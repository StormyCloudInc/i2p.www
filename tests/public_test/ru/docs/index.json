[{"categories":null,"content":"Обзор Стандартные адреса Base 32 (\u0026ldquo;b32\u0026rdquo;) содержат хэш назначения. Это не будет работать для зашифрованных LS2 (обновлённый формат LeaseSet) (proposal 123).\nМы не можем использовать традиционный адрес base 32 для зашифрованного LS2 (предложение 123), поскольку он содержит только хэш назначения. Он не предоставляет неослепленный открытый ключ. Клиентам необходимо знать открытый ключ назначения, тип подписи, тип ослепленной подписи, а также, при необходимости, секрет или закрытый ключ, чтобы получить и расшифровать leaseset. Следовательно, одного адреса base 32 недостаточно. Клиенту нужен либо полное назначение (которое содержит открытый ключ), либо сам открытый ключ. Если у клиента есть полное назначение в адресной книге, и адресная книга поддерживает обратный поиск по хэшу, то открытый ключ может быть получен.\nВ этом формате в base32-адрес вместо хэша помещается открытый ключ. Этот формат также должен содержать тип подписи открытого ключа и тип подписи схемы ослепления.\nВ этом документе определяется формат b32 для этих адресов. Хотя в ходе обсуждений мы называли этот новый формат «адресом b33», фактический новый формат сохраняет обычный суффикс «.b32.i2p».\nСтатус реализации Предложение 123 (Новые записи netDB) было полностью реализовано в версии 0.9.43 (октябрь 2019 года). Набор функций зашифрованного LS2 (второе поколение leaseSet) оставался стабильным вплоть до версии 2.10.0 (сентябрь 2025 года), без изменений, нарушающих совместимость, в формате адресации или криптографических спецификациях.\nКлючевые этапы реализации: - 0.9.38: поддержка Floodfill для стандартного LS2 с офлайн-ключами - 0.9.39: тип подписи RedDSA 11 и базовое шифрование/дешифрование - 0.9.40: полная поддержка адресации B32 (Proposal 149) - 0.9.41: поклиентская аутентификация на основе X25519 - 0.9.42: все возможности ослепления задействованы - 0.9.43: объявлено о завершении реализации (октябрь 2019)\nПроектирование Новый формат содержит неослеплённый открытый ключ, неослеплённый тип подписи и ослеплённый тип подписи. При необходимости указывает требования к секретному и/или закрытому ключу для приватных ссылок. Использует существующий суффикс \u0026ldquo;.b32.i2p\u0026rdquo;, но с большей длиной. Включает контрольную сумму для обнаружения ошибок. Адреса для зашифрованных leasesets распознаются по 56 или более закодированным символам (35 или более декодированных байтов) по сравнению с 52 символами (32 байта) у традиционных адресов Base32. Спецификация Создание и кодирование Сформируйте имя хоста вида {56+ chars}.b32.i2p (35+ символов в двоичном виде) следующим образом:\nflag (1 byte) bit 0: 0 for one-byte sigtypes, 1 for two-byte sigtypes bit 1: 0 for no secret, 1 if secret is required bit 2: 0 for no per-client auth, 1 if client private key is required bits 7-3: Unused, set to 0 public key sigtype (1 or 2 bytes as indicated in flags) If 1 byte, the upper byte is assumed zero blinded key sigtype (1 or 2 bytes as indicated in flags) If 1 byte, the upper byte is assumed zero public key Number of bytes as implied by sigtype Постобработка и контрольная сумма:\nConstruct the binary data as above. Treat checksum as little-endian. Calculate checksum = CRC-32(data[3:end]) data[0] ^= (byte) checksum data[1] ^= (byte) (checksum \u0026gt;\u0026gt; 8) data[2] ^= (byte) (checksum \u0026gt;\u0026gt; 16) hostname = Base32.encode(data) || \u0026#34;.b32.i2p\u0026#34; Любые неиспользованные биты в конце b32 (адрес в кодировке base32) должны быть равны 0. Для стандартного 56-символьного (35-байтного) адреса неиспользованных битов нет.\nДекодирование и проверка strip the \u0026#34;.b32.i2p\u0026#34; from the hostname data = Base32.decode(hostname) Calculate checksum = CRC-32(data[3:end]) Treat checksum as little-endian. flags = data[0] ^ (byte) checksum if 1 byte sigtypes: pubkey sigtype = data[1] ^ (byte) (checksum \u0026gt;\u0026gt; 8) blinded sigtype = data[2] ^ (byte) (checksum \u0026gt;\u0026gt; 16) else (2 byte sigtypes): pubkey sigtype = data[1] ^ ((byte) (checksum \u0026gt;\u0026gt; 8)) || data[2] ^ ((byte) (checksum \u0026gt;\u0026gt; 16)) blinded sigtype = data[3] || data[4] parse the remainder based on the flags to get the public key Длина в битах секретных и закрытых ключей Биты «секрета» и «закрытого ключа» используются для указания клиентам, прокси или другому клиентскому коду, что для расшифрования leaseset (набор lease-записей) потребуется секрет и/или закрытый ключ. Отдельные реализации могут предложить пользователю ввести необходимые данные или отклонить попытки подключения, если требуемые данные отсутствуют.\nЭти биты служат лишь индикаторами. Секретный или закрытый ключ ни при каких обстоятельствах не должен включаться в сам B32-адрес, так как это поставило бы под угрозу безопасность.\nДетали криптографии Схема ослепления В схеме ослепления используется RedDSA (схема цифровой подписи), основанная на Ed25519 и дизайне ZCash, формируя подписи Red25519 на кривой Ed25519 с использованием SHA-512. Такой подход гарантирует, что ослеплённые открытые ключи остаются в подгруппе простого порядка, избегая проблем безопасности, присущих некоторым альтернативным конструкциям.\nОслеплённые ключи подвергаются ежедневной ротации на основе даты UTC по следующей формуле:\nblinded_key = BLIND(unblinded_key, date, optional_secret) Место хранения в DHT (распределённой хеш-таблице) вычисляется следующим образом:\nSHA256(type_byte || blinded_public_key) Шифрование Зашифрованный leaseSet использует потоковый шифр ChaCha20 для шифрования, выбранный за высокую производительность на устройствах без аппаратного ускорения AES. В спецификации применяется HKDF для деривации ключей и X25519 — для операций Диффи‑Хеллмана.\nЗашифрованные leaseSet имеют трёхслойную структуру: - Внешний слой: незашифрованные метаданные - Средний слой: аутентификация клиента (методы DH (Диффи — Хеллман) или PSK (предварительно разделённый ключ)) - Внутренний слой: собственно данные LS2 с информацией о lease\nМетоды аутентификации Аутентификация для отдельных клиентов поддерживает два метода:\nАутентификация DH: Использует согласование ключей X25519. Каждый авторизованный клиент предоставляет серверу свой открытый ключ, а сервер шифрует средний слой, используя общий секрет, полученный из ECDH.\nАутентификация PSK: Использует предварительно распределённые ключи непосредственно для шифрования.\nВ B32 address (адресе в формате Base32) второй флаговый бит указывает, требуется ли аутентификация для каждого клиента.\nКэширование Хотя это выходит за рамки данной спецификации, routers и клиенты должны запоминать и кэшировать (рекомендуется постоянное хранение) соответствие между открытым ключом и назначением, и наоборот.\nСлужба именования blockfile (служба именования на основе блочного файла), стандартная система адресных книг I2P с версии 0.9.8, поддерживает несколько адресных книг со специальной таблицей обратного поиска, обеспечивающей быстрый поиск по хэшу. Эта функциональность критически важна для разрешения зашифрованных leaseSet, когда изначально известен только хэш.\nТипы подписей Начиная с I2P версии 2.10.0, определены типы подписи с 0 по 11. Однобайтовое кодирование остаётся стандартным; двухбайтовое кодирование доступно, но на практике не используется.\nЧасто используемые типы: - Тип 0 (DSA_SHA1): Устарел для router, поддерживается для назначений - Тип 7 (EdDSA_SHA512_Ed25519): Текущий стандарт для идентификаторов router и назначений - Тип 11 (RedDSA_SHA512_Ed25519): Исключительно для зашифрованных LS2 leasesets с поддержкой blinding (ослепления)\nВажное примечание: Только Ed25519 (тип 7) и Red25519 (тип 11) поддерживают ослепление, необходимое для зашифрованных leaseSet. Другие типы подписей не могут использоваться с этой функцией.\nТипы 9-10 (алгоритмы ГОСТ) остаются зарезервированными, но не реализованными. Типы 4-6 и 8 помечены как \u0026ldquo;только офлайн\u0026rdquo; для ключей подписи, используемых офлайн.\nПримечания Совместимость версий Данная спецификация актуальна для I2P версии 0.9.47 (август 2020 года) по версию 2.10.0 (сентябрь 2025 года) включительно. За этот период не произошло изменений, нарушающих совместимость, в формате адресации B32 (адреса в base32), структуре зашифрованного LS2 (LeaseSet версии 2) или криптографических реализациях. Все адреса, созданные в версии 0.9.47, остаются полностью совместимыми с текущими версиями.\nСсылки CRC-32 - CRC-32 (Википедия) - RFC 3309: контрольная сумма протокола управления передачей потоков (Stream Control Transmission Protocol, SCTP) Спецификации I2P - Спецификация зашифрованного LeaseSet - Предложение 123: Новые записи netDB - Предложение 149: B32 для зашифрованного LS2 (LeaseSet 2 — формат LeaseSet версии 2) - Спецификация общих структур - Именование и адресная книга Сравнение Tor - ветка обсуждения Tor (контекст проектирования) Дополнительные ресурсы - Проект I2P - Форум I2P - Документация по Java API ","description":"Формат адреса Base 32 для зашифрованных LS2 (второй версии) leaseSets","id":"cac162c86c1b599cb6bab03e6270c404","section":"docs","title":"B32 для зашифрованных LeaseSets (наборы входящих туннелей назначения)","url":"/ru/docs/specs/b32-for-encrypted-leasesets/"},{"categories":null,"content":"Обзор BitTorrent поверх I2P обеспечивает анонимный обмен файлами через зашифрованные туннели с использованием потокового уровня I2P. Все узлы идентифицируются криптографическими I2P-адресами назначения вместо IP-адресов. Система поддерживает HTTP и UDP трекеры, гибридные магнитные ссылки и гибридное постквантовое шифрование.\n1. Стек протоколов Layer Function Example Application BitTorrent i2psnark, BiglyBT Transport Streaming / SAM v3 I2CP, NTCP2 Network Garlic routing I2NP Все соединения проходят через зашифрованный транспортный уровень I2P (NTCP2 или SSU2). Даже UDP-пакеты трекера инкапсулируются внутри потоковой передачи I2P. 2. Трекеры HTTP-трекеры Стандартные .i2p трекеры отвечают на HTTP GET запросы, такие как:\nhttp://tracker2.postman.i2p/announce?info_hash=\u0026lt;20-byte\u0026gt;\u0026amp;peer_id=\u0026lt;20-byte\u0026gt;\u0026amp;port=6881\u0026amp;uploaded=0\u0026amp;downloaded=0\u0026amp;left=1234\u0026amp;compact=1 Ответы bencoded и используют хеши I2P destination для пиров.\nUDP-трекеры UDP-трекеры были стандартизированы в 2025 году (Предложение 160).\nОсновные UDP-трекеры - udp://tracker2.postman.i2p/announce - udp://opentracker.simp.i2p/a - http://opentracker.skank.i2p/a - http://opentracker.dg2.i2p/a \u0026mdash;\n3. Magnet-ссылки magnet:?xt=urn:btih:\u0026lt;infohash\u0026gt;\u0026amp;dn=\u0026lt;name\u0026gt;\u0026amp;tr=http://tracker2.postman.i2p/announce\u0026amp;tr=udp://denpa.i2p/announce\u0026amp;xs=i2p:\u0026lt;destination.b32.i2p\u0026gt; Parameter Meaning xs=i2p:\u0026lt;dest\u0026gt; Explicit I2P destination tr= Tracker URLs (HTTP or UDP) dn= Display name Magnet-ссылки поддерживают гибридные swarm'ы (рои) через I2P и clearnet при соответствующей настройке. 4. Реализации DHT Implementation Type Status Java I2P Experimental overlay Stable i2pd UDP-based internal overlay Active BiglyBT SAM v3.3-based Fully supported --- 5. Реализации клиентов I2PSnark Входит в состав всех router\u0026rsquo;ов Поддержка только HTTP-трекеров Встроенный трекер по адресу http://127.0.0.1:7658/ Нет поддержки UDP-трекеров BiglyBT Полнофункциональный с плагином I2P Поддерживает HTTP + UDP трекеры Поддержка гибридных торрентов Использует интерфейс SAM v3.3 Tixati / XD Легковесные клиенты Туннелирование на основе SAM Экспериментальное гибридное шифрование ML-KEM 6. Конфигурация I2PSnark i2psnark.dir=/home/user/torrents i2psnark.autostart=true i2psnark.maxUpBW=128 i2psnark.maxDownBW=256 i2psnark.enableDHT=false BiglyBT SAMHost=127.0.0.1 SAMPort=7656 SAMNickname=BiglyBT-I2P SAMAutoStart=true DHTEnabled=true 7. Модель безопасности Component Description Encryption NTCP2 / SSU2 with X25519+ML-KEM hybrid Identity I2P destinations replace IP addresses Anonymity Peer info hidden; traffic multiplexed Leak Prevention Remove headers (X-Forwarded-For, Client-IP, Via) Гибридные (clearnet + I2P) торренты следует использовать только в том случае, если анонимность не критична. 8. Производительность Factor Impact Recommendation Tunnel length Adds latency 1-hop client, 2-hop server Peers Boosts speed 20+ active peers Compression Minimal gain Usually off Bandwidth Router-limited Default settings optimal Типичные скорости составляют **30–80 КБ/с**, в зависимости от пиров и состояния сети. 9. Известные проблемы Частичная совместимость DHT между Java I2P и i2pd Задержка получения метаданных magnet при высокой нагрузке NTCP1 устарел, но все еще используется старыми узлами UDP, эмулируемый через streaming, увеличивает задержку 10. Дорожная карта развития QUIC-подобное мультиплексирование Полная интеграция ML-KEM Унифицированная логика гибридного роя Улучшенные зеркала reseed Адаптивные повторные попытки DHT Ссылки BEP 15 – UDP Tracker Protocol Предложение 160 – UDP Tracker через I2P Документация I2PSnark Спецификация библиотеки Streaming ","description":"Детальная спецификация и обзор экосистемы BitTorrent в сети I2P","id":"5d0ca50c8763996448d3099a14dc36b0","section":"docs","title":"BitTorrent через I2P","url":"/ru/docs/applications/bittorrent/"},{"categories":null,"content":" Предупреждение: BOB поддерживает только устаревший тип подписи DSA-SHA1. Java I2P перестал включать BOB в состав дистрибутива в 1.7.0 (2022-02); он остался только на установках, впервые развернутых в версии 1.6.1 или более ранней, а также в некоторых сборках i2pd. Новые приложения должны использовать SAM v3 .\nПривязки для языков программирования Go – ccondom Python – i2py-bob Twisted – txi2p C++ – bobcpp Примечания к протоколу KEYS обозначает destination (адрес назначения) в base64 (открытый и закрытый ключи). KEY — это открытый ключ в base64. Ответы ERROR имеют вид ERROR \u0026lt;description\u0026gt;\\n. OK обозначает завершение команды; необязательные данные следуют в той же строке. Строки DATA выводят дополнительные данные до финального OK. Команда help — единственное исключение: она может ничего не возвращать, чтобы обозначить «нет такой команды».\nБаннер подключения BOB использует строки ASCII, завершаемые символом новой строки (LF или CRLF). При подключении он отправляет:\nBOB \u0026lt;version\u0026gt; OK Текущая версия: 00.00.10. Ранние сборки использовали шестнадцатеричные цифры в верхнем регистре и нестандартную нумерацию.\nBOB Version Router Version Notes 00.00.100.9.8Latest defined version 00.00.00 – 00.00.0F—Development builds ## Основные команды Для получения полного описания команд подключитесь с помощью telnet localhost 2827 и выполните help.\nCOMMAND OPERAND RETURNS help [command] NOTHING | OK \u0026lt;info\u0026gt; clear ERROR | OK getdest ERROR | OK \u0026lt;KEY\u0026gt; getkeys ERROR | OK \u0026lt;KEYS\u0026gt; getnick \u0026lt;tunnelname\u0026gt; ERROR | OK inhost \u0026lt;hostname | IP\u0026gt; ERROR | OK inport \u0026lt;port\u0026gt; ERROR | OK list ERROR | DATA... + OK lookup \u0026lt;hostname\u0026gt; ERROR | OK \u0026lt;KEY\u0026gt; nick \u0026lt;friendlyname\u0026gt; ERROR | OK outhost \u0026lt;hostname | IP\u0026gt; ERROR | OK outport \u0026lt;port\u0026gt; ERROR | OK quit ERROR | OK setkey \u0026lt;base64 destination\u0026gt; ERROR | OK start ERROR | OK status ERROR | DATA... + OK stop ERROR | OK Сводка устареваний BOB (устаревший интерфейс приложений I2P) не поддерживает современные типы подписей, зашифрованные LeaseSets или возможности транспортного уровня. API заморожен; новые команды добавляться не будут. Приложения, которые всё ещё полагаются на BOB, должны перейти на SAM v3 как можно скорее. ","description":"Устаревший API для управления назначениями (устарело)","id":"97b881216518f8e2516b859bbca19c0b","section":"docs","title":"BOB – Basic Open Bridge (базовый открытый мост)","url":"/ru/docs/legacy/bob/"},{"categories":null,"content":" 1. Обзор Garlic routing (маршрутизация «чеснок») остается одним из ключевых нововведений I2P, объединяя многоуровневое шифрование, группировку сообщений и однонаправленные туннели. Хотя концептуально схож с onion routing (луковичной маршрутизацией), он расширяет модель, объединяя несколько зашифрованных сообщений («зубчики») в один конверт («головку чеснока»), что повышает эффективность и анонимность.\nТермин garlic routing был введён Майклом Дж. Фридманом в магистерской диссертации Роджера Динглдайна о Free Haven (июнь 2000, §8.1.1). Разработчики I2P приняли этот термин в начале 2000-х годов, чтобы отразить улучшения в группировке сообщений и однонаправленную модель передачи данных, отличающую его от дизайна Tor с коммутацией каналов.\nРезюме: Garlic routing = многослойное шифрование + объединение сообщений + анонимная доставка через однонаправленные туннели.\n2. Терминология \u0026ldquo;Garlic\u0026rdquo; Исторически термин garlic использовался в трёх различных контекстах в рамках I2P:\nМногослойное шифрование – защита на уровне туннелей в стиле луковичной маршрутизации Объединение нескольких сообщений – несколько \u0026ldquo;cloves\u0026rdquo; внутри \u0026ldquo;garlic message\u0026rdquo; Сквозное шифрование – ранее ElGamal/AES+SessionTags, теперь ECIES‑X25519‑AEAD‑Ratchet Хотя архитектура остается неизменной, схема шифрования была полностью модернизирована.\n3. Многослойное шифрование Garlic routing разделяет свой основополагающий принцип с onion routing: каждый router расшифровывает только один слой шифрования, узнавая только следующий переход, но не весь путь целиком.\nОднако I2P реализует однонаправленные туннели, а не двунаправленные цепи:\nOutbound tunnel: отправляет сообщения от создателя Inbound tunnel: доставляет сообщения обратно к создателю Полный цикл обмена данными (Алиса ↔ Боб) использует четыре tunnel: исходящий tunnel Алисы → входящий tunnel Боба, затем исходящий tunnel Боба → входящий tunnel Алисы. Такая архитектура вдвое снижает возможность корреляции данных по сравнению с двунаправленными каналами.\nДля получения информации о деталях реализации туннелей см. Спецификацию туннелей и спецификацию Создание туннелей (ECIES) .\n4. Объединение нескольких сообщений («дольки») Оригинальная концепция garlic routing Фридмана предполагала объединение нескольких зашифрованных «луковиц» внутри одного сообщения. I2P реализует это как cloves (зубчики) внутри garlic message (чесночного сообщения) — каждый clove имеет свои собственные зашифрованные инструкции доставки и цель (router, destination или tunnel).\nGarlic bundling позволяет I2P:\nОбъединять подтверждения и метаданные с сообщениями данных Снижать наблюдаемые шаблоны трафика Поддерживать сложные структуры сообщений без дополнительных соединений Рисунок 1: Garlic Message, содержащее несколько cloves, каждый со своими инструкциями доставки.\nТипичные зубчики включают:\nDelivery Status Message — подтверждения успешной или неуспешной доставки.\nОни заворачиваются в отдельный слой garlic для сохранения конфиденциальности. Database Store Message — автоматически включаемые LeaseSet\u0026rsquo;ы, чтобы узлы могли ответить без повторного запроса к netDb. Гвоздики объединяются в пучки, когда:\nНеобходимо опубликовать новый LeaseSet Доставлены новые теги сессии В последнее время не происходило объединение (~1 минута по умолчанию) Garlic-сообщения обеспечивают эффективную сквозную доставку нескольких зашифрованных компонентов в одном пакете.\n5. Эволюция шифрования 5.1 Historical Context Ранняя документация (≤ v0.9.12) описывала шифрование ElGamal/AES+SessionTags: - ElGamal 2048‑бит для упаковки AES ключей сеанса - AES‑256/CBC для шифрования полезной нагрузки - 32‑байтовые теги сеанса, используемые один раз на сообщение\nЭта криптосистема устарела.\n5.2 ECIES‑X25519‑AEAD‑Ratchet (Current Standard) В период с 2019 по 2023 год I2P полностью перешёл на ECIES‑X25519‑AEAD‑Ratchet. Современный стек стандартизирует следующие компоненты:\nLayer ECIES Primitive or Concept Transport Layer (NTCP2, SSU2) Noise_NX → X25519, ChaCha20/Poly1305, BLAKE2s I2NP Delivery ECIES‑X25519‑AEAD (ChaCha20/Poly1305) Session Management Ratchet with rekey records, per-clove key material Offline Authentication EdDSA (Ed25519) with LeaseSet2/MetaLeaseSet chains Преимущества перехода на ECIES: Прямая секретность за счёт ключей с посменной ротацией для каждого сообщения Уменьшенный размер полезной нагрузки по сравнению с ElGamal Устойчивость к достижениям криптоанализа Совместимость с будущими постквантовыми гибридами (см. Proposal 169) Дополнительные подробности: см. спецификацию ECIES и спецификацию EncryptedLeaseSet .\n6. LeaseSets and Garlic Bundling Garlic-конверты часто включают LeaseSets для публикации или обновления доступности назначения.\nVersion Type Key Capabilities Distribution Notes 1 LeaseSet (legacy) Single encryption/signature pair Accepted for backward compatibility 3 LeaseSet2 Multiple crypto suites, offline signing keys Default for modern routers 5 EncryptedLeaseSet Access-controlled, destination hidden from floodfill Requires shared decryption key 7 MetaLeaseSet Aggregates multiple destinations or multi-homed services Extends LeaseSet2 fields recursively Все LeaseSets распространяются через *floodfill DHT* (распределённую хеш-таблицу), поддерживаемую специализированными роутерами. Публикации проверяются, снабжаются временными метками и ограничиваются по частоте для снижения корреляции метаданных. См. документацию Network Database для подробностей.\n7. Modern “Garlic” Applications within I2P Garlic encryption и объединение сообщений используются во всём стеке протоколов I2P:\nСоздание и использование туннелей — послойное шифрование на каждом hop Сквозная доставка сообщений — связанные garlic-сообщения с клонированным подтверждением и LeaseSet cloves Публикация в Network Database — LeaseSets, упакованные в garlic-конверты для обеспечения приватности Транспорты SSU2 и NTCP2 — нижележащее шифрование с использованием фреймворка Noise и примитивов X25519/ChaCha20 Garlic routing — это одновременно и метод многослойного шифрования, и модель сетевого обмена сообщениями.\n6. LeaseSets и Garlic Bundling Центр документации I2P доступен здесь и постоянно обновляется. Актуальные спецификации включают:\nСпецификация ECIES — ECIES‑X25519‑AEAD‑Ratchet Создание туннелей (ECIES) — современный протокол построения туннелей Спецификация I2NP — форматы сообщений I2NP Спецификация SSU2 — транспорт SSU2 UDP Общие структуры — поведение netDb и floodfill Академическая валидация: Hoang et al. (IMC 2018, USENIX FOCI 2019) и Muntaka et al. (2025) подтверждают архитектурную стабильность и операционную устойчивость дизайна I2P.\n7. Современные \u0026ldquo;Garlic\u0026rdquo; приложения в I2P Текущие предложения:\nПредложение 169: Гибридная постквантовая криптография (ML-KEM 512/768/1024 + X25519) Предложение 168: Оптимизация пропускной способности транспорта Обновления датаграмм и потоковой передачи: Улучшенное управление перегрузкой Будущие адаптации могут включать дополнительные стратегии задержки сообщений или избыточность нескольких туннелей на уровне garlic-сообщений, основываясь на неиспользуемых опциях доставки, изначально описанных Фридманом.\n8. Текущая документация и справочные материалы Freedman, M. J. \u0026amp; Dingledine, R. (2000). Free Haven Master\u0026rsquo;s Thesis, § 8.1.1. Free Haven Papers Onion Router Publications Garlic Routing (Wikipedia) Tor Project Free Haven Anonbib Goldschlag, D. M., Reed, M. G., Syverson, P. F. (1996). Hiding Routing Information. NRL Publication. ","description":"Понимание терминологии garlic routing, архитектуры и современной реализации в I2P","id":"ba07d93d883918641f4a69832e497bb8","section":"docs","title":"Garlic Routing","url":"/ru/docs/overview/garlic-routing/"},{"categories":null,"content":"Когда сетевые условия делают git clone ненадёжным, вы можете распространять репозитории в виде git bundles через BitTorrent или любой другой способ передачи файлов. Bundle — это единый файл, содержащий всю историю репозитория. После загрузки вы получаете данные из него локально, а затем переключаетесь обратно на upstream remote.\n1. Перед началом работы Для создания bundle требуется полный клон Git. Поверхностные клоны, созданные с --depth 1, молча создадут испорченные bundle, которые выглядят работающими, но не работают, когда другие пытаются их использовать. Всегда загружайте из проверенного источника (GitHub на github.com/i2p/i2p.i2p , инстанс Gitea I2P на i2pgit.org или git.idk.i2p через I2P) и выполните git fetch --unshallow при необходимости, чтобы преобразовать любой поверхностный клон в полный клон перед созданием bundle.\nЕсли вы только используете существующий bundle, просто скачайте его. Никакой специальной подготовки не требуется.\n2. Загрузка пакета Obtaining the Bundle File Загрузите файл bundle через BitTorrent, используя I2PSnark (встроенный torrent-клиент в I2P) или другие совместимые с I2P клиенты, такие как BiglyBT с плагином I2P.\nВажно: I2PSnark работает только с торрентами, специально созданными для сети I2P. Стандартные клирнет-торренты несовместимы, поскольку I2P использует Destinations (адреса размером 387+ байт) вместо IP-адресов и портов.\nРасположение файла bundle зависит от типа установки I2P:\nПользовательские/ручные установки (установленные с помощью Java-инсталлятора): ~/.i2p/i2psnark/ Системные/демон установки (установленные через apt-get или менеджер пакетов): /var/lib/i2p/i2p-config/i2psnark/ Пользователи BiglyBT найдут загруженные файлы в настроенной директории загрузок.\nCloning from the Bundle Стандартный метод (работает в большинстве случаев):\ngit clone ~/.i2p/i2psnark/i2p.i2p.bundle Если вы столкнулись с ошибками fatal: multiple updates for ref (известная проблема в Git 2.21.0 и более поздних версиях, когда глобальная конфигурация Git содержит конфликтующие refspec для fetch), используйте ручной способ инициализации:\nmkdir i2p.i2p \u0026amp;\u0026amp; cd i2p.i2p git init git fetch ~/.i2p/i2psnark/i2p.i2p.bundle Alternatively, you can use the --update-head-ok flag:\nAlternatively, вы можете использовать флаг --update-head-ok:\ngit fetch --update-head-ok ~/.i2p/i2psnark/i2p.i2p.bundle \u0026#39;*:*\u0026#39; Получение файла Bundle После клонирования из бандла перенаправьте свой клон на активный удалённый репозиторий, чтобы будущие fetch выполнялись через I2P или clearnet:\ngit remote set-url origin git@127.0.0.1:I2P_Developers/i2p.i2p Или для доступа к clearnet:\ngit remote set-url origin https://github.com/i2p/i2p.i2p Для SSH доступа через I2P вам необходимо настроить клиентский SSH туннель в консоли вашего I2P роутера (обычно порт 7670), указывающий на g6u4vqiuy6bdc3dbu6a7gmi3ip45sqwgtbgrr6uupqaaqfyztrka.b32.i2p. Если используется нестандартный порт:\nGIT_SSH_COMMAND=\u0026#34;ssh -p 7670\u0026#34; git clone git@127.0.0.1:I2P_Developers/i2p.i2p 3. Creating a Bundle Клонирование из Bundle Убедитесь, что ваш репозиторий полностью обновлен с помощью полного клона (не поверхностного):\ngit fetch --all Если у вас поверхностный клон (shallow clone), сначала преобразуйте его:\ngit fetch --unshallow Переход на Live Remote Использование цели сборки Ant (рекомендуется для дерева исходного кода I2P):\nant git-bundle Это создаёт как i2p.i2p.bundle (файл bundle), так и i2p.i2p.bundle.torrent (метаданные BitTorrent).\nИспользование git bundle напрямую:\ngit bundle create i2p.i2p.bundle --all Для более избирательных бандлов:\ngit bundle create i2p.i2p.bundle --branches --tags Verifying Your Bundle Всегда проверяйте бандл перед распространением:\ngit bundle verify i2p.i2p.bundle Это подтверждает, что bundle валиден и показывает любые необходимые коммиты-предварительные условия.\nПредварительные требования Скопируйте бандл и его торрент-метаданные в каталог I2PSnark:\nДля пользовательских установок:\ncp i2p.i2p.bundle* ~/.i2p/i2psnark/ Для системных установок:\ncp i2p.i2p.bundle* /var/lib/i2p/i2p-config/i2psnark/ I2PSnark автоматически обнаруживает и загружает .torrent файлы в течение нескольких секунд. Откройте веб-интерфейс по адресу http://127.0.0.1:7657/i2psnark , чтобы начать раздачу.\n4. Creating Incremental Bundles Для периодических обновлений создавайте инкрементные бандлы, содержащие только новые коммиты с момента последнего бандла:\ngit tag lastBundleTag git bundle create update.bundle lastBundleTag..master Пользователи могут загрузить инкрементальный бандл, если у них уже есть базовый репозиторий:\ngit fetch /path/to/update.bundle Всегда проверяйте, что инкрементные бандлы содержат ожидаемые предварительные коммиты:\ngit bundle verify update.bundle 5. Updating After the Initial Clone После того как у вас будет работающий репозиторий из пакета, работайте с ним как с любым другим клоном Git:\ngit remote add upstream git@127.0.0.1:I2P_Developers/i2p.i2p git fetch upstream git merge upstream/master Или для более простых рабочих процессов:\ngit fetch origin git pull origin master 3. Создание пакета Устойчивое распространение: Большие репозитории можно распространять через BitTorrent, который автоматически обрабатывает повторные попытки, проверку фрагментов и возобновление передачи. Peer-to-peer начальная загрузка: Новые участники могут выполнить начальное клонирование от ближайших узлов в сети I2P, а затем получать инкрементные изменения напрямую с Git-хостов. Снижение нагрузки на сервер: Зеркала могут публиковать периодические бандлы для снятия нагрузки с активных Git-хостов, что особенно полезно для больших репозиториев или медленных сетевых условий. Офлайн-транспорт: Бандлы работают с любым файловым транспортом (USB-накопители, прямые передачи, sneakernet), а не только с BitTorrent. Бандлы не заменяют живые удалённые репозитории. Они просто обеспечивают более надёжный метод начальной загрузки для первоначального клонирования или крупных обновлений.\n7. Troubleshooting Генерация Bundle Проблема: Создание бандла завершается успешно, но другие не могут клонировать из бандла.\nПричина: Ваш исходный клон является поверхностным (создан с параметром --depth).\nРешение: Преобразуйте в полный клон перед созданием bundles:\ngit fetch --unshallow Проверка вашего пакета Проблема: fatal: multiple updates for ref при клонировании из bundle.\nПричина: Git 2.21.0+ конфликтует с глобальными refspec для fetch в ~/.gitconfig.\nРешения: 1. Используйте ручную инициализацию: mkdir repo \u0026amp;\u0026amp; cd repo \u0026amp;\u0026amp; git init \u0026amp;\u0026amp; git fetch /path/to/bundle 2. Используйте флаг --update-head-ok: git fetch --update-head-ok /path/to/bundle '*:*' 3. Удалите конфликтующую конфигурацию: git config --global --unset remote.origin.fetch\nРаспространение через I2PSnark Проблема: git bundle verify сообщает об отсутствующих требованиях.\nПричина: Инкрементальный бандл или неполное клонирование исходного кода.\nРешение: Либо получите необходимые коммиты, либо сначала используйте базовый bundle, затем примените инкрементные обновления.\n","description":"Получение и распространение больших репозиториев с помощью git bundle и BitTorrent","id":"555586cb7b43c73ad912bbb01f20326b","section":"docs","title":"Git Bundle для I2P","url":"/ru/docs/applications/git-bundle/"},{"categories":null,"content":"Клонирование и отправка репозиториев внутри I2P использует те же команды Git, которые вы уже знаете — ваш клиент просто подключается через I2P tunnel вместо TCP/IP. Это руководство описывает настройку учетной записи, конфигурирование tunnel и работу с медленными соединениями.\nБыстрый старт: Доступ только для чтения работает через HTTP-прокси: http_proxy=http://127.0.0.1:4444 git clone http://example.i2p/project.git. Следуйте инструкциям ниже для SSH доступа с правами чтения и записи.\n1. Создайте аккаунт Выберите I2P Git-сервис и зарегистрируйтесь:\nВнутри I2P: http://git.idk.i2p Зеркало в открытой сети: https://i2pgit.org Регистрация может требовать ручного одобрения; проверьте главную страницу для получения инструкций. После одобрения создайте форк или новый репозиторий, чтобы было с чем тестировать.\n2. Настройка клиента I2PTunnel (SSH) Откройте консоль роутера → I2PTunnel и добавьте новый туннель типа Client. Введите адрес назначения сервиса (Base32 или Base64). Для git.idk.i2p вы найдёте адреса как для HTTP, так и для SSH на домашней странице проекта. Выберите локальный порт (например, localhost:7442). Включите автозапуск, если планируете часто использовать этот туннель. Интерфейс подтвердит создание нового туннеля и отобразит его статус. Когда он будет запущен, SSH-клиенты смогут подключаться к 127.0.0.1 на выбранном порту.\n3. Клонирование через SSH Используйте порт туннеля с GIT_SSH_COMMAND или в секции конфигурации SSH:\nGIT_SSH_COMMAND=\u0026#34;ssh -p 7442\u0026#34; \\ git clone git@127.0.0.1:your-project/example.git Если первая попытка не удалась (туннели могут работать медленно), попробуйте поверхностное клонирование:\nGIT_SSH_COMMAND=\u0026#34;ssh -p 7442\u0026#34; \\ git clone --depth 1 git@127.0.0.1:your-project/example.git cd example git fetch --unshallow Настройте Git для получения всех веток:\ngit config remote.origin.fetch \u0026#34;+refs/heads/*:refs/remotes/origin/*\u0026#34; git fetch origin Советы по производительности Добавьте один или два резервных tunnel в редакторе tunnel для повышения устойчивости. Для тестирования или репозиториев с низким риском вы можете уменьшить длину tunnel до 1 hop, но учитывайте компромисс с анонимностью. Сохраните GIT_SSH_COMMAND в вашем окружении или добавьте запись в ~/.ssh/config: Host git.i2p HostName 127.0.0.1 Port 7442 User git Затем клонируйте с помощью git clone git@git.i2p:namespace/project.git.\n4. Рекомендации по рабочему процессу Используйте рабочий процесс с форками и ветками, распространённый на GitLab/GitHub:\nУстановите upstream remote: git remote add upstream git@git.i2p:I2P_Developers/i2p.i2p Поддерживайте ваш master в синхронизации: git pull upstream master Создавайте feature-ветки для изменений: git checkout -b feature/new-thing Отправляйте ветки в ваш форк: git push origin feature/new-thing Отправьте merge request, затем синхронизируйте master вашего форка с upstream методом fast-forward. 5. Напоминания о конфиденциальности Git сохраняет временные метки коммитов в вашем локальном часовом поясе. Чтобы принудительно использовать временные метки UTC: git config --global alias.utccommit \u0026#39;!git commit --date=\u0026#34;$(date --utc +%Y-%m-%dT%H:%M:%S%z)\u0026#34;\u0026#39; Используйте git utccommit вместо git commit, когда важна конфиденциальность.\nИзбегайте встраивания clearnet URL-адресов или IP-адресов в сообщения коммитов или метаданные репозитория, если анонимность важна. 6. Устранение неполадок Symptom Fix connection closed during clone Retry with --depth 1, add backup tunnels, or increase tunnel quantities. ssh: connect to host 127.0.0.1 port …: Connection refused Ensure the I2PTunnel client is running and SAM is enabled. Slow performance Lower tunnel length, increase bandwidth limits, or schedule large fetches during off-peak hours. Для продвинутых сценариев (зеркалирование внешних репозиториев, распространение bundle-файлов) см. дополнительные руководства: [Работа с Git bundle](/docs/applications/git-bundle/) и [Хостинг GitLab через I2P](/docs/guides/gitlab/). ","description":"Подключение Git-клиентов к сервисам, размещенным в I2P, таким как i2pgit.org","id":"17704a86e8676ba273355af4fa703c15","section":"docs","title":"Git через I2P","url":"/ru/docs/applications/git/"},{"categories":null,"content":"Введение I2P предоставляет приватный обмен сообщениями в стиле электронной почты через сервис Postman\u0026rsquo;s Mail.i2p в сочетании с SusiMail — встроенным веб-клиентом электронной почты. Эта система позволяет пользователям отправлять и получать электронные письма как внутри сети I2P, так и в/из обычного интернета (clearnet) через мост-шлюз.\nЯ готов предоставить перевод с английского на русский. Однако я вижу, что текст для перевода не был включен в ваше сообщение после строки \u0026ldquo;\u0026mdash;\u0026rdquo;.\nПожалуйста, предоставьте текст, который нужно перевести, и я выполню перевод согласно всем указанным правилам.\nPostman / Mail.i2p + SusiMail What it is Mail.i2p — это провайдер электронной почты внутри I2P, управляемый пользователем \u0026ldquo;Postman\u0026rdquo; SusiMail — это веб-клиент электронной почты, интегрированный в консоль I2P router. Он разработан для предотвращения утечки метаданных (например, имени хоста) на внешние SMTP-серверы. Благодаря этой настройке пользователи I2P могут отправлять и получать сообщения как внутри I2P, так и в/из clearnet (например, Gmail) через мост Postman. How Addressing Works I2P email использует систему двойных адресов:\nВнутри сети I2P: username@mail.i2p (например, idk@mail.i2p) Из клирнета: username@i2pmail.org (например, idk@i2pmail.org) Шлюз i2pmail.org позволяет обычным пользователям интернета отправлять электронные письма на I2P-адреса, а пользователям I2P — отправлять письма на clearnet-адреса. Письма из интернета маршрутизируются через шлюз, прежде чем быть перенаправленными через I2P в ваш почтовый ящик SusiMail.\nКвота на отправку в клирнет: 20 писем в день при отправке на обычные интернет-адреса.\nЧто это такое Для регистрации учетной записи mail.i2p:\nУбедитесь, что ваш I2P router запущен Посетите http://hq.postman.i2p внутри I2P Следуйте процедуре регистрации Получите доступ к своей электронной почте через SusiMail в консоли router Примечание: hq.postman.i2p — это адрес в сети I2P (eepsite) и доступен только при подключении к I2P. Для получения дополнительной информации о настройке электронной почты, безопасности и использовании посетите Postman HQ.\nКак работает адресация Автоматическое удаление идентифицирующих заголовков (User-Agent:, X-Mailer:) для обеспечения приватности Очистка метаданных для предотвращения утечек на внешние SMTP-серверы Сквозное шифрование для внутренних писем I2P-to-I2P Начало работы Совместимость с \u0026ldquo;обычной\u0026rdquo; электронной почтой (SMTP/POP) через мост Postman Простой пользовательский интерфейс (веб-почта встроена в консоль роутера) Интегрирован с основным дистрибутивом I2P (SusiMail поставляется с Java I2P) Удаление заголовков для защиты конфиденциальности Функции конфиденциальности Мост к внешней электронной почте требует доверия к инфраструктуре Postman Clearnet-мост снижает приватность по сравнению с чисто внутренней коммуникацией I2P Зависит от доступности и безопасности почтового сервера Postman Руководство по запуску I2P на Raspberry Pi Это руководство поможет вам запустить I2P на Raspberry Pi.\nТребования Raspberry Pi (рекомендуется модель 3 или новее) Карта microSD (минимум 8 ГБ, рекомендуется 16 ГБ или больше) Источник питания Подключение к интернету Установка Вариант 1: Использование репозитория I2P Обновите систему: sudo apt update sudo apt upgrade Установите необходимые зависимости: sudo apt install apt-transport-https curl Добавьте репозиторий I2P: curl -o i2p-keyring.gpg https://geti2p.net/_static/i2p-debian-repo.key.gpg sudo cp i2p-keyring.gpg /usr/share/keyrings/ echo \u0026#34;deb [signed-by=/usr/share/keyrings/i2p-keyring.gpg] https://deb.i2p2.de/ $(lsb_release -sc) main\u0026#34; | sudo tee /etc/apt/sources.list.d/i2p.list Обновите список пакетов и установите I2P: sudo apt update sudo apt install i2p i2p-keyring Вариант 2: Использование I2P Easy-Install Bundle Загрузите и установите комплект Easy-Install:\nwget https://geti2p.net/en/download/easyinstall chmod +x easyinstall ./easyinstall Настройка Запуск I2P как службы Чтобы I2P запускался автоматически при загрузке:\nsudo systemctl enable i2p sudo systemctl start i2p Доступ к консоли роутера После запуска I2P откройте веб-браузер и перейдите по адресу:\nhttp://127.0.0.1:7657 Оптимизация производительности Регулировка использования памяти Для устройств с ограниченной оперативной памятью отредактируйте файл конфигурации:\nsudo nano /etc/default/i2p Измените параметры wrapper:\nwrapper.java.maxmemory=256 Настройка пропускной способности В консоли роутера:\nПерейдите в раздел Configuration (Конфигурация) Выберите Bandwidth (Пропускная способность) Установите лимиты в соответствии с вашим интернет-соединением Устранение неполадок I2P не запускается Проверьте логи:\nsudo journalctl -u i2p или:\ntail -f ~/.i2p/wrapper.log Недостаточно памяти Если возникают ошибки нехватки памяти, уменьшите выделение памяти в настройках wrapper.\nМедленная загрузка Убедитесь, что router интегрирован в сеть (может занять 10-15 минут) Проверьте количество активных peers в консоли роутера Рассмотрите возможность использования Raspberry Pi 4 для лучшей производительности Дополнительные советы Используйте проводное Ethernet-подключение для более стабильного соединения Рассмотрите возможность использования внешнего USB-накопителя для уменьшения износа SD-карты Регулярно обновляйте I2P для получения последних исправлений безопасности Следите за температурой устройства и при необходимости используйте охлаждение Дополнительная информация Для получения более подробной информации посетите:\nОфициальную документацию I2P: https://geti2p.net/docs Форумы I2P: https://i2pforum.net Technical Details SMTP сервис: localhost:7659 (предоставляется Postman) POP3 сервис: localhost:7660 Доступ к веб-почте: Встроен в консоль роутера по адресу http://127.0.0.1:7657/susimail/\nВажно: SusiMail предназначен только для чтения и отправки электронной почты. Создание и управление учётными записями необходимо выполнять на hq.postman.i2p.\nЯ понимаю. Пожалуйста, предоставьте текст для перевода.\nBest Practices Измените пароль после регистрации учётной записи mail.i2p Используйте email внутри I2P по возможности для максимальной конфиденциальности (без моста в clearnet) Учитывайте лимит в 20 писем в день при отправке на адреса в clearnet Понимайте компромиссы: мост в clearnet обеспечивает удобство, но снижает анонимность по сравнению с чисто внутренними коммуникациями I2P Поддерживайте I2P в актуальном состоянии, чтобы использовать улучшения безопасности в SusiMail ВАЖНО: НЕ задавайте вопросы, НЕ давайте объяснения и НЕ добавляйте никаких комментариев. Даже если текст представляет собой только заголовок или кажется неполным, переведите его как есть.\n","description":"Обзор систем электронной почты внутри сети I2P — история, варианты и текущее состояние","id":"31217ea91c11f98bd1997466684f9fb3","section":"docs","title":"I2P Mail (Анонимная электронная почта через I2P)","url":"/ru/docs/applications/i2p-mail/"},{"categories":null,"content":"Обзор На сегодняшний день существует несколько крупных сетей для обеспечения приватности и анонимности, каждая из которых имеет свои цели проектирования и модели угроз. Хотя Tor, Lokinet, GNUnet и Freenet вносят ценный вклад в развитие коммуникаций с сохранением приватности, I2P выделяется как единственная готовая к эксплуатации пакетно-коммутируемая сеть, полностью оптимизированная для внутрисетевых скрытых сервисов и пиринговых приложений.\nТаблица ниже обобщает ключевые архитектурные и операционные различия между этими сетями по состоянию на 2025 год.\nСравнение сетей конфиденциальности (2025) Feature / Network I2P Tor Lokinet Freenet (Hyphanet) GNUnet Primary Focus Hidden services, P2P applications Clearnet anonymity via exits Hybrid VPN + hidden services Distributed storage \u0026 publishing Research framework, F2F privacy Architecture Fully distributed, packet-switched Centralized directory, circuit-switched Packet-switched LLARP with blockchain coordination DHT-based content routing DHT \u0026 F2F topology (R5N) Routing Model Unidirectional tunnels (inbound/outbound) Bidirectional circuits (3 hops) Packet-switched over staked nodes Key-based routing Random walk + DHT hybrid Directory / Peer Discovery Distributed Kademlia netDB with floodfills 9 hardcoded directory authorities Blockchain + Oxen staking Heuristic routing Distributed hash routing (R5N) Encryption ECIES-X25519-AEAD-Ratchet (ChaCha20/Poly1305) AES + RSA/ECDH Curve25519/ChaCha20 Custom symmetric encryption Ed25519/Curve25519 Participation Model All routers route traffic (democratic) Small relay subset, majority are clients Only staked nodes User-selectable trust mesh Optional F2F restriction Traffic Handling Packet-switched, multi-path, load-balanced Circuit-switched, fixed path per circuit Packet-switched, incentivized File chunk propagation Message batching and proof-of-work Garlic Routing ✅ Yes (message bundling \u0026 tagging) ❌ No Partial (message batches) ❌ No ❌ No Exit to Clearnet Limited (discouraged) Core design goal Supported (VPN-style exits) Not applicable Not applicable Built-In Apps I2PSnark, I2PTunnel, SusiMail, I2PBote Tor Browser, OnionShare Lokinet GUI, SNApps Freenet UI GNUnet CLI tools Performance Optimized for internal services, 1–3s RTT Optimized for exits, ~200–500ms RTT Low latency, staked node QoS High latency (minutes) Experimental, inconsistent Anonymity Set Size ~55,000 active routers Millions of daily users \u0026lt;1,000 service nodes Thousands (small core) Hundreds (research only) Scalability Horizontal via floodfill rotation Centralized bottleneck (directory) Dependent on token economics Limited by routing heuristics Research-scale only Funding Model Volunteer-driven nonprofit Major institutional grants Crypto-incentivized (OXEN) Volunteer community Academic research License / Codebase Open source (Java/C++/Go) Open source (C) Open source (C++) Open source (Java) Open source (C) --- Почему I2P лидирует в дизайне с приоритетом конфиденциальности 1. Packet Switching \u0026gt; Circuit Switching Модель Tor с коммутацией каналов привязывает трафик к фиксированным путям из трёх узлов — это эффективно для веб-серфинга, но хрупко для долгоживущих внутренних сервисов. Туннели I2P с коммутацией пакетов отправляют сообщения по нескольким параллельным путям, автоматически обходя перегрузки или сбои для лучшей доступности и распределения нагрузки.\n2. Unidirectional Tunnels I2P разделяет входящий и исходящий трафик. Это означает, что каждый участник видит только половину потока связи, что значительно усложняет атаки корреляции по времени. Tor, Lokinet и другие используют двунаправленные цепочки, где запросы и ответы идут по одному пути — проще, но легче отслеживается.\n3. Fully Distributed netDB Девять узлов directory authorities сети Tor определяют её топологию. I2P использует самоорганизующуюся Kademlia DHT (распределённую хеш-таблицу), поддерживаемую ротируемыми floodfill-роутерами, что устраняет любые точки централизованного контроля или координирующие серверы.\n1. Коммутация пакетов \u0026gt; Коммутация каналов I2P расширяет луковую маршрутизацию с помощью garlic routing (чесночной маршрутизации), объединяя несколько зашифрованных сообщений в один контейнер. Это снижает утечку метаданных и накладные расходы на пропускную способность, одновременно повышая эффективность передачи подтверждений, данных и управляющих сообщений.\n2. Однонаправленные туннели Каждый I2P router маршрутизирует трафик для других. Нет выделенных операторов relay или привилегированных узлов — пропускная способность и надёжность автоматически определяют, какой объём маршрутизации обеспечивает узел. Этот демократичный подход создаёт устойчивость и естественно масштабируется по мере роста сети.\n3. Полностью распределённая netDB 12-хоповый цикл туда и обратно в I2P (6 входящих + 6 исходящих) создаёт более сильную неотслеживаемость, чем 6-хоповые скрытые сервисы Tor. Поскольку обе стороны находятся внутри сети, соединения полностью избегают узкого места exit-узлов, обеспечивая более быстрый внутренний хостинг и нативную интеграцию приложений (I2PSnark, I2PTunnel, I2PBote).\nArchitectural Takeaways Design Principle I2P Advantage Decentralization No trusted authorities; netDB managed by floodfill peers Traffic Separation Unidirectional tunnels prevent request/response correlation Adaptability Packet-switching allows per-message load balancing Efficiency Garlic routing reduces metadata and increases throughput Inclusiveness All peers route traffic, strengthening anonymity set Focus Built specifically for hidden services and in-network communication --- When to Use Each Network Use Case Recommended Network Anonymous web browsing (clearnet access) I2P Anonymous hosting, P2P, or DApps I2P Anonymous file publishing and storage Freenet (Hyphanet) VPN-style private routing with staking Lokinet Academic experimentation and research GNUnet --- Summary Архитектура I2P ориентирована в первую очередь на приватность — нет серверов каталогов, нет зависимостей от блокчейна, нет централизованного доверия. Её сочетание однонаправленных tunnel, маршрутизации с коммутацией пакетов, garlic-группировки сообщений и распределённого обнаружения узлов делает её наиболее технически продвинутой системой для анонимного хостинга и peer-to-peer коммуникации на сегодняшний день.\nI2P — это не «альтернатива Tor». Это другой класс сети, созданной для того, что происходит внутри приватной сети, а не за её пределами.\n","description":"Современное техническое и философское сравнение, подчеркивающее уникальные преимущества дизайна I2P","id":"bc3abab13910824c59b1550aa1ce69df","section":"docs","title":"I2P в сравнении с другими анонимными сетями","url":"/ru/docs/overview/comparison/"},{"categories":null,"content":"Введение I2P — это масштабируемый, самоорганизующийся, устойчивый анонимный сетевой уровень с коммутацией пакетов, на котором может работать любое количество различных приложений, ориентированных на анонимность или безопасность. Каждое из этих приложений может самостоятельно выбирать компромисс между анонимностью, задержкой и пропускной способностью, не беспокоясь о правильной реализации mixnet со свободной маршрутизацией, что позволяет им смешивать свою активность с более широким набором анонимности пользователей, уже работающих поверх I2P.\nУже доступные приложения обеспечивают полный спектр типичных интернет-активностей — анонимный веб-серфинг, веб-хостинг, чат, обмен файлами, электронную почту, ведение блогов и распространение контента, а также ряд других приложений, находящихся в разработке.\nВеб-браузинг: используя любой существующий браузер с поддержкой прокси Чат: IRC и другие протоколы Обмен файлами: I2PSnark и другие приложения Электронная почта: Susimail и другие приложения Блог: используя любой локальный веб-сервер или доступные плагины В отличие от веб-сайтов, размещённых в сетях распространения контента, таких как Freenet или GNUnet , сервисы, размещённые в I2P, полностью интерактивны — здесь есть традиционные поисковые системы веб-стиля, доски объявлений, блоги, в которых можно оставлять комментарии, сайты на основе баз данных, а также мосты для запросов к статическим системам вроде Freenet без необходимости локальной установки.\nСо всеми этими приложениями с поддержкой анонимности I2P выступает в роли message-oriented middleware (промежуточного ПО, ориентированного на обмен сообщениями) — приложения указывают данные для отправки на криптографический идентификатор («destination»), а I2P обеспечивает их безопасную и анонимную доставку. I2P также включает простую библиотеку потоковой передачи , которая позволяет анонимным сообщениям I2P с доставкой по принципу «best-effort» передаваться в виде надёжных упорядоченных потоков, обеспечивая управление перегрузкой на основе TCP, настроенное под высокое произведение пропускной способности на задержку сети.\nХотя были разработаны простые SOCKS-прокси для подключения существующих приложений, их ценность ограничена, поскольку большинство приложений раскрывают конфиденциальную информацию в анонимном контексте. Самый безопасный подход — это проверить и адаптировать приложение для прямого использования API I2P.\nI2P — это не исследовательский проект (ни академический, ни коммерческий, ни государственный), а инженерная разработка, направленная на обеспечение практичной анонимности. Проект находится в активной разработке с начала 2003 года распределённой группой разработчиков по всему миру. Весь код I2P является открытым на официальном сайте , в основном выпускается в общественное достояние, некоторые компоненты распространяются под разрешительными лицензиями в стиле BSD. Доступны несколько клиентских приложений под лицензией GPL, такие как I2PTunnel , Susimail и I2PSnark . Финансирование поступает исключительно из пожертвований пользователей.\nРабота Overview I2P четко разграничивает router\u0026rsquo;ы (узлы, участвующие в сети) и destinations (анонимные конечные точки для приложений). Сам факт работы I2P не является секретом; скрыто что именно делает пользователь и какой router используют его destinations. Конечные пользователи обычно запускают несколько destinations (например, один для веб-браузинга, другой для хостинга, третий для IRC).\nКлючевая концепция I2P — это tunnel (туннель) — однонаправленный зашифрованный путь через серию роутеров. Каждый роутер расшифровывает только один слой и узнаёт только следующий переход. Tunnels истекают каждые 10 минут и должны быть перестроены заново.\nРисунок 1: Существует два типа туннелей — inbound (входящие) и outbound (исходящие).\nOutbound tunnels отправляют сообщения от создателя. Inbound tunnels доставляют сообщения обратно к создателю. Объединение этих туннелей обеспечивает двустороннюю связь. Например, «Алиса» использует outbound tunnel для отправки данных в inbound tunnel «Боба». Алиса шифрует своё сообщение с инструкциями маршрутизации к inbound gateway Боба.\nЕще одна ключевая концепция — это сетевая база данных или netDb, которая распределяет метаданные о роутерах и назначениях:\nRouterInfo: Содержит контактную информацию router и ключевой материал. LeaseSet: Содержит информацию, необходимую для связи с destination (шлюзы tunnel, время истечения, ключи шифрования). Роутеры публикуют свою информацию RouterInfo напрямую в netDb; LeaseSets отправляются через исходящие туннели для обеспечения анонимности.\nДля построения туннелей Алиса запрашивает netDb для получения записей RouterInfo, чтобы выбрать узлы, и отправляет зашифрованные сообщения построения туннеля от узла к узлу, пока туннель не будет завершён.\nРисунок 2: Информация о роутере используется для построения туннелей.\nЧтобы отправить данные Бобу, Алиса ищет LeaseSet Боба и использует один из своих исходящих туннелей для маршрутизации данных через шлюз входящего туннеля Боба.\nРисунок 3: LeaseSets соединяют исходящие и входящие туннели.\nПоскольку I2P основана на сообщениях, она добавляет сквозное garlic-шифрование для защиты сообщений даже от исходящей конечной точки или входящего шлюза. Garlic-сообщение содержит несколько зашифрованных «зубчиков» (сообщений), чтобы скрыть метаданные и улучшить анонимность.\nПриложения могут либо напрямую использовать интерфейс сообщений, либо полагаться на библиотеку потоковой передачи для надёжных соединений.\nTunnels Как входящие, так и исходящие туннели используют многослойное шифрование, но различаются по конструкции:\nВ входящих tunnel, создатель (конечная точка) расшифровывает все слои. В исходящих tunnel, создатель (шлюз) предварительно расшифровывает слои для обеспечения ясности на конечной точке. I2P профилирует узлы через косвенные метрики, такие как задержка и надежность, без прямого зондирования. На основе этих профилей узлы динамически группируются в четыре уровня:\nБыстрый и высокопроизводительный Высокопроизводительный Работоспособный Неработоспособный Выбор узлов для туннеля обычно отдаёт предпочтение высокопроизводительным узлам, случайно выбранным для баланса между анонимностью и производительностью, с дополнительными стратегиями упорядочивания на основе XOR для предотвращения атак предшественников и сбора данных netDb.\nДля более подробной информации см. Спецификацию туннелей .\nОбзор Роутеры, участвующие в распределённой хеш-таблице (DHT) floodfill, хранят и отвечают на запросы LeaseSet. DHT использует вариант Kademlia . Floodfill роутеры выбираются автоматически, если они обладают достаточной производительностью и стабильностью, или могут быть настроены вручную.\nRouterInfo: Описывает возможности router и его транспорты. LeaseSet: Описывает tunnel\u0026rsquo;ы destination и ключи шифрования. Все данные в netDb подписаны издателем и имеют временные метки для предотвращения атак повторного воспроизведения или использования устаревших записей. Синхронизация времени поддерживается через SNTP и обнаружение смещения на транспортном уровне.\nAdditional concepts Неопубликованные и зашифрованные LeaseSets:\nТочка назначения может оставаться приватной, не публикуя свой LeaseSet и делясь им только с доверенными узлами. Для доступа требуется соответствующий ключ расшифровки.\nBootstrapping (reseeding):\nЧтобы присоединиться к сети, новый router загружает подписанные файлы RouterInfo с доверенных HTTPS reseed-серверов.\nМасштабируемость поиска:\nI2P использует итеративный, а не рекурсивный поиск для улучшения масштабируемости и безопасности DHT.\nТуннели Современная коммуникация I2P использует два полностью зашифрованных транспорта:\nNTCP2 : Зашифрованный протокол на основе TCP SSU2 : Зашифрованный протокол на основе UDP Оба построены на современном Noise Protocol Framework , обеспечивая надёжную аутентификацию и устойчивость к идентификации трафика. Они заменили устаревшие протоколы NTCP и SSU (полностью выведены из эксплуатации с 2023 года).\nNTCP2 предоставляет зашифрованную, эффективную потоковую передачу данных через TCP.\nSSU2 обеспечивает надежность на основе UDP, обход NAT и опциональный hole punching. SSU2 концептуально похож на WireGuard или QUIC, сочетая надежность и анонимность.\nРоутеры могут поддерживать как IPv4, так и IPv6, публикуя свои транспортные адреса и стоимость в netDb. Транспорт соединения выбирается динамически с помощью системы торгов, которая оптимизирует условия и существующие связи.\nСетевая база данных (netDb) I2P использует многоуровневое шифрование для всех компонентов: транспортов, туннелей, garlic-сообщений и сетевой базы данных (network database).\nТекущие примитивы включают:\nX25519 для обмена ключами EdDSA (Ed25519) для подписей ChaCha20-Poly1305 для аутентифицированного шифрования SHA-256 для хеширования AES256 для шифрования на уровне tunnel Устаревшие алгоритмы (ElGamal, DSA-SHA1, ECDSA) остаются для обратной совместимости.\nI2P в настоящее время внедряет гибридные постквантовые (PQ) криптографические схемы, объединяющие X25519 с ML-KEM, для противодействия атакам типа \u0026ldquo;собрать сейчас, расшифровать позже\u0026rdquo;.\nGarlic Messages Garlic-сообщения расширяют луковую маршрутизацию, группируя несколько зашифрованных \u0026ldquo;зубчиков\u0026rdquo; с независимыми инструкциями доставки. Это обеспечивает гибкость маршрутизации на уровне сообщений и единообразное заполнение трафика.\nSession Tags Для сквозного шифрования поддерживаются две криптографические системы:\nElGamal/AES+SessionTags (устаревший):\nИспользует предварительно доставленные сессионные теги в качестве 32-байтовых nonce. Теперь устарел из-за неэффективности.\nECIES-X25519-AEAD-Ratchet (текущий):\nИспользует ChaCha20-Poly1305 и синхронизированные PRNG на основе HKDF для динамической генерации эфемерных ключей сессии и 8-байтовых тегов, снижая нагрузку на CPU, память и пропускную способность при сохранении прямой секретности.\nFuture of the Protocol Ключевые направления исследований сосредоточены на поддержании безопасности против противников государственного уровня и внедрении постквантовой защиты. Две ранние концепции дизайна — restricted routes и variable latency — были заменены современными разработками.\nRestricted Route Operation Первоначальные концепции ограниченной маршрутизации были направлены на сокрытие IP-адресов. Эта необходимость была в значительной степени устранена благодаря:\nUPnP для автоматической переадресации портов Надёжное преодоление NAT в SSU2 Поддержка IPv6 Совместные introducers и пробивка NAT Опциональная overlay-связь (например, Yggdrasil) Таким образом, современный I2P достигает тех же целей более практичным способом без сложной ограниченной маршрутизации.\nSimilar Systems I2P интегрирует концепции из промежуточного программного обеспечения, ориентированного на сообщения (message-oriented middleware), распределённых хеш-таблиц (DHT) и микснетов (mixnet). Его инновационность заключается в объединении этих концепций в удобную, самоорганизующуюся платформу для обеспечения анонимности.\nТранспортные протоколы Сайт Tor и I2P имеют общие цели, но различаются архитектурно:\nTor: Коммутация каналов; опирается на доверенные серверы каталогов. (~10 тыс. relay) I2P: Коммутация пакетов; полностью распределённая сеть на основе DHT. (~50 тыс. router) Однонаправленные туннели I2P раскрывают меньше метаданных и позволяют гибко настраивать маршруты, в то время как Tor фокусируется на анонимном доступе в Интернет (outproxying). I2P же поддерживает анонимный хостинг внутри сети.\nКриптография Сайт Freenet фокусируется на анонимной, постоянной публикации и получении файлов. I2P, напротив, предоставляет коммуникационный уровень реального времени для интерактивного использования (веб, чат, торренты). Вместе эти две системы дополняют друг друга — Freenet обеспечивает устойчивое к цензуре хранилище; I2P обеспечивает анонимность транспорта.\nOther Networks Lokinet: IP-оверлей с использованием мотивированных сервисных узлов. Nym: Миксовая сеть нового поколения с акцентом на защиту метаданных с помощью маскирующего трафика при более высокой задержке. Appendix A: Application Layer Сам I2P обрабатывает только транспорт сообщений. Функциональность прикладного уровня реализуется внешне через API и библиотеки.\nStreaming Library Библиотека потоковой передачи функционирует как TCP-аналог в I2P, с протоколом скользящего окна и управлением перегрузкой, настроенными для высокозадержанной анонимной передачи данных.\nТипичные шаблоны HTTP-запросов/ответов часто могут выполняться за один круговой обмен благодаря оптимизациям объединения сообщений.\nNaming Library and Address Book Разработано: mihi, Ragnarok См. страницу Именование и адресная книга .\nСистема именования I2P является локальной и децентрализованной, избегая глобальных имён в стиле DNS. Каждый router поддерживает локальное сопоставление человекочитаемых имён с destinations (адресами назначения). Опциональные адресные книги, основанные на сети доверия, могут быть распределены или импортированы от доверенных участников.\nЭтот подход избегает централизованных органов управления и обходит уязвимости Sybil, присущие глобальным системам именования или системам, основанным на голосовании.\nОперация ограниченного маршрута Разработано: mihi\nI2PTunnel — это основной клиентский интерфейс, обеспечивающий анонимное TCP-проксирование. Он поддерживает:\nClient tunnels (исходящие к I2P-адресатам) HTTP client (eepproxy) для доменов \u0026ldquo;.i2p\u0026rdquo; Server tunnels (входящие из I2P к локальному сервису) HTTP server tunnels (безопасное проксирование веб-сервисов) Outproxy (выход в обычный интернет) является опциональным и реализуется через добровольно управляемые «серверные» tunnels.\nI2PSnark Разработано: jrandom и др. — портировано из Snark В комплекте с I2P поставляется I2PSnark — анонимный BitTorrent-клиент с поддержкой нескольких торрентов, DHT и UDP, доступный через веб-интерфейс.\nTor Разработано: postman, susi23, mastiejaner\nI2Pmail предоставляет анонимную электронную почту через соединения I2PTunnel. Susimail — это веб-клиент, специально разработанный для предотвращения утечек информации, характерных для традиционных почтовых клиентов. Сервис mail.i2p включает фильтрацию вирусов, квоты hashcash и раздельные outproxy для дополнительной защиты.\n","description":"Техническое введение в архитектуру и работу I2P","id":"75218044125880755dabbc53c9ce4b06","section":"docs","title":"I2P: Масштабируемая платформа для анонимных коммуникаций","url":"/ru/docs/overview/tech-intro/"},{"categories":null,"content":"Документация API I2PControl I2PControl — это JSON-RPC 2.0 API, входящий в состав I2P router (начиная с версии 0.9.39). Он обеспечивает аутентифицированный мониторинг и управление router через структурированные JSON-запросы.\nПароль по умолчанию: itoopie — это заводская настройка по умолчанию, которая должна быть изменена немедленно в целях безопасности.\n1. Обзор и доступ Implementation Default Endpoint Protocol Enabled by Default Notes Java I2P (2.10.0+) http://127.0.0.1:7657/jsonrpc/ HTTP ❌ Must be enabled via WebApps (Router Console) Bundled webapp i2pd (C++ implementation) https://127.0.0.1:7650/ HTTPS ✅ Enabled by default Legacy plugin behavior В случае Java I2P вам необходимо перейти в **Router Console → WebApps → I2PControl** и включить его (установить автоматический запуск). После активации все методы требуют, чтобы вы сначала прошли аутентификацию и получили токен сессии. 2. Формат JSON-RPC Все запросы следуют структуре JSON-RPC 2.0:\n{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;MethodName\u0026#34;, \u0026#34;params\u0026#34;: { /* named parameters */ } } Успешный ответ включает поле result; в случае ошибки возвращается объект error:\n{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;result\u0026#34;: { /* data */ } } или\n{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;error\u0026#34;: { \u0026#34;code\u0026#34;: -32001, \u0026#34;message\u0026#34;: \u0026#34;Invalid password\u0026#34; } } 3. Процесс аутентификации Запрос (Аутентификация) curl -s -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;Authenticate\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;API\u0026#34;: 1, \u0026#34;Password\u0026#34;: \u0026#34;itoopie\u0026#34; } }\u0026#39; \\ http://127.0.0.1:7657/jsonrpc/ Успешный ответ { \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;result\u0026#34;: { \u0026#34;Token\u0026#34;: \u0026#34;a1b2c3d4e5\u0026#34;, \u0026#34;API\u0026#34;: 1 } } Вы должны включать этот Token во все последующие запросы в params.\n4. Методы и конечные точки 4.1 RouterInfo Получает ключевую телеметрию о роутере.\nПример запроса\ncurl -s -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;2\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;RouterInfo\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;Token\u0026#34;: \u0026#34;a1b2c3d4e5\u0026#34;, \u0026#34;i2p.router.version\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;i2p.router.status\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;i2p.router.net.status\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;i2p.router.net.tunnels.participating\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;i2p.router.net.bw.inbound.1s\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;i2p.router.net.bw.outbound.1s\u0026#34;: \u0026#34;\u0026#34; } }\u0026#39; \\ http://127.0.0.1:7657/jsonrpc/ Поля ответа (result) Согласно официальной документации (GetI2P): - i2p.router.status (String) — статус в человекочитаемом формате - i2p.router.uptime (long) — миллисекунды (или строка для старых версий i2pd) :contentReference[oaicite:0]{index=0} - i2p.router.version (String) — строка версии :contentReference[oaicite:1]{index=1} - i2p.router.net.bw.inbound.1s, i2p.router.net.bw.inbound.15s (double) — входящая пропускная способность в Б/с :contentReference[oaicite:2]{index=2} - i2p.router.net.bw.outbound.1s, i2p.router.net.bw.outbound.15s (double) — исходящая пропускная способность в Б/с :contentReference[oaicite:3]{index=3} - i2p.router.net.status (long) — числовой код статуса (см. перечисление ниже) :contentReference[oaicite:4]{index=4} - i2p.router.net.tunnels.participating (long) — количество participating tunnels :contentReference[oaicite:5]{index=5} - i2p.router.netdb.activepeers, fastpeers, highcapacitypeers (long) — статистика узлов netDB :contentReference[oaicite:6]{index=6} - i2p.router.netdb.isreseeding (boolean) — активен ли reseed :contentReference[oaicite:7]{index=7} - i2p.router.netdb.knownpeers (long) — всего известных узлов :contentReference[oaicite:8]{index=8}\nПеречисление кодов состояния (i2p.router.net.status) Code Meaning 0 OK 1 TESTING 2 FIREWALLED 3 HIDDEN 4 WARN_FIREWALLED_AND_FAST 5 WARN_FIREWALLED_AND_FLOODFILL 6 WARN_FIREWALLED_WITH_INBOUND_TCP 7 WARN_FIREWALLED_WITH_UDP_DISABLED 8 ERROR_I2CP 9 ERROR_CLOCK_SKEW 10 ERROR_PRIVATE_TCP_ADDRESS 11 ERROR_SYMMETRIC_NAT 12 ERROR_UDP_PORT_IN_USE 13 ERROR_NO_ACTIVE_PEERS_CHECK_CONNECTION_AND_FIREWALL 14 ERROR_UDP_DISABLED_AND_TCP_UNSET --- 4.2 GetRate Используется для получения метрик скорости (например, пропускной способности, успешности туннелей) за заданное временное окно.\nПример запроса\ncurl -s -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;3\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;GetRate\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;Token\u0026#34;: \u0026#34;a1b2c3d4e5\u0026#34;, \u0026#34;Stat\u0026#34;: \u0026#34;bw.combined\u0026#34;, \u0026#34;Period\u0026#34;: 60000 } }\u0026#39; \\ http://127.0.0.1:7657/jsonrpc/ Пример ответа\n{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;3\u0026#34;, \u0026#34;result\u0026#34;: { \u0026#34;Rate\u0026#34;: 12345.67 } } 4.3 RouterManager Выполнить административные действия.\nДопустимые параметры / методы - Restart, RestartGraceful - Shutdown, ShutdownGraceful - Reseed, FindUpdates, Update :contentReference[oaicite:10]{index=10}\nПример запроса\ncurl -s -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;4\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;RouterManager\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;Token\u0026#34;: \u0026#34;a1b2c3d4e5\u0026#34;, \u0026#34;Restart\u0026#34;: true } }\u0026#39; \\ http://127.0.0.1:7657/jsonrpc/ Успешный ответ\n{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;4\u0026#34;, \u0026#34;result\u0026#34;: { \u0026#34;Restart\u0026#34;: null } } 4.4 Настройки сети (NetworkSetting) Получить или установить параметры конфигурации сети (порты, upnp, распределение пропускной способности и т.д.)\nПример запроса (получение текущих значений)\ncurl -s -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;5\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;NetworkSetting\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;Token\u0026#34;: \u0026#34;a1b2c3d4e5\u0026#34;, \u0026#34;i2p.router.net.ntcp.port\u0026#34;: null, \u0026#34;i2p.router.net.ssu.port\u0026#34;: null, \u0026#34;i2p.router.net.bw.share\u0026#34;: null, \u0026#34;i2p.router.net.upnp\u0026#34;: null } }\u0026#39; \\ http://127.0.0.1:7657/jsonrpc/ Пример ответа\n{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;5\u0026#34;, \u0026#34;result\u0026#34;: { \u0026#34;i2p.router.net.ntcp.port\u0026#34;: \u0026#34;1234\u0026#34;, \u0026#34;i2p.router.net.ssu.port\u0026#34;: \u0026#34;5678\u0026#34;, \u0026#34;i2p.router.net.bw.share\u0026#34;: \u0026#34;50\u0026#34;, \u0026#34;i2p.router.net.upnp\u0026#34;: \u0026#34;true\u0026#34;, \u0026#34;SettingsSaved\u0026#34;: true, \u0026#34;RestartNeeded\u0026#34;: false } } Примечание: версии i2pd до 2.41 могут возвращать числовые типы вместо строк — клиенты должны обрабатывать оба варианта. :contentReference[oaicite:11]{index=11}\n4.5 Расширенные настройки Позволяет управлять внутренними параметрами роутера.\nПример запроса\ncurl -s -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;6\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;AdvancedSettings\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;Token\u0026#34;: \u0026#34;a1b2c3d4e5\u0026#34;, \u0026#34;Set\u0026#34;: { \u0026#34;router.sharePercentage\u0026#34;: \u0026#34;75\u0026#34;, \u0026#34;i2np.flushInterval\u0026#34;: \u0026#34;6000\u0026#34; } } }\u0026#39; \\ http://127.0.0.1:7657/jsonrpc/ Пример ответа\n{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;6\u0026#34;, \u0026#34;result\u0026#34;: { \u0026#34;Set\u0026#34;: { \u0026#34;router.sharePercentage\u0026#34;: \u0026#34;75\u0026#34;, \u0026#34;i2np.flushInterval\u0026#34;: \u0026#34;6000\u0026#34; } } } 5. Коды ошибок Помимо стандартных ошибок JSON-RPC (-32700, -32600 и т.д.), I2PControl определяет:\nCode Meaning -32001 Invalid password -32002 Missing token -32003 Token does not exist -32004 Token expired -32005 API version missing -32006 API version unsupported --- 6. Использование и рекомендации Всегда включайте параметр Token (кроме случаев аутентификации). Измените пароль по умолчанию (itoopie) при первом использовании. Для Java I2P убедитесь, что веб-приложение I2PControl включено через WebApps. Будьте готовы к небольшим различиям: некоторые поля могут быть числами или строками, в зависимости от версии I2P. Разбивайте длинные строки статуса для удобного отображения. ","description":"API удаленного управления роутером через веб-приложение I2PControl","id":"f0e7aa57ce714931128f06f6bdb94db3","section":"docs","title":"I2PControl JSON-RPC","url":"/ru/docs/api/i2pcontrol/"},{"categories":null,"content":"Обзор I2PTunnel — это основной компонент I2P для взаимодействия с сетью I2P и предоставления сервисов в ней. Он позволяет приложениям на основе TCP и потоковой передачи медиа работать анонимно через абстракцию tunnel. Назначение tunnel может быть определено через имя хоста , Base32 или полный ключ destination.\nКаждый установленный tunnel прослушивает локально (например, localhost:port) и подключается внутренне к I2P-адресатам. Для размещения сервиса создайте tunnel, указывающий на нужный IP-адрес и порт. Генерируется соответствующий ключ I2P destination, позволяющий сервису стать глобально доступным в сети I2P. Веб-интерфейс I2PTunnel доступен по адресу I2P Router Tunnel Manager .\nСлужбы по умолчанию Серверный туннель I2P Webserver – Tunnel к веб-серверу Jetty на localhost:7658 для удобного хостинга в I2P. Unix: $HOME/.i2p/eepsite/docroot Windows: %LOCALAPPDATA%\\I2P\\I2P Site\\docroot → C:\\Users\\\u0026lt;username\u0026gt;\\AppData\\Local\\I2P\\I2P Site\\docroot Клиентские туннели I2P HTTP Proxy – localhost:4444 – Используется для просмотра I2P и Интернета через outproxy-серверы. I2P HTTPS Proxy – localhost:4445 – Защищённый вариант HTTP proxy. Irc2P – localhost:6668 – Tunnel по умолчанию для анонимной IRC-сети. Git SSH (gitssh.idk.i2p) – localhost:7670 – Клиентский tunnel для SSH-доступа к репозиториям. Postman SMTP – localhost:7659 – Клиентский tunnel для исходящей почты. Postman POP3 – localhost:7660 – Клиентский tunnel для входящей почты. Примечание: Только веб-сервер I2P является server tunnel по умолчанию; все остальные являются клиентскими туннелями, подключающимися к внешним сервисам I2P.\nКонфигурация Спецификация конфигурации I2PTunnel задокументирована на странице /spec/configuration .\nРежимы клиента Стандартный Открывает локальный TCP-порт, который подключается к службе на I2P destination. Поддерживает несколько записей destination, разделенных запятыми, для обеспечения избыточности.\nHTTP Прокси-туннель для HTTP/HTTPS запросов. Поддерживает локальные и удаленные outproxy, удаление заголовков, кэширование, аутентификацию и прозрачное сжатие.\nЗащита конфиденциальности: - Удаляет заголовки: Accept-*, Referer, Via, From - Заменяет заголовки хоста на Base32 назначения - Обеспечивает RFC-совместимое удаление hop-by-hop заголовков - Добавляет поддержку прозрачной декомпрессии - Предоставляет внутренние страницы ошибок и локализованные ответы\nПоведение сжатия: - Запросы могут использовать пользовательский заголовок X-Accept-Encoding: x-i2p-gzip - Ответы с Content-Encoding: x-i2p-gzip автоматически распаковываются - Сжатие оценивается по типу MIME и длине ответа для повышения эффективности\nПостоянные соединения (новое с версии 2.5.0): HTTP Keepalive и постоянные соединения теперь поддерживаются для сервисов, размещённых в I2P, через Hidden Services Manager. Это снижает задержки и накладные расходы на соединения, но пока не обеспечивает полную совместимость с RFC 2616 для постоянных сокетов на всех hop\u0026rsquo;ах (участках маршрута).\nPipelining: Остается неподдерживаемым и ненужным; современные браузеры отказались от этой функции.\nПоведение User-Agent: - Outproxy: Использует актуальный User-Agent Firefox ESR. - Внутренний: MYOB/6.66 (AN/ON) для согласованности анонимности.\nIRC-клиент Подключается к IRC-серверам на базе I2P. Разрешает безопасное подмножество команд, фильтруя идентификаторы для обеспечения конфиденциальности.\nSOCKS 4/4a/5 Предоставляет возможность SOCKS-прокси для TCP-соединений. UDP остается нереализованным в Java I2P (только в i2pd).\nCONNECT Реализует HTTP-туннелирование CONNECT для SSL/TLS-соединений.\nStreamr Обеспечивает потоковую передачу в стиле UDP через инкапсуляцию на основе TCP. Поддерживает потоковую передачу медиа при работе с соответствующим серверным tunnel Streamr.\nРежимы сервера Стандартный сервер Создает TCP-destination, сопоставленный с локальным IP:портом.\nHTTP-сервер Создает destination, который взаимодействует с локальным веб-сервером. Поддерживает сжатие (x-i2p-gzip), удаление заголовков и защиту от DDoS-атак. Теперь включает поддержку постоянных соединений (v2.5.0+) и оптимизацию пула потоков (v2.7.0–2.9.0).\nHTTP двунаправленный Устарел – Всё ещё функционален, но не рекомендуется к использованию. Работает одновременно как HTTP-сервер и клиент без outproxy. Используется в основном для диагностических тестов с петлёй обратной связи.\nIRC-сервер Создает отфильтрованное назначение для IRC-сервисов, передавая ключи клиентских назначений в качестве имен хостов.\nStreamr Server Сочетается с клиентским туннелем Streamr для обработки потоков данных в стиле UDP через I2P.\nНовые функции (2.4.0–2.10.0) Feature Introduced Summary Keepalive/Persistent Connections 2.5.0 HTTP tunnels now support persistent sockets for I2P-hosted services, improving performance. Thread Pooling Optimization 2.7.0-2.9.0 Reduced CPU overhead and latency by improving thread management. Post-Quantum Encryption (ML-KEM) 2.10.0 Optional hybrid X25519+ML-KEM encryption to resist future quantum attacks. NetDB Segmentation 2.4.0 Isolates I2PTunnel contexts for improved security and privacy. SSU1 Removal / SSU2 Adoption 2.4.0-2.6.0 Upgraded transport layer; transparent to users. I2P-over-Tor Blocking 2.6.0 Prevents inefficient and unstable I2P-over-Tor routing. Browser Proxy (Proposal 166) 2.7.0 Introduced identity-aware proxy mode; details pending confirmation. Java 17 Requirement (upcoming) 2.11.0 Future release will require Java 17+. --- Функции безопасности Удаление заголовков для анонимности (Accept, Referer, From, Via) Рандомизация User-Agent в зависимости от in/outproxy Ограничение частоты POST-запросов и защита от Slowloris Регулирование соединений в подсистемах потоковой передачи Обработка перегрузки сети на уровне tunnel Изоляция NetDB для предотвращения утечек между приложениями Технические детали Размер ключа назначения по умолчанию: 516 байт (может быть больше для расширенных сертификатов LS2) Base32 адреса: {52–56+ символов}.b32.i2p Серверные туннели остаются совместимыми как с Java I2P, так и с i2pd Устаревшая функция: только httpbidirserver; удалений с версии 0.9.59 не было Проверены корректные порты по умолчанию и корневые директории документов для всех платформ Резюме I2PTunnel остаётся основой интеграции приложений с I2P. Между версиями 0.9.59 и 2.10.0 он получил поддержку постоянных соединений, постквантовое шифрование и значительные улучшения многопоточности. Большинство конфигураций остаются совместимыми, но разработчикам следует проверить свои настройки для соответствия современным транспортным параметрам и настройкам безопасности по умолчанию.\n","description":"Инструмент для взаимодействия с I2P и предоставления сервисов в сети","id":"7e5d426e3eead28c1767764107b1f3d1","section":"docs","title":"I2PTunnel","url":"/ru/docs/api/i2ptunnel/"},{"categories":null,"content":"Обзор Ключевые моменты\nI2P обеспечивает сквозное шифрование (end-to-end encryption) IRC-трафика через свои туннели. Отключите SSL/TLS в IRC-клиентах, если только вы не используете outproxy для выхода в clearnet. Предварительно настроенный клиентский туннель Irc2P по умолчанию прослушивает адрес 127.0.0.1:6668. Подключите свой IRC-клиент к этому адресу и порту. Не используйте термин \u0026ldquo;router‑provided TLS\u0026rdquo;. Используйте \u0026ldquo;встроенное шифрование I2P\u0026rdquo; или \u0026ldquo;сквозное шифрование\u0026rdquo; (end-to-end encryption). Быстрый старт (Java I2P) Откройте Hidden Services Manager по адресу http://127.0.0.1:7657/i2ptunnel/ и убедитесь, что туннель Irc2P запущен. В вашем IRC-клиенте установите server = 127.0.0.1, port = 6668, SSL/TLS = off. Подключитесь и присоединитесь к каналам, таким как #i2p, #i2p-dev, #i2p-help. Для пользователей i2pd (маршрутизатор на C++), создайте клиентский tunnel в tunnels.conf (см. примеры ниже).\nСети и серверы IRC2P (main community network) Федеративные серверы: irc.postman.i2p:6667, irc.echelon.i2p:6667, irc.dg.i2p:6667. Туннель Irc2P на 127.0.0.1:6668 подключается к одному из них автоматически. Типичные каналы: #i2p, #i2p-chat, #i2p-dev, #i2p-help. Ilita network Серверы: irc.ilita.i2p:6667, irc.r4sas.i2p:6667, irc.acetone.i2p:6667, rusirc.ilita.i2p:6667. Основные языки: русский и английский. Веб-интерфейсы доступны на некоторых хостах. Client setup Recommended, actively maintained WeeChat (терминал) — надёжная поддержка SOCKS; легко настраивается скриптами. Pidgin (десктоп) — всё ещё поддерживается; хорошо работает на Windows/Linux. Thunderbird Chat (десктоп) — поддерживается в ESR 128+. The Lounge (самостоятельный хостинг, веб) — современный веб-клиент. IRC2P (основная сеть сообщества) LimeChat (бесплатный, с открытым исходным кодом). Textual (платный в App Store; исходный код доступен для сборки). Сеть Ilita WeeChat via SOCKS5 /proxy add i2p socks5 127.0.0.1 4447 /set irc.server.i2p.addresses \u0026#34;127.0.0.1/6668\u0026#34; /set irc.server.i2p.proxy \u0026#34;i2p\u0026#34; /connect i2p Pidgin Протокол: IRC Сервер: 127.0.0.1 Порт: 6668 Шифрование: выключено Имя пользователя/ник: любое Thunderbird Chat Тип учётной записи: IRC Сервер: 127.0.0.1 Порт: 6668 SSL/TLS: выключен Опционально: автоматическое подключение к каналам при соединении Dispatch (SAM v3) Пример значений по умолчанию в config.toml:\n[defaults] name = \u0026#34;Irc2P\u0026#34; host = \u0026#34;irc.postman.i2p\u0026#34; port = 6667 channels = [\u0026#34;#i2p\u0026#34;,\u0026#34;#i2p-dev\u0026#34;] ssl = false Tunnel configuration Java I2P defaults Irc2P клиентский туннель: 127.0.0.1:6668 → upstream сервер на порту 6667. Hidden Services Manager: http://127.0.0.1:7657/i2ptunnel/. Рекомендуется, активно поддерживается ~/.i2pd/tunnels.conf:\n[IRC-IRC2P] type = client address = 127.0.0.1 port = 6668 destination = irc.postman.i2p destinationport = 6667 keys = irc-keys.dat Отдельный туннель для Ilita (пример):\n[IRC-ILITA] type = client address = 127.0.0.1 port = 6669 destination = irc.ilita.i2p destinationport = 6667 keys = irc-ilita-keys.dat Опции macOS Включите SAM в Java I2P (по умолчанию отключен) на /configclients или в clients.config. Значения по умолчанию: 127.0.0.1:7656/TCP и 127.0.0.1:7655/UDP. Рекомендуемая криптография: SIGNATURE_TYPE=7 (Ed25519) и i2cp.leaseSetEncType=4,0 (ECIES‑X25519 с fallback на ElGamal) или просто 4 только для современных. Примеры конфигураций Java I2P по умолчанию: 2 входящих / 2 исходящих. i2pd по умолчанию: 5 входящих / 5 исходящих. Для IRC: 2–3 каждого достаточно; установите явно для согласованного поведения на разных роутерах. Настройка клиента Не включайте SSL/TLS для внутренних IRC-соединений через I2P. I2P уже обеспечивает сквозное шифрование. Дополнительный TLS создаёт накладные расходы без выигрыша в анонимности. Используйте постоянные ключи для стабильной идентификации; избегайте пересоздания ключей при каждом перезапуске, если только не тестируете. Если несколько приложений используют IRC, предпочтительнее отдельные туннели (не общие), чтобы снизить корреляцию между сервисами. Если необходимо разрешить удалённое управление (SAM/I2CP), привяжите его к localhost и защитите доступ с помощью SSH-туннелей или аутентифицированных обратных прокси. Alternative connection method: SOCKS5 Некоторые клиенты могут подключаться через SOCKS5-прокси I2P: 127.0.0.1:4447. Для достижения наилучших результатов предпочтительнее использовать выделенный IRC client tunnel на порту 6668; SOCKS не может очистить идентификаторы на уровне приложения и может допустить утечку информации, если клиент не предназначен для обеспечения анонимности.\nTroubleshooting Не удаётся подключиться — убедитесь, что туннель Irc2P запущен и роутер полностью загрузился (bootstrapped). Зависает на resolve/join — дважды проверьте, что SSL отключён и клиент указывает на 127.0.0.1:6668. Высокая задержка — I2P имеет более высокую задержку по своей архитектуре. Держите количество туннелей умеренным (2–3) и избегайте циклов быстрого переподключения. При использовании SAM-приложений — убедитесь, что SAM включён (Java) или не заблокирован файрволом (i2pd). Рекомендуются долгоживущие сессии. Appendix: Ports and naming Стандартные порты IRC-туннелей: 6668 (по умолчанию для Irc2P), 6667 и 6669 как альтернативные. Имена хостов .b32.i2p: стандартная форма из 52 символов; существуют расширенные формы из 56+ символов для LS2/продвинутых сертификатов. Используйте имена хостов .i2p, если явно не требуются b32-адреса. ","description":"Полное руководство по IRC-сетям I2P, клиентам, туннелям и настройке сервера (обновлено 2025)","id":"f8c49a6509b36124b90dbaa1d0fbbc4b","section":"docs","title":"IRC через I2P","url":"/ru/docs/applications/irc/"},{"categories":null,"content":" Устарело: SAM v1 сохраняется только для исторической справки. Новым приложениям следует использовать SAM v3 или BOB . Оригинальный мост поддерживает только назначения DSA-SHA1 и ограниченный набор параметров.\nБиблиотеки Дерево исходного кода Java I2P по-прежнему включает устаревшие привязки для C, C#, Perl и Python. Они больше не поддерживаются и распространяются главным образом для сохранения совместимости с архивными версиями.\nСогласование версий Клиенты подключаются по TCP (по умолчанию 127.0.0.1:7656) и обмениваются данными:\nClient → HELLO VERSION MIN=1 MAX=1 Bridge → HELLO REPLY RESULT=OK VERSION=1.0 Начиная с Java I2P 0.9.14 параметр MIN является необязательным, а MIN/MAX принимают однозначные значения (\u0026quot;3\u0026quot; и т. д.) для обновленных мостов.\nСоздание сеанса SESSION CREATE STYLE={STREAM|DATAGRAM|RAW} DESTINATION={name|TRANSIENT} [DIRECTION={BOTH|RECEIVE|CREATE}] [option=value]* DESTINATION=name загружает или создаёт запись в sam.keys; TRANSIENT всегда создаёт временное назначение. STYLE выбирает виртуальные потоки (TCP-подобные), подписанные дейтаграммы или необработанные дейтаграммы. DIRECTION применяется только к сеансам потоков; по умолчанию — BOTH. Дополнительные пары ключ/значение передаются как параметры I2CP (например, tunnels.quantityInbound=3). Мост отвечает:\nSESSION STATUS RESULT=OK DESTINATION=name При ошибках возвращаются DUPLICATED_DEST, I2P_ERROR или INVALID_KEY, а также необязательное сообщение.\nФорматы сообщений Сообщения SAM — однострочные ASCII с разделёнными пробелами парами ключ/значение. Ключи — UTF‑8; значения могут быть заключены в кавычки, если содержат пробелы. Экранирование не определено.\nТипы связи:\nПотоки – проксируются через библиотеку потоковой передачи I2P Датаграммы с возможностью ответа – подписанные полезные нагрузки (Datagram1) Сырые датаграммы – неподписанные полезные нагрузки (Datagram RAW) Параметры, добавленные в версии 0.9.14 DEST GENERATE принимает SIGNATURE_TYPE=... (включая Ed25519 и т. п.) HELLO VERSION считает MIN необязательным и принимает строки версий из одной цифры Когда использовать SAM v1 Только для обеспечения совместимости с устаревшим ПО, которое нельзя обновить. Для всей новой разработки используйте:\nSAM v3 для полнофункционального доступа к потокам/датаграммам BOB для управления Destination (уникальными адресами в I2P) (всё ещё ограничен, но поддерживает более современные функции) Ссылки SAM v2 SAM v3 Спецификация дейтаграмм Протокол потоковой передачи SAM v1 (протокол SAM версии 1) заложил основу для разработки приложений, не зависящей от конкретного router, но экосистема ушла вперёд. Рассматривайте этот документ скорее как пособие по совместимости, а не как отправную точку.\n","description":"Устаревший протокол Simple Anonymous Messaging (простой анонимный обмен сообщениями) (не рекомендуется к использованию)","id":"d6c20329db11e9b5a1eff3a8709b3294","section":"docs","title":"SAM v1","url":"/ru/docs/legacy/sam/"},{"categories":null,"content":" Устарело: SAM v2 поставлялась вместе с I2P 0.6.1.31 и больше не поддерживается. Для новой разработки используйте SAM v3 . Единственным улучшением v2 по сравнению с v1 была поддержка нескольких сокетов, мультиплексированных поверх одного SAM-соединения.\nПримечания к версии Сообщаемая строка версии по‑прежнему равна \u0026quot;2.0\u0026quot;. Начиная с 0.9.14 сообщение HELLO VERSION принимает однозначные значения MIN/MAX, а параметр MIN является необязательным. DEST GENERATE поддерживает SIGNATURE_TYPE, поэтому можно создавать назначения Ed25519. Основы сеанса SESSION CREATE STYLE={STREAM|DATAGRAM|RAW} DESTINATION={name|TRANSIENT} [DIRECTION={BOTH|RECEIVE|CREATE}] [option=value] У каждого назначения может быть только один активный сеанс SAM (потоки, дейтаграммы или raw (необработанные)). STYLE выбирает виртуальные потоки, подписанные дейтаграммы или raw дейтаграммы. Дополнительные параметры передаются в I2CP (например, tunnels.quantityInbound=3). Ответы аналогичны v1: SESSION STATUS RESULT=OK|DUPLICATED_DEST|I2P_ERROR|INVALID_KEY. Кодирование сообщений Построчный ASCII с парами key=value, разделёнными пробелами (значения могут быть заключены в кавычки). Типы взаимодействия те же, что в v1:\nПотоки через потоковую библиотеку I2P Дейтаграммы с возможностью ответа (PROTO_DATAGRAM) Сырые дейтаграммы (PROTO_DATAGRAM_RAW) Когда использовать Только для устаревших клиентов, которые не могут мигрировать. SAM v3 предлагает:\nПередача назначения в бинарном виде (DEST GENERATE BASE64) Подсессии и поддержка DHT (распределённая хеш-таблица) (v3.3) Улучшенные сообщения об ошибках и согласование параметров См.:\nSAM v1 SAM v3 API датаграмм Протокол потоковой передачи ","description":"Устаревший протокол Simple Anonymous Messaging (простой протокол анонимного обмена сообщениями)","id":"a21e46f2603ba3051f18eff26aa5084d","section":"docs","title":"SAM v2","url":"/ru/docs/legacy/samv2/"},{"categories":null,"content":"SAM v3 (\u0026ldquo;Simple Anonymous Messaging\u0026rdquo;) — это текущий стабильный, не зависящий от реализации router API, который позволяет внешним приложениям взаимодействовать с сетью I2P без встраивания самого router. Он обеспечивает унифицированный доступ к потокам, датаграммам и сырым сообщениям, оставаясь каноническим связующим слоем для программного обеспечения, написанного не на Java.\n1. Обзор и назначение SAM v3 позволяет разработчикам создавать приложения для I2P на любом языке программирования, используя легковесный протокол TCP/UDP. Он абстрагирует внутреннее устройство router, предоставляя минимальный набор команд через TCP (7656) и UDP (7655). И Java I2P, и i2pd реализуют подмножества спецификации SAM v3, хотя в i2pd по состоянию на 2025 год всё ещё отсутствует большинство расширений версий 3.2 и 3.3.\n2. История версий Version Introduced Key Features 3.00.7.3 (May 2009)Streams + Datagrams; binary destinations; `SESSION CREATE STYLE=` parameter. 3.10.9.14 (Jul 2014)Signature type negotiation via `SIGNATURE_TYPE`; improved `DEST GENERATE`. 3.20.9.24 (Jan 2016)Per session encryption + tunnel options; `STREAM CONNECT ID` support. 3.30.9.25 (Mar 2016)PRIMARY / SUBSESSION architecture; multiplexing; improved datagrams. ### Примечание по именованию Java I2P использует PRIMARY/SUBSESSION. i2pd и I2P+ продолжают использовать устаревшую терминологию MASTER/SUBSESSION для обратной совместимости. 3. Основной рабочий процесс Согласование версии HELLO VERSION MIN=3.1 MAX=3.3 HELLO REPLY RESULT=OK VERSION=3.3 Создание Destination DEST GENERATE SIGNATURE_TYPE=7 SIGNATURE_TYPE=7 → Ed25519 (EdDSA SHA512). Настоятельно рекомендуется с версии I2P 0.9.15. Создание сессии SESSION CREATE STYLE=STREAM DESTINATION=NAME OPTION=i2cp.leaseSetEncType=4,0 OPTION=inbound.quantity=3 OPTION=outbound.quantity=3 i2cp.leaseSetEncType=4,0 → 4 — это X25519 (ECIES X25519 AEAD Ratchet), а 0 — резервный вариант ElGamal для совместимости. Явные количества туннелей для согласованности: по умолчанию в Java I2P — 2, в i2pd — 5. Операции протокола STREAM CONNECT ID=1 DESTINATION=b32address.i2p STREAM SEND ID=1 SIZE=128 STREAM CLOSE ID=1 Основные типы сообщений включают: STREAM CONNECT, STREAM ACCEPT, STREAM FORWARD, DATAGRAM SEND, RAW SEND, NAMING LOOKUP, DEST LOOKUP, PING, QUIT.\nПлавное завершение работы QUIT 4. Различия в реализации (Java I2P vs i2pd) Feature Java I2P 2.10.0 i2pd 2.58.0 (Sept\u0026nbsp;2025) SAM enabled by default❌ Requires manual enable in router console✅ Enabled via `enabled=true` in `i2pd.conf` Default portsTCP 7656 / UDP 7655Same AUTH / USER / PASSWORD✓ Supported✗ Not implemented PING / PONG keepalive✓ Supported✗ Not implemented QUIT / STOP / EXIT commands✓ Supported✗ Not implemented FROM_PORT / TO_PORT / PROTOCOL✓ Supported✗ Not implemented PRIMARY/SUBSESSION support✓ (since 0.9.47)✗ Absent SESSION ADD / REMOVE✓ Supported✗ Not implemented Datagram2 / Datagram3 support✓ (since 2.9.0)✗ Not implemented SSL/TLSOptional✗ None Default tunnel quantitiesInbound/outbound=2Inbound/outbound=5 **Рекомендация:** Всегда явно указывайте количество туннелей, чтобы обеспечить согласованность между роутерами. 5. Поддерживаемые библиотеки (состояние на 2025 год) Library Language SAM Support Maintenance Status (2025) libsam3C3.1Maintained by I2P Project (eyedeekay) i2psamC++3.1Minimal updates since 2019 sam3Go3.3Active; migrated from `eyedeekay/sam3` onrampGo3.3Actively maintained (2025) i2plibPython3.1Modern async replacement for `i2p.socket` i2p.socketPython3.2Abandoned (last release 2017) Py2pPython3.3Unverified/inactive i2p-rsRust3.1Experimental; unstable API @diva.exchange/i2p-samTypeScript / JS3.3Most actively maintained (2024–2025) I2PSharpC#3.3Functional; light maintenance ## 6. Предстоящие и новые функции (2024–2025) Feature Status Introduced NAMING LOOKUP `OPTIONS=true`✓ Supported2.8.0 Datagram2 / Datagram3 formats✓ (Java only)2.9.0 Post-quantum hybrid crypto (ML KEM)Optional2.10.0 Java 17+ runtime requirementPlanned2.11.0 I2P over Tor blockingActive2.6.0 Improved floodfill selectionActive2.8.0+ ## 7. Замечания по безопасности и настройке Привязывайте SAM только к 127.0.0.1. Для постоянных сервисов используйте PRIMARY сессии со статическими ключами. Используйте HELLO VERSION для проверки поддержки функций. Используйте PING или NAMING LOOKUP для проверки работоспособности router. Избегайте неаутентифицированных удалённых SAM-подключений (в i2pd нет TLS). 8. Ссылки и спецификации Спецификация SAM v3 SAM v2 (устаревший) Спецификация Streaming Датаграммы Центр документации Документация i2pd 9. Резюме SAM v3 остаётся рекомендуемым протоколом моста для всех приложений I2P, не использующих Java. Он обеспечивает стабильность, межъязыковые привязки и стабильную производительность на различных типах router.\nПри разработке с SAM: - Используйте подписи Ed25519 и шифрование X25519. - Проверяйте поддержку функций динамически через HELLO VERSION. - Проектируйте с учётом совместимости, особенно при поддержке как Java I2P, так и i2pd router\u0026rsquo;ов.\n","description":"Стабильный мостовой протокол для приложений I2P на других языках программирования","id":"dd6d27c1d72fe7c4333dc148d132f546","section":"docs","title":"SAM v3","url":"/ru/docs/api/samv3/"},{"categories":null,"content":" Внимание: SOCKS-туннель передает данные приложений без их санитарной обработки. Многие протоколы раскрывают IP-адреса, имена хостов или другие идентификаторы. Используйте SOCKS только с программным обеспечением, которое вы проверили на предмет анонимности.\n1. Обзор I2P предоставляет поддержку прокси SOCKS 4, 4a и 5 для исходящих соединений через I2PTunnel клиент. Это позволяет стандартным приложениям обращаться к I2P-адресатам, но не может получить доступ к clearnet (обычному интернету). SOCKS outproxy отсутствует, и весь трафик остается внутри сети I2P.\nКраткое описание реализации Parameter Java I2P i2pd Default Port User-defined 127.0.0.1:4447 Supported SOCKS Versions 4, 4a, 5 4, 4a, 5 UDP Mode Stubbed (non-functional) Stubbed (non-functional) Persistent Keys ✅ Since 0.9.9 ✅ Shared Client Tunnels Supported Supported Outproxy Support ❌ None ❌ None **Поддерживаемые типы адресов:** - доменные имена `.i2p` (записи адресной книги) - Base32 хеши (`.b32.i2p`) - Base64 и обычная сеть не поддерживаются 2. Риски безопасности и ограничения Утечка на уровне приложения SOCKS работает ниже прикладного уровня и не может очищать протоколы. Многие клиенты (например, браузеры, IRC, электронная почта) включают метаданные, которые раскрывают ваш IP-адрес, имя хоста или сведения о системе.\nРаспространённые утечки включают: - IP-адреса в заголовках почты или CTCP-ответах IRC - Настоящие имена/имена пользователей в данных протокола - Строки user-agent с отпечатками ОС - Внешние DNS-запросы - WebRTC и телеметрия браузера\nI2P не может предотвратить эти утечки — они происходят выше уровня tunnel. Используйте SOCKS только для проверенных клиентов, разработанных с учетом анонимности.\nОбщая идентичность туннеля Если несколько приложений используют один SOCKS tunnel, они разделяют одну и ту же идентичность I2P destination. Это позволяет проводить корреляцию или снятие цифровых отпечатков между различными сервисами.\nМеры противодействия: Используйте неразделяемые tunnel для каждого приложения и включите постоянные ключи, чтобы поддерживать согласованные криптографические идентификаторы при перезапусках.\nРежим UDP заглушен Поддержка UDP в SOCKS5 не реализована. Протокол объявляет о возможности UDP, но вызовы игнорируются. Используйте клиенты только с TCP.\nОтсутствие Outproxy по дизайну В отличие от Tor, I2P не предоставляет SOCKS-based прокси для выхода в clearnet (обычный интернет). Попытки подключиться к внешним IP-адресам завершатся неудачей или раскроют вашу личность. Если требуется выход в обычный интернет, используйте HTTP или HTTPS прокси.\n3. Исторический контекст Разработчики давно не рекомендуют использовать SOCKS для анонимного использования. Из внутренних обсуждений разработчиков и встреч 2004 года Meeting 81 и Meeting 82 :\n\u0026ldquo;Пересылка произвольного трафика небезопасна, и нам как разработчикам программного обеспечения для анонимности следует в первую очередь заботиться о безопасности наших конечных пользователей.\u0026rdquo;\nПоддержка SOCKS была включена для совместимости, но не рекомендуется для производственных сред. Практически каждое интернет-приложение пропускает конфиденциальные метаданные, непригодные для анонимной маршрутизации.\n4. Конфигурация Java I2P Откройте I2PTunnel Manager Создайте новый клиентский tunnel типа \u0026ldquo;SOCKS 4/4a/5\u0026rdquo; Настройте параметры: Локальный порт (любой доступный) Shared client: отключите для отдельной идентичности каждого приложения Persistent key: включите для уменьшения корреляции ключей Запустите tunnel i2pd i2pd включает поддержку SOCKS5, включенную по умолчанию на 127.0.0.1:4447. Конфигурация в i2pd.conf в разделе [SOCKSProxy] позволяет настроить порт, хост и параметры tunnel.\n5. График разработки Version Change Date 0.7.1 Initial SOCKS 4/4a/5 support 2010 0.9.9 Added persistent keying 2013 1.7.0 BOB API deprecated and removed 2022 2.6.0 I2P-over-Tor blocked to improve network health 2024 2.10.0 Post-quantum hybrid encryption introduced 2025 Сам модуль SOCKS не получал значительных обновлений протокола с 2013 года, но окружающий стек туннелей получил улучшения производительности и криптографии. 6. Рекомендуемые альтернативы Для любого производственного, публичного или критически важного для безопасности приложения используйте один из официальных I2P API вместо SOCKS:\nAPI Description Recommended For SAM v3 (3.3) Simple Anonymous Messaging API Cross-language apps needing socket-like I/O Streaming Library TCP-like sockets for Java Native Java integrations I2CP Low-level router communication Custom protocols, router-level integration BOB Deprecated (removed 2022) Legacy only; migrate to SAM Эти API обеспечивают надлежащую изоляцию точек назначения, управление криптографическими идентификаторами и повышенную производительность маршрутизации. 7. OnionCat / GarliCat OnionCat поддерживает I2P через режим GarliCat (диапазон IPv6 fd60:db4d:ddb5::/48). До сих пор функционирует, но с ограниченной разработкой с 2019 года.\nОграничения использования: - Требует ручной настройки .oc.b32.i2p в SusiDNS - Необходимо статическое назначение IPv6 - Официально не поддерживается проектом I2P\nРекомендуется только для продвинутых настроек VPN поверх I2P.\n8. Лучшие практики Если необходимо использовать SOCKS: 1. Создавайте отдельные туннели для каждого приложения. 2. Отключайте режим общего клиента. 3. Включайте постоянные ключи. 4. Принудительно используйте разрешение DNS через SOCKS5. 5. Проверяйте поведение протокола на предмет утечек. 6. Избегайте соединений с обычной сетью. 7. Отслеживайте сетевой трафик на предмет утечек.\n9. Техническое резюме Parameter Value Supported SOCKS Versions 4, 4a, 5 Transport TCP only UDP Support Stubbed (non-functional) Clearnet Access Not supported Default Ports Java I2P: user-set; i2pd: 127.0.0.1:4447 Persistent Keying Supported since 0.9.9 Shared Tunnels Supported (discouraged) --- 10. Заключение SOCKS-прокси в I2P обеспечивает базовую совместимость с существующими TCP-приложениями, но не предназначен для обеспечения строгих гарантий анонимности. Его следует использовать только в контролируемых, проверенных тестовых средах.\nДля серьезных развертываний переходите на SAM v3 или Streaming API. Эти API изолируют идентификаторы приложений, используют современную криптографию и получают постоянную поддержку разработки.\nДополнительные ресурсы Официальная документация SOCKS Спецификация SAM v3 Документация библиотеки Streaming Справочник I2PTunnel Документация для разработчиков I2P Форум сообщества ","description":"Безопасное использование SOCKS-туннеля I2P (обновлено для версии 2.10.0)","id":"e71093f25f593f15b6820398338abc89","section":"docs","title":"SOCKS-прокси","url":"/ru/docs/api/socks/"},{"categories":null,"content":" Устарело: SSU было заменено SSU2. Поддержка была удалена из i2pd 2.44.0 (API 0.9.56, ноя 2022) и из Java I2P 2.4.0 (API 0.9.61, дек 2023).\nSSU обеспечивал доставку по UDP с частичной надёжностью, управлением перегрузками, обходом NAT и поддержкой introducer (посредника для установления соединений). Он дополнял NTCP, обслуживая routers, находящиеся за NAT/межсетевыми экранами, и координируя обнаружение IP.\nЭлементы адреса transport: SSU caps: флаги возможностей (B, C, 4, 6, и т. д.) host / port: адрес/порт прослушивания IPv4 или IPv6 (необязательно, если за брандмауэром) key: introduction key в кодировке Base64 (ключ для установления соединения) mtu: Необязательно; по умолчанию 1484 (IPv4) / 1488 (IPv6) ihost/ikey/iport/itag/iexp: записи introducer (узла-посредника для установления соединения), когда router находится за брандмауэром Возможности Кооперативный обход NAT с использованием интродьюсеров Определение локального IP-адреса с помощью тестов пиров и инспекции входящих пакетов Автоматическая передача статуса брандмауэра другим транспортам и в router console Полунадежная доставка: сообщения повторно передаются до заданного предела, затем отбрасываются Контроль перегрузки с аддитивным увеличением / мультипликативным уменьшением и битовыми полями ACK фрагментов SSU также выполнял задачи, связанные с метаданными, такие как маяки синхронизации и согласование MTU. Вся эта функциональность теперь обеспечивается (с использованием современной криптографии) SSU2 .\n","description":"Исходный транспорт SSU (безопасный полунадёжный UDP‑транспорт)","id":"15d4d0ea2bfc8074b5a7981b8673c420","section":"docs","title":"SSU (устаревший)","url":"/ru/docs/legacy/ssu/"},{"categories":null,"content":"Обзор Данная спецификация описывает протокол UDP announce-запросов BitTorrent в I2P (запросов к трекеру). Общую спецификацию BitTorrent в I2P см. в BitTorrent over I2P documentation . Для справочной информации и дополнительных сведений о разработке этой спецификации см. Proposal 160 .\nЭтот протокол был официально утверждён 24 июня 2025 года и реализован в I2P версии 2.10.0 (API 0.9.67), выпущенной 8 сентября 2025 года. Поддержка UDP‑трекеров в настоящее время работает в сети I2P с несколькими продакшен‑трекерами и полной поддержкой в клиенте i2psnark.\nПроектирование В этой спецификации используются отвечаемые датаграммы формата Datagram2, отвечаемые датаграммы формата Datagram3 и сырые датаграммы, как определено в Спецификации датаграмм I2P . Datagram2 и Datagram3 — это варианты отвечаемых датаграмм, определённые в Предложении 163 . Datagram2 добавляет защиту от атак повторного воспроизведения (replay) и поддержку офлайн-подписей. Datagram3 меньше, чем старый формат датаграмм, но без аутентификации.\nBEP 15 Для справки, последовательность сообщений, определённая в BEP 15 , выглядит следующим образом:\nClient Tracker Connect Req. -------------\u0026gt; \u0026lt;-------------- Connect Resp. Announce Req. -------------\u0026gt; \u0026lt;-------------- Announce Resp. Announce Req. -------------\u0026gt; \u0026lt;-------------- Announce Resp. Фаза подключения необходима для предотвращения подмены IP-адреса. Трекер возвращает идентификатор соединения, который клиент использует в последующих announce-запросах (запросах announce к трекеру). Этот идентификатор соединения по умолчанию истекает через одну минуту на стороне клиента и через две минуты на стороне трекера.\nI2P использует ту же схему обмена сообщениями, что и BEP 15, для удобства внедрения в существующие клиентские кодовые базы с поддержкой UDP, для повышения эффективности, а также по соображениям безопасности, обсуждаемым ниже:\nClient Tracker Connect Req. -------------\u0026gt; (Repliable Datagram2) \u0026lt;-------------- Connect Resp. (Raw) Announce Req. -------------\u0026gt; (Repliable Datagram3) \u0026lt;-------------- Announce Resp. (Raw) Announce Req. -------------\u0026gt; (Repliable Datagram3) \u0026lt;-------------- Announce Resp. (Raw) ... Это потенциально обеспечивает значительную экономию пропускной способности по сравнению с announce-запросами через streaming (TCP). Хотя Datagram2 примерно того же размера, что и streaming SYN, сырой ответ значительно меньше, чем streaming SYN ACK. Последующие запросы используют Datagram3, а последующие ответы передаются в сыром виде.\nAnnounce-запросы передаются в формате Datagram3 (тип датаграммы третьей версии), чтобы трекеру не приходилось поддерживать большую таблицу соответствия идентификаторов соединений назначению announce или его хешу. Вместо этого трекер может криптографически генерировать идентификаторы соединений из хеша отправителя, текущей метки времени (привязанной к некоторому интервалу) и секретного значения. Когда поступает announce-запрос, трекер валидирует идентификатор соединения, а затем использует хеш отправителя Datagram3 в качестве цели отправки.\nВремя жизни соединения BEP 15 указывает, что идентификатор соединения (connection ID) истекает через одну минуту на стороне клиента и через две минуты на стороне трекера. Это не настраивается. Это ограничивает потенциальный выигрыш в эффективности, если только клиенты не будут группировать announce-запросы (запросы анонса к трекеру), выполняя их все в пределах одноминутного окна. i2psnark в настоящее время не группирует announce-запросы; он распределяет их по времени, чтобы избежать всплесков трафика. Сообщается, что продвинутые пользователи запускают одновременно тысячи торрентов, и отправка такого количества announce-запросов в течение одной минуты нереалистична.\nЗдесь предлагается расширить ответ на connect, добавив необязательное поле времени жизни соединения. Если поле отсутствует, значение по умолчанию — одна минута. В противном случае указанное в секундах время жизни должно использоваться клиентом, а трекер будет сохранять идентификатор соединения действительным еще на одну минуту сверх этого.\nСовместимость с BEP 15 Этот дизайн максимально сохраняет совместимость с BEP 15 , чтобы минимизировать изменения, необходимые в существующих клиентах и трекерах.\nЕдинственное обязательное изменение — формат информации о пирах в ответе на announce. Добавление поля lifetime в ответ на connect не является обязательным, но настоятельно рекомендуется для повышения эффективности, как объяснено выше.\nАнализ безопасности Важной целью протокола анонса по UDP является предотвращение подмены адресов. Клиент должен реально существовать и включать реальный leaseSet. У него должны быть входящие tunnels, чтобы получить Connect Response (ответ на соединение). Эти tunnels могли бы быть zero-hop (с нулевым числом хопов) и строиться мгновенно, но это раскрыло бы создателя. Этот протокол достигает этой цели.\nПроблемы Этот протокол не поддерживает blinded destinations (ослеплённые назначения), но может быть расширен для их поддержки. См. ниже.\nСпецификация Протоколы и порты Дейтаграммы с возможностью ответа Datagram2 используют протокол I2CP 19; дейтаграммы с возможностью ответа Datagram3 используют протокол I2CP 20; сырые дейтаграммы используют протокол I2CP 18. Запросы могут быть в формате Datagram2 или Datagram3. Ответы всегда в виде сырых дейтаграмм. Более старый формат отвечаемой дейтаграммы (\u0026ldquo;Datagram1\u0026rdquo;), использующий протокол I2CP 17, НЕ должен использоваться для запросов или ответов; такие сообщения должны быть отброшены, если они получены на портах запросов/ответов. Учтите, что формат Datagram1 с протоколом 17 всё ещё используется для протокола DHT (распределённая хеш-таблица).\nЗапросы используют значение I2CP \u0026ldquo;to port\u0026rdquo;, указанное в URL анонса; см. ниже. Параметр запроса \u0026ldquo;from port\u0026rdquo; выбирается клиентом, но должен быть ненулевым и отличаться от портов, используемых DHT, чтобы ответы можно было легко классифицировать. Трекеры должны отклонять запросы, полученные на неверном порту.\nОтветы используют I2CP \u0026ldquo;to port\u0026rdquo; (порт назначения) из запроса. Поле \u0026ldquo;from port\u0026rdquo; (порт источника) в ответе равно значению \u0026ldquo;to port\u0026rdquo; из запроса.\nURL-адрес анонса Формат URL анонса не определён в BEP 15 , но, как в clearnet (обычный Интернет), UDP-URL анонса имеют вид \u0026ldquo;udp://host:port/path\u0026rdquo;. Путь игнорируется и может быть пустым, но в clearnet обычно используется \u0026ldquo;/announce\u0026rdquo;. Часть :port всегда должна присутствовать; однако, если часть \u0026ldquo;:port\u0026rdquo; опущена, используйте порт I2CP по умолчанию 6969, так как это распространённый порт в clearnet. Также могут быть добавлены параметры CGI \u0026amp;a=b\u0026amp;c=d; их можно обработать и передать в запросе announce, см. BEP 41 . Если нет параметров или пути, завершающую / также можно опустить, как подразумевается в BEP 41 .\nФорматы датаграмм Все значения передаются в сетевом порядке байтов (big-endian). Не следует ожидать, что пакеты будут точно определённого размера. Будущие расширения могут увеличить размер пакетов.\nЗапрос на подключение От клиента к трекеру. 16 байт. Должен быть Datagram2 (датаграмма версии 2) с возможностью ответа. То же, что в BEP 15 . Без изменений.\nOffset Size Name Value 0 64-bit integer protocol_id 0x41727101980 // magic constant 8 32-bit integer action 0 // connect 12 32-bit integer transaction_id Ответ на подключение От трекера к клиенту. 16 или 18 байт. Должно быть в «сыром» виде. То же, что в BEP 15 , за исключением указанных ниже отличий.\nOffset Size Name Value 0 32-bit integer action 0 // connect 4 32-bit integer transaction_id 8 64-bit integer connection_id 16 16-bit integer lifetime optional // Change from BEP 15 Ответ ДОЛЖЕН быть отправлен на I2CP «to port», который был получен как «from port» в запросе.\nПоле lifetime является необязательным и указывает время жизни connection_id на стороне клиента в секундах. Значение по умолчанию — 60, минимальное (если задано) — 60. Максимум — 65535, то есть примерно 18 часов. Трекер должен сохранять connection_id на 60 секунд дольше, чем время жизни, указанное клиентом.\nЗапрос анонса От клиента к трекеру. Минимум 98 байт. Должен быть Datagram3 с возможностью ответа. То же, что в BEP 15 , за исключением оговоренных ниже отличий.\nconnection_id соответствует значению, полученному в ответе на connect.\nOffset Size Name Value 0 64-bit integer connection_id 8 32-bit integer action 1 // announce 12 32-bit integer transaction_id 16 20-byte string info_hash 36 20-byte string peer_id 56 64-bit integer downloaded 64 64-bit integer left 72 64-bit integer uploaded 80 32-bit integer event 0 // 0: none; 1: completed; 2: started; 3: stopped 84 32-bit integer IP address 0 // default, unused in I2P 88 32-bit integer key 92 32-bit integer num_want -1 // default 96 16-bit integer port // must be same as I2CP from port 98 varies options optional // As specified in BEP 41 Изменения по сравнению с BEP 15 :\nключ игнорируется IP-адрес не используется порт, вероятно, игнорируется, но должен совпадать с I2CP from port Раздел options, если он присутствует, определяется в BEP 41 Ответ ДОЛЖЕН быть отправлен на I2CP \u0026ldquo;to port\u0026rdquo;, который был получен в запросе в качестве \u0026ldquo;from port\u0026rdquo;. Не используйте порт из announce request (запроса announce).\nОтвет на announce От трекера к клиенту. Минимум 20 байт. Должно быть raw (без кодирования). То же, что в BEP 15 , за исключением отмеченного ниже.\nOffset Size Name Value 0 32-bit integer action 1 // announce 4 32-bit integer transaction_id 8 32-bit integer interval 12 32-bit integer leechers 16 32-bit integer seeders 20 32 * n 32-byte hash binary hashes // Change from BEP 15 ... // Change from BEP 15 Изменения по сравнению с BEP 15 :\nВместо 6-байтового формата IPv4+порт или 18-байтового формата IPv6+порт мы возвращаем последовательность 32-байтовых \u0026ldquo;compact responses\u0026rdquo; (компактные ответы) с бинарными хэшами пиров SHA-256. Как и в случае с TCP compact responses, мы не включаем порт. Ответ ДОЛЖЕН быть отправлен на I2CP \u0026ldquo;to port\u0026rdquo;, который был получен как \u0026ldquo;from port\u0026rdquo; запроса. Не используйте порт из announce-запроса.\nI2P датаграммы имеют очень большой максимальный размер — около 64 КБ; однако для надежной доставки следует избегать датаграмм больше 4 КБ. Для эффективного использования пропускной способности трекерам, вероятно, следует ограничить максимальное число пиров примерно до 50, что соответствует приблизительно 1600-байтному пакету до накладных расходов на различных уровнях и после фрагментации должно укладываться в лимит полезной нагрузки сообщения, проходящего через два tunnel.\nКак и в BEP 15, количество следующих адресов пиров (для BEP 15 — IP/port, здесь — хэши) не указывается. Хотя это не предусмотрено в BEP 15, можно определить маркер конца списка пиров, состоящий из одних нулей, который будет указывать на то, что информация о пирах завершена и далее следуют данные расширения.\nЧтобы в будущем было возможно расширение, клиентам следует игнорировать 32-байтовый хеш, состоящий из одних нулей, а также любые следующие за ним данные. Трекеры должны отклонять announce-запросы (запросы объявления на трекер) с хешем, состоящим из одних нулей, хотя такой хеш уже запрещён в Java routers.\nСкрейпинг Запрос/ответ scrape (операция запроса статистики у трекера) из BEP 15 не требуется этой спецификацией, но может быть реализован при желании, без каких-либо изменений. Клиент должен сначала получить идентификатор соединения. Запрос scrape всегда является repliable Datagram3 (тип Datagram3 с возможностью ответа). Ответ scrape всегда raw (тип без возможности ответа).\nОтвет об ошибке От трекера к клиенту. Минимум 8 байт (если сообщение пустое). Должно быть в виде сырых данных. То же, что в BEP 15 . Без изменений.\nOffset Size Name Value 0 32-bit integer action 3 // error 4 32-bit integer transaction_id 8 string message Расширения Биты расширений или поле версии не предусмотрены. Клиентам и трекерам не следует предполагать, что пакеты имеют определённый размер. Таким образом, можно добавлять дополнительные поля, не нарушая совместимость. При необходимости рекомендуется формат расширений, определённый в BEP 41 .\nОтвет на подключение изменён, чтобы добавить необязательный параметр времени жизни идентификатора соединения.\nЕсли требуется поддержка blinded destination (замаскированного адреса назначения), мы можем либо добавить blinded 35-байтный адрес в конец запроса announce, либо запрашивать blinded хэши в ответах, используя формат BEP 41 (параметры будут определены).\nНабор blinded 35-байтных адресов пиров может быть добавлен в конец ответа announce, после 32-байтного хеша из одних нулей.\nРекомендации по реализации См. раздел о проектировании выше, где обсуждаются проблемы, с которыми сталкиваются неинтегрированные клиенты и трекеры, не использующие I2CP.\nКлиенты Для данного имени хоста трекера клиенту следует предпочитать UDP‑URL вместо HTTP‑URL и не следует анонсироваться по обоим протоколам.\nКлиентам, уже поддерживающим BEP 15, потребуются лишь небольшие изменения.\nЕсли клиент поддерживает DHT или другие датаграммные протоколы, ему, вероятно, следует выбрать другой порт в качестве \u0026ldquo;from port\u0026rdquo; запроса, чтобы ответы возвращались на этот порт и не смешивались с сообщениями DHT. Клиент получает в качестве ответов только необработанные датаграммы. Трекеры никогда не отправят клиенту датаграмму с возможностью ответа2.\nКлиентам, использующим список opentrackers (открытые трекеры) по умолчанию, следует обновить этот список, добавив UDP URL-адреса после того, как будет подтверждено, что известные opentrackers поддерживают UDP.\nКлиенты могут как реализовывать, так и не реализовывать повторную отправку запросов. При наличии повторных отправок следует использовать начальный таймаут не менее 15 секунд и удваивать таймаут при каждой повторной отправке (экспоненциальная задержка).\nКлиенты должны выполнить back off (увеличить задержку перед повторной попыткой) после получения ответа с ошибкой.\nТрекеры Трекерам с уже реализованной поддержкой BEP 15 потребуются лишь небольшие изменения. Эта спецификация отличается от предложения 2014 года тем, что трекер должен поддерживать приём repliable (с возможностью ответа) datagram2 и datagram3 на одном и том же порту.\nЧтобы минимизировать требования к ресурсам трекера, этот протокол разработан так, чтобы устранить необходимость в хранении трекером соответствий между хэшами клиентов и идентификаторами соединений для последующей проверки. Это возможно, поскольку пакет запроса announce (запрос к трекеру для регистрации клиента) является пакетом Datagram3 (тип датаграммы в I2P), на который можно ответить, поэтому он содержит хэш отправителя.\nРекомендуемая реализация следующая:\nОпределите текущую эпоху как текущее время с шагом, равным времени жизни соединения, epoch = now / lifetime. Определите криптографическую хэш‑функцию H(secret, clienthash, epoch), которая генерирует значение длиной 8 байт. Сгенерируйте случайный постоянный секрет, используемый для всех соединений. Для ответов на подключение сгенерируйте connection_id = H(secret, clienthash, epoch) Для запросов announce проверьте полученный идентификатор соединения в текущей эпохе, проверив, что connection_id == H(secret, clienthash, epoch) || connection_id == H(secret, clienthash, epoch - 1) Статус развертывания Этот протокол был утверждён 24 июня 2025 года и полностью функционирует в сети I2P по состоянию на сентябрь 2025 года.\nТекущие реализации i2psnark: Полная поддержка UDP‑трекеров включена в I2P версии 2.10.0 (API 0.9.67), выпущенной 8 сентября 2025 года. Начиная с этой версии, все установки I2P по умолчанию включают поддержку UDP‑трекеров.\nzzzot tracker: Начиная с версии 0.20.0-beta2 поддерживаются UDP-анонсы. По состоянию на октябрь 2025 года в продакшене работают следующие трекеры: - opentracker.dg2.i2p - opentracker.simp.i2p - opentracker.skank.i2p\nПримечания по совместимости клиента Ограничения SAM v3.3: Внешние BitTorrent-клиенты, использующие SAM (Simple Anonymous Messaging), требуют поддержки Datagram2/3 (режимов датаграммной передачи без установления соединения) в SAM v3.3. Это доступно в Java I2P, но в настоящее время не поддерживается i2pd (реализация I2P на C++), что может ограничивать распространение среди клиентов на базе libtorrent, таких как qBittorrent.\nКлиенты I2CP: Клиенты, использующие I2CP напрямую (например, BiglyBT), могут реализовать поддержку UDP-трекеров без ограничений SAM.\nСсылки [BEP15]: Протокол UDP-трекера BitTorrent [BEP41]: Расширения протокола UDP-трекера [DATAGRAMS]: Спецификация датаграмм I2P [Prop160]: Предложение по UDP-трекерам [Prop163]: Предложение Datagram2 [SPEC]: BitTorrent поверх I2P ","description":"Спецификация протокола для announce-запросов (запросов клиента к трекеру) UDP-трекера BitTorrent в I2P","id":"2413d642663e185a8a31352c9a9e8f28","section":"docs","title":"UDP-анонсы BitTorrent","url":"/ru/docs/specs/udp-bittorrent-announces/"},{"categories":null,"content":" Статус: Это краткое справочное руководство по утилите v3dgsend. Оно дополняет документацию по API датаграмм и SAM v3 .\nОбзор v3dgsend — это утилита командной строки для отправки I2P-датаграмм через интерфейс SAMv3. Она полезна для тестирования доставки датаграмм, создания прототипов сервисов и проверки сквозного поведения без написания полноценного клиента.\nТипичные варианты использования включают:\nДымовое тестирование достижимости датаграмм до Destination Проверка конфигурации файрвола и адресной книги Эксперименты с сырыми и подписанными (с возможностью ответа) датаграммами Использование Базовый способ запуска зависит от платформы и способа установки. Общие варианты включают:\nDestination: base64 Destination или имя .i2p Protocol: raw (PROTOCOL 18) или signed (PROTOCOL 17) Payload: встроенная строка или входной файл Обратитесь к документации пакетов вашего дистрибутива или к выводу --help для получения точных флагов.\nСм. также Datagram API SAM v3 Streaming Library (альтернатива датаграммам) ","description":"Утилита командной строки для отправки I2P датаграмм через SAM v3","id":"3fe6f64806c4c692f530bf7fa6eb9c45","section":"docs","title":"v3dgsend","url":"/ru/docs/api/v3dgsend/"},{"categories":null,"content":"Основная реализация клиента I2P использует Java. Если вы не можете или предпочитаете не использовать Java на конкретной системе, существуют альтернативные реализации клиента I2P, разработанные и поддерживаемые членами сообщества. Эти программы обеспечивают ту же базовую функциональность, используя различные языки программирования или подходы.\nТаблица сравнения Client Language Maturity Actively Maintained Suitable For Notes Java I2P Java Stable ✅ Yes (official) General users Standard full router; includes console, plugins, and tools i2pd C++ Stable ✅ Yes Low-resource systems, servers Lightweight, fully compatible with Java I2P, includes web console Go-I2P Go Experimental ⚙️ In development Developers, testing Early-stage Go implementation; not yet production ready I2P+ Java Stable (fork) ✅ Yes Advanced users Enhanced Java I2P fork with UI and performance improvements --- i2pd (C++) Веб-сайт: https://i2pd.website Описание: i2pd (I2P Daemon) — это полнофункциональный I2P-клиент, реализованный на C++. Он стабилен для промышленного использования уже много лет (примерно с 2016 года) и активно поддерживается сообществом. i2pd полностью реализует сетевые протоколы и API I2P, что делает его полностью совместимым с Java-версией сети I2P. Этот C++ router часто используется как легковесная альтернатива на системах, где среда выполнения Java недоступна или нежелательна. i2pd включает встроенную веб-консоль для конфигурации и мониторинга. Он кроссплатформенный и доступен во многих форматах пакетов — существует даже Android-версия i2pd (например, через F-Droid).\nGo-I2P (Go) Репозиторий: https://github.com/go-i2p/go-i2p Описание: Go-I2P — это I2P-клиент, написанный на языке программирования Go. Это независимая реализация I2P router, нацеленная на использование эффективности и переносимости Go. Проект находится в активной разработке, но всё ещё на ранней стадии и не имеет полного набора функций. По состоянию на 2025 год Go-I2P считается экспериментальным — над ним активно работают разработчики сообщества, но он не рекомендуется для использования в продакшене до дальнейшего созревания. Цель Go-I2P — предоставить современный, легковесный I2P router с полной совместимостью с сетью I2P после завершения разработки.\nI2P+ (форк на Java) Веб-сайт: https://i2pplus.github.io Описание: I2P+ — это поддерживаемый сообществом форк стандартного Java-клиента I2P. Это не новая реализация на другом языке программирования, а расширенная версия Java router с дополнительными функциями и оптимизациями. I2P+ фокусируется на улучшенном пользовательском опыте и более высокой производительности, оставаясь при этом полностью совместимым с официальной сетью I2P. Он представляет обновлённый интерфейс веб-консоли, более удобные параметры конфигурации и различные оптимизации (например, улучшенную производительность торрентов и более эффективную обработку сетевых пиров, особенно для роутеров за файрволами). I2P+ требует Java-окружения точно так же, как и официальное программное обеспечение I2P, поэтому это не решение для сред без Java. Однако для пользователей, у которых есть Java и которые хотят альтернативную сборку с дополнительными возможностями, I2P+ предоставляет привлекательный вариант. Этот форк поддерживается в актуальном состоянии с upstream-релизами I2P (с добавлением «+» к номеру версии) и может быть получен с веб-сайта проекта.\n","description":"Поддерживаемые сообществом реализации I2P-клиентов (обновлено на 2025 год)","id":"fdcfc5a7a482cf9fe8fe449e9198b146","section":"docs","title":"Альтернативные клиенты I2P","url":"/ru/docs/overview/alternative-clients/"},{"categories":null,"content":" Устарело: Библиотека ministreaming предшествует современной потоковой библиотеке . Современные приложения должны использовать полный streaming API или SAM v3. Приведенная ниже информация сохранена для разработчиков, изучающих устаревший исходный код, поставляемый в ministreaming.jar.\nОбзор Ministreaming (минималистичный потоковый протокол) работает поверх I2CP , обеспечивая надёжную доставку с сохранением порядка на уровне сообщений I2P — подобно TCP поверх IP. Изначально он был выделен из раннего приложения I2PTunnel (под лицензией BSD), чтобы альтернативные транспорты могли развиваться независимо.\nКлючевые ограничения проектирования:\nКлассическая двухэтапная установка соединения (SYN/ACK/FIN), заимствованная из протокола TCP Фиксированный размер окна — 1 пакет Отсутствуют идентификаторы для каждого пакета и выборочные подтверждения Эти решения позволили сохранить реализацию компактной, но ограничивают пропускную способность — каждый пакет обычно ждёт почти два RTT (время туда-обратно), прежде чем будет отправлен следующий. Для долгоживущих потоков эта цена приемлема, но короткие обмены в стиле HTTP заметно страдают.\nСвязь с потоковой библиотекой Текущая библиотека потоковой передачи расположена в том же пакете Java (net.i2p.client.streaming). Устаревшие классы и методы остаются в Javadoc и чётко помечены, чтобы разработчики могли распознавать API периода ministreaming (ранняя минимальная реализация потоковой библиотеки). Когда потоковая библиотека заменила ministreaming, она добавила:\nБолее эффективная установка соединения с меньшим числом проходов туда-обратно Адаптивные окна перегрузки и логика ретрансляции Лучшая производительность поверх tunnels с потерями Когда Ministreaming (упрощённый протокол потоковой передачи в I2P) был полезен? Несмотря на свои ограничения, ministreaming (минималистичная подсистема потоковой передачи) обеспечивал надежный транспорт в самых ранних развертываниях. API было намеренно небольшим и устойчивым к будущим изменениям, чтобы альтернативные движки потоковой передачи можно было подменять, не ломая код вызывающих компонентов. Приложения на Java подключали его напрямую; клиенты, не на Java, получали доступ к той же функциональности через поддержку SAM для потоковых сеансов.\nСегодня ministreaming.jar следует рассматривать лишь как слой совместимости. При новой разработке следует:\nОриентируйтесь на полную streaming library (библиотека потоков I2P, Java) или SAM v3 (стиль STREAM) Удалите любые сохраняющиеся допущения о фиксированном размере окна при модернизации кода Предпочитайте большие размеры окна и оптимизированные рукопожатия при установлении соединения, чтобы улучшить работу нагрузок, чувствительных к задержкам Справочник Документация библиотеки Streaming Javadoc для Streaming – включает устаревшие классы ministreaming Спецификация SAM v3 – поддержка Streaming для приложений, не написанных на Java Если вы сталкиваетесь с кодом, который всё ещё зависит от ministreaming (устаревшая упрощённая потоковая подсистема), планируйте перенос на современный потоковый API — сеть и её инструменты ожидают обновлённого поведения.\n","description":"Исторические заметки о первом TCP‑подобном транспортном уровне I2P","id":"3a258127f502d1974fadc514a60bf831","section":"docs","title":"Библиотека Ministreaming (минималистичная библиотека для потоковой передачи данных)","url":"/ru/docs/legacy/ministreaming/"},{"categories":null,"content":"Что такое I2P? Invisible Internet Project (I2P) — это анонимный сетевой уровень, который обеспечивает устойчивую к цензуре одноранговую коммуникацию. Анонимные соединения достигаются путем шифрования трафика пользователя и его передачи через распределенную сеть, управляемую волонтерами по всему миру.\nКлючевые функции Anonymity I2P скрывает как отправителя, так и получателя сообщений. В отличие от традиционных интернет-соединений, где ваш IP-адрес виден веб-сайтам и сервисам, I2P использует множество уровней шифрования и маршрутизации для сохранения конфиденциальности вашей личности.\nDecentralization В I2P нет центрального органа управления. Сеть поддерживается добровольцами, которые предоставляют пропускную способность и вычислительные ресурсы. Это делает её устойчивой к цензуре и единым точкам отказа.\nАнонимность Весь трафик внутри I2P шифруется end-to-end. Сообщения шифруются многократно по мере прохождения через сеть, аналогично тому, как работает Tor, но с важными отличиями в реализации.\nHow It Works Децентрализация I2P использует \u0026ldquo;туннели\u0026rdquo; для маршрутизации трафика. Когда вы отправляете или получаете данные:\nВаш роутер создаёт исходящий туннель (для отправки) Ваш роутер создаёт входящий туннель (для получения) Сообщения шифруются и отправляются через несколько роутеров Каждый роутер знает только предыдущий и следующий узел, но не весь путь целиком Сквозное шифрование I2P улучшает традиционную луковую маршрутизацию с помощью «garlic routing» (чесночной маршрутизации):\nНесколько сообщений могут быть объединены вместе (как дольки в головке чеснока) Это обеспечивает лучшую производительность и дополнительную анонимность Затрудняет анализ трафика Network Database I2P поддерживает распределённую сетевую базу данных, содержащую:\nИнформация о роутере Адреса назначения (аналогично сайтам .i2p) Зашифрованные данные маршрутизации Common Use Cases Туннели Размещайте или посещайте веб-сайты с доменом .i2p — они доступны только внутри сети I2P и обеспечивают надёжные гарантии анонимности как для хостов, так и для посетителей.\nGarlic Routing Обменивайтесь файлами анонимно с помощью BitTorrent через I2P. Многие торрент-приложения имеют встроенную поддержку I2P.\nБаза данных сети Отправляйте и получайте анонимную электронную почту с помощью I2P-Bote или других почтовых приложений, разработанных для I2P.\nMessaging Используйте IRC, мгновенный обмен сообщениями или другие инструменты связи приватно через сеть I2P.\nGetting Started Готовы попробовать I2P? Посетите нашу страницу загрузок , чтобы установить I2P на вашу систему.\nДля получения более подробной технической информации см. Техническое введение или изучите полную документацию .\nКак это работает Техническое введение - Более глубокие технические концепции Модель угроз - Понимание модели безопасности I2P Сравнение с Tor - Чем I2P отличается от Tor Криптография - Детали криптографических алгоритмов I2P ","description":"Менее техническое введение в анонимную сеть I2P","id":"b4dafae75d4a04b2eac73ebf531f1d1b","section":"docs","title":"Введение в I2P","url":"/ru/docs/overview/intro/"},{"categories":null,"content":"Встраивание I2P в ваше приложение — мощный способ привлечь пользователей, но только если router настроен ответственно.\n1. Координация с командами разработчиков роутеров Свяжитесь с разработчиками Java I2P и i2pd перед интеграцией. Они могут проверить ваши настройки по умолчанию и указать на проблемы совместимости. Выберите реализацию router, которая подходит для вашего стека: Java/Scala → Java I2P C/C++ → i2pd Другие языки → интегрируйте router и подключайтесь через SAM v3 или I2CP Проверьте условия распространения для бинарных файлов router и зависимостей (среда выполнения Java, ICU и т.д.). 2. Рекомендуемые значения конфигурации по умолчанию Стремитесь «вносить больше вклада, чем потреблять». Современные настройки по умолчанию приоритизируют здоровье и стабильность сети.\nSetting Recommended Default (2025) Bandwidth share 80% for participating tunnels Tunnel quantities i2pd: 3 inbound / 3 outbound; Java I2P: 2 inbound / 2 outbound. Signature \u0026amp; encryption Use Ed25519 (SIGNATURE_TYPE=7) and advertise ECIES-X25519 + ElGamal (i2cp.leaseSetEncType=4,0). Client protocols Use SAM v3 or I2CP. API listeners Bind SAM/I2CP to 127.0.0.1 only. Disable if not needed. UI toggles Expose bandwidth controls, logs, and an opt-in checkbox for participating tunnels. ### Участвующие туннели остаются важными Не отключайте участие в туннелях.\nРоутеры, которые не ретранслируют трафик, работают хуже сами. Сеть зависит от добровольного предоставления пропускной способности. Маскирующий трафик (ретранслируемый трафик) улучшает анонимность. Официальные минимумы: - Общая пропускная способность: ≥ 12 КБ/с - Автоматическое включение floodfill: ≥ 128 КБ/с - Рекомендуется: 2 входящих / 2 исходящих tunnel (значение по умолчанию в Java I2P)\n3. Постоянство и пересев (reseeding) Директории постоянного состояния (netDb/, профили, сертификаты) должны сохраняться между запусками.\nБез сохранения состояния ваши пользователи будут запускать reseed при каждом старте — что ухудшит производительность и увеличит нагрузку на reseed-серверы.\nЕсли сохранение данных невозможно (например, контейнеры или временные установки):\nВключите 1 000–2 000 router info в установщик. Используйте один или несколько собственных reseed-серверов, чтобы снизить нагрузку на публичные. Конфигурационные переменные: - Базовая директория: i2p.dir.base - Директория конфигурации: i2p.dir.config - Включает certificates/ для reseed (повторного заполнения базы данных сети).\n4. Безопасность и уязвимости Держите консоль router (127.0.0.1:7657) только для локального доступа. Используйте HTTPS при внешнем доступе к интерфейсу. Отключите внешние SAM/I2CP, если они не требуются. Проверьте включенные плагины — поставляйте только те, которые поддерживает ваше приложение. Всегда включайте аутентификацию для удаленного доступа к консоли. Функции безопасности, представленные начиная с версии 2.5.0: - Изоляция NetDB между приложениями (2.4.0+) - Защита от DoS-атак и блок-листы Tor (2.5.1) - Устойчивость NTCP2 к зондированию (2.9.0) - Улучшения в выборе floodfill-роутеров (2.6.0+)\n5. Поддерживаемые API (2025) API Status Notes SAM v3 (3.3) ✅ Active Recommended bridge for non-Java apps. I2CP ✅ Active Stable protocol core, used internally by Java I2P. I2PControl ✅ Active JSON-RPC API; plugin maintained. BOB ⚠️ Deprecated Removed from Java I2P since 1.7.0; use SAM v3 instead. Вся официальная документация находится в `/docs/api/` — старый путь `/spec/samv3/` **не существует**. 6. Сеть и порты Типичные порты по умолчанию: - 4444 – HTTP прокси - 4445 – HTTPS прокси - 7654 – I2CP - 7656 – SAM Bridge - 7657 – Консоль роутера - 7658 – Локальный I2P сайт - 6668 – IRC прокси - 9000–31000 – Случайный порт роутера (UDP/TCP входящий)\nМаршрутизаторы выбирают случайный входящий порт при первом запуске. Проброс портов улучшает производительность, но UPnP может обработать это автоматически.\n7. Современные изменения (2024–2025) Change Status Details SSU1 Transport Removed SSU2 is now the exclusive UDP transport. I2P-over-Tor Blocked Since 2.6.0 (July 2024). Datagram2/3 Added Authenticated, repliable datagram formats (2.9.0). LeaseSet service records Added Enables service discovery (Proposal 167). Tunnel build parameters Improved Adaptive congestion handling (2.9.0+). Post-quantum crypto Introduced (beta) ML-KEM hybrid ratchet, opt-in from 2.10.0. Java 17 requirement Announced Becomes mandatory in 2.11.0 (early 2026). ## 8. Пользовательский опыт и тестирование Объяснить, что делает I2P и почему пропускная способность является общим ресурсом. Предоставить диагностику router (пропускная способность, tunnel, статус reseed). Протестировать сборки на Windows, macOS и Linux (включая системы с малым объемом RAM). Проверить совместимость с узлами Java I2P и i2pd. Протестировать восстановление после обрывов сети и некорректных завершений работы. 9. Ресурсы сообщества Форум: i2pforum.net или http://i2pforum.i2p внутри I2P. Код: i2pgit.org/I2P_Developers/i2p.i2p . IRC (сеть Irc2P): #i2p-dev, #i2pd. #i2papps не подтверждён; возможно, не существует. Уточните, какая сеть (Irc2P или ilita.i2p) размещает ваш канал. Ответственное встраивание означает баланс между пользовательским опытом, производительностью и вкладом в сеть. Используйте эти настройки по умолчанию, поддерживайте синхронизацию с разработчиками router и тестируйте под реальной нагрузкой перед релизом.\n","description":"Обновленное практическое руководство по ответственной интеграции I2P router в ваше приложение","id":"f67f27efbc9bb7bff8d34001c14105ff","section":"docs","title":"Встраивание I2P в ваше приложение","url":"/ru/docs/applications/embedding/"},{"categories":null,"content":"Статус реализации Текущее развертывание: - i2pd (реализация на C++): Полностью реализовано в версии 2.58.0 (сентябрь 2025) с поддержкой ML-KEM-512, ML-KEM-768 и ML-KEM-1024. Постквантовое сквозное шифрование включено по умолчанию при наличии OpenSSL 3.5.0 или новее. - Java I2P: Еще не реализовано на момент версий 0.9.67 / 2.10.0 (сентябрь 2025). Спецификация утверждена, реализация запланирована для будущих релизов.\nВ этой спецификации описана утверждённая функциональность, которая в настоящее время внедрена в i2pd и планируется к внедрению в реализациях Java I2P.\nОбзор Это постквантовый гибридный вариант протокола ECIES-X25519-AEAD-Ratchet ECIES . Он представляет собой первую фазу Предложения 169 Prop169 , вынесенную на утверждение. Общие цели, модели угроз, анализ, альтернативы и дополнительную информацию см. в указанном предложении.\nСтатус предложения 169: Открыто (первая фаза утверждена для реализации гибридной ECIES (схемы интегрированного шифрования на эллиптических кривых)).\nЭта спецификация содержит только отличия от стандартной ECIES и должна читаться совместно с указанной спецификацией.\nПроектирование Мы используем стандарт NIST FIPS 203 FIPS203 , который основан на CRYSTALS-Kyber (постквантовый KEM-алгоритм; версии 3.1, 3 и более ранние), но с ним не совместим.\nГибридные рукопожатия объединяют классический X25519 Diffie-Hellman с постквантовыми механизмами капсулирования ключей ML-KEM (постквантовый механизм капсулирования ключей, ранее известный как Kyber). Этот подход основан на концепциях гибридной прямой секретности, описанных в исследовании PQNoise и аналогичных реализациях в TLS 1.3, IKEv2 и WireGuard.\nОбмен ключами Мы определяем гибридный обмен ключами для Ratchet (механизма ратчета). Постквантовая KEM (механизм капсуляции ключей) предоставляет только эфемерные ключи и напрямую не поддерживает рукопожатия со статическими ключами, такие как Noise IK.\nМы определяем три варианта ML-KEM (механизм капсуляции ключей на базе модульных решеток) как определено в FIPS203 , что в итоге дает три новых типа шифрования. Гибридные типы определены только в сочетании с X25519.\nНовые типы шифрования:\nType Code Security Level ML-KEM Variant MLKEM512_X25519 5 NIST Category 1 (AES-128 equivalent) ML-KEM-512 MLKEM768_X25519 6 NIST Category 3 (AES-192 equivalent) ML-KEM-768 (Recommended) MLKEM1024_X25519 7 NIST Category 5 (AES-256 equivalent) ML-KEM-1024 **Примечание:** MLKEM768_X25519 (тип 6) — рекомендуемый вариант по умолчанию, обеспечивающий надёжную постквантовую безопасность при разумных накладных расходах. Накладные расходы значительны по сравнению с шифрованием только на X25519. Типичные размеры сообщений 1 и 2 (для IK pattern — шаблон IK в протоколе Noise) сейчас составляют около 96–103 байт (без дополнительной полезной нагрузки). Это увеличится примерно в 9–12 раз для MLKEM512, в 13–16 раз для MLKEM768 и в 17–23 раза для MLKEM1024, в зависимости от типа сообщения.\nТребуется новая криптография ML-KEM (ранее CRYSTALS-Kyber) FIPS203 - Стандарт механизма инкапсуляции ключей на основе модульных решёток SHA3-256 (ранее Keccak-512) FIPS202 - Часть стандарта SHA-3 SHAKE128 and SHAKE256 (расширения XOF (функции с расширяемой длиной выхода) к SHA3) FIPS202 - Функции с расширяемой длиной выхода Тестовые векторы для SHA3-256, SHAKE128 и SHAKE256 доступны в Программе по валидации криптографических алгоритмов NIST .\nПоддержка библиотек: - Java: библиотека Bouncycastle версии 1.79 и новее поддерживает все варианты ML-KEM и функции SHA3/SHAKE - C++: OpenSSL 3.5 и новее включает полную поддержку ML-KEM (релиз: апрель 2025 года) - Go: Доступно несколько библиотек для реализации ML-KEM и SHA3\nСпецификация Общие структуры См. спецификацию общих структур для сведений о длинах ключей и идентификаторах.\nШаблоны рукопожатия Рукопожатия используют шаблоны рукопожатий Noise Protocol Framework с адаптациями, специфичными для I2P, обеспечивающими гибридную постквантовую безопасность.\nИспользуется следующее сопоставление букв:\ne = одноразовый эфемерный ключ (X25519) s = статический ключ p = полезная нагрузка сообщения e1 = одноразовый эфемерный PQ (постквантовый) ключ, отправляемый от Алисы Бобу (токен, специфичный для I2P) ekem1 = шифротекст KEM (механизм инкапсуляции ключа), отправляемый от Боба Алисе (токен, специфичный для I2P) Важное примечание: Имена шаблонов \u0026ldquo;IKhfs\u0026rdquo; и \u0026ldquo;IKhfselg2\u0026rdquo; и токены \u0026ldquo;e1\u0026rdquo; и \u0026ldquo;ekem1\u0026rdquo; — это I2P-специфичные адаптации, не задокументированные в официальной спецификации Noise Protocol Framework (фреймворк протокола Noise). Они представляют собой нестандартные определения для интеграции ML-KEM в шаблон Noise IK. Хотя гибридный подход X25519 + ML-KEM широко признан в исследованиях по постквантовой криптографии и других протоколах, используемая здесь специфическая терминология является I2P-специфичной.\nПрименяются следующие модификации к IK (шаблон рукопожатия Noise IK) для обеспечения гибридной прямой секретности:\nStandard IK: I2P IKhfs (Hybrid): \u0026lt;- s \u0026lt;- s ... ... -\u0026gt; e, es, s, ss, p -\u0026gt; e, es, e1, s, ss, p \u0026lt;- e, ee, se, p \u0026lt;- e, ee, ekem1, se, p \u0026lt;- p \u0026lt;- p p -\u0026gt; p -\u0026gt; Note: e1 and ekem1 are encrypted within ChaCha20-Poly1305 AEAD blocks. Note: e1 (ML-KEM public key) and ekem1 (ML-KEM ciphertext) have different sizes. Шаблон e1 определяется следующим образом:\nFor Alice (sender): (encap_key, decap_key) = PQ_KEYGEN() // EncryptAndHash(encap_key) ciphertext = ENCRYPT(k, n, encap_key, ad) n++ MixHash(ciphertext) For Bob (receiver): // DecryptAndHash(ciphertext) encap_key = DECRYPT(k, n, ciphertext, ad) n++ MixHash(ciphertext) Шаблон ekem1 определяется следующим образом:\nFor Bob (receiver of encap_key): (kem_ciphertext, kem_shared_key) = ENCAPS(encap_key) // EncryptAndHash(kem_ciphertext) ciphertext = ENCRYPT(k, n, kem_ciphertext, ad) MixHash(ciphertext) // MixKey MixKey(kem_shared_key) For Alice (sender of encap_key): // DecryptAndHash(ciphertext) kem_ciphertext = DECRYPT(k, n, ciphertext, ad) MixHash(ciphertext) // MixKey kem_shared_key = DECAPS(kem_ciphertext, decap_key) MixKey(kem_shared_key) Определённые операции ML-KEM (механизм капсулирования ключей на основе модульных решёток) Мы определяем следующие функции, соответствующие криптографическим примитивам, определённым в FIPS203 .\n(encap_key, decap_key) = PQ_KEYGEN() : Алиса создаёт ключи инкапсуляции и декапсуляции. Ключ инкапсуляции отправляется в сообщении NS. Размеры ключей: - ML-KEM-512: encap_key = 800 байт, decap_key = 1632 байт - ML-KEM-768: encap_key = 1184 байт, decap_key = 2400 байт - ML-KEM-1024: encap_key = 1568 байт, decap_key = 3168 байт\n(ciphertext, kem_shared_key) = ENCAPS(encap_key) : Боб вычисляет шифртекст и общий ключ, используя ключ инкапсуляции, полученный в сообщении NS. Шифртекст отправляется в сообщении NSR. Размеры шифртекста: - ML-KEM-512: 768 байт - ML-KEM-768: 1088 байт - ML-KEM-1024: 1568 байт\nkem_shared_key всегда имеет длину 32 байта для всех трёх вариантов.\nkem_shared_key = DECAPS(ciphertext, decap_key) : Алиса вычисляет общий ключ, используя ciphertext, полученный в сообщении NSR. Значение kem_shared_key всегда равно 32 байта.\nВажно: И encap_key, и шифртекст зашифрованы внутри блоков ChaCha20-Poly1305 в сообщениях 1 и 2 рукопожатия Noise. Они будут расшифрованы как часть процесса рукопожатия.\nkem_shared_key смешивается в цепной ключ с помощью MixKey(). Подробности см. ниже.\nKDF (функция выработки ключа) рукопожатия Noise Обзор Гибридное рукопожатие сочетает классический X25519 ECDH с постквантовой ML-KEM (механизм инкапсуляции ключей). Первое сообщение, от Алисы к Бобу, содержит e1 (ключ инкапсуляции ML-KEM) перед полезной нагрузкой сообщения. Это рассматривается как дополнительный ключевой материал; вызовите EncryptAndHash() для него (со стороны Алисы) или DecryptAndHash() (со стороны Боба). Затем обработайте полезную нагрузку сообщения как обычно.\nВторое сообщение, от Боба к Алисе, содержит ekem1 (шифротекст ML-KEM) перед полезной нагрузкой сообщения. Это рассматривается как дополнительный ключевой материал; примените EncryptAndHash() к нему (со стороны Боба) или DecryptAndHash() (со стороны Алисы). Затем вычислите kem_shared_key и вызовите MixKey(kem_shared_key). Затем обработайте полезную нагрузку сообщения как обычно.\nИдентификаторы Noise (криптографический протокол) Это строки инициализации Noise (специфичные для I2P):\nNoise_IKhfselg2_25519+MLKEM512_ChaChaPoly_SHA256 Noise_IKhfselg2_25519+MLKEM768_ChaChaPoly_SHA256 Noise_IKhfselg2_25519+MLKEM1024_ChaChaPoly_SHA256 KDF Алисы для сообщения NS После шаблона сообщения \u0026rsquo;es\u0026rsquo; и перед шаблоном сообщения \u0026rsquo;s\u0026rsquo; добавьте:\nThis is the \u0026#34;e1\u0026#34; message pattern: (encap_key, decap_key) = PQ_KEYGEN() // EncryptAndHash(encap_key) // AEAD parameters k = keydata[32:63] n = 0 ad = h ciphertext = ENCRYPT(k, n, encap_key, ad) n++ // MixHash(ciphertext) h = SHA256(h || ciphertext) End of \u0026#34;e1\u0026#34; message pattern. NOTE: For the next section (payload for XK or static key for IK), the keydata and chain key remain the same, and n now equals 1 (instead of 0 for non-hybrid). Bob KDF для сообщения NS После шаблона сообщения \u0026rsquo;es\u0026rsquo; и перед шаблоном сообщения \u0026rsquo;s\u0026rsquo; добавьте:\nThis is the \u0026#34;e1\u0026#34; message pattern: // DecryptAndHash(encap_key_section) // AEAD parameters k = keydata[32:63] n = 0 ad = h encap_key = DECRYPT(k, n, encap_key_section, ad) n++ // MixHash(encap_key_section) h = SHA256(h || encap_key_section) End of \u0026#34;e1\u0026#34; message pattern. NOTE: For the next section (payload for XK or static key for IK), the keydata and chain key remain the same, and n now equals 1 (instead of 0 for non-hybrid). KDF (функция выработки ключей) Боба для сообщения NSR После шаблона сообщения \u0026rsquo;ee\u0026rsquo; и перед шаблоном сообщения \u0026lsquo;se\u0026rsquo; добавьте:\nThis is the \u0026#34;ekem1\u0026#34; message pattern: (kem_ciphertext, kem_shared_key) = ENCAPS(encap_key) // EncryptAndHash(kem_ciphertext) // AEAD parameters k = keydata[32:63] n = 0 ad = h ciphertext = ENCRYPT(k, n, kem_ciphertext, ad) // MixHash(ciphertext) h = SHA256(h || ciphertext) // MixKey(kem_shared_key) keydata = HKDF(chainKey, kem_shared_key, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] End of \u0026#34;ekem1\u0026#34; message pattern. KDF Алисы для сообщения NSR После шаблона сообщения \u0026rsquo;ee\u0026rsquo; и перед шаблоном сообщения \u0026lsquo;ss\u0026rsquo; добавьте:\nThis is the \u0026#34;ekem1\u0026#34; message pattern: // DecryptAndHash(kem_ciphertext_section) // AEAD parameters k = keydata[32:63] n = 0 ad = h kem_ciphertext = DECRYPT(k, n, kem_ciphertext_section, ad) // MixHash(kem_ciphertext_section) h = SHA256(h || kem_ciphertext_section) // MixKey(kem_shared_key) kem_shared_key = DECAPS(kem_ciphertext, decap_key) keydata = HKDF(chainKey, kem_shared_key, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] End of \u0026#34;ekem1\u0026#34; message pattern. KDF (функция выработки ключа) для split() Функция split() остаётся неизменной по сравнению со стандартной спецификацией ECIES (схема интегрированного шифрования на эллиптических кривых). После завершения рукопожатия:\nkeydata = HKDF(chainKey, ZEROLEN, \u0026#34;\u0026#34;, 64) k_ab = keydata[0:31] k_ba = keydata[32:63] Это двунаправленные сеансовые ключи для продолжающегося обмена данными.\nФормат сообщения Формат NS (New Session — новая сессия) Изменения: Текущий ratchet (механизм ратчета) содержит статический ключ в первом разделе ChaCha20-Poly1305, а полезную нагрузку — во втором разделе. При использовании ML-KEM (схема согласования ключей на модульных решётках) теперь три раздела. В первом разделе находится зашифрованный открытый ключ ML-KEM (encap_key). Во втором разделе находится статический ключ. В третьем разделе находится полезная нагрузка.\nРазмеры сообщений:\nType Type Code X25519 len NS len NS Enc len NS Dec len PQ key len pl len X25519 4 32 96+pl 64+pl pl -- pl MLKEM512_X25519 5 32 912+pl 880+pl 800+pl 800 pl MLKEM768_X25519 6 32 1296+pl 1264+pl 1184+pl 1184 pl MLKEM1024_X25519 7 32 1680+pl 1648+pl 1568+pl 1568 pl **Примечание:** Полезная нагрузка должна содержать блок DateTime (не менее 7 байт: 1 байт — тип, 2 байта — размер, 4 байта — временная метка). Соответственно могут быть рассчитаны минимальные размеры NS. Таким образом, минимальный практический размер NS составляет 103 байта для X25519, а для гибридных вариантов лежит в диапазоне от 919 до 1687 байт. Увеличения размера на 816, 1200 и 1584 байт для трёх вариантов ML-KEM объясняются тем, что они включают публичный ключ ML-KEM и 16-байтовый Poly1305 MAC для аутентифицированного шифрования.\nФормат NSR (New Session Reply — ответ на новый сеанс) Изменения: В текущем ratchet (механизм обновления ключей) первая секция ChaCha20-Poly1305 содержит пустую полезную нагрузку, а полезная нагрузка находится во второй секции. С ML-KEM теперь три секции. Первая секция содержит зашифрованный шифртекст ML-KEM. Вторая секция имеет пустую полезную нагрузку. Третья секция содержит полезную нагрузку.\nРазмеры сообщений:\nType Type Code X25519 len NSR len NSR Enc len NSR Dec len PQ ct len pl len X25519 4 32 72+pl 40+pl pl -- pl MLKEM512_X25519 5 32 856+pl 824+pl 784+pl 768 pl MLKEM768_X25519 6 32 1176+pl 1144+pl 1104+pl 1088 pl MLKEM1024_X25519 7 32 1656+pl 1624+pl 1584+pl 1568 pl Увеличения размера на 784, 1104 и 1584 байта для трёх вариантов ML-KEM обусловлены тем, что они включают шифротекст ML-KEM и 16-байтовый Poly1305 MAC (код аутентификации сообщения) для аутентифицированного шифрования. Анализ накладных расходов Обмен ключами Накладные расходы гибридного шифрования существенны по сравнению с использованием только X25519:\nMLKEM512_X25519: Примерное увеличение размера сообщения рукопожатия в 9-12x (NS: 9.5x, NSR: 11.9x) MLKEM768_X25519: Примерное увеличение размера сообщения рукопожатия в 13-16x (NS: 13.5x, NSR: 16.3x) MLKEM1024_X25519: Примерное увеличение размера сообщения рукопожатия в 17-23x (NS: 17.5x, NSR: 23x) Эти накладные расходы приемлемы ради дополнительных преимуществ постквантовой безопасности. Коэффициенты различаются в зависимости от типа сообщения, поскольку базовые размеры сообщений отличаются (для NS минимум 96 байт, для NSR минимум 72 байта).\nСоображения по пропускной способности Для типичного установления сеанса с минимальными полезными данными: - Только X25519: ~200 байт всего (NS + NSR) - MLKEM512_X25519: ~1,800 байт всего (увеличение в 9 раз) - MLKEM768_X25519: ~2,500 байт всего (увеличение в 12,5 раза) - MLKEM1024_X25519: ~3,400 байт всего (увеличение в 17 раз)\nПосле установления сеанса дальнейшее шифрование сообщений использует тот же формат передачи данных, что и в сеансах, использующих только X25519 (алгоритм обмена ключами на эллиптической кривой Curve25519), поэтому для последующих сообщений накладные расходы отсутствуют.\nАнализ безопасности Рукопожатия Гибридное рукопожатие обеспечивает как классическую (X25519), так и постквантовую (ML-KEM) криптографическую стойкость. Злоумышленнику необходимо взломать оба механизма — классический ECDH (обмен ключами Диффи — Хеллмана на эллиптических кривых) и постквантовый KEM (механизм инкапсуляции ключа), — чтобы скомпрометировать сеансовые ключи.\nЭто обеспечивает: - Текущая безопасность: X25519 ECDH обеспечивает защиту от классических противников (128-битный уровень безопасности) - Будущая безопасность: ML-KEM обеспечивает защиту от квантовых противников (зависит от набора параметров) - Гибридная безопасность: Обе должны быть взломаны, чтобы скомпрометировать сеанс (уровень безопасности = максимум из обоих компонентов)\nУровни безопасности Variant NIST Category Classical Security PQ Security Hybrid Security MLKEM512_X25519 Category 1 128-bit (X25519) AES-128 equivalent 128-bit MLKEM768_X25519 Category 3 128-bit (X25519) AES-192 equivalent 128-bit MLKEM1024_X25519 Category 5 128-bit (X25519) AES-256 equivalent 128-bit **Примечание:** Гибридный уровень стойкости ограничивается более слабым из двух компонентов. Во всех случаях X25519 обеспечивает 128-битную классическую стойкость. Если станет доступен криптографически значимый квантовый компьютер, уровень стойкости будет зависеть от выбранного набора параметров ML-KEM (модульно-решеточный механизм инкапсуляции ключа). Прямая секретность Гибридный подход сохраняет свойства прямой секретности (forward secrecy). Сеансовые ключи получаются из двух эфемерных обменов ключами: X25519 и ML-KEM. Если после рукопожатия уничтожаются эфемерные закрытые ключи X25519 или ML-KEM, прошлые сеансы невозможно расшифровать даже в случае компрометации долговременных статических ключей.\nШаблон IK обеспечивает полную прямую секретность (уровень конфиденциальности Noise 5) после отправки второго сообщения (NSR).\nНастройки типов Реализации должны поддерживать несколько гибридных типов и согласовывать наиболее сильный совместно поддерживаемый вариант. Порядок предпочтения должен быть следующим:\nMLKEM768_X25519 (Type 6) - Рекомендуемый выбор по умолчанию, оптимальный баланс безопасности и производительности MLKEM1024_X25519 (Type 7) - Максимальная безопасность для приложений с повышенными требованиями к безопасности MLKEM512_X25519 (Type 5) - Базовый уровень постквантовой безопасности для сценариев с ограниченными ресурсами X25519 (Type 4) - Только классическая криптография, резервный вариант для совместимости Обоснование: MLKEM768_X25519 рекомендуется в качестве варианта по умолчанию, поскольку обеспечивает безопасность категории 3 по NIST (эквивалент AES-192), которая считается достаточной защитой от квантовых компьютеров, при этом сохраняются разумные размеры сообщений. MLKEM1024_X25519 обеспечивает более высокий уровень безопасности, но сопровождается существенно большими накладными расходами.\nПримечания по реализации Поддержка библиотек Java: Библиотека Bouncycastle версии 1.79 (август 2024 года) и новее поддерживает все требуемые варианты ML-KEM и функции SHA3/SHAKE. Используйте org.bouncycastle.pqc.crypto.mlkem.MLKEMEngine для соответствия FIPS 203. C++: OpenSSL 3.5 (апрель 2025 года) и новее включает поддержку ML-KEM через интерфейс EVP_KEM. Это релиз долгосрочной поддержки, сопровождается до апреля 2030 года. Go: Доступно несколько сторонних библиотек для ML-KEM и SHA3, включая библиотеку CIRCL от Cloudflare. Стратегия миграции Реализации должны: 1. Поддерживать как варианты только X25519 (кривая для ECDH), так и гибридные варианты ML-KEM (постквантовая схема согласования ключей) в переходный период 2. Предпочитать гибридные варианты, когда оба узла их поддерживают 3. Сохранять возможность отката на вариант только X25519 для обеспечения обратной совместимости 4. Учитывать ограничения пропускной способности сети при выборе варианта по умолчанию\nСовместно используемые Tunnels Увеличение размеров сообщений может повлиять на использование общих tunnel. Реализациям следует учесть: - Объединять рукопожатия в пакеты, когда это возможно, чтобы распределить накладные расходы - Использовать более короткие сроки истечения для гибридных сеансов, чтобы сократить объём сохраняемого состояния - Отслеживать использование пропускной способности и соответствующим образом настраивать параметры - Реализовать контроль перегрузки для трафика установления сеанса\nСоображения по размеру новой сессии Из-за увеличенного размера сообщений рукопожатия реализациям может понадобиться: - Увеличить размеры буферов для согласования сеанса (рекомендуется минимум 4 КБ) - Скорректировать значения таймаутов для более медленных соединений (учитывать ~в 3–17 раз более крупные сообщения) - Рассмотреть сжатие полезных данных в сообщениях NS/NSR - Реализовать обработку фрагментации, если это требуется транспортным уровнем\nТестирование и валидация Реализации должны проверять: - Корректную генерацию ключей ML-KEM, инкапсуляцию и декапсуляцию - Правильную интеграцию kem_shared_key в Noise KDF (функция выработки ключей протокола Noise) - Соответствие вычислений размеров сообщений спецификации - Совместимость с другими реализациями I2P router - Поведение при недоступности ML-KEM (резервный режим)\nТестовые векторы для операций ML-KEM доступны в NIST Cryptographic Algorithm Validation Program .\nСовместимость версий Нумерация версий I2P: I2P поддерживает две параллельные схемы версионирования: - Версия релиза Router: формат 2.x.x (например, 2.10.0, выпущена в сентябре 2025 г.) - Версия API/протокола: формат 0.9.x (например, 0.9.67 соответствует router 2.10.0)\nДанная спецификация ссылается на версию протокола 0.9.67, соответствующую релизу router 2.10.0 и новее.\nМатрица совместимости:\nImplementation Version ML-KEM Support Status i2pd 2.58.0+ Full (512/768/1024) Deployed September 2025 Java I2P 0.9.67 / 2.10.0 Not yet Planned for future release ## Ссылки [ECIES]: Спецификация ECIES-X25519-AEAD-Ratchet [Prop169]: Предложение 169: постквантовая криптография [FIPS203]: NIST FIPS 203 - стандарт ML-KEM [FIPS202]: NIST FIPS 202 - стандарт SHA-3 [Noise]: Фреймворк протокола Noise [COMMON]: Спецификация общих структур [RFC7539]: RFC 7539 - ChaCha20 и Poly1305 [RFC5869]: RFC 5869 - HKDF [OpenSSL]: Документация OpenSSL 3.5 по ML-KEM [Bouncycastle]: Криптографическая библиотека Java Bouncycastle ","description":"Постквантовый гибридный вариант протокола шифрования ECIES с использованием ML-KEM","id":"f6a66a37875c5b108bc5a8ea027dc0e2","section":"docs","title":"Гибридное шифрование ECIES-X25519-AEAD-Ratchet (криптографический «рэтчет»-механизм)","url":"/ru/docs/specs/ecies-hybrid/"},{"categories":null,"content":"Этот глоссарий определяет общие термины, используемые в документации I2P и обсуждениях.\nB Blockchain Распределённый реестр, который может эффективно записывать транзакции между множеством сторон проверяемым и неизменным способом.\nD Децентрализация Сетевая архитектура, которая избегает зависимости от одной стороны. Включает в себя peer-to-peer, блокчейн, федеративные и распределенные технологии.\nDestination Криптографическая идентичность туннеля. Это идентичности клиентов и серверов внутри сети I2P.\nDHT (Distributed Hash Table) Используется в некоторых проектах для соединения пиров друг с другом путем хранения информации в виде пар ключ-значение распределенным образом.\nРаспределенные системы Академическая тема в области компьютерных наук, связанная с проектированием компьютерных систем, которые состоят из множества отдельных компьютеров, соединенных по сети.\nF Федеративная архитектура Федерация позволяет отдельным развертываниям сервиса взаимодействовать друг с другом через общий протокол.\nH Hash Число, обычно отображаемое в виде строки из букв и цифр. Может служить \u0026ldquo;отпечатком пальца\u0026rdquo;, уникально идентифицирующим данные.\nI I2P Invisible Internet Project: проект, предназначенный для обеспечения уровня анонимности, чтобы пользователи могли анонимно общаться с использованием различных приложений.\nIP-адрес Номер компьютера или сети, который является уникальным и поэтому может использоваться для его адресации.\nL LeaseSet Набор информации, необходимой для связи с клиентом или сервером по определённому Destination.\nP Peer-to-Peer (P2P) Узлы предоставляют часть своих ресурсов непосредственно другим участникам сети без необходимости централизованной координации со стороны серверов или стабильных хостов.\nR Router Основное программное обеспечение I2P, которое маршрутизирует зашифрованные пакеты в сети I2P.\nRouterIdentity Набор информации, необходимой для прямого взаимодействия с роутером.\nT TCP/UDP Два основных транспортных протокола, используемых в Интернете.\nTunnel Анонимный канал связи между клиентом или сервером и сетью I2P.\nU UX Пользовательский опыт (User experience), общий опыт человека, использующего продукт или услугу.\nW WebRTC Стандарт протокола для установления соединений в веб-браузере, при котором данные передаются напрямую между пользователями.\n","description":"Общие термины и определения, используемые в документации I2P","id":"2235ec8f316773700ef08dd43b19a1c0","section":"docs","title":"Глоссарий","url":"/ru/docs/overview/%D0%B3%D0%BB%D0%BE%D1%81%D1%81%D0%B0%D1%80%D0%B8%D0%B9/"},{"categories":null,"content":"Обзор Датаграммы обеспечивают ориентированную на сообщения коммуникацию поверх I2CP и параллельно с библиотекой потоковой передачи данных. Они позволяют отправлять пакеты с возможностью ответа, аутентифицированные или сырые пакеты без необходимости использования потоков с установлением соединения. Роутеры инкапсулируют датаграммы в I2NP-сообщения и tunnel-сообщения, независимо от того, используется ли для передачи трафика NTCP2 или SSU2.\nОсновная мотивация заключается в том, чтобы позволить приложениям (таким как трекеры, DNS-резолверы или игры) отправлять самодостаточные пакеты, которые идентифицируют своего отправителя.\nНовое в 2025 году: Проект I2P утвердил Datagram2 (протокол 19) и Datagram3 (протокол 20), добавив защиту от повторов и обмен сообщениями с ответами и низкими накладными расходами впервые за десятилетие.\n1. Константы протокола Protocol Value Description Introduced PROTO_DATAGRAM 17 Signed (repliable) datagram – “Datagram1” Original PROTO_DATAGRAM_RAW 18 Unsigned (raw) datagram – no sender info Original PROTO_DATAGRAM2 19 Signed + replay-protected datagram API 0.9.66 (2025) PROTO_DATAGRAM3 20 Repliable (no signature, hash only) API 0.9.66 (2025) Протоколы 19 и 20 были формализованы в **Предложении 163 (апрель 2025 года)**. Они сосуществуют с Datagram1 / RAW для обратной совместимости. 2. Типы датаграмм Type Protocol Repliable Authenticated Replay Protection Min Overhead Notes Raw 18 No No No 0 Minimal size; spoofable. Datagram1 17 Yes Yes No ≈ 427 Full Destination + signature. Datagram2 19 Yes Yes Yes ≈ 457 Replay prevention + offline signatures; PQ-ready. Datagram3 20 Yes No No ≈ 34 Sender hash only; low overhead. ### Типовые шаблоны проектирования Запрос → Ответ: Отправить подписанный Datagram2 (запрос + nonce), получить raw или Datagram3 ответ (echo nonce). Высокая частота/низкие накладные расходы: Предпочтительно использовать Datagram3 или RAW. Аутентифицированные управляющие сообщения: Datagram2. Совместимость с устаревшими версиями: Datagram1 по-прежнему полностью поддерживается. 3. Детали Datagram2 и Datagram3 (2025) Datagram2 (Протокол 19) Улучшенная замена Datagram1. Возможности: - Защита от повторов: 4-байтовый токен защиты от повторного воспроизведения. - Поддержка оффлайн-подписей: позволяет использовать Destinations с оффлайн-подписью. - Расширенное покрытие подписью: включает хеш destination, флаги, опции, блок оффлайн-подписи, полезную нагрузку. - Готовность к постквантовой эре: совместимость с будущими гибридами ML-KEM. - Накладные расходы: ≈ 457 байт (ключи X25519).\nDatagram3 (Протокол 20) Связывает необработанные и подписанные типы. Особенности: - Возможность ответа без подписи: содержит 32-байтовый хэш отправителя + 2-байтовые флаги. - Минимальные накладные расходы: ≈ 34 байта. - Без защиты от повторов — должно быть реализовано приложением.\nОба протокола являются функциями API 0.9.66 и реализованы в Java router начиная с Release 2.9.0; реализаций для i2pd или Go пока нет (октябрь 2025).\n4. Ограничения по размеру и фрагментации Размер сообщения tunnel: 1 028 байт (4 Б Tunnel ID + 16 Б IV + 1 008 Б полезная нагрузка). Начальный фрагмент: 956 Б (типичная доставка TUNNEL). Последующий фрагмент: 996 Б. Максимум фрагментов: 63–64. Практический лимит: ≈ 62 708 Б (~61 КБ). Рекомендуемый лимит: ≤ 10 КБ для надёжной доставки (потери увеличиваются экспоненциально выше этого значения). Сводка по накладным расходам: - Datagram1 ≈ 427 Б (минимум). - Datagram2 ≈ 457 Б. - Datagram3 ≈ 34 Б. - Дополнительные уровни (заголовок I2CP gzip, I2NP, Garlic, Tunnel): + ~5,5 КБ в худшем случае.\n5. Интеграция I2CP / I2NP Путь сообщения: 1. Приложение создает датаграмму (через I2P API или SAM). 2. I2CP оборачивает её заголовком gzip (0x1F 0x8B 0x08, RFC 1952) и контрольной суммой CRC-32. 3. Номера протокола + порта сохраняются в полях заголовка gzip. 4. Router инкапсулирует как I2NP сообщение → Garlic clove → фрагменты tunnel по 1 КБ. 5. Фрагменты проходят через outbound → сеть → inbound tunnel. 6. Собранная датаграмма доставляется обработчику приложения на основе номера протокола.\nЦелостность: CRC-32 (из I2CP) + опциональная криптографическая подпись (Datagram1/2). Отдельного поля контрольной суммы внутри самой датаграммы нет.\n6. Программные интерфейсы Java API Пакет net.i2p.client.datagram включает: - I2PDatagramMaker – создаёт подписанные датаграммы. - I2PDatagramDissector – проверяет и извлекает информацию об отправителе. - I2PInvalidDatagramException – выбрасывается при сбое проверки.\nI2PSessionMuxedImpl (net.i2p.client.impl.I2PSessionMuxedImpl) управляет мультиплексированием протоколов и портов для приложений, использующих общий Destination.\nДоступ к Javadoc: - idk.i2p Javadoc (только в сети I2P) - Зеркало Javadoc (зеркало в clearnet) - Официальная Javadoc (официальная документация)\nПоддержка SAM v3 SAM 3.2 (2016): добавлены параметры PORT и PROTOCOL. SAM 3.3 (2016): введена модель PRIMARY/subsession; позволяет использовать потоки + датаграммы на одном Destination. Добавлена поддержка стилей сессий Datagram2 / 3 в спецификацию 2025 (реализация ожидается). Официальная спецификация: Спецификация SAM v3 Модули i2ptunnel udpTunnel: Полностью функциональная основа для I2P UDP-приложений (net.i2p.i2ptunnel.udpTunnel). streamr: Работает для A/V потоковой передачи (net.i2p.i2ptunnel.streamr). SOCKS UDP: Не функционален по состоянию на 2.10.0 (только заглушка UDP). Для UDP общего назначения используйте Datagram API или udpTunnel напрямую — не полагайтесь на SOCKS UDP.\n7. Экосистема и поддержка языков (2025) Language Library / Package SAM Version Status Javacore API (net.i2p.client.datagram)3.3✓ full support C++i2pd / libsam33.2 partialLimited Gogo-i2p / sam33.1–3.2Active Pythoni2plib, i2p.socket, txi2p3.2Active Rusti2p-rs, i2p_client3.3Active C#I2PSharp3.3Active JS/TSnode-i2p, i2p-sam3.2Active Haskellnetwork-anonymous-i2p3.2Experimental Luamooni2p3.2Experimental На данный момент Java I2P является единственным router, поддерживающим полные подсессии SAM 3.3 и API Datagram2. 8. Пример использования – UDP Tracker (I2PSnark 2.10.0) Первое реальное применение Datagram2/3:\nOperation Datagram Type Purpose Announce RequestDatagram3Repliable but low-overhead update ResponseRaw DatagramMinimal payload return Паттерн демонстрирует комбинированное использование аутентифицированных и облегченных датаграмм для баланса между безопасностью и производительностью. 9. Безопасность и рекомендации Используйте Datagram2 для любого аутентифицированного обмена или когда важны атаки повторного воспроизведения. Предпочитайте Datagram3 для быстрых ответов с возможностью ответа при умеренном доверии. Используйте RAW для публичных широковещательных рассылок или анонимных данных. Держите полезную нагрузку ≤ 10 КБ для надежной доставки. Имейте в виду, что SOCKS UDP остается нерабочим. Всегда проверяйте CRC gzip и цифровые подписи при получении. 10. Техническая спецификация Этот раздел описывает низкоуровневые форматы датаграмм, инкапсуляцию и детали протокола.\n10.1 Идентификация протокола Форматы датаграмм не имеют общего заголовка. Роутеры не могут определить тип только по байтам полезной нагрузки.\nПри смешивании нескольких типов датаграмм — или при комбинировании датаграмм с потоковой передачей — явно устанавливайте: - Номер протокола (через I2CP или SAM) - Опционально номер порта, если ваше приложение мультиплексирует сервисы\nОставлять протокол неустановленным (0 или PROTO_ANY) не рекомендуется, так как это может привести к ошибкам маршрутизации или доставки.\n10.2 Сырые датаграммы Датаграммы без возможности ответа (non-repliable datagrams) не содержат данных отправителя или аутентификации. Это непрозрачные полезные нагрузки, обрабатываемые вне API датаграмм более высокого уровня, но поддерживаемые через SAM и I2PTunnel.\nПротокол: 18 (PROTO_DATAGRAM_RAW)\nФормат:\n+----+----+----+----+----// | payload... +----+----+----+----+----// Длина полезной нагрузки ограничена лимитами транспорта (≈32 КБ практический максимум, часто намного меньше).\n10.3 Datagram1 (Датаграммы с возможностью ответа) Встраивает Destination отправителя и Signature для аутентификации и адресации ответов.\nПротокол: 17 (PROTO_DATAGRAM)\nНакладные расходы: ≥427 байт Полезная нагрузка: до ~31,5 КБ (ограничено транспортом)\nФормат:\n+----+----+----+----+----+----+----+----+ | from | + + | | ~ Destination bytes ~ | | +----+----+----+----+----+----+----+----+ | signature | + + | | +----+----+----+----+----+----+----+----+ | payload... +----+----+----+----// from: Destination (387+ байт) signature: Signature, соответствующая типу ключа Для DSA_SHA1: Signature SHA-256 хеша полезной нагрузки Для других типов ключей: Signature непосредственно полезной нагрузки Примечания: - Подписи для типов, отличных от DSA, были стандартизированы в I2P 0.9.14. - Оффлайн-подписи LS2 (Предложение 123) в настоящее время не поддерживаются в Datagram1.\n10.4 Формат Datagram2 Улучшенная датаграмма с возможностью ответа, которая добавляет защиту от повторов согласно определению в Предложении 163 .\nПротокол: 19 (PROTO_DATAGRAM2)\nРеализация продолжается. Приложения должны включать проверки nonce или временных меток для избыточности.\n10.5 Формат Datagram3 Обеспечивает датаграммы с возможностью ответа, но без аутентификации. Полагается на аутентификацию сессии, поддерживаемую роутером, а не на встроенный destination и подпись.\nПротокол: 20 (PROTO_DATAGRAM3) Статус: В разработке с версии 0.9.66\nПолезно в случаях: - Назначения имеют большой размер (например, постквантовые ключи) - Аутентификация происходит на другом уровне - Критична эффективность использования пропускной способности\n10.6 Целостность данных Целостность датаграммы защищена контрольной суммой gzip CRC-32 на уровне I2CP. Явное поле контрольной суммы в самом формате полезной нагрузки датаграммы отсутствует.\n10.7 Инкапсуляция пакетов Каждая датаграмма инкапсулируется как одно I2NP-сообщение или как отдельный clove в Garlic Message. Уровни I2CP, I2NP и туннеля обрабатывают длину и фрейминг — во внутреннем протоколе датаграмм нет разделителей или полей длины.\n10.8 Соображения о постквантовой (PQ) безопасности Если будет реализовано Предложение 169 (подписи ML-DSA), размеры подписей и destination (адресов назначения) резко возрастут — с ~455 байт до ≥3739 байт. Это изменение существенно увеличит служебные данные дейтаграмм и уменьшит эффективную ёмкость полезной нагрузки.\nDatagram3, который основан на аутентификации на уровне сессии (не встроенных подписях), вероятно, станет предпочтительным решением в постквантовых средах I2P.\n11. Ссылки Предложение 163 – Datagram2 и Datagram3 Предложение 160 – Интеграция UDP Tracker Предложение 144 – Расчёты MTU для Streaming Предложение 169 – Постквантовые подписи Спецификация I2CP Спецификация I2NP Спецификация сообщений tunnel Спецификация SAM v3 Документация i2ptunnel 12. Основные изменения (2019 – 2025) Year Release Change 20190.9.43Datagram API stabilization 20210.9.50Protocol port handling reworked 20222.0.0SSU2 adoption completed 20242.6.0Legacy transport removal simplified UDP code 20252.9.0Datagram2/3 support added (Java API) 20252.10.0UDP Tracker implementation released --- 13. Резюме Подсистема датаграмм теперь поддерживает четыре варианта протокола, предлагающих спектр от полностью аутентифицированной до облегченной сырой передачи. Разработчикам следует переходить на Datagram2 для критичных к безопасности случаев использования и Datagram3 для эффективного трафика с возможностью ответа. Все старые типы остаются совместимыми для обеспечения долгосрочной интероперабельности.\n","description":"Аутентифицированный, с возможностью ответа и сырой форматы сообщений поверх I2CP","id":"b3c644204c779b5d6fc6a41438a3eb1b","section":"docs","title":"Датаграммы","url":"/ru/docs/api/datagrams/"},{"categories":null,"content":"Хостинг GitLab внутри I2P прост: запустите контейнер GitLab omnibus, откройте его на loopback и перенаправьте трафик через I2P-туннель. Приведённые ниже шаги повторяют конфигурацию, используемую для git.idk.i2p, но работают для любого самостоятельно размещённого экземпляра.\n1. Предварительные требования Debian или другой дистрибутив Linux с установленным Docker Engine (sudo apt install docker.io или docker-ce из репозитория Docker). I2P router (Java I2P или i2pd) с достаточной пропускной способностью для обслуживания ваших пользователей. Опционально: выделенная виртуальная машина, чтобы GitLab и router оставались изолированными от вашего рабочего окружения. 2. Загрузите образ GitLab docker pull gitlab/gitlab-ce:latest Официальный образ собирается на основе базовых слоев Ubuntu и регулярно обновляется. Изучите Dockerfile , если вам требуются дополнительные гарантии.\n3. Определитесь с выбором между бриджингом и режимом только I2P I2P-only инстансы никогда не связываются с хостами в clearnet. Пользователи могут зеркалировать репозитории из других I2P-сервисов, но не из GitHub/GitLab.com. Это обеспечивает максимальную анонимность. Bridged инстансы обращаются к Git-хостам в clearnet через HTTP-прокси. Это полезно для зеркалирования публичных проектов в I2P, но при этом происходит деанонимизация исходящих запросов сервера. Если вы выбираете режим bridged, настройте GitLab на использование I2P HTTP-прокси, привязанного к хосту Docker (например, http://172.17.0.1:4446). Стандартный прокси router по умолчанию слушает только на 127.0.0.1; добавьте новый прокси-tunnel, привязанный к адресу шлюза Docker.\n4. Запуск контейнера docker run --detach \\ --env HTTP_PROXY=http://172.17.0.1:4446 \\ # omit for I2P-only --publish 127.0.0.1:8443:443 \\ --publish 127.0.0.1:8080:80 \\ --publish 127.0.0.1:8022:22 \\ --name gitlab \\ --restart always \\ --volume /srv/gitlab/config:/etc/gitlab:Z \\ --volume /srv/gitlab/logs:/var/log/gitlab:Z \\ --volume /srv/gitlab/data:/var/opt/gitlab:Z \\ gitlab/gitlab-ce:latest Привяжите опубликованные порты к loopback; I2P туннели откроют их по мере необходимости. Замените /srv/gitlab/... на пути хранения, соответствующие вашему хосту. После запуска контейнера перейдите по адресу https://127.0.0.1:8443/, установите пароль администратора и настройте ограничения для учетных записей.\n5. Открыть доступ к GitLab через I2P Создайте три серверных туннеля I2PTunnel:\nPurpose Local target Suggested inbound port HTTPS web UI 127.0.0.1:8443 auto-generated HTTP web UI (optional) 127.0.0.1:8080 auto-generated SSH push/pull 127.0.0.1:8022 auto-generated Настройте каждый tunnel с соответствующей длиной и пропускной способностью. Для публичных экземпляров хорошей отправной точкой является 3 хопа с 4–6 tunnels в каждом направлении. Опубликуйте получившиеся Base32/Base64 адреса назначения на вашей целевой странице, чтобы пользователи могли настроить клиентские tunnels. Destination Enforcement Если вы используете HTTP(S) туннели, включите принудительное применение назначения (destination enforcement), чтобы только предполагаемое имя хоста могло получить доступ к сервису. Это предотвращает использование туннеля в качестве обычного прокси.\n6. Maintenance Tips Выполняйте docker exec gitlab gitlab-ctl reconfigure каждый раз при изменении настроек GitLab. Следите за использованием дискового пространства (/srv/gitlab/data) — Git-репозитории быстро растут. Регулярно создавайте резервные копии каталогов конфигурации и данных. Задачи резервного копирования rake GitLab работают внутри контейнера. Рассмотрите возможность размещения внешнего мониторингового tunnel в клиентском режиме, чтобы обеспечить доступность сервиса из более широкой сети. 6. Советы по обслуживанию Встраивание I2P в ваше приложение Git через I2P (руководство для клиента) Git bundles для офлайн/медленных сетей Правильно настроенный экземпляр GitLab обеспечивает центр совместной разработки полностью внутри I2P. Поддерживайте router в рабочем состоянии, своевременно устанавливайте обновления безопасности GitLab и координируйте действия с сообществом по мере роста пользовательской базы.\n","description":"Развертывание GitLab внутри I2P с использованием Docker и I2P-роутера","id":"0c6aba5984de265324df6360a00204c9","section":"docs","title":"Запуск GitLab через I2P","url":"/ru/docs/guides/gitlab/"},{"categories":null,"content":"Обзор В этом документе описываются ослепление, шифрование и расшифрование зашифрованного LeaseSet2 (LS2). Зашифрованные LeaseSets обеспечивают публикацию с контролем доступа информации о скрытом сервисе в сетевой базе данных I2P.\nКлючевые возможности: - Ежедневная ротация ключей для обеспечения прямой секретности - Двухуровневая авторизация клиентов (на основе DH и на основе PSK) - Шифрование ChaCha20 для повышения производительности на устройствах без аппаратной поддержки AES - Подписи Red25519 с ослеплением ключей - Сохранение конфиденциальности состава клиентов\nСвязанная документация: - Спецификация общих структур - Структура зашифрованного LeaseSet (набор данных для установления соединения с назначением) - Предложение 123: новые записи netDB (распределённая сетевая база данных I2P) - Общие сведения о зашифрованных LeaseSets - Документация по сетевой базе данных - Использование NetDB\nИстория версий и статус реализации Хронология разработки протокола Важное примечание о нумерации версий: I2P использует две отдельные схемы нумерации версий: - Версия API/Router: серия 0.9.x (используется в технических спецификациях) - Версия продуктового релиза: серия 2.x.x (используется для публичных релизов)\nТехнические спецификации ссылаются на версии API (например, 0.9.41), тогда как конечные пользователи видят версии продукта (например, 2.10.0).\nВехи реализации Version Release Date Features 0.9.38January 2019Floodfill support for standard LS2, offline keys 0.9.39March 2019Full encrypted LS2 support, Red25519 (sig type\u0026nbsp;11) 0.9.40May 2019Per-client authorization, encrypted LS2 with offline keys, B32 support 0.9.41June 2019Protocol finalized as stable 2.10.0September 2025Latest Java implementation (API version 0.9.61) i2pd 2.58.0September 2025Full C++ implementation compatibility ### Текущее состояние ✅ Состояние протокола: стабильное и неизменное с июня 2019 года ✅ Java I2P: полностью реализован начиная с версии 0.9.40+ ✅ i2pd (C++): полностью реализован начиная с версии 2.58.0+ ✅ Совместимость: полная между реализациями ✅ Развёртывание в сети: готово к промышленной эксплуатации, с 6+ годами опыта эксплуатации Криптографические определения Обозначения и соглашения || обозначает конкатенацию mod L обозначает взятие по модулю порядка Ed25519 Все массивы байтов представлены в сетевом порядке байтов (big-endian, старший байт первым), если не указано иное Значения в формате little-endian (младший байт первым) указываются явно Генератор криптографически стойких случайных чисел (n) Криптографически стойкий генератор случайных чисел\nГенерирует n байт криптографически стойких случайных данных, подходящих для генерации ключевого материала.\nТребования к безопасности: - Должен быть криптографически стойким (подходящим для генерации ключей) - Должен оставаться безопасным при раскрытии в сети соседних последовательностей байтов - Реализациям следует хешировать выходные данные, полученные из потенциально ненадёжных источников\nСсылки: - Соображения безопасности PRNG - Обсуждение в Tor Dev H(p, d) Хэш SHA-256 с персонализацией\nХеш-функция с разделением доменов принимает: - p: строка персонализации (обеспечивает разделение доменов) - d: данные для хеширования\nРеализация:\nH(p, d) := SHA-256(p || d) Использование: Обеспечивает криптографическое разделение доменов для предотвращения коллизионных атак между различными протокольными вариантами использования SHA-256.\nПотоковый шифр: ChaCha20 Потоковый шифр: ChaCha20, как определено в разделе 2.4 RFC 7539\nПараметры: - S_KEY_LEN = 32 (256-битный ключ) - S_IV_LEN = 12 (96-битный nonce (одноразовое число)) - Начальный счетчик: 1 (RFC 7539 допускает 0 или 1; 1 рекомендуется для контекстов AEAD)\nENCRYPT(k, iv, plaintext)\nШифрует открытый текст, используя: - k: 32-байтовый ключ шифрования - iv: 12-байтовый nonce (одноразовое значение; ДОЛЖЕН быть уникальным для каждого ключа) - Возвращает шифртекст того же размера, что и открытый текст\nСвойство безопасности: Весь шифртекст должен быть неотличим от случайных данных, если ключ секретен.\nРАСШИФРОВАТЬ(k, iv, ciphertext)\nРасшифровывает шифротекст, используя: - k: 32-байтный ключ шифрования - iv: 12-байтный nonce (одноразовое значение) - Возвращает открытый текст\nОбоснование выбора: ChaCha20 выбран вместо AES, потому что: - в 2,5–3 раза быстрее, чем AES, на устройствах без аппаратного ускорения - реализацию с постоянным временем выполнения проще обеспечить - при наличии AES-NI безопасность и скорость сопоставимы\nСсылки: - RFC 7539 - ChaCha20 и Poly1305 для протоколов IETF\nПодпись: Red25519 (схема цифровой подписи на основе Ed25519) Схема подписи: Red25519 (SigType 11) с Key Blinding (ослепление ключа)\nRed25519 основан на подписях Ed25519 над эллиптической кривой Ed25519, с использованием SHA-512 для хеширования и поддержкой ослепления ключа, как это определено в ZCash RedDSA (схема электронной подписи).\nФункции:\nDERIVE_PUBLIC(privkey) Возвращает публичный ключ, соответствующий заданному закрытому ключу. - Использует стандартное скалярное умножение базовой точки Ed25519\nSIGN(privkey, m) Возвращает подпись, созданную закрытым ключом privkey для сообщения m.\nРазличия в алгоритме подписи Red25519 по сравнению с Ed25519: 1. Random Nonce: (одноразовое число) Использует 80 байт дополнительных случайных данных\nT = CSRNG(80) // 80 random bytes r = H*(T || publickey || message) Это делает каждую подпись Red25519 уникальной, даже для одного и того же сообщения и ключа.\nГенерация закрытого ключа: закрытые ключи Red25519 генерируются из случайных чисел и редуцируются mod L, вместо использования подхода Ed25519 с bit-clamping (фиксация отдельных битов). VERIFY(pubkey, m, sig) Проверяет подпись sig по открытому ключу pubkey и сообщению m. - Возвращает true, если подпись действительна, false в противном случае - Проверка идентична Ed25519\nОперации ослепления ключей:\nGENERATE_ALPHA(data, secret) Генерирует параметр alpha для ослепления ключа. - data: Обычно содержит открытый ключ подписи и типы подписей - secret: Необязательный дополнительный секрет (нулевой длины, если не используется) - Результат имеет то же распределение, что и закрытые ключи Ed25519 (после редукции по модулю L)\nBLIND_PRIVKEY(privkey, alpha) Ослепляет закрытый ключ с использованием секрета alpha. - Реализация: blinded_privkey = (privkey + alpha) mod L - Использует скалярную арифметику в поле\nBLIND_PUBKEY(pubkey, alpha) Ослепляет открытый ключ с использованием секрета alpha. - Реализация: blinded_pubkey = pubkey + DERIVE_PUBLIC(alpha) - Использует сложение элементов группы (точек) на кривой\nКритическое свойство:\nBLIND_PUBKEY(pubkey, alpha) == DERIVE_PUBLIC(BLIND_PRIVKEY(privkey, alpha)) Соображения безопасности:\nИз спецификации протокола ZCash, раздел 5.4.6.1: В целях безопасности alpha должна быть распределена так же, как закрытые ключи без ослепления. Это гарантирует, что \u0026ldquo;сочетание повторно рандомизированного открытого ключа и подписи(ей), выполненной(ых) этим ключом, не раскрывает ключ, из которого был получен повторно рандомизированный ключ.\u0026rdquo;\nПоддерживаемые типы подписей: - Тип 7 (Ed25519): Поддерживается для существующих назначений (обратная совместимость) - Тип 11 (Red25519): Рекомендуется для новых назначений с использованием шифрования - Ослеплённые ключи: Всегда используйте тип 11 (Red25519)\nСсылки: - Спецификация протокола ZCash - Раздел 5.4.6 RedDSA (схема цифровой подписи) - Спецификация I2P Red25519 Диффи‑Хеллман: X25519 Диффи — Хеллман на эллиптических кривых: X25519\nСистема согласования ключей на основе Curve25519.\nПараметры: - Закрытые ключи: 32 байта - Открытые ключи: 32 байта - Значение общего секрета: 32 байта\nФункции:\nGENERATE_PRIVATE() Генерирует новый 32-байтный закрытый ключ с использованием CSRNG (криптографически стойкого генератора случайных чисел).\nDERIVE_PUBLIC(privkey) Порождает 32-байтный открытый ключ из заданного закрытого ключа. - Использует скалярное умножение на Curve25519\nDH(privkey, pubkey) Выполняет согласование ключа по протоколу Диффи-Хеллмана. - privkey: Локальный 32-байтный закрытый ключ - pubkey: Удалённый 32-байтный открытый ключ - Возвращает: 32-байтный общий секрет\nСвойства безопасности: - Предположение о вычислительной трудности задачи Диффи — Хеллмана на Curve25519 - Прямая секретность при использовании эфемерных ключей - Требуется константновременная реализация для предотвращения тайминговых атак\nСсылки: - RFC 7748 - Эллиптические кривые для безопасности\nHKDF (функция выработки ключей на основе HMAC) Функция деривации ключей на основе HMAC\nИзвлекает и расширяет ключевой материал из входного ключевого материала.\nПараметры: - salt: максимум 32 байта (обычно 32 байта для SHA-256) - ikm: входной ключевой материал (любой длины, должен иметь хорошую энтропию) - info: контекстно-зависимая информация (разделение доменов) - n: длина выходных данных в байтах\nРеализация:\nИспользует HKDF, как определено в RFC 5869, со следующими параметрами: - Хеш-функция: SHA-256 - HMAC: как указано в RFC 2104 - Длина соли: не более 32 байт (HashLen для SHA-256)\nСценарий использования:\nkeys = HKDF(salt, ikm, info, n) Разделение доменов: Параметр info обеспечивает криптографическое разделение доменов между различными использованиями HKDF (функция выработки ключей на основе HMAC) в протоколе.\nЗначения Verified Info: - \u0026quot;ELS2_L1K\u0026quot; - шифрование уровня 1 (внешнее) - \u0026quot;ELS2_L2K\u0026quot; - шифрование уровня 2 (внутреннее) - \u0026quot;ELS2_XCA\u0026quot; - авторизация клиента по DH (Диффи-Хеллмана) - \u0026quot;ELS2PSKA\u0026quot; - авторизация клиента по PSK (предварительно разделённому ключу) - \u0026quot;i2pblinding1\u0026quot; - поколение Alpha\nСсылки: - RFC 5869 - Спецификация HKDF - RFC 2104 - Спецификация HMAC\nСпецификация формата Зашифрованный LS2 состоит из трёх вложенных слоёв:\nСлой 0 (внешний): Незашифрованная информация для хранения и извлечения Слой 1 (средний): Данные аутентификации клиента (зашифрованы) Слой 2 (внутренний): Собственно данные LeaseSet2 (зашифрованы) Общая структура:\nLayer 0 data + Enc(layer 1 data + Enc(layer 2 data)) + Signature Важно: Зашифрованный LS2 использует ослеплённые ключи. Destination (адрес назначения) не указывается в заголовке. Место хранения в DHT (распределённая хеш-таблица) — SHA-256(sig type || blinded public key), меняется ежедневно.\nСлой 0 (внешний) - открытый текст Уровень 0 НЕ использует стандартный заголовок LS2. Он использует специальный формат, оптимизированный для blinded keys (ослеплённых ключей).\nСтруктура:\nField Size Description Type1 byteNot in header, from DatabaseStore message field Blinded Public Key Sig Type2 bytesBig endian, always 0x000b (Red25519 type 11) Blinded Public Key32 bytesRed25519 blinded public key Published Timestamp4 bytesBig endian, seconds since epoch (rolls over in 2106) Expires2 bytesBig endian, offset from published in seconds (max 65,535 \u0026asymp; 18.2 hours) Flags2 bytesBit flags (see below) [Optional] Transient Key DataVariablePresent if flag bit\u0026nbsp;0 is set lenOuterCiphertext2 bytesBig endian, length of outer ciphertext outerCiphertextlenOuterCiphertextEncrypted Layer\u0026nbsp;1 data Signature64 bytesRed25519 signature over all preceding data **Поле Flags (2 байта, биты 15-0):** - **Бит 0:** индикатор офлайн-ключей - `0` = Офлайн-ключей нет - `1` = Офлайн-ключи присутствуют (далее следуют временные ключевые данные) - **Биты 1-15:** Зарезервировано, должно быть 0 для будущей совместимости Данные временного ключа (присутствуют, если бит флага 0 = 1):\nField Size Description Expires Timestamp4 bytesBig endian, seconds since epoch Transient Sig Type2 bytesBig endian, signature type Transient Signing Public KeyVariableLength implied by signature type Signature64 bytesSigned by blinded public key; covers expires timestamp, transient sig type, and transient public key **Проверка подписи:** - **Без офлайн-ключей:** Проверяйте с использованием ослеплённого открытого ключа - **С офлайн-ключами:** Проверяйте с использованием временного открытого ключа Подпись охватывает все данные от Type до outerCiphertext (включительно).\nУровень 1 (Средний) - Авторизация клиента Расшифрование: См. раздел Шифрование уровня 1 .\nСтруктура:\nField Size Description Flags1 byteAuthorization flags (see below) [Optional] Auth DataVariablePresent based on flags innerCiphertextVariableEncrypted Layer\u0026nbsp;2 data (remainder) **Поле флагов (1 байт, биты 7-0):** - **Бит 0:** Режим авторизации - `0` = Нет авторизации на уровне клиента (для всех) - `1` = Авторизация на уровне клиента (далее следует раздел авторизации) - **Биты 3-1:** Схема аутентификации (только если бит 0 = 1) - `000` = Аутентификация клиента по DH - `001` = Аутентификация клиента по PSK - Остальные зарезервированы - **Биты 7-4:** Не используются, должны быть 0 Данные авторизации клиента DH (флаги = 0x01, биты 3-1 = 000):\nField Size Description ephemeralPublicKey32 bytesServer's ephemeral X25519 public key clients2 bytesBig endian, number of client entries authClient[]40 bytes eachArray of client authorization entries **Запись authClient (40 байт):** - `clientID_i`: 8 байт - `clientCookie_i`: 32 байта (зашифрованный authCookie) Данные авторизации клиента PSK (флаги = 0x03, биты 3-1 = 001):\nField Size Description authSalt32 bytesSalt for PSK key derivation clients2 bytesBig endian, number of client entries authClient[]40 bytes eachArray of client authorization entries **Запись authClient (40 байт):** - `clientID_i`: 8 байт - `clientCookie_i`: 32 байта (зашифрованный authCookie) Уровень 2 (внутренний) - данные LeaseSet Расшифрование: См. раздел Шифрование уровня 2 .\nСтруктура:\nField Size Description Type1 byte3 (LS2) or 7 (Meta LS2) DataVariableComplete LeaseSet2 or MetaLeaseSet2 Внутренний слой содержит полную структуру LeaseSet2, включая: - заголовок LS2 - информация о Lease (запись с параметрами входящего туннеля) - подпись LS2 Требования к проверке: После расшифрования реализации должны проверить: 1. Внутренняя метка времени совпадает с внешней опубликованной меткой времени 2. Внутренний срок действия совпадает с внешним сроком действия 3. Подпись LS2 действительна 4. Данные Lease (запись в leaseSet) корректно сформированы\nСсылки: - Спецификация общих структур - подробности формата LeaseSet2\nВыработка ключа ослепления Обзор I2P использует additive key blinding scheme (аддитивную схему ослепления ключей) на основе Ed25519 и ZCash RedDSA. Ослеплённые ключи обновляются ежедневно (в полночь UTC) для обеспечения прямой секретности.\nОбоснование проектных решений:\nI2P сознательно решил НЕ использовать подход из Приложения A.2 файла Tor rend-spec-v3.txt. Согласно спецификации:\n\u0026ldquo;Мы не используем приложение A.2 из документа Tor rend-spec-v3.txt, которое имеет схожие цели проектирования, поскольку ослеплённые открытые ключи в нём могут находиться вне подгруппы простого порядка, что может иметь неизвестные последствия для безопасности.\u0026rdquo;\nAdditive blinding (аддитивное ослепление) в I2P гарантирует, что ослеплённые ключи остаются в подгруппе простого порядка кривой Ed25519.\nМатематические определения Параметры Ed25519: - B: базовая точка Ed25519 (генератор) = 2^255 - 19 - L: порядок Ed25519 = 2^252 + 27742317777372353535851937790883648493\nКлючевые переменные: - A: Неослеплённый 32-байтовый открытый ключ подписи (в Destination) - a: Неослеплённый 32-байтовый закрытый ключ подписи - A': Ослеплённый 32-байтовый открытый ключ подписи (используется в зашифрованном LeaseSet) - a': Ослеплённый 32-байтовый закрытый ключ подписи - alpha: 32-байтовый фактор ослепления (секрет)\nВспомогательные функции:\nLEOS2IP(x) \u0026ldquo;Преобразование октетной строки Little-Endian (младший порядок байтов) в целое число\u0026rdquo;\nПреобразует массив байтов в формате little-endian в целочисленное представление.\nH*(x) \u0026ldquo;Хеш и редукция\u0026rdquo;\nH*(x) = (LEOS2IP(SHA512(x))) mod L Та же операция, что и при генерации ключа Ed25519.\nПоколение Альфа Ежедневная ротация: Новое значение alpha (секретный параметр ослепления) и blinded keys (ослеплённые ключи) ДОЛЖНЫ быть сгенерированы каждый день в полночь по UTC (00:00:00 UTC).\nАлгоритм GENERATE_ALPHA(destination, date, secret):\n# Input parameters A = destination\u0026#39;s signing public key (32 bytes) stA = signature type of A (2 bytes, big endian) # 0x0007 for Ed25519 or 0x000b for Red25519 stA\u0026#39; = signature type of blinded key A\u0026#39; (2 bytes, big endian) # Always 0x000b (Red25519) datestring = \u0026#34;YYYYMMDD\u0026#34; (8 bytes ASCII from current UTC date) secret = optional UTF-8 encoded string (zero-length if not used) # Computation keydata = A || stA || stA\u0026#39; # 36 bytes total seed = HKDF( salt=H(\u0026#34;I2PGenerateAlpha\u0026#34;, keydata), ikm=datestring || secret, info=\u0026#34;i2pblinding1\u0026#34;, n=64 ) # Treat seed as 64-byte little-endian integer and reduce alpha = seed mod L Проверенные параметры: - Персонализация соли: \u0026ldquo;I2PGenerateAlpha\u0026rdquo; - Параметр info для HKDF: \u0026ldquo;i2pblinding1\u0026rdquo; - Выходные данные: 64 байта до редукции - Распределение alpha: распределено так же, как закрытые ключи Ed25519 после mod L\nОслепление закрытого ключа Алгоритм BLIND_PRIVKEY(a, alpha):\nДля владельца назначения, публикующего зашифрованный LeaseSet:\n# For Ed25519 private key (type 7) if sigtype == 7: seed = destination\u0026#39;s signing private key (32 bytes) a = left_half(SHA512(seed)) # 32 bytes a = clamp(a) # Ed25519 clamping # For Red25519 private key (type 11) elif sigtype == 11: a = destination\u0026#39;s signing private key (32 bytes) # No clamping for Red25519 # Additive blinding using scalar arithmetic blinded_privkey = a\u0026#39; = (a + alpha) mod L # Derive blinded public key blinded_pubkey = A\u0026#39; = DERIVE_PUBLIC(a\u0026#39;) Критически важно: Приведение mod L необходимо для сохранения корректного алгебраического соотношения между закрытым и открытым ключами.\nОслепление открытого ключа Алгоритм BLIND_PUBKEY(A, alpha):\nДля клиентов, получающих и проверяющих зашифрованный LeaseSet:\nalpha = GENERATE_ALPHA(destination, date, secret) A = destination\u0026#39;s signing public key (32 bytes) # Additive blinding using group elements (curve points) blinded_pubkey = A\u0026#39; = A + DERIVE_PUBLIC(alpha) Математическая эквивалентность:\nОба метода дают одинаковые результаты:\nBLIND_PUBKEY(A, alpha) == DERIVE_PUBLIC(BLIND_PRIVKEY(a, alpha)) Это потому, что:\nA\u0026#39; = A + [alpha]B = [a]B + [alpha]B = [a + alpha]B (group operation) = DERIVE_PUBLIC(a + alpha mod L) Подписание с ослеплёнными ключами Неослеплённое подписание LeaseSet:\nНеослеплённый LeaseSet (отправляется непосредственно аутентифицированным клиентам) подписывается с использованием: - Стандартной подписи Ed25519 (тип 7) или Red25519 (тип 11) - Неослеплённого закрытого ключа для подписи - Проверяется с использованием неослеплённого открытого ключа\nС офлайн-ключами: - Подписано временным закрытым ключом без ослепления - Проверено временным открытым ключом без ослепления - Оба должны иметь тип 7 или 11\nПодписание зашифрованного LeaseSet:\nВнешняя часть зашифрованного LeaseSet использует подписи Red25519 с ослеплёнными ключами.\nАлгоритм подписи Red25519:\n# Generate per-signature random nonce T = CSRNG(80) # 80 random bytes # Calculate r (differs from Ed25519) r = H*(T || blinded_pubkey || message) # Rest is same as Ed25519 R = [r]B S = (r + H(R || A\u0026#39; || message) * a\u0026#39;) mod L signature = R || S # 64 bytes total Ключевые отличия от Ed25519: 1. Использует 80 байт случайных данных T (не хэш закрытого ключа) 2. Использует значение открытого ключа напрямую (не хэш закрытого ключа) 3. Каждая подпись уникальна даже для одного и того же сообщения и ключа\nПроверка:\nТо же, что и Ed25519:\n# Parse signature R = signature[0:32] S = signature[32:64] # Verify equation: [S]B = R + [H(R || A\u0026#39; || message)]A\u0026#39; return [S]B == R + [H(R || A\u0026#39; || message)]A\u0026#39; Соображения безопасности Альфа-дистрибутив:\nВ целях безопасности alpha должна распределяться идентично неослеплённым закрытым ключам. При ослеплении Ed25519 (type 7) в Red25519 (type 11) распределения слегка отличаются.\nРекомендация: используйте Red25519 (type 11) как для неослеплённых, так и для ослеплённых ключей, чтобы соответствовать требованиям ZCash: \u0026ldquo;комбинация повторно рандомизированного открытого ключа и подписей, созданных с использованием этого ключа, не позволяет раскрыть исходный ключ, на основе которого он был повторно рандомизирован.\u0026rdquo;\nПоддержка типа 7: Ed25519 поддерживается для обеспечения обратной совместимости с существующими назначениями, но для новых шифрованных назначений рекомендуется тип 11.\nПреимущества ежедневной ротации: - Прямая секретность: компрометация сегодняшнего ослеплённого ключа не раскрывает вчерашний ключ - Несвязываемость: ежедневная ротация предотвращает долгосрочное отслеживание через DHT - Разделение ключей: разные ключи для разных периодов времени\nСсылки: - Спецификация протокола Zcash - Раздел 5.4.6.1 - Обсуждение Tor Key Blinding (ослепление ключа) - Тикет Tor #8106 Шифрование и обработка Деривация Subcredential (производного учетного идентификатора) Перед шифрованием мы вычисляем credential (учетные данные) и subcredential (производные учетные данные), чтобы привязать зашифрованные слои к знанию открытого ключа подписи Destination (идентификатор назначения в I2P).\nЦель: Обеспечить, чтобы только те, кто знает открытый ключ подписи Destination (адрес назначения в I2P), могли расшифровать зашифрованный LeaseSet. Полный Destination не требуется.\nВычисление учетных данных A = destination\u0026#39;s signing public key (32 bytes) stA = signature type of A (2 bytes big endian) # 0x0007 for Ed25519 or 0x000b for Red25519 stA\u0026#39; = signature type of blinded key A\u0026#39; (2 bytes big endian) # Always 0x000b (Red25519) keydata = A || stA || stA\u0026#39; # 36 bytes credential = H(\u0026#34;credential\u0026#34;, keydata) # 32 bytes Разделение доменов: Строка персонализации \u0026ldquo;credential\u0026rdquo; гарантирует, что этот хеш не будет конфликтовать с какими-либо ключами поиска в DHT или с другими применениями протокола.\nВычисление Subcredential (вспомогательных учетных данных) blindedPublicKey = A\u0026#39; (32 bytes, from blinding process) subcredential = H(\u0026#34;subcredential\u0026#34;, credential || blindedPublicKey) # 32 bytes Назначение: subcredential (подучётные данные) привязывает зашифрованный LeaseSet к: 1. Конкретному Destination (через учётные данные) 2. Конкретному ослеплённому ключу (через blindedPublicKey) 3. Конкретному дню (через ежедневную ротацию blindedPublicKey)\nЭто предотвращает атаки повторного воспроизведения и междневное связывание.\nШифрование уровня 1 Контекст: Слой 1 содержит данные авторизации клиента и зашифрован ключом, производным от subcredential (дополнительные учетные данные).\nАлгоритм шифрования # Prepare input outerInput = subcredential || publishedTimestamp # publishedTimestamp: 4 bytes from Layer 0 # Generate random salt outerSalt = CSRNG(32) # 32 bytes # Derive encryption key and IV keys = HKDF( salt=outerSalt, ikm=outerInput, info=\u0026#34;ELS2_L1K\u0026#34;, # Domain separation n=44 # 32 bytes key + 12 bytes IV ) outerKey = keys[0:31] # 32 bytes (indices 0-31 inclusive) outerIV = keys[32:43] # 12 bytes (indices 32-43 inclusive) # Encrypt and prepend salt outerPlaintext = [Layer 1 data] outerCiphertext = outerSalt || ENCRYPT(outerKey, outerIV, outerPlaintext) Вывод: outerCiphertext составляет 32 + len(outerPlaintext) байт.\nСвойства безопасности: - Соль обеспечивает уникальные пары ключ/IV (инициализационный вектор) даже при одинаковом subcredential (производные учетные данные) - Контекстная строка \u0026quot;ELS2_L1K\u0026quot; обеспечивает разделение доменов - ChaCha20 обеспечивает семантическую безопасность (шифртекст неотличим от случайных данных)\nАлгоритм расшифрования # Parse salt from ciphertext outerSalt = outerCiphertext[0:31] # First 32 bytes # Derive decryption key and IV (same process as encryption) outerInput = subcredential || publishedTimestamp keys = HKDF( salt=outerSalt, ikm=outerInput, info=\u0026#34;ELS2_L1K\u0026#34;, n=44 ) outerKey = keys[0:31] # 32 bytes outerIV = keys[32:43] # 12 bytes # Decrypt (skip salt bytes) outerPlaintext = DECRYPT(outerKey, outerIV, outerCiphertext[32:end]) Проверка: После расшифровки убедитесь, что структура уровня 1 корректно сформирована, прежде чем переходить к уровню 2.\nШифрование канального уровня Контекст: Уровень 2 содержит фактические данные LeaseSet2 и зашифрован ключом, полученным из authCookie (если включена аутентификация для каждого клиента (per-client auth)) или из пустой строки (если нет).\nАлгоритм шифрования # Determine authCookie based on authorization mode if per_client_auth_enabled: authCookie = [32-byte cookie from client authorization process] else: authCookie = b\u0026#39;\u0026#39; # Zero-length byte array # Prepare input innerInput = authCookie || subcredential || publishedTimestamp # Generate random salt innerSalt = CSRNG(32) # 32 bytes # Derive encryption key and IV keys = HKDF( salt=innerSalt, ikm=innerInput, info=\u0026#34;ELS2_L2K\u0026#34;, # Domain separation n=44 # 32 bytes key + 12 bytes IV ) innerKey = keys[0:31] # 32 bytes innerIV = keys[32:43] # 12 bytes # Encrypt and prepend salt innerPlaintext = [Layer 2 data: LS2 type byte + LeaseSet2 data] innerCiphertext = innerSalt || ENCRYPT(innerKey, innerIV, innerPlaintext) Вывод: innerCiphertext — это 32 + len(innerPlaintext) байт.\nПривязка ключа: - Если аутентификация клиента отсутствует: Привязан только к subcredential (дополнительные учетные данные) и метке времени - Если аутентификация клиента включена: Дополнительно привязан к authCookie (различается для каждого авторизованного клиента)\nАлгоритм расшифрования # Determine authCookie (same as encryption) if per_client_auth_enabled: authCookie = [32-byte cookie from client authorization process] else: authCookie = b\u0026#39;\u0026#39; # Zero-length byte array # Parse salt from ciphertext innerSalt = innerCiphertext[0:31] # First 32 bytes # Derive decryption key and IV innerInput = authCookie || subcredential || publishedTimestamp keys = HKDF( salt=innerSalt, ikm=innerInput, info=\u0026#34;ELS2_L2K\u0026#34;, n=44 ) innerKey = keys[0:31] # 32 bytes innerIV = keys[32:43] # 12 bytes # Decrypt (skip salt bytes) innerPlaintext = DECRYPT(innerKey, innerIV, innerCiphertext[32:end]) Проверка: После расшифровки: 1. Проверьте, что байт типа LS2 допустим (3 или 7) 2. Разберите структуру LeaseSet2 3. Проверьте, что внутренняя метка времени соответствует внешней опубликованной метке времени 4. Проверьте, что внутренний срок действия соответствует внешнему сроку действия 5. Проверьте подпись LeaseSet2\nОбзор уровня шифрования ┌─────────────────────────────────────────────────┐ │ Layer 0 (Plaintext) │ │ - Blinded public key │ │ - Timestamps │ │ - Signature │ │ │ │ ┌─────────────────────────────────────────┐ │ │ │ Layer 1 (Encrypted with subcredential) │ │ │ │ - Authorization flags │ │ │ │ - Client auth data (if enabled) │ │ │ │ │ │ │ │ ┌────────────────────────────────┐ │ │ │ │ │ Layer 2 (Encrypted with │ │ │ │ │ │ authCookie + subcred) │ │ │ │ │ │ - LeaseSet2 type │ │ │ │ │ │ - LeaseSet2 data │ │ │ │ │ │ - Leases │ │ │ │ │ │ - LS2 signature │ │ │ │ │ └────────────────────────────────┘ │ │ │ └─────────────────────────────────────────┘ │ └─────────────────────────────────────────────────┘ Процесс расшифровки: 1. Проверить подпись уровня 0 с использованием ослеплённого открытого ключа 2. Расшифровать уровень 1, используя subcredential (дополнительные учетные данные) 3. Обработать данные авторизации (если есть), чтобы получить authCookie 4. Расшифровать уровень 2, используя authCookie и subcredential 5. Проверить и разобрать LeaseSet2\nПоклиентская авторизация Обзор Когда включена авторизация для отдельных клиентов, сервер ведёт список авторизованных клиентов. У каждого клиента есть ключевой материал, который необходимо безопасно передать по отдельному каналу связи (вне основного).\nДва механизма авторизации: 1. DH (Диффи-Хеллман) авторизация клиента: Более безопасная, использует согласование ключей X25519 2. PSK (предварительно разделённый ключ) авторизация: Проще, использует симметричные ключи\nОбщие свойства безопасности: - Конфиденциальность состава клиентов: наблюдатели видят число клиентов, но не могут идентифицировать конкретных клиентов - Анонимное добавление/удаление клиентов: невозможно отследить, когда конкретные клиенты добавляются или удаляются - Вероятность коллизии 8-байтового идентификатора клиента: ~1 на 18 квинтиллионов (пренебрежимо мала)\nАвторизация клиента на основе DH Обзор: Каждый клиент генерирует пару ключей X25519 и отправляет свой открытый ключ серверу через безопасный канал out-of-band (вне основного канала). Сервер использует ephemeral DH (временный Диффи-Хеллман) для шифрования уникального authCookie для каждого клиента.\nГенерация ключей клиента # Client generates keypair csk_i = GENERATE_PRIVATE() # 32-byte X25519 private key cpk_i = DERIVE_PUBLIC(csk_i) # 32-byte X25519 public key # Client sends cpk_i to server via secure out-of-band channel # Client KEEPS csk_i secret (never transmitted) Преимущество в безопасности: Закрытый ключ клиента никогда не покидает устройство клиента. Злоумышленник, перехвативший внеполосную передачу (out-of-band transmission), не сможет расшифровать будущие зашифрованные LeaseSets без взлома X25519 DH.\nОбработка на сервере # Server generates new auth cookie and ephemeral keypair authCookie = CSRNG(32) # 32-byte cookie esk = GENERATE_PRIVATE() # 32-byte ephemeral private key epk = DERIVE_PUBLIC(esk) # 32-byte ephemeral public key # For each authorized client i for cpk_i in authorized_clients: # Perform DH key agreement sharedSecret = DH(esk, cpk_i) # 32 bytes # Derive client-specific encryption key authInput = sharedSecret || cpk_i || subcredential || publishedTimestamp okm = HKDF( salt=epk, # Ephemeral public key as salt ikm=authInput, info=\u0026#34;ELS2_XCA\u0026#34;, # Domain separation n=52 # 32 key + 12 IV + 8 ID ) # Extract components clientKey_i = okm[0:31] # 32 bytes clientIV_i = okm[32:43] # 12 bytes clientID_i = okm[44:51] # 8 bytes # Encrypt authCookie for this client clientCookie_i = ENCRYPT(clientKey_i, clientIV_i, authCookie) # Store [clientID_i, clientCookie_i] entry in Layer 1 Структура данных уровня 1:\nephemeralPublicKey (32 bytes) clients (2 bytes) = N [clientID_1 (8 bytes) || clientCookie_1 (32 bytes)] [clientID_2 (8 bytes) || clientCookie_2 (32 bytes)] ... [clientID_N (8 bytes) || clientCookie_N (32 bytes)] Рекомендации для сервера: - Генерируйте новую эфемерную ключевую пару для каждого публикуемого зашифрованного LeaseSet - Случайно перемешивайте порядок клиентов, чтобы предотвратить отслеживание по позиции - Рассмотрите добавление фиктивных записей, чтобы скрыть истинное количество клиентов\nОбработка клиентских запросов # Client has: csk_i (their private key), destination, date, secret # Client receives: encrypted LeaseSet with epk in Layer 1 # Perform DH key agreement with server\u0026#39;s ephemeral public key sharedSecret = DH(csk_i, epk) # 32 bytes # Derive expected client identifier and decryption key cpk_i = DERIVE_PUBLIC(csk_i) # Client\u0026#39;s own public key authInput = sharedSecret || cpk_i || subcredential || publishedTimestamp okm = HKDF( salt=epk, ikm=authInput, info=\u0026#34;ELS2_XCA\u0026#34;, n=52 ) clientKey_i = okm[0:31] # 32 bytes clientIV_i = okm[32:43] # 12 bytes clientID_i = okm[44:51] # 8 bytes # Search Layer 1 authorization data for clientID_i for (clientID, clientCookie) in layer1_auth_entries: if clientID == clientID_i: # Found matching entry, decrypt authCookie authCookie = DECRYPT(clientKey_i, clientIV_i, clientCookie) # Use authCookie to decrypt Layer 2 break else: # No matching entry - client not authorized or revoked raise AuthorizationError(\u0026#34;Client not authorized\u0026#34;) Обработка ошибок на стороне клиента: - Если clientID_i не найден: доступ клиента был отозван или он никогда не был авторизован - Если расшифрование не удалось: повреждённые данные или неверные ключи (крайне редко) - Клиентам следует периодически повторно получать данные для обнаружения отзыва\nАвторизация клиента по PSK (предварительно согласованному ключу) Обзор: У каждого клиента есть предварительно разделённый симметричный ключ длиной 32 байта (PSK — предварительно разделённый ключ). Сервер шифрует один и тот же authCookie с использованием PSK каждого клиента.\nГенерация ключей # Option 1: Client generates key psk_i = CSRNG(32) # 32-byte pre-shared key # Client sends psk_i to server via secure out-of-band channel # Option 2: Server generates key psk_i = CSRNG(32) # 32-byte pre-shared key # Server sends psk_i to one or more clients via secure out-of-band channel Примечание по безопасности: Один и тот же PSK (предварительно разделяемый ключ) может быть общим для нескольких клиентов при желании (создаёт \u0026ldquo;групповую\u0026rdquo; авторизацию).\nСерверная обработка # Server generates new auth cookie and salt authCookie = CSRNG(32) # 32-byte cookie authSalt = CSRNG(32) # 32-byte salt # For each authorized client i for psk_i in authorized_clients: # Derive client-specific encryption key authInput = psk_i || subcredential || publishedTimestamp okm = HKDF( salt=authSalt, ikm=authInput, info=\u0026#34;ELS2PSKA\u0026#34;, # Domain separation n=52 # 32 key + 12 IV + 8 ID ) # Extract components clientKey_i = okm[0:31] # 32 bytes clientIV_i = okm[32:43] # 12 bytes clientID_i = okm[44:51] # 8 bytes # Encrypt authCookie for this client clientCookie_i = ENCRYPT(clientKey_i, clientIV_i, authCookie) # Store [clientID_i, clientCookie_i] entry in Layer 1 Структура данных уровня 1:\nauthSalt (32 bytes) clients (2 bytes) = N [clientID_1 (8 bytes) || clientCookie_1 (32 bytes)] [clientID_2 (8 bytes) || clientCookie_2 (32 bytes)] ... [clientID_N (8 bytes) || clientCookie_N (32 bytes)] Обработка на стороне клиента # Client has: psk_i (their pre-shared key), destination, date, secret # Client receives: encrypted LeaseSet with authSalt in Layer 1 # Derive expected client identifier and decryption key authInput = psk_i || subcredential || publishedTimestamp okm = HKDF( salt=authSalt, ikm=authInput, info=\u0026#34;ELS2PSKA\u0026#34;, n=52 ) clientKey_i = okm[0:31] # 32 bytes clientIV_i = okm[32:43] # 12 bytes clientID_i = okm[44:51] # 8 bytes # Search Layer 1 authorization data for clientID_i for (clientID, clientCookie) in layer1_auth_entries: if clientID == clientID_i: # Found matching entry, decrypt authCookie authCookie = DECRYPT(clientKey_i, clientIV_i, clientCookie) # Use authCookie to decrypt Layer 2 break else: # No matching entry - client not authorized or revoked raise AuthorizationError(\u0026#34;Client not authorized\u0026#34;) Сравнение и рекомендации Feature DH Authorization PSK Authorization Key ExchangeAsymmetric (X25519)Symmetric (shared secret) SecurityHigher (forward secrecy)Lower (depends on PSK secrecy) Client PrivacyPrivate key never transmittedPSK must be transmitted securely PerformanceN+1 DH operationsNo DH operations Key SharingOne key per clientCan share key among multiple clients Revocation DetectionAdversary cannot tell when revokedAdversary can track revocation if PSK intercepted Use CaseHigh security requirementsPerformance-critical or group access **Рекомендации:** - **Используйте DH authorization (авторизацию на основе Диффи‑Хеллмана)** для приложений с повышенными требованиями к безопасности, где важна прямая секретность - **Используйте PSK authorization (авторизацию на основе предварительно согласованного ключа)** когда критична производительность или при управлении группами клиентов - **Никогда не используйте повторно PSKs** для разных сервисов или периодов времени - **Всегда используйте безопасные каналы** для распространения ключей (например, Signal, OTR, PGP) Соображения безопасности Конфиденциальность членства клиента:\nОба механизма обеспечивают конфиденциальность принадлежности клиента посредством: 1. Зашифрованных идентификаторов клиента: 8-байтный clientID, полученный из вывода HKDF 2. Неотличимых cookie (куки): Все 32-байтные значения clientCookie выглядят случайными 3. Отсутствия метаданных, привязанных к клиенту: Невозможно определить, какая запись относится к какому клиенту\nНаблюдатель может видеть:\nКоличество авторизованных клиентов (из поля clients) Изменения количества клиентов со временем Наблюдатель НЕ может видеть: - Какие конкретные клиенты авторизованы - Когда конкретные клиенты добавляются или удаляются (если количество остаётся прежним) - Любая информация, позволяющая идентифицировать клиента\nРекомендации по рандомизации:\nСерверам следует случайным образом перемешивать порядок клиентов каждый раз, когда они генерируют зашифрованный LeaseSet:\nimport random # Before serializing auth_entries = [(clientID_i, clientCookie_i) for each client] random.shuffle(auth_entries) # Now serialize in randomized order Преимущества: - Не позволяет клиентам узнавать своё положение в списке - Предотвращает inference attacks (атаки по выводу) на основе изменений положения - Делает добавление/отзыв клиента неразличимыми\nСокрытие количества клиентов:\nСерверы МОГУТ добавлять случайные фиктивные записи:\n# Add dummy entries num_dummies = random.randint(0, max_dummies) for _ in range(num_dummies): dummy_id = CSRNG(8) dummy_cookie = CSRNG(32) auth_entries.append((dummy_id, dummy_cookie)) # Randomize all entries (real + dummy) random.shuffle(auth_entries) Стоимость: Фиктивные записи увеличивают размер зашифрованного LeaseSet (каждая по 40 байт).\nРотация AuthCookie:\nСерверам СЛЕДУЕТ генерировать новый authCookie (токен аутентификации): - Каждый раз при публикации зашифрованного LeaseSet (набор параметров входящих туннелей) (обычно каждые несколько часов) - Сразу после отзыва доступа у клиента - По регулярному расписанию (например, ежедневно), даже если нет изменений у клиентов\nПреимущества: - Ограничивает последствия, если authCookie скомпрометирован - Гарантирует, что отозванные клиенты быстро теряют доступ - Обеспечивает прямую секретность для уровня 2\nАдресация Base32 для зашифрованных LeaseSets Обзор Традиционные адреса I2P в base32 содержат только хэш назначения (32 байта → 52 символа). Этого недостаточно для зашифрованных LeaseSets, потому что:\nКлиентам нужен неослеплённый открытый ключ, чтобы вывести ослеплённый открытый ключ Клиентам нужны типы подписи (неослеплённой и ослеплённой) для корректной деривации ключа Сам по себе хэш не содержит этой информации Решение: Новый формат base32, включающий типы открытого ключа и подписи.\nСпецификация формата адреса Декодированная структура (35 байт):\n┌─────────────────────────────────────────────────────┐ │ Byte 0 │ Byte 1 │ Byte 2 │ Bytes 3-34 │ │ Flags │ Unblind │ Blinded │ Public Key │ │ (XOR) │ SigType │ SigType │ (32 bytes) │ │ │ (XOR) │ (XOR) │ │ └─────────────────────────────────────────────────────┘ Первые 3 байта (исключающее ИЛИ с контрольной суммой):\nПервые 3 байта содержат метаданные, к которым применена операция XOR (побитовое исключающее ИЛИ) с частями контрольной суммы CRC-32:\n# Data structure before XOR flags = 0x00 # 1 byte (reserved for future use) unblinded_sigtype = 0x07 or 0x0b # 1 byte (7 or 11) blinded_sigtype = 0x0b # 1 byte (always 11) # Compute CRC-32 checksum of public key checksum = crc32(pubkey) # 4-byte CRC-32 of bytes 3-34 # XOR first 3 bytes with parts of checksum data[0] = flags XOR (checksum \u0026gt;\u0026gt; 24) \u0026amp; 0xFF data[1] = unblinded_sigtype XOR (checksum \u0026gt;\u0026gt; 16) \u0026amp; 0xFF data[2] = blinded_sigtype XOR (checksum \u0026gt;\u0026gt; 8) \u0026amp; 0xFF # Bytes 3-34 contain the unmodified 32-byte public key data[3:34] = pubkey Свойства контрольной суммы: - Использует стандартный полином CRC-32 - Частота ложных отрицательных результатов: ~1 на 16 миллионов - Обнаруживает ошибки при опечатках в адресе - Не подходит для аутентификации (не является криптографически стойким)\nЗакодированный формат:\nBase32Encode(35 bytes) || \u0026#34;.b32.i2p\u0026#34; Характеристики: - Всего символов: 56 (35 байт × 8 бит ÷ 5 бит на символ) - Суффикс: \u0026ldquo;.b32.i2p\u0026rdquo; (как в традиционном base32) - Общая длина: 56 + 8 = 64 символа (не включая нулевой терминатор)\nКодирование Base32: - Алфавит: abcdefghijklmnopqrstuvwxyz234567 (стандарт RFC 4648) - 5 неиспользуемых битов в конце ДОЛЖНЫ быть равны 0 - Нечувствительно к регистру (по соглашению — нижний регистр)\nГенерация адреса import struct from zlib import crc32 import base64 def generate_encrypted_b32_address(pubkey, unblinded_sigtype, blinded_sigtype): \u0026#34;\u0026#34;\u0026#34; Generate base32 address for encrypted LeaseSet. Args: pubkey: 32-byte public key (bytes) unblinded_sigtype: Unblinded signature type (7 or 11) blinded_sigtype: Blinded signature type (always 11) Returns: String address ending in .b32.i2p \u0026#34;\u0026#34;\u0026#34; # Verify inputs assert len(pubkey) == 32, \u0026#34;Public key must be 32 bytes\u0026#34; assert unblinded_sigtype in [7, 11], \u0026#34;Unblinded sigtype must be 7 or 11\u0026#34; assert blinded_sigtype == 11, \u0026#34;Blinded sigtype must be 11\u0026#34; # Compute CRC-32 of public key checksum = crc32(pubkey) \u0026amp; 0xFFFFFFFF # Ensure 32-bit unsigned # Prepare metadata bytes flags = 0x00 # XOR metadata with checksum parts byte0 = flags ^ ((checksum \u0026gt;\u0026gt; 24) \u0026amp; 0xFF) byte1 = unblinded_sigtype ^ ((checksum \u0026gt;\u0026gt; 16) \u0026amp; 0xFF) byte2 = blinded_sigtype ^ ((checksum \u0026gt;\u0026gt; 8) \u0026amp; 0xFF) # Construct 35-byte data data = bytes([byte0, byte1, byte2]) + pubkey # Base32 encode (standard alphabet) # Python\u0026#39;s base64 module uses uppercase by default b32 = base64.b32encode(data).decode(\u0026#39;ascii\u0026#39;).lower().rstrip(\u0026#39;=\u0026#39;) # Construct full address address = b32 + \u0026#34;.b32.i2p\u0026#34; return address Разбор адресов import struct from zlib import crc32 import base64 def parse_encrypted_b32_address(address): \u0026#34;\u0026#34;\u0026#34; Parse base32 address for encrypted LeaseSet. Args: address: String address ending in .b32.i2p Returns: Tuple of (pubkey, unblinded_sigtype, blinded_sigtype) Raises: ValueError: If address is invalid or checksum fails \u0026#34;\u0026#34;\u0026#34; # Remove suffix if not address.endswith(\u0026#39;.b32.i2p\u0026#39;): raise ValueError(\u0026#34;Invalid address suffix\u0026#34;) b32 = address[:-8] # Remove \u0026#34;.b32.i2p\u0026#34; # Verify length (56 characters for 35 bytes) if len(b32) != 56: raise ValueError(f\u0026#34;Invalid length: {len(b32)} (expected 56)\u0026#34;) # Base32 decode # Add padding if needed padding_needed = (8 - (len(b32) % 8)) % 8 b32_padded = b32.upper() + \u0026#39;=\u0026#39; * padding_needed try: data = base64.b32decode(b32_padded) except Exception as e: raise ValueError(f\u0026#34;Invalid base32 encoding: {e}\u0026#34;) # Verify decoded length if len(data) != 35: raise ValueError(f\u0026#34;Invalid decoded length: {len(data)} (expected 35)\u0026#34;) # Extract public key pubkey = data[3:35] # Compute CRC-32 for verification checksum = crc32(pubkey) \u0026amp; 0xFFFFFFFF # Un-XOR metadata bytes flags = data[0] ^ ((checksum \u0026gt;\u0026gt; 24) \u0026amp; 0xFF) unblinded_sigtype = data[1] ^ ((checksum \u0026gt;\u0026gt; 16) \u0026amp; 0xFF) blinded_sigtype = data[2] ^ ((checksum \u0026gt;\u0026gt; 8) \u0026amp; 0xFF) # Verify expected values if flags != 0x00: raise ValueError(f\u0026#34;Invalid flags: {flags:#x} (expected 0x00)\u0026#34;) if unblinded_sigtype not in [7, 11]: raise ValueError(f\u0026#34;Invalid unblinded sigtype: {unblinded_sigtype} (expected 7 or 11)\u0026#34;) if blinded_sigtype != 11: raise ValueError(f\u0026#34;Invalid blinded sigtype: {blinded_sigtype} (expected 11)\u0026#34;) return pubkey, unblinded_sigtype, blinded_sigtype Сравнение с традиционным Base32 Feature Traditional B32 Encrypted LS2 B32 ContentSHA-256 hash of DestinationPublic key + signature types Decoded Size32 bytes35 bytes Encoded Length52 characters56 characters Suffix.b32.i2p.b32.i2p Total Length60 chars64 chars ChecksumNoneCRC-32 (XOR'd into first 3 bytes) Use CaseRegular destinationsEncrypted LeaseSet destinations ### Ограничения использования Несовместимость с BitTorrent:\nЗашифрованные адреса LS2 (LeaseSet v2 — вторая версия LeaseSet) НЕ МОГУТ использоваться с компактными ответами на announce в BitTorrent:\nCompact announce reply format: ┌────────────────────────────┐ │ 32-byte destination hash │ ← Only hash, no signature types │ 2-byte port │ └────────────────────────────┘ Проблема: Компактный формат содержит только хэш (32 байта), при этом нет места для типов подписи или информации об открытом ключе.\nРешение: Используйте полные ответы на announce-запросы или HTTP-трекеры, которые поддерживают полные адреса.\nИнтеграция с адресной книгой Если у клиента в адресной книге есть полный Destination (публичный адрес/идентификатор в I2P):\nХранить полный Destination (идентификатор назначения в I2P; включает открытый ключ) Поддерживать обратный поиск по хешу При обнаружении зашифрованного LS2 (LeaseSet v2 — формат leaseSet версии 2), получать открытый ключ из адресной книги Новый формат base32 не требуется, если полный Destination уже известен Форматы адресной книги, поддерживающие зашифрованный LS2: - hosts.txt с полными строками назначения - базы данных SQLite со столбцом назначения - форматы JSON/XML с полными данными назначения\nПримеры реализации Пример 1: Генерация адреса\n# Ed25519 destination example pubkey = bytes.fromhex(\u0026#39;a\u0026#39; * 64) # 32-byte public key unblinded_type = 7 # Ed25519 blinded_type = 11 # Red25519 (always) address = generate_encrypted_b32_address(pubkey, unblinded_type, blinded_type) print(f\u0026#34;Address: {address}\u0026#34;) # Output: 56 base32 characters + .b32.i2p Пример 2: Разбор и валидация\naddress = \u0026#34;abc...xyz.b32.i2p\u0026#34; # 56 chars + suffix try: pubkey, unblinded, blinded = parse_encrypted_b32_address(address) print(f\u0026#34;Public Key: {pubkey.hex()}\u0026#34;) print(f\u0026#34;Unblinded SigType: {unblinded}\u0026#34;) print(f\u0026#34;Blinded SigType: {blinded}\u0026#34;) except ValueError as e: print(f\u0026#34;Invalid address: {e}\u0026#34;) Пример 3: Преобразование из Destination (идентификатора назначения)\ndef destination_to_encrypted_b32(destination): \u0026#34;\u0026#34;\u0026#34; Convert full Destination to encrypted LS2 base32 address. Args: destination: I2P Destination object Returns: Base32 address string \u0026#34;\u0026#34;\u0026#34; # Extract public key and signature type from destination pubkey = destination.signing_public_key # 32 bytes sigtype = destination.sig_type # 7 or 11 # Blinded type is always 11 (Red25519) blinded_type = 11 # Generate address return generate_encrypted_b32_address(pubkey, sigtype, blinded_type) Соображения безопасности Конфиденциальность: - Адрес Base32 раскрывает открытый ключ - Это сделано намеренно и требуется протоколом - НЕ раскрывает закрытый ключ и не подрывает безопасность - Открытые ключи по замыслу являются общедоступной информацией\nУстойчивость к коллизиям: - CRC-32 обеспечивает лишь 32 бита устойчивости к коллизиям - Не является криптографически стойким (используйте только для обнаружения ошибок) - НЕ полагайтесь на контрольную сумму для аутентификации - По-прежнему требуется полная проверка назначения\nПроверка адреса: - Всегда проверяйте контрольную сумму перед использованием - Отклоняйте адреса с недопустимыми типами подписи - Проверьте, что открытый ключ лежит на кривой (зависит от реализации)\nСсылки: - Предложение 149: B32 для Encrypted LS2 - Спецификация адресации B32 - Спецификация именования I2P Поддержка офлайн‑ключей Обзор Офлайн-ключи позволяют основному ключу подписи оставаться офлайн (в холодном хранении), в то время как для повседневных операций используется временный ключ подписи. Это критически важно для сервисов с повышенными требованиями к безопасности.\nОсобые требования к зашифрованному LS2: - Временные ключи должны генерироваться офлайн - Ослеплённые закрытые ключи должны быть предварительно сгенерированы (по одному в день) - И временные, и ослеплённые ключи передаются партиями - Стандартизированный формат файла ещё не определён (TODO в спецификации)\nСтруктура офлайн-ключа Данные эфемерного ключа уровня 0 (когда бит 0 флага = 1):\n┌───────────────────────────────────────────────────┐ │ Expires Timestamp │ 4 bytes (seconds) │ │ Transient Sig Type │ 2 bytes (big endian) │ │ Transient Signing Pubkey│ Variable (sigtype len) │ │ Signature (by blinded) │ 64 bytes (Red25519) │ └───────────────────────────────────────────────────┘ Что охватывает подпись: Подпись в блоке офлайн-ключа охватывает: - Метка времени истечения срока действия (4 байта) - Тип подписи временного ключа (2 байта) - Открытый ключ временной подписи (переменной длины)\nЭта подпись проверяется с использованием ослеплённого открытого ключа, что доказывает, что сторона, обладающая ослеплённым закрытым ключом, санкционировала этот временный ключ.\nПроцесс генерации ключей Для зашифрованного LeaseSet с офлайн-ключами:\nСгенерируйте временные пары ключей (офлайн, в холодном хранилище):\n# For each day in future for date in future_dates: # Generate daily transient keypair transient_privkey = generate_red25519_privkey() # Type 11 transient_pubkey = derive_public(transient_privkey) # Store for later delivery keys[date] = (transient_privkey, transient_pubkey) Generate daily blinded keypairs (offline, in cold storage):\nДля каждого дня for date in future_dates: # Derive alpha for this date datestring = date.strftime(\u0026quot;%Y%m%d\u0026quot;) # \u0026quot;YYYYMMDD\u0026quot; alpha = GENERATE_ALPHA(destination, datestring, secret) # Blind the signing private key a = destination_signing_privkey # Type 7 or 11 blinded_privkey = BLIND_PRIVKEY(a, alpha) # Result is type 11 blinded_pubkey = DERIVE_PUBLIC(blinded_privkey) # Store for later delivery blinded_keys[date] = (blinded_privkey, blinded_pubkey) 3. **Sign transient keys with blinded keys** (offline): ```python for date in future_dates: transient_pubkey = keys[date][1] blinded_privkey = blinded_keys[date][0] # Create signature data expires = int((date + timedelta(days=1)).timestamp()) sig_data = struct.pack(\u0026#39;\u0026gt;I\u0026#39;, expires) # 4 bytes sig_data += struct.pack(\u0026#39;\u0026gt;H\u0026#39;, 11) # Transient type (Red25519) sig_data += transient_pubkey # 32 bytes # Sign with blinded private key signature = RED25519_SIGN(blinded_privkey, sig_data) # Package for delivery offline_sig_blocks[date] = { \u0026#39;expires\u0026#39;: expires, \u0026#39;transient_type\u0026#39;: 11, \u0026#39;transient_pubkey\u0026#39;: transient_pubkey, \u0026#39;signature\u0026#39;: signature } Package for delivery to router: Для каждой даты delivery_package[date] = { 'transient_privkey': keys[date][0], 'transient_pubkey': keys[date][1], 'blinded_privkey': blinded_keys[date][0], 'blinded_pubkey': blinded_keys[date][1], 'offline_sig_block': offline_sig_blocks[date] }\n### Router Usage **Daily Key Loading:** ```python # В полночь по UTC (или до публикации) date = datetime.utcnow().date() # Загрузить ключи на сегодня today_keys = load_delivery_package(date) transient_privkey = today_keys[\u0026#39;transient_privkey\u0026#39;] transient_pubkey = today_keys[\u0026#39;transient_pubkey\u0026#39;] blinded_privkey = today_keys[\u0026#39;blinded_privkey\u0026#39;] blinded_pubkey = today_keys[\u0026#39;blinded_pubkey\u0026#39;] offline_sig_block = today_keys[\u0026#39;offline_sig_block\u0026#39;] # Используйте эти ключи для сегодняшнего зашифрованного LeaseSet (записи с перечнем входящих туннелей узла) Publishing Process:\n# 1. Создайте внутренний LeaseSet2 inner_ls2 = create_leaseset2( destinations, leases, expires, signing_key=transient_privkey # Use transient key ) # 2. Зашифруйте уровень 2 layer2_ciphertext = encrypt_layer2(inner_ls2, authCookie, subcredential, timestamp) # 3. Создайте уровень 1 с данными авторизации layer1_plaintext = create_layer1(authorization_data, layer2_ciphertext) # 4. Зашифруйте слой 1 layer1_ciphertext = encrypt_layer1(layer1_plaintext, subcredential, timestamp) # 5. Создайте слой 0 с блоком офлайн-подписи layer0 = create_layer0( blinded_pubkey, timestamp, expires, flags=0x0001, # Bit 0 set (offline keys present) offline_sig_block=offline_sig_block, layer1_ciphertext=layer1_ciphertext ) # 6. Подписать слой 0 временным закрытым ключом signature = RED25519_SIGN(transient_privkey, layer0) # 7. Добавьте подпись и опубликуйте encrypted_leaseset = layer0 + signature publish_to_netdb(encrypted_leaseset) Security Considerations Tracking via Offline Signature Block:\nThe offline signature block is in plaintext (Layer 0). An adversary scraping floodfills could:\nTrack the same encrypted LeaseSet across multiple days Correlate encrypted LeaseSets even though blinded keys change daily Mitigation: Generate new transient keys daily (in addition to blinded keys):\n# Генерируйте каждый день ОБА типа ключей — новые временные и новые blinded keys (ослепленные ключи) for date in future_dates: # New transient keypair for this day transient_privkey = generate_red25519_privkey() transient_pubkey = derive_public(transient_privkey) # New blinded keypair for this day alpha = GENERATE_ALPHA(destination, datestring, secret) blinded_privkey = BLIND_PRIVKEY(signing_privkey, alpha) blinded_pubkey = DERIVE_PUBLIC(blinded_privkey) # Sign new transient key with new blinded key sig = RED25519_SIGN(blinded_privkey, transient_pubkey || metadata) # Now offline sig block changes daily Benefits:\nPrevents tracking across days via offline signature block Provides same security as encrypted LS2 without offline keys Each day appears completely independent Cost:\nMore keys to generate and store More complex key management File Format (TODO) Current Status: No standardized file format defined for batch key delivery.\nRequirements for Future Format:\nMust support multiple dates:\nBatch delivery of 30+ days worth of keys Clear date association for each key set Must include all necessary data:\nTransient private key Transient public key Blinded private key Blinded public key Pre-computed offline signature block Expiration timestamps Should be tamper-evident:\nChecksums or signatures over entire file Integrity verification before loading Should be encrypted:\nKeys are sensitive material Encrypt file with router\u0026rsquo;s key or passphrase Proposed Format Example (JSON, encrypted):\n{ \u0026#34;version\u0026#34;: 1, \u0026#34;destination_hash\u0026#34;: \u0026#34;base64...\u0026#34;, \u0026#34;keys\u0026#34;: [ { \u0026#34;date\u0026#34;: \u0026#34;2025-10-15\u0026#34;, \u0026#34;transient\u0026#34;: { \u0026#34;type\u0026#34;: 11, \u0026#34;privkey\u0026#34;: \u0026#34;base64...\u0026#34;, \u0026#34;pubkey\u0026#34;: \u0026#34;base64...\u0026#34; }, \u0026#34;blinded\u0026#34;: { \u0026#34;privkey\u0026#34;: \u0026#34;base64...\u0026#34;, \u0026#34;pubkey\u0026#34;: \u0026#34;base64...\u0026#34; }, \u0026#34;offline_sig_block\u0026#34;: { \u0026#34;expires\u0026#34;: 1729123200, \u0026#34;signature\u0026#34;: \u0026#34;base64...\u0026#34; } } ], \u0026#34;signature\u0026#34;: \u0026#34;base64...\u0026#34; // Signature over entire structure } I2CP Protocol Enhancement (TODO) Current Status: No I2CP protocol enhancement defined for offline keys with encrypted LeaseSet.\nRequirements:\nKey delivery mechanism:\nUpload batch of keys from client to router Acknowledgment of successful key loading Key expiration notification:\nRouter notifies client when keys running low Client can generate and upload new batch Key revocation:\nEmergency revocation of future keys if compromise suspected Proposed I2CP Messages:\nUPLOAD_OFFLINE_KEYS - Пакет зашифрованного ключевого материала - Охватываемый диапазон дат OFFLINE_KEY_STATUS - Количество оставшихся дней - Дата истечения срока действия следующего ключа REVOKE_OFFLINE_KEYS - Диапазон дат для отзыва - Новые ключи для замены (необязательно) Implementation Status Java I2P:\n✅ Offline keys for standard LS2: Fully supported (since 0.9.38) ⚠️ Offline keys for encrypted LS2: Implemented (since 0.9.40) ❌ File format: Not standardized ❌ I2CP protocol: Not enhanced i2pd (C++):\n✅ Offline keys for standard LS2: Fully supported ✅ Offline keys for encrypted LS2: Fully supported (since 2.58.0) ❌ File format: Not standardized ❌ I2CP protocol: Not enhanced References:\nOffline Signatures Proposal I2CP Specification Security Considerations Cryptographic Security Algorithm Selection:\nAll cryptographic primitives are based on well-studied algorithms:\nChaCha20: Modern stream cipher, constant-time, no timing attacks SHA-256: NIST-approved hash, 128-bit security level HKDF: RFC 5869 standard, proven security bounds Ed25519/Red25519: Curve25519-based, ~128-bit security level X25519: Diffie-Hellman over Curve25519, ~128-bit security level Key Sizes:\nAll symmetric keys: 256 bits (32 bytes) All public/private keys: 256 bits (32 bytes) All nonces/IVs: 96 bits (12 bytes) All signatures: 512 bits (64 bytes) These sizes provide adequate security margins against current and near-future attacks.\nForward Secrecy Daily Key Rotation:\nEncrypted LeaseSets rotate keys daily (UTC midnight):\nNew blinded public/private key pair New storage location in DHT New encryption keys for both layers Benefits:\nCompromising today\u0026rsquo;s blinded key doesn\u0026rsquo;t reveal yesterday\u0026rsquo;s Limits exposure window to 24 hours Prevents long-term tracking via DHT Enhanced with Ephemeral Keys:\nDH client authorization uses ephemeral keys:\nServer generates new ephemeral DH keypair for each publication Compromising ephemeral key only affects that publication True forward secrecy even if long-term keys compromised Privacy Properties Destination Blinding:\nThe blinded public key:\nIs unlinkable to the original destination (without knowing the secret) Changes daily, preventing long-term correlation Cannot be reversed to find the original public key Client Membership Privacy:\nPer-client authorization provides:\nAnonymity: No way to identify which clients are authorized Untraceability: Cannot track when specific clients added/revoked Size obfuscation: Can add dummy entries to hide true count DHT Privacy:\nStorage location rotates daily:\nlocation = SHA-256(sig_type || blinded_public_key) This prevents:\nCorrelation across days via DHT lookups Long-term monitoring of service availability Traffic analysis of DHT queries Threat Model Adversary Capabilities:\nNetwork Adversary:\nCan monitor all DHT traffic Can observe encrypted LeaseSet publications Cannot decrypt without proper keys Floodfill Adversary:\nCan store and analyze all encrypted LeaseSets Can track publication patterns over time Cannot decrypt Layer 1 or Layer 2 Can see client count (but not identities) Authorized Client Adversary:\nCan decrypt specific encrypted LeaseSets Can access inner LeaseSet2 data Cannot determine other clients\u0026rsquo; identities Cannot decrypt past LeaseSets (with ephemeral keys) Out of Scope:\nMalicious router implementations Compromised router host systems Side-channel attacks (timing, power analysis) Physical access to keys Social engineering attacks Attack Scenarios 1. Offline Keys Tracking Attack:\nAttack: Adversary tracks encrypted LeaseSets via unchanging offline signature block.\nMitigation: Generate new transient keys daily (in addition to blinded keys).\nStatus: Documented recommendation, implementation-specific.\n2. Client Position Inference Attack:\nAttack: If client order is static, clients can infer their position and detect when other clients added/removed.\nMitigation: Randomize client order in authorization list for each publication.\nStatus: Documented recommendation in specification.\n3. Client Count Analysis Attack:\nAttack: Adversary monitors client count changes over time to infer service popularity or client churn.\nMitigation: Add random dummy entries to authorization list.\nStatus: Optional feature, deployment-specific trade-off (size vs. privacy).\n4. PSK Interception Attack:\nAttack: Adversary intercepts PSK during out-of-band exchange and can decrypt all future encrypted LeaseSets.\nMitigation: Use DH client authorization instead, or ensure secure key exchange (Signal, OTR, PGP).\nStatus: Known limitation of PSK approach, documented in specification.\n5. Timing Correlation Attack:\nAttack: Adversary correlates publication times across days to link encrypted LeaseSets.\nMitigation: Randomize publication times, use delayed publishing.\nStatus: Implementation-specific, not addressed in core specification.\n6. Long-term Secret Compromise:\nAttack: Adversary compromises the blinding secret and can compute all past and future blinded keys.\nMitigation:\nUse optional secret parameter (not empty) Rotate secret periodically Use different secrets for different services Status: Secret parameter is optional; using it is highly recommended.\nOperational Security Key Management:\nSigning Private Key:\nStore offline in cold storage Use only for generating blinded keys (batch process) Never expose to online router Blinded Private Keys:\nGenerate offline, deliver in batches Rotate daily automatically Delete after use (forward secrecy) Transient Private Keys (with offline keys):\nGenerate offline, deliver in batches Can be longer-lived (days/weeks) Rotate regularly for enhanced privacy Client Authorization Keys:\nDH: Client private keys never leave client device PSK: Use unique keys per client, secure exchange Revoke immediately upon client removal Secret Management:\nThe optional secret parameter in GENERATE_ALPHA:\nSHOULD be used for high-security services MUST be transmitted securely to authorized clients SHOULD be rotated periodically (e.g., monthly) CAN be different for different client groups Monitoring and Auditing:\nPublication Monitoring:\nVerify encrypted LeaseSets published successfully Monitor floodfill acceptance rates Alert on publication failures Client Access Monitoring:\nLog client authorization attempts (without identifying clients) Monitor for unusual patterns Detect potential attacks early Key Rotation Auditing:\nVerify daily key rotation occurs Check blinded key changes daily Ensure old keys are deleted Implementation Security Constant-Time Operations:\nImplementations MUST use constant-time operations for:\nAll scalar arithmetic (mod L operations) Private key comparisons Signature verification DH key agreement Memory Security:\nZero sensitive key material after use Use secure memory allocation for keys Prevent keys from being paged to disk Clear stack variables containing key material Random Number Generation:\nUse cryptographically secure RNG (CSRNG) Properly seed RNG from OS entropy source Do not use predictable RNGs for key material Verify RNG output quality periodically Input Validation:\nValidate all public keys are on the curve Check all signature types are supported Verify all lengths before parsing Reject malformed encrypted LeaseSets early Error Handling:\nDo not leak information via error messages Use constant-time comparison for authentication Do not expose timing differences in decryption Log security-relevant events properly Recommendations For Service Operators:\n✅ Use Red25519 (type 11) for new destinations ✅ Use DH client authorization for high-security services ✅ Generate new transient keys daily when using offline keys ✅ Use the optional secret parameter in GENERATE_ALPHA ✅ Randomize client order in authorization lists ✅ Monitor publication success and investigate failures ⚠️ Consider dummy entries to hide client count (size trade-off) For Client Implementers:\n✅ Validate blinded public keys are on prime-order subgroup ✅ Verify all signatures before trusting data ✅ Use constant-time operations for cryptographic primitives ✅ Zero key material immediately after use ✅ Implement proper error handling without information leaks ✅ Support both Ed25519 and Red25519 destination types For Network Operators:\n✅ Accept encrypted LeaseSets in floodfill routers ✅ Enforce reasonable size limits to prevent abuse ✅ Monitor for anomalous patterns (extremely large, frequent updates) ⚠️ Consider rate limiting encrypted LeaseSet publications Implementation Notes Java I2P Implementation Repository: https://github.com/i2p/i2p.i2p Key Classes:\nnet.i2p.data.LeaseSet2 - LeaseSet2 structure net.i2p.data.EncryptedLeaseSet - Encrypted LS2 implementation net.i2p.crypto.eddsa.EdDSAEngine - Ed25519/Red25519 signatures net.i2p.crypto.HKDF - HKDF implementation net.i2p.crypto.ChaCha20 - ChaCha20 cipher Configuration:\nEnable encrypted LeaseSet in clients.config:\n# Включить зашифрованный LeaseSet (набор записей о входящих туннелях) i2cp.encryptLeaseSet=true # Необязательно: включите авторизацию клиента i2cp.enableAccessList=true # Необязательно: используйте авторизацию DH (по умолчанию — PSK) i2cp.accessListType=0 # Необязательно: секрет ослепления (настоятельно рекомендуется) i2cp.blindingSecret=your-secret-here API Usage Example:\n// Создать зашифрованный LeaseSet EncryptedLeaseSet els = new EncryptedLeaseSet(); // Установить назначение els.setDestination(destination); // Включить авторизацию для каждого клиента els.setAuthorizationEnabled(true); els.setAuthType(EncryptedLeaseSet.AUTH_DH); // Добавьте авторизованных клиентов (публичные ключи DH) for (byte[] clientPubKey : authorizedClients) { els.addClient(clientPubKey); } // Установите параметры ослепления els.setBlindingSecret(\u0026#34;your-secret\u0026#34;); // Подписать и опубликовать els.sign(signingPrivateKey); netDb.publish(els); i2pd (C++) Implementation Repository: https://github.com/PurpleI2P/i2pd Key Files:\nlibi2pd/LeaseSet.h/cpp - LeaseSet implementations libi2pd/Crypto.h/cpp - Cryptographic primitives libi2pd/Ed25519.h/cpp - Ed25519/Red25519 signatures libi2pd/ChaCha20.h/cpp - ChaCha20 cipher Configuration:\nEnable in tunnel configuration (tunnels.conf):\n[my-hidden-service] type = http host = 127.0.0.1 port = 8080 keys = my-service-keys.dat # Включить зашифрованный LeaseSet (описание входящих туннелей назначения) encryptleaseset = true # Необязательно: Тип авторизации клиента (0=DH, 1=PSK) authtype = 0 # Необязательно: Секрет ослепления secret = your-secret-here # Необязательно: Авторизованные клиенты (по одному в строке, открытые ключи, закодированные в base64) client.1 = открытый ключ клиента 1, закодированный в base64 client.2 = открытый ключ клиента 2, закодированный в base64 API Usage Example:\n// Создать зашифрованный LeaseSet auto encryptedLS = std::make_shared\u0026lt;i2p::data::EncryptedLeaseSet\u0026gt;( destination, blindingSecret ); // Включить авторизацию для каждого клиента encryptedLS-\u0026gt;SetAuthType(i2p::data::AUTH_TYPE_DH); // Добавить авторизованных клиентов for (const auto\u0026amp; clientPubKey : authorizedClients) { encryptedLS-\u0026gt;AddClient(clientPubKey); } // Подписать и опубликовать encryptedLS-\u0026gt;Sign(signingPrivKey); netdb.Publish(encryptedLS); Testing and Debugging Test Vectors:\nGenerate test vectors for implementation verification:\n# Тестовый вектор 1: Ослепление ключа destination_pubkey = bytes.fromhex(\u0026#39;a\u0026#39; * 64) sigtype = 7 blinded_sigtype = 11 date = \u0026#34;20251015\u0026#34; secret = \u0026#34;\u0026#34; alpha = generate_alpha(destination_pubkey, sigtype, blinded_sigtype, date, secret) print(f\u0026#34;Alpha: {alpha.hex()}\u0026#34;) # Ожидается: (сверить с эталонной реализацией) Unit Tests:\nKey areas to test:\nHKDF derivation with various inputs ChaCha20 encryption/decryption Red25519 signature generation and verification Key blinding (private and public) Layer 1/2 encryption/decryption Client authorization (DH and PSK) Base32 address generation and parsing Integration Tests:\nPublish encrypted LeaseSet to test network Retrieve and decrypt from client Verify daily key rotation Test client authorization (add/remove clients) Test offline keys (if supported) Common Implementation Errors:\nIncorrect mod L reduction: Must use proper modular arithmetic Endianness errors: Most fields are big-endian, but some crypto uses little-endian Off-by-one in array slicing: Verify indices are inclusive/exclusive as needed Missing constant-time comparisons: Use constant-time for all sensitive comparisons Not zeroing key material: Always zero keys after use Performance Considerations Computational Costs:\nOperation Cost Notes Key blinding (server)1 scalar multPer publication Key blinding (client)1 point add + 1 scalar multPer retrieval Layer 1 encryption1 HKDF + 1 ChaCha20Fast Layer 2 encryption1 HKDF + 1 ChaCha20Fast DH client auth (server)N+1 X25519 opsN = number of clients DH client auth (client)1 X25519 opPer retrieval PSK client auth0 DH opsOnly HKDF + ChaCha20 Signature (Red25519)1 signature opSimilar cost to Ed25519 Size Overhead:\nComponent Size Frequency Blinded public key32 bytesPer LeaseSet Layer 1 encryption overhead32 bytes (salt)Per LeaseSet Layer 2 encryption overhead32 bytes (salt)Per LeaseSet DH auth per client40 bytesPer client per LeaseSet DH ephemeral pubkey32 bytesPer LeaseSet (if DH auth) PSK auth per client40 bytesPer client per LeaseSet PSK salt32 bytesPer LeaseSet (if PSK auth) Signature64 bytesPer LeaseSet Offline sig block≈100 bytesPer LeaseSet (if offline keys) Typical Sizes:\nNo client auth: ~200 bytes overhead With 10 DH clients: ~600 bytes overhead With 100 DH clients: ~4200 bytes overhead Optimization Tips:\nBatch key generation: Generate blinded keys for multiple days in advance Cache subcredentials: Compute once per day, reuse for all publications Reuse ephemeral keys: Can reuse ephemeral DH key for short period (minutes) Parallel client encryption: Encrypt client cookies in parallel Fast path for no auth: Skip authorization layer entirely when disabled Compatibility Backward Compatibility:\nEd25519 (type 7) destinations supported for unblinded keys Red25519 (type 11) required for blinded keys Traditional LeaseSets still fully supported Encrypted LeaseSets do not break existing network Forward Compatibility:\nReserved flag bits for future features Extensible authorization scheme (3 bits allow 8 types) Version field in various structures Interoperability:\nJava I2P and i2pd fully interoperable since: Java I2P 0.9.40 (May 2019) i2pd 2.58.0 (September 2025) Encrypted LeaseSets work across implementations Client authorization works across implementations References IETF RFCs RFC 2104 - HMAC: Keyed-Hashing for Message Authentication (February 1997) RFC 5869 - HMAC-based Extract-and-Expand Key Derivation Function (HKDF) (May 2010) RFC 7539 - ChaCha20 and Poly1305 for IETF Protocols (May 2015) RFC 7748 - Elliptic Curves for Security (January 2016) I2P Specifications Common Structures Specification - LeaseSet2 and EncryptedLeaseSet structures Proposal 123: New netDB Entries - Background and design of LeaseSet2 Proposal 146: Red25519 - Red25519 signature scheme specification Proposal 149: B32 for Encrypted LS2 - Base32 addressing for encrypted LeaseSets Red25519 Specification - Detailed Red25519 implementation B32 Addressing Specification - Base32 address format Network Database Documentation - NetDB usage and operations I2CP Specification - I2P Client Protocol Cryptographic References Ed25519 Paper - \u0026ldquo;High-speed high-security signatures\u0026rdquo; by Bernstein et al. ZCash Protocol Specification - Section 5.4.6: RedDSA signature scheme Tor Rendezvous Specification v3 - Tor\u0026rsquo;s onion service specification (for comparison) Security References Key Blinding Security Discussion - Tor Project mailing list discussion Tor Ticket #8106 - Key blinding implementation discussion PRNG Security - Random number generator security considerations Tor PRNG Discussion - Discussion of PRNG usage in Tor Implementation References Java I2P Repository - Official Java implementation i2pd Repository - C++ implementation I2P Website - Official I2P project website I2P Specifications - Complete specification index Version History I2P Release Notes - Official release announcements Java I2P Releases - GitHub release history i2pd Releases - GitHub release history Appendix A: Cryptographic Constants Ed25519 / Red25519 Constants # Базовая точка Ed25519 (генератор) B = 2**255 - 19 # Порядок Ed25519 (размер скалярного поля) L = 2**252 + 27742317777372353535851937790883648493 # Значения типов подписи SIGTYPE_ED25519 = 7 # 0x0007 SIGTYPE_RED25519 = 11 # 0x000b # Длины ключей PRIVKEY_SIZE = 32 # байт PUBKEY_SIZE = 32 # байт SIGNATURE_SIZE = 64 # байт ChaCha20 Constants # Параметры ChaCha20 (алгоритма потокового шифрования) CHACHA20_KEY_SIZE = 32 # байт (256 бит) CHACHA20_NONCE_SIZE = 12 # байт (96 бит) CHACHA20_INITIAL_COUNTER = 1 # RFC 7539 допускает 0 или 1 HKDF Constants # Параметры HKDF HKDF_HASH = \u0026#34;SHA-256\u0026#34; HKDF_SALT_MAX = 32 # байт (HashLen) # Строки параметра info HKDF (разделение доменов) HKDF_INFO_ALPHA = b\u0026#34;i2pblinding1\u0026#34; HKDF_INFO_LAYER1 = b\u0026#34;ELS2_L1K\u0026#34; HKDF_INFO_LAYER2 = b\u0026#34;ELS2_L2K\u0026#34; HKDF_INFO_DH_AUTH = b\u0026#34;ELS2_XCA\u0026#34; HKDF_INFO_PSK_AUTH = b\u0026#34;ELS2PSKA\u0026#34; Hash Personalization Strings # Строки персонализации для SHA-256 HASH_PERS_ALPHA = b\u0026#34;I2PGenerateAlpha\u0026#34; HASH_PERS_RED25519 = b\u0026#34;I2P_Red25519H(x)\u0026#34; HASH_PERS_CREDENTIAL = b\u0026#34;credential\u0026#34; HASH_PERS_SUBCREDENTIAL = b\u0026#34;subcredential\u0026#34; Structure Sizes # Размеры слоя 0 (внешнего) BLINDED_SIGTYPE_SIZE = 2 # байта BLINDED_PUBKEY_SIZE = 32 # байта (для Red25519) PUBLISHED_TS_SIZE = 4 # байта EXPIRES_SIZE = 2 # байта FLAGS_SIZE = 2 # байта LEN_OUTER_CIPHER_SIZE = 2 # байта SIGNATURE_SIZE = 64 # байта (Red25519) # Размеры блоков офлайн-ключа OFFLINE_EXPIRES_SIZE = 4 # байт OFFLINE_SIGTYPE_SIZE = 2 # байт OFFLINE_SIGNATURE_SIZE = 64 # байт # Размеры слоя 1 (среднего) AUTH_FLAGS_SIZE = 1 # байт EPHEMERAL_PUBKEY_SIZE = 32 # байта (DH аутентификация) AUTH_SALT_SIZE = 32 # байта (PSK аутентификация) NUM_CLIENTS_SIZE = 2 # байта CLIENT_ID_SIZE = 8 # байт CLIENT_COOKIE_SIZE = 32 # байта AUTH_CLIENT_ENTRY_SIZE = 40 # байт (CLIENT_ID + CLIENT_COOKIE) # Накладные расходы шифрования SALT_SIZE = 32 # байт (добавляется в начало каждого зашифрованного слоя) # Base32-адрес B32_ENCRYPTED_DECODED_SIZE = 35 # bytes B32_ENCRYPTED_ENCODED_LEN = 56 # characters B32_SUFFIX = \u0026#34;.b32.i2p\u0026#34; Appendix B: Test Vectors Test Vector 1: Alpha Generation Input:\n# Открытый ключ назначения (Ed25519) A = bytes.fromhex(\u0026#39;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\u0026#39;) stA = 0x0007 # Ed25519 stA_prime = 0x000b # Red25519 date = \u0026#34;20251015\u0026#34; secret = \u0026#34;\u0026#34; # Пустой секрет Computation:\nkeydata = A || bytes([0x00, 0x07]) || bytes([0x00, 0x0b]) # keydata = 36 байт salt = SHA256(b\u0026#34;I2PGenerateAlpha\u0026#34; + keydata) ikm = b\u0026#34;20251015\u0026#34; info = b\u0026#34;i2pblinding1\u0026#34; seed = HKDF(salt, ikm, info, 64) alpha = LEOS2IP(seed) по модулю L Expected Output:\n(Сверьте с эталонной реализацией) alpha = [64-байтовое шестнадцатеричное значение] Test Vector 2: ChaCha20 Encryption Input:\nkey = bytes([i for i in range(32)]) # 0x00..0x1f nonce = bytes([i for i in range(12)]) # 0x00..0x0b plaintext = b\u0026#34;Hello, I2P!\u0026#34; Computation:\nciphertext = ChaCha20_Encrypt(key, nonce, plaintext, counter=1) Expected Output:\nciphertext = [сверить с тестовыми векторами RFC 7539] Test Vector 3: HKDF Input:\nsalt = bytes(32) # Все нули ikm = b\u0026#34;test input keying material\u0026#34; info = b\u0026#34;ELS2_L1K\u0026#34; n = 44 Computation:\nkeys = HKDF(salt, ikm, info, n) Expected Output:\nkeys = [44-байтовое шестнадцатеричное значение] Test Vector 4: Base32 Address Input:\npubkey = bytes.fromhex(\u0026#39;bbbb\u0026#39; + \u0026#39;bb\u0026#39; * 30) # 32 байта unblinded_sigtype = 11 # Red25519 blinded_sigtype = 11 # Red25519 Computation:\naddress = generate_encrypted_b32_address(pubkey, unblinded_sigtype, blinded_sigtype) Expected Output:\naddress = [56 символов base32].b32.i2p # Убедитесь, что проверка контрольной суммы выполняется корректно Appendix C: Glossary Alpha (α): The secret blinding factor used to blind public and private keys. Generated from the destination, date, and optional secret.\nAuthCookie: A 32-byte random value encrypted for each authorized client, used as input to Layer 2 encryption.\nB (Base Point): The generator point for the Ed25519 elliptic curve.\nBlinded Key: A public or private key that has been transformed using the alpha blinding factor. Blinded keys cannot be linked to the original keys without knowing alpha.\nChaCha20: A stream cipher providing fast, secure encryption without requiring AES hardware support.\nClientID: An 8-byte identifier derived from HKDF output, used to identify authorization entries for clients.\nClientCookie: A 32-byte encrypted value containing the authCookie for a specific client.\nCredential: A 32-byte value derived from the destination\u0026rsquo;s public key and signature types, binding encryption to knowledge of the destination.\nCSRNG: Cryptographically Secure Random Number Generator. Must provide unpredictable output suitable for key generation.\nDH (Diffie-Hellman): A cryptographic protocol for securely establishing shared secrets. I2P uses X25519.\nEd25519: An elliptic curve signature scheme providing fast signatures with 128-bit security level.\nEphemeral Key: A short-lived cryptographic key, typically used once and then discarded.\nFloodfill: I2P routers that store and serve network database entries, including encrypted LeaseSets.\nHKDF: HMAC-based Key Derivation Function, used to derive multiple cryptographic keys from a single source.\nL (Order): The order of the Ed25519 scalar field (approximately 2^252).\nLayer 0 (Outer): The plaintext portion of an encrypted LeaseSet, containing blinded key and metadata.\nLayer 1 (Middle): The first encrypted layer, containing client authorization data.\nLayer 2 (Inner): The innermost encrypted layer, containing the actual LeaseSet2 data.\nLeaseSet2 (LS2): Second version of I2P\u0026rsquo;s network database entry format, introducing encrypted variants.\nNetDB: The I2P network database, a distributed hash table storing router and destination information.\nOffline Keys: A feature allowing the main signing key to remain in cold storage while a transient key handles daily operations.\nPSK (Pre-Shared Key): A symmetric key shared in advance between two parties, used for PSK client authorization.\nRed25519: An Ed25519-based signature scheme with key blinding support, based on ZCash RedDSA.\nSalt: Random data used as input to key derivation functions to ensure unique outputs.\nSigType: A numeric identifier for signature algorithms (e.g., 7 = Ed25519, 11 = Red25519).\nSubcredential: A 32-byte value derived from the credential and blinded public key, binding encryption to a specific encrypted LeaseSet.\nTransient Key: A temporary signing key used with offline keys, with a limited validity period.\nX25519: An elliptic curve Diffie-Hellman protocol over Curve25519, providing key agreement.\nDocument Information Status: This document represents the current stable encrypted LeaseSet specification as implemented in I2P since June 2019. The protocol is mature and widely deployed.\nContributing: For corrections or improvements to this documentation, please submit issues or pull requests to the I2P specifications repository.\nSupport: For questions about implementing encrypted LeaseSets:\nI2P Forum: https://i2pforum.net/ IRC: #i2p-dev on OFTC Matrix: #i2p-dev:matrix.org Acknowledgments: This specification builds on work by the I2P development team, ZCash cryptography research, and Tor Project\u0026rsquo;s key blinding research.\n","description":"Формат LeaseSet с контролем доступа для приватных назначений","id":"14f2a4c0bb3f459df8db8dbce45508ff","section":"docs","title":"Зашифрованный LeaseSet","url":"/ru/docs/specs/encryptedleaseset/"},{"categories":null,"content":"I2P-адреса представляют собой длинные криптографические ключи. Система именования обеспечивает более дружественный уровень поверх этих ключей без введения центрального органа управления. Все имена являются локальными — каждый router самостоятельно определяет, на какое назначение ссылается имя хоста.\nНужна предыстория? В обсуждении именования документированы исходные дискуссии по дизайну, альтернативные предложения и философские основы децентрализованной системы именования I2P.\n1. Компоненты Система именования I2P состоит из нескольких независимых, но взаимодействующих подсистем:\nNaming service – преобразует имена хостов в destinations и обрабатывает Base32 имена хостов . HTTP proxy – передает запросы .i2p в router и предлагает jump-сервисы, когда имя неизвестно. Host-add сервисы – CGI-формы, которые добавляют новые записи в локальную адресную книгу. Jump-сервисы – удаленные помощники, которые возвращают destination для указанного имени хоста. Адресная книга – периодически загружает и объединяет удаленные списки хостов, используя локально доверенную \u0026ldquo;сеть доверия\u0026rdquo;. SusiDNS – веб-интерфейс для управления адресными книгами, подписками и локальными переопределениями. Такая модульная архитектура позволяет пользователям определять собственные границы доверия и автоматизировать процесс именования в той степени, в которой они считают нужным.\n2. Службы именования API именования роутера (net.i2p.client.naming) поддерживает несколько бэкендов через настраиваемое свойство i2p.naming.impl=\u0026lt;class\u0026gt;. Каждая реализация может предлагать различные стратегии поиска, но все они используют одну и ту же модель доверия и разрешения имён.\n2.1 Hosts.txt (legacy format) Устаревшая модель использовала три текстовых файла, проверяемых по порядку:\nprivatehosts.txt userhosts.txt hosts.txt Каждая строка хранит соответствие hostname=base64-destination. Этот простой текстовый формат по-прежнему полностью поддерживается для импорта/экспорта, но он больше не используется по умолчанию из-за низкой производительности при превышении списком хостов нескольких тысяч записей.\n2.2 Blockfile Naming Service (default backend) Представлена в релизе 0.8.8, Blockfile Naming Service теперь является бэкендом по умолчанию. Она заменяет плоские файлы высокопроизводительным хранилищем ключ/значение на основе skiplist на диске (hostsdb.blockfile), обеспечивая примерно в 10 раз более быструю скорость поиска.\nОсновные характеристики: - Хранит несколько логических адресных книг (private, user и hosts) в одной бинарной базе данных. - Поддерживает совместимость с устаревшим импортом/экспортом hosts.txt. - Поддерживает обратный поиск, метаданные (дата добавления, источник, комментарии) и эффективное кэширование. - Использует тот же трёхуровневый порядок поиска: private → user → hosts.\nЭтот подход обеспечивает обратную совместимость, при этом значительно повышая скорость разрешения и масштабируемость.\n2.1 Hosts.txt (устаревший формат) Разработчики могут реализовать пользовательские backend-системы, такие как: - Meta – объединяет несколько систем именования. - PetName – поддерживает petnames, хранящиеся в petnames.txt. - AddressDB, Exec, Eepget и Dummy – для внешнего разрешения имён или резервных вариантов.\nРеализация blockfile остается рекомендуемым бэкендом для общего использования благодаря производительности и надежности.\n3. Base32 Hostnames Имена хостов Base32 (*.b32.i2p) работают аналогично адресам .onion в Tor. Когда вы обращаетесь к адресу .b32.i2p:\nRouter декодирует Base32 содержимое. Он восстанавливает destination непосредственно из ключа — поиск в адресной книге не требуется. Это гарантирует достижимость, даже если не существует человекочитаемого имени хоста. Расширенные Base32 имена, представленные в релизе 0.9.40, поддерживают LeaseSet2 и зашифрованные назначения.\n4. Address Book \u0026amp; Subscriptions Приложение адресной книги получает списки удалённых хостов по HTTP и объединяет их локально в соответствии с настроенными пользователем правилами доверия.\n2.2 Blockfile Naming Service (стандартный бэкенд) Подписки представляют собой стандартные .i2p URL, указывающие на hosts.txt или ленты инкрементальных обновлений. Обновления загружаются периодически (по умолчанию ежечасно) и проверяются перед объединением. Конфликты разрешаются по принципу «первым пришёл — первым обслужен», следуя порядку приоритета:\nprivatehosts.txt → userhosts.txt → hosts.txt. Default Providers Начиная с I2P 2.3.0 (июнь 2023 года), включены два провайдера подписок по умолчанию: - http://i2p-projekt.i2p/hosts.txt - http://notbob.i2p/hosts.txt\nЭта избыточность повышает надежность, сохраняя при этом модель локального доверия. Пользователи могут добавлять или удалять подписки через SusiDNS.\nIncremental Updates Инкрементальные обновления загружаются через newhosts.txt (заменяя устаревшую концепцию recenthosts.cgi). Эта конечная точка обеспечивает эффективные обновления на основе ETag — возвращая только новые записи с момента последнего запроса или 304 Not Modified, когда изменений нет.\n2.3 Альтернативные бэкенды и плагины Сервисы добавления хостов (add*.cgi) позволяют вручную отправлять сопоставления имени и destination. Всегда проверяйте destination перед принятием. Jump-сервисы отвечают соответствующим ключом и могут перенаправлять через HTTP-прокси с параметром ?i2paddresshelper=. Распространённые примеры: stats.i2p, identiguy.i2p и notbob.i2p. Эти сервисы не являются доверенными центрами—пользователи должны сами решать, какие использовать. 5. Managing Entries Locally (SusiDNS) SusiDNS доступен по адресу: http://127.0.0.1:7657/susidns/\nВы можете: - Просматривать и редактировать локальные адресные книги. - Управлять подписками и устанавливать их приоритет. - Импортировать/экспортировать списки хостов. - Настраивать расписание обновлений.\nНовое в I2P 2.8.1 (март 2025 года): - Добавлена функция «сортировка по последним». - Улучшена обработка подписок (исправление несоответствий ETag).\nВсе изменения остаются локальными — адресная книга каждого роутера уникальна.\n3. Base32 имена хостов Следуя RFC 9476, I2P зарегистрировал .i2p.alt в GNUnet Assigned Numbers Authority (GANA) по состоянию на март 2025 года (I2P 2.8.1).\nЦель: Предотвратить случайные утечки DNS из-за неправильно настроенного программного обеспечения.\nDNS-резолверы, совместимые с RFC 9476, не будут пересылать домены .alt в публичный DNS. Программное обеспечение I2P обрабатывает .i2p.alt как эквивалент .i2p, удаляя суффикс .alt при разрешении. .i2p.alt не предназначен для замены .i2p; это техническая мера защиты, а не ребрендинг. 4. Адресная книга и подписки Ключи destination: 516–616 байт (Base64) Имена хостов: Максимум 67 символов (включая .i2p) Допустимые символы: a–z, 0–9, -, . (без двойных точек, без заглавных букв) Зарезервировано: *.b32.i2p ETag и Last-Modified: активно используются для минимизации трафика Средний размер hosts.txt: ~400 КБ для ~800 хостов (пример) Использование трафика: ~10 байт/сек при обновлении каждые 12 часов 8. Security Model and Philosophy I2P намеренно жертвует глобальной уникальностью в обмен на децентрализацию и безопасность — прямое применение треугольника Зуко (Zooko\u0026rsquo;s Triangle).\nКлючевые принципы: - Отсутствие центрального органа: все запросы выполняются локально. - Устойчивость к перехвату DNS: запросы шифруются с использованием публичных ключей назначения. - Предотвращение Sybil-атак: отсутствие голосования или консенсусного именования. - Неизменяемые сопоставления: после установления локальной ассоциации она не может быть удалённо переопределена.\nСистемы именования на основе блокчейна (например, Namecoin, ENS) исследовали решение всех трёх сторон треугольника Зуко, но I2P намеренно избегает их из-за задержек, сложности и философской несовместимости с его моделью локального доверия.\n9. Compatibility and Stability Никакие функции именования не были признаны устаревшими в период 2023–2025. Формат hosts.txt, jump-сервисы, подписки и все реализации API именования остаются функциональными. Проект I2P поддерживает строгую обратную совместимость при внедрении улучшений производительности и безопасности (изоляция NetDB, разделение Sub-DB и т.д.). 10. Best Practices Храните только доверенные подписки; избегайте больших списков неизвестных хостов. Создавайте резервные копии hostsdb.blockfile и privatehosts.txt перед обновлением или переустановкой. Регулярно проверяйте jump-сервисы и отключайте те, которым больше не доверяете. Помните: ваша адресная книга определяет вашу версию мира I2P — каждое имя хоста является локальным. Further Reading Обсуждение именования Спецификация Blockfile Формат файла конфигурации Javadoc службы именования ","description":"Как I2P сопоставляет удобочитаемые имена хостов с адресами назначения","id":"fc2ecb5df890709d0740d866d03a6250","section":"docs","title":"Именование и Адресная книга","url":"/ru/docs/overview/naming/"},{"categories":null,"content":" Основная ветка разработки I2P (i2p.i2p) настроена таким образом, чтобы разработчики могли легко настроить две из наиболее часто используемых IDE для разработки на Java: Eclipse и NetBeans. Eclipse Основные ветки разработки I2P (i2p.i2p и ветки, созданные на его основе) содержат build.gradle, чтобы обеспечить простую настройку ветки в Eclipse. Убедитесь, что у вас установлена последняя версия Eclipse. Подойдёт любая версия новее 2017 года. Склонируйте ветку I2P в какую-либо директорию (например, $HOME/dev/i2p.i2p). Выберите «File → Import...», а затем в разделе «Gradle» выберите «Existing Gradle Project». В поле «Project root directory:» укажите директорию, в которую была склонирована ветка I2P. В диалоговом окне «Import Options» выберите «Gradle Wrapper» и нажмите Continue. В диалоговом окне «Import Preview» вы можете просмотреть структуру проекта. В разделе «i2p.i2p» должны отобразиться несколько проектов. Нажмите «Finish». Готово! Ваше рабочее пространство теперь содержит все проекты из ветки I2P, и их зависимости сборки должны быть корректно настроены. NetBeans Основные ветки разработки I2P (i2p.i2p и ветки от неё) содержат файлы проекта NetBeans. ","description":"Настройка Eclipse и NetBeans для разработки I2P с использованием Gradle и встроенных файлов проекта","id":"59847e4ae7ce8d8ccadb441422ecc856","section":"docs","title":"Использование IDE с I2P","url":"/ru/docs/guides/ides/"},{"categories":null,"content":"Обзор I2CP — это низкоуровневый протокол управления между I2P router и любым клиентским процессом. Он определяет строгое разделение ответственности:\nRouter: Управляет маршрутизацией, криптографией, жизненными циклами tunnel и операциями сетевой базы данных Клиент: Выбирает параметры анонимности, настраивает tunnels и отправляет/получает сообщения Весь обмен данными осуществляется через один TCP-сокет (опционально — в TLS-обёртке), что обеспечивает асинхронную, полнодуплексную работу.\nВерсия протокола: I2CP использует байт версии протокола 0x2A (42 в десятичной системе), отправляемый во время первоначального установления соединения. Этот байт версии оставался неизменным с момента создания протокола.\nТекущее состояние: Эта спецификация актуальна для router версии 0.9.67 (версия API 0.9.67), выпущенной в сентябре 2025 года.\nКонтекст реализации Реализация на Java Референсная реализация находится в Java I2P: - Клиентский SDK: i2p.jar пакет - Реализация router: router.jar пакет - Javadocs Когда клиент и router выполняются в одной виртуальной машине Java (JVM), сообщения I2CP передаются как объекты Java без сериализации. Внешние клиенты используют сериализованный протокол поверх TCP.\nРеализация на C++ i2pd (C++ I2P router) также реализует I2CP как внешний интерфейс для клиентских подключений.\nКлиенты не на Java Не существует известных реализаций не на Java полной клиентской библиотеки I2CP. Приложения не на Java должны вместо этого использовать более высокоуровневые протоколы:\nSAM (Simple Anonymous Messaging — простой анонимный обмен сообщениями) v3: Интерфейс на основе сокетов с библиотеками на нескольких языках программирования BOB (Basic Open Bridge — базовый открытый мост): Более простая альтернатива SAM Эти протоколы более высокого уровня скрывают сложность I2CP внутри себя и также предоставляют потоковую библиотеку (для TCP-подобных соединений) и библиотеку дейтаграмм (для UDP-подобных соединений).\nУстановление соединения 1. TCP-соединение Подключитесь к порту I2CP router:\nПо умолчанию: 127.0.0.1:7654 Настраивается в настройках router Необязательная TLS-обёртка (настоятельно рекомендуется для удалённых подключений) 2. Рукопожатие протокола Шаг 1: Отправьте байт версии протокола 0x2A\nШаг 2: Синхронизация часов\nClient → Router: GetDateMessage Router → Client: SetDateMessage router возвращает свою текущую метку времени и строку версии API I2CP (начиная с 0.8.7).\nШаг 3: Аутентификация (если включена)\nНачиная с 0.9.11, аутентификация может быть включена в GetDateMessage в виде Mapping (структуры ключ-значение), который содержит: - i2cp.username - i2cp.password\nНачиная с 0.9.16, если включена аутентификация, она должна быть завершена через GetDateMessage до отправки любых других сообщений.\nШаг 4: Создание сеанса\nClient → Router: CreateSessionMessage (contains SessionConfig) Router → Client: SessionStatusMessage (status=Created) Шаг 5: Сигнал готовности Tunnel\nRouter → Client: RequestVariableLeaseSetMessage Это сообщение сигнализирует о том, что входящие tunnels построены. router НЕ отправит его, пока не будут существовать как минимум один входящий И один исходящий tunnel.\nШаг 6: Публикация LeaseSet\nClient → Router: CreateLeaseSet2Message На этом этапе сеанс полностью готов к отправке и получению сообщений.\nШаблоны потоков сообщений Исходящее сообщение (клиент отправляет удалённому назначению) При i2cp.messageReliability=none:\nClient → Router: SendMessageMessage (nonce=0) [No acknowledgments] С i2cp.messageReliability=BestEffort:\nClient → Router: SendMessageMessage (nonce\u0026gt;0) Router → Client: MessageStatusMessage (status=Accepted) Router → Client: MessageStatusMessage (status=Success or Failure) Входящее сообщение (Router доставляет клиенту) При i2cp.fastReceive=true (по умолчанию начиная с версии 0.9.4):\nRouter → Client: MessagePayloadMessage [No acknowledgment required] При i2cp.fastReceive=false (УСТАРЕЛО):\nRouter → Client: MessageStatusMessage (status=Available) Client → Router: ReceiveMessageBeginMessage Router → Client: MessagePayloadMessage Client → Router: ReceiveMessageEndMessage Современные клиенты всегда должны использовать режим быстрого приёма.\nОбщие структуры данных Заголовок сообщения I2CP Все сообщения I2CP используют этот общий заголовок:\n+----+----+----+----+----+----+----+----+ | Body Length (4 bytes) | +----+----+----+----+----+----+----+----+ |Type| Message Body (variable) | +----+----+----+----+----+----+----+----+ Длина тела: 4-байтовое целое число, длина только тела сообщения (без заголовка) Тип: 1-байтовое целое число, идентификатор типа сообщения Тело сообщения: 0+ байт, формат зависит от типа сообщения Ограничение размера сообщения: Примерно 64 КБ максимум.\nИдентификатор сессии Двухбайтовое целое число, уникально идентифицирующее сеанс на router.\nСпециальное значение: 0xFFFF означает «нет сессии» (используется для разрешения имени хоста без установленной сессии).\nИдентификатор сообщения 4-байтовое целое число, генерируемое router для однозначной идентификации сообщения в рамках сеанса.\nВажно: идентификаторы сообщений не являются глобально уникальными, они уникальны только в пределах сеанса. Они также отличаются от nonce (одноразового числа), генерируемого клиентом.\nФормат полезной нагрузки Полезные данные сообщений сжимаются gzip с использованием стандартного 10-байтового заголовка gzip: - Начинается с: 0x1F 0x8B 0x08 (RFC 1952) - Начиная с 0.7.1: неиспользуемые части заголовка gzip содержат информацию о протоколе, from-port (порт-источник) и to-port (порт-назначение) - Это позволяет использовать потоковую передачу и дейтаграммы на одном и том же назначении\nУправление сжатием: Установите i2cp.gzip=false, чтобы отключить сжатие (устанавливает уровень сжатия gzip в 0). Заголовок gzip по-прежнему включается, но накладные расходы на сжатие минимальны.\nСтруктура SessionConfig Определяет конфигурацию для клиентского сеанса:\n+----------------------------------+ | Destination | +----------------------------------+ | Mapping (configuration options) | +----------------------------------+ | Creation Date | +----------------------------------+ | Signature | +----------------------------------+ Критические требования: 1. Отображение должно быть отсортировано по ключу для проверки подписи 2. Дата создания должна быть в пределах ±30 секунд от текущего времени router 3. Подпись создаётся с помощью SigningPrivateKey объекта Destination (адрес назначения в I2P)\nОфлайн-подписи (по состоянию на 0.9.38):\nПри использовании офлайн-подписания Mapping (отображение ключ‑значение) должно содержать: - i2cp.leaseSetOfflineExpiration - i2cp.leaseSetTransientPublicKey - i2cp.leaseSetOfflineSignature\nЗатем подпись генерируется временным закрытым ключом подписи (SigningPrivateKey).\nПараметры конфигурации ядра Конфигурация Tunnel Option Default Description inbound.length 3 Number of hops for inbound tunnels outbound.length 3 Number of hops for outbound tunnels inbound.lengthVariance 0 Random variance in hop count (since 0.7.6) outbound.lengthVariance 0 Random variance in hop count (since 0.7.6) inbound.quantity 2 Number of concurrent inbound tunnels outbound.quantity 2 Number of concurrent outbound tunnels inbound.backupQuantity 0 Standby inbound tunnels (hot spares) outbound.backupQuantity 0 Standby outbound tunnels (hot spares) inbound.allowZeroHop true Allow 0-hop tunnels (disable for full anonymity) outbound.allowZeroHop true Allow 0-hop tunnels (disable for full anonymity) **Примечания**: - Значения параметра `quantity` \u003e 6 требуют узлов, работающих на версии 0.9.0+, и существенно увеличивают потребление ресурсов - Установите `backupQuantity` в значение 1-2 для сервисов с высокой доступностью - Zero-hop tunnels (туннели без промежуточных узлов) жертвуют анонимностью ради снижения задержки, но полезны для тестирования Обработка сообщений Option Default Description clientMessageTimeout 60000\u0026nbsp;ms Legacy timeout for message delivery i2cp.messageReliability BestEffort None, BestEffort, or Guaranteed i2cp.fastReceive true Skip ReceiveMessageBegin/End handshake (default since 0.9.4) i2cp.gzip true Enable gzip compression of message payloads outbound.priority 0 Priority for outbound scheduling (-25 to +25) **Надёжность сообщений**: - `None`: Нет подтверждений от router (значение по умолчанию стриминговой библиотеки начиная с 0.8.1) - `BestEffort`: Router отправляет уведомления о принятии + об успехе/сбое - `Guaranteed`: Не реализовано (в настоящее время ведёт себя как BestEffort) Переопределение на уровне сообщения (начиная с 0.9.14): - В сессии с messageReliability=none, установка ненулевого nonce (одноразовое число) запрашивает уведомление о доставке для этого конкретного сообщения - Установка nonce=0 в сессии BestEffort отключает уведомления для этого сообщения\nКонфигурация LeaseSet Option Default Description i2cp.dontPublishLeaseSet false Disable automatic LeaseSet publication (for client-only destinations) i2cp.leaseSetType 1 LeaseSet variant: 1 = standard, 3 = LS2, 5 = encrypted, 7 = meta i2cp.leaseSetEncType 0 Comma-separated encryption type codes (see below) ### Устаревшие теги сеанса ElGamal/AES Эти параметры применимы только к устаревшему шифрованию Эль-Гамаля:\nOption Default Description crypto.lowTagThreshold 30 Minimum session tags before replenishing crypto.tagsToSend 40 Number of tags to send in a batch **Примечание**: Клиенты ECIES-X25519 используют другой механизм ратчета и игнорируют эти параметры. Типы шифрования I2CP поддерживает несколько схем сквозного шифрования с помощью параметра i2cp.leaseSetEncType. Можно указать несколько типов (через запятую), чтобы обеспечить совместимость как с современными пирами, так и с пирами старых версий.\nПоддерживаемые типы шифрования Type Algorithm Key Size Since Status 0 ElGamal/AES+SessionTags 2048-bit ElGamal Original Legacy 1-3 Reserved - - Unused 4 ECIES-X25519-AEAD-Ratchet 32-byte X25519 0.9.46 Current Standard 5 ECIES-X25519-AEAD-Ratchet + ML-KEM-768 hybrid 32\u0026nbsp;+\u0026nbsp;PQ 0.9.67 Beta 6 ECIES-X25519-AEAD-Ratchet + ML-KEM-1024 hybrid 32\u0026nbsp;+\u0026nbsp;PQ 0.9.67 Beta 7 Reserved (likely ML-KEM-512 hybrid) 32\u0026nbsp;+\u0026nbsp;PQ Future Planned **Рекомендуемая конфигурация**: i2cp.leaseSetEncType=4,0 Здесь используется X25519 (предпочтительно) с резервным переходом на ElGamal для совместимости.\nПодробности о типах шифрования Тип 0 - ElGamal/AES+SessionTags (одноразовые теги сессии): - 2048-битные открытые ключи ElGamal (256 байт) - симметричное шифрование AES-256 - 32-байтные session tags передаются партиями - высокие накладные расходы по CPU, полосе пропускания и памяти - постепенно выводится из эксплуатации по всей сети\nТип 4 - ECIES-X25519-AEAD-Ratchet: - Обмен ключами X25519 (ключи по 32 байта) - ChaCha20/Poly1305 AEAD - Двойной ратчет в стиле Signal - 8-байтовые теги сеанса (по сравнению с 32 байтами у ElGamal) - Теги генерируются с помощью синхронизированного PRNG (генератора псевдослучайных чисел; не отправляются заранее) - ~92% сокращение накладных расходов по сравнению с ElGamal - Стандарт для современного I2P (это используется большинством routers)\nТипы 5-6 - постквантовый гибрид: - Комбинирует X25519 с ML-KEM (NIST FIPS 203) - Обеспечивает устойчивость к квантовым атакам - ML-KEM-768 — для баланса безопасности/производительности - ML-KEM-1024 — для максимальной безопасности - Увеличенный размер сообщений из-за постквантового ключевого материала - Поддержка в сети всё ещё внедряется\nСтратегия миграции Сеть I2P активно мигрирует с ElGamal (тип 0) на X25519 (тип 4): - NTCP → NTCP2 (завершено) - SSU → SSU2 (завершено) - ElGamal tunnels → X25519 tunnels (завершено) - сквозное шифрование ElGamal → ECIES-X25519 (в основном завершено)\nLeaseSet2 (новый формат LeaseSet в I2P) и расширенные возможности Параметры LeaseSet2 (начиная с 0.9.38) Option Since Purpose i2cp.leaseSetType 0.9.38 Specifies LeaseSet variant (1, 3, 5, 7) i2cp.leaseSetEncType 0.9.38 Encryption types supported (comma-separated) i2cp.leaseSetAuthType 0.9.41 Per-client authentication: 0 = none, 1 = DH, 2 = PSK i2cp.leaseSetPrivKey 0.9.41 X25519 private key for decrypting LS2 with auth i2cp.leaseSetSecret 0.9.39 Base64 secret for blinded addresses i2cp.leaseSetTransientPublicKey 0.9.38 Transient signing key for offline signatures i2cp.leaseSetPrivateKey 0.9.18 Persistent LeaseSet encryption keys (type:key pairs) i2cp.leaseSetOption.nnn 0.9.66 Service records (proposal 167) i2cp.leaseSetClient.dh.nnn 0.9.41 DH client auth material (indexed from 0) i2cp.leaseSetClient.psk.nnn 0.9.41 PSK client auth material (indexed from 0) ### Ослеплённые адреса Начиная с версии 0.9.39, назначения могут использовать адреса \u0026ldquo;blinded\u0026rdquo; (b33 format) (адреса с ослеплением — скрывают исходный публичный ключ), которые периодически меняются: - Требуется i2cp.leaseSetSecret для защиты паролем - Необязательная аутентификация для каждого клиента - Подробности см. в предложениях 123 и 149\nСервисные записи (начиная с 0.9.66) LeaseSet2 поддерживает параметры сервисной записи (предложение 167):\ni2cp.leaseSetOption.0=_smtp._tcp=1 86400 0 0 25 mail.example.b32.i2p Формат следует стилю записей DNS SRV, но адаптирован для I2P.\nНесколько сеансов (начиная с 0.9.21) Одно подключение по I2CP может поддерживать несколько сеансов:\nОсновная сессия: Первая сессия, созданная для соединения Подсессии: Дополнительные сессии, разделяющие пул tunnel основной сессии\nХарактеристики подсессии Общие Tunnels: Используют те же пулы входящих/исходящих tunnel, что и у основного Общие ключи шифрования: Должны использовать идентичные ключи шифрования LeaseSet Разные ключи подписи: Должны использовать различные ключи подписи Destination (адрес назначения) Нет гарантии анонимности: Явно связаны с основным сеансом (тот же router, те же tunnels) Сценарий использования подсессии Включить связь с назначениями, использующими разные типы подписи: - Основной: подпись EdDSA (современная) - Subsession (подсессия): подпись DSA (обратная совместимость)\nЖизненный цикл подсессии Создание:\nClient → Router: CreateSessionMessage Router → Client: SessionStatusMessage (unique Session ID) Router → Client: RequestVariableLeaseSetMessage (separate for each destination) Client → Router: CreateLeaseSet2Message (separate for each destination) Уничтожение: - Уничтожение подсессии: Оставляет основную сессию нетронутой - Уничтожение основной сессии: Уничтожает все подсессии и закрывает соединение - DisconnectMessage (сообщение отключения): Уничтожает все сессии\nОбработка идентификатора сеанса Большинство сообщений I2CP содержат поле идентификатора сеанса (Session ID). Исключения: - DestLookup / DestReply (устарели, используйте HostLookup / HostReply) - GetBandwidthLimits / BandwidthLimits (ответ не зависит от сеанса)\nВажно: Клиентам не следует иметь несколько одновременно незавершённых сообщений CreateSession, поскольку ответы нельзя однозначно сопоставить с запросами.\nКаталог сообщений Сводка типов сообщений Type Name Direction Since Status 1 CreateSession C → R Original Current 2 ReconfigureSession C → R 0.7.1 Current 3 DestroySession C → R Original Current 4 CreateLeaseSet C → R Original Deprecated 5 SendMessage C → R Original Current 6 ReceiveMessageBegin C → R Original Deprecated 7 ReceiveMessageEnd C → R Original Deprecated 8 GetBandwidthLimits C → R 0.7.2 Current 20 SessionStatus R → C Original Current 21 RequestLeaseSet R → C Original Deprecated 22 MessageStatus R → C Original Current 23 BandwidthLimits R → C 0.7.2 Current 29 ReportAbuse Bidirectional Original Unused 30 Disconnect Bidirectional Original Current 31 MessagePayload R → C Original Current 32 GetDate C → R Original Current 33 SetDate R → C Original Current 34 DestLookup C → R 0.7 Deprecated 35 DestReply R → C 0.7 Deprecated 36 SendMessageExpires C → R 0.7.1 Current 37 RequestVariableLeaseSet R → C 0.9.7 Current 38 HostLookup C → R 0.9.11 Current 39 HostReply R → C 0.9.11 Current 41 CreateLeaseSet2 C → R 0.9.39 Current 42 BlindingInfo C → R 0.9.43 Current **Условные обозначения**: C = Клиент, R = Router Ключевые сведения о сообщении CreateSessionMessage (Тип 1) Назначение: Инициировать новый сеанс I2CP\nСодержимое: структура SessionConfig (конфигурация сеанса)\nОтвет: SessionStatusMessage (status=Created или Invalid)\nТребования: - Время в SessionConfig должно находиться в пределах ±30 секунд от времени на router (маршрутизаторе) - Отображение должно быть отсортировано по ключу для проверки подписи - У Destination (адрес назначения) не должно уже быть активного сеанса\nRequestVariableLeaseSetMessage (Тип 37) Назначение: Router запрашивает авторизацию клиента для входящих tunnels\nСодержимое: - ID сессии - Количество Lease (элемент LeaseSet) - Массив структур Lease (каждая со своим временем истечения)\nОтвет: CreateLeaseSet2Message\nЗначение: Это сигнал о том, что сеанс работоспособен. router отправляет это только после: 1. Построен хотя бы один входящий tunnel 2. Построен хотя бы один исходящий tunnel\nРекомендация по тайм-ауту: Клиентам следует закрыть сеанс, если это сообщение не получено в течение 5 минут и более с момента создания сеанса.\nCreateLeaseSet2Message (Тип 41) Назначение: Клиент публикует LeaseSet в сетевую базу данных\nСодержимое: - ID сессии - байт типа LeaseSet (1, 3, 5 или 7) - LeaseSet или LeaseSet2 или EncryptedLeaseSet или MetaLeaseSet - Количество закрытых ключей - Список закрытых ключей (по одному на каждый публичный ключ в LeaseSet, в том же порядке)\nЗакрытые ключи: Необходимы для расшифровки входящих garlic messages (механизм I2P объединения нескольких сообщений для повышения анонимности). Формат:\nEncryption type (2 bytes) Key length (2 bytes) Private key data (variable) Примечание: Заменяет устаревший CreateLeaseSetMessage (тип 4), который не поддерживает: - Варианты LeaseSet2 - Шифрование, не основанное на ElGamal - Несколько типов шифрования - Зашифрованные LeaseSets - Офлайн-ключи подписи\nSendMessageExpiresMessage (Тип 36) Назначение: Отправить сообщение на адрес назначения с указанием срока действия и расширенными параметрами\nСодержимое: - ID сеанса - Адрес назначения - Полезная нагрузка (gzipped) - Нонс (4 байта) - Флаги (2 байта) - см. ниже - Дата истечения срока (6 байт, усечено с 8 байт)\nПоле флагов (2 байта, порядок битов 15\u0026hellip;0):\nБиты 15–11: не используются, должны быть 0\nБиты 10-9: Переопределение надёжности сообщения (не используется, вместо этого используйте nonce (одноразовое число))\nБит 8: Не вкладывать LeaseSet - 0: Router может вкладывать LeaseSet в garlic (многокомпонентное зашифрованное сообщение I2P) - 1: Не вкладывать LeaseSet\nБиты 7-4: Низкий порог тегов (только для ElGamal, игнорируется для ECIES)\n0000 = Use session settings 0001 = 2 tags 0010 = 3 tags ... 1111 = 192 tags Биты 3-0: Метки для отправки при необходимости (только ElGamal, игнорируется для ECIES)\n0000 = Use session settings 0001 = 2 tags 0010 = 4 tags ... 1111 = 160 tags MessageStatusMessage (сообщение о статусе) (тип 22) Назначение: Уведомить клиента о статусе доставки сообщения\nСодержимое: - Идентификатор сеанса - Идентификатор сообщения (генерируется router) - Код статуса (1 байт) - Размер (4 байта, имеет значение только при status=0) - Nonce (одноразовое число; 4 байта, совпадает с nonce клиента из SendMessage)\nКоды состояния (исходящие сообщения):\nCode Name Meaning Result 1 Accepted Router accepted message Success 2 Best Effort Success Probable delivery Success 4 Guaranteed Success Probable delivery Success 6 Local Success Delivered to local client Success 3 Best Effort Failure Probable failure Failure 5 Guaranteed Failure Generic failure Failure 7 Local Failure Local delivery failed Failure 8 Router Failure Router shutdown/error Failure 9 Network Failure No network connectivity Failure 10 Bad Session Invalid/closed session Failure 11 Bad Message Invalid payload Failure 12 Bad Options Invalid options/expiration Failure 13 Overflow Failure Queue/buffer full Failure 14 Message Expired Expired before send Failure 15 Bad Local LeaseSet Local LeaseSet problem Failure 16 No Local Tunnels No tunnels available Failure 17 Unsupported Encryption Incompatible encryption Failure 18 Bad Destination Invalid remote destination Failure 19 Bad Leaseset Invalid remote LeaseSet Failure 20 Expired Leaseset Remote LeaseSet expired Failure 21 No Leaseset Remote LeaseSet not found Failure 22 Meta Leaseset Cannot send to meta LS Failure 23 Loopback Denied Same source and destination Failure **Коды успеха**: 1, 2, 4, 6 **Коды ошибок**: все остальные Код состояния 0 (УСТАРЕВШЕ): Сообщение доступно (входящее, быстрый приём отключён)\nHostLookupMessage (Тип 38) Назначение: Поиск адреса назначения по имени хоста или хешу (заменяет DestLookup)\nСодержимое: - ID сессии (или 0xFFFF при отсутствии сессии) - ID запроса (4 байта) - Тайм-аут в миллисекундах (4 байта, минимально рекомендуемое значение: 10000) - Тип запроса (1 байт) - Ключ поиска (Hash (хэш), строка hostname, или Destination (идентификатор назначения в I2P))\nТипы запросов:\nType Lookup Key Returns Since 0 Hash Destination Original 1 Hostname String Destination Original 2 Hash Destination + Options 0.9.66 3 Hostname String Destination + Options 0.9.66 4 Destination Destination + Options 0.9.66 Типы 2-4 возвращают параметры LeaseSet (предложение 167), если доступны. Ответ: HostReplyMessage (сообщение ответа хоста)\nHostReplyMessage (тип 39) Назначение: Ответ на HostLookupMessage (запрос на разрешение имени хоста)\nСодержимое: - Идентификатор сессии - Идентификатор запроса - Код результата (1 байт) - Назначение (присутствует при успехе, иногда — при некоторых конкретных ошибках) - Сопоставление (только для типов поиска 2-4, может быть пустым)\nКоды результатов:\nCode Name Meaning 0 Success Lookup succeeded 1 Failure Generic failure 2 Lookup Password Required Blinded address requires password 3 Private Key Required Blinded address requires private key 4 Password and Key Required Blinded address requires both 5 LeaseSet Decryption Failure Cannot decrypt LeaseSet 6 LeaseSet Lookup Failure LeaseSet not found in netdb 7 Lookup Type Unsupported Router doesn't support this type #### BlindingInfoMessage (сообщение с информацией об ослеплении) (Тип 42) Назначение: Сообщает router о требованиях к аутентификации для blinded destination (ослеплённый Destination) (начиная с 0.9.43)\nСодержимое: - ID сеанса - Флаги (1 байт) - Тип конечной точки (1 байт): 0=хеш, 1=имя хоста, 2=назначение, 3=SigType+Key - Тип слепой подписи (2 байта) - Срок действия (4 байта, в секундах от эпохи Unix) - Данные конечной точки (зависят от типа) - Закрытый ключ (32 байта, только если установлен бит 0 флага) - Пароль для поиска (String, только если установлен бит 4 флага)\nФлаги (порядок битов 76543210):\nБит 0: 0=для всех, 1=для каждого клиента Биты 3-1: Схема аутентификации (если бит 0=1): 000=DH (Диффи-Хеллман), 001=PSK (предварительно разделённый ключ) Бит 4: 1=требуется секрет Биты 7-5: Не используется, установить в 0 Нет ответа: Router обрабатывает молча\nСценарий использования: Перед отправкой на ослеплённое назначение (адрес b33) клиент должен либо: 1. выполнить поиск b33 через HostLookup, ИЛИ 2. отправить сообщение BlindingInfo\nЕсли Destination (идентификатор назначения в I2P) требует аутентификации, BlindingInfo (информация для ослепления Destination) является обязательным.\nReconfigureSessionMessage (Тип 2) Назначение: Обновить конфигурацию сеанса после создания\nСодержимое: - ID сессии - SessionConfig (нужны только изменённые параметры)\nОтвет: SessionStatusMessage (status=Updated or Invalid)\nПримечания: - Router объединяет новую конфигурацию с существующей конфигурацией - Параметры Tunnel (inbound.*, outbound.*) всегда применяются - Некоторые параметры могут быть неизменяемыми после создания сеанса - Дата должна находиться в пределах ±30 секунд от времени Router - Отображение должно быть отсортировано по ключу\nDestroySessionMessage (Тип 3) Назначение: Завершить сеанс\nСодержимое: Идентификатор сеанса\nОжидаемый ответ: SessionStatusMessage (status=Destroyed)\nФактическое поведение (Java I2P до версии 0.9.66 включительно): - Router никогда не отправляет SessionStatus(Destroyed) - Если сеансов не осталось: Отправляет DisconnectMessage - Если остаются subsessions (подсеансы): Нет ответа\nВажно: Поведение Java I2P отличается от спецификации. Реализациям следует проявлять осторожность при удалении отдельных подсессий.\nDisconnectMessage (тип 30) Назначение: Уведомить о скором завершении соединения\nСодержимое: Строка причины\nEffect: Все сеансы этого соединения уничтожаются, сокет закрывается\nРеализация: Преимущественно router → клиент в Java I2P\nИстория версий протокола Определение версии Информация о версии протокола I2CP обменивается в сообщениях Get/SetDate (начиная с 0.8.7). Для старых router информация о версии недоступна.\nСтрока версии: Указывает версию API \u0026ldquo;core\u0026rdquo;, не обязательно версию router.\nХронология функций Version Key Features 0.9.67 PQ Hybrid ML-KEM (enc types 5-7) in LeaseSet 0.9.66 Host lookup/reply extensions (proposal 167), service records 0.9.62 MessageStatus loopback error code 0.9.46 X25519 (enc type 4) in LeaseSet, ECIES end-to-end 0.9.43 BlindingInfo message, extended HostReply failure codes 0.9.41 EncryptedLeaseSet options, Meta LS error code 0.9.39 CreateLeaseSet2 message, RedDSA Ed25519 support 0.9.38 Preliminary LS2 support (format changed in 0.9.39) 0.9.21 Multiple sessions on single connection 0.9.20 Additional SetDate messages for clock shifts 0.9.16 Authentication required before other messages (when enabled) 0.9.15 EdDSA Ed25519 signature type 0.9.14 Per-message reliability override with nonzero nonce 0.9.12 ECDSA P-256/384/521 signature types, RSA support 0.9.11 HostLookup/HostReply messages, auth in GetDate 0.9.7 RequestVariableLeaseSet message 0.9.5 Additional MessageStatus codes 0.9.4 Fast receive mode default, nonce=0 allowed 0.9.2 SendMessageExpires flag tag bits 0.9 16 leases per LeaseSet (up from 6) 0.8.7 Version strings in Get/SetDate 0.8.4 SendMessageExpires flag bits 0.8.3 DestLookup in standard session, concurrent lookups 0.8.1 messageReliability=none 0.7.2 GetBandwidthLimits, BandwidthLimits 0.7.1 SendMessageExpires, ReconfigureSession, ports in gzip header 0.7 DestLookup, DestReply 0.6.5- Original protocol features ## Соображения безопасности Аутентификация По умолчанию: Аутентификация не требуется Необязательно: Аутентификация по имени пользователя/паролю (начиная с 0.9.11) Обязательно: При включении аутентификация должна завершиться до других сообщений (начиная с 0.9.16)\nУдалённые подключения: Всегда используйте TLS (i2cp.SSL=true), чтобы защитить учётные данные и закрытые ключи.\nСмещение часов Значение SessionConfig Date должно находиться в пределах ±30 секунд от времени router, иначе сеанс будет отклонён. Для синхронизации используйте Get/SetDate.\nОбращение с закрытым ключом CreateLeaseSet2Message содержит закрытые ключи для расшифровки входящих сообщений. Эти ключи должны: - Передаваться безопасно (TLS для удалённых подключений) - Храниться в защищённом виде у router - Заменяться при компрометации\nИстечение срока действия сообщения Всегда используйте SendMessageExpires (а не SendMessage), чтобы указать явный срок истечения. Это позволяет:\nпредотвращать бесконечное зависание сообщений в очереди снижать потребление ресурсов повышать надёжность Управление тегами сеанса ElGamal (устаревший): - Теги должны передаваться пакетами - Потеря тегов приводит к ошибкам расшифрования - Высокие накладные расходы по памяти\nECIES-X25519 (текущий): - Теги генерируются синхронизированным ГПСЧ - Предварительная передача не требуется - Устойчив к потере сообщений - Существенно меньшие накладные расходы\nЛучшие практики Для разработчиков клиентских приложений Используйте режим быстрого приёма: Всегда устанавливайте i2cp.fastReceive=true (или оставьте значение по умолчанию)\nПредпочитайте ECIES-X25519: Настройте i2cp.leaseSetEncType=4,0 для лучшей производительности при сохранении совместимости\nЗадайте явное время истечения: Используйте SendMessageExpires, а не SendMessage\nОсторожно обращайтесь с подсессиями: Имейте в виду, что подсессии не обеспечивают анонимности между адресами назначения\nТайм-аут при создании сеанса: Уничтожить сеанс, если RequestVariableLeaseSet не получен в течение 5 минут\nСортировка сопоставлений конфигурации: Всегда сортируйте ключи сопоставлений перед подписанием SessionConfig\nИспользуйте подходящее количество Tunnel: Не устанавливайте quantity \u0026gt; 6, если это не требуется\nРассмотрите SAM/BOB для приложений не на Java: Реализуйте SAM вместо прямого использования I2CP\nДля разработчиков Router Проверка дат: Соблюдать окно ±30 секунд для дат в SessionConfig\nОграничить размер сообщений: Обеспечить соблюдение максимального размера сообщения ~64 КБ\nПоддержка нескольких сессий: Реализовать поддержку подсессий в соответствии со спецификацией 0.9.21\nОтправьте RequestVariableLeaseSet незамедлительно: только после того, как будут созданы и входящие, и исходящие tunnels\nОбрабатывать устаревшие сообщения: Принимать, но не рекомендовать ReceiveMessageBegin/End\nПоддержка ECIES-X25519 (ECIES на основе X25519): Отдавайте приоритет шифрованию типа 4 в новых развертываниях\nОтладка и устранение неполадок Распространённые проблемы Сессия отклонена (недействительна): - Проверьте расхождение часов (должно быть в пределах ±30 секунд) - Проверьте, что отображение отсортировано по ключу - Убедитесь, что адрес назначения ещё не используется\nНет RequestVariableLeaseSet: - Router может создавать tunnels (подождите до 5 минут) - Проверьте наличие проблем с сетевым подключением - Убедитесь в достаточном количестве соединений с пирами\nСбои доставки сообщений: - Проверьте коды MessageStatus, чтобы определить конкретную причину сбоя - Проверьте, что удалённый LeaseSet опубликован и актуален - Убедитесь, что используются совместимые типы шифрования\nПроблемы с подсессией: - Убедитесь, что основная сессия создана первой - Подтвердите, что используются те же ключи шифрования - Проверьте, что ключи подписи различаются\nДиагностические сообщения GetBandwidthLimits: Запросить лимиты пропускной способности router HostLookup: Проверить разрешение имени и доступность LeaseSet MessageStatus: Отслеживать сквозную доставку сообщений\nСвязанные спецификации Общие структуры: /docs/specs/common-structures/ I2NP (сетевой протокол): /docs/specs/i2np/ ECIES-X25519: /docs/specs/ecies/ Создание tunnel\u0026rsquo;ов: /docs/specs/implementation/ Библиотека потоков: /docs/specs/streaming/ Библиотека дейтаграмм: /docs/api/datagrams/ SAM v3: /docs/api/samv3/ Упомянутые предложения Предложение 123 : Зашифрованные LeaseSets и аутентификация Предложение 144 : ECIES-X25519-AEAD-Ratchet Предложение 149 : Формат ослепленного адреса (b33) Предложение 152 : Создание tunnel на основе X25519 Предложение 154 : Запросы к базе данных из ECIES Destinations (адреса назначения) Предложение 156 : Миграция router на ECIES-X25519 Предложение 161 : Сжатие заполнения Destination Предложение 167 : Сервисные записи LeaseSet Предложение 169 : Гибридная постквантовая криптография (ML-KEM) Справочник по Javadoc Пакет I2CP MessageStatusMessage Клиентское API Сводка устареваний Устаревшие сообщения (не использовать) CreateLeaseSetMessage (тип 4): Используйте CreateLeaseSet2Message RequestLeaseSetMessage (тип 21): Используйте RequestVariableLeaseSetMessage ReceiveMessageBeginMessage (тип 6): Используйте режим быстрого приёма ReceiveMessageEndMessage (тип 7): Используйте режим быстрого приёма DestLookupMessage (тип 34): Используйте HostLookupMessage DestReplyMessage (тип 35): Используйте HostReplyMessage ReportAbuseMessage (тип 29): Никогда не реализовано Устаревшие параметры Шифрование Эль-Гамаля (тип 0): перейти на ECIES-X25519 (тип 4) Подписи DSA: перейти на EdDSA или ECDSA i2cp.fastReceive=false: Всегда использовать режим быстрого приёма ","description":"Как приложения согласовывают сессии, tunnels и LeaseSets с I2P router.","id":"ed43fc9da2a03819fd3c8f71e9e9a5a3","section":"docs","title":"Клиентский протокол I2P (I2CP)","url":"/ru/docs/specs/i2cp/"},{"categories":null,"content":"Контакт по вопросам безопасности Для сообщения об уязвимостях безопасности или конфиденциальных вопросах безопасности, пожалуйста, свяжитесь с командой безопасности I2P по адресу security@i2p.net Для безопасной связи используйте наш PGP-ключ ниже.\nИнформация о PGP-ключе Email: security@i2p.net Key ID: 176E1941 Отпечаток: 40DF FE20 7D79 9BEC 3AE8 7DEA 5F98 BE91 176E 1941 Тип ключа: RSA 4096-бит Создан: 2025-10-19 Истекает: 2030-11-19 UID: I2P Security \u0026lt;security@i2p.net\u0026gt; Публичный ключ Ниже приведен публичный GPG-ключ команды безопасности I2P: \u0026mdash;\u0026ndash;BEGIN PGP PUBLIC KEY BLOCK\u0026mdash;\u0026ndash;\nmQINBGj1TtUBEADKsCC54egdJgxMs4HWcsYlr4GbrevM5gjZ+QZYEDGjaz44duOc E9W+a/NNA8PsryCql893odYdqGrFX+WTUT3UuN7DbbS7qSDs7jWZzjj0lr4/pbzJ B28lC0aIx6SQTEbzsGr2hOlFq/+JD9x/fMFrHFX81cJdIz9yabcH1vg9wPuhwkUS 5v2GFtvODCmSxQEJHSWvL2PkGiYEEZMKVXF5msdqJZK5/Dwp3UgVNeAkUYEHU6px Vu/YUpGo07/LNW5FfGDGf0pWYQ/9Tu5ykno3q3EA7TwWoVwbDK0hh9mpbZYiWSoy PSbIWNpwVMwGri4+KFjCEyG8DLzDlM4UMrK3PnrPh4M4+4a+flR+CMNeM1lyioC3 +jJf3TEOjvUsMzbwoDEE6O0wxBtfFC0xzzDDCAVrPvEZ3lt0do3kVHLbYS6ZXHkX ZwZWNBDWr2mSG9GU4oWizPIlq7MIhRYKA+ADqNxznxm9rtdfidk1tcLdyNUDjOwC jk/vQ8PCORbUYfytMhHzlRk7zieK6wBwr3aFFVgE8HxhgIZkAaUEbeej+dNADo6Z IFY+OF8mjpErcfJscCNgPSDbNid87dA78qRrqL6HLU2sek9g72EFpx2OVV7drkEp +Zy9kuiML4wWfOpC+kQa1Ka66E520U8Hs++cpf1LUOUmn1ajQDSfGoJMMwARAQAB tB9JMlAgU2VjdXJpdHkgPHNlY3VyaXR5QGkycC5uZXQ+iQJXBBMBCABBFiEEQN/+ IH15m+w66H3qX5i+kRduGUEFAmj1TtUCGwMFCQmQP4EFCwkIBwICIgIGFQoJCAsC BBYCAwECHgMCF4AACgkQX5i+kRduGUEEJhAAuZECNIWnC2UbrW/AXF8nPvFjpvLe kK7VQmMgno6iHRB1HAMh5hk3ZOYSRcjghcOHRpMFT64Uuc5vc9eBoegi5TDxYDkF Y9/ciEG5j2TXk93R/rY14UiH/kjFIhBAmc2t6Fs9R1m1vHHJtgY+KLqRF9fh2hc9 43odXnCrn5nhONtW+nb086eJEnJ4vsG/yR4EGzbu+fbrMJlycA/gZS63Q0rIcEJ2 VbZPCEXAf8LmebwxPxlboEuhXJSjCt1gWZwoKZlELaWdHliL3fUrMd3ojM5y66q3 ClO+7nWuwzKxKtZGKzxvF78o0O+HR4BbC16oQGpkT0yAij7ps/3KD2FJVQ/GQLef mpNQABfdVCPgcDS1p9/hjUoVHlRSC4gyehKX/C+H8Qvem92tzmJZy8PvcXaCsK/u wRxRwkoGhv0H5rsMOxfnB06dvT1Mo+KHED5j4y8C5DOnNpzHqwxJh1nQlJvLUvh8 LWIxiiE4+CeQ5V5YH7KfJmGq5ho93GgFmOXJvAuoFCoOLwXbQt9rMpq8iXM1RHRG E1AbB+KA3zcvAdzbgPtXlrOMkIfYO9xCyc8M0sfHB8b4RgrUs2tFz1fw3g4yE7ax 5ljquRefDmqBjtvu15FcZ4CA+I8FyVnrEb9jDTXyW7DiyM2kB7ZFeLpYytShbPq3 oJQMJYaGMoxDk025Ag0EaPVO1QEQAOuZtLOlab2EnuR5St05MXBpwtQUSWJzRckf w3NpnOl55+BavqsPl63rZYiO2lH9rAkZvfcL7auddQZSjDdsuPbUpsrQgsi2P9ig a3QiJOwSZzJ1qNb4VZSXrq2AqkBhCdw9rjpXGFfPNlClgVRbWpsGaQ5KtflnOA+I RfymidNXH0mDROBQuRh+2lkEYfANshjFjIqbI05tDic0KOab46R5MRVF7cihaMWp qPdxeYmvFWZ9lAnx5lMGwDdnGgfWFkU57lAd3NuHUnYIr/ExB/YgMdDeie5lQHKu svbcws9tIucUME9n8lGY77+1HlmNOCU4V12i4ZURJ4TwjHpScMOovkumtO4nXGRq GS8j1zeG7V9+yvdkSrclHJC33Mu6SPFC5SJBqU1G39/VpTD6CZPSPowZ0RlH2AVh D77Snrn53R3gziv5uxq+LpSJoafAx5tgIrg7HB+iJYRB1YVwIIHoT4YrBF01YyH6 cclkf3TNBjKgmtsynVw/TGy56nvR5lmt2uMq0Wwl4ZEwYPp+8ZmFuLbEHsI9RSdD iAdHoK9pEsTSxvzpcDTcG0CLZ4By/4oIKra6KuLr7XcB5eBmgXxrFBw4kveNWGW0 iEdg0xUVp8dxNjdZucB8m9qXQUUSmUxVjFYu4ee8tpo8iEVzu4wm4kOiOBKlwCn2 nOI72oGxABEBAAGJAjwEGAEIACYWIQRA3/4gfXmb7DrofepfmL6RF24ZQQUCaPVO 1QIbDAUJCZA/gQAKCRBfmL6RF24ZQShLD/9BlA+nLmJvwL3FYXm8JOqN07gPKlyQ +gWdV8p22Gawoq6dJLJanWURjn5Kfy30x2CSX6QwiaQG5aHHudNBF2h4Z/qEMcO5 ml5Dq7BP9R5VKmG4vwrL5ccNwuey1/d9Rtjt1zsd+52+x6dfjFv95o9j8jviIEoS HhhbO9ujmx3QLRNlg0SkG6ZlTALGp3EcKNdrV1vpF6ccgt3pdWYFB62N7q8zObHf bfOFMITJIXJJVKICCxzw3xOW2fMashjqf4Ic2UTFsAG3Hqqf5ASGbu4TyjFS3VXV JSzvdhGnxb7qJUzBImK9mGPRXYSV5d4g7kCFfgUg6KSFxbfYreEjCZXWJyqCr/VB eLpIhUWce/AiDPD8lGVD6sNevsNw4HhO6IyQu0pqbRAo+fJZNi+wcqOUqYlMczNw tUKw73QmFj0IqvyBr8Rfq9JC9O6ipyzalwK8uO0gmqOiK79zfnNIJaZ1+LM3Gh6n 3yluwq1df40lEU171i70IbSON6ekGNLTrvhTlDg6vHCMRfQR2UjA5FYBAtFXqQNG c4IYbu2UQm/191P77oI0vBEh3YnrD9eXtdYxgyT+Lj8RBJ+aM+IykK7c2mgOmlqb vYv+KkVFCpOyXrvSwId+3jHiGP6jis7vuzTwiG0S9EyOjxf9XIDowULuY28ntBB0 hOLK7ID/AeaOxA== =39fn \u0026mdash;\u0026ndash;END PGP PUBLIC KEY BLOCK\u0026mdash;\u0026ndash; ","description":"Публичный ключ GPG для связи с командой безопасности I2P","id":"c65864821d13039a727e933e7e6e2891","section":"docs","title":"Ключ безопасности GPG","url":"/ru/docs/develop/security-key/"},{"categories":null,"content":" Релизы начиная с версии 0.9.57 подписаны idk. Его текущий публичный ключ: Скачать публичный ключ PGP Релизы 0.7.6 и 0.9.56 подписаны zzz. Его текущий публичный ключ: Скачать публичный ключ PGP -----BEGIN PGP SIGNED MESSAGE----- Hash: SHA1 Я создал новые GPG ключи и подключи и подписал новые ключи старым ключом.\nСтарые ключи:\npub 1024D/A76E0BED 2005-12-16 Key fingerprint = 4456 EBBE C805 63FE 57E6 B310 4155 76BA A76E 0BED uid zzz (zzz) \u0026lt;zzz@mail.i2p\u0026gt; sub 2048g/74C8122D 2005-12-16 Новые ключи:\npub 4096R/EE7256A8 2014-05-08 [expires: 2024-05-05] Key fingerprint = 2D3D 2D03 910C 6504 C121 0C65 EE60 C0C8 EE72 56A8 uid zzz on i2p (key signing) \u0026lt;zzz@mail.i2p\u0026gt; uid zzz on i2p (key signing) \u0026lt;zzz@i2pmail.org\u0026gt; sub 4096R/1AE988AB 2014-05-08 [expires: 2019-05-07] sub 4096R/01B5610C 2014-05-08 [expires: 2019-05-07] sub 4096R/59683006 2014-05-08 [expires: 2019-05-07] Я буду использовать новые ключи следующим образом:\nEE7256A8: key signing 1AE988AB: email signing 01B5610C email encryption 59683006 release signing Ключ подписи релизов будет использоваться начиная с версии 0.9.13. Это сообщение подписано моим старым ключом.\nzzz 25 мая 2014\nСледуют новые ключи:\n\u0026mdash;\u0026ndash;BEGIN PGP PUBLIC KEY BLOCK\u0026mdash;\u0026ndash; Version: GnuPG v1.4.14 (GNU/Linux)\nmQINBFNrjZsBEADMHWiucM8ES5VDfq6n4M9DJhMyG5jVoakzSFHfzVOEpHeDYR1E eaEIFt5CEx0mbpXWy6UBoj0E7o3se5RvF81VQQ4xO0MyHZLkpotGffZo7D34uKTd 1SFbirosXwnsOxjPGLF+PuwifV+mzSoE66XRmg5UJbOJj0ZitYBn4lDKMxU1Rext WX7D79qnJW2GXv/HuzTwZ/KV3fOVB782+fNdFBDZt4XHSM32ideXedTtTJ+FXjBv 1/eQ/Ls8PMYKaYUm/j0oTI2A5aNP+6BH8/NrVvF8xQWCibrOILASWFRJE7insciJ m9eeEPPOp1D4fRDWFyjABcn00fv7T7RDBgIdpuj3gBDvGXgx8SRiWxe9CwV9TcJl WNPTAKd9XGHT13XWwc1myO/yg+yQoJB6HO1jGjqxQuu3aHCw2i4gTHflq4qZoSDV oxJWeh+mNsfx4DgmoT1UeEmh2Uq64czMGh8wJC0FqSa+FmgCKa1FxcTnYlfIjR79 qwbEKK3JZ5PPkiK5Lh4hNvkXKLrUXpG1KHm6yNVPNIWCOMd7VCDziEhsbeNPCzQc 6af8dkyI9BUeQD3fGjeHCh/QHLju9Lde77GDddYaShXVI/Wiy4AWgN0KVUk8CnEZ Uu2JbazpJBLGGiB2CujP44eJzm9VPoBx8Xc9/Pk2RFbz2bN4uQtSD6lAjQARAQAB tCd6enogb24gaTJwIChrZXkgc2lnbmluZykgPHp6ekBtYWlsLmkycD6JAj4EEwEC ACgFAlNrjyYCGwMFCRLMAwAGCwkIBwMCBhUIAgkKCwQWAgMBAh4BAheAAAoJEO5g wMjuclaoxkEP/RQRz7kWfCWcDWtKSxq1zA3HEUKUHLxhBIl1C+tmMtJypyWwiP8Y hrO/Tuk8nsnVOl9wMMtz2ZxMpUS2gTsuquZ6pIUCNtEP+IAuKsZlCcsNB+yOoi2T i71cXLBPcN/rbxyoOUMpk+fJgdsustUnSMbXJQ2sLjieurD/YpUMJZw6KoNVrhU1 1nDaJqAq/zouhSvNMvx5+GBodQ41gvtb984xbrNc8B24upCBHSF1olczWYPUtaAi oMlZTNr5XFS//Q8X3sEKAoRMbAX6UvZVdtgqQajGilMg+HM3HnbPqsHoyPWx4f8O n134ITgrVwL24y+m9XHfY+JPjcBgg9uGLuLJqMrrjYfz7jVdUJQUsy/R2+yzg1Bm Ruf3SBhHpG2dSBOTxi9GD4aL/7wXuXj9uIuFtX80EwsT4XifnIaHTdtNNzVO+obF dJyiIpF1IFmFOTgJ3ba9gcILQIWXGIp1e5C8g2MtuYO/6/jZK1lhFCLbvhpA9C4q uUp6/WXnavd3beKltkzL1v2dOjC1EkjrsFF50olV4f3d56JdS7JEnFzx7gVeSQfF uLR/t22CluxzubcYoAk/hdIWM2Ufi6v6ONVWc7D5nYBW9onNRKEquA/qOHZr3C/M QbRxTYyhaMW4Nrwck9jmpcQBE1EzscX3DAr+3W+rnKDCZL5QuI2Yq5gkiEYEEBEC AAYFAlNrl+YACgkQQVV2uqduC+1XMwCcC24MIzSxDOEpX7c/ecTKm18bOQkAmwU9 WqqUgT37bQ+U9ME322JPrBsitCp6enogb24gaTJwIChrZXkgc2lnbmluZykgPHp6 ekBpMnBtYWlsLm9yZz6JAj4EEwECACgFAlNrjZsCGwMFCRLMAwAGCwkIBwMCBhUI AgkKCwQWAgMBAh4BAheAAAoJEO5gwMjuclaobxQP/0oU+/nhTx7NRUZ3Ay/LzD7v DHqX+A1iPos1Xzmz+vq9a7z/mjjiQn0wfFiMctFc5dRf+hSM+W7BUfcG5rML+416 rEgtCDsQ0KfaFYUPRObxxNRdDv4N0j6uw2hFmAZ+KkOxKf5Z5CV7A2dwpjsO+PSc Ed0BM1iAjzNbod5b5uAn6r/Z43GSH2omRdhE8Ne5UrH58kLFSg8+iAfnnV5SSEKo bkP0f5m91esbh+vAgq0nFRsB8PeBYklw20wnAkIy6rmKJngBpiF0KfC/V6NY3g63 NDqf4wbSO8WqnrS9QWqYFzJfDsARQvx3jBqLTcQ4SlpIVWKNeogkeSeuqCVKRgvN jWBHdfABkf+DHrzlf072PK8RtDZn6wn1D91MeFCvg+Ss6XV2d0JEd+bxdK6Aj1RR X4XGv0jcH1Ftm9JRNjzXsALzndvwvEKU2xgDA2LATA7ikKbIq19VoTf90uc7i1Os 6cOXZkezZatyuJzJITGeq4llek+PVFxU/5LnRLr6h6K5D0/5F9KlgtPJKgSDOipp TN1Vof8f+v1/zWmyxpw9jtkNjM9chtOY7xhQfNxQLZuHXjQtDT3+JGo6/gTqj105 Yg+HNTJjkDYl2Y5AHb0WFHUFSn2GiBtot4V/g2ojMeQIiw2a8v17H6HUZSKYBjgR L7ln7O4oBduvaSSyZE2jiEYEEBECAAYFAlNrl+YACgkQQVV2uqduC+3d7ACgpRpk 13FSAhz/RpPnqYwRSFUiQTsAoIewgMNIxgbPQGUVDO3FpzChAfUruQINBFNrj7YB EAC8GDV5JcAcktMYnUbPxpydlWSDzzBaDUvbOAtWbrmkwQUXyij0O4ZW1W81e0R+ APT26TLuqc6Q+v6b0rWlVoZkSKYaqzm0S3mtLWUvEgPjHfYXT7VaHtzu6QUPwmVa w+o8dxkbajl5C1i9CZyr8ACziD23FSPA5nd/WQ18EAbnIjnT4cV9dP7lLqZAWtzE Cp3ze4ZHt6kg5i6rhJBJWbycHAZK2SMclC37S6MtZAwW0pJJwn/qdj7UvmL72QoV qXNHe8dfKfnxzo0/HoCKn4rlIW0W3xHgqy6VQUnyigL0blrVmxzcH5bgttXr94yh MVV1Kg9ie1GfhPf1ui86NnGHczbZB2TmTc/d2Nl1/L3TwxiWX2fv9BF+mVczRiXc 9FZRTF5JsBN0BAyxIE9vDXK/yygiWRSD1ND/0eTmKJRqOplpXoCBSDCsfvFN6/63 mx70wP92bNMmDZ/zbjFApmbMCjf+0wCZljiBtkNgT4k2nOYjb6Kt+vOeEg1XBTqo WREHEUA23xsu2DMH5Ra0OA0NwA9jrp1dg4t7fKIkSlBLNlIsZ73lNV21uuA8lVFR KHRX7y394c5/T9c8zPtJSmIZnAY52KXBFfsM3h+ExaQIWclyU375kYi0IBE9tCfF 7VuX1JgvA/9SjjtgfEWWLkhkPUAUl82e8SYQRx5Ki3RIvQARAQABiQREBBgBAgAP BQJTa4+2AhsCBQkJZgGAAikJEO5gwMjuclaowV0gBBkBAgAGBQJTa4+2AAoJEA6+ gRoa6YirbtsQAKheBU6M3oAfyAJ7i13mPEY2EvZFXdY41ct89ebdLCe4revG5Tao Fj/OmD0W+eBvRbJvOglw+0wYjpjAsnl95kYCBRL/BAr9xWt/g9SCcQqxOaYI9gM0 pFAcPjicEF44xdSMDSWGpN0PT5M6omlz5EObxuU3vaZ8y2XWYdvW8p1AwST66y/M AoACZqJUsIo7HIsz607XzNa3evIkCuGGNbTrD0OCTNUxOhwtqMIt3bHE2h4I8Hwp hptTf2eDf2z587/32gs3yp/VAeP6dCeQF3+Wduc41aRsCru7HnE2w/BiW1nzePyK 6b3RA56bZcbANIS8k/+EVOakS4uRDnweqkwBVgkWsCk17+XNeIaRaY0pWJaFs+hO f7cdp/XK+z2eFO1brEJa3BmnHHMx/lUv5YS8MgD+CcdvHvb2dirthzvyb6yDKFNn ZkMz3/Z1wnlDkMp/fjJAwXfmKT7IOqPVN5fpLcXp27Jh2BSrafvLupkIzZhrGL7R hTg8X83rLuQ0ZSn8k9cFju1pECI1atXC/kPMlSC4VffoViqwSZDLFsniFSNTaBOw EfKCLxv4s0BNovaUQfY2DUkL2BHrU18HbpGkaD3Gmb6TnzBYRTWSz15/9w8cjOc9 rr9d5SZaUeMZkGmlUdEG5q43b0MwQxYSA4Y3ZZGMgbjzEa83YN2njV7U07MP/1C2 D/tpWM2SliCGQ9ioPZVnwB43sme7J0GWjLRR085Q8+4V3/buWNG0UBc+l3MNlO0m N/zPp8ZqKCe6tLIXiExgiMSfcv9/7G3AgKxfzY+t3wFC6ISZiG5JFQIx/NI6zR+F RPUXUf8ZWH+i49p3UY564wULQMLobMuxhO2+BkjZKPkHAiXB0FTdP9WW/Gt2vWgZ L6ogdmo2bo2BQCU0VOOlCp8MxL9MlQ0FGURT/2kGoFzNFUo63UGvJc2iFmICI//9 OGBkpEMuPGrZI9W/4NTh+yMYj1b176IssWU2PWvhpempaXbcgXnlZQ5x6qcszzrw m403O814RLkIljRdtjHWOJKygXpjj8qTbDFfLXWDZ6MTtZOgFOPHFpc+Drbyzgu0 Z3dpXBeoyXQaZGOtClVJTCUYMjE6AaWZrnvsjT2TSxK+oy4XXzI4vVvDMJh2Ibfs YKiRahGQnBiYEMIrefoj/wu2GaZ71y8P6tCfdvlv9DikIVTHajdG4G2K7Sr4glgk cB9M2IsSy7bw2OGrGFvkpqriL1aYvIF5Wf4KIsxpMZ2FIUeGP4YfT3ec7zfSC5bp /yBP8J/XXaCV8NkhLF4bD9tU+XRRK54LZkoDrJwmTreHknluF6hFuJl8d0+oHyjp kHp\niEYEARECAAYFAlOB3xkACgkQQVV2uqduC+3+UgCfYZiUtx7FDGdQDhdVP8MyRf0D ANIAn2YHOQh4yv84u2Kuars1gC0j3Nr2 =Zu9F \u0026mdash;\u0026ndash;END PGP SIGNATURE\u0026mdash;\u0026ndash; Релизы начиная с версии 0.9.9 могли быть подписаны str4d. Его текущий публичный ключ: -----BEGIN PGP SIGNED MESSAGE----- Hash: SHA512 Мои текущие публичные ключи следующие:\npub 4096R/0EC51FCDA94FB53E 2014-03-11 [истекает: 2019-03-10] uid [ полный ] str4d (http://str4d.i 2p) str4d@mail.i2p uid [ полный ] str4d str4d@i2pmail.org sub 4096R/1CC61D9B33C3241B 2014-03-11 [истёк: 2015-03-11] sub 4096R/803DEE491A3473E7 2014-03-12 [истёк: 2015-03-12] sub 4096R/A1B84C9B733AAC82 2015-04-05 [истекает: 2016-04-04] sub 4096R/13B5EE58C09FB3E0 2015-04-05 [истекает: 2016-04-04]\nВ настоящее время я использую ключи следующим образом:\nA94FB53E: key signing 733AAC82: email encryption C09FB3E0: email and release signing Я генерирую новые подключи для шифрования и подписи ежегодно. Любой релиз I2P, подписанный мной, всегда будет подписан последним подключом для подписи на момент выпуска.\nstr4d 20 ноя 2015\nТекущие ключи (на указанную выше дату):\n\u0026mdash;\u0026ndash;BEGIN PGP PUBLIC KEY BLOCK\u0026mdash;\u0026ndash; mQINBFMfofkBEADlyw6v1hGBtnIISujt/18RJcVTLAxYtfe3DsGhWqYZN3iKGGWb NJ5vZcV65FVH/70NFnmKlvYp+tVNJcoRtEYpfwiNG7nIyOC4GgaSLwkNVgLcFZhV mNj2RIJphjN5qsWm6ut9p9CyhWkVNJYDP65gqwShZQ2lPboo9s0XjUF78SrSshy2 iVij0xu6oqdjwqn1B7L3lXVYCwxReCvSdFnBMpjGUEgGnbt7euhrViFk8FrUkAje 2tZA5FAUA/t2Mnc9JREe6WlbZ44mLApOjFdw0g415FdcnS2GGaYuXNG1lJ1yOA33 n9JXT7A31wPyiw5yz7fxgl7ZNYZr2TsRjBlqEhf2SCPfqU9UlhJ9NqApaPyCEr+8 oZQfZ9r6stc98MlnmdQ7p4SmKRwCLiBtgmrB8mbgYV+iOwaKztqEoma3FoO2EJ+j Gx+UrJ0bIFVr6sL0ulfneYlY76wWWRpB/pLLgIMmZw83uB+JDBQyZFXcAHj9jMQ7 ZNn0MNQ/I+qcmX+CRAyl2+cQHUVbbQWDjB3crZlpK5TGw/x7w0YxBYAH8Us5JqJH QOsact8ADnE4IiKm5gVefFmNX6vsljkNESdpAMxnB7Ckl2XV/r5sKwrdxxUbFSxp IKGx2uKGUs4oUffOzpKULhGBWypN+3fVwvP+q896Il9hgyx6SCQ8AgPHRwARAQAB tClzdHI0ZCAoaHR0cDovL3N0cjRkLmkycCkgPHN0cjRkQG1haWwuaTJwPokCQAQT AQoAKgIbAwUJCWYBgAULCgkIBwYVCgkIAwIEFgMCAQIeAQIXgAUCUx/ZQgIZAQAK CRAOxR/NqU+1Pk9EEADHdpsmrA6ZKU4EmBZNbw62D7tAo00Fh25m8OuIkXtOqEbF /guTZiZM4nbhZpPFG9sCN1bXS8VslA7isOedbznkKnSK0BJcrzldwKzW25cwptoQ CCqTUarYbhcIzEOKNetYqICWrVTy2Yuc37maA66PnRLphV7pP3Fj7eN6aMtqwtpJ YukIU4LAjKOMJ6gwy7tjsZYbAqgSE8wRJm7i1MfO1W864a1l2a68Gooz03NC6mfY J8aW0y1F87xMJIgZeN7OyHf2AC4/Tp/cL+Gd3HcUuoRjmWBgaxH8tVNgfxSIUMNH 5pTdDs5VlRolwlOEcTW5VxOSu5C7ZbuKyFmbI0DSevDVGS0rxSSizjlyGmnxkLU1 ozpeIwTbwTUzvd26+k8cidGodKqoNoyAXzjaiBXYKgIrVeXBMHxCGeQtGeEhQR+L OXs8cEX6xpt9g7nKbNki0Cfv/lx9Byn+0v9RvMJKDa1mOSKbNOx3NJ8+ewdTVkTs iYFTZwpJexbfovPYqTdisiO7dv0i5teE8sEj25icdPtKYvn/55JCT67E8MVZaeyU YOaMPtgsiOX0v68NtrC1L37UuBykQlm7FdobN4Sg5FnLTt4IWktf0/vsaLdhRozD KsbTmsumCrScAwZfa0H3S8WqK6yCEKjPi+J4xG1OZP1WptlV41wLnFKkeFaZRIkB HAQTAQoABgUCUx/Y+AAKCRDV3jiWlKRlsmU0B/96eiPHIIvapoXKoZSt23OFjXG+ 3xp/Zzf2Ug0384FYZJ1eX/R2IWsh64CVvOR0LMFvHvPU7SCMu2OreNHfPx/B/kn8 MmusGy6JHP25A4BWzs1eeyKgYQTFz7vSCeAnytmcdBot1s099upIRw4usCLhdxzv Qyx6TogAacGC3YFj7o0agz+ApPnCQZ68kZpDOCDrtOe/DRted1LLXM661Cp15d5R d+91ZSKfQ9xjK1d2k8iMYJqWYll50DalGtzPGDB335gX7agliI5dYiu2XSLyynhw /7f8d0Bz8KVj7pgCroAVjTSdHvZfVcZJU4HST/jHx5hilVUzkr9NK5YONJ8SiQQc BBABCgAGBQJTKlm2AAoJEPvivaOtdGgqmGAgALl0eAcUSF7IuloPT4VyJeNGMuOb 7aN4yYrGBM+y7Ij/dTWSS1yjlcixsqd+s0dqGse6RtJkyhkisEmNdS7Sf62okGDl ZbmhjvMQteUO1zw+CREdfx5oMpW/eCHq/Pzw8KRdp6qY0wBRj10GFMAaMX8XCNOh 6B6Ti0AQ/424yEvcPpA0zXwvLGylFozRxjK6qWEHEmW/+knxYYN/W+8TERuwVJSN F3jBYl73DTVBZ4bzpu5jMSydhRD02nV2LbnolhbCzGllLkhQw6iFW36br8600Tba loQhcJU+cmuCId/B6xXcF+fyWqmMmm+b0UFoHGRBnXCf4gBcjCK0UwJ1lUOTY5qg IYJTrBpCrGAoGTd9s+1CtnnZFlIcwFJB7NwMZEsTWvOvO6sZPYP33ktcUwWAKqNj 3sSjy43kdfUeVip0jzV0K5uStC+DiVq8VwH7uNIH2UbkQZato67WgShUCCaSvf2p HapSRdrmwIaoANQuEluhytdafX7yqJXGkhYI0Ylh2FH3oZyTnz1XoB5y5T1OpFpi I7CgjRO677aieRsf6HACHPX5mWcq8zJQ8fuxoHZ5GJ8FEyk6ULUgFJ3u9SgG5k5I vP4pK8+lP/d90Zf98Uaq4aMgAoIlrtwz68Bv/KUlpwVWhiIgo89C5UwcTUNQOmi3 0PxCpamM81NwGPxjZAqr/+0YP3NBtJOITL0oqRCxcHCJ9N8gmqUmUEgEffP+glsJ p/mQeJEacmR9loz6WAB6GT9mu5TvX6bZ5EawnluQ1mI6Tn+v6ltjhKzPzaVhOo6d iKriQFZhcelX1qDnE3zs7driBeacuKGt4URV8A+UDGJBeIAEfrlszor3FQ0qOUPs plbcbB4YudUOhlH1REtGx7zWVFefuy80ZC7abHsPhWkJow2axWlvPqjSsd/KgpjG IAHIZxiYAozNJqDNluGx1+qa1d7/YINthZKefhkG3XDLuhgxvD8rAovyAFW/8Vy0 S+GpzUVtC8HY9FZf2gRkVtZQGboZck2uFyIaU/Ni4ahX8Z9IvtsU9JPLzp0HRgAv 9kz9EyRZt1viueeIVcmadHirUe1IKqndeslcXOX4dUF0nrqP1+shYhebgq93rMPR yH3EsoXtAP1KCN8tWPdnlDnMY0Zpy32mfCL0hMMnH+CY5rARssSbiFP9HeWk/CN+ yES7FY705QmV/2SV4rEngqnIcrcqEJFp49JPihC1pSikHCItzSVFaODbUl4qhTjn Tjtl0pdFQc9ksA/6IEOH/bufDwtxCLwAjUpqyNGEH/8FnxtwotsTmhmTWMe9vxYe YStdTLkAvJFMVEU0W+H2ZZG481P5/8tqFS9cHEU++3VvuYxfipwjpIQhm5WJARwE EAEKAAYFAlMuEVwACgkQq+DDGd8KChpPGwf/QL66k12OzqI40KQL+UbzW25vxbmE OyZ1MT9SuUVt6Th9zdoNm9Cosi9kOiq+DPLFFT751Lmm1hcM0rDDNeN+l8wpLwX9 EifD/bQ7Q5esM8NJmGVyhA/Cd3wkp5yYNdZPOu9/0xpe/Px4YgficRErhgyVh2Vs svQRQ0WcTYbgbmQFpOUsjNVOchJMFERSJaQxWgN3olYd5DTDxPDLztt3vdBCIkz0 4OAotZqbqdnmvlkjKjzrJylfCkyo9bOU471v6Hs3mfUQXo9nXC9zGETFWsvB4WCC QdWEyj+2K+PcdZU0FEPonfTouVcsR9oTqQqqfg21M7HUHSmlrOyCLqNnZ4kCHAQQ AQIABgUCU2vk5AAKCRDuYMDI7nJWqGIzD/9vdI3uUUYGCaURAprGEo4kk6JP2TcS AmyO9Pr8bBdpmt/DVFK0zWllQ+69QAWLFoCmgjOgWUPRNWA+ldG5lzExjuuP38P1 4HupPMh0yOd+QUod4Gdi+hqPCuFT4/oErWZcOGGXAw4ZcvdEGKY9E975D+3yd7sG HGskvGB/UmLIBQ2XfQOoqk0A9eXz55wLN1ia1imHd/0NkPkQOHkjTdOtHhcBhuoc ttex9HcmYy2g5oorG+7wx0EtHxIhuCcRq1wQgXm2JtbiFHXiH0MpLfBr29kpzH7y 8jompGgAJsK8uRwTC8UFWHnx0VxnFQ+4vinqlgj7/O+WMZ/siDlOZDo2RC3ts+Ct 91kYNFHsycrkJYuoPzNcMy7mmixQFj5L2VIG1Ne3OTdEPVWE5jIQ/w5IX0aYxNt4 ANIZJA/r1AqDqDEhto6gdnkrVZSJN+Mvd7yj7XTbrErpTmQeNkGgb9ult4XaEOdm bjAjE6rTQqFD3Tn8SeXNgkJFr0Zb8lZypmOL6cxU4vTG66blJPLZGuaH3yCrtA1i ynZPrV2TYiET+fhg2TBEXbjLkWHQnA+7sFFOTgK5WOqc6vK29h5ssEQKIFodDh4a e88tiGLW9lSc+YWRpKHgEc8QDXIuBrV18hZEvbITvLZnnf5uIFXJV5ZCHG+o6I+Y jQrPY4oC2HGrMIkBIgQQAQoADAUCVRRYygWDB4YfgAAKCRCFZ1M6Yr7+XbxwB/42 Kbk6DpZueEK0qtdoLUh7H+dWfwA0Gsh/vCoS6RM9iXjKPBoQGlbCBpsBpqCJkGd/ iXH+tnkU2dq4BvGc/igSHadNYmYq077l1vu3pJjDjxfQ2qZSF9D27EUzlXLd4Q6s hysZ18HoTehxr3AG33N1tEm9kBUfZjeMZxk7zbty3Lo7tK/UYN+4mIgYqLc97XIe 40Z\niQIcBAEBCgAGBQJWT6iBAAoJEBO17ljAn7PgnxIP/RevbXaCm2Q3ildI0YLjQFDr vSIGKsCjD9nZY3ETk+CNFGOL4aYWp96HWuQoMq7B6qlb/sLejN/Ssu3M0sxf2hNK pCIagZClqRchSBK+0UpAEIs98sf0sPakqKg0FlOJhuCsKHMUOxpQJ4qCDh6f24b2 cqKR8GjyUAgSeiiyN+DkDyqRYingQGAU5vzKepYzX+DMHC/izqQhrwQLVImv20wr 5pKZJDjfOpYUZRTuScV5Qwcgc0JYcMOjfgA93ZUA2zDrGIpw3dcCSMrpNQcvM6Cg 1mfiLZzkvPH3UkUOWhHCn/N2XaAF58joCaS+/bVUaXx02IbxJ1TTjqtCiH9491mE aaHeRCFYbkKCXWjuxCx1+VZN2yRk24rSkis/+LFgZm850fXgYfrqiyPRDlCMApdo 5JDUBTioyZz24vhqWpe0OZueu11DXtpU1G0BiheGrweXAAx0Yki8dRiPTXkavAMj oMBND9G7a1564KOe+t6V2qUyH50+3NaANvIiDJZbspX7yl8eVzPbwcGvtHzmHdnV pDh+38XUQEID5YJ/mdZh6evzmmTnQR1HVqPVrzs8SwIDO++tqj8DXTjID47c3VIl YhCMNlucciFxVn/sYI5qiJzCEMLMbvG+EhnoLNU4JGjfzo6I0RCpPfbrDfOsWJNi zYMz9htqusCQsGwUZSTZ =XBC5 \u0026mdash;\u0026ndash;END PGP SIGNATURE\u0026mdash;\u0026ndash; str4d подписал следующие релизы: 0.9.23 Релизы с 0.7.6 по 0.9.12 были подписаны zzz следующим ключом: -----BEGIN PGP PUBLIC KEY BLOCK----- Version: GnuPG v1.4.6 (GNU/Linux) mQGiBEOjTnURBADegKKrIP6pz4+n57dqo3l9QrKhIklCtIxgJkL06ZJq5fKAnMLv GPaGXmn5vRrbo6QzHs/lGLG+ySWFWr9SsVstNKrwk+F1yGIERutl0BqMwX1esfN2 ugiZ3wB1yRu0PIrkm5cuDAFASFE+2lBjr1lfOrhw/dV+lLTcWx4NzkMzlwCgxgIk 4cqQMGaVkmtuICQdYmmMicUD/AmNSVJEm2XUvaS5fYWsHJG3+oNkdNGcx5SOMUdk PFwcSozqvT9FeIP76OVHAshQKeftE3utOFANQ/YomXEnypmwMxLLR+GPw5pMbKlK 6p+87aJZz+SA95E3ekmh7MmndvRd5RJDboUZy2H0FKX+FgaBlpsLl0uhT6uDuM/s 7nb0A/9nEAgICOU5SeXtO3jKY+RQvKyE0AblK7xVaU+Sn8ly0zauOJD13rycVGhu vLcAUVR3FKEjxafpvZ0ZPBo7AACjSDqAoCw/s/vt9gmrhHKiqN31PhYYLhKdfKTs 4LzWKTWKIAOwErkbYsMAXWKFT3LXsrEYvxq5j5m/6zMOwz2N7rQYenp6ICh6enop IDx6enpAbWFpbC5pMnA+iF8EExECAB8FAkOjTnUCGwMGCwkIBwMCBBUCCAMDFgIB Ah4BAheAAAoJEEFVdrqnbgvtxGsAn39SvQ3+ey87WDDG+TWArN6oU8gnAJ4zeAsA LUK37WZIt8OImZSxk37uQbkCDQRDo06VEAgAy2UeqsM5a+U6ZOWS9NQiILb3KbTL FeeAd2rn9oLSLpn5gDWycwUS0Q62JmbSMWy6m9aczpnxvwaBYXz6aCIvZmTNtaU6 vyR/6wfJDyiUWSHtCyjpyFFYJimANd8Y8dDCimvceI/ihEDVyBX0kkgUGRAn8t3e unaLXqhbfiLiFw/GG1MNxUMzHt55/+9AqLOfRZg0riZvDoV79K+1sYSs8n1WeaVc T3wTb+Cb7fKNN7GT1MUhcXIoYYY6FGwsy5EWFsxYBRervqHtBJog2SoNUa/6BFGr zX+LDjK9L3xMTr3+fHIt4gPR/Lt4nnfEzL+rjClz/Fazmv38BRwPuKahFwADBQgA nD/AvZCnbWSB6khAVMqva5ROaD0gV0/UejCelZdYfgfHeCmrcMNQ+wCyww2NPsih 9vB1w+AUE0pdH37k65VZN+2falUdzN+PFugJGuH2pmlVOprH2SuC5gKpGRvzUqV5 U0nJmT2okDpW/52asUDJJLu1g//A3qBP83WGvSKUZg/ZisZA0qTiHH4QpjklopXi sSxR2hT8Fr9gF9WmDa09wbxE2xh/EL7gvVg/vk0gwOJcsFd67bNC+KUMOnjhOP0T K0/Ah4TEEs/hHNe9RsyyWlMoIUsF8AhG71ISOrJ5lLSXNe151XEb5FzZRM8sD9Zq 0E3PjmLbdVhanYvsPnWK6YhJBBgRAgAJBQJDo06VAhsMAAoJEEFVdrqnbgvtXTwA njMu9ueCFbsjme7nwsz96PdazJcHAKCce17hGI25QNXDZyHohrjha6IxDg== =fAfi \u0026mdash;\u0026ndash;END PGP PUBLIC KEY BLOCK\u0026mdash;\u0026ndash;\nРелизы с 0.6.1.31 по 0.7.5 были подписаны Complication. Его публичный ключ: \u0026mdash;\u0026ndash;BEGIN PGP SIGNED MESSAGE\u0026mdash;\u0026ndash; Hash: SHA1\nЗдравствуйте,\nНастоящим удостоверяю, что ниже указан мой новый публичный ключ, выпущенный 2007-11-24, действителен до 2009-11-23, и его отпечаток ключа:\n73CF 2862 87A7 E7D2 19FF DB66 FA1D FC6B 79FC CE33\nЕсли у вас есть мой старый публичный ключ, и вы используете его для проверки, вы заметите, что мой старый ключ истёк 2007-11-15. Приношу извинения за задержку с этим обновлением.\nДля тех, кто хочет скопировать ключ непосредственно из этого сообщения, но не читает его в почтовом клиенте, пожалуйста, не забудьте удалить escape-последовательности \u0026ldquo;- \u0026quot; из начального и конечного маркеров блока открытого ключа. В противном случае он не будет распознан.\nОсложнение.\n\u0026mdash;\u0026ndash;BEGIN PGP PUBLIC KEY BLOCK\u0026mdash;\u0026ndash; Version: GnuPG v1.4.7 (GNU/Linux)\nmQGiBEdH5SYRBACzCum9jIjq+/G7ckuZ/TcFmaVYeBRE6OXPQozyrmTYtoCM2qGj DmvMJvKYiNiQVM42KiwlnqvaNtlgnXIZ6rcyLyn+bCI5cdX1SD5Rr5tgsgcXYA6Z l7usiFv1bTjD67piBehF130o+LZAJnVzI7JdpbA9SBY0mUwgKXLi0DAo8wCgiKOV UXC8+9X9vU1Mh/GyIrD4c3kD/iQOkYH4ajNaehTHNB31K+61ltpK9tMmcWtUY30A Z3q38jg/nmqqup/MYCtkvOqY4X9kujKzu01eSWSNZIE+BQSSd1cSsVD17OY3TL6B EvE+UFxh8OnDKs3tzJ0COnT/2zbgTavbWwqovoUE0P0PSYOFm2Co0BEQiCt9Tabc CxU3BACRWDvq7LFMRnHT+/OOJS6M442CYzy3+tIuc3ZAmZ8QwGsh4r1kd+5P1JTN YJCun6MPQEllJbRyHRBby76vFkWearRgnkpAmk2l1T2SXw3lip/SdmI0GgIzPSfQ 8WyNbMjQXyH8/3k2Y9rgrC0DttrJPYOcTFMNKPpeTR+HN3ZnibQ+Q29tcGxpY2F0 aW9uIChodHRwOi8vY29tcGxpY2F0aW9uLmkycCkgPGNvbXBsaWNhdGlvbkBtYWls LmkycD6IZQQTEQIAJQUCR0flJgIbAwUJA8JnAAYLCQgHAwIEFQIIAwMWAgECHgEC F4AACgkQ+h38a3n8zjP1yACfWkF1zjmlD0EzLaJRnefW5OHr10MAn0fgMyElK6ee AoPl2mTfxQQYOophuQQNBEdH5SYQEACTcoMJQBhyrr+EunLmEGNMO7D6RSBAtEKZ i5ctmhr/TCXMV9qjXkWISLZ9AS6z88rKozeOOK+QPBnc2FcEf77N04O5hwSdAyPH Qt7+umhiNQFQpZycJ5W87Y0ryERJygA5XyU47g7CGvuuOLgKGk0dDGCNFZGSblwI xtSh1CsrjWp23grFiBS0xvlU2VyuYUyrBuH5ip04pxmOyeRcaelkQerFhEXSRIR7 XFxl6JpfqWt2oWHmYbYD3RT6WHU+rpSF1Hyey+zoF2zXfRb+JD90MpBL1xIkpieQ Y69Cj5U5VRjEppJJowSmwgz+UyMnT2KLl45vJesPrMUaSgduHiIQo4LM5BcbbV+2 SC5i9xqbSJ+rc19Ftt9IEUZVMLole9PJC5Ff/h1qsabyueFuMIQkbiaUiNLOKl31 I+JAiDt0Xku2PEVCERg7Jq5AsTLB9D+zKqxbvFu+JvqSdlaCvlas2BYU5rBosszH TStK2XW/+poTKnjnbJl6nGC06BNQPhRFAwuXboyUC5fyiuG1HohvPmPIi6IejLUY G8A5nZ+7um/XpKlt2i5rdVRfN1BX3+aKHQeLmrc+EIORZUU32TrP4ceLtSDf+JOW 8N3vwzqKIPu42Y5KB8vnXEFSOkyt36OfEd6CcPKmncDyA4wJmfC+X3eoKcj+Yrh7 UMr0elyw4wADBg/9F7g+bTpT4wPXj5ax1i+4BdedjVlO3YBdhc4LP6MXipNU6yLl l63TJ8q/l8pvSkUWZXrO3a7OibM/MHp0Te/7sTmKib2/3MFwHTrtjgcZBF6wx8LD T3oa6O0IK8IRnRwNqeu83SxojvVY0wLz/hpUbnIrOcHMZjWLMJEfHkNBHn+1HhT5 tk9LRGu3j1oTpGh+DpdoPF5fggNu48YJ6n7etJJGW2MXQ++33aKeQSFrx+KlMtFW DSzg3KKSroB8Ex9wiKKWybagaed0YoP9BW3vIAaOeDpqK92UuTFz1Bte1DYiYU1e Rqq1xoBVhJXE5xzGmvS4/PIZMOL/bpKcuNxAgmwOVoaYoWZuIgePUaBbNvNg84HE RBjFMyfpzRCdPlWPZ18KcLUki3T58KzXEZ7WS5hC5lezwC6ET+wJusAt0A+Ik146 igayKfVnvhedQdqufWhQWNr+hDc5Fb/az8nTyNOflAhD3yHldjxgkCOV8wjqyS+4 iO33P5wW7o2QkZNWq8pyjsKRRJCtZ/PJ7FRGkUOjoC/gwhnGvBi0KoDcyBmfnPXp 3MAgrzk9LwiA7PlS7PyhyMx5mYpa90xlXzszweCIXzGfbm6ciCUAM3G3Qb+qa2dW 0u1X5L6bVtHVpYnr+5JOxCS4qwQvoK0QnHu6ezu4+rFutUJN35z6rFquejiITwQY EQIADwUCR0flJgIbDAUJA8JnAAAKCRD6HfxrefzOMzSZAJ9PmYNkW4Ia1qPqowg9 z4Ja+hJ3dgCeL3mqvOEHG7AcUQrSlc6xlC1vbNY= =rGxK - \u0026mdash;\u0026ndash;END PGP PUBLIC KEY BLOCK\u0026mdash;\u0026ndash; \u0026mdash;\u0026ndash;BEGIN PGP SIGNATURE\u0026mdash;\u0026ndash; Version: GnuPG v1.4.7 (GNU/Linux)\niD8DBQFHR/zm4tLxqYRsGn0RAtCfAJ9rz+tsyEbeUAHcogdzgSPfuiWOAwCfWaVn Aiib6V5wOPbYTy13ADmxhfE= =mPFq \u0026mdash;\u0026ndash;END PGP SIGNATURE\u0026mdash;\u0026ndash; ","description":"PGP-ключи, используемые для подписи релизов I2P, и где их получить","id":"ae494d28c5c0216d277398ccdcc21df5","section":"docs","title":"Ключ подписи релизов","url":"/ru/docs/develop/release-signing-key/"},{"categories":null,"content":"Обзор Эта спецификация расширяет ленту подписки адресной книги командами, позволяя серверам имён рассылать обновления записей от владельцев имён хостов. Впервые предложена в Предложение 112 (сентябрь 2014), реализована в версии 0.9.26 (июнь 2016) и развернута по всей сети со статусом CLOSED.\nСистема оставалась стабильной и неизменной с момента первоначальной реализации, продолжая работать идентично в I2P 2.10.0 (Router API 0.9.65, сентябрь 2025 года).\nМотивация Ранее серверы подписки на hosts.txt отправляли данные только в простом формате hosts.txt:\nexample.i2p=b64destination Этот базовый формат создал несколько проблем:\nВладельцы имён хоста не могут обновлять Destination (криптографический адрес назначения в I2P), связанный с их именами хоста (например, чтобы обновить ключ подписи до более стойкого криптографического типа). Владельцы имён хоста не могут по своему усмотрению отказаться от владения своими именами хоста. Они должны передать соответствующие закрытые ключи Destination непосредственно новому владельцу. Нет способа подтвердить, что поддомен контролируется владельцем соответствующего базового имени хоста. В настоящее время это обеспечивается лишь некоторыми серверами имён в индивидуальном порядке. Проектирование Эта спецификация добавляет строки-команды в формат hosts.txt. С помощью этих команд серверы имён могут расширять предоставляемые ими службы, обеспечивая дополнительные возможности. Клиенты, реализующие эту спецификацию, могут отслеживать эти возможности через обычный процесс подписки.\nВсе командные строки должны быть подписаны соответствующей Destination (уникальный адрес сервиса в I2P). Это гарантирует, что изменения вносятся только по запросу владельца имени хоста.\nПоследствия для безопасности Эта спецификация не влияет на анонимность.\nРиски, связанные с утратой контроля над ключом Destination, возрастают, поскольку тот, кто завладеет им, сможет с помощью этих команд вносить изменения в любые связанные имена хостов. Однако это не представляет большей проблемы, чем текущее положение дел, при котором тот, кто получает Destination (адрес назначения в I2P), может выдавать себя за имя хоста и (частично) перехватывать его трафик. Повышенный риск компенсируется тем, что владельцам имен хостов предоставляется возможность изменить Destination, связанный с именем хоста, в случае если они считают, что Destination был скомпрометирован. В текущей системе это невозможно.\nСпецификация Новые типы перевода строки Появились два новых типа линий:\nКоманды Add и Change: example.i2p=b64destination#!key1=val1#key2=val2... Удалите команды: #!key1=val1#key2=val2... Упорядочение Лента не обязательно упорядочена или полна. Например, команда change может появиться в строке перед командой add или вовсе без команды add.\nКлючи могут быть в любом порядке. Повторяющиеся ключи не допускаются. Все ключи и значения чувствительны к регистру.\nОбщие ключи Требуется во всех командах:\nsig : подпись в формате Base64, с использованием ключа подписи из destination\nСсылки на второе имя хоста и/или адрес назначения:\noldname : Второе имя хоста (новое или изменённое)\nolddest : Второй адрес назначения в Base64 (новый или изменённый)\noldsig : Вторая подпись Base64, использующая ключ подписи из olddest\nДругие распространённые ключи:\naction : Команда\nname : Имя хоста, присутствует только если ему не предшествует example.i2p=b64dest\ndest : Назначение в формате Base64, присутствует только если ему не предшествует example.i2p=b64dest\ndate : В секундах с начала эпохи Unix\nexpires : В секундах с начала эпохи\nКоманды Все команды, кроме команды \u0026ldquo;Add\u0026rdquo;, должны содержать пару ключ/значение action=command.\nДля совместимости с более старыми клиентами большинство команд предваряются example.i2p=b64dest, как указано ниже. При изменениях всегда используются новые значения. Все старые значения включены в раздел ключ/значение.\nПеречисленные ключи обязательны. Все команды могут содержать дополнительные пары ключ/значение, не определённые здесь.\nДобавить имя хоста Предваряется example.i2p=b64dest : ДА, это новое имя хоста и назначение.\nдействие : НЕ включено, оно подразумевается.\nsig : подпись\nПример:\nexample.i2p=b64dest#!sig=b64sig Изменить имя хоста Предваряется example.i2p=b64dest : ДА, это новое имя хоста и старое назначение.\nдействие : changename\noldname : старое имя хоста, которое нужно заменить\nsig : подпись\nПример:\nexample.i2p=b64dest#!action=changename#oldname=oldhostname#sig=b64sig Изменить адрес назначения Предваряется example.i2p=b64dest : ДА, это старое имя хоста и новый адрес назначения.\naction : changedest\nolddest : старый адрес назначения, подлежит замене\noldsig : подпись с использованием olddest\nsig : подпись\nПример:\nexample.i2p=b64dest#!action=changedest#olddest=oldb64dest#oldsig=b64sig#sig=b64sig Добавить псевдоним хоста Предваряется example.i2p=b64dest : ДА, это новое (псевдоним) имя хоста и прежний destination (адрес назначения).\naction : addname\noldname : старое имя хоста\nsig : подпись\nПример:\nexample.i2p=b64dest#!action=addname#oldname=oldhostname#sig=b64sig Добавить псевдоним адреса назначения (Используется для обновления криптографии)\nПредваряется example.i2p=b64dest : ДА, это старое имя хоста и новый (альтернативный) адрес назначения.\naction : adddest\nolddest : старое назначение\noldsig : подпись с использованием olddest\nsig : подпись с использованием dest\nПример:\nexample.i2p=b64dest#!action=adddest#olddest=oldb64dest#oldsig=b64sig#sig=b64sig Добавить поддомен С префиксом subdomain.example.i2p=b64dest : ДА, это новое имя поддомена и назначение.\naction : addsubdomain\noldname : имя хоста более высокого уровня (example.i2p)\nolddest : назначение верхнего уровня (например example.i2p)\noldsig : подпись с использованием olddest\nsig : подпись с использованием dest\nПример:\nsubdomain.example.i2p=b64dest#!action=addsubdomain#oldname=example.i2p#olddest=oldb64dest#oldsig=b64sig#sig=b64sig Обновить метаданные С префиксом example.i2p=b64dest : ДА, это старое имя хоста и назначение.\nдействие : обновление\nsig : подпись\n(добавьте сюда любые обновлённые ключи)\nПример:\nexample.i2p=b64dest#!action=update#k1=v1#k2=v2#sig=b64sig Удалить имя хоста Предваряется записью example.i2p=b64dest : НЕТ, это указывается в параметрах\nдействие : удалить\nname : имя хоста\ndest : адрес назначения\nsig : подпись\nПример:\n#!action=remove#name=example.i2p#dest=b64dest#sig=b64sig Удалить все с этим адресом назначения С префиксом example.i2p=b64dest : НЕТ, это указывается в параметрах\nдействие : removeall\ndest : адрес назначения\nsig : подпись\nПример:\n#!action=removeall#dest=b64dest#sig=b64sig Подписи Все команды должны быть подписаны соответствующим Destination (уникальный адрес назначения в I2P). Для команд с двумя Destination могут потребоваться две подписи.\noldsig — это всегда \u0026ldquo;внутренняя\u0026rdquo; подпись. Подписывайте и проверяйте без ключей oldsig или sig. sig — это всегда \u0026ldquo;внешняя\u0026rdquo; подпись. Подписывайте и проверяйте при наличии ключа oldsig, но без ключа sig.\nВходные данные для подписей Чтобы сгенерировать поток байтов для создания или проверки подписи, сериализуйте следующим образом:\nУдалите ключ sig Если проверка выполняется с oldsig, также удалите ключ oldsig Только для команд Add или Change выведите example.i2p=b64dest Если остались какие-либо ключи, выведите #! Отсортируйте параметры по ключу в UTF-8, выдайте ошибку при дублирующихся ключах Для каждой пары ключ/значение выведите key=value, после чего (если это не последняя пара ключ/значение) символ # Примечания\nНе выводите символ новой строки Кодировка вывода — UTF-8 Все значения destination и signature кодируются в Base 64 с использованием алфавита I2P Ключи и значения чувствительны к регистру Имена хостов должны быть в нижнем регистре Текущие типы подписей Начиная с I2P 2.10.0 поддерживаются следующие типы подписей для назначений:\nEdDSA_SHA512_Ed25519 (Type 7): Наиболее распространённый для назначений начиная с 0.9.15. Использует 32-байтный открытый ключ и 64-байтную подпись. Это рекомендуемый тип подписи для новых назначений. RedDSA_SHA512_Ed25519 (Type 13): Доступен только для назначений и зашифрованных leasesets (начиная с 0.9.39). Устаревшие типы (DSA_SHA1, варианты ECDSA): Всё ещё поддерживаются, но объявлены устаревшими для новых Router Identities начиная с 0.9.58. Примечание: Постквантовые криптографические варианты доступны начиная с I2P 2.10.0, но пока не являются типами подписей по умолчанию.\nСовместимость Все новые строки в формате hosts.txt реализованы с использованием начальных символов комментария (#!), поэтому все более старые версии I2P будут интерпретировать новые команды как комментарии и корректно их игнорировать.\nКогда I2P routers обновятся до новой спецификации, они не будут заново интерпретировать старые комментарии, но начнут обрабатывать новые команды при последующих загрузках своих лент подписок. Поэтому важно, чтобы серверы имён тем или иным образом сохраняли записи команд или включили поддержку ETag (HTTP‑заголовка с идентификатором версии ресурса), чтобы routers могли получить все прошлые команды.\nСтатус реализации Первоначальное развертывание: Версия 0.9.26 (7 июня 2016)\nТекущее состояние: Стабильное и без изменений до I2P 2.10.0 включительно (Router API 0.9.65, сентябрь 2025)\nСтатус предложения: ЗАКРЫТО (успешно развернуто по всей сети)\nРасположение реализации: apps/addressbook/java/src/net/i2p/addressbook/ в I2P Java router\nКлючевые классы: - SubscriptionList.java: Управляет обработкой подписок - Subscription.java: Обрабатывает отдельные ленты подписок - AddressBook.java: Базовая функциональность адресной книги - Daemon.java: Фоновая служба адресной книги\nURL подписки по умолчанию: http://i2p-projekt.i2p/hosts.txt\nПодробности транспорта Подписки используют HTTP с поддержкой условного GET:\nЗаголовок ETag: Позволяет эффективно обнаруживать изменения Заголовок Last-Modified: Отслеживает моменты обновления подписки 304 Not Modified: Серверы должны возвращать этот статус, когда содержимое не изменилось Content-Length: Настоятельно рекомендуется для всех ответов I2P router использует стандартное поведение HTTP‑клиента с полноценной поддержкой кэширования.\nКонтекст версии Примечание о версионировании I2P: Начиная примерно с версии 1.5.0 (август 2021 года), I2P перешёл с схемы версионирования 0.9.x на семантическое версионирование (1.x, 2.x и т. д.). Однако внутренняя версия Router API продолжает использовать нумерацию 0.9.x для обеспечения обратной совместимости. По состоянию на октябрь 2025 года текущий релиз — I2P 2.10.0 с версией Router API 0.9.65.\nНастоящий документ спецификации был изначально написан для версии 0.9.49 (февраль 2021 года) и остаётся полностью актуальным для текущей версии 0.9.65 (I2P 2.10.0), поскольку система подписных лент не претерпела изменений с момента своей первоначальной реализации в 0.9.26.\nСсылки Предложение 112 (Оригинал) Официальная спецификация Документация по системе именования I2P Спецификация общих структур Репозиторий исходного кода I2P Репозиторий I2P на Gitea Связанные разработки Хотя сама система подписки на ленты не изменилась, следующие связанные изменения в инфраструктуре именования I2P могут представлять интерес:\nРасширенные имена Base32 (0.9.40+): Поддержка base32-адресов длиной 56+ символов для зашифрованных leasesets. Не влияет на формат ленты подписки. Регистрация TLD .i2p.alt (RFC 9476, конец 2023 года): Официальная регистрация .i2p.alt в GANA как альтернативного TLD. Будущие обновления router могут удалять суффикс .alt, но изменения в командах подписки не требуются. Постквантовая криптография (2.10.0+): Доступна, но не используется по умолчанию. В дальнейшем планируется рассмотреть алгоритмы подписи в лентах подписки. ","description":"Расширение для лент подписки на адреса, позволяющее владельцам имён хостов обновлять и управлять своими записями","id":"fa3cedda5fbeac90d0dcf029a44ee945","section":"docs","title":"Команды фида подписки адресов","url":"/ru/docs/specs/subscription/"},{"categories":null,"content":"Как того требует наша модель угроз (среди прочих причин), программное обеспечение, разработанное для поддержки сети анонимных коммуникаций, которую мы называем I2P, должно быть свободно доступным, с открытым исходным кодом и возможностью модификации пользователями. Чтобы соответствовать этим критериям, мы используем различные юридические и программные методы для устранения максимального количества барьеров на пути тех, кто рассматривает возможность использования I2P или внесения вклада в проект I2P.\nХотя информация ниже может показаться более запутанной, чем просто утверждение \u0026ldquo;I2P использует лицензию BSD\u0026rdquo;, \u0026ldquo;I2P использует лицензию GPL\u0026rdquo; или \u0026ldquo;I2P находится в общественном достоянии\u0026rdquo;, краткий ответ на вопрос \u0026ldquo;Какая лицензия у I2P?\u0026rdquo; следующий:\nВсе программное обеспечение, входящее в состав дистрибутивов I2P, позволяет: использование без платы использование без ограничений на то, как, когда, где, почему или кем оно запускается доступ к исходному коду без платы модификации исходного кода Большинство программного обеспечения гарантирует гораздо больше - возможность любому распространять модифицированный исходный код по своему усмотрению. Однако не все программное обеспечение в комплекте предоставляет такую свободу - GPL ограничивает возможности разработчиков, желающих интегрировать I2P со своими приложениями, которые сами не являются приложениями с открытым исходным кодом. Хотя мы приветствуем благородные цели увеличения ресурсов в общем достоянии, I2P лучше всего служит устранение любых барьеров, стоящих на пути его внедрения - если разработчик, рассматривающий возможность интеграции I2P со своим приложением, должен остановиться и проконсультироваться со своим юристом или провести аудит кода, чтобы убедиться, что их собственный исходный код может быть выпущен как совместимый с GPL, мы теряем возможности.\nЛицензии компонентов Дистрибутив I2P содержит несколько ресурсов, отражающих разделение исходного кода на компоненты. Каждый компонент имеет свою собственную лицензию, с которой соглашаются все разработчики, вносящие в него вклад — либо путём явного объявления о выпуске кода под лицензией, совместимой с этим компонентом, либо путём неявного выпуска кода под основной лицензией компонента. У каждого из этих компонентов есть ведущий разработчик, который принимает окончательное решение о том, какая лицензия совместима с основной лицензией компонента, а менеджер проекта I2P принимает окончательное решение о том, какие лицензии соответствуют вышеуказанным четырём гарантиям для включения в дистрибутив I2P.\nComponent Source path Resource Primary license Alternate licenses Lead developer I2P SDK core i2p.jar Public domain BSD, Cryptix, MIT zzz I2P Router router router.jar Public domain BSD, Cryptix, MIT zzz Ministreaming apps/ministreaming mstreaming.jar BSD Public domain, Cryptix, MIT zzz Streaming apps/streaming streaming.jar Public domain BSD, Cryptix, MIT zzz I2PTunnel apps/i2ptunnel i2ptunnel.jar GPL + exception Public domain, BSD, Cryptix, MIT zzz Routerconsole apps/routerconsole routerconsole.war Public domain — zzz Address Book apps/addressbook addressbook.war MIT Public domain, Cryptix, BSD — Susidns apps/susidns susidns.war GPL + exception — — Susimail apps/susimail susimail.war GPL + exception — — I2PSnark apps/i2psnark i2psnark.jar GPL + exception — zzz [BOB](/docs/legacy/bob/) Bridge apps/BOB BOB.jar WTFPL — sponge [SAM](/docs/api/samv3/) Bridge apps/sam sam.jar Public domain Cryptix, BSD, MIT zzz [SAM v1](/docs/legacy/sam/) Perl library apps/sam/perl SAM.pm GPL Public domain, Cryptix, BSD, MIT BrianR [SAM v1](/docs/legacy/sam/) C library apps/sam/c libSAM BSD Public domain, Cryptix, MIT Nightblade [SAM v1](/docs/legacy/sam/) Python library apps/sam/python i2p.py Public domain BSD, Cryptix, MIT Connelly [SAM v1](/docs/legacy/sam/) C# library apps/sam/csharp/ n/a Public domain BSD, Cryptix, MIT smeghead Other apps not mentioned apps/ ... Probably Public domain but check the source — — Installer installer install.jar, guiinstall.jar Public domain GPL + exception, BSD, Cryptix, MIT — Исключение GPL Хотя это может быть избыточным, для ясности код под GPL, включённый в I2PTunnel и другие приложения, должен распространяться под GPL с дополнительным «исключением», явно разрешающим использование стандартных библиотек Java:\nIn addition, as a special exception, XXXX gives permission to link the code of this program with the proprietary Java implementation provided by Sun (or other vendors as well), and distribute linked combinations including the two. You must obey the GNU General Public License in all respects for all of the code used other than the proprietary Java implementation. If you modify this file, you may extend this exception to your version of the file, but you are not obligated to do so. If you do not wish to do so, delete this exception statement from your version. Весь исходный код каждого компонента по умолчанию лицензируется в соответствии с основной лицензией, если в коде не указано иное. Всё вышеизложенное является кратким изложением условий лицензирования — пожалуйста, обратитесь к конкретной лицензии соответствующего компонента или исходного кода для получения точных условий. Местоположение исходных файлов компонентов и упаковка ресурсов могут быть изменены в случае реорганизации репозитория.\nЛицензия веб-сайта Если не указано иное, содержимое этого сайта лицензировано под Creative Commons Attribution-ShareAlike 4.0 International License .\nДоступ к коммитам Разработчики могут отправлять изменения в распределенный git-репозиторий, если получат разрешение от лица, управляющего этим репозиторием. Подробности смотрите в Руководстве для новых разработчиков .\nОднако, чтобы изменения были включены в релиз, разработчики должны быть доверенными лицами у менеджера релизов (в настоящее время zzz). Кроме того, они должны явно согласиться с вышеуказанными условиями, чтобы получить доверие. Это означает, что они должны отправить одному из менеджеров релизов подписанное сообщение, подтверждающее, что:\nЕсли не указано иное, весь код, который я отправляю, неявно лицензируется в соответствии с основной лицензией компонента Если указано в исходном коде, код может быть явно лицензирован в соответствии с одной из альтернативных лицензий компонента Я имею право выпускать код, который я отправляю, на условиях, под которыми я его отправляю Если кому-либо известны случаи, когда вышеуказанные условия не выполняются, пожалуйста, свяжитесь с руководителем компонента и/или менеджером релизов I2P для предоставления дополнительной информации.\n","description":"Политика лицензирования и лицензии компонентов программного обеспечения, входящего в состав I2P","id":"74bb6af167b1176b4058e46e5f8ca568","section":"docs","title":"Лицензии программного обеспечения I2P","url":"/ru/docs/develop/licenses/"},{"categories":null,"content":"Обзор I2P строит временные, однонаправленные tunnel — упорядоченные последовательности router, которые пересылают зашифрованный трафик. Tunnel классифицируются как inbound (сообщения движутся к создателю) или outbound (сообщения движутся от создателя).\nТипичный обмен направляет сообщение Алисы через один из её исходящих туннелей, инструктирует конечную точку исходящего туннеля переслать его к шлюзу одного из входящих туннелей Боба, после чего Боб получает его на своей входящей конечной точке.\nA: Outbound Gateway (Алиса) B: Outbound Participant C: Outbound Endpoint D: Inbound Gateway E: Inbound Participant F: Inbound Endpoint (Боб) Туннели имеют фиксированное время жизни 10 минут и передают сообщения фиксированного размера 1024 байта (1028 байт включая заголовок туннеля), чтобы предотвратить анализ трафика на основе размера сообщений или временных паттернов.\nСловарь терминов Tunnel Tunnel gateway: Первый router в туннеле. Для входящих туннелей идентификатор этого router\u0026rsquo;а появляется в опубликованном LeaseSet . Для исходящих туннелей gateway является исходным router\u0026rsquo;ом (A и D выше). Tunnel endpoint: Последний router в туннеле (C и F выше). Tunnel participant: Промежуточный router в туннеле (B и E выше). Участники не могут определить свою позицию или направление туннеля. n-hop tunnel: Количество межроутерных переходов. 0-hop: Gateway и endpoint являются одним и тем же router\u0026rsquo;ом – минимальная анонимность. 1-hop: Gateway подключается напрямую к endpoint – низкая задержка, низкая анонимность. 2-hop: По умолчанию для исследовательских туннелей; баланс между безопасностью и производительностью. 3-hop: Рекомендуется для приложений, требующих сильной анонимности. Tunnel ID: 4-байтовое целое число, уникальное для каждого router\u0026rsquo;а и каждого перехода, случайно выбираемое создателем. Каждый переход получает и перенаправляет с разными ID. Информация о построении туннелей Роутеры, выполняющие роли gateway, participant и endpoint, получают различные записи в сообщении Tunnel Build Message. Современный I2P поддерживает два метода:\nElGamal (устаревший, записи размером 528 байт) ECIES-X25519 (текущий, записи размером 218 байт через Short Tunnel Build Message – STBM) Information Distributed to Participants Gateway получает: - Ключ туннельного слоя (ключ AES-256 или ChaCha20 в зависимости от типа tunnel) - Ключ туннельного IV (для шифрования векторов инициализации) - Ключ ответа и IV ответа (для шифрования ответа на построение) - ID туннеля (только для входящих gateway) - Хеш идентификатора следующего узла и ID туннеля (если не конечный)\nПромежуточные участники получают: - Ключ tunnel layer и ключ IV для своего hop - Tunnel ID и информацию о следующем hop - Ключ ответа и IV для шифрования build response\nКонечные точки получают: - Ключи уровня tunnel и IV - Ответный router и идентификатор tunnel (только для исходящих конечных точек) - Ключ ответа и IV (только для исходящих конечных точек)\nДля получения полной информации см. Спецификацию создания туннелей и Спецификацию создания туннелей ECIES .\nTunnel Pooling Роутеры объединяют туннели в пулы туннелей для обеспечения избыточности и распределения нагрузки. Каждый пул поддерживает несколько параллельных туннелей, обеспечивая переключение при отказе одного из них. Пулы, используемые внутри системы, называются exploratory tunnels (исследовательские туннели), в то время как специфичные для приложений пулы — это client tunnels (клиентские туннели).\nКаждое назначение поддерживает отдельные входящие и исходящие пулы, настраиваемые через параметры I2CP (количество туннелей, количество резервных, длина и параметры QoS). Роутеры отслеживают состояние туннелей, проводят периодические тесты и автоматически перестраивают отказавшие туннели для поддержания размера пула.\nПулирование туннелей 0-hop Tunnels: Обеспечивают только правдоподобное отрицание. Трафик всегда исходит и завершается на одном и том же router — не рекомендуется для анонимного использования.\nТуннели с 1 hop : Обеспечивают базовую анонимность против пассивных наблюдателей, но уязвимы, если противник контролирует этот единственный hop.\n2-хоповые туннели: Включают два удаленных роутера и существенно увеличивают стоимость атаки. По умолчанию для исследовательских пулов.\n3-hop Tunnels: Рекомендуется для приложений, требующих надежной защиты анонимности. Дополнительные хопы увеличивают задержку без существенного улучшения безопасности.\nПо умолчанию: Роутеры используют 2-хоповые исследовательские tunnels и специфичные для приложений 2- или 3-хоповые клиентские tunnels, обеспечивая баланс между производительностью и анонимностью.\nДлина туннеля Роутеры периодически тестируют туннели, отправляя DeliveryStatusMessage через исходящий туннель во входящий туннель. Если тест не проходит, оба туннеля получают отрицательный вес профиля. Последовательные сбои помечают туннель как неработоспособный; после этого роутер создает замену и публикует новый LeaseSet. Результаты используются в метриках пропускной способности узлов, применяемых системой выбора узлов .\nТестирование туннелей Роутеры строят туннели используя неинтерактивный телескопический метод: одно сообщение Tunnel Build Message распространяется от узла к узлу. Каждый узел расшифровывает свою запись, добавляет свой ответ и пересылает сообщение дальше. Конечный узел возвращает совокупный ответ о построении по другому пути, предотвращая корреляцию. Современные реализации используют Short Tunnel Build Messages (STBM) для ECIES и Variable Tunnel Build Messages (VTBM) для устаревших путей. Каждая запись шифруется для каждого узла с использованием ElGamal или ECIES-X25519.\nСоздание туннеля Трафик туннеля использует многослойное шифрование. Каждый hop (промежуточный узел) добавляет или удаляет слой шифрования по мере прохождения сообщений через туннель.\nElGamal tunnels: AES-256/CBC для полезной нагрузки с дополнением PKCS#5. ECIES tunnels: ChaCha20 или ChaCha20-Poly1305 для аутентифицированного шифрования. Каждый hop имеет два ключа: layer key и IV key. Роутеры расшифровывают IV, используют его для обработки полезной нагрузки, затем повторно шифруют IV перед пересылкой. Эта схема двойного IV предотвращает маркировку сообщений.\nИсходящие шлюзы предварительно расшифровывают все слои, чтобы конечные точки получали открытый текст после того, как все участники добавили шифрование. Входящие туннели шифруют в обратном направлении. Участники не могут определить направление или длину туннеля.\nШифрование туннелей Динамическое время жизни туннелей и адаптивный размер пула для балансировки сетевой нагрузки Альтернативные стратегии тестирования туннелей и диагностика отдельных переходов (hop) Опциональная проверка proof-of-work или сертификатов пропускной способности (реализовано в API 0.9.65+) Исследование формирования трафика и вставки шума (chaff) для смешивания конечных точек Продолжение вывода из эксплуатации ElGamal и миграция на ECIES-X25519 Текущая разработка Спецификация реализации туннелей Спецификация создания туннелей (ElGamal) Спецификация создания туннелей (ECIES-X25519) Спецификация туннельных сообщений Garlic-маршрутизация Сетевая база данных I2P Профилирование и выбор узлов Модель угроз I2P Шифрование ElGamal/AES + SessionTag Параметры I2CP ","description":"Обзор терминологии I2P туннелей, их построения и жизненного цикла","id":"d2bb4d16ccaaecd4bfaae8d5b1356800","section":"docs","title":"Маршрутизация туннелей","url":"/ru/docs/overview/tunnel-routing/"},{"categories":null,"content":"1. Что означает \u0026ldquo;Анонимный\u0026rdquo; I2P обеспечивает практическую анонимность — не невидимость. Анонимность определяется как сложность для противника получить информацию, которую вы хотите сохранить в тайне: кто вы, где вы находитесь или с кем вы общаетесь. Абсолютная анонимость невозможна; вместо этого I2P стремится к достаточной анонимности в условиях глобальных пассивных и активных противников.\nВаша анонимность зависит от того, как вы настроите I2P, как выберете узлы и подписки, и какие приложения вы откроете для доступа.\n2. Эволюция криптографии и транспорта (2003 → 2025) Era Primary Algorithms Notes 0.3 – 0.9 ElGamal + AES-256 + DSA-SHA1 Legacy stack (2003–2015) 0.9.15 Ed25519 signatures Replaced DSA 0.9.36 (2018) NTCP2 introduced Noise XK_25519_ChaChaPoly_SHA256 0.9.56 (2022) SSU2 enabled by default Noise-based UDP transport 2.4.0 (2023) NetDB Sub-DB isolation Prevents router↔client linkage 2.8.0+ (2025) Congestion-aware routing / observability reductions DoS hardening 2.10.0 (2025) Post-quantum hybrid ML-KEM support (optional) Experimental **Текущий криптографический набор (Noise XK):** - **X25519** для обмена ключами - **ChaCha20/Poly1305 AEAD** для шифрования - **Ed25519 (EdDSA-SHA512)** для подписей - **SHA-256** для хеширования и HKDF - Опциональные **ML-KEM гибриды** для постквантового тестирования Все использования ElGamal и AES-CBC упразднены. Транспорт полностью основан на NTCP2 (TCP) и SSU2 (UDP); оба поддерживают IPv4/IPv6, прямую секретность (forward secrecy) и обфускацию для противодействия DPI.\n3. Краткий обзор сетевой архитектуры Mixnet со свободной маршрутизацией: Отправители и получатели самостоятельно определяют свои tunnel. Отсутствие центрального органа: Маршрутизация и именование децентрализованы; каждый router поддерживает локальное доверие. Однонаправленные tunnel: Входящие и исходящие разделены (время жизни 10 минут). Exploratory tunnel: По умолчанию 2 hop; клиентские tunnel — 2–3 hop. Floodfill router: ~1 700 из ~55 000 узлов (~6 %) поддерживают распределённую NetDB. Ротация NetDB: Пространство ключей обновляется ежедневно в полночь UTC. Изоляция под-БД: Начиная с версии 2.4.0, каждый клиент и router используют отдельные базы данных для предотвращения связывания. 4. Категории атак и текущие средства защиты Category Current Status (2025) Primary Defenses Brute Force / Cryptanalysis Impractical with modern primitives (X25519, ChaCha20). Strong crypto, key rotation, Noise handshakes. Timing Attacks Still unsolved for low-latency systems. Unidirectional tunnels, 1024\u0026nbsp;B cells, profile recalc (45\u0026nbsp;s). Research continues for non-trivial delays (3.0+). Intersection Attacks Inherent weakness of low latency mixnets. Tunnel rotation (10\u0026nbsp;min), leaseset expirations, multihoming. Predecessor Attacks Partially mitigated. Tiered peer selection, strict XOR ordering, variable length tunnels. Sybil Attacks No comprehensive defense. IP /16 limits, profiling, diversity rules; HashCash infra exists but not required. Floodfill / NetDB Attacks Improved but still a concern. One /16 per lookup, limit 500 active, daily rotation, randomized verification delay, Sub-DB isolation. DoS / Flooding Frequent (esp. 2023 incidents). Congestion-aware routing (2.4+), aggressive leaseset removal (2.8+). Traffic ID / Fingerprinting Greatly reduced. Noise obfuscation, random padding, no plaintext headers. Censorship / Partitioning Possible with state-level blocking. Hidden mode, IPv6, multiple reseeds, mirrors. Development / Supply Chain Mitigated. Open source, signed SU3 releases (RSA-4096), multi-signer trust model. --- 5. Современная сетевая база данных (NetDB) Основные факты (всё ещё актуальны): - Модифицированная Kademlia DHT хранит RouterInfo и LeaseSets. - Хеширование ключей SHA-256; параллельные запросы к 2 ближайшим floodfills с таймаутом 10 с. - Время жизни LeaseSet ≈ 10 мин (LeaseSet2) или 18 ч (MetaLeaseSet).\nНовые типы (начиная с версии 0.9.38): - LeaseSet2 (тип 3) – несколько типов шифрования, с временными метками. - EncryptedLeaseSet2 (тип 5) – скрытый destination для приватных сервисов (аутентификация DH или PSK). - MetaLeaseSet (тип 7) – мультихоминг и расширенные сроки действия.\nКрупное обновление безопасности – изоляция Sub-DB (2.4.0): - Предотвращает связывание router↔client. - Каждый client и router используют отдельные сегменты netDb. - Проверено и прошло аудит (2.5.0).\n6. Скрытый режим и ограниченные маршруты Hidden Mode: Реализован (автоматически активируется в странах со строгими ограничениями согласно индексу Freedom House).\nРоутеры не публикуют RouterInfo и не маршрутизируют трафик. Restricted Routes: Частично реализовано (базовые tunnel только через доверенные узлы).\nКомплексная маршрутизация через доверенные узлы запланирована (3.0+). Компромисс: Лучшая конфиденциальность ↔ уменьшенный вклад в пропускную способность сети.\n7. DoS и Floodfill атаки Исторический контекст: Исследование UCSB 2013 года показало возможность атак Eclipse и захвата Floodfill. Современные меры защиты включают: - Ежедневная ротация keyspace. - Ограничение Floodfill ≈ 500, один на /16. - Рандомизированные задержки проверки хранилища. - Предпочтение более новым роутерам (2.6.0). - Исправление автоматической регистрации (2.9.0). - Маршрутизация с учётом перегрузки и throttling lease (2.4.0+).\nАтаки на floodfill остаются теоретически возможными, но практически более сложными.\n8. Анализ трафика и цензура Трафик I2P сложно идентифицировать: нет фиксированного порта, нет handshake в открытом виде и используется случайное заполнение. Пакеты NTCP2 и SSU2 имитируют распространённые протоколы и применяют обфускацию заголовков ChaCha20. Стратегии заполнения базовые (случайные размеры), фиктивный трафик не реализован (ресурсозатратно). Подключения с выходных узлов Tor блокируются начиная с версии 2.6.0 (для защиты ресурсов).\n9. Постоянные ограничения (признанные) Корреляция по времени для низколатентных приложений остается фундаментальным риском. Атаки пересечения все еще эффективны против известных публичных узлов назначения. Атаки Сивиллы не имеют полной защиты (HashCash не применяется принудительно). Трафик с постоянной скоростью и нетривиальные задержки остаются нереализованными (запланировано в 3.0). Прозрачность в отношении этих ограничений является намеренной — она предотвращает переоценку пользователями уровня анонимности.\n10. Сетевая статистика (2025) ~55 000 активных роутеров по всему миру (↑ с 7 000 в 2013) ~1 700 floodfill роутеров (~6 %) 95 % участвуют в маршрутизации туннелей по умолчанию Уровни пропускной способности: K (\u0026lt;12 КБ/с) → X (\u0026gt;2 МБ/с) Минимальная скорость для floodfill: 128 КБ/с Консоль роутера требует Java 8+, планируется Java 17+ в следующем цикле 11. Разработка и центральные ресурсы Официальный сайт: geti2p.net Документация: Documentation Репозиторий Debian: https://deb.i2pgit.org (заменил deb.i2p2.de в октябре 2023) Исходный код: https://i2pgit.org/I2P_Developers/i2p.i2p (Gitea) + зеркало на GitHub Все релизы подписаны в контейнерах SU3 (RSA-4096, ключи zzz/str4d) Активных списков рассылки нет; сообщество на https://i2pforum.net и IRC2P. Цикл обновлений: стабильные релизы каждые 6–8 недель. 12. Обзор улучшений безопасности с версии 0.8.x Year Feature Effect 2015 Ed25519 signatures Removed SHA1/DSA weakness 2018 NTCP2 Noise-based TCP transport 2019 LeaseSet2 / EncryptedLeaseSet2 Hidden services privacy 2022 SSU2 Noise-based UDP transport 2023 Sub-DB Isolation + Congestion-Aware Routing Stopped NetDB linkage / improved resilience 2024 Floodfill selection improvements Reduced long-term node influence 2025 Observability reductions + PQ hybrid crypto Harder timing analysis / future-proofing --- 13. Известные нерешенные вопросы или запланированная работа Комплексная маршрутизация через ограниченные маршруты (доверенные узлы) → запланировано в 3.0. Нетривиальные задержки/пакетирование для защиты от анализа времени → запланировано в 3.0. Расширенное дополнение (padding) и фиктивный трафик → не реализовано. Проверка идентификации через HashCash → инфраструктура существует, но неактивна. Замена DHT на R5N → только предложение. 14. Ключевые ссылки Practical Attacks Against the I2P Network (Egger et al., RAID 2013) Privacy Implications of Performance-Based Peer Selection (Herrmann \u0026amp; Grothoff, PETS 2011) Resilience of the Invisible Internet Project (Muntaka et al., Wiley 2025) Официальная документация I2P 15. Заключение Базовая модель анонимности I2P существует уже два десятилетия: жертвовать глобальной уникальностью ради локального доверия и безопасности. От ElGamal к X25519, от NTCP к NTCP2 и от ручных reseed к изоляции Sub-DB, проект эволюционировал, сохраняя при этом свою философию эшелонированной защиты и прозрачности.\nМногие атаки остаются теоретически возможными против любой низколатентной mixnet, но непрерывное укрепление I2P делает их всё более непрактичными. Сеть больше, быстрее и безопаснее, чем когда-либо, — но по-прежнему честно признаёт свои ограничения.\n","description":"Каталог атак, учтенных в дизайне I2P, и существующие меры защиты","id":"8433fa179e266d091a906a9059db53f4","section":"docs","title":"Модель угроз I2P","url":"/ru/docs/overview/threat-model/"},{"categories":null,"content":" Статус: Обновлено для I2P 2.10.0 (октябрь 2025). Этот список объединяет все активные, устаревшие и зарезервированные порты, используемые Java Router I2P, i2pd и связанными плагинами. Все порты перечислены в числовом порядке для единообразия.\nPort Service / Component Description Notes 123SNTPNetwork time synchronizationUses external NTP servers; required for accurate LeaseSet timestamps. 2827BOB interfaceLegacy client API bridgeDeprecated; disabled by default. 4444HTTP ProxyStandard web proxy for eepsite browsingDefault for both HTTP and HTTPS browser traffic. 4445HTTPS ProxyDedicated SSL/TLS proxyOptional; often redundant with 4444. 6667–6669IRC ProxyAccess to I2P IRC networksDefault = 6668; alternate ports avoid conflicts. 7650I2PControl PluginJSON‑RPC management APIAuth required; default password itoopie. 7652UPnP HTTP eventsUPnP control interfaceSupports automatic port forwarding. 7653UPnP SSDP responsesUPnP discoveryUDP response listener for device search. 7654I2CPCore application APIUsed by Java apps and i2pd for router integration. 7655SAM DatagramUDP bridge for SAM APISAM v3 support for real‑time apps. 7656SAM StreamTCP bridge for SAM APIPrimary non‑Java application interface. 7657Router Console (HTTP)Web admin interfaceLoopback‑only by default (127.0.0.1). 7658EepsiteDefault web server for I2PTunnelUsed for locally hosted services. 7659SMTP ProxyOutgoing mail via I2P‑BoteBridges standard email clients. 7660POP3 ProxyIncoming mail via I2P‑BoteServerless email retrieval. 7661I2PBote SMTP / Pebble BlogPlugin dual‑use portRarely conflicts since plugins don’t co‑install. 7662I2PBote IMAP / Zzzot TrackerPlugin dual‑use portUsed by Zzzot for BitTorrent tracking. 7663—Reserved for future pluginsUnused as of 2.10.0. 7664JAMWiki PluginWiki platform for I2P sitesOptional plugin. 7667Router Console (HTTPS)Secure web admin interfaceSelf‑signed cert by default. 7672Railroad PluginPlugin port reservationLast documented plugin port in series. 7644Browser Mode ProxyHTTP proxy for I2P Browser BundleUsed when running Browser mode alongside router. 7647Browser Mode ConsoleRouter console for I2P Browser BundleAvoids conflict with 7657. 8002I2PSnark Web UI (HTTP)BitTorrent client UIIntegrated in router console. 8003I2PSnark Web UI (HTTPS)BitTorrent client UI (SSL)Optional secure mode. 8887Router Network Port (Legacy)Old default for peer connectionsReplaced by randomized 9151–30777 range. 8118Privoxy (Reserved)External web proxy integrationNot part of core I2P; reserved for compatibility. 8123Polipo (Reserved)Alternate proxy integrationLegacy Tor proxy compatibility. 8888Freenet (Reserved)Anonymous network portPrevents conflicts on privacy nodes. 9050–9053Tor SOCKS (Reserved)Tor proxy range for co‑installationAvoids conflicts with I2P. 9150–9153Tor Browser SOCKS (Reserved)Tor Browser integrationReserved for cross‑tool coexistence. 9151–30777Router Network Port (Random)Active TCP/UDP transport portRandomized per install for anti‑fingerprinting. 1488 / 1776XD BitTorrent ClientStandalone I2P torrent clientAlternate to I2PSnark. 31000–32000Java Service WrapperRouter process managementHandles service control and restart. 3456 / 3458 / 3459Tahoe‑LAFS PluginDecentralized file storageOptional third‑party plugin. 4691 / 8997–8999Monotone Version ControlDistributed VCS supportHistorical usage for developer tools. 7070i2pd ConsoleWeb console for C++ implementationEquivalent to Java router console. 767xPlugin Range (General)Recommended port block for pluginsDevelopers start from 7672 upward. 11371SKS/GPG Key Server (Reserved)Key distribution serviceUsed for PGP/GPG over I2P. ## Примечания по реализации Все порты ниже 9000 (кроме 8887) по умолчанию привязаны к 127.0.0.1 в целях безопасности. Сетевой порт router (9151–30777) должен быть открыт для интернета для полноценного участия в сети. i2pd использует в основном те же назначения портов для совместимости (7070 консоль, 7654 I2CP, 7656/7655 SAM). Разработчикам плагинов следует согласовывать новые назначения портов через сообщество I2P во избежание конфликтов. ","description":"Полный справочник назначений портов I2P, портов плагинов и зарезервированных диапазонов.","id":"69ea4623f7bc59ab65ef7ea636966780","section":"docs","title":"Назначение портов","url":"/ru/docs/overview/ports/"},{"categories":null,"content":"Обзор В этом документе представлена исчерпывающая техническая спецификация файлов конфигурации I2P, используемых router и различными приложениями. Она охватывает спецификации форматов файлов, определения свойств и детали реализации, проверенные по исходному коду I2P и официальной документации.\nОбласть применения Файлы и форматы конфигурации Router Конфигурации клиентских приложений Конфигурации tunnel для I2PTunnel Спецификации форматов файлов и реализация Версионные особенности и устаревшие возможности Примечания по реализации Файлы конфигурации читаются и записываются с использованием методов DataHelper.loadProps() и storeProps() в библиотеке ядра I2P. Формат файла существенно отличается от сериализованного формата, используемого в протоколах I2P (см. Спецификация общих структур — Сопоставление типов ).\nОбщий формат конфигурационного файла Файлы конфигурации I2P следуют модифицированному формату Java Properties с определёнными исключениями и ограничениями.\nСпецификация формата Основано на Java Properties со следующими существенными отличиями:\nКодирование ОБЯЗАТЕЛЬНО использовать кодировку UTF-8 (НЕ ISO-8859-1, как в стандартных Java Properties) Реализация: использует утилиту DataHelper.getUTF8() для всех операций с файлами Экранирующие последовательности Последовательности экранирования НЕ распознаются (включая обратную косую черту \\) Продолжение строки НЕ поддерживается Символы обратной косой черты трактуются как литералы Символы комментариев # начинает комментарий в любом месте строки ; начинает комментарий только если находится в первом столбце ! НЕ начинает комментарий (в отличие от Java Properties) Разделители пар ключ–значение = — ЕДИНСТВЕННЫЙ допустимый разделитель пары «ключ–значение» : НЕ распознаётся как разделитель Пробельные символы НЕ распознаются как разделители Обработка пробельных символов Начальные и конечные пробельные символы в ключах НЕ обрезаются Начальные и конечные пробельные символы в значениях обрезаются Обработка строк Строки без = игнорируются (считаются комментариями или пустыми строками) Пустые значения (key=) поддерживаются начиная с версии 0.9.10 Ключи с пустыми значениями сохраняются и извлекаются как обычно Ограничения на символы Ключи НЕ могут содержать: - # (знак решётки) - = (знак равенства) - \\n (символ новой строки) - Не могут начинаться с ; (точка с запятой)\nЗначения НЕ могут содержать: - # (знак решётки) - \\n (символ перевода строки) - Не могут начинаться или заканчиваться на \\r (возврат каретки) - Не могут начинаться или заканчиваться пробельными символами (удаляются автоматически)\nСортировка файлов Конфигурационные файлы не обязательно сортировать по ключам. Однако большинство приложений I2P при записи конфигурационных файлов сортируют ключи в алфавитном порядке, чтобы упростить: - Ручное редактирование - Операции diff в системах контроля версий - Читаемость для людей\nПодробности реализации Чтение конфигурационных файлов // Method signature from net.i2p.data.DataHelper public static Properties loadProps(File file) Поведение: - Читает файлы в кодировке UTF-8 - Обеспечивает соблюдение всех правил формата, описанных выше - Проверяет соблюдение ограничений на символы - Возвращает пустой объект Properties, если файл не существует - Выбрасывает IOException при ошибках чтения\nСоздание файлов конфигурации // Method signature from net.i2p.data.DataHelper public static void storeProps(Properties props, File file) Поведение: - Записывает файлы в кодировке UTF-8 - Сортирует ключи в алфавитном порядке (если не используется OrderedProperties) - Устанавливает для файла права доступа 600 (только чтение/запись для пользователя) начиная с версии 0.8.1 - Выбрасывает IllegalArgumentException при недопустимых символах в ключах или значениях - Выбрасывает IOException при ошибках записи\nПроверка формата Реализация выполняет строгую проверку:\nКлючи и значения проверяются на запрещённые символы Недопустимые записи вызывают исключения при операциях записи При чтении некорректные строки (строки без =) молча игнорируются Примеры форматов Корректный файл конфигурации # This is a comment ; This is also a comment (column 1 only) key.with.dots=value with spaces another_key=value=with=equals empty.value= numeric.value=12345 unicode.value=こんにちは Примеры некорректных настроек # INVALID: Key contains equals sign invalid=key=value # INVALID: Key contains hash invalid#key=value # INVALID: Value contains newline (implicit) key=value continues here # INVALID: Semicolon comment not in column 1 (treated as key) ; not.a.comment=value Библиотека ядра и конфигурация Router Конфигурация клиентов (clients.config) Расположение: $I2P_CONFIG_DIR/clients.config (устаревший) или $I2P_CONFIG_DIR/clients.config.d/ (современный) Интерфейс конфигурации: консоль Router на /configclients Изменение формата: Версия 0.9.42 (август 2019 г.)\nСтруктура каталогов (версия 0.9.42+) Начиная с релиза 0.9.42, файл clients.config по умолчанию автоматически разделяется на отдельные файлы конфигурации:\n$I2P_CONFIG_DIR/ ├── clients.config.d/ │ ├── 00-webConsole.config │ ├── 01-i2ptunnel.config │ ├── 02-i2psnark.config │ ├── 03-susidns.config │ └── ... └── clients.config (legacy, auto-migrated) Поведение при миграции: - При первом запуске после обновления до 0.9.42+ монолитный файл автоматически разделяется на несколько файлов - Параметры в разделённых файлах имеют префикс clientApp.0. - Устаревший формат по-прежнему поддерживается для обратной совместимости - Разделённый формат позволяет модульное пакетирование и управление плагинами\nФормат свойства Строки имеют вид clientApp.x.prop=val, где x — номер приложения.\nТребования к нумерации приложений: - ДОЛЖНА начинаться с 0 - ДОЛЖНА быть последовательной (без пропусков) - Порядок определяет последовательность запуска\nОбязательные свойства основной Тип: String (полностью квалифицированное имя класса) Обязательный: Да Описание: В этом классе будет вызван конструктор или метод main() в зависимости от типа клиента (управляемый или неуправляемый) Пример: clientApp.0.main=net.i2p.router.web.RouterConsoleRunner Необязательные параметры имя Тип: Строка Обязательный: Нет Описание: Отображаемое имя в консоли router Пример: clientApp.0.name=Router Console args Тип: Строка (разделители: пробел или символ табуляции) Обязательно: Нет Описание: Аргументы, передаваемые конструктору главного класса или методу main() Кавычки: Аргументы, содержащие пробелы или табуляцию, можно заключать в кавычки ' или \u0026quot; Пример: clientApp.0.args=-d $CONFIG/eepsite задержка Тип: Целое число (секунды) Обязательный: Нет Значение по умолчанию: 120 Описание: Количество секунд ожидания перед запуском клиента Переопределение: Переопределяется onBoot=true (устанавливает задержку в 0) Специальные значения: \u0026lt; 0: Дождаться, пока router достигнет состояния RUNNING, затем запустить немедленно в новом потоке = 0: Запустить немедленно в том же потоке (исключения передаются в консоль) \u0026gt; 0: Запустить после задержки в новом потоке (исключения логируются, не передаются) onBoot Тип: Логическое значение Обязательный: Нет Значение по умолчанию: false Описание: Принудительно устанавливает задержку 0, переопределяет явную настройку задержки Сценарий использования: Немедленный запуск критически важных служб при загрузке router startOnLoad Тип: Логический Обязательный: Нет Значение по умолчанию: true Описание: Следует ли вообще запускать клиент Сценарий использования: Отключать клиентов без удаления конфигурации Свойства, специфичные для плагина Эти свойства используются только плагинами (а не основными клиентами):\nstopargs Тип: Строка (разделённая пробелами или табуляцией) Описание: Аргументы, передаваемые для остановки клиента Подстановка переменных: Да (см. ниже) uninstallargs Тип: Строка (разделённая пробелами или табуляцией) Описание: Аргументы, передаваемые при удалении клиента Подстановка переменных: Да (см. ниже) путь к классам Тип: Строка (пути, разделённые запятыми) Описание: Дополнительные элементы classpath (путь к классам) для клиента Подстановка переменных: Да (см. ниже) Подстановка переменных (только для плагинов) Следующие переменные подставляются в args, stopargs, uninstallargs и classpath для плагинов:\nVariable Expands To Example $I2P Base I2P installation directory /usr/share/i2p $CONFIG User configuration directory ~/.i2p $PLUGIN Plugin directory ~/.i2p/plugins/foo $OS Operating system name linux $ARCH Architecture name amd64 **Примечание**: Подстановка переменных выполняется только для плагинов, а не для основных клиентов. Типы клиентов Управляемые клиенты Конструктор вызывается с параметрами RouterContext и ClientAppManager Клиент должен реализовывать интерфейс ClientApp Жизненный цикл контролируется router Может быть запущен, остановлен и перезапущен динамически Неуправляемые клиенты вызывается метод main(String[] args) запускается в отдельном потоке жизненный цикл не управляется router устаревший тип клиента Пример конфигурации # Router Console (core client) clientApp.0.main=net.i2p.router.web.RouterConsoleRunner clientApp.0.name=Router Console clientApp.0.args=-d $CONFIG/eepsite clientApp.0.delay=0 clientApp.0.onBoot=true clientApp.0.startOnLoad=true # I2PTunnel (core client) clientApp.1.main=net.i2p.i2ptunnel.TunnelControllerGroup clientApp.1.name=I2PTunnel clientApp.1.args= clientApp.1.delay=120 clientApp.1.startOnLoad=true # Plugin Example clientApp.2.main=org.example.plugin.PluginMain clientApp.2.name=Example Plugin clientApp.2.args=-config $PLUGIN/config.properties clientApp.2.stopargs=-shutdown clientApp.2.uninstallargs=-remove $PLUGIN clientApp.2.classpath=$PLUGIN/lib/plugin.jar,$PLUGIN/lib/dep.jar clientApp.2.delay=240 clientApp.2.startOnLoad=true Конфигурация логгера (logger.config) Расположение: $I2P_CONFIG_DIR/logger.config Интерфейс конфигурации: консоль Router по адресу /configlogging\nСправочник свойств Настройка буфера консоли logger.consoleBufferSize Тип: Целое число По умолчанию: 20 Описание: Максимальное количество сообщений журнала для буферизации в консоли Диапазон: 1-1000, рекомендуется Форматирование даты и времени logger.dateFormat Тип: Строка (шаблон SimpleDateFormat) Значение по умолчанию: Определяется системной локалью Пример: HH:mm:ss.SSS Документация: Java SimpleDateFormat Уровни журналирования logger.defaultLevel Тип: перечисление По умолчанию: ERROR Значения: CRIT, ERROR, WARN, INFO, DEBUG Описание: Уровень логирования по умолчанию для всех классов logger.minimumOnScreenLevel Тип: Перечисление (Enum) По умолчанию: CRIT Значения: CRIT, ERROR, WARN, INFO, DEBUG Описание: Минимальный уровень для сообщений, отображаемых на экране logger.record.{class} Тип: перечисление (Enum) Значения: CRIT, ERROR, WARN, INFO, DEBUG Описание: Переопределение уровня логирования для конкретного класса Пример: logger.record.net.i2p.router.transport.udp=DEBUG Параметры отображения logger.displayOnScreen Тип: логический По умолчанию: true Описание: Показывать ли сообщения журнала в консольном выводе logger.dropDuplicates Тип: булево По умолчанию: true Описание: Отбрасывать повторяющиеся подряд сообщения журнала logger.dropOnOverflow Тип: логический тип (Boolean) По умолчанию: false Описание: Отбрасывать сообщения, когда буфер заполнен (вместо блокировки) Поведение при сбросе буфера logger.flushInterval Тип: целое число (секунды) По умолчанию: 29 С версии: 0.9.18 Описание: Как часто сбрасывать буфер журнала на диск Настройка формата logger.format Тип: String (последовательность символов) Описание: Шаблон формата сообщения журнала Символы формата: d = дата/время c = имя класса t = имя потока p = приоритет (уровень логирования) m = сообщение Пример: dctpm выдаёт [timestamp] [class] [thread] [level] message Сжатие (версия 0.9.56+) logger.gzip Тип: булево По умолчанию: false С версии: 0.9.56 Описание: Включает сжатие gzip для файлов журналов после ротации logger.minGzipSize Тип: Целое число (байты) По умолчанию: 65536 Начиная с: версии 0.9.56 Описание: Минимальный размер файла для включения сжатия (по умолчанию 64 КБ) Управление файлами logger.logBufferSize Тип: Целое число (байты) По умолчанию: 1024 Описание: Максимальное число сообщений, накапливаемых в буфере перед сбросом logger.logFileName Тип: Строка (путь к файлу) Значение по умолчанию: logs/log-@.txt Описание: Шаблон именования файла журнала (@ заменяется номером ротации) logger.logFilenameOverride Тип: Строка (путь к файлу) Описание: Переопределение имени файла журнала (отключает шаблон ротации) logger.logFileSize Тип: Строка (размер с единицей измерения) По умолчанию: 10M Единицы: K (килобайты), M (мегабайты), G (гигабайты) Пример: 50M, 1G logger.logRotationLimit Тип: целое число По умолчанию: 2 Описание: Максимальный номер файла ротации (от log-0.txt до log-N.txt) Пример конфигурации # Basic logging configuration logger.consoleBufferSize=50 logger.dateFormat=yyyy-MM-dd HH:mm:ss.SSS logger.defaultLevel=WARN logger.displayOnScreen=true logger.dropDuplicates=true logger.dropOnOverflow=false # Flushing and format logger.flushInterval=30 logger.format=dctpm # File management logger.logBufferSize=2048 logger.logFileName=logs/log-@.txt logger.logFileSize=25M logger.logRotationLimit=5 # Compression (0.9.56+) logger.gzip=true logger.minGzipSize=131072 # On-screen filtering logger.minimumOnScreenLevel=ERROR # Per-class overrides logger.record.net.i2p.router.transport=INFO logger.record.net.i2p.router.tunnel=DEBUG logger.record.net.i2p.crypto=WARN Настройка плагина Конфигурация отдельного плагина (plugins/*/plugin.config) Расположение: $I2P_CONFIG_DIR/plugins/{plugin-name}/plugin.config Формат: Стандартный формат файла конфигурации I2P Документация: Спецификация плагина Обязательные свойства имя Тип: строка Обязательно: Да Описание: Отображаемое имя плагина Пример: name=I2P Plugin Example ключ Тип: Строка (открытый ключ) Обязателен: Да (опустите для плагинов, подписанных SU3) Описание: Открытый ключ для проверки подписи плагина Формат: Ключ подписи, закодированный в Base64 подписант Тип: Строка Обязательно: Да Описание: Идентификатор подписанта плагина Пример: signer=user@example.i2p версия Тип: Строка (формат VersionComparator) Обязательный: Да Описание: Версия плагина для проверки обновлений Формат: Семантическое версионирование или пользовательский сравнимый формат Пример: version=1.2.3 Свойства отображения дата Тип: Long (метка времени Unix в миллисекундах) Описание: Дата выпуска плагина автор Тип: строка Описание: Имя автора плагина websiteURL Тип: Строка (URL) Описание: URL веб-сайта плагина updateURL Тип: Строка (URL) Описание: URL для проверки обновлений плагина updateURL.su3 Тип: Строка (URL) Начиная с: Версия 0.9.15 Описание: URL обновления в формате SU3 (предпочтительно) описание Тип: String Описание: Описание плагина на английском языке description_{language} Тип: Строка Описание: Локализованное описание плагина Пример: description_de=Немецкое описание лицензия Тип: строка Описание: Идентификатор лицензии плагина Пример: license=Apache 2.0 Параметры установки не запускать после установки Тип: логический По умолчанию: false Описание: Предотвращает автоматический запуск после установки Требуется перезапуск router Тип: Булево По умолчанию: false Описание: Требует перезапуска router после установки только установка Тип: булево По умолчанию: false Описание: Однократная установка (без обновлений) только для обновления Тип: логический По умолчанию: false Описание: Обновлять только существующую установку (без чистой установки) Пример настройки плагина # Required properties name=Example I2P Plugin signer=developer@mail.i2p version=1.5.0 # Display properties author=Plugin Developer websiteURL=http://plugin.example.i2p updateURL=http://plugin.example.i2p/update.xpi2p updateURL.su3=http://plugin.example.i2p/update.su3 description=Example plugin demonstrating configuration description_de=Beispiel-Plugin zur Demonstration der Konfiguration license=MIT # Installation behavior dont-start-at-install=false router-restart-required=false Глобальная конфигурация плагинов (plugins.config) Расположение: $I2P_CONFIG_DIR/plugins.config Назначение: Глобальное включение/отключение установленных плагинов\nФормат свойства plugin.{name}.startOnLoad=true|false {name}: Имя плагина из plugin.config startOnLoad: Запускать ли плагин при запуске router Пример plugin.i2psnark.startOnLoad=true plugin.susimail.startOnLoad=true plugin.susidns.startOnLoad=true plugin.i2pbote.startOnLoad=false Конфигурация веб-приложений (webapps.config) Расположение: $I2P_CONFIG_DIR/webapps.config Назначение: Включение/отключение и настройка веб-приложений\nФормат свойства webapps.{name}.startOnLoad Тип: Логический Описание: Запускать ли веб-приложение при запуске router Формат: webapps.{name}.startOnLoad=true|false webapps.{name}.classpath Тип: Строка (пути, разделённые пробелом или запятой) Описание: Дополнительные элементы classpath (путь к классам) для веб-приложения Формат: webapps.{name}.classpath=[paths] Подстановка переменных Пути поддерживают следующие подстановки переменных:\nVariable Expands To Context $I2P Base I2P directory Core webapps $CONFIG User config directory All webapps $PLUGIN Plugin directory Plugin webapps #### Разрешение пути классов Основные веб-приложения: Пути относительно $I2P/lib Веб-приложения плагинов: Пути относительно $CONFIG/plugins/{appname}/lib Пример конфигурации # Router console webapps.routerconsole.startOnLoad=true webapps.routerconsole.classpath=routerconsole.jar # I2PSnark webapps.i2psnark.startOnLoad=true webapps.i2psnark.classpath=i2psnark.jar # SusiDNS webapps.susidns.startOnLoad=true webapps.susidns.classpath=susidns.jar # Plugin webapp example webapps.exampleplugin.startOnLoad=false webapps.exampleplugin.classpath=$PLUGIN/lib/webapp.jar,$PLUGIN/lib/deps.jar Конфигурация Router (router.config) Расположение: $I2P_CONFIG_DIR/router.config Интерфейс конфигурации: Консоль Router на /configadvanced Назначение: Основные настройки router и сетевые параметры\nКатегории конфигурации Настройка сети Настройки пропускной способности:\ni2np.bandwidth.inboundKBytesPerSecond=100 i2np.bandwidth.outboundKBytesPerSecond=50 i2np.bandwidth.share.percentage=80 Конфигурация транспорта:\n# NTCP (TCP-based transport) i2np.ntcp.port=8887 i2np.ntcp.enable=true i2np.ntcp.autoip=true # SSU (UDP-based transport) i2np.udp.port=8887 i2np.udp.enable=true # UPnP/NAT-PMP i2np.upnp.enable=true Поведение Router # Tunnel participation router.maxParticipatingTunnels=200 router.sharePercentage=80 # Updates router.updatePolicy=notify router.updateURL=http://update.i2p2.i2p/ # Network integration router.hiddenMode=false router.clockSkewOffset=0 Настройка консоли # Language and display routerconsole.lang=en routerconsole.country=US routerconsole.summaryRefresh=60 # Browser routerconsole.browser=default # Security routerconsole.enableCompression=true Настройка времени # NTP time.disabled=false time.sntpServerList=0.pool.ntp.org,1.pool.ntp.org Примечание: Конфигурация router обширна. См. консоль router на странице /configadvanced для полного справочника по свойствам.\nФайлы конфигурации приложений Настройка адресной книги (addressbook/config.txt) Расположение: $I2P_CONFIG_DIR/addressbook/config.txt Приложение: SusiDNS Назначение: Разрешение имён хостов и управление адресной книгой\nРасположение файлов router_addressbook По умолчанию: ../hosts.txt Описание: Основная адресная книга (общесистемные имена хостов) Формат: Стандартный формат файла hosts privatehosts.txt Расположение: $I2P_CONFIG_DIR/addressbook/privatehosts.txt Описание: Частные сопоставления имён хостов Приоритет: Наивысший (переопределяет все остальные источники) userhosts.txt Расположение: $I2P_CONFIG_DIR/addressbook/userhosts.txt Описание: Добавленные пользователем сопоставления имён хостов Управление: через интерфейс SusiDNS hosts.txt Расположение: $I2P_CONFIG_DIR/addressbook/hosts.txt Описание: Загруженная общедоступная адресная книга Источник: Ленты подписок Служба имен BlockfileNamingService (служба имён на основе блок-файла; по умолчанию с 0.8.8) Формат хранения: - Файл: hostsdb.blockfile - Расположение: $I2P_CONFIG_DIR/addressbook/ - Производительность: ~в 10 раз более быстрое разрешение имен, чем в hosts.txt - Формат: двоичный формат базы данных\nУстаревшая служба имён: - Формат: Текстовый файл hosts.txt - Статус: Устаревший, но всё ещё поддерживается - Сценарий использования: Ручное редактирование, контроль версий\nПравила имён хостов Имена хостов I2P должны соответствовать:\nТребование к домену верхнего уровня (TLD): Должно оканчиваться на .i2p Максимальная длина: всего 67 символов Набор символов: [a-z], [0-9], . (точка), - (дефис) Регистр: только строчные буквы Ограничения на начало: не может начинаться с . или - Запрещённые последовательности: не может содержать .., .- или -. (начиная с 0.6.1.33) Зарезервировано: Base32-имена хостов *.b32.i2p (52 символа base32.b32.i2p) Корректные примеры example.i2p my-site.i2p test.example.i2p site123.i2p Некорректные примеры example.com # Wrong TLD -invalid.i2p # Starts with hyphen invalid..i2p # Contains double dot invalid.-.i2p # Contains dot-hyphen UPPERCASE.I2P # Must be lowercase verylonghostnameover67charactersthatexceedsthemaximumlength.i2p # Too long Управление подписками subscriptions.txt Расположение: $I2P_CONFIG_DIR/addressbook/subscriptions.txt Формат: По одному URL на строку По умолчанию: http://i2p-projekt.i2p/hosts.txt Формат ленты подписки (с версии 0.9.26) Расширенный формат ленты с метаданными:\n# # I2P Address Book Subscription Feed # Format: hostname=destination [#property=value ...] # example.i2p=base64destination #added=20250101 #src=manual another.i2p=base64destination #added=20250102 #src=feed1 Свойства метаданных: - added: Дата добавления имени хоста (формат YYYYMMDD) - src: Идентификатор источника - sig: Необязательная подпись\nОбратная совместимость: Простой формат hostname=destination по-прежнему поддерживается.\nПример конфигурации # Address book locations router_addressbook=../hosts.txt privatehosts.txt=$CONFIG/addressbook/privatehosts.txt userhosts.txt=$CONFIG/addressbook/userhosts.txt hosts.txt=$CONFIG/addressbook/hosts.txt # Naming service naming.service=BlockfileNamingService naming.service.blockfile.location=$CONFIG/addressbook/hostsdb.blockfile # Subscriptions subscriptions.txt=$CONFIG/addressbook/subscriptions.txt subscriptions.schedule=daily subscriptions.proxy=false Конфигурация I2PSnark (i2psnark.config.d/i2psnark.config) Расположение: $I2P_CONFIG_DIR/i2psnark.config.d/i2psnark.config Приложение: BitTorrent‑клиент I2PSnark Интерфейс конфигурации: Веб‑интерфейс по адресу http://127.0.0.1:7657/i2psnark\nСтруктура каталогов $I2P_CONFIG_DIR/i2psnark.config.d/ ├── i2psnark.config ├── [torrent-hash-1]/ │ └── *.config ├── [torrent-hash-2]/ │ └── *.config └── ... Основная конфигурация (i2psnark.config) Минимальная конфигурация по умолчанию:\ni2psnark.dir=i2psnark Дополнительные параметры, управляемые через веб-интерфейс:\n# Basic settings i2psnark.dir=i2psnark i2psnark.autoStart=false i2psnark.openTrackers=true # Network settings i2psnark.uploaders=8 i2psnark.upBW=40 i2psnark.seedPct=100 # I2CP settings i2psnark.i2cpHost=127.0.0.1 i2psnark.i2cpPort=7654 Индивидуальная настройка торрента Расположение: $I2P_CONFIG_DIR/i2psnark.config.d/[torrent-hash]/*.config Формат: Настройки для каждого торрента Управление: Автоматическое (через веб-интерфейс)\nСвойства включают: - Параметры отдачи/скачивания, специфичные для торрента - Приоритеты файлов - Информация о трекере - Лимиты пиров\nПримечание: Настройка торрентов в основном осуществляется через веб-интерфейс. Ручное редактирование не рекомендуется.\nОрганизация данных торрента Хранение данных отделено от конфигурации:\n$I2P_CONFIG_DIR/i2psnark/ # Data directory ├── *.torrent # Torrent metadata files ├── *.torrent.downloaded/ # Downloaded file directories ├── file1.dat # Direct file downloads └── ... $I2P_CONFIG_DIR/i2psnark.config.d/ # Configuration directory ├── i2psnark.config # Main config └── [hashes]/ # Per-torrent configs Конфигурация I2PTunnel (i2ptunnel.config) Расположение: $I2P_CONFIG_DIR/i2ptunnel.config (устаревший) или $I2P_CONFIG_DIR/i2ptunnel.config.d/ (современный) Интерфейс конфигурации: консоль Router по адресу /i2ptunnel Изменение формата: версия 0.9.42 (август 2019)\nСтруктура каталогов (версия 0.9.42+) Начиная с релиза 0.9.42, файл i2ptunnel.config по умолчанию автоматически разделяется:\n$I2P_CONFIG_DIR/ ├── i2ptunnel.config.d/ │ ├── http-proxy/ │ │ └── tunnel.config │ ├── irc-proxy/ │ │ └── tunnel.config │ ├── ssh-service/ │ │ └── tunnel.config │ └── ... └── i2ptunnel.config (legacy, auto-migrated) Критическое различие форматов: - Монолитный формат: Свойства с префиксом tunnel.N. - Раздельный формат: Свойства БЕЗ префикса (например, description=, а не tunnel.0.description=)\nПоведение при миграции При первом запуске после обновления до 0.9.42: 1. Существующий i2ptunnel.config читается 2. Отдельные конфигурации tunnel создаются в i2ptunnel.config.d/ 3. В разделённых файлах у свойств удаляются префиксы 4. Создаётся резервная копия исходного файла 5. Устаревший формат по-прежнему поддерживается для обратной совместимости\nРазделы конфигурации Конфигурация I2PTunnel подробно описана в разделе Справочник по конфигурации I2PTunnel ниже. Описания свойств применимы для обоих форматов: монолитного (tunnel.N.property) и раздельного (property).\nСправочник по конфигурации I2PTunnel В этом разделе приведена исчерпывающая техническая справочная информация по свойствам конфигурации I2PTunnel. Свойства показаны в раздельном формате (без префикса tunnel.N.). Для монолитного формата добавьте ко всем свойствам префикс tunnel.N., где N — номер tunnel.\nВажно: Свойства, описанные как tunnel.N.option.i2cp.*, реализованы в I2PTunnel (приложение для прокидывания TCP через I2P) и НЕ поддерживаются через другие интерфейсы, такие как протокол I2CP (I2P Client Protocol — клиентский протокол I2P) или SAM API.\nОсновные свойства tunnel.N.description (описание) Тип: Строка Контекст: Все tunnels Описание: Человекочитаемое описание tunnel для отображения в пользовательском интерфейсе Пример: description=HTTP Proxy for outproxy access tunnel.N.name (имя) Тип: Строка Контекст: Все tunnels Обязателен: Да Описание: Уникальный идентификатор tunnel и отображаемое имя Пример: name=I2P HTTP Proxy tunnel.N.type (тип) Тип: Перечисление Контекст: Все tunnels Обязательно: Да Значения: client - Универсальный клиентский tunnel httpclient - Клиент HTTP-прокси ircclient - Клиентский IRC tunnel socksirctunnel - SOCKS IRC-прокси sockstunnel - SOCKS-прокси (версии 4, 4a, 5) connectclient - Клиент CONNECT-прокси streamrclient - Клиент Streamr server - Универсальный серверный tunnel httpserver - HTTP-серверный tunnel ircserver - IRC-серверный tunnel httpbidirserver - Двунаправленный HTTP-сервер streamrserver - Сервер Streamr tunnel.N.interface (интерфейс) Тип: Строка (IP-адрес или имя хоста) Контекст: Только для Client tunnels По умолчанию: 127.0.0.1 Описание: Локальный интерфейс, к которому привязывать входящие подключения Примечание по безопасности: Привязка к 0.0.0.0 разрешает удалённые подключения Пример: interface=127.0.0.1 tunnel.N.listenPort (listenPort) Тип: целое число Контекст: только для клиентских tunnels Диапазон: 1-65535 Описание: Локальный порт для прослушивания клиентских подключений Пример: listenPort=4444 tunnel.N.targetHost (targetHost) Тип: Строка (IP-адрес или имя хоста) Контекст: только для Server tunnels Описание: Локальный сервер, на который перенаправлять соединения Пример: targetHost=127.0.0.1 tunnel.N.targetPort (targetPort) Тип: Целое число Контекст: Только для серверных tunnels Диапазон: 1-65535 Описание: Порт на targetHost для подключения Пример: targetPort=80 tunnel.N.targetDestination (targetDestination) Тип: Строка (назначения, разделённые запятыми или пробелами) Контекст: только для Client tunnels Формат: destination[:port][,destination[:port]] Описание: I2P-адрес(а) назначения для подключения Примеры: targetDestination=example.i2p targetDestination=example.i2p:8080 targetDestination=site1.i2p,site2.i2p:8080 tunnel.N.i2cpHost (i2cpHost) Тип: Строка (IP-адрес или имя хоста) По умолчанию: 127.0.0.1 Описание: Адрес интерфейса I2CP I2P router Примечание: Игнорируется при запуске в контексте router Пример: i2cpHost=127.0.0.1 tunnel.N.i2cpPort (i2cpPort) Тип: Целое число По умолчанию: 7654 Диапазон: 1-65535 Описание: Порт I2CP для I2P router Примечание: Игнорируется при запуске в контексте router Пример: i2cpPort=7654 tunnel.N.startOnLoad (startOnLoad) Тип: Логический Значение по умолчанию: true Описание: Следует ли запускать tunnel при загрузке I2PTunnel Пример: startOnLoad=true Настройка прокси tunnel.N.proxyList (proxyList) Тип: Строка (имена хостов, разделённые запятыми или пробелами) Контекст: Только для HTTP- и SOCKS-прокси Описание: Список хостов outproxy (внешний прокси в I2P) Пример: proxyList=outproxy.example.i2p,backup.example.i2p Конфигурация сервера tunnel.N.privKeyFile (privKeyFile) Тип: Строка (путь к файлу) Контекст: Серверы и постоянные клиентские tunnels Описание: Файл, содержащий закрытые ключи постоянного destination (адреса назначения) Путь: Абсолютный или относительный к каталогу конфигурации I2P Пример: privKeyFile=eepsite/eepPriv.dat tunnel.N.spoofedHost (spoofedHost) Тип: Строка (имя хоста) Контекст: только для HTTP-серверов По умолчанию: имя хоста назначения в формате Base32 Описание: Значение заголовка Host, передаваемое локальному серверу Пример: spoofedHost=example.i2p tunnel.N.spoofedHost.NNNN (spoofedHost.NNNN) Тип: Строка (имя хоста) Контекст: Только для HTTP-серверов Описание: Переопределение виртуального хоста для конкретного входящего порта Сценарий использования: Размещение нескольких сайтов на разных портах Пример: spoofedHost.8080=site1.example.i2p Параметры для конкретного клиента tunnel.N.sharedClient (sharedClient) Тип: Логическое значение Контекст: Только для клиентских tunnels По умолчанию: false Описание: Могут ли несколько клиентов совместно использовать этот tunnel Пример: sharedClient=false tunnel.N.option.persistentClientKey (persistentClientKey) Тип: логический Контекст: Только для Client tunnels Значение по умолчанию: false Описание: Сохранять и повторно использовать ключи назначения между перезапусками Конфликт: Взаимоисключимо с i2cp.newDestOnResume=true Пример: option.persistentClientKey=true Параметры I2CP (реализация I2PTunnel) Важно: Эти свойства имеют префикс option.i2cp., но реализованы в I2PTunnel, а не на уровне протокола I2CP. Они недоступны через API I2CP или SAM.\ntunnel.N.option.i2cp.delayOpen (option.i2cp.delayOpen) Тип: Boolean Контекст: Только клиентские tunnel Значение по умолчанию: false Описание: Отложить создание tunnel до первого подключения Сценарий использования: Экономия ресурсов для редко используемых tunnel Пример: option.i2cp.delayOpen=false tunnel.N.option.i2cp.newDestOnResume (option.i2cp.newDestOnResume) Тип: Булево Контекст: Только для клиентских tunnels По умолчанию: false Требуется: i2cp.closeOnIdle=true Конфликт: Взаимоисключимо с persistentClientKey=true Описание: Создавать новый destination (криптографический адрес назначения) после истечения тайм-аута простоя Пример: option.i2cp.newDestOnResume=false tunnel.N.option.i2cp.leaseSetPrivateKey (option.i2cp.leaseSetPrivateKey) Тип: Строка (ключ, закодированный в base64) Контекст: Только для server tunnels Описание: Постоянный закрытый ключ шифрования leaseSet Сценарий использования: Обеспечить сохранение одного и того же зашифрованного leaseSet при перезапусках Пример: option.i2cp.leaseSetPrivateKey=AAAA...base64... tunnel.N.option.i2cp.leaseSetSigningPrivateKey (option.i2cp.leaseSetSigningPrivateKey) Тип: Строка (sigtype:base64) Контекст: Только для серверных tunnel\u0026rsquo;ов Формат: sigtype:base64key Описание: Постоянный закрытый ключ подписи leaseSet (набор аренд входящих tunnel\u0026rsquo;ов) Пример: option.i2cp.leaseSetSigningPrivateKey=7:AAAA...base64... Параметры, специфичные для сервера tunnel.N.option.enableUniqueLocal (option.enableUniqueLocal) Тип: Логический (Boolean) Контекст: Только для серверных tunnel\u0026rsquo;ов По умолчанию: false Описание: Использовать уникальный локальный IP для каждого удалённого I2P-назначения (destination) Сценарий использования: Отслеживать IP клиентов в журналах сервера Примечание по безопасности: Может снизить анонимность Пример: option.enableUniqueLocal=false tunnel.N.option.targetForPort.NNNN (option.targetForPort.NNNN) Тип: Строка (hostname:port) Контекст: Только для server tunnels Описание: Переопределяет targetHost/targetPort для входящего порта NNNN Сценарий использования: Маршрутизация по портам к разным локальным сервисам Пример: option.targetForPort.8080=localhost:8080 Конфигурация пула потоков tunnel.N.option.i2ptunnel.usePool (option.i2ptunnel.usePool) Тип: Булево Контекст: только для server tunnels По умолчанию: true Описание: использовать пул потоков для обработки подключений Примечание: всегда false для стандартных серверов (игнорируется) Пример: option.i2ptunnel.usePool=true tunnel.N.option.i2ptunnel.blockingHandlerCount (option.i2ptunnel.blockingHandlerCount) Тип: Целое число Контекст: Только для серверных tunnels По умолчанию: 65 Описание: Максимальный размер пула потоков Примечание: Не применяется для стандартных серверов Пример: option.i2ptunnel.blockingHandlerCount=100 Параметры HTTP-клиента tunnel.N.option.i2ptunnel.httpclient.allowInternalSSL (option.i2ptunnel.httpclient.allowInternalSSL) Тип: булево Контекст: только для HTTP-клиентов По умолчанию: false Описание: Разрешить SSL-подключения к адресам .i2p Пример: option.i2ptunnel.httpclient.allowInternalSSL=false tunnel.N.option.i2ptunnel.httpclient.disableAddressHelper (option.i2ptunnel.httpclient.disableAddressHelper) Тип: Булево Контекст: только для HTTP-клиентов По умолчанию: false Описание: Отключить ссылки address helper (ссылки‑помощники адреса) в ответах прокси Пример: option.i2ptunnel.httpclient.disableAddressHelper=false tunnel.N.option.i2ptunnel.httpclient.jumpServers (option.i2ptunnel.httpclient.jumpServers) Тип: Строка (URL-адреса, разделённые запятыми или пробелами) Контекст: Только для HTTP-клиентов Описание: URL-адреса Jump server (служба Jump) для разрешения имён хостов Пример: option.i2ptunnel.httpclient.jumpServers=http://jump.i2p/jump,http://stats.i2p/jump tunnel.N.option.i2ptunnel.httpclient.sendAccept (option.i2ptunnel.httpclient.sendAccept) Тип: Логический (Boolean) Контекст: только для HTTP-клиентов Значение по умолчанию: false Описание: Передавать заголовки Accept-* (кроме Accept и Accept-Encoding) Пример: option.i2ptunnel.httpclient.sendAccept=false tunnel.N.option.i2ptunnel.httpclient.sendReferer (option.i2ptunnel.httpclient.sendReferer) Тип: Логический Контекст: только для HTTP-клиентов По умолчанию: false Описание: Передавать заголовки Referer через прокси Примечание о конфиденциальности: Может привести к утечке информации Пример: option.i2ptunnel.httpclient.sendReferer=false tunnel.N.option.i2ptunnel.httpclient.sendUserAgent (option.i2ptunnel.httpclient.sendUserAgent) Тип: логический Контекст: только для HTTP‑клиентов По умолчанию: false Описание: Передавать заголовки User-Agent через прокси Примечание по конфиденциальности: Может раскрывать информацию о браузере Пример: option.i2ptunnel.httpclient.sendUserAgent=false tunnel.N.option.i2ptunnel.httpclient.sendVia (option.i2ptunnel.httpclient.sendVia) Тип: Логический Контекст: только для HTTP‑клиентов Значение по умолчанию: false Описание: Передавать заголовки Via через прокси Пример: option.i2ptunnel.httpclient.sendVia=false tunnel.N.option.i2ptunnel.httpclient.SSLOutproxies (option.i2ptunnel.httpclient.SSLOutproxies) Type: String (назначения, разделённые запятыми или пробелами) Context: только HTTP-клиенты Description: Внутрисетевые SSL outproxies (прокси-шлюзы из I2P в Интернет) для HTTPS Example: option.i2ptunnel.httpclient.SSLOutproxies=ssl-outproxy.i2p tunnel.N.option.i2ptunnel.useLocalOutproxy (option.i2ptunnel.useLocalOutproxy) Тип: логический Контекст: только для HTTP‑клиентов Значение по умолчанию: true Описание: Использовать зарегистрированные локальные плагины outproxy (выходного прокси) Пример: option.i2ptunnel.useLocalOutproxy=true Аутентификация клиента HTTP tunnel.N.option.proxyAuth (option.proxyAuth) Тип: Enum (перечисление) Контекст: только для HTTP‑клиентов По умолчанию: false Значения: true, false, basic, digest Описание: Требовать локальную аутентификацию для доступа к прокси Примечание: true эквивалентно basic Пример: option.proxyAuth=basic tunnel.N.option.proxy.auth.USER.md5 (option.proxy.auth.USER.md5) Тип: Строка (32-символьная шестнадцатеричная строка в нижнем регистре) Контекст: только клиенты HTTP Требуется: proxyAuth=basic или proxyAuth=digest Описание: MD5-хеш пароля для пользователя USER Устарело: вместо этого используйте SHA-256 (0.9.56+) Пример: option.proxy.auth.alice.md5=5f4dcc3b5aa765d61d8327deb882cf99 tunnel.N.option.proxy.auth.USER.sha256 (option.proxy.auth.USER.sha256) Тип: Строка (64-символьное шестнадцатеричное значение в нижнем регистре) Контекст: только для HTTP-клиентов Требуется: proxyAuth=digest С версии: 0.9.56 Стандарт: RFC 7616 Описание: хеш SHA-256 пароля для пользователя USER Пример: option.proxy.auth.alice.sha256=5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8 Аутентификация Outproxy (внешнего прокси) tunnel.N.option.outproxyAuth (option.outproxyAuth) Тип: логический Контекст: только для HTTP‑клиентов Значение по умолчанию: false Описание: Отправлять данные аутентификации на outproxy (прокси-сервер выхода в обычный интернет) Пример: option.outproxyAuth=false tunnel.N.option.outproxyUsername (option.outproxyUsername) Тип: Строка Контекст: только для HTTP‑клиентов Требует: outproxyAuth=true Описание: Имя пользователя для аутентификации на outproxy (внешний прокси I2P) Пример: option.outproxyUsername=user tunnel.N.option.outproxyPassword (option.outproxyPassword) Тип: Строка Контекст: Только для HTTP-клиентов Требует: outproxyAuth=true Описание: Пароль для аутентификации на outproxy Безопасность: Хранится в незашифрованном виде Пример: option.outproxyPassword=secret Параметры клиента SOCKS tunnel.N.option.i2ptunnel.socks.proxy.default (option.i2ptunnel.socks.proxy.default) Тип: Строка (адреса назначения, разделённые запятыми или пробелами) Контекст: Только для клиентов SOCKS Описание: Внутрисетевые outproxies (прокси для выхода из сети I2P в Интернет) для неуказанных портов Пример: option.i2ptunnel.socks.proxy.default=outproxy.i2p tunnel.N.option.i2ptunnel.socks.proxy.NNNN (option.i2ptunnel.socks.proxy.NNNN) Тип: Строка (destinations (адреса назначения в I2P), разделённые запятыми или пробелами) Контекст: только для клиентов SOCKS Описание: outproxies (аутпрокси) внутри сети I2P специально для порта NNNN Пример: option.i2ptunnel.socks.proxy.443=ssl-outproxy.i2p tunnel.N.option.outproxyType (option.outproxyType) Тип: Перечисление Контекст: Только клиенты SOCKS По умолчанию: socks Начиная с: версии 0.9.57 Значения: socks, connect (HTTPS) Описание: Тип настроенного outproxy (прокси-выход в обычный интернет) Пример: option.outproxyType=connect Параметры HTTP-сервера tunnel.N.option.maxPosts (option.maxPosts) Тип: Целое число Контекст: Только для HTTP-серверов По умолчанию: 0 (без ограничений) Описание: Максимальное число POST-запросов от одного назначения за postCheckTime Пример: option.maxPosts=10 tunnel.N.option.maxTotalPosts (option.maxTotalPosts) Тип: Целое число Контекст: Только для HTTP-серверов По умолчанию: 0 (неограниченно) Описание: Максимальное число POST-запросов со всех источников за период postCheckTime Пример: option.maxTotalPosts=50 tunnel.N.option.postCheckTime (option.postCheckTime) Тип: Целое число (секунды) Контекст: только для HTTP-серверов По умолчанию: 300 Описание: Временное окно для проверки лимитов POST Пример: option.postCheckTime=600 tunnel.N.option.postBanTime (option.postBanTime) Тип: Целое число (секунды) Контекст: только для HTTP-серверов По умолчанию: 1800 Описание: Срок блокировки после превышения maxPosts для одного назначения Пример: option.postBanTime=3600 tunnel.N.option.postTotalBanTime (option.postTotalBanTime) Тип: Целое число (секунды) Контекст: Только для HTTP-серверов По умолчанию: 600 Описание: Длительность блокировки после превышения maxTotalPosts Пример: option.postTotalBanTime=1200 Параметры безопасности HTTP-сервера tunnel.N.option.rejectInproxy (option.rejectInproxy) Тип: Логический Контекст: только HTTP-серверы По умолчанию: false Описание: Отклонять подключения, предположительно идущие через inproxy (входящий прокси для доступа к I2P из обычного интернета) Пример: option.rejectInproxy=false tunnel.N.option.rejectReferer (option.rejectReferer) Тип: булево значение Контекст: только для HTTP-серверов По умолчанию: false С версии: 0.9.25 Описание: Отклонять соединения с заголовком Referer Пример: option.rejectReferer=false tunnel.N.option.rejectUserAgents (option.rejectUserAgents) Тип: Логическое значение Контекст: Только для HTTP-серверов Значение по умолчанию: false С версии: 0.9.25 Требуется: свойство userAgentRejectList Описание: Отклоняет соединения с совпадающим значением User-Agent Пример: option.rejectUserAgents=false tunnel.N.option.userAgentRejectList (option.userAgentRejectList) Тип: Строка (список шаблонов сопоставления, разделённых запятыми) Контекст: только HTTP-серверы Начиная с: версии 0.9.25 Регистр: регистрозависимое сопоставление Особое: \u0026ldquo;none\u0026rdquo; (начиная с 0.9.33) соответствует пустому User-Agent Описание: Список шаблонов User-Agent для отклонения Пример: option.userAgentRejectList=Mozilla,Opera,none Параметры сервера IRC tunnel.N.option.ircserver.fakeHostname (option.ircserver.fakeHostname) Тип: Строка (шаблон имени хоста) Контекст: Только для серверов IRC По умолчанию: %f.b32.i2p Токены: %f = Полный base32-хеш назначения %c = Замаскированный хеш назначения (см. cloakKey) Описание: Формат имени хоста, отправляемый на сервер IRC Пример: option.ircserver.fakeHostname=%c.irc.i2p tunnel.N.option.ircserver.cloakKey (option.ircserver.cloakKey) Тип: Строка (парольная фраза) Контекст: Только для серверов IRC По умолчанию: Случайное для каждой сессии Ограничения: Без кавычек и пробелов Описание: Парольная фраза для единообразного маскирования имени хоста Сценарий использования: Постоянное отслеживание пользователя при перезапусках/на разных серверах Пример: option.ircserver.cloakKey=mysecretkey tunnel.N.option.ircserver.method (option.ircserver.method) Тип: перечисление Контекст: только для серверов IRC По умолчанию: user Значения: user, webirc Описание: метод аутентификации для сервера IRC Пример: option.ircserver.method=webirc tunnel.N.option.ircserver.webircPassword (option.ircserver.webircPassword) Тип: Строка (пароль) Контекст: только IRC-серверы Требует: method=webirc Ограничения: без кавычек и пробелов Описание: Пароль для аутентификации по протоколу WEBIRC Пример: option.ircserver.webircPassword=webircpass tunnel.N.option.ircserver.webircSpoofIP (option.ircserver.webircSpoofIP) Тип: строка (IP-адрес) Контекст: только для IRC‑серверов Требует: method=webirc Описание: Подменённый IP‑адрес для протокола WEBIRC Пример: option.ircserver.webircSpoofIP=10.0.0.1 Настройка SSL/TLS tunnel.N.option.useSSL (option.useSSL) Тип: логический По умолчанию: false Контекст: Все tunnels Поведение: Серверы: Использовать SSL для соединений с локальным сервером Клиенты: Требовать SSL от локальных клиентов Пример: option.useSSL=false tunnel.N.option.keystoreFile (option.keystoreFile) Тип: Строка (путь к файлу) Контекст: Только Client tunnels По умолчанию: i2ptunnel-(random).ks Путь: Относительный к $(I2P_CONFIG_DIR)/keystore/, если путь не абсолютный Автоматическое создание: Создается, если не существует Описание: Файл хранилища ключей (keystore), содержащий закрытый ключ SSL Пример: option.keystoreFile=my-tunnel.ks tunnel.N.option.keystorePassword (option.keystorePassword) Тип: Строка (пароль) Контекст: Только клиентские tunnels По умолчанию: changeit Автоматически генерируется: Случайный пароль, если создано новое хранилище ключей Описание: Пароль для SSL хранилища ключей Пример: option.keystorePassword=secretpassword tunnel.N.option.keyAlias (option.keyAlias) Тип: Строка (псевдоним) Контекст: только для клиентских tunnels Автоматически создаётся: если сгенерирован новый ключ Описание: Псевдоним для закрытого ключа в хранилище ключей Пример: option.keyAlias=mytunnel-key tunnel.N.option.keyPassword (option.keyPassword) Тип: Строка (пароль) Контекст: Только для client tunnels Автоматически генерируется: Случайный пароль при создании нового ключа Описание: Пароль для закрытого ключа в хранилище ключей Пример: option.keyPassword=keypass123 Общие параметры I2CP и Streaming (библиотека потоковой передачи данных) Все свойства tunnel.N.option.* (не описанные явно выше) передаются в интерфейс I2CP и библиотеку потоковой передачи без префикса tunnel.N.option..\nВажно: Это отдельные параметры, отличные от параметров, специфичных для I2PTunnel. Смотрите: - Спецификация I2CP - Спецификация потоковой библиотеки Примеры параметров стриминга:\noption.i2cp.messageReliability=BestEffort option.i2p.streaming.connectDelay=1000 option.i2p.streaming.maxWindowSize=128 Полный пример Tunnel # HTTP Proxy (split format without tunnel.N. prefix) name=I2P HTTP Proxy description=HTTP proxy for accessing I2P sites and outproxy type=httpclient interface=127.0.0.1 listenPort=4444 targetDestination= sharedClient=true startOnLoad=true # I2CP configuration i2cpHost=127.0.0.1 i2cpPort=7654 # HTTP client options option.i2ptunnel.httpclient.allowInternalSSL=false option.i2ptunnel.httpclient.disableAddressHelper=false option.i2ptunnel.httpclient.jumpServers=http://stats.i2p/cgi-bin/jump.cgi option.i2ptunnel.httpclient.sendAccept=false option.i2ptunnel.httpclient.sendReferer=false option.i2ptunnel.httpclient.sendUserAgent=false # Proxy authentication option.proxyAuth=false # Outproxy configuration option.i2ptunnel.httpclient.SSLOutproxies=false.i2p proxyList=false.i2p # Client behavior option.persistentClientKey=false option.i2cp.delayOpen=false # I2CP tunnel options option.inbound.length=3 option.outbound.length=3 option.inbound.quantity=2 option.outbound.quantity=2 История версий и хронология функций Версия 0.9.10 (2013) Новая возможность: Поддержка пустых значений в файлах конфигурации - Ключи с пустыми значениями (key=) теперь поддерживаются - Ранее игнорировались или вызывали ошибки разбора\nВерсия 0.9.18 (2015) Функция: Настройка интервала сброса буфера логгера - Свойство: logger.flushInterval (по умолчанию 29 секунд) - Снижает нагрузку на дисковый ввод-вывод при сохранении приемлемой задержки записи логов\nВерсия 0.9.23 (Ноябрь 2015) Важное изменение: минимальное требование — Java 7 - поддержка Java 6 прекращена - требуется для дальнейших обновлений безопасности\nВерсия 0.9.25 (2015) Функции: Параметры безопасности HTTP-сервера - tunnel.N.option.rejectReferer - Отклонять соединения с заголовком Referer - tunnel.N.option.rejectUserAgents - Отклонять определённые заголовки User-Agent - tunnel.N.option.userAgentRejectList - Шаблоны User-Agent для отклонения - Сценарий использования: Снизить активность краулеров и нежелательных клиентов\nВерсия 0.9.33 (январь 2018) Функция: Улучшенная фильтрация заголовка User-Agent - userAgentRejectList строка \u0026ldquo;none\u0026rdquo; соответствует пустому User-Agent - Дополнительные исправления ошибок для i2psnark, i2ptunnel, streaming, SusiMail\nВерсия 0.9.41 (2019) Объявление об устаревании: протокол BOB удалён из Android - пользователям Android необходимо перейти на SAM или I2CP\nВерсия 0.9.42 (август 2019 г.) Существенное изменение: Разделение конфигурационных файлов - clients.config разделён на структуру каталога clients.config.d/ - i2ptunnel.config разделён на структуру каталога i2ptunnel.config.d/ - Автоматическая миграция при первом запуске после обновления - Обеспечивает модульное пакетирование и управление плагинами - Устаревший монолитный формат по-прежнему поддерживается\nДополнительные возможности: - Улучшения производительности SSU - Предотвращение межсетевых соединений (Предложение 147) - Начальная поддержка типов шифрования\nВерсия 0.9.56 (2021) Возможности: улучшения безопасности и журналирования - logger.gzip - Gzip-сжатие для ротируемых логов (по умолчанию: false) - logger.minGzipSize - Минимальный размер для сжатия (по умолчанию: 65536 байт) - tunnel.N.option.proxy.auth.USER.sha256 - Дайджест-аутентификация SHA-256 (RFC 7616) - Безопасность: SHA-256 заменяет MD5 для дайджест-аутентификации\nВерсия 0.9.57 (январь 2023) Функция: Настройка типа SOCKS outproxy (прокси-сервера для выхода во внешний Интернет) - tunnel.N.option.outproxyType - Выбор типа outproxy (socks|connect) - По умолчанию: socks - Поддержка HTTPS CONNECT для HTTPS outproxy\nВерсия 2.6.0 (июль 2024) Несовместимое изменение: I2P-over-Tor заблокирован - Подключения с IP-адресов выходных узлов Tor теперь отклоняются - Причина: ухудшает производительность I2P, расходует ресурсы выходных узлов Tor - Последствия: пользователи, обращающиеся к I2P через выходные узлы Tor, будут заблокированы - Невыходные ретрансляторы и клиенты Tor не затронуты\nВерсия 2.10.0 (сентябрь 2025 - настоящее время) Основные возможности: - Постквантовая криптография доступна (опционально через Hidden Service Manager) - Поддержка UDP-трекеров для I2PSnark для снижения нагрузки на трекеры - Стабильность Скрытого режима улучшена для уменьшения истощения RouterInfo (метаданных router) - Улучшения сети для перегруженных router - Улучшено прохождение через UPnP/NAT - Улучшения NetDB с агрессивным удалением leaseset - Снижение наблюдаемости событий router\nКонфигурация: Новых параметров конфигурации не добавлено\nКритическое предстоящее изменение: Следующий релиз (вероятно, 2.11.0 или 3.0.0) потребует Java 17 или новее\nУстаревшие функции и изменения, нарушающие обратную совместимость Критические устаревания Доступ к I2P поверх Tor (Версия 2.6.0+) Статус: ЗАБЛОКИРОВАНО с июля 2024 года Влияние: Соединения с IP-адресов выходных узлов Tor отклоняются Причина: Ухудшает производительность сети I2P, не давая преимуществ в анонимности Затрагивает: Только выходные узлы Tor; ретрансляторы и обычные клиенты Tor не затрагиваются Альтернатива: Используйте I2P или Tor отдельно, не совместно Digest-аутентификация MD5 Статус: Устарело (используйте SHA-256) Свойство: tunnel.N.option.proxy.auth.USER.md5 Причина: MD5 криптографически небезопасен Замена: tunnel.N.option.proxy.auth.USER.sha256 (начиная с 0.9.56) Статус поддержки: MD5 всё ещё поддерживается, но не рекомендуется Изменения в архитектуре конфигурации Монолитные файлы конфигурации (Версия 0.9.42+) Затронуто: clients.config, i2ptunnel.config Статус: Устарело в пользу раздельной структуры каталогов Миграция: Автоматическая при первом запуске после обновления до 0.9.42 Совместимость: Устаревший формат по-прежнему работает (обратная совместимость) Рекомендация: Используйте раздельный формат для новых конфигураций Требования к версии Java Поддержка Java 6 Завершено: версия 0.9.23 (ноябрь 2015) Минимум: Java 7 требуется начиная с 0.9.23 Требование Java 17 (в ближайшее время) Статус: КРИТИЧЕСКОЕ ПРЕДСТОЯЩЕЕ ИЗМЕНЕНИЕ Цель: Следующий мажорный релиз после 2.10.0 (вероятно, 2.11.0 или 3.0.0) Текущая минимальная версия: Java 8 Необходимо: Подготовиться к переходу на Java 17 Сроки: Будут объявлены вместе с примечаниями к релизу Удалённые функции Протокол BOB (Android) Удалено: Версия 0.9.41 Платформа: только для Android Альтернатива: протоколы SAM (протокол взаимодействия с I2P) или I2CP Настольные системы: BOB (интерфейс управления I2P) по-прежнему доступен на настольных платформах Рекомендуемые миграции Аутентификация: Перейти с MD5 на аутентификацию по дайджесту SHA-256 Формат конфигурации: Перейти на раздельную структуру каталогов для клиентов и tunnels Среда выполнения Java: Запланировать обновление до Java 17 перед следующим крупным релизом Интеграция с Tor: Не маршрутизировать I2P через выходные узлы Tor Ссылки Официальная документация I2P Configuration Specification - Официальная спецификация формата конфигурационного файла I2P Plugin Specification - Конфигурация и упаковка плагинов I2P Common Structures - Type Mapping - Формат сериализации данных протокола Java Properties Format - Базовая спецификация формата Исходный код Репозиторий I2P Java Router - Зеркало на GitHub Gitea разработчиков I2P - Официальный репозиторий исходного кода I2P DataHelper.java - Реализация ввода/вывода файлов конфигурации Ресурсы сообщества Форум I2P - Активные обсуждения в сообществе и поддержка Сайт I2P - Официальный сайт проекта Документация по API DataHelper JavaDoc - документация по API для методов файла конфигурации Статус спецификации Последнее обновление спецификации: январь 2023 (версия 0.9.57) Текущая версия I2P: 2.10.0 (сентябрь 2025) Техническая корректность: спецификация остаётся корректной вплоть до 2.10.0 (без несовместимых изменений) Сопровождение: живой документ, обновляется при изменении формата конфигурации ","description":"Параметры конфигурации и форматы для I2P router'ов и клиентов","id":"b6b01c53245c0e36ca08c56f843abb7f","section":"docs","title":"Настройка router","url":"/ru/docs/specs/configuration/"},{"categories":null,"content":"Это руководство показывает, как настроить популярные браузеры для отправки трафика через встроенный HTTP-прокси I2P. Оно охватывает Safari, Firefox и браузеры Chrome/Chromium с подробными пошаговыми инструкциями.\nВажные замечания:\nHTTP-прокси I2P по умолчанию прослушивает 127.0.0.1:4444. I2P защищает трафик внутри сети I2P (сайты .i2p). Убедитесь, что ваш I2P router запущен, прежде чем настраивать браузер. Safari (macOS) Safari использует системные настройки прокси-сервера в macOS.\nStep 1: Open Network Settings Откройте Safari и перейдите в Safari → Настройки (или Preferences) Нажмите на вкладку Расширенные (Advanced) В разделе Прокси нажмите Изменить настройки\u0026hellip; (Change Settings\u0026hellip;) Это откроет Системные настройки сети на вашем Mac.\nШаг 1: Откройте настройки сети В настройках сети установите флажок для Веб-прокси (HTTP) Введите следующее: Сервер веб-прокси: 127.0.0.1 Порт: 4444 Нажмите ОК, чтобы сохранить настройки Теперь вы можете просматривать сайты .i2p в Safari!\nПримечание: Эти настройки прокси повлияют на все приложения, использующие системные прокси macOS. Рассмотрите возможность создания отдельной учетной записи пользователя или использования другого браузера исключительно для I2P, если вы хотите изолировать просмотр веб-страниц через I2P.\nFirefox (Desktop) Firefox имеет собственные настройки прокси-сервера, независимые от системных, что делает его идеальным для выделенного просмотра I2P.\nШаг 2: Настройка HTTP-прокси Нажмите на кнопку меню (☰) в правом верхнем углу Выберите Настройки Step 2: Find Proxy Settings В поле поиска настроек введите \u0026ldquo;proxy\u0026rdquo; Прокрутите до Настроек сети Нажмите кнопку Настройки\u0026hellip; Шаг 1: Откройте настройки Выберите Ручная настройка прокси Введите следующее: HTTP-прокси: 127.0.0.1 Порт: 4444 Оставьте SOCKS Host пустым (если только вам не нужен специально SOCKS-прокси) Установите флажок Proxy DNS when using SOCKS только при использовании SOCKS-прокси Нажмите ОК для сохранения Теперь вы можете просматривать сайты .i2p в Firefox!\nСовет: Рассмотрите возможность создания отдельного профиля Firefox, предназначенного для работы с I2P. Это позволит изолировать ваш I2P-трафик от обычного просмотра веб-страниц. Чтобы создать профиль, введите about:profiles в адресной строке Firefox.\nChrome / Chromium (Desktop) Chrome и браузеры на базе Chromium (Brave, Edge и т.д.) обычно используют системные настройки прокси-сервера в Windows и macOS. В данном руководстве показана конфигурация для Windows.\nШаг 2: Найдите настройки прокси-сервера Нажмите на меню с тремя точками (⋮) в правом верхнем углу Выберите Настройки Шаг 3: Настройка прокси вручную В поле поиска настроек введите \u0026ldquo;proxy\u0026rdquo; Нажмите Открыть настройки прокси-сервера компьютера Step 3: Open Manual Proxy Setup Это откроет настройки сети и интернета Windows.\nПрокрутите вниз до раздела Ручная настройка прокси-сервера Нажмите Настроить Шаг 1: Откройте настройки Chrome Переключите Использовать прокси-сервер в положение Вкл. Введите следующее: IP-адрес прокси: 127.0.0.1 Порт: 4444 При необходимости добавьте исключения в поле \u0026ldquo;Не использовать прокси-сервер для адресов, начинающихся с\u0026rdquo; (например, localhost;127.*) Нажмите Сохранить Теперь вы можете просматривать сайты .i2p в Chrome!\nПримечание: Эти настройки влияют на все браузеры на основе Chromium и некоторые другие приложения в Windows. Чтобы избежать этого, рассмотрите возможность использования Firefox с выделенным профилем I2P.\nШаг 2: Откройте настройки прокси В Linux вы можете запустить Chrome/Chromium с флагами прокси, чтобы избежать изменения системных настроек:\nchromium \\ --proxy-server=\u0026#34;http=127.0.0.1:4444 \\ --proxy-bypass-list=\u0026#34;\u0026lt;-loopback\u0026gt;\u0026#34; Или создайте скрипт для запуска с рабочего стола:\n#!/bin/bash chromium --proxy-server=\u0026#34;http=127.0.0.1:4444\u0026#34; --user-data-dir=\u0026#34;$HOME/.config/chromium-i2p\u0026#34; Флаг --user-data-dir создает отдельный профиль Chrome для работы с I2P.\nFirefox (Десктоп) Современные сборки Firefox \u0026ldquo;Fenix\u0026rdquo; по умолчанию ограничивают about:config и расширения. IceRaven — это форк Firefox, который включает курируемый набор расширений, упрощая настройку прокси.\nКонфигурация на основе расширения (IceRaven):\nЕсли вы уже используете IceRaven, рассмотрите возможность очистки истории просмотров (Меню → История → Удалить историю). 2) Откройте Меню → Дополнения → Менеджер дополнений. 3) Установите расширение \u0026ldquo;I2P Proxy for Android and Other Systems\u0026rdquo;. 4) Теперь браузер будет использовать прокси через I2P. Это расширение также работает в браузерах на основе Firefox до версии Fenix, если установлено из AMO .\nВключение поддержки широкого спектра расширений в Firefox Nightly требует отдельного процесса, описанного Mozilla .\nInternet Explorer / Windows System Proxy В Windows системный диалог прокси применяется к IE и может использоваться браузерами на основе Chromium, когда они наследуют системные настройки.\nОткройте «Параметры сети и Интернета» → «Прокси-сервер». 2) Включите «Использовать прокси-сервер для локальных подключений». 3) Установите адрес 127.0.0.1, порт 4444 для HTTP. 4) При необходимости отметьте «Не использовать прокси-сервер для локальных адресов». ","description":"Настройка популярных браузеров для использования HTTP/HTTPS прокси I2P на десктопе и Android","id":"a40410c542dc82558c1c1a8be78d2e62","section":"docs","title":"Настройка веб-браузера","url":"/ru/docs/guides/browser-config/"},{"categories":null,"content":" Статус: Эта страница сводит воедино материалы из устаревшей \u0026ldquo;Low-level Cryptography Specification\u0026rdquo; (спецификация криптографии низкого уровня). Современные релизы I2P (2.10.0, октябрь 2025) завершили миграцию на новые криптографические примитивы. Для деталей реализации используйте специализированные спецификации, такие как ECIES , Encrypted LeaseSets , NTCP2 , Red25519 , SSU2 и Tunnel Creation (ECIES) .\nСнимок эволюции Functional Area Legacy Primitive Current / Planned Primitive Migration Status Transport key exchange Diffie–Hellman over 2048-bit prime (NTCP / SSU) X25519 (NTCP2 / SSU2) Completed (NTCP2 and SSU2 fully deployed) End-to-end encryption ElGamal/AES+SessionTags ECIES-X25519-AEAD-Ratchet Completed (2.4.0+) Symmetric cipher AES-256/CBC + HMAC-MD5 ChaCha20/Poly1305 (AEAD) Active (tunnel layer remains AES-256) Default signatures DSA-SHA1 (1024-bit) EdDSA/RedDSA on Ed25519 Fully migrated Experimental / future — Hybrid post-quantum encryption (opt-in) In testing (2.10.0) ## Асимметричное шифрование X25519 (алгоритм обмена ключами на эллиптических кривых) Используется для NTCP2, ECIES-X25519-AEAD-Ratchet (схема шифрования/обмена ключами на основе X25519 с AEAD и ратчетом), SSU2 и создания tunnel на основе X25519. Обеспечивает компактные ключи, операции с постоянным временем выполнения и прямую секретность через фреймворк протокола Noise. Обеспечивает 128-битную криптостойкость с 32-байтовыми ключами и эффективный обмен ключами. Эль-Гамаль (устаревший) Сохранено для обратной совместимости со старыми routers. Работает на 2048‑битном простом числе группы Oakley 14 (RFC 3526) с генератором 2. Шифрует сеансовые ключи AES и векторы инициализации (IVs) в 514‑байтовые шифротексты. Не обеспечивает аутентифицированного шифрования и прямой секретности; все современные конечные точки перешли на ECIES. Симметричное шифрование ChaCha20/Poly1305 (алгоритм аутентифицированного шифрования AEAD) Примитив аутентифицированного шифрования по умолчанию для NTCP2, SSU2 и ECIES. Обеспечивает защиту AEAD и высокую производительность без аппаратной поддержки AES. Реализован согласно RFC 7539 (256‑битный ключ, 96‑битный nonce (одноразовое число), 128‑битный тег). AES‑256/CBC (устаревший) По‑прежнему используется для шифрования на уровне tunnel, где его структура блочного шифра хорошо вписывается в многослойную модель шифрования I2P. Использует дополнение PKCS#5 и преобразования IV на каждом переходе. Запланирован к долгосрочному пересмотру, но остаётся криптографически стойким. Подписи Signature Type Usage Notes Status DSA‑SHA1 (1024‑bit) Original default; still accepted for legacy Destinations. Deprecated ECDSA‑SHA256/384/512 Used during 2014–2015 transition. Supported EdDSA‑SHA512‑Ed25519 Default for Router and Destination identities (since 0.9.15). Default RedDSA‑SHA512‑Ed25519 Used for encrypted LeaseSet signatures (0.9.39+). Specialized RSA‑SHA512‑4096 For out‑of‑band signing (su3 updates, reseeds, plugins). Application‑layer ## Хэш и деривация ключей SHA‑256: Используется для ключей DHT (распределённой хеш‑таблицы), HKDF и устаревших подписей. SHA‑512: Используется в EdDSA/RedDSA и при выводе ключей HKDF в Noise. HKDF‑SHA256: Используется для вывода сеансовых ключей в ECIES, NTCP2 и SSU2. Ежедневно ротируемые производные SHA‑256 защищают места хранения RouterInfo и LeaseSet в netDb. Сводка по транспортному уровню Transport Key Exchange Encryption Authentication Status NTCP2 X25519 ChaCha20/Poly1305 AEAD Default TCP transport SSU2 X25519 ChaCha20/Poly1305 AEAD Default UDP transport SSU (Legacy) DH‑2048 AES‑256/CBC + HMAC‑MD5 Legacy Removed (2.4.0) Оба транспорта обеспечивают прямую секретность и защиту от повторов на канальном уровне, используя шаблон рукопожатия Noise_XK. Шифрование уровня tunnel По‑прежнему используется AES‑256/CBC для многослойного шифрования на каждом переходе. Шлюзы исходящего туннеля выполняют итеративную расшифровку AES; каждый переход повторно шифрует, используя свой ключ слоя и ключ IV (инициализационный вектор). Шифрование с двойным IV снижает риск корреляционных и подтверждающих атак. Переход на AEAD (аутентифицированное шифрование с дополнительными данными) изучается, но в настоящее время не планируется. Постквантовая криптография I2P 2.10.0 представляет экспериментальное гибридное постквантовое шифрование. Включается вручную через менеджер скрытых сервисов для тестирования. Комбинирует X25519 с квантово‑устойчивым KEM (механизм инкапсуляции ключа) (гибридный режим). Не включено по умолчанию; предназначено для исследований и оценки производительности. Фреймворк расширяемости Идентификаторы типов шифрования и подписи обеспечивают параллельную поддержку нескольких криптографических примитивов. Текущие соответствия включают: Типы шифрования: 0 = ElGamal/AES+SessionTags, 4 = ECIES‑X25519‑AEAD‑Ratchet. Типы подписей: 0 = DSA‑SHA1, 7 = EdDSA‑SHA512‑Ed25519, 11 = RedDSA‑SHA512‑Ed25519. Этот механизм позволяет выполнять будущие обновления, включая пост‑квантовые схемы, без разделения сети. Композиция криптографических примитивов Транспортный уровень: X25519 + ChaCha20/Poly1305 (фреймворк Noise). Уровень tunnel: многослойное шифрование AES‑256/CBC для анонимности. Сквозной: ECIES‑X25519‑AEAD‑Ratchet для конфиденциальности и прямой секретности (forward secrecy). Уровень базы данных: подписи EdDSA/RedDSA для аутентичности. Эти уровни в совокупности обеспечивают защиту в глубину: даже если один из уровней скомпрометирован, остальные сохраняют конфиденциальность и несвязываемость.\nСводка Криптографический стек I2P 2.10.0 сосредоточен на:\nCurve25519 (X25519) для обмена ключами ChaCha20/Poly1305 для симметричного шифрования EdDSA / RedDSA для подписей SHA‑256 / SHA‑512 для хеширования и деривации ключей Экспериментальные постквантовые гибридные режимы для обеспечения совместимости в будущем Устаревшие ElGamal, AES‑CBC и DSA сохраняются для обратной совместимости, но больше не используются в активных транспортах или путях шифрования.\n","description":"Сводка симметричных, асимметричных и примитивов электронной подписи, используемых в I2P","id":"f5b93f818161e04d49735c3df52fcbdc","section":"docs","title":"Низкоуровневая криптография","url":"/ru/docs/specs/cryptography/"},{"categories":null,"content":"Обсуждение NTCP vs. SSU (март 2007) Вопросы по NTCP Адаптировано из беседы в IRC между zzz и cervantes.\nПочему NTCP имеет приоритет над SSU, если NTCP, похоже, добавляет накладные расходы и задержку?\nВ целом NTCP обеспечивает лучшую надежность, чем исходная реализация SSU. Приводит ли потоковая передача поверх NTCP к классическому коллапсу TCP поверх TCP?\nВозможно, но SSU задумывался как облегченный вариант на основе UDP и на практике оказался слишком ненадежным. “NTCP признан вредным” (zzz, 25 марта 2007) Резюме: более высокая задержка и накладные расходы NTCP могут приводить к перегрузке, однако маршрутизация предпочитает NTCP, поскольку его bid scores (оценки bid при выборе транспорта) жестко заданы ниже, чем у SSU. Анализ выявил несколько моментов:\nПредложения из темы 2007 года Инвертировать приоритеты транспортов так, чтобы routers предпочитали SSU (восстановив i2np.udp.alwaysPreferred). Пометить трафик streaming (библиотека потоковой передачи в I2P) так, чтобы SSU снижал приоритет только для помеченных сообщений, без ущерба для анонимности. Ужесточить пределы ретрансляции SSU, чтобы снизить риск коллапса. Изучить semi-reliable underlays (полунадежные нижние транспортные слои), чтобы определить, дают ли ретрансляции ниже библиотеки streaming чистую выгоду. Пересмотреть очереди приоритетов и тайм-ауты—например, увеличить тайм-ауты streaming свыше 45 с, чтобы привести их в соответствие с NTCP. Ответ от jrandom (27 марта 2007 г.) Основные контраргументы:\nNTCP существует потому, что ранние внедрения SSU страдали от коллапса сети из‑за перегрузки. Даже умеренные уровни повторных передач на каждом переходе (hop) могут взрывно возрастать через многохоповые tunnel. Без подтверждений на уровне tunnel лишь часть сообщений получает сквозной (end‑to‑end) статус доставки; сбои могут оставаться незаметными. Механизмы управления перегрузкой в TCP оптимизировались десятилетиями; NTCP использует это благодаря зрелым реализациям стеков TCP. Наблюдавшийся рост эффективности при предпочтении SSU может отражать поведение очередей на router, а не внутренние преимущества протокола. Увеличенные тайм‑ауты стриминга уже улучшали стабильность; прежде чем вносить крупные изменения, рекомендовалось собрать больше наблюдений и данных. Дискуссия помогла уточнить последующую настройку транспорта, но не отражает современную архитектуру NTCP2/SSU2.\n","description":"Исторические заметки по сравнению транспортов NTCP и SSU и предложения по настройке","id":"6fe94dc04faadfde27bcfeaaf9da5f71","section":"docs","title":"Обсуждение NTCP","url":"/ru/docs/ntcp/"},{"categories":null,"content":" Примечание: Этот архив содержит проектные проработки гипотетического характера, выполненные до I2P 0.9.41. Информацию о продакшн-реализации см. в tunnel documentation .\nВарианты настройки Идеи, рассматривавшиеся для будущих параметров настройки tunnel, включали:\nМеханизмы ограничения частоты доставки сообщений Политики дополнения (включая инъекцию ложного трафика) Механизмы управления временем жизни tunnel Стратегии пакетирования и управления очередями для отправки полезной нагрузки Ни один из этих параметров не поставлялся вместе с устаревшей реализацией.\nСтратегии заполнения Обсуждавшиеся возможные подходы к padding (добавочное заполнение):\nБез какого-либо дополнения Дополнение случайной длины Дополнение фиксированной длины Дополнение до ближайшего килобайта Дополнение до степеней двойки (2^n байт) Ранние измерения (релиз 0.4) привели к текущему фиксированному размеру сообщения tunnel в 1024 байта. Более высокоуровневые garlic messages (чесночные сообщения) могут добавлять собственное заполнение.\nФрагментация Чтобы предотвратить атаки маркировкой по длине сообщений, сообщения tunnel имеют фиксированный размер 1024 байта. Более крупные полезные нагрузки I2NP разбиваются шлюзом на фрагменты; конечная точка собирает фрагменты в течение короткого тайм-аута. Routers могут переупорядочивать фрагменты, чтобы максимизировать эффективность уплотнения перед отправкой.\nДополнительные альтернативы Настройка обработки Tunnel на лету Были рассмотрены три варианта:\nРазрешить промежуточному переходу временно прервать tunnel, предоставив доступ к расшифрованным полезным данным. Разрешить участвующим routers “перемешивать” сообщения, отправляя их через один из собственных исходящих tunnels, прежде чем продолжить к следующему переходу. Позволить создателю tunnel динамически переопределять следующий переход пира. Двунаправленные Tunnels Использование отдельных входящих и исходящих tunnels ограничивает объем информации, который может наблюдать любой конкретный набор пиров (например, запрос GET в отличие от объемного ответа). Двунаправленные tunnels упрощают управление пирами, но одновременно раскрывают полную картину трафика в обоих направлениях. Поэтому однонаправленные tunnels остались предпочтительным вариантом.\nОбратные каналы и переменные размеры Разрешение переменных размеров сообщений в tunnel позволило бы организовать скрытые каналы между узлами, действующими в сговоре (например, кодируя данные с помощью выбранных размеров или частот). Сообщения фиксированного размера снижают этот риск ценой дополнительных накладных расходов на заполнение.\nАльтернативы построения Tunnel Ссылка: Hashing it out in Public Устаревший метод сборки «Parallel» До релиза 0.6.1.10 запросы на построение tunnel отправлялись параллельно каждому участнику. Этот метод описан на старой странице tunnel .\nОдношаговое телескопическое построение (текущий метод) Современный подход передаёт сообщения построения последовательно от узла к узлу через частично сформированный tunnel. Хотя это похоже на телескопирование в Tor, маршрутизация сообщений построения через исследовательские tunnels снижает утечку информации.\n«Интерактивное» телескопирование Построение по одному хопу за раз с явными обменами по схеме запрос–ответ позволяет пирам подсчитывать сообщения и делать вывод о своём положении внутри tunnel, поэтому от такого подхода отказались.\nНеисследовательские управляющие tunnels Одним из предложений было поддерживать отдельный пул управляющих tunnels для трафика построения. Хотя это могло бы помочь разделённым routers, при достаточной интеграции сети это сочли ненужным.\nИсследовательская доставка (устаревшее) До версии 0.6.1.10 отдельные запросы на tunnel шифровались средствами garlic encryption и доставлялись через исследовательские tunnels, а ответы возвращались отдельно. Эта стратегия была заменена текущим методом однократного телескопирования.\nВыводы Сообщения в tunnel фиксированного размера защищают от маркировки по размеру и скрытых каналов, несмотря на дополнительные накладные расходы на заполнение (padding). Альтернативные подходы к заполнению, фрагментации и построению были изучены, но не приняты из‑за компромиссов в отношении анонимности. Дизайн tunnel продолжает балансировать между эффективностью, наблюдаемостью и устойчивостью к атакам предшественника и атакам на основе перегрузки. ","description":"Исторический обзор паддинга tunnel, фрагментации и стратегий построения","id":"e5773155afe129d73b1384e5c116ec56","section":"docs","title":"Обсуждение Tunnel","url":"/ru/docs/legacy/tunnel/"},{"categories":null,"content":" Контекст: На этой странице собраны затяжные дискуссии из раннего этапа проектирования I2P. Она объясняет, почему проект отдавал предпочтение локально доверенным адресным книгам, а не DNS-подобному разрешению имён или реестрам, основанным на решении большинством. Актуальные рекомендации по использованию см. в документации по именованию .\nОтклонённые альтернативы Цели безопасности I2P исключают привычные схемы именования:\nРазрешение в стиле DNS. Любой резолвер на пути разрешения может подделать или цензурировать ответы. Даже с DNSSEC скомпрометированные регистраторы или центры сертификации остаются единой точкой отказа. В I2P destinations (адреса назначения) являются открытыми ключами—перехват запроса на разрешение полностью компрометирует идентичность. Именование на основе голосования. Противник может создавать неограниченное число идентичностей (атака Сивиллы) и “выигрывать” голоса за популярные имена. Меры на основе доказательства работы повышают стоимость атаки, но вносят серьёзные накладные расходы на координацию. Вместо этого в I2P система именования сознательно располагается над транспортным уровнем. Встроенная библиотека именования предоставляет интерфейс поставщика услуг, чтобы альтернативные схемы могли сосуществовать — пользователи сами решают, каким адресным книгам или jump services (службам перехода) они доверяют.\nЛокальные и глобальные имена (jrandom, 2005) Имена в I2P являются локально уникальными, но человекочитаемыми. Ваш boss.i2p может не совпадать с boss.i2p другого человека, и это сделано намеренно. Если злоумышленник обманом заставит вас изменить Destination (назначение), стоящее за именем, он фактически захватит сервис. Отказ от глобальной уникальности предотвращает такой класс атак. Относитесь к именам как к закладкам или никам в мессенджерах — вы сами выбираете, каким Destination доверять, подписываясь на конкретные адресные книги или добавляя ключи вручную. Распространённые возражения и ответы (zzz) Concern Response “Downloading hosts.txt is inefficient.” At ~400\u0026nbsp;KB for ~800 hosts the bandwidth impact is minor (~10\u0026nbsp;B/s if refreshed twice daily). ETags already avoid unnecessary transfers. Alternate formats (for example recenthosts.cgi) can deliver only new entries. “It won’t scale.” A hosts.txt entry is ~500\u0026nbsp;bytes; storing thousands locally is practical. Real-time lookups would dramatically slow browsing. “Requires trust and manual setup.” True—and intentional. Users must choose address book providers they trust. Trust is not binary; forcing configuration encourages users to think about it. “Why not just use DNS?” DNS depends on short TTLs and can be hijacked mid-path. I2P destinations are immutable public keys, so DNS semantics map poorly. “Subscriptions rely on specific servers.” Subscriptions are decentralised—you can add multiple providers or run your own. Completely decentralised systems struggle with conflict resolution and hijacking. “Jump services and hosts.txt feel awkward.” They are pragmatic trade-offs. Jump services provide just-in-time lookups; subscriptions keep a local cache for performance. ## Обсуждение идей повышения эффективности Предоставлять инкрементальные обновления (только назначения, добавленные после последнего получения). Предлагать дополнительные фиды (recenthosts.cgi) наряду с полными файлами hosts. Рассмотреть инструменты с поддержкой скриптов (например, i2host.i2p) для объединения фидов или фильтрации по уровням доверия. Основные выводы Безопасность важнее глобального консенсуса: локально сопровождаемые адресные книги минимизируют риск подмены. Несколько подходов к именованию могут сосуществовать через API именования—пользователи сами решают, чему доверять. Полностью децентрализованная глобальная система именования все еще остается открытой исследовательской задачей; компромиссы между безопасностью, удобством запоминания для человека и глобальной уникальностью по-прежнему отражают треугольник Зуко . Ссылки Документация по именованию Зуко: «Имена: децентрализованные, безопасные, понятные человеку: выберите любые два» Пример инкрементальной ленты: stats.i2p/cgi-bin/newhosts.txt ","description":"Историческая дискуссия о модели именования I2P и о том, почему были отвергнуты глобальные DNS‑подобные схемы","id":"952b10ba82200ff92e5ddeed512d6afb","section":"docs","title":"Обсуждение именования","url":"/ru/docs/legacy/naming/"},{"categories":null,"content":" Примечание: Это архивное обсуждение описывает исторические подходы к сетевой базе данных (netDb). Обратитесь к основной документации по netDb , чтобы узнать об актуальном поведении и рекомендациях.\nИстория netDb I2P распространяется с использованием простого алгоритма floodfill. Ранние релизы также сохраняли реализацию Kademlia DHT в качестве запасного варианта, но она оказалась ненадежной и была полностью отключена в версии 0.6.1.20. В схеме floodfill опубликованная запись пересылается на участвующий router, ожидается подтверждение и при необходимости выполняются повторные попытки через других участников floodfill. Пиры floodfill рассылают публикации от router, не участвующих во floodfill, всем прочим участникам floodfill.\nВ конце 2009 года запросы Kademlia были частично вновь введены, чтобы уменьшить нагрузку по хранению данных на отдельных floodfill routers.\nВведение в Floodfill (тип узлов I2P, хранящих и распространяющих записи netDb) Floodfill впервые появилась в релизе 0.6.0.4, при этом Kademlia оставалась доступной в качестве резервного варианта. В то время значительные потери пакетов и ограниченные маршруты затрудняли получение подтверждений от четырёх ближайших узлов, часто требуя десятков избыточных попыток сохранения. Переход к подмножеству floodfill среди доступных извне routers обеспечил прагматичное краткосрочное решение.\nПереосмысление Kademlia (протокол распределённой хеш-таблицы, DHT) Среди рассмотренных альтернатив были:\nИспользование netDb как Kademlia DHT (распределённая хеш-таблица Kademlia), ограниченной достижимыми routers, добровольно согласившимися участвовать Сохранение модели floodfill, но с ограничением участия для обладающих достаточными ресурсами routers и проверкой распределения с помощью случайных выборочных проверок Подход floodfill взял верх, поскольку его было проще развернуть, а netDb содержит только метаданные, а не пользовательскую полезную нагрузку. Большинство назначений никогда не публикуют LeaseSet, потому что отправитель обычно вкладывает свой LeaseSet в чесночные сообщения.\nТекущее состояние (историческая перспектива) Алгоритмы netDb настроены под потребности сети и исторически без труда справлялись с несколькими сотнями routers. Ранние оценки предполагали, что 3–5 floodfill routers могли поддерживать примерно 10,000 узлов.\nОбновлённые расчёты (март 2008) recvKBps = N * (L + 1) * (1 + F) * (1 + R) * S / T Где:\nN: Число router-ов в сети L: Среднее число клиентских назначений на один router (плюс одно для RouterInfo) F: Процент отказов tunnel-ов R: Период пересборки tunnel-а как доля времени жизни tunnel-а S: Средний размер записи netDb T: Время жизни tunnel-а Используя значения образца 2008 года (N = 700, L = 0.5, F = 0.33, R = 0.5, S = 4 KB, T = 10 minutes), получаем:\nrecvKBps ≈ 700 * (0.5 + 1) * (1 + 0.33) * (1 + 0.5) * 4 KB / 10m ≈ 28 KBps Вернётся ли Kademlia (протокол распределённой хеш-таблицы)? В начале 2007 года разработчики обсуждали повторное внедрение Kademlia (распределённой хеш-таблицы, DHT). Было достигнуто согласие, что ёмкость floodfill можно постепенно наращивать по мере необходимости, тогда как Kademlia добавляет существенную сложность и требования к ресурсам для базовой популяции router. Резервный механизм остаётся неактивным, пока ёмкость floodfill не станет недостаточной.\nПланирование пропускной способности floodfill Автоматическое включение routers класса пропускной способности O в floodfill, хотя и выглядит привлекательным, чревато сценариями атак отказа в обслуживании, если в него добровольно включатся враждебные узлы. Исторический анализ показывал, что ограничение пула floodfill (например, 3–5 пиров, обслуживающих ~10K routers) более безопасно. Для поддержания достаточного, но контролируемого набора floodfill использовались доверенные операторы или автоматические эвристики.\nFloodfill TODO (историческое) Этот раздел сохранён для истории. Основная страница netDb содержит актуальную дорожную карту и соображения по проектированию.\nОперационные инциденты, такие как период 13 марта 2008 года, когда был доступен только один floodfill router, привели к ряду улучшений, реализованных в релизах 0.6.1.33—0.7.x, включая:\nСлучайный выбор floodfill для поисковых запросов и приоритет для отзывчивых пиров Отображение дополнительных метрик floodfill на странице \u0026ldquo;Profiles\u0026rdquo; консоли router Постепенное сокращение размера записей netDb для снижения использования пропускной способности floodfill Автоматическое включение подмножества routers класса O на основе показателей производительности, собранных по данным профиля Улучшение блоклистов, выбора пиров floodfill и эвристик исследования Оставшиеся идеи того периода включали:\nИспользование статистики dbHistory для более точного оценивания и выбора floodfill-пиров Улучшение поведения повторных попыток, чтобы избежать многократных обращений к сбоящим пирам Использование метрик задержки и оценок интеграции при выборе Более быстрое обнаружение и реакция на сбои floodfill routers Продолжение снижения требований к ресурсам на узлах с высокой пропускной способностью и на floodfill-узлах Даже на момент составления этих заметок сеть считалась устойчивой, с инфраструктурой, позволяющей быстро реагировать на враждебные floodfills (специализированные узлы в netDb) или на атаки отказа в обслуживании, нацеленные на floodfill.\nДополнительные примечания Консоль router давно предоставляет расширенные данные профиля, чтобы помочь в анализе надёжности floodfill. Хотя в исторических комментариях высказывались предположения о Kademlia или альтернативных схемах DHT (распределённой хеш-таблицы), floodfill по-прежнему остаётся основным алгоритмом в боевых сетях. Перспективные исследования сосредоточились на том, чтобы сделать допуск в floodfill адаптивным, одновременно ограничивая возможности для злоупотреблений. ","description":"Исторические заметки о floodfill, экспериментах с Kademlia (алгоритм распределённой хеш-таблицы, DHT) и предстоящей настройке netDb","id":"0ddefeec5b7108b36649c4d989bf474e","section":"docs","title":"Обсуждение сетевой базы данных","url":"/ru/docs/netdb/"},{"categories":null,"content":"Обзор Этот документ определяет базовые структуры данных, используемые во всех протоколах I2P, включая I2NP , I2CP , SSU2 , NTCP2 и другие. Эти общие структуры обеспечивают совместимость между различными реализациями I2P и уровнями протоколов.\nОсновные изменения с версии 0.9.58 ElGamal и DSA-SHA1 признаны устаревшими для Router Identities (используйте X25519 + EdDSA) Постквантовая поддержка ML-KEM проходит бета-тестирование (включается по выбору начиная с 2.10.0) Параметры service record (запись службы) стандартизированы (Proposal 167 , реализовано в 0.9.66) Спецификации сжимаемого padding (дополнение) завершены (Proposal 161 , реализовано в 0.9.57) Общие спецификации типов Целое число Описание: Представляет неотрицательное целое число в сетевом порядке байтов (big-endian).\nСодержимое: от 1 до 8 байт, представляющих беззнаковое целое.\nИспользование: Длины полей, счётчики, идентификаторы типов и числовые значения во всех протоколах I2P.\nДата Описание: Метка времени, представляющая количество миллисекунд с начала эпохи Unix (1 января 1970 00:00:00 GMT).\nСодержимое: 8-байтовое целое число (unsigned long)\nСпециальные значения: - 0 = Неопределённая или нулевая дата - Максимальное значение: 0xFFFFFFFFFFFFFFFF (год 584 942 417 355)\nПримечания по реализации: - Всегда часовой пояс UTC/GMT - Требуется точность до миллисекунд - Используется для истечения срока действия аренды, публикации RouterInfo и проверки меток времени\nСтрока Описание: Строка в кодировке UTF-8 с префиксом длины.\nФормат:\n+----+----+----+----+----+----+ |len | UTF-8 encoded data... | +----+----+----+----+----+----+ len :: Integer (1 byte) Value: 0-255 (string length in bytes, NOT characters) data :: UTF-8 encoded bytes Length: 0-255 bytes Ограничения: - Максимальная длина: 255 байт (не символов — многобайтные последовательности UTF-8 учитываются как несколько байт) - Длина может быть равна нулю (пустая строка) - Завершающий нулевой байт НЕ включён - Строка НЕ завершается нулевым байтом\nВажно: последовательности UTF-8 могут использовать несколько байт на символ. Строка из 100 символов может превысить лимит в 255 байт, если используются многобайтовые символы.\nСтруктуры криптографических ключей Открытый ключ Описание: Открытый ключ для асимметричного шифрования. Тип и длина ключа зависят от контекста или указаны в Key Certificate (сертификате ключа).\nТип по умолчанию: ElGamal (устарел для Router Identities с версии 0.9.58)\nПоддерживаемые типы:\nType Code Length (bytes) Since Endianness Usage Status ElGamal0256-BigDestinations only (unused field)Deprecated for RIs P256164TBDBigReservedSee Proposal 145 P384296TBDBigReservedSee Proposal 145 P5213132TBDBigReservedSee Proposal 145 X255194320.9.38LittleCurrent standardRecommended MLKEM512_X255195320.9.67MixedHybrid PQ, LeaseSets onlyBeta MLKEM768_X255196320.9.67MixedHybrid PQ, LeaseSets onlyBeta MLKEM1024_X255197320.9.67MixedHybrid PQ, LeaseSets onlyBeta MLKEM512-8000.9.67TBDHandshakes onlyBeta MLKEM768-11840.9.67TBDHandshakes onlyBeta MLKEM1024-15680.9.67TBDHandshakes onlyBeta MLKEM512_CT-7680.9.67TBDHandshakes onlyBeta MLKEM768_CT-10880.9.67TBDHandshakes onlyBeta MLKEM1024_CT-15680.9.67TBDHandshakes onlyBeta **Требования к реализации:** X25519 (Тип 4) - текущий стандарт:\nИспользуется для шифрования ECIES-X25519-AEAD-Ratchet Обязателен для идентификаторов Router начиная с 0.9.48 Кодирование в little-endian (порядок байтов от младшего к старшему; в отличие от других типов) См. ECIES и ECIES-ROUTERS ElGamal (тип 0) - устаревший:\nУстарел для Router Identities (идентификаторов router) с версии 0.9.58 По-прежнему действителен для Destinations (адресатов в I2P) (поле не используется с 0.6/2005) Использует фиксированные простые числа, определённые в ElGamal specification Поддержка сохраняется для обратной совместимости MLKEM (постквантовый) - Бета:\nГибридный подход объединяет ML-KEM с X25519 По умолчанию НЕ включено в 2.10.0 Требует ручной активации через Hidden Service Manager (менеджер скрытых сервисов) См. ECIES-HYBRID и Предложение 169 Коды типов и спецификации могут быть изменены JavaDoc: PublicKey Закрытый ключ Описание: Закрытый ключ для асимметричного расшифрования, соответствующий типам PublicKey.\nХранение: Тип и длина определяются по контексту или хранятся отдельно в структурах данных/файлах ключей.\nПоддерживаемые типы:\nType Code Length (bytes) Since Endianness Usage Status ElGamal0256-BigDestinations onlyDeprecated for RIs P256132TBDBigReservedSee Proposal 145 P384248TBDBigReservedSee Proposal 145 P521366TBDBigReservedSee Proposal 145 X255194320.9.38LittleCurrent standardRecommended MLKEM512_X255195320.9.67MixedHybrid PQ, LeaseSets onlyBeta MLKEM768_X255196320.9.67MixedHybrid PQ, LeaseSets onlyBeta MLKEM1024_X255197320.9.67MixedHybrid PQ, LeaseSets onlyBeta MLKEM512-16320.9.67TBDHandshakes onlyBeta MLKEM768-24000.9.67TBDHandshakes onlyBeta MLKEM1024-31680.9.67TBDHandshakes onlyBeta **Примечания по безопасности:** - Закрытые ключи ДОЛЖНЫ генерироваться с использованием криптографически стойких генераторов случайных чисел - Закрытые ключи X25519 используют scalar clamping (ограничение скаляра), как определено в RFC 7748 - Ключевой материал ДОЛЖЕН быть безопасно удалён из памяти, когда он больше не нужен Документация JavaDoc: PrivateKey Сеансовый ключ Описание: Симметричный ключ для AES-256 шифрования и расшифрования в tunnel и garlic encryption I2P.\nСодержимое: 32 байта (256 бит)\nИспользование: - Шифрование на уровне Tunnel (AES-256/CBC с IV) - Шифрование сообщений (garlic encryption) - Сквозное шифрование сеанса\nГенерация: необходимо использовать криптографически стойкий генератор случайных чисел.\nJavaDoc: SessionKey SigningPublicKey Описание: Открытый ключ для проверки подписи. Тип и длина указаны в сертификате ключа Destination (адрес назначения в I2P) или определяются из контекста.\nТип по умолчанию: DSA_SHA1 (устарел начиная с версии 0.9.58)\nПоддерживаемые типы:\nType Code Length (bytes) Since Endianness Usage Status DSA_SHA10128-BigLegacy onlyDeprecated ECDSA_SHA256_P2561640.9.12BigOlder DestinationsDeprecated ECDSA_SHA384_P3842960.9.12BigRareDeprecated ECDSA_SHA512_P52131320.9.12BigRareDeprecated RSA_SHA256_204842560.9.12BigOffline signing onlyDeprecated RSA_SHA384_307253840.9.12BigOffline signing onlyDeprecated RSA_SHA512_409665120.9.12BigOffline signing onlyRecommended for SU3 EdDSA_SHA512_Ed255197320.9.15LittleCurrent standardRecommended EdDSA_SHA512_Ed25519ph8320.9.25LittleOffline signing onlyRare RedDSA_SHA512_Ed2551911320.9.39LittleEncrypted leasesets onlySpecialized Reserved (GOST)964-BigReservedProposal 134 Reserved (GOST)10128-BigReservedProposal 134 Reserved (MLDSA)12-20TBD-TBDReservedProposal 169 Experimental65280-65534Varies-VariesTesting onlyNever production Reserved65535---Future expansion- **Требования к реализации:** EdDSA_SHA512_Ed25519 (Тип 7) - текущий стандарт:\nПо умолчанию для всех новых Router Identities и Destinations (назначений) с конца 2015 года Использует кривую Ed25519 с хешированием SHA-512 32-байтные открытые ключи, 64-байтные подписи Кодирование little-endian (в отличие от большинства других типов) Высокая производительность и безопасность RedDSA_SHA512_Ed25519 (Тип 11) - специализированный:\nИспользуется ТОЛЬКО для зашифрованных leasesets и blinding (криптографическое ослепление) Никогда не используется для Router Identities или стандартных Destinations (назначений) Ключевые отличия от EdDSA: Закрытые ключи через приведение по модулю (не clamping (фиксирование битов)) Подписи включают 80 байт случайных данных Использует открытые ключи напрямую (не хеши закрытых ключей) См. [спецификация Red25519](//docs/specs/red25519-signature-scheme/ DSA_SHA1 (Type 0) - Устаревшее:\nПомечено как устаревшее для Router Identities начиная с 0.9.58 Не рекомендуется для новых назначений 1024-битная DSA с SHA-1 (известные слабости) Поддержка сохраняется только для совместимости Многокомпонентные ключи:\nКогда состоят из двух элементов (например, координаты точки ECDSA X, Y) Каждый элемент дополняется ведущими нулями до длины/2 Пример: 64-байтовый ключ ECDSA = 32-байтовый X + 32-байтовый Y JavaDoc: SigningPublicKey SigningPrivateKey Описание: Закрытый ключ для создания подписей, соответствующий типам SigningPublicKey.\nХранилище: Тип и длина задаются при создании.\nПоддерживаемые типы:\nType Code Length (bytes) Since Endianness Usage Status DSA_SHA1020-BigLegacy onlyDeprecated ECDSA_SHA256_P2561320.9.12BigOlder DestinationsDeprecated ECDSA_SHA384_P3842480.9.12BigRareDeprecated ECDSA_SHA512_P5213660.9.12BigRareDeprecated RSA_SHA256_204845120.9.12BigOffline signing onlyDeprecated RSA_SHA384_307257680.9.12BigOffline signing onlyDeprecated RSA_SHA512_4096610240.9.12BigOffline signing onlyRecommended for SU3 EdDSA_SHA512_Ed255197320.9.15LittleCurrent standardRecommended EdDSA_SHA512_Ed25519ph8320.9.25LittleOffline signing onlyRare RedDSA_SHA512_Ed2551911320.9.39LittleEncrypted leasesets onlySpecialized **Требования к безопасности:** - Генерируйте с использованием криптографически стойкого источника случайных чисел - Защищайте с помощью соответствующих механизмов контроля доступа - По завершении безопасно удаляйте из памяти - Для EdDSA: 32-байтовый seed хэшируется с помощью SHA-512, первые 32 байта становятся скаляром (clamped — клампирование, установка определённых битов) - Для RedDSA: иная генерация ключа (редуцирование по модулю вместо clamping) Документация JavaDoc: SigningPrivateKey Подпись Описание: Криптографическая подпись данных с использованием алгоритма подписи, соответствующего типу SigningPrivateKey.\nТип и длина: Выводятся из типа ключа, используемого для подписи.\nПоддерживаемые типы:\nType Code Length (bytes) Since Endianness Usage Status DSA_SHA1040-BigLegacy onlyDeprecated ECDSA_SHA256_P2561640.9.12BigOlder DestinationsDeprecated ECDSA_SHA384_P3842960.9.12BigRareDeprecated ECDSA_SHA512_P52131320.9.12BigRareDeprecated RSA_SHA256_204842560.9.12BigOffline signing onlyDeprecated RSA_SHA384_307253840.9.12BigOffline signing onlyDeprecated RSA_SHA512_409665120.9.12BigOffline signing onlyCurrent for SU3 EdDSA_SHA512_Ed255197640.9.15LittleCurrent standardRecommended EdDSA_SHA512_Ed25519ph8640.9.25LittleOffline signing onlyRare RedDSA_SHA512_Ed2551911640.9.39LittleEncrypted leasesets onlySpecialized **Примечания по формату:** - Многоэлементные подписи (например, значения R и S в ECDSA) дополняются ведущими нулями до длины/2 для каждого элемента - EdDSA и RedDSA используют кодирование с порядком байт little-endian (младший байт первым) - Все остальные типы используют кодирование с порядком байт big-endian (старший байт первым) Проверка: - Используйте соответствующий SigningPublicKey - Следуйте спецификациям алгоритма подписи для данного типа ключа - Проверьте, что длина подписи соответствует ожидаемой для данного типа ключа\nJavaDoc: Signature Хэш Описание: SHA-256 хэш данных, широко используемый в I2P для проверки целостности и идентификации.\nСодержимое: 32 байта (256 бит)\nИспользование: - хэши Router Identity (структуры идентификации router) (ключи сетевой базы данных) - хэши Destination (адресата в I2P) (ключи сетевой базы данных) - идентификация шлюза tunnel в Leases (элементах LeaseSet) - проверка целостности данных - генерация Tunnel ID\nАлгоритм: SHA-256, как определено в стандарте FIPS 180-4\nДокументация JavaDoc: Hash Сессионный тег Описание: Случайное число, используемое для идентификации сеанса и шифрования на основе тегов.\nВажно: Размер тега сессии варьируется в зависимости от типа шифрования: - ElGamal/AES+SessionTag: 32 байта (устаревший) - ECIES-X25519: 8 байт (текущий стандарт)\nТекущий стандарт (ECIES, интегрированная схема шифрования на эллиптических кривых):\nContents: 8 bytes Usage: Ratchet-based encryption for Destinations and Routers См. ECIES и ECIES-ROUTERS для получения подробных спецификаций.\nУстаревшее (ElGamal/AES):\nContents: 32 bytes Usage: Deprecated encryption scheme Генерация: ДОЛЖЕН использовать криптографически стойкий генератор случайных чисел.\nДокументация JavaDoc: SessionTag TunnelId Описание: Уникальный идентификатор позиции router в tunnel. Каждый хоп в tunnel имеет свой собственный TunnelId (идентификатор туннеля).\nФормат:\nContents: 4-byte Integer (unsigned 32-bit) Range: Generally \u0026gt; 0 (zero reserved for special cases) Использование: - Идентифицирует входящие/исходящие соединения tunnel на каждом router - Разный TunnelId на каждом переходе в цепочке tunnel - Используется в структурах Lease (элемент Lease — запись параметров доставки) для идентификации шлюзовых tunnel\nОсобые значения: - 0 = Зарезервировано для специальных нужд протокола (не используйте при нормальной работе) - TunnelIds локально значимы для каждого router\nДокументация JavaDoc: TunnelId Спецификации сертификатов Сертификат Описание: Контейнер для подтверждений, доказательства работы или криптографических метаданных, используемых во всём I2P.\nФормат:\n+----+----+----+----+----+----+-// |type| length | payload +----+----+----+----+----+----+-// type :: Integer (1 byte) Values: 0-5 (see types below) length :: Integer (2 bytes, big-endian) Size of payload in bytes payload :: data length -\u0026gt; $length bytes Общий размер: минимум 3 байта (NULL certificate — сертификат NULL), максимум 65538 байт\nТипы сертификатов Type Code Payload Length Total Size Status Usage NULL003CurrentDefault/empty certificate HASHCASH1VariesVariesDeprecatedUnused (was for proof-of-work) HIDDEN203DeprecatedUnused (hidden routers don't advertise) SIGNED340 or 7243 or 75DeprecatedUnused (DSA signature ± destination hash) MULTIPLE4VariesVariesDeprecatedUnused (multiple certificates) KEY54+7+CurrentSpecifies key types (see below) ### Сертификат ключа (тип 5) Введение: Версия 0.9.12 (декабрь 2013)\nНазначение: Указывает нестандартные типы ключей и хранит дополнительные данные ключей сверх стандартной 384-байтной структуры KeysAndCert (структура ключей и сертификата).\nСтруктура полезной нагрузки:\n+----+----+----+----+----+----+----+----+-// |SPKtype|CPKtype| Excess SPK data | +----+----+----+----+----+----+----+----+-// | Excess CPK data... | +----+----+----+----+----+----+----+----+ SPKtype :: Signing Public Key Type (2 bytes) See SigningPublicKey table above CPKtype :: Crypto Public Key Type (2 bytes) See PublicKey table above Excess SPK data :: Signing key bytes beyond 128 bytes Length: 0 to 65531 bytes Excess CPK data :: Crypto key bytes beyond 256 bytes Length: 0 to remaining space Критические замечания по реализации:\nПорядок типов ключей:\nПРЕДУПРЕЖДЕНИЕ: Тип ключа подписи идет ПЕРЕД типом криптографического ключа Это неинтуитивно, но сохраняется ради совместимости Порядок: SPKtype, CPKtype (не CPKtype, SPKtype) Структура ключевых данных в KeysAndCert:\n[Crypto Public Key (partial/complete)] [Padding (if total key lengths \u0026lt; 384)] [Signing Public Key (partial/complete)] [Certificate Header (3 bytes)] [Key Certificate (4+ bytes)] [Excess Signing Key Data] [Excess Crypto Key Data] Расчёт избыточных данных ключа:\nЕсли Crypto Key \u0026gt; 256 байт: Excess = (Crypto Length - 256) Если Signing Key \u0026gt; 128 байт: Excess = (Signing Length - 128) Padding (дополнение) = max(0, 384 - Crypto Length - Signing Length) Примеры (криптографический ключ ElGamal):\nSigning Key Type Total SPK Length Padding Excess in Cert Total Structure Size DSA_SHA112800387 + 7 = 394 ECDSA_P25664640387 + 7 = 394 ECDSA_P38496320387 + 7 = 394 ECDSA_P52113204387 + 11 = 398 RSA_20482560128387 + 135 = 522 RSA_40965120384387 + 391 = 778 EdDSA32960387 + 7 = 394 **Требования к Router Identity:** - NULL-сертификат использовался до версии 0.9.15 - Сертификат ключа требуется для нестандартных типов ключей начиная с 0.9.16 - Ключи шифрования X25519 поддерживаются начиная с 0.9.48 Требования к Destination (адрес назначения в I2P): - NULL-сертификат ИЛИ Сертификат ключа (по необходимости) - Сертификат ключа обязателен для типов ключей подписи, отличных от значения по умолчанию, начиная с 0.9.12 - Поле открытого криптографического ключа не используется начиная с 0.6 (2005), но по-прежнему должно присутствовать\nВажные предупреждения:\nСертификат NULL против сертификата KEY:\nСертификат KEY с типами (0,0), указывающими ElGamal+DSA_SHA1, допускается, но не рекомендуется Всегда используйте сертификат NULL для ElGamal+DSA_SHA1 (каноническое представление) Сертификат KEY с (0,0) на 4 байта длиннее и может вызвать проблемы совместимости Некоторые реализации могут некорректно обрабатывать сертификаты KEY с (0,0) Проверка избыточных данных:\nРеализации ДОЛЖНЫ проверять, что длина сертификата соответствует ожидаемой длине для типов ключей Отклонять сертификаты с избыточными данными, не соответствующими типам ключей Не допускать наличия мусорных данных в конце после корректной структуры сертификата JavaDoc: Сертификат Сопоставление Описание: Набор свойств «ключ–значение», используемый для конфигурации и метаданных.\nФормат:\n+----+----+----+----+----+----+----+----+ | size | key_string (len + data)| = | +----+----+----+----+----+----+----+----+ | val_string (len + data) | ; | ... +----+----+----+----+----+----+----+ size :: Integer (2 bytes, big-endian) Total number of bytes that follow (not including size field) Range: 0 to 65535 key_string :: String Format: 1-byte length + UTF-8 data Length: 0-255 bytes = :: Single byte (0x3D, \u0026#39;=\u0026#39; character) val_string :: String Format: 1-byte length + UTF-8 data Length: 0-255 bytes ; :: Single byte (0x3B, \u0026#39;;\u0026#39; character) [Repeat key_string = val_string ; for additional entries] Ограничения по размеру: - Длина ключа: 0-255 байт (+ 1 байт длины) - Длина значения: 0-255 байт (+ 1 байт длины) - Общий размер отображения: 0-65535 байт (+ 2 байта поля размера) - Максимальный размер структуры: 65537 байт\nКритически важное требование к сортировке:\nКогда отображения присутствуют в подписанных структурах (RouterInfo (информация о router), RouterAddress (адрес router), Destination properties (свойства Destination), I2CP SessionConfig (конфигурация сессии I2CP)), записи ДОЛЖНЫ быть отсортированы по ключу для обеспечения инвариантности подписи:\nМетод сортировки: Лексикографическое упорядочивание по значениям кодовых точек Unicode (эквивалентно Java String.compareTo()) Чувствительность к регистру: Ключи и значения, как правило, чувствительны к регистру (зависит от приложения) Повторяющиеся ключи: НЕ допускаются в подписанных структурах (приведёт к ошибке проверки подписи) Кодировка символов: побайтовое сравнение в UTF-8 Почему важна сортировка: - Подписи вычисляются по байтовому представлению - Разный порядок ключей приводит к разным подписям - Для неподписанных отображений сортировка не требуется, но следует придерживаться того же соглашения\nПримечания по реализации:\nИзбыточность кодирования:\nПрисутствуют и разделители = и ;, и байты длины строки Это неэффективно, но сохранено ради совместимости Байты длины имеют приоритет; разделители обязательны, но избыточны Поддержка символов:\nНесмотря на документацию, = и ; ПОДДЕРЖИВАЮТСЯ внутри строк (это обрабатывается байтами длины) Кодировка UTF-8 поддерживает весь Юникод Предупреждение: I2CP использует UTF-8, но I2NP исторически некорректно обрабатывал UTF-8 По возможности используйте ASCII для сопоставлений I2NP ради максимальной совместимости Особые контексты:\nRouterInfo/RouterAddress: ДОЛЖНЫ быть отсортированы, без дубликатов I2CP SessionConfig: ДОЛЖНЫ быть отсортированы, без дубликатов Сопоставления приложений: Сортировка рекомендуется, но не всегда обязательна Пример (параметры RouterInfo):\nMapping size: 45 bytes Sorted entries: caps=L (capabilities) netId=2 (network ID) router.version=0.9.67 JavaDoc: DataHelper Спецификация общей структуры Ключи и сертификат Описание: Базовая структура, объединяющая ключ шифрования, ключ подписи и сертификат. Используется как RouterIdentity, так и Destination.\nСтруктура:\n+----+----+----+----+----+----+----+----+ | public_key | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | padding (optional) | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | signing_key | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | certificate | +----+----+----+-// public_key :: PublicKey (partial or full) Default: 256 bytes (ElGamal) Other sizes: As specified in Key Certificate padding :: Random data Length: 0 bytes or as needed CONSTRAINT: public_key + padding + signing_key = 384 bytes signing_key :: SigningPublicKey (partial or full) Default: 128 bytes (DSA_SHA1) Other sizes: As specified in Key Certificate certificate :: Certificate Minimum: 3 bytes (NULL certificate) Common: 7 bytes (Key Certificate with default keys) TOTAL LENGTH: 387+ bytes (never assume exactly 387!) Выравнивание ключа: - Криптографический открытый ключ: Выровнен в начале (байт 0) - Заполнение: Посередине (при необходимости) - Открытый ключ подписи: Выровнен в конце (с байта 256 по байт 383) - Сертификат: Начинается с байта 384\nРасчёт размера:\nTotal size = 384 + 3 + key_certificate_length For NULL certificate (ElGamal + DSA_SHA1): Total = 384 + 3 = 387 bytes For Key Certificate (EdDSA + X25519): Total = 384 + 3 + 4 = 391 bytes For larger keys (e.g., RSA_4096): Total = 384 + 3 + 4 + excess_key_data_length Рекомендации по генерации заполнения (Предложение 161 ) Версия реализации: 0.9.57 (январь 2023, релиз 2.1.0)\nПредпосылки: - Для ключей, отличных от ElGamal+DSA, дополнение присутствует в 384-байтовой фиксированной структуре - Для Destinations (идентификаторов назначения), поле открытого ключа размером 256 байт не используется с версии 0.6 (2005) - Дополнение должно генерироваться так, чтобы хорошо сжиматься, при этом оставаясь безопасным\nТребования:\nМинимальный объём случайных данных:\nИспользуйте не менее 32 байт криптографически стойких случайных данных Это обеспечивает достаточный уровень энтропии для безопасности Стратегия сжатия:\nПовторяйте эти 32 байта по всему полю заполнения/открытого ключа Протоколы, такие как I2NP Database Store, Streaming SYN, SSU2 handshake, используют сжатие Существенная экономия пропускной способности без ущерба для безопасности Примеры:\nИдентификатор Router (X25519 + EdDSA):\nStructure: - 32 bytes X25519 public key - 320 bytes padding (10 copies of 32-byte random data) - 32 bytes EdDSA public key - 7 bytes Key Certificate Compression savings: ~288 bytes when compressed Destination (адрес назначения в I2P) (ElGamal-unused + EdDSA):\nStructure: - 256 bytes unused ElGamal field (11 copies of 32-byte random data, truncated to 256) - 96 bytes padding (3 copies of 32-byte random data) - 32 bytes EdDSA public key - 7 bytes Key Certificate Compression savings: ~320 bytes when compressed Почему это работает:\nХэш SHA-256 полной структуры по-прежнему содержит всю энтропию Распределение DHT в netDb зависит только от хэша Ключ подписи (32 байта EdDSA/X25519) обеспечивает 256 бит энтропии Дополнительные 32 байта повторяющихся случайных данных = 512 бит суммарной энтропии Более чем достаточно для криптографической стойкости Примечания по реализации:\nОБЯЗАТЕЛЬНО хранить и передавать полную структуру размером 387+ байт Хэш SHA-256 вычисляется по полной несжатой структуре Сжатие применяется на уровне протокола (I2NP, Streaming, SSU2) Обратно совместимо со всеми версиями, начиная с 0.6 (2005) JavaDoc: KeysAndCert RouterIdentity (идентификатор router-а) Описание: Однозначно идентифицирует router в сети I2P. Структура идентична KeysAndCert (ключи и сертификат).\nФормат: См. структуру KeysAndCert выше\nТекущие требования (по состоянию на 0.9.58):\nОбязательные типы ключей:\nШифрование: X25519 (тип 4, 32 байта) Подпись: EdDSA_SHA512_Ed25519 (тип 7, 32 байта) Сертификат: Key Certificate (тип 5) Устаревшие типы ключей:\nElGamal (type 0) помечен как устаревший для Router Identities начиная с 0.9.58 DSA_SHA1 (type 0) помечен как устаревший для Router Identities начиная с 0.9.58 Их НЕ следует использовать для новых routers Типичный размер:\nX25519 + EdDSA с Key Certificate (сертификатом ключа) = 391 байт 32 байта публичного ключа X25519 320 байт заполнения (сжимаемого согласно Proposal 161 ) 32 байта публичного ключа EdDSA 7 байт сертификата (3-байтовый заголовок + 4 байта типов ключей) Историческое развитие: - До 0.9.16: Всегда NULL certificate (нулевой сертификат, тип 0) (ElGamal + DSA_SHA1) - 0.9.16-0.9.47: Добавлена поддержка Key Certificate (сертификата ключа) - 0.9.48+: Поддерживаются ключи шифрования X25519 - 0.9.58+: ElGamal и DSA_SHA1 объявлены устаревшими\nКлюч netDb: - RouterInfo индексируется по SHA-256-хешу полной RouterIdentity - Хеш вычисляется по всей структуре размером 391+ байт (включая padding (заполнение))\nСм. также: - Рекомендации по генерации заполнения (Proposal 161 ) - Спецификация Key Certificate (сертификата ключа) выше\nДокументация Javadoc: RouterIdentity Destination (адрес назначения в I2P) Описание: Идентификатор конечной точки для безопасной доставки сообщений. Структурно идентичен структуре KeysAndCert (ключи и сертификат), но с иной семантикой использования.\nФормат: См. структуру KeysAndCert выше\nКритическое отличие от RouterIdentity (идентификатора маршрутизатора): - Поле открытого ключа НЕ ИСПОЛЬЗУЕТСЯ и может содержать случайные данные - Это поле не используется начиная с версии 0.6 (2005) - Изначально предназначалось для старого шифрования I2CP-to-I2CP (отключено) - В настоящее время используется только как инициализационный вектор для устаревшего шифрования LeaseSet\nТекущие рекомендации:\nКлюч подписи:\nРекомендуется: EdDSA_SHA512_Ed25519 (тип 7, 32 байта) Альтернатива: типы ECDSA для совместимости со старыми версиями Избегайте: DSA_SHA1 (устарело, не рекомендуется) Ключ шифрования:\nПоле не используется, но должно присутствовать Рекомендуется: заполнить случайными данными в соответствии с Предложением 161 (сжимаемыми) Размер: Всегда 256 байт (слот ElGamal, хотя не используется для ElGamal) Сертификат:\nNULL certificate (нулевой сертификат) для ElGamal + DSA_SHA1 (только для устаревшего варианта) Key Certificate (сертификат ключа) для всех остальных типов ключей подписи Типичное современное назначение:\nStructure: - 256 bytes unused field (random data, compressible) - 96 bytes padding (random data, compressible) - 32 bytes EdDSA signing public key - 7 bytes Key Certificate Total: 391 bytes Compression savings: ~320 bytes Фактический ключ шифрования: - Ключ шифрования для Destination (адресата в I2P) находится в LeaseSet, а не в Destination - LeaseSet содержит текущие открытые ключи шифрования - См. спецификацию LeaseSet2 по обработке ключей шифрования\nКлюч сетевой базы данных: - LeaseSet индексируется по хешу SHA-256 от полного Destination (идентификатора назначения в I2P) - Хеш вычисляется по полной структуре размером 387+ байт\nJavaDoc: Destination Структуры сетевой базы данных Lease (запись с информацией о входном туннеле и сроке действия) Описание: Авторизует конкретный tunnel на приём сообщений для Destination (идентификатор назначения в I2P). Часть исходного формата LeaseSet (тип 1).\nФормат:\n+----+----+----+----+----+----+----+----+ | tunnel_gw | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ | tunnel_id | end_date +----+----+----+----+----+----+----+----+ | +----+----+----+----+ tunnel_gw :: Hash (32 bytes) SHA-256 hash of the gateway RouterIdentity tunnel_id :: TunnelId (4 bytes) Tunnel identifier at the gateway router end_date :: Date (8 bytes) Expiration timestamp in milliseconds since epoch Общий размер: 44 байта\nИспользование: - Используется только в оригинальном LeaseSet (тип 1, устаревший) - Для LeaseSet2 и более поздних вариантов вместо этого используйте Lease2\nДокументация JavaDoc: Lease LeaseSet (Тип 1) Описание: Исходный формат LeaseSet. Содержит разрешённые tunnels и ключи для Destination (адрес назначения в I2P). Хранится в базе данных сети (netDb). Статус: Устарело (вместо этого используйте LeaseSet2).\nСтруктура:\n+----+----+----+----+----+----+----+----+ | destination | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | encryption_key | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | signing_key | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | num| Lease 0 | +----+ + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | Lease 1 | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | Lease ($num-1) | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | signature | + + | | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ destination :: Destination Length: 387+ bytes encryption_key :: PublicKey (256 bytes, ElGamal) Used for end-to-end ElGamal/AES+SessionTag encryption Generated anew at each router startup (not persistent) signing_key :: SigningPublicKey (128+ bytes) Same type as Destination signing key Used for LeaseSet revocation (unimplemented) Generated anew at each router startup (not persistent) num :: Integer (1 byte) Number of Leases to follow Range: 0-16 leases :: Array of Lease structures Length: $num × 44 bytes Each Lease is 44 bytes signature :: Signature (40+ bytes) Length determined by Destination signing key type Signed by Destination\u0026#39;s SigningPrivateKey Хранение базы данных: - Тип базы данных: 1 - Ключ: хеш SHA-256 от Destination (идентификатор назначения) - Значение: полная структура LeaseSet\nВажные примечания:\nОткрытый ключ Destination (идентификатор назначения в I2P) не используется:\nПоле открытого ключа шифрования в Destination не используется Ключ шифрования в LeaseSet является фактическим ключом шифрования Временные ключи:\nencryption_key временный (генерируется заново при запуске router) signing_key временный (генерируется заново при запуске router) Ни один из ключей не сохраняется между перезапусками Отзыв (не реализовано):\nsigning_key предназначался для отзыва LeaseSet Механизм отзыва так и не был реализован LeaseSet с нулевым числом записей был задуман для отзыва, но не используется Версионирование/Временная метка:\nВ LeaseSet нет явного поля метки времени published Версия — это самый ранний срок истечения всех leases (элементов LeaseSet с указанием шлюза tunnel и времени истечения) Новый LeaseSet принимается только если срок истечения lease более ранний Публикация сроков действия lease (запись в leaseSet):\nДо 0.9.7: Все lease публиковались с одинаковым сроком действия (самым ранним) С 0.9.7+: Публикуются фактические сроки действия отдельных lease Это деталь реализации, не часть спецификации Нулевое количество leases:\nLeaseSet с нулём leases технически допустим Предназначен для отзыва (не реализовано) На практике не используется Варианты LeaseSet2 требуют как минимум один Lease (арендная запись в I2P) Устарело: LeaseSet типа 1 устарел. Новые реализации должны использовать LeaseSet2 (тип 3), который обеспечивает: - Поле метки времени публикации (лучшее версионирование) - Поддержку нескольких ключей шифрования - Возможность офлайн-подписи - 4-байтовые сроки истечения элементов LeaseSet (вместо 8-байтовых) - Более гибкие параметры\nJavaDoc: LeaseSet Варианты LeaseSet Lease2 (вторая версия записи Lease в составе LeaseSet) Описание: Улучшенный формат Lease (элемент LeaseSet) с 4-байтовым сроком действия. Используется в LeaseSet2 (тип 3) и MetaLeaseSet (тип 7).\nВведение: Версия 0.9.38 (см. Предложение 123 )\nФормат:\n+----+----+----+----+----+----+----+----+ | tunnel_gw | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ | tunnel_id | end_date | +----+----+----+----+----+----+----+----+ tunnel_gw :: Hash (32 bytes) SHA-256 hash of gateway RouterIdentity tunnel_id :: TunnelId (4 bytes) Tunnel identifier at gateway end_date :: 4-byte timestamp (seconds since epoch) Rolls over in year 2106 Общий размер: 40 байт (на 4 байта меньше, чем исходный Lease (запись в leaseSet))\nСравнение с исходным Lease (элементом leaseSet с параметрами входящего tunnel):\nFeature Lease (Type\u0026nbsp;1) Lease2 (Type\u0026nbsp;3+) Size44 bytes40 bytes Expiration Size8 bytes (ms)4 bytes (seconds) PrecisionMillisecondSecond RolloverYear\u0026nbsp;292,277,026,596Year\u0026nbsp;2106 Used InLeaseSet (deprecated)LeaseSet2, MetaLeaseSet **Документация JavaDoc:** [Lease2](http://docs.i2p-projekt.de/javadoc/net/i2p/data/Lease2.html) Офлайновая подпись Описание: Необязательная структура для предварительно подписанных временных ключей, позволяющая публиковать LeaseSet без онлайн-доступа к закрытому ключу подписи Destination (криптографическая идентичность/адрес в I2P).\nВведение: Версия 0.9.38 (см. Предложение 123 )\nФормат:\n+----+----+----+----+----+----+----+----+ | expires | sigtype | | +----+----+----+----+----+----+ + | transient_public_key | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | signature | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ expires :: 4-byte timestamp (seconds since epoch) Expiration of transient key validity Rolls over in year 2106 sigtype :: 2-byte signature type Type of transient_public_key (see SigningPublicKey types) transient_public_key :: SigningPublicKey Length determined by sigtype Temporary signing key for LeaseSet signature :: Signature Length determined by Destination\u0026#39;s signing key type Signature of (expires || sigtype || transient_public_key) Signed by Destination\u0026#39;s permanent SigningPrivateKey Назначение: - Позволяет создавать LeaseSet офлайн - Защищает основной ключ назначения от онлайн-раскрытия - Временный ключ может быть отозван путём публикации нового LeaseSet без офлайн-подписи\nСценарии использования:\nНазначения повышенной безопасности:\nМастер-ключ подписи хранится офлайн (HSM (аппаратный модуль безопасности), холодное хранение) Временные ключи генерируются офлайн на ограничённые промежутки времени Скомпрометированный временный ключ не раскрывает мастер-ключ Публикация зашифрованного LeaseSet:\nEncryptedLeaseSet может включать офлайн-подпись Ослеплённый публичный ключ + офлайн-подпись обеспечивают дополнительную безопасность Соображения безопасности:\nУправление сроком действия:\nУстанавливайте разумный срок действия (от нескольких дней до нескольких недель, а не лет) Генерируйте новые временные ключи до истечения срока действия Более короткий срок действия = выше безопасность, больше обслуживания Генерация ключей:\nГенерируйте временные ключи офлайн в защищённой среде Подпишите их мастер-ключом офлайн Передайте на онлайн router только подписанный временный ключ + подпись Отзыв:\nОпубликовать новый LeaseSet без офлайн-подписи для неявного отзыва Или опубликовать новый LeaseSet с другим временным ключом Проверка подписи:\nData to sign: expires (4 bytes) || sigtype (2 bytes) || transient_public_key Verification: 1. Extract Destination from LeaseSet 2. Get Destination\u0026#39;s SigningPublicKey 3. Verify signature over (expires || sigtype || transient_public_key) 4. Check that current time \u0026lt; expires 5. If valid, use transient_public_key to verify LeaseSet signature Примечания по реализации: - Общий размер зависит от sigtype и типа ключа подписи Destination (идентификатора получателя в I2P) - Минимальный размер: 4 + 2 + 32 (ключ EdDSA) + 64 (подпись EdDSA) = 102 байта - Максимальный практический размер: ~600 байт (временный ключ RSA-4096 + подпись RSA-4096)\nСовместимо с: - LeaseSet2 (тип 3) - EncryptedLeaseSet (тип 5) - MetaLeaseSet (тип 7)\nСм. также: Предложение 123 с подробным описанием протокола офлайн-подписи.\nLeaseSet2Header Описание: Общая структура заголовка для LeaseSet2 (тип 3) и MetaLeaseSet (тип 7).\nВведение: Версия 0.9.38 (см. Предложение 123 )\nФормат:\n+----+----+----+----+----+----+----+----+ | destination | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | published | expires | flags | +----+----+----+----+----+----+----+----+ | offline_signature (optional) | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ destination :: Destination Length: 387+ bytes published :: 4-byte timestamp (seconds since epoch) Publication time of this LeaseSet Rolls over in year 2106 expires :: 2-byte offset (seconds) Offset from published timestamp Maximum: 65535 seconds (18.2 hours) flags :: 2 bytes (bit flags) See flag definitions below offline_signature :: OfflineSignature (optional) Present only if flags bit 0 is set Variable length Минимальный общий размер: 395 байт (без офлайн-подписи)\nОпределения флагов (порядок битов: 15 14 \u0026hellip; 3 2 1 0):\nBit Name Description 0Offline Keys0 = No offline keys, 1 = Offline signature present 1Unpublished0 = Standard published, 1 = Unpublished (client-side only) 2Blinded0 = Standard, 1 = Will be blinded when published 3-15ReservedMust be 0 for compatibility **Подробности флага:** Бит 0 - Offline Keys (офлайн-ключи): - 0: Нет офлайновой подписи, используется ключ подписи Destination (идентификатор назначения в I2P) для проверки подписи LeaseSet - 1: Структура OfflineSignature (офлайновой подписи) следует сразу после поля flags\nБит 1 - Неопубликовано: - 0: Стандартный опубликованный LeaseSet, должен быть распространён на floodfills - 1: Неопубликованный LeaseSet (только на стороне клиента) - НЕ должен распространяться, публиковаться или отправляться в ответ на запросы - Если истёк срок действия, НЕ запрашивать в netdb замену (если также установлен бит 2) - Используется для локальных tunnels или тестирования\nБит 2 - Blinded (ослепление) (начиная с 0.9.42): - 0: Стандартный LeaseSet - 1: Этот нешифрованный LeaseSet будет ослеплён и зашифрован при публикации - Опубликованная версия будет EncryptedLeaseSet (тип 5) - Если истёк срок действия, запросите ослеплённое местоположение в netdb для замены - Также необходимо установить бит 1 в 1 (неопубликован + ослеплён) - Используется для зашифрованных скрытых сервисов\nОграничения срока действия:\nLeaseSet Type Maximum Expires Value Maximum Actual Time LeaseSet2 (type 3)≈660 seconds≈11 minutes MetaLeaseSet (type 7)65,535 seconds≈18.2 hours **Требования к временной метке публикации:** LeaseSet (тип 1) не имел поля published, что для версионирования требовало поиска самого раннего истечения срока действия lease (запись о tunnel с временем истечения). LeaseSet2 добавляет явную метку времени published с точностью до одной секунды.\nКритически важное замечание по реализации: - Routers ДОЛЖНЫ ограничивать частоту публикации LeaseSet до уровня значительно реже, чем один раз в секунду для каждого Destination - Если публикация происходит чаще, убедитесь, что каждый новый LeaseSet имеет время published как минимум на 1 секунду позже - Floodfills отклонят LeaseSet, если время published не новее текущей версии - Рекомендуемый минимальный интервал: 10-60 секунд между публикациями\nПримеры расчётов:\nLeaseSet2 (максимум 11 минут):\npublished = 1704067200 (2024-01-01 00:00:00 UTC) expires = 660 (seconds) Actual expiration = 1704067200 + 660 = 1704067860 (2024-01-01 00:11:00 UTC) MetaLeaseSet (максимум 18,2 часа):\npublished = 1704067200 (2024-01-01 00:00:00 UTC) expires = 65535 (seconds) Actual expiration = 1704067200 + 65535 = 1704132735 (2024-01-01 18:12:15 UTC) Версионирование: - LeaseSet считается \u0026ldquo;более новым\u0026rdquo;, если метка времени published больше - Floodfills хранят и распространяют только самую новую версию - Будьте внимательны, когда самый старый Lease (запись аренды туннеля) совпадает с самым старым Lease предыдущего LeaseSet\nLeaseSet2 (Тип 3) Описание: Современный формат LeaseSet с несколькими ключами шифрования, офлайн-подписями и service records (записями сервиса). Текущий стандарт для скрытых сервисов I2P.\nВведение: Версия 0.9.38 (см. Предложение 123 )\nСтруктура:\n+----+----+----+----+----+----+----+----+ | ls2_header | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | options | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ |numk| keytype0| keylen0 | | +----+----+----+----+----+ + | encryption_key_0 | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | keytypen| keylenn | | +----+----+----+----+ + | encryption_key_n | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | num| Lease2 0 | +----+ + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | Lease2($num-1) | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | signature | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ ls2header :: LeaseSet2Header Length: 395+ bytes (varies with offline signature) options :: Mapping Key-value pairs for service records and metadata Length: 2+ bytes (size field + data) numk :: Integer (1 byte) Number of encryption keys Range: 1 to (implementation-defined maximum, typically 8) keytype :: 2-byte encryption type See PublicKey type table keylen :: 2-byte key length Must match keytype specification encryption_key :: PublicKey Length: keylen bytes Type: keytype [Repeat keytype/keylen/encryption_key for each key] num :: Integer (1 byte) Number of Lease2s Range: 1-16 (at least one required) leases :: Array of Lease2 structures Length: $num × 40 bytes signature :: Signature Length determined by signing key type Signed over entire structure including database type prefix Хранилище базы данных: - Тип базы данных: 3 - Ключ: хэш SHA-256 от назначения - Значение: Полная структура LeaseSet2\nВычисление подписи:\nData to sign: database_type (1 byte, value=3) || complete LeaseSet2 data Verification: 1. Prepend database type byte (0x03) to LeaseSet2 data 2. If offline signature present: - Verify offline signature against Destination key - Verify LeaseSet2 signature against transient key 3. Else: - Verify LeaseSet2 signature against Destination key Порядок предпочтения ключей шифрования Для опубликованного (серверного) LeaseSet: - Ключи перечислены в порядке предпочтений сервера (наиболее предпочтительные — первыми) - Клиенты, поддерживающие несколько типов, ДОЛЖНЫ соблюдать предпочтения сервера - Выберите первый поддерживаемый тип из списка - В общем случае типы ключей с более высоким номером (более новые) более безопасны/эффективны - Рекомендуемый порядок: перечисляйте ключи в обратном порядке по коду типа (новейшие первыми)\nПример настройки сервера:\nnumk = 2 Key 0: X25519 (type 4, 32 bytes) [Most preferred] Key 1: ElGamal (type 0, 256 bytes) [Legacy compatibility] Для неопубликованного (клиентского) LeaseSet: - Порядок ключей по сути не имеет значения (попытки соединения с клиентами редки) - Для единообразия придерживайтесь той же конвенции\nВыбор клиентского ключа: - Учитывать предпочтение сервера (выбрать первый поддерживаемый тип) - Или использовать предпочтение, определённое реализацией - Или определить комбинированное предпочтение на основе возможностей обеих сторон\nСопоставление параметров Требования: - Параметры ДОЛЖНЫ быть отсортированы по ключу (лексикографический порядок, порядок байтов UTF-8) - Сортировка обеспечивает инвариантность подписи - Дублирующиеся ключи НЕ допускаются\nСтандартный формат (Предложение 167 ):\nНачиная с API 0.9.66 (июнь 2025, релиз 2.9.0), параметры сервисных записей соответствуют стандартизированному формату. См. Proposal 167 для полной спецификации.\nФормат опции записи службы:\nKey: _service._proto Value: record_type ttl [priority weight] port target [appoptions] service :: Symbolic name of service (lowercase, [a-z0-9-]) Examples: smtp, http, irc, mumble Use standard identifiers from IANA Service Name Registry or Linux /etc/services when available proto :: Transport protocol (lowercase, [a-z0-9-]) \u0026#34;tcp\u0026#34; = streaming protocol \u0026#34;udp\u0026#34; = repliable datagrams Protocol indicators for raw datagrams may be defined later record_type :: \u0026#34;0\u0026#34; (self-reference) or \u0026#34;1\u0026#34; (SRV record) ttl :: Time to live in seconds (positive integer) Recommended minimum: 86400 (one day) Prevents frequent re-queries For record_type = 0 (self-reference): port :: I2CP port number (non-negative integer) appoptions :: Optional application-specific data (no spaces or commas) For record_type = 1 (SRV record): priority :: Lower value = more preferred (non-negative integer) weight :: Relative weight for same priority, higher = more likely (non-negative) port :: I2CP port number (non-negative integer) target :: Hostname or b32 of destination (lowercase) Format: \u0026#34;example.i2p\u0026#34; or \u0026#34;aaaaa...aaaa.b32.i2p\u0026#34; Recommend b32 unless hostname is \u0026#34;well known\u0026#34; appoptions :: Optional application-specific data (no spaces or commas) Примеры записей службы:\n1. Самореферентный SMTP-сервер:\nDestination: aaaa...aaaa.b32.i2p (this LeaseSet) Option: \u0026#34;_smtp._tcp\u0026#34; = \u0026#34;0 999999 25\u0026#34; Meaning: This destination provides SMTP service on I2CP port 25 2. Один внешний SMTP-сервер:\nDestination: aaaa...aaaa.b32.i2p (this LeaseSet) Option: \u0026#34;_smtp._tcp\u0026#34; = \u0026#34;1 86400 0 0 25 bbbb...bbbb.b32.i2p\u0026#34; Meaning: SMTP service provided by bbbb...bbbb on port 25 TTL = 1 day, single server (priority=0, weight=0) 3. Несколько SMTP-серверов (балансировка нагрузки):\nDestination: aaaa...aaaa.b32.i2p (this LeaseSet) Option: \u0026#34;_smtp._tcp\u0026#34; = \u0026#34;1 86400 0 0 25 bbbb...bbbb.b32.i2p,1 86400 1 0 25 cccc...cccc.b32.i2p\u0026#34; Meaning: Two SMTP servers bbbb...bbbb (priority=0, preferred) cccc...cccc (priority=1, backup) 4. Служба HTTP с параметрами приложения:\nOption: \u0026#34;_http._tcp\u0026#34; = \u0026#34;0 86400 80 tls=1.3;cert=ed25519\u0026#34; Meaning: HTTP on port 80 with TLS 1.3 and EdDSA certificates Рекомендации по TTL: - Минимум: 86400 секунд (1 день) - Более длительный TTL снижает нагрузку на netdb от запросов - Баланс между сокращением числа запросов и распространением обновлений сервиса - Для стабильных сервисов: 604800 (7 дней) или дольше\nПримечания по реализации:\nКлючи шифрования (по состоянию на 0.9.44):\nElGamal (тип 0, 256 байт): совместимость со старыми версиями X25519 (тип 4, 32 байта): текущий стандарт Варианты MLKEM (Module-Lattice Key Encapsulation Mechanism — постквантовый механизм инкапсуляции ключей): постквантовые (бета, не финализированы) Проверка длины ключа:\nFloodfills и клиенты ДОЛЖНЫ уметь разбирать неизвестные типы ключей Используйте поле keylen, чтобы пропускать неизвестные ключи Не завершайте разбор с ошибкой, если тип ключа неизвестен Отметка времени публикации:\nСм. примечания к LeaseSet2Header об ограничении частоты Минимальный интервал между публикациями — 1 секунда Рекомендуется: 10–60 секунд между публикациями Миграция типа шифрования:\nПоддержка нескольких ключей обеспечивает постепенную миграцию Указывайте старые и новые ключи в переходный период Удалите старый ключ после того, как пройдет достаточный период для обновления клиентов JavaDoc: LeaseSet2 MetaLease (метаданные Lease в I2P) Описание: Структура Lease для MetaLeaseSet (вариант LeaseSet), способного ссылаться на другие LeaseSets вместо tunnels. Используется для балансировки нагрузки и избыточности.\nВведение: Версия 0.9.38, запланировано к внедрению в 0.9.40 (см. Предложение 123 )\nФормат:\n+----+----+----+----+----+----+----+----+ | tunnel_gw | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ | flags |cost| end_date | +----+----+----+----+----+----+----+----+ tunnel_gw :: Hash (32 bytes) SHA-256 hash of: - Gateway RouterIdentity (for type 1), OR - Another MetaLeaseSet destination (for type 3/5/7) flags :: 3 bytes Bit order: 23 22 ... 3 2 1 0 Bits 3-0: Entry type (see table below) Bits 23-4: Reserved (must be 0) cost :: 1 byte (0-255) Lower value = higher priority Used for load balancing end_date :: 4-byte timestamp (seconds since epoch) Expiration time Rolls over in year 2106 Общий размер: 40 байт\nТип записи (биты flags 3-0):\nType Code Description Unknown0Unknown/invalid entry LeaseSet1Points to LeaseSet (type 1, deprecated) LeaseSet23Points to LeaseSet2 (type 3) EncryptedLeaseSet5Points to EncryptedLeaseSet (type 5) MetaLeaseSet7Points to another MetaLeaseSet (type 7) **Сценарии использования:** Балансировка нагрузки:\nMetaLeaseSet (структура для балансировки, содержащая несколько записей MetaLease (мета-запись)) Каждая запись указывает на свой LeaseSet2 (расширенная версия LeaseSet в I2P) Клиенты выбирают на основе поля cost Избыточность:\nНесколько записей, указывающих на резервные LeaseSets Резервный вариант при недоступности основного LeaseSet Миграция сервиса:\nMetaLeaseSet (специальная структура, указывающая на LeaseSet в I2P) ссылается на новый LeaseSet Обеспечивает плавный переход между Destinations (идентификаторами назначения в I2P) Использование поля Cost: - Меньшее значение Cost = более высокий приоритет - Cost 0 = наивысший приоритет - Cost 255 = самый низкий приоритет - Клиенты ДОЛЖНЫ предпочитать записи с более низким значением Cost - Записи с одинаковым значением Cost могут балансироваться по нагрузке случайным образом\nСравнение с Lease2:\nFeature Lease2 MetaLease Size40 bytes40 bytes Tunnel ID4 bytesReplaced by flags (3 bytes) + cost (1 byte) Points ToSpecific tunnelLeaseSet or MetaLeaseSet UsageDirect tunnel referenceIndirection/load balancing **JavaDoc:** [MetaLease](http://docs.i2p-projekt.de/javadoc/net/i2p/data/MetaLease.html) MetaLeaseSet (Тип 7) Описание: Вариант LeaseSet, содержащий записи MetaLease (тип записи, указывающей на другие LeaseSets), обеспечивающие косвенное обращение к другим LeaseSets. Используется для балансировки нагрузки, избыточности и миграции сервиса.\nВведение: Определено в 0.9.38, запланировано к работе в 0.9.40 (см. Предложение 123 )\nСтатус: Спецификация завершена. Статус боевого развертывания следует проверить по текущим релизам I2P.\nСтруктура:\n+----+----+----+----+----+----+----+----+ | ls2_header | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | options | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | num| MetaLease 0 | +----+ + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | MetaLease($num-1) | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ |numr| | +----+ + | revocation_0 | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | revocation_n | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | signature | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ ls2header :: LeaseSet2Header Length: 395+ bytes options :: Mapping Length: 2+ bytes (size + data) MUST be sorted by key num :: Integer (1 byte) Number of MetaLease entries Range: 1 to (implementation-defined, recommend 1-16) metaleases :: Array of MetaLease structures Length: $num × 40 bytes numr :: Integer (1 byte) Number of revocation hashes Range: 0 to (implementation-defined, recommend 0-16) revocations :: Array of Hash structures Length: $numr × 32 bytes SHA-256 hashes of revoked LeaseSet Destinations Хранилище базы данных: - Тип базы данных: 7 - Ключ: SHA-256-хеш от Destination (идентификатор назначения в I2P) - Значение: Полная структура MetaLeaseSet (расширенная структура leaseSet)\nВычисление подписи:\nData to sign: database_type (1 byte, value=7) || complete MetaLeaseSet data Verification: 1. Prepend database type byte (0x07) to MetaLeaseSet data 2. If offline signature present in header: - Verify offline signature against Destination key - Verify MetaLeaseSet signature against transient key 3. Else: - Verify MetaLeaseSet signature against Destination key Сценарии использования:\n1. Балансировка нагрузки:\nMetaLeaseSet for primary.i2p: MetaLease 0: cost=0, points to server1.i2p LeaseSet2 MetaLease 1: cost=0, points to server2.i2p LeaseSet2 MetaLease 2: cost=0, points to server3.i2p LeaseSet2 Clients randomly select among equal-cost entries 2. Аварийное переключение:\nMetaLeaseSet for service.i2p: MetaLease 0: cost=0, points to primary.i2p LeaseSet2 MetaLease 1: cost=100, points to backup.i2p LeaseSet2 Clients prefer cost=0 (primary), fall back to cost=100 (backup) 3. Миграция сервиса:\nMetaLeaseSet for old-domain.i2p: MetaLease 0: cost=0, points to new-domain.i2p LeaseSet2 Transparently redirects clients from old to new destination 4. Многоуровневая архитектура:\nMetaLeaseSet for service.i2p: MetaLease 0: cost=0, points to region1-meta.i2p (another MetaLeaseSet) MetaLease 1: cost=0, points to region2-meta.i2p (another MetaLeaseSet) Each region MetaLeaseSet points to regional servers Allows hierarchical load balancing Список отзыва:\nСписок отзыва позволяет MetaLeaseSet (мета-структура LeaseSet) явно отзывать ранее опубликованные LeaseSets:\nНазначение: Пометить конкретные Destination (адрес назначения в I2P) как недействительными Содержимое: Хэши SHA-256 отозванных структур Destination Использование: Клиенты НЕ ДОЛЖНЫ использовать LeaseSets, хэш Destination которых присутствует в списке отзыва Типичное значение: Пусто (numr=0) в большинстве развёртываний Пример отзыва:\nService migrates from dest-v1.i2p to dest-v2.i2p: MetaLease 0: points to dest-v2.i2p Revocations: [hash(dest-v1.i2p)] Clients will use v2 and ignore v1 even if cached Обработка истечения срока действия:\nMetaLeaseSet использует LeaseSet2Header с максимальным значением expires=65535 секунд (~18.2 часа):\nГораздо дольше, чем LeaseSet2 (макс. ~11 минут) Подходит для относительно статической косвенной адресации LeaseSets, на которые ссылаются, могут иметь более короткий срок действия Клиенты должны проверять срок действия как MetaLeaseSet, так и LeaseSets, на которые он ссылается Сопоставление параметров:\nИспользуйте тот же формат, что и у параметров LeaseSet2 Может включать записи сервиса (Предложение 167 ) ДОЛЖНЫ быть отсортированы по ключу Записи сервиса обычно описывают конечный сервис, а не структуру косвенной адресации Примечания по реализации клиента:\nПроцесс разрешения:\n1. Query netdb for MetaLeaseSet using SHA-256(Destination) 2. Parse MetaLeaseSet, extract MetaLease entries 3. Sort entries by cost (lower = better) 4. For each entry in cost order: a. Extract LeaseSet hash from tunnel_gw field b. Determine entry type from flags c. Query netdb for referenced LeaseSet (may be another MetaLeaseSet) d. Check revocation list e. Check expiration f. If valid, use the LeaseSet; else try next entry Кэширование:\nКэшируйте как MetaLeaseSet, так и ссылочные LeaseSets Проверяйте истечение срока действия на обоих уровнях Отслеживайте публикацию обновлённого MetaLeaseSet Переключение при отказе (failover):\nЕсли предпочитаемая запись отказала, попробуйте запись со следующей наименьшей стоимостью Рассмотрите возможность помечать отказавшие записи как временно недоступные Периодически перепроверяйте на предмет восстановления Статус реализации:\nПредложение 123 отмечает, что некоторые разделы остаются «в разработке». Реализаторам следует: - Проверить готовность к промышленной эксплуатации в целевой версии I2P - Протестировать поддержку MetaLeaseSet (мета-тип записи leaseSet) перед развертыванием - Проверить наличие обновленных спецификаций в более новых релизах I2P\nДокументация JavaDoc: MetaLeaseSet EncryptedLeaseSet (Тип 5) Описание: Зашифрованный и ослеплённый LeaseSet для повышенной конфиденциальности. Видны только ослеплённый открытый ключ и метаданные; реальные leases (записи Lease) и ключи шифрования зашифрованы.\nВведение: Определено в 0.9.38, работает в 0.9.39 (см. Предложение 123 )\nСтруктура:\n+----+----+----+----+----+----+----+----+ | sigtype | | +----+----+ + | blinded_public_key | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | published | expires | flags | +----+----+----+----+----+----+----+----+ | offline_signature (optional) | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | len | | +----+----+ + | encrypted_data | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | signature | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ sigtype :: 2-byte signature type Type of blinded_public_key MUST be RedDSA_SHA512_Ed25519 (type 11) blinded_public_key :: SigningPublicKey (32 bytes for RedDSA) Blinded version of Destination signing key Used to verify signature on EncryptedLeaseSet published :: 4-byte timestamp (seconds since epoch) Publication time Rolls over in year 2106 expires :: 2-byte offset (seconds) Offset from published Maximum: 65535 seconds (18.2 hours) Practical maximum for LeaseSet data: ~660 seconds (~11 min) flags :: 2 bytes Bit 0: Offline signature present (0=no, 1=yes) Bit 1: Unpublished (0=published, 1=client-side only) Bits 15-2: Reserved (must be 0) offline_signature :: OfflineSignature (optional) Present only if flags bit 0 = 1 Variable length len :: 2-byte integer Length of encrypted_data Range: 1 to 65535 encrypted_data :: Encrypted payload Length: len bytes Contains encrypted LeaseSet2 or MetaLeaseSet signature :: Signature (64 bytes for RedDSA) Length determined by sigtype Signed by blinded_public_key or transient key Хранение в базе данных: - Тип базы данных: 5 - Ключ: хеш SHA-256 от ослеплённого Destination (не исходного Destination — идентификатор сервиса в I2P) - Значение: Полная структура EncryptedLeaseSet\nПринципиальные отличия от LeaseSet2:\nНЕ использует структуру LeaseSet2Header (имеет схожие поля, но иной формат) Ослеплённый открытый ключ вместо полного Destination (адрес назначения в I2P) Зашифрованная полезная нагрузка вместо leases и ключей в открытом виде Ключ базы данных — хеш ослеплённого Destination, а не исходного Destination Вычисление подписи:\nData to sign: database_type (1 byte, value=5) || complete EncryptedLeaseSet data Verification: 1. Prepend database type byte (0x05) to EncryptedLeaseSet data 2. If offline signature present (flags bit 0 = 1): - Verify offline signature against blinded public key - Verify EncryptedLeaseSet signature against transient key 3. Else: - Verify EncryptedLeaseSet signature against blinded public key Требование к типу подписи:\nОБЯЗАТЕЛЬНО использовать RedDSA_SHA512_Ed25519 (схема подписи RedDSA на Ed25519 с SHA-512; type 11): - 32-байтные ослеплённые открытые ключи - 64-байтные подписи - Требуется для обеспечения свойств безопасности ослепления - См. [спецификацию Red25519](//docs/specs/red25519-signature-scheme/\nКлючевые отличия от EdDSA: - Закрытые ключи получаются посредством модульного приведения (не clamping — фиксация некоторых битов) - Подписи включают 80 байт случайных данных - Напрямую используются открытые ключи (не хэши) - Обеспечивает безопасную операцию ослепления\nОслепление и шифрование:\nПодробности см. в спецификации EncryptedLeaseSet :\n1. Ослепление ключа:\nBlinding process (daily rotation): secret = HKDF(original_signing_private_key, date_string, \u0026#34;i2pblinding1\u0026#34;) alpha = SHA-256(secret) mod L (where L is Ed25519 group order) blinded_private_key = alpha * original_private_key blinded_public_key = alpha * original_public_key 2. Расположение базы данных:\nClient publishes to: Key = SHA-256(blinded_destination) Where blinded_destination uses: - Blinded public key (signing key) - Same unused public key field (random) - Same certificate structure 3. Слои шифрования (трёхслойные):\nУровень 1 - слой аутентификации (доступ клиентов): - Шифрование: поточный шифр ChaCha20 - Деривация ключей: HKDF с секретами для каждого клиента - Аутентифицированные клиенты могут расшифровать внешний слой\nСлой 2 - уровень шифрования: - Шифрование: ChaCha20 - Ключ: выведен из DH (Диффи—Хеллман) между клиентом и сервером - Содержит сам LeaseSet2 или MetaLeaseSet\nСлой 3 - Внутренний LeaseSet (набор записей о входящих tunnels и ключах в I2P): - Полный LeaseSet2 или MetaLeaseSet - Включает все tunnels, ключи шифрования, параметры - Доступен только после успешной расшифровки\nВыработка ключа шифрования:\nClient has: ephemeral_client_private_key Server has: ephemeral_server_public_key (in encrypted_data) Shared secret = X25519(client_private, server_public) Encryption key = HKDF(shared_secret, context_info, \u0026#34;i2pblinding2\u0026#34;) Процесс обнаружения:\nДля авторизованных клиентов:\n1. Client knows original Destination 2. Client computes current blinded Destination (based on current date) 3. Client computes database key: SHA-256(blinded_destination) 4. Client queries netdb for EncryptedLeaseSet using blinded key 5. Client decrypts layer 1 using authorization credentials 6. Client decrypts layer 2 using DH shared secret 7. Client extracts inner LeaseSet2/MetaLeaseSet 8. Client uses tunnels from inner LeaseSet for communication Для неавторизованных клиентов: - Не могут расшифровать, даже если обнаружат EncryptedLeaseSet - Не могут определить исходный Destination (адрес назначения в I2P) из ослеплённой версии - Не могут сопоставить EncryptedLeaseSets между различными периодами ослепления (ежедневная ротация)\nСроки действия:\nContent Type Maximum Expires Notes EncryptedLeaseSet (outer)65,535 sec (≈18.2 hr)Full 2-byte expires field Inner LeaseSet2≈660 sec (≈11 min)Actual lease data practical maximum Inner MetaLeaseSet65,535 sec (≈18.2 hr)Indirection can be longer-lived **Метка времени публикации:** Те же требования, что и у LeaseSet2Header:\nДолжно увеличиваться минимум на 1 секунду между публикациями Floodfills отклоняют, если не новее текущей версии Рекомендуется: 10–60 секунд между публикациями Подписи в автономном режиме с зашифрованными LeaseSets:\nОсобые соображения при использовании офлайн-подписей: - Ослеплённый открытый ключ обновляется ежедневно - Офлайн-подпись должна ежедневно пересоздаваться с новым ослеплённым ключом - ИЛИ используйте офлайн-подпись во внутреннем LeaseSet (набор сведений для связи с сервисом в I2P), а не во внешнем EncryptedLeaseSet (зашифрованный LeaseSet) - См. примечания к Предложению 123 Примечания по реализации:\nАвторизация клиентов:\nМожно авторизовать нескольких клиентов с разными ключами У каждого авторизованного клиента есть уникальные учетные данные для расшифрования Отозвать клиента можно, изменив ключи авторизации Ежедневная ротация ключей:\nBlinded keys (ослеплённые ключи) меняются в полночь по UTC Клиенты должны ежедневно пересчитывать blinded Destination (адрес назначения в I2P) Старые EncryptedLeaseSets (зашифрованные leaseSet в I2P) становятся недоступными для обнаружения после ротации Свойства конфиденциальности:\nУзлы floodfill не могут определить исходный Destination (идентификатор назначения в I2P) Неавторизованные клиенты не могут получить доступ к сервису Разные периоды blinding (ослепления) не могут быть связаны между собой Отсутствуют метаданные в открытом виде, кроме сроков истечения Производительность:\nКлиенты должны выполнять ежедневное вычисление ослепления Трёхслойное шифрование добавляет вычислительные накладные расходы Рассмотрите кэширование расшифрованного внутреннего LeaseSet Соображения безопасности:\nУправление ключами авторизации:\nБезопасно распространяйте клиентские учетные данные авторизации Используйте уникальные учетные данные для каждого клиента для избирательного отзыва Периодически обновляйте (ротируйте) ключи авторизации Синхронизация времени:\nЕжедневное blinding (ослепление) зависит от синхронизированных дат UTC Смещение часов может приводить к ошибкам при поиске Рассмотрите поддержку blinding за предыдущий/следующий день для повышения устойчивости к смещению часов Утечка метаданных:\nПоля Published и expires передаются в открытом виде Анализ закономерностей может раскрыть характеристики сервиса Если есть опасения, варьируйте интервалы публикации случайным образом JavaDoc: EncryptedLeaseSet Структуры Router RouterAddress (адрес Router) Описание: Определяет информацию о подключении для router по конкретному транспортному протоколу.\nФормат:\n+----+----+----+----+----+----+----+----+ |cost| expiration +----+----+----+----+----+----+----+----+ | transport_style | +----+----+----+----+-//-+----+----+----+ | | + + | options | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ cost :: Integer (1 byte) Relative cost, 0=free, 255=expensive Typical values: 5-6: SSU2 10-11: NTCP2 expiration :: Date (8 bytes) MUST BE ALL ZEROS (see critical note below) transport_style :: String (1-256 bytes) Transport protocol name Current values: \u0026#34;SSU2\u0026#34;, \u0026#34;NTCP2\u0026#34; Legacy: \u0026#34;SSU\u0026#34;, \u0026#34;NTCP\u0026#34; (removed) options :: Mapping Transport-specific configuration Common options: \u0026#34;host\u0026#34;, \u0026#34;port\u0026#34; Transport-specific options vary КРИТИЧЕСКОЕ - Поле срока действия:\n⚠️ Поле срока действия ДОЛЖНО быть установлено во все нули (8 нулевых байт).\nПричина: Начиная с версии 0.9.3, ненулевое значение Expiration (поле срока действия) приводит к сбою проверки подписи История: Expiration изначально не использовалось, всегда было null Текущее состояние: Поле снова стало распознаваться начиная с 0.9.12, но требуется дождаться обновления сети Реализация: Всегда устанавливается в 0x0000000000000000 Любое ненулевое значение срока действия приведёт к тому, что подпись RouterInfo не пройдёт проверку.\nТранспортные протоколы Текущие протоколы (по состоянию на 2.10.0):\nProtocol Status Introduced Removed Notes SSU2Current0.9.54 (May 2022)-Default since 0.9.56 NTCP2Current0.9.36 (Aug 2018)-Active NTCPRemoved-0.9.50 (May 2021)Use NTCP2 SSURemoved-2.4.0 (Dec 2023)Use SSU2 **Значения стиля транспорта:** - `\"SSU2\"`: Текущий транспорт на основе UDP - `\"NTCP2\"`: Текущий транспорт на основе TCP - `\"NTCP\"`: Устаревший, удалён (не использовать) - `\"SSU\"`: Устаревший, удалён (не использовать) Общие параметры Все транспорты обычно включают:\n\u0026#34;host\u0026#34; = IPv4 or IPv6 address or hostname \u0026#34;port\u0026#34; = Port number (1-65535) Специфические для SSU2 параметры См. спецификацию SSU2 для получения полной информации.\nОбязательные параметры:\n\u0026#34;host\u0026#34; = IP address (IPv4 or IPv6) \u0026#34;port\u0026#34; = UDP port number \u0026#34;s\u0026#34; = Static X25519 public key (Base64, 44 characters = 32 bytes) \u0026#34;i\u0026#34; = Introduction key X25519 (Base64, 44 characters = 32 bytes) \u0026#34;v\u0026#34; = \u0026#34;2\u0026#34; (protocol version) Необязательные параметры:\n\u0026#34;caps\u0026#34; = Capability string (e.g., \u0026#34;B\u0026#34; for bandwidth tier) \u0026#34;ihost0\u0026#34;, \u0026#34;ihost1\u0026#34;, ... = Introducer IP addresses \u0026#34;iport0\u0026#34;, \u0026#34;iport1\u0026#34;, ... = Introducer ports \u0026#34;ikey0\u0026#34;, \u0026#34;ikey1\u0026#34;, ... = Introducer static keys (Base64, 44 chars) \u0026#34;itag0\u0026#34;, \u0026#34;itag1\u0026#34;, ... = Introducer relay tags \u0026#34;iexp0\u0026#34;, \u0026#34;iexp1\u0026#34;, ... = Introducer expiration timestamps \u0026#34;mtu\u0026#34; = Maximum transmission unit (default 1500, min 1280) \u0026#34;mtu6\u0026#34; = IPv6 MTU (if different from IPv4) Пример SSU2 RouterAddress:\ncost: 5 expiration: 0x0000000000000000 transport_style: \u0026#34;SSU2\u0026#34; options: host=198.51.100.42 port=12345 s=SGVsbG8gV29ybGQhIFRoaXMgaXMgYSBzYW1wbGUga2V5IQ== i=QW5vdGhlciBTYW1wbGUgS2V5IGZvciBJbnRyb2R1Y3Rpb24= v=2 caps=BC mtu=1472 Специфические параметры NTCP2 См. спецификацию NTCP2 для получения полных сведений.\nОбязательные параметры:\n\u0026#34;host\u0026#34; = IP address (IPv4 or IPv6) \u0026#34;port\u0026#34; = TCP port number \u0026#34;s\u0026#34; = Static X25519 public key (Base64, 44 characters = 32 bytes) \u0026#34;i\u0026#34; = Initialization vector (Base64, 24 characters = 16 bytes) \u0026#34;v\u0026#34; = \u0026#34;2\u0026#34; (protocol version) Необязательные параметры (начиная с 0.9.50):\n\u0026#34;caps\u0026#34; = Capability string Пример NTCP2 RouterAddress (адрес маршрутизатора):\ncost: 10 expiration: 0x0000000000000000 transport_style: \u0026#34;NTCP2\u0026#34; options: host=198.51.100.42 port=23456 s=SGVsbG8gV29ybGQhIFRoaXMgaXMgYSBzYW1wbGUga2V5IQ== i=U2FtcGxlIElWIGhlcmU= v=2 Примечания по реализации Значения стоимости:\nUDP (SSU2) обычно имеет более низкую стоимость (5-6) благодаря эффективности TCP (NTCP2) обычно имеет более высокую стоимость (10-11) из-за накладных расходов Более низкая стоимость = предпочитаемый транспорт Несколько адресов:\nRouters могут публиковать несколько записей RouterAddress Разные транспорты (SSU2 и NTCP2) Разные версии IP (IPv4 и IPv6) Клиенты выбирают на основе стоимости и возможностей Имя хоста против IP:\nIP‑адреса предпочтительнее с точки зрения производительности Имена хостов поддерживаются, но добавляют накладные расходы на разрешение DNS Рассмотрите использование IP для публикуемых RouterInfos (объекты RouterInfo) Кодирование Base64:\nВсе ключи и двоичные данные кодируются в Base64 Стандартный Base64 (RFC 4648) Без padding (заполнения) и нестандартных символов JavaDoc: RouterAddress RouterInfo Описание: Полная опубликованная информация о router, хранящаяся в сетевой базе данных. Содержит идентификатор, адреса и возможности.\nФормат:\n+----+----+----+----+----+----+----+----+ | router_ident | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | published | +----+----+----+----+----+----+----+----+ |size| RouterAddress 0 | +----+ + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | RouterAddress 1 | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | RouterAddress ($size-1) | + + | | ~ ~ ~ ~ | | +----+----+----+----+-//-+----+----+----+ |psiz| options | +----+----+----+----+-//-+----+----+----+ | signature | + + | | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ router_ident :: RouterIdentity Length: 387+ bytes (typically 391 for X25519+EdDSA) published :: Date (8 bytes) Publication timestamp (milliseconds since epoch) size :: Integer (1 byte) Number of RouterAddress entries Range: 0-255 addresses :: Array of RouterAddress Variable length Each RouterAddress has variable size peer_size :: Integer (1 byte) Number of peer hashes (ALWAYS 0) Historical, unused feature options :: Mapping Router capabilities and metadata MUST be sorted by key signature :: Signature Length determined by router_ident signing key type Typically 64 bytes (EdDSA) Signed by router_ident\u0026#39;s SigningPrivateKey Хранение в базе данных: - Тип базы данных: 0 - Ключ: SHA-256-хеш от RouterIdentity - Значение: Полная структура RouterInfo\nМетка времени публикации: - 8-байтная дата (миллисекунды с начала эпохи) - Используется для версионирования RouterInfo - Routers периодически публикуют новый RouterInfo - Floodfills сохраняют самую новую версию на основе опубликованной метки времени\nСортировка адресов: - Исторически: Очень старые routers требовали, чтобы адреса были отсортированы по значению SHA-256 их данных - Текущее: Сортировка НЕ требуется, реализовывать ради совместимости не имеет смысла - Адреса могут быть в любом порядке\nПоле размера пиров (историческое): - Всегда 0 в современной I2P - Предназначалось для ограниченных маршрутов (не реализовано) - При реализации за ним следовало бы соответствующее количество хэшей Router - В некоторых старых реализациях мог требоваться отсортированный список пиров\nСопоставление параметров:\nПараметры ДОЛЖНЫ быть отсортированы по ключу. Стандартные параметры включают:\nПараметры возможностей:\n\u0026#34;caps\u0026#34; = Capability string Common values: f = Floodfill (network database) L or M or N or O = Bandwidth tier (L=lowest, O=highest) R = Reachable U = Unreachable/firewalled Example: \u0026#34;fLRU\u0026#34; = Floodfill, Low bandwidth, Reachable, Unreachable Параметры сети:\n\u0026#34;netId\u0026#34; = Network ID (default \u0026#34;2\u0026#34; for main I2P network) Different values for test networks \u0026#34;router.version\u0026#34; = I2P version string Example: \u0026#34;0.9.67\u0026#34; or \u0026#34;2.10.0\u0026#34; Параметры статистики:\n\u0026#34;stat_uptime\u0026#34; = Uptime in milliseconds \u0026#34;coreVersion\u0026#34; = Core I2P version \u0026#34;router.version\u0026#34; = Full router version string См. документацию по RouterInfo базы данных сети для полного списка стандартных параметров.\nВычисление подписи:\nData to sign: Complete RouterInfo structure from router_ident through options Verification: 1. Extract RouterIdentity from RouterInfo 2. Get SigningPublicKey from RouterIdentity (type determines algorithm) 3. Verify signature over all data preceding signature field 4. Signature must match signing key type and length Типичный современный RouterInfo (информация о router):\nRouterIdentity: 391 bytes (X25519+EdDSA with Key Certificate) Published: 8 bytes Size: 1 byte (typically 1-4 addresses) RouterAddress × N: Variable (typically 200-500 bytes each) Peer Size: 1 byte (value=0) Options: Variable (typically 50-200 bytes) Signature: 64 bytes (EdDSA) Total: ~1000-2500 bytes typical Примечания по реализации:\nНесколько адресов:\nRouters обычно публикуют 1-4 адреса Варианты IPv4 и IPv6 Транспорты SSU2 и/или NTCP2 Каждый адрес независим Версионирование:\nБолее новая RouterInfo имеет более позднюю метку времени published Routers публикуют заново каждые ~2 часа или при изменении адресов Floodfills хранят и распространяют только самую новую версию Валидация:\nПроверьте подпись перед принятием RouterInfo (структура данных с информацией о router) Проверьте, что поле expiration состоит из одних нулей в каждом RouterAddress (сетевой адрес router) Проверьте, что отображение options отсортировано по ключу Проверьте, что типы сертификата и ключа известны/поддерживаются Сетевая база данных:\nFloodfills хранят RouterInfo, индексированный по Hash(RouterIdentity) Данные хранятся ~2 дня после последней публикации Routers запрашивают floodfills, чтобы обнаружить другие routers Документация JavaDoc: RouterInfo Примечания по реализации Порядок байтов (эндианность) По умолчанию: Big-Endian (сетевой порядок байтов)\nБольшинство структур I2P используют порядок байтов big-endian (старший байт первым): - Все целочисленные типы (1-8 байт) - Метки времени - TunnelId - Префикс длины строки - Типы и длины сертификатов - Коды типов ключей - Поля размера сопоставления\nИсключение: Little-Endian (младший порядок байтов)\nСледующие типы ключей используют кодирование в формате little-endian: - X25519 ключи шифрования (тип 4) - EdDSA_SHA512_Ed25519 ключи подписи (тип 7) - EdDSA_SHA512_Ed25519ph ключи подписи (тип 8) - RedDSA_SHA512_Ed25519 ключи подписи (тип 11)\nРеализация:\n// Big-endian (most structures) int value = ((bytes[0] \u0026amp; 0xFF) \u0026lt;\u0026lt; 24) | ((bytes[1] \u0026amp; 0xFF) \u0026lt;\u0026lt; 16) | ((bytes[2] \u0026amp; 0xFF) \u0026lt;\u0026lt; 8) | (bytes[3] \u0026amp; 0xFF); // Little-endian (X25519, EdDSA, RedDSA) int value = (bytes[0] \u0026amp; 0xFF) | ((bytes[1] \u0026amp; 0xFF) \u0026lt;\u0026lt; 8) | ((bytes[2] \u0026amp; 0xFF) \u0026lt;\u0026lt; 16) | ((bytes[3] \u0026amp; 0xFF) \u0026lt;\u0026lt; 24); Версионирование структуры Никогда не полагайтесь на фиксированные размеры:\nМногие структуры имеют переменную длину: - RouterIdentity: 387+ байт (не всегда 387) - Destination: 387+ байт (не всегда 387) - LeaseSet2: значительно варьируется - Certificate: 3+ байт\nВсегда считывайте поля размеров: - Длина сертификата в байтах 1-2 - Размер сопоставления в начале - KeysAndCert всегда вычисляется как 384 + 3 + certificate_length\nПроверка на лишние данные: - Запретить лишние байты в конце после корректных структур - Проверять, что длины сертификатов соответствуют типам ключей - Требовать строгого соответствия ожидаемым длинам для типов фиксированного размера\nАктуальные рекомендации (октябрь 2025 года) Для новых идентичностей router:\nEncryption: X25519 (type 4, 32 bytes) Signing: EdDSA_SHA512_Ed25519 (type 7, 32 bytes) Certificate: Key Certificate (type 5) Total Size: 391 bytes Padding: Compressible per [Proposal 161](/ru/proposals/161-ri-dest-padding/) Для новых назначений:\nUnused Public Key Field: 256 bytes random (compressible) Signing: EdDSA_SHA512_Ed25519 (type 7, 32 bytes) Certificate: Key Certificate (type 5) Total Size: 391 bytes Padding: Compressible per [Proposal 161](/ru/proposals/161-ri-dest-padding/) Для новых LeaseSets:\nType: LeaseSet2 (type 3) Encryption Keys: X25519 (type 4, 32 bytes) Leases: At least 1, typically 3-5 Options: Include service records per [Proposal 167](/proposals/167-service-records/) Signature: EdDSA (64 bytes) Для зашифрованных сервисов:\nType: EncryptedLeaseSet (type 5) Blinding: RedDSA_SHA512_Ed25519 (type 11) Inner LeaseSet: LeaseSet2 (type 3) Rotation: Daily blinding key rotation Authorization: Per-client encryption keys Устаревшие функции - не использовать Устаревшее шифрование: - ElGamal (тип 0) для идентичностей Router (устарело в 0.9.58) - шифрование ElGamal/AES+SessionTag (используйте ECIES-X25519)\nУстаревшие типы подписи: - DSA_SHA1 (тип 0) для идентификаторов Router (устарело в 0.9.58) - варианты ECDSA (типы 1-3) для новых реализаций - варианты RSA (типы 4-6) за исключением файлов SU3\nУстаревшие сетевые форматы: - LeaseSet тип 1 (используйте LeaseSet2) - Lease (запись в LeaseSet; 44 байта, используйте Lease2) - Оригинальный формат истечения срока действия Lease\nУстаревшие транспорты: - NTCP (удалён в 0.9.50) - SSU (удалён в 2.4.0)\nУстаревшие сертификаты: - HASHCASH (тип 1) - HIDDEN (тип 2) - SIGNED (тип 3) - MULTIPLE (тип 4)\nСоображения безопасности Генерация ключей: - Всегда используйте криптографически стойкие генераторы случайных чисел - Никогда не используйте повторно ключи в разных контекстах - Защищайте закрытые ключи соответствующими мерами контроля доступа - Надёжно стирайте ключевой материал из памяти по завершении работы\nПроверка подписи: - Всегда проверяйте подписи, прежде чем доверять данным - Проверяйте, что длина подписи соответствует типу ключа - Проверяйте, что подписанные данные содержат ожидаемые поля - Для отсортированных отображений проверяйте порядок сортировки перед подписанием/проверкой\nПроверка временных меток: - Проверить, что опубликованные времена разумны (не в далёком будущем) - Убедиться, что сроки действия lease (временная запись о доступности tunnel) не истекли - Учитывать допуск расхождения часов (обычно ±30 секунд)\nnetDb (сетевая база данных): - Проверять все структуры перед сохранением - Применять ограничения размера для предотвращения DoS-атак - Ограничивать частоту запросов и публикаций - Проверять, что ключи базы данных соответствуют хэшам структур\nПримечания по совместимости Обратная совместимость: - ElGamal и DSA_SHA1 по-прежнему поддерживаются для устаревших routers - Типы ключей, помеченные как устаревшие, остаются работоспособными, но их использование не рекомендуется - Сжимаемый padding (выравнивающая вставка) (Proposal 161 ) обратно совместим вплоть до 0.6\nСовместимость с будущими версиями: - Неизвестные типы ключей можно разбирать, используя поля длины - Неизвестные типы сертификатов можно пропускать, используя поле длины - Неизвестные типы подписей следует обрабатывать корректно - Реализации не должны аварийно завершаться при столкновении с неизвестными необязательными функциями\nСтратегии миграции: - Поддержка одновременно старых и новых типов ключей на время перехода - LeaseSet2 может содержать несколько ключей шифрования - Офлайн-подписи обеспечивают безопасную ротацию ключей - MetaLeaseSet обеспечивает прозрачную миграцию сервиса\nТестирование и валидация Проверка структуры: - Проверьте, что все поля длины находятся в ожидаемых диапазонах - Проверьте, что структуры переменной длины корректно разбираются - Проверьте, что подписи успешно проходят проверку - Протестируйте со структурами минимального и максимального размера\nПограничные случаи: - Строки нулевой длины - Пустые отображения - Минимальное и максимальное число lease (записей в LeaseSet) - Сертификат с нулевой длиной полезной нагрузки - Очень крупные структуры (близкие к максимальным размерам)\nСовместимость: - Тестировать на соответствие официальной реализации Java I2P - Проверять совместимость с i2pd - Тестировать с различным содержимым сетевой базы данных - Проверять на соответствие известным корректным тестовым векторам\nСсылки Спецификации Протокол I2NP Протокол I2CP Транспорт SSU2 Транспорт NTCP2 Протокол Tunnel Протокол датаграмм Криптография Обзор криптографии Шифрование ElGamal/AES Шифрование ECIES-X25519 ECIES для Routers Гибридный ECIES (постквантовый) Подписи Red25519 Зашифрованный LeaseSet Предложения Предложение 123: Новые записи netDB Предложение 134: Типы подписей ГОСТ Предложение 136: Экспериментальные типы подписей Предложение 145: ECIES-P256 Предложение 156: ECIES Routers Предложение 161: Генерация паддинга Предложение 167: Сервисные записи Предложение 169: Постквантовая криптография Индекс всех предложений Сетевая база данных Обзор базы данных сети Стандартные параметры RouterInfo Справочник по API JavaDoc Базовый пакет данных PublicKey PrivateKey SessionKey SigningPublicKey SigningPrivateKey Signature Hash SessionTag TunnelId Certificate DataHelper KeysAndCert RouterIdentity Destination Lease LeaseSet Lease2 LeaseSet2 MetaLease MetaLeaseSet EncryptedLeaseSet RouterAddress RouterInfo Внешние стандарты RFC 7748 (X25519): Эллиптические кривые для обеспечения безопасности RFC 7539 (ChaCha20): ChaCha20 и Poly1305 для протоколов IETF RFC 4648 (Base64): Кодировки данных Base16, Base32 и Base64 FIPS 180-4 (SHA-256): Стандарт безопасного хэширования FIPS 204 (ML-DSA): Стандарт цифровой подписи на основе модульных решёток Реестр служб IANA Ресурсы сообщества Сайт I2P Форум I2P GitLab I2P Зеркало I2P на GitHub Индекс технической документации Информация о выпуске Релиз I2P 2.10.0 История релизов Журнал изменений Приложение: краткие справочные таблицы Краткая справка по типам ключей Текущий стандарт (рекомендуется для всех новых реализаций): - Шифрование: X25519 (тип 4, 32 байта, little-endian) - Подпись: EdDSA_SHA512_Ed25519 (тип 7, 32 байта, little-endian)\nУстаревшее (поддерживается, но признано устаревшим): - Шифрование: ElGamal (тип 0, 256 байт, big-endian (порядок от старшего байта к младшему)) - Подписание: DSA_SHA1 (тип 0, 20-байтовый закрытый / 128-байтовый открытый, big-endian)\nСпециализированные: - Подпись (зашифрованный LeaseSet): RedDSA_SHA512_Ed25519 (тип 11, 32 байта, little-endian)\nПостквантовое (бета, не финализировано): - Гибридное шифрование: варианты MLKEM_X25519 (типы 5-7) - Чисто постквантовое шифрование: варианты MLKEM (коды типов еще не назначены)\nКраткий справочник по размерам структур Structure Minimum Size Typical Size Maximum Size Integer1 byteVaries8 bytes Date8 bytes8 bytes8 bytes String1 byteVaries256 bytes SessionKey32 bytes32 bytes32 bytes Hash32 bytes32 bytes32 bytes TunnelId4 bytes4 bytes4 bytes Certificate3 bytes7 bytes65,538 bytes KeysAndCert387 bytes391 bytes≈1000+ bytes RouterIdentity387 bytes391 bytes≈1000+ bytes Destination387 bytes391 bytes≈1000+ bytes Lease44 bytes44 bytes44 bytes Lease240 bytes40 bytes40 bytes LeaseSet≈1000 bytes≈1200 bytes≈2000+ bytes LeaseSet2≈500 bytes≈800 bytes≈2000+ bytes EncryptedLeaseSet≈600 bytes≈1000 bytes≈3000+ bytes RouterAddress≈150 bytes≈300 bytes≈600 bytes RouterInfo≈1000 bytes≈1500 bytes≈3000+ bytes ### Краткая справка по типу базы данных Type Structure Status Notes 0RouterInfoCurrentStored under Hash(RouterIdentity) 1LeaseSetDeprecatedUse LeaseSet2 instead 3LeaseSet2CurrentStored under Hash(Destination) 5EncryptedLeaseSetCurrentStored under Hash(Blinded Destination) 7MetaLeaseSetDefinedVerify production status ### Краткая справка по транспортному протоколу Protocol Status Port Type Since Notes SSU2CurrentUDP0.9.54Default since 0.9.56 NTCP2CurrentTCP0.9.36Active SSURemovedUDP-Removed in 2.4.0 NTCPRemovedTCP-Removed in 0.9.50 ### Краткая справка по вехам версий Version API Date Key Changes 0.60.6.x2005Destination encryption disabled 0.9.120.9.12Dec 2013Key Certificates introduced 0.9.150.9.15Sep 2015EdDSA support added 0.9.160.9.16Nov 2015Router Key Certificates 0.9.360.9.36Aug 2018NTCP2 introduced 0.9.380.9.38Nov 2018LeaseSet2, X25519 for Destinations 0.9.390.9.39Dec 2018EncryptedLeaseSet working 0.9.480.9.48Jul 2020X25519 for Router Identities 0.9.500.9.50May 2021NTCP removed 0.9.540.9.54May 2022SSU2 testing 0.9.570.9.57Jan 2023[Proposal 161](/ru/proposals/161-ri-dest-padding/) padding (release 2.1.0) 0.9.580.9.58Mar 2023ElGamal/DSA deprecated for RIs (2.2.0) 0.9.660.9.66Jun 2025[Proposal 167](/proposals/167-service-records/) service records (2.9.0) 0.9.670.9.67Sep 2025ML-KEM beta support (2.10.0) --- ","description":"Общие типы данных и форматы сериализации, используемые во всех спецификациях I2P","id":"178a1cfe9e5d2970a6e9f8d07c374b78","section":"docs","title":"Общие структуры","url":"/ru/docs/specs/common-structures/"},{"categories":null,"content":" Историческое примечание: Эта страница сохраняет устаревшее обсуждение «Однонаправленные Tunnels» для справки. Обратитесь к актуальной документации по реализации tunnel за информацией о текущем поведении.\nОбзор I2P строит однонаправленные tunnels: один tunnel передаёт исходящий трафик, а отдельный tunnel — входящие ответы. Эта архитектура восходит к самым ранним проектам сети и остаётся ключевым отличием от систем с двунаправленными цепочками, таких как Tor. С терминологией и подробностями реализации см. обзор tunnel и спецификацию tunnel .\nОбзор Однонаправленные tunnels разделяют трафик запросов и ответов, поэтому любая отдельная группа сговорившихся пиров видит лишь половину цикла туда-обратно. Атакам по времени необходимо пересекать два пула tunnel (исходящий и входящий), а не анализировать одну цепочку, что повышает сложность корреляции. Независимые входящие и исходящие пулы позволяют routers настраивать задержку, пропускную способность и характеристики обработки сбоев для каждого направления. К недостаткам относятся возросшая сложность управления пирами и необходимость поддерживать несколько наборов tunnel для надёжного предоставления сервиса. Анонимность Статья Hermann и Grothoff, I2P is Slow… and What to Do About It , анализирует атаки предшественника против однонаправленных tunnels, предполагая, что достаточно настойчивые противники в конечном итоге способны подтвердить долгоживущих пиров. Отзывы сообщества отмечают, что исследование опирается на конкретные предположения о терпении противника и его правовых полномочиях и не сопоставляет этот подход с тайминговыми атаками, которые затрагивают двунаправленные архитектуры. Продолжающиеся исследования и практический опыт всё больше укрепляют однонаправленные tunnels как осознанный выбор в пользу анонимности, а не недосмотр.\n","description":"Краткий исторический обзор дизайна однонаправленного tunnel в I2P.","id":"37ac13877a690f9c4635959a57451755","section":"docs","title":"Однонаправленные Tunnels","url":"/ru/docs/legacy/unidirectional/"},{"categories":null,"content":"Обзор I2P Streaming Library обеспечивает надежную, упорядоченную и аутентифицированную передачу данных поверх слоя сообщений I2P, аналогично TCP поверх IP. Она располагается над протоколом I2CP и используется практически всеми интерактивными приложениями I2P, включая HTTP-прокси, IRC, BitTorrent и электронную почту.\nОсновные характеристики Однофазная установка соединения с использованием флагов SYN, ACK и FIN, которые могут объединяться с полезной нагрузкой для уменьшения количества циклов обмена данными. Управление перегрузкой со скользящим окном с медленным стартом и предотвращением перегрузки, настроенными для высоколатентной среды I2P. Сжатие пакетов (по умолчанию сегменты размером 4 КБ в сжатом виде), балансирующее стоимость повторной передачи и задержку фрагментации. Полностью аутентифицированный, зашифрованный и надежный канал между I2P-назначениями. Эта конструкция позволяет небольшим HTTP-запросам и ответам завершаться за один цикл обмена данными. SYN-пакет может нести полезную нагрузку запроса, в то время как SYN/ACK/FIN ответчика может содержать полное тело ответа.\nОсновы API Java streaming API соответствует стандартному программированию сокетов в Java:\nI2PSocketManager mgr = I2PSocketManagerFactory.createManager(host, port, options); I2PSocket socket = mgr.connect(destination); I2PServerSocket server = mgr.getServerSocket(); I2PSocketManagerFactory согласовывает или повторно использует сессию router через I2CP. Если ключ не предоставлен, новый destination создаётся автоматически. Разработчики могут передавать параметры I2CP (например, длину tunnel, типы шифрования или настройки соединения) через карту options. I2PSocket и I2PServerSocket повторяют стандартные интерфейсы Java Socket, что делает миграцию простой. Полные Javadocs доступны из консоли I2P router или здесь .\nКонфигурация и настройка Вы можете передать свойства конфигурации при создании менеджера сокетов через:\nI2PSocketManagerFactory.createManager(host, port, properties); Ключевые опции Option Description Default i2p.streaming.maxWindowSize Maximum send window (bytes) 128 KB i2p.streaming.initialRTO Initial retransmission timeout 9s i2p.streaming.inactivityTimeout Timeout before connection close 90s i2p.streaming.enforceProtocol Enforce protocol ID (prevents confusion) true i2p.streaming.congestionAlgorithm Congestion control method Default (AIMD TCP-like) i2p.streaming.disableRejectLogging Disable logging rejected packets false ### Поведение в зависимости от рабочей нагрузки Workload Recommended Settings HTTP-like Default parameters are ideal. Bulk Transfer Increase window size to 256 KB or 512 KB; lengthen timeouts. Real-time Streaming Lower tunnel length to 1-2 hops; adjust RTO downwards. Новые функции, начиная с версии 0.9.4, включают подавление журнала отклонений, поддержку списков DSA (0.9.21) и обязательное соблюдение протокола (0.9.36). Роутеры начиная с версии 2.10.0 включают постквантовое гибридное шифрование (ML-KEM + X25519) на транспортном уровне. Детали протокола Каждый поток идентифицируется по Stream ID. Пакеты несут управляющие флаги, аналогичные TCP: SYNCHRONIZE, ACK, FIN и RESET. Пакеты могут одновременно содержать как данные, так и управляющие флаги, что повышает эффективность для кратковременных соединений.\nЖизненный цикл соединения SYN отправлен — инициатор включает необязательные данные. SYN/ACK ответ — отвечающая сторона включает необязательные данные. ACK финализация — устанавливает надёжность и состояние сессии. FIN/RESET — используется для упорядоченного закрытия или внезапного завершения. Фрагментация и переупорядочивание Поскольку I2P tunnel вносят задержки и изменяют порядок сообщений, библиотека буферизует пакеты из неизвестных или рано прибывших потоков. Буферизованные сообщения хранятся до завершения синхронизации, обеспечивая полную доставку в правильном порядке.\nПрименение протокола Опция i2p.streaming.enforceProtocol=true (по умолчанию с версии 0.9.36) гарантирует, что соединения используют правильный номер протокола I2CP, предотвращая конфликты между несколькими подсистемами, использующими одно назначение.\nСовместимость и Лучшие Практики Протокол потоковой передачи сосуществует с Datagram API, предоставляя разработчикам выбор между транспортом с установлением соединения и без установления соединения.\nUse Case Recommended Transport Reliable, ordered data (HTTP, IRC, FTP) Streaming Connectionless or lossy data (DNS, telemetry) Datagram ### Общие клиенты Приложения могут повторно использовать существующие туннели, работая как общие клиенты (shared clients), что позволяет нескольким сервисам использовать один и тот же destination. Хотя это снижает накладные расходы, это увеличивает риск корреляции между сервисами — используйте с осторожностью.\nУправление перегрузкой Потоковый уровень постоянно адаптируется к задержкам и пропускной способности сети с помощью обратной связи на основе RTT. Приложения работают лучше всего, когда роутеры являются активными участниками (включены туннели для участия в сети). Механизмы контроля перегрузки, подобные TCP, предотвращают перегрузку медленных узлов и помогают балансировать использование пропускной способности между туннелями. Соображения по задержкам Поскольку I2P добавляет несколько сотен миллисекунд базовой задержки, приложения должны минимизировать количество обменов данными. По возможности объединяйте данные с установкой соединения (например, HTTP-запросы в SYN). Избегайте архитектур, основанных на многочисленных последовательных обменах небольшими порциями данных.\nТестирование и совместимость Всегда тестируйте совместимость с Java I2P и i2pd. Несмотря на стандартизацию протокола, могут существовать незначительные различия в реализации. Корректно обрабатывайте устаревшие router\u0026rsquo;ы — многие узлы по-прежнему используют версии до 2.0. Отслеживайте статистику соединений с помощью I2PSocket.getOptions() и getSession() для получения метрик RTT и повторных передач. Производительность сильно зависит от конфигурации tunnel: - Короткие tunnel (1–2 hop) → меньшая задержка, сниженная анонимность. - Длинные tunnel (3+ hop) → более высокая анонимность, увеличенное RTT.\nКлючевые улучшения (2.0.0–2.10.0) Feature Introduced Description Persistent ACK Bundling 2.0.0 Optimized round-trip reduction for HTTP workloads. Adaptive Window Scaling 2.3.0 Improved large file transfer stability. Thread Pooling and Socket Reuse 2.5.0 Reduced per-connection overhead. Protocol Enforcement Default 0.9.36 Ensures correct stream usage. Hybrid ML-KEM Ratchet 2.10.0 Adds post-quantum hybrid encryption layer. i2pd Streaming API Compatibility Fixes 2.9.0 Full parity with Java I2P library behavior. --- Краткое описание I2P Streaming Library — это основа всех надёжных коммуникаций в I2P. Она обеспечивает упорядоченную, аутентифицированную и зашифрованную доставку сообщений и предоставляет практически готовую замену TCP в анонимных средах.\nДля достижения оптимальной производительности: - Минимизируйте количество циклов обмена данными с помощью объединения SYN+полезной нагрузки. - Настройте параметры окна и тайм-аута для вашей рабочей нагрузки. - Отдавайте предпочтение более коротким tunnel для приложений, чувствительных к задержкам. - Используйте дизайн, учитывающий перегрузки, чтобы избежать перегрузки узлов.\n","description":"TCP-подобный транспорт, используемый большинством I2P-приложений","id":"d5eaf45dea26928a910e0f2b8a0e1037","section":"docs","title":"Потоковый протокол","url":"/ru/docs/api/streaming/"},{"categories":null,"content":"Производительность сети I2P: Скорость, соединения и управление ресурсами Сеть I2P является полностью динамичной. Каждый клиент известен другим узлам и тестирует локально известные узлы на предмет доступности и производительности. Только доступные и производительные узлы сохраняются в локальную NetDB. В процессе построения туннелей из этого пула выбираются лучшие ресурсы для создания туннелей. Поскольку тестирование происходит непрерывно, пул узлов изменяется. Каждый узел I2P знает разные части NetDB, что означает, что каждый router имеет различный набор узлов I2P для использования в туннелях. Даже если два router\u0026rsquo;а имеют одинаковое подмножество известных узлов, тесты на доступность и производительность, вероятно, покажут разные результаты, поскольку другие router\u0026rsquo;ы могут находиться под нагрузкой именно в момент тестирования одним router\u0026rsquo;ом, но быть свободными, когда второй router проводит тестирование.\nЭто объясняет, почему каждый узел I2P использует разные узлы для построения туннелей. Поскольку каждый узел I2P имеет различную задержку и пропускную способность, туннели (которые строятся через эти узлы) имеют разные значения задержки и пропускной способности. И поскольку каждый узел I2P строит разные туннели, ни у каких двух узлов I2P нет одинаковых наборов туннелей.\nСервер/клиент известен как \u0026ldquo;destination\u0026rdquo;, и каждый destination имеет по крайней мере один входящий и один исходящий tunnel. По умолчанию используется 3 перехода на tunnel. Это составляет в общей сложности 12 переходов (12 различных узлов I2P) для полного цикла клиент → сервер → клиент.\nКаждый пакет данных проходит через 6 других узлов I2P, прежде чем достигнет сервера:\nклиент - узел1 - узел2 - узел3 - узелA1 - узелA2 - узелA3 - сервер\nи на обратном пути 6 различных I2P-узлов:\nserver - hopb1 - hopb2 - hopb3 - hopc1 - hopc2 - hopc3 - client\nТрафику в сети требуется ACK перед отправкой новых данных; необходимо дождаться возвращения ACK от сервера: отправить данные, ждать ACK, отправить ещё данные, ждать ACK. Поскольку RTT (Round Trip Time, время прохождения сигнала туда и обратно) складывается из задержки каждого отдельного узла I2P и каждого соединения на этом пути туда-обратно, обычно проходит 1–3 секунды, пока ACK вернётся к клиенту. Из-за особенностей проектирования TCP и транспорта I2P пакет данных имеет ограниченный размер. Вместе эти условия устанавливают предел максимальной пропускной способности на туннель примерно в 20–50 кБ/с. Однако если хотя бы один узел (hop) в туннеле располагает только 5 кБ/с пропускной способности, весь туннель ограничивается 5 кБ/с, независимо от задержки и других ограничений.\nШифрование, задержка и процесс построения туннеля делают создание туннеля довольно затратным по процессорному времени. Поэтому destination может иметь максимум 6 входящих и 6 исходящих туннелей для передачи данных. При максимальной пропускной способности 50 кБ/с на туннель, destination может использовать примерно 300 кБ/с суммарного трафика (в реальности это может быть больше, если используются более короткие туннели с низкой или отсутствующей анонимностью). Используемые туннели уничтожаются каждые 10 минут, и строятся новые. Эта смена туннелей, а также иногда клиенты, которые завершают работу или теряют соединение с сетью, могут приводить к разрыву туннелей и соединений. Пример этого можно увидеть в IRC2P Network при потере соединения (ping timeout) или при использовании eepget.\nПри ограниченном наборе назначений и ограниченном количестве туннелей на каждое назначение, один узел I2P использует лишь ограниченный набор туннелей через другие узлы I2P. Например, если узел I2P является «hop1» в небольшом примере выше, он видит только один участвующий туннель, исходящий от клиента. Если суммировать всю сеть I2P, можно построить лишь относительно ограниченное число участвующих туннелей с ограниченным общим объёмом пропускной способности. Если распределить эти ограниченные числа по количеству узлов I2P, для использования доступна лишь малая часть имеющейся пропускной способности/ёмкости.\nЧтобы сохранить анонимность, один router не должен использоваться всей сетью для построения туннелей. Если один router действительно выступает в роли tunnel router для всех узлов I2P, он становится реальной единой точкой отказа, а также центральной точкой для сбора IP-адресов и данных от клиентов. Вот почему сеть распределяет трафик между узлами в процессе построения туннелей.\nЕще одним фактором, влияющим на производительность, является способ, которым I2P обрабатывает mesh-сети. Каждый переход между узлами (hop-to-hop) использует одно TCP или UDP соединение на узлах I2P. При 1000 соединений наблюдается 1000 TCP-соединений. Это довольно много, и некоторые домашние маршрутизаторы и маршрутизаторы малых офисов допускают лишь небольшое количество соединений. I2P пытается ограничить эти соединения до 1500 на каждый тип — UDP и TCP. Это также ограничивает объем трафика, маршрутизируемого через узел I2P.\nЕсли узел доступен, имеет настройку пропускной способности \u0026gt;128 КБ/с для общего использования и доступен 24/7, он должен использоваться через некоторое время для участия в трафике. Если он в промежутке времени отключается, тестирование узла I2P, проводимое другими узлами, покажет им, что он недоступен. Это блокирует узел на других узлах как минимум на 24 часа. Таким образом, другие узлы, которые протестировали этот узел как недоступный, не будут использовать его для построения туннелей в течение 24 часов. Вот почему ваш трафик ниже после перезапуска/выключения вашего I2P router минимум в течение 24 часов.\nКроме того, другим узлам I2P необходимо знать I2P router для проверки его доступности и пропускной способности. Этот процесс можно ускорить, взаимодействуя с сетью, например, используя приложения или посещая I2P-сайты, что приведёт к большему количеству построений tunnel и, следовательно, к большей активности и доступности для тестирования узлами сети.\nИстория производительности (избранное) За годы существования I2P было реализовано несколько значительных улучшений производительности:\nNative math Реализовано через JNI-привязки к библиотеке GNU MP (GMP) для ускорения операции modPow в BigInteger, которая ранее занимала основную часть процессорного времени. Первые результаты показали значительное ускорение криптографии с открытым ключом. См.: /misc/jbigi/\nGarlic wrapping a \u0026ldquo;reply\u0026rdquo; LeaseSet (tuned) Ранее для ответов часто требовался поиск LeaseSet отправителя в сетевой базе данных. Включение LeaseSet отправителя в начальный garlic улучшает задержку ответа. Теперь это делается выборочно (в начале соединения или при изменении LeaseSet) для снижения накладных расходов.\nНативная математика Перенесены некоторые шаги валидации на более ранний этап процесса установления соединения transport, чтобы отклонять некорректные узлы быстрее (неправильные часы, неправильная настройка NAT/firewall, несовместимые версии), экономя CPU и трафик.\nУпаковка LeaseSet для \u0026ldquo;ответа\u0026rdquo; в garlic (настроенная) Используйте контекстно-зависимое тестирование tunnel: избегайте тестирования tunnel, которые уже передают данные; отдавайте предпочтение тестированию в режиме простоя. Это снижает накладные расходы и ускоряет обнаружение неисправных tunnel.\nБолее эффективное отклонение TCP Сохранение выбранных туннелей для данного соединения уменьшает доставку пакетов не по порядку и позволяет библиотеке потоковой передачи увеличивать размеры окон, улучшая пропускную способность.\nКорректировки тестирования туннелей GZip или аналогичные методы для объёмных структур (например, опций RouterInfo) снижают использование пропускной способности там, где это целесообразно.\nПостоянный выбор tunnel/lease Замена упрощённого протокола «ministreaming». Современный streaming включает выборочные ACK и управление перегрузкой, адаптированные под анонимный, ориентированный на сообщения субстрат I2P. См.: /docs/api/streaming/\nFuture Performance Improvements (historical ideas) Ниже представлены идеи, задокументированные исторически как потенциальные улучшения. Многие из них устарели, реализованы или заменены архитектурными изменениями.\nСжимать выбранные структуры данных Улучшить механизм выбора роутерами узлов для построения туннелей, чтобы избежать медленных или перегруженных узлов, сохраняя при этом устойчивость к Sybil-атакам со стороны мощных противников.\nПолный протокол потоковой передачи Уменьшите ненужное исследование, когда пространство ключей стабильно; настройте, сколько узлов возвращается в запросах и сколько одновременных поисков выполняется.\nSession Tag tuning and improvements (legacy) Для устаревшей схемы ElGamal/AES+SessionTag более умные стратегии истечения и пополнения снижают количество откатов к ElGamal и неиспользованных тегов.\nУлучшенное профилирование и выбор пиров Генерировать теги из синхронизированного PRNG, инициализированного при установке новой сессии, что снижает накладные расходы на сообщение по сравнению с предварительно доставленными тегами.\nНастройка сетевой базы данных Более длительное время жизни туннелей в сочетании с восстановлением может снизить накладные расходы на перестроение; необходимо найти баланс между анонимностью и надёжностью.\nНастройка и улучшения Session Tag (устаревшее) Отклонять недействительные узлы раньше и делать тесты туннелей более контекстно-зависимыми для снижения конкуренции и задержки.\nМиграция SessionTag на синхронизированный PRNG (устаревший) Выборочное объединение LeaseSet, опции сжатия RouterInfo и внедрение полного протокола потоковой передачи — всё это способствует улучшению воспринимаемой производительности.\nНе вижу текста для перевода. Пожалуйста, предоставьте текст, который нужно перевести с английского на русский.\nСмотрите также:\nМаршрутизация туннелей Выбор пиров Транспорты Спецификация SSU2 и Спецификация NTCP2 ","description":"Производительность сети I2P: как она работает сегодня, исторические улучшения и идеи для будущей оптимизации","id":"eb296d22dd7b2414170601d7c73a1613","section":"docs","title":"Производительность","url":"/ru/docs/overview/performance/"},{"categories":null,"content":"Обзор I2P Streaming Library (библиотека потоковой передачи данных I2P) обеспечивает надёжную, упорядоченную и аутентифицированную доставку данных поверх ненадёжного уровня сообщений I2P — аналогично TCP поверх IP. Её используют почти все интерактивные приложения I2P, такие как просмотр веб‑страниц, IRC, электронная почта и обмен файлами.\nОн обеспечивает надежную передачу данных, контроль перегрузок, ретрансляцию и управление потоком поверх анонимных tunnels I2P с высокой задержкой. Каждый поток полностью зашифрован от конца до конца между назначениями.\nОсновные принципы проектирования Стриминговая библиотека реализует однофазную установку соединения, при которой флаги SYN, ACK и FIN могут нести полезную нагрузку в том же сообщении. Это минимизирует число обменов туда‑обратно в средах с высокой задержкой — небольшая HTTP‑транзакция может завершиться за один обмен.\nКонтроль перегрузки и повторная передача смоделированы по образцу TCP, но адаптированы к среде I2P. Размеры окна основаны на сообщениях, а не на байтах, и подстроены под задержки и накладные расходы tunnel. Протокол поддерживает медленный старт, предотвращение перегрузок и экспоненциальное увеличение интервала ожидания, аналогичные алгоритму AIMD в TCP.\nАрхитектура Потоковая библиотека работает между приложениями и интерфейсом I2CP.\nLayer Responsibility Application Standard I2PSocket and I2PServerSocket usage Streaming Library Connection setup, sequencing, retransmission, and flow control I2CP Tunnel creation, routing, and message handling I2NP / Router Layer Transport through tunnels Большинство пользователей получают доступ к нему через I2PSocketManager, I2PTunnel или SAMv3. Библиотека прозрачно обрабатывает управление destination (адресом назначения в I2P), работу с tunnel и повторные передачи. Формат пакета +-----------------------------------------------+ | Send Stream ID (4B) | Receive Stream ID (4B) | +-----------------------------------------------+ | Sequence Number (4B) | Ack Through (4B) | +-----------------------------------------------+ | NACK Count (1B) | optional NACK list (4B each) +-----------------------------------------------+ | Flags (1B) | Option Size (1B) | Options ... | +-----------------------------------------------+ | Payload ... | Сведения о заголовке Идентификаторы потоков: 32-битные значения, однозначно идентифицирующие локальные и удаленные потоки. Порядковый номер: начинается с 0 для SYN (сегмента инициации соединения), увеличивается на 1 для каждого сообщения. Подтверждение до (Ack Through): подтверждает все сообщения до N, за исключением находящихся в списке NACK (отрицательных подтверждений). Флаги: битовая маска, управляющая состоянием и поведением. Параметры: список переменной длины для RTT (время туда-обратно), MTU (максимальная передаваемая единица) и согласования протокола. Ключевые флаги Flag Purpose SYN Connection initiation ACK Acknowledge received packets FIN Graceful close RST Reset connection FROM_INCLUDED Sender’s destination included SIGNATURE_INCLUDED Message signed by sender ECHO / ECHO_REPLY Ping/Pong keepalive --- Управление потоком и надёжность Streaming (библиотека потоковой передачи данных в I2P) использует оконный механизм на основе сообщений, в отличие от байтово-ориентированного подхода TCP. Количество неподтверждённых пакетов, разрешённых в полёте, равно текущему размеру окна (по умолчанию 128).\nМеханизмы Контроль перегрузки: Медленный старт и предотвращение перегрузки на основе AIMD (аддитивное увеличение/мультипликативное уменьшение). Choke/Unchoke (блокировка/разблокировка передачи): Сигнализация управления потоком на основе заполненности буфера. Повторная передача: Расчет RTO (таймаута повторной передачи) согласно RFC 6298 с экспоненциальным увеличением интервала. Фильтрация дубликатов: Обеспечивает надежность при возможном переупорядочивании сообщений. Типичные значения конфигурации:\nParameter Default Description maxWindowSize 128 Max unacknowledged messages maxMessageSize 1730 Maximum payload bytes per message initialRTO 9000 ms Initial retransmission timeout inactivityTimeout 90000 ms Idle connection timeout connectTimeout 300000 ms Connection establishment timeout --- Установление соединения Инициатор отправляет SYN (необязательно с полезной нагрузкой и FROM_INCLUDED). Ответчик отвечает SYN+ACK (может включать полезную нагрузку). Инициатор отправляет финальный ACK, подтверждающий установление соединения. Необязательные начальные полезные нагрузки позволяют передавать данные до завершения полного рукопожатия.\nПодробности реализации Повторная передача и таймаут Алгоритм повторной передачи соответствует RFC 6298. - Начальный RTO (тайм-аут повторной передачи): 9 с - Минимальный RTO: 100 мс - Максимальный RTO: 45 с - Альфа: 0.125 - Бета: 0.25\nСовместное использование блока управления Недавние соединения с тем же пиром повторно используют прежние данные RTT (время кругового прохода) и окна для более быстрого разгона, избегая задержки “холодного старта”. Контрольные блоки истекают через несколько минут.\nMTU и фрагментация MTU по умолчанию: 1730 байт (вмещает два сообщения I2NP). ECIES destinations (тип назначения в I2P на основе ECIES): 1812 байт (сниженные накладные расходы). Минимально поддерживаемый MTU: 512 байт. Размер полезной нагрузки не включает минимальный 22-байтовый заголовок Streaming (библиотека потоковой передачи I2P).\nИстория версий Router Version Feature 0.7.1 Protocol numbers defined in I2CP 0.9.11 Variable-length signatures 0.9.12 ECDSA signature support 0.9.15 Ed25519 signature support 0.9.18 Ping/Pong payloads 0.9.20 FROM_INCLUDED not required in RESET 0.9.36 Protocol enforcement enabled by default 0.9.39 OFFLINE_SIGNATURE support 0.9.58 Bob’s hash added to NACK field in SYN 2.10.0 Post-Quantum hybrid encryption (experimental) --- Использование на уровне приложений Пример на Java Properties props = new Properties(); props.setProperty(\u0026#34;i2p.streaming.maxWindowSize\u0026#34;, \u0026#34;512\u0026#34;); I2PSocketManager mgr = I2PSocketManagerFactory.createManager(props); I2PSocket socket = mgr.connect(destination); InputStream in = socket.getInputStream(); OutputStream out = socket.getOutputStream(); Поддержка SAMv3 и i2pd SAMv3: Предоставляет режимы STREAM и DATAGRAM для клиентов, не использующих Java. i2pd: Предоставляет идентичные параметры потоковой передачи через опции файла конфигурации (например, i2p.streaming.maxWindowSize, profile, и т. д.). Выбор между потоковой передачей и дейтаграммами Use Case Recommended Transport Reason HTTP, IRC, Email Streaming Requires reliability DNS Repliable Datagram Single request/response Telemetry, Logging Raw Datagram Best-effort acceptable P2P DHT Datagram High connection churn --- Безопасность и постквантовое будущее Сеансы библиотеки Streaming защищены сквозным шифрованием на уровне I2CP. Постквантовое гибридное шифрование (ML-KEM + X25519) поддерживается экспериментально в версии 2.10.0, но по умолчанию отключено.\nСсылки Обзор Streaming API Спецификация протокола Streaming (потоковый протокол) Спецификация I2CP Предложение 144: расчёты MTU для Streaming Примечания к выпуску I2P 2.10.0 ","description":"Надежный, похожий на TCP транспорт, используемый большинством приложений I2P","id":"100837c91cc0808ee048c86902b36251","section":"docs","title":"Протокол потоковой передачи","url":"/ru/docs/specs/streaming/"},{"categories":null,"content":"Зачем писать код специально для I2P? Существует несколько способов использования приложений в I2P. Используя I2PTunnel , вы можете использовать обычные приложения без необходимости программировать явную поддержку I2P. Это очень эффективно для сценариев клиент-сервер, когда вам нужно подключиться к одному веб-сайту. Вы можете просто создать туннель с помощью I2PTunnel для подключения к этому веб-сайту, как показано на Рисунке 1.\nЕсли ваше приложение является распределённым, ему потребуются соединения с большим количеством узлов. При использовании I2PTunnel вам нужно будет создать новый туннель для каждого узла, с которым вы хотите связаться, как показано на рисунке 2. Этот процесс, конечно, можно автоматизировать, но запуск большого количества экземпляров I2PTunnel создаёт значительные накладные расходы. Кроме того, при работе со многими протоколами вам потребуется заставить всех использовать один и тот же набор портов для всех узлов — например, если вы хотите надёжно запустить DCC-чат, все должны договориться, что порт 10001 — это Алиса, порт 10002 — это Боб, порт 10003 — это Чарли и так далее, поскольку протокол включает специфичную для TCP/IP информацию (хост и порт).\nОбычные сетевые приложения часто отправляют множество дополнительных данных, которые могут быть использованы для идентификации пользователей. Имена хостов, номера портов, часовые пояса, кодировки символов и т.д. часто отправляются без уведомления пользователя. Поэтому разработка сетевого протокола специально с учетом анонимности может помочь избежать компрометации личности пользователей.\nТакже следует учитывать соображения эффективности при определении способа взаимодействия поверх I2P. Библиотека streaming и компоненты, построенные на её основе, работают с подтверждениями соединения, аналогичными TCP, в то время как базовые протоколы I2P (I2NP и I2CP) являются строго основанными на сообщениях (как UDP или в некоторых случаях raw IP). Важное различие заключается в том, что в I2P коммуникация происходит через длинную широкополосную сеть — каждое сквозное сообщение будет иметь значительные задержки, но может содержать полезную нагрузку до нескольких КБ. Приложение, которому требуется простой запрос и ответ, может избавиться от любого состояния и устранить задержку, возникающую при установлении и завершении соединения, используя датаграммы (с наилучшим усилием) без необходимости беспокоиться об определении MTU или фрагментации сообщений.\nFigure 1: Creating a server-client connection using I2PTunnel only requires creating a single tunnel. Figure 2: Setting up connections for a peer-to-peer applications requires a very large amount of tunnels. Подводя итог, несколько причин для написания специального кода для I2P: Создание большого количества экземпляров I2PTunnel потребляет значительный объём ресурсов, что создаёт проблемы для распределённых приложений (для каждого пира требуется новый tunnel). Общие сетевые протоколы часто передают много дополнительных данных, которые могут быть использованы для идентификации пользователей. Программирование специально для I2P позволяет создать сетевой протокол, который не допускает утечки такой информации, сохраняя анонимность и безопасность пользователей. Сетевые протоколы, разработанные для использования в обычном интернете, могут быть неэффективными в I2P — сети с гораздо более высокой задержкой. I2P поддерживает стандартный интерфейс плагинов для разработчиков, чтобы приложения могли быть легко интегрированы и распространены.\nПриложения, написанные на Java и доступные/запускаемые через HTML-интерфейс с использованием стандартного webapps/app.war, могут быть рассмотрены для включения в дистрибутив I2P.\nВажные концепции Есть несколько изменений, к которым нужно привыкнуть при использовании I2P:\nНаправления Приложение, работающее в I2P, отправляет сообщения из уникальной криптографически защищённой конечной точки — \u0026ldquo;destination\u0026rdquo; — и получает сообщения на неё. С точки зрения TCP или UDP, destination можно (в значительной степени) считать эквивалентом пары имя хоста плюс номер порта, хотя есть несколько различий.\nI2P destination сам по себе является криптографической конструкцией — все данные, отправленные на него, шифруются так, как если бы IPsec был повсеместно развёрнут, а (анонимизированное) местоположение конечной точки подписывается так, как если бы DNSSEC был повсеместно развёрнут. I2P destinations являются мобильными идентификаторами — они могут быть перемещены с одного I2P router на другой (или даже могут работать в режиме \u0026ldquo;multihome\u0026rdquo; — функционировать на нескольких router одновременно). Это существенно отличается от мира TCP или UDP, где одна конечная точка (порт) должна оставаться на одном хосте. I2P destinations громоздкие и большие по размеру — внутри они содержат 2048-битный открытый ключ ElGamal для шифрования, 1024-битный открытый ключ DSA для подписи и сертификат переменного размера, который может содержать proof of work или скрытые данные. Существуют способы обращения к этим большим и неудобным адресам назначения по коротким и понятным именам (например, \u0026ldquo;irc.duck.i2p\u0026rdquo;), но эти методы не гарантируют глобальную уникальность (поскольку они хранятся локально в базе данных на машине каждого пользователя), а текущий механизм не особенно масштабируем и безопасен (обновления списка хостов управляются с помощью \u0026ldquo;подписок\u0026rdquo; на службы именования). Возможно, когда-нибудь появится безопасная, человекочитаемая, масштабируемая и глобально уникальная система именования, но приложения не должны зависеть от её наличия. Дополнительная информация о системе именования доступна.\nХотя большинству приложений не нужно различать протоколы и порты, I2P поддерживает их. Сложные приложения могут указывать протокол, порт отправителя и порт получателя для каждого сообщения отдельно, чтобы мультиплексировать трафик на одном destination. Подробности см. на странице о датаграммах . Простые приложения работают, прослушивая «все протоколы» на «всех портах» destination.\nАнонимность и конфиденциальность I2P обеспечивает прозрачное сквозное шифрование и аутентификацию для всех данных, передаваемых по сети — если Боб отправляет данные на destination Алисы, только destination Алисы может их получить, и если Боб использует библиотеку датаграмм или потоковую библиотеку, Алиса точно знает, что данные были отправлены с destination Боба.\nКонечно, I2P прозрачно анонимизирует данные, передаваемые между Алисой и Бобом, но никак не анонимизирует содержание того, что они отправляют. Например, если Алиса отправляет Бобу форму со своим полным именем, государственными идентификационными документами и номерами кредитных карт, I2P ничего не может с этим поделать. Поэтому протоколы и приложения должны учитывать, какую информацию они пытаются защитить, а какую готовы раскрыть.\nI2P дейтаграммы могут достигать нескольких КБ Приложения, использующие I2P-датаграммы (как обычные, так и с возможностью ответа), по сути можно рассматривать с точки зрения UDP — датаграммы неупорядочены, доставляются по принципу «best effort» и не требуют установления соединения — но в отличие от UDP, приложениям не нужно беспокоиться об определении MTU и можно просто отправлять большие датаграммы. Хотя верхний предел номинально составляет 32 КБ, сообщение фрагментируется при передаче, что снижает надёжность доставки в целом. В настоящее время не рекомендуется использовать датаграммы размером более 10 КБ. Подробности см. на странице о датаграммах . Для многих приложений 10 КБ данных достаточно для всего запроса или ответа, что позволяет им прозрачно работать в I2P как UDP-подобное приложение без необходимости реализовывать фрагментацию, повторные отправки и т.д.\nПараметры разработки Существует несколько способов передачи данных через I2P, каждый со своими преимуществами и недостатками. Библиотека streaming lib является рекомендуемым интерфейсом, используемым большинством I2P-приложений.\nБиблиотека потоковой передачи Полная библиотека streaming теперь является стандартным интерфейсом. Она позволяет программировать с использованием TCP-подобных сокетов, как объясняется в руководстве по разработке с использованием Streaming .\nBOB BOB — это Basic Open Bridge , позволяющий приложению на любом языке программирования устанавливать потоковые соединения в I2P и из него. На данный момент отсутствует поддержка UDP, но она планируется в ближайшем будущем. BOB также содержит несколько инструментов, таких как генерация ключей destination и проверка соответствия адреса спецификациям I2P. Актуальную информацию и приложения, использующие BOB, можно найти на этом I2P Site .\nSAM, SAM V2, SAM V3 SAM не рекомендуется. SAM V2 приемлем, SAM V3 рекомендуется.\nSAM — это протокол Simple Anonymous Messaging (простой анонимный обмен сообщениями), позволяющий приложению, написанному на любом языке, взаимодействовать с SAM bridge через обычный TCP-сокет, при этом bridge мультиплексирует весь его I2P-трафик, прозрачно координируя шифрование/дешифрование и обработку событий. SAM поддерживает три режима работы:\nпотоки, когда Алиса и Боб хотят надежно отправлять данные друг другу в правильном порядке датаграммы с возможностью ответа, когда Алиса хочет отправить Бобу сообщение, на которое Боб может ответить необработанные датаграммы, когда Алиса хочет получить максимальную пропускную способность и производительность, а Боб не волнуется, аутентифицирован ли отправитель данных или нет (например, передаваемые данные самоаутентифицируются) SAMv3 преследует ту же цель, что и SAM и SAM V2, но не требует мультиплексирования/демультиплексирования. Каждый I2P поток обрабатывается собственным сокетом между приложением и мостом SAM. Кроме того, датаграммы могут отправляться и приниматься приложением через датаграммную связь с мостом SAM.\nSAM V2 — это новая версия, используемая imule, которая исправляет некоторые проблемы в SAM .\nSAM V3 используется imule начиная с версии 1.4.0.\nI2PTunnel Приложение I2PTunnel позволяет приложениям создавать специфические TCP-подобные туннели к узлам путём создания либо \u0026lsquo;клиентских\u0026rsquo; приложений I2PTunnel (которые прослушивают определённый порт и подключаются к определённому I2P destination при каждом открытии сокета к этому порту), либо \u0026lsquo;серверных\u0026rsquo; приложений I2PTunnel (которые прослушивают определённый I2P destination и при каждом новом I2P-соединении выполняют outproxy к определённому TCP-хосту/порту). Эти потоки являются 8-битно чистыми и аутентифицированы и защищены через ту же библиотеку потоковой передачи, что использует SAM, но создание множества уникальных экземпляров I2PTunnel связано с нетривиальными накладными расходами, поскольку каждый имеет свой собственный уникальный I2P destination и свой собственный набор tunnel, ключей и т.д.\nSOCKS I2P поддерживает прокси SOCKS V4 и V5. Исходящие соединения работают хорошо. Входящие (серверные) соединения и функциональность UDP могут быть неполными и непроверенными.\nMinistreaming Удалено\nРаньше существовала простая библиотека \u0026ldquo;ministreaming\u0026rdquo;, но теперь ministreaming.jar содержит только интерфейсы для полной библиотеки streaming.\nДатаграммы Рекомендуется для UDP-подобных приложений\nБиблиотека Datagram позволяет отправлять пакеты, похожие на UDP. Можно использовать:\nДатаграммы с возможностью ответа Необработанные датаграммы I2CP Не рекомендуется\nI2CP сам по себе является языконезависимым протоколом, но для реализации библиотеки I2CP на чём-то отличном от Java требуется написать значительное количество кода (процедуры шифрования, маршаллинг объектов, асинхронная обработка сообщений и т. д.). Хотя кто-то может написать библиотеку I2CP на C или другом языке, скорее всего, будет более полезным использовать вместо этого библиотеку SAM для C.\nВеб-приложения I2P поставляется с веб-сервером Jetty, и настройка для использования Apache вместо него довольно проста. Любая стандартная технология веб-приложений должна работать.\nНачало разработки — Простое руководство Для разработки с использованием I2P требуется рабочая установка I2P и среда разработки на ваш выбор. Если вы используете Java, вы можете начать разработку с библиотеки streaming или библиотеки datagram. При использовании другого языка программирования можно применять SAM или BOB.\nРазработка с использованием библиотеки Streaming Ниже приведена сокращённая и модернизированная версия примера с исходной страницы. Полный пример см. на устаревшей странице или в наших примерах на Java в кодовой базе.\n// Server example (excerpt) I2PSocketManager manager = I2PSocketManagerFactory.createManager(); I2PServerSocket server = manager.getServerSocket(); I2PSocket socket = server.accept(); BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream())); String s; while ((s = br.readLine()) != null) { System.out.println(\u0026#34;Received: \u0026#34; + s); } Пример кода: базовый сервер, принимающий данные.\n// Client example (excerpt) I2PSocketManager manager = I2PSocketManagerFactory.createManager(); Destination dest = new Destination(serverDestBase64); I2PSocket socket = manager.connect(dest); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream())); bw.write(\u0026#34;Hello I2P!\\n\u0026#34;); bw.flush(); Пример кода: клиент подключается и отправляет строку.\n","description":"Зачем писать приложения специально для I2P, ключевые концепции, варианты разработки и простое руководство для начала работы","id":"d137fc4f3bedf693b877aa1ba9bde3eb","section":"docs","title":"Разработка приложений","url":"/ru/docs/develop/applications/"},{"categories":null,"content":"Цель: Обеспечивать единообразие, точность и доступность во всей технической документации I2P\nОсновные принципы 1. Проверьте всё Никогда не делайте предположений и не угадывайте. Все технические утверждения должны быть проверены на соответствие: - Текущему исходному коду I2P (https://i2pgit.org/I2P_Developers/i2p.i2p/src/branch/master ) - Официальной документации API (https://i2p.github.io/i2p.i2p/ - Спецификации конфигурации /docs/specs/ - Недавние примечания к релизам /releases/ Пример корректной проверки:\n❌ BAD: \u0026#34;The ClientApp interface probably requires three constructor parameters.\u0026#34; ✅ GOOD: \u0026#34;The ClientApp interface requires this constructor signature: public MyClientApp(I2PAppContext context, ClientAppManager manager, String[] args)\u0026#34; 2. Ясность важнее краткости Пишите для разработчиков, которые могут впервые сталкиваться с I2P. Объясняйте понятия полностью, не предполагая наличия предварительных знаний.\nПример:\n❌ BAD: \u0026#34;Use the port mapper for service discovery.\u0026#34; ✅ GOOD: \u0026#34;The port mapper offers a simple directory for internal TCP services. Register loopback ports so other applications can discover your service without hardcoded addresses.\u0026#34; 3. Доступность прежде всего Документация должна быть доступна разработчикам в клирнете (обычный интернет), даже несмотря на то, что I2P — оверлейная сеть. Всегда предоставляйте альтернативы, доступные из клирнета, для внутренних ресурсов I2P.\nТехническая точность Документация по API и интерфейсу Всегда указывайте: 1. Полные имена пакетов при первом упоминании: net.i2p.app.ClientApp 2. Полные сигнатуры методов с типами возвращаемых значений 3. Имена параметров и их типы 4. Обязательные и необязательные параметры\nПример:\nThe `startup()` method has signature `void startup() throws IOException` and must execute without blocking. The method must call `ClientAppManager.notify()` at least once to transition from INITIALIZED state. Параметры конфигурации При документировании файлов конфигурации: 1. Показывайте точные имена свойств 2. Указывайте кодировку файла (UTF-8 для конфигов I2P) 3. Приводите полные примеры 4. Документируйте значения по умолчанию 5. Указывайте версию, в которой свойства были введены/изменены\nПример:\n### clients.config Properties **Required:** - `clientApp.N.main` - Full class name (no default) **Optional:** - `clientApp.N.delay` - Seconds before starting (default: 120) - `clientApp.N.onBoot` - Forces delay=0 if true (default: false, added in 0.9.4) Константы и перечисления При документировании констант используйте точные имена из кода:\n❌ BAD: \u0026#34;Common registrations include console, i2ptunnel, Jetty, sam, and bob\u0026#34; ✅ GOOD: \u0026#34;Common port mapper service constants from `net.i2p.util.PortMapper`: - `SVC_CONSOLE` - Router console (default port 7657) - `SVC_HTTP_PROXY` - HTTP proxy (default port 4444) - `SVC_SAM` - SAM bridge (default port 7656)\u0026#34; Различайте близкие по смыслу понятия I2P имеет несколько пересекающихся подсистем. Всегда уточняйте, какую именно подсистему вы документируете:\nПример:\nNote that client registry and port mapper are separate systems: - **ClientAppManager registry** enables inter-application communication by name lookup - **PortMapper** maps service names to host:port combinations for service discovery - **i2ptunnel tunnel types** are configuration values (tunnel.N.type), not service registrations URL-адреса документации и ссылки Правила доступности URL-адресов Основные источники должны использовать URL-адреса, доступные из clearnet (открытого интернета) Внутренние для I2P URL-адреса (.i2p domains) должны включать примечания о доступности Всегда предоставляйте альтернативы при ссылках на внутренние для I2P ресурсы Шаблон для внутренних URL-адресов I2P:\n\u0026gt; **Note:** The I2P network hosts comprehensive documentation at http://idk.i2p/javadoc-i2p/ \u0026gt; which requires an I2P router for access. For clearnet access, use the GitHub Pages \u0026gt; mirror at https://eyedeekay.github.io/javadoc-i2p/ Рекомендуемые справочные URL-адреса I2P Официальные спецификации: - Конфигурация - Плагин - Индекс документации Документация по API (выберите самую актуальную): - Самая актуальная: https://i2p.github.io/i2p.i2p/ (API 0.9.66 по состоянию на I2P 2.10.0) - Зеркало в Clearnet (открытом интернете): https://eyedeekay.github.io/javadoc-i2p/ Исходный код: - GitLab (официальный): https://i2pgit.org/I2P_Developers/i2p.i2p/src/branch/master - Зеркало на GitHub: https://github.com/i2p/i2p.i2p Стандарты формата ссылок ✅ GOOD: [ClientApp Javadoc](https://i2p.github.io/i2p.i2p/net/i2p/app/ClientApp.html) ✅ GOOD: [Configuration Specification](https://geti2p.net/spec/configuration) ❌ BAD: See the ClientApp docs at http://idk.i2p/... ❌ BAD: [link](url) with no descriptive text Отслеживание версий Метаданные документа Каждый технический документ должен включать метаданные версии в frontmatter (служебный блок метаданных в начале файла):\n--- title: \u0026#34;Document Title\u0026#34; description: \u0026#34;Brief description\u0026#34; slug: \u0026#34;url-slug\u0026#34; lastUpdated: \u0026#34;2025-10\u0026#34; accurateFor: \u0026#34;2.10.0\u0026#34; reviewStatus: \u0026#34;verified\u0026#34; --- Определения полей: - lastUpdated: Год и месяц последней проверки/обновления документа - accurateFor: Версия I2P, на соответствие которой документ был проверен - reviewStatus: Одно из \u0026ldquo;draft\u0026rdquo;, \u0026ldquo;needs-review\u0026rdquo;, \u0026ldquo;verified\u0026rdquo;, \u0026ldquo;outdated\u0026rdquo;\nСсылки на версии в содержимом При упоминании версий: 1. Выделяйте текущую версию жирным: \u0026ldquo;версия 2.10.0 (сентябрь 2025)\u0026rdquo; 2. В исторических упоминаниях указывайте и номер версии, и дату 3. При необходимости указывайте версию API отдельно от версии I2P\nПример:\nManaged clients were introduced in **version 0.9.4** (December 17, 2012) and remain the recommended architecture as of **version 2.10.0** (September 9, 2025). The current API version is **0.9.66**. Документирование изменений со временем Для возможностей, которые развивались:\n**Version history:** - **0.9.4 (December 2012)** - Managed clients introduced - **0.9.42 (2019)** - clients.config.d/ directory structure added - **1.7.0 (2021)** - ShellService added for external program tracking - **2.10.0 (September 2025)** - Current release, no API changes to managed clients Уведомления об устаревании Если вы документируете устаревшие возможности:\n\u0026gt; **Deprecated:** This feature was deprecated in version X.Y.Z and will be removed \u0026gt; in version A.B.C. Use [alternative feature](link) instead. Стандарты терминологии Официальные термины I2P Используйте эти точные термины последовательно:\nCorrect Term Avoid I2P router I2P node, I2P client (ambiguous) eepsite I2P website, hidden service (Tor term) tunnel connection, circuit (Tor term) netDb network database, DHT lease set destination info destination address, endpoint base64 destination I2P address, .i2p address ### Терминология управляемого клиента При документировании управляемых клиентов:\nUse This Not This managed client managed application unmanaged client legacy client, static client ClientAppManager application manager, client manager lifecycle methods state methods, control methods client registry application registry, name service port mapper port registry, service directory ### Терминология конфигурации Correct Incorrect clients.config clients.cfg, client.config clients.config.d/ clients.d/, config.d/ router.config router.cfg i2ptunnel.config tunnel.config ### Имена пакетов и классов Всегда при первом упоминании используйте полностью квалифицированные имена, в дальнейшем — краткие имена:\nThe `net.i2p.app.ClientApp` interface requires implementation of three lifecycle methods. When a ClientApp starts, the manager calls `startup()`... Примеры кода и форматирование Примеры кода на Java Используйте правильную подсветку синтаксиса и полные примеры:\n### Example: Registering with Port Mapper \\`\\`\\`java // Register HTTP proxy service context.portMapper().register( PortMapper.SVC_HTTP_PROXY, \u0026#34;127.0.0.1\u0026#34;, 4444 ); // Later, retrieve the port int port = context.portMapper().getPort(PortMapper.SVC_HTTP_PROXY); if (port == -1) { // Service not registered } \\`\\`\\` Требования к примеру кода: 1. Добавьте комментарии, объясняющие ключевые строки 2. Покажите обработку ошибок там, где это уместно 3. Используйте реалистичные имена переменных 4. Соответствуйте соглашениям кодирования I2P (отступ в 4 пробела) 5. Покажите импорты, если из контекста это не очевидно\nПримеры конфигурации Приведите полные и корректные примеры конфигурации:\n### Example: clients.config.d/ Entry File: `clients.config.d/00-console.config` \\`\\`\\`properties # Router console configuration clientApp.0.main=net.i2p.router.web.RouterConsoleRunner clientApp.0.name=Router Console clientApp.0.args=7657 ::1,127.0.0.1 ./webapps/ clientApp.0.delay=0 clientApp.0.onBoot=true \\`\\`\\` Примеры командной строки Используйте $ для команд пользователя, # для суперпользователя:\n\\`\\`\\`bash # Install I2P on Debian/Ubuntu $ sudo apt-get install i2p # Start the router $ i2prouter start \\`\\`\\` Встроенный код Используйте обратные кавычки для: - Имена методов: startup() - Имена классов: ClientApp - Имена свойств: clientApp.0.main - Имена файлов: clients.config - Константы: SVC_HTTP_PROXY - Имена пакетов: net.i2p.app\nТон и голос Профессионально, но доступно Пишите для технической аудитории без снисходительного тона:\n❌ BAD: \u0026#34;Obviously, you should implement the startup() method.\u0026#34; ✅ GOOD: \u0026#34;Managed clients must implement the startup() method to initialize resources.\u0026#34; ❌ BAD: \u0026#34;Even a junior dev knows you need to call notify().\u0026#34; ✅ GOOD: \u0026#34;The manager requires at least one notify() call during startup to track state transitions.\u0026#34; Действительный залог Используйте активный залог для ясности:\n❌ PASSIVE: \u0026#34;The ClientAppManager is notified by the client when state changes.\u0026#34; ✅ ACTIVE: \u0026#34;The client notifies ClientAppManager when state changes.\u0026#34; Повелительное наклонение в инструкциях Используйте повелительное наклонение в процедурных материалах:\n✅ \u0026#34;Implement these three lifecycle methods:\u0026#34; ✅ \u0026#34;Call manager.notify() after changing state.\u0026#34; ✅ \u0026#34;Register services using context.portMapper().register()\u0026#34; Избегайте лишнего жаргона Объясняйте термины при первом упоминании:\n✅ GOOD: \u0026#34;The netDb (network database) stores information about I2P routers and destinations.\u0026#34; ❌ BAD: \u0026#34;Query the netDb for peer info.\u0026#34; (no explanation) Рекомендации по пунктуации Не используйте длинные тире - вместо этого используйте обычные дефисы, запятые или точки с запятой Используйте оксфордскую запятую в списках: \u0026ldquo;console, i2ptunnel, and Jetty\u0026rdquo; Точки внутри блоков кода только при грамматической необходимости Сложные перечисления используют точки с запятой, когда элементы содержат запятые Структура документа Стандартный порядок разделов Для документации по API:\nОбзор - что делает функция, для чего она нужна Реализация - как реализовать/использовать её Настройка - как её настроить Справочник по API - подробные описания методов и свойств Примеры - полные рабочие примеры Лучшие практики - советы и рекомендации История версий - когда появилась, изменения со временем Ссылки - ссылки на связанную документацию Иерархия заголовков Используйте семантические уровни заголовков:\n# Document Title (h1 - only one per document) ## Major Section (h2) ### Subsection (h3) #### Detail Section (h4) **Bold text for emphasis within sections** Информационные блоки Используйте блоки цитирования для специальных уведомлений:\n\u0026gt; **Note:** Additional information that clarifies the main content. \u0026gt; **Warning:** Important information about potential issues or breaking changes. \u0026gt; **Deprecated:** This feature is deprecated and will be removed in version X.Y.Z. \u0026gt; **Status:** Current implementation status or version information. Списки и организация Ненумерованные списки для непоследовательных элементов:\n- First item - Second item - Third item Нумерованные списки для последовательных шагов:\n1. First step 2. Second step 3. Third step Списки определений для пояснения терминов:\n**Term One** : Explanation of term one **Term Two** : Explanation of term two Распространённые ошибки, которых следует избегать 1. Схожие системы, которые часто путают Не путайте: - реестр ClientAppManager (менеджер клиентских приложений) и PortMapper - типы tunnel в i2ptunnel и константы сервиса port mapper - ClientApp и RouterApp (разные контексты) - Управляемые и неуправляемые клиенты\nВсегда уточняйте, о какой системе вы говорите:\n✅ \u0026#34;Register with ClientAppManager using manager.register(this) for name-based lookup.\u0026#34; ✅ \u0026#34;Register with PortMapper using context.portMapper().register() for port discovery.\u0026#34; 2. Ссылки на устаревшие версии Не делайте: - Называть старые версии «текущими» - Давать ссылки на устаревшую документацию API - Использовать устаревшие сигнатуры методов в примерах\nСледует: - Проверьте примечания к выпуску перед публикацией - Убедитесь, что документация по API соответствует текущей версии - Обновите примеры, чтобы использовать текущие наилучшие практики\n3. Недоступные URL-адреса Не следует: - Ссылаться только на домены .i2p без альтернатив в клирнете - Использовать битые или устаревшие URL-адреса документации - Ссылаться на локальные пути file://\nСледует: - Предоставляйте альтернативы в clearnet (открытый интернет) для всех внутренних I2P-ссылок - Проверяйте доступность URL-адресов перед публикацией - Используйте постоянные URL-адреса (geti2p.net, а не временный хостинг)\n4. Неполные примеры кода Не делайте: - Показывать фрагменты без контекста - Опускать обработку ошибок - Использовать неопределённые переменные - Пропускать операторы импорта, когда это не очевидно\nСледует: - Приводите полные, компилируемые примеры - Включайте необходимую обработку ошибок - Объясняйте, что делает каждая важная строка кода - Тестируйте примеры перед публикацией\n5. Неоднозначные утверждения ❌ \u0026#34;Some applications register services.\u0026#34; ✅ \u0026#34;Applications implementing ClientApp may register with ClientAppManager using manager.register(this) to enable name-based lookup.\u0026#34; ❌ \u0026#34;Configuration files go in the config directory.\u0026#34; ✅ \u0026#34;Modern I2P installations store client configurations in $I2P/clients.config.d/ as individual files.\u0026#34; Соглашения по Markdown Именование файлов Используйте kebab-case (слова, разделённые дефисами) для имён файлов: - managed-clients.md - port-mapper-guide.md - configuration-reference.md\nФормат фронтматтера Всегда включайте YAML фронтматтер:\n--- title: \u0026#34;Document Title\u0026#34; description: \u0026#34;Brief description under 160 characters\u0026#34; slug: \u0026#34;url-slug\u0026#34; lastUpdated: \u0026#34;2025-10\u0026#34; accurateFor: \u0026#34;2.10.0\u0026#34; reviewStatus: \u0026#34;verified\u0026#34; --- Форматирование ссылок Внутренние ссылки (внутри документации):\nSee [clients.config specification](https://geti2p.net/spec/configuration#clients-config) Внешние ссылки (на другие ресурсы):\nFor more details, see [ClientApp Javadoc](https://i2p.github.io/i2p.i2p/net/i2p/app/ClientApp.html) Ссылки на репозитории исходного кода:\nView source: [ClientApp.java](https://i2pgit.org/I2P_Developers/i2p.i2p/src/branch/master/core/java/src/net/i2p/app/ClientApp.java) Форматирование таблиц Используйте таблицы GitHub Flavored Markdown (вариант Markdown от GitHub):\n| Property | Type | Default | Description | |----------|------|---------|-------------| | `main` | String | (required) | Full class name | | `delay` | Integer | 120 | Seconds before start | | `onBoot` | Boolean | false | Force immediate start | Языковые теги для блоков кода Всегда указывайте язык для подсветки синтаксиса:\n\\`\\`\\`java // Java code \\`\\`\\` \\`\\`\\`bash # Shell commands \\`\\`\\` \\`\\`\\`properties # Configuration files \\`\\`\\` \\`\\`\\`xml \u0026lt;!-- XML files --\u0026gt; \\`\\`\\` Проверочный список Перед публикацией документации проверьте:\nВсе технические утверждения проверены по исходному коду или официальной документации Номера версий и даты актуальны Все URL-адреса доступны из clearnet (обычный интернет), либо предоставлены альтернативы Примеры кода полные и протестированы Терминология соответствует соглашениям I2P Без длинных тире (используйте обычные дефисы или другую пунктуацию) Раздел Frontmatter (метаданные в начале документа) заполнен полностью и корректно Иерархия заголовков семантическая (h1 → h2 → h3) Списки и таблицы корректно отформатированы Раздел со ссылками содержит все цитируемые источники Документ следует рекомендациям по структуре Тон профессиональный, но доступный Близкие по смыслу понятия четко разграничены Нет битых ссылок или некорректных перекрестных ссылок Примеры конфигурации валидны и актуальны Обратная связь: Если вы обнаружите проблемы или у вас есть предложения по этим рекомендациям, пожалуйста, сообщите о них через официальные каналы разработки I2P.\n","description":"Обеспечивайте согласованность, точность и доступность во всей технической документации I2P","id":"797e1cb5256ec022a3d99eefd7eda1f4","section":"docs","title":"Рекомендации по написанию документации I2P","url":"/ru/docs/writing-guidelines/"},{"categories":null,"content":"Хотите помочь сделать I2P доступным для большего числа людей по всему миру? Перевод — это один из самых ценных вкладов, которые вы можете внести в проект. Это руководство проведёт вас через процесс перевода консоли router.\nМетоды перевода Есть два способа внести вклад в переводы:\nМетод 1: Transifex (Рекомендуется) Это самый простой способ перевести I2P. Transifex предоставляет веб-интерфейс, который делает перевод простым и доступным.\nЗарегистрируйтесь на Transifex Подайте заявку на вступление в команду переводчиков I2P Начните переводить прямо в браузере Технические знания не требуются — просто зарегистрируйтесь и начните переводить!\nМетод 2: Ручной перевод Для переводчиков, которые предпочитают работать с git и локальными файлами, или для языков, ещё не настроенных на Transifex.\nТребования: - Знакомство с системой контроля версий git - Текстовый редактор или инструмент для перевода (рекомендуется POEdit) - Инструменты командной строки: git, gettext\nНастройка: 1. Присоединитесь к #i2p-dev в IRC и представьтесь 2. Обновите статус перевода на вики (запросите доступ в IRC) 3. Клонируйте соответствующий репозиторий (см. разделы ниже)\nПеревод консоли роутера Консоль роутера — это веб-интерфейс, который вы видите при запуске I2P. Его перевод помогает пользователям, которым неудобно работать на английском языке.\nИспользование Transifex (Рекомендуется) Перейдите на I2P на Transifex Выберите проект консоли router Выберите ваш язык Начните переводить Ручной перевод консоли роутера Предварительные требования: - Те же, что и для перевода веб-сайта (git, gettext) - GPG-ключ (для доступа к коммитам) - Подписанное соглашение разработчика\nКлонируйте основной репозиторий I2P:\ngit clone https://i2pgit.org/I2P_Developers/i2p.i2p.git cd i2p.i2p Файлы для перевода:\nКонсоль роутера содержит примерно 15 файлов, которые требуют перевода:\nОсновные файлы интерфейса:\napps/routerconsole/locale/messages_*.po - Основные сообщения консоли apps/routerconsole/locale-news/messages_*.po - Новостные сообщения Файлы прокси:\napps/i2ptunnel/locale/messages_*.po - Интерфейс настройки туннелей Локализации приложений:\napps/susidns/locale/messages_*.po - Интерфейс адресной книги apps/susimail/locale/messages_*.po - Интерфейс электронной почты Другие директории локализации для конкретных приложений Файлы документации:\ninstaller/resources/readme/readme_*.html - Readme для установки Файлы справки в различных приложениях Процесс перевода:\n# Update .po files from source ant extractMessages # Edit .po files with POEdit or text editor poedit apps/routerconsole/locale/messages_es.po # Build and test ant updaters # Install the update and check translations in the console Отправьте свою работу: - Создайте merge request на GitLab - Или поделитесь файлами с командой разработчиков в IRC\nИнструменты перевода POEdit (Настоятельно рекомендуется) POEdit — специализированный редактор для файлов перевода .po.\nВозможности: - Визуальный интерфейс для работы над переводом - Показывает контекст перевода - Автоматическая проверка - Доступно для Windows, macOS и Linux\nТекстовые редакторы Вы также можете использовать любой текстовый редактор: - VS Code (с расширениями для i18n) - Sublime Text - vim/emacs (для пользователей терминала)\nПроверки качества Перед отправкой: 1. Проверьте форматирование: Убедитесь, что заполнители типа %s и {0} остались без изменений 2. Протестируйте переводы: Установите и запустите I2P, чтобы увидеть, как они выглядят 3. Последовательность: Сохраняйте единообразие терминологии во всех файлах 4. Длина: Некоторые строки имеют ограничения по длине в пользовательском интерфейсе\nСоветы для переводчиков Общие рекомендации Сохраняйте единообразие: Используйте одни и те же переводы для общих терминов по всему тексту Сохраняйте форматирование: Не изменяйте HTML-теги, заполнители (%s, {0}) и разрывы строк Контекст важен: Внимательно читайте исходный английский текст, чтобы понять контекст Задавайте вопросы: Используйте IRC или форумы, если что-то неясно Общие термины I2P Некоторые термины следует оставлять на английском языке или транслитерировать осторожно:\nI2P - Keep as is eepsite - веб-сайт I2P (I2P website) tunnel - путь соединения netDb - база данных сети floodfill - тип router destination - конечная точка I2P-адреса Тестирование ваших переводов Соберите I2P с вашими переводами Измените язык в настройках консоли роутера Просмотрите все страницы, чтобы проверить: Текст помещается в элементах интерфейса Отсутствуют искаженные символы (проблемы с кодировкой) Переводы имеют смысл в контексте Часто задаваемые вопросы Почему процесс перевода такой сложный? Процесс использует систему контроля версий (git) и стандартные инструменты перевода (файлы .po), потому что:\nПодотчетность: Отслеживание того, кто, что и когда изменил Качество: Проверка изменений перед их публикацией Согласованность: Поддержание правильного форматирования и структуры файлов Масштабируемость: Эффективное управление переводами на нескольких языках Совместная работа: Несколько переводчиков могут работать над одним языком Нужны ли мне навыки программирования? Нет! Если вы используете Transifex, вам понадобится только: - Владение английским и вашим целевым языком - Веб-браузер - Базовые навыки работы с компьютером\nДля ручного перевода вам понадобятся базовые знания командной строки, но программирование не требуется.\nСколько времени это занимает? Консоль роутера: Примерно 15-20 часов на все файлы Поддержка: Несколько часов в месяц на обновление новых строк Могут ли несколько человек работать над одним языком? Да! Координация — ключевой момент: - Используйте Transifex для автоматической координации - Для ручной работы общайтесь в IRC-канале #i2p-dev - Распределяйте работу по разделам или файлам\nЧто делать, если моего языка нет в списке? Запросите его на Transifex или свяжитесь с командой в IRC. Команда разработчиков может быстро настроить новый язык.\nКак протестировать мои переводы перед отправкой? Соберите I2P из исходного кода с вашими переводами Установите и запустите локально Измените язык в настройках консоли Получение помощи Поддержка IRC Присоединяйтесь к #i2p-dev в IRC для: - Технической помощи с инструментами перевода - Вопросов по терминологии I2P - Координации с другими переводчиками - Прямой поддержки от разработчиков\nФорумы Обсуждения переводов на форумах I2P Inside I2P: Форум переводов на zzz.i2p (требуется I2P router) Документация Документация Transifex Документация POEdit Руководство gettext Благодарности Все переводчики указаны в:\nКонсоли I2P router (страница «О программе») Странице благодарностей на сайте Истории коммитов Git Объявлениях о релизах Ваша работа напрямую помогает людям по всему миру безопасно и конфиденциально использовать I2P. Спасибо за ваш вклад!\nСледующие шаги Готовы начать перевод?\nВыберите способ:\nБыстрый старт: Зарегистрируйтесь на Transifex Ручной подход: Присоединяйтесь к #i2p-dev в IRC Начните с малого: Переведите несколько строк, чтобы ознакомиться с процессом\nОбращайтесь за помощью: Не стесняйтесь обратиться в IRC или на форумы\nСпасибо за помощь в том, чтобы сделать I2P доступным для всех!\n","description":"Как помочь с переводами сайта I2P и консоли роутера используя Transifex или ручные методы","id":"a436f7ab16669c43b076458496d70009","section":"docs","title":"Руководство для новых переводчиков","url":"/ru/docs/develop/new-translators/"},{"categories":null,"content":"Итак, вы хотите начать работу над I2P? Отлично! Вот краткое руководство по началу работы: внесение вклада в веб-сайт или программное обеспечение, разработка или создание переводов.\nЕще не готовы к программированию? Попробуйте сначала принять участие .\nЗнакомство с Java I2P router и его встроенные приложения используют Java в качестве основного языка разработки. Если у вас нет опыта работы с Java, вы всегда можете ознакомиться с книгой Thinking in Java Изучите введение в \u0026ldquo;как это работает\u0026rdquo;, другие документы \u0026ldquo;как\u0026rdquo;, техническое введение и связанные документы:\nКак вступление: Введение в I2P Центр документации: Документация Техническое введение: Техническое введение Это даст вам хорошее представление о том, как устроен I2P и какие различные функции он выполняет.\nПолучение кода I2P Для разработки router или встроенных приложений необходимо получить исходный код.\nНаш текущий способ: Git I2P имеет официальные Git-сервисы и принимает вклады через Git на нашем собственном GitLab:\nВнутри I2P: http://git.idk.i2p Вне I2P: https://i2pgit.org Клонируйте основной репозиторий:\ngit clone https://i2pgit.org/I2P_Developers/i2p.i2p.git Зеркало только для чтения также доступно на GitHub:\nЗеркало на GitHub: github.com/i2p/i2p.i2p git clone https://github.com/i2p/i2p.i2p.git Сборка I2P Для компиляции кода вам потребуется Sun/Oracle Java Development Kit 6 или выше, либо эквивалентный JDK (настоятельно рекомендуется Sun/Oracle JDK 6) и Apache Ant версии 1.7.0 или выше. Если вы работаете с основным кодом I2P, перейдите в директорию i2p.i2p и выполните команду ant, чтобы увидеть доступные варианты сборки.\nДля сборки или работы над переводами консоли вам понадобятся инструменты xgettext, msgfmt и msgmerge из пакета GNU gettext.\nДля разработки новых приложений смотрите руководство по разработке приложений .\nИдеи для разработки См. список TODO проекта или список задач на GitLab для идей:\nПроблемы GitLab: i2pgit.org/I2P_Developers/i2p.i2p/issues Предоставление результатов См. нижнюю часть страницы лицензий для требований к правам commit. Они вам нужны для добавления кода в i2p.i2p (не требуется для веб-сайта!).\nСтраница лицензий Узнайте о нас! Разработчики общаются в IRC. С ними можно связаться в различных сетях и во внутренней сети I2P. Обычно их можно найти в канале #i2p-dev. Присоединяйтесь к каналу и поздоровайтесь! У нас также есть дополнительные рекомендации для постоянных разработчиков .\nПереводы Переводчики сайта и консоли роутера: См. Руководство для новых переводчиков для дальнейших шагов.\nИнструменты I2P — это программное обеспечение с открытым исходным кодом, разработка которого в основном ведется с использованием инструментов с открытым исходным кодом. Проект I2P недавно получил лицензию на YourKit Java Profiler. Проекты с открытым исходным кодом имеют право получить бесплатную лицензию при условии, что на веб-сайте проекта будет размещена ссылка на YourKit. Пожалуйста, свяжитесь с нами, если вы заинтересованы в профилировании кодовой базы I2P.\nYourKit любезно поддерживает проекты с открытым исходным кодом своими полнофункциональными профилировщиками. YourKit, LLC — создатель инновационных и интеллектуальных инструментов для профилирования Java и .NET приложений. Ознакомьтесь с ведущими программными продуктами YourKit:\nYourKit Java Profiler YourKit .NET Profiler ","description":"Как начать вносить вклад в I2P: учебные материалы, исходный код, сборка, идеи, публикация, сообщество, переводы и инструменты","id":"e74ff72be9767cc925c6712e11e5e1c5","section":"docs","title":"Руководство для новых разработчиков","url":"/ru/docs/develop/new-developers/"},{"categories":null,"content":"Сначала прочитайте Руководство для новых разработчиков .\nОсновные рекомендации и стиль кодирования Большая часть нижеследующего должна быть очевидной для любого, кто работал над открытым исходным кодом или в коммерческой среде программирования. Следующее применимо в основном к основной ветке разработки i2p.i2p. Руководства для других веток, плагинов и внешних приложений могут существенно отличаться; проконсультируйтесь с соответствующим разработчиком для получения рекомендаций.\nСообщество Пожалуйста, не просто пишите код. Если можете, участвуйте в других связанных с разработкой активностях, включая: обсуждения разработки и поддержку на IRC и i2pforum.i2p; тестирование; сообщения об ошибках и ответы на них; документацию; проверку кода; и т.д. Активные разработчики должны периодически присутствовать на IRC #i2p-dev. Следите за текущим циклом релизов. Придерживайтесь контрольных точек релиза, таких как заморозка функциональности, заморозка тегов и крайний срок регистрации изменений для релиза. Цикл релизов Обычный цикл релиза составляет 10–16 недель, четыре релиза в год. Ниже приведены приблизительные сроки в типичном 13-недельном цикле. Фактические сроки для каждого релиза устанавливаются менеджером релиза после консультации со всей командой.\n1–2 дня после предыдущего релиза: Разрешены коммиты в trunk. 2–3 недели после предыдущего релиза: Крайний срок для переноса крупных изменений из других веток в trunk. 4–5 недель до релиза: Крайний срок для запроса новых ссылок на домашней странице. 3–4 недели до релиза: Заморозка функциональности. Крайний срок для крупных новых функций. 2–3 недели до релиза: Провести собрание проекта для рассмотрения запросов на новые ссылки на домашней странице, если таковые имеются. 10–14 дней до релиза: Заморозка строк. Больше никаких изменений в переведённых (помеченных) строках. Отправить строки на Transifex, объявить крайний срок перевода на Transifex. 10–14 дней до релиза: Крайний срок функциональности. После этого времени только исправления ошибок. Никаких новых функций, рефакторинга или очистки кода. 3–4 дня до релиза: Крайний срок перевода. Получить переводы из Transifex и зафиксировать. 3–4 дня до релиза: Крайний срок коммитов. Никаких коммитов после этого времени без разрешения сборщика релиза. За несколько часов до релиза: Крайний срок проверки кода. Git Имейте базовое понимание распределенных систем управления версиями, даже если вы раньше не использовали git. Попросите помощи, если она вам нужна. После отправки коммиты остаются навсегда; отмены не существует. Пожалуйста, будьте осторожны. Если вы не использовали git раньше, начните с малого. Зафиксируйте несколько небольших изменений и посмотрите, как это работает. Тестируйте свои изменения перед их фиксацией. Если вы предпочитаете модель разработки «сначала фиксация, потом тестирование», используйте собственную ветку разработки в своём аккаунте и создайте MR после завершения работы. Не ломайте сборку. Не вызывайте регрессий. Если это всё же произошло (такое случается), пожалуйста, не исчезайте надолго после отправки своих изменений. Если ваше изменение нетривиально, или вы хотите, чтобы люди его протестировали и вам нужны качественные отчёты о тестировании, чтобы узнать, было ли ваше изменение протестировано или нет, добавьте комментарий о фиксации в history.txt и увеличьте номер ревизии сборки в RouterVersion.java. Не фиксируйте крупные изменения в основной ветке i2p.i2p в конце цикла релиза. Если проект займёт у вас больше пары дней, создайте собственную ветку в git в своём аккаунте и ведите разработку там, чтобы не блокировать релизы. Для больших изменений (как правило, более 100 строк или затрагивающих более трёх файлов) зафиксируйте их в новой ветке в своём аккаунте GitLab, создайте MR и назначьте рецензента. Назначьте MR на себя. Объедините MR самостоятельно после одобрения рецензентом. Не создавайте WIP-ветки в основном аккаунте I2P_Developers (за исключением i2p.www). WIP должен находиться в вашем собственном аккаунте. Когда работа завершена, создайте MR. Единственными ветками в основном аккаунте должны быть ветки для настоящих форков, например, для точечного релиза. Ведите разработку прозрачно и с учётом сообщества. Фиксируйте часто. Фиксируйте или объединяйте в основную ветку так часто, как это возможно, с учётом приведённых выше рекомендаций. Если вы работаете над большим проектом в своей собственной ветке/аккаунте, дайте людям знать, чтобы они могли следить за процессом и проводить ревью/тестирование/комментирование. Стиль кодирования Стиль кодирования в большей части кода — 4 пробела для отступов. Не используйте табуляцию. Не переформатируйте код. Если ваша IDE или редактор хочет всё переформатировать, возьмите это под контроль. В некоторых местах стиль кодирования отличается. Используйте здравый смысл. Имитируйте стиль в файле, который вы изменяете. Все новые публичные классы и методы уровня пакета требуют Javadocs. Добавьте @since номер-релиза. Javadocs для новых приватных методов желательны. Для любых добавленных Javadocs не должно быть ошибок или предупреждений doclint. Запустите ant javadoc с Oracle Java 14 или выше для проверки. Все параметры должны иметь строки @param, все не-void методы должны иметь строки @return, все объявленные исключения должны иметь строки @throws, и никаких HTML ошибок. Классы в core/ (i2p.jar) и части i2ptunnel являются частью нашего официального API. Существует несколько внешних плагинов и других приложений, которые полагаются на этот API. Будьте осторожны и не вносите изменения, нарушающие совместимость. Не добавляйте методы в API, если они не имеют общей полезности. Javadocs для методов API должны быть ясными и полными. Если вы добавляете или изменяете API, также обновите документацию на веб-сайте (ветка i2p.www). Помечайте строки для перевода там, где это уместно, что справедливо для всех строк пользовательского интерфейса. Не изменяйте существующие помеченные строки без крайней необходимости, так как это нарушит существующие переводы. Не добавляйте и не изменяйте помеченные строки после заморозки тегов в цикле релиза, чтобы у переводчиков была возможность обновиться перед релизом. Используйте дженерики и классы для параллельных вычислений, где это возможно. I2P — это высоко многопоточное приложение. Ознакомьтесь с распространёнными Java-ловушками, которые обнаруживаются FindBugs/SpotBugs. Запустите ant findbugs, чтобы узнать больше. Java 8 требуется для сборки и запуска I2P начиная с релиза 0.9.47. Не используйте классы или методы Java 7 или 8 во встроенных подсистемах: addressbook, core, i2ptunnel.jar (не-UI), mstreaming, router, routerconsole (только news), streaming. Эти подсистемы используются Android и встроенными приложениями, которым требуется только Java 6. Все классы должны быть доступны в Android API 14. Языковые функции Java 7 допустимы в этих подсистемах, если они поддерживаются текущей версией Android SDK и компилируются в код, совместимый с Java 6. Try‑with‑resources нельзя использовать во встроенных подсистемах, так как это требует java.lang.AutoCloseable в runtime, а это недоступно до Android API 19 (KitKat 4.4). Пакет java.nio.file нельзя использовать во встроенных подсистемах, так как он недоступен до Android API 26 (Oreo 8). Помимо указанных выше ограничений, классы, методы и конструкции Java 8 могут использоваться только в следующих подсистемах: BOB, desktopgui, i2psnark, i2ptunnel.war (UI), jetty‑i2p.jar, jsonrpc, routerconsole (кроме news), SAM, susidns, susimail, systray. Авторы плагинов могут требовать любую минимальную версию Java через файл plugin.config. Явно преобразовывайте между примитивными типами и классами; не полагайтесь на автоупаковку/распаковку. Не используйте URL. Используйте URI. Не ловите Exception. Ловите RuntimeException и проверяемые исключения по отдельности. Не используйте String.getBytes() без аргумента кодировки UTF‑8. Вы также можете использовать DataHelper.getUTF8() или DataHelper.getASCII(). Всегда указывайте кодировку UTF‑8 при чтении или записи файлов. Утилиты DataHelper могут быть полезны. Всегда указывайте локаль (например, Locale.US) при использовании String.toLowerCase() или String.toUpperCase(). Не используйте String.equalsIgnoreCase(), так как локаль не может быть указана. Не используйте String.split(). Используйте DataHelper.split(). Не добавляйте код для форматирования дат и времени. Используйте DataHelper.formatDate() и DataHelper.formatTime(). Убедитесь, что InputStreamы и OutputStreamы закрываются в блоках finally. Используйте {} для всех блоков for и while, даже если это только одна строка. Если вы используете {} для блока if, else или if-else, используйте их для всех блоков. Помещайте } else { на одну строку. Указывайте поля как final везде, где это возможно. Не храните I2PAppContext, RouterContext, Log или любые другие ссылки на router или контекстные элементы в статических полях. Не запускайте потоки в конструкторах. Используйте I2PAppThread вместо Thread. Логирование Следующие рекомендации применяются к router, веб-приложениям и всем плагинам.\nДля любых сообщений, не отображаемых на уровне журналирования по умолчанию (WARN, INFO и DEBUG), если сообщение не является статической строкой (без конкатенации), всегда используйте log.shouldWarn(), log.shouldInfo() или log.shouldDebug() перед вызовом журналирования, чтобы избежать ненужного создания объектов. Сообщения журнала, которые могут отображаться на уровне журналирования по умолчанию (ERROR, CRIT и logAlways()), должны быть краткими, понятными и доступными для нетехнического пользователя. Это включает текст причины исключения, который также может отображаться. Рассмотрите возможность перевода, если ошибка может произойти с высокой вероятностью (например, при ошибках отправки формы). В остальных случаях перевод не обязателен, но может быть полезно найти и повторно использовать строку, которая уже помечена для перевода в другом месте. Сообщения журнала, не отображаемые на уровне журналирования по умолчанию (WARN, INFO и DEBUG), предназначены для использования разработчиками и не имеют вышеуказанных требований. Однако сообщения WARN доступны во вкладке журнала Android и могут помочь пользователям в отладке проблем, поэтому проявляйте осторожность и с сообщениями WARN. Сообщения журнала INFO и DEBUG следует использовать умеренно, особенно в часто выполняемых участках кода. Хотя они полезны во время разработки, рассмотрите возможность их удаления или закомментирования после завершения тестирования. Не записывайте сообщения в stdout или stderr (журнал wrapper). Лицензии Добавляйте в репозиторий только код, который вы написали самостоятельно. Перед добавлением любого кода или библиотечных JAR-файлов из внешних источников обоснуйте необходимость этого, убедитесь в совместимости лицензии и получите одобрение от менеджера релиза. Если вы получили одобрение на добавление внешнего кода или JAR-файлов, и бинарные файлы доступны в каком-либо пакете Debian или Ubuntu, вы должны реализовать опции сборки и упаковки для использования внешнего пакета. Контрольный список файлов для изменения: build.properties, build.xml, debian/control, debian/i2p-router.install, debian/i2p-router.links, debian/rules, sub-build.xml. Для любых изображений, добавляемых из внешних источников, вы обязаны сначала проверить совместимость лицензии. Укажите информацию о лицензии и источнике в комментарии к коммиту. Ошибки Управление issues (задачами) — это работа каждого; пожалуйста, помогайте. Отслеживайте GitLab на предмет issues, с которыми вы можете помочь. Комментируйте, исправляйте и закрывайте issues, если можете. Новым разработчикам следует начинать с исправления issues. Когда у вас есть исправление, прикрепите свой патч к issue и добавьте ключевое слово review-needed. Не закрывайте issue, пока оно не будет успешно проверено и вы не зафиксируете свои изменения. После того как вы проделаете это гладко для пары тикетов, вы можете следовать обычной процедуре, описанной выше. Закрывайте issue, когда считаете, что исправили его. У нас нет тестового отдела для проверки и закрытия тикетов. Если вы не уверены, что исправили его, закройте его и добавьте примечание: \u0026ldquo;Думаю, я это исправил, пожалуйста, протестируйте и переоткройте, если всё ещё сломано\u0026rdquo;. Добавьте комментарий с номером dev build или ревизии и установите milestone (веху) на следующий релиз. ","description":"Полное руководство по внесению вклада в I2P: рабочий процесс, цикл релизов, стиль кодирования, логирование, лицензирование и работа с проблемами","id":"6c8fe691caf216ba9024152afc39c5c6","section":"docs","title":"Руководство для разработчиков и стиль кодирования","url":"/ru/docs/develop/dev-guidelines/"},{"categories":null,"content":"Данное руководство предоставляет обзор консоли I2P Router и её страниц конфигурации. Каждый раздел объясняет, что делает страница и для чего она предназначена, помогая вам понять, как отслеживать и настраивать ваш I2P router.\nДоступ к консоли роутера Консоль I2P Router — это центральный узел для управления и мониторинга вашего I2P router. По умолчанию к ней можно получить доступ по адресу I2P Router Console после запуска вашего I2P router.\nГлавная страница отображает несколько ключевых разделов:\nПриложения - Быстрый доступ к встроенным приложениям I2P, таким как электронная почта, торренты, менеджер скрытых сервисов и веб-сервер Сайты сообщества I2P - Ссылки на важные ресурсы сообщества, включая форумы, документацию и веб-сайты проекта Настройка и помощь - Инструменты для настройки параметров пропускной способности, управления плагинами и доступа к справочным ресурсам Информация о сети и для разработчиков - Доступ к графикам, логам, технической документации и статистике сети Адресная книга URL: Address Book Адресная книга I2P функционирует аналогично DNS в обычном интернете, позволяя управлять понятными для человека именами для I2P-адресатов (eepsite). Здесь вы можете просматривать и добавлять I2P-адреса в вашу личную адресную книгу.\nСистема адресной книги работает через несколько уровней:\nLocal Records - Ваши персональные адресные книги, которые хранятся только на вашем роутере\nLocal Addressbook - Хосты, которые вы добавляете вручную или сохраняете для личного использования Private Addressbook - Адреса, которыми вы не хотите делиться с другими; никогда не распространяются публично Подписки - Удалённые источники адресной книги (например, http://i2p-projekt.i2p/hosts.txt), которые автоматически обновляют адресную книгу вашего router известными I2P-сайтами\nRouter Addressbook - Объединённый результат ваших локальных записей и подписок, доступный для поиска всем I2P-приложениям на вашем роутере\nОпубликованная адресная книга (Published Addressbook) - Необязательная публичная публикация вашей адресной книги для использования другими в качестве источника подписки (полезно, если вы управляете I2P-сайтом)\nАдресная книга регулярно опрашивает ваши подписки и объединяет содержимое в адресную книгу вашего router, поддерживая ваш файл hosts.txt в актуальном состоянии с сетью I2P.\nКонфигурация URL: Расширенная конфигурация Раздел Конфигурация предоставляет доступ ко всем настройкам router через несколько специализированных вкладок.\nAdvanced Страница расширенных настроек предоставляет доступ к низкоуровневым параметрам router, которые обычно не требуются для обычной работы. Большинство пользователей не должны изменять эти настройки, если они не понимают конкретный параметр конфигурации и его влияние на поведение router.\nКлючевые особенности:\nКонфигурация Floodfill - Управление участием вашего роутера в качестве floodfill-узла, который помогает сети, храня и распространяя информацию сетевой базы данных. Это может использовать больше системных ресурсов, но укрепляет сеть I2P.\nРасширенная конфигурация I2P - Прямой доступ к файлу router.config с отображением всех расширенных параметров конфигурации, включая:\nОграничения пропускной способности и настройки пакетной передачи Настройки транспорта (NTCP2, SSU2, UDP-порты и ключи) Идентификация router и информация о версии Настройки консоли и параметры обновления Большинство расширенных параметров конфигурации не отображаются в пользовательском интерфейсе, поскольку они редко требуются. Чтобы включить редактирование этих настроек, необходимо вручную добавить routerconsole.advanced=true в файл router.config.\nПредупреждение: Неправильное изменение расширенных настроек может негативно повлиять на производительность или подключение вашего router. Изменяйте эти настройки, только если вы знаете, что делаете.\nBandwidth URL: Настройка пропускной способности Страница настройки пропускной способности позволяет вам контролировать, какую пропускную способность ваш router выделяет для сети I2P. I2P работает лучше всего, когда вы настраиваете скорости в соответствии со скоростью вашего интернет-соединения.\nКлючевые настройки:\nKBps In - Максимальная входящая пропускная способность, которую будет принимать ваш router (скорость загрузки) KBps Out - Максимальная исходящая пропускная способность, которую будет использовать ваш router (скорость отдачи) Share - Процент вашей исходящей пропускной способности, выделенный для транзитного трафика (помощь в маршрутизации трафика для других) Важные примечания:\nВсе значения указаны в байтах в секунду (КБ/с), а не в битах в секунду Чем больше пропускной способности вы предоставляете, тем больше помогаете сети и улучшаете собственную анонимность Объём исходящего трафика (KBps Out) определяет ваш общий вклад в сеть Если вы не уверены в скорости вашего подключения, используйте Тест пропускной способности для её измерения Более высокая пропускная способность улучшает как вашу анонимность, так и помогает укрепить сеть I2P Страница конфигурации показывает оценочный месячный объём передачи данных на основе ваших настроек, помогая планировать распределение пропускной способности в соответствии с лимитами вашего интернет-тарифа.\nClient Configuration URL: Конфигурация клиента Страница конфигурации клиента позволяет управлять тем, какие приложения и сервисы I2P запускаются при старте. Здесь вы можете включать или отключать встроенные клиенты I2P без их удаления.\nВажное предупреждение: Будьте осторожны при изменении настроек здесь. Консоль router и туннели приложений необходимы для большинства вариантов использования I2P. Только опытные пользователи должны изменять эти настройки.\nДоступные клиенты:\nApplication tunnels - Система I2PTunnel, которая управляет клиентскими и серверными туннелями (HTTP-прокси, IRC и т.д.) I2P Router Console - Веб-интерфейс администрирования, который вы сейчас используете I2P webserver (eepsite) - Встроенный веб-сервер Jetty для размещения вашего собственного I2P-сайта Open Router Console in web browser at startup - Автоматически открывает браузер на домашней странице консоли при запуске SAM application bridge - API-мост для подключения сторонних приложений к I2P Каждый клиент показывает:\nЗапускать при старте? - Флажок для включения/отключения автозапуска Управление - Кнопки Запуск/Остановка для немедленного контроля Класс и аргументы - Технические детали о том, как запускается клиент Изменения в настройке «Запускать при старте?» требуют перезапуска роутера для вступления в силу. Все изменения сохраняются в /var/lib/i2p/i2p-config/clients.config.d/.\nРасширенные настройки URL: Конфигурация I2CP Страница конфигурации I2CP (I2P Client Protocol) позволяет настроить способ подключения внешних приложений к вашему I2P router. I2CP — это протокол, который приложения используют для взаимодействия с router для создания tunnel и отправки/получения данных через I2P.\nВажно: Настройки по умолчанию подойдут большинству пользователей. Любые изменения, внесённые здесь, должны быть также настроены в приложении внешнего клиента. Многие клиенты не поддерживают SSL или авторизацию. Все изменения требуют перезапуска для вступления в силу.\nПараметры конфигурации:\nКонфигурация внешнего интерфейса I2CP\nВключено без SSL - Стандартный доступ I2CP (по умолчанию и наиболее совместимый) Включено с обязательным SSL - Только зашифрованные соединения I2CP Отключено - Блокирует подключение внешних клиентов через I2CP I2CP Interface - Сетевой интерфейс для прослушивания (по умолчанию: 127.0.0.1 только для localhost)\nI2CP Port - Номер порта для I2CP-соединений (по умолчанию: 7654)\nАвторизация\nТребовать имя пользователя и пароль - Включить аутентификацию для I2CP соединений Имя пользователя - Установить требуемое имя пользователя для доступа к I2CP Пароль - Установить требуемый пароль для доступа к I2CP Примечание по безопасности: Если вы запускаете приложения только на той же машине, что и ваш I2P router, оставьте интерфейс установленным на 127.0.0.1, чтобы предотвратить удалённый доступ. Изменяйте эти настройки только в том случае, если вам нужно разрешить I2P-приложениям с других устройств подключаться к вашему router.\nПропускная способность URL: Конфигурация сети Страница конфигурации сети позволяет настроить, как ваш I2P router подключается к интернету, включая определение IP-адреса, настройки IPv4/IPv6 и параметры портов для транспортов UDP и TCP.\nВнешне Доступный IP-адрес:\nИспользовать все методы автоопределения - Автоматически определяет ваш публичный IP с использованием нескольких методов (рекомендуется) Отключить определение IP-адреса через UPnP - Предотвращает использование UPnP для обнаружения вашего IP Игнорировать IP-адрес локального интерфейса - Не использовать IP вашей локальной сети Использовать только определение IP-адреса через SSU - Использовать только транспорт SSU2 для определения IP Скрытый режим - не публиковать IP - Предотвращает участие в сетевом трафике (снижает анонимность) Указать имя хоста или IP - Вручную задать ваш публичный IP или имя хоста Конфигурация IPv4:\nОтключить входящие соединения (Firewalled) - Отметьте эту опцию, если вы находитесь за firewall, домашней сетью, у провайдера с блокировкой входящих соединений, DS-Lite или carrier-grade NAT Конфигурация IPv6:\nПредпочитать IPv4 вместо IPv6 - Приоритет соединений IPv4 Предпочитать IPv6 вместо IPv4 - Приоритет соединений IPv6 (по умолчанию для двухстековых сетей) Включить IPv6 - Разрешает соединения IPv6 Отключить IPv6 - Отключает всю связь IPv6 Использовать только IPv6 (отключить IPv4) - Экспериментальный режим только IPv6 Отключить входящие соединения (за файрволом) - Отметьте, если ваш IPv6 заблокирован файрволом Действия при смене IP-адреса:\nРежим ноутбука (Laptop mode) - Экспериментальная функция, которая изменяет идентификатор router и UDP-порт при изменении вашего IP-адреса для повышенной анонимности Настройка UDP:\nSpecify Port - Установите конкретный UDP-порт для транспорта SSU2 (должен быть открыт в вашем файрволе) Completely disable - Выбирайте только если находитесь за файрволом, который блокирует весь исходящий UDP-трафик Настройка TCP:\nУкажите порт - Установите конкретный TCP-порт для транспорта NTCP2 (должен быть открыт в вашем файрволе) Использовать тот же порт, что настроен для UDP - Упрощает конфигурацию, используя один порт для обоих транспортов Использовать автоматически определённый IP-адрес - Автоматически определяет ваш публичный IP (показывает \u0026ldquo;currently unknown\u0026rdquo;, если ещё не определён или заблокирован файрволом) Всегда использовать автоматически определённый IP-адрес (не заблокирован файрволом) - Лучший вариант для роутеров с прямым доступом в интернет Отключить входящие соединения (заблокировано файрволом) - Отметьте, если TCP-соединения блокируются вашим файрволом Полностью отключить - Выбирайте только если находитесь за файрволом, который ограничивает или блокирует исходящий TCP Укажите имя хоста или IP - Вручную настройте ваш внешне доступный адрес Важно: Изменения в сетевых настройках могут требовать перезапуска роутера для полного вступления в силу. Правильная настройка переадресации портов значительно улучшает производительность вашего роутера и помогает сети I2P.\nКонфигурация клиента URL: Конфигурация пиров Страница конфигурации пиров предоставляет ручное управление отдельными пирами в сети I2P. Это расширенная функция, которая обычно используется только для устранения проблем с проблемными пирами.\nРучное управление пирами:\nRouter Hash - Введите 44-символьный base64 router hash пира, которым вы хотите управлять Вручную заблокировать / разблокировать peer:\nБлокировка узла предотвращает его участие в любых tunnel, которые вы создаёте. Это действие: - Предотвращает использование узла в ваших клиентских или исследовательских tunnel - Вступает в силу немедленно без необходимости перезапуска - Сохраняется до тех пор, пока вы вручную не разблокируете узел или не перезапустите router - Заблокировать узел до перезапуска - Временно блокирует узел - Разблокировать узел - Снимает блокировку с ранее заблокированного узла\nНастройка бонусов профиля:\nБонусы профиля влияют на то, как выбираются узлы для участия в туннеле. Бонусы могут быть положительными или отрицательными: - Быстрые узлы - Используются для клиентских туннелей, требующих высокой скорости - Высокопроизводительные узлы - Используются для некоторых исследовательских туннелей, требующих надежной маршрутизации - Текущие бонусы отображаются на странице профилей\nКонфигурация: - Скорость - Настроить бонус скорости для этого пира (0 = нейтрально) - Пропускная способность - Настроить бонус пропускной способности для этого пира (0 = нейтрально) - Применить бонусы пира - Применить настройки бонусов\nПримеры использования: - Заблокировать узел, который постоянно вызывает проблемы с соединением - Временно исключить узел, который вы подозреваете во вредоносной активности - Настроить бонусы, чтобы понизить приоритет недостаточно производительных узлов - Отладить проблемы построения tunnel, исключив определенные узлы\nПримечание: Большинству пользователей никогда не потребуется использовать эту функцию. I2P router автоматически управляет выбором узлов и их профилированием на основе метрик производительности.\nКонфигурация I2CP URL: Конфигурация Reseed Страница настройки Reseed позволяет вручную выполнить reseed вашего router, если автоматический reseed не удался. Reseeding — это процесс начальной загрузки, используемый для поиска других router при первой установке I2P или когда у вашего router осталось слишком мало ссылок на другие router.\nКогда использовать ручной Reseed:\nЕсли reseed не удался, сначала проверьте ваше сетевое подключение\nЕсли брандмауэр блокирует ваши соединения с reseed-хостами, вы можете использовать прокси:\nПрокси может быть удалённым публичным прокси или работать на вашем компьютере (localhost) Чтобы использовать прокси, настройте тип, хост и порт в разделе Конфигурация Reseed Если вы используете Tor Browser, выполните reseed через него, настроив SOCKS 5, localhost, порт 9150 Если вы используете Tor из командной строки, выполните reseed через него, настроив SOCKS 5, localhost, порт 9050 Если у вас есть несколько узлов, но нужно больше, попробуйте опцию I2P Outproxy. Оставьте поля хоста и порта пустыми. Это не сработает для начального reseed, когда у вас вообще нет узлов Затем нажмите «Сохранить изменения и выполнить reseed сейчас» Настройки по умолчанию подойдут для большинства пользователей. Изменяйте их только в том случае, если HTTPS блокируется строгим брандмауэром и reseed не удался Если вы знаете и доверяете кому-то, кто использует I2P, попросите его отправить вам файл reseed, созданный с помощью этой страницы в консоли его роутера. Затем используйте эту страницу для reseed с помощью полученного файла. Сначала выберите файл ниже. Затем нажмите «Reseed from file»\nЕсли вы знаете и доверяете кому-то, кто публикует reseed файлы, спросите у них URL. Затем используйте эту страницу для reseed с полученным URL. Сначала введите URL ниже. Затем нажмите \u0026ldquo;Reseed from URL\u0026rdquo;\nСм. FAQ для инструкций по ручной пересылке reseed\nВарианты ручного Reseed:\nReseed из URL - Введите URL zip или su3 файла из доверенного источника и нажмите \u0026ldquo;Reseed from URL\u0026rdquo;\nФормат su3 предпочтителен, так как он будет проверен как подписанный доверенным источником Формат zip не подписан; используйте zip файл только из источника, которому вы доверяете Пересев из файла - Выберите локальный zip или su3 файл, затем нажмите \u0026ldquo;Reseed from file\u0026rdquo;\nВы можете найти файлы reseed на checki2p.com/reseed Создать файл Reseed - Сгенерировать новый zip-файл reseed, которым вы можете поделиться с другими для ручного reseed\nЭтот файл никогда не будет содержать идентификатор или IP-адрес вашего собственного роутера Конфигурация Reseeding:\nНастройки по умолчанию подойдут большинству пользователей. Изменяйте их только в том случае, если HTTPS блокируется строгим файрволом и reseed не удался.\nReseed URLs - Список HTTPS-адресов серверов reseed (список по умолчанию встроен и регулярно обновляется) Proxy Configuration - Настройка HTTP/HTTPS/SOCKS-прокси, если вам необходим доступ к серверам reseed через прокси Reset URL list - Восстановить список серверов reseed по умолчанию Важно: Ручной reseed должен требоваться только в редких случаях, когда автоматический reseed многократно не срабатывает. Большинству пользователей никогда не понадобится использовать эту страницу.\nКонфигурация сети URL: Конфигурация семейства маршрутизаторов Страница настройки семейства роутеров позволяет управлять семействами роутеров. Роутеры в одном семействе используют общий ключ семейства, который идентифицирует их как управляемые одним и тем же лицом или организацией. Это предотвращает выбор нескольких контролируемых вами роутеров для одного и того же tunnel, что снизило бы анонимность.\nЧто такое Router Family?\nКогда вы управляете несколькими I2P router\u0026rsquo;ами, вам следует настроить их как часть одного семейства. Это обеспечивает: - Ваши router\u0026rsquo;ы не будут использоваться вместе в одном и том же tunnel пути - Другие пользователи сохранят надлежащую анонимность, когда их tunnel\u0026rsquo;и используют ваши router\u0026rsquo;ы - Сеть сможет правильно распределять участие в tunnel\u0026rsquo;ях\nТекущее семейство:\nНа странице отображается текущее имя семейства вашего router. Если вы не входите в семейство, это поле будет пустым.\nЭкспорт Family Key:\nЭкспортируйте секретный ключ семейства для импорта в другие маршрутизаторы, которыми вы управляете Нажмите \u0026ldquo;Export Family Key\u0026rdquo;, чтобы загрузить файл ключа семейства Импортируйте этот ключ на других маршрутизаторах, чтобы добавить их в то же семейство Покинуть семейство роутеров:\nБольше не быть членом семейства Нажмите «Покинуть семейство», чтобы удалить этот роутер из его текущего семейства Это действие нельзя отменить без повторного импорта ключа семейства Важные замечания:\nТребуется публичная регистрация: Чтобы ваша семья была признана во всей сети, ваш ключ семьи должен быть добавлен в кодовую базу I2P командой разработчиков. Это гарантирует, что все router\u0026rsquo;ы в сети знают о вашей семье. Свяжитесь с командой I2P для регистрации вашего ключа семьи, если вы управляете несколькими публичными router\u0026rsquo;ами Большинству пользователей, использующих только один router, эта функция никогда не понадобится Конфигурация семьи в основном используется операторами нескольких публичных router\u0026rsquo;ов или поставщиками инфраструктуры Примеры использования:\nРабота нескольких I2P router для обеспечения избыточности Запуск инфраструктуры, такой как reseed-серверы или outproxy, на нескольких машинах Управление сетью I2P router для организации Конфигурация пиров URL: Конфигурация туннелей Страница конфигурации туннелей позволяет настроить параметры туннелей по умолчанию как для exploratory tunnels (используемых для связи между роутерами), так и для клиентских туннелей (используемых приложениями). Настройки по умолчанию подходят большинству пользователей и должны изменяться только если вы понимаете возможные компромиссы.\nВажные предупреждения:\n⚠️ Компромисс между анонимностью и производительностью: Существует фундаментальный компромисс между анонимностью и производительностью. Tunnels длиннее 3 хопов (например, 2 хопа + 0-2 хопа, 3 хопа + 0-1 хоп, 3 хопа + 0-2 хопа) или высокое значение количества + резервного количества могут существенно снизить производительность или надёжность. Это может привести к высокой загрузке процессора и/или высокому использованию исходящей пропускной способности. Изменяйте эти настройки с осторожностью и корректируйте их при возникновении проблем.\n⚠️ Сохранение настроек: Изменения настроек исследовательских tunnel сохраняются в файле router.config. Изменения клиентских tunnel являются временными и не сохраняются. Чтобы внести постоянные изменения клиентских tunnel, см. страницу I2PTunnel .\nРазведывательные туннели:\nИсследовательские туннели используются вашим роутером для связи с netDb и участия в сети I2P.\nПараметры конфигурации для входящих (Inbound) и исходящих (Outbound) туннелей: - Length - Количество переходов (хопов) в туннеле (по умолчанию: 2-3 хопа) - Randomization - Случайное отклонение длины туннеля (по умолчанию: 0-1 хоп) - Quantity - Количество активных туннелей (по умолчанию: 2 туннеля) - Backup quantity - Количество резервных туннелей, готовых к активации (по умолчанию: 0 туннелей)\nКлиентские туннели для веб-сервера I2P:\nЭти настройки управляют туннелями для встроенного I2P веб-сервера (eepsite).\n⚠️ ПРЕДУПРЕЖДЕНИЕ ОБ АНОНИМНОСТИ - Настройки включают 1-hop tunnel. ⚠️ ПРЕДУПРЕЖДЕНИЕ О ПРОИЗВОДИТЕЛЬНОСТИ - Настройки включают большое количество tunnel.\nПараметры конфигурации для входящих (Inbound) и исходящих (Outbound) туннелей: - Length - Длина туннеля (по умолчанию: 1 hop для веб-сервера) - Randomization - Случайное отклонение в длине туннеля - Quantity - Количество активных туннелей - Backup quantity - Количество резервных туннелей\nКлиентские туннели для совместно используемых клиентов:\nЭти настройки применяются к общим клиентским приложениям (HTTP-прокси, IRC и т.д.).\nПараметры конфигурации для входящих и исходящих туннелей: - Length - Длина туннеля (по умолчанию: 3 хопа) - Randomization - Случайное отклонение длины туннеля - Quantity - Количество активных туннелей - Backup quantity - Количество резервных туннелей\nПонимание параметров туннелей:\nДлина: Более длинные туннели обеспечивают большую анонимность, но снижают производительность и надёжность Рандомизация: Добавляет непредсказуемость маршрутам туннелей, улучшая безопасность Количество: Большее количество туннелей улучшает надёжность и распределение нагрузки, но увеличивает потребление ресурсов Резервное количество: Предварительно построенные туннели, готовые заменить отказавшие туннели, повышая устойчивость Лучшие практики:\nОставляйте настройки по умолчанию, если у вас нет специфических требований Увеличивайте длину туннеля только если анонимность критически важна и вы готовы принять снижение производительности Увеличивайте количество/резервные копии только при частых сбоях туннелей Отслеживайте производительность router после внесения изменений Нажмите \u0026ldquo;Save changes\u0026rdquo; для применения изменений Конфигурация Reseed URL: Конфигурация интерфейса Страница конфигурации UI позволяет настроить внешний вид и доступность консоли вашего router, включая выбор темы, языковые предпочтения и защиту паролем.\nТема консоли роутера:\nВыберите между тёмной и светлой темами для интерфейса консоли роутера:\nТёмная - Тёмная тема (легче для глаз в условиях слабого освещения) Светлая - Светлая тема (традиционный внешний вид) Дополнительные параметры темы: - Установить тему универсально для всех приложений - Применить выбранную тему ко всем приложениям I2P, а не только к консоли router - Принудительно использовать мобильную консоль - Использовать мобильно-оптимизированный интерфейс даже в desktop браузерах - Встроить приложения Email и Torrent в консоль - Интегрировать Susimail и I2PSnark непосредственно в интерфейс консоли вместо открытия их в отдельных вкладках\nЯзык консоли роутера:\nВыберите предпочитаемый язык для интерфейса консоли роутера из выпадающего меню. I2P поддерживает множество языков, включая английский, немецкий, французский, испанский, русский, китайский, японский и другие.\nПриветствуются вклады в перевод: Если вы заметили неполные или неправильные переводы, вы можете помочь улучшить I2P, внеся вклад в проект перевода. Свяжитесь с разработчиками в #i2p-dev в IRC или проверьте отчёт о статусе перевода (ссылка на странице).\nПароль консоли роутера:\nДобавьте аутентификацию по имени пользователя и паролю для защиты доступа к консоли вашего router:\nИмя пользователя - Введите имя пользователя для доступа к консоли Пароль - Введите пароль для доступа к консоли Добавить пользователя - Создать нового пользователя с указанными учетными данными Удалить выбранное - Удалить существующие учетные записи пользователей Зачем добавлять пароль?\nПредотвращает несанкционированный локальный доступ к консоли вашего роутера Необходимо, если несколько человек пользуются вашим компьютером Рекомендуется, если консоль вашего роутера доступна в локальной сети Защищает вашу конфигурацию I2P и настройки приватности от несанкционированных изменений Примечание по безопасности: Защита паролем влияет только на доступ к веб-интерфейсу консоли роутера по адресу I2P Router Console . Она не шифрует I2P-трафик и не препятствует приложениям использовать I2P. Если вы единственный пользователь своего компьютера и консоль роутера прослушивает только localhost (по умолчанию), пароль может не понадобиться.\nКонфигурация семейства роутеров URL: Конфигурация веб-приложений Страница конфигурации WebApp позволяет управлять Java веб-приложениями, которые работают внутри вашего I2P router. Эти приложения запускаются клиентом webConsole и выполняются в той же JVM, что и router, обеспечивая интегрированную функциональность, доступную через консоль router.\nЧто такое WebApps?\nWebApps — это приложения на основе Java, которые могут быть: - Полноценными приложениями (например, I2PSnark для торрентов) - Веб-интерфейсами к другим клиентам, которые должны быть включены отдельно (например, Susidns, I2PTunnel) - Веб-приложениями без веб-интерфейса (например, адресная книга)\nВажные замечания:\nВеб-приложение может быть полностью отключено, или может быть отключено только при запуске Удаление war-файла из директории webapps полностью отключает веб-приложение Однако .war файл и директория веб-приложения появятся снова, когда вы обновите router до новой версии Для постоянного отключения веб-приложения: Отключите его здесь, это предпочтительный метод Доступные веб-приложения:\nWebApp Description i2psnark Torrents - Built-in BitTorrent client for I2P i2ptunnel Hidden Services Manager - Configure client and server tunnels imagegen Identification Image Generator - Creates unique identicons jsonrpc jsonrpc.war - JSON-RPC API interface (disabled by default) routerconsole I2P Router Console - The main administrative interface susidns Address Book - Manage I2P addresses and subscriptions susimail Email - Web-based email client for I2P Элементы управления: Для каждого веб-приложения: - Запускать при старте? - Флажок для включения/отключения автоматического запуска - Управление - Кнопки Старт/Стоп для немедленного управления - Стоп - Останавливает текущее работающее веб-приложение - Старт - Запускает остановленное веб-приложение\nКнопки конфигурации:\nОтмена - Отменить изменения и вернуться на предыдущую страницу Сохранить конфигурацию WebApp - Сохранить изменения и применить их Варианты использования:\nОстановите I2PSnark, если не используете торренты, чтобы сэкономить ресурсы Отключите jsonrpc, если не нужен доступ к API Остановите Susimail, если используете внешний почтовый клиент Временно остановите веб-приложения, чтобы освободить память или устранить проблемы Совет по производительности: Отключение неиспользуемых веб-приложений может снизить потребление памяти и улучшить производительность роутера, особенно на системах с ограниченными ресурсами.\nHelp URL: Помощь Страница Помощи предоставляет исчерпывающую документацию и ресурсы, которые помогут вам эффективно понять и использовать I2P. Она служит центральным узлом для устранения неполадок, обучения и получения поддержки.\nЧто вы найдете:\nРуководство по быстрому началу работы - Основная информация для новых пользователей, начинающих работу с I2P Часто задаваемые вопросы (FAQ) - Ответы на распространённые вопросы об установке, настройке и использовании I2P Устранение неполадок - Решения типичных проблем и проблем с подключением Техническая документация - Подробная информация о протоколах I2P, архитектуре и спецификациях Руководства по приложениям - Инструкции по использованию приложений I2P, таких как торренты, электронная почта и скрытые сервисы Информация о сети - Понимание того, как работает I2P и что обеспечивает его безопасность Ресурсы поддержки - Ссылки на форумы, IRC-каналы и поддержку сообщества Получение помощи:\nЕсли у вас возникли проблемы с I2P: 1. Ознакомьтесь с FAQ для получения ответов на часто задаваемые вопросы 2. Изучите раздел устранения неполадок для вашей конкретной проблемы 3. Посетите форум I2P по адресу i2pforum.i2p или i2pforum.net 4. Присоединяйтесь к IRC-каналу #i2p для получения поддержки сообщества в режиме реального времени 5. Воспользуйтесь поиском в документации для получения подробной технической информации\nСовет: Страница справки всегда доступна из боковой панели консоли роутера, что позволяет легко найти помощь в любой момент, когда она вам понадобится.\nPerformance Graphs URL: Графики производительности Страница графиков производительности предоставляет визуальный мониторинг в реальном времени производительности вашего I2P router и сетевой активности. Эти графики помогают понять использование пропускной способности, подключения к узлам, потребление памяти и общее состояние router.\nДоступные графики:\nИспользование полосы пропускания\nСкорость отправки на низком уровне (байт/сек) - Скорость исходящего трафика Скорость приёма на низком уровне (байт/сек) - Скорость входящего трафика Показывает текущее, среднее и максимальное использование полосы пропускания Помогает отслеживать приближение к настроенным лимитам полосы пропускания Активные пиры\nrouter.activePeers усреднённое за 60 сек - Количество пиров, с которыми вы активно взаимодействуете Показывает состояние вашего сетевого подключения Большее количество активных пиров обычно означает лучшее построение tunnel и участие в сети Использование памяти роутером\nrouter.memoryUsed усреднённое за 60 сек - потребление памяти JVM Показывает текущее, среднее и максимальное использование памяти в МБ Полезно для выявления утечек памяти или определения необходимости увеличения размера кучи Java Настройка отображения графика:\nНастройте отображение и обновление графиков:\nРазмер графика - Установите ширину (по умолчанию: 400 пикселей) и высоту (по умолчанию: 100 пикселей) Период отображения - Временной диапазон для отображения (по умолчанию: 60 минут) Задержка обновления - Как часто обновляются графики (по умолчанию: 5 минут) Тип графика - Выберите между отображением средних значений или событий Скрыть легенду - Удалить легенду с графиков для экономии места UTC - Использовать время UTC вместо местного времени на графиках Сохранение данных - Хранить данные графиков на диске для исторического анализа Дополнительные параметры:\nНажмите [Select Stats], чтобы выбрать, какую статистику отображать на графике: - Метрики tunnel (успешность построения, количество tunnel и т.д.) - Статистика базы данных сети - Статистика транспорта (NTCP2, SSU2) - Производительность клиентских tunnel - И множество других детальных метрик\nВарианты использования:\nОтслеживайте пропускную способность, чтобы убедиться, что не превышаете заданные лимиты Проверяйте подключение к пирам при диагностике сетевых проблем Контролируйте использование памяти для оптимизации настроек Java heap Выявляйте закономерности производительности с течением времени Диагностируйте проблемы построения tunnel путём сопоставления графиков Совет: Нажмите «Сохранить настройки и перерисовать графики» после внесения изменений, чтобы применить вашу конфигурацию. Графики обновятся автоматически в соответствии с установленной задержкой обновления.\n","description":"Полное руководство по пониманию и настройке консоли I2P Router Console","id":"c46f1b6edeab9b686fd57cf9b311df1c","section":"docs","title":"Руководство по настройке консоли маршрутизатора","url":"/ru/docs/guides/router-console-config/"},{"categories":null,"content":" Область действия: Это руководство объединяет реализацию tunnel, формат сообщений и обе спецификации создания tunnel (ECIES и устаревший ElGamal). Существующие глубокие ссылки продолжают работать через приведённые выше псевдонимы.\nМодель Tunnel I2P пересылает полезные данные через однонаправленные tunnels: упорядоченные наборы router, которые передают трафик в одном направлении. Полный обмен данными между двумя конечными точками требует четырёх tunnels (два исходящих, два входящих).\nНачните с раздела Обзор Tunnel по терминологии, затем используйте это руководство для подробностей работы.\nЖизненный цикл сообщения tunnel шлюз группирует одно или несколько сообщений I2NP, фрагментирует их и записывает инструкции доставки. Шлюз инкапсулирует полезную нагрузку в фиксированное по размеру (1024 B) сообщение tunnel, добавляя заполнение при необходимости. Каждый участник проверяет предыдущий хоп, применяет свой слой шифрования и пересылает {nextTunnelId, nextIV, encryptedPayload} следующему хопу. tunnel конечная точка удаляет последний слой, обрабатывает инструкции доставки, заново собирает фрагменты и передаёт восстановленные сообщения I2NP. Обнаружение дубликатов использует затухающий фильтр Блума, в котором ключом служит XOR от IV (вектор инициализации) и первого блока шифротекста, чтобы предотвратить атаки с маркировкой, основанные на подмене IV.\nРоли вкратце Role Pre-processing Crypto Operation Post-processing Outbound gateway (creator) Fragment, batch, pad Iteratively decrypt using every hop’s keys (so downstream peers encrypt) Forward to first hop Participant — Encrypt IV and payload with hop keys Forward to next hop Outbound endpoint — Encrypt once more to reveal plaintext payload Deliver to target tunnel/destination Inbound gateway Fragment, batch, pad Encrypt with local keys Forward to next hop Inbound endpoint (creator) — Iteratively decrypt using stored hop keys Reassemble and deliver locally ### Процесс шифрования {#encryption-workflow} Входящие tunnels: шлюз один раз шифрует своим ключом уровня; последующие участники продолжают шифровать, пока создатель не расшифрует конечную полезную нагрузку. Исходящие tunnels: шлюз предварительно применяет обратное преобразование шифрования для каждого перехода, так что каждый участник шифрует. Когда конечная точка шифрует, исходный открытый текст шлюза восстанавливается. Оба направления пересылают {tunnelId, IV, encryptedPayload} на следующий хоп.\nФормат сообщения tunnel Шлюзы tunnel разбивают сообщения I2NP на оболочки фиксированного размера, чтобы скрыть длину полезной нагрузки и упростить обработку на каждом хопе.\nЗашифрованная структура +----------------+----------------+-------------------+ | Tunnel ID (4B) | IV (16B) | Encrypted payload | +----------------+----------------+-------------------+ Tunnel ID – 32-битный идентификатор следующего узла (ненулевой, обновляется при каждом цикле построения). IV – 16-байтный AES IV, выбирается для каждого сообщения. Encrypted payload – 1008 байт шифротекста AES-256-CBC. Общий размер: 1028 байт.\nРасшифрованная структура После снятия промежуточным узлом своего слоя шифрования:\n[Checksum (4B)][Padding ... 0x00 terminator] [Delivery Instructions 1][I2NP fragment 1] [Delivery Instructions 2][I2NP fragment 2] ... Контрольная сумма проверяет целостность расшифрованного блока. Дополнение (padding) — случайные ненулевые байты, оканчивающиеся нулевым байтом. Инструкции доставки сообщают конечной точке, как обрабатывать каждый фрагмент (доставить локально, переслать в другой tunnel и т. п.). Фрагменты содержат исходные сообщения I2NP; конечная точка собирает их, прежде чем передать на вышележащие уровни. Этапы обработки Шлюзы фрагментируют и ставят в очередь сообщения I2NP, ненадолго удерживая частичные фрагменты для последующей сборки. Шлюз шифрует полезную нагрузку соответствующими ключами уровня и устанавливает tunnel ID и IV (вектор инициализации). Каждый участник шифрует IV (AES-256/ECB), затем полезную нагрузку (AES-256/CBC), после чего повторно шифрует IV и пересылает сообщение. Конечная точка расшифровывает в обратном порядке, проверяет контрольную сумму, обрабатывает инструкции доставки и собирает фрагменты. Создание tunnel (ECIES-X25519) Современные routers создают tunnels с ключами ECIES-X25519, что уменьшает размер сообщений построения и обеспечивает прямую секретность.\nСообщение построения: одно сообщение I2NP TunnelBuild (или VariableTunnelBuild) переносит 1–8 зашифрованных записей построения, по одной на каждый hop (переход). Ключи слоя: создатель выводит для каждого хопа ключи слоя, IV и ключи ответа с помощью HKDF, используя статический X25519-идентификатор хопа и свой эфемерный ключ. Обработка: каждый хоп расшифровывает свою запись, проверяет флаги запроса, записывает блок ответа (успех или подробный код ошибки), повторно шифрует оставшиеся записи и пересылает сообщение дальше. Ответы: создатель получает ответное сообщение, упакованное с garlic encryption. Записи, помеченные как неуспешные, содержат код уровня серьёзности, чтобы router мог профилировать пира. Совместимость: routers всё ещё могут принимать устаревшие построения ElGamal для обратной совместимости, но новые tunnels по умолчанию используют ECIES. За константами для каждого поля и примечаниями по выведению ключей см. историю предложений ECIES (схема интегрированного шифрования на эллиптических кривых) и исходный код router; это руководство описывает последовательность работы.\nУстаревшее создание Tunnel (ElGamal-2048) Первоначальный формат построения tunnel использовал открытые ключи ElGamal. Современные routers сохраняют ограниченную поддержку для обратной совместимости.\nСтатус: Устарело. Оставлено здесь для исторической справки и для тех, кто поддерживает инструменты, совместимые с устаревшими версиями.\nНеинтерактивное телескопирование: одно сообщение построения проходит по всему маршруту. Каждый хоп расшифровывает свою 528-байтовую запись, обновляет сообщение и пересылает его дальше. Переменная длина: Variable Tunnel Build Message (VTBM; переменное сообщение построения tunnel) допускало 1–8 записей. Более раннее фиксированное сообщение всегда содержало восемь записей, чтобы скрыть длину tunnel. Структура записи запроса: Bytes 0–3 : Tunnel ID (receiving ID) Bytes 4–35 : Current hop router hash Bytes 36–39 : Next tunnel ID Bytes 40–71 : Next hop router hash Bytes 72–103 : AES-256 layer key Bytes 104–135: AES-256 IV key Bytes 136–167: AES-256 reply key Bytes 168–183: AES-256 reply IV Byte 184 : Flags (bit7=IBGW, bit6=OBEP) Bytes 185–188: Request time (hours since epoch) Bytes 189–192: Next message ID Bytes 193–221: Padding Флаги: бит 7 обозначает входной шлюз (IBGW); бит 6 помечает исходящую конечную точку (OBEP). Они взаимно исключают друг друга. Шифрование: каждая запись зашифрована с помощью ElGamal-2048 с использованием открытого ключа хопа. Многослойное симметричное шифрование AES-256-CBC обеспечивает, что только целевой хоп может прочитать свою запись. Ключевые факты: идентификаторы tunnel — это ненулевые 32-битные значения; создатели могут вставлять фиктивные записи, чтобы скрыть фактическую длину tunnel; надежность зависит от повторных попыток при неудачных построениях. Пулы Tunnel и жизненный цикл Routers поддерживают независимые входящие и исходящие tunnel-пулы для исследовательского трафика и для каждой сессии I2CP.\nВыбор пиров: исследовательские tunnels выбираются из бакета пиров “активные, без сбоев” для повышения разнообразия; клиентские tunnels предпочитают быстрых пиров с высокой пропускной способностью. Детерминированная упорядоченность: пиры сортируются по расстоянию XOR между SHA256(peerHash || poolKey) и случайным ключом пула. Ключ сменяется при перезапуске, обеспечивая стабильность в рамках одного запуска и затрудняя атаки предшественника между запусками. Жизненный цикл: routers отслеживают исторические времена построения для каждого кортежа {mode, direction, length, variance}. По мере приближения срока истечения tunnels замены запускаются заранее; router увеличивает число параллельных сборок при сбоях, ограничивая максимальное количество незавершённых попыток. Параметры конфигурации: число активных/резервных tunnels, длина хопа и вариация, разрешение zero-hop (0 хопов), а также лимиты скорости построения — всё настраивается для каждого пула. Перегрузка и надёжность Хотя tunnels напоминают цепочки, routers рассматривают их как очереди сообщений. Взвешенное случайное раннее отбрасывание (Weighted Random Early Discard, WRED) используется, чтобы поддерживать задержку в заданных пределах:\nВероятность отбрасывания растёт по мере приближения загрузки к настроенным пределам. Участники используют фрагменты фиксированного размера; шлюзы/конечные точки отбрасывают на основании суммарного размера фрагментов, отдавая приоритет отбрасыванию крупных полезных нагрузок. Исходящие конечные точки отбрасывают раньше других ролей, чтобы минимизировать напрасные затраты сетевых ресурсов. Гарантированная доставка оставлена более высоким уровням, таким как Streaming library (библиотека потоковой передачи данных) . Приложения, которым требуется надежность, должны самостоятельно обрабатывать повторную передачу и подтверждения.\nДополнительные материалы Выбор пиров Обзор Tunnel Старая реализация Tunnel ","description":"Унифицированная спецификация для построения, шифрования и передачи трафика с использованием I2P tunnels.","id":"6fb0b76b8bc10fa3e571b748f502baaa","section":"docs","title":"Руководство по работе с tunnel","url":"/ru/docs/specs/implementation/"},{"categories":null,"content":"Чаще всего сбои I2P router происходят из‑за проблем с пробросом портов, недостаточного выделения полосы пропускания и недостаточного времени на инициализацию. Эти три фактора объясняют более 70% сообщённых проблем. Router требует как минимум 10-15 минут после запуска для полной интеграции в сеть, 128 KB/sec минимальной полосы пропускания (рекомендуется 256 KB/sec) и корректный проброс портов UDP/TCP для достижения статуса non-firewalled (без блокировки фаерволом). Новые пользователи часто ожидают немедленной связности и слишком рано перезапускают router, что сбрасывает прогресс интеграции и создаёт раздражающий замкнутый цикл. В этом руководстве приведены подробные решения всех основных проблем I2P, затрагивающих версии 2.10.0 и новее.\nАрхитектура анонимности I2P по своей природе жертвует скоростью ради конфиденциальности за счёт многохоповых шифрованных tunnel-ов. Понимание этого фундаментального дизайна помогает пользователям формировать реалистичные ожидания и эффективно устранять неполадки, вместо того чтобы принимать нормальное поведение за проблемы.\nRouter не запускается или сразу аварийно завершает работу Наиболее распространённые сбои при запуске вызваны конфликтами портов, несовместимостью версии Java или повреждёнными файлами конфигурации. Прежде чем углубляться в диагностику, проверьте, не запущен ли уже другой экземпляр I2P.\nУбедитесь, что нет конфликтующих процессов:\nLinux: ps aux | grep i2p или netstat -tulpn | grep 7657\nWindows: Диспетчер задач → Подробности → найдите java.exe с i2p в командной строке\nmacOS: Мониторинг системы → найдите \u0026ldquo;i2p\u0026rdquo;\nЕсли существует процесс-зомби, завершите его: pkill -9 -f i2p (Linux/Mac) или taskkill /F /IM javaw.exe (Windows)\nПроверьте совместимость версии Java:\nI2P 2.10.0+ требует минимум Java 8, рекомендуется Java 11 или новее. Проверьте, что ваша установка показывает \u0026ldquo;mixed mode\u0026rdquo; (а не \u0026ldquo;interpreted mode\u0026rdquo;):\njava -version Должно отображаться: OpenJDK или Oracle Java, версия 8+, \u0026ldquo;mixed mode\u0026rdquo;\nИзбегайте: GNU GCJ, устаревшие реализации Java, режимы только интерпретации\nЧастые конфликты портов возникают, когда несколько служб конкурируют за порты I2P по умолчанию. Консоль router (7657), I2CP (7654), SAM (7656) и HTTP‑прокси (4444) должны быть свободны. Проверьте наличие конфликтов: netstat -ano | findstr \u0026quot;7657 4444 7654\u0026quot; (Windows) или lsof -i :7657,4444,7654 (Linux/Mac).\nПовреждение файла конфигурации проявляется немедленными аварийными завершениями работы с ошибками разбора в журналах. Router.config требует кодировку UTF-8 без BOM, использует = в качестве разделителя (не :) и запрещает использование некоторых специальных символов. Создайте резервную копию, затем проверьте: ~/.i2p/router.config (Linux), %LOCALAPPDATA%\\I2P\\router.config (Windows), ~/Library/Application Support/i2p/router.config (macOS).\nЧтобы сбросить конфигурацию с сохранением идентичности: остановите I2P, сделайте резервную копию router.keys и каталога keyData, удалите router.config, перезапустите. router заново сгенерирует конфигурацию по умолчанию.\nСлишком маленький размер кучи Java вызывает сбои с ошибкой OutOfMemoryError. Отредактируйте wrapper.config и увеличьте wrapper.java.maxmemory с значения по умолчанию 128 или 256 до минимум 512 (1024 для routers с высокой пропускной способностью). Это требует полной остановки, ожидания 11 минут, затем перезапуска - нажатие \u0026ldquo;Restart\u0026rdquo; в консоли не применит изменение.\nУстранение статуса \u0026ldquo;Network: Firewalled\u0026rdquo; Статус Firewalled означает, что router не может принимать прямые входящие соединения, вынуждая полагаться на introducers (узлы-интродьюсеры). Пока router работает в этом состоянии, производительность значительно снижается и вклад в сеть остаётся минимальным. Для достижения состояния non-firewalled (без блокировки файрволом) требуется корректный проброс портов.\nrouter случайным образом выбирает порт в диапазоне 9000-31000 для связи. Узнайте свой порт на http://127.0.0.1:7657/confignet - найдите \u0026ldquo;UDP Port\u0026rdquo; и \u0026ldquo;TCP Port\u0026rdquo; (обычно это одно и то же число). Для оптимальной производительности необходимо настроить переадресацию портов и UDP, и TCP, хотя один только UDP обеспечивает базовую функциональность.\nВключить автоматический проброс портов через UPnP (самый простой способ):\nОткройте http://127.0.0.1:7657/confignet Отметьте \u0026ldquo;Enable UPnP\u0026rdquo; Сохраните изменения и перезапустите router Подождите 5–10 минут и убедитесь, что статус изменился с \u0026ldquo;Network: Firewalled\u0026rdquo; на \u0026ldquo;Network: OK\u0026rdquo; UPnP требует поддержки со стороны router (по умолчанию включена на большинстве потребительских routers, выпущенных после 2010 года) и корректной настройки сети.\nРучной проброс портов (требуется, если UPnP не работает):\nЗапишите ваш I2P‑порт со страницы http://127.0.0.1:7657/confignet (например, 22648) Найдите свой локальный IP‑адрес: ipconfig (Windows), ip addr (Linux), Системные настройки → Сеть (macOS) Откройте админ‑интерфейс вашего router (обычно 192.168.1.1 или 192.168.0.1) Перейдите к Переадресации портов (может находиться в разделах Advanced, NAT или Virtual Servers) Создайте два правила: Внешний порт: [ваш I2P‑порт] → Внутренний IP: [ваш компьютер] → Внутренний порт: [тот же] → Протокол: UDP Внешний порт: [ваш I2P‑порт] → Внутренний IP: [ваш компьютер] → Внутренний порт: [тот же] → Протокол: TCP Сохраните конфигурацию и при необходимости перезагрузите ваш router Проверьте переадресацию портов с помощью онлайн-сервисов проверки после настройки. Если проверка не удаётся, проверьте настройки брандмауэра - как системный брандмауэр, так и брандмауэр антивируса должны разрешать порт I2P.\nАльтернатива Hidden mode для ограничительных сетей, где проброс портов невозможен: Включите на http://127.0.0.1:7657/confignet → отметьте \u0026ldquo;Hidden mode\u0026rdquo;. router остаётся за файерволом, но оптимизирует работу для этого состояния, используя исключительно интродьюсеров SSU. Производительность будет ниже, но работоспособность сохранится.\nRouter застрял в состояниях \u0026ldquo;Starting\u0026rdquo; или \u0026ldquo;Testing\u0026rdquo; Эти временные состояния в ходе первичной загрузки обычно проходят в течение 10-15 минут для новых установок или 3-5 минут для уже функционирующих routers. Преждевременное вмешательство часто усугубляет проблемы.\n\u0026ldquo;Network: Testing\u0026rdquo; означает, что router проверяет достижимость через различные типы соединений (прямое, introducers (узлы-посредники для установления соединений), несколько версий протокола). Это нормально в течение первых 5-10 минут после запуска. Router тестирует несколько сценариев, чтобы определить оптимальную конфигурацию.\n\u0026ldquo;Rejecting tunnels: starting up\u0026rdquo; появляется на этапе начальной инициализации (bootstrap), когда у router недостаточно информации о пирах. Router не будет участвовать в транзитном трафике, пока не будет достаточно интегрирован в сеть. Это сообщение должно исчезнуть через 10–20 минут, когда в netDb накопится информация о 50+ routers.\nРассинхронизация часов срывает проверку доступности. I2P требует, чтобы системное время отличалось от сетевого не более чем на ±60 секунд. Разница более 90 секунд приводит к автоматическому отклонению соединений. Синхронизируйте системные часы:\nLinux: sudo timedatectl set-ntp true \u0026amp;\u0026amp; sudo systemctl restart systemd-timesyncd\nWindows: Панель управления → Дата и время → Время по Интернету → Обновить сейчас → Включить автоматическую синхронизацию\nmacOS: Системные настройки → Дата и время → Включить «Устанавливать дату и время автоматически»\nПосле корректировки смещения часов полностью перезапустите I2P для корректной интеграции.\nНедостаточное выделение полосы пропускания не позволяет успешно выполнить тестирование. router нуждается в достаточной пропускной способности для построения тестовых tunnels. Настройте по адресу http://127.0.0.1:7657/config:\nМинимально достаточная: Входящая 96 КБ/с, Исходящая 64 КБ/с Рекомендуемый стандарт: Входящая 256 КБ/с, Исходящая 128 КБ/с Оптимальная производительность: Входящая 512+ КБ/с, Исходящая 256+ КБ/с Процент отдачи: 80% (позволяет router выделять полосу пропускания для сети) Более низкая пропускная способность может работать, но увеличивает время интеграции с минут до часов.\nПовреждённый netDb из‑за некорректного завершения работы или ошибок диска вызывает бесконечные циклы тестирования. router не может завершить тестирование без корректных данных о пирах:\n# Stop I2P completely i2prouter stop # or systemctl stop i2p # Delete corrupted database (safe - will reseed automatically) rm -rf ~/.i2p/netDb/* # Restart and allow 10-15 minutes for reseed i2prouter start Windows: Удалите содержимое %APPDATA%\\I2P\\netDb\\ или %LOCALAPPDATA%\\I2P\\netDb\\\nБлокировка reseed (процедуры получения начальных пиров) брандмауэром не позволяет получить начальные пиры. Во время начальной инициализации I2P получает информацию о router с HTTPS-серверов reseed. Корпоративные/провайдерские брандмауэры могут блокировать эти соединения. Настройте прокси для reseed на http://127.0.0.1:7657/configreseed, если работаете в ограничительных сетях.\nНизкие скорости, тайм-ауты и сбои при построении tunnel Архитектура I2P по своей природе приводит к скоростям в 3–10 раз ниже, чем в открытом интернете (clearnet) из‑за многохопового шифрования, накладных расходов на уровне пакетов и непредсказуемости маршрутов. Построение tunnel проходит через несколько routers, и каждый из них добавляет задержку. Понимание этого помогает не принимать нормальное поведение за проблемы.\nТипичные ожидания по производительности:\nПросмотр .i2p-сайтов: поначалу загрузка страниц занимает 10-30 секунд, быстрее после установления tunnel Загрузка торрентов через I2PSnark: 10-100 КБ/с на торрент в зависимости от количества сидеров и условий в сети Загрузка больших файлов: требуется терпение - файлы размером в мегабайты могут занимать минуты, гигабайты - часы Первое подключение самое медленное: построение tunnel занимает 30-90 секунд; последующие подключения используют существующие tunnels Показатель успешности построения Tunnel указывает на состояние сети. Проверьте на http://127.0.0.1:7657/tunnels:\nВыше 60%: Нормальная, стабильная работа 40-60%: Погранично, рассмотрите увеличение пропускной способности или снижение нагрузки Ниже 40%: Проблемно - указывает на недостаточную пропускную способность, проблемы с сетью или неудачный выбор пиров Увеличьте выделение пропускной способности в качестве первоочередной оптимизации. Большинство случаев низкой производительности связано с нехваткой пропускной способности. На http://127.0.0.1:7657/config увеличивайте лимиты постепенно и следите за графиками на http://127.0.0.1:7657/graphs.\nДля DSL/Cable (подключения 1-10 Мбит/с): - Входящая: 400 КБ/с - Исходящая: 200 КБ/с - Доля: 80% - Память: 384 МБ (измените wrapper.config)\nДля высокоскоростных подключений (10-100+ Мбит/с): - Входящая скорость: 1500 КБ/с - Исходящая скорость: 1000 КБ/с - Доля: 80-100% - Память: 512-1024 МБ - Рассмотрите: увеличить число участвующих tunnels до 2000-5000 на http://127.0.0.1:7657/configadvanced\nОптимизируйте конфигурацию tunnel для повышения производительности. Перейдите к настройкам отдельных tunnel по адресу http://127.0.0.1:7657/i2ptunnel и отредактируйте каждый tunnel:\nКоличество tunnel: Увеличьте с 2 до 3-4 (больше доступных маршрутов) Количество резервных: Установите 1-2 (быстрое переключение на резерв при сбое tunnel) Длина tunnel: По умолчанию 3 хопа обеспечивают хороший баланс; уменьшение до 2 повышает скорость, но снижает анонимность Нативная криптографическая библиотека (jbigi) обеспечивает производительность в 5–10 раз выше, чем шифрование на чистой Java. Проверьте, что библиотека загружена, на http://127.0.0.1:7657/logs - ищите \u0026ldquo;jbigi loaded successfully\u0026rdquo; или \u0026ldquo;Using native CPUID implementation\u0026rdquo;. Если отсутствует:\nLinux: Обычно автоматически обнаруживается и загружается из ~/.i2p/jbigi-*.so Windows: Проверьте наличие jbigi.dll в каталоге установки I2P Если отсутствует: Установите инструменты сборки и соберите из исходников или скачайте предварительно собранные бинарные файлы из официальных репозиториев\nПоддерживайте непрерывную работу router. Каждый перезапуск сбрасывает интеграцию, из‑за чего требуется 30–60 минут на восстановление сети tunnel и связей с пирами. Стабильные router с высоким аптаймом получают приоритет при построении tunnel, что создает положительную обратную связь, улучшая производительность.\nВысокая загрузка процессора и потребление памяти Чрезмерное потребление ресурсов обычно указывает на недостаточное выделение памяти, отсутствие нативных криптографических библиотек или чрезмерную степень участия в сети. Хорошо настроенные routers должны потреблять 10–30% CPU при активном использовании и поддерживать стабильное использование памяти ниже 80% от выделенной кучи.\nПроблемы с памятью проявляются следующим образом: - Графики использования памяти с плоской вершиной (зафиксированы на максимуме) - Частые сборки мусора (пилообразный рисунок с резкими провалами) - OutOfMemoryError в журналах - Router становится неотзывчивым под нагрузкой - Автоматическое завершение работы из‑за исчерпания ресурсов\nУвеличьте размер кучи Java в wrapper.config (требуется полная остановка):\n# Linux: ~/.i2p/wrapper.config # Windows: %APPDATA%\\I2P\\wrapper.config # Find and modify: wrapper.java.maxmemory=512 # Recommendations by usage: # Light browsing only: 256 # Standard use (browsing + light torrenting): 512 # Heavy use (multiple applications, active torrenting): 768-1024 # Floodfill or very high bandwidth: 1024-2048 Критично: После редактирования wrapper.config необходимо полностью остановить (а не перезапускать), подождать 11 минут для корректного завершения работы, затем запустить заново. Кнопка «Restart» в консоли router не перечитывает настройки wrapper.\nОптимизация CPU требует нативной криптографической библиотеки. Операции BigInteger в чистой Java потребляют в 10-20 раз больше ресурсов CPU, чем нативные реализации. Проверьте состояние jbigi по адресу http://127.0.0.1:7657/logs во время запуска. Без jbigi нагрузка на CPU будет подскакивать до 50-100% во время построения tunnel и операций шифрования.\nСнизьте нагрузку от участвующих tunnel если router перегружен:\nОткройте http://127.0.0.1:7657/configadvanced Установите router.maxParticipatingTunnels=1000 (по умолчанию 8000) Уменьшите долю шеринга на http://127.0.0.1:7657/config с 80% до 50% Отключите режим floodfill, если он включен: router.floodfillParticipant=false Ограничьте полосу пропускания I2PSnark и количество одновременно активных торрентов. Торрент-трафик потребляет значительные ресурсы. На http://127.0.0.1:7657/i2psnark:\nОграничьте число активных торрентов до 3-5 Установите \u0026ldquo;Up BW Limit\u0026rdquo; и \u0026ldquo;Down BW Limit\u0026rdquo; на разумные значения (по 50-100 KB/sec каждый) Останавливайте торренты, когда они не нужны Избегайте одновременной раздачи десятков торрентов Следите за использованием ресурсов через встроенные графики по адресу http://127.0.0.1:7657/graphs. Память должна иметь запас, а не образовывать плато на максимуме. Всплески загрузки CPU во время построения tunnel — это нормально; устойчиво высокая загрузка CPU указывает на проблемы с конфигурацией.\nДля систем с сильно ограниченными ресурсами (Raspberry Pi, старое оборудование) рассмотрите i2pd (реализация на C++) в качестве альтернативы. i2pd требует ~130 МБ ОЗУ, по сравнению с 350+ МБ для Java I2P, и использует ~7% ЦП против 70% при схожей нагрузке. Учтите, что в i2pd нет встроенных приложений и требуются внешние инструменты.\nПроблемы с торрентами в I2PSnark Интеграция I2PSnark с архитектурой router в I2P требует понимания того, что торрентинг полностью зависит от здоровья tunnels router. Торренты не запустятся, пока router не достигнет достаточной интеграции с 10+ активными пирами и работающими tunnels.\nТорренты, застрявшие на 0%, обычно указывают на:\nRouter не полностью интегрирован: Подождите 10–15 минут после запуска I2P, прежде чем ожидать активности торрентов DHT (распределенная хеш-таблица) отключён: Включите на http://127.0.0.1:7657/i2psnark → Configuration → отметьте \u0026ldquo;Enable DHT\u0026rdquo; (по умолчанию включено начиная с версии 0.9.2) Недействительные или неработающие трекеры: Торренты I2P требуют трекеров, предназначенных для I2P - трекеры clearnet (обычного интернета) не будут работать Недостаточная конфигурация tunnels: Увеличьте число tunnels в I2PSnark Configuration → раздел Tunnels Настройте I2PSnark tunnels для повышения производительности:\nВходящие tunnels: 3-5 (по умолчанию 2 для Java I2P, 5 для i2pd) Исходящие tunnels: 3-5 Длина tunnel: 3 хопа (уменьшите до 2 ради скорости, но с меньшей анонимностью) Количество tunnel: 3 (обеспечивает стабильную производительность) Основные торрент-трекеры I2P для добавления: - tracker2.postman.i2p (основной, наиболее надёжный) - w7tpbzncbcocrqtwwm3nezhnnsw4ozadvi2hmvzdhrqzfxfum7wa.b32.i2p/a\nУдалите любые трекеры clearnet (обычный интернет) (non-.i2p) - они не приносят пользы и создают попытки подключения, которые заканчиваются тайм-аутом.\nОшибки \u0026ldquo;Torrent not registered\u0026rdquo; возникают при сбое связи с трекером. Щелчок правой кнопкой по торренту → «Старт» принудительно выполняет переанонс. Если проблема сохраняется, проверьте доступность трекера, открыв http://tracker2.postman.i 2p в браузере, настроенном для I2P. Неактивные трекеры следует заменить рабочими альтернативами.\nПиры не подключаются несмотря на успешную работу трекера, указывает на следующее: - Router заблокирован брандмауэром (помогает проброс портов, но не обязателен) - недостаточная пропускная способность (увеличьте до 256+ КБ/с) - слишком маленький рой (у некоторых торрентов 1-2 сидера; требуется терпение) - DHT отключён (включите для обнаружения пиров без трекера)\nВключите DHT (Distributed Hash Table — распределённая хеш-таблица) и PEX (Peer Exchange — обмен пирами) в настройках I2PSnark. DHT позволяет находить пиры без зависимости от трекера. PEX обнаруживает пиры через уже подключённых пиров, ускоряя обнаружение роя.\nПовреждение скачанных файлов редко происходит благодаря встроенной в I2PSnark проверке целостности. Если обнаружено:\nЩелкните правой кнопкой мыши по торренту → \u0026ldquo;Check\u0026rdquo; выполняет принудительное перехеширование всех частей Удалите поврежденные данные торрента (сохраняется файл .torrent) Щелкните правой кнопкой → \u0026ldquo;Start\u0026rdquo; для повторной загрузки с проверкой частей Проверьте диск на ошибки, если повреждения сохраняются: chkdsk (Windows), fsck (Linux) Каталог наблюдения не работает требует правильной настройки:\nНастройки I2PSnark → \u0026ldquo;Папка наблюдения\u0026rdquo;: Укажите абсолютный путь (например, /home/user/torrents/watch) Убедитесь, что процесс I2P имеет права на чтение: chmod 755 /path/to/watch Поместите файлы .torrent в папку наблюдения - I2PSnark добавляет их автоматически Настройте \u0026ldquo;Автозапуск\u0026rdquo;: Отметьте, должны ли торренты запускаться сразу после добавления Оптимизация производительности при работе с торрентами:\nОграничьте число одновременно активных торрентов: максимум 3-5 для стандартных подключений Расставляйте приоритеты для важных загрузок: временно останавливайте низкоприоритетные торренты Увеличьте выделение пропускной способности для router: больше пропускной способности = лучшая производительность торрентов Будьте терпеливы: торренты через I2P по своей природе медленнее, чем BitTorrent в clearnet (открытом интернете) Раздавайте после загрузки: сеть процветает благодаря взаимности Настройка и устранение неполадок Git поверх I2P Операции Git через I2P требуют либо настройки прокси SOCKS, либо выделенных I2P tunnels для доступа по SSH/HTTP. Архитектура Git предполагает соединения с низкой задержкой, поэтому архитектура I2P с высокой задержкой создаёт сложности.\nНастройте Git для использования SOCKS-прокси I2P:\nОтредактируйте ~/.ssh/config (создайте, если не существует):\nHost *.i2p ProxyCommand nc -X 5 -x 127.0.0.1:4447 %h %p ServerAliveInterval 60 ServerAliveCountMax 3 Compression yes Это направляет все SSH-подключения к .i2p-хостам через SOCKS-прокси I2P (порт 4447). Параметры ServerAlive поддерживают соединение при задержках I2P.\nДля операций Git по HTTP/HTTPS настройте Git глобально:\ngit config --global http.proxy socks5h://127.0.0.1:4447 git config --global https.proxy socks5h://127.0.0.1:4447 Примечание: socks5h выполняет разрешение DNS через прокси - это критически важно для доменов .i2p.\nСоздайте выделенный I2P tunnel для Git по SSH (надёжнее, чем SOCKS):\nОткройте http://127.0.0.1:7657/i2ptunnel \u0026ldquo;Новый клиентский tunnel\u0026rdquo; → \u0026ldquo;Standard\u0026rdquo; Настройте: Имя: Git-SSH Тип: Client Порт: 2222 (локальный порт для доступа к Git) Назначение: [your-git-server].i2p:22 Автозапуск: Включено Количество tunnel: 3-4 (больше для надежности) Сохраните и запустите tunnel Настройте SSH на использование tunnel: ssh -p 2222 git@127.0.0.1 Ошибки аутентификации SSH через I2P обычно возникают из-за:\nКлюч не добавлен в ssh-agent: ssh-add ~/.ssh/id_rsa Неверные права на файл ключа: chmod 600 ~/.ssh/id_rsa Tunnel не запущен: Проверьте на http://127.0.0.1:7657/i2ptunnel, что статус зелёный Сервер Git требует определённый тип ключа: сгенерируйте ключ ed25519, если RSA не срабатывает Истечение времени ожидания операций Git связано с характеристиками задержки I2P:\nУвеличьте таймаут Git: git config --global http.postBuffer 524288000 (буфер 500 МБ) Увеличьте лимит низкой скорости: git config --global http.lowSpeedLimit 1000 и git config --global http.lowSpeedTime 600 (ожидает 10 минут) Используйте поверхностное клонирование для первичного клонирования: git clone --depth 1 [url] (загружает только последний коммит, быстрее) Клонируйте в периоды низкой активности: сетевая перегрузка влияет на производительность I2P Медленные операции git clone/fetch присущи архитектуре I2P. Репозиторий 100MB может передаваться через I2P 30–60 минут, тогда как на clearnet (открытый интернет) — секунды. Стратегии:\nИспользуйте поверхностное клонирование: --depth 1 существенно сокращает начальный объём передаваемых данных Выполняйте выборку поэтапно: вместо полного клонирования получайте конкретные ветки: git fetch origin branch:branch Рассмотрите rsync поверх I2P: для очень больших репозиториев rsync может работать лучше Увеличьте количество tunnel: большее число tunnels обеспечивает лучшую пропускную способность при длительных крупных передачах Ошибки \u0026ldquo;Connection refused\u0026rdquo; указывают на неправильную конфигурацию tunnel:\nУбедитесь, что I2P router запущен: проверьте http://127.0.0.1:7657 Подтвердите, что tunnel активен и зелёный на http://127.0.0.1:7657/i2ptunnel Протестируйте tunnel: nc -zv 127.0.0.1 2222 (должно подключиться, если tunnel работает) Проверьте, что назначение доступно: откройте HTTP‑интерфейс назначения, если он доступен Изучите журналы tunnel на http://127.0.0.1:7657/logs для поиска конкретных ошибок Лучшие практики использования Git поверх I2P:\nДержите I2P router запущенным постоянно для стабильного доступа к Git Используйте ключи SSH вместо аутентификации по паролю (меньше интерактивных запросов) Настройте постоянные tunnels вместо временных SOCKS-подключений Рассмотрите размещение собственного сервера Git в I2P для лучшего контроля Задокументируйте свои .i2p конечные точки Git для соавторов Доступ к eepsites и разрешение доменных имен .i2p Самая частая причина, по которой пользователи не могут получить доступ к сайтам .i2p, — это неверная настройка прокси в браузере. Сайты I2P существуют только внутри сети I2P и требуют маршрутизации через HTTP‑прокси I2P.\nНастройте параметры прокси браузера в точности:\nFirefox (рекомендуется для I2P):\nМеню → Настройки → Настройки сети → кнопка \u0026ldquo;Настройки\u0026rdquo; Выберите \u0026ldquo;Ручная настройка прокси\u0026rdquo; HTTP-прокси: 127.0.0.1 Порт: 4444 SSL-прокси: 127.0.0.1 Порт: 4444 SOCKS-прокси: 127.0.0.1 Порт: 4447 (необязательно, для приложений SOCKS) Отметьте \u0026ldquo;Проксировать DNS при использовании SOCKS v5\u0026rdquo; Нажмите OK, чтобы сохранить Критически важные настройки about:config в Firefox:\nПерейдите на about:config и измените:\nmedia.peerconnection.ice.proxy_only = true (предотвращает утечки IP через WebRTC) keyword.enabled = false (предотвращает перенаправление адресов .i2p на поисковые системы) network.proxy.socks_remote_dns = true (DNS через прокси) Ограничения Chrome/Chromium:\nChrome использует системные настройки прокси, а не отдельные настройки приложения. В Windows: Параметры → найдите \u0026ldquo;proxy\u0026rdquo; → \u0026ldquo;Открыть настройки прокси на этом компьютере\u0026rdquo; → Настройте HTTP: 127.0.0.1:4444 и HTTPS: 127.0.0.1:4445.\nЛучший способ: используйте расширения FoxyProxy или Proxy SwitchyOmega для выборочной маршрутизации .i2p.\nОшибки \u0026ldquo;Website Not Found In Address Book\u0026rdquo; означают, что у router отсутствует криптографический адрес домена .i2p. I2P использует локальные адресные книги вместо централизованного DNS. Решения:\nСпособ 1: Используйте jump services (jump-сервисы) (самый простой для новых сайтов):\nПерейдите на http://stats.i 2p и найдите сайт. Нажмите ссылку addresshelper (специальная ссылка для добавления адреса в адресную книгу): http://example.i2p/?i2paddresshelper=base64destination. Ваш браузер покажет \u0026ldquo;Сохранить в адресную книгу?\u0026rdquo; - подтвердите, чтобы добавить.\nСпособ 2: Обновите подписки адресной книги:\nПерейдите на http://127.0.0.1:7657/dns (SusiDNS) Нажмите вкладку \u0026ldquo;Subscriptions\u0026rdquo; Проверьте активные подписки (по умолчанию: http://i2p-projekt.i 2p/hosts.txt) Добавьте рекомендуемые подписки: http://stats.i 2p/cgi-bin/newhosts.txt http://notbob.i 2p/hosts.txt http://reg.i 2p/export/hosts.txt Нажмите \u0026ldquo;Update Now\u0026rdquo;, чтобы принудительно выполнить немедленное обновление подписок Подождите 5–10 минут на обработку Метод 3: Используйте адреса base32 (всегда работает, если сайт онлайн):\nКаждый сайт .i2p имеет адрес base32: 52 случайных символа, за которыми следует .b32.i2p (например, ukeu3k5oycgaauneqgtnvselmt4yemvoilkln7jpvamvfx7dnkdq.b32.i2p). Адреса base32 обходят адресную книгу - router выполняет прямой криптографический поиск.\nТипичные ошибки настройки браузера:\nПопытка использовать HTTPS на сайтах, доступных только по HTTP: большинство сайтов .i2p используют только HTTP — попытка https://example.i2p завершится неудачей Забытый префикс http://: браузер может начать поиск вместо подключения — всегда используйте http://example.i2p Включённый WebRTC: может раскрыть реальный IP-адрес — отключите в настройках Firefox или с помощью расширений DNS не проксируется: DNS clearnet (открытый интернет) не может разрешать .i2p — необходимо проксировать DNS-запросы Неверный порт прокси: 4444 для HTTP (не 4445, который — HTTPS outproxy (прокси-выход) в clearnet) Router не полностью интегрирован препятствует доступу к любым сайтам. Проверьте достаточность интеграции:\nПроверьте, что http://127.0.0.1:7657 показывает \u0026ldquo;Network: OK\u0026rdquo; или \u0026ldquo;Network: Firewalled\u0026rdquo; (не \u0026ldquo;Network: Testing\u0026rdquo;) Active peers показывает минимум 10+ (оптимально 50+) Нет сообщения \u0026ldquo;Rejecting tunnels: starting up\u0026rdquo; Подождите полные 10-15 минут после запуска router, прежде чем ожидать доступ к .i2p Настройка клиентов IRC и электронной почты следует аналогичным шаблонам прокси:\nIRC: Клиенты подключаются к 127.0.0.1:6668 (IRC-прокси tunnel I2P). Отключите в IRC-клиенте настройки прокси - подключение к localhost:6668 уже проксируется через I2P.\nЭлектронная почта (Postman): - SMTP: 127.0.0.1:7659 - POP3: 127.0.0.1:7660 - Без SSL/TLS (шифрование обеспечивается I2P tunnel) - Учетные данные из регистрации учетной записи на postman.i2p\nВсе эти tunnels должны отображать статус «running» (зелёный) на http://127.0.0.1:7657/i2ptunnel.\nСбои при установке и проблемы с пакетами Пакетные установки (Debian, Ubuntu, Arch) иногда завершаются сбоем из‑за изменений в репозиториях, истечения срока действия GPG ключей или конфликтов зависимостей. В последних версиях официальные репозитории были перенесены с deb.i2p2.de/deb.i2p2.no (сняты с поддержки) на deb.i2p.net.\nОбновите репозиторий Debian/Ubuntu до актуального состояния:\n# Remove old repository entries sudo rm /etc/apt/sources.list.d/i2p.list # Add current repository echo \u0026#34;deb [signed-by=/usr/share/keyrings/i2p-archive-keyring.gpg] https://deb.i2p.net/ $(lsb_release -sc) main\u0026#34; | sudo tee /etc/apt/sources.list.d/i2p.list # Download and install current signing key curl -o i2p-archive-keyring.gpg https://geti2p.net/_static/i2p-archive-keyring.gpg sudo cp i2p-archive-keyring.gpg /usr/share/keyrings/ # Update and install sudo apt update sudo apt install i2p i2p-keyring Ошибки проверки подписи GPG возникают, когда ключи репозитория истекают или меняются:\n# Error: \u0026#34;The following signatures were invalid\u0026#34; # Solution: Install current keyring package sudo apt install i2p-keyring # Manual key import if package unavailable wget https://geti2p.net/_static/i2p-debian-repo.key.asc sudo apt-key add i2p-debian-repo.key.asc Служба не запускается после установки пакета чаще всего из-за проблем с профилем AppArmor в Debian/Ubuntu:\n# Check service status sudo systemctl status i2p.service # Common error: \u0026#34;Failed at step APPARMOR spawning\u0026#34; # Solution: Reconfigure without AppArmor sudo dpkg-reconfigure -plow i2p # Select \u0026#34;No\u0026#34; for AppArmor when prompted # Alternative: Set profile to complain mode sudo aa-complain /usr/sbin/wrapper # Check logs for specific errors sudo journalctl -xe -u i2p.service Проблемы с правами доступа в I2P, установленном через пакетный менеджер:\n# Fix ownership (package install uses \u0026#39;i2psvc\u0026#39; user) sudo chown -R i2psvc:i2psvc /var/lib/i2p /var/log/i2p /run/i2p sudo chmod 750 /var/log/i2p /var/lib/i2p # Set file descriptor limits (add to /etc/security/limits.conf) i2psvc soft nofile 4096 i2psvc hard nofile 8192 Проблемы совместимости с Java:\nI2P 2.10.0 требует минимум Java 8. На более старых системах может быть Java 7 или более ранняя версия:\n# Check Java version java -version # Install appropriate Java (Debian/Ubuntu) sudo apt install openjdk-11-jre-headless # Set default Java if multiple versions installed sudo update-alternatives --config java Ошибки конфигурации Wrapper (Java Service Wrapper — служебная оболочка) предотвращают запуск службы:\nРасположение Wrapper.config зависит от способа установки: - Установка пользователем: ~/.i2p/wrapper.config - Установка из пакета: /etc/i2p/wrapper.config или /var/lib/i2p/wrapper.config\nРаспространенные проблемы с wrapper.config:\nНекорректные пути: wrapper.java.command должен указывать на корректную установку Java Недостаточный объём памяти: значение wrapper.java.maxmemory установлено слишком низким (увеличьте до 512+) Неверное расположение pidfile: wrapper.pidfile должен указывать на расположение, доступное для записи Отсутствует бинарный файл wrapper: на некоторых платформах нет предварительно скомпилированного wrapper (используйте runplain.sh как резервный вариант) Сбои при обновлении и повреждённые обновления:\nОбновления консоли Router иногда срываются во время загрузки из‑за перебоев в сети. Процедура ручного обновления:\nСкачайте i2pupdate_X.X.X.zip с https://geti2p.net/en/download Проверьте, что контрольная сумма SHA256 совпадает с опубликованным хэшем Скопируйте в каталог установки I2P как i2pupdate.zip Перезапустите router - обновление будет автоматически обнаружено и распаковано Подождите 5-10 минут, пока обновление установится Проверьте новую версию на http://127.0.0.1:7657 Миграция с очень старых версий (до 0.9.47) на текущие версии может завершиться неудачей из‑за несовместимых ключей подписи или удалённых возможностей. Необходимы поэтапные обновления:\nВерсии старее 0.9.9: невозможно проверить текущие подписи - необходимо ручное обновление Версии, работающие на Java 6/7: необходимо обновить Java перед обновлением I2P до 2.x Существенный разрыв между версиями: сначала обновитесь до промежуточной версии (рекомендуемая контрольная точка - 0.9.47) Когда использовать установщик, а когда пакет:\nПакеты (apt/yum): Лучший вариант для серверов, автоматических обновлений безопасности, интеграции с системой, управления через systemd Установщик (.jar): Лучший вариант для установки на уровне пользователя, Windows, macOS, нестандартных установок, доступности последней версии Повреждение конфигурационного файла и восстановление Сохранение конфигурации I2P опирается на несколько критически важных файлов. Повреждение обычно возникает из‑за неправильного завершения работы, ошибок диска или ошибок при ручном редактировании. Понимание назначения этих файлов позволяет проводить точечное восстановление вместо полной переустановки.\nКритические файлы и их назначение:\nrouter.keys (516+ байт): Криптографическая идентичность router - потеря этого файла создаст новую идентичность router.info (автоматически создается): Опубликованная информация о router - можно удалить, восстановится автоматически router.config (текст): Основная конфигурация - пропускная способность, сетевые настройки, предпочтения i2ptunnel.config (текст): Определения tunnel - клиентские/серверные tunnel, ключи, назначения netDb/ (каталог): База данных пиров - информация о router для участников сети peerProfiles/ (каталог): Статистика производительности по пирам - влияет на выбор tunnel keyData/ (каталог): Ключи назначений для eepsites и сервисов - потеря приведет к смене адресов addressbook/ (каталог): Локальные сопоставления имен хостов .i2p Полная процедура резервного копирования перед внесением изменений:\n# Stop I2P first i2prouter stop # or: systemctl stop i2p # Backup directory BACKUP_DIR=~/i2p-backup-$(date +%Y%m%d-%H%M) mkdir -p $BACKUP_DIR # Copy critical files cp -r ~/.i2p/router.keys $BACKUP_DIR/ cp -r ~/.i2p/*.config $BACKUP_DIR/ cp -r ~/.i2p/keyData $BACKUP_DIR/ cp -r ~/.i2p/addressbook $BACKUP_DIR/ cp -r ~/.i2p/eepsite $BACKUP_DIR/ # if hosting sites # Optional but recommended tar -czf $BACKUP_DIR.tar.gz $BACKUP_DIR Симптомы повреждения Router.config:\nRouter не запускается из-за ошибок разбора в журналах Настройки не сохраняются после перезапуска Появляются неожиданные значения по умолчанию Искажённые символы при просмотре файла Восстановление повреждённого router.config:\nСделайте резервную копию имеющегося: cp router.config router.config.broken Проверьте кодировку файла: должна быть UTF-8 без BOM Проверьте синтаксис: ключи используют разделитель = (не :), у ключей не должно быть завершающих пробелов, # — только для комментариев Распространённые проблемы: не-ASCII символы в значениях, проблемы с концами строк (CRLF vs LF) Если исправить не удаётся: удалите router.config - router создаст файл по умолчанию, сохранив идентичность Важные настройки router.config, которые следует сохранить:\ni2np.bandwidth.inboundKBytesPerSecond=512 i2np.bandwidth.outboundKBytesPerSecond=256 router.updatePolicy=notify routerconsole.lang=en router.hiddenMode=false Утерянный или недействительный router.keys создаёт новую идентичность router. Это приемлемо, за исключением случаев:\nРабота в режиме floodfill (узел-распространитель netDb) (теряет статус floodfill) Размещение eepsites (скрытые сайты I2P) с опубликованным адресом (теряется непрерывность) Сформированная репутация в сети Восстановление без резервной копии невозможно — создайте новую: удалите router.keys, перезапустите I2P, будет создана новая идентичность.\nКлючевое различие: router.keys (идентичность) против keyData/* (службы). Потеря router.keys изменит идентичность router\u0026rsquo;а. Потеря keyData/mysite-keys.dat изменит .i2p-адрес вашего eepsite - катастрофа, если адрес уже опубликован.\nСоздавайте резервные копии ключей eepsite/службы отдельно:\n# Identify your service keys ls -la ~/.i2p/keyData/ # Backup with descriptive names cp ~/.i2p/keyData/myservice-keys.dat ~/backups/myservice-keys-$(date +%Y%m%d).dat # Store securely (encrypted if sensitive) gpg -c ~/backups/myservice-keys-*.dat Повреждение NetDb и peerProfiles (профили пиров):\nСимптомы: Ноль активных пиров, не удаётся построить tunnels, в журналах «Database corruption detected»\nБезопасное исправление (всё автоматически пройдет через reseed (получение стартовых пиров)/пересборку):\ni2prouter stop rm -rf ~/.i2p/netDb/* rm -rf ~/.i2p/peerProfiles/* i2prouter start # Wait 10-15 minutes for reseed and integration Эти каталоги содержат только кэшированную сетевую информацию — их удаление заставит выполнить новый bootstrap (первичную инициализацию), но не приведёт к потере критически важных данных.\nСтратегии предотвращения:\nВсегда корректное завершение работы: Используйте i2prouter stop или кнопку «Shutdown» в консоли router — никогда не завершайте процесс принудительно Автоматические резервные копии: Задача cron: еженедельная резервная копия ~/.i2p на отдельный диск Мониторинг состояния диска: Периодически проверяйте статус SMART — сбойные диски приводят к повреждению данных Достаточно свободного места на диске: Поддерживайте свободными 1+ ГБ — переполненные диски вызывают повреждение данных Рекомендуется ИБП: Отключения питания во время записи приводят к повреждению файлов Контроль версий критически важных конфигураций: Репозиторий Git для router.config, i2ptunnel.config позволяет откатывать изменения Права доступа к файлам имеют значение:\n# Correct permissions (user install) chmod 600 ~/.i2p/router.keys chmod 600 ~/.i2p/*.config chmod 700 ~/.i2p/keyData chmod 755 ~/.i2p # Never run as root - creates permission problems Расшифровка распространённых сообщений об ошибках Журналирование в I2P предоставляет конкретные сообщения об ошибках, которые точно указывают на проблему. Понимание этих сообщений ускоряет устранение неполадок.\n\u0026ldquo;No tunnels available\u0026rdquo; появляется, когда router не построил достаточно tunnels для работы. Это нормально в течение первых 5–10 минут после запуска. Если сохраняется дольше 15 минут:\nУбедитесь, что число активных пиров \u0026gt; 10 на http://127.0.0.1:7657 Проверьте, что выделенная пропускная способность достаточна (минимум 128+ КБ/с) Проверьте процент успешных tunnel на http://127.0.0.1:7657/tunnels (должен быть \u0026gt;40%) Просмотрите журналы на предмет причин отказа в построении tunnel \u0026ldquo;Clock skew detected\u0026rdquo; или \u0026ldquo;NTCP2 disconnect code 7\u0026rdquo; означает, что системное время отличается от консенсуса сети более чем на 90 секунд. I2P требует точности ±60 секунд. Соединения с routers с рассинхронизированным временем автоматически отклоняются.\nИсправить немедленно:\n# Linux sudo timedatectl set-ntp true sudo systemctl restart systemd-timesyncd date # Verify correct time # Windows # Control Panel → Date and Time → Internet Time → Update now # Verify after sync http://127.0.0.1:7657/logs # Should no longer show clock skew warnings \u0026ldquo;Build timeout\u0026rdquo; или \u0026ldquo;Tunnel build timeout exceeded\u0026rdquo; означает, что построение tunnel через цепочку пиров не завершилось в отведённое окно тайм-аута (обычно 60 секунд). Причины:\nМедленные узлы: Router выбрал неотзывчивых участников для tunnel Перегрузка сети: сеть I2P испытывает высокую нагрузку Недостаточная пропускная способность: ваши ограничения пропускной способности препятствуют своевременному построению tunnel Перегруженный router: слишком много участвующих tunnels потребляют ресурсы Решения: Увеличьте пропускную способность, уменьшите число участвующих tunnels (router.maxParticipatingTunnels на http://127.0.0.1:7657/configadvanced), включите проброс портов для улучшения выбора пиров.\n\u0026ldquo;Router is shutting down\u0026rdquo; или \u0026ldquo;Graceful shutdown in progress\u0026rdquo; появляются во время обычного завершения работы или восстановления после сбоя. Корректное завершение работы может занять до 10 минут, пока router закрывает tunnels, уведомляет пиры и сохраняет состояние.\nЕсли застрял в состоянии завершения дольше 11 минут, выполните принудительное завершение:\n# Linux kill -9 $(pgrep -f i2p) # Windows taskkill /F /IM javaw.exe \u0026ldquo;java.lang.OutOfMemoryError: Java heap space\u0026rdquo; сигнализирует об исчерпании кучи. Немедленные решения:\nОтредактируйте wrapper.config: wrapper.java.maxmemory=512 (или выше) Требуется полное выключение - перезапуск не применит изменения Подождите 11 минут для полного выключения Запустите router заново Проверьте выделение памяти на http://127.0.0.1:7657/graphs - должен быть виден запас Связанные ошибки памяти:\n\u0026ldquo;GC overhead limit exceeded\u0026rdquo; (превышено ограничение по времени на сборку мусора): Слишком много времени тратится на сборку мусора - увеличьте размер кучи \u0026ldquo;Metaspace\u0026rdquo; (область метаданных классов Java): Пространство метаданных классов Java исчерпано - добавьте wrapper.java.additional.X=-XX:MaxMetaspaceSize=256M Только для Windows: Kaspersky Antivirus ограничивает кучу Java до 512 МБ независимо от настроек в wrapper.config - удалите Kaspersky Antivirus или добавьте I2P в исключения.\n\u0026ldquo;Тайм-аут соединения\u0026rdquo; или \u0026ldquo;Ошибка I2CP - порт 7654\u0026rdquo; когда приложения пытаются подключиться к router:\nПроверьте, что router запущен: http://127.0.0.1:7657 должен отвечать Проверьте порт I2CP: netstat -an | grep 7654 должно показать LISTENING Убедитесь, что брандмауэр localhost разрешает: sudo ufw allow from 127.0.0.1 Проверьте, что приложение использует правильный порт (I2CP=7654, SAM=7656) \u0026ldquo;Certificate validation failed\u0026rdquo; или \u0026ldquo;RouterInfo corrupt\u0026rdquo; во время reseed (ресид):\nОсновные причины: смещение системных часов (сначала исправьте), повреждённый netDb, недействительные reseed certificates (сертификаты серверов ресида)\n# After fixing clock: i2prouter stop rm -rf ~/.i2p/netDb/* # Delete corrupted database i2prouter start # Auto-reseeds with fresh data \u0026ldquo;Database corruption detected\u0026rdquo; указывает на повреждение данных на уровне диска в netDb или peerProfiles (каталог профилей пиров):\n# Safe fix - all will rebuild i2prouter stop rm -rf ~/.i2p/netDb/* ~/.i2p/peerProfiles/* i2prouter start Проверьте состояние диска с помощью утилит SMART — повторяющееся повреждение данных указывает на выход из строя накопителя.\nПроблемы, специфичные для платформы Различные операционные системы создают специфические сложности при развертывании I2P, связанные с правами доступа, политиками безопасности и интеграцией с системой.\nПроблемы с правами доступа и службами в Linux I2P, установленный из пакета, запускается от имени системного пользователя i2psvc (Debian/Ubuntu) или i2p (другие дистрибутивы), что требует определённых прав доступа:\n# Fix package install permissions sudo chown -R i2psvc:i2psvc /var/lib/i2p /var/log/i2p /run/i2p sudo chmod 750 /var/log/i2p /var/lib/i2p sudo chmod 644 /var/lib/i2p/*.config # User install permissions (should be your user) chown -R $USER:$USER ~/.i2p chmod 700 ~/.i2p chmod 600 ~/.i2p/router.keys ~/.i2p/*.config Ограничения на файловые дескрипторы влияют на возможности router по обслуживанию соединений. Значение по умолчанию (1024) недостаточно для router с высокой пропускной способностью:\n# Check current limits ulimit -n # Temporary increase ulimit -n 4096 # Permanent fix: Edit /etc/security/limits.conf i2psvc soft nofile 4096 i2psvc hard nofile 8192 # Systemd override sudo mkdir -p /etc/systemd/system/i2p.service.d/ sudo nano /etc/systemd/system/i2p.service.d/override.conf # Add: [Service] LimitNOFILE=8192 sudo systemctl daemon-reload sudo systemctl restart i2p Конфликты AppArmor, распространённые в Debian/Ubuntu, препятствуют запуску службы:\n# Error: \u0026#34;Failed at step APPARMOR spawning /usr/sbin/wrapper\u0026#34; # Cause: AppArmor profile missing or misconfigured # Solution 1: Disable AppArmor for I2P sudo aa-complain /usr/sbin/wrapper # Solution 2: Reconfigure package without AppArmor sudo dpkg-reconfigure -plow i2p # Select \u0026#34;No\u0026#34; when asked about AppArmor # Solution 3: LXC/Proxmox containers - disable AppArmor in container config lxc.apparmor.profile: unconfined Проблемы с SELinux на RHEL/CentOS/Fedora:\n# Temporary: Set permissive mode sudo setenforce 0 # Permanent: Generate custom policy sudo ausearch -c \u0026#39;java\u0026#39; --raw | audit2allow -M i2p_policy sudo semodule -i i2p_policy.pp # Or disable SELinux for I2P process (less secure) sudo semanage permissive -a i2p_t Устранение неполадок службы SystemD:\n# Detailed service status sudo systemctl status i2p.service -l # Full logs sudo journalctl -xe -u i2p.service # Follow logs live sudo journalctl -f -u i2p.service # Restart with logging sudo systemctl restart i2p.service \u0026amp;\u0026amp; sudo journalctl -f -u i2p.service Вмешательство брандмауэра Windows и антивируса Windows Defender и сторонние антивирусы часто помечают I2P как угрозу из‑за характерных шаблонов сетевого поведения. Правильная настройка предотвращает ненужные блокировки при сохранении безопасности.\nНастройте брандмауэр Защитника Windows:\n# Run PowerShell as Administrator # Find Java path (adjust for your Java installation) $javaPath = \u0026#34;C:\\Program Files\\Eclipse Adoptium\\jdk-11.0.16.101-hotspot\\bin\\javaw.exe\u0026#34; # Create inbound rules New-NetFirewallRule -DisplayName \u0026#34;I2P Java\u0026#34; -Direction Inbound -Program $javaPath -Action Allow New-NetFirewallRule -DisplayName \u0026#34;I2P UDP\u0026#34; -Direction Inbound -Protocol UDP -LocalPort 22648 -Action Allow New-NetFirewallRule -DisplayName \u0026#34;I2P TCP\u0026#34; -Direction Inbound -Protocol TCP -LocalPort 22648 -Action Allow # Add exclusions to Windows Defender Add-MpPreference -ExclusionPath \u0026#34;C:\\Program Files\\i2p\u0026#34; Add-MpPreference -ExclusionPath \u0026#34;$env:APPDATA\\I2P\u0026#34; Add-MpPreference -ExclusionPath \u0026#34;$env:LOCALAPPDATA\\I2P\u0026#34; Add-MpPreference -ExclusionProcess \u0026#34;javaw.exe\u0026#34; Замените порт 22648 на ваш фактический порт I2P, указанный на http://127.0.0.1:7657/confignet.\nСпецифическая проблема Kaspersky Antivirus: компонент Kaspersky \u0026ldquo;Application Control\u0026rdquo; ограничивает кучу Java до 512 МБ вне зависимости от настроек в wrapper.config. Это приводит к OutOfMemoryError на router с высокой пропускной способностью.\nРешения: 1. Добавьте I2P в исключения Kaspersky: Настройки → Дополнительно → Угрозы и исключения → Управление исключениями 2. Или удалите Kaspersky (рекомендуется для корректной работы I2P)\nОбщие рекомендации по сторонним антивирусам:\nДобавьте каталог установки I2P в исключения Добавьте %APPDATA%\\I2P и %LOCALAPPDATA%\\I2P в исключения Исключите javaw.exe из поведенческого анализа Отключите функции \u0026ldquo;Network Attack Protection\u0026rdquo;, которые могут мешать протоколам I2P macOS Gatekeeper (механизм безопасности macOS для проверки приложений) блокирует установку Gatekeeper в macOS препятствует запуску неподписанных приложений. Установщики I2P не подписаны Apple Developer ID, что приводит к предупреждениям безопасности.\nОбход Gatekeeper для установщика I2P:\n# Method 1: Remove quarantine attribute xattr -d com.apple.quarantine ~/Downloads/i2pinstall_*.jar java -jar ~/Downloads/i2pinstall_*.jar # Method 2: Use System Settings (macOS 13+) # Try to open installer → macOS blocks it # System Settings → Privacy \u0026amp; Security → scroll down # Click \u0026#34;Open Anyway\u0026#34; next to I2P warning # Confirm in dialog # Method 3: Control-click installer # Control-click (right-click) i2pinstall_*.jar # Select \u0026#34;Open\u0026#34; from menu → \u0026#34;Open\u0026#34; again in dialog # Bypasses Gatekeeper for this specific file После установки запуск может по-прежнему вызывать предупреждения:\n# If I2P won\u0026#39;t start due to Gatekeeper: xattr -dr com.apple.quarantine ~/i2p/ Никогда не отключайте Gatekeeper (функция безопасности macOS) постоянно - это представляет угрозу безопасности для других приложений. Используйте только исключения для конкретных файлов.\nНастройка брандмауэра macOS:\nСистемные настройки → Защита и безопасность → Брандмауэр → Параметры брандмауэра Нажмите \u0026ldquo;+\u0026rdquo;, чтобы добавить приложение Перейдите к каталогу установки Java (например, /Library/Java/JavaVirtualMachines/jdk-11.jdk/Contents/Home/bin/java) Добавьте и установите значение \u0026ldquo;Разрешить входящие соединения\u0026rdquo; Проблемы приложения I2P на Android Ограничения версий Android и ограниченность ресурсов создают особые сложности.\nМинимальные требования: - Требуется Android 5.0+ (API level 21+) для текущих версий - минимум 512 МБ ОЗУ, рекомендуется 1 ГБ+ - 100 МБ места для приложения и данных router - Для I2P должны быть отключены ограничения фоновой работы приложения\nПриложение сразу вылетает:\nПроверьте версию Android: Настройки → О телефоне → Версия Android (должна быть 5.0+) Удалите все версии I2P: Установите только один вариант: net.i2p.android (Google Play) net.i2p.android.router (F-Droid)\nОдновременная установка нескольких вариантов вызывает конфликт Очистьте данные приложения: Настройки → Приложения → I2P → Хранилище → Очистить данные Переустановите начисто Оптимизация батареи убивает router:\nAndroid агрессивно завершает фоновые приложения для экономии заряда аккумулятора. Для I2P нужно добавить исключение:\nНастройки → Батарея → Оптимизация батареи (или Использование батареи приложениями) Найдите I2P → Не оптимизировать (или Разрешить фоновую активность) Настройки → Приложения → I2P → Батарея → Разрешить фоновую активность + Снять ограничения Проблемы с подключением на мобильных устройствах:\nДля начальной синхронизации (bootstrap) требуется Wi‑Fi: Начальная процедура reseed (получение стартовых узлов) загружает значительный объём данных — используйте Wi‑Fi, а не сотовую связь Изменения сети: I2P плохо обрабатывает переключение сетей — перезапустите приложение после перехода между Wi‑Fi и сотовой связью Пропускная способность для мобильной связи: Настройте консервативно на 64-128 КБ/с, чтобы избежать исчерпания сотового трафика Оптимизация производительности для мобильных устройств:\nПриложение I2P → Меню → Настройки → Пропускная способность Установите подходящие ограничения: 64 KB/sec входящая, 32 KB/sec исходящая для сотовой связи Сократите количество участвующих tunnels: Настройки → Дополнительно → Max participating tunnels: 100-200 Включите \u0026ldquo;Останавливать I2P при выключенном экране\u0026rdquo; для экономии заряда батареи Торренты на Android:\nОграничьте количество одновременно активных торрентов до 2–3 Снизьте агрессивность DHT Используйте WiFi только для торрентов Примите более низкие скорости на мобильных устройствах Проблемы с Reseed (получением начальных данных netDb) и bootstrap (начальной инициализацией) Новые установки I2P требуют reseeding (первичное получение начальной информации о пирах) - загрузки этих данных с публичных HTTPS-серверов для присоединения к сети. Проблемы с reseed оставляют пользователей без пиров и без доступа к сети.\n\u0026ldquo;No active peers\u0026rdquo; после чистой установки обычно указывает на сбой reseed (получение начальных пиров). Симптомы:\nИзвестные пиры: 0 или их число держится ниже 5 \u0026ldquo;Network: Testing\u0026rdquo; сохраняется дольше 15 минут В логах видно \u0026ldquo;Reseed failed\u0026rdquo; или ошибки подключения к серверам reseed (серверы первичной загрузки пиров) Почему не удаётся reseed (начальная загрузка пиров):\nБлокировка HTTPS межсетевым экраном: Корпоративные/ISP межсетевые экраны блокируют подключения к reseed server (сервер начальной загрузки I2P) (порт 443) Ошибки SSL-сертификатов: В системе отсутствуют актуальные корневые сертификаты Требуется прокси: Сеть требует HTTP/SOCKS-прокси для внешних подключений Смещение системного времени: Проверка SSL-сертификатов завершается ошибкой, если системное время указано неверно Географическая цензура: Некоторые страны/провайдеры блокируют известные reseed servers Принудительный ручной ресид:\nОткройте http://127.0.0.1:7657/configreseed Нажмите \u0026ldquo;Save changes and reseed now\u0026rdquo; Следите за http://127.0.0.1:7657/logs на предмет \u0026ldquo;Reseed got XX router infos\u0026rdquo; Дайте 5-10 минут на обработку Проверьте http://127.0.0.1:7657 - показатель Known peers должен увеличиться до 50+ Настройте reseed proxy (прокси для начальной загрузки узлов сети) для сетей с ограничениями:\nhttp://127.0.0.1:7657/configreseed → Настройка прокси:\nHTTP-прокси: [proxy-server]:[port] Или SOCKS5: [socks-server]:[port] Включить \u0026ldquo;Use proxy for reseed only\u0026rdquo; (reseed — начальная загрузка узлов) Учетные данные, если требуется Сохранить и принудительно выполнить reseed Альтернатива: Tor-прокси для reseed (процедуры начальной загрузки пиров):\nЕсли запущены Tor Browser или демон Tor:\nТип прокси: SOCKS5 Хост: 127.0.0.1 Порт: 9050 (порт SOCKS Tor по умолчанию) Включить и выполнить reseed (процедура начальной загрузки узлов) Ручной reseed (ресид) через файл su3 (в крайнем случае):\nЕсли все автоматические попытки reseed (повторное получение начальных данных о пирах) терпят неудачу, получите файл reseed по стороннему каналу:\nСкачайте i2pseeds.su3 из доверенного источника через неограниченное подключение (https://reseed.i2p.rocks/i2pseeds.su3 , https://reseed-fr.i2pd.xyz/i2pseeds.su3 ) Полностью остановите I2P Скопируйте i2pseeds.su3 в каталог ~/.i2p/ Запустите I2P — он автоматически извлечёт и обработает файл Удалите i2pseeds.su3 после обработки Убедитесь, что число пиров увеличивается на http://127.0.0.1:7657 Ошибки SSL-сертификатов при reseed (получение начальных узлов сети):\nError: \u0026#34;Reseed: Certificate verification failed\u0026#34; Cause: System root certificates outdated or missing Решения:\n# Linux - update certificates sudo apt install ca-certificates sudo update-ca-certificates # Windows - install KB updates for root certificate trust # Or install .NET Framework (includes certificate updates) # macOS - update system # Software Update includes certificate trust updates Зависло на 0 известных пирах более 30 минут:\nУказывает на полный сбой reseed (получение начальных пиров). Порядок устранения неполадок:\nПроверьте корректность системного времени (самая частая проблема — исправьте СНАЧАЛА) Проверьте подключение по HTTPS: Попробуйте открыть https://reseed.i2p.rocks в браузере — если не открывается, проблема с сетью Проверьте журналы I2P на http://127.0.0.1:7657/logs на предмет конкретных ошибок reseed (получение начального списка узлов) Попробуйте другой reseed URL: http://127.0.0.1:7657/configreseed → добавьте пользовательский reseed URL: https://reseed-fr.i2pd.xyz/ Используйте ручной метод с файлом su3, если автоматические попытки исчерпаны Reseed servers (серверы первичной загрузки) периодически недоступны: I2P включает несколько жёстко заданных reseed servers. Если один из них отказывает, router автоматически пробует другие. Полный отказ всех reseed servers крайне редок, но возможен.\nТекущие активные ресид-серверы (по состоянию на октябрь 2025 года):\nhttps://reseed.i2p.rocks/ https://reseed-fr.i2pd.xyz/ https://i2p.novg.net/ https://i2p-projekt.de/ Добавьте как пользовательские URL-адреса, если возникают проблемы с URL-адресами по умолчанию.\nДля пользователей в регионах с жёсткой цензурой:\nРассмотрите возможность использования мостов Snowflake/Meek (подключаемых транспортов Tor для обхода блокировок) через Tor для первичного reseed (загрузки начальных данных о пирах), а затем переключитесь на прямое подключение к I2P, как только вы подключитесь к сети. Или получите i2pseeds.su3 с помощью стеганографии, по электронной почте или через USB-накопитель за пределами зоны цензуры.\nКогда обращаться за дополнительной помощью Это руководство охватывает подавляющее большинство проблем I2P, но некоторые из них требуют внимания разработчиков или экспертных знаний сообщества.\nОбращайтесь за помощью к сообществу I2P, когда:\nRouter стабильно падает после выполнения всех шагов по устранению неполадок Утечки памяти, приводящие к устойчивому росту использования памяти сверх выделенной кучи Уровень успешности Tunnel остается ниже 20% несмотря на корректную настройку Новые ошибки в журналах, не охваченные данным руководством Выявленные уязвимости безопасности Запросы новых функций или предложения по улучшениям Перед обращением за помощью соберите диагностическую информацию:\nВерсия I2P: http://127.0.0.1:7657 (например, \u0026ldquo;2.10.0\u0026rdquo;) Версия Java: вывод java -version Операционная система и версия Статус router: состояние сети, количество активных пиров, участвующие tunnels Конфигурация пропускной способности: входящие/исходящие лимиты Состояние переадресации портов: Firewalled или OK Соответствующие выдержки из журналов: последние 50 строк с ошибками из http://127.0.0.1:7657/logs Официальные каналы поддержки:\nФорум: https://i2pforum.net (клирнет) или http://i2pforum.i 2p (внутри I2P) IRC: #i2p на Irc2P (irc.postman.i2p через I2P) или irc.freenode.net (клирнет) Reddit: https://reddit.com/r/i2p для обсуждений в сообществе Трекер ошибок: https://i2pgit.org/i2p-hackers/i2p.i2p/-/issues для подтверждённых ошибок Список рассылки: i2p-dev@lists.i2p-projekt.de для вопросов по разработке Реалистичные ожидания имеют значение. I2P медленнее, чем clearnet (обычный интернет), по самой своей архитектуре: многохоповая зашифрованная передача через tunnel создаёт неизбежные задержки. Рабочий I2P router с загрузкой страниц за 30 секунд и скоростью торрентов 50 KB/sec — функционирует корректно, а не сломан. Пользователи, ожидающие скоростей clearnet, будут разочарованы вне зависимости от оптимизации конфигурации.\nЗаключение Большинство проблем в I2P сводятся к трём категориям: недостаточное терпение во время bootstrap (начальная инициализация сети; требуется 10–15 минут), недостаточное выделение ресурсов (минимум 512 МБ ОЗУ и 256 КБ/с пропускной способности) или некорректно настроенный проброс портов. Понимание распределённой архитектуры I2P и ориентированного на анонимность дизайна помогает пользователям отличать ожидаемое поведение от реальных проблем.\nСтатус router \u0026ldquo;Firewalled\u0026rdquo;, хотя и не оптимален, не мешает использованию I2P - он лишь ограничивает вклад в сеть и немного снижает производительность. Новым пользователям следует ставить в приоритет стабильность, а не оптимизацию: запустите router и держите его запущенным непрерывно в течение нескольких дней, прежде чем менять продвинутые настройки, поскольку интеграция с сетью естественным образом улучшается по мере увеличения времени работы.\nПри устранении неполадок всегда сначала проверяйте базовые вещи: корректное системное время, достаточную пропускную способность, непрерывную работу router (узел I2P) и наличие 10+ активных пиров. Большинство проблем решается, если сперва заняться этими основами, а не пытаться править неочевидные параметры конфигурации. I2P вознаграждает терпение и непрерывную работу улучшением производительности по мере того, как router наращивает репутацию и оптимизирует выбор пиров в течение дней и недель времени работы.\n","description":"Полное руководство по устранению типичных неполадок I2P router, включая проблемы с подключением, производительностью и конфигурацией","id":"2ff67fee0173608876ccc012bf3ff6ce","section":"docs","title":"Руководство по устранению неполадок I2P Router","url":"/ru/docs/troubleshooting/"},{"categories":null,"content":" 1. Обзор netDb — специализированная распределённая база данных, содержащая всего два типа данных: - RouterInfos – контактная информация router - LeaseSets – контактная информация назначения\nВсе данные криптографически подписаны и могут быть проверены. Каждая запись содержит информацию о liveness (о «живости»/доступности), позволяющую отбрасывать устаревшие записи и заменять неактуальные, что обеспечивает защиту от некоторых классов атак.\nРаспределение использует механизм floodfill, при котором подмножество routers поддерживает распределённую базу данных.\n2. Информация о router Когда routers нужно связаться с другими routers, они обмениваются пакетами RouterInfo, содержащими:\nИдентичность router – ключ шифрования, ключ подписи, сертификат Контактные адреса – как связаться с router Метка времени публикации – когда эта информация была опубликована Произвольные текстовые опции – флаги возможностей и настройки Криптографическая подпись – подтверждает подлинность 2.1 Флаги возможностей Routers сообщают о своих возможностях с помощью буквенных кодов в своих RouterInfo:\nFlag Meaning f Floodfill participation R Reachable U Unreachable D, E, G, H Various capability indicators ### 2.2 Классификации пропускной способности Code Bandwidth K Under 12 KBps L 12–48 KBps (default) M 48–64 KBps N 64–128 KBps O 128–256 KBps P 256–2000 KBps X Over 2000 KBps ### 2.3 Значения идентификатора сети Value Purpose 0 Reserved 1 Current Network (default) 2 Reserved for Future Networks 3–15 Forks and Test Networks 16–254 Reserved 255 Reserved ### 2.4 Статистика RouterInfo Routers публикуют необязательную статистику состояния для анализа сети: - Показатели успешности/отклонений/тайм-аутов при построении Exploratory tunnel - Среднее за 1 час число участвующих tunnel\nСтатистические данные соответствуют формату stat_(statname).(statperiod) со значениями, разделёнными точкой с запятой.\nПример статистики:\nstat_tunnel.buildExploratoryExpire.60m = 0;0;0;53.14 stat_tunnel.buildExploratoryReject.60m = 0;0;0;15.51 stat_tunnel.buildExploratorySuccess.60m = 0;0;0;31.35 stat_tunnel.participatingTunnels.60m = 289.20 Floodfill routers также могут публиковать: netdb.knownLeaseSets и netdb.knownRouters\n2.5 Параметры семейства Начиная с релиза 0.9.24, routers могут объявлять принадлежность к семье (один и тот же оператор):\nfamily: Имя семейства family.key: Код типа подписи, конкатенированный с открытым ключом подписи, закодированным в base64 family.sig: Подпись имени семейства и 32-байтового хеша router Несколько routers из одного семейства не будут использоваться в одном tunnel.\n2.6 Истечение срока действия RouterInfo (информация о router) Нет истечения в первый час работы Нет истечения при 25 или меньше сохранённых RouterInfos (записей с информацией о маршрутизаторах) Срок истечения уменьшается по мере роста локального числа routers (72 часа при \u0026lt;120 routers; ~30 часов при 300 routers) SSU introducers (вводящие узлы) истекают примерно через ~1 час Floodfills используют истечение через 1 час для всех локальных RouterInfos 3. LeaseSet LeaseSets описывают точки входа в tunnel для конкретных назначений, указывая:\nИдентичность router шлюза Tunnel 4-байтовый tunnel ID Время истечения срока действия Tunnel LeaseSets include: - Destination (адрес назначения) – ключ шифрования, ключ подписи, сертификат - Дополнительный открытый ключ шифрования – для сквозного garlic encryption - Дополнительный открытый ключ подписи – предназначен для отзыва (в настоящее время не используется) - Криптографическая подпись\n3.1 Варианты LeaseSet Type Description Unpublished Destinations used only for outgoing connections aren't published to floodfill routers Revoked Published with zero leases, signed by additional signing key (not fully implemented) LeaseSet2 (LS2) As of 0.9.38, supports new encryption types, multiple encryption types, options, offline signing keys ([Proposal 123](/proposals/123-new-netdb-entries/)) Meta LeaseSet Tree-like DHT structure for multihomed services, supporting hundreds/thousands of destinations with long expirations (up to 18.2 hours) Encrypted LeaseSet (LS1) All leases encrypted with separate key; only those with the key can decode and contact the destination Encrypted LeaseSet (LS2) As of 0.9.38, destination hidden with only blinded public key and expiration visible to floodfill ### 3.2 Истечение срока действия LeaseSet Обычные LeaseSets истекают в момент самого позднего истечения срока действия их lease (lease — запись о сроке действия для конкретного tunnel). Срок действия LeaseSet2 указан в заголовке. Срок действия EncryptedLeaseSet и MetaLeaseSet может различаться; может применяться принудительное ограничение максимального срока.\n4. Инициализация Децентрализованная netDb требует как минимум одной ссылки на узел для включения в сеть. Reseeding (начальная загрузка netDb) загружает файлы RouterInfo (routerInfo-$hash.dat) из каталогов netDb добровольцев. При первом запуске они автоматически загружаются с жестко заданных URL-адресов, выбираемых случайным образом.\n5. Механизм Floodfill Система floodfill netDb использует простую распределённую схему хранения: данные отправляются ближайшему узлу floodfill. Когда узлы, не являющиеся floodfill, отправляют данные на сохранение, узлы floodfill пересылают их подмножеству узлов floodfill, ближайших к заданному ключу.\nУчастие в Floodfill указывается как флаг возможности (f) в RouterInfo.\n5.1 Требования к добровольному участию в Floodfill В отличие от жестко заданных доверенных серверов каталогов Tor, множество floodfill в I2P не является доверенным и со временем меняется.\nFloodfill автоматически включается только на routers с высокой пропускной способностью, соответствующих следующим требованиям: - Минимум 128 KBytes/sec общей пропускной способности (настраивается вручную) - Должны пройти дополнительные тесты работоспособности (время ожидания в очереди исходящих сообщений, задержка задач)\nТекущее автоматическое включение приводит примерно к 6% доле узлов сети, участвующих в floodfill.\nРучные floodfill существуют наряду с автоматическими добровольцами. Когда число floodfill падает ниже порога, routers с высокой пропускной способностью автоматически берут на себя роль floodfill. Когда число floodfill становится слишком большим, они снимают с себя роль floodfill.\n5.2 Роли Floodfill Помимо приёма записей в netDb и обработки запросов, floodfills выполняют стандартные функции router. Их более высокая пропускная способность обычно означает участие в большем числе tunnel, но это не связано напрямую со службами базы данных.\n6. Метрика близости Kademlia В netDb используется измерение расстояния на основе XOR, в стиле Kademlia. Хэш SHA256 от RouterIdentity или Destination формирует ключ Kademlia (за исключением LS2 зашифрованных LeaseSets, которые используют SHA256 от байта типа 3 вместе с ослеплённым открытым ключом).\n6.1 Ротация пространства ключей Чтобы увеличить затраты на Sybil-атаку, вместо использования SHA256(key) система использует:\nSHA256(key + yyyyMMdd) где дата — это 8-байтовая дата UTC в ASCII. Это создаёт ключ маршрутизации, который меняется ежедневно в полночь по UTC — что называется ротацией пространства ключей.\nКлючи маршрутизации никогда не передаются в сообщениях I2NP; они используются только для локального определения расстояния.\n7. Сегментация Network Database (сетевая база данных I2P) Традиционные DHT Kademlia не обеспечивают unlinkability (несвязываемость) хранимых данных. I2P предотвращает атаки, связывающие клиентские tunnels с routers, реализуя сегментацию.\n7.1 Стратегия сегментации Routers отслеживают: - Пришли ли записи через клиентские tunnels или напрямую - Если через tunnel, то какой клиентский tunnel/destination (адрес назначения в I2P) - Отслеживаются множественные поступления через tunnels - Различаются ответы на операции хранения и на операции поиска\nОбе реализации на Java и C++ используют: - \u0026ldquo;Основная\u0026rdquo; netDb для прямых запросов/операций floodfill в контексте router - \u0026ldquo;Клиентские сетевые базы данных\u0026rdquo; или \u0026ldquo;Под-базы данных\u0026rdquo; в клиентских контекстах, собирающие записи, отправляемые в клиентские tunnels\nКлиентские netDb существуют только на время жизни клиента и содержат только записи клиентских tunnel. Записи из клиентских tunnel не могут пересекаться с прямыми поступлениями.\nКаждый netDb отслеживает, поступили ли записи как store (в ответ на запросы поиска) или как ответы на поиск (отвечают только если ранее были сохранены для того же назначения). Клиенты никогда не отвечают на запросы записями из основного netDb, только записями из клиентского netDb.\nКомбинированные стратегии сегментируют netDb против атак на установление соответствия между клиентом и router.\n8. Хранение, проверка и поиск 8.1 Сохранение RouterInfo (информация о router) у пиров I2NP DatabaseStoreMessage, содержащее локальный RouterInfo (информация о маршрутизаторе) для обмена во время инициализации транспортного соединения NTCP или SSU.\n8.2 Хранение LeaseSet у пиров I2NP DatabaseStoreMessage, содержащие локальный LeaseSet, периодически передаются через сообщения, зашифрованные с помощью garlic encryption, в составе трафика Destination (адрес назначения в I2P), что позволяет отвечать без запросов к LeaseSet.\n8.3 Выбор Floodfill DatabaseStoreMessage отправляет ближайшему к текущему ключу маршрутизации floodfill. Ближайший floodfill определяется посредством поиска по локальной базе данных. Даже если это фактически не самый близкий, flooding (широковещательная рассылка) распространяет его \u0026ldquo;ближе\u0026rdquo;, отправляя нескольким floodfill.\nТрадиционная Kademlia использует поиск \u0026ldquo;find-closest\u0026rdquo; (поиск ближайших узлов) перед вставкой. Хотя в I2NP нет таких сообщений, routers могут выполнять итеративный поиск с инверсией младшего значащего бита (key ^ 0x01), чтобы обеспечить обнаружение действительно ближайшего узла.\n8.4 Сохранение RouterInfo на floodfill-узлах Routers публикуют RouterInfo (информация о router), напрямую подключаясь к floodfill и отправляя I2NP DatabaseStoreMessage с ненулевым Reply Token (токеном ответа). Сообщение не использует сквозное garlic encryption (прямое соединение, без посредников). Floodfill отвечает DeliveryStatusMessage, используя Reply Token в качестве ID сообщения.\nRouters также могут отправлять RouterInfo через исследовательский tunnel (ограничения на соединения, несовместимость, сокрытие IP). Floodfills могут отклонять такие операции хранения при перегрузке.\n8.5 Хранение LeaseSet в узлах Floodfill Хранение LeaseSet более чувствительно, чем хранение RouterInfo. Routers должны предотвращать привязку LeaseSet к себе.\nRouters публикуют LeaseSet, отправляя через исходящий клиентский tunnel DatabaseStoreMessage с ненулевым токеном ответа. Сообщение сквозным образом зашифровано с использованием garlic encryption и менеджера сеансовых ключей Destination (идентификатор назначения в I2P), что скрывает его от конечной точки исходящего tunnel. Floodfill отвечает DeliveryStatusMessage, который возвращается через входящий tunnel.\n8.6 Процесс flooding (массовой рассылки) Floodfills (специализированные узлы netdb) проверяют RouterInfo/LeaseSet перед локальным сохранением, используя адаптивные критерии, зависящие от нагрузки, размера netdb и других факторов.\nПосле получения более новых корректных данных floodfills \u0026ldquo;flood\u0026rdquo; их, находя 3 ближайших floodfill routers к ключу маршрутизации. Прямые соединения отправляют I2NP DatabaseStoreMessage с нулевым Reply Token (токен ответа). Другие routers не отвечают и не выполняют повторный flood.\nВажные ограничения: - Floodfills не должны рассылать через tunnels; только прямые соединения - Floodfills никогда не рассылают устаревший LeaseSet или RouterInfo, опубликованные более часа назад\n8.7 Поиск RouterInfo и LeaseSet I2NP DatabaseLookupMessage запрашивает записи netdb у floodfill routers. Запросы отправляются через исходящий исследовательский tunnel; в ответах указывается входящий исследовательский tunnel для возврата.\nЗапросы поиска обычно отправляются к двум \u0026ldquo;хорошим\u0026rdquo; floodfill routers, ближайшим к запрашиваемому ключу, параллельно.\nЛокальное совпадение: получает ответ I2NP DatabaseStoreMessage Нет локального совпадения: получает I2NP DatabaseSearchReplyMessage со ссылками на другие floodfill router (узлы индексирования), близкие к ключу Запросы LeaseSet используют сквозное garlic encryption (начиная с 0.9.5). Запросы RouterInfo (описание узла I2P) не шифруются из-за высокой вычислительной стоимости алгоритма Эль-Гамаля, что делает их уязвимыми для перехвата на выходной конечной точке.\nНачиная с версии 0.9.7, ответы на запросы поиска включают сеансовый ключ и тег, скрывая ответы от входного шлюза.\n8.8 Итеративные поиски До 0.8.9: два параллельных избыточных поиска без рекурсивной или итеративной маршрутизации.\nНачиная с 0.8.9: Итеративные поиски реализованы без избыточности — более эффективны, надёжны и лучше подходят для неполного знания о floodfill. По мере роста сетей и уменьшения числа floodfills, известных routers, сложность поисков приближается к O(log n).\nИтеративные поиски продолжаются даже при отсутствии ссылок на более близких узлов, что предотвращает злонамеренный black-holing (скрытое «поглощение» запросов без ответов). Действуют текущие значения максимального числа запросов и тайм-аута.\n8.9 Проверка Проверка RouterInfo (запись с данными узла I2P): Отключена начиная с версии 0.9.7.1, чтобы предотвратить атаки, описанные в статье \u0026ldquo;Practical Attacks Against the I2P Network\u0026rdquo;.\nПроверка LeaseSet: Routers ждут ~10 секунд, затем выполняют запрос к другому floodfill (специализированному узлу каталога) через исходящий клиентский tunnel. Сквозное garlic encryption (многосообщенческое шифрование в I2P) скрывает это от исходящей конечной точки. Ответы возвращаются через входящие tunnels.\nНачиная с 0.9.7, ответы шифруются с применением сокрытия ключа/тега сеанса от входного шлюза.\n8.10 Исследование Исследование включает поиск в netdb по случайным ключам, чтобы обнаруживать новые router. Узлы floodfill отвечают сообщением DatabaseSearchReplyMessage, содержащим хэши router, не являющихся floodfill, близкие к запрошенному ключу. Исследовательские запросы устанавливают специальный флаг в DatabaseLookupMessage.\n9. Мультихоминг Назначения, использующие идентичные закрытые/открытые ключи (традиционный eepPriv.dat), могут одновременно размещаться на нескольких router. Каждый экземпляр периодически публикует подписанные LeaseSets; наиболее недавно опубликованный LeaseSet отдаётся запрашивающим при поиске. При максимальном времени жизни LeaseSet в 10 минут простои длятся не более ~10 минут.\nНачиная с 0.9.38, Meta LeaseSets поддерживают крупные мультихоминговые сервисы, использующие отдельные Destinations (адреса назначения в I2P), предоставляющие общие сервисы. Записи Meta LeaseSet — это Destinations или другие Meta LeaseSets со сроком действия до 18,2 часа, что позволяет иметь сотни/тысячи Destinations, размещающих общие сервисы.\n10. Анализ угроз В настоящее время работают примерно 1700 floodfill routers (специализированных узлов для распространения netDb). Рост сети делает большинство атак более сложными или менее эффективными.\n10.1 Общие меры по смягчению рисков Рост: Увеличение числа floodfills делает атаки сложнее или менее ощутимыми Избыточность: Все записи netdb хранятся на 3 floodfill routers, ближайших к ключу, посредством flooding (массовой рассылки) Подписи: Все записи подписаны создателем; их подделка невозможна 10.2 Медленные или не отвечающие routers Routers ведут расширенную статистику профилей пиров для floodfills: - Среднее время отклика - Процент отвеченных запросов - Процент успешной проверки сохранения - Последнее успешное сохранение - Последний успешный поиск - Последний ответ\nRouters используют эти метрики при оценке «качества» для выбора ближайшего floodfill. Полностью не отвечающие routers быстро выявляются и избегаются; частично вредоносные routers представляют более серьёзную сложность.\n10.3 Атака Сивиллы (полное пространство ключей) Злоумышленники могут создать многочисленные floodfill routers, распределённые по всему пространству ключей, в качестве эффективной DoS-атаки.\nЕсли подозрительное поведение недостаточно серьёзно для присвоения статуса \u0026ldquo;bad\u0026rdquo;, возможные меры включают: - Составление списков хэшей router и IP, публикуемых через новости консоли, веб‑сайт, форум - Включение floodfill по всей сети («бороться с Sybil ещё большим количеством Sybil») - Новые версии ПО с жёстко заданными списками \u0026ldquo;bad\u0026rdquo; - Улучшенные метрики профилей пиров и пороги для автоматической идентификации - Квалификация IP‑блоков, запрещающая несколько floodfill в одном IP‑блоке - Автоматический чёрный список по подписке (аналогичный консенсусу Tor)\nБолее крупные сети делают это сложнее.\n10.4 Атака Сивиллы (частичное пространство ключей) Злоумышленники могут создать 8–15 экземпляров floodfill router, тесно сгруппированных в пространстве ключей. Все операции поиска/сохранения для этого пространства ключей будут направляться к router, контролируемым злоумышленником, что позволяет проводить DoS-атаку на конкретные I2P-сайты.\nПоскольку пространство ключей индексирует криптографические хэши SHA256, атакующим требуется перебор, чтобы создать routers, расположенные достаточно близко (в пространстве ключей).\nЗащита: Алгоритм близости Kademlia со временем варьируется с использованием SHA256(key + YYYYMMDD), обновляясь ежедневно в полночь по UTC. Эта ротация пространства ключей вынуждает ежедневную регенерацию атаки.\nПримечание: Недавние исследования показывают, что ротация пространства ключей не особенно эффективна — атакующие могут заранее предвычислить хэши router, и им достаточно нескольких router, чтобы затмить части пространства ключей в течение получаса после ротации.\nПоследствие ежедневной ротации: распределённая netdb становится ненадёжной на несколько минут после ротации — запросы поиска завершаются неудачей до того, как новый ближайший router получит вставки (stores).\n10.5 Атаки на инициализацию Злоумышленники могут перехватить контроль над reseed websites (сайтами начальной загрузки сети) или обманом склонить разработчиков добавить в список враждебные reseed websites, из‑за чего новые router будут запускаться в изолированных или контролируемых большинством сетях.\nРеализованные меры защиты: - Получение подмножеств RouterInfo (запись с информацией о маршрутизаторе) с нескольких reseed-сайтов (сайтов первичной загрузки узлов) вместо одного сайта - Внешний по отношению к сети мониторинг reseed с периодическим опросом сайтов - Начиная с 0.9.14, наборы данных reseed распространяются как подписанные zip-файлы с проверкой загруженной подписи (см. спецификацию su3 )\n10.6 Перехват запросов Floodfill routers могут «направлять» пиров к контролируемым атакующим routers через возвращаемые ссылки.\nМаловероятно через exploration (процедуру исследования пиров) из-за низкой частоты; routers получают ссылки на пиров главным образом в ходе обычного построения tunnel\u0026rsquo;ов.\nНачиная с 0.8.9 реализованы итеративные поиски. Ссылки floodfill из DatabaseSearchReplyMessage используются, если они ближе к ключу поиска. Запрашивающие routers не доверяют оценке близости ссылок. Поиски продолжаются, даже при отсутствии более близких ключей, до истечения тайм-аута/достижения максимального числа запросов, что предотвращает злонамеренное black-holing (направление запросов в «черную дыру»).\n10.7 Утечки информации Утечка информации в DHT (распределённая хеш-таблица) в I2P требует дальнейшего исследования. Floodfill routers наблюдают за запросами, собирая информацию. При доле вредоносных узлов в 20% ранее описанные атаки Sybil (атаки с множественными личностями) становятся проблематичными по нескольким причинам.\n11. Дальнейшая работа Сквозное шифрование дополнительных запросов и ответов netDb Улучшенные методы отслеживания ответов на поисковые запросы Методы смягчения проблем надежности, связанных с ротацией пространства ключей 12. Ссылки Спецификация общих структур – структуры RouterInfo и LeaseSet Спецификация I2NP – типы сообщений базы данных Предложение 123: Новые записи netDb – спецификация LeaseSet2 Историческое обсуждение netDb – история разработки и архивные обсуждения ","description":"Понимание распределённой сетевой базы данных I2P (netDb) - специализированной DHT для контактной информации о router и поиска назначений","id":"ef0a5e8bee4372a50a7f4562af717b0c","section":"docs","title":"Сетевая база данных (netDb)","url":"/ru/docs/overview/network-database/"},{"categories":null,"content":"Обзор Сетевой протокол I2P (I2NP) определяет, как routers обмениваются сообщениями, выбирают транспорты и перемешивают трафик при сохранении анонимности. Он функционирует между I2CP (клиентским API) и транспортными протоколами (NTCP2 и SSU2).\nI2NP — это уровень выше транспортных протоколов I2P. Это протокол уровня router-to-router (взаимодействия между router), используемый для: - Запросов к сетевой базе данных и ответов - Создания tunnels - Зашифрованных сообщений с данными для router и клиента\nСообщения I2NP могут быть отправлены по схеме «точка-точка» к другому router или анонимно через tunnels к тому router.\nRouter помещает исходящие задания в очередь, используя локальные приоритеты. Более высокие номера приоритетов обрабатываются первыми. Всё, что выше стандартного приоритета данных tunnel (400), считается срочным.\nТекущие транспорты I2P теперь использует NTCP2 (TCP) и SSU2 (UDP) как для IPv4, так и для IPv6. Оба транспортных протокола используют: - X25519 для обмена ключами (фреймворк протоколов Noise) - ChaCha20/Poly1305 для аутентифицированного шифрования (AEAD) - SHA-256 для хэширования\nУстаревшие транспорты удалены: - NTCP (оригинальный TCP) был удалён из Java router в релизе 0.9.50 (май 2021) - SSU v1 (оригинальный UDP) был удалён из Java router в релизе 2.4.0 (декабрь 2023) - SSU v1 был удалён из i2pd в релизе 2.44.0 (ноябрь 2022)\nПо состоянию на 2025 год сеть полностью перешла на транспорты на основе Noise (фреймворка криптографических протоколов) без какой-либо поддержки устаревших транспортов.\nСистема нумерации версий ВАЖНО: В I2P используется двойная система версионирования, которую необходимо чётко понимать:\nРелизные версии (для пользователей) Это версии, которые пользователи видят и скачивают: - 0.9.50 (май 2021) - Последний релиз ветки 0.9.x - 1.5.0 (август 2021) - Первый релиз ветки 1.x - 1.6.0, 1.7.0, 1.8.0, 1.9.0 (в 2021–2022 гг.) - 2.0.0 (ноябрь 2022) - Первый релиз ветки 2.x - с 2.1.0 по 2.9.0 (в 2023–2025 гг.) - 2.10.0 (8 сентября 2025) - Текущий релиз\nВерсии API (совместимость протоколов) Это внутренние номера версий, публикуемые в поле \u0026ldquo;router.version\u0026rdquo; в свойствах RouterInfo (структура с информацией о router): - 0.9.50 (май 2021) - 0.9.51 (август 2021) - версия API для релиза 1.5.0 - с 0.9.52 по 0.9.66 (продолжается в релизах 2.x) - 0.9.67 (сентябрь 2025) - версия API для релиза 2.10.0\nКлючевой момент: Не было НИКАКИХ релизов с номерами 0.9.51–0.9.67. Эти номера существуют только как идентификаторы версии API. I2P перешёл с релиза 0.9.50 напрямую на 1.5.0.\nТаблица соответствия версий Release Version API Version Date Key Features 0.9.50 0.9.50 May 2021 Last 0.9.x release, removed NTCP1 1.5.0 0.9.51 August 2021 Short tunnel build messages (218 bytes) 1.6.0 0.9.52 November 2021 Various improvements 1.7.0 0.9.53 January 2022 Performance enhancements 1.8.0 0.9.54 May 2022 SSU2 introduced 1.9.0 0.9.55 August 2022 SSU2 improvements 2.0.0 0.9.56 November 2022 SSU2 enabled by default 2.1.0 0.9.57 January 2023 Stability improvements 2.2.0 0.9.58 March 2023 ElGamal routers deprecated 2.3.0 0.9.59 May 2023 Various improvements 2.4.0 0.9.61 December 2023 Removed SSU1 support 2.5.0 0.9.62 February 2024 Performance improvements 2.6.0 0.9.63 May 2024 Network optimizations 2.7.0 0.9.64 October 2024 Post-quantum preparation work 2.8.0 0.9.65 February 2025 Tunnel bandwidth parameters 2.9.0 0.9.66 June 2025 LeaseSet service records 2.10.0 0.9.67 September 2025 Post-quantum hybrid cryptography (beta) **Скоро:** Релиз 2.11.0 (запланирован на декабрь 2025 года) потребует Java 17+ и по умолчанию включит постквантовую криптографию. Версии протоколов Все router должны публиковать свою версию протокола I2NP в поле \u0026ldquo;router.version\u0026rdquo; в свойствах RouterInfo. Это поле — версия API, указывающая уровень поддержки различных функций протокола I2NP, и оно не обязательно совпадает с фактической версией router.\nАльтернативные (не на Java) routers, если они желают публиковать какую-либо информацию о версии конкретной реализации router, должны делать это в другом свойстве. Допускаются версии, отличные от перечисленных ниже. Поддержка будет определяться на основе численного сравнения; например, 0.9.13 означает поддержку возможностей 0.9.12.\nПримечание: Свойство \u0026ldquo;coreVersion\u0026rdquo; больше не публикуется в информации о router и никогда не использовалось для определения версии протокола I2NP.\nСводка возможностей версий API API Version Required I2NP Features 0.9.67Post-quantum hybrid cryptography (MLKEM ratchet) support (beta), UDP tracker support 0.9.66LeaseSet2 service record options (see proposal 167) 0.9.65Tunnel build bandwidth parameters (see proposal 168) 0.9.59Minimum peers will build tunnels through (as of 0.9.63), minimum floodfill peers will send DSM to (as of 0.9.63) 0.9.58Minimum peers will build tunnels through (as of 0.9.62), ElGamal routers deprecated 0.9.55SSU2 transport support (if published in router info) 0.9.51Short tunnel build messages for ECIES-X25519 routers, minimum peers will build tunnels through (as of 0.9.58), minimum floodfill peers will send DSM to (as of 0.9.58) 0.9.49Garlic messages to ECIES-X25519 routers 0.9.48ECIES-X25519 routers, ECIES-X25519 build request/response records 0.9.46DatabaseLookup flag bit 4 for AEAD reply 0.9.44ECIES-X25519 keys in LeaseSet2 0.9.40MetaLeaseSet may be sent in a DSM 0.9.39EncryptedLeaseSet may be sent in a DSM, RedDSA_SHA512_Ed25519 signature type supported 0.9.38DSM type bits 3-0 now contain the type; LeaseSet2 may be sent in a DSM 0.9.36NTCP2 transport support (if published in router info), minimum peers will build tunnels through (as of 0.9.46) 0.9.28RSA signature types disallowed, minimum floodfill peers will send DSM to (as of 0.9.34) 0.9.18DSM type bits 7-1 ignored 0.9.16RI key certs / ECDSA and EdDSA signature types, DLM lookup types (flag bits 3-2), minimum version compatible with the current network 0.9.15Destination/LeaseSet key certificates with EdDSA Ed25519 signature type (if floodfill) 0.9.12Destination/LeaseSet key certificates with ECDSA P-256, P-384, and P-521 signature types (if floodfill); non-zero expiration allowed in RouterAddress 0.9.7Encrypted DSM/DSRM replies supported (DLM flag bit 1) for floodfill routers 0.9.6Non-zero DLM flag bits 7-1 allowed 0.9.3Requires zero expiration in RouterAddress 0.9Supports up to 16 leases in a DSM LeaseSet store (previously 6) 0.7.12VTBM and VTBRM message support 0.7.10Floodfill supports encrypted DSM stores 0.6.1.10TBM and TBRM messages introduced; minimum version compatible with the current network **Примечание:** Существуют также особенности, связанные с транспортом, и вопросы совместимости. Подробнее см. документацию по транспортам NTCP2 и SSU2. Заголовок сообщения I2NP использует логическую структуру 16-байтового заголовка, тогда как современные транспортные протоколы (NTCP2 и SSU2) используют укороченный 9-байтовый заголовок, исключающий избыточные поля размера и контрольной суммы. Поля остаются концептуально идентичными.\nСравнение форматов заголовков Стандартный формат (16 байт):\nИспользуется в устаревшем транспорте NTCP и когда сообщения I2NP инкапсулируются в другие сообщения (TunnelData, TunnelGateway, GarlicClove).\nBytes 0-15: +----+----+----+----+----+----+----+----+ |type| msg_id | expiration +----+----+----+----+----+----+----+----+ | size |chks| +----+----+----+----+----+----+----+----+ type :: Integer (1 byte) Identifies the message type (see message type table) msg_id :: Integer (4 bytes) Uniquely identifies this message (for some time at least) Usually a locally-generated random number, but for outgoing tunnel build messages may be derived from the incoming message expiration :: Date (8 bytes) Unix timestamp in milliseconds when this message expires size :: Integer (2 bytes) Length of the payload (0 to ~61.2 KB for tunnel messages) chks :: Integer (1 byte) SHA256 hash of payload truncated to first byte Deprecated - NTCP2/SSU2 use ChaCha20/Poly1305 AEAD for integrity Короткий формат для SSU (устаревший, 5 байт):\n+----+----+----+----+----+ |type| short_expiration | +----+----+----+----+----+ type :: Integer (1 byte) short_expiration :: Integer (4 bytes, seconds since epoch) Краткий формат для NTCP2, SSU2 и ECIES-Ratchet Garlic Cloves (дольки в терминологии garlic encryption) (9 байт):\nИспользуется в современных транспортных протоколах и в garlic-сообщениях (сообщениях, объединяющих несколько сообщений), зашифрованных с помощью ECIES.\n+----+----+----+----+----+----+----+----+ |type| msg_id | short_expira- +----+----+----+----+----+----+----+----+ tion| +----+ type :: Integer (1 byte) msg_id :: Integer (4 bytes) short_expiration :: Integer (4 bytes, seconds since epoch, unsigned) Сведения о полях заголовка Field Bytes Description Type 1 Identifies the message class (0\u0026ndash;255, see message types below) Unique ID 4 Locally unique identifier for matching replies Expiration 8 (standard) / 4 (short) Timestamp when the message expires. Routers discard expired messages. Short format uses seconds since epoch (unsigned, wraps February 7, 2106) Payload Length 2 Size in bytes (0 to ~61.2 KB for tunnel messages). NTCP2 and SSU2 encode this in their frame headers Checksum 1 Deprecated. First byte of SHA-256 hash of the payload. NTCP2/SSU2 use ChaCha20/Poly1305 AEAD for integrity ### Примечания по реализации При передаче по SSU (устаревший) включались только тип и 4-байтовое значение срока действия При передаче по NTCP2 или SSU2 используется 9-байтовый короткий формат Стандартный 16-байтовый заголовок обязателен для сообщений I2NP, вложенных в другие сообщения (Data, TunnelData, TunnelGateway, GarlicClove) Начиная с версии 0.8.12, проверка контрольной суммы в некоторых местах стека протокола отключена для повышения эффективности, но генерация контрольной суммы по-прежнему требуется для совместимости Короткое поле срока действия является беззнаковым и переполнится 7 февраля 2106 года. После этой даты для получения корректного времени необходимо добавлять смещение Для совместимости со старыми версиями всегда генерируйте контрольные суммы, даже если они могут не проверяться Ограничения по размеру Сообщения tunnel фрагментируют полезную нагрузку I2NP на фрагменты фиксированного размера: - Первый фрагмент: приблизительно 956 байт - Последующие фрагменты: приблизительно по 996 байт каждый - Максимум фрагментов: 64 (пронумерованы 0-63) - Максимальная полезная нагрузка: приблизительно 61,200 байт (61.2 KB)\nРасчёт: 956 + (63 × 996) = 63,704 байт — теоретический максимум, при практическом ограничении около 61,200 байт из-за накладных расходов.\nИсторический контекст Старые транспортные протоколы имели более строгие ограничения на размер кадра: - NTCP: кадры размером 16 КБ - SSU: кадры примерно по 32 КБ\nNTCP2 поддерживает фреймы размером примерно 65 КБ, но лимит фрагментации tunnel по‑прежнему применяется.\nСоображения по данным приложения Garlic messages (чесночные сообщения) могут объединять LeaseSets, теги сессии или зашифрованные варианты LeaseSet2, уменьшая доступное место для полезной нагрузки.\nРекомендация: Датаграммы следует оставлять ≤ 10 KB для обеспечения надежной доставки. Сообщения, приближающиеся к пределу 61 KB, могут столкнуться со следующим: - Повышенная задержка из-за сборки после фрагментации - Повышенная вероятность недоставки - Большая подверженность анализу трафика\nТехнические детали фрагментации Каждое сообщение tunnel имеет размер ровно 1,024 байта (1 КБ) и содержит: - 4-байтовый ID tunnel - 16-байтовый вектор инициализации (IV) - 1,004 байта зашифрованных данных\nВнутри зашифрованных данных, сообщения tunnel переносят фрагментированные сообщения I2NP с заголовками фрагментов, указывающими: - Номер фрагмента (0-63) - Является ли это первым или последующим фрагментом - Идентификатор всего сообщения для сборки\nПервый фрагмент включает полный заголовок сообщения I2NP (16 байт), оставляя примерно 956 байт для полезной нагрузки. Последующие фрагменты не включают заголовок сообщения, что позволяет разместить примерно по 996 байт полезной нагрузки на фрагмент.\nРаспространенные типы сообщений Routers используют тип сообщения и приоритет для планирования исходящих операций. Значения с более высоким приоритетом обрабатываются первыми. Приведённые ниже значения соответствуют текущим значениям по умолчанию в Java I2P (по состоянию на версию API 0.9.67).\nПримечание: Приоритеты зависят от реализации. За эталонными значениями приоритетов обратитесь к документации класса OutNetMessage в исходном коде Java I2P.\nMessage Type Priority Typical Size Purpose DatabaseStore 1 460 Varies (LeaseSet ≈ 898\u0026nbsp;B, RouterInfo ≈ 2\u0026ndash;4\u0026nbsp;KB compressed) Publishes RouterInfo or LeaseSet objects. Supports LeaseSet2, EncryptedLeaseSet, and MetaLeaseSet DatabaseLookup 2 500 Varies Queries the network database for RouterInfo or LeaseSet entries DatabaseSearchReply 3 300 ≈161\u0026nbsp;B (5 hashes) Returns candidate floodfill router hashes (typically 3\u0026ndash;16 hashes, recommended maximum 16) DeliveryStatus 10 Varies 12\u0026nbsp;B Receipts for tunnel tests or acknowledgements inside GarlicMessages GarlicMessage 11 100 (local) Varies Bundles multiple message cloves (e.g., DataMessage, LeaseSets). Supports ElGamal/AES (deprecated) and ECIES-X25519-AEAD-Ratchet encryption TunnelData 18 400 1,028\u0026nbsp;B (fixed) Encrypted tunnel message exchanged between hops. Contains a 4-byte tunnel ID, 16-byte IV, and 1,004 bytes of encrypted data TunnelGateway 19 300\u0026ndash;400 Varies Encapsulates messages at the tunnel gateway before fragmentation DataMessage 20 425 4\u0026ndash;62\u0026nbsp;KB Carries end-to-end garlic payloads (application traffic) TunnelBuild (deprecated) 21 500 4,224\u0026nbsp;B Requests tunnel participation from routers (8 × 528-byte records). Replaced by VariableTunnelBuild for ECIES TunnelBuildReply (deprecated) 22 300 4,224\u0026nbsp;B Replies to TunnelBuild with accept/reject status per hop VariableTunnelBuild 23 500 1,057\u0026ndash;4,225\u0026nbsp;B Variable-length tunnel build for ElGamal or ECIES-X25519 routers (1\u0026ndash;8 records, API 0.9.12+) VariableTunnelBuildReply 24 300 1,057\u0026ndash;4,225\u0026nbsp;B Replies to VariableTunnelBuild ShortTunnelBuild 25 500 873\u0026ndash;1,745\u0026nbsp;B Short tunnel build messages for ECIES-X25519 routers only (1\u0026ndash;8 × 218-byte records, API 0.9.51+) OutboundTunnelBuildReply 26 300 873\u0026ndash;1,745\u0026nbsp;B Sent from outbound endpoint to originator for ECIES-X25519 routers (API 0.9.51+) **Зарезервированные типы сообщений:** - Тип 0: Зарезервирован - Типы 4-9: Зарезервированы для будущего использования - Типы 12-17: Зарезервированы для будущего использования - Типы 224-254: Зарезервированы для экспериментальных сообщений - Тип 255: Зарезервирован для будущего расширения Примечания к типу сообщения Сообщения управляющей плоскости (DatabaseLookup, TunnelBuild и т. д.) обычно проходят через исследовательские tunnels, а не через клиентские tunnels, что позволяет назначать им независимые приоритеты Значения приоритета являются ориентировочными и могут различаться в зависимости от реализации TunnelBuild (21) и TunnelBuildReply (22) считаются устаревшими, но по-прежнему реализованы для совместимости с очень длинными tunnels (\u0026gt;8 хопов) Стандартный приоритет данных в tunnel — 400; все, что выше, рассматривается как срочное Типичная длина tunnel в текущей сети составляет 3–4 хопа, поэтому для построения большинства tunnels используются ShortTunnelBuild (218-байтовые записи) или VariableTunnelBuild (528-байтовые записи) Шифрование и обертывание сообщений Routers часто инкапсулируют сообщения I2NP перед передачей, создавая несколько уровней шифрования. Сообщение DeliveryStatus может быть: 1. Заключено в GarlicMessage (зашифровано) 2. Внутри DataMessage 3. Внутри сообщения TunnelData (повторно зашифровано)\nКаждый промежуточный узел расшифровывает только свой слой; конечный адресат получает доступ к самой внутренней полезной нагрузке.\nАлгоритмы шифрования Устаревшее (поэтапно выводится из эксплуатации): - ElGamal/AES + SessionTags (теги сеанса) - ElGamal-2048 для асимметричного шифрования - AES-256 для симметричного шифрования - 32-байтовые SessionTags\nТекущее (стандарт по состоянию на API 0.9.48): - ECIES-X25519 + ChaCha20/Poly1305 AEAD с ratcheting forward secrecy (механизм последовательного обновления ключей, обеспечивающий прямую секретность) - Фреймворк протокола Noise (Noise_IK_25519_ChaChaPoly_SHA256 для назначений) - 8-байтовые сеансовые теги (уменьшено с 32 байт) - Алгоритм Signal Double Ratchet для обеспечения прямой секретности - Введено в версии API 0.9.46 (2020) - Обязательно для всех routers начиная с версии API 0.9.58 (2023)\nБудущее (бета начиная с 2.10.0): - Постквантовая гибридная криптография с использованием MLKEM (ML-KEM-768) в сочетании с X25519 - Гибридный ratchet (механизм пошагового обновления ключей), объединяющий классическое и постквантовое согласование ключей - Обратная совместимость с ECIES-X25519 - Станет настройкой по умолчанию в релизе 2.11.0 (декабрь 2025)\nОбъявление ElGamal Router устаревшим CRITICAL: ElGamal routers были объявлены устаревшими начиная с версии API 0.9.58 (релиз 2.2.0, март 2023). Поскольку рекомендуемая минимальная версия floodfill для запросов теперь 0.9.58, реализациям нет необходимости поддерживать шифрование для ElGamal floodfill routers.\nОднако: назначения ElGamal по-прежнему поддерживаются для обратной совместимости. Клиенты, использующие шифрование ElGamal, по-прежнему могут обмениваться данными через ECIES routers.\nПодробности ECIES-X25519-AEAD-Ratchet Это тип криптографии 4 в криптографической спецификации I2P. Он обеспечивает:\nКлючевые особенности: - Прямая секретность благодаря ratcheting (механизм ратчета; новые ключи для каждого сообщения) - Сокращённое хранение меток сеанса (8 байт против 32 байт) - Несколько типов сеансов (Новый сеанс, Существующий сеанс, Одноразовый) - Основано на протоколе Noise Noise_IK_25519_ChaChaPoly_SHA256 - Интегрировано с алгоритмом Double Ratchet от Signal\nКриптографические примитивы: - X25519 для согласования ключей Диффи-Хеллмана - ChaCha20 для потокового шифрования - Poly1305 для аутентификации сообщений (AEAD) - SHA-256 для хеширования - HKDF для вывода ключей\nУправление сеансами: - Новый сеанс: Первичное подключение с использованием статического ключа назначения - Существующий сеанс: Последующие сообщения с использованием тегов сеанса - Одноразовый сеанс: Одно сообщение в сеансе для снижения накладных расходов\nСм. спецификацию ECIES и Предложение 144 для получения полных технических сведений.\nОбщие структуры Следующие структуры являются элементами нескольких сообщений I2NP. Они не являются полными сообщениями.\nBuildRequestRecord (запись запроса построения) (ElGamal) УСТАРЕЛО. Используется в текущей сети только если tunnel содержит ElGamal router. См. ECIES Tunnel Creation для современного формата.\nНазначение: Одна запись в наборе из нескольких записей для запроса создания одного хопа в tunnel.\nФормат:\nЗашифровано с использованием ElGamal и AES (всего 528 байт):\n+----+----+----+----+----+----+----+----+ | encrypted data (528 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ Структура, зашифрованная алгоритмом Эль-Гамаля (528 байт):\n+----+----+----+----+----+----+----+----+ | toPeer (16 bytes) | +----+----+----+----+----+----+----+----+ | ElGamal encrypted data (512 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ toPeer :: First 16 bytes of SHA-256 hash of peer\u0026#39;s RouterIdentity encrypted_data :: ElGamal-2048 encrypted (bytes 1-256 and 258-513 of the 514-byte ElGamal block, with padding bytes at positions 0 and 257 removed) Структура незашифрованных данных (222 байта до шифрования):\n+----+----+----+----+----+----+----+----+ | receive_tunnel (4) | our_ident (32) | +----+----+----+----+ + | | + +----+----+----+----+ | | next_tunnel (4) | +----+----+----+----+----+----+----+----+ | next_ident (32 bytes) | + + | | +----+----+----+----+----+----+----+----+ | layer_key (32 bytes) | + + | | +----+----+----+----+----+----+----+----+ | iv_key (32 bytes) | + + | | +----+----+----+----+----+----+----+----+ | reply_key (32 bytes) | + + | | +----+----+----+----+----+----+----+----+ | reply_iv (16 bytes) | + + | | +----+----+----+----+----+----+----+----+ |flag| request_time (4) | send_msg_id | +----+----+----+----+----+----+----+----+ (4) | padding (29) | +----+----+----+----+----+ + | | + +----+----+ | | +----+----+----+----+----+----+ receive_tunnel :: TunnelId (4 bytes, nonzero) our_ident :: Hash (32 bytes) next_tunnel :: TunnelId (4 bytes, nonzero) next_ident :: Hash (32 bytes) layer_key :: SessionKey (32 bytes) iv_key :: SessionKey (32 bytes) reply_key :: SessionKey (32 bytes) reply_iv :: 16 bytes flag :: Integer (1 byte) request_time :: Integer (4 bytes, hours since epoch = time / 3600) send_message_id :: Integer (4 bytes) padding :: 29 bytes random data Примечания: - Шифрование ElGamal-2048 производит блок размером 514 байт, но два байта заполнения (в позициях 0 и 257) удаляются, в результате — 512 байт - См. Спецификацию создания tunnel для подробностей о полях - Исходный код: net.i2p.data.i2np.BuildRequestRecord - Константа: EncryptedBuildRecord.RECORD_SIZE = 528\nBuildRequestRecord (запись запроса на построение) (ECIES-X25519 Long) Для ECIES-X25519 routers, представленных в версии API 0.9.48. Использует 528 байт для обеспечения обратной совместимости со смешанными tunnels.\nФормат:\n+----+----+----+----+----+----+----+----+ | toPeer (16 bytes) | +----+----+----+----+----+----+----+----+ | ephemeral_key (32 bytes) | + + | | +----+----+----+----+----+----+----+----+ | ChaCha20 encrypted data (464 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ | Poly1305 MAC (16 bytes) | + + | | +----+----+----+----+----+----+----+----+ toPeer :: First 16 bytes of SHA-256 hash of peer\u0026#39;s RouterIdentity ephemeral_key :: X25519 ephemeral public key (32 bytes) encrypted_data :: ChaCha20 encrypted (464 bytes) mac :: Poly1305 message authentication code (16 bytes) Общий размер: 528 байт (такой же, как у ElGamal, для совместимости)\nСм. ECIES Tunnel Creation для сведений о структуре открытого текста и подробностях шифрования.\nBuildRequestRecord (ECIES-X25519, короткий) Только для routers ECIES-X25519, начиная с версии API 0.9.51 (релиз 1.5.0). Это текущий стандартный формат.\nФормат:\n+----+----+----+----+----+----+----+----+ | toPeer (16 bytes) | +----+----+----+----+----+----+----+----+ | ephemeral_key (32 bytes) | + + | | +----+----+----+----+----+----+----+----+ | ChaCha20 encrypted data (154 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ | Poly1305 MAC (16 bytes) | + + | | +----+----+----+----+----+----+----+----+ toPeer :: First 16 bytes of SHA-256 hash of peer\u0026#39;s RouterIdentity ephemeral_key :: X25519 ephemeral public key (32 bytes) encrypted_data :: ChaCha20 encrypted (154 bytes) mac :: Poly1305 message authentication code (16 bytes) Общий размер: 218 байт (снижение на 59% по сравнению с 528 байтами)\nКлючевое отличие: Короткие записи получают ВСЕ ключи с помощью HKDF (функция выработки ключей), вместо того чтобы включать их явно в запись. Это включает: - Ключи слоя (для шифрования tunnel) - Ключи IV (для шифрования tunnel) - Ключи ответа (для build reply (ответа на построение)) - IV ответа (для build reply)\nВсе ключи выводятся с использованием механизма HKDF протокола Noise на основе общего секрета, полученного в результате обмена ключами X25519.\nПреимущества: - 4 короткие записи умещаются в одном сообщении tunnel (873 байта) - 3 сообщения построения tunnel вместо отдельных сообщений для каждой записи - Снижены трафик и задержка - Те же свойства безопасности, что и у длинного формата\nСм. Предложение 157 для обоснования и Создание ECIES Tunnel для полной спецификации.\nИсходный код: - net.i2p.data.i2np.ShortEncryptedBuildRecord - Константа: ShortEncryptedBuildRecord.RECORD_SIZE = 218\nBuildResponseRecord (запись ответа на построение, ElGamal) УСТАРЕЛО. Используется только, если tunnel содержит ElGamal router.\nНазначение: Отдельная запись в наборе из нескольких записей, содержащих ответы на запрос на построение.\nФормат:\nЗашифрованные данные (528 байт, тот же размер, что и BuildRequestRecord):\nbytes 0-527 :: AES-encrypted record Незашифрованная структура:\n+----+----+----+----+----+----+----+----+ | SHA-256 hash (32 bytes) | + + | (hash of bytes 32-527) | + + | | +----+----+----+----+----+----+----+----+ | random data (495 bytes) | ~ ~ | |ret | +----+----+----+----+----+----+----+----+ bytes 0-31 :: SHA-256 hash of bytes 32-527 bytes 32-526 :: Random data (could be used for congestion info) byte 527 :: Reply code (0 = accept, 30 = reject) Коды ответа: - 0 - Принято - 30 - Отклонено (превышение пропускной способности)\nСм. Спецификацию создания tunnel для подробностей о поле ответа.\nBuildResponseRecord (ECIES-X25519) Для ECIES-X25519 routers — версия API 0.9.48+. Того же размера, что и соответствующий запрос (528 для длинного, 218 для короткого).\nФормат:\nДлинный формат (528 байт):\n+----+----+----+----+----+----+----+----+ | ChaCha20 encrypted data (512 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ | Poly1305 MAC (16 bytes) | + + | | +----+----+----+----+----+----+----+----+ Короткий формат (218 байт):\n+----+----+----+----+----+----+----+----+ | ChaCha20 encrypted data (202 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ | Poly1305 MAC (16 bytes) | + + | | +----+----+----+----+----+----+----+----+ Структура открытого текста (в обоих форматах):\nСодержит структуру Mapping (формат ключ-значение I2P) с:\nКод состояния ответа (обязательно) Параметр доступной пропускной способности (\u0026ldquo;b\u0026rdquo;) (необязательно, добавлено в API 0.9.65) Другие необязательные параметры для будущих расширений Коды состояния ответа: - 0 - Успех - 30 - Отклонено: превышение пропускной способности\nСм. Создание ECIES Tunnel для ознакомления с полной спецификацией.\nGarlicClove (долька сообщения «garlic»; ElGamal/AES) ПРЕДУПРЕЖДЕНИЕ: Это формат, используемый для долек внутри чесночных сообщений, зашифрованных с помощью ElGamal. Формат чесночных сообщений и долек в ECIES-AEAD-X25519-Ratchet существенно отличается. См. Спецификацию ECIES для современного формата.\nУстарело для routers (API 0.9.58+), по-прежнему поддерживается для назначений.\nФормат:\nБез шифрования:\n+----+----+----+----+----+----+----+----+ | Delivery Instructions (variable) | ~ ~ +----+----+----+----+----+----+----+----+ | I2NP Message (variable) | ~ ~ +----+----+----+----+----+----+----+----+ | Clove ID (4) | Expiration (8) |Cert| +----+----+----+----+----+----+----+----+ (3) | +----+----+----+----+----+----+----+----+ Delivery Instructions :: Variable length (typically 1, 33, or 37 bytes) I2NP Message :: Any I2NP message Clove ID :: 4-byte Integer (random, checked for duplicates) Expiration :: Date (8 bytes) Certificate :: Always NULL (3 bytes total, all zeroes) См. Garlic Routing (маршрутизация Garlic в I2P) для концептуального обзора.\nGarlicClove (долька garlic-сообщения) (ECIES-X25519-AEAD-Ratchet) Для ECIES-X25519 routers и назначений — версия API 0.9.46+. Это текущий стандартный формат.\nПРИНЦИПИАЛЬНОЕ ОТЛИЧИЕ: ECIES garlic (механизм «чесночных» сообщений в I2P) использует совершенно иную структуру, основанную на блоках протокола Noise, а не на явных структурах clove (долек).\nФормат:\nЧесночные сообщения ECIES состоят из ряда блоков:\nBlock structure: +----+----+----+----+----+----+----+----+ |type| length | data ... +----+----+----+----+----+-//- type :: 1 byte block type length :: 2 bytes block length data :: variable length data Типы блоков: - 0 - Блок Garlic Clove (долька чеснока; содержит сообщение I2NP) - 1 - Блок даты и времени (метка времени) - 2 - Блок параметров (параметры доставки) - 3 - Блок заполнения - 254 - Блок завершения (не реализовано)\nGarlic Clove Block (блок «дольки чеснока», type 0):\n+----+----+----+----+----+----+----+----+ | 0 | length | Delivery Instructions | +----+----+----+----+ + ~ ~ +----+----+----+----+----+----+----+----+ | I2NP Message | ~ ~ +----+----+----+----+----+----+----+----+ | Clove ID (4) | Expiration (4) | +----+----+----+----+----+----+----+----+ Ключевые отличия от формата ElGamal: - Использует 4-байтовое поле истечения (секунды с начала эпохи) вместо 8-байтового Date - Нет поля сертификата - Заключено в блочную структуру с типом и длиной - Сообщение целиком зашифровано с использованием ChaCha20/Poly1305 AEAD - Управление сессией через ratcheting (последовательное обновление ключей)\nСм. спецификацию ECIES для подробной информации о Noise Protocol Framework (фреймворк протокола Noise) и структурах блоков.\nИнструкции по доставке Garlic Clove (долька в garlic encryption) Этот формат используется как для чесночных долек ElGamal, так и ECIES. В нём задаётся способ доставки вложенного сообщения.\nКРИТИЧЕСКОЕ ПРЕДУПРЕЖДЕНИЕ: Эта спецификация предназначена ТОЛЬКО для \u0026ldquo;инструкций доставки\u0026rdquo; внутри Garlic Cloves (дольки чесночного сообщения). \u0026ldquo;Инструкции доставки\u0026rdquo; также используются внутри сообщений Tunnel, где формат существенно отличается. См. Спецификацию сообщений Tunnel для инструкций доставки tunnel. НЕ путайте эти два формата.\nФормат:\nСеансовый ключ и задержка не используются и никогда не передаются, поэтому возможны три длины: - 1 байт (LOCAL) - 33 байта (ROUTER и DESTINATION) - 37 байт (TUNNEL)\n+----+----+----+----+----+----+----+----+ |flag| | +----+ + | Session Key (optional, 32) | + + | | + +----+----+----+----+--------------+ | | | +----+ + | To Hash (optional, 32) | + + | | + +----+----+----+----+--------------+ | | Tunnel ID (4, opt)| Delay (4, opt)| +----+----+----+----+----+----+----+----+ flag :: 1 byte Bit order: 76543210 bit 7: encrypted? (Unimplemented, always 0) If 1, a 32-byte encryption session key follows bits 6-5: delivery type 0x0 = LOCAL (0) 0x1 = DESTINATION (1) 0x2 = ROUTER (2) 0x3 = TUNNEL (3) bit 4: delay included? (Not fully implemented, always 0) If 1, four delay bytes are included bits 3-0: reserved, set to 0 for compatibility Session Key :: 32 bytes (Optional, unimplemented) Present if encrypt flag bit is set To Hash :: 32 bytes (Optional) Present if delivery type is DESTINATION, ROUTER, or TUNNEL - DESTINATION: SHA256 hash of the destination - ROUTER: SHA256 hash of the router identity - TUNNEL: SHA256 hash of the gateway router identity Tunnel ID :: 4 bytes (Optional) Present if delivery type is TUNNEL The destination tunnel ID (nonzero) Delay :: 4 bytes (Optional, unimplemented) Present if delay included flag is set Specifies delay in seconds Типичные длины: - ЛОКАЛЬНАЯ доставка: 1 байт (только флаг) - ROUTER / DESTINATION доставка: 33 байта (флаг + хеш) - TUNNEL доставка: 37 байт (флаг + хеш + tunnel ID)\nОписания типов доставки:\nType Value Description LOCAL 0 Deliver to the local router (this router) DESTINATION 1 Deliver to a destination (client) identified by hash ROUTER 2 Deliver to another router identified by hash TUNNEL 3 Deliver to a tunnel gateway router **Примечания по реализации:** - Шифрование сеансового ключа не реализовано, и бит флага всегда равен 0 - Задержка реализована не полностью, и бит флага всегда равен 0 - Для доставки TUNNEL хэш идентифицирует шлюзовой router, а ID tunnel указывает, какой входящий tunnel - Для доставки DESTINATION (назначение), хэш — это SHA-256 публичного ключа назначения - Для доставки ROUTER хэш — это SHA-256 идентификатора router Сообщения I2NP Полные спецификации для всех типов сообщений I2NP.\nСводка типов сообщений Message Type Since Status DatabaseStore10.6.1.10Active DatabaseLookup20.6.1.10Active DatabaseSearchReply30.6.1.10Active DeliveryStatus100.6.1.10Active Garlic110.6.1.10Active TunnelData180.6.1.10Active TunnelGateway190.6.1.10Active Data200.6.1.10Active TunnelBuild210.6.1.10Deprecated TunnelBuildReply220.6.1.10Deprecated VariableTunnelBuild230.7.12Active VariableTunnelBuildReply240.7.12Active ShortTunnelBuild250.9.51Active OutboundTunnelBuildReply260.9.51Active **Зарезервировано:** - Тип 0: зарезервирован - Типы 4-9: зарезервированы для будущего использования - Типы 12-17: зарезервированы для будущего использования - Типы 224-254: зарезервированы для экспериментальных сообщений - Тип 255: зарезервирован для будущего расширения DatabaseStore (тип 1) Назначение: Незапрошенное сохранение в базе данных или ответ на успешный запрос DatabaseLookup (поиск в базе данных).\nСодержимое: Несжатый LeaseSet, LeaseSet2, MetaLeaseSet или EncryptedLeaseSet, либо сжатый RouterInfo (информация о router).\nФормат с токеном ответа:\n+----+----+----+----+----+----+----+----+ | SHA256 Hash as key (32 bytes) | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ |type| reply token (4) | reply_tunnelId +----+----+----+----+----+----+----+----+ (4) | reply gateway | +----+----+----+----+----+ + | SHA256 hash (32 bytes) | + + | | + +----+ | | +----+----+----+----+----+----+----+ | data ... +----+-// key :: 32 bytes SHA256 hash (the \u0026#34;real\u0026#34; hash, not routing key) type :: 1 byte Type identifier bit 0: 0 = RouterInfo 1 = LeaseSet or variants bits 3-1: (as of 0.9.38) 0: RouterInfo or LeaseSet (types 0 or 1) 1: LeaseSet2 (type 3) 2: EncryptedLeaseSet (type 5) 3: MetaLeaseSet (type 7) 4-7: Unsupported, invalid bits 7-4: Reserved, set to 0 reply token :: 4 bytes If greater than zero, a DeliveryStatusMessage is requested with the Message ID set to the reply token A floodfill router is also expected to flood the data to the closest floodfill peers reply_tunnelId :: 4 bytes (only if reply token \u0026gt; 0) TunnelId of the inbound gateway of the tunnel for the response If 0, reply is sent directly to reply gateway reply gateway :: 32 bytes (only if reply token \u0026gt; 0) SHA256 hash of the RouterInfo If reply_tunnelId is nonzero: inbound gateway router If reply_tunnelId is zero: router to send reply to data :: Variable length If type == 0: 2-byte Integer length + gzip-compressed RouterInfo If type == 1: Uncompressed LeaseSet If type == 3: Uncompressed LeaseSet2 If type == 5: Uncompressed EncryptedLeaseSet If type == 7: Uncompressed MetaLeaseSet Формат при токене ответа == 0:\n+----+----+----+----+----+----+----+----+ | SHA256 Hash as key (32 bytes) | + + | | +----+----+----+----+----+----+----+----+ |type| 0 | data ... +----+----+----+----+----+-// Примечания: - В целях безопасности поля ответа игнорируются, если сообщение получено через tunnel - Ключ — это «реальный» хэш от RouterIdentity или Destination, а НЕ ключ маршрутизации - Типы 3, 5 и 7 (варианты LeaseSet2) были добавлены в выпуске 0.9.38 (API 0.9.38). См. Предложение 123 для подробностей - Эти типы следует отправлять только на routers с версией API 0.9.38 или выше - В качестве оптимизации для сокращения числа соединений: если тип — LeaseSet, включён токен ответа, ID ответного tunnel не равен нулю, и пара reply gateway/tunnelID найдена в LeaseSet как lease (элемент LeaseSet), получатель может перенаправить ответ на любой другой lease в LeaseSet - Формат gzip RouterInfo: Чтобы скрыть ОС и реализацию router, приведите формат к реализации router на Java, установив время модификации равным 0 и байт ОС — 0xFF, а XFL — 0x02 (максимальное сжатие, самый медленный алгоритм) согласно RFC 1952. Первые 10 байт: 1F 8B 08 00 00 00 00 00 02 FF\nИсходный код: - net.i2p.data.i2np.DatabaseStoreMessage - net.i2p.data.RouterInfo (для структуры RouterInfo) - net.i2p.data.LeaseSet (для структуры LeaseSet)\nDatabaseLookup (Тип 2) Назначение: Запрос на поиск записи в сетевой базе данных (netDb). Ответом будет либо DatabaseStore, либо DatabaseSearchReply.\nФормат:\n+----+----+----+----+----+----+----+----+ | SHA256 hash as the key (32 bytes) | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ | SHA256 hash of the from router (32) | + or reply tunnel gateway + | | + + | | + + | | +----+----+----+----+----+----+----+----+ |flag| reply_tunnelId (4)| size (2)| | +----+----+----+----+----+----+----+ + | SHA256 of key1 to exclude (32 bytes) | + + | | + +----+ | | | +----+----+----+----+----+----+----+ + | SHA256 of key2 to exclude (32) | + + ~ ~ | | + +----+ | | | +----+----+----+----+----+----+----+ + | Session key if reply encryption | + requested (32 bytes) + | | + +----+ | |tags| +----+----+----+----+----+----+----+----+ | Session tags if reply encryption | + requested (variable) + ~ ~ | | +----+----+----+----+----+----+----+----+ key :: 32 bytes SHA256 hash of the object to lookup from :: 32 bytes If deliveryFlag == 0: SHA256 hash of RouterInfo (sender) If deliveryFlag == 1: SHA256 hash of reply tunnel gateway flags :: 1 byte Bit order: 76543210 bit 0: deliveryFlag 0 = send reply directly 1 = send reply to some tunnel bit 1: encryptionFlag Through 0.9.5: must be 0 As of 0.9.6: ignored As of 0.9.7: 0 = send unencrypted reply 1 = send AES encrypted reply using key and tag bits 3-2: lookup type flags Through 0.9.5: must be 00 As of 0.9.6: ignored As of 0.9.16: 00 = ANY (deprecated, use LS or RI as of 0.9.16) 01 = LS lookup (LeaseSet or variants) 10 = RI lookup (RouterInfo) 11 = exploration lookup (RouterInfo, non-floodfill) bit 4: ECIESFlag Before 0.9.46: ignored As of 0.9.46: 0 = send unencrypted or ElGamal reply 1 = send ChaCha/Poly encrypted reply using key bits 7-5: Reserved, set to 0 reply_tunnelId :: 4 bytes (only if deliveryFlag == 1) TunnelId of the tunnel to send reply to (nonzero) size :: 2 bytes Integer (valid range: 0-512) Number of peers to exclude from DatabaseSearchReply excludedPeers :: $size SHA256 hashes of 32 bytes each If lookup fails, exclude these peers from the reply If includes a hash of all zeroes, the request is exploratory (return non-floodfill routers only) reply_key :: 32 bytes (conditional, see encryption modes below) reply_tags :: 1 byte count + variable length tags (conditional) Режимы шифрования ответов:\nПРИМЕЧАНИЕ: ElGamal routers признаны устаревшими с версии API 0.9.58. Поскольку рекомендуемая минимальная версия floodfill для запросов теперь 0.9.58, реализациям не требуется реализовывать шифрование для ElGamal floodfill routers. Назначения ElGamal по‑прежнему поддерживаются.\nБит 4 флага (ECIESFlag) используется в сочетании с битом 1 (encryptionFlag) для определения режима шифрования ответа:\nFlag bits 4,1 From To Router Reply DH? Notes 0 0 Any Any No encryption n/a No encryption 0 1 ElG ElG AES No As of 0.9.7, deprecated 0.9.58 1 0 ECIES ElG AEAD No As of 0.9.46, deprecated 0.9.58 1 0 ECIES ECIES AEAD No As of 0.9.49, current standard 1 1 ElG ECIES AES Yes TBD, future 1 1 ECIES ECIES AEAD Yes TBD, future **Без шифрования (флаги 0,0):** reply_key, tags и reply_tags отсутствуют.\nElG в ElG (флаги 0,1) - УСТАРЕВШЕЕ:\nПоддерживается начиная с 0.9.7, объявлено устаревшим начиная с 0.9.58.\nreply_key :: 32 byte SessionKey (big-endian) CSRNG(32) random data tags :: 1 byte Integer (1-32, typically 1) Number of reply tags that follow reply_tags :: One or more 32-byte SessionTags Each is CSRNG(32) random data ECIES в ElG (флаги 1,0) - УСТАРЕЛО:\nПоддерживается с версии 0.9.46, помечено как устаревшее с версии 0.9.58.\nreply_key :: 32 byte ECIES SessionKey (big-endian) CSRNG(32) random data tags :: 1 byte Integer (required value: 1) Number of reply tags that follow reply_tags :: One 8-byte ECIES SessionTag CSRNG(8) random data Ответ представляет собой сообщение ECIES Existing Session (существующий сеанс), как определено в спецификации ECIES :\n+----+----+----+----+----+----+----+----+ | Session Tag (8 bytes) | +----+----+----+----+----+----+----+----+ | ChaCha20 encrypted payload | ~ ~ | | +----+----+----+----+----+----+----+----+ | Poly1305 MAC (16 bytes) | + + | | +----+----+----+----+----+----+----+----+ tag :: 8 byte reply_tag k :: 32 byte session key (the reply_key) n :: 0 (nonce) ad :: The 8 byte reply_tag payload :: Plaintext data (DSM or DSRM) ciphertext = ENCRYPT(k, n, payload, ad) ECIES в ECIES (flags 1,0) - ТЕКУЩИЙ СТАНДАРТ:\nECIES Destination (адрес назначения) или router отправляет запрос на поиск к ECIES router. Поддерживается начиная с 0.9.49.\nТакой же формат, как у \u0026ldquo;ECIES to ElG\u0026rdquo; выше. Шифрование сообщения поиска определено в ECIES Routers . Запрашивающий анонимен.\nECIES (схема шифрования на эллиптических кривых) в ECIES с DH (алгоритм Диффи — Хеллмана) (флаги 1,1) - БУДУЩЕЕ:\nЕщё не полностью определено. См. Предложение 156 .\nПримечания: - До версии 0.9.16 ключ мог относиться к RouterInfo или LeaseSet (одно и то же пространство ключей, нет флага для различения) - Зашифрованные ответы полезны только когда ответ проходит через tunnel - Число включённых тегов может быть больше одного, если реализованы альтернативные стратегии поиска в DHT - Ключ поиска и ключи исключения — это \u0026ldquo;реальные\u0026rdquo; хэши, НЕ маршрутизационные ключи - Типы 3, 5 и 7 (варианты LeaseSet2) могут возвращаться начиная с 0.9.38. См. Proposal 123 - Примечания по exploratory lookup (исследовательский поиск): exploratory lookup определяется как возвращающий список не-floodfill хэшей, близких к ключу. Однако реализации различаются: Java действительно выполняет поиск по ключу RI и, если он есть, возвращает DatabaseStore (сообщение I2NP); i2pd — нет. Поэтому не рекомендуется использовать exploratory lookup для ранее полученных хэшей\nИсходный код: - net.i2p.data.i2np.DatabaseLookupMessage - Шифрование: net.i2p.crypto.SessionKeyManager\nDatabaseSearchReply (Тип 3) Назначение: Ответ на неудавшийся запрос DatabaseLookup (поиск в базе данных).\nСодержимое: Список хэшей router, ближайших к запрошенному ключу.\nФормат:\n+----+----+----+----+----+----+----+----+ | SHA256 hash as query key (32 bytes) | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ | num| peer_hashes (variable) | +----+ + | | ~ ~ | | + +----+----+----+----+----+----+----+ | | from (32 bytes) | +----+ + | | + + | | + + | | + +----+----+----+----+----+----+----+ | | +----+ key :: 32 bytes SHA256 of the object being searched num :: 1 byte Integer Number of peer hashes that follow (0-255) peer_hashes :: $num SHA256 hashes of 32 bytes each (total $num*32 bytes) SHA256 of the RouterIdentity that the sender thinks is close to the key from :: 32 bytes SHA256 of the RouterInfo of the router this reply was sent from Примечания: - Хэш \u0026lsquo;from\u0026rsquo; не аутентифицирован и ему нельзя доверять - Возвращаемые хэши узлов не обязательно ближе к ключу, чем запрашиваемый router. В ответах на обычные запросы это облегчает обнаружение новых floodfills и \u0026ldquo;обратный\u0026rdquo; поиск (дальше от ключа) для повышения устойчивости - Для исследовательских запросов ключ обычно генерируется случайно. Не-floodfill peer_hashes в ответе могут отбираться с использованием оптимизированного алгоритма (например, близкие, но не обязательно самые близкие узлы), чтобы избежать неэффективной сортировки всей локальной базы данных. Также могут использоваться стратегии кэширования. Это зависит от реализации - Типичное количество возвращаемых хэшей: 3 - Рекомендуемое максимальное количество возвращаемых хэшей: 16 - Ключ поиска, хэши узлов и хэш \u0026lsquo;from\u0026rsquo; являются \u0026ldquo;реальными\u0026rdquo; хэшами, НЕ ключами маршрутизации - Если num равно 0, это означает, что более близкие узлы не найдены (тупик)\nИсходный код: - net.i2p.data.i2np.DatabaseSearchReplyMessage\nDeliveryStatus (тип 10) Назначение: Простое подтверждение получения сообщения. Обычно создаётся отправителем сообщения и помещается в Garlic Message (тип сообщения «Garlic») вместе с самим сообщением, для последующего возврата получателем.\nСодержимое: Идентификатор доставленного сообщения и время создания или поступления.\nФормат:\n+----+----+----+----+----+----+----+----+----+----+----+----+ | msg_id (4) | time_stamp (8) | +----+----+----+----+----+----+----+----+----+----+----+----+ msg_id :: Integer (4 bytes) Unique ID of the message we deliver the DeliveryStatus for (see I2NP Message Header for details) time_stamp :: Date (8 bytes) Time the message was successfully created or delivered Примечания: - Метка времени всегда устанавливается создателем на текущее время. Однако в коде есть несколько мест, где это используется, и в будущем их может стать больше - Это сообщение также используется как подтверждение установления сессии в SSU. В этом случае ID сообщения устанавливается в случайное число, а \u0026ldquo;время прибытия\u0026rdquo; устанавливается равным текущему общесетевому идентификатору, который равен 2 (т. е., 0x0000000000000002) - DeliveryStatus (тип сообщения I2NP для подтверждения доставки) обычно оборачивается в GarlicMessage (агрегированное garlic-сообщение) и отправляется через tunnel, чтобы предоставить подтверждение, не раскрывая отправителя - Используется для тестирования tunnel с целью измерения задержки и надежности\nИсходный код: - net.i2p.data.i2np.DeliveryStatusMessage - Используется в: net.i2p.router.tunnel.InboundEndpointProcessor для тестирования tunnel\nGarlicMessage (сообщение I2NP «Garlic», тип 11) ПРЕДУПРЕЖДЕНИЕ: Это формат, используемый для garlic messages (тип сообщений в I2P, в которых несколько сообщений объединяются в один), зашифрованных с помощью ElGamal. Формат для ECIES-AEAD-X25519-Ratchet garlic messages существенно отличается. См. ECIES Specification для современного формата.\nНазначение: Используется для инкапсуляции нескольких зашифрованных сообщений I2NP.\nСодержимое: после расшифрования — совокупность Garlic Cloves (долек) и дополнительных данных, также известная как Clove Set (набор долек).\nЗашифрованный формат:\n+----+----+----+----+----+----+----+----+ | length (4) | data | +----+----+----+----+----+ + | | ~ ~ | | +----+----+----+----+----+----+----+----+ length :: 4 byte Integer Number of bytes that follow (0 to 64 KB) data :: $length bytes ElGamal encrypted data Расшифрованные данные (Clove Set — набор долек):\n+----+----+----+----+----+----+----+----+ | num| clove 1 (variable) | +----+ + | | ~ ~ | | +----+----+----+----+----+----+----+----+ | clove 2 (variable) | ~ ~ | | +----+----+----+----+----+----+----+----+ | Certificate (3) | Message_ID (4) | +----+----+----+----+----+----+----+----+ Expiration (8) | +----+----+----+----+----+----+----+----+ num :: 1 byte Integer Number of GarlicCloves to follow clove :: GarlicClove (see GarlicClove structure above) Certificate :: Always NULL (3 bytes total, all zeroes) Message_ID :: 4 byte Integer Expiration :: Date (8 bytes) Notes: - When unencrypted, data contains one or more Garlic Cloves - The AES encrypted block is padded to a minimum of 128 bytes; with the 32-byte Session Tag, the minimum size of the encrypted message is 160 bytes; with the 4-byte length field, the minimum size of the Garlic Message is 164 bytes - Actual max length is less than 64 KB (practical limit around 61.2 KB for tunnel messages) - See ElGamal/AES Specification for encryption details - See Garlic Routing for conceptual overview - The 128 byte minimum size of the AES encrypted block is not currently configurable - The message ID is generally set to a random number on transmit and appears to be ignored on receive - The certificate could possibly be used for HashCash to \u0026ldquo;pay\u0026rdquo; for routing (future possibility) - ElGamal encryption structure: 32-byte session tag + ElGamal-encrypted session key + AES-encrypted payload\nДля формата ECIES-X25519-AEAD-Ratchet (текущий стандарт для routers):\nСм. спецификацию ECIES и предложение 144 .\nИсходный код: - net.i2p.data.i2np.GarlicMessage - Шифрование: net.i2p.crypto.elgamal.ElGamalAESEngine (устарело) - Современное шифрование: net.i2p.crypto.ECIES пакеты\nTunnelData (Тип 18) Назначение: Сообщение, отправляемое со шлюза tunnel или его участника к следующему участнику или конечной точке. Данные имеют фиксированную длину и содержат сообщения I2NP, которые фрагментируются, пакетируются, дополняются и шифруются.\nФормат:\n+----+----+----+----+----+----+----+----+ | tunnelID (4) | data (1024) | +----+----+----+----+----+ + | | ~ ~ | | + +----+----+----+----+ | | +----+----+----+----+ tunnelId :: 4 bytes TunnelId identifying the tunnel this message is directed at Nonzero data :: 1024 bytes Payload data, fixed to 1024 bytes Структура полезной нагрузки (1024 байта):\nBytes 0-15: Initialization Vector (IV) for AES encryption Bytes 16-1023: Encrypted tunnel message data (1008 bytes) Примечания: - ID сообщения I2NP для TunnelData устанавливается в новое случайное значение на каждом переходе - Формат сообщения tunnel (внутри зашифрованных данных) определён в Спецификации сообщений tunnel - Каждый переход расшифровывает один слой с использованием AES-256 в режиме CBC - Вектор инициализации (IV) обновляется на каждом переходе с использованием расшифрованных данных - Общий размер ровно 1,028 байт (4 tunnelId + 1024 data) - Это базовая единица трафика tunnel - Сообщения TunnelData переносят фрагментированные сообщения I2NP (GarlicMessage, DatabaseStore и т. д.)\nИсходный код: - net.i2p.data.i2np.TunnelDataMessage - Константа: TunnelDataMessage.DATA_LENGTH = 1024 - Обработка: net.i2p.router.tunnel.InboundGatewayProcessor\nTunnelGateway (шлюз tunnel; Тип 19) Назначение: Инкапсулирует другое сообщение I2NP для отправки в tunnel через его входной шлюз.\nФормат:\n+----+----+----+----+----+----+----+-// | tunnelId (4) | length (2)| data... +----+----+----+----+----+----+----+-// tunnelId :: 4 bytes TunnelId identifying the tunnel this message is directed at Nonzero length :: 2 byte Integer Length of the payload data :: $length bytes Actual payload of this message Примечания: - Полезная нагрузка представляет собой сообщение I2NP со стандартным 16-байтовым заголовком - Используется для внедрения сообщений в tunnels из локального router - Шлюз туннеля фрагментирует вложенное сообщение при необходимости - После фрагментации фрагменты инкапсулируются в сообщения TunnelData - TunnelGateway никогда не передаётся по сети; это внутренний тип сообщения, используемый до обработки tunnel\nИсходный код: - net.i2p.data.i2np.TunnelGatewayMessage - Обработка: net.i2p.router.tunnel.OutboundGatewayProcessor\nDataMessage (Тип 20) Назначение: Используется в Garlic Messages (сообщения типа Garlic) и Garlic Cloves (вложенные «дольки» сообщения Garlic) для инкапсуляции произвольных данных (обычно данных приложения со сквозным шифрованием).\nФормат:\n+----+----+----+----+----+----+-//-+ | length (4) | data... | +----+----+----+----+----+----+-//-+ length :: 4 bytes Length of the payload data :: $length bytes Actual payload of this message Примечания: - Это сообщение не содержит маршрутной информации и никогда не отправляется \u0026ldquo;в необёрнутом виде\u0026rdquo; - Используется только внутри сообщений Garlic - Обычно содержит сквозно зашифрованные данные приложений (HTTP, IRC, email и т. д.) - Данные обычно представляют собой полезную нагрузку, зашифрованную ElGamal/AES или ECIES - Максимальная практическая длина составляет около 61.2 KB из-за ограничений фрагментации сообщений в tunnel\nИсходный код: - net.i2p.data.i2np.DataMessage\nTunnelBuild (Тип 21) УСТАРЕЛО. Используйте VariableTunnelBuild (тип 23) или ShortTunnelBuild (тип 25).\nНазначение: Запрос на построение tunnel фиксированной длины на 8 хопов.\nФормат:\n+----+----+----+----+----+----+----+----+ | Record 0 (528 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ | Record 1 (528 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ | Record 7 (528 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ Just 8 BuildRequestRecords attached together Record size: 528 bytes Total size: 8 × 528 = 4,224 bytes Примечания: - Начиная с 0.9.48, может содержать ECIES-X25519 BuildRequestRecords (записи запросов на построение). См. Создание tunnel ECIES - Подробности см. в Спецификации создания tunnel - Идентификатор сообщения I2NP для данного сообщения должен быть установлен в соответствии со спецификацией создания tunnel - Хотя в сегодняшней сети встречается редко (заменено на VariableTunnelBuild), это всё ещё может использоваться для очень длинных tunnels и формально не объявлено устаревшим - Routers по-прежнему должны реализовывать это для совместимости - Фиксированный формат из 8 записей негибок и зря расходует полосу пропускания для более коротких tunnels\nИсходный код: - net.i2p.data.i2np.TunnelBuildMessage - Константа: TunnelBuildMessageBase.MAX_RECORD_COUNT = 8\nTunnelBuildReply (Ответ на построение tunnel, Тип 22) УСТАРЕЛО. Используйте VariableTunnelBuildReply (тип 24) или OutboundTunnelBuildReply (тип 26).\nНазначение: Ответ на построение tunnel фиксированной длины для 8 хопов.\nФормат:\nТот же формат, что и у TunnelBuildMessage, с BuildResponseRecords вместо BuildRequestRecords.\nTotal size: 8 × 528 = 4,224 bytes Примечания: - Начиная с 0.9.48, может содержать ECIES-X25519 BuildResponseRecords. См. ECIES Tunnel Creation - Подробности см. в Tunnel Creation Specification - Идентификатор сообщения I2NP для данного сообщения должен быть установлен в соответствии со спецификацией создания Tunnel - Хотя в нынешней сети встречается редко (заменён на VariableTunnelBuildReply), он всё ещё может использоваться для очень длинных tunnels и формально не объявлен устаревшим - Routers по-прежнему должны поддерживать это для совместимости\nИсходный код: - net.i2p.data.i2np.TunnelBuildReplyMessage\nVariableTunnelBuild (Тип 23) Назначение: Построение tunnel переменной длины из 1-8 хопов. Поддерживает routers как на базе ElGamal, так и на базе ECIES-X25519.\nФормат:\n+----+----+----+----+----+----+----+----+ | num| BuildRequestRecords (variable) | +----+----+----+----+----+----+----+----+ num :: 1 byte Integer Valid values: 1-8 BuildRequestRecords :: $num records of 528 bytes each Record size: 528 bytes Total size: 1 + ($num × 528) bytes Примечания: - Начиная с 0.9.48, может содержать ECIES-X25519 BuildRequestRecords (записи запроса построения). См. Создание ECIES tunnel - Введено в router версии 0.7.12 (2009) - Не следует отправлять участникам tunnel с версиями ниже 0.7.12 - Подробности: см. Спецификацию создания tunnel - ID сообщения I2NP должен быть установлен в соответствии со спецификацией создания tunnel - Типичное количество записей: 4 (для 4-хопового tunnel) - Типичный общий размер: 1 + (4 × 528) = 2,113 байт - Это стандартное сообщение построения tunnel для ElGamal routers - ECIES routers обычно используют ShortTunnelBuild (сообщение короткого построения tunnel, тип 25) вместо этого\nИсходный код: - net.i2p.data.i2np.VariableTunnelBuildMessage\nVariableTunnelBuildReply (Тип 24) Назначение: Ответ переменной длины на построение tunnel (туннель I2P) для 1-8 хопов. Поддерживает оба типа routers (маршрутизаторы I2P): ElGamal и ECIES-X25519.\nФормат:\nТот же формат, что и у VariableTunnelBuildMessage, с BuildResponseRecords вместо BuildRequestRecords.\n+----+----+----+----+----+----+----+----+ | num| BuildResponseRecords (variable) | +----+----+----+----+----+----+----+----+ num :: 1 byte Integer Valid values: 1-8 BuildResponseRecords :: $num records of 528 bytes each Record size: 528 bytes Total size: 1 + ($num × 528) bytes Примечания: - Начиная с 0.9.48, может содержать ECIES-X25519 BuildResponseRecords. См. Создание Tunnel с ECIES - Введено в версии router 0.7.12 (2009) - Не должно отправляться участникам tunnel с версией ниже 0.7.12 - Подробности см. в Спецификации создания Tunnel - Идентификатор сообщения I2NP должен быть установлен в соответствии со спецификацией создания tunnel - Типичное количество записей: 4 - Типичный общий размер: 2,113 байт\nИсходный код: - net.i2p.data.i2np.VariableTunnelBuildReplyMessage\nShortTunnelBuild (Тип 25) Назначение: Короткие сообщения для построения tunnel только для ECIES-X25519 routers. Введены в версии API 0.9.51 (релиз 1.5.0, август 2021 г.). Это текущий стандарт для построения ECIES tunnel.\nФормат:\n+----+----+----+----+----+----+----+----+ | num| ShortBuildRequestRecords (var) | +----+----+----+----+----+----+----+----+ num :: 1 byte Integer Valid values: 1-8 ShortBuildRequestRecords :: $num records of 218 bytes each Record size: 218 bytes Total size: 1 + ($num × 218) bytes Примечания: - Введено в router версии 0.9.51 (релиз 1.5.0, август 2021) - Не должно отправляться участникам tunnel в версиях API ранее 0.9.51 - См. Создание ECIES Tunnel для полной спецификации - См. Предложение 157 для обоснования - Типичное число записей: 4 - Типичный общий размер: 1 + (4 × 218) = 873 байт - Экономия полосы пропускания: на 59% меньше, чем VariableTunnelBuild (формат построения tunnel с переменной длиной) (873 против 2,113 байт) - Преимущество по производительности: 4 короткие записи умещаются в одном сообщении tunnel; VariableTunnelBuild требует 3 сообщения tunnel - Теперь это стандартный формат построения tunnel для чистых ECIES-X25519 tunnel - Записи выводят ключи через HKDF, вместо того чтобы включать их явно\nИсходный код: - net.i2p.data.i2np.ShortTunnelBuildMessage - Константа: ShortEncryptedBuildRecord.RECORD_SIZE = 218\nOutboundTunnelBuildReply (Тип 26) Назначение: Отправляется с исходящей конечной точки нового tunnel инициатору. Только для ECIES-X25519 routers. Введено в версии API 0.9.51 (релиз 1.5.0, август 2021).\nФормат:\nТот же формат, что и у ShortTunnelBuildMessage, но с ShortBuildResponseRecords вместо ShortBuildRequestRecords.\n+----+----+----+----+----+----+----+----+ | num| ShortBuildResponseRecords (var) | +----+----+----+----+----+----+----+----+ num :: 1 byte Integer Valid values: 1-8 ShortBuildResponseRecords :: $num records of 218 bytes each Record size: 218 bytes Total size: 1 + ($num × 218) bytes Примечания: - Введено в версии router 0.9.51 (релиз 1.5.0, август 2021) - См. ECIES Tunnel Creation для полной спецификации - Типичное количество записей: 4 - Типичный общий размер: 873 байт - Этот ответ отправляется от конечной точки исходящего tunnel (OBEP) обратно создателю tunnel через вновь созданный исходящий tunnel - Подтверждает, что все хопы приняли построение tunnel\nИсходный код: - net.i2p.data.i2np.OutboundTunnelBuildReplyMessage\nСсылки Официальные спецификации Спецификация I2NP - Полная спецификация формата сообщений I2NP Общие структуры - Типы данных и структуры, используемые во всём I2P Создание tunnel - Создание tunnel на основе ElGamal (устарело) Создание tunnel ECIES - Создание tunnel на основе ECIES-X25519 (текущее) Сообщение tunnel - Формат сообщений tunnel и инструкции по доставке Спецификация NTCP2 - Транспортный протокол TCP Спецификация SSU2 - Транспортный протокол UDP Спецификация ECIES - Шифрование ECIES-X25519-AEAD-Ratchet Спецификация криптографии - Низкоуровневые криптографические примитивы Спецификация I2CP - Спецификация клиентского протокола Спецификация дейтаграмм - Форматы Datagram2 и Datagram3 Предложения Документация Маршрутизация Garlic - Многоуровневое объединение сообщений ElGamal/AES - Устаревшая схема шифрования Реализация tunnel - Фрагментация и обработка Сетевая база данных - Распределенная хеш-таблица Транспорт NTCP2 - Спецификация транспорта TCP Транспорт SSU2 - Спецификация транспорта UDP Техническое введение - Обзор архитектуры I2P Исходный код Репозиторий Java I2P - Официальная реализация на Java Зеркало на GitHub - Зеркало Java I2P на GitHub Репозиторий i2pd - Реализация на C++ Основные расположения исходного кода Java I2P (i2pgit.org/I2P_Developers/i2p.i2p): - core/java/src/net/i2p/data/i2np/ - Реализации сообщений I2NP - core/java/src/net/i2p/crypto/ - Криптографические реализации - router/java/src/net/i2p/router/tunnel/ - Обработка tunnel - router/java/src/net/i2p/router/transport/ - Реализации транспорта\nКонстанты и значения: - I2NPMessage.MAX_SIZE = 65536 - Максимальный размер сообщения I2NP - I2NPMessageImpl.HEADER_LENGTH = 16 - Стандартный размер заголовка - TunnelDataMessage.DATA_LENGTH = 1024 - Полезная нагрузка сообщения tunnel - EncryptedBuildRecord.RECORD_SIZE = 528 - Длинная запись построения - ShortEncryptedBuildRecord.RECORD_SIZE = 218 - Короткая запись построения - TunnelBuildMessageBase.MAX_RECORD_COUNT = 8 - Максимальное число записей на одно построение\nПриложение A: Статистика сети и текущее состояние Состав сети (по состоянию на октябрь 2025 года) Всего router\u0026rsquo;ов: Примерно 60,000-70,000 (варьируется) Floodfill router\u0026rsquo;ы: Примерно 500-700 активных Типы шифрования: ECIES-X25519: \u0026gt;95% router\u0026rsquo;ов ElGamal: \u0026lt;5% router\u0026rsquo;ов (устаревший, только для совместимости) Использование транспортов: SSU2: \u0026gt;60% основной транспорт NTCP2: ~40% основной транспорт Устаревшие транспорты (SSU1, NTCP): 0% (удалены) Типы подписей: EdDSA (Ed25519): Подавляющее большинство ECDSA: Небольшой процент RSA: Запрещено (удалено) Минимальные требования к Router Версия API: 0.9.16+ (для совместимости EdDSA с сетью) Рекомендуемый минимум: API 0.9.51+ (сборки ECIES с короткими tunnel) Текущий минимум для floodfills: API 0.9.58+ (объявление router на ElGamal устаревшим) Предстоящее требование: Java 17+ (начиная с релиза 2.11.0, декабрь 2025) Требования к пропускной способности Минимум: 128 KBytes/sec (флаг N или выше) для floodfill Рекомендуется: 256 KBytes/sec (флаг O) или выше Требования к floodfill: Минимальная пропускная способность 128 KB/sec Стабильный аптайм (рекомендуется \u0026gt;95%) Низкая задержка (\u0026lt;500ms до пиров) Прохождение проверок состояния (время в очереди, задержка задач) Статистика Tunnel Типичная длина tunnel: 3-4 хопа Максимальная длина tunnel: 8 хопов (теоретически, редко используется) Типичное время жизни tunnel: 10 минут Доля успешных построений tunnel: \u0026gt;85% для routers с хорошей связностью Формат сообщений для построения tunnel: ECIES routers: ShortTunnelBuild (218-байтовые записи) Смешанные tunnels: VariableTunnelBuild (528-байтовые записи) Метрики производительности Время построения tunnel: 1-3 секунды (типично) Сквозная задержка: 0.5-2 секунды (типично, всего 6-8 хопов) Пропускная способность: ограничивается пропускной способностью tunnel (обычно 10-50 KB/sec на tunnel) Максимальный размер датаграммы: рекомендуется 10 KB (теоретический максимум 61.2 KB) Приложение B: Устаревшие и удалённые возможности Полностью удалено (больше не поддерживается) Транспорт NTCP - Удалён в релизе 0.9.50 (май 2021) Транспорт SSU v1 - Удалён из Java I2P в релизе 2.4.0 (декабрь 2023) Транспорт SSU v1 - Удалён из i2pd в релизе 2.44.0 (ноябрь 2022) Типы подписей RSA - Запрещены начиная с API 0.9.28 Устаревшее (поддерживается, но не рекомендуется) ElGamal routers - Устарело начиная с API 0.9.58 (март 2023 г.) Назначения ElGamal по-прежнему поддерживаются для обратной совместимости Новые routers должны использовать исключительно ECIES-X25519 TunnelBuild (type 21) - Устарело в пользу VariableTunnelBuild и ShortTunnelBuild По-прежнему реализовано для очень длинных tunnels (\u0026gt;8 хопов) TunnelBuildReply (type 22) - Устарело в пользу VariableTunnelBuildReply и OutboundTunnelBuildReply Шифрование ElGamal/AES - Устарело в пользу ECIES-X25519-AEAD-Ratchet По-прежнему используется для устаревших назначений Длинные ECIES BuildRequestRecords (528 байт) - Устарело в пользу короткого формата (218 байт) По-прежнему используется для смешанных tunnels с ElGamal-хопами Сроки поддержки устаревших версий Feature Introduced Deprecated Removed Notes NTCP 2003 2018 (0.9.36) 2021 (0.9.50) Replaced by NTCP2 SSU v1 2004 2022 (0.9.54) 2023 (Java) / 2022 (i2pd) Replaced by SSU2 ElGamal routers 2003 2023 (0.9.58) TBD Destinations still supported RSA signatures 2015 2017 2017 (0.9.28) Never widely used TunnelBuild 2004 2009 (0.7.12) Not removed Still supported for long tunnels --- Приложение C: будущие разработки Постквантовая криптография Статус: Бета, начиная с релиза 2.10.0 (сентябрь 2025), станет по умолчанию в релизе 2.11.0 (декабрь 2025)\nРеализация: - Гибридный подход, сочетающий классический X25519 и постквантовый MLKEM (ML-KEM-768) - Обратная совместимость с существующей инфраструктурой ECIES-X25519 - Использует Signal Double Ratchet (двойной ратчет Signal) с классическим и постквантовым (PQ) ключевым материалом - Подробности см. в Proposal 169 Путь миграции: 1. Релиз 2.10.0 (сентябрь 2025): доступно как бета-опция 2. Релиз 2.11.0 (декабрь 2025): включено по умолчанию 3. Будущие релизы: в конечном итоге станет обязательным\nПланируемые возможности Улучшения IPv6 - Лучшая поддержка IPv6 и механизмы перехода Ограничение пропускной способности для каждого tunnel - Тонкое управление полосой пропускания для каждого tunnel Расширенные метрики - Улучшенный мониторинг производительности и диагностика Оптимизации протокола - Сниженные накладные расходы и повышенная эффективность Улучшенный выбор floodfill (узлы, распространяющие netDb) - Лучшее распределение netDb (сетевая база данных) Области исследований Оптимизация длины tunnel - Динамическая длина tunnel на основе модели угроз Усовершенствованное заполнение - Улучшения устойчивости к анализу трафика Новые схемы шифрования - Подготовка к угрозам квантовых вычислений Контроль перегрузок - Более эффективная обработка сетевой нагрузки Поддержка мобильных устройств - Оптимизации для мобильных устройств и сетей Приложение D: Рекомендации по реализации Для новых реализаций Минимальные требования: 1. Поддерживать возможности API версии 0.9.51+ 2. Реализовать шифрование ECIES-X25519-AEAD-Ratchet 3. Поддерживать транспорты NTCP2 и SSU2 4. Реализовать сообщения ShortTunnelBuild (218-байтовые записи) 5. Поддерживать варианты LeaseSet2 (типы 3, 5, 7) 6. Использовать подписи EdDSA (Ed25519)\nРекомендуется: 1. Поддерживать гибридную постквантовую криптографию (по состоянию на 2.11.0) 2. Реализовать параметры пропускной способности для каждого tunnel (туннель) 3. Поддерживать форматы Datagram2 и Datagram3 4. Реализовать опции сервисных записей в LeaseSets 5. Следовать официальным спецификациям на /docs/specs/\nНе требуется: 1. Поддержка ElGamal в router (устарело) 2. Поддержка устаревших транспортов (SSU1, NTCP) 3. Длинные ECIES BuildRequestRecords (528 байт для чистых ECIES tunnels) 4. сообщения TunnelBuild/TunnelBuildReply (используйте варианты Variable или Short)\nТестирование и валидация Соответствие протоколу: 1. Проверить совместимость с официальным Java I2P router 2. Проверить совместимость с i2pd C++ router 3. Проверить форматы сообщений на соответствие спецификациям 4. Протестировать циклы построения/разборки tunnel 5. Проверить шифрование/дешифрование с использованием тестовых векторов\nТестирование производительности: 1. Измерить долю успешного построения tunnel (должно быть \u0026gt;85%) 2. Протестировать с различными длинами tunnel (2-8 переходов) 3. Проверить фрагментацию и сборку 4. Тестировать под нагрузкой (несколько одновременных tunnel) 5. Измерить сквозную задержку\nТестирование безопасности: 1. Проверить реализацию шифрования (использовать тестовые векторы) 2. Проверить защиту от атак повторного воспроизведения 3. Проверить корректность обработки истечения срока действия сообщений 4. Проверить устойчивость к некорректно сформированным сообщениям 5. Проверить корректность генерации случайных чисел\nРаспространённые подводные камни при реализации Неоднозначные форматы инструкций доставки - Garlic clove (долька garlic‑сообщения) против tunnel‑сообщения Некорректная деривация ключей - использование HKDF для коротких записей построения Обработка Message ID - неправильная установка при построении tunnel Проблемы с фрагментацией - игнорирование практического лимита 61.2 KB Ошибки порядка байтов - Java использует big-endian (старший байт первым) для всех целых чисел Обработка истечения срока - короткий формат переполняется 7 февраля 2106 года Генерация контрольной суммы - требуется по-прежнему, даже если не проверяется ","description":"Форматы сообщений router-to-router, приоритеты и ограничения по размеру в I2P.","id":"917124900b0896942323b4effccf9b55","section":"docs","title":"Сетевой протокол I2P (I2NP)","url":"/ru/docs/specs/i2np/"},{"categories":null,"content":"Что такое Eepsite? eepsite — это веб‑сайт, который существует исключительно в сети I2P. В отличие от традиционных веб‑сайтов, доступных через clearnet (открытый интернет), eepsites доступны только через I2P, обеспечивая анонимность и конфиденциальность как оператору сайта, так и посетителям. Eepsites используют псевдодомен верхнего уровня .i2p и доступны по специальным адресам .b32.i2p или по человекочитаемым именам, зарегистрированным в адресной книге I2P.\nВсе установки Java I2P поставляются с Jetty — легковесным веб‑сервером на Java, предустановленным и преднастроенным. Это позволяет за считанные минуты начать размещать собственный eepsite — без необходимости установки дополнительного программного обеспечения.\nЭто руководство проведёт вас через процесс создания и настройки вашего первого eepsite с помощью встроенных инструментов I2P.\nШаг 1: Откройте менеджер скрытых сервисов Менеджер скрытых сервисов (также называемый I2P Tunnel Manager) — это место, где настраиваются все I2P серверные и клиентские tunnels, включая HTTP-серверы (eepsites).\nОткройте Консоль I2P Router Перейдите к Менеджеру скрытых сервисов Вы должны увидеть интерфейс Диспетчера скрытых сервисов, отображающий: - Сообщения о состоянии - Текущее состояние tunnel и клиента - Глобальное управление tunnel - Кнопки для управления всеми tunnels одновременно - Скрытые сервисы I2P - Список настроенных серверных tunnels\nПо умолчанию вы увидите существующую запись I2P веб‑сервера, настроенную, но не запущенную. Это предварительно настроенный веб‑сервер Jetty, готовый к использованию.\nШаг 2: Настройте параметры сервера Eepsite Нажмите на запись I2P webserver в списке скрытых сервисов, чтобы открыть страницу конфигурации сервера. Здесь вы сможете настроить параметры вашего eepsite.\nПояснение параметров конфигурации Имя - Это внутренний идентификатор для вашего tunnel - Полезно, если вы запускаете несколько eepsites, чтобы различать их между собой - По умолчанию: \u0026ldquo;I2P webserver\u0026rdquo;\nОписание - Краткое описание вашего eepsite для собственной справки - Видно только вам в Менеджере скрытых служб - Пример: \u0026ldquo;Мой eepsite\u0026rdquo; или \u0026ldquo;Личный блог\u0026rdquo;\nАвтоматический запуск Tunnel - Важно: Отметьте этот флажок, чтобы ваш eepsite автоматически запускался при запуске I2P router - Гарантирует, что ваш сайт останется доступным без ручного вмешательства после перезапуска router - Рекомендуется: Включено\nНазначение (Host и Port) - Host: Локальный адрес, на котором работает ваш веб‑сервер (по умолчанию: 127.0.0.1) - Port: Порт, на котором ваш веб‑сервер принимает подключения (по умолчанию: 7658 для Jetty) - Если вы используете предустановленный веб‑сервер Jetty, оставьте эти параметры со значениями по умолчанию - Изменяйте только если вы запускаете собственный веб‑сервер на другом порту\nИмя хоста сайта - Это человекочитаемое доменное имя вашего eepsite в зоне .i2p - По умолчанию: mysite.i2p (заглушка) - Вы можете зарегистрировать собственный домен, например stormycloud.i2p или myblog.i2p - Оставьте пустым, если хотите использовать только автоматически сгенерированный адрес .b32.i2p (для outproxies (выходные прокси)) - См. ниже Регистрация вашего домена I2P о том, как зарегистрировать собственное имя хоста\nЛокальный Destination - Это уникальный криптографический идентификатор вашего eepsite (адрес назначения) - Автоматически генерируется при первом создании tunnel - Считайте это постоянным \u0026ldquo;IP-адресом\u0026rdquo; вашего сайта в I2P - Длинная буквенно-цифровая строка — это адрес вашего сайта .b32.i2p в закодированном виде\nФайл закрытого ключа - Место, где хранятся закрытые ключи вашего eepsite - По умолчанию: eepsite/eepPriv.dat - Храните этот файл в безопасности - любой, у кого есть доступ к этому файлу, может выдавать себя за ваш eepsite - Никогда не делитесь этим файлом и не удаляйте его\nВажное примечание Желтое предупреждающее сообщение напоминает, что для включения генерации QR‑кода или функций аутентификации при регистрации необходимо настроить имя хоста веб‑сайта с суффиксом .i2p (например, mynewsite.i2p).\nШаг 3: Расширенные сетевые параметры (необязательно) Если на странице конфигурации прокрутить вниз, вы найдёте расширенные сетевые параметры. Эти параметры необязательны — значения по умолчанию хорошо подходят большинству пользователей. Однако вы можете настроить их в соответствии с вашими требованиями к безопасности и производительности.\nПараметры длины Tunnel Длина tunnel - По умолчанию: 3-хоповый tunnel (высокая анонимность) - Определяет, через сколько router-хопов проходит запрос, прежде чем достичь вашего eepsite - Больше хопов = выше анонимность, но ниже производительность - Меньше хопов = выше производительность, но ниже анонимность - Варианты в диапазоне от 0 до 3 хопов с настройками вариации - Рекомендация: оставьте 3 хопа, если только у вас нет особых требований к производительности\nРазброс длины tunnel - По умолчанию: 0 hop variance (без рандомизации, стабильная производительность) - Добавляет рандомизацию длины tunnel для повышения безопасности - Пример: \u0026ldquo;0-1 hop variance\u0026rdquo; означает, что tunnels будут случайной длины: 3 или 4 перехода - Повышает непредсказуемость, но может привести к нестабильному времени загрузки\nПараметры количества tunnel Количество (входящих/исходящих Tunnels) - По умолчанию: 2 входящих, 2 исходящих tunnels (стандартная пропускная способность и надёжность) - Определяет, сколько параллельных tunnels выделено для вашего eepsite - Больше tunnels = Лучшая доступность и обработка нагрузки, но выше потребление ресурсов - Меньше tunnels = Ниже потребление ресурсов, но сниженная избыточность - Рекомендуется для большинства пользователей: 2/2 (по умолчанию) - Сайты с высоким трафиком могут выиграть от 3/3 или больше\nЧисло резервных tunnels - По умолчанию: 0 резервных tunnels (без избыточности, без дополнительного расхода ресурсов) - Резервные tunnels, которые активируются при отказе основных tunnels - Повышает надёжность, но потребляет больше пропускной способности и CPU - Большинство персональных eepsites не нуждаются в резервных tunnels\nОграничения POST Если ваш eepsite содержит формы (контактные формы, разделы комментариев, загрузка файлов и т. п.), вы можете настроить ограничения на POST-запросы, чтобы предотвратить злоупотребления:\nЛимиты на клиента - За период: Максимум запросов от одного клиента (по умолчанию: 6 за 5 минут) - Длительность блокировки: Как долго блокировать клиентов-нарушителей (по умолчанию: 20 минут)\nОбщие лимиты - Всего: Максимальное число POST-запросов от всех клиентов суммарно (по умолчанию: 20 за 5 минут) - Длительность блокировки: Как долго отклонять все POST-запросы при превышении лимита (по умолчанию: 10 минут)\nПериод ограничения для POST - Временное окно для измерения частоты запросов (по умолчанию: 5 минут)\nЭти ограничения помогают защититься от спама, атак отказа в обслуживании и злоупотребления автоматизированной отправкой форм.\nКогда следует изменять расширенные настройки Сайт сообщества с высоким трафиком: Увеличьте количество tunnel (3-4 входящих/исходящих) Приложение, критичное к производительности: Уменьшите длину tunnel до 2 переходов (компромисс по приватности) Требуется максимальная анонимность: Оставьте 3 перехода, добавьте разброс 0-1 Формы с ожидаемо высокой нагрузкой: Соответственно увеличьте лимиты POST Личный блог/портфолио: Используйте все настройки по умолчанию Шаг 4: Добавление контента на ваш Eepsite Теперь, когда ваш eepsite настроен, вам нужно добавить файлы вашего сайта (HTML, CSS, изображения и т. д.) в корневой каталог веб-сервера. Его расположение зависит от вашей операционной системы, типа установки и реализации I2P.\nПоиск корневого каталога сайта document root (часто называется docroot) — это папка, в которую вы помещаете все файлы вашего веб‑сайта. Файл index.html должен находиться непосредственно в этой папке.\nJava I2P (стандартный дистрибутив) Linux - Стандартная установка: ~/.i2p/eepsite/docroot/ - Установка из пакета (запуск как служба): /var/lib/i2p/i2p-config/eepsite/docroot/\nWindows - Стандартная установка: %LOCALAPPDATA%\\I2P\\eepsite\\docroot\\ - Типичный путь: C:\\Users\\YourUsername\\AppData\\Local\\I2P\\eepsite\\docroot\\ - Установка как служба Windows: %PROGRAMDATA%\\I2P\\eepsite\\docroot\\ - Типичный путь: C:\\ProgramData\\I2P\\eepsite\\docroot\\\nmacOS - Стандартная установка: /Users/YourUsername/Library/Application Support/i2p/eepsite/docroot/\nI2P+ (улучшенный дистрибутив I2P) I2P+ использует ту же структуру каталогов, что и Java I2P. Следуйте указанным выше путям в зависимости от вашей операционной системы.\ni2pd (Реализация на C++) Linux/Unix - По умолчанию: /var/lib/i2pd/eepsite/ или ~/.i2pd/eepsite/ - Проверьте ваш конфигурационный файл i2pd.conf, чтобы узнать фактическое значение параметра root в настройках вашего HTTP‑сервера tunnel\nWindows - Проверьте файл i2pd.conf в каталоге установки i2pd\nmacOS - Обычно: ~/Library/Application Support/i2pd/eepsite/\nДобавление файлов вашего веб-сайта Перейдите в корневой каталог сайта с помощью файлового менеджера или терминала Создайте или скопируйте файлы вашего сайта в папку docroot Как минимум создайте файл index.html (это ваша главная страница) При необходимости добавьте CSS, JavaScript, изображения и другие ресурсы Организуйте подкаталоги так же, как для любого сайта: docroot/ ├── index.html ├── about.html ├── css/ │ └── style.css ├── images/ │ └── logo.png └── js/ └── script.js Быстрый старт: простой пример HTML Если вы только начинаете, создайте простой файл index.html в папке docroot:\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;My I2P Eepsite\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Welcome to My Eepsite!\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;This is my first website on the I2P network.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Privacy-focused and decentralized!\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Права доступа (Linux/Unix/macOS) Если вы запускаете I2P как службу или от имени другого пользователя, убедитесь, что процесс I2P имеет доступ на чтение к вашим файлам:\n# Set appropriate ownership (if running as i2p user) sudo chown -R i2p:i2p /var/lib/i2p/i2p-config/eepsite/docroot/ # Or set readable permissions for all users chmod -R 755 ~/.i2p/eepsite/docroot/ Советы Содержимое по умолчанию: После установки I2P в папке docroot уже есть демонстрационный контент - можете смело заменить его Статические сайты работают лучше: Хотя Jetty поддерживает сервлеты и JSP, простые сайты на HTML/CSS/JavaScript проще в сопровождении Внешние веб-серверы: Опытные пользователи могут запускать собственные веб-серверы (Apache, Nginx, Node.js и т. д.) на разных портах и направить на них I2P tunnel Шаг 5: Запуск вашего Eepsite Теперь, когда ваш eepsite настроен и наполнен содержимым, пора запустить его и сделать доступным в сети I2P.\nЗапустите Tunnel Вернитесь в Менеджер скрытых сервисов Найдите в списке запись I2P webserver Нажмите кнопку Start в столбце Control Ожидание установления Tunnel После нажатия кнопки Start начнётся построение вашего eepsite tunnel. Этот процесс обычно занимает 30-60 секунд. Следите за индикатором состояния:\nКрасный индикатор = Tunnel запускается/строится Жёлтый индикатор = Tunnel частично установлен Зелёный индикатор = Tunnel полностью работоспособен и готов Как только вы увидите зеленый индикатор, ваш eepsite доступен в сети I2P!\nДоступ к вашему Eepsite Нажмите кнопку Preview рядом с запущенным eepsite (сайт в сети I2P). Это откроет новую вкладку браузера с адресом вашего eepsite.\nУ вашего eepsite есть два типа адресов:\nАдрес Base32 (.b32.i2p): Длинный криптографический адрес, который выглядит так:\nhttp://fcyianvr325tdgiiueyg4rsq4r5iuibzovl26msox5ryoselykpq.b32.i2p Это постоянный, криптографически производный адрес вашего eepsite Его нельзя изменить; он привязан к вашему закрытому ключу Работает всегда, даже без регистрации домена Человеко-читаемый домен (.i2p): Если вы укажете Имя хоста сайта (например, testwebsite.i2p)\nРаботает только после регистрации домена (см. следующий раздел) Проще запомнить и поделиться Сопоставляется с вашим адресом .b32.i2p Кнопка Copy Hostname позволяет быстро скопировать ваш полный адрес .b32.i2p для обмена.\n⚠️ Критически важно: Создайте резервную копию вашего закрытого ключа Прежде чем продолжить, вы обязательно сделайте резервную копию файла закрытого ключа вашего eepsite. Это крайне важно по нескольким причинам:\nЗачем создавать резервную копию вашего ключа? Ваш закрытый ключ (eepPriv.dat) — это идентичность вашего eepsite. Он определяет ваш адрес .b32.i2p и подтверждает владение вашим eepsite.\nКлюч = .b32 address: Ваш закрытый ключ криптографически порождает ваш уникальный адрес .b32.i2p Восстановлению не подлежит: Если вы потеряете свой ключ, вы навсегда потеряете адрес eepsite Нельзя изменить: Если вы зарегистрировали домен, указывающий на .b32 address, обновить его невозможно - регистрация постоянная Требуется для миграции: Переход на новый компьютер или переустановка I2P требует этого ключа для сохранения того же адреса Поддержка multihoming (мультихоминг): Запуск вашего eepsite из нескольких мест требует одного и того же ключа на каждом сервере Где находится закрытый ключ? По умолчанию ваш закрытый ключ хранится по адресу: - Linux: ~/.i2p/eepsite/eepPriv.dat (или /var/lib/i2p/i2p-config/eepsite/eepPriv.dat для установок в виде службы) - Windows: %LOCALAPPDATA%\\I2P\\eepsite\\eepPriv.dat или %PROGRAMDATA%\\I2P\\eepsite\\eepPriv.dat - macOS: /Users/YourUsername/Library/Application Support/i2p/eepsite/eepPriv.dat\nВы также можете проверить/изменить этот путь в конфигурации вашего tunnel в разделе \u0026ldquo;Private Key File\u0026rdquo;.\nКак создать резервную копию Остановите свой tunnel (необязательно, но безопаснее) Скопируйте eepPriv.dat в защищённое место: Внешний USB-накопитель Зашифрованный диск для резервных копий Архив, защищённый паролем Безопасное облачное хранилище (с шифрованием) Храните несколько резервных копий в разных физических местах Никогда не делитесь этим файлом - любой, у кого он есть, сможет выдать себя за ваш eepsite Восстановление из резервной копии Чтобы восстановить ваш eepsite на новой системе или после переустановки:\nУстановите I2P и создайте/настройте параметры вашего tunnel Остановите tunnel перед копированием ключа Скопируйте ваш резервный eepPriv.dat в правильное расположение Запустите tunnel - он будет использовать ваш исходный адрес .b32 Если вы не регистрируете домен Поздравляем! Если вы не планируете регистрировать собственное доменное имя .i2p, ваш eepsite теперь полностью готов и работает.\nВы можете: - Поделиться своим адресом .b32.i2p с другими - Получать доступ к своему сайту через сеть I2P с помощью любого браузера с поддержкой I2P - В любое время обновлять файлы сайта в папке docroot - Отслеживать состояние вашего tunnel в Менеджере скрытых служб\nЕсли вам нужен человекочитаемый домен (например, mysite.i2p вместо длинного адреса .b32), перейдите к следующему разделу.\nРегистрация вашего I2P-домена Читаемый человеком домен .i2p (например, testwebsite.i2p) намного легче запомнить и им поделиться, чем длинным адресом .b32.i2p. Регистрация домена бесплатна и связывает выбранное вами имя с криптографическим адресом вашей eepsite.\nПредварительные требования Ваш eepsite должен работать с зелёным индикатором Вы должны указать Website Hostname в конфигурации tunnel (Шаг 2) Пример: testwebsite.i2p или myblog.i2p Шаг 1: Сгенерируйте строку аутентификации Вернитесь к конфигурации вашего tunnel в Менеджере скрытых сервисов Нажмите на запись вашего I2P веб‑сервера, чтобы открыть настройки Прокрутите вниз, чтобы найти кнопку Аутентификация регистрации Нажмите Аутентификация регистрации Скопируйте всю строку аутентификации, показанную для \u0026ldquo;Аутентификация для добавления хоста [yourdomainhere]\u0026rdquo; Строка аутентификации будет выглядеть следующим образом:\ntestwebsite.i2p=I8WiuSx1TcYAutCrhLveZ6gghdqsIJ1v9noSGPb7ItYjxaK5LHVNxgC60KuEu95nqCCF2qwgnW~2ehIY9vsi1iPForksdU3GALrQq4S73meoIIXarCCdb~Z6Ehj2-yLWI8WiuSx1TcYAutCrhLveZ6gghdqsIJ1v9noSGPb7ItYjxaK5LHVNxgC60KuEu95nqCCF2qwgnW~2ehIY9vsi1iPForksdU3GALrQq4S73meoIIXarCCdb~Z6Ehj2-yLWI8WiuSx1TcYAutCrhLveZ6gghdqsIJ1v9noSGPb7ItYjxaK5LHVNxgC60KuEu95nqCCF2qwgnW~2ehIY9vsi1iPForksdU3GALrQq4S73meoIIXarCCdb~Z6Ehj2-yLWI8WiuSx1TcYAutCrhLveZ6gghdqsIJ1v9noSGPb7ItYjxaK5LHVNxgC60KuEu95nqCCF2qwgnW~2ehIY9vsi1uNxFZ0HN7tQbbVj1pmbahepQZNxEW0ufwnMYAoFo8opBQAEAAcAAA==#!date=1762104890#sig=9DjEfrcNRxsoSxiE0Mp0-7rH~ktYWtgwU8c4J0eSo0VHbGxDxdiO9D1Cvwcx8hkherMO07UWOC9BWf-1wRyUAw== Эта строка содержит: - Ваше доменное имя (testwebsite.i2p) - Ваш адрес назначения (длинный криптографический идентификатор) - Метку времени - Криптографическую подпись, подтверждающую, что вы владеете закрытым ключом\nСохраните эту строку аутентификации - она понадобится вам для обоих сервисов регистрации.\nШаг 2: Зарегистрируйтесь на stats.i2p Перейдите к stats.i2p Add Key (внутри I2P) Вставьте строку аутентификации в поле \u0026ldquo;Authentication String\u0026rdquo; Добавьте своё имя (необязательно) - по умолчанию \u0026ldquo;Anonymous\u0026rdquo; Добавьте описание (рекомендуется) - кратко опишите, о чём ваш eepsite Например: \u0026ldquo;Новый I2P Eepsite\u0026rdquo;, \u0026ldquo;Персональный блог\u0026rdquo;, \u0026ldquo;Сервис обмена файлами\u0026rdquo; Отметьте \u0026ldquo;HTTP Service?\u0026rdquo; если это веб-сайт (оставьте отмеченным для большинства eepsites) Снимите отметку для IRC, NNTP, прокси, XMPP, git и т. д. Нажмите Submit Если всё прошло успешно, вы увидите подтверждение того, что ваш домен был добавлен в адресную книгу stats.i2p.\nШаг 3: Зарегистрируйтесь на reg.i2p Чтобы обеспечить максимальную доступность, вам также следует зарегистрироваться на сервисе reg.i2p:\nПерейдите на reg.i2p Add Domain (внутри сети I2P) Вставьте ту же строку аутентификации в поле \u0026ldquo;Auth string\u0026rdquo; Добавьте описание (необязательно, но рекомендуется) Это помогает другим пользователям I2P понять, что предлагает ваш сайт Нажмите Submit Вы должны получить подтверждение того, что ваш домен был зарегистрирован.\nШаг 4: Дождитесь распространения После отправки в оба сервиса регистрация вашего домена распространится через систему адресных книг сети I2P.\nСроки распространения: - Первичная регистрация: Немедленно на сервисах регистрации - Распространение по всей сети: От нескольких часов до 24+ часов - Полная доступность: Может занять до 48 часов, пока все routers обновятся\nЭто нормально! Система адресной книги I2P обновляется периодически, а не мгновенно. Ваш eepsite работает - другим пользователям просто нужно получить обновлённую адресную книгу.\nПодтвердите ваш домен Через несколько часов вы сможете протестировать свой домен:\nОткройте новую вкладку в браузере I2P Попробуйте перейти к вашему домену напрямую: http://yourdomainname.i2p Если страница загружается, ваш домен зарегистрирован и распространяется! Если это еще не работает: - Подождите дольше (адресные книги обновляются по своему расписанию) - Адресной книге вашего router может потребоваться время для синхронизации - Попробуйте перезапустить ваш I2P router, чтобы принудительно обновить адресную книгу\nВажные замечания Регистрация постоянна: После регистрации и распространения в сети ваш домен навсегда указывает на ваш адрес .b32.i2p Нельзя изменить назначение: Вы не можете изменить, на какой адрес .b32.i2p указывает ваш домен - поэтому резервное копирование eepPriv.dat критически важно Владение доменом: Только владелец закрытого ключа может зарегистрировать или обновить домен Бесплатный сервис: Регистрация доменов в I2P бесплатна, управляется сообществом и децентрализована Несколько регистраторов: Регистрация одновременно на stats.i2p и reg.i2p повышает надёжность и скорость распространения Поздравляем! Ваш I2P eepsite теперь полностью функционирует с зарегистрированным доменом!\nСледующие шаги: - Добавьте больше контента в папку docroot - Поделитесь своим доменом с сообществом I2P - Храните резервную копию eepPriv.dat в надежном месте - Регулярно отслеживайте состояние вашего tunnel (туннеля) - Рассмотрите возможность присоединиться к форумам I2P или IRC, чтобы продвигать свой сайт\nДобро пожаловать в сеть I2P! 🎉\n","description":"Узнайте, как создать и разместить свой собственный веб‑сайт в сети I2P с помощью встроенного веб‑сервера Jetty","id":"cdd089b486cced0cc2a37529ae0ace6b","section":"docs","title":"Создание Eepsite в I2P","url":"/ru/docs/guides/%D1%81%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5-eepsite-%D0%B2-i2p/"},{"categories":null,"content":"SSH-туннель обеспечивает безопасное зашифрованное соединение для доступа к консоли удаленного I2P router или другим сервисам. Это руководство показывает, как создавать SSH-туннели в системах Windows, Linux и Mac.\nЧто такое SSH-туннель? SSH-туннель — это метод безопасной маршрутизации данных и информации через зашифрованное SSH-соединение. Представьте его как создание защищённого «трубопровода» через интернет — ваши данные передаются через этот зашифрованный туннель, не позволяя никому перехватить или прочитать их по пути.\nSSH-туннелирование особенно полезно для:\nДоступ к удалённым I2P router\u0026rsquo;ам: Подключайтесь к консоли I2P, запущенной на удалённом сервере Безопасные соединения: Весь трафик шифруется от конца до конца Обход ограничений: Получайте доступ к сервисам на удалённых системах, как если бы они были локальными Проброс портов: Сопоставьте локальный порт с удалённым сервисом В контексте I2P вы можете использовать SSH-туннель для доступа к консоли вашего I2P router (обычно на порту 7657) на удалённом сервере, перенаправив его на локальный порт на вашем компьютере.\nПредварительные требования Перед созданием SSH-туннеля вам потребуется:\nSSH-клиент: Windows: PuTTY (бесплатная загрузка) Linux/Mac: Встроенный SSH-клиент (через Terminal) Доступ к удалённому серверу: Имя пользователя для удалённого сервера IP-адрес или имя хоста удалённого сервера SSH-пароль или аутентификация на основе ключей Доступный локальный порт: Выберите неиспользуемый порт в диапазоне 1-65535 (для I2P обычно используется 7657) Понимание команды Tunnel Команда SSH-туннеля следует этой схеме:\nssh -L [local_port]:[destination_ip]:[destination_port] [username]@[remote_server] Объяснение параметров: - local_port: Порт на вашей локальной машине (например, 7657) - destination_ip: Обычно 127.0.0.1 (localhost на удалённом сервере) - destination_port: Порт службы на удалённом сервере (например, 7657 для I2P) - username: Ваше имя пользователя на удалённом сервере - remote_server: IP-адрес или имя хоста удалённого сервера\nПример: ssh -L 7657:127.0.0.1:7657 i2p@20.228.143.58\nЭто создаёт туннель, где: - Локальный порт 7657 на вашей машине перенаправляется на\u0026hellip; - Порт 7657 на localhost удалённого сервера (где запущен I2P) - Подключение выполняется от имени пользователя i2p к серверу 20.228.143.58\nСоздание SSH-туннелей в Windows Пользователи Windows могут создавать SSH-туннели с помощью PuTTY, бесплатного SSH-клиента.\nStep 1: Download and Install PuTTY Загрузите PuTTY с putty.org и установите его на вашу систему Windows.\nStep 2: Configure the SSH Connection Откройте PuTTY и настройте ваше соединение:\nВ категории Session: Введите IP-адрес или имя хоста вашего удалённого сервера в поле Host Name Убедитесь, что в поле Port установлено значение 22 (стандартный порт SSH) Тип соединения должен быть SSH Step 3: Configure the Tunnel Перейдите в Connection → SSH → Tunnels в боковой панели слева:\nИсходящий порт: Введите локальный порт, который хотите использовать (например, 7657) Назначение: Введите 127.0.0.1:7657 (localhost:порт на удалённом сервере) Нажмите Добавить, чтобы добавить tunnel Tunnel должен появиться в списке «Переадресованные порты» Step 4: Connect Нажмите Open, чтобы инициировать соединение Если вы подключаетесь впервые, появится предупреждение безопасности — нажмите Yes, чтобы доверять серверу Введите ваше имя пользователя, когда будет предложено Введите ваш пароль, когда будет предложено После подключения вы можете получить доступ к удалённой консоли I2P, открыв браузер и перейдя по адресу http://127.0.0.1:7657\nШаг 1: Скачайте и установите PuTTY Чтобы избежать повторной настройки каждый раз:\nВернитесь в категорию Session Введите имя в поле Saved Sessions (например, \u0026ldquo;I2P Tunnel\u0026rdquo;) Нажмите Save В следующий раз просто загрузите эту сессию и нажмите Open Creating SSH Tunnels on Linux В системах Linux SSH встроен в терминал, что делает создание туннелей быстрым и простым.\nШаг 2: Настройка SSH-соединения Откройте терминал и выполните команду SSH-туннеля:\nssh -L 7657:127.0.0.1:7657 i2p@20.228.143.58 Замените: - 7657 (первое вхождение): Желаемый локальный порт - 127.0.0.1:7657: Адрес назначения и порт на удалённом сервере - i2p: Ваше имя пользователя на удалённом сервере - 20.228.143.58: IP-адрес вашего удалённого сервера\nПри появлении запроса введите пароль. После подключения туннель становится активным.\nПолучите доступ к удаленной консоли I2P по адресу http://127.0.0.1:7657 в вашем браузере.\nШаг 3: Настройка туннеля Туннель остается активным до тех пор, пока запущена SSH-сессия. Чтобы поддерживать его работу в фоновом режиме:\nssh -f -N -L 7657:127.0.0.1:7657 i2p@20.228.143.58 Дополнительные флаги: - -f: Запускает SSH в фоновом режиме - -N: Не выполнять удалённые команды (только туннель)\nЧтобы закрыть фоновый туннель, найдите и завершите процесс SSH:\nps aux | grep ssh kill [process_id] Шаг 4: Подключение Для лучшей безопасности и удобства используйте аутентификацию по SSH-ключу:\nСгенерируйте пару SSH-ключей (если у вас её ещё нет):\nssh-keygen -t ed25519 -C \u0026#34;your_email@example.com\u0026#34; Скопируйте ваш публичный ключ на удалённый сервер:\nssh-copy-id i2p@20.228.143.58 Теперь вы можете подключиться без пароля:\nssh -L 7657:127.0.0.1:7657 i2p@20.228.143.58 Creating SSH Tunnels on Mac Системы Mac используют тот же SSH-клиент, что и Linux, поэтому процесс идентичен.\nНеобязательно: Сохраните свою сессию Откройте Терминал (Программы → Утилиты → Терминал) и выполните:\nssh -L 7657:127.0.0.1:7657 i2p@20.228.143.58 Замените: - 7657 (первое вхождение): Желаемый локальный порт - 127.0.0.1:7657: Адрес назначения и порт на удалённом сервере - i2p: Ваше имя пользователя на удалённом сервере - 20.228.143.58: IP-адрес вашего удалённого сервера\nВведите пароль при запросе. После подключения откройте удалённую консоль I2P по адресу http://127.0.0.1:7657\nBackground Tunnels on Mac Как и в Linux, вы можете запустить туннель в фоновом режиме:\nssh -f -N -L 7657:127.0.0.1:7657 i2p@20.228.143.58 Использование терминала Настройка SSH ключей на Mac идентична Linux:\n# Generate key (if needed) ssh-keygen -t ed25519 -C \u0026#34;your_email@example.com\u0026#34; # Copy to remote server ssh-copy-id i2p@20.228.143.58 Common Use Cases Поддержание активности туннеля Наиболее распространенный случай использования - доступ к консоли вашего удалённого I2P router:\nssh -L 7657:127.0.0.1:7657 user@remote-server Затем откройте http://127.0.0.1:7657 в вашем браузере.\nИспользование SSH-ключей (Рекомендуется) Перенаправление нескольких портов одновременно:\nssh -L 7657:127.0.0.1:7657 -L 7658:127.0.0.1:7658 user@remote-server Это перенаправляет как порт 7657 (консоль I2P), так и 7658 (другой сервис).\nCustom Local Port Используйте другой локальный порт, если 7657 уже занят:\nssh -L 8080:127.0.0.1:7657 user@remote-server Вместо этого откройте консоль I2P по адресу http://127.0.0.1:8080.\nTroubleshooting Использование терминала Ошибка: \u0026ldquo;bind: Address already in use\u0026rdquo;\nРешение: Выберите другой локальный порт или завершите процесс, использующий этот порт:\n# Linux/Mac - find process on port 7657 lsof -i :7657 # Kill the process kill [process_id] Фоновые туннели на Mac Ошибка: \u0026ldquo;Connection refused\u0026rdquo; или \u0026ldquo;channel 2: open failed\u0026rdquo;\nВозможные причины: - Удалённый сервис не запущен (проверьте, что I2P router работает на удалённом сервере) - Файрвол блокирует соединение - Неверный порт назначения\nРешение: Убедитесь, что I2P router запущен на удаленном сервере:\nssh user@remote-server \u0026#34;systemctl status i2p\u0026#34; Настройка SSH-ключей на Mac Ошибка: \u0026ldquo;Permission denied\u0026rdquo; или \u0026ldquo;Authentication failed\u0026rdquo;\nВозможные причины: - Неверное имя пользователя или пароль - SSH-ключ настроен неправильно - SSH-доступ отключен на удаленном сервере\nРешение: Проверьте учетные данные и убедитесь, что SSH-доступ включен на удаленном сервере.\nTunnel Drops Connection Ошибка: Соединение разрывается после периода неактивности\nРешение: Добавьте настройки keep-alive в ваш SSH конфиг (~/.ssh/config):\nHost remote-server ServerAliveInterval 60 ServerAliveCountMax 3 Security Best Practices Используйте SSH-ключи: Более безопасны, чем пароли, сложнее скомпрометировать Отключите аутентификацию по паролю: После настройки SSH-ключей отключите вход по паролю на сервере Используйте надёжные пароли: Если используете аутентификацию по паролю, применяйте сложный уникальный пароль Ограничьте доступ по SSH: Настройте правила файрвола для ограничения SSH-доступа только с доверенных IP-адресов Обновляйте SSH: Регулярно обновляйте клиентское и серверное ПО SSH Мониторьте логи: Проверяйте SSH-логи на сервере на предмет подозрительной активности Используйте нестандартные порты SSH: Измените стандартный SSH-порт (22) для снижения риска автоматизированных атак Создание SSH-туннелей в Linux Доступ к консоли I2P Создайте скрипт для автоматического установления туннелей:\n#!/bin/bash # i2p-tunnel.sh ssh -f -N -L 7657:127.0.0.1:7657 i2p@20.228.143.58 echo \u0026#34;I2P tunnel established\u0026#34; Сделайте его исполняемым:\nchmod +x i2p-tunnel.sh ./i2p-tunnel.sh Несколько туннелей Создайте службу systemd для автоматического создания туннелей:\nsudo nano /etc/systemd/system/i2p-tunnel.service Добавить:\n[Unit] Description=I2P SSH Tunnel After=network.target [Service] ExecStart=/usr/bin/ssh -NT -o ServerAliveInterval=60 -o ExitOnForwardFailure=yes -L 7657:127.0.0.1:7657 i2p@20.228.143.58 Restart=always RestartSec=10 User=your-username [Install] WantedBy=multi-user.target Включить и запустить:\nsudo systemctl enable i2p-tunnel sudo systemctl start i2p-tunnel Advanced Tunneling Пользовательский локальный порт Создайте SOCKS прокси для динамической переадресации:\nssh -D 8080 user@remote-server Настройте ваш браузер на использование 127.0.0.1:8080 в качестве SOCKS5 прокси.\nReverse Tunneling Разрешить удалённому серверу доступ к сервисам на вашей локальной машине:\nssh -R 7657:127.0.0.1:7657 user@remote-server Порт уже используется Туннелирование через промежуточный сервер:\nssh -J jumphost.example.com -L 7657:127.0.0.1:7657 user@final-server Conclusion SSH-туннелирование — это мощный инструмент для безопасного доступа к удалённым I2P router и другим сервисам. Независимо от того, используете ли вы Windows, Linux или Mac, процесс прост и обеспечивает надёжное шифрование ваших соединений.\nДля дополнительной помощи или вопросов посетите сообщество I2P: - Форум: i2pforum.net - IRC: #i2p в различных сетях - Документация: I2P Docs Туннели I2P Туннели являются основным строительным блоком сети I2P. Они представляют собой однонаправленные пути, через которые проходит трафик. Каждый tunnel состоит из последовательности роутеров, и трафик, проходящий через tunnel, шифруется на каждом hop (прыжке).\nТипы туннелей Существует два основных типа туннелей:\nВходящие туннели (Inbound tunnels): используются для получения данных от других роутеров в сети Исходящие туннели (Outbound tunnels): используются для отправки данных другим роутерам в сети Для обеспечения анонимности и коммуникации требуются как входящие, так и исходящие туннели.\nСтруктура туннелей Каждый tunnel состоит из:\nШлюз (Gateway): точка входа в tunnel Участники (Participants): промежуточные роутеры в tunnel Конечная точка (Endpoint): точка выхода из tunnel Длина tunnel (количество hop\u0026rsquo;ов) может варьироваться, но обычно составляет от 2 до 3 роутеров для баланса между производительностью и анонимностью.\nСоздание туннелей Когда роутер создает tunnel:\nВыбирает случайные роутеры из netDb Создает набор ключей шифрования для каждого hop Отправляет запросы на построение tunnel всем выбранным роутерам Ожидает подтверждения от всех участников После успешного создания tunnel публикуется в leaseSet роутера.\nПулы туннелей Роутеры поддерживают несколько активных туннелей одновременно:\nПул входящих туннелей: несколько параллельных inbound tunnels Пул исходящих туннелей: несколько параллельных outbound tunnels Это обеспечивает резервирование и балансировку нагрузки.\nВремя жизни туннелей Туннели имеют ограниченное время жизни (обычно 10 минут) по соображениям безопасности. Роутеры автоматически создают новые туннели до истечения срока действия старых, чтобы обеспечить непрерывную работу.\nРуководство изначально создано Stormy Cloud , адаптировано для документации I2P.\n","description":"Узнайте, как создавать защищенные SSH-туннели в Windows, Linux и Mac для доступа к вашему удаленному I2P router","id":"7d461aaa86788adfcb07bfb98f6e4965","section":"docs","title":"Создание SSH-туннеля для удаленного доступа к I2P","url":"/ru/docs/guides/%D1%81%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5-ssh-%D1%82%D1%83%D0%BD%D0%BD%D0%B5%D0%BB%D1%8F-%D0%B4%D0%BB%D1%8F-%D1%83%D0%B4%D0%B0%D0%BB%D0%B5%D0%BD%D0%BD%D0%BE%D0%B3%D0%BE-%D0%B4%D0%BE%D1%81%D1%82%D1%83%D0%BF%D0%B0-%D0%BA-i2p/"},{"categories":null,"content":"Reseed-хосты являются критически важной инфраструктурой для сети I2P, предоставляя новым router\u0026rsquo;ам начальную группу узлов в процессе bootstrap\u0026rsquo;а. Это руководство проведет вас через настройку и запуск собственного reseed-сервера.\nЧто такое I2P Reseed Server? Reseed-сервер I2P помогает интегрировать новые роутеры в сеть I2P следующим образом:\nОбеспечение первоначального обнаружения узлов: Новые роутеры получают начальный набор сетевых узлов для подключения Восстановление bootstrap: Помощь роутерам, испытывающим трудности с поддержанием соединений Безопасное распространение: Процесс reseeding шифруется и цифровым образом подписывается для обеспечения безопасности сети Когда новый I2P router запускается впервые (или потерял все свои пиринговые соединения), он обращается к reseed-серверам для загрузки начального набора информации о роутерах. Это позволяет новому router начать построение собственной netDb (базы данных сети) и установление tunnel.\nПредварительные требования Перед началом работы вам понадобится:\nLinux-сервер (рекомендуется Debian/Ubuntu) с правами root Доменное имя, указывающее на ваш сервер Минимум 1 ГБ оперативной памяти и 10 ГБ дискового пространства Работающий I2P router на сервере для заполнения network database Базовые знания системного администрирования Linux Подготовка сервера Step 1: Update System and Install Dependencies Сначала обновите вашу систему и установите необходимые пакеты:\nsudo apt update \u0026amp;\u0026amp; sudo apt upgrade -y \u0026amp;\u0026amp; sudo apt-get install golang-go git make docker.io docker-compose -y Это устанавливает: - golang-go: среда выполнения языка программирования Go - git: система контроля версий - make: инструмент автоматизации сборки - docker.io \u0026amp; docker-compose: контейнерная платформа для запуска Nginx Proxy Manager\nStep 2: Clone and Build Reseed Tools Клонируйте репозиторий reseed-tools и соберите приложение:\ncd /home/i2p git clone https://i2pgit.org/idk/reseed-tools cd reseed-tools make build sudo make install Пакет reseed-tools предоставляет основной функционал для запуска reseed-сервера. Он обрабатывает: - Сбор информации о router из вашей локальной базы данных сети - Упаковку информации router в подписанные SU3-файлы - Предоставление этих файлов через HTTPS\nStep 3: Generate SSL Certificate Сгенерируйте SSL-сертификат и приватный ключ вашего reseed-сервера:\nsu - i2p -c \u0026#39;reseed-tools reseed --signer=admin@stormycloud.org --netdb=/home/i2p/.i2p/netDb --port=8443 --ip=127.0.0.1 --trustProxy\u0026#39; Важные параметры: - --signer: Ваш адрес электронной почты (замените admin@stormycloud.org на свой собственный) - --netdb: Путь к сетевой базе данных вашего I2P router - --port: Внутренний порт (рекомендуется 8443) - --ip: Привязка к localhost (мы будем использовать reverse proxy для публичного доступа) - --trustProxy: Доверять заголовкам X-Forwarded-For от reverse proxy\nКоманда сгенерирует: - Приватный ключ для подписи SU3-файлов - SSL-сертификат для безопасных HTTPS-соединений\nШаг 1: Обновление системы и установка зависимостей Критически важно: Создайте безопасную резервную копию сгенерированных ключей, расположенных в /home/i2p/.reseed/:\nsudo tar -czf reseed-keys-backup.tar.gz /home/i2p/.reseed/ Храните эту резервную копию в безопасном зашифрованном месте с ограниченным доступом. Эти ключи необходимы для работы вашего reseed-сервера и должны быть тщательно защищены.\nConfiguring the Service Шаг 2: Клонирование и сборка инструментов Reseed Создайте systemd service для автоматического запуска reseed-сервера:\nsudo tee /etc/systemd/system/reseed.service \u0026lt;\u0026lt;EOF [Unit] Description=Reseed Service After=network.target [Service] User=i2p WorkingDirectory=/home/i2p ExecStart=/bin/bash -c \u0026#39;reseed-tools reseed --signer=admin@stormycloud.org --netdb=/home/i2p/.i2p/netDb --port=8443 --ip=127.0.0.1 --trustProxy\u0026#39; Restart=always RestartSec=10 [Install] WantedBy=multi-user.target EOF Не забудьте заменить admin@stormycloud.org на ваш собственный адрес электронной почты.\nТеперь включите и запустите службу:\nsudo systemctl daemon-reload sudo systemctl enable reseed sudo systemctl start reseed Проверьте, что сервис запущен:\nsudo systemctl status reseed Шаг 3: Генерация SSL-сертификата Для оптимальной производительности вы можете периодически перезапускать службу reseed для обновления информации о роутерах:\nsudo crontab -e Добавьте эту строку для перезапуска сервиса каждые 3 часа:\n0 */3 * * * systemctl restart reseed Setting Up Reverse Proxy Reseed-сервер работает на localhost:8443 и требует обратный прокси-сервер для обработки публичного HTTPS-трафика. Мы рекомендуем Nginx Proxy Manager за простоту использования.\nШаг 4: Резервное копирование ключей Развертывание Nginx Proxy Manager с использованием Docker:\ndocker run -d \\ --name nginx-proxy-manager \\ -p 80:80 \\ -p 81:81 \\ -p 443:443 \\ -v $(pwd)/data:/data \\ -v $(pwd)/letsencrypt:/etc/letsencrypt \\ --restart unless-stopped \\ jc21/nginx-proxy-manager:latest Это открывает: - Порт 80: HTTP-трафик - Порт 81: Интерфейс администратора - Порт 443: HTTPS-трафик\nConfigure Proxy Manager Откройте интерфейс администратора по адресу http://your-server-ip:81\nВойдите, используя учетные данные по умолчанию:\nEmail: admin@example.com Пароль: changeme Важно: Измените эти учетные данные сразу после первого входа в систему!\nПерейдите в раздел Proxy Hosts и нажмите Add Proxy Host Настройте proxy host: Domain Name: Ваш домен reseed-сервера (например, reseed.example.com) Scheme: https Forward Hostname / IP: 127.0.0.1 Forward Port: 8443 Включите Cache Assets Включите Block Common Exploits Включите Websockets Support На вкладке SSL: Выберите Request a new SSL Certificate (Let\u0026rsquo;s Encrypt) Включите Force SSL Включите HTTP/2 Support Примите условия использования Let\u0026rsquo;s Encrypt Нажмите Сохранить Ваш reseed сервер теперь должен быть доступен по адресу https://reseed.example.com\nRegistering Your Reseed Server После того как ваш reseed-сервер заработает, свяжитесь с разработчиками I2P, чтобы добавить его в официальный список reseed-серверов.\nШаг 5: Создание службы Systemd Напишите на email zzz (ведущему разработчику I2P) следующую информацию:\nЭлектронная почта I2P: zzz@mail.i2p Электронная почта в обычной сети: zzz@i2pmail.org Шаг 6: Опционально - Настройка периодических перезапусков Укажите в своем письме:\nURL сервера reseed: Полный HTTPS URL (например, https://reseed.example.com) Публичный reseed сертификат: Расположен в /home/i2p/.reseed/ (приложите файл .crt) Контактный email: Предпочтительный способ связи для уведомлений об обслуживании сервера Местоположение сервера: Опционально, но полезно (страна/регион) Ожидаемое время работы: Ваше обязательство по поддержанию работы сервера Verification Разработчики I2P проверят, что ваш reseed-сервер: - Правильно настроен и раздаёт информацию о роутерах - Использует действительные SSL-сертификаты - Предоставляет корректно подписанные SU3-файлы - Доступен и отвечает на запросы\nПосле одобрения ваш reseed-сервер будет добавлен в список, распространяемый вместе с I2P-роутерами, помогая новым пользователям присоединиться к сети!\nMonitoring and Maintenance Установка Nginx Proxy Manager Мониторинг вашего reseed-сервиса:\nsudo systemctl status reseed sudo journalctl -u reseed -f Настройка Proxy Manager Следите за системными ресурсами:\nhtop df -h Update Reseed Tools Периодически обновляйте reseed-tools, чтобы получать последние улучшения:\ncd /home/i2p/reseed-tools git pull make build sudo make install sudo systemctl restart reseed Контактная информация Если используется Let\u0026rsquo;s Encrypt через Nginx Proxy Manager, сертификаты будут обновляться автоматически. Проверьте, что обновление работает:\ndocker logs nginx-proxy-manager | grep -i certificate Настройка сервиса Необходимая информация Проверьте логи на наличие ошибок:\nsudo journalctl -u reseed -n 50 Распространённые проблемы: - I2P router не запущен или база данных сети пуста - Порт 8443 уже используется - Проблемы с правами доступа к директории /home/i2p/.reseed/\nПроверка Убедитесь, что ваш I2P router запущен и заполнил свою netDb:\nls -lh /home/i2p/.i2p/netDb/ Вы должны увидеть множество файлов .dat. Если папка пуста, подождите, пока ваш I2P router обнаружит peers.\nSSL Certificate Errors Проверьте, что ваши сертификаты действительны:\nopenssl s_client -connect reseed.example.com:443 -servername reseed.example.com Проверка состояния сервиса Проверьте: - DNS-записи правильно указывают на ваш сервер - Файрвол разрешает порты 80 и 443 - Nginx Proxy Manager запущен: docker ps\nSecurity Considerations Храните приватные ключи в безопасности: Никогда не передавайте и не раскрывайте содержимое /home/i2p/.reseed/ Регулярные обновления: Поддерживайте системные пакеты, Docker и reseed-tools в актуальном состоянии Мониторинг логов: Следите за подозрительными паттернами доступа Ограничение частоты запросов: Рассмотрите возможность внедрения rate limiting для предотвращения злоупотреблений Правила файрвола: Открывайте только необходимые порты (80, 443, 81 для администрирования) Интерфейс администратора: Ограничьте доступ к административному интерфейсу Nginx Proxy Manager (порт 81) только доверенными IP-адресами Contributing to the Network Запуская reseed-сервер, вы предоставляете критически важную инфраструктуру для сети I2P. Спасибо за ваш вклад в более приватный и децентрализованный интернет!\nДля вопросов или помощи обращайтесь в сообщество I2P: - Форум: i2pforum.net - IRC/Reddit: #i2p в различных сетях - Разработка: i2pgit.org Часто задаваемые вопросы по I2P Общие вопросы Что такое I2P? I2P - это анонимная оверлейная сеть, которая позволяет приложениям безопасно и анонимно отправлять друг другу сообщения. I2P обеспечивает конфиденциальность, анонимность и защиту от цензуры.\nЧем I2P отличается от других анонимных сетей? I2P разработан для предоставления анонимных сервисов внутри сети (веб-сайты, чаты, файлообмен), в то время как другие сети могут больше ориентироваться на анонимный выход в открытый интернет. I2P использует технологию garlic encryption для защиты сообщений.\nБезопасен ли I2P? I2P предоставляет сильную анонимность при правильном использовании. Однако никакая система не является полностью безопасной. Важно следовать рекомендациям по безопасности и понимать ограничения системы.\nТехнические вопросы Как работает маршрутизация в I2P? I2P использует технологию garlic routing - вариант onion routing. Сообщения инкапсулируются в несколько слоёв шифрования и проходят через серию router\u0026rsquo;ов перед достижением получателя.\nЧто такое tunnel в I2P? Tunnel - это временный однонаправленный путь через несколько router\u0026rsquo;ов. Каждый клиент создаёт входящие и исходящие tunnel\u0026rsquo;ы для получения и отправки данных.\nЧто такое netDb? netDb (Network Database) - это распределённая база данных, содержащая информацию о router\u0026rsquo;ах и destination\u0026rsquo;ах в сети. Floodfill router\u0026rsquo;ы хранят и распространяют эти данные.\nКакие транспортные протоколы использует I2P? I2P поддерживает несколько транспортных протоколов: NTCP2 (TCP-подобный) и SSU (UDP-подобный). Они используются для связи между router\u0026rsquo;ами.\nИспользование Как получить доступ к eepsite? Eepsite - это веб-сайт, размещённый внутри I2P. Для доступа нужно настроить браузер для использования HTTP-прокси I2P (обычно localhost:4444).\nЧто такое addressbook в I2P? Addressbook - это локальная служба, которая преобразует человекочитаемые имена (например, example.i2p) в cryptographic destination\u0026rsquo;ы I2P.\nКак запустить свой сервис в I2P? Используйте I2PTunnel или SAMv3 API для создания server tunnel\u0026rsquo;а. I2PTunnel предоставляет простой интерфейс для настройки различных типов сервисов.\nПроизводительность Почему I2P работает медленно? I2P жертвует скоростью ради анонимности. Сообщения проходят через несколько router\u0026rsquo;ов, что добавляет задержку. Производительность также зависит от количества участников сети и качества их соединений.\nМожно ли ускорить I2P? Вы можете: увеличить пропускную способность в настройках, открыть порты в firewall, дать router\u0026rsquo;у время для интеграции в сеть (обычно 10-15 минут), участвовать в маршрутизации трафика других пользователей.\nУстранение неполадок Router не подключается к сети Проверьте:\nНастройки firewall и NAT Доступность портов Правильность системного времени (критично для I2P) Логи router\u0026rsquo;а на наличие ошибок Не могу получить доступ к eepsite Возможные причины:\nEepsite временно недоступен Ваш router ещё не полностью интегрирован в сеть Проблемы с настройками прокси в браузере Destination eepsite\u0026rsquo;а не найден в netDb Низкое количество активных peers Это нормально для нового router\u0026rsquo;а. Подождите 15-30 минут. Если проблема сохраняется, проверьте настройки firewall и убедитесь, что ваш router может принимать входящие соединения.\nРуководство изначально создано Stormy Cloud , адаптировано для документации I2P.\n","description":"Полное руководство по настройке и эксплуатации reseed-сервера I2P для помощи новым роутерам в присоединении к сети","id":"d360e14f0f61d776e3c0b0f5b1262be5","section":"docs","title":"Создание и запуск сервер-ресида I2P","url":"/ru/docs/guides/%D1%81%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5-%D0%B8-%D0%B7%D0%B0%D0%BF%D1%83%D1%81%D0%BA-%D1%81%D0%B5%D1%80%D0%B2%D0%B5%D1%80-%D1%80%D0%B5%D1%81%D0%B8%D0%B4%D0%B0-i2p/"},{"categories":null,"content":"Обзор Этот документ определяет формат файла I2P blockfile и таблицы в hostsdb.blockfile, используемые в Blockfile Naming Service (службе именования Blockfile). Для справки см. Именование в I2P и адресная книга .\nblockfile (файл блоков) позволяет выполнять быстрый поиск назначений в компактном двоичном формате. По сравнению с устаревшей системой hosts.txt:\nDestinations (адреса назначения в I2P) хранятся в двоичном виде, а не в Base64. Можно прикреплять произвольные метаданные (например, дату добавления, источник, комментарии). Время поиска примерно в 10× раз быстрее. Использование дискового пространства умеренно увеличивается. Blockfile (файл блоков) — это хранящаяся на диске коллекция отсортированных отображений (пары ключ‑значение), реализованных в виде скип-листов. Он был создан на основе Metanotion Blockfile Database . Эта спецификация сначала определяет структуру файла, затем описывает, как этот формат используется BlockfileNamingService.\nBlockfile Naming Service (служба имён на основе блочных файлов) заменила старую реализацию hosts.txt в I2P 0.8.8. \u0026gt; При инициализации она импортирует записи из privatehosts.txt, userhosts.txt и hosts.txt.\nФормат Blockfile Формат состоит из 1024-байтовых страниц, каждая из которых имеет префикс в виде магического числа для обеспечения целостности. Страницы нумеруются начиная с 1:\nPage Description 1 Superblock (starts at byte 0) 2 Metaindex skiplist (starts at byte 1024) Все целые числа используют **сетевой порядок байтов (big-endian — старший байт первым)**. 2-байтовые значения беззнаковые; 4-байтовые значения (номера страниц) знаковые и должны быть положительными. Потоковая модель: База данных спроектирована для однопоточного доступа; BlockfileNamingService обеспечивает синхронизацию.\nФормат суперблока Byte Contents 0-5 Magic number 0x3141de493250 (\"1A\" 0xde \"I2P\") 6 Major version 0x01 7 Minor version 0x02 8-15 File length (in bytes) 16-19 First free list page 20-21 Mounted flag (0x01 = yes) 22-23 Span size (max key/value pairs per span, 16 for hostsdb) 24-27 Page size (as of v1.2; 1024 before that) 28-1023 Unused --- Формат страницы блока Skip List (структура данных «список с пропусками») Byte Contents 0-7 Magic 0x536b69704c697374 (\"SkipList\") 8-11 First span page 12-15 First level page 16-19 Size (total keys, valid at startup) 20-23 Spans (total spans, valid at startup) 24-27 Levels (total levels, valid at startup) 28-29 Span size (as of v1.2; used for new spans) 30-1023 Unused --- Формат страницы блокировки при пропуске уровня У каждого уровня есть диапазон, но не у каждого диапазона есть уровни.\nByte Contents 0-7 Magic 0x42534c6576656c73 (\"BSLevels\") 8-9 Max height 10-11 Current height 12-15 Span page 16-… Next level pages (current height × 4 bytes, lowest first) \u0026mdash; Remaining bytes unused --- Пропустить Span (строчный элемент) Block (блочный элемент) Формат страницы Пары ключ/значение отсортированы по ключу по всем интервалам. Интервалы, кроме первого, не должны быть пустыми.\nByte Contents 0-3 Magic 0x5370616e (\"Span\") 4-7 First continuation page or 0 8-11 Previous span page or 0 12-15 Next span page or 0 16-17 Max keys (16 for hostsdb) 18-19 Size (current keys) 20-1023 Key/value structures --- Формат страницы блока продолжения диапазона Byte Contents 0-3 Magic 0x434f4e54 (\"CONT\") 4-7 Next continuation page or 0 8-1023 Key/value structures --- Формат структуры ключ/значение Для ключа и значения поля длины не могут пересекать границы страниц (все 4 байта должны уместиться). Если остается недостаточно места, добавьте до 3 байт заполнения и продолжайте со смещения 8 на следующей странице.\nByte Contents 0-1 Key length (bytes) 2-3 Value length (bytes) 4-… Key data → Value data \u0026mdash; Max length = 65535 bytes each --- Формат страницы блока свободного списка Byte Contents 0-7 Magic 0x2366724c69737423 (\"#frList#\") 8-11 Next free list block or 0 12-15 Number of valid free pages (0 – 252) 16-1023 Free page numbers (4 bytes each) --- Формат блока свободной страницы Byte Contents 0-7 Magic 0x7e2146524545217e (\"~!FREE!~\") 8-1023 Unused --- Метаиндекс Расположено на странице 2. Отображает строки US-ASCII → 4-байтовые целые числа. Ключ — имя skiplist (список с пропусками); значение — индекс страницы.\nТаблицы службы имён Blockfile (формат блочного файла) Сервис определяет несколько skiplist (структура данных «пропускающий список»). Каждый диапазон поддерживает до 16 элементов.\nСвойства Skiplist (структура данных «скип-лист») %%__INFO__%% содержит одну запись:\nKey Value info A Properties object (UTF-8 String / String map) serialized as a Mapping Типичные поля: Property Description version \"4\" created Java long (ms since epoch) upgraded Java long (ms since epoch, since DB v2) lists Comma-separated host DBs (e.g. privatehosts.txt,userhosts.txt,hosts.txt) listversion_* Version of each DB (used to detect partial upgrades, since v4) --- Скип-лист обратного поиска %%__REVERSE__%% содержит записи Integer → Properties (начиная с DB v2).\nКлюч: Первые 4 байта хэша SHA-256 от Destination (адреса назначения в I2P). Значение: Объект Properties (сериализованный Mapping). Несколько записей позволяют обрабатывать коллизии и Destinations с несколькими именами хоста. Каждый ключ свойства = имя хоста; значение = пустая строка. Скип-листы базы данных хостов Каждый из hosts.txt, userhosts.txt и privatehosts.txt сопоставляет имена хостов → назначения.\nВерсия 4 поддерживает несколько Destinations (уникальные адреса назначения) на одно имя хоста (введено в I2P 0.9.26). Базы данных версии 3 мигрируются автоматически.\nКлюч Строка UTF-8 (имя хоста, в нижнем регистре, оканчивается на .i2p)\nЗначение Версия 4: 1 байт — количество пар свойство/Destination (адрес назначения) Для каждой пары: Свойства → Destination (в двоичном виде) Версия 3: Свойства → Destination (в двоичном виде) Свойства DestEntry Key Meaning a Time added (Java long ms) m Last modified (Java long ms) notes User comments s Source (file or subscription URL) v Signature verified (true/false) --- Примечания по реализации Класс Java BlockfileNamingService реализует эту спецификацию.\nВне контекста router, база данных открывается только для чтения, если не установлено i2p.naming.blockfile.writeInAppContext=true. Не предназначено для доступа из нескольких экземпляров или нескольких JVM. Поддерживает три основные отображения (privatehosts, userhosts, hosts) и обратное отображение для быстрого поиска. Ссылки Документация по именованию и адресной книге I2P Спецификация общих структур База данных Metanotion Blockfile JavaDoc для BlockfileNamingService ","description":"Формат хранения на диске blockfile (блочный файл), используемый в I2P для разрешения имён хостов","id":"5cbdbb030530ec5e0200cc202d4bff7f","section":"docs","title":"Спецификация Blockfile (формат блочного файла)","url":"/ru/docs/specs/blockfile/"},{"categories":null,"content":"1. Обзор SSU2 — это основанный на UDP протокол транспортного уровня, используемый для безопасной, полунадежной связи между router-ами в I2P. Это не универсальный транспорт, а специализирован для обмена сообщениями I2NP.\nОсновные возможности Аутентифицированный обмен ключами по шаблону Noise XK Зашифрованные заголовки для устойчивости к DPI (глубокой проверке пакетов) Обход NAT с использованием ретрансляторов и техники hole-punching (пробивки отверстий) Миграция соединения и проверка адреса Необязательная проверка маршрута Прямая секретность и защита от повторов Устаревшие компоненты и совместимость Implementation SSU2 Default SSU1 Removed i2pd2.44.02.44.0 Java I2P0.9.560.9.61 SSU1 больше не используется в общедоступной сети I2P. 2. Криптография SSU2 использует Noise_XK_25519_ChaChaPoly_SHA256 с расширениями, специфичными для I2P.\nFunction Algorithm Notes Diffie-HellmanX25519 (RFC 7748)32-byte keys CipherChaCha20/Poly1305 (RFC 7539)AEAD encryption HashSHA-256Used for key derivation and message integrity KDFHKDF-SHA256 (RFC 5869)For session and header keys Заголовки и полезные данные криптографически связаны с помощью `mixHash()`. Все криптографические примитивы совместно используются с NTCP2 и ECIES (схема шифрования на основе эллиптических кривых) для повышения эффективности реализации. 3. Обзор сообщений 3.1 Правила дейтаграмм UDP Каждая UDP-датаграмма несет ровно одно сообщение SSU2. Сообщения Session Confirmed (подтверждение сеанса) могут быть фрагментированы на несколько датаграмм. Минимальный размер: 40 байт Максимальный размер: 1472 байта (IPv4) / 1452 байта (IPv6)\n3.2 Типы сообщений Type Message Header Description 0Session Request32BHandshake initiation 1Session Created32BHandshake response 2Session Confirmed16BFinal handshake, may be fragmented 6Data16BEncrypted I2NP message blocks 7Peer Test32BNAT reachability testing 9Retry32BToken or rejection notice 10Token Request32BRequest for validation token 11Hole Punch32BNAT traversal signaling --- 4. Установление сеанса 4.1 Стандартный поток (действительный токен) Alice Bob SessionRequest ─────────────\u0026gt; \u0026lt;────────────── SessionCreated SessionConfirmed ────────────\u0026gt; 4.2 Получение токена Alice Bob TokenRequest ───────────────\u0026gt; \u0026lt;────────────── Retry (Token) SessionRequest ─────────────\u0026gt; \u0026lt;────────────── SessionCreated SessionConfirmed ────────────\u0026gt; 4.3 Недопустимый токен Alice Bob SessionRequest ─────────────\u0026gt; \u0026lt;────────────── Retry (Termination) 5. Структуры заголовков 5.1 Длинный заголовок (32 байта) Используется до установления сеанса (SessionRequest, Created, Retry, PeerTest, TokenRequest, HolePunch).\nField Size Description Destination Connection ID8Random unique ID Packet Number4Random (ignored during handshake) Type1Message type Version1Always 2 NetID12 = main I2P network Flags1Reserved (0) Source Connection ID8Random ID distinct from destination Token8Token for address validation ### 5.2 Короткий заголовок (16 байт) Используется во время установленных сеансов (SessionConfirmed, Data).\nField Size Description Destination Connection ID8Stable throughout session Packet Number4Incrementing per message Type1Message type (2 or 6) Flags3ACK/fragment flags --- 6. Шифрование 6.1 AEAD (аутентифицированное шифрование с дополнительными данными) Все полезные нагрузки зашифрованы с использованием ChaCha20/Poly1305 AEAD (аутентифицированное шифрование с дополнительными данными):\nciphertext = ChaCha20_Poly1305_Encrypt(key, nonce, plaintext, associated_data) Nonce (одноразовое число): 12 байт (4 нуля + 8 счётчика) Тег: 16 байт Ассоциированные данные: включают заголовок для привязки целостности 6.2 Защита заголовка Заголовки маскируются с помощью потока ключей ChaCha20, полученного из ключей заголовка сессии. Это гарантирует, что все идентификаторы соединений (Connection IDs) и поля пакетов выглядят случайными, обеспечивая устойчивость к DPI (глубокой инспекции пакетов).\n6.3 Выработка ключей Phase Input Output InitialintroKey + salthandshake header key HandshakeDH(X25519)chainKey + AEAD key Data phasechainKeyTX/RX keys Key rotationoldKeynewKey --- 7. Безопасность и защита от повторов Токены выдаются на IP-адрес и истекают через ~60 секунд. Повторы предотвращаются с помощью сеансовых фильтров Блума. Дублирующиеся эфемерные ключи отклоняются. Заголовки и полезные данные криптографически связаны. Routers должны отбрасывать любой пакет, не прошедший аутентификацию AEAD или имеющий недопустимую версию или NetID.\n8. Нумерация пакетов и время жизни сессии Каждое направление ведет собственный 32-битный счетчик. - Начинается с 0, увеличивается на 1 для каждого пакета. - Не должен переполняться; перед достижением 2³² необходимо выполнить rekey сеанса (смену ключей) или завершить сеанс.\nИдентификаторы соединений остаются неизменными на протяжении всей сессии, в том числе во время миграции.\n9. Фаза данных Тип = 6 (Данные) Короткий заголовок (16 байт) Полезная нагрузка содержит один или несколько зашифрованных блоков: Списки ACK/NACK (подтверждение/отказ) Фрагменты сообщений I2NP Выравнивание (0–31 байт случайных данных) Блоки завершения (необязательно) Поддерживаются избирательная повторная передача и доставка не по порядку. Надёжность остаётся “полунадёжной” — потерянные пакеты могут быть отброшены без уведомления после исчерпания лимита повторных попыток.\n10. Ретрансляция и обход NAT Message Type Purpose Peer Test7Determines inbound reachability Retry9Issues new token or rejection Token Request10Requests new address token Hole Punch11Coordinates NAT hole punching Ретрансляционные routers помогают пирам, находящимся за ограничительными NAT, используя эти управляющие сообщения. 11. Завершение сеанса Любой пир может закрыть сеанс, используя Termination block (блок завершения) внутри Data message (сообщение данных). Ресурсы должны быть освобождены немедленно после получения. Повторные пакеты завершения могут игнорироваться после подтверждения.\n12. Рекомендации по реализации Routers ДОЛЖНЫ: - Проверять, что version = 2 и NetID = 2. - Отбрасывать пакеты \u0026lt;40 байт или с некорректной AEAD. - Обеспечивать кэш защиты от повторов на 120 с. - Отклонять повторно используемые токены или эфемерные ключи.\nRouters СЛЕДУЕТ: - Случайно варьировать размер заполнения 0–31 байт. - Использовать адаптивную ретрансляцию (RFC 6298). - Реализовать проверку пути для каждого пира перед миграцией.\n13. Сводка по безопасности Property Achieved By Forward secrecyX25519 ephemeral keys Replay protectionTokens + Bloom filter Authenticated encryptionChaCha20/Poly1305 KCI resistanceNoise XK pattern DPI resistanceEncrypted headers NAT traversalRelay + Hole Punch MigrationStatic connection IDs --- 14. Ссылки Предложение 159 – SSU2 Фреймворк протокола Noise RFC 9000 – Транспорт QUIC RFC 9001 – TLS для QUIC RFC 7539 – ChaCha20/Poly1305 AEAD RFC 7748 – X25519 ECDH RFC 5869 – HKDF-SHA256 ","description":"Безопасный частично надёжный транспортный протокол поверх UDP, версия 2","id":"b45756033b706b68daaee09f536f3c91","section":"docs","title":"Спецификация SSU2","url":"/ru/docs/specs/ssu2/"},{"categories":null,"content":"Обзор Routers автоматически проверяют наличие обновлений, опрашивая подписанную ленту новостей, распространяемую через сеть I2P. Когда анонсируется более новая версия, router загружает криптографически подписанный архив обновления (.su3) и подготавливает его к установке. Эта система обеспечивает аутентифицированное, защищённое от подмены и многоканальное распространение официальных релизов.\nНачиная с I2P 2.10.0, система обновлений использует:\nподписи RSA-4096 / SHA-512 формат контейнера SU3 (вместо устаревших SUD/SU2) Избыточные зеркала: HTTP в сети I2P, HTTPS в клирнете и BitTorrent 1. Лента новостей Routers опрашивают подписанную ленту Atom каждые несколько часов, чтобы обнаруживать новые версии и уведомления о безопасности. Лента подписывается и распространяется в виде файла .su3, который может включать:\n\u0026lt;i2p:version\u0026gt; — номер новой версии \u0026lt;i2p:minVersion\u0026gt; — минимально поддерживаемая версия router \u0026lt;i2p:minJavaVersion\u0026gt; — требуемая минимальная среда выполнения Java \u0026lt;i2p:update\u0026gt; — перечисляет несколько зеркал загрузки (I2P, HTTPS, торрент) \u0026lt;i2p:revocations\u0026gt; — данные об отзыве сертификатов \u0026lt;i2p:blocklist\u0026gt; — блок-листы на уровне сети для скомпрометированных пиров Распространение ленты Channel Description Usage I2P HTTP (eepsite) Primary update source Private, resilient Clearnet HTTPS Fallback mirror Public fallback BitTorrent magnet Distributed channel Reduces mirror load Routers предпочитают I2P‑фид, но при необходимости могут переключиться на clearnet (открытый интернет) или торрент-распространение. 2. Форматы файлов SU3 (Текущий стандарт) Начиная с версии 0.9.9, SU3 заменил устаревшие форматы SUD и SU2. Каждый файл содержит заголовок, полезную нагрузку и завершающую подпись.\nСтруктура заголовка \u0026lt;tr\u0026gt; \u0026lt;th style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem; text-align:left; background:var(--color-bg-secondary);\u0026quot;\u0026gt;Field\u0026lt;/th\u0026gt; \u0026lt;th style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem; text-align:left; background:var(--color-bg-secondary);\u0026quot;\u0026gt;Description\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Magic\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;\u0026lt;code\u0026gt;\u0026quot;I2Psu3\u0026quot;\u0026lt;/code\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Format Version\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;\u0026lt;code\u0026gt;0\u0026lt;/code\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Signature Type\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;e.g., \u0026lt;code\u0026gt;0x000B\u0026lt;/code\u0026gt; (RSA-SHA512-4096)\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Signature Length\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;\u0026lt;code\u0026gt;512 bytes\u0026lt;/code\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Version String\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Router version\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Signer ID\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Certificate name\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Content Type\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;1 = router update, 3 = reseed, 4 = news feed\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; Шаги проверки подписи 1. Разберите заголовок и определите алгоритм подписи. 2. Проверьте хэш и подпись, используя сохранённый сертификат подписанта. 3. Убедитесь, что сертификат подписанта не отозван. 4. Сравните встроенную строку версии с метаданными полезной нагрузки.\nRouters поставляются с сертификатами доверенных подписантов (в настоящее время — zzz и str4d) и отклоняют любые неподписанные или отозванные источники.\nSU2 (устарело) Использовалось расширение .su2 для JAR-файлов, сжатых с помощью Pack200. Удалено после того, как в Java 14 Pack200 был объявлен устаревшим (JEP 367). Отключено в I2P 0.9.48+; теперь полностью заменено ZIP-сжатием. SUD (устаревшее) Ранний формат ZIP с подписью DSA-SHA1 (до 0.9.9). Нет идентификатора подписанта или заголовка, ограниченная защита целостности. Заменён из-за слабой криптографии и отсутствия принудительного контроля версий. 3. Рабочий процесс обновления 3.1 Проверка заголовка Routers получают только SU3 header (заголовок SU3) для проверки строки версии перед загрузкой полных файлов. Это позволяет избежать напрасной траты пропускной способности на устаревшие зеркала или версии.\n3.2 Полная загрузка После проверки заголовка, router загружает полный файл .su3 с: - Внутрисетевые зеркала eepsite (предпочтительно) - HTTPS зеркала clearnet (обычный интернет) (резервный вариант) - BitTorrent (необязательное распространение при участии пиров)\nДля загрузок используются стандартные HTTP‑клиенты I2PTunnel с повторными попытками, обработкой таймаутов и переключением на зеркала.\n3.3 Проверка подписи Каждый загруженный файл проходит: - Проверка подписи: верификация RSA-4096/SHA512 - Сопоставление версий: проверка соответствия версий заголовка и полезной нагрузки - Предотвращение понижения версии: гарантирует, что обновление новее установленной версии\nНекорректные или несовпадающие файлы немедленно отбрасываются.\n3.4 Подготовка к установке После проверки: 1. Извлеките содержимое ZIP во временный каталог 2. Удалите файлы, перечисленные в deletelist.txt 3. Замените нативные библиотеки, если включён lib/jbigi.jar 4. Скопируйте сертификаты подписанта в ~/.i2p/certificates/ 5. Переместите обновление в i2pupdate.zip для применения при следующем перезапуске\nОбновление устанавливается автоматически при следующем запуске или при ручном запуске «Install update now».\n4. Управление файлами deletelist.txt Текстовый список устаревших файлов, которые нужно удалить перед распаковкой нового содержимого.\nПравила: - Один путь на строку (только относительные пути) - Строки, начинающиеся с #, игнорируются - .. и абсолютные пути отклоняются\nНативные библиотеки Чтобы избежать использования устаревших или несовместимых нативных бинарных файлов: - Если lib/jbigi.jar существует, старые файлы .so или .dll удаляются - Обеспечивается повторное извлечение библиотек, зависящих от платформы\n5. Управление сертификатами Routers могут получать новые сертификаты подписанта посредством обновлений или аннулирований в ленте новостей.\nНовые файлы .crt копируются в каталог сертификатов. Отозванные сертификаты удаляются перед последующими проверками. Поддерживает ротацию ключей без необходимости ручного вмешательства пользователя. Все обновления подписываются в автономном режиме с использованием air-gapped signing systems (систем подписания, изолированных от сети). Закрытые ключи никогда не хранятся на серверах сборки.\n6. Рекомендации для разработчиков Topic Details Signing Use RSA-4096 (SHA-512) via apps/jetty/news SU3 tooling. Mirror Policy I2P eepsite preferred, clearnet HTTPS fallback, torrent optional. Testing Validate updates from prior releases, across all OS platforms. Version Enforcement minVersion prevents incompatible upgrades. Certificate Rotation Distribute new certs in updates and revocation lists. В будущих релизах будут изучаться вопросы интеграции постквантовых подписей (см. Proposal 169) и реализации воспроизводимых сборок. 7. Обзор безопасности Threat Mitigation Tampering Cryptographic signature (RSA-4096/SHA512) Key Compromise Feed-based certificate revocation Downgrade Attack Version comparison enforcement Mirror Hijack Signature verification, multiple mirrors DoS Fallback to alternate mirrors/torrents MITM HTTPS transport + signature-level integrity --- 8. Версионирование Router: 2.10.0 (API 0.9.67) Семантическое версионирование с Major.Minor.Patch. Принудительное соблюдение минимальной версии предотвращает небезопасные обновления. Поддерживаемые версии Java: Java 8–17. В будущих версиях 2.11.0+ потребуется Java 17+. ","description":"Безопасный механизм подписанных обновлений и структура канала обновлений для I2P routers","id":"aea843f73d809c9546b3d675324af161","section":"docs","title":"Спецификация обновления программного обеспечения","url":"/ru/docs/specs/updates/"},{"categories":null,"content":"Обзор Назначение ECIES-X25519-AEAD-Ratchet — современный протокол сквозного шифрования I2P, заменяющий устаревшую систему ElGamal/AES+SessionTags. Он обеспечивает прямую секретность, аутентифицированное шифрование и значительные улучшения производительности и безопасности.\nОсновные улучшения по сравнению с ElGamal/AES+SessionTags Ключи меньшего размера: 32-байтные ключи против 256-байтных открытых ключей ElGamal (снижение на 87,5%) Прямая секретность: достигается посредством DH ratcheting (поэтапное обновление ключей) (отсутствует в устаревшем протоколе) Современная криптография: X25519 DH, ChaCha20-Poly1305 AEAD, SHA-256 Аутентифицированное шифрование: встроенная аутентификация через схему AEAD Двунаправленный протокол: сопряжённые сессии (входящая/исходящая) против однонаправленного устаревшего протокола Эффективные теги: 8-байтные сеансовые теги против 32-байтных тегов (снижение на 75%) Маскировка трафика: кодирование Elligator2 делает рукопожатия неотличимыми от случайных данных Статус развертывания Первый релиз: Версия 0.9.46 (25 мая 2020 г.) Развертывание в сети: Завершено по состоянию на 2020 год Текущий статус: Зрелый, широко развернут (более 5 лет в эксплуатации) Поддержка router (маршрутизатор I2P): Требуется версия 0.9.46 или выше Требования к Floodfill (специальные узлы индексирования netDb): Практически 100%-ное принятие для зашифрованных запросов Статус реализации Полностью реализовано: - Сообщения новой сессии (NS) с привязкой - Сообщения ответа новой сессии (NSR) - Сообщения существующей сессии (ES) - Механизм DH-трещотки - Трещотки для Session tag (тегов сессии) и симметричных ключей - Блоки DateTime, NextKey, ACK, ACK Request, Garlic Clove (долька Garlic) и Padding\nНе реализовано (на момент версии 0.9.50): - блок MessageNumbers (тип 6) - блок Options (тип 5) - блок Termination (тип 4) - Автоматические ответы на уровне протокола - Режим с нулевым статическим ключом - Мультикаст-сессии\nПримечание: Статус реализации для версий с 1.5.0 по 2.10.0 (2021–2025) требует проверки, так как некоторые функции могли быть добавлены.\nОснова протокола Noise Protocol Framework (фреймворк протоколов Noise) ECIES-X25519-AEAD-Ratchet основан на Noise Protocol Framework (фреймворк протоколов Noise) (ревизия 34, 2018-07-11), в частности на шаблоне рукопожатия IK (интерактивный, с известным удалённым статическим ключом) с расширениями, специфичными для I2P.\nИдентификатор протокола Noise Noise_IKelg2+hs2_25519_ChaChaPoly_SHA256 Компоненты идентификатора: - Noise - Базовый фреймворк - IK - Интерактивный шаблон рукопожатия с известным удалённым статическим ключом - elg2 - Кодирование Elligator2 для эфемерных ключей (расширение I2P) - +hs2 - MixHash вызывается перед вторым сообщением для смешивания тега (расширение I2P) - 25519 - Функция Диффи—Хеллмана X25519 - ChaChaPoly - Шифр AEAD ChaCha20-Poly1305 - SHA256 - Хэш-функция SHA-256\nШаблон рукопожатия Noise Нотация шаблона IK:\n\u0026lt;- s (Bob\u0026#39;s static key known to Alice) ... -\u0026gt; e, es, s, ss (Alice sends ephemeral, DH es, static key, DH ss) \u0026lt;- e, ee, se (Bob sends ephemeral, DH ee, DH se) Значения токенов: - e - передача эфемерного ключа - s - передача статического ключа - es - DH (Диффи-Хеллман) между эфемерным ключом Алисы и статическим ключом Боба - ss - DH между статическим ключом Алисы и статическим ключом Боба - ee - DH между эфемерным ключом Алисы и эфемерным ключом Боба - se - DH между статическим ключом Боба и эфемерным ключом Алисы\nСвойства безопасности Noise (протокольный фреймворк) Используя терминологию Noise, паттерн IK обеспечивает:\nMessage Authentication Level Confidentiality Level Message\u0026nbsp;1 (NS) Level\u0026nbsp;1 (sender auth, KCI vulnerable) Level\u0026nbsp;2 (weak forward secrecy) Message\u0026nbsp;2 (NSR) Level\u0026nbsp;2 (mutual auth) Level\u0026nbsp;4 (weak forward secrecy) Transport (ES) Level\u0026nbsp;2 (mutual auth) Level\u0026nbsp;5 (strong forward secrecy) **Уровни аутентификации:** - **Уровень 1**: Полезная нагрузка аутентифицирована как принадлежащая владельцу статического ключа отправителя, но уязвима для Key Compromise Impersonation (подмена личности при компрометации ключа, KCI) - **Уровень 2**: Устойчива к атакам KCI после NSR Уровни конфиденциальности: - Уровень 2: Прямая секретность (forward secrecy), если статический ключ отправителя впоследствии компрометирован - Уровень 4: Прямая секретность, если эфемерный ключ отправителя впоследствии компрометирован - Уровень 5: Полная прямая секретность после удаления обоих эфемерных ключей\nРазличия между IK и XK Паттерн IK отличается от паттерна XK, используемого в NTCP2 и SSU2:\nЧетыре операции DH (Диффи—Хеллмана): IK использует 4 операции DH (es, ss, ee, se) против 3 у XK Мгновенная аутентификация: Алиса аутентифицируется в первом сообщении (уровень аутентификации 1) Более быстрое достижение прямой секретности: Полная прямая секретность (уровень 5) достигается после второго сообщения (1-RTT) Компромисс: Полезная нагрузка первого сообщения не обладает прямой секретностью (в отличие от XK, где все полезные нагрузки обладают прямой секретностью) Сводка: IK обеспечивает доставку ответа Боба за 1-RTT с полной прямой секретностью, ценой отсутствия прямой секретности для начального запроса.\nКонцепции Signal Double Ratchet (алгоритма «двойной трещотки») ECIES (интегрированная схема шифрования на эллиптических кривых) использует идеи из Signal Double Ratchet Algorithm :\nРатчет DH: Обеспечивает прямую секретность за счет периодического обмена новыми ключами DH Ратчет симметричных ключей: Выводит новые сеансовые ключи для каждого сообщения Ратчет Session Tag (меток сеанса): Детерминированно генерирует одноразовые session tags Ключевые отличия от Signal: - Менее частый ratcheting (механизм пошагового обновления ключей): I2P выполняет ratcheting только при необходимости (при близком исчерпании тегов или по политике) - Сессионные теги вместо шифрования заголовков: использует детерминированные теги, а не зашифрованные заголовки - Явные ACK: использует in-band блоки ACK, вместо того чтобы полагаться только на обратный трафик - Раздельные ratchet\u0026rsquo;ы для тегов и ключей: эффективнее для получателя (можно отложить вычисление ключа)\nРасширения I2P для протокола Noise Кодирование Elligator2: Эфемерные ключи кодируются так, чтобы быть неотличимыми от случайных Метка, добавляемая перед NSR: Метка сессии добавляется перед сообщением NSR (Noise Session Request — запрос сессии Noise) для корреляции Определённый формат полезной нагрузки: Блочная структура полезной нагрузки для всех типов сообщений Инкапсуляция I2NP: Все сообщения обёрнуты в заголовки I2NP Garlic Message (многочастного сообщения I2P) Отдельная фаза данных: Транспортные сообщения (ES) отличаются от стандартной фазы данных Noise Криптографические примитивы Диффи-Хеллман на X25519 Спецификация: RFC 7748 Ключевые свойства: - Размер закрытого ключа: 32 байта - Размер открытого ключа: 32 байта - Размер общего секрета: 32 байта - Порядок байт: младший порядок байт (little-endian) - Кривая: Curve25519\nОперации:\nX25519 GENERATE_PRIVATE() Генерирует случайный 32-байтный закрытый ключ:\nprivkey = CSRNG(32) X25519 DERIVE_PUBLIC(privkey) Вычисляет соответствующий открытый ключ:\npubkey = curve25519_scalarmult_base(privkey) Возвращает 32-байтный открытый ключ в формате little-endian.\nX25519 DH(privkey, pubkey) Выполняет согласование ключей Диффи-Хеллмана:\nsharedSecret = curve25519_scalarmult(privkey, pubkey) Возвращает 32-байтовый общий секрет.\nПримечание по безопасности: Реализации обязаны проверять, что общий секрет не состоит полностью из нулей (слабый ключ). В таком случае отклоните и прервите рукопожатие.\nChaCha20-Poly1305 AEAD (аутентифицированное шифрование с дополнительными данными) Спецификация: RFC 7539 раздел 2.8\nПараметры: - Размер ключа: 32 байта (256 бит) - Размер nonce (одноразового значения): 12 байт (96 бит) - Размер MAC: 16 байт (128 бит) - Размер блока: 64 байта (внутренний)\nФормат нонса:\nByte 0-3: 0x00 0x00 0x00 0x00 (always zero) Byte 4-11: Little-endian counter (message number N) Схема AEAD:\nAEAD (аутентифицированное шифрование с дополнительными данными) объединяет потоковый шифр ChaCha20 с алгоритмом MAC Poly1305:\nСгенерируйте ключевой поток ChaCha20 на основе ключа и nonce (одноразовое число) Зашифруйте открытый текст с помощью операции XOR (исключающего ИЛИ) с ключевым потоком Вычислите MAC (код аутентификации сообщения) Poly1305 над (associated data (дополнительные аутентифицируемые данные) || шифртекстом) Добавьте 16-байтный MAC к шифртексту ChaCha20-Poly1305 ENCRYPT(k, n, plaintext, ad) Шифрует открытый текст с аутентификацией:\n# Inputs k = 32-byte cipher key n = 12-byte nonce (first 4 bytes zero, last 8 bytes = message number) plaintext = data to encrypt (0 to 65519 bytes) ad = associated data (optional, used in MAC calculation) # Output ciphertext = chacha20_encrypt(k, n, plaintext) mac = poly1305(ad || ciphertext, poly1305_key_gen(k, n)) return ciphertext || mac # Total length = len(plaintext) + 16 Свойства: - Шифртекст имеет ту же длину, что и открытый текст (потоковый шифр) - Выходные данные имеют размер plaintext_length + 16 байт (включает MAC) - Все выходные данные неотличимы от случайных данных, если ключ секретен - MAC аутентифицирует как ассоциированные данные, так и шифртекст\nChaCha20-Poly1305 DECRYPT(k, n, ciphertext, ad) Расшифровывает и проверяет аутентификацию:\n# Split ciphertext and MAC ct_without_mac = ciphertext[0:-16] received_mac = ciphertext[-16:] # Verify MAC expected_mac = poly1305(ad || ct_without_mac, poly1305_key_gen(k, n)) if not constant_time_compare(received_mac, expected_mac): raise AuthenticationError(\u0026#34;MAC verification failed\u0026#34;) # Decrypt plaintext = chacha20_decrypt(k, n, ct_without_mac) return plaintext Критические требования безопасности: - Nonces (одноразовые числа) ДОЛЖНЫ быть уникальными для каждого сообщения с одним и тем же ключом - Nonces НЕ ДОЛЖНЫ переиспользоваться (катастрофический сбой при повторном использовании) - Проверка MAC ДОЛЖНА использовать константное по времени сравнение для предотвращения тайминговых атак - Неуспешная проверка MAC ДОЛЖНА приводить к полному отклонению сообщения (без частичной расшифровки)\nХеш-функция SHA-256 Спецификация: NIST FIPS 180-4\nСвойства: - Размер вывода: 32 байта (256 бит) - Размер блока: 64 байта (512 бит) - Уровень безопасности: 128 бит (устойчивость к коллизиям)\nОперации:\nSHA-256 H(p, d) Хэш SHA-256 со строкой персонализации:\nH(p, d) := SHA256(p || d) Где || обозначает конкатенацию, p — строка персонализации, d — данные.\nSHA-256 MixHash(d) (смешанный хеш) Обновляет текущий хэш новыми данными:\nh = SHA256(h || d) Используется на протяжении всего рукопожатия Noise для поддержания хэша транскрипта.\nДеривация ключей HKDF Спецификация: RFC 5869 Описание: Функция деривации ключей на основе HMAC с использованием SHA-256\nПараметры: - Хэш-функция: HMAC-SHA256 - Длина соли: До 32 байт (размер выходных данных SHA-256) - Длина вывода: Переменная (до 255 * 32 байт)\nФункция HKDF:\ndef HKDF(salt, ikm, info, length): \u0026#34;\u0026#34;\u0026#34; Args: salt: Salt value (32 bytes max for SHA-256) ikm: Input key material (any length) info: Context-specific info string length: Desired output length in bytes Returns: output: Derived key material (length bytes) \u0026#34;\u0026#34;\u0026#34; # Extract phase prk = HMAC-SHA256(salt, ikm) # Expand phase n = ceil(length / 32) t = b\u0026#39;\u0026#39; okm = b\u0026#39;\u0026#39; for i in range(1, n + 1): t = HMAC-SHA256(prk, t || info || byte(i)) okm = okm || t return okm[0:length] Типичные сценарии использования:\n# Generate two keys (64 bytes total) keydata = HKDF(chainKey, sharedSecret, \u0026#34;KDFDHRatchetStep\u0026#34;, 64) nextRootKey = keydata[0:31] chainKey = keydata[32:63] # Generate session tag (8 bytes) tagdata = HKDF(chainKey, CONSTANT, \u0026#34;SessionTagKeyGen\u0026#34;, 64) nextChainKey = tagdata[0:31] sessionTag = tagdata[32:39] # Generate symmetric key (32 bytes) keydata = HKDF(chainKey, ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) nextChainKey = keydata[0:31] sessionKey = keydata[32:63] Строки info, используемые в ECIES: - \u0026quot;KDFDHRatchetStep\u0026quot; - вывод ключа для DH-трещотки - \u0026quot;TagAndKeyGenKeys\u0026quot; - инициализация ключей цепочки меток и цепочки ключей - \u0026quot;STInitialization\u0026quot; - инициализация трещотки сеансовых меток - \u0026quot;SessionTagKeyGen\u0026quot; - генерация сеансовых меток - \u0026quot;SymmetricRatchet\u0026quot; - генерация симметрических ключей - \u0026quot;XDHRatchetTagSet\u0026quot; - ключ набора меток DH-трещотки - \u0026quot;SessionReplyTags\u0026quot; - генерация набора меток NSR - \u0026quot;AttachPayloadKDF\u0026quot; - вывод ключа полезной нагрузки NSR\nКодирование Elligator2 (криптографическая схема отображения точек эллиптической кривой в равномерно распределённые случайные данные) Назначение: Кодировать открытые ключи X25519 так, чтобы они были неотличимы от равномерно распределённых случайных 32-байтовых строк.\nСпецификация: Статья Elligator2 Проблема: Стандартные публичные ключи X25519 имеют распознаваемую структуру. Наблюдатель может определить сообщения рукопожатия, обнаруживая эти ключи, даже если содержимое зашифровано.\nРешение: Elligator2 обеспечивает биективное отображение между ~50% корректных открытых ключей X25519 и на вид случайными 254-битными строками.\nГенерация ключей с использованием Elligator2:\nElligator2 GENERATE_PRIVATE_ELG2() Генерирует закрытый ключ, которому соответствует открытый ключ, кодируемый по схеме Elligator2 (алгоритм маскировки открытых ключей):\nwhile True: privkey = CSRNG(32) pubkey = DERIVE_PUBLIC(privkey) # Test if public key is Elligator2-encodable try: encoded = ENCODE_ELG2(pubkey) # Success - this key pair is suitable return privkey except NotEncodableError: # Try again with new random key continue Важно: Примерно 50% случайно сгенерированных закрытых ключей приводят к получению некодируемых открытых ключей. Такие закрытые ключи необходимо отбросить и попытаться сгенерировать заново.\nОптимизация производительности: заранее генерируйте ключи в фоновом потоке, чтобы поддерживать пул подходящих пар ключей и избежать задержек во время рукопожатия.\nElligator2 ENCODE_ELG2(pubkey) Кодирует открытый ключ в 32 байта, похожие на случайные:\ndef ENCODE_ELG2(pubkey): \u0026#34;\u0026#34;\u0026#34; Encodes X25519 public key using Elligator2. Args: pubkey: 32-byte X25519 public key (little-endian) Returns: encoded: 32-byte encoded key indistinguishable from random Raises: NotEncodableError: If pubkey cannot be encoded \u0026#34;\u0026#34;\u0026#34; # Perform Elligator2 representative calculation # Returns 254-bit value (31.75 bytes) encodedKey = elligator2_encode(pubkey) # Add 2 random bits to MSB to make full 32 bytes randomByte = CSRNG(1) encodedKey[31] |= (randomByte \u0026amp; 0xc0) return encodedKey Подробности кодирования: - Elligator2 даёт 254 бита (не полные 256) - Старшие 2 бита 31-го байта — случайное заполнение - Результат равномерно распределён по 32-байтовому пространству - Успешно кодирует примерно 50% валидных публичных ключей X25519\nElligator2 DECODE_ELG2(encodedKey) Декодируется обратно в исходный открытый ключ:\ndef DECODE_ELG2(encodedKey): \u0026#34;\u0026#34;\u0026#34; Decodes Elligator2-encoded key back to X25519 public key. Args: encodedKey: 32-byte encoded key Returns: pubkey: 32-byte X25519 public key (little-endian) \u0026#34;\u0026#34;\u0026#34; # Mask out 2 random padding bits from MSB encodedKey[31] \u0026amp;= 0x3f # Perform Elligator2 representative inversion pubkey = elligator2_decode(encodedKey) return pubkey Свойства безопасности: - Закодированные ключи вычислительно неотличимы от случайных байтов - Ни один статистический тест не может надежно обнаружить ключи, закодированные с использованием Elligator2 - Декодирование детерминированно (один и тот же закодированный ключ всегда дает один и тот же открытый ключ) - Кодирование биективно для ~50% ключей в кодируемом подмножестве\nПримечания по реализации: - Сохраняйте закодированные ключи на этапе генерации, чтобы избежать повторного кодирования во время рукопожатия - Неподходящие ключи, полученные при генерации Elligator2 (метод маскировки точек эллиптической кривой), можно использовать для NTCP2 (которому Elligator2 не требуется) - Фоновая генерация ключей критически важна для производительности - Среднее время генерации удваивается из-за 50% уровня отбраковки\nФорматы сообщений Обзор ECIES (интегрированная схема шифрования на эллиптических кривых) определяет три типа сообщений:\nNew Session (NS): Начальное сообщение рукопожатия от Алисы к Бобу New Session Reply (NSR): Ответное сообщение рукопожатия от Боба Алисе Existing Session (ES): Все последующие сообщения в обоих направлениях Все сообщения инкапсулируются в формате I2NP Garlic Message с дополнительными слоями шифрования.\nКонтейнер Garlic Message протокола I2NP Все сообщения ECIES (схема интегрированного шифрования на эллиптических кривых) обернуты в стандартные заголовки I2NP Garlic Message:\n+----+----+----+----+----+----+----+----+ |type| msg_id | expiration | +----+----+----+----+----+----+----+----+ | size |chks| +----+----+----+----+----+----+----+----+ | length | | +----+----+----+----+ + | encrypted data | ~ ~ Поля: - type: 0x26 (Garlic Message — чесночное сообщение) - msg_id: 4-байтовый идентификатор сообщения I2NP - expiration: 8-байтовая метка времени Unix (миллисекунды) - size: 2-байтовый размер полезной нагрузки - chks: 1-байтовая контрольная сумма - length: 4-байтовая длина зашифрованных данных - encrypted data: ECIES-зашифрованная полезная нагрузка\nНазначение: Обеспечивает идентификацию сообщений и их маршрутизацию на уровне I2NP. Поле length позволяет получателям узнать общий размер зашифрованной полезной нагрузки.\nСообщение новой сессии (NS) Сообщение New Session инициирует новый сеанс от Алисы к Бобу. Оно бывает в трех вариантах:\nС привязкой (1b): Включает статический ключ Алисы для двунаправленной связи Без привязки (1c): Не включает статический ключ для однонаправленной связи Однократный (1d): Режим одиночного сообщения без установления сеанса Сообщение NS с привязкой (тип 1b) Сценарий использования: Потоковая передача, датаграммы с возможностью ответа, любой протокол, требующий ответов\nОбщая длина: 96 + payload_length байт\nФормат:\n+----+----+----+----+----+----+----+----+ | | + + | New Session Ephemeral Public Key | + 32 bytes + | Encoded with Elligator2 | + + | | +----+----+----+----+----+----+----+----+ | | + Static Key Section + | ChaCha20 encrypted data | + 32 bytes + | | + + | | +----+----+----+----+----+----+----+----+ | Poly1305 Message Authentication Code | + (MAC) for Static Key Section + | 16 bytes | +----+----+----+----+----+----+----+----+ | | + Payload Section + | ChaCha20 encrypted data | ~ Variable length ~ | | + + | | +----+----+----+----+----+----+----+----+ | Poly1305 Message Authentication Code | + (MAC) for Payload Section + | 16 bytes | +----+----+----+----+----+----+----+----+ Сведения о поле:\nЭфемерный открытый ключ (32 байта, в открытом виде): - одноразовый открытый ключ X25519 Алисы - кодируется с помощью Elligator2 (неотличим от случайных данных) - генерируется заново для каждого сообщения NS (никогда не переиспользуется) - формат little-endian (порядок байтов от младшего к старшему)\nРаздел статического ключа (32 байта зашифровано, 48 байт с MAC): - Содержит статический открытый ключ X25519 Алисы (32 байта) - Зашифровано с помощью ChaCha20 - Аутентифицировано с помощью Poly1305 MAC (16 байт) - Используется Бобом для привязки сеанса к назначению Алисы\nСекция полезной нагрузки (переменной длины, зашифрована, +16 байт MAC): - Содержит garlic cloves (подсообщения внутри garlic-сообщения) и другие блоки - Должна включать блок DateTime в качестве первого блока - Обычно включает блоки Garlic Clove с данными приложения - Может включать NextKey block (блок следующего ключа) для немедленного ratchet (механизм пошаговой смены ключей) - Шифруется с помощью ChaCha20 - Аутентифицируется с помощью Poly1305 MAC (16 байт)\nСвойства безопасности: - Эфемерный ключ обеспечивает компонент прямой секретности - Статический ключ аутентифицирует Алису (привязка к назначению) - Обе секции имеют отдельные MAC для разделения доменов - Всего рукопожатие выполняет 2 операции DH (es, ss)\nСообщение NS без привязки (тип 1c) Сценарий использования: Сырые датаграммы, где ответ не ожидается и не желателен\nОбщая длина: 96 + payload_length байт\nФормат:\n+----+----+----+----+----+----+----+----+ | | + + | New Session Ephemeral Public Key | + 32 bytes + | Encoded with Elligator2 | + + | | +----+----+----+----+----+----+----+----+ | | + Flags Section + | ChaCha20 encrypted data | + 32 bytes + | All zeros | + + | | +----+----+----+----+----+----+----+----+ | Poly1305 Message Authentication Code | + (MAC) for above section + | 16 bytes | +----+----+----+----+----+----+----+----+ | | + Payload Section + | ChaCha20 encrypted data | ~ Variable length ~ | | + + | | +----+----+----+----+----+----+----+----+ | Poly1305 Message Authentication Code | + (MAC) for Payload Section + | 16 bytes | +----+----+----+----+----+----+----+----+ Ключевое отличие: Раздел Flags содержит 32 байта нулей вместо статического ключа.\nОпределение: Боб определяет тип сообщения, расшифровав 32-байтовую секцию и проверив, что все байты равны нулю: - Все нули → непривязанный сеанс (тип 1c) - Ненулевые → привязанный сеанс со статическим ключом (тип 1b)\nСвойства: - Отсутствие статического ключа означает отсутствие привязки к назначению Алисы - Боб не может отправлять ответы (назначение неизвестно) - Выполняет только 1 операцию DH - Следует шаблону Noise \u0026ldquo;N\u0026rdquo;, а не \u0026ldquo;IK\u0026rdquo; - Более эффективно, если ответы никогда не требуются\nРаздел флагов (зарезервирован для будущего использования): В настоящее время все биты равны нулю. В будущих версиях может использоваться для согласования возможностей.\nОдноразовое сообщение NS (тип 1d) Сценарий использования: Одно анонимное сообщение без сеанса и без ожидания ответа\nОбщая длина: 96 + payload_length байт\nФормат: Идентичен NS без привязки (тип 1c)\nОтличия: - Тип 1c может отправлять несколько сообщений в той же сессии (далее следуют сообщения ES) - Тип 1d отправляет ровно одно сообщение без установления сессии - На практике реализации изначально могут обрабатывать их одинаково\nСвойства: - Максимальная анонимность (без статического ключа, без сеанса) - Состояние сеанса не сохраняется ни одной стороной - Следует шаблону Noise \u0026ldquo;N\u0026rdquo; - Одна операция Диффи—Хеллмана (es)\nСообщение «Ответ на новый сеанс» (NSR) Боб отправляет одно или несколько сообщений NSR в ответ на сообщение NS от Алисы. NSR завершает рукопожатие Noise IK и устанавливает двунаправленный сеанс.\nОбщая длина: 72 + payload_length байт\nФормат:\n+----+----+----+----+----+----+----+----+ | Session Tag 8 bytes | +----+----+----+----+----+----+----+----+ | | + Ephemeral Public Key + | | + 32 bytes + | Encoded with Elligator2 | + + | | +----+----+----+----+----+----+----+----+ | Poly1305 Message Authentication Code | + (MAC) for Key Section (empty) + | 16 bytes | +----+----+----+----+----+----+----+----+ | | + Payload Section + | ChaCha20 encrypted data | ~ Variable length ~ | | + + | | +----+----+----+----+----+----+----+----+ | Poly1305 Message Authentication Code | + (MAC) for Payload Section + | 16 bytes | +----+----+----+----+----+----+----+----+ Сведения о поле:\nМетка сеанса (8 байт, в открытом виде): - Генерируется из набора тегов NSR (см. разделы по KDF (функция выработки ключа)) - Соотносит этот ответ с NS-сообщением Алисы - Позволяет Алисе определить, на какой NS отвечает этот NSR - Одноразовая (никогда не используется повторно)\nЭфемерный открытый ключ (32 байта, в открытом виде): - Одноразовый открытый ключ X25519 Боба - Закодирован с помощью Elligator2 (метод маскировки эллиптических ключей) - Генерируется заново для каждого сообщения NSR - Должен отличаться для каждого отправленного NSR\nMAC секции ключа (16 байт): - Аутентифицирует пустые данные (ZEROLEN) - Часть протокола Noise IK (шаблон se) - Использует хэш транскрипта в качестве ассоциированных данных - Критично для связывания NSR с NS\nРаздел полезной нагрузки (переменной длины): - Содержит garlic cloves (дольки «garlic»-сообщения) и блоки - Обычно включает ответы уровня приложения - Может быть пустым (NSR только с ACK) - Максимальный размер: 65519 байт (65535 - 16-байтный MAC)\nНесколько сообщений NSR:\nБоб может отправить несколько сообщений NSR в ответ на один NS:\nУ каждого NSR уникальный эфемерный ключ У каждого NSR уникальный тег сеанса Алиса использует первый полученный NSR для завершения рукопожатия Остальные NSR являются избыточными (на случай потери пакетов) Критический тайминг: - Алиса должна получить один NSR, прежде чем отправлять сообщения ES - Боб должен получить одно сообщение ES, прежде чем отправлять сообщения ES - NSR устанавливает двунаправленные сеансовые ключи с помощью операции split()\nСвойства безопасности: - Завершает рукопожатие Noise IK - Выполняет 2 дополнительные операции Диффи — Хеллмана (DH) (ee, se) - Итого 4 операции DH для NS+NSR - Обеспечивает взаимную аутентификацию (Уровень 2) - Обеспечивает слабую прямую секретность (Уровень 4) для полезной нагрузки NSR\nСообщение Existing Session (ES) Все сообщения после NS/NSR handshake (рукопожатия NS/NSR) используют формат Existing Session (формат «существующего сеанса»). Сообщения ES используются двунаправленно Алисой и Бобом.\nОбщая длина: 8 + payload_length + 16 байт (минимум 24 байта)\nФормат:\n+----+----+----+----+----+----+----+----+ | Session Tag 8 bytes | +----+----+----+----+----+----+----+----+ | | + Payload Section + | ChaCha20 encrypted data | ~ Variable length ~ | | + + | | +----+----+----+----+----+----+----+----+ | Poly1305 Message Authentication Code | + (MAC) + | 16 bytes | +----+----+----+----+----+----+----+----+ Сведения о поле:\nТег сеанса (8 байт, в открытом виде): - Генерируется из текущего исходящего набора тегов - Идентифицирует сеанс и номер сообщения - Получатель по тегу находит ключ сеанса и nonce (одноразовое число) - Одноразовое использование (каждый тег используется ровно один раз) - Формат: первые 8 байт результата HKDF\nРаздел Payload (переменная длина): - Содержит garlic cloves (подсообщения в garlic encryption) и блоки - Обязательных блоков нет (может быть пустым) - Распространённые блоки: Garlic Clove, NextKey, ACK, ACK Request, Padding - Максимальный размер: 65519 байт (65535 - 16-байтный MAC)\nMAC (16 байт): - Тег аутентификации Poly1305 - Вычисляется по всей полезной нагрузке - Ассоциированные данные: 8-байтовый тег сессии - Должен корректно проверяться, иначе сообщение отклоняется\nПроцесс поиска тегов:\nПолучатель извлекает 8-байтовый тег Ищет тег во всех текущих входящих наборах тегов Получает соответствующий сеансовый ключ и номер сообщения N Формирует nonce (одноразовое значение): [0x00, 0x00, 0x00, 0x00, N (8 bytes little-endian)] Расшифровывает полезную нагрузку с использованием AEAD с тегом в качестве ассоциированных данных Удаляет тег из набора тегов (одноразовое использование) Обрабатывает расшифрованные блоки Тег сеанса не найден:\nЕсли тег не найден ни в одном наборе тегов: - Возможно, это сообщение NS → попытаться расшифровать как NS - Возможно, это сообщение NSR → попытаться расшифровать как NSR - Возможно, это пришедший не по порядку ES → ненадолго подождать обновления набора тегов - Возможно, это атака повторного воспроизведения (replay-атака) → отклонить - Возможно, данные повреждены → отклонить\nПустая полезная нагрузка:\nСообщения ES могут иметь пустую полезную нагрузку (0 байт): - Служит явным ACK (подтверждение получения) при получении ACK Request (запрос подтверждения) - Обеспечивает ответ на уровне протокола без данных приложения - Всё равно расходует session tag (тег сеанса) - Полезно, когда вышележащему уровню нечего немедленно отправлять\nСвойства безопасности: - Полная прямая секретность (уровень 5) после получения NSR - Аутентифицированное шифрование посредством AEAD (аутентифицированное шифрование с дополнительными данными) - Тег используется в качестве дополнительных ассоциированных данных - Максимум 65535 сообщений на tagset (набор тегов) до необходимости ratchet (механизма пошагового обновления ключей)\nФункции деривации ключей В этом разделе описаны все операции KDF (функции деривации ключа), используемые в ECIES, и приводятся полные криптографические выводы.\nОбозначения и константы Константы: - ZEROLEN - Байтовый массив нулевой длины (пустая строка) - || - Оператор конкатенации\nПеременные: - h - Текущий хэш стенограммы обмена (32 байта) - chainKey - Ключ сцепления для HKDF (32 байта) - k - Ключ симметричного шифра (32 байта) - n - Nonce (одноразовое значение) / номер сообщения\nКлючи: - ask / apk - статический закрытый/открытый ключ Алисы - aesk / aepk - эфемерный закрытый/открытый ключ Алисы - bsk / bpk - статический закрытый/открытый ключ Боба - besk / bepk - эфемерный закрытый/открытый ключ Боба\nФункции выработки ключей для сообщений NS KDF 1: начальный ключ цепочки Выполняется один раз при инициализации протокола (может быть предварительно вычислено):\n# Protocol name (40 bytes, ASCII, no null termination) protocol_name = \u0026#34;Noise_IKelg2+hs2_25519_ChaChaPoly_SHA256\u0026#34; # Initialize hash h = SHA256(protocol_name) # Initialize chaining key chainKey = h # MixHash with empty prologue h = SHA256(h) # State: chainKey and h initialized # Can be precalculated for all outbound sessions Результат: - chainKey = Начальный цепной ключ для всех последующих KDF (функций выработки ключей) - h = Начальный хэш-транскрипт\nKDF 2: Смешивание статического ключа Боба Боб выполняет это один раз (может быть предварительно вычислено для всех входящих сеансов):\n# Bob\u0026#39;s static keys (published in LeaseSet) bsk = GENERATE_PRIVATE() bpk = DERIVE_PUBLIC(bsk) # Mix Bob\u0026#39;s public key into hash h = SHA256(h || bpk) # State: h updated with Bob\u0026#39;s identity # Can be precalculated by Bob for all inbound sessions KDF 3: Генерация эфемерного ключа Алисы Алиса генерирует новые ключи для каждого сообщения NS:\n# Generate ephemeral key pair suitable for Elligator2 aesk = GENERATE_PRIVATE_ELG2() aepk = DERIVE_PUBLIC(aesk) # Mix ephemeral public key into hash h = SHA256(h || aepk) # Elligator2 encode for transmission elg2_aepk = ENCODE_ELG2(aepk) # State: h updated with Alice\u0026#39;s ephemeral key # Send elg2_aepk as first 32 bytes of NS message KDF 4: Раздел статического ключа NS (es DH — временно-статический Диффи‑Хеллман) Выводит ключи для шифрования статического ключа Алисы:\n# Perform first DH (ephemeral-static) sharedSecret = DH(aesk, bpk) # Alice computes # Equivalent: sharedSecret = DH(bsk, aepk) # Bob computes # Derive cipher key from shared secret keydata = HKDF(chainKey, sharedSecret, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k = keydata[32:63] # AEAD encryption parameters nonce = 0 associated_data = h # Current hash transcript # Encrypt static key section if binding_requested: plaintext = apk # Alice\u0026#39;s static public key (32 bytes) else: plaintext = bytes(32) # All zeros for unbound ciphertext = ENCRYPT(k, nonce, plaintext, associated_data) # ciphertext = 32 bytes encrypted + 16 bytes MAC = 48 bytes # Mix ciphertext into hash h = SHA256(h || ciphertext) # State: Static key section encrypted, h updated # Send ciphertext (48 bytes) as next part of NS message KDF 5: Секция полезной нагрузки NS (ss DH, только с привязкой) Для привязанных сеансов выполните второй обмен ключами Диффи — Хеллмана для шифрования полезной нагрузки:\nif binding_requested: # Alice\u0026#39;s static keys ask = GENERATE_PRIVATE() # Alice\u0026#39;s long-term key apk = DERIVE_PUBLIC(ask) # Perform second DH (static-static) sharedSecret = DH(ask, bpk) # Alice computes # Equivalent: sharedSecret = DH(bsk, apk) # Bob computes # Derive cipher key keydata = HKDF(chainKey, sharedSecret, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k = keydata[32:63] nonce = 0 associated_data = h else: # Unbound: reuse keys from static key section # chainKey and k unchanged nonce = 1 # Increment nonce (reusing same key) associated_data = h # Encrypt payload payload = build_payload() # DateTime + Garlic Cloves + etc. ciphertext = ENCRYPT(k, nonce, payload, associated_data) # Mix ciphertext into hash h = SHA256(h || ciphertext) # State: Payload encrypted, h contains complete NS transcript # Save chainKey and h for NSR processing # Send ciphertext as final part of NS message Важные примечания:\nBound vs Unbound (связанное против несвязанного):\nBound выполняет 2 операции DH (es + ss) Unbound выполняет 1 операцию DH (только es) Unbound увеличивает nonce (одноразовое число) вместо выведения нового ключа Безопасность при повторном использовании ключей:\nРазные nonces (одноразовые значения) (0 против 1) предотвращают повторное использование ключа/nonce Разные associated data (ассоциированные данные) (h отличается) обеспечивают domain separation (разделение доменов) Хеширование транскрипта:\nh теперь содержит: protocol_name, пустой пролог, bpk, aepk, static_key_ciphertext, payload_ciphertext Этот транскрипт связывает воедино все части сообщения NS KDF для набора тегов ответа NSR Боб генерирует теги для сообщений NSR:\n# Chain key from NS payload section # chainKey = final chainKey from NS KDF # Generate tagset key tagsetKey = HKDF(chainKey, ZEROLEN, \u0026#34;SessionReplyTags\u0026#34;, 32) # Initialize NSR tagset (see DH_INITIALIZE below) tagset_nsr = DH_INITIALIZE(chainKey, tagsetKey) # Get tag for this NSR tagsetEntry = tagset_nsr.GET_NEXT_ENTRY() tag = tagsetEntry.SESSION_TAG # 8 bytes # State: tag available for NSR message # Send tag as first 8 bytes of NSR Функции выработки ключей для сообщений NSR KDF 6: Генерация эфемерного ключа NSR Боб генерирует новый эфемерный ключ для каждого NSR (технический термин без устоявшегося перевода):\n# Mix tag into hash (I2P extension to Noise) h = SHA256(h || tag) # Generate ephemeral key pair besk = GENERATE_PRIVATE_ELG2() bepk = DERIVE_PUBLIC(besk) # Mix ephemeral public key into hash h = SHA256(h || bepk) # Elligator2 encode for transmission elg2_bepk = ENCODE_ELG2(bepk) # State: h updated with tag and Bob\u0026#39;s ephemeral key # Send elg2_bepk as bytes 9-40 of NSR message KDF 7: Секция ключей NSR (ee и se DH) Выводит ключи для секции ключей NSR:\n# Perform third DH (ephemeral-ephemeral) sharedSecret_ee = DH(aesk, bepk) # Alice computes # Equivalent: sharedSecret_ee = DH(besk, aepk) # Bob computes # Mix ee into chain keydata = HKDF(chainKey, sharedSecret_ee, \u0026#34;\u0026#34;, 32) chainKey = keydata[0:31] # Perform fourth DH (static-ephemeral) sharedSecret_se = DH(ask, bepk) # Alice computes # Equivalent: sharedSecret_se = DH(besk, apk) # Bob computes # Derive cipher key from se keydata = HKDF(chainKey, sharedSecret_se, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k = keydata[32:63] # AEAD encryption of empty data (key section has no payload) nonce = 0 associated_data = h ciphertext = ENCRYPT(k, nonce, ZEROLEN, associated_data) # ciphertext = 16 bytes (MAC only, no plaintext) # Mix ciphertext into hash h = SHA256(h || ciphertext) # State: Key section encrypted, chainKey contains all 4 DH results # Send ciphertext (16 bytes MAC) as bytes 41-56 of NSR Критично: На этом завершается Noise IK handshake (рукопожатие протокола Noise по схеме IK). chainKey теперь содержит результаты всех 4 операций DH (es, ss, ee, se).\nKDF 8: раздел полезной нагрузки NSR Выводит ключи для шифрования полезной нагрузки NSR:\n# Split chainKey into bidirectional keys keydata = HKDF(chainKey, ZEROLEN, \u0026#34;\u0026#34;, 64) k_ab = keydata[0:31] # Alice → Bob key k_ba = keydata[32:63] # Bob → Alice key # Initialize ES tagsets for both directions tagset_ab = DH_INITIALIZE(chainKey, k_ab) # Alice → Bob tagset_ba = DH_INITIALIZE(chainKey, k_ba) # Bob → Alice # Derive NSR payload key (Bob → Alice) k_nsr = HKDF(k_ba, ZEROLEN, \u0026#34;AttachPayloadKDF\u0026#34;, 32) # Encrypt NSR payload nonce = 0 associated_data = h # Binds payload to entire NSR payload = build_payload() # Usually application reply ciphertext = ENCRYPT(k_nsr, nonce, payload, associated_data) # State: Bidirectional ES sessions established # tagset_ab and tagset_ba ready for ES messages # Send ciphertext as bytes 57+ of NSR message Важные примечания:\nОперация разделения:\nСоздает независимые ключи для каждого направления Предотвращает повторное использование ключей между направлениями Alice→Bob и Bob→Alice Привязка полезной нагрузки NSR:\nИспользует h как ассоциированные данные, чтобы связать полезную нагрузку с рукопожатием Отдельный KDF (\u0026ldquo;AttachPayloadKDF\u0026rdquo;) обеспечивает разделение доменов Готовность ES:\nПосле NSR обе стороны могут отправлять сообщения ES Алиса должна получить NSR перед отправкой ES Боб должен получить ES перед отправкой ES KDF (функции выработки ключей) для сообщений ES Сообщения ES используют предварительно сгенерированные сеансовые ключи из наборов тегов:\n# Sender gets next tag and key tagsetEntry = outbound_tagset.GET_NEXT_ENTRY() tag = tagsetEntry.SESSION_TAG # 8 bytes k = tagsetEntry.SESSION_KEY # 32 bytes N = tagsetEntry.INDEX # Message number # Construct nonce (12 bytes) nonce = [0x00, 0x00, 0x00, 0x00] + little_endian_8_bytes(N) # AEAD encryption associated_data = tag # Tag is associated data payload = build_payload() ciphertext = ENCRYPT(k, nonce, payload, associated_data) # Send: tag || ciphertext (8 + len(ciphertext) bytes) Процесс получателя:\n# Extract tag tag = message[0:8] # Look up tag in inbound tagsets tagsetEntry = inbound_tagset.GET_SESSION_KEY(tag) if tagsetEntry is None: # Not an ES message, try NS/NSR decryption return try_handshake_decryption(message) k = tagsetEntry.SESSION_KEY N = tagsetEntry.INDEX # Construct nonce nonce = [0x00, 0x00, 0x00, 0x00] + little_endian_8_bytes(N) # AEAD decryption associated_data = tag ciphertext = message[8:] try: payload = DECRYPT(k, nonce, ciphertext, associated_data) except AuthenticationError: # MAC verification failed, reject message return reject_message() # Process payload blocks process_payload(payload) # Remove tag from tagset (one-time use) inbound_tagset.remove(tag) Функция DH_INITIALIZE Создаёт набор тегов для одного направления:\ndef DH_INITIALIZE(rootKey, k): \u0026#34;\u0026#34;\u0026#34; Initializes a tagset with session tag and symmetric key ratchets. Args: rootKey: Chain key from previous DH ratchet (32 bytes) k: Key material from split() or DH ratchet (32 bytes) Returns: tagset: Initialized tagset object \u0026#34;\u0026#34;\u0026#34; # Derive next root key and chain key keydata = HKDF(rootKey, k, \u0026#34;KDFDHRatchetStep\u0026#34;, 64) nextRootKey = keydata[0:31] chainKey_tagset = keydata[32:63] # Derive separate chain keys for tags and keys keydata = HKDF(chainKey_tagset, ZEROLEN, \u0026#34;TagAndKeyGenKeys\u0026#34;, 64) sessTag_ck = keydata[0:31] # Session tag chain key symmKey_ck = keydata[32:63] # Symmetric key chain key # Create tagset object tagset = Tagset() tagset.nextRootKey = nextRootKey tagset.sessTag_chainKey = sessTag_ck tagset.symmKey_chainKey = symmKey_ck tagset.lastIndex = -1 return tagset Контексты использования:\nНабор тегов NSR: DH_INITIALIZE(chainKey_from_NS, tagsetKey_NSR) Наборы тегов ES: DH_INITIALIZE(chainKey_from_NSR, k_ab or k_ba) Наборы тегов с храповым механизмом: DH_INITIALIZE(nextRootKey_from_previous, tagsetKey_from_DH) Храповые механизмы ECIES использует три синхронизированных механизма ratchet (криптографическая «трещотка») для обеспечения прямой секретности и эффективного управления сессиями.\nОбзор Ratchet (механизма последовательного обновления ключей) Три типа Ratchet (криптографический механизм последовательного обновления ключей):\nDH Ratchet: Выполняет обмен ключами Диффи-Хеллмана для генерации новых корневых ключей (Ratchet — механизм последовательного обновления ключей) Session Tag Ratchet: Детерминированно выводит одноразовые метки сеанса Symmetric Key Ratchet: Выводит ключи сеанса для шифрования сообщений Связь:\nDH Ratchet (periodic) ↓ Creates new tagset ↓ Session Tag Ratchet (per message) ← synchronized → Symmetric Key Ratchet (per message) ↓ ↓ Session Tags (8 bytes each) Session Keys (32 bytes each) Ключевые свойства:\nОтправитель: Генерирует теги и ключи по требованию (хранение не требуется) Получатель: Предварительно генерирует теги для окна опережения (требуется хранение) Синхронизация: Индекс тега определяет индекс ключа (N_tag = N_key) Прямая секретность: Достигается посредством периодического DH ratchet (механизм обновления ключей на основе Диффи—Хеллмана) Эффективность: Получатель может отложить вычисление ключа до получения тега Трещотка Диффи — Хеллмана DH ratchet (механизм ратчета Диффи—Хеллмана) обеспечивает прямую секретность путем периодического обмена новыми эфемерными ключами.\nЧастота DH-ратчета Обязательные условия для Ratchet (механизма криптографического обновления ключей): - Набор тегов приближается к исчерпанию (максимальный тег — 65535) - Политики, зависящие от реализации: - Порог по количеству сообщений (например, каждые 4096 сообщений) - Порог по времени (например, каждые 10 минут) - Порог по объёму данных (например, каждые 100 МБ)\nРекомендуемый первый ратчет: Около номера тега 4096, чтобы не достичь лимита\nМаксимальные значения: - Максимальный идентификатор набора тегов: 65535 - Максимальный идентификатор ключа: 32767 - Максимальное число сообщений на один набор тегов: 65535 - Теоретический максимальный объём данных на сессию: ~6.9 TB (64K наборов тегов × 64K сообщений × 1730 байт в среднем)\nИдентификаторы тегов и ключей DH Ratchet (механизм ратчета на основе Диффи—Хеллмана) Начальный набор тегов (после рукопожатия): - Идентификатор набора тегов: 0 - Блоки NextKey ещё не отправлялись - Идентификаторы ключей не назначены\nПосле первой трещотки: - ID набора тегов: 1 = (1 + ID ключа Алисы + ID ключа Боба) = (1 + 0 + 0) - Алиса отправляет NextKey с ID ключа 0 - Боб отвечает сообщением NextKey с ID ключа 0\nПоследующие наборы тегов: - ID набора тегов = 1 + ID ключа отправителя + ID ключа получателя - Пример: Набор тегов 5 = (1 + sender_key_2 + receiver_key_2)\nТаблица эволюции набора тегов:\nTag Set ID Sender Key ID Receiver Key ID Notes 0 n/a n/a Initial tag set (post-NSR) 1 0 * 0 * First ratchet (both generate new keys) 2 1 * 0 Sender generates new key 3 1 1 * Receiver generates new key 4 2 * 1 Sender generates new key 5 2 2 * Receiver generates new key ... ... ... Pattern repeats 65534 32767 * 32766 Second-to-last tag set 65535 32767 32767 * Final tag set \\* = Новый ключ, сгенерированный этим ratchet (криптографический механизм смены ключей) Правила идентификаторов ключей: - Идентификаторы идут последовательно, начиная с 0 - Идентификаторы увеличиваются только при генерации нового ключа - Максимальный идентификатор ключа — 32767 (15 бит) - После идентификатора ключа 32767 требуется новый сеанс\nПоследовательность обмена сообщениями в DH Ratchet (криптографический храповик Диффи — Хеллмана) Роли: - Отправитель тегов: Владеет набором исходящих тегов, отправляет сообщения - Получатель тегов: Владеет набором входящих тегов, принимает сообщения\nШаблон: Отправитель тегов инициирует ratchet (механизм последовательного обновления ключей), когда набор тегов почти исчерпан.\nДиаграмма потока сообщений:\nTag Sender Tag Receiver ... using tag set #0 ... (Tag set #0 approaching exhaustion) (Generate new key #0) NextKey forward, request reverse, with key #0 --------\u0026gt; (Repeat until NextKey ACK received) (Generate new key #0) (Perform DH: sender_key_0 × receiver_key_0) (Create inbound tag set #1) \u0026lt;--------------- NextKey reverse, with key #0 (Repeat until tag from tag set #1 received) (Receive NextKey with key #0) (Perform DH: sender_key_0 × receiver_key_0) (Create outbound tag set #1) ... using tag set #1 ... (Tag set #1 approaching exhaustion) (Generate new key #1) NextKey forward, with key #1 --------\u0026gt; (Repeat until NextKey ACK received) (Reuse existing key #0) (Perform DH: sender_key_1 × receiver_key_0) (Create inbound tag set #2) \u0026lt;-------------- NextKey reverse, id 0 (ACK) (Repeat until tag from tag set #2 received) (Receive NextKey with id 0) (Perform DH: sender_key_1 × receiver_key_0) (Create outbound tag set #2) ... using tag set #2 ... (Tag set #2 approaching exhaustion) (Reuse existing key #1) NextKey forward, request reverse, id 1 --------\u0026gt; (Repeat until NextKey received) (Generate new key #1) (Perform DH: sender_key_1 × receiver_key_1) (Create inbound tag set #3) \u0026lt;-------------- NextKey reverse, with key #1 (Receive NextKey with key #1) (Perform DH: sender_key_1 × receiver_key_1) (Create outbound tag set #3) ... using tag set #3 ... (Pattern repeats: even-numbered tag sets use forward key, odd-numbered use reverse key) Шаблоны Ratchet (механизм обновления ключей):\nСоздание наборов тегов с чётными номерами (2, 4, 6, \u0026hellip;): 1. Отправитель создаёт новый ключ 2. Отправитель отправляет блок NextKey с новым ключом 3. Получатель отправляет блок NextKey со старым идентификатором ключа (ACK, подтверждение) 4. Оба выполняют DH (Диффи-Хеллман) с использованием (нового ключа отправителя × старого ключа получателя)\nСоздание наборов тегов с нечётными номерами (3, 5, 7, \u0026hellip;): 1. Отправитель запрашивает обратный ключ (отправляет NextKey с флагом запроса) 2. Получатель генерирует новый ключ 3. Получатель отправляет блок NextKey с новым ключом 4. Обе стороны выполняют DH (Диффи-Хеллмана) с (старый ключ отправителя × новый ключ получателя)\nФормат блока NextKey См. раздел Payload Format для подробной спецификации блока NextKey.\nКлючевые элементы: - Байт флагов: - Бит 0: Ключ присутствует (1) или только ID (0) - Бит 1: Обратный ключ (1) или прямой ключ (0) - Бит 2: Запросить обратный ключ (1) или без запроса (0) - ID ключа: 2 байта, big-endian (0-32767) - Публичный ключ: 32 байта X25519 (если бит 0 = 1)\nПример блоков NextKey:\n# Sender initiates ratchet with new key (key ID 0, tag set 1) NextKey(flags=0x01, key_id=0, pubkey=sender_key_0) # Receiver replies with new key (key ID 0, tag set 1) NextKey(flags=0x03, key_id=0, pubkey=receiver_key_0) # Sender ratchets again with new key (key ID 1, tag set 2) NextKey(flags=0x01, key_id=1, pubkey=sender_key_1) # Receiver ACKs with old key ID (tag set 2) NextKey(flags=0x02, key_id=0) # Sender requests reverse key (tag set 3) NextKey(flags=0x04, key_id=1) # Receiver sends new reverse key (key ID 1, tag set 3) NextKey(flags=0x03, key_id=1, pubkey=receiver_key_1) KDF для DH-ратчета При обмене новыми ключами:\n# Tag sender generates or reuses key if generating_new: sender_sk = GENERATE_PRIVATE() sender_pk = DERIVE_PUBLIC(sender_sk) else: # Reuse existing key pair sender_pk = existing_sender_pk # Tag receiver generates or reuses key if generating_new: receiver_sk = GENERATE_PRIVATE() receiver_pk = DERIVE_PUBLIC(receiver_sk) else: # Reuse existing key pair receiver_pk = existing_receiver_pk # Both parties perform DH sharedSecret = DH(sender_sk, receiver_pk) # Derive tagset key tagsetKey = HKDF(sharedSecret, ZEROLEN, \u0026#34;XDHRatchetTagSet\u0026#34;, 32) # Get next root key from previous tagset rootKey = previous_tagset.nextRootKey # Initialize new tagset new_tagset = DH_INITIALIZE(rootKey, tagsetKey) # Tag sender: outbound tagset # Tag receiver: inbound tagset Критические временные требования:\nОтправитель тегов: - Немедленно создаёт новый исходящий набор тегов - Немедленно начинает использовать новые теги - Удаляет старый исходящий набор тегов\nПолучатель тегов: - Создает новый набор входящих тегов - Сохраняет старый набор входящих тегов в течение льготного периода (3 минуты) - Принимает теги из обоих наборов — старого и нового — в течение льготного периода - Удаляет старый набор входящих тегов по окончании льготного периода\nУправление состоянием DH-ратчета Состояние отправителя: - Текущий исходящий набор тегов - ID набора тегов и ID ключей - Следующий корневой ключ (для следующего ratchet (криптографический ратчет)) - Количество сообщений в текущем наборе тегов\nСостояние получателя: - Текущий входящий набор тегов (в льготный период их может быть два) - Номера предыдущих сообщений (PN) для обнаружения пропусков - Окно упреждения предварительно сгенерированных тегов - Следующий корневой ключ (для следующего ratchet (криптографический ратчет))\nПравила переходов состояний:\nДо первого Ratchet (криптографический механизм эволюции ключей):\nИспользуется набор тегов 0 (из NSR) Идентификаторы ключей не назначены Инициация Ratchet (механизм пошагового обновления ключей):\nСгенерировать новый ключ (если в этом раунде ключ генерирует отправитель) Отправить блок NextKey (блок «следующего» ключа) в ES message (сообщение ES) Дождаться ответа NextKey перед созданием нового исходящего набора тегов Получение запроса Ratchet (механизма поэтапного обновления ключей):\nСгенерировать новый ключ (если в этом раунде ключ генерирует получатель) Выполнить DH с полученным ключом Создать новый набор входящих тегов Отправить ответ NextKey Сохранить старый набор входящих тегов на переходный период Завершение Ratchet (криптографического механизма обновления ключей):\nПолучить ответ NextKey Выполнить DH (обмен Диффи—Хеллмана) Создать новый исходящий набор тегов Начать использовать новые теги Session Tag Ratchet (трещоточный механизм для меток сеанса) Ратчет сеансовых тегов детерминированным образом генерирует одноразовые сеансовые теги длиной 8 байт.\nНазначение Session Tag Ratchet (криптографическая трещотка) Заменяет явную передачу тегов (ElGamal отправлял 32-байтные теги) Позволяет получателю предварительно генерировать теги для окна упреждения Отправитель генерирует по мере необходимости (хранение не требуется) Синхронизируется с ratchet (механизм последовательного обновления ключей) симметричного ключа по индексу Формула ратчета тегов сеанса Инициализация:\n# From DH_INITIALIZE sessTag_ck = initial_chain_key # 32 bytes # Initialize session tag ratchet keydata = HKDF(sessTag_ck, ZEROLEN, \u0026#34;STInitialization\u0026#34;, 64) sessTag_chainKey = keydata[0:31] # First chain key SESSTAG_CONSTANT = keydata[32:63] # Constant for all tags in this tagset Генерация тега (для тега N):\n# Generate tag N keydata = HKDF(sessTag_chainKey_(N-1), SESSTAG_CONSTANT, \u0026#34;SessionTagKeyGen\u0026#34;, 64) sessTag_chainKey_N = keydata[0:31] # Chain key for next tag tag_N = keydata[32:39] # Session tag (8 bytes) # Chain continues for each tag # tag_0, tag_1, tag_2, ..., tag_65535 Полная последовательность:\n# Tag 0 keydata_0 = HKDF(sessTag_chainKey, SESSTAG_CONSTANT, \u0026#34;SessionTagKeyGen\u0026#34;, 64) sessTag_chainKey_0 = keydata_0[0:31] tag_0 = keydata_0[32:39] # Tag 1 keydata_1 = HKDF(sessTag_chainKey_0, SESSTAG_CONSTANT, \u0026#34;SessionTagKeyGen\u0026#34;, 64) sessTag_chainKey_1 = keydata_1[0:31] tag_1 = keydata_1[32:39] # Tag N keydata_N = HKDF(sessTag_chainKey_(N-1), SESSTAG_CONSTANT, \u0026#34;SessionTagKeyGen\u0026#34;, 64) sessTag_chainKey_N = keydata_N[0:31] tag_N = keydata_N[32:39] Реализация отправителя Session Tag Ratchet (ratchet — механизм последовательного обновления) class OutboundTagset: def __init__(self, sessTag_ck): # Initialize keydata = HKDF(sessTag_ck, ZEROLEN, \u0026#34;STInitialization\u0026#34;, 64) self.chainKey = keydata[0:31] self.constant = keydata[32:63] self.index = -1 def get_next_tag(self): # Increment index self.index += 1 if self.index \u0026gt; 65535: raise TagsetExhausted(\u0026#34;Ratchet required\u0026#34;) # Generate tag keydata = HKDF(self.chainKey, self.constant, \u0026#34;SessionTagKeyGen\u0026#34;, 64) self.chainKey = keydata[0:31] tag = keydata[32:39] return (tag, self.index) Процесс отправителя: 1. Вызовите get_next_tag() для каждого сообщения 2. Используйте возвращённый тег в сообщении ES 3. Сохраните индекс N для возможного отслеживания ACK (подтверждений) 4. Хранение тегов не требуется (генерируются по запросу)\nРеализация получателя Session Tag Ratchet (механизма ратчета меток сеанса) class InboundTagset: def __init__(self, sessTag_ck, look_ahead=32): # Initialize keydata = HKDF(sessTag_ck, ZEROLEN, \u0026#34;STInitialization\u0026#34;, 64) self.chainKey = keydata[0:31] self.constant = keydata[32:63] self.index = -1 self.look_ahead = look_ahead self.tags = {} # Dictionary: tag -\u0026gt; index # Pre-generate initial tags self.extend(look_ahead) def extend(self, count): \u0026#34;\u0026#34;\u0026#34;Generate \u0026#39;count\u0026#39; more tags\u0026#34;\u0026#34;\u0026#34; for _ in range(count): self.index += 1 if self.index \u0026gt; 65535: return # Cannot exceed maximum # Generate tag keydata = HKDF(self.chainKey, self.constant, \u0026#34;SessionTagKeyGen\u0026#34;, 64) self.chainKey = keydata[0:31] tag = keydata[32:39] # Store tag self.tags[tag] = self.index def lookup_tag(self, tag): \u0026#34;\u0026#34;\u0026#34;Look up tag and return index\u0026#34;\u0026#34;\u0026#34; if tag in self.tags: index = self.tags[tag] # Remove tag (one-time use) del self.tags[tag] return index return None def check_and_extend(self): \u0026#34;\u0026#34;\u0026#34;Extend if tag count is low\u0026#34;\u0026#34;\u0026#34; current_count = len(self.tags) if current_count \u0026lt; self.look_ahead // 2: # Extend to restore window self.extend(self.look_ahead - current_count) Процесс получателя: 1. Предварительно сгенерировать теги для окна упреждения (например, 32 тега) 2. Сохранить теги в хеш-таблице или словаре 3. При получении сообщения выполнить поиск тега, чтобы получить индекс N 4. Удалить тег из хранилища (одноразовое использование) 5. Расширить окно, если число тегов падает ниже порога\nСтратегия упреждающей подготовки сеансовых тегов Цель: баланс между использованием памяти и обработкой сообщений, приходящих не по порядку\nРекомендуемые размеры просмотра вперёд:\nTagset Type Initial Size Maximum Size Notes NSR tagset 12 12 Short-lived ES tagset 0 24 160 Initial ES tagset ES tagset 1+ 160 160 Ratcheted tagsets **Адаптивный просмотр вперёд:** # Dynamic look-ahead based on highest tag received look_ahead = min(tsmax, tsmin + N // 4) # Example: # tsmin = 24, tsmax = 160 # N = 0: look_ahead = min(160, 24 + 0/4) = 24 # N = 100: look_ahead = min(160, 24 + 100/4) = 49 # N = 500: look_ahead = min(160, 24 + 500/4) = 149 # N = 544: look_ahead = min(160, 24 + 544/4) = 160 Обрезать позади:\n# Trim tags far behind highest received trim_behind = look_ahead // 2 # If highest received tag is N=100, trim tags below N=50 Расчёт памяти:\n# Per tag: 8 bytes (tag) + 2 bytes (index) + overhead ≈ 16 bytes # Look-ahead of 160 tags ≈ 2.5 KB per inbound tagset # With multiple sessions: # 100 inbound sessions × 2.5 KB = 250 KB total Обработка сеансовых тегов, полученных не по порядку Сценарий: Сообщения приходят не по порядку\nExpected: tag_5, tag_6, tag_7, tag_8 Received: tag_5, tag_7, tag_6, tag_8 Поведение получателя:\nПолучение tag_5:\nПоиск: найден по индексу 5 Обработать сообщение Удалить tag_5 Наибольший принятый: 5 Получить tag_7 (не по порядку):\nПоиск: найден по индексу 7 Обработать сообщение Удалить tag_7 Наибольший полученный номер: 7 Примечание: tag_6 всё ещё в хранилище (ещё не получен) Получение tag_6 (с задержкой):\nПоиск: найден по индексу 6 Обработать сообщение Удалить tag_6 Максимальный принятый: 7 (без изменений) Получаем tag_8:\nПоиск: найден по индексу 8 Обработать сообщение Удалить tag_8 Наибольший полученный индекс: 8 Обслуживание окна: - Отслеживать наибольший полученный индекс - Вести список отсутствующих индексов (разрывы) - Расширять окно исходя из наибольшего индекса - Необязательно: удалять старые разрывы по истечении тайм-аута\nТрещотка симметричных ключей symmetric key ratchet (механизм храповика для симметричных ключей) генерирует 32-байтные ключи шифрования, синхронизированные с тегами сеанса.\nНазначение симметричного ключевого ратчета Обеспечивает уникальный ключ шифрования для каждого сообщения Синхронизирован с session tag ratchet (механизм ратчета тегов сессии; тот же индекс) Отправитель может генерировать по требованию Получатель может отложить генерацию до получения тега Формула Symmetric Key Ratchet (механизм пошагового обновления симметричных ключей) Инициализация:\n# From DH_INITIALIZE symmKey_ck = initial_chain_key # 32 bytes # No additional initialization needed # Unlike session tag ratchet, no constant is derived Генерация ключа (для N-го ключа):\n# Generate key N SYMMKEY_CONSTANT = ZEROLEN # Empty string keydata = HKDF(symmKey_chainKey_(N-1), SYMMKEY_CONSTANT, \u0026#34;SymmetricRatchet\u0026#34;, 64) symmKey_chainKey_N = keydata[0:31] # Chain key for next key key_N = keydata[32:63] # Session key (32 bytes) Полная последовательность:\n# Key 0 keydata_0 = HKDF(symmKey_ck, ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) symmKey_chainKey_0 = keydata_0[0:31] key_0 = keydata_0[32:63] # Key 1 keydata_1 = HKDF(symmKey_chainKey_0, ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) symmKey_chainKey_1 = keydata_1[0:31] key_1 = keydata_1[32:63] # Key N keydata_N = HKDF(symmKey_chainKey_(N-1), ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) symmKey_chainKey_N = keydata_N[0:31] key_N = keydata_N[32:63] Реализация отправителя симметричного ключевого ратчета class OutboundKeyRatchet: def __init__(self, symmKey_ck): self.chainKey = symmKey_ck self.index = -1 def get_key(self, index): \u0026#34;\u0026#34;\u0026#34;Generate key for specific index\u0026#34;\u0026#34;\u0026#34; # Fast-forward to desired index if needed while self.index \u0026lt; index: self.index += 1 keydata = HKDF(self.chainKey, ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) self.chainKey = keydata[0:31] if self.index == index: return keydata[32:63] # Should not reach here if called correctly raise ValueError(\u0026#34;Key already generated\u0026#34;) Процесс отправителя: 1. Получить следующий тег и его индекс N 2. Сгенерировать ключ для индекса N 3. Использовать ключ для шифрования сообщения 4. Хранение ключа не требуется\nРеализация получателя симметрического ключевого ратчета Стратегия 1: Отложенная генерация (рекомендуется)\nclass InboundKeyRatchet: def __init__(self, symmKey_ck): self.chainKey = symmKey_ck self.index = -1 self.cache = {} # Optional: cache recently used keys def get_key(self, index): \u0026#34;\u0026#34;\u0026#34;Generate key for specific index\u0026#34;\u0026#34;\u0026#34; # Check cache first (optional optimization) if index in self.cache: key = self.cache[index] del self.cache[index] return key # Fast-forward to desired index while self.index \u0026lt; index: self.index += 1 keydata = HKDF(self.chainKey, ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) self.chainKey = keydata[0:31] if self.index == index: return keydata[32:63] raise ValueError(\u0026#34;Index already passed\u0026#34;) Процесс отложенной генерации: 1. Получить сообщение ES с тегом 2. Найти тег, чтобы получить индекс N 3. Сгенерировать ключи с 0 по N (если еще не сгенерированы) 4. Использовать ключ N для расшифровки сообщения 5. Цепной ключ теперь находится на индексе N\nПреимущества: - Минимальное использование памяти - Ключи генерируются только при необходимости - Простая реализация\nНедостатки: - Необходимо сгенерировать все ключи от 0 до N при первом использовании - Невозможно обрабатывать сообщения, пришедшие не по порядку, без кэширования\nСтратегия 2: Предварительная генерация с Tag Window (окно тегов) (альтернативный вариант)\nclass InboundKeyRatchet: def __init__(self, symmKey_ck): self.chainKey = symmKey_ck self.index = -1 self.keys = {} # Dictionary: index -\u0026gt; key def extend(self, count): \u0026#34;\u0026#34;\u0026#34;Pre-generate \u0026#39;count\u0026#39; more keys\u0026#34;\u0026#34;\u0026#34; for _ in range(count): self.index += 1 keydata = HKDF(self.chainKey, ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) self.chainKey = keydata[0:31] key = keydata[32:63] self.keys[self.index] = key def get_key(self, index): \u0026#34;\u0026#34;\u0026#34;Retrieve pre-generated key\u0026#34;\u0026#34;\u0026#34; if index in self.keys: key = self.keys[index] del self.keys[index] return key return None Процесс предварительной генерации: 1. Предварительно сгенерировать ключи, соответствующие окну тегов (например, 32 ключа) 2. Хранить ключи, индексированные по номеру сообщения 3. При получении тега найти соответствующий ключ 4. Расширять окно по мере использования тегов\nПреимущества: - Естественно обрабатывает сообщения, приходящие не по порядку - Быстрое получение ключа (без задержки на генерацию)\nНедостатки: - Более высокий расход памяти (32 байта на ключ против 8 байт на тег) - Необходимо поддерживать синхронизацию ключей с тегами\nСравнение памяти:\n# Look-ahead of 160: # Tags only: 160 × 16 bytes = 2.5 KB # Tags+Keys: 160 × (16 + 32) bytes = 7.5 KB # # For 100 sessions: # Tags only: 250 KB # Tags+Keys: 750 KB Синхронизация симметрического ратчета с метками сеанса Критическое требование: Индекс тега сессии ДОЛЖЕН быть равен индексу симметричного ключа\n# Sender tag, index = outbound_tagset.get_next_tag() key = outbound_keyratchet.get_key(index) # Same index nonce = construct_nonce(index) ciphertext = ENCRYPT(key, nonce, payload, tag) # Receiver index = inbound_tagset.lookup_tag(tag) key = inbound_keyratchet.get_key(index) # Same index nonce = construct_nonce(index) plaintext = DECRYPT(key, nonce, ciphertext, tag) Режимы отказа:\nЕсли нарушается синхронизация: - Использован неверный ключ для расшифрования - Проверка MAC не удалась - Сообщение отклонено\nПредотвращение: - Всегда используйте один и тот же индекс для тега и ключа - Никогда не пропускайте индексы ни в одном из ratchet (механизм пошагового обновления ключей) - Осторожно обрабатывайте сообщения, поступающие не по порядку\nФормирование одноразового значения (nonce) для Symmetric Ratchet (симметрического механизма трещотки) Nonce (одноразовое число) вычисляется из номера сообщения:\ndef construct_nonce(index): \u0026#34;\u0026#34;\u0026#34; Construct 12-byte nonce for ChaCha20-Poly1305 Args: index: Message number (0-65535) Returns: nonce: 12-byte nonce \u0026#34;\u0026#34;\u0026#34; # First 4 bytes are always zero nonce = bytearray(12) nonce[0:4] = b\u0026#39;\\x00\\x00\\x00\\x00\u0026#39; # Last 8 bytes are little-endian message number nonce[4:12] = index.to_bytes(8, byteorder=\u0026#39;little\u0026#39;) return bytes(nonce) Примеры:\nindex = 0: nonce = 0x00000000 0000000000000000 index = 1: nonce = 0x00000000 0100000000000000 index = 255: nonce = 0x00000000 FF00000000000000 index = 256: nonce = 0x00000000 0001000000000000 index = 65535: nonce = 0x00000000 FFFF000000000000 Важные свойства: - Одноразовые значения уникальны для каждого сообщения в наборе тегов - Одноразовые значения никогда не повторяются (это обеспечивается одноразовыми тегами) - 8-байтовый счетчик допускает 2^64 сообщений (мы используем только 2^16) - Формат одноразового значения соответствует конструкции на основе счетчика из RFC 7539\nУправление сеансами Контекст сеанса Все входящие и исходящие сессии должны принадлежать определённому контексту:\nКонтекст router: Сеансы для самого router Контекст Destination (назначение): Сеансы для конкретного локального Destination (клиентского приложения) Критическое правило: Сеансы НЕ ДОЛЖНЫ разделяться между контекстами для предотвращения корреляционных атак.\nРеализация:\nclass SessionKeyManager: \u0026#34;\u0026#34;\u0026#34;Context for managing sessions (router or destination)\u0026#34;\u0026#34;\u0026#34; def __init__(self, context_id): self.context_id = context_id self.inbound_sessions = {} # far_end_dest -\u0026gt; [sessions] self.outbound_sessions = {} # far_end_dest -\u0026gt; session self.static_keypair = generate_keypair() # Context\u0026#39;s identity def get_outbound_session(self, destination): \u0026#34;\u0026#34;\u0026#34;Get or create outbound session to destination\u0026#34;\u0026#34;\u0026#34; if destination not in self.outbound_sessions: self.outbound_sessions[destination] = create_outbound_session(destination) return self.outbound_sessions[destination] def add_inbound_session(self, session, destination=None): \u0026#34;\u0026#34;\u0026#34;Add inbound session, optionally bound to destination\u0026#34;\u0026#34;\u0026#34; if destination: if destination not in self.inbound_sessions: self.inbound_sessions[destination] = [] self.inbound_sessions[destination].append(session) else: # Unbound session self.inbound_sessions[None].append(session) Реализация I2P на Java:\nВ Java I2P, класс SessionKeyManager предоставляет эту функциональность: - Один SessionKeyManager на router - Один SessionKeyManager на локальный destination (адрес назначения) - Раздельное управление сеансами ECIES и ElGamal в каждом контексте\nПривязка сеанса Привязка связывает сеанс с конкретным удалённым адресатом.\nПривязанные сеансы Характеристики: - Включать статический ключ отправителя в сообщение NS - Получатель может идентифицировать destination (назначение) отправителя - Обеспечивает двунаправленную связь - Один исходящий сеанс на destination - Может иметь несколько входящих сеансов (во время переходов)\nСценарии использования: - Потоковые соединения (похожие на TCP) - repliable datagrams (датаграммы с возможностью ответа) - Любой протокол, требующий схемы запрос/ответ\nПроцесс привязки:\n# Alice creates bound outbound session outbound_session = OutboundSession( destination=bob_destination, static_key=alice_static_key, bound=True ) # Alice sends NS with static key ns_message = build_ns_message( ephemeral_key=alice_ephemeral_key, static_key=alice_static_key, # Included for binding payload=data ) # Bob receives NS bob_receives_ns(ns_message) # Bob extracts Alice\u0026#39;s static key alice_static_key = decrypt_static_key_section(ns_message) # Bob looks up Alice\u0026#39;s destination (from bundled LeaseSet) alice_destination = lookup_destination_by_static_key(alice_static_key) # Bob creates bound inbound session inbound_session = InboundSession( destination=alice_destination, bound=True ) # Bob pairs with outbound session outbound_session = OutboundSession( destination=alice_destination, bound=True ) Преимущества: 1. Эфемерный-эфемерный DH: Ответ использует ee DH (полная прямая секретность) 2. Непрерывность сеанса: Ratchets (механизм смены ключей) поддерживают привязку к тому же адресу назначения 3. Безопасность: Предотвращает перехват сессии (аутентификация по статическому ключу) 4. Эффективность: Одна сессия на адрес назначения (без дублирования)\nНепривязанные сеансы Характеристики: - Нет статического ключа в сообщении NS (раздел флагов состоит из одних нулей) - Получатель не может идентифицировать отправителя - Только односторонняя связь - Разрешены несколько сеансов к одному и тому же назначению\nСценарии использования: - Сырые дейтаграммы (fire-and-forget — без подтверждения доставки) - Анонимная публикация - Широковещательные сообщения\nСвойства: - Более анонимно (нет идентификации отправителя) - Более эффективно (1 DH (Диффи — Хеллман) против 2 DH при рукопожатии) - Ответы невозможны (получатель не знает, куда отвечать) - Без ратчета сеанса (однократное или ограниченное использование)\nСопряжение сеансов Сопряжение соединяет входящий сеанс с исходящим сеансом для двусторонней связи.\nСоздание сопряжённых сеансов Перспектива Алисы (инициатор):\n# Create outbound session to Bob outbound_session = create_outbound_session(bob_destination) # Create paired inbound session inbound_session = create_inbound_session( paired_with=outbound_session, bound_to=bob_destination ) # Link them outbound_session.paired_inbound = inbound_session inbound_session.paired_outbound = outbound_session # Send NS message send_ns_message(outbound_session, payload) Перспектива Боба (ответчик):\n# Receive NS message ns_message = receive_ns_message() # Create inbound session inbound_session = create_inbound_session_from_ns(ns_message) # If NS contains static key (bound): if ns_message.has_static_key(): alice_destination = extract_destination(ns_message) inbound_session.bind_to(alice_destination) # Create paired outbound session outbound_session = create_outbound_session(alice_destination) # Link them outbound_session.paired_inbound = inbound_session inbound_session.paired_outbound = outbound_session # Send NSR send_nsr_message(inbound_session, outbound_session, payload) Преимущества сопряжения сеансов In-band ACKs (подтверждения в том же канале): Могут подтверждать сообщения без отдельного clove (вложения внутри garlic message) Эффективное Ratcheting (пошаговое обновление ключей): Оба направления обновляют ключи совместно Управление потоком: Можно реализовать back-pressure (обратное давление: ограничение потока при перегрузке) между парными сессиями Согласованность состояния: Проще поддерживать синхронизированное состояние Правила сопряжения сессий Исходящий сеанс может быть несопряжённым (непривязанный NS (namespace — пространство имён)) Входящий сеанс для привязанного NS должен быть сопряжён Сопряжение происходит при создании сеанса, а не после Сопряжённые сеансы имеют одинаковую привязку к назначению Обновления ratchet (криптографический ратчет) происходят независимо, но согласованно Жизненный цикл сеанса Жизненный цикл сеанса: фаза создания Создание исходящей сессии (Алиса):\ndef create_outbound_session(destination, bound=True): session = OutboundSession() session.destination = destination session.bound = bound session.state = SessionState.NEW session.created_time = now() # Generate keys for NS message session.ephemeral_keypair = generate_elg2_keypair() if bound: session.static_key = context.static_keypair.public_key # Will be populated after NSR received session.outbound_tagset = None session.inbound_tagset = None return session Создание входящей сессии (Bob):\ndef create_inbound_session_from_ns(ns_message): session = InboundSession() session.state = SessionState.ESTABLISHED session.created_time = now() # Extract from NS session.remote_ephemeral_key = ns_message.ephemeral_key session.remote_static_key = ns_message.static_key if session.remote_static_key: session.bound = True session.destination = lookup_destination(session.remote_static_key) else: session.bound = False session.destination = None # Generate keys for NSR session.ephemeral_keypair = generate_elg2_keypair() # Create tagsets from KDF session.inbound_tagset = create_tagset_from_nsr() session.outbound_tagset = create_tagset_from_nsr() return session Жизненный цикл сеанса: активная фаза Переходы состояний:\nNEW (outbound only) ↓ NS sent ↓ PENDING_REPLY (outbound only) ↓ NSR received ↓ ESTABLISHED ↓ ES messages exchanged ↓ ESTABLISHED (ongoing) ↓ (optional) RATCHETING ↓ ESTABLISHED Поддержание активной сессии:\ndef maintain_active_session(session): # Update last activity time session.last_activity = now() # Check for ratchet needed if session.outbound_tagset.needs_ratchet(): initiate_ratchet(session) # Check for incoming ratchet if received_nextkey_block(): process_ratchet(session) # Trim old tags from inbound tagset session.inbound_tagset.expire_old_tags() # Check session health if session.idle_time() \u0026gt; SESSION_TIMEOUT: mark_session_idle(session) Жизненный цикл сеанса: фаза истечения срока действия Значения тайм-аутов сеанса:\nSession Type Sender Timeout Receiver Timeout Notes NSR tagset N/A 3 minutes Short-lived ES tagset 0 8 minutes 10 minutes Initial ES tagset 1+ 8 minutes 10 minutes Ratcheted Old tagset N/A 3 minutes After ratchet **Логика истечения срока действия:** def check_session_expiration(): for session in active_sessions: # Outbound session expiration (sender) if session.is_outbound(): if session.idle_time() \u0026gt; 8 * 60: # 8 minutes expire_outbound_session(session) # Inbound session expiration (receiver) else: if session.idle_time() \u0026gt; 10 * 60: # 10 minutes expire_inbound_session(session) # Old tagsets (after ratchet) for tagset in old_tagsets: if tagset.age() \u0026gt; 3 * 60: # 3 minutes delete_tagset(tagset) Критическое правило: срок действия исходящих сессий ДОЛЖЕН истекать раньше, чем у входящих, чтобы предотвратить рассинхронизацию.\nКорректное завершение:\ndef terminate_session(session, reason=0): # Send Termination block (if implemented) send_termination_block(session, reason) # Mark session for deletion session.state = SessionState.TERMINATED # Keep session briefly for final messages schedule_deletion(session, delay=30) # 30 seconds # Notify paired session if session.paired_session: session.paired_session.mark_remote_terminated() Несколько сообщений NS Сценарий: Сообщение NS (поиск в netDb) от Алисы потеряно или ответ NSR (ответ на поиск в netDb) потерян.\nПоведение Алисы:\nclass OutboundSession: def __init__(self): self.ns_messages_sent = [] self.ns_timer = None self.max_ns_attempts = 5 def send_ns_message(self, payload): # Generate new ephemeral key for each NS ephemeral_key = generate_elg2_keypair() ns_message = build_ns_message( ephemeral_key=ephemeral_key, static_key=self.static_key, payload=payload ) # Store state for this NS ns_state = { \u0026#39;ephemeral_key\u0026#39;: ephemeral_key, \u0026#39;chainkey\u0026#39;: compute_chainkey(ns_message), \u0026#39;hash\u0026#39;: compute_hash(ns_message), \u0026#39;tagset\u0026#39;: derive_nsr_tagset(ns_message), \u0026#39;sent_time\u0026#39;: now() } self.ns_messages_sent.append(ns_state) # Send message send_message(ns_message) # Set timer for retry if not self.ns_timer: self.ns_timer = set_timer(1.0, self.on_ns_timeout) def on_ns_timeout(self): if len(self.ns_messages_sent) \u0026gt;= self.max_ns_attempts: # Give up fail_session(\u0026#34;No NSR received after {self.max_ns_attempts} attempts\u0026#34;) return # Retry with new NS message send_ns_message(self.payload) def on_nsr_received(self, nsr_message): # Cancel timer cancel_timer(self.ns_timer) # Find which NS this NSR responds to tag = nsr_message.tag for ns_state in self.ns_messages_sent: if tag in ns_state[\u0026#39;tagset\u0026#39;]: # This NSR corresponds to this NS self.active_ns_state = ns_state break # Process NSR and complete handshake complete_handshake(nsr_message, self.active_ns_state) # Discard other NS states self.ns_messages_sent = [] Важные свойства:\nУникальные эфемерные ключи: Каждый NS использует собственный эфемерный ключ Независимые рукопожатия: Каждый NS создает отдельное состояние рукопожатия Корреляция NSR: Тег NSR указывает, на какой NS он отвечает Очистка состояния: Неиспользованные состояния NS удаляются после успешного NSR Предотвращение атак:\nЧтобы предотвратить истощение ресурсов:\n# Limit NS sending rate max_ns_rate = 5 per 10 seconds per destination # Limit total NS attempts max_ns_attempts = 5 # Limit total pending NS states max_pending_ns = 10 per context Несколько сообщений NSR (Session Request — запрос сеанса) Сценарий: Боб отправляет несколько NSR (служебных ответных сообщений) (например, данные ответа разбиты на несколько сообщений).\nПоведение Боба:\nclass InboundSession: def send_nsr_replies(self, payload_chunks): # One NS received, multiple NSRs to send for chunk in payload_chunks: # Generate new ephemeral key for each NSR ephemeral_key = generate_elg2_keypair() # Get next tag from NSR tagset tag = self.nsr_tagset.get_next_tag() nsr_message = build_nsr_message( tag=tag, ephemeral_key=ephemeral_key, payload=chunk ) send_message(nsr_message) # Wait for ES message from Alice self.state = SessionState.AWAITING_ES Поведение Алисы:\nclass OutboundSession: def on_nsr_received(self, nsr_message): if self.state == SessionState.PENDING_REPLY: # First NSR received complete_handshake(nsr_message) self.state = SessionState.ESTABLISHED # Create ES sessions self.es_outbound_tagset = derive_es_outbound_tagset() self.es_inbound_tagset = derive_es_inbound_tagset() # Send ES message (ACK) send_es_message(empty_payload) elif self.state == SessionState.ESTABLISHED: # Additional NSR received # Decrypt and process payload payload = decrypt_nsr_payload(nsr_message) process_payload(payload) # These NSRs are from other NS attempts, ignore handshake Очистка Боба:\nclass InboundSession: def on_es_received(self, es_message): # First ES received from Alice # This confirms which NSR Alice used # Clean up other handshake states for other_ns_state in self.pending_ns_states: if other_ns_state != self.active_ns_state: delete_ns_state(other_ns_state) # Delete unused NSR tagsets for tagset in self.nsr_tagsets: if tagset != self.active_nsr_tagset: delete_tagset(tagset) self.state = SessionState.ESTABLISHED Важные свойства:\nДопускается несколько NSR: Боб может отправлять несколько NSR на один NS Разные эфемерные ключи: Каждый NSR должен использовать уникальный эфемерный ключ Один и тот же набор тегов для NSR: Все NSR для одного NS используют один и тот же набор тегов Первый ES побеждает: Первый ES от Алисы определяет, какой NSR оказался успешным Очистка после ES: Боб удаляет неиспользованные состояния после получения ES Автомат состояний сеанса Полная диаграмма состояний:\nOutbound Session Inbound Session NEW | send NS | PENDING_REPLY -------------------- receive NS ---\u0026gt; ESTABLISHED | | receive NSR send NSR | | ESTABLISHED \u0026lt;---------- receive ES ------------- AWAITING_ES | | | ┌─────┴─────┐ | receive ES | | | | send ES receive ES | ESTABLISHED | | | | └─────┬─────┘ | ┌─────────┴─────────┐ | | | | | | send ES receive ES | | | | | | └─────────┬─────────┘ | | | └─────────────────────┴──────────────────────────┘ ACTIVE | idle timeout | EXPIRED Описания состояний:\nNEW: Исходящий сеанс создан, NS ещё не отправлен PENDING_REPLY: NS отправлен, ожидается NSR AWAITING_ES: NSR отправлен, ожидается первый ES от Алисы ESTABLISHED: Рукопожатие завершено, можно отправлять/принимать ES ACTIVE: Активный обмен сообщениями ES RATCHETING: Выполняется DH ratchet (механизм ратчета Диффи‑Хеллмана) (подмножество состояния ACTIVE) EXPIRED: Сеанс завершился по тайм-ауту, ожидает удаления TERMINATED: Сеанс явно прекращён Формат полезной нагрузки Раздел полезной нагрузки всех сообщений ECIES (NS, NSR, ES) использует блочный формат, аналогичный NTCP2.\nСтруктура блока Общий формат:\n+----+----+----+----+----+----+----+----+ |blk | size | data | +----+----+----+ + | | ~ ... ~ | | +----+----+----+----+----+----+----+----+ |blk | size | data | +----+----+----+ + | | ~ ... ~ | | +----+----+----+----+----+----+----+----+ Поля:\nblk: 1 байт - номер типа блока size: 2 байта - размер поля данных в формате big-endian (0-65516) data: переменная длина - данные, специфичные для блока Ограничения:\nМаксимальный фрейм ChaChaPoly (шифр ChaCha20-Poly1305): 65535 байт Poly1305 MAC (код аутентификации сообщения): 16 байт Максимальный суммарный размер блоков: 65519 байт (65535 - 16) Максимальный размер одного блока: 65519 байт (включая 3-байтовый заголовок) Максимальный размер данных одного блока: 65516 байт Типы блоков Определённые типы блоков:\nType Name Size Status Usage 0 DateTime 7 bytes Implemented Required in NS 1-3 Reserved - - Future use 4 Termination 9+ bytes Unimplemented Session termination 5 Options 21+ bytes Unimplemented Session options 6 MessageNumbers 5 bytes Unimplemented PN value 7 NextKey 3 or 35 bytes Implemented DH ratchet 8 ACK 4+ bytes Implemented Message acknowledgment 9 ACK Request 3 bytes Implemented Request ACK 10 Reserved - - Future use 11 Garlic Clove Variable Implemented Application data 12-223 Reserved - - Future use 224-253 Experimental Variable - Testing features 254 Padding Variable Implemented Traffic shaping 255 Reserved - - Future extension **Обработка неизвестных блоков:** Реализации ДОЛЖНЫ игнорировать блоки с неизвестными номерами типов и рассматривать их как заполнение. Это обеспечивает совместимость с будущими версиями.\nПравила упорядочивания блоков Порядок сообщений NS Обязательно: - блок DateTime ДОЛЖЕН быть первым\nРазрешено: - Garlic Clove (тип 11; долька в сообщении Garlic) - Параметры (тип 5) - если реализовано - Заполнение (тип 254)\nЗапрещено: - NextKey, ACK, ACK Request, Termination, MessageNumbers\nПример валидной полезной нагрузки NS:\nDateTime (0) | Garlic Clove (11) | Garlic Clove (11) | Padding (254) Упорядочивание сообщений NSR Обязательные: - Нет (полезная нагрузка может быть пустой)\nРазрешено: - Garlic Clove (элемент «чесночного» сообщения) (тип 11) - Опции (тип 5) - если реализовано - Заполнение (тип 254)\nЗапрещено: - DateTime, NextKey, ACK, ACK Request, Termination, MessageNumbers\nПример валидной полезной нагрузки NSR:\nGarlic Clove (11) | Garlic Clove (11) | Padding (254) или\n(empty - ACK only) Порядок сообщений ES Требуется: - нет (полезная нагрузка может быть пустой)\nДопускается (в любом порядке): - Garlic Clove (долька garlic-сообщения) (type 11) - NextKey (следующий ключ) (type 7) - ACK (type 8) - ACK Request (type 9) - Завершение (type 4) - если реализовано - MessageNumbers (номера сообщений) (type 6) - если реализовано - Параметры (type 5) - если реализовано - Заполнение (type 254)\nОсобые правила: - Termination (завершение) ДОЛЖЕН быть последним блоком (кроме Padding) - Padding (заполнение) ДОЛЖЕН быть последним блоком - Допускается несколько Garlic Cloves (отдельных «долек» сообщения Garlic) - Допускается до 2 блоков NextKey (следующий ключ) (прямой и обратный) - НЕ допускается несколько блоков Padding\nПримеры допустимых полезных нагрузок ES:\nGarlic Clove (11) | ACK (8) | Padding (254) NextKey (7) | Garlic Clove (11) | Garlic Clove (11) NextKey (7) forward | NextKey (7) reverse | Garlic Clove (11) ACK Request (9) | Garlic Clove (11) | Termination (4) | Padding (254) Блок даты и времени (тип 0) Назначение: Метка времени для предотвращения атак повторного воспроизведения и проверки смещения часов\nРазмер: 7 байт (3 байта заголовка + 4 байта данных)\nФормат:\n+----+----+----+----+----+----+----+ | 0 | 4 | timestamp | +----+----+----+----+----+----+----+ Поля:\nblk: 0 size: 4 (big-endian; старший байт первым) timestamp: 4 байта - отметка времени Unix в секундах (без знака, big-endian) Формат временной метки:\ntimestamp = int(time.time()) # Seconds since 1970-01-01 00:00:00 UTC # Wraps around in year 2106 (4-byte unsigned maximum) Правила проверки:\nMAX_CLOCK_SKEW_PAST = 5 * 60 # 5 minutes MAX_CLOCK_SKEW_FUTURE = 2 * 60 # 2 minutes def validate_datetime(timestamp): now = int(time.time()) age = now - timestamp if age \u0026lt; -MAX_CLOCK_SKEW_FUTURE: return False # Too far in future if age \u0026gt; MAX_CLOCK_SKEW_PAST: return False # Too old return True Предотвращение повторных атак:\nclass ReplayFilter: def __init__(self, duration=5*60): self.duration = duration # 5 minutes self.seen_messages = BloomFilter(size=100000, false_positive_rate=0.001) self.cleanup_timer = RepeatTimer(60, self.cleanup) def check_replay(self, ephemeral_key, timestamp): # Check timestamp validity if not validate_datetime(timestamp): return False # Check if ephemeral key seen recently if ephemeral_key in self.seen_messages: return False # Replay attack # Add to seen messages self.seen_messages.add(ephemeral_key) return True def cleanup(self): # Expire old entries (Bloom filter automatically ages out) pass Примечания по реализации:\nNS Messages: DateTime ДОЛЖЕН быть первым блоком NSR/ES Messages: DateTime обычно не включается Окно повторов: 5 минут — минимально рекомендуемое значение Фильтр Блума: Рекомендуется для эффективного обнаружения повторов Смещение часов: Допускайте отставание до 5 минут и опережение до 2 минут Garlic Clove Block (блок «зубчика чеснока», тип 11) Назначение: Инкапсулирует сообщения I2NP для доставки\nФормат:\n+----+----+----+----+----+----+----+----+ | 11 | size | | +----+----+----+ + | Delivery Instructions | ~ ~ | | +----+----+----+----+----+----+----+----+ |type| Message_ID | Expiration | +----+----+----+----+----+----+----+----+ | I2NP Message body | +----+ + ~ ~ | | +----+----+----+----+----+----+----+----+ Поля:\nblk: 11 size: Общий размер clove (вложенного сообщения в garlic-сообщении) (переменный) Delivery Instructions: Как указано в спецификации I2NP type: тип сообщения I2NP (1 байт) Message_ID: идентификатор сообщения I2NP (4 байта) Expiration: метка времени Unix в секундах (4 байта) I2NP Message body: данные сообщения переменной длины Форматы инструкций доставки:\nЛокальная доставка (1 байт):\n+----+ |0x00| +----+ Доставка до Destination (адрес назначения в I2P) (33 байта):\n+----+----+----+----+----+----+----+----+ |0x01| | +----+ Destination Hash + | 32 bytes | + + | | +----+----+----+----+----+----+----+----+ Доставка к Router (33 байта):\n+----+----+----+----+----+----+----+----+ |0x02| | +----+ Router Hash + | 32 bytes | + + | | +----+----+----+----+----+----+----+----+ Доставка через Tunnel (37 байт):\n+----+----+----+----+----+----+----+----+ |0x03| Tunnel ID | +----+----+----+----+----+ + | Router Hash | + 32 bytes + | | + + | | +----+----+----+----+----+----+----+----+ Заголовок сообщения I2NP (всего 9 байт):\n+----+----+----+----+----+----+----+----+ |type| msg_id | expiration | +----+----+----+----+----+----+----+----+ | | type: тип сообщения I2NP (Database Store, Database Lookup, Data и т. д.) msg_id: 4-байтовый идентификатор сообщения expiration: 4-байтовая метка времени Unix (в секундах) Важные отличия от формата ElGamal Clove:\nБез сертификата: Поле сертификата опущено (не используется в ElGamal) Нет Clove ID: Clove ID опущен (всегда был 0) Нет поля Clove Expiration: Вместо этого используется срок истечения сообщения I2NP Компактный заголовок: 9-байтный заголовок I2NP по сравнению с более крупным форматом ElGamal Каждый Clove (долька) — отдельный блок: Нет структуры CloveSet (набор долек) Несколько долек:\n# Multiple Garlic Cloves in one message payload = [ build_datetime_block(), build_garlic_clove(i2np_message_1), build_garlic_clove(i2np_message_2), build_garlic_clove(i2np_message_3), build_padding_block() ] Распространённые типы сообщений I2NP в Cloves (дольках):\nType Name Usage 1 DatabaseStore Publishing LeaseSet 2 DatabaseLookup Requesting LeaseSet 5 DeliveryStatus ACK (legacy, avoid in ECIES) 20 Data Streaming data 21 Garlic Nested garlic messages **Обработка зубчиков:** def process_garlic_clove(clove_data): # Parse delivery instructions delivery_type = clove_data[0] if delivery_type == 0x00: # Local delivery offset = 1 elif delivery_type == 0x01: # Destination delivery dest_hash = clove_data[1:33] offset = 33 elif delivery_type == 0x02: # Router delivery router_hash = clove_data[1:33] offset = 33 elif delivery_type == 0x03: # Tunnel delivery tunnel_id = struct.unpack(\u0026#39;\u0026gt;I\u0026#39;, clove_data[1:5])[0] router_hash = clove_data[5:37] offset = 37 # Parse I2NP header i2np_type = clove_data[offset] msg_id = struct.unpack(\u0026#39;\u0026gt;I\u0026#39;, clove_data[offset+1:offset+5])[0] expiration = struct.unpack(\u0026#39;\u0026gt;I\u0026#39;, clove_data[offset+5:offset+9])[0] # Extract I2NP body i2np_body = clove_data[offset+9:] # Process message process_i2np_message(i2np_type, msg_id, expiration, i2np_body) Блок NextKey (Тип 7) Назначение: обмен ключами DH ratchet (механизм ратчета Диффи-Хеллмана)\nФормат (ключ присутствует - 38 байт):\n+----+----+----+----+----+----+----+----+ | 7 | 35 |flag| key ID | | +----+----+----+----+----+----+ + | | + Next DH Ratchet Public Key + | 32 bytes | + + | | + +----+----+ | | +----+----+----+----+----+----+ Формат (только ID ключа - 6 байт):\n+----+----+----+----+----+----+ | 7 | 3 |flag| key ID | +----+----+----+----+----+----+ Поля:\nblk: 7 size: 3 (только ID) или 35 (с ключом) flag: 1 байт - биты флагов key ID: 2 байта - идентификатор ключа Big-endian (старший байт первым) (0-32767) Public Key: 32 байта - открытый ключ X25519 (little-endian, младший байт первым), если бит 0 flag = 1 Биты флагов:\nBit 7 6 5 4 3 2 1 0 | | | | | | | | | | | | | | | +-- Bit 0: Key present (1) or ID only (0) | | | | | | +---- Bit 1: Reverse key (1) or forward key (0) | | | | | +------ Bit 2: Request reverse key (1) or no request (0) | | | | | +-+-+-+-+-------- Bits 3-7: Reserved (set to 0) Примеры флагов:\n# Forward key present flags = 0x01 # Binary: 00000001 # Reverse key present flags = 0x03 # Binary: 00000011 # Forward key ID only (ACK) flags = 0x00 # Binary: 00000000 # Reverse key ID only (ACK) flags = 0x02 # Binary: 00000010 # Forward key ID with reverse request flags = 0x04 # Binary: 00000100 Правила идентификаторов ключей:\nID идут последовательно: 0, 1, 2, \u0026hellip;, 32767 ID увеличивается только при генерации нового ключа Один и тот же ID используется для нескольких сообщений до следующего ratchet (механизма пошагового обновления ключей) Максимальный ID — 32767 (после этого необходимо начать новую сессию) Примеры использования:\n# Initiating ratchet (sender generates new key) nextkey = NextKeyBlock( flags=0x01, # Key present, forward key_id=0, public_key=sender_new_pk ) # Replying to ratchet (receiver generates new key) nextkey = NextKeyBlock( flags=0x03, # Key present, reverse key_id=0, public_key=receiver_new_pk ) # Acknowledging ratchet (no new key from sender) nextkey = NextKeyBlock( flags=0x02, # ID only, reverse key_id=0 ) # Requesting reverse ratchet nextkey = NextKeyBlock( flags=0x04, # Request reverse, forward ID key_id=1 ) Логика обработки:\ndef process_nextkey_block(block): flags = block.flags key_id = block.key_id key_present = (flags \u0026amp; 0x01) != 0 is_reverse = (flags \u0026amp; 0x02) != 0 request_reverse = (flags \u0026amp; 0x04) != 0 if key_present: public_key = block.public_key if is_reverse: # Reverse key received perform_dh_ratchet(receiver_key=public_key, key_id=key_id) # Sender should ACK with own key ID else: # Forward key received perform_dh_ratchet(sender_key=public_key, key_id=key_id) # Receiver should reply with reverse key send_reverse_key(generate_new_key()) else: # Key ID only (ACK) if is_reverse: # Reverse key ACK confirm_reverse_ratchet(key_id) else: # Forward key ACK confirm_forward_ratchet(key_id) if request_reverse: # Sender requests receiver to generate new key send_reverse_key(generate_new_key()) Несколько NextKey Blocks (блоков NextKey):\nОдно сообщение ES может содержать до 2 блоков NextKey, когда в обоих направлениях одновременно выполняется ratcheting (криптографический механизм храповика):\n# Both directions ratcheting payload = [ NextKeyBlock(flags=0x01, key_id=2, public_key=forward_key), # Forward NextKeyBlock(flags=0x03, key_id=1, public_key=reverse_key), # Reverse build_garlic_clove(data) ] Блок ACK (тип 8) Назначение: Подтверждение получения сообщений in-band (в рамках того же канала связи)\nФормат (одиночный ACK - 7 байт):\n+----+----+----+----+----+----+----+ | 8 | 4 |tagsetid | N | +----+----+----+----+----+----+----+ Формат (несколько подтверждений):\n+----+----+----+----+----+----+----+----+ | 8 | size |tagsetid | N | | +----+----+----+----+----+----+----+ + | more ACKs | ~ ... ~ | | +----+----+----+----+----+----+----+----+ Поля:\nblk: 8 size: 4 * число ACK (подтверждений) (минимум 4) Для каждого ACK: tagsetid: 2 байта - идентификатор набора тегов в порядке старшего байта первым (0-65535) N: 2 байта - номер сообщения в порядке старшего байта первым (0-65535) Определение Tag Set ID (идентификатора набора тегов):\n# Tag set 0 (initial, after NSR) tagset_id = 0 # After first ratchet (tag set 1) # Both Alice and Bob sent key ID 0 tagset_id = 1 + 0 + 0 = 1 # After second ratchet (tag set 2) # Alice sent key ID 1, Bob still using key ID 0 tagset_id = 1 + 1 + 0 = 2 # After third ratchet (tag set 3) # Alice still using key ID 1, Bob sent key ID 1 tagset_id = 1 + 1 + 1 = 3 Пример одиночного ACK (подтверждение):\n# ACK message from tag set 5, message number 127 ack_block = ACKBlock( tagset_id=5, message_number=127 ) # Wire format (7 bytes): # 08 00 04 00 05 00 7F # | | | | | | | # | | | | | | +-- N (127) # | | | | +--------- N high byte # | | | +------------ tagset_id (5) # | | +--------------- tagset_id high byte # | +------------------ size (4) # +--------------------- type (8) Пример нескольких ACK:\n# ACK three messages ack_block = ACKBlock([ (tagset_id=3, N=42), (tagset_id=3, N=43), (tagset_id=4, N=0) ]) # Wire format (15 bytes): # 08 00 0C 00 03 00 2A 00 03 00 2B 00 04 00 00 # (ts=3, N=42) (ts=3, N=43) (ts=4, N=0) Обработка:\ndef process_ack_block(block): num_acks = block.size // 4 for i in range(num_acks): offset = i * 4 tagset_id = struct.unpack(\u0026#39;\u0026gt;H\u0026#39;, block.data[offset:offset+2])[0] message_num = struct.unpack(\u0026#39;\u0026gt;H\u0026#39;, block.data[offset+2:offset+4])[0] # Mark message as acknowledged mark_acked(tagset_id, message_num) # May trigger retransmission timeout cancellation cancel_retransmit_timer(tagset_id, message_num) Когда отправлять ACKs (подтверждения):\nТайминг ACK (подтверждений):\nclass ACKManager: def __init__(self): self.pending_acks = [] self.ack_timer = None def request_ack(self, tagset_id, message_num): self.pending_acks.append((tagset_id, message_num)) if not self.ack_timer: # Delay ACK briefly to allow higher layer to respond self.ack_timer = set_timer(0.1, self.send_acks) # 100ms def send_acks(self): if self.pending_acks and not has_outbound_data(): # No higher layer data, send explicit ACK send_es_message(build_ack_block(self.pending_acks)) # Otherwise, ACK will piggyback on next ES message self.pending_acks = [] self.ack_timer = None Блок запроса ACK (Тип 9) Назначение: Запрос подтверждения получения текущего сообщения по основному каналу (in-band acknowledgment)\nФормат:\n+----+----+----+----+ | 9 | 1 |flg | +----+----+----+----+ Поля:\nblk: 9 size: 1 flg: 1 байт - Флаги (все биты в настоящее время не используются, установлены в 0) Использование:\n# Request ACK for this message payload = [ build_ack_request_block(), build_garlic_clove(important_data) ] Ответ получателя:\nКогда получен ACK Request (запрос подтверждения):\nС немедленными данными: включить ACK-блок в немедленный ответ Без немедленных данных: запустить таймер (например, 100 мс) и отправить пустой ES с ACK, если таймер истечет Идентификатор набора тегов: использовать текущий ID входящего набора тегов Номер сообщения: использовать номер сообщения, связанный с полученным тегом сеанса Обработка:\ndef process_ack_request(message): # Extract message identification tagset_id = message.tagset_id message_num = message.message_num # Schedule ACK schedule_ack(tagset_id, message_num) # If no data to send immediately, start timer if not has_pending_data(): set_timer(0.1, lambda: send_ack_only(tagset_id, message_num)) Когда использовать ACK Request (запрос подтверждения):\nКритические сообщения: Сообщения, которые должны быть подтверждены Доставка LeaseSet: При включении LeaseSet в пакет Session Ratchet (механизм обновления ключей сеанса): После отправки блока NextKey (блок следующего ключа) Окончание передачи: Когда у отправителя больше нет данных для отправки, но он хочет получить подтверждение Когда НЕ следует использовать:\nПотоковый протокол: Потоковый слой обрабатывает подтверждения (ACK) Высокочастотные сообщения: Избегайте запроса ACK для каждого сообщения (накладные расходы) Неважные дейтаграммы: Сырые дейтаграммы обычно не нуждаются в ACK Блок завершения (Тип 4) Статус: НЕ РЕАЛИЗОВАНО\nНазначение: Корректно завершить сеанс\nФормат:\n+----+----+----+----+----+----+----+----+ | 4 | size | rsn| addl data | +----+----+----+----+ + ~ ... ~ +----+----+----+----+----+----+----+----+ Поля:\nblk: 4 size: 1 или более байт rsn: 1 байт - код причины addl data: Необязательные дополнительные данные (формат зависит от причины) Коды причин:\nCode Meaning Additional Data 0 Normal close / unspecified None 1 Termination received None 2 Idle timeout None (implementation-specific) 3 Resource exhaustion None (implementation-specific) 4+ Reserved Implementation-specific **Использование (когда будет реализовано):** # Normal session close termination = TerminationBlock( reason=0, additional_data=b\u0026#39;\u0026#39; ) # Session termination due to received termination termination = TerminationBlock( reason=1, additional_data=b\u0026#39;\u0026#39; ) Правила:\nДОЛЖЕН быть последним блоком, за исключением Padding (выравнивание) Padding ДОЛЖЕН следовать за Termination (блок завершения) при наличии Не допускается в сообщениях NS или NSR Допускается только в сообщениях ES Блок параметров (Тип 5) Статус: НЕ РЕАЛИЗОВАНО\nНазначение: Согласовать параметры сеанса\nФормат:\n+----+----+----+----+----+----+----+----+ | 5 | size |ver |flg |STL |STimeout | +----+----+----+----+----+----+----+----+ | SOTW | RITW |tmin|tmax|rmin|rmax| +----+----+----+----+----+----+----+----+ | tdmy | rdmy | tdelay | rdelay | +----+----+----+----+----+----+----+----+ | more_options | ~ ... ~ | | +----+----+----+----+----+----+----+----+ Поля:\nblk: 5 size: 21 или более байт ver: 1 байт - версия протокола (должна быть 0) flg: 1 байт - флаги (все биты в настоящее время не используются) STL: 1 байт - длина тега сеанса (должна быть равна 8) STimeout: 2 байта - таймаут простоя сеанса в секундах (big-endian — старший байт первым) SOTW: 2 байта - окно исходящих тегов отправителя (big-endian) RITW: 2 байта - окно входящих тегов получателя (big-endian) tmin, tmax, rmin, rmax: по 1 байту каждый - параметры заполнения (фиксированная точка 4.4) tdmy: 2 байта - максимальный объём фиктивного трафика, который готов отправлять (байт/с, big-endian) rdmy: 2 байта - запрашиваемый фиктивный трафик (байт/с, big-endian) tdelay: 2 байта - максимальная задержка внутри сообщения, которую готов вставить (мс, big-endian) rdelay: 2 байта - запрашиваемая задержка внутри сообщения (мс, big-endian) more_options: переменной длины - будущие расширения Параметры дополнения (4.4 с фиксированной точкой):\ndef encode_padding_ratio(ratio): \u0026#34;\u0026#34;\u0026#34; Encode padding ratio as 4.4 fixed-point ratio: 0.0 to 15.9375 returns: 0x00 to 0xFF \u0026#34;\u0026#34;\u0026#34; return int(ratio * 16) def decode_padding_ratio(encoded): \u0026#34;\u0026#34;\u0026#34; Decode 4.4 fixed-point to ratio encoded: 0x00 to 0xFF returns: 0.0 to 15.9375 \u0026#34;\u0026#34;\u0026#34; return encoded / 16.0 # Examples: # 0x00 = 0.0 (no padding) # 0x01 = 0.0625 (6.25% padding) # 0x10 = 1.0 (100% padding - double traffic) # 0x80 = 8.0 (800% padding - 9x traffic) # 0xFF = 15.9375 (1593.75% padding) Согласование окна тегов:\n# SOTW: Sender\u0026#39;s recommendation for receiver\u0026#39;s inbound window # RITW: Sender\u0026#39;s declaration of own inbound window # Receiver calculates actual inbound window: inbound_window = calculate_window( sender_suggestion=SOTW, own_constraints=MAX_INBOUND_TAGS, own_resources=available_memory() ) # Sender uses: # - RITW to know how far ahead receiver will accept # - Own SOTW to hint optimal window size Значения по умолчанию (когда параметры не согласованы):\nDEFAULT_OPTIONS = { \u0026#39;version\u0026#39;: 0, \u0026#39;session_tag_length\u0026#39;: 8, \u0026#39;session_timeout\u0026#39;: 600, # 10 minutes \u0026#39;sender_outbound_tag_window\u0026#39;: 160, \u0026#39;receiver_inbound_tag_window\u0026#39;: 160, \u0026#39;tmin\u0026#39;: 0x00, # No minimum padding \u0026#39;tmax\u0026#39;: 0x10, # Up to 100% padding \u0026#39;rmin\u0026#39;: 0x00, # No minimum requested \u0026#39;rmax\u0026#39;: 0x10, # Up to 100% requested \u0026#39;tdmy\u0026#39;: 0, # No dummy traffic \u0026#39;rdmy\u0026#39;: 0, # No dummy traffic requested \u0026#39;tdelay\u0026#39;: 0, # No delay \u0026#39;rdelay\u0026#39;: 0 # No delay requested } Блок номеров сообщений (Тип 6) Статус: НЕ РЕАЛИЗОВАНО\nНазначение: указать последнее сообщение, отправленное в предыдущем наборе тегов (позволяет обнаруживать пропуски)\nФормат:\n+----+----+----+----+----+ | 6 | 2 | PN | +----+----+----+----+----+ Поля:\nblk: 6 size: 2 PN: 2 байта — номер последнего сообщения предыдущего набора тегов (big-endian (старший байт первым), 0-65535) Определение PN (Previous Number — предыдущее число):\nPN — это индекс последнего тега, отправленного в предыдущем наборе тегов.\nИспользование (когда будет реализовано):\n# After ratcheting to new tag set # Old tag set: sent messages 0-4095 # New tag set: sending first message payload = [ MessageNumbersBlock(PN=4095), build_garlic_clove(data) ] Преимущества для получателя:\ndef process_message_numbers(pn_value): # Receiver can now: # 1. Determine if any messages were skipped highest_received_in_old_tagset = 4090 if pn_value \u0026gt; highest_received_in_old_tagset: missing_count = pn_value - highest_received_in_old_tagset # 5 messages were never received # 2. Delete tags higher than PN from old tagset for tag_index in range(pn_value + 1, MAX_TAG_INDEX): delete_tag(old_tagset, tag_index) # 3. Expire tags ≤ PN after grace period (e.g., 2 minutes) schedule_deletion(old_tagset, delay=120) Правила:\nНЕ ДОЛЖЕН отправляться в наборе тегов 0 (нет предыдущего набора тегов) Отправляется только в ES messages (сообщениях формата ES) Отправляется только в первом или первых сообщениях нового набора тегов Значение PN берётся с точки зрения отправителя (последний тег, отправленный отправителем) Связь с Signal:\nВ Signal Double Ratchet PN находится в заголовке сообщения. В ECIES PN находится в зашифрованной полезной нагрузке и является необязательным.\nБлок заполнения (тип 254) Назначение: противодействие анализу трафика и маскировка размера сообщений\nФормат:\n+----+----+----+----+----+----+----+----+ |254 | size | padding | +----+----+----+ + | | ~ ... ~ | | +----+----+----+----+----+----+----+----+ Поля:\nblk: 254 size: 0-65516 байт (big-endian — старший байт вперёд) padding: Случайные или нулевые данные Правила:\nДОЛЖЕН быть последним блоком в сообщении Несколько блоков заполнения НЕ допускаются Может иметь нулевую длину (только 3-байтовый заголовок) Данные заполнения могут быть нулями или случайными байтами Паддинг по умолчанию:\nDEFAULT_PADDING_MIN = 0 DEFAULT_PADDING_MAX = 15 def generate_default_padding(): size = random.randint(DEFAULT_PADDING_MIN, DEFAULT_PADDING_MAX) data = random.bytes(size) # or zeros return PaddingBlock(size, data) Стратегии противодействия анализу трафика:\nСтратегия 1: Случайный размер (по умолчанию)\n# Add 0-15 bytes random padding to each message padding_size = random.randint(0, 15) padding_block = PaddingBlock(padding_size, random.bytes(padding_size)) Стратегия 2: Округление до кратного\n# Round total message size to next multiple of 64 target_size = ((message_size + 63) // 64) * 64 padding_size = target_size - message_size - 3 # -3 for block header padding_block = PaddingBlock(padding_size, random.bytes(padding_size)) Стратегия 3: Фиксированные размеры сообщений\n# Always send 1KB messages TARGET_MESSAGE_SIZE = 1024 padding_size = TARGET_MESSAGE_SIZE - message_size - 3 padding_block = PaddingBlock(padding_size, random.bytes(padding_size)) Стратегия 4: Согласованное заполнение (Options block — блок параметров)\n# Calculate padding based on negotiated parameters # tmin, tmax from Options block min_padding = int(payload_size * tmin_ratio) max_padding = int(payload_size * tmax_ratio) padding_size = random.randint(min_padding, max_padding) padding_block = PaddingBlock(padding_size, random.bytes(padding_size)) Сообщения, состоящие только из заполнения:\nСообщения могут целиком состоять из заполнения (без данных приложения):\n# Dummy traffic message payload = [ PaddingBlock(random.randint(100, 500), random.bytes(...)) ] Примечания по реализации:\nПолностью нулевое заполнение: Допустимо (будет зашифровано ChaCha20) Случайное заполнение: Не добавляет дополнительной безопасности после шифрования, но использует больше энтропии Производительность: Генерация случайного заполнения может быть затратной; рассмотрите использование нулей Память: Большие блоки заполнения потребляют пропускную способность; будьте осторожны с максимальным размером Руководство по реализации Предварительные требования Криптографические библиотеки:\nX25519: libsodium, NaCl, или Bouncy Castle ChaCha20-Poly1305: libsodium, OpenSSL 1.1.0+, или Bouncy Castle SHA-256: OpenSSL, Bouncy Castle, или встроенная поддержка на уровне языка Elligator2: Ограниченная поддержка в библиотеках; может потребоваться собственная реализация Реализация Elligator2 (криптографический алгоритм маскировки публичных ключей):\nElligator2 (криптографический метод маскировки открытых ключей на эллиптических кривых) не широко реализован. Варианты:\nOBFS4 (протокол маскировки трафика для Tor): подключаемый транспорт obfs4 для Tor включает реализацию Elligator2 (криптографический метод маскировки публичных ключей) Собственная реализация: основана на статье Elligator2 kleshni/Elligator: эталонная реализация на GitHub Примечание по Java I2P: Java I2P использует библиотеку net.i2p.crypto.eddsa с собственными дополнениями Elligator2 (криптографическая схема маскировки точек эллиптической кривой).\nРекомендуемый порядок реализации Этап 1: Основная криптография 1. генерация и обмен DH-ключами X25519 2. шифрование/расшифрование AEAD ChaCha20-Poly1305 3. хеширование SHA-256 и MixHash (операция смешивания хэша) 4. деривация ключей HKDF 5. кодирование/декодирование Elligator2 (поначалу можно использовать тестовые векторы)\nФаза 2: Форматы сообщений 1. Сообщение NS (без привязки) - самый простой формат 2. Сообщение NS (с привязкой) - добавляет статический ключ 3. Сообщение NSR 4. Сообщение ES 5. Разбор и генерация блоков\nЭтап 3: Управление сеансами 1. Создание и хранение сеанса 2. Управление набором тегов (для отправителя и получателя) 3. Ratchet (механизм пошагового обновления) для тегов сеанса 4. Ratchet симметричного ключа 5. Поиск тегов и управление окном\nЭтап 4: DH-ратчет 1. Обработка блока NextKey 2. KDF для DH-ратчета 3. Создание набора тегов после ратчета 4. Управление несколькими наборами тегов\nФаза 5: Логика протокола 1. Машина состояний для NS/NSR/ES 2. Защита от повторного воспроизведения (DateTime, фильтр Блума) 3. Логика повторной передачи (множественные NS/NSR) 4. Обработка ACK\nЭтап 6: Интеграция 1. Обработка I2NP Garlic Clove (вложенного элемента в garlic-сообщении) 2. Упаковка LeaseSet 3. Интеграция потокового протокола 4. Интеграция протокола дейтаграмм\nРеализация отправителя Жизненный цикл исходящего сеанса:\nclass OutboundSession: def __init__(self, destination, bound=True): self.destination = destination self.bound = bound self.state = SessionState.NEW # Keys for NS message self.ephemeral_keypair = generate_elg2_keypair() if bound: self.static_key = context.static_keypair # Will be populated after NSR self.outbound_tagset = None self.outbound_keyratchet = None self.inbound_tagset = None self.inbound_keyratchet = None # Timing self.created_time = now() self.last_activity = now() # Retransmission self.ns_attempts = [] self.ns_timer = None def send_initial_message(self, payload): \u0026#34;\u0026#34;\u0026#34;Send NS message\u0026#34;\u0026#34;\u0026#34; # Build NS message ns_message = self.build_ns_message(payload) # Send send_to_network(self.destination, ns_message) # Track for retransmission self.ns_attempts.append({ \u0026#39;message\u0026#39;: ns_message, \u0026#39;time\u0026#39;: now(), \u0026#39;ephemeral_key\u0026#39;: self.ephemeral_keypair, \u0026#39;kdf_state\u0026#39;: self.save_kdf_state() }) # Start timer self.ns_timer = set_timer(1.0, self.on_ns_timeout) self.state = SessionState.PENDING_REPLY def build_ns_message(self, payload): \u0026#34;\u0026#34;\u0026#34;Construct NS message\u0026#34;\u0026#34;\u0026#34; # KDF initialization chainKey, h = self.initialize_kdf() # Ephemeral key section elg2_ephemeral = ENCODE_ELG2(self.ephemeral_keypair.public_key) h = SHA256(h || self.destination.static_key) h = SHA256(h || self.ephemeral_keypair.public_key) # es DH es_shared = DH(self.ephemeral_keypair.private_key, self.destination.static_key) keydata = HKDF(chainKey, es_shared, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k_static = keydata[32:63] # Encrypt static key section if self.bound: static_section = self.static_key.public_key else: static_section = bytes(32) static_ciphertext = ENCRYPT(k_static, 0, static_section, h) h = SHA256(h || static_ciphertext) # ss DH (if bound) if self.bound: ss_shared = DH(self.static_key.private_key, self.destination.static_key) keydata = HKDF(chainKey, ss_shared, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k_payload = keydata[32:63] nonce = 0 else: k_payload = k_static nonce = 1 # Build payload blocks payload_data = self.build_ns_payload(payload) # Encrypt payload payload_ciphertext = ENCRYPT(k_payload, nonce, payload_data, h) h = SHA256(h || payload_ciphertext) # Save KDF state for NSR processing self.ns_chainkey = chainKey self.ns_hash = h # Assemble message return elg2_ephemeral + static_ciphertext + payload_ciphertext def build_ns_payload(self, application_data): \u0026#34;\u0026#34;\u0026#34;Build NS payload blocks\u0026#34;\u0026#34;\u0026#34; blocks = [] # DateTime block (required, first) blocks.append(build_datetime_block()) # Garlic Clove(s) with application data blocks.append(build_garlic_clove(application_data)) # Optionally bundle LeaseSet if should_send_leaseset(): blocks.append(build_garlic_clove(build_leaseset_store())) # Padding blocks.append(build_padding_block(random.randint(0, 15))) return encode_blocks(blocks) def on_nsr_received(self, nsr_message): \u0026#34;\u0026#34;\u0026#34;Process NSR and establish ES session\u0026#34;\u0026#34;\u0026#34; # Cancel retransmission timer cancel_timer(self.ns_timer) # Parse NSR tag = nsr_message[0:8] elg2_bob_ephemeral = nsr_message[8:40] key_section_mac = nsr_message[40:56] payload_ciphertext = nsr_message[56:] # Find corresponding NS attempt ns_state = self.find_ns_by_tag(tag) if not ns_state: raise ValueError(\u0026#34;NSR tag doesn\u0026#39;t match any NS\u0026#34;) # Restore KDF state chainKey = ns_state[\u0026#39;chainkey\u0026#39;] h = ns_state[\u0026#39;hash\u0026#39;] # Decode Bob\u0026#39;s ephemeral key bob_ephemeral = DECODE_ELG2(elg2_bob_ephemeral) # Mix tag and Bob\u0026#39;s ephemeral into hash h = SHA256(h || tag) h = SHA256(h || bob_ephemeral) # ee DH ee_shared = DH(self.ephemeral_keypair.private_key, bob_ephemeral) keydata = HKDF(chainKey, ee_shared, \u0026#34;\u0026#34;, 32) chainKey = keydata[0:31] # se DH se_shared = DH(self.static_key.private_key, bob_ephemeral) keydata = HKDF(chainKey, se_shared, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k_key_section = keydata[32:63] # Verify key section MAC try: DECRYPT(k_key_section, 0, key_section_mac, h) except AuthenticationError: raise ValueError(\u0026#34;NSR key section MAC verification failed\u0026#34;) h = SHA256(h || key_section_mac) # Split for bidirectional ES keydata = HKDF(chainKey, ZEROLEN, \u0026#34;\u0026#34;, 64) k_ab = keydata[0:31] # Alice → Bob k_ba = keydata[32:63] # Bob → Alice # Initialize ES tagsets self.outbound_tagset = DH_INITIALIZE(chainKey, k_ab) self.inbound_tagset = DH_INITIALIZE(chainKey, k_ba) # Decrypt NSR payload k_nsr = HKDF(k_ba, ZEROLEN, \u0026#34;AttachPayloadKDF\u0026#34;, 32) try: payload = DECRYPT(k_nsr, 0, payload_ciphertext, h) except AuthenticationError: raise ValueError(\u0026#34;NSR payload MAC verification failed\u0026#34;) # Process NSR payload blocks self.process_payload_blocks(payload) # Session established self.state = SessionState.ESTABLISHED self.last_activity = now() # Send ES message (implicit ACK) self.send_es_ack() def send_es_message(self, payload): \u0026#34;\u0026#34;\u0026#34;Send ES message\u0026#34;\u0026#34;\u0026#34; if self.state != SessionState.ESTABLISHED: raise ValueError(\u0026#34;Session not established\u0026#34;) # Get next tag and key tag, index = self.outbound_tagset.get_next_tag() key = self.outbound_keyratchet.get_key(index) # Construct nonce nonce = construct_nonce(index) # Build payload blocks payload_data = self.build_es_payload(payload) # AEAD encryption ciphertext = ENCRYPT(key, nonce, payload_data, tag) # Assemble message es_message = tag + ciphertext # Send send_to_network(self.destination, es_message) # Update activity self.last_activity = now() # Check if ratchet needed if self.outbound_tagset.should_ratchet(): self.initiate_ratchet() Реализация получателя Жизненный цикл входящего сеанса:\nclass InboundSession: def __init__(self): self.state = None self.bound = False self.destination = None # Keys self.remote_ephemeral_key = None self.remote_static_key = None self.ephemeral_keypair = None # Tagsets self.inbound_tagset = None self.outbound_tagset = None # Timing self.created_time = None self.last_activity = None # Paired session self.paired_outbound = None @staticmethod def try_decrypt_ns(message): \u0026#34;\u0026#34;\u0026#34;Attempt to decrypt as NS message\u0026#34;\u0026#34;\u0026#34; # Parse NS structure elg2_ephemeral = message[0:32] static_ciphertext = message[32:80] # 32 + 16 payload_ciphertext = message[80:] # Decode ephemeral key try: alice_ephemeral = DECODE_ELG2(elg2_ephemeral) except: return None # Not a valid Elligator2 encoding # Check replay if is_replay(alice_ephemeral): return None # KDF initialization chainKey, h = initialize_kdf() # Mix keys h = SHA256(h || context.static_keypair.public_key) h = SHA256(h || alice_ephemeral) # es DH es_shared = DH(context.static_keypair.private_key, alice_ephemeral) keydata = HKDF(chainKey, es_shared, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k_static = keydata[32:63] # Decrypt static key section try: static_data = DECRYPT(k_static, 0, static_ciphertext, h) except AuthenticationError: return None # Not a valid NS message h = SHA256(h || static_ciphertext) # Check if bound or unbound if static_data == bytes(32): # Unbound alice_static_key = None k_payload = k_static nonce = 1 else: # Bound - perform ss DH alice_static_key = static_data ss_shared = DH(context.static_keypair.private_key, alice_static_key) keydata = HKDF(chainKey, ss_shared, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k_payload = keydata[32:63] nonce = 0 # Decrypt payload try: payload = DECRYPT(k_payload, nonce, payload_ciphertext, h) except AuthenticationError: return None h = SHA256(h || payload_ciphertext) # Create session session = InboundSession() session.state = SessionState.ESTABLISHED session.created_time = now() session.last_activity = now() session.remote_ephemeral_key = alice_ephemeral session.remote_static_key = alice_static_key session.bound = (alice_static_key is not None) session.ns_chainkey = chainKey session.ns_hash = h # Extract destination if bound if session.bound: session.destination = extract_destination_from_payload(payload) # Process payload session.process_payload_blocks(payload) return session def send_nsr_reply(self, reply_payload): \u0026#34;\u0026#34;\u0026#34;Send NSR message\u0026#34;\u0026#34;\u0026#34; # Generate NSR tagset tagsetKey = HKDF(self.ns_chainkey, ZEROLEN, \u0026#34;SessionReplyTags\u0026#34;, 32) nsr_tagset = DH_INITIALIZE(self.ns_chainkey, tagsetKey) # Get tag tag, _ = nsr_tagset.get_next_tag() # Mix tag into hash h = SHA256(self.ns_hash || tag) # Generate ephemeral key self.ephemeral_keypair = generate_elg2_keypair() bob_ephemeral = self.ephemeral_keypair.public_key elg2_bob_ephemeral = ENCODE_ELG2(bob_ephemeral) # Mix ephemeral key h = SHA256(h || bob_ephemeral) chainKey = self.ns_chainkey # ee DH ee_shared = DH(self.ephemeral_keypair.private_key, self.remote_ephemeral_key) keydata = HKDF(chainKey, ee_shared, \u0026#34;\u0026#34;, 32) chainKey = keydata[0:31] # se DH se_shared = DH(context.static_keypair.private_key, self.remote_ephemeral_key) keydata = HKDF(chainKey, se_shared, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k_key_section = keydata[32:63] # Encrypt key section (empty) key_section_ciphertext = ENCRYPT(k_key_section, 0, ZEROLEN, h) h = SHA256(h || key_section_ciphertext) # Split for bidirectional ES keydata = HKDF(chainKey, ZEROLEN, \u0026#34;\u0026#34;, 64) k_ab = keydata[0:31] # Alice → Bob k_ba = keydata[32:63] # Bob → Alice # Initialize ES tagsets self.inbound_tagset = DH_INITIALIZE(chainKey, k_ab) self.outbound_tagset = DH_INITIALIZE(chainKey, k_ba) # Build reply payload payload_data = build_payload_blocks(reply_payload) # Encrypt payload k_nsr = HKDF(k_ba, ZEROLEN, \u0026#34;AttachPayloadKDF\u0026#34;, 32) payload_ciphertext = ENCRYPT(k_nsr, 0, payload_data, h) # Assemble NSR nsr_message = tag + elg2_bob_ephemeral + key_section_ciphertext + payload_ciphertext # Send send_to_network(self.destination, nsr_message) # Wait for ES self.state = SessionState.AWAITING_ES self.last_activity = now() def on_es_received(self, es_message): \u0026#34;\u0026#34;\u0026#34;Process first ES message\u0026#34;\u0026#34;\u0026#34; if self.state == SessionState.AWAITING_ES: # First ES received, confirms session self.state = SessionState.ESTABLISHED # Process ES message self.process_es_message(es_message) def process_es_message(self, es_message): \u0026#34;\u0026#34;\u0026#34;Decrypt and process ES message\u0026#34;\u0026#34;\u0026#34; # Extract tag tag = es_message[0:8] ciphertext = es_message[8:] # Look up tag index = self.inbound_tagset.lookup_tag(tag) if index is None: raise ValueError(\u0026#34;Tag not found\u0026#34;) # Get key key = self.inbound_keyratchet.get_key(index) # Construct nonce nonce = construct_nonce(index) # Decrypt try: payload = DECRYPT(key, nonce, ciphertext, tag) except AuthenticationError: raise ValueError(\u0026#34;ES MAC verification failed\u0026#34;) # Process blocks self.process_payload_blocks(payload) # Update activity self.last_activity = now() Классификация сообщений Различение типов сообщений:\ndef classify_message(message): \u0026#34;\u0026#34;\u0026#34;Determine message type\u0026#34;\u0026#34;\u0026#34; # Minimum lengths if len(message) \u0026lt; 24: return None # Too short # Check for session tag (8 bytes) tag = message[0:8] # Try ES decryption first (most common) session = lookup_session_by_tag(tag) if session: return (\u0026#39;ES\u0026#39;, session) # Try NSR decryption (tag + Elligator2 key) if len(message) \u0026gt;= 72: # Check if bytes 8-40 are valid Elligator2 try: nsr_ephemeral = DECODE_ELG2(message[8:40]) nsr_session = find_pending_nsr_by_tag(tag) if nsr_session: return (\u0026#39;NSR\u0026#39;, nsr_session) except: pass # Try NS decryption (starts with Elligator2 key) if len(message) \u0026gt;= 96: try: ns_ephemeral = DECODE_ELG2(message[0:32]) ns_session = InboundSession.try_decrypt_ns(message) if ns_session: return (\u0026#39;NS\u0026#39;, ns_session) except: pass # Check ElGamal/AES (for dual-key compatibility) if len(message) \u0026gt;= 514: if (len(message) - 2) % 16 == 0: # Might be ElGamal NS return (\u0026#39;ELGAMAL_NS\u0026#39;, None) elif len(message) % 16 == 0: # Might be ElGamal ES return (\u0026#39;ELGAMAL_ES\u0026#39;, None) return None # Unknown message type Лучшие практики управления сессиями Хранилище сеанса:\nclass SessionKeyManager: def __init__(self): # Outbound sessions (one per destination) self.outbound_sessions = {} # destination -\u0026gt; OutboundSession # Inbound sessions (multiple per destination during transition) self.inbound_sessions = [] # [InboundSession] # Session tag lookup (fast path for ES messages) self.tag_to_session = {} # tag -\u0026gt; InboundSession # Limits self.max_inbound_sessions = 1000 self.max_tags_per_session = 160 def get_outbound_session(self, destination): \u0026#34;\u0026#34;\u0026#34;Get or create outbound session\u0026#34;\u0026#34;\u0026#34; if destination not in self.outbound_sessions: session = OutboundSession(destination) self.outbound_sessions[destination] = session return self.outbound_sessions[destination] def add_inbound_session(self, session): \u0026#34;\u0026#34;\u0026#34;Add new inbound session\u0026#34;\u0026#34;\u0026#34; # Check limits if len(self.inbound_sessions) \u0026gt;= self.max_inbound_sessions: self.expire_oldest_session() self.inbound_sessions.append(session) # Add tags to lookup table self.register_session_tags(session) def register_session_tags(self, session): \u0026#34;\u0026#34;\u0026#34;Register session\u0026#39;s tags in lookup table\u0026#34;\u0026#34;\u0026#34; for tag in session.inbound_tagset.get_all_tags(): self.tag_to_session[tag] = session def lookup_tag(self, tag): \u0026#34;\u0026#34;\u0026#34;Fast tag lookup\u0026#34;\u0026#34;\u0026#34; return self.tag_to_session.get(tag) def expire_sessions(self): \u0026#34;\u0026#34;\u0026#34;Periodic session expiration\u0026#34;\u0026#34;\u0026#34; now_time = now() # Expire outbound sessions for dest, session in list(self.outbound_sessions.items()): if session.idle_time(now_time) \u0026gt; 8 * 60: del self.outbound_sessions[dest] # Expire inbound sessions expired = [] for session in self.inbound_sessions: if session.idle_time(now_time) \u0026gt; 10 * 60: expired.append(session) for session in expired: self.remove_inbound_session(session) def remove_inbound_session(self, session): \u0026#34;\u0026#34;\u0026#34;Remove inbound session and clean up tags\u0026#34;\u0026#34;\u0026#34; self.inbound_sessions.remove(session) # Remove tags from lookup for tag in session.inbound_tagset.get_all_tags(): if tag in self.tag_to_session: del self.tag_to_session[tag] Управление памятью:\nclass TagMemoryManager: def __init__(self, max_memory_kb=10240): # 10 MB default self.max_memory = max_memory_kb * 1024 self.current_memory = 0 self.max_tags_per_session = 160 self.min_tags_per_session = 32 def calculate_tag_memory(self, session): \u0026#34;\u0026#34;\u0026#34;Calculate memory used by session tags\u0026#34;\u0026#34;\u0026#34; tag_count = len(session.inbound_tagset.tags) # Each tag: 8 bytes (tag) + 2 bytes (index) + 32 bytes (key, optional) # + overhead bytes_per_tag = 16 if session.defer_keys else 48 return tag_count * bytes_per_tag def check_pressure(self): \u0026#34;\u0026#34;\u0026#34;Check if under memory pressure\u0026#34;\u0026#34;\u0026#34; return self.current_memory \u0026gt; (self.max_memory * 0.9) def handle_pressure(self): \u0026#34;\u0026#34;\u0026#34;Reduce memory usage when under pressure\u0026#34;\u0026#34;\u0026#34; if not self.check_pressure(): return # Strategy 1: Reduce look-ahead windows for session in all_sessions: if session.look_ahead \u0026gt; self.min_tags_per_session: session.reduce_look_ahead(self.min_tags_per_session) # Strategy 2: Trim old tags aggressively for session in all_sessions: session.inbound_tagset.trim_behind(aggressive=True) # Strategy 3: Refuse new ratchets for session in all_sessions: if session.outbound_tagset.should_ratchet(): session.defer_ratchet = True # Strategy 4: Expire idle sessions early expire_idle_sessions(threshold=5*60) # 5 min instead of 10 Стратегии тестирования Модульные тесты:\ndef test_x25519_dh(): \u0026#34;\u0026#34;\u0026#34;Test X25519 key exchange\u0026#34;\u0026#34;\u0026#34; alice_sk = GENERATE_PRIVATE() alice_pk = DERIVE_PUBLIC(alice_sk) bob_sk = GENERATE_PRIVATE() bob_pk = DERIVE_PUBLIC(bob_sk) # Both sides compute same shared secret alice_shared = DH(alice_sk, bob_pk) bob_shared = DH(bob_sk, alice_pk) assert alice_shared == bob_shared def test_elligator2_encode_decode(): \u0026#34;\u0026#34;\u0026#34;Test Elligator2 roundtrip\u0026#34;\u0026#34;\u0026#34; sk = GENERATE_PRIVATE_ELG2() pk = DERIVE_PUBLIC(sk) encoded = ENCODE_ELG2(pk) decoded = DECODE_ELG2(encoded) assert decoded == pk def test_chacha_poly_encrypt_decrypt(): \u0026#34;\u0026#34;\u0026#34;Test ChaCha20-Poly1305 AEAD\u0026#34;\u0026#34;\u0026#34; key = CSRNG(32) nonce = construct_nonce(42) plaintext = b\u0026#34;Hello, I2P!\u0026#34; ad = b\u0026#34;associated_data\u0026#34; ciphertext = ENCRYPT(key, nonce, plaintext, ad) decrypted = DECRYPT(key, nonce, ciphertext, ad) assert decrypted == plaintext def test_session_tag_ratchet(): \u0026#34;\u0026#34;\u0026#34;Test session tag generation\u0026#34;\u0026#34;\u0026#34; sessTag_ck = CSRNG(32) tagset = SessionTagRatchet(sessTag_ck) # Generate 100 tags tags = [tagset.get_next_tag() for _ in range(100)] # All tags should be unique assert len(set(tags)) == 100 # Each tag should be 8 bytes for tag in tags: assert len(tag) == 8 Интеграционные тесты:\ndef test_ns_nsr_handshake(): \u0026#34;\u0026#34;\u0026#34;Test NS/NSR handshake\u0026#34;\u0026#34;\u0026#34; # Alice creates outbound session alice_session = OutboundSession(bob_destination, bound=True) # Alice sends NS ns_message = alice_session.build_ns_message(b\u0026#34;Hello Bob\u0026#34;) # Bob receives NS bob_session = InboundSession.try_decrypt_ns(ns_message) assert bob_session is not None assert bob_session.bound == True # Bob sends NSR nsr_message = bob_session.build_nsr_message(b\u0026#34;Hello Alice\u0026#34;) # Alice receives NSR alice_session.on_nsr_received(nsr_message) assert alice_session.state == SessionState.ESTABLISHED # Both should have matching ES tagsets # (Cannot directly compare, but can test by sending ES messages) def test_es_bidirectional(): \u0026#34;\u0026#34;\u0026#34;Test ES messages in both directions\u0026#34;\u0026#34;\u0026#34; # (After NS/NSR handshake) # Alice sends ES to Bob es_alice_to_bob = alice_session.send_es_message(b\u0026#34;Data from Alice\u0026#34;) # Bob receives ES bob_session.process_es_message(es_alice_to_bob) # Bob sends ES to Alice es_bob_to_alice = bob_session.send_es_message(b\u0026#34;Data from Bob\u0026#34;) # Alice receives ES alice_session.process_es_message(es_bob_to_alice) def test_dh_ratchet(): \u0026#34;\u0026#34;\u0026#34;Test DH ratchet\u0026#34;\u0026#34;\u0026#34; # (After established session) # Alice initiates ratchet alice_session.initiate_ratchet() nextkey_alice = build_nextkey_block( flags=0x01, key_id=0, public_key=alice_new_key ) # Send to Bob bob_session.process_nextkey_block(nextkey_alice) # Bob replies nextkey_bob = build_nextkey_block( flags=0x03, key_id=0, public_key=bob_new_key ) # Send to Alice alice_session.process_nextkey_block(nextkey_bob) # Both should now be using new tagsets assert alice_session.outbound_tagset.id == 1 assert bob_session.inbound_tagset.id == 1 Тестовые векторы:\nРеализовать тестовые векторы из спецификации:\nРукопожатие Noise IK: Используйте стандартные тестовые векторы Noise HKDF: Используйте тестовые векторы из RFC 5869 ChaCha20-Poly1305: Используйте тестовые векторы из RFC 7539 Elligator2: Используйте тестовые векторы из статьи по Elligator2 или из OBFS4 Тестирование на совместимость:\nJava I2P: Протестируйте на совместимость с эталонной реализацией Java I2P i2pd: Протестируйте на совместимость с реализацией i2pd на C++ Захваты пакетов: Используйте диссектор Wireshark (если доступен) для проверки форматов сообщений Межреализационное тестирование: Создайте тестовый стенд, который может отправлять/принимать данные между реализациями Соображения по производительности Генерация ключей:\nГенерация ключей Elligator2 (криптографическая схема маскировки ключей) вычислительно затратна (50% уровень отбраковки):\nclass KeyPool: \u0026#34;\u0026#34;\u0026#34;Pre-generate keys in background thread\u0026#34;\u0026#34;\u0026#34; def __init__(self, pool_size=10): self.pool = Queue(maxsize=pool_size) self.generator_thread = Thread(target=self.generate_keys, daemon=True) self.generator_thread.start() def generate_keys(self): while True: if not self.pool.full(): keypair = generate_elg2_keypair() # Also compute encoded form encoded = ENCODE_ELG2(keypair.public_key) self.pool.put((keypair, encoded)) else: sleep(0.1) def get_keypair(self): try: return self.pool.get(timeout=1.0) except Empty: # Pool exhausted, generate inline return generate_elg2_keypair() Поиск тегов:\nИспользуйте хеш-таблицы для поиска тегов за O(1):\nclass FastTagLookup: def __init__(self): self.tag_to_session = {} # Python dict is hash table def add_tag(self, tag, session, index): # 8-byte tag as bytes is hashable self.tag_to_session[tag] = (session, index) def lookup_tag(self, tag): return self.tag_to_session.get(tag) Оптимизация памяти:\nОтложенная генерация симметричного ключа:\nclass DeferredKeyRatchet: \u0026#34;\u0026#34;\u0026#34;Only generate keys when needed\u0026#34;\u0026#34;\u0026#34; def __init__(self, symmKey_ck): self.chainKey = symmKey_ck self.index = -1 self.cache = LRUCache(maxsize=32) # Cache recent keys def get_key(self, index): # Check cache first if index in self.cache: return self.cache[index] # Generate keys up to index while self.index \u0026lt; index: self.index += 1 keydata = HKDF(self.chainKey, ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) self.chainKey = keydata[0:31] if self.index == index: key = keydata[32:63] self.cache[index] = key return key Пакетная обработка:\nОбрабатывайте несколько сообщений пакетно:\ndef process_message_batch(messages): \u0026#34;\u0026#34;\u0026#34;Process multiple messages efficiently\u0026#34;\u0026#34;\u0026#34; results = [] # Group by type ns_messages = [] nsr_messages = [] es_messages = [] for msg in messages: msg_type = classify_message(msg) if msg_type[0] == \u0026#39;NS\u0026#39;: ns_messages.append(msg) elif msg_type[0] == \u0026#39;NSR\u0026#39;: nsr_messages.append(msg) elif msg_type[0] == \u0026#39;ES\u0026#39;: es_messages.append(msg) # Process in batches # ES messages are most common, process first for msg in es_messages: results.append(process_es_message(msg)) for msg in nsr_messages: results.append(process_nsr_message(msg)) for msg in ns_messages: results.append(process_ns_message(msg)) return results Соображения безопасности Модель угроз Возможности противника:\nПассивный наблюдатель: Может наблюдать весь сетевой трафик Активный атакующий: Может внедрять, изменять, отбрасывать, повторно воспроизводить сообщения Скомпрометированный узел: Может скомпрометировать router или назначение Анализ трафика: Может выполнять статистический анализ шаблонов трафика Цели безопасности:\nКонфиденциальность: Содержимое сообщений скрыто от наблюдателя Аутентификация: Личность отправителя подтверждена (для привязанных сеансов) Прямая секретность: Прошлые сообщения остаются секретными, даже если ключи скомпрометированы Защита от повторов: Нельзя повторно передать старые сообщения Маскировка трафика: Рукопожатия неотличимы от случайных данных Криптографические предположения Предположения о сложности:\nX25519 CDH: Вычислительная задача Диффи — Хеллмана трудна на Curve25519 ChaCha20 PRF: ChaCha20 является псевдослучайной функцией Poly1305 MAC: Poly1305 обеспечивает неподделываемость при атаке с выбранным сообщением SHA-256 CR: SHA-256 обладает стойкостью к коллизиям HKDF Security: HKDF извлекает и расширяет, обеспечивая равномерно распределённые ключи Уровни безопасности:\nX25519: стойкость ~128 бит (порядок кривой 2^252) ChaCha20: ключи 256 бит, стойкость 256 бит Poly1305: стойкость 128 бит (вероятность коллизии) SHA-256: стойкость к коллизиям 128 бит, стойкость к поиску прообраза 256 бит Управление ключами Генерация ключей:\n# CRITICAL: Use cryptographically secure RNG def CSRNG(length): # GOOD: os.urandom, secrets.token_bytes (Python) # GOOD: /dev/urandom (Linux) # GOOD: BCryptGenRandom (Windows) # BAD: random.random(), Math.random() (NOT cryptographically secure) return os.urandom(length) # CRITICAL: Validate keys def validate_x25519_key(pubkey): # Check for weak keys (all zeros, small order points) if pubkey == bytes(32): raise WeakKeyError(\u0026#34;All-zero public key\u0026#34;) # Perform DH to check for weak shared secrets test_shared = DH(test_private_key, pubkey) if test_shared == bytes(32): raise WeakKeyError(\u0026#34;Results in zero shared secret\u0026#34;) Хранилище ключей:\n# CRITICAL: Protect private keys class SecureKeyStorage: def __init__(self): # Store in memory with protection self.keys = {} # Option 1: Memory locking (prevent swapping to disk) # mlock(self.keys) # Option 2: Encrypted storage # self.encryption_key = derive_from_password() def store_key(self, key_id, private_key): # Option: Encrypt before storage # encrypted = encrypt(private_key, self.encryption_key) # self.keys[key_id] = encrypted self.keys[key_id] = private_key def delete_key(self, key_id): # Securely wipe memory if key_id in self.keys: key = self.keys[key_id] # Overwrite with zeros before deletion for i in range(len(key)): key[i] = 0 del self.keys[key_id] Ротация ключей:\n# CRITICAL: Rotate keys regularly class KeyRotationPolicy: def __init__(self): self.max_messages_per_tagset = 4096 # Ratchet before 65535 self.max_tagset_age = 10 * 60 # 10 minutes self.max_session_age = 60 * 60 # 1 hour def should_ratchet(self, tagset): return (tagset.messages_sent \u0026gt;= self.max_messages_per_tagset or tagset.age() \u0026gt;= self.max_tagset_age) def should_replace_session(self, session): return session.age() \u0026gt;= self.max_session_age Меры по противодействию атакам Меры против атак повторного воспроизведения Валидация даты и времени:\nMAX_CLOCK_SKEW_PAST = 5 * 60 MAX_CLOCK_SKEW_FUTURE = 2 * 60 def validate_datetime(timestamp): now = int(time.time()) age = now - timestamp if age \u0026lt; -MAX_CLOCK_SKEW_FUTURE: raise ReplayError(\u0026#34;Timestamp too far in future\u0026#34;) if age \u0026gt; MAX_CLOCK_SKEW_PAST: raise ReplayError(\u0026#34;Timestamp too old\u0026#34;) return True Фильтр Блума для сообщений NS:\nclass ReplayFilter: def __init__(self, capacity=100000, error_rate=0.001, duration=5*60): self.bloom = BloomFilter(capacity=capacity, error_rate=error_rate) self.duration = duration self.entries = [] # (timestamp, ephemeral_key) def check_replay(self, ephemeral_key, timestamp): # Validate timestamp if not validate_datetime(timestamp): return False # Check Bloom filter if ephemeral_key in self.bloom: # Potential replay (or false positive) # Check exact match in entries for ts, key in self.entries: if key == ephemeral_key: return False # Definite replay # Add to filter self.bloom.add(ephemeral_key) self.entries.append((timestamp, ephemeral_key)) # Expire old entries self.expire_old_entries() return True def expire_old_entries(self): now = int(time.time()) self.entries = [(ts, key) for ts, key in self.entries if now - ts \u0026lt; self.duration] Одноразовое использование сеансового тега:\ndef process_session_tag(tag): # Look up tag entry = tagset.lookup_tag(tag) if entry is None: raise ValueError(\u0026#34;Invalid session tag\u0026#34;) # CRITICAL: Remove tag immediately (one-time use) tagset.remove_tag(tag) # Use associated key return entry.key, entry.index Меры по снижению риска подмены личности при компрометации ключа (KCI) Проблема: аутентификация сообщений NS уязвима к атаке KCI (имперсонация при компрометации ключа) (Уровень аутентификации 1)\nМеры по смягчению:\nПерейдите на NSR (уровень аутентификации 2) как можно скорее Не доверяйте полезной нагрузке NS при выполнении операций, критичных для безопасности Дождитесь подтверждения NSR перед выполнением необратимых действий def process_ns_message(ns_message): # NS authenticated at Level 1 (KCI vulnerable) # Do NOT perform security-critical operations yet # Extract sender\u0026#39;s static key sender_key = ns_message.static_key # Mark session as pending Level 2 authentication session.auth_level = 1 session.sender_key = sender_key # Send NSR send_nsr_reply(session) def process_first_es_message(es_message): # Now we have Level 2 authentication (KCI resistant) session.auth_level = 2 # Safe to perform security-critical operations process_security_critical_operation(es_message) Меры противодействия атакам отказа в обслуживании Защита от флуда NS:\nclass NSFloodProtection: def __init__(self): self.ns_count = defaultdict(int) # source -\u0026gt; count self.ns_timestamps = defaultdict(list) # source -\u0026gt; [timestamps] self.max_ns_per_source = 5 self.rate_window = 10 # seconds self.max_concurrent_ns = 100 def check_ns_allowed(self, source): # Global limit total_pending = sum(self.ns_count.values()) if total_pending \u0026gt;= self.max_concurrent_ns: return False # Per-source rate limit now = time.time() timestamps = self.ns_timestamps[source] # Remove old timestamps timestamps = [ts for ts in timestamps if now - ts \u0026lt; self.rate_window] self.ns_timestamps[source] = timestamps # Check rate if len(timestamps) \u0026gt;= self.max_ns_per_source: return False # Allow NS timestamps.append(now) self.ns_count[source] += 1 return True def on_session_established(self, source): # Decrease pending count if self.ns_count[source] \u0026gt; 0: self.ns_count[source] -= 1 Ограничения на хранение тегов:\nclass TagStorageLimit: def __init__(self, max_tags=1000000): self.max_tags = max_tags self.current_tags = 0 def can_create_session(self, look_ahead): if self.current_tags + look_ahead \u0026gt; self.max_tags: return False return True def add_tags(self, count): self.current_tags += count def remove_tags(self, count): self.current_tags -= count Адаптивное управление ресурсами:\nclass AdaptiveResourceManager: def __init__(self): self.load_level = 0 # 0 = low, 1 = medium, 2 = high, 3 = critical def adjust_parameters(self): if self.load_level == 0: # Normal operation return { \u0026#39;max_look_ahead\u0026#39;: 160, \u0026#39;max_sessions\u0026#39;: 1000, \u0026#39;session_timeout\u0026#39;: 10 * 60 } elif self.load_level == 1: # Moderate load return { \u0026#39;max_look_ahead\u0026#39;: 80, \u0026#39;max_sessions\u0026#39;: 800, \u0026#39;session_timeout\u0026#39;: 8 * 60 } elif self.load_level == 2: # High load return { \u0026#39;max_look_ahead\u0026#39;: 32, \u0026#39;max_sessions\u0026#39;: 500, \u0026#39;session_timeout\u0026#39;: 5 * 60 } else: # load_level == 3 # Critical load return { \u0026#39;max_look_ahead\u0026#39;: 16, \u0026#39;max_sessions\u0026#39;: 200, \u0026#39;session_timeout\u0026#39;: 3 * 60 } Устойчивость к анализу трафика Кодирование Elligator2:\nГарантирует, что сообщения рукопожатия неотличимы от случайных:\n# NS and NSR start with Elligator2-encoded ephemeral keys # Observer cannot distinguish from random 32-byte string Стратегии заполнения:\n# Resist message size fingerprinting def add_padding(payload, strategy=\u0026#39;random\u0026#39;): if strategy == \u0026#39;random\u0026#39;: # Random padding 0-15 bytes size = random.randint(0, 15) elif strategy == \u0026#39;round\u0026#39;: # Round to next 64-byte boundary target = ((len(payload) + 63) // 64) * 64 size = target - len(payload) - 3 # -3 for block header elif strategy == \u0026#39;fixed\u0026#39;: # Always 1KB messages size = 1024 - len(payload) - 3 return build_padding_block(size) Атаки по времени:\n# CRITICAL: Use constant-time operations def constant_time_compare(a, b): \u0026#34;\u0026#34;\u0026#34;Constant-time byte string comparison\u0026#34;\u0026#34;\u0026#34; if len(a) != len(b): return False result = 0 for x, y in zip(a, b): result |= x ^ y return result == 0 # CRITICAL: Constant-time MAC verification def verify_mac(computed_mac, received_mac): if not constant_time_compare(computed_mac, received_mac): # Always take same time regardless of where comparison fails raise AuthenticationError(\u0026#34;MAC verification failed\u0026#34;) Подводные камни реализации Распространенные ошибки:\nПовторное использование nonce (одноразового значения): НИКОГДА не используйте повторно пары (key, nonce) # BAD: Reusing nonce with same key ciphertext1 = ENCRYPT(key, nonce, plaintext1, ad1) ciphertext2 = ENCRYPT(key, nonce, plaintext2, ad2) # CATASTROPHIC ПРАВИЛЬНО: Уникальный одноразовый номер для каждого сообщения ciphertext1 = ENCRYPT(key, nonce1, plaintext1, ad1) ciphertext2 = ENCRYPT(key, nonce2, plaintext2, ad2) 2. **Ephemeral Key Reuse**: Generate fresh ephemeral key for each NS/NSR ```python # ПЛОХО: Повторное использование эфемерного ключа ephemeral_key = generate_elg2_keypair() send_ns_message(ephemeral_key) send_ns_message(ephemeral_key) # ПЛОХО # ХОРОШО: Новый ключ для каждого сообщения send_ns_message(generate_elg2_keypair()) send_ns_message(generate_elg2_keypair()) Weak RNG: Use cryptographically secure random number generator ПЛОХО: Некриптографический генератор случайных чисел import random key = bytes([random.randint(0, 255) for _ in range(32)]) # НЕБЕЗОПАСНО ХОРОШО: Криптографически стойкий RNG (генератор случайных чисел) import os key = os.urandom(32) 4. **Timing Attacks**: Use constant-time comparisons ```python # ПЛОХО: сравнение с ранним выходом if computed_mac == received_mac: # утечка по времени pass # ПРАВИЛЬНО: Сравнение за константное время if constant_time_compare(computed_mac, received_mac): pass Incomplete MAC Verification: Always verify before using data ПЛОХО: Расшифровка до проверки plaintext = chacha20_decrypt(key, nonce, ciphertext) mac_ok = verify_mac(mac, plaintext) # СЛИШКОМ ПОЗДНО if not mac_ok: return error ХОРОШО: AEAD проверяет перед расшифрованием try: plaintext = DECRYPT(key, nonce, ciphertext, ad) # Verifies MAC first except AuthenticationError:\nreturn error 6. **Key Deletion**: Securely wipe keys from memory ```python # ПЛОХО: Простое удаление del private_key # Все еще в памяти # ПРАВИЛЬНО: Перезаписывайте перед удалением for i in range(len(private_key)): private_key[i] = 0 del private_key Security Audits Recommended Audits:\nCryptographic Review: Expert review of KDF chains and DH operations Implementation Audit: Code review for timing attacks, key management, RNG usage Protocol Analysis: Formal verification of handshake security properties Side-Channel Analysis: Timing, power, and cache attacks Fuzzing: Random input testing for parser robustness Test Cases:\n# Критически важные для безопасности тест-кейсы def test_nonce_uniqueness(): \u0026#34;\u0026#34;\u0026#34;Ensure nonces are never reused\u0026#34;\u0026#34;\u0026#34; nonces = set() for i in range(10000): nonce = construct_nonce(i) assert nonce not in nonces nonces.add(nonce) def test_key_isolation(): \u0026#34;\u0026#34;\u0026#34;Ensure sessions don\u0026#39;t share keys\u0026#34;\u0026#34;\u0026#34; session1 = create_session(destination1) session2 = create_session(destination2) assert session1.key != session2.key def test_replay_prevention(): \u0026#34;\u0026#34;\u0026#34;Ensure replay attacks are detected\u0026#34;\u0026#34;\u0026#34; ns_message = create_ns_message() # First delivery succeeds assert process_ns_message(ns_message) == True # Replay fails assert process_ns_message(ns_message) == False def test_mac_verification(): \u0026#34;\u0026#34;\u0026#34;Ensure MAC verification is enforced\u0026#34;\u0026#34;\u0026#34; key = CSRNG(32) nonce = construct_nonce(0) plaintext = b\u0026#34;test\u0026#34; ad = b\u0026#34;test_ad\u0026#34; ciphertext = ENCRYPT(key, nonce, plaintext, ad) # Correct MAC verifies assert DECRYPT(key, nonce, ciphertext, ad) == plaintext # Corrupted MAC fails corrupted = ciphertext[:-1] + bytes([ciphertext[-1] ^ 0xFF]) with pytest.raises(AuthenticationError): DECRYPT(key, nonce, corrupted, ad) Configuration and Deployment I2CP Configuration Enable ECIES Encryption:\n# Только ECIES (схема интегрированного шифрования на эллиптических кривых) (рекомендуется для новых развертываний) i2cp.leaseSetEncType=4 # Двухключевая (ECIES (схема шифрования на эллиптических кривых) + ElGamal (криптосистема Эль-Гамаля) для совместимости) i2cp.leaseSetEncType=4,0 # Только ElGamal (устаревший, не рекомендуется) i2cp.leaseSetEncType=0 LeaseSet Type:\n# Стандартный LS2 (leaseSet версии 2; наиболее распространённый) i2cp.leaseSetType=3 # Зашифрованный LS2 (blinded destinations — скрытые назначения) i2cp.leaseSetType=5 # Мета LS2 (несколько назначений) i2cp.leaseSetType=7 Additional Options:\n# Статический ключ для ECIES (необязательно, автоматически создаётся, если не указано) # 32-байтный открытый ключ X25519, закодированный в Base64 i2cp.leaseSetPrivateKey=\u0026lt;base64-encoded-key\u0026gt; # Тип подписи (для LeaseSet) i2cp.leaseSetSigningPrivateKey=\u0026lt;base64-encoded-key\u0026gt; i2cp.leaseSetSigningType=7 # Ed25519 Java I2P Configuration router.config:\n# ECIES между router-ами i2p.router.useECIES=true Build Properties:\n// Для клиентов I2CP (Java) Properties props = new Properties(); props.setProperty(\u0026#34;i2cp.leaseSetEncType\u0026#34;, \u0026#34;4\u0026#34;); props.setProperty(\u0026#34;i2cp.leaseSetType\u0026#34;, \u0026#34;3\u0026#34;); I2PSession session = i2pClient.createSession(props); i2pd Configuration i2pd.conf:\n[ограничения] # Лимит памяти для сессий ECIES (схема интегрированного шифрования на эллиптических кривых) ecies.memory = 128M [ecies] # Включить ECIES (интегрированная схема шифрования на эллиптических кривых) enabled = true # Только ECIES (схема шифрования на эллиптических кривых) или dual-key (двухключевой режим) compatibility = true # true = dual-key (двухключевой режим), false = ECIES-only (только ECIES) Tunnels Configuration:\n[my-service] type = http host = 127.0.0.1 port = 8080 keys = my-service-keys.dat # Только ECIES (интегрированная схема шифрования на эллиптических кривых) ecies = true Compatibility Matrix Router Version Support:\nVersion ECIES Support LS2 Support Dual-Key Notes \u0026lt; 0.9.38 ❌ No ❌ No N/A Legacy only 0.9.38-0.9.45 ❌ No ✅ Yes N/A LS2 only 0.9.46-0.9.50 ✅ Yes ✅ Yes ✅ Yes Initial ECIES 1.5.0+ ✅ Yes ✅ Yes ✅ Yes Current 2.0.0+ ✅ Yes ✅ Yes ✅ Yes Current Destination Compatibility:\nDestination Type Can Connect To Notes ECIES-only ECIES-only, Dual-key Requires 0.9.46+ routers Dual-key Any Maximum compatibility ElGamal-only ElGamal-only, Dual-key Legacy FloodFill Requirements:\nECIES-only destinations: Require majority of floodfills on 0.9.46+ for encrypted lookups Dual-key destinations: Work with any floodfill version Current status: Near 100% floodfill adoption as of 2025 Migration Guide Migrating from ElGamal to ECIES:\nStep 1: Enable Dual-Key Mode\n# Добавить ECIES, сохранив ElGamal i2cp.leaseSetEncType=4,0 Step 2: Monitor Connections\n# Проверьте типы соединений i2prouter.exe status # или http://127.0.0.1:7657/peers Step 3: Switch to ECIES-Only (after testing)\n# Удалить ElGamal (криптографический алгоритм Эль‑Гамаля) i2cp.leaseSetEncType=4 Step 4: Restart Application\n# Перезапустите I2P router или приложение systemctl restart i2p # или i2prouter.exe restart Rollback Plan:\n# Вернитесь к режиму только ElGamal при возникновении проблем i2cp.leaseSetEncType=0 Performance Tuning Session Limits:\n# Максимальное число входящих сеансов i2p.router.maxInboundSessions=1000 # Максимальное количество исходящих сеансов i2p.router.maxOutboundSessions=1000 # Тайм-аут сеанса (секунды) i2p.router.sessionTimeout=600 Memory Limits:\n# Лимит хранения тегов (КБ) i2p.ecies.maxTagMemory=10240 # 10 МБ # Окно упреждающего просмотра i2p.ecies.tagLookAhead=160 i2p.ecies.tagLookAheadMin=32 Ratchet Policy:\n# Сообщения до начала ratchet (криптографического механизма «трещотка») i2p.ecies.ratchetThreshold=4096 # Время до срабатывания ratchet (криптографический механизм обновления ключей) (секунды) i2p.ecies.ratchetTimeout=600 # 10 минут Monitoring and Debugging Logging:\n# Включить отладочное логирование для ECIES (интегрированная схема шифрования на эллиптических кривых) logger.i2p.router.transport.ecies=DEBUG Metrics:\nMonitor these metrics:\nNS Success Rate: Percentage of NS messages receiving NSR Session Establishment Time: Time from NS to first ES Tag Storage Usage: Current memory usage for tags Ratchet Frequency: How often sessions ratchet Session Lifetime: Average session duration Common Issues:\nNS Timeout: No NSR received\nCheck destination is online Check floodfill availability Verify LeaseSet published correctly High Memory Usage: Too many tags stored\nReduce look-ahead window Decrease session timeout Implement aggressive expiration Frequent Ratchets: Sessions ratcheting too often\nIncrease ratchet threshold Check for retransmissions Session Failures: ES messages failing to decrypt\nVerify tag synchronization Check for replay attacks Validate nonce construction References Specifications ECIES Proposal: Proposal 144 I2NP: I2NP Specification Common Structures: Common Structures Specification NTCP2: NTCP2 Specification SSU2: SSU2 Specification I2CP: I2CP Specification ElGamal/AES+SessionTags: ElGamal/AES Specification Cryptographic Standards Noise Protocol Framework: Noise Specification (Revision 34, 2018-07-11) Signal Double Ratchet: Signal Specification RFC 7748: Elliptic Curves for Security (X25519) RFC 7539: ChaCha20 and Poly1305 for IETF Protocols RFC 5869: HKDF (HMAC-based Key Derivation Function) RFC 2104: HMAC: Keyed-Hashing for Message Authentication Elligator2: Elligator Paper Implementation Resources Java I2P: i2p.i2p Repository i2pd (C++): i2pd Repository OBFS4 (Elligator2): obfs4proxy Repository Additional Information I2P Website: / I2P Forum: https://i2pforum.net I2P Wiki: https://wiki.i2p-projekt.de Appendix A: KDF Summary All KDF Operations in ECIES:\nOperation Input Info String Output NS Initial ChainKey protocol_name (none - SHA256) h, chainKey NS Static Key Section chainKey, es_shared \"\" chainKey, k NS Payload Section (bound) chainKey, ss_shared \"\" chainKey, k NSR Tagset chainKey \"SessionReplyTags\" tagsetKey NSR ee DH chainKey, ee_shared \"\" chainKey NSR se DH chainKey, se_shared \"\" chainKey, k NSR Split chainKey \"\" k_ab, k_ba NSR Payload k_ba \"AttachPayloadKDF\" k_nsr DH Initialize rootKey, k \"KDFDHRatchetStep\" nextRootKey, chainKey Tag and Key Chain Keys chainKey \"TagAndKeyGenKeys\" sessTag_ck, symmKey_ck Session Tag Init sessTag_ck \"STInitialization\" chainKey, CONSTANT Session Tag Gen chainKey, CONSTANT \"SessionTagKeyGen\" chainKey, tag Symmetric Key Gen chainKey \"SymmetricRatchet\" chainKey, key DH Ratchet sharedSecret \"XDHRatchetTagSet\" tagsetKey Appendix B: Message Size Calculator Calculate message sizes for capacity planning:\ndef calculate_ns_size(payload_size, bound=True): \u0026#34;\u0026#34;\u0026#34;Calculate New Session message size\u0026#34;\u0026#34;\u0026#34; ephemeral_key = 32 static_section = 32 + 16 # encrypted + MAC payload_encrypted = payload_size + 16 # + MAC return ephemeral_key + static_section + payload_encrypted def calculate_nsr_size(payload_size): \u0026#34;\u0026#34;\u0026#34;Calculate New Session Reply message size\u0026#34;\u0026#34;\u0026#34; tag = 8 ephemeral_key = 32 key_section_mac = 16 payload_encrypted = payload_size + 16 # + MAC return tag + ephemeral_key + key_section_mac + payload_encrypted def calculate_es_size(payload_size): \u0026#34;\u0026#34;\u0026#34;Calculate Existing Session message size\u0026#34;\u0026#34;\u0026#34; tag = 8 payload_encrypted = payload_size + 16 # + MAC return tag + payload_encrypted # Примеры print(\u0026#34;NS (с привязкой, полезная нагрузка 1 КБ):\u0026#34;, calculate_ns_size(1024, bound=True), \u0026#34;байт\u0026#34;) # Вывод: 1120 байт print(\u0026#34;NSR (1 КБ полезной нагрузки):\u0026#34;, calculate_nsr_size(1024), \u0026#34;байт\u0026#34;) # Вывод: 1096 байт print(\u0026#34;ES (полезная нагрузка 1 КБ):\u0026#34;, calculate_es_size(1024), \u0026#34;байт\u0026#34;) # Вывод: 1048 байт Appendix C: Glossary AEAD: Authenticated Encryption with Associated Data - encryption mode that provides both confidentiality and authenticity\nAuthentication Level: Noise protocol security property indicating strength of sender identity verification\nBinding: Association of a session with a specific far-end destination\nChaCha20: Stream cipher designed by Daniel J. Bernstein\nChainKey: Cryptographic key used in HKDF chains to derive subsequent keys\nConfidentiality Level: Noise protocol security property indicating strength of forward secrecy\nDH: Diffie-Hellman key agreement protocol\nElligator2: Encoding technique to make elliptic curve points indistinguishable from random\nEphemeral Key: Short-lived key used only for a single handshake\nES: Existing Session message (used after handshake completion)\nForward Secrecy: Property ensuring past communications remain secure if keys are compromised\nGarlic Clove: I2NP message container for end-to-end delivery\nHKDF: HMAC-based Key Derivation Function\nIK Pattern: Noise handshake pattern where initiator sends static key immediately\nKCI: Key Compromise Impersonation attack\nKDF: Key Derivation Function - cryptographic function for generating keys from other keys\nLeaseSet: I2P structure containing a destination\u0026rsquo;s public keys and tunnel information\nLS2: LeaseSet version 2 with encryption type support\nMAC: Message Authentication Code - cryptographic checksum proving authenticity\nMixHash: Noise protocol function for maintaining running hash transcript\nNS: New Session message (initiates new session)\nNSR: New Session Reply message (response to NS)\nNonce: Number used once - ensures unique encryption even with same key\nPairing: Linking an inbound session with an outbound session for bidirectional communication\nPoly1305: Message authentication code designed by Daniel J. Bernstein\nRatchet: Cryptographic mechanism for deriving sequential keys\nSession Tag: 8-byte one-time identifier for existing session messages\nStatic Key: Long-term key associated with a destination\u0026rsquo;s identity\nTag Set: Collection of session tags derived from a common root\nX25519: Elliptic curve Diffie-Hellman key agreement using Curve25519\n","description":"Интегрированная схема шифрования на эллиптических кривых для I2P (X25519 + AEAD)","id":"82b727dd29ed7e2e04873dac8c2acf51","section":"docs","title":"Спецификация шифрования ECIES-X25519-AEAD-Ratchet","url":"/ru/docs/specs/ecies/"},{"categories":null,"content":" Статус «устаревшее»: Этот материал сохранён исключительно для исторической справки. Он описывает tunnel-систему, поставлявшуюся до I2P 0.6.1.10, и не должен использоваться для современной разработки. Для рекомендаций по промышленной эксплуатации обратитесь к текущей реализации .\nИсходная подсистема tunnel также использовала однонаправленные tunnels, но отличалась структурой сообщений, механизмом обнаружения дубликатов и стратегией построения. Многие разделы ниже отражают структуру устаревшего документа для облегчения сравнения.\n1. Обзор Tunnel Tunnels строились как упорядоченные последовательности пиров, выбранных создателем. Длины tunnels находились в диапазоне 0–7 hops (переходов), при этом было несколько настроек для заполнения, ограничения скорости и генерации chaff (мусорного трафика). Входящие tunnels доставляли сообщения от недоверенного шлюза к создателю (конечной точке); исходящие tunnels пересылали данные от создателя наружу. Срок жизни tunnels составлял 10 минут, после чего строились новые tunnels (часто с использованием тех же пиров, но с другими tunnel IDs). 2. Функционирование в устаревшей архитектуре 2.1 Предварительная обработка сообщений Шлюзы накопили ≤32 KB полезной нагрузки I2NP, выбрали заполнение и сформировали полезную нагрузку, содержащую:\nДвухбайтовое поле длины заполнения и соответствующее число случайных байтов Последовательность пар {instructions, I2NP message}, описывающих цели доставки, фрагментацию и необязательные задержки Полные сообщения I2NP, дополненные до границы в 16 байт Инструкции доставки упаковывали маршрутную информацию в битовые поля (тип доставки, флаги задержки, флаги фрагментации и необязательные расширения). Фрагментированные сообщения содержали 4-байтовый идентификатор сообщения плюс флаг индекса/последнего фрагмента.\n2.2 Шифрование на шлюзе В устаревшем дизайне длина tunnel на этапе шифрования была фиксирована — восемь переходов. Шлюзы накладывали слоями блоки AES-256/CBC и блоки контрольной суммы, чтобы каждый переход мог проверять целостность, не уменьшая полезную нагрузку. Сама контрольная сумма представляла собой блок, полученный на основе SHA-256, встроенный в сообщение.\n2.3 Поведение участников Узлы отслеживали идентификаторы входящих tunnel, проверяли целостность на раннем этапе и отбрасывали дубликаты перед пересылкой. Поскольку padding (заполнение) и проверочные блоки были встроены, размер сообщения оставался постоянным независимо от числа хопов.\n2.4 Обработка конечной точки Конечные точки последовательно расшифровали многослойные блоки, проверили контрольные суммы и разделили полезную нагрузку обратно на закодированные инструкции и сообщения I2NP для последующей доставки.\n3. Построение Tunnel (устаревший процесс) Выбор пиров: Пиры выбирались из локально ведённых профилей (exploratory — исследовательские, client — клиентские). В исходном документе уже подчёркивалось снижение риска атаки предшественника путём повторного использования упорядоченных списков пиров для каждого пула tunnel. Доставка запросов: Сообщения построения передавались от хопа к хопу, с зашифрованными секциями для каждого пира. Альтернативные идеи, такие как телескопическое расширение, перемаршрутизация на середине пути или удаление блоков контрольной суммы, обсуждались как эксперименты, но так и не были приняты. Пулы: У каждой локальной Destination (адрес назначения) были отдельные входящие и исходящие пулы. Настройки включали желаемое количество, резервные tunnels, разброс длины, ограничение скорости и политики пэддинга. 4. Концепции ограничения скорости и смешивания Старый документ предложил несколько стратегий, которые повлияли на последующие релизы:\nВзвешенное случайное раннее отбрасывание (WRED) для контроля перегрузок Дросселирование для каждого tunnel на основе скользящих средних недавнего использования Необязательные настройки chaff (фиктивного трафика) и пакетирования (реализовано не полностью) 5. Архивные альтернативы Разделы исходного документа рассматривали идеи, которые так и не были внедрены:\nУдаление блоков контрольных сумм для сокращения обработки на каждом хопе Телескопирование tunnels по ходу для изменения состава пиров Переход на двунаправленные tunnels (в итоге отклонено) Использование более коротких хэшей или иных схем дополнения Эти идеи остаются ценным историческим контекстом, но не отражают актуальную кодовую базу.\nСсылки Оригинальный архив устаревших документов (до версии 0.6.1.10) Обзор Tunnel по актуальной терминологии Профилирование и выбор пиров по современным эвристикам ","description":"Архивное описание архитектуры tunnel, использовавшейся до версии I2P 0.6.1.10.","id":"0970f5387a965fe6857e4afbb03bdc8f","section":"docs","title":"Старая реализация Tunnel (устаревшая)","url":"/ru/docs/legacy/old-implementation/"},{"categories":null,"content":"Эта реализация I2P (Java-реализация, распространяемая на этом сайте) включает «Список строгих стран», используемый для корректировки поведения router в регионах, где участие в маршрутизации трафика для других пользователей может быть ограничено законом. Хотя нам не известно о юрисдикциях, которые запрещают использование I2P, в некоторых действуют широкие запреты на ретрансляцию трафика. Router, которые, по всей видимости, находятся в «строгих» странах, автоматически переводятся в скрытый режим (Hidden mode).\nПроект ссылается на исследования организаций по защите гражданских и цифровых прав при принятии этих решений. В частности, текущие исследования Freedom House информируют наш выбор. Общая рекомендация заключается в том, чтобы включать страны с оценкой гражданских свобод (CL) 16 или менее, или оценкой интернет-свободы 39 или менее (несвободные).\nОбзор скрытого режима Когда роутер переводится в скрытый режим, три ключевых аспекта его поведения изменяются:\nОн не публикует RouterInfo в netDb. Он не принимает транзитные туннели (participating tunnels). Он отклоняет прямые соединения с роутерами в той же стране. Эти защитные меры затрудняют надёжное перечисление роутеров и снижают риск нарушения местных запретов на ретрансляцию трафика для других пользователей.\nСписок стран со строгими ограничениями (по состоянию на 2024 год) /* Afghanistan */ \u0026#34;AF\u0026#34;, /* Azerbaijan */ \u0026#34;AZ\u0026#34;, /* Bahrain */ \u0026#34;BH\u0026#34;, /* Belarus */ \u0026#34;BY\u0026#34;, /* Brunei */ \u0026#34;BN\u0026#34;, /* Burundi */ \u0026#34;BI\u0026#34;, /* Cameroon */ \u0026#34;CM\u0026#34;, /* Central African Republic */ \u0026#34;CF\u0026#34;, /* Chad */ \u0026#34;TD\u0026#34;, /* China */ \u0026#34;CN\u0026#34;, /* Cuba */ \u0026#34;CU\u0026#34;, /* Democratic Republic of the Congo */ \u0026#34;CD\u0026#34;, /* Egypt */ \u0026#34;EG\u0026#34;, /* Equatorial Guinea */ \u0026#34;GQ\u0026#34;, /* Eritrea */ \u0026#34;ER\u0026#34;, /* Ethiopia */ \u0026#34;ET\u0026#34;, /* Iran */ \u0026#34;IR\u0026#34;, /* Iraq */ \u0026#34;IQ\u0026#34;, /* Kazakhstan */ \u0026#34;KZ\u0026#34;, /* Laos */ \u0026#34;LA\u0026#34;, /* Libya */ \u0026#34;LY\u0026#34;, /* Myanmar */ \u0026#34;MM\u0026#34;, /* North Korea */ \u0026#34;KP\u0026#34;, /* Palestinian Territories */ \u0026#34;PS\u0026#34;, /* Pakistan */ \u0026#34;PK\u0026#34;, /* Rwanda */ \u0026#34;RW\u0026#34;, /* Saudi Arabia */ \u0026#34;SA\u0026#34;, /* Somalia */ \u0026#34;SO\u0026#34;, /* South Sudan */ \u0026#34;SS\u0026#34;, /* Sudan */ \u0026#34;SD\u0026#34;, /* Eswatini (Swaziland) */ \u0026#34;SZ\u0026#34;, /* Syria */ \u0026#34;SY\u0026#34;, /* Tajikistan */ \u0026#34;TJ\u0026#34;, /* Thailand */ \u0026#34;TH\u0026#34;, /* Turkey */ \u0026#34;TR\u0026#34;, /* Turkmenistan */ \u0026#34;TM\u0026#34;, /* Venezuela */ \u0026#34;VE\u0026#34;, /* United Arab Emirates */ \u0026#34;AE\u0026#34;, /* Uzbekistan */ \u0026#34;UZ\u0026#34;, /* Vietnam */ \u0026#34;VN\u0026#34;, /* Western Sahara */ \u0026#34;EH\u0026#34;, /* Yemen */ \u0026#34;YE\u0026#34; Если вы считаете, что страну следует добавить в строгий список или удалить из него, пожалуйста, создайте issue: https://i2pgit.org/i2p/i2p.i2p/ Справочная информация: Freedom House – https://freedomhouse.org/ ","description":"Как I2P ведёт себя в юрисдикциях с ограничениями на маршрутизацию или инструменты анонимности (скрытый режим и строгий список)","id":"483dc8380c381981cff8df178412f086","section":"docs","title":"Строгие/Ограничивающие страны","url":"/ru/docs/overview/restrictive-countries/"},{"categories":null,"content":"Обзор В этом документе описывается схема подписи с возможностью повторной рандомизации, подходящая для создания Destinations, которые можно ослеплять. Кроме того, её можно использовать для ослепления существующих Ed25519 Destinations с небольшим снижением эффективности.\nRed25519 полностью поддерживается в I2P routers начиная с версии 0.9.39 (выпущенной 21 марта 2019 года). Данная спецификация была финализирована в версии 0.9.47 (август 2020) после 17 месяцев промышленной эксплуатации. Схема подписи используется как тип подписи 11 (RedDSA_SHA512_Ed25519) в сети I2P.\nМотивация Предложение 123 (Новые записи netDB) определяет зашифрованный формат LeaseSet2, воплощающий принцип наименьших полномочий: каждому участнику сети предоставляется только информация, необходимая для его роли. В частности, зашифрованный LeaseSet2, публикуемый на floodfill, не раскрывает Destination (адрес назначения в I2P), для которого он предназначен, а содержащиеся в нём Leases могут быть просмотрены только тем, кто заранее знает этот Destination. Однако floodfills по-прежнему должны иметь возможность аутентифицировать публикуемые зашифрованные LeaseSet2, а клиентам дополнительно необходимо удостовериться, что эта аутентификация была обеспечена самим Destination.\nПредложение 123 достигает этого путём ослепления подписывающих ключей Destinations (идентификаторов назначения в I2P). Ослеплённые ключи можно использовать для создания подписей, которые могут быть проверены floodfills, и клиенты могут быть уверены, что только Destination мог создать эти подписи. Поэтому необходимо определить схему подписи, которую можно использовать для ослепления.\nПримечание о статусе Proposal 123: Части Proposal 123 были реализованы и постепенно внедрялись начиная с версии 0.9.38, при этом поддержка Red25519 была добавлена в версии 0.9.39. Функциональность шифрованного LeaseSet2 готова к промышленной эксплуатации и активно используется в сети I2P для скрытых сервисов с повышенной конфиденциальностью.\nПроектирование Основная схема подписи Схема подписи, описанная здесь, Red25519, является конкретной реализацией RedDSA, как определено в разделе 5.4.6 спецификации протокола Zcash (Sapling и новее). RedDSA — это схема подписи на основе Шнорра, которая поддерживает перерандомизацию ключей. Она имеет следующие функции:\nGENERATE_PRIVATE() : Возвращает равновероятно выбранный закрытый ключ.\nDERIVE_PUBLIC(sk) : Возвращает открытый ключ, соответствующий заданному закрытому ключу.\nGENERATE_RANDOM() : Возвращает случайный скаляр, подходящий для повторной рандомизации ключевой пары.\nRANDOMIZE_PRIVATE(sk, alpha) : Повторно рандомизирует закрытый ключ, используя секретный скаляр alpha.\nRANDOMIZE_PUBLIC(vk, alpha) : Повторно рандомизирует открытый ключ, используя секретный скаляр alpha.\nSIGN(sk, m) : Возвращает подпись, вычисленную закрытым ключом sk для заданного сообщения m.\nVERIFY(vk, m, sig) : Проверяет подпись sig на соответствие открытому ключу vk и сообщению m. Возвращает true, если подпись действительна, иначе false.\nДля заданной пары ключей (sk, vk) выполняется следующее соотношение:\nRANDOMIZE_PUBLIC(vk, alpha) == DERIVE_PUBLIC(RANDOMIZE_PRIVATE(sk, alpha)) Преобразование ключей Ed25519 в Red25519 Ключи Ed25519 МОГУТ быть временно односторонне преобразованы в ключи Red25519, чтобы поддержать повторную рандомизацию существующих Ed25519 Destinations (идентификаторы назначения в I2P). Другие типы подписи несовместимы.\nМы определяем следующие функции преобразования:\nCONVERT_ED25519_PRIVATE(privkey) : Возвращает закрытый ключ Red25519, соответствующий заданному закрытому ключу Ed25519.\nCONVERT_ED25519_PUBLIC(pubkey) : Возвращает открытый ключ Red25519, соответствующий заданному открытому ключу Ed25519.\nДля заданной пары ключей Ed25519 (privkey, pubkey) выполняется следующее соотношение:\nCONVERT_ED25519_PUBLIC(pubkey) == DERIVE_PUBLIC(CONVERT_ED25519_PRIVATE(privkey)) Спецификация Определения B : Базовая точка Ed25519, как в RFC 8032 .\nL : Порядок группы Ed25519 2^252 + 27742317777372353535851937790883648493, как в RFC 8032 .\n[s] B : Скалярное умножение базовой точки на s при фиксированной базе.\n[s] A : Скалярное умножение точки A на скаляр s с переменным основанием.\nx || y : Конкатенация двух байтовых массивов x и y.\nRed25519 (тип подписи на основе Ed25519, используемый в I2P) Схема Red25519 (вариант RedDSA) специализирует RedDSA (криптографическая схема подписи) следующим образом:\nG := группа точек на форме Эдвардса кривой Curve25519. В частности, это означает, что Red25519 использует подгруппу простого порядка L, а кофактор h_G равен 8. P_G := базовая точка Ed25519 B. l_H := 512 H(x) := SHA-512(\u0026ldquo;I2P_Red25519H(x)\u0026rdquo; || x) Примечание о выборе функции хеширования: Red25519 использует SHA-512 вместо BLAKE2b-512 (как в Zcash RedDSA). Этот выбор компенсируется описанной ниже защитой методом префиксирования длины. I2P Proposal 148 предлагает в будущем перейти на BLAKE2b-512 для усиления защиты от идентификации дубликатов сообщений (DMI) и атак расширения длины (LEA), а также для повышения производительности.\nВ RedDSA предполагается, что H(x) реализован с использованием криптографической хеш-функции, устойчивой к атакам на расширение длины. Сам по себе SHA-512 этому требованию не удовлетворяет. Чтобы исправить это, мы требуем, чтобы сообщения предварялись префиксно-свободным кодированием их длины:\nlen_u16(M) || M где len_u16(M) — это 2-байтовое представление длины M в формате little-endian (порядок от младшего к старшему байту), для согласованности с кодированием скаляров и точек в формате little-endian.\nСообщения не должны быть длиннее 65534 байт. Длина 65535 зарезервирована для возможных будущих расширений.\nПримечание по безопасности: Включение публичного ключа (vk) в хеш-функцию в сочетании с 80 случайными байтами при подписании обеспечивает защиту от уязвимостей класса SURK-CMA (Strong Unforgeability with Re-randomized Keys under Chosen Message Attack — «сильная стойкость к подделке при атаке с выбранным сообщением для повторно рандомизированных ключей»), обнаруженных в ранних вариантах RedDSA (схема цифровой подписи для Zcash). В этой реализации включены исправления безопасности из аудита Zcash компании NCC Group (замечание NCC-Zcash2018-009).\nКодирование и декодирование Закрытые ключи Red25519 — это скаляры по модулю L, кодируемые в представлении little-endian. Мы определяем функции DECODE_SCALAR и ENCODE_SCALAR для взаимного преобразования между байтовым массивом и целочисленной формой скаляра.\nОткрытые ключи Red25519 — это точки на кривой Curve25519 в форме Эдвардса. Они кодируются как 255-битное представление координаты y в формате little-endian, за которым следует один бит, указывающий знак координаты x. Это та же схема кодирования, что и у Ed25519. Мы определяем функции DECODE_POINT и ENCODE_POINT для взаимного преобразования между байтовым массивом и координатным представлением точки.\nФункции RedDSA (схема цифровой подписи) Для упрощения реализации ниже мы явно приводим функции RedDSA (а также несколько вспомогательных функций), уже специализированные для Red25519. Разработчикам следует обратиться к разделу 5.4.6 Спецификации протокола Zcash для общей спецификации функций RedDSA.\nHStar(prefix1, prefix2, m) := h = SHA-512() h.input(\u0026#34;I2P_Red25519H(x)\u0026#34;) h.input(prefix1) h.input(prefix2) h.input(len(m) \u0026amp; 0xff) h.input((len(m) \u0026gt;\u0026gt; 8) \u0026amp; 0xff) h.input(m) s = h.digest() return s mod L GENERATE_PRIVATE := s = 64 random bytes return s mod L DERIVE_PUBLIC(sk) := [sk] B GENERATE_RANDOM := s = 64 random bytes return s mod L RANDOMIZE_PRIVATE(sk, alpha) := (sk + alpha) mod L RANDOMIZE_PUBLIC(vk, alpha) := vk + [alpha] B SIGN(sk, m) := T = 80 random bytes vkBytes = ENCODE_POINT(DERIVE_PUBLIC(sk)) r = HStar(T, vkBytes, m) R = [r] B Rbytes = ENCODE_POINT(R) c = HStar(Rbytes, vkBytes, m) S = (r + (c * sk)) mod L return Rbytes || ENCODE_SCALAR(S) VERIFY(vk, m, sig) := Rbytes = sig[0..32] Sbytes = sig[32..64] R = DECODE_POINT(Rbytes) if R is invalid: return false S = DECODE_SCALAR(Sbytes) if S \u0026gt;= L: return false vkBytes = ENCODE_POINT(vk) c = HStar(Rbytes, vkBytes, m) return ((-[S] B) + R + ([c] vk)).multiplyByCofactor().isIdentity() Функции преобразования CONVERT_ED25519_PRIVATE(privkey) := s = SHA-512(privkey)[0..32] s[0] = s[0] \u0026amp; 248 s[31] = (s[31] \u0026amp; 63) | 64 return s CONVERT_ED25519_PUBLIC(pubkey) := pubkey Обратите внимание, что реализация CONVERT_ED25519_PRIVATE эквивалентна вычислению секретного скаляра s при получении открытого ключа Ed25519 из закрытого ключа Ed25519, как указано в шагах 1-3 раздела 5.1.5 RFC 8032 .\nПоследствия для безопасности Повторная рандомизация Red25519 Destination (адреса назначения) и последующее создание подписей с ним не приводит к утечке какой-либо информации о Destination, поскольку распределение закрытых ключей Red25519, генерируемых с помощью RANDOMIZE_PRIVATE, идентично распределению закрытых ключей, генерируемых с помощью GENERATE_PRIVATE, а DERIVE_PUBLIC выполняется детерминированно.\nПреобразование закрытых ключей Ed25519 в Red25519 с помощью CONVERT_ED25519_PRIVATE не приводит к тому же распределению. Тем не менее, мы считаем снижение уровня безопасности приемлемым по следующим причинам:\nПространство скаляров Ed25519 приблизительно вдвое меньше пространства скаляров Red25519 (существует 2^251 возможных скаляров Ed25519, и L ~= 2^252 возможных скаляров Red25519). Следовательно, снижение стойкости — не более чем примерно в 2 раза, то есть примерно на 1 бит (поскольку мы могли случайно выбрать скаляр Red25519, который также является допустимым скаляром Ed25519). Существующие назначения Ed25519 ранее уже были видимы в сети, и следует исходить из того, что злонамеренные floodfills уже их проиндексировали. Важно: Пользователям, которых беспокоит это снижение уровня безопасности, следует использовать Red25519 (тип подписи 11) в качестве типа подписи (sigtype) для своих Destinations (идентификаторов назначения) вместо Ed25519 (тип подписи 7).\nОтметим, что вышеизложенный аргумент не применим к скаляру перерандомизации alpha; каждый раз, когда выбирается смещённый alpha, происходит утечка информации о ключе, поскольку аддитивная перерандомизация ведёт себя как одноразовый блокнот.\nСтатус аудита безопасности Важное раскрытие информации: I2P, включая Red25519, никогда не проходил формального аудита безопасности третьей стороной. Базовый дизайн RedDSA проходил проверку безопасности компанией NCC Group в рамках аудита протокола Zcash Sapling в 2018 году, в ходе которого были выявлены и исправлены уязвимости. Однако конкретная реализация I2P с использованием SHA-512 (вместо BLAKE2b-512) и I2P domain separation (доменное разделение) не подвергалась независимому анализу.\nЭталонная реализация ed25519-java от str4d прошла один независимый аудит, проведённый третьей стороной, но он предшествовал реализации Red25519 и охватывал только функциональность Ed25519, а не расширения Red25519.\nПользователи, внедряющие Red25519 (криптографическая схема), должны понимать это ограничение и оценивать компромиссы в области безопасности с учётом своей модели угроз.\nСовместимость Версии I2P с поддержкой Red25519 (0.9.39 и новее) смогут проверять сетевые структуры данных, подписанные с использованием Red25519. Версии I2P без поддержки Red25519 будут рассматривать такую подпись как неизвестную и МОГУТ отбрасывать соответствующие структуры данных.\nХронология развертывания: - 0.9.39 (март 2019): Первая реализация с поддержкой Encrypted LS2 (зашифрованный LeaseSet v2) в floodfills - 0.9.40 (май 2019): По-клиентная авторизация для Encrypted LS2 - 0.9.41 (август 2019): Meta LS2 и Encrypted LS2 с офлайн-ключами - 0.9.43 (февраль 2020): Поддержка b32 для Encrypted LS2 - 0.9.47 (август 2020): Финализация спецификации - 2.10.0 (октябрь 2025): Текущая версия сети (эквивалент 0.9.67+)\nПользователи могут рассчитывать на хорошую надежность структур данных, подписанных Red25519, для сценариев использования Encrypted LeaseSet2, поскольку у сети было более шести лет на обновление с момента первоначальной реализации. Однако метрики принятия для общего использования destination (идентификатор назначения в I2P) публично недоступны.\nОсновной сценарий использования: Red25519 в первую очередь применяется для функциональности зашифрованного LeaseSet2, где требуется ослепление ключа. Для стандартных назначений без требований к зашифрованному leaseSet Ed25519 (тип подписи 7) остаётся рекомендуемым выбором благодаря более широкой совместимости и более длительной проверенной историей использования.\nПримечания по реализации Red25519 реализован в I2P Java router в net.i2p.crypto.eddsa.RedDSAEngine и использует библиотеку ed25519-java от str4d (Jack Grigg) в качестве зависимости Maven net.i2p.crypto:eddsa (версии 0.1.0–0.3.0).\nРеализация i2pd на C++ также поддерживает Red25519 (signaturetype=11) для публикации зашифрованного LeaseSet.\nПример конфигурации для i2pd:\nsignaturetype=11 i2cp.leaseSetType=5 Совместимость зашифрованного LeaseSet2: Спецификация зашифрованного LeaseSet требует, чтобы открытый ключ подписи в неослеплённом назначении был Ed25519 (тип подписи 7) или Red25519 (тип подписи 11). Другие типы подписи для функциональности зашифрованного leaseset не поддерживаются.\nТестовые векторы Следующие тестовые векторы предоставлены для проверки корректности реализации. Каждый вектор содержит:\nedsk: закрытый ключ Ed25519 (случайный) edpk: открытый ключ Ed25519, соответствующий edsk sk: CONVERT_ED25519_PRIVATE(edsk) vk: CONVERT_ED25519_PUBLIC(edpk) msg: сообщение для подписи sig: SIGN(sk, msg) alpha: GENERATE_RANDOM() rsk: RANDOMIZE_PRIVATE(sk, alpha) rvk: RANDOMIZE_PUBLIC(vk, alpha) rsig: SIGN(rsk, msg) Примечание по реализации: Эти тестовые векторы следует интегрировать в автоматизированные наборы модульных тестов для непрерывной проверки. Разработчикам следует проверять, что все преобразования, подписи и операции по повторной рандомизации соответствуют этим ожидаемым значениям.\nТестовый вектор 1 edsk: 0101010101010101010101010101010101010101010101010101010101010101 edpk: 8a88e3dd7409f195fd52db2d3cba5d72ca6709bf1d94121bf3748801b40f6f5c sk: 58e86efb75fa4e2c410f46e16de9f6acae1a1703528651b69bc176c088bef36e vk: 8a88e3dd7409f195fd52db2d3cba5d72ca6709bf1d94121bf3748801b40f6f5c msg: 0202020202020202020202020202020202020202020202020202020202020202 sig: 61f5527f4d3b46de4b2c234390370bf715ae9098907a0d191ba1b44b23a8ac1a 6a40437a5294e9503faaf9bd2b7f2fe7ba44dec487b3185aba7ff7d7a17cd40f alpha: ae9ba9cbbc047c442448fca7c9f4e288a202ed520bfad0c784b792b7773cee08 rsk: 8bb85f3c7a494a08890d7d142109c1a3501d04565d80227e2079097800fbe107 rvk: 6fe128737b8e76fa66698a748b0dc0a89168dd8a0601c2b1c0b26835d323e9b3 rsig: 533053074d3b44f08723aab988ede9880a001b7a684d4a98f2d1b88fabee07a5 b5c9430c69a690321e0cb8365d7aeb6688bcbad2c0780e0c69e8a1b4a45f3001 Тестовый вектор 2 edsk: 0202020202020202020202020202020202020202020202020202020202020202 edpk: 8139770ea87d175f56a35466c34c7ecccb8d8a91b4ee37a25df60f5b8fc9b394 sk: a83c626bc9c38c8c201878ebb1d5b0b50ac40e8986c78793db1d4ef369fca14e vk: 8139770ea87d175f56a35466c34c7ecccb8d8a91b4ee37a25df60f5b8fc9b394 msg: 0303030303030303030303030303030303030303030303030303030303030303 sig: 0829e58eb5399870f009bd1f0270264e556424bda7a93fbcec99f6d9d75db46d 5c3cb546d9947ca7c1200876c8775a90c357a2aef3d2f16388242ee1914b1a0a alpha: 98b615d9027e996cc2796c019d9c8beb46aa7d2b6eea2e5d98eb29eb1584c203 rsk: 9fcfaa734852ca40b3810ebef590e138516e8cb4f4b1b6f0730978de7f806402 rvk: 527e121090158419609e4a0d8de6f7d3271b353a8cd0b8172fe41468ea1e9177 rsig: 9a6961f35ed264a946cd6214b2326a6e6caa426c2a61bc14367fd278e0b5fb51 3ac065a69210a457f17d12ba8a496cfd835002691affa8efcdecae48135c090f Примечание: Дополнительные тестовые векторы 3-10 следуют тому же формату и могут быть найдены в референсной реализации.\nСсылки Предложение 123: Новые записи netDB - Части реализованы и развернуты в 0.9.38, 0.9.39 и более поздних релизах Спецификация протокола Zcash, раздел 5.4.6: RedDSA, RedJubjub и RedPallas - RedDSA определена как часть спецификации протокола Zcash; прошла аудит безопасности компанией NCC Group (январь 2019) RFC 8032: Алгоритм цифровой подписи на кривых Эдвардса (EdDSA) Предложение 148: RedDSA-BLAKE2b-Ed25519 - Предложено, но ещё не реализовано; предполагает будущую миграцию на BLAKE2b-512 Спецификация зашифрованного LeaseSet Спецификация низкоуровневой криптографии ","description":"Перерандомизируемая схема подписи для создания ослеплённых Destinations (адресов назначения в I2P)","id":"31b087e2977ad9f01f6b3b93e6af1f20","section":"docs","title":"Схема подписи Red25519","url":"/ru/docs/specs/red25519-signature-scheme/"},{"categories":null,"content":"Обзор NTCP2 заменяет устаревший транспорт NTCP рукопожатием на базе протокола Noise, которое устойчиво к фингерпринтингу трафика, шифрует поля длины и поддерживает современные наборы шифров. Routers могут запускать NTCP2 вместе с SSU2 как два обязательных транспортных протокола в сети I2P. NTCP (версия 1) был объявлен устаревшим в 0.9.40 (май 2019) и полностью удалён в 0.9.50 (май 2021).\nФреймворк протоколов Noise NTCP2 использует фреймворк протокола Noise Ревизия 33, 2017-10-04 с расширениями, специфичными для I2P:\nШаблон: Noise_XK_25519_ChaChaPoly_SHA256 Расширенный идентификатор: Noise_XKaesobfse+hs2+hs3_25519_ChaChaPoly_SHA256 (для инициализации KDF (функции выработки ключей)) Функция DH: X25519 (RFC 7748) - 32-байтные ключи, кодирование little-endian Шифр: AEAD_CHACHA20_POLY1305 (RFC 7539/RFC 8439) 12-байтный nonce (одноразовое значение): первые 4 байта — нули, последние 8 байт — счетчик (little-endian) Максимальное значение nonce: 2^64 - 2 (соединение должно быть завершено до достижения 2^64 - 1) Хеш-функция: SHA-256 (32-байтный вывод) MAC: Poly1305 (16-байтный тег аутентификации) Расширения, специфичные для I2P AES-обфускация: Эфемерные ключи зашифрованы с помощью AES-256-CBC с использованием хеша router Боба и опубликованного IV Случайный паддинг: Паддинг в открытом виде в сообщениях 1-2 (аутентифицирован), паддинг AEAD в сообщениях 3+ (зашифрован) Обфускация длины SipHash-2-4: Двухбайтовые длины кадров побитово складываются по XOR с выходом SipHash Структура кадров: Кадры с префиксом длины для фазы данных (совместимость с потоковой передачей по TCP) Блочно-ориентированные полезные данные: Структурированный формат данных с типизированными блоками Последовательность рукопожатия Alice (Initiator) Bob (Responder) SessionRequest ──────────────────────► ◄────────────────────── SessionCreated SessionConfirmed ──────────────────────► Рукопожатие из трех сообщений SessionRequest - замаскированный эфемерный ключ Алисы, параметры, подсказки по padding (заполнению) SessionCreated - замаскированный эфемерный ключ Боба, зашифрованные параметры, padding SessionConfirmed - зашифрованный статический ключ Алисы и RouterInfo (два AEAD-фрейма) Шаблоны сообщений Noise XK(s, rs): Authentication Confidentiality \u0026lt;- s (Bob\u0026#39;s static key known in advance) -\u0026gt; e, es 0 2 \u0026lt;- e, ee 2 1 -\u0026gt; s, se 2 5 \u0026lt;- 2 5 Уровни аутентификации: - 0: Без аутентификации (кто угодно мог отправить) - 2: Аутентификация отправителя, устойчивая к key-compromise impersonation (KCI, подмене личности при компрометации ключа)\nУровни конфиденциальности: - 1: Эфемерный получатель (прямая секретность, без аутентификации получателя) - 2: Известный получатель, прямая секретность только при компрометации отправителя - 5: Сильная прямая секретность (эфемерный-эфемерный + эфемерный-статический DH (Диффи — Хеллман))\nСпецификации сообщений Обозначения ключей RH_A = Router Hash для Алисы (32 байта, SHA-256) RH_B = Router Hash для Боба (32 байта, SHA-256) || = Оператор конкатенации byte(n) = Один байт со значением n Все многобайтовые целые числа — биг-эндиан (если не указано иное) Ключи X25519 — литтл-эндиан (32 байта) Аутентифицированное шифрование (ChaCha20-Poly1305) Функция шифрования:\nAEAD_ChaCha20_Poly1305(key, nonce, associatedData, plaintext) → (ciphertext || MAC) Параметры: - key: 32-байтный ключ шифрования из KDF (функции деривации ключа) - nonce: 12 байт (4 нулевых байта + 8-байтный счётчик, little-endian) - associatedData: 32-байтный хеш в фазе рукопожатия; нулевой длины в фазе передачи данных - plaintext: Данные для шифрования (0+ байт)\nВывод: - Шифротекст: той же длины, что и открытый текст - MAC: 16 байт (аутентификационный тег Poly1305)\nУправление Nonce (одноразовым числом): - Счетчик начинается с 0 для каждого экземпляра шифра - Увеличивается при каждой операции AEAD в данном направлении - Отдельные счетчики для Alice→Bob и Bob→Alice на этапе передачи данных - Соединение должно быть завершено до того, как счетчик достигнет 2^64 - 1\nСообщение 1: SessionRequest Алиса инициирует соединение с Бобом.\nОперации Noise: e, es (генерация и обмен эфемерными ключами)\nНеобработанный формат +----+----+----+----+----+----+----+----+ | | + AES-256-CBC Encrypted X (32B) + | Key: RH_B, IV: Bob\u0026#39;s published IV | + + | | +----+----+----+----+----+----+----+----+ | | + ChaChaPoly Frame (48 bytes) + | Plaintext: 32B (X + options) | + k from KDF-1, n=0, ad=h + | | +----+----+----+----+----+----+----+----+ | Cleartext Padding (optional) | + Length specified in options + | 0 to 65535 - 80 bytes | ~ . . . ~ +----+----+----+----+----+----+----+----+ Ограничения по размеру: - Минимум: 80 байт (32 AES + 48 AEAD) - Максимум: 65535 байт всего - Особый случай: Максимум 287 байт при подключении к адресам \u0026ldquo;NTCP\u0026rdquo; (определение версии)\nРасшифрованное содержимое +----+----+----+----+----+----+----+----+ | | + X (Alice ephemeral public key) + | 32 bytes, X25519, little-endian | + + | | +----+----+----+----+----+----+----+----+ | Options Block | + (16 bytes) + | | +----+----+----+----+----+----+----+----+ | Cleartext Padding (optional) | ~ . . . ~ +----+----+----+----+----+----+----+----+ Блок опций (16 байт, big-endian (старший байт первым)) +----+----+----+----+----+----+----+----+ | id | ver| padLen | m3p2len | Rsvd(0) | +----+----+----+----+----+----+----+----+ | tsA | Reserved (0) | +----+----+----+----+----+----+----+----+ id : 1 byte - Network ID (2 for mainnet, 16-254 for testnets) ver : 1 byte - Protocol version (currently 2) padLen : 2 bytes - Padding length in this message (0-65455) m3p2len : 2 bytes - Length of SessionConfirmed part 2 frame Rsvd : 2 bytes - Reserved, set to 0 tsA : 4 bytes - Unix timestamp (seconds since epoch) Reserved: 4 bytes - Reserved, set to 0 Критические поля: - Идентификатор сети (начиная с 0.9.42): Быстрое отклонение соединений между разными сетями - m3p2len: Точный размер части 2 сообщения 3 (должен совпадать при отправке)\nФункция выработки ключа (KDF-1) Инициализация протокола:\nprotocol_name = \u0026#34;Noise_XKaesobfse+hs2+hs3_25519_ChaChaPoly_SHA256\u0026#34; h = SHA256(protocol_name) ck = h // Chaining key initialized to hash Операции MixHash:\nh = SHA256(h) // Null prologue h = SHA256(h || rs) // Bob\u0026#39;s static key (known) h = SHA256(h || e.pubkey) // Alice\u0026#39;s ephemeral key X // h is now the associated data for message 1 AEAD Операция MixKey (es pattern, шаблон рукопожатия ephemeral-static):\ndh_result = X25519(Alice.ephemeral_private, Bob.static_public) temp_key = HMAC-SHA256(ck, dh_result) ck = HMAC-SHA256(temp_key, byte(0x01)) k = HMAC-SHA256(temp_key, ck || byte(0x02)) // k is the cipher key for message 1 // ck is retained for message 2 KDF Примечания по реализации AES Obfuscation: Используется только для устойчивости к DPI (глубокая инспекция пакетов); любой, у кого есть хеш router Боба и IV (инициализационный вектор), может расшифровать X Replay Prevention: Боб должен кэшировать значения X (или их зашифрованные эквиваленты) не менее 2*D секунд (D = макс. рассинхронизация часов) Timestamp Validation: Боб должен отклонять соединения с |tsA - current_time| \u0026gt; D (обычно D = 60 секунд) Curve Validation: Боб должен проверить, что X — корректная точка X25519 Fast Rejection: Боб может проверить X[31] \u0026amp; 0x80 == 0 до расшифрования (у корректных ключей X25519 старший бит сброшен) Error Handling: При любом сбое Боб закрывает соединение отправкой TCP RST после случайной задержки и чтения случайного числа байтов Buffering: Алиса должна сбрасывать весь буфер сообщения (включая паддинг) сразу для эффективности Сообщение 2: SessionCreated Боб отвечает Алисе.\nОперации Noise: e, ee (эфемерно-эфемерный Диффи-Хеллман)\nНеобработанный формат +----+----+----+----+----+----+----+----+ | | + AES-256-CBC Encrypted Y (32B) + | Key: RH_B, IV: AES state from msg1 | + + | | +----+----+----+----+----+----+----+----+ | | + ChaChaPoly Frame (48 bytes) + | Plaintext: 32B (Y + options) | + k from KDF-2, n=0, ad=h + | | +----+----+----+----+----+----+----+----+ | Cleartext Padding (optional) | + Length specified in options + | 0 to 65535 - 80 bytes | ~ . . . ~ +----+----+----+----+----+----+----+----+ Расшифрованное содержимое +----+----+----+----+----+----+----+----+ | | + Y (Bob ephemeral public key) + | 32 bytes, X25519, little-endian | + + | | +----+----+----+----+----+----+----+----+ | Options Block | + (16 bytes) + | | +----+----+----+----+----+----+----+----+ | Cleartext Padding (optional) | ~ . . . ~ +----+----+----+----+----+----+----+----+ Блок параметров (16 байт, big-endian (старший байт первым)) +----+----+----+----+----+----+----+----+ | Rsvd(0) | padLen | Reserved (0) | +----+----+----+----+----+----+----+----+ | tsB | Reserved (0) | +----+----+----+----+----+----+----+----+ Rsvd : 2 bytes - Reserved, set to 0 padLen : 2 bytes - Padding length in this message Reserved: 10 bytes - Reserved, set to 0 tsB : 4 bytes - Unix timestamp (seconds since epoch) Функция выработки ключей (KDF-2) Операции MixHash:\nh = SHA256(h || encrypted_payload_msg1) // 32-byte ciphertext if (msg1_padding_length \u0026gt; 0): h = SHA256(h || padding_from_msg1) h = SHA256(h || e.pubkey) // Bob\u0026#39;s ephemeral key Y // h is now the associated data for message 2 AEAD Операция MixKey (шаблон ee):\ndh_result = X25519(Bob.ephemeral_private, Alice.ephemeral_public) temp_key = HMAC-SHA256(ck, dh_result) ck = HMAC-SHA256(temp_key, byte(0x01)) k = HMAC-SHA256(temp_key, ck || byte(0x02)) // k is the cipher key for message 2 // ck is retained for message 3 KDF Очистка памяти:\n// Overwrite ephemeral keys after ee DH Alice.ephemeral_public = zeros(32) Alice.ephemeral_private = zeros(32) // Bob side Bob.received_ephemeral = zeros(32) // Bob side Примечания по реализации Цепной режим AES: Шифрование Y использует состояние AES-CBC из сообщения 1 (не сбрасывается) Защита от повторов: Алиса должна кэшировать значения Y как минимум в течение 2*D секунд Проверка метки времени: Алиса должна отклонять, если |tsB - current_time| \u0026gt; D Проверка кривой: Алиса должна проверить, что Y — корректная точка X25519 Обработка ошибок: Алиса закрывает соединение, посылая TCP RST, при любой ошибке Буферизация: Боб должен сбрасывать всё сообщение целиком за один раз Сообщение 3: SessionConfirmed (подтверждение сеанса) Алиса подтверждает сеанс и отправляет RouterInfo (данные о router в I2P).\nОперации Noise: s, se (раскрытие статического ключа и статический-эфемерный DH)\nСтруктура из двух частей Сообщение 3 состоит из двух отдельных AEAD-фреймов:\nЧасть 1: Фиксированный 48-байтовый кадр с зашифрованным статическим ключом Алисы Часть 2: Кадр переменной длины с RouterInfo, параметрами и заполнением Необработанный формат +----+----+----+----+----+----+----+----+ | ChaChaPoly Frame 1 (48 bytes) | + Plaintext: Alice static key (32B) + | k from KDF-2, n=1, ad=h | + + | | +----+----+----+----+----+----+----+----+ | | + ChaChaPoly Frame 2 (variable) + | Length specified in msg1.m3p2len | + k from KDF-3, n=0, ad=h + | Plaintext: RouterInfo + padding | + + | | ~ . . . ~ +----+----+----+----+----+----+----+----+ Ограничения по размеру: - Часть 1: Ровно 48 байт (32 байта открытого текста + 16 байт MAC) - Часть 2: Длина указана в сообщении 1 (поле m3p2len) - Общий максимум: 65535 байт (часть 1 максимум 48, значит часть 2 максимум 65487)\nРасшифрованное содержимое Часть 1:\n+----+----+----+----+----+----+----+----+ | | + S (Alice static public key) + | 32 bytes, X25519, little-endian | + + | | +----+----+----+----+----+----+----+----+ Часть 2:\n+----+----+----+----+----+----+----+----+ | Block: RouterInfo (required) | + Type=2, contains Alice\u0026#39;s RI + | | ~ . . . ~ +----+----+----+----+----+----+----+----+ | Block: Options (optional) | + Type=1, padding parameters + | | +----+----+----+----+----+----+----+----+ | Block: Padding (optional) | + Type=254, random data + | MUST be last block if present | ~ . . . ~ +----+----+----+----+----+----+----+----+ Функция вывода ключей (KDF-3) Часть 1 (шаблон s):\nh = SHA256(h || encrypted_payload_msg2) // 32-byte ciphertext if (msg2_padding_length \u0026gt; 0): h = SHA256(h || padding_from_msg2) // Encrypt static key with message 2 cipher key ciphertext = AEAD_ChaCha20_Poly1305(k_msg2, n=1, h, Alice.static_public) h = SHA256(h || ciphertext) // 48 bytes (32 + 16) // h is now the associated data for message 3 part 2 Часть 2 (se pattern):\ndh_result = X25519(Alice.static_private, Bob.ephemeral_public) temp_key = HMAC-SHA256(ck, dh_result) ck = HMAC-SHA256(temp_key, byte(0x01)) k = HMAC-SHA256(temp_key, ck || byte(0x02)) // k is the cipher key for message 3 part 2 // ck is retained for data phase KDF ciphertext = AEAD_ChaCha20_Poly1305(k, n=0, h, payload) h = SHA256(h || ciphertext) // h is retained for SipHash KDF Очистка памяти:\n// Overwrite Bob\u0026#39;s ephemeral key after se DH Alice.received_ephemeral = zeros(32) // Alice side Bob.ephemeral_public = zeros(32) // Bob side Bob.ephemeral_private = zeros(32) // Bob side Примечания по реализации Проверка RouterInfo: Боб должен проверить подпись, метку времени и согласованность ключей Сопоставление ключа: Боб должен удостовериться, что статический ключ Алисы в части 1 совпадает с ключом в RouterInfo Расположение статического ключа: Ищите совпадающий параметр \u0026ldquo;s\u0026rdquo; в NTCP или NTCP2 RouterAddress Порядок блоков: RouterInfo должен идти первым, Options — вторым (если есть), Padding — последним (если есть) Планирование длины: Алиса должна убедиться, что m3p2len в сообщении 1 в точности соответствует длине части 2 Буферизация: Алиса должна сбросить буфер, отправив обе части вместе одной отправкой TCP Необязательное связывание: Алиса может сразу добавить кадр фазы данных для повышения эффективности Фаза данных После завершения рукопожатия все сообщения используют кадры AEAD (аутентифицированное шифрование с дополнительными данными) переменной длины с обфусцированными полями длины.\nФункция выработки ключей (фаза данных) Функция Split (протокол Noise):\n// Generate transmit and receive keys zerolen = \u0026#34;\u0026#34; // Zero-length byte array temp_key = HMAC-SHA256(ck, zerolen) // Alice transmits to Bob k_ab = HMAC-SHA256(temp_key, byte(0x01)) // Bob transmits to Alice k_ba = HMAC-SHA256(temp_key, k_ab || byte(0x02)) // Cleanup ck = zeros(32) temp_key = zeros(32) Деривация ключа SipHash:\n// Generate additional symmetric key for SipHash ask_master = HMAC-SHA256(temp_key, \u0026#34;ask\u0026#34; || byte(0x01)) // \u0026#34;siphash\u0026#34; is 7 bytes US-ASCII temp_key2 = HMAC-SHA256(ask_master, h || \u0026#34;siphash\u0026#34;) sip_master = HMAC-SHA256(temp_key2, byte(0x01)) // Alice to Bob SipHash keys temp_key3 = HMAC-SHA256(sip_master, zerolen) sipkeys_ab = HMAC-SHA256(temp_key3, byte(0x01)) sipk1_ab = sipkeys_ab[0:7] // 8 bytes, little-endian sipk2_ab = sipkeys_ab[8:15] // 8 bytes, little-endian sipiv_ab = sipkeys_ab[16:23] // 8 bytes, IV // Bob to Alice SipHash keys sipkeys_ba = HMAC-SHA256(temp_key3, sipkeys_ab || byte(0x02)) sipk1_ba = sipkeys_ba[0:7] // 8 bytes, little-endian sipk2_ba = sipkeys_ba[8:15] // 8 bytes, little-endian sipiv_ba = sipkeys_ba[16:23] // 8 bytes, IV Структура кадра +----+----+----+----+----+----+----+----+ |Obfs Len | | +----+----+ ChaChaPoly Frame + | Encrypted Block Data | + k_ab (Alice→Bob) or k_ba (Bob→Alice)| | Nonce starts at 0, increments | + No associated data (empty string) + | | ~ . . . ~ | | +----+----+----+----+----+----+----+----+ | Poly1305 MAC (16 bytes) | +----+----+----+----+----+----+----+----+ Ограничения фрейма: - Минимум: 18 байт (2 байта обфусцированной длины + 0 байт открытого текста + 16 байт MAC) - Максимум: 65537 байт (2 байта обфусцированной длины + 65535 байт данных фрейма) - Рекомендуется: Несколько КБ на фрейм (минимизировать задержку на стороне получателя)\nМаскировка длины с помощью SipHash Назначение: Предотвратить идентификацию средствами DPI (глубокая проверка пакетов) границ кадров\nАлгоритм:\n// Initialization (per direction) IV[0] = sipiv // From KDF // For each frame: IV[n] = SipHash-2-4(sipk1, sipk2, IV[n-1]) Mask[n] = IV[n][0:1] // First 2 bytes of IV ObfuscatedLength = ActualLength XOR Mask[n] // Send 2-byte ObfuscatedLength, then ActualLength bytes Декодирование:\n// Receiver maintains identical IV chain IV[n] = SipHash-2-4(sipk1, sipk2, IV[n-1]) Mask[n] = IV[n][0:1] ActualLength = ObfuscatedLength XOR Mask[n] // Read ActualLength bytes (includes 16-byte MAC) Примечания: - Отдельные цепочки IV (инициализационный вектор) для каждого направления (Alice→Bob и Bob→Alice) - Если SipHash возвращает uint64, используйте 2 младших байта в качестве маски - Преобразуйте uint64 в следующий IV в виде байтов в формате little-endian\nФормат блока Каждый кадр содержит ноль или более блоков:\n+----+----+----+----+----+----+----+----+ |Type| Length | Data | +----+----+----+ + | | ~ . . . ~ +----+----+----+----+----+----+----+----+ Type : 1 byte - Block type identifier Length: 2 bytes - Big-endian, data size (0-65516) Data : Variable length payload Ограничения по размеру: - Максимальный кадр: 65535 байт (включая MAC (код аутентификации сообщения)) - Максимальное пространство под блоки: 65519 байт (кадр - 16-байтовый MAC) - Максимальный размер одного блока: 65519 байт (3-байтовый заголовок + 65516 байт данных)\nТипы блоков Type Name Description 0DateTimeTime synchronization (4-byte timestamp) 1OptionsPadding parameters, dummy traffic 2RouterInfoRouterInfo delivery/flooding 3I2NPI2NP message with shortened header 4TerminationExplicit connection close 224-253ReservedExperimental features 254PaddingRandom padding (must be last) 255ReservedFuture extensions **Правила упорядочивания блоков:** - **Сообщение 3, часть 2**: RouterInfo, Параметры (необязательно), Заполнение (необязательно) - НИКАКИХ других типов - **Фаза данных**: Любой порядок, кроме: - Заполнение ДОЛЖНО быть последним блоком, если присутствует - Завершение ДОЛЖНО быть последним блоком (кроме Заполнения), если присутствует - Несколько блоков I2NP допускаются в одном кадре - Несколько блоков Заполнения НЕ допускаются в одном кадре Тип блока 0: DateTime Синхронизация времени для обнаружения рассинхронизации часов.\n+----+----+----+----+----+----+----+ | 0 | 4 | timestamp | +----+----+----+----+----+----+----+ Type : 0 Length : 4 (big-endian) Timestamp: 4 bytes, Unix seconds (big-endian) Реализация: Округляйте до ближайшей секунды, чтобы предотвратить накопление смещения часов.\nТип блока 1: Параметры Параметры паддинга и формирования трафика.\n+----+----+----+----+----+----+----+----+ | 1 | size |tmin|tmax|rmin|rmax|tdmy| +----+----+----+----+----+----+----+----+ |tdmy| rdmy | tdelay | rdelay | | +----+----+----+----+----+----+----+ + | more_options (TBD) | ~ . . . ~ +----+----+----+----+----+----+----+----+ Type : 1 Length: 12+ bytes (big-endian) Коэффициенты паддинга (число с фиксированной точкой 4.4, value/16.0): - tmin: Минимальный коэффициент паддинга при передаче (0.0 - 15.9375) - tmax: Максимальный коэффициент паддинга при передаче (0.0 - 15.9375) - rmin: Минимальный коэффициент паддинга при приёме (0.0 - 15.9375) - rmax: Максимальный коэффициент паддинга при приёме (0.0 - 15.9375)\nПримеры: - 0x00 = 0% заполнения - 0x01 = 6.25% заполнения - 0x10 = 100% заполнения (соотношение 1:1) - 0x80 = 800% заполнения (соотношение 8:1)\nФиктивный трафик: - tdmy: Максимальная скорость, которую готовы отправлять (2 байта, среднее в байтах/с) - rdmy: Запрашиваемая скорость приёма (2 байта, среднее в байтах/с)\nВставка задержки: - tdelay: Максимальная задержка, которую готов вставить (2 байта, среднее значение в миллисекундах) - rdelay: Запрашиваемая задержка (2 байта, среднее значение в миллисекундах)\nРекомендации: - Минимальные значения указывают на желаемую устойчивость к анализу трафика - Максимальные значения указывают на ограничения пропускной способности - Отправитель должен соблюдать максимальные значения, указанные получателем - Отправитель может учитывать минимальные значения получателя в пределах ограничений - Механизм принуждения отсутствует; реализации могут различаться\nТип блока 2: RouterInfo (структура с информацией о router) Доставка RouterInfo для пополнения netdb и выполнения flooding (массовой рассылки).\n+----+----+----+----+----+----+----+----+ | 2 | size |flg | RouterInfo | +----+----+----+----+ + | | ~ . . . ~ +----+----+----+----+----+----+----+----+ Type : 2 Length: Flag (1 byte) + RouterInfo size Flag : Bit 0 = flood request (1) or local store (0) Bits 1-7 = Reserved, set to 0 Использование:\nВ сообщении 3, часть 2 (рукопожатие): - Алиса отправляет свой RouterInfo (информация о router) Бобу - Flood bit (флаг распространения в netDb) обычно равен 0 (локальное хранение) - RouterInfo НЕ сжат gzip\nВо время Data Phase (этап передачи данных): - Любая из сторон может отправить свой обновлённый RouterInfo - Бит Flood = 1: запросить распространение через floodfill (если получатель — floodfill) - Бит Flood = 0: только локальное хранение в netdb\nТребования к проверке: 1. Проверьте, что тип подписи поддерживается 2. Проверьте подпись RouterInfo 3. Проверьте, что метка времени находится в допустимых пределах 4. Для рукопожатия: Проверьте, что статический ключ соответствует параметру \u0026ldquo;s\u0026rdquo; адреса NTCP2 5. Для фазы данных: Проверьте, что хэш router соответствует пиру сеанса 6. Распространяйте только RouterInfos с опубликованными адресами\nПримечания: - Нет механизма ACK (используйте I2NP DatabaseStore с токеном ответа при необходимости) - Может содержать сторонние RouterInfos (при использовании floodfill) - НЕ сжато gzip (в отличие от I2NP DatabaseStore)\nТип блока 3: сообщение I2NP Сообщение I2NP с укороченным 9-байтным заголовком.\n+----+----+----+----+----+----+----+----+ | 3 | size |type| msg_id | +----+----+----+----+----+----+----+----+ | expiration | I2NP payload | +----+----+----+ + | | ~ . . . ~ +----+----+----+----+----+----+----+----+ Type : 3 Length : 9 + payload_size (big-endian) Type : 1 byte, I2NP message type Msg_ID : 4 bytes, big-endian, I2NP message ID Expiration: 4 bytes, big-endian, Unix timestamp (seconds) Payload : I2NP message body (length = size - 9) Отличия от NTCP1: - Срок действия: 4 байта (секунды) против 8 байт (миллисекунды) - Длина: опущена (выводится из длины блока) - Контрольная сумма: опущена (AEAD (аутентифицированное шифрование с дополнительными данными) обеспечивает целостность) - Заголовок: 9 байт против 16 байт (сокращение на 44%)\nФрагментация: - Сообщения I2NP НЕ ДОЛЖНЫ фрагментироваться между блоками - Сообщения I2NP НЕ ДОЛЖНЫ фрагментироваться между кадрами - В одном кадре допускается несколько блоков I2NP\nТип блока 4: Завершение Явное закрытие соединения с указанием кода причины.\n+----+----+----+----+----+----+----+----+ | 4 | size | valid_frames_recv | +----+----+----+----+----+----+----+----+ | (continued) |rsn | additional_data | +----+----+----+----+ + | | ~ . . . ~ +----+----+----+----+----+----+----+----+ Type : 4 Length : 9+ bytes (big-endian) Valid_Frames_Recv: 8 bytes, big-endian (receive nonce value) 0 if error in handshake phase Reason : 1 byte (see table below) Additional_Data : Optional (format unspecified, for debugging) Коды причин:\nCode Reason Phase 0Normal close / unspecifiedAny 1Termination receivedData 2Idle timeoutData 3Router shutdownData 4Data phase AEAD failureData 5Incompatible optionsHandshake 6Incompatible signature typeHandshake 7Clock skewHandshake 8Padding violationAny 9AEAD framing errorData 10Payload format errorData 11Message 1 errorHandshake 12Message 2 errorHandshake 13Message 3 errorHandshake 14Intra-frame read timeoutData 15RouterInfo signature verification failHandshake 16Static key parameter mismatchHandshake 17BannedAny **Правила:** - Termination (блок завершения) ДОЛЖЕН быть последним блоком, не являющимся блоком заполнения, в кадре - Не более одного блока завершения на кадр - Отправителю следует закрыть соединение после отправки - Получателю следует закрыть соединение после получения Обработка ошибок: - Ошибки рукопожатия: обычно закрывать с TCP RST (без блока завершения) - Ошибки AEAD на этапе передачи данных: случайный тайм-аут + случайное чтение, затем отправить блок завершения - См. раздел \u0026ldquo;AEAD Error Handling\u0026rdquo; для процедур безопасности\nТип блока 254: Заполнение Случайный паддинг (добавление случайных данных) для противодействия анализу трафика.\n+----+----+----+----+----+----+----+----+ |254 | size | random_data | +----+----+----+ + | | ~ . . . ~ +----+----+----+----+----+----+----+----+ Type: 254 Length: 0-65516 bytes (big-endian) Data: Cryptographically random bytes Правила: - Паддинг ДОЛЖЕН быть последним блоком в фрейме, если он присутствует - Паддинг нулевой длины допускается - В каждом фрейме допускается только один блок паддинга - Допускаются фреймы, содержащие только паддинг - Следует придерживаться согласованных параметров из блока Options\nПаддинг в сообщениях 1-2: - Вне фрейма AEAD (аутентифицированное шифрование с дополнительными данными) (в открытом виде) - Включён в хеш-цепочку следующего сообщения (аутентифицировано) - Подмена обнаруживается, когда проверка AEAD следующего сообщения завершается с ошибкой\nЗаполнение в сообщении 3+ и в фазе передачи данных: - Внутри фрейма AEAD (зашифровано и аутентифицировано) - Используется для формирования трафика и маскировки размера\nОбработка ошибок AEAD Критические требования безопасности:\nФаза рукопожатия (сообщения 1–3) Известный размер сообщения: - Размеры сообщений заранее определены или явно указаны - Сбой аутентификации AEAD однозначно обнаруживается\nОтвет Боба на сбой сообщения 1: 1. Установить случайный таймаут (диапазон зависит от реализации, рекомендуется 100–500 мс) 2. Прочитать случайное число байтов (диапазон зависит от реализации, рекомендуется 1–64 КБ) 3. Закрыть соединение с помощью TCP RST (без ответа) 4. Временно занести исходный IP-адрес в чёрный список 5. Отслеживать повторяющиеся сбои для долгосрочных блокировок\nОтвет Алисы на ошибку сообщения 2: 1. Немедленно закрыть соединение с помощью TCP RST 2. Не отвечать Бобу\nОтвет Боба на сбой сообщения 3: 1. Немедленно закрыть соединение отправкой TCP RST 2. Не отвечать Алисе\nФаза данных Обфусцированный размер сообщения: - Поле длины обфусцировано с помощью SipHash - Недопустимая длина или сбой AEAD может указывать на: - Зондирование атакующим - Повреждение данных в сети - Рассинхронизированный IV (инициализирующий вектор) SipHash - Злонамеренный пир\nОтвет на ошибку AEAD (аутентифицированное шифрование с дополнительными данными) или ошибку длины: 1. Установить случайный таймаут (рекомендуется 100-500 мс) 2. Прочитать случайное количество байтов (рекомендуется 1KB-64KB) 3. Отправить блок завершения с кодом причины 4 (сбой AEAD) или 9 (ошибка фрейминга) 4. Закрыть соединение\nПредотвращение атаки типа «оракул расшифрования»: - Никогда не раскрывать тип ошибки пиру до истечения случайного тайм-аута - Никогда не пропускать проверку длины перед проверкой AEAD - Рассматривать недопустимую длину так же, как ошибку AEAD - Использовать одинаковый путь обработки ошибок для обеих ошибок\nСоображения по реализации: - Некоторые реализации могут продолжать работу после ошибок AEAD, если они редки - Прекращать работу после повторяющихся ошибок (рекомендуемый порог: 3-5 ошибок в час) - Баланс между восстановлением после ошибок и безопасностью\nОпубликованный RouterInfo (информация о маршрутизаторе) Формат адреса Router Поддержка NTCP2 анонсируется через опубликованные записи RouterAddress (адрес маршрутизатора) с определёнными параметрами.\nСтиль транспорта: - \u0026quot;NTCP2\u0026quot; - NTCP2 только на этом порту - \u0026quot;NTCP\u0026quot; - И NTCP, и NTCP2 на этом порту (автоопределение) - Примечание: поддержка NTCP (v1) удалена в 0.9.50 (май 2021) - стиль \u0026ldquo;NTCP\u0026rdquo; теперь устарел; используйте \u0026ldquo;NTCP2\u0026rdquo;\nОбязательные параметры Все опубликованные адреса NTCP2:\nhost - IP-адрес (IPv4 или IPv6) или имя хоста\nФормат: стандартная запись IP или доменное имя Может быть опущен для routers только с исходящими соединениями или скрытых routers port - номер TCP-порта\nФормат: целое число, 1-65535 Можно опустить для router, работающих только на исходящую связь, или скрытых s - Статический открытый ключ (X25519)\nФормат: закодирован в Base64, 44 символа Кодировка: алфавит Base64 I2P Источник: 32-байтный открытый ключ X25519, little-endian (младший порядок байтов) i - Вектор инициализации (IV) для AES\nФормат: закодировано в Base64, 24 символа Кодировка: алфавит Base64 I2P Источник: 16-байтовый IV, big-endian (старший байт первым) v - Версия протокола\nФормат: целое число или целые числа, разделённые запятыми Текущее: \u0026quot;2\u0026quot; Будущее: \u0026quot;2,3\u0026quot; (должны быть в числовом порядке) Необязательные параметры:\ncaps - Возможности (начиная с 0.9.50)\nФормат: строка символов, обозначающих возможности Значения: \u0026quot;4\u0026quot; - возможность исходящих соединений по IPv4 \u0026quot;6\u0026quot; - возможность исходящих соединений по IPv6 \u0026quot;46\u0026quot; - и IPv4, и IPv6 (рекомендуемый порядок) Не требуется, если host опубликован Полезно для скрытых/за межсетевым экраном routers cost - Приоритет адреса\nФормат: целое число, 0-255 Меньшие значения = более высокий приоритет Рекомендуется: 5-10 для обычных адресов Рекомендуется: 14 для неопубликованных адресов Примеры записей RouterAddress (адрес маршрутизатора) Опубликованный IPv4-адрес:\n\u0026lt;Address cost=\u0026#34;5\u0026#34;\u0026gt; \u0026lt;transport_style\u0026gt;NTCP2\u0026lt;/transport_style\u0026gt; \u0026lt;options\u0026gt; \u0026lt;host\u0026gt;192.0.2.1\u0026lt;/host\u0026gt; \u0026lt;port\u0026gt;8887\u0026lt;/port\u0026gt; \u0026lt;s\u0026gt;9EjeG7BZeznKbL9a2fXx8JBDPgLZbLmKbqY3QrNGJCo=\u0026lt;/s\u0026gt; \u0026lt;i\u0026gt;MDEyMzQ1Njc4OUFCQ0RFRg==\u0026lt;/i\u0026gt; \u0026lt;v\u0026gt;2\u0026lt;/v\u0026gt; \u0026lt;/options\u0026gt; \u0026lt;/Address\u0026gt; Скрытый Router (только исходящий):\n\u0026lt;Address cost=\u0026#34;14\u0026#34;\u0026gt; \u0026lt;transport_style\u0026gt;NTCP2\u0026lt;/transport_style\u0026gt; \u0026lt;options\u0026gt; \u0026lt;s\u0026gt;9EjeG7BZeznKbL9a2fXx8JBDPgLZbLmKbqY3QrNGJCo=\u0026lt;/s\u0026gt; \u0026lt;v\u0026gt;2\u0026lt;/v\u0026gt; \u0026lt;caps\u0026gt;4\u0026lt;/caps\u0026gt; \u0026lt;/options\u0026gt; \u0026lt;/Address\u0026gt; Router с двойным стеком:\n\u0026lt;!-- IPv4 Address --\u0026gt; \u0026lt;Address cost=\u0026#34;5\u0026#34;\u0026gt; \u0026lt;transport_style\u0026gt;NTCP2\u0026lt;/transport_style\u0026gt; \u0026lt;options\u0026gt; \u0026lt;host\u0026gt;192.0.2.1\u0026lt;/host\u0026gt; \u0026lt;port\u0026gt;8887\u0026lt;/port\u0026gt; \u0026lt;s\u0026gt;9EjeG7BZeznKbL9a2fXx8JBDPgLZbLmKbqY3QrNGJCo=\u0026lt;/s\u0026gt; \u0026lt;i\u0026gt;MDEyMzQ1Njc4OUFCQ0RFRg==\u0026lt;/i\u0026gt; \u0026lt;v\u0026gt;2\u0026lt;/v\u0026gt; \u0026lt;/options\u0026gt; \u0026lt;/Address\u0026gt; \u0026lt;!-- IPv6 Address (same keys, same port) --\u0026gt; \u0026lt;Address cost=\u0026#34;5\u0026#34;\u0026gt; \u0026lt;transport_style\u0026gt;NTCP2\u0026lt;/transport_style\u0026gt; \u0026lt;options\u0026gt; \u0026lt;host\u0026gt;2001:db8::1\u0026lt;/host\u0026gt; \u0026lt;port\u0026gt;8887\u0026lt;/port\u0026gt; \u0026lt;s\u0026gt;9EjeG7BZeznKbL9a2fXx8JBDPgLZbLmKbqY3QrNGJCo=\u0026lt;/s\u0026gt; \u0026lt;i\u0026gt;MDEyMzQ1Njc4OUFCQ0RFRg==\u0026lt;/i\u0026gt; \u0026lt;v\u0026gt;2\u0026lt;/v\u0026gt; \u0026lt;/options\u0026gt; \u0026lt;/Address\u0026gt; Важные правила: - Несколько адресов NTCP2 с одним и тем же портом ДОЛЖНЫ использовать идентичные значения s, i и v - Разные порты могут использовать разные ключи - Двухстековые routers должны публиковать отдельные адреса IPv4 и IPv6\nНеопубликованный адрес NTCP2 Для routers в режиме Outbound-Only:\nЕсли router не принимает входящие соединения NTCP2, но инициирует исходящие соединения, он ДОЛЖЕН всё равно публиковать RouterAddress со следующими параметрами:\n\u0026lt;Address cost=\u0026#34;14\u0026#34;\u0026gt; \u0026lt;transport_style\u0026gt;NTCP2\u0026lt;/transport_style\u0026gt; \u0026lt;options\u0026gt; \u0026lt;s\u0026gt;9EjeG7BZeznKbL9a2fXx8JBDPgLZbLmKbqY3QrNGJCo=\u0026lt;/s\u0026gt; \u0026lt;v\u0026gt;2\u0026lt;/v\u0026gt; \u0026lt;/options\u0026gt; \u0026lt;/Address\u0026gt; Назначение: - Позволяет Бобу проверить статический ключ Алисы во время рукопожатия - Требуется для проверки RouterInfo (информация о router) в сообщении 3, часть 2 - Не требуются i, host или port (только исходящее)\nАльтернатива: - Добавьте s и v к уже опубликованному адресу \u0026ldquo;NTCP\u0026rdquo; или SSU\nРотация открытого ключа и вектора инициализации (IV) Критическая политика безопасности:\nОбщие правила: 1. Никогда не выполняйте ротацию, пока router работает 2. Сохраняйте ключ и IV (инициализационный вектор) между перезапусками 3. Отслеживайте предыдущий простой, чтобы определить допустимость ротации\nМинимальное время простоя перед ротацией:\nRouter Type Min Downtime Reason Published NTCP2 address1 monthMany routers cache RouterInfo Published SSU only (no NTCP2)1 dayModerate caching No published addresses (hidden)2 hoursMinimal impact **Дополнительные триггеры:** - Изменение локального IP-адреса: может вызывать ротацию независимо от простоя - Router \"rekey\" (смена ключей; новый Router Hash): генерация новых ключей Обоснование: - Предотвращает раскрытие времени перезапуска через смену ключей - Позволяет кэшированным RouterInfos естественным образом устаревать - Поддерживает стабильность сети - Снижает количество неудачных попыток подключения\nРеализация: 1. Сохранять ключ, IV (вектор инициализации) и метку времени последнего завершения работы в постоянном хранилище 2. При запуске вычислить downtime = current_time - last_shutdown 3. Если downtime \u0026gt; минимума для типа router, можно выполнить ротацию 4. Если IP изменился или происходит смена ключей, можно выполнить ротацию 5. В противном случае повторно использовать предыдущие ключ и IV\nРотация IV (вектор инициализации): - Подчиняется тем же правилам, что и ротация ключа - Присутствует только в опубликованных адресах (не в скрытых routers) - Рекомендуется менять IV при каждом изменении ключа\nОпределение версии Контекст: Когда transportStyle=\u0026quot;NTCP\u0026quot; (устаревший), Bob поддерживает как NTCP v1, так и v2 на одном порту и должен автоматически определять версию протокола.\nАлгоритм обнаружения:\n1. Wait for at least 64 bytes (minimum NTCP2 message 1 size) 2. If received ≥ 288 bytes: → Connection is NTCP version 1 (NTCP1 message 1 is 288 bytes) 3. If received \u0026lt; 288 bytes: Option A (conservative, pre-NTCP2 majority): a. Wait additional short time (e.g., 100-500ms) b. If total received ≥ 288 bytes → NTCP1 c. Otherwise → Attempt NTCP2 decode Option B (aggressive, post-NTCP2 majority): a. Attempt NTCP2 decode immediately: - Decrypt first 32 bytes (X key) with AES-256-CBC - Verify valid X25519 point (X[31] \u0026amp; 0x80 == 0) - Verify AEAD frame b. If decode succeeds → NTCP2 c. If decode fails → Wait for more data or NTCP1 Быстрая проверка старшего бита (MSB): - Перед расшифрованием AES проверьте: encrypted_X[31] \u0026amp; 0x80 == 0 - У валидных ключей X25519 старший бит сброшен - Сбой, вероятно, указывает на NTCP1 (старый транспортный протокол I2P) (или атаку) - При сбое реализуйте устойчивость к зондированию (случайный таймаут + чтение)\nТребования к реализации:\nОбязанности Алисы:\nПри подключении к адресу \u0026ldquo;NTCP\u0026rdquo; ограничьте размер сообщения 1 не более 287 байтов Буферизуйте и сбросьте всё сообщение 1 целиком за один раз Повышает вероятность доставки одним TCP-пакетом Ответственность Боба:\nБуферизовать полученные данные до определения версии Реализовать корректную обработку таймаутов Использовать TCP_NODELAY для быстрого определения версии Буферизовать и затем целиком сбросить сообщение 2 сразу после определения версии Соображения безопасности: - Атаки сегментацией: Боб должен быть устойчив к сегментации TCP - Зондирующие атаки: реализуйте случайные задержки и по-байтовое чтение при сбоях - Предотвращение DoS: ограничьте число одновременных ожидающих установления соединений - Тайм-ауты чтения: как на каждое чтение, так и общий (защита от «slowloris» — атака, при которой клиент удерживает соединение открытым, передавая данные крайне медленно)\nРекомендации по смещению часов Поля временных меток: - Сообщение 1: tsA (метка времени Алисы) - Сообщение 2: tsB (метка времени Боба) - Сообщение 3+: необязательные блоки DateTime\nМаксимальное расхождение (D): - Обычно: ±60 секунд - Настраивается в каждой реализации - Расхождение \u0026gt; D, как правило, фатально\nОбработка на стороне Боба (Сообщение 1) 1. Receive tsA from Alice 2. skew = tsA - current_time 3. If |skew| \u0026gt; D: a. Still send message 2 (allows Alice to calculate skew) b. Include tsB in message 2 c. Do NOT initiate handshake completion d. Optionally: Temporary ban Alice\u0026#39;s IP e. After message 2 sent, close connection 4. If |skew| ≤ D: a. Continue handshake normally Обоснование: Отправка сообщения 2 даже при расхождении часов позволяет Алисе диагностировать проблемы с системным временем.\nОбработка на стороне Алисы (сообщение 2) 1. Receive tsB from Bob 2. RTT = (current_time_now - tsA_sent) 3. adjusted_skew = (tsB - current_time_now) - (RTT / 2) 4. If |adjusted_skew| \u0026gt; D: a. Close connection immediately b. If local clock suspect: Adjust clock or use external time source c. If Bob\u0026#39;s clock suspect: Temporary ban Bob d. Log for operator review 5. If |adjusted_skew| ≤ D: a. Continue handshake normally b. Optionally: Track skew for time synchronization Корректировка RTT: - Вычтите половину RTT из рассчитанного смещения - Учитывает задержку распространения в сети - Более точная оценка смещения\nОбработка Бобом (Сообщение 3) 1. If message 3 received (unlikely if skew exceeded in message 1) 2. Recalculate skew = tsA_received - current_time 3. If |adjusted_skew| \u0026gt; D: a. Send termination block (reason code 7: clock skew) b. Close connection c. Ban Alice for period (e.g., 1-24 hours) Синхронизация времени Блоки DateTime (фаза данных): - Периодически отправляйте блок DateTime (тип 0) - Получатель может использовать для корректировки часов - Округляйте метку времени до ближайшей секунды (чтобы предотвратить смещение)\nВнешние источники времени: - NTP (Network Time Protocol) - Синхронизация системных часов - Время консенсуса сети I2P\nСтратегии корректировки часов: - Если локальные часы неверны: скорректируйте системное время или используйте смещение - Если часы пиров стабильно неверны: зафиксируйте проблему на стороне пира - Отслеживайте статистику рассинхронизации для мониторинга состояния сети\nСвойства безопасности Прямая секретность Достигается посредством: - Эфемерного обмена ключами Диффи-Хеллмана (X25519) - Трех операций DH: es, ee, se (шаблон Noise XK) - Уничтожения эфемерных ключей после завершения рукопожатия\nПрогрессия конфиденциальности: - Сообщение 1: Уровень 2 (прямая секретность при компрометации отправителя) - Сообщение 2: Уровень 1 (эфемерный получатель) - Сообщение 3+: Уровень 5 (сильная прямая секретность)\nСовершенная прямая секретность: - Компрометация долгосрочных статических ключей НЕ раскрывает сессионные ключи прошлых сессий - Каждая сессия использует уникальные эфемерные ключи - Эфемерные закрытые ключи никогда не используются повторно - Очистка памяти после согласования ключей\nОграничения: - Сообщение 1 уязвимо, если статический ключ Боба скомпрометирован (но сохраняется прямая секретность в случае компрометации Алисы) - Возможны атаки воспроизведения для сообщения 1 (смягчаются меткой времени и кэшем повторов)\nАутентификация Взаимная аутентификация: - Алиса аутентифицируется статическим ключом в сообщении 3 - Боб аутентифицируется владением статическим закрытым ключом (неявно из успешного рукопожатия)\nУстойчивость к Key Compromise Impersonation (KCI; имитация при компрометации ключа): - Уровень аутентификации 2 (устойчив к KCI) - Злоумышленник не может выдать себя за Alice, даже имея статический закрытый ключ Alice (без её эфемерного ключа) - Злоумышленник не может выдать себя за Bob, даже имея статический закрытый ключ Bob (без его эфемерного ключа)\nПроверка статического ключа: - Алиса заранее знает статический ключ Боба (из RouterInfo) - Боб проверяет, что статический ключ Алисы соответствует RouterInfo в сообщении 3 - Предотвращает атаки типа «человек посередине»\nУстойчивость к анализу трафика Контрмеры против DPI: 1. Сокрытие с помощью AES: Эфемерные ключи зашифрованы, данные выглядят случайными 2. Сокрытие длины с SipHash: Длины фреймов не в открытом виде 3. Случайное заполнение (padding): Переменные размеры сообщений, нет фиксированных шаблонов 4. Зашифрованные фреймы: Вся полезная нагрузка зашифрована алгоритмом ChaCha20\nПредотвращение атак повторов: - Проверка метки времени (±60 секунд) - Кэш повторов для эфемерных ключей (время жизни 2*D) - Инкрементирование Nonce (одноразовое число) предотвращает повтор пакетов в рамках сеанса\nУстойчивость к зондированию: - Случайные тайм-ауты при ошибках AEAD - Случайное чтение байтов перед закрытием соединения - Отсутствие ответов при ошибках рукопожатия - Занесение IP-адресов в черный список при повторных сбоях\nРекомендации по паддингу: - Сообщения 1-2: паддинг в открытом виде (аутентифицированный) - Сообщение 3+: зашифрованный паддинг внутри фреймов AEAD (шифрование с аутентификацией и ассоциированными данными) - Согласованные параметры паддинга (Options block — блок параметров) - Разрешены фреймы только с паддингом\nПротиводействие атакам отказа в обслуживании Ограничения соединений: - Максимальное количество активных соединений (зависит от реализации) - Максимальное количество незавершённых рукопожатий (например, 100-1000) - Ограничения на число соединений с одного IP-адреса (например, 3-10 одновременно)\nЗащита ресурсов: - операции DH (обмен ключами Диффи — Хеллмана) ограничены по частоте (ресурсоёмные) - таймауты чтения для каждого сокета и общий - защита от \u0026ldquo;Slowloris\u0026rdquo; (общие лимиты времени) - занесение IP в чёрный список за злоупотребления\nБыстрое отклонение: - Несоответствие идентификатора сети → немедленное закрытие - Некорректная точка X25519 → быстрая проверка старшего бита до расшифрования - Метка времени вне допустимого диапазона → закрытие без вычислений - Сбой AEAD (аутентифицированное шифрование с дополнительными данными) → без ответа, случайная задержка\nУстойчивость к зондированию: - Случайный таймаут: 100-500 мс (зависит от реализации) - Случайный объём чтения: 1KB-64KB (зависит от реализации) - Нет информации об ошибках для атакующего - Закрытие соединения TCP RST (без рукопожатия FIN)\nКриптографическая безопасность Алгоритмы: - X25519: 128-битная стойкость, DH на эллиптических кривых (Curve25519) - ChaCha20: потоковый шифр с ключом 256 бит - Poly1305: информационно-теоретически стойкий MAC - SHA-256: 128-битная стойкость к коллизиям, 256-битная стойкость к нахождению прообраза - HMAC-SHA256: PRF (псевдослучайная функция) для деривации ключей\nРазмеры ключей: - Статические ключи: 32 байта (256 бит) - Эфемерные ключи: 32 байта (256 бит) - Ключи шифрования: 32 байта (256 бит) - MAC (код аутентификации сообщения): 16 байт (128 бит)\nИзвестные проблемы: - В ChaCha20 повторное использование nonce (одноразового номера) катастрофично (предотвращается увеличением счётчика) - У X25519 есть проблемы малых подгрупп (смягчаются проверкой кривой) - SHA-256 теоретически уязвим к атаке расширения длины (не эксплуатируется в HMAC)\nНеизвестно о каких-либо уязвимостях (по состоянию на октябрь 2025 года): - Noise Protocol Framework (фреймворк протоколов Noise) широко исследован - ChaCha20-Poly1305 используется в TLS 1.3 - X25519 является стандартом в современных протоколах - Нет практических атак на конструкцию\nСсылки Основные спецификации Спецификация NTCP2 - Официальная спецификация I2P Предложение 111 - Исходный документ проектирования с обоснованием Noise Protocol Framework (фреймворк протокола Noise) - Редакция 33 (2017-10-04) Криптографические стандарты RFC 7748 - Эллиптические кривые для обеспечения безопасности (X25519) RFC 7539 - ChaCha20 и Poly1305 для протоколов IETF RFC 8439 - ChaCha20-Poly1305 (объявляет устаревшим RFC 7539) RFC 2104 - HMAC: хеширование с ключом для аутентификации сообщений SipHash - SipHash-2-4 для приложений хеш-функций Связанные спецификации I2P Спецификация I2NP - формат сообщений протокола сети I2P Общие структуры - форматы RouterInfo, RouterAddress Транспорт SSU - транспорт UDP (исходный, теперь SSU2) Предложение 147 - проверка идентификатора транспортной сети (0.9.42) Ссылки по реализации I2P Java - Эталонная реализация (Java) i2pd - Реализация на C++ Примечания к выпуску I2P - История версий и обновления Исторический контекст Station-To-Station Protocol (STS) - Послужил источником вдохновения для фреймворка Noise obfs4 - Подключаемый транспорт (пример обфускации длины на базе SipHash) Рекомендации по реализации Обязательные требования Для соответствия требованиям:\nРеализовать полное рукопожатие:\nПоддержать все три сообщения с корректными цепочками KDF (функция выработки ключей) Проверять все теги AEAD (аутентифицированное шифрование с дополнительными данными) Проверять, что точки на кривой X25519 (эллиптическая кривая X25519) корректны Реализовать фазу данных:\nОбфускация длины с помощью SipHash (в обоих направлениях) Все типы блоков: 0 (DateTime), 1 (Options), 2 (RouterInfo), 3 (I2NP), 4 (Termination), 254 (Padding) Корректное управление nonce (одноразовое значение) (отдельные счётчики) Функции безопасности:\nЗащита от повторов (кэширование эфемерных ключей в течение 2*D) Проверка меток времени (по умолчанию ±60 секунд) Случайное заполнение в сообщениях 1-2 Обработка ошибок AEAD со случайными таймаутами Публикация RouterInfo:\nПубликовать статический ключ (\u0026ldquo;s\u0026rdquo;), вектор инициализации (IV) (\u0026ldquo;i\u0026rdquo;) и версию (\u0026ldquo;v\u0026rdquo;) Выполнять ротацию ключей согласно политике Поддерживать поле возможностей (\u0026ldquo;caps\u0026rdquo;) для скрытых routers Совместимость с сетью:\nПоддерживать поле идентификатора сети (в настоящее время — 2 для mainnet (основная сеть)) Обеспечивать совместимость с существующими реализациями на Java и i2pd Поддерживать как IPv4, так и IPv6 Рекомендуемые практики Оптимизация производительности:\nСтратегия буферизации:\nСбрасывать сообщения полностью сразу (сообщения 1, 2, 3) Использовать TCP_NODELAY для сообщений рукопожатия Буферизовать несколько блоков данных в один кадр Ограничить размер кадра до нескольких КБ (минимизировать задержку у получателя) Управление соединениями:\nПереиспользуйте соединения, когда возможно Реализуйте пул соединений Отслеживайте состояние соединений (DateTime blocks — временные блокировки) Управление памятью:\nОбнуляйте конфиденциальные данные после использования (эфемерные ключи, результаты DH (Диффи-Хеллман)) Ограничивайте число параллельных рукопожатий (предотвращение DoS-атак) Используйте пулы памяти для частых выделений Укрепление безопасности:\nУстойчивость к зондированию:\nСлучайные тайм-ауты: 100-500 мс Случайные чтения байтов: 1 КБ-64 КБ Занесение IP-адресов в черный список при повторных сбоях Без подробностей об ошибках для пиров Ограничения ресурсов:\nМаксимальное число соединений на IP-адрес: 3-10 Максимальное число ожидающих рукопожатий: 100-1000 Таймауты чтения: 30-60 секунд на операцию Общий таймаут соединения: 5 минут на рукопожатие Управление ключами:\nПостоянное хранение статического ключа и вектора инициализации (IV) Безопасная генерация случайных чисел (криптографически стойкий генератор случайных чисел) Строгое соблюдение политик ротации Никогда не переиспользовать эфемерные ключи Мониторинг и диагностика:\nМетрики:\nДоли успешных/неудачных рукопожатий Частота ошибок AEAD Распределение смещения часов Статистика длительности соединений Логирование:\nЛогировать ошибки рукопожатия с кодами причин Логировать события смещения часов Логировать заблокированные IP-адреса Никогда не логировать конфиденциальный ключевой материал Тестирование:\nМодульные тесты для цепочек KDF (функций выработки ключа) Интеграционные тесты с другими реализациями Фаззинг обработки пакетов Нагрузочное тестирование на устойчивость к DoS-атакам Распространённые ошибки Критические ошибки, которых следует избегать:\nПовторное использование Nonce (одноразового числа):\nНикогда не сбрасывайте счетчик nonce в середине сеанса Используйте отдельные счетчики для каждого направления Завершайте сеанс до достижения 2^64 - 1 Ротация ключей:\nНикогда не выполняйте ротацию ключей, пока router работает Никогда не переиспользуйте эфемерные ключи между сеансами Соблюдайте правила минимального времени простоя Обработка временных меток:\nНикогда не принимать истекшие временные метки Всегда вносить поправку на RTT (время кругового прохода) при расчете смещения Округлять метки времени DateTime до секунд Ошибки AEAD:\nНикогда не раскрывайте тип ошибки атакующему Всегда используйте случайный таймаут перед закрытием Обрабатывайте недопустимую длину так же, как ошибку AEAD Заполнение:\nНикогда не отправляйте заполнение вне согласованных границ Всегда размещайте блок заполнения последним Никогда не используйте несколько блоков заполнения в одном кадре RouterInfo (метаданные router):\nВсегда проверяйте, что статический ключ соответствует данным в RouterInfo Никогда не рассылайте RouterInfo без опубликованных адресов Всегда проверяйте подписи Методология тестирования Модульные тесты:\nКриптографические примитивы:\nТестовые векторы для X25519, ChaCha20, Poly1305, SHA-256 Тестовые векторы для HMAC-SHA256 Тестовые векторы для SipHash-2-4 Цепочки KDF:\nТесты с эталонными ответами для всех трёх сообщений Проверить передачу ключа цепочки Тест генерации вектора инициализации (IV) для SipHash Разбор сообщений:\nДекодирование корректных сообщений Отклонение некорректных сообщений Граничные условия (пустое сообщение, максимальный размер) Интеграционные тесты:\nРукопожатие:\nУспешный обмен из трёх сообщений Отклонение при смещении часов Обнаружение атаки повторного воспроизведения Отклонение некорректного ключа Фаза данных:\nПередача сообщений I2NP Обмен RouterInfo (информация о router) Обработка заполнения Сообщения завершения Совместимость:\nТестирование с Java I2P Тестирование с i2pd Тестирование IPv4 и IPv6 Тестирование опубликованных и скрытых routers Тесты безопасности:\nНегативные тесты:\nНедопустимые теги AEAD (аутентифицированное шифрование с дополнительными данными) Повторно переданные сообщения Атаки на основе смещения часов Некорректно сформированные кадры Тесты DoS:\nФлуд соединениями Атаки Slowloris Истощение CPU (чрезмерные DH-вычисления) Истощение памяти Фаззинг:\nСлучайные сообщения рукопожатия Случайные кадры фазы данных Случайные типы и размеры блоков Недопустимые криптографические значения Переход с NTCP Для поддержки устаревшего NTCP (теперь удалено):\nNTCP (version 1) был удалён в I2P 0.9.50 (май 2021 года). Все текущие реализации должны поддерживать NTCP2. Исторические примечания:\nПереходный период (2018–2021):\n0.9.36: NTCP2 представлен (по умолчанию отключён) 0.9.37: NTCP2 включён по умолчанию 0.9.40: NTCP объявлён устаревшим 0.9.50: NTCP удалён Определение версии:\nПоле transportStyle (тип транспорта) со значением \u0026ldquo;NTCP\u0026rdquo; указывало на поддержку обеих версий Поле transportStyle со значением \u0026ldquo;NTCP2\u0026rdquo; указывало на поддержку только NTCP2 Автоматическое определение по размеру сообщения (287 против 288 байт) Текущее состояние:\nВсе router должны поддерживать NTCP2 \u0026ldquo;NTCP\u0026rdquo; transportStyle устарел Используйте исключительно \u0026ldquo;NTCP2\u0026rdquo; transportStyle Приложение A: шаблон Noise XK Стандартный шаблон Noise XK:\nXK(s, rs): \u0026lt;- s ... -\u0026gt; e, es \u0026lt;- e, ee -\u0026gt; s, se Интерпретация:\n\u0026lt;- : Сообщение от респондента (Боба) к инициатору (Алисе) -\u0026gt; : Сообщение от инициатора (Алисы) к респонденту (Бобу) s : Статический ключ (долгосрочный ключ идентичности) rs : Удалённый статический ключ (статический ключ пира, известный заранее) e : Эфемерный ключ (специфичный для сеанса, создаётся по требованию) es : Эфемерный-Статический DH (Диффи — Хеллман) (эфемерный Алисы × статический Боба) ee : Эфемерный-Эфемерный DH (эфемерный Алисы × эфемерный Боба) se : Статический-Эфемерный DH (статический Алисы × эфемерный Боба) Последовательность согласования ключа:\nПредсообщение: Алиса знает статический открытый ключ Боба (из RouterInfo) Сообщение 1: Алиса отправляет эфемерный ключ, выполняет es DH Сообщение 2: Боб отправляет эфемерный ключ, выполняет ee DH Сообщение 3: Алиса раскрывает статический ключ, выполняет se DH Свойства безопасности:\nАлиса аутентифицирована: Да (на основании сообщения 3) Боб аутентифицирован: Да (по наличию статического закрытого ключа) Прямая секретность: Да (эфемерные ключи уничтожаются) KCI resistance (устойчивость к имперсонации при компрометации ключа): Да (уровень аутентификации 2) Приложение B: кодирование Base64 Алфавит Base64 в I2P:\nABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-~ Отличия от стандартного Base64: - Символы 62–63: -~ вместо +/ - Дополнение: то же самое (=) или опускается в зависимости от контекста\nИспользование в NTCP2: - Статический ключ (\u0026ldquo;s\u0026rdquo;): 32 байта → 44 символа (без дополнения) - IV (\u0026ldquo;i\u0026rdquo;): 16 байт → 24 символа (без дополнения)\nПример кодирования:\n# 32-byte static key (hex): # f4489e1bb0597b39ca6cbf5ad9f5f1f09043e02d96cb9aa6a63742b3462429aa # I2P Base64 encoded: # 9EjeG7BZeznKbL9a2fXx8JBDPgLZbLmKbqY3QrNGJCo= Приложение C: Анализ захвата пакетов Идентификация трафика NTCP2:\nРукопожатие TCP:\nСтандартные TCP SYN, SYN-ACK, ACK Порт назначения обычно 8887 или аналогичный Сообщение 1 (SessionRequest — запрос сеанса):\nПервые прикладные данные от Алисы 80-65535 байт (обычно несколько сотен) Выглядит как случайные данные (эфемерный ключ, зашифрованный AES) 287 байт максимум при подключении к адресу \u0026ldquo;NTCP\u0026rdquo; Сообщение 2 (SessionCreated — «создание сессии»):\nОтвет от Боба 80-65535 байт (обычно несколько сотен) Также похоже на случайные данные Сообщение 3 (SessionConfirmed):\nОт Alice 48 байт + переменная часть (размер RouterInfo (информация о router) + заполнение) Обычно 1-4 КБ Фаза данных:\nКадры переменной длины Поле длины замаскировано (выглядит случайным) Зашифрованная полезная нагрузка Padding (выравнивание данными) делает размер непредсказуемым Обход DPI: - Отсутствуют незашифрованные заголовки - Отсутствуют фиксированные шаблоны - Поля длины замаскированы - Случайный паддинг нарушает работу эвристик, основанных на размере\nСравнение с NTCP: - Сообщение 1 в NTCP всегда 288 байт (идентифицируемо) - Размер сообщения 1 в NTCP2 варьируется (не идентифицируемо) - В NTCP были распознаваемые шаблоны - NTCP2 спроектирован для противодействия глубокой инспекции пакетов (DPI)\nПриложение D: История версий Ключевые вехи:\n0.9.36 (23 августа 2018 г.): Введён NTCP2, по умолчанию отключён 0.9.37 (4 октября 2018 г.): NTCP2 включён по умолчанию 0.9.40 (20 мая 2019 г.): NTCP объявлен устаревшим 0.9.42 (27 августа 2019 г.): Добавлено поле Network ID (идентификатор сети; Proposal 147) 0.9.50 (17 мая 2021 г.): NTCP удалён, добавлена поддержка capabilities (флагов возможностей) 2.10.0 (9 сентября 2025 г.): Последний стабильный релиз Стабильность протокола: - Нет изменений, нарушающих совместимость, с 0.9.50 - Продолжаются улучшения устойчивости к зондированию - Фокус на производительности и надежности - Постквантовая криптография в разработке (не включена по умолчанию)\nТекущий статус транспортов: - NTCP2: Обязательный транспорт TCP - SSU2: Обязательный транспорт UDP - NTCP (v1): Удалён - SSU (v1): Удалён\n","description":"TCP-транспорт на основе Noise для соединений router-to-router","id":"4882afdd530d8c7e8da14bb97487aecc","section":"docs","title":"Транспорт NTCP2","url":"/ru/docs/specs/ntcp2/"},{"categories":null,"content":" Устарело: SSU (Secure Semi-Reliable UDP) был заменён на SSU2 . В Java I2P SSU был удалён в выпуске 2.4.0 (API 0.9.61), а в i2pd — в 2.44.0 (API 0.9.56). Этот документ сохранён исключительно для исторической справки.\nОсновные моменты UDP-транспорт, обеспечивающий зашифрованную, аутентифицированную доставку точка-точка сообщений I2NP. Основывался на 2048-битном рукопожатии Diffie–Hellman (то же простое число, что и в ElGamal). Каждая датаграмма содержала 16-байтовый HMAC-MD5 (нестандартный усечённый вариант) + 16-байтовый IV, за которыми следовала зашифрованная AES-256-CBC полезная нагрузка. Защита от повторов и состояние сеанса отслеживались внутри зашифрованной полезной нагрузки. Заголовок сообщения [16-byte MAC][16-byte IV][encrypted payload] Используемое вычисление MAC: HMAC-MD5(ciphertext || IV || (len ^ version ^ ((netid-2)\u0026lt;\u0026lt;8))) с 32-байтным ключом MAC. Длина полезной нагрузки представлялась 16-битным значением в формате big-endian, добавленным к данным внутри вычисления MAC. Версия протокола по умолчанию равнялась 0; netId по умолчанию равнялся 2 (основная сеть).\nСеансовые и MAC-ключи Получено из общего секрета DH (Диффи-Хеллмана):\nПреобразуйте разделяемое значение в байтовый массив в порядке big-endian (добавьте 0x00 в начало, если установлен старший бит). Сеансовый ключ: первые 32 байта (дополните нулями, если короче). Ключ MAC: байты 33–64; при нехватке используйте хэш SHA-256 от разделяемого значения. Статус Routers больше не анонсируют адреса SSU. Клиентам следует перейти на транспортные протоколы SSU2 или NTCP2. Исторические реализации можно найти в более старых релизах:\nИсходные коды на Java до версии 2.4.0 в каталоге router/transport/udp Исходные коды i2pd до версии 2.44.0 Сведения о текущем поведении UDP‑транспорта см. в спецификации SSU2 .\n","description":"Первоначальный UDP-транспорт, использовавшийся до SSU2","id":"1eefecf66e3adc6ea013d5a5e58326da","section":"docs","title":"Транспорт SSU (устаревший)","url":"/ru/docs/legacy/ssu/"},{"categories":null,"content":" 1. Обзор Транспорт в I2P — это способ прямой связи между routers по схеме точка‑к‑точке. Эти механизмы обеспечивают конфиденциальность и целостность, одновременно выполняя проверку аутентификации router.\nКаждый транспорт работает на основе моделей соединений с поддержкой аутентификации, управления потоком, подтверждений и повторной передачи.\n2. Текущие транспорты В настоящее время I2P поддерживает два основных транспортных протокола:\nTransport Protocol Description NTCP2 TCP Noise-based TCP transport with modern encryption (as of 0.9.36) SSU2 UDP Secure Semireliable UDP with modern encryption (as of 0.9.56) ### 2.1 Устаревшие транспортные протоколы (не рекомендуется к использованию) Transport Protocol Status NTCP TCP Replaced by NTCP2; removed in 0.9.62 SSU UDP Replaced by SSU2; removed in 0.9.62 --- 3. Транспортные службы Транспортная подсистема предоставляет следующие службы:\n3.1 Доставка сообщений Надёжная доставка сообщений I2NP (транспортные протоколы обрабатывают исключительно обмен сообщениями I2NP) Доставка в порядке отправки НЕ гарантируется в общем случае Очередь сообщений на основе приоритетов 3.2 Управление соединениями Установление и завершение соединений Управление лимитами соединений с принудительным соблюдением пороговых значений Отслеживание состояния по каждому пиру Автоматическое и ручное применение черного списка пиров 3.3 Конфигурация сети Несколько адресов router для каждого транспорта (поддержка IPv4 и IPv6 начиная с v0.9.8) Открытие портов брандмауэра через UPnP Поддержка обхода NAT/брандмауэра Определение локального IP-адреса несколькими методами 3.4 Безопасность Шифрование для обменов точка-точка Проверка IP-адреса по локальным правилам Определение консенсуса времени (резерв через NTP) 3.5 Управление пропускной способностью Ограничения пропускной способности для входящего и исходящего трафика Выбор оптимального транспорта для исходящих сообщений 4. Транспортные адреса Подсистема ведёт список точек контакта router:\nТип транспорта (NTCP2, SSU2) IP-адрес Номер порта Необязательные параметры Возможны несколько адресов для каждого транспорта.\n4.1 Распространённые конфигурации адресов Configuration Description Hidden Routers with no published addresses Firewalled Routers publishing SSU2 addresses with \"introducer\" peer lists for NAT traversal Unrestricted Routers advertising both NTCP2 and SSU2 addresses on IPv4 and/or IPv6 --- 5. Выбор транспорта Система выбирает транспорты для сообщений I2NP независимо от протоколов верхнего уровня. Выбор осуществляется с помощью системы торгов, в которой каждый транспорт подает ставки, и побеждает ставка с наименьшим значением.\n5.1 Факторы определения ставки Настройки предпочтений транспорта Существующие соединения с пирами Текущее и пороговое количество соединений История недавних попыток соединения Ограничения на размер сообщений Транспортные возможности RouterInfo (информация о router) пира Прямота соединения (прямое или через introducer (узел-посредник в SSU)) Объявленные пиром предпочтения транспорта Обычно два router одновременно поддерживают соединения по одному транспорту, хотя возможны одновременные соединения по нескольким транспортам.\n6. NTCP2 NTCP2 (New Transport Protocol 2) — современный транспорт на базе TCP для I2P, представленный в версии 0.9.36.\n6.1 Ключевые возможности Основано на Noise Protocol Framework (паттерн Noise_XK) Использует X25519 для обмена ключами Использует ChaCha20/Poly1305 для аутентифицированного шифрования Использует BLAKE2s для хеширования Обфускация протокола для противодействия DPI (глубокая инспекция пакетов) Необязательное заполнение для устойчивости к анализу трафика 6.2 Установление соединения Запрос сеанса (Alice → Bob): Эфемерный ключ X25519 + зашифрованная полезная нагрузка Сеанс создан (Bob → Alice): Эфемерный ключ + зашифрованное подтверждение Сеанс подтверждён (Alice → Bob): Завершающее рукопожатие с RouterInfo (информация о Router) Все последующие данные шифруются сеансовыми ключами, выведенными из рукопожатия.\nПодробности см. в спецификации NTCP2 .\n7. SSU2 SSU2 (Secure Semireliable UDP 2 — защищённый полунадёжный UDP 2) — современный транспорт на основе UDP для I2P, представленный в версии 0.9.56.\n7.1 Ключевые особенности Основан на Noise Protocol Framework (фреймворк протокола Noise; шаблон Noise_XK) Использует X25519 для обмена ключами Использует ChaCha20/Poly1305 для аутентифицированного шифрования Частично надёжная доставка с выборочными подтверждениями Обход NAT посредством hole punching (пробивание) и ретрансляции/введения Поддержка миграции соединения Обнаружение MTU на пути 7.2 Преимущества по сравнению с SSU (устаревшим) Feature SSU (Legacy) SSU2 Encryption ElGamal + AES X25519 + ChaCha20/Poly1305 Header encryption Partial Full (ChaCha20) Connection ID Fixed Encrypted, rotatable NAT traversal Basic introduction Enhanced hole punching + relay Obfuscation Minimal Improved (variable padding) Подробности см. в [спецификации SSU2](/docs/specs/ssu2/). 8. Обход NAT Оба транспорта поддерживают обход NAT, чтобы routers, находящиеся за межсетевым экраном, могли участвовать в сети.\n8.1 Введение в SSU2 Когда router не может напрямую принимать входящие соединения:\nrouter публикует адреса introducer (узел‑посредник для обхода NAT) в своем RouterInfo Подключающийся пир отправляет запрос на представление в адрес introducer Introducer пересылает информацию для соединения router за файрволом Router за файрволом инициирует исходящее соединение (NAT-пробивка (hole punching)) Установлена прямая связь 8.2 NTCP2 и межсетевые экраны NTCP2 требует доступности входящих соединений по TCP. Routers, находящиеся за NAT, могут:\nИспользовать UPnP для автоматического открытия портов Вручную настроить проброс портов Полагаться на SSU2 для входящих соединений, а для исходящих использовать NTCP2 9. Обфускация протокола Оба современных транспортных протокола включают возможности маскировки:\nСлучайное заполнение в сообщениях рукопожатия Зашифрованные заголовки, не раскрывающие сигнатуры протокола Сообщения переменной длины для противодействия анализу трафика Отсутствие фиксированных шаблонов при установлении соединения Примечание: Обфускация на транспортном уровне дополняет, но не заменяет анонимность, обеспечиваемую архитектурой tunnel I2P.\n10. Дальнейшее развитие Планируемые исследования и улучшения включают:\nПодключаемые транспорты – совместимые с Tor плагины маскировки Транспорт на основе QUIC – исследование преимуществ протокола QUIC Оптимизация лимита соединений – исследование оптимальных лимитов соединений с пирами Расширенные стратегии padding (добавочного трафика) – улучшенная устойчивость к анализу трафика 11. Ссылки Спецификация NTCP2 – TCP-транспорт на основе Noise Спецификация SSU2 – Безопасный полунадежный UDP 2 Спецификация I2NP – Сообщения протокола I2NP Общие структуры – RouterInfo и структуры адресов Историческое обсуждение NTCP – История разработки устаревшего транспорта Устаревшая документация по SSU – Исходная спецификация SSU (устарело) ","description":"Понимание транспортного уровня I2P - методы связи «точка-точка» между routers, включая NTCP2 и SSU2","id":"5fbac972dc212081634c49c5e6ac0004","section":"docs","title":"Транспортный уровень","url":"/ru/docs/overview/transport/"},{"categories":null,"content":"1. Обзор Записи в clients.config указывают роутеру, какие приложения запускать при старте. Каждая запись может работать как управляемый клиент (предпочтительно) или как неуправляемый клиент. Управляемые клиенты взаимодействуют с ClientAppManager, который:\nСоздает экземпляр приложения и отслеживает состояние жизненного цикла для консоли роутера Предоставляет пользователю элементы управления запуском/остановкой и обеспечивает корректное завершение работы при выходе из роутера Размещает легковесный реестр клиентов и маппер портов, чтобы приложения могли обнаруживать сервисы друг друга Неуправляемые клиенты просто вызывают метод main(); используйте их только для устаревшего кода, который невозможно модернизировать.\n2. Реализация управляемого клиента Управляемые клиенты должны реализовывать либо net.i2p.app.ClientApp (для пользовательских приложений), либо net.i2p.router.app.RouterApp (для расширений router). Предоставьте один из конструкторов ниже, чтобы менеджер мог передать аргументы контекста и конфигурации:\npublic MyClientApp(I2PAppContext context, ClientAppManager manager, String[] args) public MyRouterApp(RouterContext context, ClientAppManager manager, String[] args) Массив args содержит значения, настроенные в clients.config или отдельных файлах в clients.config.d/. По возможности расширяйте вспомогательные классы ClientApp / RouterApp, чтобы унаследовать стандартную логику жизненного цикла.\n2.1 Lifecycle Methods Ожидается, что управляемые клиенты реализуют:\nstartup() - выполняет инициализацию и возвращает управление незамедлительно. Должен вызвать manager.notify() хотя бы один раз для перехода из состояния INITIALIZED. shutdown(String[] args) - освобождает ресурсы и останавливает фоновые потоки. Должен вызвать manager.notify() хотя бы один раз для изменения состояния на STOPPING или STOPPED. getState() - сообщает консоли, работает ли приложение, запускается, останавливается или завершилось с ошибкой Менеджер вызывает эти методы по мере того, как пользователи взаимодействуют с консолью.\n2.2 Advantages Точная отчетность о статусе в консоли роутера Чистые перезапуски без утечек потоков или статических ссылок Меньший объем используемой памяти после остановки приложения Централизованное логирование и отчетность об ошибках через внедренный контекст 3. Unmanaged Clients (Fallback Mode) Если настроенный класс не реализует управляемый интерфейс, роутер запускает его путем вызова main(String[] args) и не может отслеживать полученный процесс. Консоль показывает ограниченную информацию, и хуки завершения работы могут не выполниться. Используйте этот режим для скриптов или одноразовых утилит, которые не могут применить управляемые API.\n4. Client Registry Управляемые и неуправляемые клиенты могут регистрировать себя в менеджере, чтобы другие компоненты могли получать ссылку по имени:\nmanager.register(this); Регистрация использует возвращаемое значение getName() клиента в качестве ключа реестра. Известные регистрации включают console, i2ptunnel, Jetty, outproxy и update. Получите клиент с помощью ClientAppManager.getRegisteredApp(String name) для координации функций (например, консоль запрашивает у Jetty детали статуса).\nОбратите внимание, что реестр клиентов и маппер портов являются отдельными системами. Реестр клиентов обеспечивает межприложенное взаимодействие посредством поиска по имени, в то время как маппер портов сопоставляет имена сервисов с комбинациями host:port для обнаружения сервисов.\n3. Неуправляемые клиенты (режим отката) Маппер портов предоставляет простой справочник для внутренних TCP-сервисов. Регистрируйте loopback-порты, чтобы участники проекта избегали жёстко заданных адресов:\ncontext.portMapper().register(PortMapper.SVC_HTTPS_PROXY, 4445); Или с явным указанием хоста:\ncontext.portMapper().register(PortMapper.SVC_HTTP_PROXY, \u0026#34;127.0.0.1\u0026#34;, 4444); Поиск сервисов выполняется с помощью PortMapper.getPort(String name) (возвращает -1, если не найден) или getPort(String name, int defaultPort) (возвращает значение по умолчанию, если не найден). Проверить статус регистрации можно с помощью isRegistered(String name), а получить зарегистрированный хост — с помощью getActualHost(String name).\nОбщие константы сервиса маппинга портов из net.i2p.util.PortMapper:\nSVC_CONSOLE - Консоль роутера (порт по умолчанию 7657) SVC_HTTP_PROXY - HTTP прокси (порт по умолчанию 4444) SVC_HTTPS_PROXY - HTTPS прокси (порт по умолчанию 4445) SVC_I2PTUNNEL - Менеджер I2PTunnel SVC_SAM - SAM мост (порт по умолчанию 7656) SVC_SAM_SSL - SAM мост SSL SVC_SAM_UDP - SAM UDP SVC_BOB - BOB мост (порт по умолчанию 2827) SVC_EEPSITE - Стандартный eepsite (порт по умолчанию 7658) SVC_HTTPS_EEPSITE - HTTPS eepsite SVC_IRC - IRC tunnel (порт по умолчанию 6668) SVC_SUSIDNS - SusiDNS Примечание: httpclient, httpsclient и httpbidirclient — это типы tunnel для i2ptunnel (используются в конфигурации tunnel.N.type), а не константы сервиса port mapper.\n4. Реестр клиентов 2.1 Методы жизненного цикла Начиная с версии 0.9.42, router поддерживает разделение конфигурации на отдельные файлы в директории clients.config.d/. Каждый файл содержит свойства для одного клиента, где все свойства имеют префикс clientApp.0.:\nclientApp.0.main=net.i2p.router.web.RouterConsoleRunner clientApp.0.name=Router Console clientApp.0.args=7657 ::1,127.0.0.1 ./webapps/ clientApp.0.delay=0 clientApp.0.onBoot=true Это рекомендуемый подход для новых установок и плагинов.\n2.2 Преимущества Для обратной совместимости традиционный формат использует последовательную нумерацию:\nclientApp.0.main=net.i2p.router.web.RouterConsoleRunner clientApp.0.name=Router Console clientApp.0.args=7657 ::1,127.0.0.1 ./webapps/ clientApp.1.main=net.i2p.apps.systray.UrlLauncher clientApp.1.name=URL Launcher clientApp.1.delay=5 6.3 Configuration Properties Обязательно: - main - Полное имя класса, реализующего ClientApp или RouterApp, или содержащего статический метод main(String[] args)\nОпционально: - name - Отображаемое имя для консоли router (по умолчанию имя класса) - args - Аргументы, разделённые пробелами или табуляцией (поддерживает строки в кавычках) - delay - Секунды до запуска (по умолчанию 120) - onBoot - Принудительно устанавливает delay=0 если true - startOnLoad - Включает/отключает клиент (по умолчанию true)\nСпецифичные для плагина: - stopargs - Аргументы, передаваемые при остановке - uninstallargs - Аргументы, передаваемые при удалении плагина - classpath - Дополнительные записи classpath, разделённые запятыми\nПодстановка переменных для плагинов: - $I2P - базовый каталог I2P - $CONFIG - каталог конфигурации пользователя (например, ~/.i2p) - $PLUGIN - каталог плагина - $OS - название операционной системы - $ARCH - название архитектуры\n5. Port Mapper Предпочитайте управляемые клиенты; используйте неуправляемые только в крайнем случае. Держите инициализацию и завершение работы облегчёнными, чтобы операции консоли оставались отзывчивыми. Используйте описательные имена в реестре и для портов, чтобы диагностические инструменты (и конечные пользователи) понимали, что делает сервис. Избегайте статических синглтонов - полагайтесь на внедрённый контекст и менеджер для совместного использования ресурсов. Вызывайте manager.notify() при всех переходах состояния для поддержания точного статуса консоли. Если вам необходимо запускаться в отдельной JVM, документируйте, как логи и диагностика передаются в основную консоль. Для внешних программ рассмотрите использование ShellService (добавлен в версии 1.7.0) для получения преимуществ управляемого клиента. 6. Формат конфигурации Управляемые клиенты были введены в версии 0.9.4 (17 декабря 2012 года) и остаются рекомендуемой архитектурой по состоянию на версию 2.10.0 (9 сентября 2025 года). Основные API оставались стабильными без каких-либо критических изменений за весь этот период:\nСигнатуры конструкторов не изменены Методы жизненного цикла (startup, shutdown, getState) не изменены Методы регистрации ClientAppManager не изменены Методы регистрации и поиска PortMapper не изменены Значимые улучшения: - 0.9.42 (2019) - структура каталогов clients.config.d/ для отдельных файлов конфигурации - 1.7.0 (2021) - добавлен ShellService для отслеживания состояния внешних программ - 2.10.0 (2025) - текущий релиз без изменений в API управляемых клиентов\nСледующий крупный релиз будет требовать Java 17+ как минимум (требование инфраструктуры, а не изменение API).\nReferences Спецификация clients.config Спецификация конфигурационного файла Указатель технической документации I2P ClientAppManager Javadoc (API 0.9.66) PortMapper Javadoc (API 0.9.66) Интерфейс ClientApp (API 0.9.66) Интерфейс RouterApp (API 0.9.66) Альтернативная Javadoc (стабильная версия) Альтернативная Javadoc (clearnet-зеркало) Примечание: Сеть I2P размещает полную документацию по адресу http://idk.i 2p/javadoc-i2p/, для доступа к которой требуется I2P router. Для доступа из обычного интернета используйте зеркало GitHub Pages, указанное выше.\n","description":"Как управляемые маршрутизатором приложения интегрируются с ClientAppManager и сопоставителем портов","id":"f9e2324a49e9ed9bf413b4c636d5d1b6","section":"docs","title":"Управляемые клиенты","url":"/ru/docs/applications/managed-clients/"},{"categories":null,"content":"Выберите способ установки Существует два способа установки I2P на Windows. Выберите метод, который лучше всего подходит вашим потребностям:\n🚀 Easy Install Bundle (Recommended) Оптимально для большинства пользователей\n✅ Универсальный установщик ✅ Java включена (не требует отдельной установки) ✅ Профили Firefox включены ✅ Самая быстрая установка\nВыбирайте это, если: - Вам нужна самая простая установка - У вас не установлена Java - Вы новичок в I2P\nРуководство по простой установке →\nВАЖНО: НЕ задавайте вопросы, не давайте объяснения и не добавляйте никаких комментариев. Даже если текст представляет собой только заголовок или кажется неполным, переведите его как есть.\n🚀 Простой установочный пакет (Рекомендуется) Для опытных пользователей\n📦 Установщик на основе Java JAR 🔧 Больше контроля над установкой 💾 Меньший размер загрузки\nВыбирайте это, если: - У вас уже установлена Java - Вы хотите больше контроля - Вы предпочитаете традиционный метод\nРуководство по стандартной установке →\nТуннели I2P Туннели являются однонаправленными виртуальными путями через определённое количество пиров, используемыми для обеспечения анонимности отправителя и получателя пары, пытающихся связаться, а также для скрытия местоположения участвующих пиров.\nКаждый туннель управляется шлюзом туннеля, который периодически выбирает и создаёт цепочку пиров для работы в качестве участников туннеля. Каждый участник туннеля знает только соседних пиров в цепочке и не имеет информации о более широкой топологии туннеля. Сообщения, проходящие через туннель, шифруются многослойным образом (garlic encryption), так что только шлюз туннеля может увидеть содержимое исходного сообщения.\nТипы туннелей Существует четыре типа туннелей:\nИсходящие туннели клиента - используются для отправки данных от клиента к их destination Входящие туннели клиента - используются для получения данных от destination клиента Исходящие туннели для исследования - используются для взаимодействия с netDb Входящие туннели для исследования - используются для получения ответов от netDb Длина туннеля Длина туннеля — это количество хопов (пиров) в туннеле. Длина туннеля по умолчанию настраиваемая и обычно составляет 3 хопа. Более длинные туннели обеспечивают лучшую анонимность, но также увеличивают латентность и нагрузку на сеть.\nСрок действия туннеля Туннели имеют ограниченный срок действия, обычно 10 минут. После истечения срока действия туннеля шлюз туннеля создаёт новый туннель с другим набором участников. Это помогает предотвратить анализ трафика и профилирование туннелей.\nEasy Install Bundle ⚙️ Стандартная установка I2P Easy Install Bundle — это рекомендуемый метод установки для пользователей Windows. Этот универсальный установщик включает всё необходимое для начала работы с I2P:\nI2P Router - Основное программное обеспечение I2P Embedded Java Runtime - Не требуется отдельная установка Java Firefox profiles and extensions - Оптимизированные для I2P профили браузера и расширения для безопасного просмотра Simple installer - Не требуется ручная настройка Automatic updates - Поддерживайте ваше программное обеспечение I2P актуальным Этот бета-установщик упрощает процесс установки, включая Java напрямую, поэтому вам не нужно загружать или настраивать Java отдельно.\nО I2P I2P (The Invisible Internet Project) — это анонимная сетевая оверлейная сеть, которая позволяет приложениям отправлять сообщения друг другу псевдонимно и безопасно. Анонимность достигается за счёт того, что сообщения шифруются и маршрутизируются через несколько узлов-посредников (роутеров) в сети I2P. Каждый роутер может отправлять, получать и пересылать сообщения.\nОсновные возможности Конфиденциальность и анонимность: скрывает от наблюдателей, кто с кем общается и где находятся участники коммуникации Сквозное шифрование: сообщения зашифрованы на всём пути от отправителя до получателя Распределённая архитектура: нет единой точки отказа или контроля Устойчивость к цензуре: сложно заблокировать доступ к сети или отдельным сервисам внутри неё Как это работает I2P использует packet switching (коммутацию пакетов) и garlic encryption (чесночное шифрование) для защиты коммуникаций. Каждый роутер в сети участвует в маршрутизации пакетов для других пользователей, создавая распределённую и устойчивую инфраструктуру.\nСеть использует несколько ключевых компонентов:\nTunnel: односторонний путь через несколько роутеров для анонимной передачи данных LeaseSet: информация о том, как связаться с конкретным destination (адресатом) NetDb: распределённая база данных маршрутной информации Floodfill роутеры: специальные узлы, хранящие информацию netDb Транспортные протоколы: NTCP2 и SSU для связи между роутерами Step 1: Select Your Language После запуска установщика Easy Install Bundle вы увидите экран выбора языка.\nВыберите предпочитаемый язык из выпадающего меню Доступные языки включают английский, немецкий, испанский, французский и многие другие Нажмите OK, чтобы продолжить Интерфейс установщика будет использовать выбранный вами язык для всех последующих шагов.\nI2P I2P (Invisible Internet Project) — это анонимная оверлейная сеть, которая позволяет приложениям отправлять сообщения друг другу псевдонимно и безопасно.\nАнонимность достигается благодаря тому, что сеть распределена: нет доверенных сторон, которые могли бы раскрыть информацию об отправителях и получателях сообщений.\nОсновные особенности Распределенная архитектура — нет центральных серверов или единой точки отказа Сквозное шифрование — сообщения шифруются от источника до получателя Garlic routing — множественные сообщения объединяются вместе для усиления анонимности Защита от анализа трафика — случайная задержка и перемешивание пакетов Встроенные сервисы — веб-серверы, электронная почта, файлообмен и другие приложения Как это работает Каждый router в сети I2P:\nУчаствует в построении туннелей через другие роутеры Хранит информацию о других роутерах в распределенной базе данных (netDb) Обрабатывает зашифрованные сообщения для других пользователей Поддерживает несколько туннелей для обеспечения отказоустойчивости Все сообщения маршрутизируются через несколько роутеров, что делает практически невозможным отслеживание источника или получателя сообщения.\nПакет простой установки Далее вам будет представлена информация о лицензии I2P. Easy Install Bundle включает компоненты, распространяемые под различными свободными лицензиями с открытым исходным кодом.\nДля продолжения установки: 1. Ознакомьтесь с информацией о лицензии (необязательно, но рекомендуется) 2. Нажмите Я принимаю, чтобы принять условия лицензии и продолжить 3. Нажмите Отмена, если вы не хотите выполнять установку\nStep 3: Choose Installation Folder Теперь вы выберете, куда установить I2P на вашем компьютере.\nВарианты установки:\nИспользовать расположение по умолчанию (рекомендуется)\nПуть по умолчанию: C:\\Users\\[YourUsername]\\AppData\\Local\\I2peasy\\ Устанавливает I2P в директорию вашего профиля пользователя Не требуются права администратора для обновлений Выберите пользовательское расположение\nНажмите Обзор\u0026hellip;, чтобы выбрать другую папку Полезно, если вы хотите установить на другой диск Убедитесь, что у вас есть права на запись в выбранную папку Требования к дисковому пространству: - Установщик показывает, сколько места требуется (обычно менее 1 ГБ) - Убедитесь, что на выбранном диске имеется достаточно свободного места\nНажмите Установить, чтобы начать процесс установки Установщик скопирует все необходимые файлы в выбранное вами расположение. Это может занять несколько минут.\nШаг 1: Выберите ваш язык По завершении установки вы увидите экран завершения.\nМастер установки подтверждает, что \u0026ldquo;I2P - i2peasy был установлен на ваш компьютер.\u0026rdquo;\nВажно: Убедитесь, что флажок \u0026ldquo;Start I2P?\u0026rdquo; установлен (он должен быть установлен по умолчанию).\nОтмечено (рекомендуется): I2P запустится автоматически после нажатия кнопки \u0026ldquo;Готово\u0026rdquo; Не отмечено: Вам потребуется запустить I2P вручную позже через меню \u0026ldquo;Пуск\u0026rdquo; или ярлык на рабочем столе Нажмите Готово, чтобы завершить установку и запустить I2P.\nЯ предоставлю перевод, как только вы предоставите текст для перевода. Пожалуйста, вставьте текст после \u0026ldquo;Text to translate:\u0026rdquo; в вашем запросе.\nШаг 2: Примите лицензионное соглашение После нажатия кнопки «Готово» с отмеченным флажком «Запустить I2P?»:\nI2P Router запускается - I2P router начинает работу в фоновом режиме Появляется иконка в системном трее - Найдите иконку I2P в системном трее Windows (правый нижний угол) Открывается консоль router - Ваш веб-браузер по умолчанию автоматически откроет I2P Router Console (обычно по адресу http://127.0.0.1:7657) Первоначальное подключение - I2P начнёт подключение к сети и построение tunnel (это может занять 5-10 минут при первом запуске) Поздравляем! I2P теперь установлен и запущен на вашем компьютере с Windows.\nI2P I2P (Invisible Internet Project) — это анонимная оверлейная сеть, которая позволяет приложениям безопасно обмениваться сообщениями между собой. I2P шифрует трафик несколькими слоями и перенаправляет его через несколько узлов сети, управляемых добровольцами по всему миру.\nОсновные возможности Анонимность: Скрывает как отправителя, так и получателя Приватность: Использует end-to-end шифрование Распределенность: Нет центральных серверов или точек отказа Самоорганизующаяся: Автоматически находит и использует оптимальные маршруты Ключевые компоненты Router Основное программное обеспечение I2P, которое создает и поддерживает tunnel\u0026rsquo;ы для анонимной связи.\nTunnel Односторонний путь через несколько router\u0026rsquo;ов I2P, используемый для отправки или получения сообщений анонимно.\nNetDb Распределенная база данных, хранящая информацию о router\u0026rsquo;ах и destination\u0026rsquo;ах в сети I2P.\nLeaseSet Содержит информацию о том, как связаться с конкретным destination через его inbound tunnel\u0026rsquo;ы.\nШаг 3: Выбор папки установки Хотя это и не является строго обязательным, проброс портов значительно улучшает работу с I2P, позволяя вашему router более эффективно взаимодействовать с другими I2P router\u0026rsquo;ами. Без проброса портов вы всё ещё сможете использовать I2P, но с пониженной производительностью и меньшим вкладом в сеть.\nWhy Forward a Port? Улучшенная связность: Позволяет принимать входящие соединения от других I2P роутеров Более быстрая интеграция: Помогает быстрее интегрироваться в сеть Вклад в сеть: Делает вас лучшим участником сети I2P Улучшенная производительность: Как правило, приводит к повышению надёжности туннелей и скорости Что такое Easy Install Bundle? Сначала вам нужно определить, какой порт использует I2P (по умолчанию он назначается случайным образом).\nНайдите значок I2P в системном трее Windows (область уведомлений) в правом нижнем углу экрана Щёлкните правой кнопкой мыши по значку I2P, чтобы открыть контекстное меню Нажмите \u0026ldquo;Launch I2P Browser\u0026rdquo;, чтобы открыть консоль I2P router Меню также показывает полезные опции, такие как: - Network: Firewalled - Показывает текущий статус сети - Configure I2P System Tray - Настройка параметров иконки в трее - Stop I2P / Stop I2P Immediately - Опции завершения работы\nFinding Your Port Numbers После открытия браузера I2P необходимо проверить, какие порты использует I2P:\nПерейдите на страницу настройки сети:\nОткройте I2P Router Network Configuration в вашем браузере Или из боковой панели консоли router: Configuration → Network Прокрутите вниз до раздела настройки портов\nОбратите внимание на номера портов, которые показаны: Конфигурация UDP: - UDP порт: Порт, показанный здесь (пример: 13697) - По умолчанию установлено значение \u0026ldquo;Указать порт\u0026rdquo; со случайно назначенным номером\nКонфигурация TCP: - Внешне доступный TCP-порт: Обычно настраивается на использование того же порта, что и UDP - В примере выше: \u0026ldquo;Использовать тот же порт, что настроен для UDP (в настоящее время 13697)\u0026rdquo;\nВажно: Вам необходимо пробросить как UDP, так и TCP на одном и том же номере порта (в этом примере порт 13697) в вашем маршрутизаторе/межсетевом экране.\nHow to Forward Your Port Поскольку каждый роутер и файрвол отличаются друг от друга, мы не можем предоставить универсальные инструкции. Однако на сайте portforward.com есть подробные руководства для тысяч моделей роутеров:\nПосетите portforward.com Выберите производителя и модель вашего роутера Следуйте пошаговому руководству для настройки проброса портов Пробросьте оба протокола UDP и TCP на номер порта, указанный в вашей конфигурации I2P Общие шаги (зависит от роутера): - Войдите в административный интерфейс вашего роутера (обычно по адресу 192.168.1.1 или 192.168.0.1) - Найдите раздел «Переадресация портов» или «Виртуальные серверы» - Создайте новое правило переадресации портов для номера порта вашего I2P - Установите протоколы UDP и TCP - Укажите в правиле локальный IP-адрес вашего компьютера - Сохраните конфигурацию\nПосле проброса порта статус I2P должен измениться с \u0026ldquo;Network: Firewalled\u0026rdquo; на \u0026ldquo;Network: OK\u0026rdquo; в меню системного трея (это может занять несколько минут).\nI2P I2P (Invisible Internet Project) — это анонимная оверлейная сеть, которая позволяет приложениям отправлять сообщения друг другу псевдонимно и безопасно. Анонимность достигается путем шифрования пользовательского трафика и его маршрутизации через распределенную сеть, управляемую добровольцами по всему миру. При правильной настройке сеть затрудняет для третьих лиц отслеживание интернет-активности, включая посещаемые веб-сайты, публикации в социальных сетях, обмен мгновенными сообщениями и другие формы коммуникации.\nОсновные возможности Анонимность: I2P скрывает ваше местоположение и использование от наблюдателей Устойчивость к цензуре: Децентрализованная архитектура затрудняет блокировку Сквозное шифрование: Сообщения шифруются несколько раз (garlic encryption) Скрытые сервисы: Хостите веб-сайты и сервисы, которые доступны только внутри I2P (eepsite) Распределенная сеть: Нет центральных серверов или точек отказа Как это работает I2P использует криптографию с открытым ключом и tunnel (туннели) для обеспечения приватности. Каждый клиент создает несколько входящих и исходящих tunnel, которые являются временными однонаправленными путями через другие I2P router (роутеры). Данные разбиваются на сообщения, шифруются несколько раз и отправляются через эти tunnel.\nКлючевые компоненты:\nRouter: Основное программное обеспечение, обеспечивающее участие в сети Tunnel: Зашифрованные пути через сеть для отправки и получения данных LeaseSet: Опубликованная информация о том, как связаться с destination (пунктом назначения) NetDb: Распределенная база данных информации о router и leaseSet Floodfill: Специализированные router, которые хранят части netDb Начало работы Скачайте I2P с официального сайта Установите и запустите router Откройте консоль роутера (обычно доступна по адресу http://127.0.0.1:7657) Подождите, пока ваш router интегрируется в сеть (15-30 минут для оптимальной производительности) Настройте ваш браузер для использования HTTP-прокси I2P или используйте встроенные приложения Транспортные протоколы I2P поддерживает несколько транспортных протоколов для связи между router:\nNTCP2: Протокол на основе TCP с улучшенными функциями безопасности SSU: Протокол на основе UDP для NAT traversal (прохождения через NAT) Интерфейсы приложений Разработчики могут интегрировать приложения с I2P, используя:\nSAMv3: Простой протокол на основе сокетов I2PTunnel: Туннелирование TCP/HTTP соединений I2CP: Протокол клиент-роутер для расширенного управления BOB: Основной анонимный протокол-мост Дополнительные ресурсы Официальная документация Спецификации I2NP Сообщество и поддержка Шаг 4: Завершите установку и запустите I2P Дождитесь интеграции: Дайте I2P 5-10 минут для интеграции в сеть и построения tunnel\u0026rsquo;ов Настройте браузер: Используйте прилагаемый профиль Firefox для просмотра I2P Пробросьте порт: См. portforward.com для инструкций по пробросу портов для вашего роутера, который использует I2P Изучите консоль роутера: Узнайте о возможностях, сервисах и параметрах конфигурации I2P Посетите eepsite\u0026rsquo;ы: Попробуйте получить доступ к .i2p веб-сайтам через сеть I2P Прочитайте документацию: Ознакомьтесь с документацией I2P для получения дополнительной информации Добро пожаловать в сеть I2P! 🎉\nI2P I2P — это анонимная оверлейная сеть, предоставляющая простой уровень, который идентичности и местоположение чувствительных пользователей могут использовать для анонимной защиты.\nЧто происходит дальше What is the Standard Installation? Стандартная установка I2P — это традиционный метод установки I2P на Windows. В отличие от Easy Install Bundle, этот метод требует от вас:\nУстановите Java отдельно - Загрузите и установите Java Runtime Environment (JRE) перед установкой I2P Запустите JAR-установщик - Используйте графический установщик на основе Java Настройте вручную - Настройте конфигурации браузера самостоятельно (опционально) Этот метод рекомендуется для: - Пользователей, у которых уже установлена Java - Опытных пользователей, которым требуется больший контроль над установкой - Пользователей, предпочитающих традиционный метод установки - Систем, где Easy Install Bundle несовместим\nСеть I2P I2P — это анонимная сетевая прослойка, которая позволяет приложениям отправлять друг другу сообщения псевдонимно и безопасно.\nОбзор Сеть I2P состоит из всех router\u0026rsquo;ов, работающих с программным обеспечением I2P. Router\u0026rsquo;ы взаимодействуют друг с другом, используя протоколы I2P Network Protocol (I2NP) и I2P Control Protocol (I2CP).\nRouter\u0026rsquo;ы Router I2P — это программный компонент, который направляет трафик через сеть I2P. Router\u0026rsquo;ы общаются друг с другом, используя транспорты NTCP2 и SSU.\nTunnel\u0026rsquo;ы Tunnel\u0026rsquo;ы — это временные однонаправленные пути через несколько router\u0026rsquo;ов. Они используются для анонимной маршрутизации сообщений через сеть.\nLeaseSet\u0026rsquo;ы LeaseSet содержит информацию о том, как связаться с конкретным destination в сети I2P. Он включает набор входящих tunnel\u0026rsquo;ов и информацию об истечении срока действия.\nNetwork Database (netDb) Network Database (netDb) — это распределённая база данных, содержащая информацию о router\u0026rsquo;ах и destination\u0026rsquo;ах в сети I2P. Floodfill router\u0026rsquo;ы хранят и распространяют записи netDb.\nТранспортные протоколы I2P использует два основных транспортных протокола:\nNTCP2: TCP-подобный транспорт с шифрованием SSU: UDP-транспорт для NAT-обхода Интерфейсы приложений Приложения могут взаимодействовать с I2P, используя несколько интерфейсов:\nI2CP: I2P Control Protocol для управления подключениями SAMv3: Simple Anonymous Messaging для простой интеграции приложений I2PTunnel: Туннелирование TCP/IP-трафика через I2P Eepsite\u0026rsquo;ы Eepsite — это веб-сайт, размещённый в сети I2P. Eepsite\u0026rsquo;ы доступны только через I2P и используют .i2p домены.\nБезопасность I2P использует многоуровневое шифрование (garlic encryption) для защиты конфиденциальности и безопасности коммуникаций в сети.\nРекомендуется: Проброс портов (Опционально, но важно) Перед установкой I2P необходимо установить Java в вашей системе.\nJava Requirements Версия Java: требуется Java 8 (1.8) или выше Рекомендуется: Java 11 или новее (LTS-версия) Тип: Java Runtime Environment (JRE) или Java Development Kit (JDK) Installing Java Если у вас ещё не установлена Java, вы можете скачать её из нескольких источников:\nВариант 1: Oracle Java - Официальный источник: java.com/download - Наиболее широко используемый дистрибутив\nВариант 2: OpenJDK - Открытая реализация: openjdk.org - Бесплатная и с открытым исходным кодом\nВариант 3: Adoptium (Eclipse Temurin) - Рекомендуемая альтернатива: adoptium.net - Бесплатные, открытые и хорошо поддерживаемые LTS-релизы\nЧтобы проверить, установлена ли Java: 1. Откройте командную строку (нажмите Windows + R, введите cmd, нажмите Enter) 2. Введите: java -version 3. Вы должны увидеть вывод с указанием версии Java\nКонечно, я готов перевести текст. Пожалуйста, предоставьте текст для перевода.\nStep 1: Install Java Перед установкой I2P необходимо установить Java на вашу систему.\nВыберите дистрибутив Java:\nOracle Java: java.com/download OpenJDK: openjdk.org Adoptium: adoptium.net Загрузите установщик для Windows для выбранного дистрибутива\nЗапустите установщик и следуйте инструкциям по установке\nПроверьте установку:\nОткройте Командную строку Введите java -version и нажмите Enter Убедитесь, что установлена Java 8 или выше После установки Java вы готовы к установке I2P.\nStep 2: Download and Launch the I2P Installer Скачайте установщик I2P:\nПосетите страницу загрузок I2P Скачайте установщик для Windows (файл JAR): i2pinstall_X.X.X.jar Сохраните его в место, где его легко найти (например, в папку «Загрузки») Запустите установщик:\nДважды щёлкните по загруженному JAR-файлу, чтобы запустить установщик Если двойной щелчок не работает, щёлкните правой кнопкой мыши по файлу и выберите «Открыть с помощью → Java(TM) Platform SE binary» Или откройте командную строку и выполните: java -jar i2pinstall_X.X.X.jar Step 3: Select Your Language После запуска установщика вы увидите диалог выбора языка.\nВыберите предпочитаемый язык из выпадающего меню Доступные языки включают английский, немецкий, испанский, французский и многие другие Нажмите OK, чтобы продолжить Установщик будет использовать выбранный вами язык для всех последующих шагов.\nЯ понимаю. Я вижу, что вы указали, что предоставите текст для перевода, но сам текст отсутствует после \u0026ldquo;\u0026mdash;\u0026rdquo;.\nПожалуйста, предоставьте текст, который нужно перевести, и я выполню перевод согласно всем указанным правилам.\nStep 4: Welcome to I2P Installation Это Шаг 1 из 8 в процессе установки.\nНажмите Далее, чтобы продолжить установку.\nЧто такое I2P? I2P — это анонимная оверлейная сеть — слой, который работает поверх интернета. Он позволяет приложениям отправлять сообщения друг другу псевдонимно и безопасно. Анонимность достигается за счёт многоуровневого шифрования сообщений (garlic encryption) и передачи их через распределённую сеть peers, которыми управляют волонтёры по всему миру. Ни один отдельный peer не знает истинного отправителя или получателя сообщения, поэтому местоположение и личность каждого пользователя остаются конфиденциальными. Принципы проектирования и коды открыты, а сеть принадлежит сообществу и управляется им.\nСледующие шаги Это Шаг 2 из 8 в процессе установки.\nНажмите Далее, чтобы принять лицензию и продолжить.\nI2P I2P — это анонимная оверлейная сеть, предлагающая простой уровень, который приложения могут использовать для анонимной и защищенной отправки сообщений друг другу. Связь зашифрована от конца до конца (от отправителя к получателю), и нет ни одной стороны, которая могла бы увидеть, где начинается трафик, куда он направляется и каково его содержимое.\nСтандартная установка Выберите место на вашем компьютере, куда вы хотите установить I2P.\nПуть установки по умолчанию: C:\\Program Files (x86)\\i2p\\\nВы можете: - Использовать расположение по умолчанию (рекомендуется) - Нажать Обзор\u0026hellip;, чтобы выбрать другую папку\nЭто Шаг 3 из 8 в процессе установки.\nНажмите Далее, чтобы продолжить.\nПримечание: Если вы устанавливаете I2P впервые, появится всплывающее окно с подтверждением создания каталога:\nНажмите OK, чтобы создать каталог установки.\nВажно: Перед использованием I2P Прежде чем начать использовать I2P, важно понимать базовые концепции безопасности и конфиденциальности. I2P — мощный инструмент для защиты конфиденциальности, но он не является универсальным решением всех проблем безопасности.\nЧто I2P делает I2P создаёт зашифрованную сеть поверх интернета, обеспечивая:\nАнонимность: скрывает ваш IP-адрес от других участников сети I2P Шифрование end-to-end: защищает содержимое вашей коммуникации Устойчивость к цензуре: помогает обходить сетевые ограничения Что I2P НЕ делает I2P не защищает вас от:\nВредоносного ПО: зловредные программы могут скомпрометировать вашу систему независимо от I2P Небезопасных приложений: приложения с уязвимостями остаются уязвимыми Утечек на уровне приложений: программы могут раскрывать информацию в обход I2P Ненадёжного поведения: публикация личной информации раскрывает вашу личность Целенаправленных атак: продвинутые атакующие с достаточными ресурсами могут попытаться деанонимизировать пользователей Рекомендации по безопасности Обновляйте программное обеспечение: регулярно обновляйте I2P и все приложения Используйте надёжные приложения: применяйте только проверенное программное обеспечение с I2P Не смешивайте трафик: избегайте одновременного использования I2P и clearnet с одной личности Защитите свою систему: используйте фаерволы, антивирусы и безопасные практики Понимайте свою модель угроз: знайте, от кого и от чего вам нужна защита Дополнительная информация Для более глубокого понимания безопасности и конфиденциальности I2P посетите:\nДокументацию по безопасности Руководства пользователя Step 7: Select Installation Packs Выберите компоненты для установки.\nВажно: Убедитесь, что выбраны оба пакета: - Base (обязательно) - Основное ПО I2P (27.53 МБ) - Windows Service (рекомендуется) - Автоматический запуск I2P при загрузке системы\nОпция Служба Windows обеспечивает автоматический запуск I2P при загрузке компьютера, так что вам не нужно будет запускать его вручную каждый раз.\nЭто Шаг 4 из 8 в процессе установки.\nНажмите Далее, чтобы продолжить.\nПотенциальные уязвимости I2P Предварительные требования Установщик скопирует файлы на вашу систему.\nВы увидите две индикатора прогресса: - Прогресс установки пакета: Показывает устанавливаемый в данный момент пакет - Общий прогресс установки: Показывает общий прогресс (например, \u0026ldquo;2 / 2\u0026rdquo;)\nЭто Шаг 5 из 8 процесса установки.\nДождитесь завершения установки, затем нажмите Далее.\nI2P I2P — это анонимная оверлейная сеть, которая позволяет приложениям отправлять друг другу сообщения псевдонимно и безопасно.\nОсновные возможности Анонимная коммуникация: скрывает как отправителя, так и получателя Устойчивость к цензуре: работает поверх существующего интернет-соединения Распределённая архитектура: нет единой точки отказа Шифрование end-to-end: все сообщения криптографически защищены Как это работает I2P использует garlic routing — продвинутый вариант луковой маршрутизации, где несколько сообщений объединяются вместе для повышения эффективности и безопасности.\nКаждый router в сети:\nСоздаёт зашифрованные tunnel для входящего и исходящего трафика Участвует в netDb (распределённая база данных сети) Может выступать в качестве floodfill (узел для хранения информации о сети) Транспортные протоколы I2P поддерживает несколько транспортных протоколов:\nNTCP2: основанный на TCP транспорт с шифрованием SSU: основанный на UDP транспорт для работы за NAT Интерфейсы приложений SAMv3: простой протокол для интеграции приложений I2PTunnel: туннелирование TCP/HTTP трафика I2CP: низкоуровневый протокол для клиент-роутер взаимодействия Step 9: Setup Shortcuts Настройте, где вы хотите создать ярлыки I2P.\nВарианты ярлыков: - ✓ Создать ярлыки в меню «Пуск» (рекомендуется) - ✓ Создать дополнительные ярлыки на рабочем столе (опционально)\nГруппа программ: Выберите или создайте имя папки для ярлыков - По умолчанию: I2P - Вы можете выбрать существующую группу программ или создать новую\nСоздать ярлык для: - Текущего пользователя - Только вы можете получить доступ к ярлыкам - Всех пользователей - Все пользователи системы могут получить доступ к ярлыкам (требуются права администратора)\nЭто Шаг 6 из 8 в процессе установки.\nНажмите Далее, чтобы продолжить.\nI2P I2P — это анонимная оверлейная сеть, предоставляющая простой уровень, который приложения с поддержкой идентификации могут использовать для безопасной коммуникации. Весь трафик зашифрован с использованием end-to-end шифрования (в общей сложности четыре уровня), и даже конечные точки (\u0026ldquo;пункты назначения\u0026rdquo;) являются криптографическими идентификаторами (по сути, публичными ключами).\nStep 10: Installation Complete Установка завершена!\nВы увидите: - ✓ Installation has completed successfully - An uninstaller will be created in: C:\\Program Files (x86)\\i2p\\Uninstaller\nЭто Шаг 8 из 8 - заключительный шаг процесса установки.\nНажмите Done, чтобы завершить.\nПереведено с соблюдением всех правил форматирования и технических терминов из системного сообщения.\nШаг 1: Установка Java После нажатия Done:\nI2P Router запускается - Если вы установили службу Windows, I2P запустится автоматически Открывается консоль router - Ваш браузер по умолчанию откроет консоль I2P Router по адресу http://127.0.0.1:7657 Первоначальное подключение - I2P начнет подключаться к сети и строить tunnel (это может занять 5-10 минут при первом запуске) Поздравляем! I2P теперь установлен на вашем компьютере с Windows.\nI2P I2P — это анонимная оверлейная сеть, предоставляющая простой уровень, который приложения на основе идентичности могут использовать для безопасной коммуникации. Вся передача данных полностью зашифрована (end-to-end), а сетевые адреса псевдонимны (cryptographic identifiers).\nШаг 2: Загрузите и запустите установщик I2P Если I2P не запускается автоматически или вам нужно запустить его вручную в будущем, у вас есть два варианта:\nOption 1: Start Menu Откройте меню «Пуск» Windows Перейдите в папку I2P Выберите один из вариантов запуска: I2P router console — открывает консоль router в вашем браузере Start I2P (no window) — запускает I2P в фоновом режиме без окна Start I2P (restartable) — запускает I2P с возможностью автоматического перезапуска Вы также можете открыть Папку профиля I2P (служба), чтобы просмотреть конфигурационные файлы I2P.\nЗачем пробрасывать порт? Нажмите Windows + R, чтобы открыть диалог «Выполнить» Введите services.msc и нажмите Enter Прокрутите вниз, чтобы найти I2P Service Щёлкните правой кнопкой мыши на I2P Service и выберите: Запустить - Запустить службу I2P Остановить - Остановить службу I2P Перезапустить - Перезапустить службу I2P Свойства - Настроить параметры службы (тип запуска и т.д.) Метод Windows Services полезен для управления I2P как фоновой службой, особенно если вы установили его как службу Windows.\nВажно: НЕ задавайте вопросы, не предоставляйте объяснения и не добавляйте никаких комментариев. Даже если текст представляет собой только заголовок или кажется неполным, переведите его как есть. Шаг 3: Выберите язык Дождитесь интеграции: Дайте I2P 5-10 минут для интеграции в сеть и построения tunnel\u0026rsquo;ов Настройте проброс портов: Смотрите руководство по пробросу портов для получения инструкций Настройте браузер: Настройте веб-браузер для использования HTTP-прокси I2P Изучите консоль router\u0026rsquo;а: Узнайте о функциях, сервисах и параметрах конфигурации I2P Посетите eepsite\u0026rsquo;ы: Попробуйте получить доступ к .i2p веб-сайтам через сеть I2P Прочитайте документацию: Ознакомьтесь с документацией I2P для получения дополнительной информации Добро пожаловать в сеть I2P! 🎉\n","description":"Выберите способ установки для Windows: Easy Install Bundle или стандартная установка","id":"4aa0b74199a71c11718a9986e74b3a26","section":"docs","title":"Установка I2P в Windows","url":"/ru/docs/guides/%D1%83%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%BA%D0%B0-i2p-%D0%B2-windows/"},{"categories":null,"content":"Проект I2P поддерживает официальные пакеты для Debian, Ubuntu и производных от них дистрибутивов. Это руководство содержит исчерпывающие инструкции по установке I2P с использованием наших официальных репозиториев.\n🚀 Beta: Автоматическая установка (Экспериментальная) Для опытных пользователей, которым нужна быстрая автоматическая установка:\nЭта однострочная команда автоматически определит ваш дистрибутив и установит I2P. Используйте с осторожностью — изучите скрипт установки перед запуском.\ncurl -fsSL https://i2p.net/installlinux.sh | sudo bash Что это делает: - Определяет ваш дистрибутив Linux (Ubuntu/Debian) - Добавляет соответствующий репозиторий I2P - Устанавливает GPG-ключи и необходимые пакеты - Автоматически устанавливает I2P\n⚠️ Это бета-функция. Если вы предпочитаете ручную установку или хотите понять каждый шаг, используйте методы ручной установки ниже.\nПоддерживаемые платформы Пакеты Debian совместимы с:\nUbuntu 18.04 (Bionic) и новее Linux Mint 19 (Tara) и новее Debian Buster (10) и новее Knoppix Другие дистрибутивы на базе Debian (LMDE, ParrotOS, Kali Linux и т.д.) Поддерживаемые архитектуры: amd64, i386, armhf, arm64, powerpc, ppc64el, s390x\nПакеты I2P могут работать на других системах на базе Debian, не указанных явно выше. Если вы столкнулись с проблемами, пожалуйста, сообщите о них в нашем GitLab .\nМетоды установки Выберите метод установки, соответствующий вашему дистрибутиву:\nВариант 1: Ubuntu и производные дистрибутивы (Linux Mint, elementary OS, Pop!_OS и т.д.) Вариант 2: Debian и дистрибутивы на основе Debian (включая LMDE, Kali, ParrotOS) I2P I2P — это анонимная оверлейная сеть, предоставляющая простой уровень, на котором приложения могут безопасно общаться друг с другом. Вся передача данных полностью зашифрована с использованием сквозного шифрования (end-to-end), и даже конечные точки (\u0026ldquo;пункты назначения\u0026rdquo;) являются криптографическими идентификаторами (по сути, хешами открытых ключей), поэтому любые отправитель и получатель сообщения остаются анонимными. Каждое запущенное клиентское приложение I2P имеет свои собственные зашифрованные туннели I2P, и эти туннели непродолжительны и постоянно меняются.\nУстановка на Ubuntu Ubuntu и его официальные производные (Linux Mint, elementary OS, Trisquel и т.д.) могут использовать I2P PPA (Personal Package Archive) для простой установки и автоматических обновлений.\nMethod 1: Command Line Installation (Recommended) Это самый быстрый и надёжный способ установки I2P на системах на базе Ubuntu.\nШаг 1: Добавление PPA для I2P\nОткройте терминал и выполните:\nsudo apt-add-repository ppa:i2p-maintainers/i2p Эта команда добавляет I2P PPA в /etc/apt/sources.list.d/ и автоматически импортирует GPG-ключ, которым подписан репозиторий. Цифровая подпись GPG гарантирует, что пакеты не были изменены с момента их сборки.\nШаг 2: Обновление списка пакетов\nОбновите базу данных пакетов вашей системы, чтобы включить новый PPA:\nsudo apt-get update Это получает информацию о последних пакетах из всех включённых репозиториев, включая PPA I2P, который вы только что добавили.\nШаг 3: Установка I2P\nТеперь установите I2P:\nsudo apt-get install i2p Вот и всё! Перейдите к разделу Настройка после установки , чтобы узнать, как запустить и настроить I2P.\nMethod 2: Using the Software Center GUI Если вы предпочитаете графический интерфейс, вы можете добавить PPA, используя Центр приложений Ubuntu.\nШаг 1: Откройте Программы и обновления\nЗапустите «Программы и обновления» из меню приложений.\nШаг 2: Перейдите в раздел «Другое программное обеспечение»\nВыберите вкладку \u0026ldquo;Other Software\u0026rdquo; и нажмите кнопку \u0026ldquo;Add\u0026rdquo; внизу для настройки нового PPA.\nШаг 3: Добавление PPA для I2P\nВ диалоговом окне PPA введите:\nppa:i2p-maintainers/i2p Шаг 4: Обновите информацию о репозитории\nНажмите кнопку «Reload», чтобы загрузить обновленную информацию репозитория.\nШаг 5: Установка I2P\nОткройте приложение \u0026ldquo;Программы\u0026rdquo; из меню приложений, найдите \u0026ldquo;i2p\u0026rdquo; и нажмите \u0026ldquo;Установить\u0026rdquo;.\nПосле завершения установки перейдите к Настройке после установки .\nРесид-серверы I2P Ресид-серверы — это специальные серверы, которые предоставляют новым роутерам I2P начальный список активных узлов для подключения к сети.\nЧто такое ресид-сервер? Когда ваш I2P-роутер запускается впервые, ему необходимо знать о других роутерах в сети для установления соединения. Ресид-серверы решают эту проблему \u0026ldquo;холодного старта\u0026rdquo;, предоставляя список контактной информации других роутеров.\nКак это работает Новый I2P-роутер подключается к одному из настроенных ресид-серверов Ресид-сервер отправляет список известных активных роутеров (их RouterInfo) Ваш роутер использует эту информацию для установления первых соединений После подключения ваш роутер может находить других участников через netDb Настроенные ресид-серверы I2P поставляется с несколькими встроенными ресид-серверами:\nhttps://reseed.i2p-projekt.de/ https://i2p.mooo.com/ https://reseed.onion.im/ https://reseed.diva.exchange/ https://reseed-pl.i2pd.xyz/ https://reseed2.i2p.rocks/ https://reseed.memcpy.io/ Настройка ресид-серверов Вы можете настроить, какие ресид-серверы использует ваш роутер:\nВ Java I2P: перейдите в раздел настроек консоли роутера В i2pd: отредактируйте файл i2pd.conf Безопасность Ресид-серверы используют HTTPS и подписывают данные роутеров своими ключами. Ваш I2P-роутер проверяет эти подписи, чтобы убедиться, что получает достоверную информацию о роутерах.\nЗапуск собственного ресид-сервера Для опытных пользователей доступна возможность запустить свой собственный ресид-сервер. Это помогает децентрализации сети и обеспечивает дополнительные точки входа для новых пользователей.\nDebian Installation Debian и его производные дистрибутивы (LMDE, Kali Linux, ParrotOS, Knoppix и т.д.) должны использовать официальный репозиторий I2P для Debian по адресу deb.i2p.net.\nImportant Notice Наши старые репозитории на deb.i2p2.de и deb.i2p2.no больше не поддерживаются. Если вы используете эти устаревшие репозитории, пожалуйста, следуйте приведённым ниже инструкциям для миграции на новый репозиторий по адресу deb.i2p.net.\nPrerequisites Все нижеприведённые шаги требуют прав root. Либо переключитесь на пользователя root с помощью su, либо добавляйте sudo перед каждой командой.\nМетод 1: Установка через командную строку (Рекомендуется) Шаг 1: Установите необходимые пакеты\nУбедитесь, что у вас установлены необходимые инструменты:\nsudo apt-get update sudo apt-get install apt-transport-https lsb-release curl Эти пакеты обеспечивают безопасный HTTPS-доступ к репозиториям, определение дистрибутива и загрузку файлов.\nШаг 2: Добавьте репозиторий I2P\nКоманда, которую вы используете, зависит от вашей версии Debian. Сначала определите, какую версию вы используете:\ncat /etc/debian_version Сверьтесь с информацией о релизах Debian , чтобы определить кодовое имя вашего дистрибутива (например, Bookworm, Bullseye, Buster).\nДля Debian Bullseye (11) или новее:\necho \u0026#34;deb [signed-by=/usr/share/keyrings/i2p-archive-keyring.gpg] https://deb.i2p.net/ $(lsb_release -sc) main\u0026#34; \\ | sudo tee /etc/apt/sources.list.d/i2p.list Для производных Debian (LMDE, Kali, ParrotOS и т.д.) на Bullseye-эквиваленте или новее:\necho \u0026#34;deb [signed-by=/usr/share/keyrings/i2p-archive-keyring.gpg] https://deb.i2p.net/ $(dpkg --status tzdata | grep Provides | cut -f2 -d\u0026#39;-\u0026#39;) main\u0026#34; \\ | sudo tee /etc/apt/sources.list.d/i2p.list Для Debian Buster (10) или более старых версий:\necho \u0026#34;deb https://deb.i2p.net/ $(lsb_release -sc) main\u0026#34; \\ | sudo tee /etc/apt/sources.list.d/i2p.list Для производных от Debian на Buster-эквивалентных или более старых версиях:\necho \u0026#34;deb https://deb.i2p.net/ $(dpkg --status tzdata | grep Provides | cut -f2 -d\u0026#39;-\u0026#39;) main\u0026#34; \\ | sudo tee /etc/apt/sources.list.d/i2p.list Шаг 3: Загрузка ключа подписи репозитория\ncurl -o i2p-archive-keyring.gpg https://geti2p.net/_static/i2p-archive-keyring.gpg Шаг 4: Проверьте отпечаток ключа\nПеред тем как доверять ключу, убедитесь, что его отпечаток соответствует официальному ключу подписи I2P:\ngpg --keyid-format long --import --import-options show-only --with-fingerprint i2p-archive-keyring.gpg Убедитесь, что вывод показывает этот отпечаток:\n7840 E761 0F28 B904 7535 49D7 67EC E560 5BCF 1346 ⚠️ Не продолжайте, если отпечаток не совпадает. Это может указывать на компрометацию загрузки.\nШаг 5: Установите ключ репозитория\nСкопируйте проверенную связку ключей в системную директорию связок ключей:\nsudo cp i2p-archive-keyring.gpg /usr/share/keyrings Только для Debian Buster или более старых версий, вам также необходимо создать символическую ссылку:\nsudo ln -sf /usr/share/keyrings/i2p-archive-keyring.gpg /etc/apt/trusted.gpg.d/i2p-archive-keyring.gpg Шаг 6: Обновление списков пакетов\nОбновите базу данных пакетов вашей системы, чтобы включить репозиторий I2P:\nsudo apt-get update Шаг 7: Установка I2P\nУстановите как сам I2P router, так и пакет keyring (который обеспечит получение будущих обновлений ключей):\nsudo apt-get install i2p i2p-keyring Отлично! I2P теперь установлен. Перейдите к разделу Настройка после установки .\nРуководство по настройке I2P Введение I2P — это анонимная сеть, предоставляющая простой уровень, который приложения могут использовать для анонимной и безопасной отправки сообщений друг другу. Связь зашифрована от конца до конца. Всего активных пользователей, одновременно участвующих в работе сети, обычно около 30 000-50 000.\nУстановка Windows Скачайте установщик I2P с официального сайта Запустите установщик и следуйте инструкциям на экране После установки запустите I2P router из меню \u0026ldquo;Пуск\u0026rdquo; Linux/Mac # Для систем на базе Debian sudo apt-get update sudo apt-get install i2p # Запуск I2P router i2prouter start Базовая конфигурация После установки откройте веб-консоль router по адресу http://127.0.0.1:7657\nНастройка пропускной способности Рекомендуется выделить как минимум:\nВходящая: 256 Кбит/с Исходящая: 128 Кбит/с Чем больше пропускной способности вы выделяете, тем лучше работает сеть для всех.\nИспользование приложений Браузинг eepsite I2P позволяет получать доступ к скрытым сервисам (.i2p сайтам). Настройте браузер на использование HTTP-прокси:\nHost: 127.0.0.1 Port: 4444 Запуск собственного сервера Используйте I2PTunnel для создания серверных tunnel:\nОткройте I2PTunnel Manager в веб-консоли Нажмите \u0026ldquo;Добавить новый сервер tunnel\u0026rdquo; Настройте параметры и сохраните Дополнительные настройки Производительность Для лучшей производительности:\nОбеспечьте постоянное подключение к интернету Держите router запущенным как можно дольше Рассмотрите возможность участия в качестве floodfill router (требуется стабильное соединение и достаточная пропускная способность) Безопасность Регулярно обновляйте I2P до последней версии Используйте строгие настройки прокси Не используйте личную информацию в приложениях I2P Устранение неполадок Router не запускается Проверьте, не используется ли уже порт другим приложением Убедитесь, что у вас установлена актуальная версия Java Проверьте логи в ~/.i2p/wrapper.log Медленное подключение Подождите 10-15 минут после первого запуска для интеграции в netDb Проверьте настройки пропускной способности Убедитесь, что ваш firewall не блокирует I2P Заключение I2P — это мощный инструмент для приватных коммуникаций. Терпение важно при первом использовании, поскольку router требуется время для построения tunnel и интеграции в сеть. Чем дольше вы держите router запущенным, тем лучше будет производительность.\nPost-Installation Configuration После установки I2P вам потребуется запустить router и выполнить первоначальную настройку.\nМетод 2: Использование графического интерфейса Центра приложений Пакеты I2P предоставляют три способа запуска I2P router:\nOption 1: On-Demand (Basic) Запускайте I2P вручную при необходимости, используя скрипт i2prouter:\ni2prouter start Важно: Не используйте sudo и не запускайте от имени root! I2P должен работать от имени вашего обычного пользователя.\nЧтобы остановить I2P:\ni2prouter stop Option 2: On-Demand (Without Java Service Wrapper) Если вы используете систему не на базе x86 или Java Service Wrapper не работает на вашей платформе, используйте:\ni2prouter-nowrapper Снова, не используйте sudo и не запускайте от имени root.\nOption 3: System Service (Recommended) Для наилучшего опыта настройте автоматический запуск I2P при загрузке системы, ещё до входа в систему:\nsudo dpkg-reconfigure i2p Откроется диалог настройки. Выберите \u0026ldquo;Yes\u0026rdquo;, чтобы включить I2P в качестве системной службы.\nЭто рекомендуемый метод, потому что:\nI2P запускается автоматически при загрузке системы Ваш router поддерживает лучшую интеграцию с сетью Вы вносите вклад в стабильность сети I2P доступен сразу, когда вам это нужно Initial Router Configuration После первого запуска I2P потребуется несколько минут для интеграции в сеть. Тем временем настройте следующие важные параметры:\n1. Configure NAT/Firewall Для оптимальной производительности и участия в сети пробросьте порты I2P через ваш NAT/межсетевой экран:\nОткройте I2P Router Console Перейдите на страницу настройки сети Обратите внимание на указанные номера портов (обычно случайные порты в диапазоне 9000-31000) Пробросьте эти UDP и TCP порты в вашем роутере/файрволе Если вам нужна помощь с проброской портов, portforward.com предоставляет инструкции для конкретных моделей роутеров.\n2. Adjust Bandwidth Settings Стандартные настройки пропускной способности являются консервативными. Настройте их в соответствии с вашим интернет-соединением:\nПерейдите на страницу конфигурации Найдите раздел настроек пропускной способности По умолчанию установлены значения 96 КБ/с загрузка / 40 КБ/с отдача Увеличьте эти значения, если у вас более быстрый интернет (например, 250 КБ/с загрузка / 100 КБ/с отдача для типичного широкополосного подключения) Примечание: Установка более высоких лимитов помогает сети и улучшает вашу собственную производительность.\n3. Configure Your Browser Для доступа к I2P-сайтам (eepsites) и сервисам настройте ваш браузер на использование HTTP-прокси I2P:\nСмотрите наше Руководство по настройке браузера для подробных инструкций по настройке Firefox, Chrome и других браузеров.\nЯ предоставлю перевод с сохранением всех технических терминов I2P, Markdown-форматирования и структуры. Однако вы не предоставили текст для перевода после строки \u0026ldquo;\u0026mdash;\u0026rdquo;.\nПожалуйста, предоставьте текст, который нужно перевести, и я выполню перевод согласно всем указанным правилам.\nУстановка на Debian Важное уведомление Убедитесь, что I2P не запущен от имени root: ps aux | grep i2p Проверьте логи: tail -f ~/.i2p/wrapper.log Убедитесь, что Java установлена: java -version Предварительные требования Если во время установки возникают ошибки GPG-ключа:\nПовторно загрузите и проверьте отпечаток ключа (Шаги 3-4 выше) Убедитесь, что файл связки ключей имеет корректные права доступа: sudo chmod 644 /usr/share/keyrings/i2p-archive-keyring.gpg Шаги установки Если I2P не получает обновления:\nПроверьте, что репозиторий настроен: cat /etc/apt/sources.list.d/i2p.list Обновите списки пакетов: sudo apt-get update Проверьте наличие обновлений I2P: sudo apt-get upgrade Migrating from old repositories Если вы используете старые репозитории deb.i2p2.de или deb.i2p2.no:\nУдалите старый репозиторий: sudo rm /etc/apt/sources.list.d/i2p.list Следуйте шагам Установки на Debian выше Обновите: sudo apt-get update \u0026amp;\u0026amp; sudo apt-get install i2p i2p-keyring Следующие шаги Теперь, когда I2P установлен и работает:\nНастройте свой браузер для доступа к I2P-сайтам Изучите консоль I2P router для мониторинга вашего router Узнайте о приложениях I2P , которые вы можете использовать Прочитайте о том, как работает I2P , чтобы понять сеть Добро пожаловать в Невидимый Интернет!\n","description":"Полное руководство по установке I2P на Debian, Ubuntu и производные дистрибутивы с использованием официальных репозиториев","id":"88fb5f6d2f5129ce7be2a42b1e9fb9af","section":"docs","title":"Установка I2P на Debian и Ubuntu","url":"/ru/docs/guides/%D1%83%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%BA%D0%B0-i2p-%D0%BD%D0%B0-debian-%D0%B8-ubuntu/"},{"categories":null,"content":"Что вам понадобится Mac с macOS 10.14 (Mojave) или новее Права администратора для установки приложений Около 15-20 минут времени Подключение к интернету для загрузки установочных файлов Обзор Процесс установки включает четыре основных этапа:\nУстановите Java - Скачайте и установите Oracle Java Runtime Environment Установите I2P - Скачайте и запустите установщик I2P Настройте приложение I2P - Настройте launcher и добавьте в dock Настройте пропускную способность I2P - Запустите мастер настройки для оптимизации вашего соединения Часть первая: Установка Java Для работы I2P требуется Java. Если у вас уже установлена Java 8 или более поздняя версия, вы можете перейти к части второй .\nStep 1: Download Java Посетите страницу загрузки Oracle Java и скачайте установщик для macOS для Java 8 или более поздней версии.\nStep 2: Run the Installer Найдите загруженный файл .dmg в папке «Загрузки» и дважды щёлкните по нему, чтобы открыть.\nStep 3: Allow Installation macOS может отобразить предупреждение безопасности, поскольку установщик получен от идентифицированного разработчика. Нажмите Открыть, чтобы продолжить.\nШаг 1: Загрузите Java Нажмите Install, чтобы начать процесс установки Java.\nШаг 2: Запустите установщик Установщик скопирует файлы и настроит Java в вашей системе. Обычно это занимает 1-2 минуты.\nШаг 3: Разрешить установку Когда вы увидите сообщение об успешной установке, Java установлена! Нажмите Закрыть, чтобы завершить.\nPart Two: Download and Install I2P Теперь, когда Java установлена, вы можете установить I2P роутер.\nШаг 4: Установка Java Посетите страницу загрузок и скачайте установщик I2P для Unix/Linux/BSD/Solaris (файл .jar).\nШаг 5: Дождитесь завершения установки Дважды щёлкните по загруженному файлу i2pinstall_X.X.X.jar. Программа установки запустится и предложит выбрать предпочитаемый язык.\nШаг 6: Установка завершена Прочитайте приветственное сообщение и нажмите Next, чтобы продолжить.\nStep 4: Important Notice Установщик отобразит важное уведомление об обновлениях. Обновления I2P подписаны и проверяются сквозным образом (end-to-end), несмотря на то, что сам установщик не подписан. Нажмите Next.\nШаг 1: Скачайте I2P Прочитайте лицензионное соглашение I2P (лицензия типа BSD). Нажмите Далее, чтобы принять.\nШаг 2: Запустите установщик Выберите место для установки I2P. Рекомендуется использовать расположение по умолчанию (/Applications/i2p). Нажмите Далее.\nШаг 3: Экран приветствия Оставьте все компоненты выбранными для полной установки. Нажмите Далее.\nШаг 4: Важное замечание Просмотрите свой выбор и нажмите Next, чтобы начать установку I2P.\nШаг 5: Лицензионное соглашение Установщик скопирует файлы I2P в вашу систему. Это займет около 1-2 минут.\nШаг 6: Выбор директории установки Установщик создаёт скрипты запуска для запуска I2P.\nШаг 7: Выбор компонентов Программа установки предлагает создать ярлыки на рабочем столе и пункты меню. Сделайте свой выбор и нажмите Далее.\nШаг 8: Начало установки Успешно! I2P теперь установлен. Нажмите Готово для завершения.\nPart Three: Configure I2P App Теперь давайте упростим запуск I2P, добавив его в папку «Программы» и в Dock.\nШаг 9: Установка файлов Откройте Finder и перейдите в папку Программы.\nШаг 10: Генерация скриптов запуска Найдите папку I2P или приложение Start I2P Router внутри /Applications/i2p/.\nШаг 11: Ярлыки установки Перетащите приложение Start I2P Router на панель Dock для быстрого доступа. Вы также можете создать псевдоним на рабочем столе.\nСовет: Нажмите правой кнопкой мыши на значок I2P в Dock и выберите Параметры → Закрепить в Dock, чтобы сделать его постоянным.\nPart Four: Configure I2P Bandwidth Когда вы впервые запустите I2P, вам будет предложено пройти мастер настройки для конфигурации параметров пропускной способности. Это помогает оптимизировать производительность I2P для вашего соединения.\nШаг 12: Установка завершена Нажмите на значок I2P в Dock (или дважды щёлкните по ярлыку запуска). Ваш браузер по умолчанию откроет консоль I2P Router Console.\nStep 2: Welcome Wizard Мастер настройки поприветствует вас. Нажмите Далее, чтобы начать настройку I2P.\nШаг 1: Откройте папку «Программы» Выберите предпочитаемый язык интерфейса и выберите между светлой или тёмной темой. Нажмите Далее.\nШаг 2: Найти I2P Launcher Мастер настройки объяснит тест пропускной способности. Этот тест подключается к сервису M-Lab для измерения скорости вашего интернет-соединения. Нажмите Далее, чтобы продолжить.\nШаг 3: Добавить в Dock Нажмите Run Test, чтобы измерить скорость загрузки и выгрузки. Тест занимает около 30-60 секунд.\nStep 6: Test Results Просмотрите результаты тестирования. I2P порекомендует настройки пропускной способности на основе скорости вашего соединения.\nШаг 1: Запуск I2P Выберите, какой объём пропускной способности вы хотите предоставить сети I2P:\nАвтоматический (Рекомендуется): I2P управляет пропускной способностью на основе вашего использования Ограниченный: Установите конкретные лимиты загрузки/выгрузки Неограниченный: Делитесь максимально возможным объёмом (для быстрых соединений) Нажмите Next (Далее), чтобы сохранить настройки.\nШаг 2: Мастер приветствия Ваш I2P router теперь настроен и работает! Консоль роутера покажет статус соединения и позволит вам просматривать I2P-сайты.\nGetting Started with I2P Теперь, когда I2P установлен и настроен, вы можете:\nПросмотр I2P-сайтов: Посетите домашнюю страницу I2P , чтобы увидеть ссылки на популярные I2P-сервисы Настройка браузера: Создайте профиль браузера для доступа к сайтам .i2p Изучение сервисов: Ознакомьтесь с I2P-почтой, форумами, файлообменом и другими возможностями Мониторинг router: Консоль показывает статус вашей сети и статистику Шаг 3: Язык и тема Router Console: http://127.0.0.1:7657/ Конфигурация: http://127.0.0.1:7657/config Адресная книга: http://127.0.0.1:7657/susidns/addressbook Настройки пропускной способности: http://127.0.0.1:7657/config Re-running the Setup Wizard Если вы хотите изменить настройки пропускной способности или перенастроить I2P позже, вы можете запустить мастер приветствия снова из консоли router:\nПерейдите в Мастер настройки I2P Снова выполните шаги мастера Troubleshooting Шаг 4: Информация о тесте пропускной способности Проверьте Java: Убедитесь, что Java установлена, выполнив команду java -version в Terminal Проверьте права доступа: Убедитесь, что папка I2P имеет корректные права доступа Проверьте логи: Просмотрите ~/.i2p/wrapper.log на наличие сообщений об ошибках Шаг 5: Запуск теста пропускной способности Убедитесь, что I2P запущен (проверьте Router Console) Настройте прокси-сервер в браузере на использование HTTP proxy 127.0.0.1:4444 Подождите 5-10 минут после запуска, чтобы I2P интегрировался в сеть Шаг 6: Результаты тестирования Запустите тест пропускной способности снова и скорректируйте настройки Убедитесь, что вы делитесь пропускной способностью с сетью Проверьте статус подключения в Router Console Часть вторая: Загрузка и установка I2P Чтобы удалить I2P с вашего Mac:\nЗакройте I2P router, если он запущен Удалите папку /Applications/i2p Удалите папку ~/.i2p (ваша конфигурация и данные I2P) Удалите иконку I2P из Dock Next Steps Присоединяйтесь к сообществу: Посетите i2pforum.net или загляните в I2P на Reddit Узнайте больше: Прочитайте документацию I2P , чтобы понять, как работает сеть Примите участие: Рассмотрите возможность внести вклад в разработку I2P или запустить инфраструктуру Поздравляем! Теперь вы являетесь частью сети I2P. Добро пожаловать в невидимый интернет!\nЯ предоставлю перевод текста, как только вы его укажете. Пожалуйста, добавьте текст для перевода после разделителя \u0026ldquo;\u0026mdash;\u0026rdquo;.\n","description":"Пошаговое руководство по ручной установке I2P и его зависимостей на macOS","id":"f88100195c365b18735e1ea12826a97e","section":"docs","title":"Установка I2P на macOS (Длинный способ)","url":"/ru/docs/guides/%D1%83%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%BA%D0%B0-i2p-%D0%BD%D0%B0-macos-%D0%B4%D0%BB%D0%B8%D0%BD%D0%BD%D1%8B%D0%B9-%D1%81%D0%BF%D0%BE%D1%81%D0%BE%D0%B1/"},{"categories":null,"content":"Фреймворк плагинов I2P позволяет расширять функциональность router без изменения базовой установки. Доступные плагины охватывают почту, блоги, IRC, хранилище данных, вики, инструменты мониторинга и многое другое.\nПримечание по безопасности: Плагины работают с теми же правами доступа, что и роутер. Относитесь к загрузкам от сторонних разработчиков так же, как вы относитесь к любому подписанному обновлению программного обеспечения — проверяйте источник перед установкой.\n1. Установка плагина Скопируйте URL для загрузки плагина со страницы проекта.\nОткройте страницу конфигурации плагинов в консоли router.\nВставьте URL в поле установки и нажмите Install Plugin.\nРоутер загружает подписанный архив, проверяет подпись и активирует плагин немедленно. Большинство плагинов добавляют ссылки в консоль или фоновые сервисы без необходимости перезапуска роутера.\n2. Почему плагины важны Установка в один клик для конечных пользователей — без ручного редактирования wrapper.config или clients.config Сохраняет размер основного пакета i2update.su3 небольшим, предоставляя крупные или нишевые функции по требованию Опциональные JVM для каждого плагина обеспечивают изоляцию процессов при необходимости Автоматическая проверка совместимости с версией роутера, средой выполнения Java и Jetty Механизм обновления аналогичен роутеру: подписанные пакеты и инкрементальные загрузки Поддерживаются интеграции с консолью, языковые пакеты, темы UI и приложения не на Java (через скрипты) Позволяет создавать курируемые каталоги «магазинов приложений», такие как plugins.i2p 3. Управление установленными плагинами Используйте элементы управления на странице плагинов маршрутизатора I2P , чтобы:\nПроверка обновлений для отдельного плагина Проверка всех плагинов одновременно (запускается автоматически после обновления роутера) Установка всех доступных обновлений одним кликом\nВключение/отключение автозапуска для плагинов, регистрирующих сервисы Чистое удаление плагинов 4. Создайте свой собственный плагин Изучите спецификацию плагинов для понимания требований к упаковке, подписи и метаданным. Используйте makeplugin.sh для упаковки существующего бинарного файла или веб-приложения в устанавливаемый архив. Опубликуйте URL-адреса как для установки, так и для обновления, чтобы роутер мог различать первоначальную установку и инкрементные обновления. Разместите контрольные суммы и ключи подписи на видном месте на странице вашего проекта, чтобы помочь пользователям проверить подлинность. Ищете примеры? Просмотрите исходный код плагинов сообщества на plugins.i2p (например, образец snowman).\n5. Известные ограничения Обновление плагина, который поставляется в виде обычных JAR-файлов, может потребовать перезапуска роутера, так как загрузчик классов Java кэширует классы. Консоль может отображать кнопку Stop, даже если у плагина нет активного процесса. Плагины, запущенные в отдельной JVM, создают директорию logs/ в текущем рабочем каталоге. При первом появлении ключа подписанта он автоматически считается доверенным; централизованного центра подписи не существует. Windows иногда оставляет пустые директории после удаления плагина. Установка плагина, предназначенного только для Java 6, на JVM Java 5 выдаёт ошибку «plugin is corrupt» из-за сжатия Pack200. Плагины тем и переводов остаются в основном непротестированными. Флаги автозапуска не всегда сохраняются для неуправляемых плагинов. 6. Требования и рекомендации Поддержка плагинов доступна в I2P версии 0.7.12 и новее. Поддерживайте свой router и плагины в актуальном состоянии, чтобы получать исправления безопасности. Включайте краткие примечания к выпуску, чтобы пользователи понимали, какие изменения произошли между версиями. По возможности размещайте архивы плагинов по HTTPS внутри I2P, чтобы минимизировать раскрытие метаданных в открытой сети. 7. Дополнительные материалы Спецификация плагинов Фреймворк клиентских приложений Репозиторий скриптов I2P для утилит упаковки ","description":"Установка, обновление и разработка плагинов роутера","id":"f8687b90431c32a8ee7e10be9f7c44e0","section":"docs","title":"Установка пользовательских плагинов","url":"/ru/docs/guides/plugins/"},{"categories":null,"content":"Обзор Плагины I2P — это подписанные архивы, которые расширяют функциональность router. Они поставляются в виде файлов .xpi2p или .su3, устанавливаются в ~/.i2p/plugins/\u0026lt;name\u0026gt;/ (или %APPDIR%\\I2P\\plugins\\\u0026lt;name\u0026gt;\\ в Windows) и выполняются с полными правами доступа router без sandboxing (изоляции в песочнице).\nПоддерживаемые типы плагинов Веб‑приложения консоли Новые eepsites с cgi-bin, веб‑приложениями Темы консоли Переводы консоли Программы на Java (внутри процесса или в отдельной JVM) Скрипты оболочки и нативные бинарные файлы Модель безопасности КРИТИЧНО: Плагины выполняются в той же JVM с теми же правами, что и I2P router. Они имеют неограниченный доступ к: - Файловой системе (чтение и запись) - API router и его внутреннему состоянию - Сетевым подключениям - Выполнению внешних программ\nПлагины следует рассматривать как полностью доверенный код. Пользователи должны проверять источники и подписи плагинов перед установкой.\nФорматы файлов Формат SU3 (настоятельно рекомендуется) Статус: Активный, предпочтительный формат начиная с I2P 0.9.15 (сентябрь 2014)\nФормат .su3 предоставляет: - Ключи подписи RSA-4096 (по сравнению с DSA-1024 в xpi2p) - Подпись хранится в заголовке файла - Магическое число: I2Psu3 - Лучшая совместимость с будущими версиями\nСтруктура:\n[SU3 Header with RSA-4096 signature] [ZIP Archive] ├── plugin.config (required) ├── console/ ├── lib/ ├── webapps/ └── [other plugin files] Формат XPI2P (устаревший, не рекомендуется к использованию) Статус: Поддерживается для обратной совместимости, не рекомендуется для новых плагинов\nФормат .xpi2p использует устаревшие криптографические подписи: - Подписи DSA-1024 (устарели согласно NIST-800-57) - 40-байтовая подпись DSA, добавляемая перед ZIP - Требуется поле key в plugin.config\nСтруктура:\n[40-byte DSA signature] [16-byte version string (UTF-8, zero-padded)] [ZIP Archive] Путь миграции: При миграции с xpi2p на su3 указывайте оба updateURL и updateURL.su3 во время перехода. Современные routers (0.9.15+) автоматически отдают приоритет SU3.\nСтруктура архива и plugin.config Необходимые файлы plugin.config - Стандартный файл конфигурации I2P с парами ключ-значение\nОбязательные параметры Property Description Format nameInstallation directory name, must match for updatesAlphanumeric, no spaces signerDeveloper contact informationuser@mail.i2p format recommended versionPlugin version for update comparisonMax 16 bytes, parsed by VersionComparator keyDSA public key (172 B64 chars ending with '=')Omit for SU3 format **Примеры форматов версий:** - `1.2.3` - `1.2.3-4` - `2.0.0-beta.1` Допустимые разделители: . (точка), - (дефис), _ (нижнее подчеркивание)\nНеобязательные свойства метаданных Отображение информации date - Дата релиза (метка времени в формате Java long) author - Имя разработчика (user@mail.i2p рекомендуется) description - Описание на английском description_xx - Локализованное описание (xx = код языка) websiteURL - Домашняя страница плагина (http://foo.i2p/) license - Идентификатор лицензии (например, \u0026ldquo;Apache-2.0\u0026rdquo;, \u0026ldquo;GPL-3.0\u0026rdquo;) Настройка обновлений updateURL - адрес обновления XPI2P (устаревший) updateURL.su3 - адрес обновления SU3 (предпочтительный) min-i2p-version - минимально необходимая версия I2P max-i2p-version - максимальная совместимая версия I2P min-java-version - минимальная версия Java (например, 1.7, 17) min-jetty-version - минимальная версия Jetty (используйте 6 для Jetty 6+) max-jetty-version - максимальная версия Jetty (используйте 5.99999 для Jetty 5) Поведение установки dont-start-at-install - По умолчанию false. Если true, требуется ручной запуск router-restart-required - По умолчанию false. Сообщает пользователю, что после обновления требуется перезапуск update-only - По умолчанию false. Завершается с ошибкой, если плагин ещё не установлен install-only - По умолчанию false. Завершается с ошибкой, если плагин уже установлен min-installed-version - Минимальная версия, необходимая для обновления max-installed-version - Максимальная версия, которую можно обновить disableStop - По умолчанию false. Если true, скрывает кнопку остановки Интеграция с консолью consoleLinkName - Текст для ссылки в сводной панели консоли consoleLinkName_xx - Локализованный текст ссылки (xx = код языка) consoleLinkURL - Адрес назначения ссылки (например, /appname/index.jsp) consoleLinkTooltip - Текст всплывающей подсказки (поддерживается с 0.7.12-6) consoleLinkTooltip_xx - Локализованная всплывающая подсказка console-icon - Путь к значку 32x32 (поддерживается с 0.9.20) icon-code - Base64-кодированный PNG 32x32 для плагинов без веб-ресурсов (с 0.9.25) Требования к платформе (только для отображения) required-platform-OS - Требование к операционной системе (не проверяется) other-requirements - Дополнительные требования (например, \u0026ldquo;Python 3.8+\u0026rdquo;) Управление зависимостями (не реализовано) depends - Зависимости плагина, перечисленные через запятую depends-version - Требования к версиям для зависимостей langs - Содержимое языкового пакета type - Тип плагина (app/theme/locale/webapp) Обновление подстановки переменных в URL Статус функции: Доступно начиная с I2P 1.7.0 (0.9.53)\nИ updateURL, и updateURL.su3 поддерживают переменные, зависящие от платформы:\nПеременные: - $OS - Операционная система: windows, linux, mac - $ARCH - Архитектура: 386, amd64, arm64\nПример:\nupdateURL.su3=http://foo.i2p/downloads/foo-$OS-$ARCH.su3 Результат на Windows AMD64:\nhttp://foo.i2p/downloads/foo-windows-amd64.su3 Это позволяет использовать единый файл plugin.config для платформозависимых сборок.\nСтруктура каталогов Стандартная компоновка plugins/ └── pluginname/ ├── plugin.config (required) ├── console/ │ ├── locale/ # Translation JARs │ ├── themes/ # Console themes │ ├── webapps/ # Web applications │ └── webapps.config # Webapp configuration ├── eepsite/ │ ├── cgi-bin/ │ ├── docroot/ │ ├── logs/ │ ├── webapps/ │ └── jetty.xml ├── lib/ │ └── *.jar # Plugin libraries └── clients.config # Client startup configuration Назначение каталогов console/locale/ - файлы JAR с пакетами ресурсов для базовых переводов I2P - переводы, специфичные для плагинов, должны быть в console/webapps/*.war или lib/*.jar\nconsole/themes/ - Каждый подкаталог содержит полноценную тему консоли - Автоматически добавляется в путь поиска тем\nconsole/webapps/ - файлы .war для интеграции с консолью - Запускаются автоматически, если не отключены в webapps.config - Имя WAR не обязательно должно совпадать с именем плагина\neepsite/ - Полноценный eepsite с собственным экземпляром Jetty - Требует конфигурации jetty.xml с подстановкой переменных - См. примеры zzzot и плагина pebble\nlib/ - JAR-библиотеки плагина - Укажите в classpath через clients.config или webapps.config\nНастройка веб-приложений Формат webapps.config Стандартный файл конфигурации I2P, управляющий поведением веб‑приложения.\nСинтаксис:\n# Disable autostart webapps.warname.startOnLoad=false # Add classpath JARs (as of API 0.9.53, works for any warname) webapps.warname.classpath=$PLUGIN/lib/foo.jar,$I2P/lib/bar.jar Важные примечания: - До router 0.7.12-9, используйте plugin.warname.startOnLoad для совместимости - До API 0.9.53, classpath (путь к классам) работал только если warname совпадал с именем плагина - Начиная с 0.9.53+, classpath работает для любого имени веб‑приложения\nЛучшие практики для веб-приложений Реализация ServletContextListener\nРеализуйте javax.servlet.ServletContextListener для очистки Или переопределите destroy() в сервлете Обеспечивает корректное завершение работы при обновлениях и остановке router Управление библиотеками\nРазмещайте общие JAR-файлы в lib/, а не внутри WAR (архива веб-приложения Java) Подключайте через classpath в webapps.config Позволяет отдельно устанавливать и обновлять плагины Избегайте конфликтующих библиотек\nНикогда не включайте в пакет JAR‑файлы Jetty, Tomcat или сервлетов Никогда не включайте JAR‑файлы из стандартной установки I2P Проверьте раздел classpath на наличие стандартных библиотек Требования к компиляции\nНе включайте исходные файлы .java или .jsp Предварительно скомпилируйте все JSP, чтобы избежать задержек при запуске Нельзя предполагать наличие компилятора Java/JSP Совместимость с Servlet API\nI2P поддерживает Servlet 3.0 (начиная с 0.9.30) Сканирование аннотаций НЕ поддерживается (@WebContent) Необходимо предоставить традиционный дескриптор развертывания web.xml Версия Jetty\nТекущая: Jetty 9 (I2P 0.9.30+) Используйте net.i2p.jetty.JettyStart для абстракции Защищает от изменений в API Jetty Настройка клиента Формат clients.config Определяет клиентов (служб), запускаемых вместе с плагином.\nБазовый клиент:\nclientApp.0.main=com.example.PluginMain clientApp.0.name=Example Plugin Service clientApp.0.delay=30 clientApp.0.args=arg1 arg2 $PLUGIN/config.properties Клиент с возможностью остановки/удаления:\nclientApp.0.stopargs=stop clientApp.0.uninstallargs=uninstall clientApp.0.classpath=$PLUGIN/lib/plugin.jar,$I2P/lib/i2p.jar Справочник по свойствам Property Description mainFully qualified class name implementing ClientApp interface nameDisplay name for user interface delayStartup delay in seconds (default: 0) argsSpace-separated arguments passed to constructor stopargsArguments for shutdown (must handle gracefully) uninstallargsArguments called before plugin deletion classpathComma-separated JAR paths ### Подстановка переменных Следующие переменные подставляются в args, stopargs, uninstallargs и classpath:\nVariable Replacement $I2PI2P base installation directory $CONFIGI2P configuration directory (typically ~/.i2p) $PLUGINThis plugin's directory ($CONFIG/plugins/name) $OSOperating system: windows, linux, mac $ARCHArchitecture: 386, amd64, arm64 ### Управляемые и неуправляемые клиенты Управляемые клиенты (рекомендуется с версии 0.9.4): - Создаются ClientAppManager - Обеспечивают отслеживание ссылок и состояния - Упрощают управление жизненным циклом - Улучшают управление памятью\nНеуправляемые клиенты: - Запускаются router; отслеживание состояния не ведётся - Должны корректно обрабатывать многократные вызовы запуска/остановки - Для координации используют статическое состояние или PID-файлы - Вызываются при завершении работы router (начиная с 0.7.12-3)\nShellService (начиная с 0.9.53 / 1.7.0) Универсальное решение для запуска внешних программ с автоматическим отслеживанием состояния.\nОсобенности: - Управляет жизненным циклом процесса - Взаимодействует с ClientAppManager - Автоматическое управление PID - Кроссплатформенная поддержка\nИспользование:\nclientApp.0.main=net.i2p.apps.ShellService clientApp.0.args=$PLUGIN/bin/myservice.sh Для платформозависимых скриптов:\nclientApp.0.args=$PLUGIN/bin/myservice-$OS.$ARCH Альтернатива (устаревшее): Напишите обёртку на Java, проверяющую тип ОС, и вызовите ShellCommand с соответствующим файлом .bat или .sh.\nПроцесс установки Пользовательский процесс установки Пользователь вставляет URL плагина на страницу конфигурации плагинов консоли router (/configplugins) router загружает файл плагина Проверка подписи (не проходит, если ключ неизвестен и включен строгий режим) Проверка целостности ZIP Извлечение и разбор plugin.config Проверка совместимости версий (min-i2p-version, min-java-version и т. д.) Обнаружение конфликта названий веб-приложений Остановка существующего плагина при обновлении Проверка каталога (должен находиться в plugins/) Извлечение всех файлов в каталог плагина Обновление plugins.config Запуск плагина (если не задано dont-start-at-install=true) Безопасность и доверие Управление ключами: - Модель доверия «first-key-seen» (доверие при первом использовании) для новых подписантов - Только ключи jrandom и zzz включены в поставку - Начиная с 0.9.14.1, неизвестные ключи по умолчанию отклоняются - Можно переопределить с помощью расширенного параметра для разработки\nОграничения установки: - Архивы должны распаковываться только в каталог плагина - Установщик отказывается принимать пути вне plugins/ - После установки плагины могут получать доступ к файлам в других местах - Нет песочницы или изоляции привилегий\nМеханизм обновления Процесс проверки обновлений Router читает updateURL.su3 (предпочтительно) или updateURL из plugin.config HTTP HEAD или частичный запрос GET, чтобы получить байты 41-56 Извлечь строку версии из удаленного файла Сравнить с установленной версией с помощью VersionComparator Если новее, запросить у пользователя подтверждение или выполнить автоматическую загрузку (в зависимости от настроек) Остановить плагин Установить обновление Запустить плагин (если пользовательская настройка не была изменена) Сравнение версий Версии интерпретируются как компоненты, разделённые точками/дефисами/подчёркиваниями: - 1.2.3 \u0026lt; 1.2.4 - 1.2.3 \u0026lt; 1.2.3-1 - 2.0.0 \u0026gt; 1.9.9\nМаксимальная длина: 16 байт (должна совпадать с заголовком SUD/SU3)\nЛучшие практики обновления Всегда увеличивайте версию для релизов Протестируйте путь обновления из предыдущей версии Рассмотрите использование router-restart-required для крупных изменений Во время миграции указывайте и updateURL, и updateURL.su3 Используйте суффикс номера сборки для тестирования (1.2.3-456) Classpath и стандартные библиотеки Всегда доступно в Classpath Следующие JAR-файлы из $I2P/lib всегда включены в classpath (путь к классам) для I2P 0.9.30+:\nJAR Contents Plugin Usage i2p.jarCore APIRequired for all plugins mstreaming.jarStreaming APIMost plugins need streaming.jarStreaming implementationMost plugins need i2ptunnel.jarI2PTunnelHTTP/server plugins router.jarRouter internalsRarely needed, avoid if possible javax.servlet.jarServlet 3.1, JSP 2.3 APIPlugins with servlets/JSPs jasper-runtime.jarJasper compiler/runtimePlugins with JSPs commons-el.jarEL 3.0 APIJSPs using expression language jetty-i2p.jarJetty utilitiesPlugins starting Jetty org.mortbay.jetty.jarJetty 9 baseCustom Jetty instances sam.jarSAM APIRarely needed addressbook.jarSubscription/blockfileUse NamingService instead routerconsole.jarConsole librariesNot public API, avoid jbigi.jarNative cryptoPlugins should not need systray.jarURL launcherRarely needed wrapper.jarService wrapperPlugins should not need ### Особые примечания commons-logging.jar: - Пустой начиная с 0.9.30 - До 0.9.30: Apache Tomcat JULI - До 0.9.24: Commons Logging + JULI - До 0.9: Только Commons Logging\njasper-compiler.jar: - Пустой начиная с Jetty 6 (0.9)\nsystray4j.jar: - Удалён в 0.9.26\nОтсутствует в classpath (необходимо указать) JAR Contents Usage jstl.jarStandard TaglibJSP tag libraries standard.jarStandard TaglibJSP tag libraries ### Спецификация пути классов В clients.config:\nclientApp.0.classpath=$PLUGIN/lib/mylib.jar,$I2P/lib/i2p.jar В файле webapps.config:\nwebapps.mywebapp.classpath=$PLUGIN/lib/mylib.jar,$I2P/lib/jstl.jar Важно: Начиная с версии 0.7.13-3, значения classpath (путь к классам) привязаны к потокам, а не глобальны для JVM. Указывайте полный classpath для каждого клиента.\nТребования к версии Java Текущие требования (октябрь 2025 года) I2P 2.10.0 и более ранние версии: - Минимум: Java 7 (требуется с 0.9.24, январь 2016) - Рекомендуется: Java 8 или выше\nI2P 2.11.0 и новее (СКОРО): - Минимум: Java 17+ (объявлено в примечаниях к выпуску 2.9.0) - Предупреждение за два релиза дано (2.9.0 → 2.10.0 → 2.11.0)\nСтратегия совместимости плагинов Для максимальной совместимости (вплоть до I2P 2.10.x включительно):\n\u0026lt;javac source=\u0026#34;1.7\u0026#34; target=\u0026#34;1.7\u0026#34; /\u0026gt; min-java-version=1.7 Для возможностей Java 8+:\n\u0026lt;javac source=\u0026#34;1.8\u0026#34; target=\u0026#34;1.8\u0026#34; /\u0026gt; min-java-version=1.8 Для возможностей Java 11+:\n\u0026lt;javac source=\u0026#34;11\u0026#34; target=\u0026#34;11\u0026#34; /\u0026gt; min-java-version=11 Подготовка к версии 2.11.0+:\n\u0026lt;javac source=\u0026#34;17\u0026#34; target=\u0026#34;17\u0026#34; /\u0026gt; min-java-version=17 min-i2p-version=2.11.0 Лучшие практики компиляции При компиляции с более новой JDK под более старую целевую версию:\n\u0026lt;javac source=\u0026#34;1.7\u0026#34; target=\u0026#34;1.7\u0026#34; bootclasspath=\u0026#34;${java7.home}/jre/lib/rt.jar\u0026#34; includeantruntime=\u0026#34;false\u0026#34; /\u0026gt; Это предотвращает использование API, недоступных в целевой версии Java.\nСжатие Pack200 - УСТАРЕЛО Критическое обновление: не используйте Pack200 Статус: УСТАРЕЛО И УДАЛЕНО\nВ исходной спецификации настоятельно рекомендовалось сжатие Pack200 для уменьшения размера на 60–65%. Это больше не применимо.\nХронология: - JEP 336: Pack200 объявлён устаревшим в Java 11 (сентябрь 2018) - JEP 367: Pack200 удалён в Java 14 (март 2020)\nОфициальная спецификация обновлений I2P гласит: \u0026gt; \u0026ldquo;Файлы JAR и WAR в ZIP-архиве больше не сжимаются с помощью pack200, как описано выше для файлов \u0026lsquo;su2\u0026rsquo;, поскольку современные среды выполнения Java больше не поддерживают его.\u0026rdquo;\nЧто делать:\nНемедленно удалите pack200 (формат сжатия JAR) из процессов сборки Используйте стандартное сжатие ZIP Рассмотрите альтернативы: ProGuard/R8 для уменьшения размера кода UPX для нативных исполняемых файлов Современные алгоритмы сжатия (zstd, brotli) при наличии собственного распаковщика Для существующих плагинов: - Старые routers (0.7.11-5 до Java 10 включительно) по-прежнему могут распаковывать pack200 - Новые routers (Java 11+) не могут распаковывать pack200 - Переиздайте плагины без сжатия pack200\nКлючи подписи и безопасность Генерация ключей (формат SU3) Используйте скрипт makeplugin.sh из репозитория i2p.scripts:\n# Generate new signing key ./makeplugin.sh keygen # Keys stored in ~/.i2p-plugin-keys/ Ключевые параметры: - Алгоритм: RSA_SHA512_4096 - Формат: сертификат X.509 - Хранилище: формат Java keystore\nПодписание плагинов # Create signed su3 file ./makeplugin.sh sign myplugin.zip myplugin.su3 keyname # Verify signature ./makeplugin.sh verify myplugin.su3 Лучшие практики управления ключами Сгенерируйте один раз — защищайте навсегда\nRouters отклоняют одинаковые имена ключей при разных ключах Routers отклоняют одинаковые ключи с разными именами ключей Обновления отклоняются при несоответствии ключа и имени Безопасное хранение\nСоздавайте безопасные резервные копии хранилища ключей Используйте надёжную парольную фразу Никогда не добавляйте в систему контроля версий Ротация ключей\nНе поддерживается текущей архитектурой Планируйте долгосрочное использование ключей Рассмотрите схемы мультиподписи для командной разработки Устаревшее подписание DSA (XPI2P) Статус: Работоспособно, но устарело\nПодписи DSA-1024, используемые форматом xpi2p (формат пакета xpi2p): - подпись длиной 40 байт - открытый ключ длиной 172 символа base64 - NIST-800-57 рекомендует минимум (L=2048, N=224) - I2P использует более слабые (L=1024, N=160)\nРекомендация: Вместо этого используйте SU3 (формат подписанных обновлений I2P) с RSA-4096.\nРекомендации по разработке плагинов Основные лучшие практики Документация\nПредоставьте понятный README с инструкциями по установке Документируйте параметры конфигурации и значения по умолчанию Добавляйте журнал изменений к каждому релизу Укажите требуемые версии I2P/Java Оптимизация размера\nВключайте только необходимые файлы Никогда не включайте в пакет router JARs Разделяйте пакеты установки и обновления (библиотеки в lib/) Используйте сжатие Pack200 УСТАРЕЛО - используйте стандартный ZIP Конфигурация\nНикогда не изменяйте plugin.config во время выполнения Используйте отдельный файл конфигурации для настроек времени выполнения Задокументируйте требуемые настройки router (порты SAM, tunnels и т. д.) Уважайте существующую конфигурацию пользователя Использование ресурсов\nИзбегайте агрессивного использования пропускной способности по умолчанию Внедрите разумные ограничения на использование процессора Очищайте ресурсы при завершении работы Используйте демон-потоки там, где это уместно Тестирование\nПротестировать установку/обновление/удаление на всех платформах Протестировать обновления с предыдущей версии Проверить остановку/перезапуск веб‑приложения во время обновлений Протестировать с минимально поддерживаемой версией I2P Файловая система\nНикогда не записывайте в $I2P (может быть доступен только для чтения) Записывайте данные времени выполнения в $PLUGIN или $CONFIG Используйте I2PAppContext для определения расположения каталогов Не предполагайте расположение $CWD Совместимость\nНе дублируйте стандартные классы I2P Расширяйте классы при необходимости, не заменяйте Проверьте min-i2p-version, min-jetty-version в plugin.config Тестируйте со старыми версиями I2P, если вы их поддерживаете Обработка завершения работы\nНастройте корректные stopargs в clients.config Зарегистрируйте хуки завершения (shutdown hooks): I2PAppContext.addShutdownTask() Корректно обрабатывайте многократные вызовы запуска/остановки Установите всем потокам режим демона Безопасность\nПроверяйте весь внешний ввод Никогда не вызывайте System.exit() Уважайте конфиденциальность пользователей Соблюдайте безопасные практики программирования Лицензирование\nЧётко укажите лицензию плагина Соблюдайте лицензии включённых библиотек Включите обязательные упоминания авторства Предоставьте доступ к исходному коду, если это требуется Расширенные соображения Обработка часовых поясов: - Router устанавливает часовой пояс JVM на UTC - Фактический часовой пояс пользователя: I2PAppContext свойство i2p.systemTimeZone\nОбнаружение каталога:\n// Plugin directory String pluginDir = I2PAppContext.getGlobalContext() .getAppDir().getAbsolutePath() + \u0026#34;/plugins/\u0026#34; + pluginName; // Or use $PLUGIN variable in clients.config args Нумерация версий: - Используйте семантическое версионирование (major.minor.patch) - Добавьте номер сборки для тестирования (1.2.3-456) - Обеспечьте монотонное возрастание версий при обновлениях\nДоступ к классам Router: - Как правило, избегайте зависимостей от router.jar - Вместо этого используйте публичные API в i2p.jar - В будущих версиях I2P доступ к классам Router может быть ограничён\nПредотвращение сбоев JVM (историческое): - Исправлено в 0.7.13-3 - Корректно используйте загрузчики классов - Избегайте обновления JAR-файлов в запущенном плагине - При необходимости проектируйте с поддержкой перезапуска при обновлении\nПлагины eepsite Обзор Плагины могут предоставлять полноценные eepsites с собственными экземплярами Jetty и I2PTunnel.\nАрхитектура Не пытайтесь: - Устанавливать в существующий eepsite - Объединять с eepsite по умолчанию для router - Предполагать доступность только одного eepsite\nВместо этого: - Запустите новый экземпляр I2PTunnel (через CLI, интерфейс командной строки) - Запустите новый экземпляр Jetty - Настройте оба в clients.config\nПример структуры plugins/myeepsite/ ├── plugin.config ├── clients.config # Starts Jetty + I2PTunnel ├── eepsite/ │ ├── jetty.xml # Requires variable substitution │ ├── docroot/ │ ├── webapps/ │ └── logs/ └── lib/ └── [dependencies] Подстановка переменных в jetty.xml Используйте переменную $PLUGIN для путей:\n\u0026lt;Set name=\u0026#34;resourceBase\u0026#34;\u0026gt;$PLUGIN/eepsite/docroot\u0026lt;/Set\u0026gt; Router выполняет подстановку при запуске плагина.\nПримеры Эталонные реализации: - zzzot плагин - Торрент-трекер - pebble плагин - Платформа для блогов\nОба доступны на странице плагинов zzz (внутри I2P).\nИнтеграция с консолью Ссылки сводной панели Добавить кликабельную ссылку в панель сводки консоли router:\nconsoleLinkName=My Plugin consoleLinkURL=/myplugin/ consoleLinkTooltip=Open My Plugin Interface Локализованные версии:\nconsoleLinkName_de=Mein Plugin consoleLinkTooltip_de=Öffne Mein Plugin Schnittstelle Значки консоли Файл образа (начиная с 0.9.20):\nconsole-icon=/myicon.png Путь относительно consoleLinkURL, если указан (начиная с 0.9.53), иначе — относительно имени веб-приложения.\nВстроенный значок (начиная с версии 0.9.25):\nicon-code=iVBORw0KGgoAAAANSUhEUgAAA...Base64EncodedPNG... Сгенерировать с помощью:\nbase64 -w 0 icon-32x32.png Или Java:\njava -cp i2p.jar net.i2p.data.Base64 encode icon.png Требования: - 32x32 пикселей - формат PNG - в кодировке Base64 (без переносов строк)\nИнтернационализация Пакеты переводов Для базовых переводов I2P: - Поместите JAR-файлы в console/locale/ - Содержат ресурсные пакеты для существующих приложений I2P - Именование: messages_xx.properties (xx = код языка)\nДля переводов, специфичных для плагина: - Поместите в console/webapps/*.war - Или поместите в lib/*.jar - Используйте стандартный подход Java ResourceBundle\nЛокализованные строки в plugin.config description=My awesome plugin description_de=Mein tolles Plugin description_fr=Mon plugin génial description_es=Mi plugin increíble Поддерживаемые поля: - description_xx - consoleLinkName_xx - consoleLinkTooltip_xx\nПеревод темы консоли Темы в console/themes/ автоматически добавляются в путь поиска тем.\nПлагины, специфичные для платформы Подход с отдельными пакетами Используйте разные имена плагинов для каждой платформы:\n# Windows package name=myplugin-windows # Linux package name=myplugin-linux # macOS package name=myplugin-mac Подход с подстановкой переменных Единый plugin.config с переменными платформы:\nname=myplugin updateURL.su3=http://myplugin.i2p/downloads/myplugin-$OS-$ARCH.su3 В clients.config:\nclientApp.0.main=net.i2p.apps.ShellService clientApp.0.args=$PLUGIN/bin/myapp-$OS-$ARCH Определение ОС во время выполнения Подход в Java к условному выполнению:\nString os = System.getProperty(\u0026#34;os.name\u0026#34;).toLowerCase(); if (os.contains(\u0026#34;win\u0026#34;)) { // Windows-specific code } else if (os.contains(\u0026#34;nix\u0026#34;) || os.contains(\u0026#34;nux\u0026#34;)) { // Linux-specific code } else if (os.contains(\u0026#34;mac\u0026#34;)) { // macOS-specific code } Устранение неполадок Распространенные проблемы Плагин не запускается: 1. Проверьте совместимость с версией I2P (min-i2p-version) 2. Проверьте версию Java (min-java-version) 3. Проверьте журналы router на ошибки 4. Убедитесь, что все необходимые JAR-файлы есть в classpath (путь классов)\nВеб‑приложение недоступно: 1. Убедитесь, что webapps.config не отключает его 2. Проверьте совместимость версии Jetty (min-jetty-version) 3. Убедитесь, что web.xml присутствует (сканирование аннотаций не поддерживается) 4. Проверьте, нет ли конфликтующих имён веб‑приложений\nСбой обновления: 1. Убедитесь, что номер версии увеличен 2. Проверьте, что подпись соответствует ключу подписи 3. Убедитесь, что имя плагина соответствует установленной версии 4. Проверьте настройки update-only/install-only\nВнешняя программа не останавливается: 1. Используйте ShellService для автоматического управления жизненным циклом 2. Реализуйте корректную обработку stopargs 3. Проверьте очистку PID-файла 4. Убедитесь, что процесс завершён\nОтладочное логирование Включите отладочное логирование в router:\nlogger.record.net.i2p.router.web.ConfigPluginsHandler=DEBUG Проверьте журналы:\n~/.i2p/logs/log-router-0.txt Справочная информация Официальные спецификации Спецификация плагинов Формат конфигурации Спецификация обновлений Криптография История версий I2P Текущий релиз: - I2P 2.10.0 (8 сентября 2025 г.)\nОсновные релизы с 0.9.53: - 2.10.0 (сен 2025) - объявление о Java 17+ - 2.9.0 (июн 2025) - предупреждение о Java 17+ - 2.8.0 (окт 2024) - тестирование постквантовой криптографии - 2.6.0 (май 2024) - блокировка I2P поверх Tor - 2.4.0 (дек 2023) - улучшения безопасности NetDB - 2.2.0 (мар 2023) - контроль перегрузок - 2.1.0 (янв 2023) - улучшения сети - 2.0.0 (ноя 2022) - транспортный протокол SSU2 - 1.7.0/0.9.53 (фев 2022) - ShellService (служба оболочки), подстановка переменных - 0.9.15 (сен 2014) - представлен формат SU3\nНумерация версий: - серия 0.9.x: до версии 0.9.53 включительно - серия 2.x: начиная с 2.0.0 (введение SSU2)\nРесурсы для разработчиков Исходный код: - Основной репозиторий: https://i2pgit.org/I2P_Developers/i2p.i2p - Зеркало на GitHub: https://github.com/i2p/i2p.i2p Примеры плагинов: - zzzot (трекер BitTorrent) - pebble (блог-платформа) - i2p-bote (бессерверная электронная почта) - orchid (клиент Tor) - seedless (обмен пирами)\nИнструменты сборки: - makeplugin.sh - Генерация ключей и подписание - Находятся в репозитории i2p.scripts - Автоматизируют создание и проверку su3\nПоддержка сообщества Форумы: - I2P Forum - zzz.i2p (только внутри I2P)\nIRC/чат: - #i2p-dev на OFTC - I2P IRC внутри сети\nПриложение A: Полный пример файла plugin.config # Required fields name=example-plugin signer=developer@mail.i2p version=1.2.3 # Update configuration updateURL.su3=http://example.i2p/plugins/example-$OS-$ARCH.su3 min-i2p-version=2.0.0 min-java-version=17 # Display information date=1698796800000 author=Example Developer \u0026lt;developer@mail.i2p\u0026gt; websiteURL=http://example.i2p/ license=Apache-2.0 description=An example I2P plugin demonstrating best practices description_de=Ein Beispiel-I2P-Plugin zur Demonstration bewährter Praktiken description_es=Un plugin I2P de ejemplo que demuestra las mejores prácticas # Console integration consoleLinkName=Example Plugin consoleLinkName_de=Beispiel-Plugin consoleLinkURL=/example/ consoleLinkTooltip=Open the Example Plugin control panel consoleLinkTooltip_de=Öffne das Beispiel-Plugin-Kontrollfeld console-icon=/icon.png # Installation behavior dont-start-at-install=false router-restart-required=false # Platform requirements (informational) required-platform-OS=All platforms supported other-requirements=Requires 512MB free disk space Приложение B: Полный пример clients.config # Main service client (managed) clientApp.0.main=com.example.plugin.MainService clientApp.0.name=Example Plugin Main Service clientApp.0.delay=30 clientApp.0.args=$PLUGIN/config.properties --port=7656 clientApp.0.stopargs=shutdown clientApp.0.uninstallargs=cleanup clientApp.0.classpath=$PLUGIN/lib/example.jar,$I2P/lib/i2p.jar,$I2P/lib/mstreaming.jar # External program via ShellService clientApp.1.main=net.i2p.apps.ShellService clientApp.1.name=Example Native Helper clientApp.1.delay=35 clientApp.1.args=$PLUGIN/bin/helper-$OS-$ARCH --config $PLUGIN/helper.conf clientApp.1.classpath=$I2P/lib/i2p.jar # Jetty eepsite clientApp.2.main=net.i2p.jetty.JettyStart clientApp.2.name=Example Eepsite clientApp.2.delay=40 clientApp.2.args=$PLUGIN/eepsite/jetty.xml clientApp.2.stopargs=$PLUGIN/eepsite/jetty.xml stop clientApp.2.classpath=$PLUGIN/lib/example-web.jar,$I2P/lib/i2p.jar # I2PTunnel for eepsite clientApp.3.main=net.i2p.i2ptunnel.TunnelControllerGroup clientApp.3.name=Example Eepsite Tunnel clientApp.3.delay=45 clientApp.3.args=$PLUGIN/eepsite/i2ptunnel.config Приложение C: Полный пример файла webapps.config # Disable autostart for admin webapp webapps.example-admin.startOnLoad=false # Main webapp with classpath webapps.example.startOnLoad=true webapps.example.classpath=$PLUGIN/lib/example-core.jar,$PLUGIN/lib/commons-utils.jar,$I2P/lib/jstl.jar,$I2P/lib/standard.jar # Legacy support (pre-0.7.12-9) plugin.example.startOnLoad=true Приложение D: Контрольный список миграции (с 0.9.53 до 2.10.0) Необходимые изменения Удалить сжатие Pack200 из процесса сборки\nУдалить задачи pack200 из скриптов Ant/Maven/Gradle Переиздать существующие плагины без pack200 Проверить требования к версиям Java\nРассмотреть введение требования Java 11+ для новых возможностей Запланировать введение требования Java 17+ в I2P 2.11.0 Обновить min-java-version в plugin.config Обновить документацию\nУдалить упоминания Pack200 Обновить требования к версии Java Обновить упоминания версий I2P (0.9.x → 2.x) Рекомендуемые изменения Усилить криптографические подписи\nПерейти с XPI2P на SU3, если ещё не сделано Использовать ключи RSA-4096 для новых плагинов Используйте новые возможности (если используете 0.9.53+)\nИспользуйте переменные $OS / $ARCH для платформозависимых обновлений Используйте ShellService (служба оболочки) для внешних программ Используйте улучшенный classpath веб-приложения (работает с любым именем WAR-архива) Проверить совместимость\nПротестировать на I2P 2.10.0 Проверить с Java 8, 11, 17 Проверить на Windows, Linux, macOS Необязательные улучшения Реализовать корректный ServletContextListener (слушатель контекста сервлета) Добавить локализованные описания Добавить значок консоли Улучшить обработку завершения работы Добавить расширенное логирование Написать автоматические тесты ","description":"Правила упаковки .xpi2p / .su3 для плагинов I2P","id":"b25aafc3542216f9bbc2f124d1943fbc","section":"docs","title":"Формат пакета плагина","url":"/ru/docs/specs/plugin/"},{"categories":null,"content":"Фильтры доступа позволяют операторам серверов I2PTunnel разрешать, запрещать или ограничивать входящие соединения на основе исходного Destination (уникальный адрес узла в I2P) и недавней частоты подключений. Фильтр представляет собой обычный текстовый файл с правилами. Файл читается сверху вниз, и первое совпавшее правило применяется.\nИзменения в определении фильтра вступают в силу при перезапуске tunnel. Некоторые сборки могут повторно считывать файловые списки во время работы, но планируйте перезапуск, чтобы гарантировать применение изменений.\nФормат файла Одно правило на строку. Пустые строки игнорируются. # начинает комментарий, который продолжается до конца строки. Правила проверяются по порядку; используется первое совпадение. Пороговые значения Порог задает, сколько попыток соединения от одного Destination (адрес назначения в I2P) допускается в скользящем временном окне.\nЧисловой формат: N/S означает разрешить N подключений за S секунд. Пример: 15/5 позволяет до 15 подключений каждые 5 секунд. Попытка номер N+1 в течение этого окна будет отклонена. Ключевые слова: allow значит без ограничений. deny значит всегда отклонять. Синтаксис правил Правила имеют вид:\n\u0026lt;threshold\u0026gt; \u0026lt;scope\u0026gt; \u0026lt;target\u0026gt; Где:\n\u0026lt;threshold\u0026gt; — это N/S, allow или deny \u0026lt;scope\u0026gt; — один из default, explicit, file или record (см. ниже) \u0026lt;target\u0026gt; зависит от области действия Правило по умолчанию Применяется, когда не подходит ни одно другое правило. Допускается только одно правило по умолчанию. Если не задано, неизвестные Destinations (назначения) разрешены без ограничений.\n15/5 default allow default deny default Явное правило Указывает конкретный Destination (идентификатор назначения в I2P) по адресу Base32 (например, example1.b32.i2p) или по полному ключу.\n15/5 explicit example1.b32.i2p deny explicit example2.b32.i2p allow explicit example3.b32.i2p Правило на основе файла В качестве целей используются все назначения, перечисленные во внешнем файле. Каждая строка содержит одно назначение; допускаются комментарии # и пустые строки.\n15/5 file /var/i2p/throttled.txt deny file /var/i2p/blocked.txt allow file /var/i2p/trusted.txt Рабочее примечание: Некоторые реализации периодически перечитывают списки файлов. Если вы редактируете список, пока tunnel работает, ожидайте небольшой задержки, прежде чем изменения будут обнаружены. Перезапустите, чтобы применить изменения сразу.\nРекордер (плавное управление) Регистратор отслеживает попытки подключения и записывает Destinations (адреса назначения в I2P), которые превышают пороговое значение, в файл. Затем вы можете сослаться на этот файл в правиле file, чтобы применять ограничения или блокировки к последующим попыткам.\n# Start permissive allow default # Record Destinations exceeding 30 connections in 5 seconds 30/5 record /var/i2p/aggressive.txt # Apply throttling to recorded Destinations 15/5 file /var/i2p/aggressive.txt Перед тем как полагаться на функцию записи, убедитесь, что ваша сборка её поддерживает. Используйте списки file для гарантированного поведения.\nПорядок вычисления Сначала ставьте конкретные правила, затем — общие. Типичный шаблон:\nЯвные разрешения для доверенных пиров Явные запреты для известных нарушителей Файловые списки разрешения/запрета Регистраторы для постепенного ограничения скорости Правило по умолчанию на все случаи Полный пример # Moderate limits by default 30/10 default # Always allow trusted peers allow explicit friend1.b32.i2p allow explicit friend2.b32.i2p # Block known bad actors deny file /var/i2p/blocklist.txt # Throttle aggressive sources 15/5 file /var/i2p/throttle.txt # Automatically populate the throttle list 60/5 record /var/i2p/throttle.txt Примечания по реализации Фильтр доступа работает на уровне tunnel, до обработки приложением, поэтому нежелательный трафик может быть отклонён на ранней стадии. Поместите файл фильтра в каталог конфигурации I2PTunnel и перезапустите tunnel, чтобы применить изменения. Разделяйте файловые списки между несколькими tunnels, если вам нужна единая политика для всех сервисов. ","description":"Синтаксис файлов фильтров контроля доступа для tunnel","id":"d8b5745531fca07ea47765403a9a4d0c","section":"docs","title":"Формат фильтра доступа","url":"/ru/docs/specs/filter-format/"},{"categories":null,"content":"Обзор ПРИМЕЧАНИЕ: УСТАРЕЛО - Теперь мы поддерживаем три формата, в порядке предпочтения:\nMaxmind geoip2 (GeoLite2-Country.mmdb) поставляется в комплекте со всеми установками, за исключением пакетов Debian и Android Maxmind geoip1 (GeoIP.dat) в пакете Debian geoip-database Формат Tor для IPv4 (geoip.txt) и пользовательский формат для IPv6 (geoipv6.dat.gz), описанные ниже, по-прежнему поддерживаются, но не используются. Эта страница описывает формат различных файлов GeoIP, используемых router для определения страны по IP-адресу.\nФормат названия страны (countries.txt) Этот формат легко можно сгенерировать из файлов данных, доступных из многочисленных открытых источников. Например:\n$ wget http://geolite.maxmind.com/download/geoip/database/GeoIPCountryCSV.zip $ unzip GeoIPCountryCSV.zip $ cut -d, -f5,6 \u0026lt; GeoIPCountryWhois.csv | sed \u0026#39;s/\u0026#34;//g\u0026#39; | sort | uniq \u0026gt; countries.txt Спецификации формата:\nКодировка — UTF-8 \u0026lsquo;#\u0026rsquo; в первом столбце обозначает строку комментария Строки записей имеют вид CountryCode,CountryName CountryCode — это двухбуквенный код ISO в верхнем регистре CountryName указывается на английском языке Формат IPv4 (geoip.txt) Этот формат заимствован у Tor и легко генерируется из файлов данных, доступных из многих публичных источников. Например:\n$ wget http://geolite.maxmind.com/download/geoip/database/GeoIPCountryCSV.zip $ unzip GeoIPCountryCSV.zip $ cut -d, -f3-5 \u0026lt; GeoIPCountryWhois.csv | sed \u0026#39;s/\u0026#34;//g\u0026#39; \u0026gt; geoip.txt $ cut -d, -f5,6 \u0026lt; GeoIPCountryWhois.csv | sed \u0026#39;s/\u0026#34;//g\u0026#39; | sort | uniq \u0026gt; countries.txt Спецификации формата:\nКодировка — ASCII \u0026lsquo;#\u0026rsquo; в первом столбце обозначает строку комментария Строки записей имеют вид FromIP,ToIP,CountryCode FromIP и ToIP — беззнаковые целочисленные представления 4-байтового IP CountryCode — это двухбуквенный код ISO в верхнем регистре Строки записей должны быть отсортированы по числовому значению FromIP Формат IPv6 (geoipv6.dat.gz) Это сжатый двоичный формат, предназначенный для I2P. Файл сжат с помощью gzip. Формат после распаковки:\nBytes 0-9: Magic number \u0026#34;I2PGeoIPv6\u0026#34; Bytes 10-11: Version (0x0001) Bytes 12-15 Options (0x00000000) (future use) Bytes 16-23: Creation date (ms since 1970-01-01) Bytes 24-xx: Optional comment (UTF-8) terminated by zero byte Bytes xx-255: null padding Bytes 256-: 18 byte records: 8 byte from (/64) 8 byte to (/64) 2 byte ISO country code LOWER case (ASCII) Примечания:\nДанные должны быть отсортированы (знаковый long в формате дополнительного кода), без перекрытий. Порядок такой: 80000000 \u0026hellip; FFFFFFFF 00000000 \u0026hellip; 7FFFFFFF. Класс GeoIPv6.java содержит программу для генерации этого формата из публичных источников, таких как данные Maxmind GeoLite. Поиск GeoIP по IPv6 поддерживается начиная с релиза 0.9.8. ","description":"Спецификации устаревшего формата файла GeoIP для определения страны по IP-адресу","id":"b5f34a4f13210a8caf4c4d0b5e62a828","section":"docs","title":"Форматы файлов GeoIP","url":"/ru/docs/legacy/%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%82%D1%8B-%D1%84%D0%B0%D0%B9%D0%BB%D0%BE%D0%B2-geoip/"},{"categories":null,"content":"О хостах reseed (серверы начальной загрузки сети) Новым router нужно несколько пиров, чтобы присоединиться к сети I2P. Ресид-серверы предоставляют этот начальный набор через зашифрованные загрузки по HTTPS. Каждый ресид-пакет подписан сервером, что предотвращает подмену со стороны неаутентифицированных сторон. Уже работающие router могут время от времени выполнять ресид, если их набор пиров устаревает.\nПроцесс начальной инициализации сети Когда I2P router запускается впервые или находился офлайн длительное время, ему требуются данные RouterInfo (сведения о router) для подключения к сети. Поскольку у router нет существующих пиров, он не может получить эту информацию внутри самой сети I2P. Механизм reseed (получение стартовых данных из внешних источников) решает эту проблему начальной загрузки, предоставляя файлы RouterInfo с доверенных внешних HTTPS‑серверов.\nПроцесс reseed (получение начального набора данных сети) доставляет 75–100 файлов RouterInfo в одном криптографически подписанном пакете. Это гарантирует, что новые routers смогут быстро установить соединения, не подвергая их атакам типа «человек посередине», которые могли бы изолировать их в отдельные недоверенные сегменты сети.\nТекущее состояние сети По состоянию на октябрь 2025 года сеть I2P работает с версией router 2.10.0 (версия API 0.9.67). Протокол reseed (механизм начальной загрузки сети), представленный в версии 0.9.14, остаётся стабильным и неизменным в своей основной функциональности. Сеть поддерживает несколько независимых reseed servers, распределённых по всему миру, чтобы обеспечить доступность и устойчивость к цензуре.\nСервис checki2p отслеживает все I2P reseed-серверы (серверы начальной загрузки пиров) каждые 4 часа, предоставляя проверки статуса и метрики доступности в реальном времени для reseed-инфраструктуры.\nСпецификация формата файла SU3 Формат файла SU3 является основой протокола reseed I2P (первичной загрузки адресной базы), обеспечивая криптографически подписанную доставку контента. Понимание этого формата необходимо для реализации серверов и клиентов reseed.\nСтруктура файлов Формат SU3 состоит из трех основных компонентов: заголовка (40+ байт), содержимого (переменной длины) и подписи (длина указана в заголовке).\nФормат заголовка (минимум — байты 0–39) Byte Range Field Description 0-5Magic NumberASCII string \"I2Psu3\" (0x493250737533) 6ReservedUnused, must be 0x00 7File Format VersionCurrent version: 0x00 8-9Signature TypeBig-endian 16-bit integer. Type 6 = RSA-4096-SHA512 (reseed standard) 10-11Signature LengthBig-endian 16-bit integer. 512 bytes (0x0200) for RSA-4096 12ReservedUnused, must be 0x00 13Version LengthMinimum 16 bytes (0x10) for compatibility 14ReservedUnused, must be 0x00 15Signer ID LengthLength of UTF-8 signer identifier string 16-23Content LengthBig-endian 64-bit integer, length of content in bytes 24ReservedUnused, must be 0x00 25File Type0x00 = ZIP, 0x01 = XML, 0x02 = HTML, 0x03 = XML.GZ, 0x04 = TXT.GZ, 0x05 = DMG, 0x06 = EXE 26ReservedUnused, must be 0x00 27Content Type0x00 = unknown, 0x01 = router update, 0x02 = plugin, 0x03 = reseed, 0x04 = news, 0x05 = blocklist 28-39PaddingUnused, must be all zeros 40-55Version StringASCII version string, padded with zeros (minimum 16 bytes) 56-...Signer IDUTF-8 encoded signer identifier (e.g., \"user@mail.i2p\") ### Параметры SU3, специфичные для Reseed (сервер начальной раздачи узлов) Для reseed bundles (пакетов для начальной загрузки сети) файл SU3 должен иметь следующие характеристики:\nИмя файла: Должно быть точно i2pseeds.su3 Тип содержимого (байт 27): 0x03 (RESEED) Тип файла (байт 25): 0x00 (ZIP) Тип подписи (байты 8-9): 0x0006 (RSA-4096-SHA512) Строка версии: метка времени Unix в ASCII (секунды с начала эпохи, формат date +%s) Идентификатор подписанта: идентификатор в стиле адреса электронной почты, совпадающий с CN сертификата X.509 Параметр запроса идентификатора сети Начиная с версии 0.9.42, routers добавляют ?netid=2 к reseed-запросам. Это предотвращает соединения между сетями, поскольку тестовые сети используют другие идентификаторы сети. Текущая рабочая сеть I2P использует идентификатор сети 2.\nПример запроса: https://reseed.example.com/i2pseeds.su3?netid=2\nСтруктура содержимого ZIP-архива Раздел содержимого (после заголовка, перед подписью) содержит стандартный ZIP-архив со следующими требованиями:\nСжатие: Стандартное сжатие ZIP (DEFLATE) Количество файлов: Обычно 75–100 файлов RouterInfo (метаданные о router) Структура каталога: Все файлы должны находиться на верхнем уровне (без подкаталогов) Именование файлов: routerInfo-{44-character-base64-hash}.dat Алфавит Base64: Необходимо использовать модифицированный алфавит Base64 I2P Алфавит I2P base64 отличается от стандартного base64 использованием - и ~ вместо + и /, чтобы обеспечить совместимость с файловой системой и URL.\nКриптографическая подпись Подпись покрывает весь файл от байта 0 до конца раздела содержимого. Сама подпись добавляется после содержимого.\nАлгоритм подписи (RSA-4096-SHA512) Вычислите хэш SHA-512 для данных с 0-го байта до конца содержимого Подпишите хэш с помощью «raw» RSA (без дополнительного хеширования/форматирования; NONEwithRSA в терминологии Java) При необходимости дополните подпись ведущими нулями до 512 байт Добавьте 512-байтовую подпись в конец файла Процесс проверки подписи Клиенты должны:\nПрочитать байты 0-11, чтобы определить тип и длину подписи Прочитать весь заголовок, чтобы определить границы содержимого Передавать содержимое потоком, одновременно вычисляя хэш SHA-512 Извлечь подпись с конца файла Проверить подпись с использованием открытого ключа RSA-4096 подписанта Отклонить файл, если проверка подписи не удалась Модель доверия сертификатов Ключи подписанта reseed распространяются в виде самоподписанных сертификатов X.509 с ключами RSA-4096. Эти сертификаты входят в состав пакетов I2P router в каталоге certificates/reseed/.\nФормат сертификата: - Тип ключа: RSA-4096 - Подпись: Самоподписанная - Subject CN: Должно совпадать с Signer ID (идентификатор подписанта) в заголовке SU3 - Сроки действия: Клиенты должны обеспечивать соблюдение сроков действия сертификата\nЗапуск Reseed-сервера Эксплуатация reseed-сервиса (службы начальной загрузки сети для новых routers) требует тщательного учета требований безопасности, надежности и разнообразия сети. Большее число независимых reseed-хостов повышает устойчивость и усложняет злоумышленникам или цензорам блокирование присоединения новых routers.\nТехнические требования Технические характеристики сервера Операционная система: Unix/Linux (Ubuntu, Debian, FreeBSD протестированы и рекомендуются) Подключение: требуется статический IPv4-адрес, IPv6 рекомендуется, но необязателен Процессор: минимум 2 ядра ОЗУ: минимум 2 ГБ Трафик: примерно 15 ГБ в месяц Время работы: требуется режим 24/7 I2P Router: корректно настроенный I2P router, работающий постоянно Требования к программному обеспечению Java: JDK 8 или новее (Java 17+ станет обязательной начиная с I2P 2.11.0) Веб-сервер: nginx или Apache с поддержкой обратного прокси (Lighttpd больше не поддерживается из-за ограничений заголовка X-Forwarded-For) TLS/SSL: Действительный сертификат TLS (Let\u0026rsquo;s Encrypt, самоподписанный или коммерческий УЦ) Защита от DDoS: fail2ban или аналог (обязательно, не опционально) Reseed Tools (ресид — начальная загрузка данных сети): официальные reseed-tools с https://i2pgit.org/idk/reseed-tools Требования безопасности Настройка HTTPS/TLS Протокол: только HTTPS, без резервного перехода на HTTP Версия TLS: минимум TLS 1.2 Наборы шифров: должны поддерживаться сильные наборы шифров, совместимые с Java 8+ CN/SAN сертификата: должны совпадать с именем хоста в обслуживаемом URL Тип сертификата: может быть самоподписанным при согласовании с командой разработки или выданным признанным УЦ Управление сертификатами Сертификаты подписи SU3 (формат пакетов обновления I2P) и сертификаты TLS предназначены для разных целей:\nСертификат TLS (certificates/ssl/): Обеспечивает защищённый транспорт по HTTPS Сертификат подписи SU3 (certificates/reseed/): Подписывает пакеты reseed (для начальной инициализации сети) Оба сертификата должны быть предоставлены координатору reseed (начальной загрузки списка узлов) (zzz@mail.i2p ) для включения в пакеты router.\nЗащита от DDoS-атак и скрейпинга Reseed servers (серверы начальной загрузки I2P) сталкиваются с периодическими атаками со стороны ошибочных реализаций, ботнетов и злоумышленников, пытающихся массово выгружать данные из сетевой базы данных. Меры защиты включают:\nfail2ban: Требуется для ограничения частоты запросов и смягчения атак Bundle Diversity: Выдавать разные наборы RouterInfo (информация о router) разным запрашивающим Bundle Consistency: Выдавать тот же набор при повторных запросах с одного и того же IP в пределах настраиваемого временного окна Ограничения на логирование IP: Не публиковать логи или IP-адреса (требование политики конфиденциальности) Методы реализации Способ 1: Официальные reseed-tools (Рекомендуется) Каноническая реализация, поддерживаемая проектом I2P. Репозиторий: https://i2pgit.org/idk/reseed-tools Установка:\n# Install dependencies sudo apt-get install golang git # Clone repository git clone https://i2pgit.org/idk/reseed-tools.git cd reseed-tools # Build make # Generate keys and start server (first run) ./reseed-tools reseed \\ --signer=your-email@mail.i2p \\ --netdb=/path/to/i2p/netDb \\ --tlsHost=your-domain.tld \\ --port=8443 При первом запуске утилита создаст: - your-email@mail.i2p.crt (сертификат для подписи SU3) - your-email@mail.i2p.pem (закрытый ключ для подписи SU3) - your-email@mail.i2p.crl (список отзыва сертификатов) - файлы сертификата и ключа TLS\nВозможности: - Автоматическая генерация пакетов SU3 (350 вариантов, по 77 RouterInfo (метаданные router в I2P) в каждом) - Встроенный HTTPS-сервер - Перестроение кэша каждые 9 часов через cron - Поддержка заголовка X-Forwarded-For с флагом --trustProxy - Совместимо с конфигурациями обратного прокси\nРазвертывание в продакшн-среде:\n# Create systemd service cat \u0026gt; /etc/systemd/system/i2p-reseed.service \u0026lt;\u0026lt; EOF [Unit] Description=I2P Reseed Server After=network.target [Service] Type=simple User=i2p-reseed WorkingDirectory=/opt/i2p-reseed ExecStart=/opt/i2p-reseed/reseed-tools reseed \\ --signer=your-email@mail.i2p \\ --netdb=/var/lib/i2p/netDb \\ --port=8443 \\ --ip=127.0.0.1 \\ --trustProxy Restart=always [Install] WantedBy=multi-user.target EOF systemctl enable i2p-reseed systemctl start i2p-reseed Метод 2: Реализация на Python (pyseeder) Альтернативная реализация проекта PurpleI2P: https://github.com/PurpleI2P/pyseeder pip install pyseeder # Generate SU3 file echo \u0026#34;your_password\u0026#34; | pyseeder reseed \\ --netdb /path/to/netDb \\ --private-key priv_key.pem \\ --outfile i2pseeds.su3 \\ --signer-id user@mail.i2p # Serve via built-in server pyseeder serve \\ --port 8443 \\ --host 0.0.0.0 \\ --private-key priv_key.pem \\ --cert user_at_mail.i2p.crt \\ --file i2pseeds.su3 Метод 3: Развертывание с помощью Docker Для контейнеризованных окружений существует несколько реализаций, готовых для работы в Docker:\nDivaExchange i2p-reseed: https://github.com/diva-exchange/i2p-reseed RTradeLtd/i2p-tools-1: Добавляет onion‑сервис Tor и поддержку IPFS Настройка обратного прокси-сервера Конфигурация nginx upstream i2p_reseed { server 127.0.0.1:8443; } server { listen 443 ssl http2; server_name reseed.example.com; ssl_certificate /path/to/tls-cert.crt; ssl_certificate_key /path/to/tls-key.key; ssl_protocols TLSv1.2 TLSv1.3; ssl_ciphers HIGH:!aNULL:!MD5; location / { proxy_pass http://i2p_reseed; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $remote_addr; proxy_set_header Host $host; } } Конфигурация Apache \u0026lt;VirtualHost *:443\u0026gt; ServerName reseed.example.com SSLEngine on SSLCertificateFile /path/to/tls-cert.crt SSLCertificateKeyFile /path/to/tls-key.key SSLProtocol all -SSLv2 -SSLv3 -TLSv1 -TLSv1.1 ProxyRequests Off \u0026lt;Proxy *\u0026gt; Order deny,allow Allow from all \u0026lt;/Proxy\u0026gt; ProxyPass / http://127.0.0.1:8443/ ProxyPassReverse / http://127.0.0.1:8443/ \u0026lt;/VirtualHost\u0026gt; Регистрация и координация Чтобы включить ваш reseed server (сервер начальной загрузки) в официальный пакет I2P:\nЗавершите настройку и тестирование Отправьте оба сертификата (для подписания SU3 и TLS) координатору reseed (первичной загрузки узлов) Контакты: zzz@mail.i2p или zzz@i2pmail.org Присоединитесь к #i2p-dev в IRC2P для координации с другими операторами Лучшие операционные практики Мониторинг и логирование Включить комбинированный формат журналов Apache/nginx для статистики Реализовать ротацию журналов (журналы быстро разрастаются) Отслеживать успешность генерации bundle (пакета) и время пересборки Отслеживать использование пропускной способности и паттерны запросов Никогда не публиковать IP-адреса или подробные журналы доступа График технического обслуживания Каждые 9 часов: Пересобрать кэш пакетов SU3 (автоматизировано через cron) Еженедельно: Просматривать журналы на предмет шаблонов атак Ежемесячно: Обновлять I2P router и reseed-tools (инструменты для начальной загрузки списка пиров) По мере необходимости: Продлевать TLS-сертификаты (автоматизировать с помощью Let\u0026rsquo;s Encrypt) Выбор порта По умолчанию: 8443 (рекомендуется) Альтернатива: любой порт в диапазоне 1024-49151 Порт 443: требует прав root или проброса портов (рекомендуется перенаправление через iptables) Пример проброса портов:\niptables -A PREROUTING -t nat -p tcp --dport 443 -j REDIRECT --to-port 8443 Альтернативные методы Reseed (первоначальная загрузка данных для netDb) Другие варианты начальной инициализации помогают пользователям, находящимся в сетях с ограничениями:\nReseed (первичная загрузка узлов сети) из файла Начиная с версии 0.9.16, файловый ресидинг позволяет пользователям вручную загружать пакеты с RouterInfo (запись о router в netDb). Этот метод особенно полезен для пользователей в регионах с цензурой, где HTTPS-ресид-серверы заблокированы.\nПроцесс: 1. Доверенный контакт создает пакет SU3, используя свой router 2. Пакет передается по электронной почте, через USB-накопитель или другим внеполосным каналом связи 3. Пользователь помещает i2pseeds.su3 в каталог конфигурации I2P 4. При перезапуске router автоматически обнаруживает и обрабатывает пакет\nДокументация: /blog/2020/06/07/help-your-friends-join-i2p-by-sharing-reseed-bundles/\nСценарии использования: - Пользователи за национальными брандмауэрами, блокирующими reseed servers (ресид-серверы) - Изолированные сети, которым требуется ручной bootstrap (ручная инициализация) - Среды тестирования и разработки\nРесидинг через Cloudflare Маршрутизация reseed-трафика (процесс начальной загрузки списка узлов I2P) через CDN Cloudflare предоставляет операторам в регионах с жесткой цензурой ряд преимуществ.\nПреимущества: - IP-адрес origin-сервера (исходного сервера) скрыт от клиентов - Защита от DDoS через инфраструктуру Cloudflare - Географическое распределение нагрузки за счет edge caching (кеширования на периферии сети) - Улучшенная производительность для клиентов по всему миру\nТребования к реализации: - --trustProxy флаг включён в reseed-tools - Прокси Cloudflare включён для записи DNS - Корректная обработка заголовка X-Forwarded-For\nВажные замечания: - Действуют ограничения Cloudflare на порты (нужно использовать поддерживаемые порты) - Для обеспечения консистентности bundle (набор) для одного и того же клиента требуется поддержка X-Forwarded-For - Конфигурация SSL/TLS управляется Cloudflare\nДокументация: https://homepage.np-tokumei.net/post/notes-i2p-reseed-over-cloudflare/ Стратегии устойчивости к цензуре Исследование Нгуен Фонга Хоанга (USENIX FOCI 2019) выявляет дополнительные методы начальной загрузки для сетей, подвергающихся цензуре:\nПоставщики облачного хранилища Box, Dropbox, Google Drive, OneDrive: Размещать файлы SU3 (формат файла обновлений I2P) через публичные ссылки Преимущество: Сложно заблокировать, не нарушив работу легитимных сервисов Ограничение: Требует ручного распространения URL среди пользователей Распространение через IPFS Размещать пакеты reseed (начальная загрузка списка узлов I2P) в InterPlanetary File System (IPFS) Хранилище с адресацией по содержимому предотвращает подмену данных Устойчиво к попыткам принудительного удаления Скрытые сервисы Tor Reseed servers (серверы начальной загрузки) доступны через адреса .onion Устойчиво к блокировке по IP-адресам Требуется клиент Tor на системе пользователя Исследовательская документация: https://homepage.np-tokumei.net/post/notes-censorship-resistant-i2p-reseeding/ Страны, где известно о блокировке I2P По состоянию на 2025 год подтверждено, что следующие страны блокируют ресид-серверы I2P: - Китай - Иран - Оман - Катар - Кувейт\nПользователям в этих регионах следует использовать альтернативные методы bootstrap (первичной инициализации сети) или устойчивые к цензуре стратегии reseeding (получения первоначальных пиров).\nПодробности протокола для реализаторов Спецификация запроса Reseed (первичная загрузка списка узлов) Поведение клиента Выбор сервера: Router хранит жестко заданный список URL reseed (первичная загрузка данных о сети) Случайный выбор: Клиент случайным образом выбирает сервер из доступного списка Формат запроса: GET /i2pseeds.su3?netid=2 HTTP/1.1 User-Agent: Должен имитировать распространенные браузеры (например, \u0026ldquo;Wget/1.11.4\u0026rdquo;) Логика повторных попыток: Если запрос SU3 завершается неудачей, перейти к разбору индексной страницы Проверка сертификата: Проверить сертификат TLS по системному хранилищу доверенных сертификатов Проверка подписи SU3: Проверить подпись по известным сертификатам reseed Поведение сервера Выбор набора: Выбрать псевдослучайное подмножество RouterInfos из netDb Отслеживание клиентов: Идентифицировать запросы по исходному IP-адресу (с учетом X-Forwarded-For) Согласованность набора: Возвращать один и тот же набор для повторных запросов в пределах временного окна (обычно 8–12 часов) Разнообразие наборов: Возвращать разные наборы разным клиентам для повышения разнообразия сети Content-Type: application/octet-stream или application/x-i2p-reseed Формат файла RouterInfo Каждый файл .dat в пакете reseed содержит структуру RouterInfo:\nИменование файлов: routerInfo-{base64-hash}.dat - Хэш состоит из 44 символов, используется алфавит I2P base64 - Пример: routerInfo-ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmn.dat\nСодержимое файла: - RouterIdentity (идентификатор router; хэш router, ключ шифрования, ключ подписи) - Временная метка публикации - Адреса router (IP, порт, тип транспорта) - Возможности и параметры router - Подпись, охватывающая все приведённые выше данные\nТребования к разнообразию сети Чтобы предотвратить централизацию сети и обеспечить обнаружение Sybil-атак (атак Сивиллы):\nНикаких полных дампов NetDb: Никогда не выдавать все RouterInfos одному клиенту Случайная выборка: Каждый пакет содержит различное подмножество доступных пиров Минимальный размер пакета: 75 RouterInfos (увеличено с изначальных 50) Максимальный размер пакета: 100 RouterInfos Актуальность: RouterInfos должны быть свежими (в течение 24 часов после генерации) Особенности IPv6 Текущий статус (2025): - Несколько ресид-серверов не отвечают по IPv6 - Клиентам следует предпочитать или принудительно использовать IPv4 ради надежности - Поддержка IPv6 рекомендуется для новых развертываний, но не критична\nПримечание по реализации: При настройке серверов с двойным стеком убедитесь, что оба адреса прослушивания IPv4 и IPv6 работают корректно, или отключите IPv6, если обеспечить его корректную поддержку невозможно.\nСоображения безопасности Модель угроз Протокол reseed защищает от:\nАтаки «человек посередине»: Подписи RSA-4096 предотвращают подмену пакетов Разделение сети: Несколько независимых reseed-серверов исключают единую точку контроля Атаки Сивиллы: Разнообразие пакетов ограничивает возможности атакующего изолировать пользователей Цензура: Несколько серверов и альтернативные методы обеспечивают избыточность Протокол reseed (первичная загрузка списка узлов) НЕ защищает от:\nСкомпрометированные reseed-серверы (процедура начальной загрузки сети): если атакующий контролирует закрытые ключи сертификатов reseed Полная блокировка сети: если в регионе заблокированы все методы reseed Долгосрочное наблюдение: запросы reseed раскрывают IP-адрес, пытающийся присоединиться к I2P Управление сертификатами Безопасность приватных ключей: - Храните ключи подписи SU3 офлайн, когда они не используются - Используйте надежные пароли для шифрования ключей - Поддерживайте защищенные резервные копии ключей и сертификатов - Рассмотрите hardware security modules (HSMs; аппаратные модули безопасности) для критически важных развертываний\nОтзыв сертификатов: - Списки отзыва сертификатов (CRLs) распространяются через новостную ленту - Скомпрометированные сертификаты могут быть отозваны координатором - Routers автоматически обновляют CRLs вместе с обновлениями ПО\nСмягчение атак Защита от DDoS: - правила fail2ban при чрезмерном количестве запросов - ограничение частоты запросов на уровне веб-сервера - лимиты соединений на один IP-адрес - Cloudflare или аналогичный CDN в качестве дополнительного слоя защиты\nПредотвращение скрейпинга: - Разные пакеты для каждого запрашивающего IP-адреса - Кэширование пакетов по времени для каждого IP-адреса - Логирование шаблонов, указывающих на попытки скрейпинга - Координация с другими операторами по обнаруженным атакам\nТестирование и валидация Тестирование вашего Reseed‑сервера (сервер начальной загрузки сети I2P) Метод 1: Чистая установка Router Установите I2P на чистую систему Добавьте свой URL для reseed (процедура начальной загрузки узлов сети) в конфигурацию Удалите или отключите другие URL для reseed Запустите router и следите за журналами на предмет успешного reseed Проверьте подключение к сети в течение 5–10 минут Ожидаемый вывод журнала:\nReseed got 77 router infos from https://your-reseed.example.com/i2pseeds.su3?netid=2 with 0 errors Reseed complete, 77 received Метод 2: Ручная проверка SU3 # Download bundle curl -k -A \u0026#34;Wget/1.11.4\u0026#34; https://your-reseed.example.com/i2pseeds.su3 \u0026gt; test.su3 # Verify it\u0026#39;s a valid SU3 file hexdump -C test.su3 | head -n 3 # Should show: 49 32 50 73 75 33 (I2Psu3) # Extract content (requires su3 tools) java -cp /path/to/i2p.jar net.i2p.crypto.SU3File verify test.su3 your-cert.crt # Unzip content # (Extract content section, skip header+signature, then unzip) Метод 3: мониторинг checki2p Сервис по адресу https://checki2p.com/reseed выполняет автоматические проверки каждые 4 часа всех зарегистрированных reseed-серверов I2P (серверы начальной загрузки). Это обеспечивает:\nМониторинг доступности Метрики времени отклика Проверка сертификата TLS Проверка подписи SU3 Исторические данные о времени безотказной работы Как только ваш reseed (сервер начальной раздачи данных о маршрутизаторах I2P) будет зарегистрирован в проекте I2P, он автоматически появится на checki2p в течение 24 часов.\nУстранение распространённых неполадок Проблема: \u0026ldquo;Unable to read signing key\u0026rdquo; при первом запуске - Решение: Это ожидаемо. Ответьте \u0026lsquo;y\u0026rsquo;, чтобы сгенерировать новые ключи.\nПроблема: Router не удаётся проверить подпись - Причина: Сертификат отсутствует в хранилище доверенных сертификатов router - Решение: Поместите сертификат в каталог ~/.i2p/certificates/reseed/\nПроблема: Один и тот же бандл выдаётся разным клиентам - Причина: заголовок X-Forwarded-For передаётся некорректно - Решение: включите --trustProxy и настройте заголовки обратного прокси\nПроблема: ошибки «Connection refused» - Причина: порт недоступен из Интернета - Решение: проверьте правила брандмауэра, убедитесь в корректной настройке проброса портов\nПроблема: Высокая загрузка процессора при пересборке бандла - Причина: Нормальное поведение при генерации 350+ вариантов SU3 (формат подписанных обновлений I2P) - Решение: Обеспечьте достаточные ресурсы процессора, рассмотрите снижение частоты пересборки\nСправочная информация Официальная документация Руководство для участников Reseed (сервер начальной загрузки сети I2P): /guides/creating-and-running-an-i2p-reseed-server/ Требования политики Reseed: /guides/reseed-policy/ Спецификация SU3: /docs/specs/updates/ Репозиторий инструментов Reseed: https://i2pgit.org/idk/reseed-tools Документация по инструментам Reseed: https://eyedeekay.github.io/reseed-tools/ Альтернативные реализации PurpleI2P pyseeder: https://github.com/PurpleI2P/pyseeder DivaExchange i2p-reseed: https://github.com/diva-exchange/i2p-reseed RTradeLtd i2p-tools-1: https://github.com/RTradeLtd/i2p-tools-1 Python WSGI reseeder (сервер начальной загрузки узлов): https://github.com/torbjo/i2p-reseeder Ресурсы сообщества Форум I2P: https://i2pforum.net/ Репозиторий Gitea: https://i2pgit.org/I2P_Developers/i2p.i2p IRC: #i2p-dev на IRC2P Мониторинг статуса: https://checki2p.com/reseed История версий 0.9.14 (2014): Введён формат SU3 для reseed (первичная загрузка пиров) 0.9.16 (2014): Добавлен reseeding на основе файлов 0.9.42 (2019): Параметр запроса Network ID стал обязательным 2.0.0 (2022): Введён транспортный протокол SSU2 2.4.0 (2024): Изоляция NetDB и улучшения безопасности 2.6.0 (2024): Подключения I2P-over-Tor заблокированы 2.10.0 (2025): Текущий стабильный релиз (по состоянию на сентябрь 2025) Справочник по типам подписей Type Code Algorithm Key Size Signature Size Hash DSA-SHA10DSA1024-bit40 bytesSHA-1 ECDSA-SHA256-P2561ECDSAP-25664 bytesSHA-256 ECDSA-SHA384-P3842ECDSAP-38496 bytesSHA-384 ECDSA-SHA512-P5213ECDSAP-521132 bytesSHA-512 RSA-SHA256-20484RSA2048-bit256 bytesSHA-256 RSA-SHA384-30725RSA3072-bit384 bytesSHA-384 RSA-SHA512-40966RSA4096-bit512 bytesSHA-512 EdDSA-SHA512-Ed255197EdDSAEd2551964 bytesSHA-512 **Стандарт Reseed**: Тип 6 (RSA-SHA512-4096) требуется для пакетов reseed (первичная загрузка). Благодарность Спасибо всем операторам reseed (сервер начальной загрузки узлов сети) за поддержание доступности и устойчивости сети. Особая признательность следующим участникам и проектам:\nzzz: Многолетний разработчик I2P и координатор reseed (серверов начальной загрузки сети I2P) idk: Текущий мейнтейнер reseed-tools и менеджер релизов Nguyen Phong Hoang: Исследования стратегий reseeding, устойчивых к цензуре PurpleI2P Team: Альтернативные реализации I2P и инструменты checki2p: Автоматический сервис мониторинга инфраструктуры reseed Децентрализованная инфраструктура reseed (механизм первоначального получения списка узлов сети) сети I2P является результатом совместных усилий десятков операторов по всему миру, гарантируя, что новые пользователи всегда могут найти способ присоединиться к сети независимо от локальной цензуры или технических барьеров.\n","description":"Эксплуатация служб ресида и альтернативные методы начальной инициализации","id":"02dba83ad9e38e1355d624c0d4fa28aa","section":"docs","title":"Хосты Reseed (серверы начальной загрузки)","url":"/ru/docs/misc/reseed/"},{"categories":null,"content":"Справка I2P Router На каких системах будет работать I2P? I2P написан на языке программирования Java. Он был протестирован на Windows, Linux, FreeBSD и OSX. Также доступна версия для Android.\nЧто касается использования памяти, I2P по умолчанию настроен на использование 128 МБ оперативной памяти. Этого достаточно для веб-серфинга и использования IRC. Однако другие виды активности могут требовать большего выделения памяти. Например, если вы хотите запустить router с высокой пропускной способностью, участвовать в I2P-торрентах или обслуживать скрытые сервисы с высоким трафиком, потребуется больший объем памяти.\nЧто касается использования процессора, I2P был протестирован на скромных системах, таких как одноплатные компьютеры серии Raspberry Pi. Поскольку I2P активно использует криптографические методы, более мощный процессор лучше справится с нагрузкой, создаваемой I2P, а также с задачами, связанными с остальной частью системы (т.е. операционная система, графический интерфейс, другие процессы, например, веб-браузинг).\nРекомендуется использовать Sun/Oracle Java или OpenJDK.\nТребуется ли установка Java для использования I2P? Да, для использования I2P Core требуется Java. Мы включаем Java в наши установщики для Windows, Mac OSX и Linux. Если вы используете приложение I2P для Android, вам также потребуется среда выполнения Java, такая как Dalvik или ART, установленная в большинстве случаев.\nЧто такое \u0026ldquo;I2P Site\u0026rdquo; (сайт в I2P) и как настроить браузер для их использования? I2P-сайт — это обычный веб-сайт, за исключением того, что он размещён внутри I2P. I2P-сайты имеют адреса, которые выглядят как обычные интернет-адреса, заканчивающиеся на \u0026ldquo;.i2p\u0026rdquo; в удобочитаемом, некриптографическом виде для удобства людей. Фактическое подключение к I2P-сайту требует криптографии, что означает, что адреса I2P-сайтов также представляют собой длинные \u0026ldquo;Base64\u0026rdquo; Destinations и более короткие \u0026ldquo;B32\u0026rdquo; адреса. Вам может потребоваться выполнить дополнительную настройку для корректного просмотра. Для просмотра I2P-сайтов потребуется активировать HTTP-прокси в вашей установке I2P, а затем настроить браузер на его использование. Для получения дополнительной информации ознакомьтесь с разделом \u0026ldquo;Браузеры\u0026rdquo; ниже или руководством \u0026ldquo;Настройка браузера\u0026rdquo;.\nЧто означают числа Активные x/y в консоли роутера? На странице Peers (пиры) в консоли вашего роутера вы можете увидеть два числа - Active x/y. Первое число — это количество пиров, которым вы отправили или от которых получили сообщение в течение последних нескольких минут. Второе число — это количество пиров, обнаруженных недавно, оно всегда будет больше или равно первому числу.\nУ моего роутера очень мало активных пиров, это нормально? Да, это может быть нормально, особенно когда router только что был запущен. Новым routers потребуется время для запуска и подключения к остальной части сети. Чтобы помочь улучшить интеграцию в сеть, время работы и производительность, проверьте эти настройки:\nShare bandwidth - Если router настроен на предоставление пропускной способности, он будет маршрутизировать больше трафика для других роутеров, что помогает интегрировать его с остальной сетью, а также улучшает производительность локального соединения. Это можно настроить на странице http://localhost:7657/config . Network interface - Убедитесь, что на странице http://localhost:7657/confignet не указан конкретный интерфейс. Это может снизить производительность, если только ваш компьютер не имеет несколько сетевых интерфейсов с различными внешними IP-адресами. I2NP protocol - Убедитесь, что router настроен на ожидание подключений по протоколу, подходящему для операционной системы хоста, и что настройки сети (Advanced) пусты. Не вводите IP-адрес в поле \u0026lsquo;Hostname\u0026rsquo; на странице конфигурации сети. Выбранный здесь I2NP Protocol будет использоваться только в том случае, если у вас ещё нет доступного адреса. Например, большинство беспроводных подключений Verizon 4G и 5G в США блокируют UDP и недоступны через него. Другие же используют UDP принудительно, даже если он им доступен. Выберите подходящую настройку из списка I2NP Protocols. Я против определенных типов контента. Как мне избежать их распространения, хранения или доступа к ним? По умолчанию такой контент не устанавливается. Однако, поскольку I2P является пиринговой сетью, вы можете случайно столкнуться с запрещенным контентом. Вот краткое описание того, как I2P предотвращает вашу непреднамеренную причастность к нарушениям ваших убеждений.\nРаспространение - Трафик остаётся внутри сети I2P, вы не являетесь exit node (в нашей документации называется outproxy). Хранение - Сеть I2P не осуществляет распределённое хранение контента, это должно быть специально установлено и настроено пользователем (например, с помощью Tahoe-LAFS). Это функция другой анонимной сети, Freenet . Запуская router I2P, вы не храните ничей контент. Доступ - Ваш router не будет запрашивать какой-либо контент без вашего специального указания на это. Можно ли заблокировать I2P? Да, самый простой и распространённый способ — блокировка bootstrap или \u0026ldquo;Reseed\u0026rdquo; серверов. Полная блокировка всего обфусцированного трафика также сработает (хотя это нарушит работу множества других вещей, не связанных с I2P, и большинство не готовы заходить так далеко). В случае блокировки reseed существует reseed bundle на Github, блокировка которого также заблокирует Github. Вы можете выполнить reseed через прокси (множество прокси можно найти в интернете, если не хотите использовать Tor) или обмениваться reseed bundle с друзьями в офлайн-режиме.\nВ wrapper.log я вижу ошибку \u0026ldquo;Protocol family unavailable\u0026rdquo; при загрузке Router Console Часто эта ошибка возникает с любым сетевым программным обеспечением на Java на некоторых системах, которые настроены на использование IPv6 по умолчанию. Существует несколько способов решения этой проблемы:\nВ системах на базе Linux вы можете выполнить echo 0 \u0026gt; /proc/sys/net/ipv6/bindv6only Найдите следующие строки в wrapper.config: #wrapper.java.additional.5=-Djava.net.preferIPv4Stack=true #wrapper.java.additional.6=-Djava.net.preferIPv6Addresses=false Если эти строки присутствуют, раскомментируйте их, удалив символы \u0026ldquo;#\u0026rdquo;. Если этих строк нет, добавьте их без символов \u0026ldquo;#\u0026rdquo;. Другой вариант — удалить ::1 из ~/.i2p/clients.config\nВНИМАНИЕ: Чтобы любые изменения в wrapper.config вступили в силу, необходимо полностью остановить router и wrapper. Нажатие Перезапустить в консоли роутера НЕ перечитает этот файл! Вы должны нажать Остановить, подождать 11 минут, затем запустить I2P.\nБольшинство I2P-сайтов внутри I2P недоступны? Если учитывать каждый I2P Site, который когда-либо был создан, то да, большинство из них недоступны. Люди и I2P Sites приходят и уходят. Хороший способ начать работу с I2P — это ознакомиться со списком I2P Sites, которые в настоящее время активны. identiguy.i2p отслеживает активные I2P Sites.\nПочему I2P прослушивает порт 32000? Оболочка java сервиса Tanuki, которую мы используем, открывает этот порт — привязанный к localhost — для связи с программным обеспечением, работающим внутри JVM. При запуске JVM ему передаётся ключ, чтобы он мог подключиться к оболочке. После того как JVM установит соединение с оболочкой, оболочка отклоняет любые дополнительные подключения.\nБольше информации можно найти в документации wrapper .\nКак настроить мой браузер? Настройка прокси для различных браузеров находится на отдельной странице со скриншотами. Возможны более продвинутые конфигурации с внешними инструментами, такими как плагин для браузера FoxyProxy или прокси-сервер Privoxy, но они могут привести к утечкам в вашей настройке.\nКак подключиться к IRC внутри I2P? Туннель к основному IRC-серверу внутри I2P, Irc2P, создаётся при установке I2P (см. страницу конфигурации I2PTunnel ) и автоматически запускается вместе с router I2P. Чтобы подключиться к нему, настройте свой IRC-клиент на подключение к localhost 6668. Пользователи клиентов типа HexChat могут создать новую сеть с сервером localhost/6668 (не забудьте отметить \u0026ldquo;Обход прокси-сервера\u0026rdquo;, если у вас настроен прокси-сервер). Пользователи Weechat могут использовать следующую команду для добавления новой сети:\n/server add irc2p localhost/6668 Как настроить свой собственный I2P-сайт? Самый простой способ — перейти по ссылке i2ptunnel в консоли роутера и создать новый \u0026lsquo;Server Tunnel\u0026rsquo;. Вы можете обслуживать динамический контент, установив назначение туннеля на порт существующего веб-сервера, такого как Tomcat или Jetty. Также можно обслуживать статический контент. Для этого установите назначение туннеля на: 0.0.0.0 port 7659 и поместите контент в каталог ~/.i2p/eepsite/docroot/. (В системах, отличных от Linux, это может быть в другом месте. Проверьте консоль роутера.) Программное обеспечение \u0026rsquo;eepsite\u0026rsquo; входит в состав установочного пакета I2P и настроено на автоматический запуск при старте I2P. Сайт по умолчанию, который при этом создаётся, доступен по адресу http://127.0.0.1:7658. Однако ваш \u0026rsquo;eepsite\u0026rsquo; также доступен другим пользователям через файл ключа eepsite, расположенный в: ~/.i2p/eepsite/i2p/eepsite.keys. Для получения дополнительной информации прочитайте файл readme: ~/.i2p/eepsite/README.txt.\nЕсли я размещаю веб-сайт в I2P дома, содержащий только HTML и CSS, это опасно? Это зависит от вашего противника и вашей модели угроз. Если вас беспокоят только корпоративные нарушения \u0026ldquo;приватности\u0026rdquo;, типичные преступники и цензура, то это не представляет особой опасности. Правоохранительные органы, вероятно, все равно найдут вас, если действительно захотят. Только хостинг в то время, когда у вас запущен обычный (интернет) браузер домашнего пользователя, действительно усложнит определение того, кто именно хостит эту часть. Пожалуйста, рассматривайте хостинг вашего I2P сайта так же, как хостинг любого другого сервиса - он настолько опасен - или безопасен - насколько вы сами его настраиваете и управляете им.\nПримечание: Уже существует способ отделить хостинг i2p-сервиса (destination) от i2p router. Если вы понимаете, как это работает, то можете просто настроить отдельную машину в качестве сервера для веб-сайта (или сервиса), который будет публично доступен, и перенаправить его на веб-сервер через [очень] безопасный SSH-туннель или использовать защищённую общую файловую систему.\nКак I2P находит веб-сайты \u0026ldquo;.i2p\u0026rdquo;? Приложение I2P Address Book сопоставляет удобочитаемые имена с долгосрочными destination (адресами назначения), связанными с сервисами, что делает его больше похожим на файл hosts или список контактов, чем на сетевую базу данных или DNS-сервис. Он также работает по принципу \u0026ldquo;локальный приоритет\u0026rdquo; — не существует признанного глобального пространства имён, вы сами решаете, на что в конечном итоге будет указывать любой домен .i2p. Промежуточным решением является так называемый \u0026ldquo;Jump Service\u0026rdquo; (служба переходов), который предоставляет удобочитаемое имя, перенаправляя вас на страницу, где вам будет задан вопрос типа \u0026ldquo;Разрешаете ли вы I2P router называть $SITE_CRYPTO_KEY именем $SITE_NAME.i2p\u0026rdquo; или что-то в этом роде. Как только запись окажется в вашей адресной книге, вы сможете создавать собственные jump URL для помощи в распространении сайта среди других пользователей.\nКак добавить адреса в адресную книгу? Вы не можете добавить адрес, не зная хотя бы base32 или base64 сайта, который хотите посетить. \u0026ldquo;Hostname\u0026rdquo; (имя хоста), читаемое человеком, является лишь псевдонимом для криптографического адреса, который соответствует base32 или base64. Без криптографического адреса нет способа получить доступ к I2P-сайту, это заложено в архитектуре. Распространение адреса людям, которые его еще не знают, обычно является обязанностью провайдера Jump-сервиса. Посещение неизвестного I2P-сайта запустит использование Jump-сервиса. stats.i2p является наиболее надежным Jump-сервисом.\nЕсли вы размещаете сайт через i2ptunnel, то у него ещё не будет регистрации в jump-сервисе. Чтобы присвоить ему URL локально, перейдите на страницу конфигурации и нажмите кнопку «Add to Local Address Book» («Добавить в локальную адресную книгу»). Затем перейдите по адресу http://127.0.0.1:7657/dns, чтобы найти URL addresshelper и поделиться им.\nКакие порты использует I2P? Порты, которые использует I2P, можно разделить на 2 категории:\nПорты, обращенные в Интернет, которые используются для связи с другими I2P routers Локальные порты для локальных соединений Они подробно описаны ниже.\n1. Порты, доступные из Интернета Примечание: Начиная с версии 0.7.8, новые установки не используют порт 8887; случайный порт в диапазоне от 9000 до 31000 выбирается при первом запуске программы. Выбранный порт отображается на странице конфигурации router\u0026rsquo;а.\nИСХОДЯЩИЙ\nUDP с произвольного порта, указанного на странице конфигурации , на произвольные удалённые UDP-порты, с возможностью получения ответов TCP с произвольных высоких портов на произвольные удалённые TCP-порты Исходящий UDP на порт 123, с возможностью получения ответов. Это необходимо для внутренней синхронизации времени I2P (через SNTP - запрос к случайному SNTP-хосту в pool.ntp.org или другому серверу, который вы укажете) ВХОДЯЩИЙ\n(Опционально, рекомендуется) UDP на порт, указанный на странице конфигурации , из произвольных мест (Опционально, рекомендуется) TCP на порт, указанный на странице конфигурации , из произвольных мест Входящий TCP можно отключить на странице конфигурации 2. Локальные порты I2P Локальные порты I2P по умолчанию принимают только локальные подключения, за исключением случаев, где указано иное:\nPORT PURPOSE DESCRIPTION 1900 UPnP SSDP UDP multicast listener Cannot be changed. Binds to all interfaces. May be disabled on confignet. 2827 BOB bridge A higher level socket API for clients. Disabled by default. May be enabled/disabled on configclients. May be changed in the bob.config file. 4444 HTTP proxy Configured on configclients, go to the page i2ptunnel to start/stop it and on the page I2P HTTP Proxy to configure it. Include in your browser's proxy configuration for HTTP 4445 HTTPS proxy Configured on configclients, go to the page i2ptunnel to start/stop it and on the page I2P HTTPS Proxy to configure it. Include in your browser's proxy configuration for HTTPS 6668 IRC proxy A tunnel to the inside-the-I2P IRC network. Disabled by default. Configured on the page irc.postman.i2p (IRC proxy) and may be enabled/disabled on the page i2ptunnel 7654 I2CP (client protocol) port For advanced client usage. Do not expose to an external network. 7656 SAM bridge A socket API for clients. Disabled by default. May be enabled/disabled on configclients and configured on sam. 7657 (or 7658 via SSL) Router console The router console provides valuable information about your router and the network, in addition to giving you access to configure your router and its associated applications. 7659 'eepsite' - an example webserver (Jetty) Included in the i2pinstall and i2pupdate packages - may be disabled if another webserver is available. May be configured on the page eepsite and disabled on the page i2ptunnel 7660 I2PTunnel UDP port for SSH Required for Grizzled's/novg's UDP support. Instances disabled by default. May be enabled/disabled and configured to use a different port on the page i2ptunnel. 123 NTP Port Used by NTP Time Sync. May be disabled/changed. ### В моей адресной книге не хватает множества хостов. Какие есть хорошие ссылки для подписки? {#subscriptions} Адресная книга находится по адресу http://localhost:7657/dns , где можно найти дополнительную информацию.\nКакие есть хорошие ссылки для подписки на адресную книгу?\nВы можете попробовать следующее:\nhttp://stats.i2p/cgi-bin/newhosts.txt http://identiguy.i2p/hosts.txt Как получить доступ к веб-консоли с других компьютеров или защитить её паролем? В целях безопасности консоль администрирования роутера по умолчанию принимает соединения только на локальном интерфейсе.\nСуществует два способа удалённого доступа к консоли:\nSSH Tunnel Настройка вашей консоли для доступа по публичному IP-адресу с именем пользователя и паролем Они подробно описаны ниже:\nМетод 1: SSH-туннель\nЕсли вы используете Unix-подобную операционную систему, это самый простой способ для удалённого доступа к вашей консоли I2P. (Примечание: программное обеспечение SSH-сервера доступно и для систем Windows, например https://github.com/PowerShell/Win32-OpenSSH )\nПосле настройки SSH-доступа к вашей системе передайте флаг \u0026lsquo;-L\u0026rsquo; команде SSH с соответствующими аргументами - например:\nssh -L 7657:localhost:7657 (System_IP) где \u0026lsquo;(System_IP)\u0026rsquo; заменяется на IP-адрес вашей системы. Эта команда перенаправляет порт 7657 (число перед первым двоеточием) на порт 7657 удалённой системы (указанной строкой \u0026rsquo;localhost\u0026rsquo; между первым и вторым двоеточиями) (число после второго двоеточия). Ваша удалённая консоль I2P теперь будет доступна в вашей локальной системе по адресу \u0026lsquo;http://localhost:7657\u0026rsquo; и будет доступна, пока активна ваша SSH-сессия.\nЕсли вы хотите запустить SSH-сессию без инициализации оболочки на удалённой системе, можно добавить флаг \u0026lsquo;-N\u0026rsquo;:\nssh -NL 7657:localhost:7657 (System_IP) Метод 2: Настройка консоли для доступа по публичному IP-адресу с использованием имени пользователя и пароля\nОткройте ~/.i2p/clients.config и замените:\nclientApp.0.args=7657 ::1,127.0.0.1 ./webapps/ на:\nclientApp.0.args=7657 ::1,127.0.0.1,(System_IP) ./webapps/ где вы заменяете (System_IP) на публичный IP-адрес вашей системы\nПерейдите по адресу http://localhost:7657/configui и добавьте имя пользователя и пароль для консоли, если требуется - Настоятельно рекомендуется добавить имя пользователя и пароль для защиты консоли I2P от несанкционированного доступа, который может привести к деанонимизации.\nПерейдите на http://localhost:7657/index и нажмите \u0026ldquo;Graceful restart\u0026rdquo;, что перезапустит JVM и перезагрузит клиентские приложения\nПосле запуска вы теперь сможете получить удаленный доступ к консоли. Загрузите консоль роутера по адресу http://(System_IP):7657, и вам будет предложено ввести имя пользователя и пароль, указанные на шаге 2 выше, если ваш браузер поддерживает всплывающее окно аутентификации.\nПРИМЕЧАНИЕ: Вы можете указать 0.0.0.0 в приведённой выше конфигурации. Это указывает интерфейс, а не сеть или маску сети. 0.0.0.0 означает \u0026ldquo;привязаться ко всем интерфейсам\u0026rdquo;, поэтому консоль будет доступна как на 127.0.0.1:7657, так и на любом IP-адресе локальной или глобальной сети. Будьте осторожны при использовании этой опции, так как консоль будет доступна на ВСЕХ адресах, настроенных в вашей системе.\nКак я могу использовать приложения с других моих машин? Пожалуйста, смотрите предыдущий ответ для инструкций по использованию переадресации портов SSH, а также смотрите эту страницу в вашей консоли: http://localhost:7657/configi2cp Можно ли использовать I2P в качестве SOCKS-прокси? SOCKS proxy функционирует с версии 0.7.1. Поддерживаются SOCKS 4/4a/5. I2P не имеет SOCKS outproxy, поэтому его использование ограничено только сетью I2P.\nМногие приложения раскрывают конфиденциальную информацию, которая может идентифицировать вас в Интернете, и это риск, о котором следует знать при использовании SOCKS-прокси I2P. I2P фильтрует только данные соединения, но если программа, которую вы собираетесь использовать, отправляет эту информацию в качестве содержимого, I2P не может защитить вашу анонимность. Например, некоторые почтовые приложения отправляют IP-адрес машины, на которой они работают, на почтовый сервер. Мы рекомендуем специализированные инструменты или приложения для I2P (например, I2PSnark для торрентов) или приложения, которые, как известно, безопасны для использования с I2P, включая популярные плагины для Firefox .\nКак получить доступ к IRC, BitTorrent или другим сервисам в обычном Интернете? Существуют сервисы под названием Outproxy, которые служат мостом между I2P и Интернетом, подобно Tor Exit Nodes. Функциональность outproxy по умолчанию для HTTP и HTTPS предоставляется exit.stormycloud.i2p и управляется компанией StormyCloud Inc. Она настраивается в HTTP Proxy. Кроме того, для защиты анонимности I2P по умолчанию не позволяет устанавливать анонимные соединения с обычным Интернетом. Пожалуйста, смотрите страницу Socks Outproxy для получения дополнительной информации.\nReseed-серверы Мой роутер работает уже несколько минут и имеет ноль или очень мало соединений Сначала проверьте страницу http://127.0.0.1:7657/netdb в консоли router – вашу сетевую базу данных. Если вы не видите ни одного router в списке из I2P, но консоль сообщает, что вы находитесь за firewall, то вероятно вы не можете подключиться к серверам reseed. Если вы видите другие I2P router в списке, попробуйте уменьшить количество максимальных соединений http://127.0.0.1:7657/config – возможно ваш router не может обрабатывать много соединений.\nКак выполнить reseed вручную? При обычных обстоятельствах I2P автоматически подключит вас к сети, используя наши ссылки для начальной загрузки. Если проблемы с интернетом приводят к сбою начальной загрузки с reseed-серверов, простой способ выполнить начальную загрузку — использовать браузер Tor (по умолчанию он открывает localhost), который отлично работает с http://127.0.0.1:7657/configreseed . Также возможно выполнить reseed router I2P вручную.\nПри использовании Tor Browser для reseed вы можете выбрать несколько URL одновременно и продолжить. Хотя значение по умолчанию, равное 2 (из нескольких URL), также будет работать, но это будет медленно.\nКонфиденциальность и безопасность Является ли мой роутер \u0026ldquo;exit node\u0026rdquo; (outproxy) к обычному Интернету? Я не хочу, чтобы так было. Нет, ваш router участвует в транспортировке зашифрованного e2e трафика через сеть i2p до случайной конечной точки tunnel, обычно не outproxy, но никакой трафик не передается между вашим router и Интернетом на транспортном уровне. Как конечный пользователь, вам не следует запускать outproxy, если у вас нет навыков системного и сетевого администрирования.\nЛегко ли обнаружить использование I2P, анализируя сетевой трафик? Трафик I2P обычно выглядит как UDP-трафик, и не более того – и цель заключается в том, чтобы он выглядел именно так. Он также поддерживает TCP. При некоторых усилиях пассивный анализ трафика может классифицировать трафик как \u0026ldquo;I2P\u0026rdquo;, но мы надеемся, что дальнейшее развитие обфускации трафика ещё больше это затруднит. Даже довольно простой слой обфускации протокола, такой как obfs4, предотвратит блокировку I2P цензорами (это цель, которую преследует I2P).\nБезопасно ли использование I2P? Это зависит от вашей личной модели угроз. Для большинства людей I2P намного безопаснее, чем отсутствие какой-либо защиты. Некоторые другие сети (такие как Tor, mixminion/mixmaster), вероятно, безопаснее против определённых противников. Например, трафик I2P не использует TLS/SSL, поэтому у него нет проблемы \u0026ldquo;слабого звена\u0026rdquo;, как у Tor. I2P использовали многие люди в Сирии во время \u0026ldquo;Арабской весны\u0026rdquo;, и в последнее время проект наблюдает больший рост в небольших языковых установках I2P на Ближнем и Среднем Востоке. Самое важное, что нужно отметить здесь, это то, что I2P — это технология, и вам нужна инструкция/руководство для повышения вашей приватности/анонимности в Интернете. Также проверьте свой браузер или импортируйте поисковую систему по отпечаткам, чтобы блокировать атаки по снятию отпечатков с помощью очень большого (то есть: типичные длинные хвосты / очень точная разнообразная структура данных) набора данных о множестве параметров окружения, и не используйте VPN, чтобы уменьшить все риски, исходящие от него самого, такие как поведение собственного кэша TLS и техническая конструкция бизнеса провайдера, которую можно взломать легче, чем собственную настольную систему. Возможно, использование изолированного Tor V-Browser с его отличной защитой от снятия отпечатков и общей защитой appguard на время работы с разрешением только необходимых системных коммуникаций и последней линией защиты в виде использования виртуальной машины со скриптами отключения шпионажа и live-cd для устранения любого \u0026ldquo;практически постоянного возможного риска\u0026rdquo; и снижения всех рисков за счёт уменьшения вероятности — хороший вариант в публичной сети и для высокой индивидуальной модели риска, и это может быть лучшее, что вы можете сделать с этой целью для использования I2P.\nЯ вижу IP-адреса всех остальных узлов I2P в консоли роутера. Означает ли это, что мой IP-адрес виден другим? Да, для других узлов I2P, которые знают о вашем router. Мы используем это для подключения к остальной сети I2P. Адреса физически находятся в объектах \u0026ldquo;routerInfos (key,value)\u0026rdquo;, либо загруженных удалённо, либо полученных от узлов сети. \u0026ldquo;routerInfos\u0026rdquo; содержит некоторую информацию (некоторая добавляется опционально оппортунистически), \u0026ldquo;опубликованную узлом\u0026rdquo;, о самом router для начальной загрузки. В этом объекте нет данных о клиентах. Более детальный взгляд под капот покажет вам, что все учитываются с использованием новейшего типа создания идентификаторов, называемого \u0026ldquo;SHA-256 хеши (low=положительный хеш(-key), high=отрицательный хеш(+key))\u0026rdquo;. Сеть I2P имеет собственную базу данных routerInfos, созданную во время загрузки и индексирования, но это глубоко зависит от реализации таблиц key/value и топологии сети, состояния нагрузки / состояния пропускной способности и вероятностей маршрутизации для хранилищ в компонентах БД.\nБезопасно ли использовать outproxy? Это зависит от того, что вы понимаете под словом \u0026ldquo;безопасный\u0026rdquo;. Outproxy-серверы отлично работают, когда они доступны, но, к сожалению, они управляются добровольцами, которые могут потерять интерес или могут не иметь ресурсов для их поддержки 24/7 – пожалуйста, имейте в виду, что вы можете столкнуться с периодами времени, когда сервисы недоступны, прерываются или работают ненадёжно, и мы не связаны с этим сервисом и не имеем на него никакого влияния.\nСами outproxy могут видеть ваш входящий и исходящий трафик, за исключением данных, зашифрованных end-to-end с помощью HTTPS/SSL, точно так же, как ваш интернет-провайдер может видеть трафик, поступающий и исходящий с вашего компьютера. Если вас устраивает ваш интернет-провайдер, то с outproxy не будет ничего хуже.\nЧто насчет атак по \u0026ldquo;деанонимизации\u0026rdquo;? Для очень подробного объяснения читайте больше в наших статьях о Модели угроз . В целом, деанонимизация не является тривиальной задачей, но возможна, если вы недостаточно осторожны.\nДоступ в Интернет/Производительность Я не могу получить доступ к обычным сайтам в Интернете через I2P. Проксирование к интернет-сайтам (eepsites, которые выходят в Интернет) предоставляется в качестве услуги пользователям I2P провайдерами без блокировок. Эта услуга не является основным направлением разработки I2P и предоставляется на добровольной основе. Eepsites, размещённые в I2P, должны всегда работать без outproxy. Outproxy — это удобство, но по своей природе они не являются совершенными и не составляют значительную часть проекта. Имейте в виду, что они могут быть не в состоянии обеспечить высококачественный сервис, который могут предоставить другие службы I2P.\nЯ не могу получить доступ к сайтам https:// или ftp:// через I2P. HTTP-прокси по умолчанию поддерживает только HTTP и HTTPS outproxy.\nПочему мой router использует слишком много процессора? Во-первых, убедитесь, что у вас установлена последняя версия всех компонентов I2P — в старых версиях были ненужные участки кода, потребляющие процессорное время. Также существует журнал производительности , в котором задокументированы некоторые улучшения производительности I2P с течением времени.\nМои активные пиры / известные пиры / туннели, в которых я участвую / соединения / пропускная способность резко меняются со временем! Что-то не так? Общая стабильность сети I2P является постоянной областью исследований. Значительная часть этих исследований сосредоточена на том, как небольшие изменения в настройках конфигурации влияют на поведение router. Поскольку I2P является одноранговой сетью, действия других узлов будут влиять на производительность вашего router.\nЧто делает загрузки, торренты, веб-серфинг и всё остальное медленнее в I2P по сравнению с обычным интернетом? I2P использует различные средства защиты, которые добавляют дополнительную маршрутизацию и дополнительные уровни шифрования. Он также перенаправляет трафик через других участников сети (tunnels), которые имеют свою собственную скорость и качество — некоторые медленные, другие быстрые. Это приводит к значительным накладным расходам и трафику, движущемуся с разной скоростью в разных направлениях. По своей конструкции все эти факторы делают I2P медленнее по сравнению с прямым подключением к интернету, но при этом он обеспечивает значительно более высокую анонимность и остаётся достаточно быстрым для большинства задач.\nНиже представлен пример с пояснением, который поможет понять особенности задержек и пропускной способности при использовании I2P.\nРассмотрим диаграмму ниже. Она показывает соединение между клиентом, отправляющим запрос через I2P, сервером, получающим запрос через I2P и затем отвечающим также через I2P. Также показан маршрут, по которому проходит запрос.\nИз диаграммы видно, что блоки с обозначениями \u0026lsquo;P\u0026rsquo;, \u0026lsquo;Q\u0026rsquo; и \u0026lsquo;R\u0026rsquo; представляют исходящий туннель для \u0026lsquo;A\u0026rsquo;, а блоки с обозначениями \u0026lsquo;X\u0026rsquo;, \u0026lsquo;Y\u0026rsquo; и \u0026lsquo;Z\u0026rsquo; представляют исходящий туннель для \u0026lsquo;B\u0026rsquo;. Аналогично, блоки с обозначениями \u0026lsquo;X\u0026rsquo;, \u0026lsquo;Y\u0026rsquo; и \u0026lsquo;Z\u0026rsquo; представляют входящий туннель для \u0026lsquo;B\u0026rsquo;, в то время как блоки с обозначениями \u0026lsquo;P_1\u0026rsquo;, \u0026lsquo;Q_1\u0026rsquo; и \u0026lsquo;R_1\u0026rsquo; представляют входящий туннель для \u0026lsquo;A\u0026rsquo;. Стрелки между блоками показывают направление трафика. Текст над и под стрелками детализирует примеры пропускной способности между парами узлов, а также примеры задержек.\nКогда и клиент, и сервер используют 3-хоповые туннели на всём протяжении, в ретрансляции трафика участвует в общей сложности 12 других I2P-маршрутизаторов. 6 узлов ретранслируют трафик от клиента к серверу, который разделяется на 3-хоповый исходящий туннель от \u0026lsquo;A\u0026rsquo; (\u0026lsquo;P\u0026rsquo;, \u0026lsquo;Q\u0026rsquo;, \u0026lsquo;R\u0026rsquo;) и 3-хоповый входящий туннель к \u0026lsquo;B\u0026rsquo; (\u0026lsquo;X\u0026rsquo;, \u0026lsquo;Y\u0026rsquo;, \u0026lsquo;Z\u0026rsquo;). Аналогично, 6 узлов ретранслируют трафик от сервера обратно к клиенту.\nВо-первых, мы можем рассмотреть задержку - время, которое требуется запросу от клиента, чтобы пройти через сеть I2P, достичь сервера и вернуться обратно к клиенту. Суммируя все задержки, мы видим, что:\n40 + 100 + 20 + 60 + 80 + 10 + 30 ms (client to server) + 60 + 40 + 80 + 60 + 100 + 20 + 40 ms (server to client) ----------------------------------- TOTAL: 740 ms Общее время прохождения туда и обратно в нашем примере составляет 740 мс — безусловно, намного больше, чем обычно наблюдается при просмотре обычных интернет-сайтов.\nВо-вторых, мы можем рассмотреть доступную пропускную способность. Она определяется самым медленным соединением между узлами от клиента к серверу, а также при передаче трафика сервером клиенту. Для трафика, идущего от клиента к серверу, мы видим, что доступная пропускная способность в нашем примере между узлами \u0026lsquo;R\u0026rsquo; и \u0026lsquo;X\u0026rsquo;, а также между узлами \u0026lsquo;X\u0026rsquo; и \u0026lsquo;Y\u0026rsquo; составляет 32 КБ/с. Несмотря на более высокую доступную пропускную способность между другими узлами, эти узлы будут выступать в качестве узких мест и ограничат максимальную доступную пропускную способность для трафика от \u0026lsquo;A\u0026rsquo; к \u0026lsquo;B\u0026rsquo; на уровне 32 КБ/с. Аналогично, отслеживая путь от сервера к клиенту, мы видим, что максимальная пропускная способность составляет 64 КБ/с — между узлами \u0026lsquo;Z_1\u0026rsquo; и \u0026lsquo;Y_1\u0026rsquo;, \u0026lsquo;Y_1\u0026rsquo; и \u0026lsquo;X_1\u0026rsquo;, а также \u0026lsquo;Q_1\u0026rsquo; и \u0026lsquo;P_1\u0026rsquo;.\nМы рекомендуем увеличить ограничения пропускной способности. Это помогает сети, увеличивая количество доступной пропускной способности, что в свою очередь улучшит ваш опыт использования I2P. Настройки пропускной способности находятся на странице http://localhost:7657/config . Пожалуйста, учитывайте ограничения вашего интернет-соединения, установленные вашим провайдером, и настраивайте параметры соответствующим образом.\nМы также рекомендуем установить достаточный объём shared bandwidth — это позволяет транзитным tunnel проходить через ваш I2P router. Разрешение транзитного трафика поддерживает хорошую интеграцию вашего router в сеть и улучшает скорость передачи данных.\nI2P — это проект в разработке. Множество улучшений и исправлений постоянно реализуется, и, как правило, использование последней версии улучшит производительность. Если вы еще не сделали этого, установите последнюю версию.\nЯ думаю, что нашёл ошибку, где я могу сообщить о ней? Вы можете сообщить о любых ошибках/проблемах, с которыми столкнулись, в нашем багтрекере, который доступен как через обычный интернет, так и через I2P. У нас есть форум для обсуждений, также доступный через I2P и обычный интернет. Вы также можете присоединиться к нашему IRC-каналу: либо через нашу IRC-сеть IRC2P, либо через Freenode.\nНаш Bugtracker: Вне приватного интернета: https://i2pgit.org/I2P_Developers/i2p.i2p/issues В I2P: http://git.idk.i2p/I2P_Developers/i2p.i2p/issues Наши форумы: i2pforum.i2p Вставка логов: Вы можете разместить любые интересные логи в сервисе вставок, таком как сервисы вне приватного интернета, перечисленные в PrivateBin Wiki , или в сервисе вставок I2P, таком как этот экземпляр PrivateBin или этот сервис вставок без Javascript , и продолжить обсуждение в IRC в канале #i2p IRC: Присоединяйтесь к #i2p-dev для обсуждения с разработчиками в IRC Пожалуйста, включите соответствующую информацию со страницы логов router, которая доступна по адресу: http://127.0.0.1:7657/logs . Мы просим вас предоставить весь текст из раздела \u0026lsquo;I2P Version and Running Environment\u0026rsquo;, а также все ошибки или предупреждения, отображаемые в различных логах на этой странице.\nУ меня есть вопрос! Отлично! Найдите нас в IRC:\nна irc.freenode.net канал #i2p на IRC2P канал #i2p или опубликуйте на форуме , и мы разместим это здесь (с ответом, будем надеяться).\n","description":"Полное FAQ по I2P: помощь с router, настройка, reseeds, приватность/безопасность, производительность и устранение неполадок","id":"b0f8e4ee3509d229b406a0b0bb933ca4","section":"docs","title":"Часто задаваемые вопросы","url":"/ru/docs/overview/faq/"},{"categories":null,"content":" Статус: В этом документе описан устаревший протокол шифрования ElGamal/AES+SessionTag. Он поддерживается только для обратной совместимости, поскольку современные версии I2P (2.10.0+) используют ECIES-X25519-AEAD-Ratchet . Протокол ElGamal признан устаревшим и сохраняется исключительно в исторических целях и для обеспечения совместимости.\nОбзор ElGamal/AES+SessionTag обеспечивал первоначальный механизм сквозного шифрования в I2P для garlic messages (garlic-сообщений). Он объединял:\nElGamal (2048-битный) — для обмена ключами AES-256/CBC — для шифрования полезной нагрузки SHA-256 — для хеширования и генерации IV (инициализационный вектор) Сеансовые теги (32 байта) — для одноразовых идентификаторов сообщений Протокол позволял routers и адресатам безопасно обмениваться данными без поддержания постоянных соединений. В каждой сессии выполнялся асимметричный обмен по алгоритму ElGamal для установления симметричного ключа AES, после чего передавались легковесные \u0026ldquo;помеченные\u0026rdquo; сообщения, ссылающиеся на эту сессию.\nРабота протокола Установление сеанса (новый сеанс) Новый сеанс начался с сообщения, содержащего два раздела:\nSection Size Contents Purpose ElGamal-encrypted block 514 bytes 222 bytes of plaintext encrypted using the recipient's ElGamal public key Establishes the AES session key and IV seed AES-encrypted block Variable (≥128 bytes typical) Payload data, integrity hash, and session tags Carries the actual message and new tags Открытый текст внутри блока ElGamal состоял из: Field Size Description Session Key 32 bytes AES-256 key for the session Pre-IV 32 bytes Material for deriving the AES initialization vector (IV = first 16 bytes of SHA-256(Pre-IV)) Random Padding 158 bytes Filler to reach required ElGamal plaintext length ### Сообщения для существующей сессии После установления сеанса отправитель мог отправлять сообщения existing-session (для уже существующей сессии), используя кэшированные теги сеанса:\nField Size Description Session Tag 32 bytes Single-use identifier tied to the existing session key AES-Encrypted Block Variable Encrypted payload and metadata using the established AES key Routers кэшировали полученные теги примерно **15 минут**, после чего срок действия неиспользованных тегов истекал. Каждый тег был действителен ровно для **одного сообщения**, чтобы предотвратить корреляционные атаки. Формат AES-зашифрованного блока Field Size Description Tag Count 2 bytes Number (0–200) of new session tags included Session Tags 32 × N bytes Newly generated single-use tags Payload Size 4 bytes Length of the payload in bytes Payload Hash 32 bytes SHA-256 digest of the payload Flag 1 byte 0x00 normal, 0x01 = new session key follows (unused) New Session Key 32 bytes (optional) Replacement AES key (rarely used) Payload Variable Encrypted message data Padding Variable (16-byte aligned) Random padding to block boundary Routers расшифровывают, используя сеансовый ключ и IV, полученные либо из Pre-IV (предварительный IV) для новых сеансов, либо из сеансового тега для существующих сеансов. После расшифрования они проверяют целостность, пересчитывая хэш SHA-256 от открытого текста полезной нагрузки. Управление тегами сеанса Теги — односторонние: теги для направления Алиса → Боб не могут быть повторно использованы для Боб → Алиса. Срок действия тегов истекает примерно через 15 минут. Routers поддерживают по одному менеджеру сеансовых ключей для каждого назначения, чтобы отслеживать теги, ключи и время их истечения. Приложения могут управлять поведением тегов с помощью параметров I2CP : i2cp.tagThreshold — минимальное количество кэшированных тегов до пополнения i2cp.tagCount — число новых тегов на сообщение Этот механизм минимизировал ресурсоёмные рукопожатия ElGamal, сохраняя при этом несвязываемость между сообщениями.\nКонфигурация и эффективность Сеансовые теги были введены, чтобы повысить эффективность при работе поверх транспорта I2P с высокой задержкой и неупорядоченной доставкой. Типичная конфигурация передавала 40 тегов на сообщение, добавляя около 1,2 КБ служебных данных. Приложения могли настраивать поведение доставки в зависимости от ожидаемого трафика:\nUse Case Recommended Tags Notes Short-lived requests (HTTP, datagrams) 0 – 5 Low overhead, may trigger ElGamal fallback Persistent streams or bulk transfer 20 – 50 Higher bandwidth use, avoids session re-establishment Long-term services 50+ Ensures steady tag supply despite loss or delay Routers периодически удаляют просроченные теги и подчищают неиспользуемое состояние сеанса, чтобы снизить использование памяти и противодействовать атакам tag-flooding (наводнение метками). Ограничения Category Limitation Performance 514-byte ElGamal block adds heavy overhead for new sessions; session tags consume 32 bytes each. Security No forward secrecy – compromise of ElGamal private key exposes past sessions. Integrity AES-CBC requires manual hash verification; no AEAD. Quantum Resistance Vulnerable to Shor's algorithm – will not survive quantum attacks. Complexity Requires stateful tag management and careful timeout tuning. Эти недостатки непосредственно подтолкнули к разработке протокола [ECIES-X25519-AEAD-Ratchet](/docs/specs/ecies/), который обеспечивает совершенную прямую секретность, аутентифицированное шифрование и эффективный обмен ключами. Статус устаревания и миграции Введено: Ранние релизы I2P (до 0.6) Устарело: С появлением ECIES-X25519 (0.9.46 → 0.9.48) Удалено: Больше не используется по умолчанию начиная с 2.4.0 (декабрь 2023 г.) Поддерживается: Только для обратной совместимости Современные router и назначения теперь анонсируют тип криптографии 4 (ECIES-X25519) вместо типа 0 (ElGamal/AES). Устаревший протокол по‑прежнему распознаётся для обеспечения совместимости с устаревшими пирами, но его не следует использовать для новых развёртываний.\nИсторический контекст ElGamal/AES+SessionTag лежал в основе ранней криптографической архитектуры I2P. Его гибридная конструкция ввела такие новшества, как одноразовые session tags (метки сеанса) и однонаправленные сеансы, которые повлияли на последующие протоколы. Многие из этих идей эволюционировали в современные конструкции, такие как детерминированные ratchets (механизмы последовательного обновления ключей) и гибридные постквантовые обмены ключами.\n","description":"Устаревшее сквозное шифрование, сочетающее ElGamal, AES, SHA-256 и одноразовые сеансовые теги","id":"092d77bf065d0f13bb2b2a470f57a902","section":"docs","title":"Шифрование ElGamal/AES + SessionTag (метка сессии)","url":"/ru/docs/legacy/elgamal-aes/"}]
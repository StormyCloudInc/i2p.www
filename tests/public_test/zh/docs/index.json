[{"categories":null,"content":"概述 BitTorrent over I2P 通过使用 I2P 流式传输层的加密 tunnel 实现匿名文件共享。所有节点通过加密的 I2P destination（目的地标识符）而非 IP 地址进行识别。该系统支持 HTTP 和 UDP tracker、混合磁力链接以及后量子混合加密。\n1. 协议栈 Layer Function Example Application BitTorrent i2psnark, BiglyBT Transport Streaming / SAM v3 I2CP, NTCP2 Network Garlic routing I2NP 所有连接都通过 I2P 的加密传输层（NTCP2 或 SSU2）运行。即使是 UDP tracker 数据包也被封装在 I2P streaming 中。 2. Tracker（追踪器） HTTP Tracker（HTTP 追踪器） 标准的 .i2p tracker 响应 HTTP GET 请求，例如：\nhttp://tracker2.postman.i2p/announce?info_hash=\u0026lt;20-byte\u0026gt;\u0026amp;peer_id=\u0026lt;20-byte\u0026gt;\u0026amp;port=6881\u0026amp;uploaded=0\u0026amp;downloaded=0\u0026amp;left=1234\u0026amp;compact=1 响应使用 bencoded 编码，并使用 I2P destination 哈希来表示对等节点。\nUDP Tracker UDP tracker 在 2025 年标准化（提案 160）。\n主要 UDP Trackers - udp://tracker2.postman.i2p/announce - udp://opentracker.simp.i2p/a - http://opentracker.skank.i2p/a - http://opentracker.dg2.i2p/a \u0026mdash;\n3. 磁力链接 magnet:?xt=urn:btih:\u0026lt;infohash\u0026gt;\u0026amp;dn=\u0026lt;name\u0026gt;\u0026amp;tr=http://tracker2.postman.i2p/announce\u0026amp;tr=udp://denpa.i2p/announce\u0026amp;xs=i2p:\u0026lt;destination.b32.i2p\u0026gt; Parameter Meaning xs=i2p:\u0026lt;dest\u0026gt; Explicit I2P destination tr= Tracker URLs (HTTP or UDP) dn= Display name 当配置好后，磁力链接支持跨 I2P 和明网的混合种群。 4. DHT 实现 Implementation Type Status Java I2P Experimental overlay Stable i2pd UDP-based internal overlay Active BiglyBT SAM v3.3-based Fully supported --- 5. 客户端实现 I2PSnark 所有路由器均内置 仅支持 HTTP tracker 内置 tracker 位于 http://127.0.0.1:7658/ 不支持 UDP tracker BiglyBT 功能完整，支持 I2P 插件 支持 HTTP + UDP tracker 支持混合种子 使用 SAM v3.3 接口 Tixati / XD 轻量级客户端 基于 SAM 的隧道 实验性 ML-KEM 混合加密 6. 配置 I2PSnark i2psnark.dir=/home/user/torrents i2psnark.autostart=true i2psnark.maxUpBW=128 i2psnark.maxDownBW=256 i2psnark.enableDHT=false BiglyBT SAMHost=127.0.0.1 SAMPort=7656 SAMNickname=BiglyBT-I2P SAMAutoStart=true DHTEnabled=true 7. 安全模型 Component Description Encryption NTCP2 / SSU2 with X25519+ML-KEM hybrid Identity I2P destinations replace IP addresses Anonymity Peer info hidden; traffic multiplexed Leak Prevention Remove headers (X-Forwarded-For, Client-IP, Via) 混合（明网 + I2P）种子仅应在匿名性不重要时使用。 8. 性能 Factor Impact Recommendation Tunnel length Adds latency 1-hop client, 2-hop server Peers Boosts speed 20+ active peers Compression Minimal gain Usually off Bandwidth Router-limited Default settings optimal 典型速度范围为 **30–80 KB/s**，具体取决于节点和网络状况。 9. 已知问题 Java I2P 和 i2pd 之间的部分 DHT 互操作性 高负载下 Magnet 元数据获取延迟 NTCP1 已弃用但仍被旧节点使用 通过流式传输模拟的 UDP 增加延迟 10. 未来路线图 类似 QUIC 的多路复用 完整的 ML-KEM 集成 统一的混合群逻辑 改进的重新播种镜像 自适应 DHT 重试 参考文献 BEP 15 – UDP Tracker 协议 提案 160 – 基于 I2P 的 UDP Tracker I2PSnark 文档 Streaming 库规范 ","description":"I2P 网络中 BitTorrent 的详细规范和生态系统概述","id":"5d0ca50c8763996448d3099a14dc36b0","section":"docs","title":"BitTorrent over I2P","url":"/zh/docs/applications/bittorrent/"},{"categories":null,"content":"概述 本文档规定了 I2P blockfile（块文件）文件格式，以及由 Blockfile Naming Service（Blockfile 命名服务） 使用的 hostsdb.blockfile 中的表。 背景信息参见 I2P 命名与地址簿 。\nblockfile（块文件格式）以紧凑的二进制格式实现了快速查找目标地址。 与传统的 hosts.txt 系统相比：\nDestinations（目标地址）以二进制形式存储，而非 Base64。 可附加任意元数据（例如：添加日期、来源、注释）。 查找时间大约快 10×。 磁盘使用量会小幅增加。 blockfile（块文件）是一种以跳表实现、存储在磁盘上的已排序映射（键值对）集合。它源自 Metanotion Blockfile Database 。本规范首先定义文件结构，然后说明 BlockfileNamingService 如何使用它。\nBlockfile Naming Service（Blockfile 命名服务）在 I2P 0.8.8 中取代了旧的 hosts.txt 实现。 \u0026gt; 初始化时，它会从 privatehosts.txt、userhosts.txt 和 hosts.txt 中导入条目。\nBlockfile 格式 该格式由1024 字节的页面组成，每个页面前都有一个用于完整性校验的魔数。 页面从 1 开始编号：\nPage Description 1 Superblock (starts at byte 0) 2 Metaindex skiplist (starts at byte 1024) 所有整数使用**网络字节序（大端）**。 2 字节的值为无符号；4 字节的值（页号）为有符号，且必须为正数。 线程模型： 该数据库设计为单线程访问；BlockfileNamingService 提供同步机制。\n超级块格式 Byte Contents 0-5 Magic number 0x3141de493250 (\"1A\" 0xde \"I2P\") 6 Major version 0x01 7 Minor version 0x02 8-15 File length (in bytes) 16-19 First free list page 20-21 Mounted flag (0x01 = yes) 22-23 Span size (max key/value pairs per span, 16 for hostsdb) 24-27 Page size (as of v1.2; 1024 before that) 28-1023 Unused --- 跳表块页格式 Byte Contents 0-7 Magic 0x536b69704c697374 (\"SkipList\") 8-11 First span page 12-15 First level page 16-19 Size (total keys, valid at startup) 20-23 Spans (total spans, valid at startup) 24-27 Levels (total levels, valid at startup) 28-29 Span size (as of v1.2; used for new spans) 30-1023 Unused --- 跳级块页格式 每个层级都有其跨度，但并非所有跨度都对应某个层级。\nByte Contents 0-7 Magic 0x42534c6576656c73 (\"BSLevels\") 8-9 Max height 10-11 Current height 12-15 Span page 16-… Next level pages (current height × 4 bytes, lowest first) \u0026mdash; Remaining bytes unused --- 跳过、跨度、块、页面格式 键/值对在所有 span（区段）中按键排序。非第一个 span 不得为空。\nByte Contents 0-3 Magic 0x5370616e (\"Span\") 4-7 First continuation page or 0 8-11 Previous span page or 0 12-15 Next span page or 0 16-17 Max keys (16 for hostsdb) 18-19 Size (current keys) 20-1023 Key/value structures --- Span Continuation Block 页面格式 Byte Contents 0-3 Magic 0x434f4e54 (\"CONT\") 4-7 Next continuation page or 0 8-1023 Key/value structures --- 键值结构格式 键和值的长度字段不得跨页（全部 4 个字节必须位于同一页内）。 如果剩余空间不足，则最多填充 3 个字节，并在下一页的偏移 8 处继续。\nByte Contents 0-1 Key length (bytes) 2-3 Value length (bytes) 4-… Key data → Value data \u0026mdash; Max length = 65535 bytes each --- 空闲列表块页格式 Byte Contents 0-7 Magic 0x2366724c69737423 (\"#frList#\") 8-11 Next free list block or 0 12-15 Number of valid free pages (0 – 252) 16-1023 Free page numbers (4 bytes each) --- 空闲页块格式 Byte Contents 0-7 Magic 0x7e2146524545217e (\"~!FREE!~\") 8-1023 Unused --- 元索引 位于第 2 页。 映射 US-ASCII 字符串 → 4 字节整数。 键为跳表名称；值为页面索引。\nBlockfile（块文件）命名服务数据表 该服务定义了若干个跳表。每个 span（区段）最多支持 16 个条目。\n属性跳表 %%__INFO__%% 包含一个条目：\nKey Value info A Properties object (UTF-8 String / String map) serialized as a Mapping 典型字段： Property Description version \"4\" created Java long (ms since epoch) upgraded Java long (ms since epoch, since DB v2) lists Comma-separated host DBs (e.g. privatehosts.txt,userhosts.txt,hosts.txt) listversion_* Version of each DB (used to detect partial upgrades, since v4) --- 反向查找跳表 %%__REVERSE__%% 包含 Integer → Properties 条目（自 DB v2 起）。\nKey: Destination（I2P 目的地标识）的 SHA-256 哈希的前 4 字节。 Value: Properties 对象（序列化的 Mapping）。 多个条目用于处理哈希冲突和多主机名的 Destination。 每个属性 key = 主机名；value = 空字符串。 主机数据库跳表 每个 hosts.txt、userhosts.txt 和 privatehosts.txt 都将主机名映射到 Destination（I2P 目的地）。\n版本 4 支持每个主机名对应多个 Destination（目标标识）（在 I2P 0.9.26 中引入）。 版本 3 的数据库会自动迁移。\n密钥 UTF-8 字符串 (主机名，小写，以 .i2p 结尾)\n值 版本 4： 1 字节，表示属性/目的地对的数量 对于每一对：属性 → 目的地 (二进制) 版本 3： 属性 → 目的地 (二进制) DestEntry 属性 Key Meaning a Time added (Java long ms) m Last modified (Java long ms) notes User comments s Source (file or subscription URL) v Signature verified (true/false) --- 实现说明 Java 类 BlockfileNamingService 实现了本规范。\n在 router 上下文之外，数据库将以只读方式打开，除非设置了 i2p.naming.blockfile.writeInAppContext=true。 不适用于多实例或多 JVM 访问。 维护三个主要的映射（privatehosts、userhosts、hosts），以及一个用于快速查找的反向映射。 参考资料 I2P 命名与地址簿文档 通用结构规范 Metanotion Blockfile（块文件）数据库 BlockfileNamingService JavaDoc ","description":"I2P 用于主机名解析的基于磁盘的 blockfile（块文件）存储格式","id":"5cbdbb030530ec5e0200cc202d4bff7f","section":"docs","title":"Blockfile（块文件）规范","url":"/zh/docs/specs/blockfile/"},{"categories":null,"content":" 警告： BOB 仅支持旧版 DSA-SHA1 签名类型。Java I2P 自 1.7.0（2022-02）起不再随附 BOB；它仅在最初从 1.6.1 或更早版本开始的安装中，以及某些 i2pd 构建中仍然存在。新的应用程序必须使用 SAM v3 。\n语言绑定 Go 语言 – ccondom Python – i2py-bob Twisted – txi2p C++ – bobcpp 协议说明 KEYS 表示一个 base64 destination（目标地址，公钥 + 私钥）。 KEY 是一个 base64 公钥。 ERROR 响应的格式为 ERROR \u0026lt;description\u0026gt;\\n。 OK 表示命令已完成；可选数据紧随其后，位于同一行。 DATA 行会在最终的 OK 之前流式输出额外内容。 help 命令是唯一的例外：它可能什么也不返回，以表示“无此命令”。\n连接横幅 BOB 使用以换行符结尾的 ASCII 行（LF 或 CRLF）。建立连接时它会输出：\nBOB \u0026lt;version\u0026gt; OK 当前版本：00.00.10。早期构建使用大写十六进制数字和非标准编号。\nBOB Version Router Version Notes 00.00.100.9.8Latest defined version 00.00.00 – 00.00.0F—Development builds ## 核心命令 如需完整的命令详情，请使用 telnet localhost 2827 进行连接并运行 help。\nCOMMAND OPERAND RETURNS help [command] NOTHING | OK \u0026lt;info\u0026gt; clear ERROR | OK getdest ERROR | OK \u0026lt;KEY\u0026gt; getkeys ERROR | OK \u0026lt;KEYS\u0026gt; getnick \u0026lt;tunnelname\u0026gt; ERROR | OK inhost \u0026lt;hostname | IP\u0026gt; ERROR | OK inport \u0026lt;port\u0026gt; ERROR | OK list ERROR | DATA... + OK lookup \u0026lt;hostname\u0026gt; ERROR | OK \u0026lt;KEY\u0026gt; nick \u0026lt;friendlyname\u0026gt; ERROR | OK outhost \u0026lt;hostname | IP\u0026gt; ERROR | OK outport \u0026lt;port\u0026gt; ERROR | OK quit ERROR | OK setkey \u0026lt;base64 destination\u0026gt; ERROR | OK start ERROR | OK status ERROR | DATA... + OK stop ERROR | OK 弃用摘要 BOB 不支持现代签名类型、加密的 LeaseSets（租约集）以及传输层特性。 API 已冻结；不会再添加新的命令。 仍依赖 BOB 的应用应尽快迁移到 SAM v3。 ","description":"用于目标管理的已弃用 API（已弃用）","id":"97b881216518f8e2516b859bbca19c0b","section":"docs","title":"BOB – 基本开放桥","url":"/zh/docs/legacy/bob/"},{"categories":null,"content":"实现状态 当前部署: - i2pd (C++ 实现): 已在版本 2.58.0 (2025 年 9 月) 中完整实现，并支持 ML-KEM-512、ML-KEM-768 和 ML-KEM-1024。当可用 OpenSSL 3.5.0 或更高版本时，默认启用后量子端到端加密。 - Java I2P: 截至版本 0.9.67 / 2.10.0 (2025 年 9 月) 尚未实现。规范已获批准，计划在未来版本中实现。\n本规范描述了已获批准的功能，这些功能目前已在 i2pd 部署，并计划在 Java I2P 实现中采用。\n概述 这是 ECIES-X25519-AEAD-Ratchet 协议 ECIES 的后量子混合变体。它是有待批准的提案 169 Prop169 的第一阶段。有关总体目标、威胁模型、分析、替代方案及更多信息，请参阅该提案。\n提案 169 状态：开放 (混合 ECIES（椭圆曲线集成加密方案）实现的第一阶段已获批准).\n本规范仅包含相对于标准 ECIES （椭圆曲线集成加密方案）的差异，必须与该规范一并阅读。\n设计 我们使用 NIST FIPS 203 标准 FIPS203 ，该标准以 CRYSTALS-Kyber 为基础，但与其不兼容（版本 3.1、3 以及更早版本）。\n混合握手将经典的 X25519 Diffie-Hellman 与后量子 ML-KEM 密钥封装机制（NIST 后量子密钥封装标准，原名 Kyber）相结合。这种方法基于 PQNoise（关于混合前向保密的研究）中记录的混合前向保密概念，以及在 TLS 1.3、IKEv2 和 WireGuard 中的类似实现。\n密钥交换 我们为 Ratchet（棘轮机制）定义了一种混合密钥交换。后量子 KEM（密钥封装机制）仅提供临时密钥，并不直接支持诸如 Noise IK 之类的静态密钥握手。\n我们按照 FIPS203 的规定定义三种 ML-KEM（基于模块格的密钥封装机制）变体，共计新增 3 种加密类型。混合类型仅在与 X25519（椭圆曲线 Diffie–Hellman 密钥交换算法的一种实现）组合时定义。\n新的加密类型为：\nType Code Security Level ML-KEM Variant MLKEM512_X25519 5 NIST Category 1 (AES-128 equivalent) ML-KEM-512 MLKEM768_X25519 6 NIST Category 3 (AES-192 equivalent) ML-KEM-768 (Recommended) MLKEM1024_X25519 7 NIST Category 5 (AES-256 equivalent) ML-KEM-1024 **注意：** MLKEM768_X25519（Type 6）是推荐的默认变体，在合理开销下提供强大的后量子安全性。 与仅使用 X25519 的加密相比，额外开销相当可观。针对 IK 模式，消息 1 和 2 的典型大小目前约为 96-103 字节（不含额外负载）。根据消息类型不同，这一数值在 MLKEM512 情况下将增加约 9-12 倍，在 MLKEM768 情况下增加约 13-16 倍，在 MLKEM1024 情况下增加约 17-23 倍。\n需要新的加密技术 ML-KEM（原名 CRYSTALS-Kyber）FIPS203 - 基于模格的密钥封装机制标准 SHA3-256（原名 Keccak-512）FIPS202 - SHA-3 标准的一部分 SHAKE128 和 SHAKE256（SHA3 的 XOF（可扩展输出函数）扩展）FIPS202 - 可扩展输出函数 SHA3-256、SHAKE128 和 SHAKE256 的测试向量可在 NIST 加密算法验证计划 中获取。\n库支持: - Java: Bouncycastle 库 1.79 及以上版本支持所有 ML-KEM（模块格密钥封装机制）变体以及 SHA3/SHAKE 函数 - C++: OpenSSL 3.5 及以上版本包含对 ML-KEM 的完整支持（于 2025 年 4 月发布） - Go: 有多种库可用于 ML-KEM 和 SHA3 的实现\n规范 通用结构 有关密钥长度和标识符，请参阅通用结构规范 。\n握手模式 握手使用 Noise Protocol Framework （Noise 协议框架）的握手模式，并结合针对 I2P 的特定改动，以实现混合式后量子安全性。\n使用以下字母映射：\ne = 一次性临时密钥（X25519） s = 静态密钥 p = 消息负载 e1 = 一次性临时 PQ（后量子）密钥，从 Alice 发送给 Bob（I2P 特定的令牌） ekem1 = KEM（密钥封装机制）密文，从 Bob 发送给 Alice（I2P 特定的令牌） 重要说明： 模式名称 \u0026ldquo;IKhfs\u0026rdquo; 和 \u0026ldquo;IKhfselg2\u0026rdquo; 以及标记 \u0026ldquo;e1\u0026rdquo; 和 \u0026ldquo;ekem1\u0026rdquo; 是 I2P 特定的适配，未记录于官方 Noise 协议框架规范中。这些表示为将 ML-KEM（模块格密钥封装机制）集成到 Noise IK 模式而做的自定义定义。尽管混合的 X25519 + ML-KEM 方案在后量子密码学研究和其他协议中广为认可，但此处使用的特定命名法是 I2P 特有的。\n将以下修改应用于 IK，以实现混合前向保密：\nStandard IK: I2P IKhfs (Hybrid): \u0026lt;- s \u0026lt;- s ... ... -\u0026gt; e, es, s, ss, p -\u0026gt; e, es, e1, s, ss, p \u0026lt;- e, ee, se, p \u0026lt;- e, ee, ekem1, se, p \u0026lt;- p \u0026lt;- p p -\u0026gt; p -\u0026gt; Note: e1 and ekem1 are encrypted within ChaCha20-Poly1305 AEAD blocks. Note: e1 (ML-KEM public key) and ekem1 (ML-KEM ciphertext) have different sizes. e1 模式定义如下：\nFor Alice (sender): (encap_key, decap_key) = PQ_KEYGEN() // EncryptAndHash(encap_key) ciphertext = ENCRYPT(k, n, encap_key, ad) n++ MixHash(ciphertext) For Bob (receiver): // DecryptAndHash(ciphertext) encap_key = DECRYPT(k, n, ciphertext, ad) n++ MixHash(ciphertext) ekem1 模式定义如下：\nFor Bob (receiver of encap_key): (kem_ciphertext, kem_shared_key) = ENCAPS(encap_key) // EncryptAndHash(kem_ciphertext) ciphertext = ENCRYPT(k, n, kem_ciphertext, ad) MixHash(ciphertext) // MixKey MixKey(kem_shared_key) For Alice (sender of encap_key): // DecryptAndHash(ciphertext) kem_ciphertext = DECRYPT(k, n, ciphertext, ad) MixHash(ciphertext) // MixKey kem_shared_key = DECAPS(kem_ciphertext, decap_key) MixKey(kem_shared_key) 定义的 ML-KEM（基于模块格的密钥封装机制）操作 我们定义以下函数，它们对应于 FIPS203 所规定的密码学构建模块。\n(encap_key, decap_key) = PQ_KEYGEN() : Alice 生成封装密钥和解封装密钥。封装密钥在 NS 消息中发送。密钥大小： - ML-KEM-512: encap_key = 800 字节, decap_key = 1632 字节 - ML-KEM-768: encap_key = 1184 字节, decap_key = 2400 字节 - ML-KEM-1024: encap_key = 1568 字节, decap_key = 3168 字节\n(ciphertext, kem_shared_key) = ENCAPS(encap_key) : Bob 使用在 NS 消息中收到的封装密钥计算密文和共享密钥。密文在 NSR 消息中发送。密文大小: - ML-KEM-512: 768 字节 - ML-KEM-768: 1088 字节 - ML-KEM-1024: 1568 字节\nkem_shared_key 在所有三种变体中始终为 32 字节。\nkem_shared_key = DECAPS(ciphertext, decap_key) : Alice 使用在 NSR 消息中收到的密文计算共享密钥。kem_shared_key 始终为 32 字节。\n重要： encap_key 和 ciphertext 都在 Noise（加密握手协议框架）的握手消息 1 和 2 中的 ChaCha20-Poly1305 块内被加密。它们会作为握手过程的一部分被解密。\n使用 MixKey() 将 kem_shared_key 混入链密钥。详见下文。\nNoise 握手的密钥派生函数 概述 混合握手将经典的 X25519 ECDH（椭圆曲线 Diffie-Hellman）与后量子 ML-KEM（密钥封装机制）相结合。第一条消息（从 Alice 发往 Bob）在消息载荷之前包含 e1（ML-KEM 封装密钥）。将其视为额外的密钥材料；对其调用 EncryptAndHash()（作为 Alice）或 DecryptAndHash()（作为 Bob）。然后按常规处理消息载荷。\n第二条消息（从 Bob 发往 Alice）在消息负载之前包含 ekem1（ML-KEM 密文）。将其视为额外的密钥材料；对其调用 EncryptAndHash()（作为 Bob）或 DecryptAndHash()（作为 Alice）。随后计算 kem_shared_key，并调用 MixKey(kem_shared_key)。然后照常处理消息负载。\nNoise 标识符 这些是 Noise（加密握手协议框架）初始化字符串（I2P 专用）：\nNoise_IKhfselg2_25519+MLKEM512_ChaChaPoly_SHA256 Noise_IKhfselg2_25519+MLKEM768_ChaChaPoly_SHA256 Noise_IKhfselg2_25519+MLKEM1024_ChaChaPoly_SHA256 用于 NS 消息的 Alice 端 KDF（密钥派生函数） 在 \u0026rsquo;es\u0026rsquo; 消息模式之后、\u0026rsquo;s\u0026rsquo; 消息模式之前，添加：\nThis is the \u0026#34;e1\u0026#34; message pattern: (encap_key, decap_key) = PQ_KEYGEN() // EncryptAndHash(encap_key) // AEAD parameters k = keydata[32:63] n = 0 ad = h ciphertext = ENCRYPT(k, n, encap_key, ad) n++ // MixHash(ciphertext) h = SHA256(h || ciphertext) End of \u0026#34;e1\u0026#34; message pattern. NOTE: For the next section (payload for XK or static key for IK), the keydata and chain key remain the same, and n now equals 1 (instead of 0 for non-hybrid). Bob 端 NS 消息的密钥派生函数 在 \u0026rsquo;es\u0026rsquo; 消息模式之后，并在 \u0026rsquo;s\u0026rsquo; 消息模式之前，添加：\nThis is the \u0026#34;e1\u0026#34; message pattern: // DecryptAndHash(encap_key_section) // AEAD parameters k = keydata[32:63] n = 0 ad = h encap_key = DECRYPT(k, n, encap_key_section, ad) n++ // MixHash(encap_key_section) h = SHA256(h || encap_key_section) End of \u0026#34;e1\u0026#34; message pattern. NOTE: For the next section (payload for XK or static key for IK), the keydata and chain key remain the same, and n now equals 1 (instead of 0 for non-hybrid). 用于 NSR 消息的 Bob 侧 KDF（密钥派生函数） 在 \u0026rsquo;ee\u0026rsquo; 消息模式之后、\u0026lsquo;se\u0026rsquo; 消息模式之前，添加：\nThis is the \u0026#34;ekem1\u0026#34; message pattern: (kem_ciphertext, kem_shared_key) = ENCAPS(encap_key) // EncryptAndHash(kem_ciphertext) // AEAD parameters k = keydata[32:63] n = 0 ad = h ciphertext = ENCRYPT(k, n, kem_ciphertext, ad) // MixHash(ciphertext) h = SHA256(h || ciphertext) // MixKey(kem_shared_key) keydata = HKDF(chainKey, kem_shared_key, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] End of \u0026#34;ekem1\u0026#34; message pattern. 用于 NSR 消息的 Alice KDF（密钥派生函数） 在 \u0026rsquo;ee\u0026rsquo; 消息模式之后且在 \u0026lsquo;ss\u0026rsquo; 消息模式之前，添加：\nThis is the \u0026#34;ekem1\u0026#34; message pattern: // DecryptAndHash(kem_ciphertext_section) // AEAD parameters k = keydata[32:63] n = 0 ad = h kem_ciphertext = DECRYPT(k, n, kem_ciphertext_section, ad) // MixHash(kem_ciphertext_section) h = SHA256(h || kem_ciphertext_section) // MixKey(kem_shared_key) kem_shared_key = DECAPS(kem_ciphertext, decap_key) keydata = HKDF(chainKey, kem_shared_key, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] End of \u0026#34;ekem1\u0026#34; message pattern. 用于 split() 的密钥派生函数 split() 函数保持与标准 ECIES（椭圆曲线集成加密方案）规范一致，未作改动。握手完成后：\nkeydata = HKDF(chainKey, ZEROLEN, \u0026#34;\u0026#34;, 64) k_ab = keydata[0:31] k_ba = keydata[32:63] 这些是用于持续通信的双向会话密钥。\n消息格式 NS (New Session，新会话) 格式 Changes: 当前的棘轮在第一个 ChaCha20-Poly1305 部分中包含静态密钥，在第二个部分中包含有效载荷。随着 ML-KEM 的引入，现在有三个部分。第一部分包含加密的 ML-KEM 公钥（encap_key）。第二部分包含静态密钥。第三部分包含有效载荷。\n消息大小：\nType Type Code X25519 len NS len NS Enc len NS Dec len PQ key len pl len X25519 4 32 96+pl 64+pl pl -- pl MLKEM512_X25519 5 32 912+pl 880+pl 800+pl 800 pl MLKEM768_X25519 6 32 1296+pl 1264+pl 1184+pl 1184 pl MLKEM1024_X25519 7 32 1680+pl 1648+pl 1568+pl 1568 pl **注意：** 负载必须包含一个 DateTime 块（日期时间块）（最少 7 字节：1 字节类型、2 字节大小、4 字节时间戳）。因此，可以相应地计算出 NS 的最小大小。由此，X25519 的可用最小 NS 大小为 103 字节，而混合变体范围为 919 到 1687 字节。 对于三个 ML-KEM 变体，大小分别增加 816、1200 和 1584 字节，这些增加量由 ML-KEM 公钥以及用于认证加密的 16 字节 Poly1305 消息认证码（MAC）共同构成。\nNSR（New Session Reply，新会话应答）格式 变更： 当前的 ratchet（密钥棘轮）在第一个 ChaCha20-Poly1305 部分的负载为空，负载位于第二个部分。引入 ML-KEM 后，现在有三个部分。第一部分包含加密的 ML-KEM 密文。第二部分的负载为空。第三部分包含负载。\n消息大小：\nType Type Code X25519 len NSR len NSR Enc len NSR Dec len PQ ct len pl len X25519 4 32 72+pl 40+pl pl -- pl MLKEM512_X25519 5 32 856+pl 824+pl 784+pl 768 pl MLKEM768_X25519 6 32 1176+pl 1144+pl 1104+pl 1088 pl MLKEM1024_X25519 7 32 1656+pl 1624+pl 1584+pl 1568 pl 对于三种 ML-KEM（基于模格的密钥封装机制）变体，大小分别增加 784、1104 和 1584 字节；这些增量由 ML-KEM 密文以及用于认证加密的 16 字节 Poly1305 消息认证码（MAC）共同构成。 开销分析 密钥交换 与仅使用 X25519 相比，混合加密的开销相当可观：\nMLKEM512_X25519: 握手消息大小约增加 9-12 倍 (NS: 9.5 倍, NSR: 11.9 倍) MLKEM768_X25519: 握手消息大小约增加 13-16 倍 (NS: 13.5 倍, NSR: 16.3 倍) MLKEM1024_X25519: 握手消息大小约增加 17-23 倍 (NS: 17.5 倍, NSR: 23 倍) 为获得后量子安全带来的额外收益，这种开销是可以接受的。由于基础消息大小不同，各消息类型的倍率也会有所不同（NS 最小为 96 字节，NSR 最小为 72 字节）。\n带宽注意事项 对于典型的会话建立且负载最小的场景： - 仅 X25519：总计 ~200 字节（NS + NSR） - MLKEM512_X25519：总计 ~1,800 字节（增长 9 倍） - MLKEM768_X25519：总计 ~2,500 字节（增长 12.5 倍） - MLKEM1024_X25519：总计 ~3,400 字节（增长 17 倍）\n在会话建立之后，后续的消息加密使用与仅使用 X25519 的会话相同的数据传输格式，因此不会给后续消息带来额外开销。\n安全分析 握手 混合握手同时提供经典（X25519）与后量子（ML-KEM）的安全性。攻击者必须破解两者：经典的ECDH（椭圆曲线Diffie-Hellman）和后量子的KEM（密钥封装机制），才能危及会话密钥。\n这提供： - 当前安全性：X25519 ECDH 可抵御传统攻击者（128 位安全级别） - 未来安全性：ML-KEM（模块格密钥封装机制）可抵御量子攻击者（因参数集而异） - 混合安全性：要危及会话，必须同时攻破二者（安全级别 = 两者中的最大值）\n安全级别 Variant NIST Category Classical Security PQ Security Hybrid Security MLKEM512_X25519 Category 1 128-bit (X25519) AES-128 equivalent 128-bit MLKEM768_X25519 Category 3 128-bit (X25519) AES-192 equivalent 128-bit MLKEM1024_X25519 Category 5 128-bit (X25519) AES-256 equivalent 128-bit **注意：** 混合安全级别受两种组成部分中较弱者所限制。在所有情况下，X25519（基于 Curve25519 的椭圆曲线 Diffie-Hellman 密钥交换算法）提供 128 位经典安全性。若出现具备密码学相关能力的量子计算机，安全级别将取决于所选择的 ML-KEM（基于模格的密钥封装机制，NIST 标准 Kyber）参数集。 前向保密 这种混合方案保持了前向保密性。会话密钥由临时的 X25519 和临时的 ML-KEM（模块格密钥封装机制，后量子密钥封装算法）密钥交换共同导出。只要在握手后销毁 X25519 或 ML-KEM 的临时私钥，即使长期静态密钥被泄露，过去的会话也无法被解密。\n在第二个消息（NSR）发送后，IK 模式即可提供完全的前向保密（Noise Confidentiality level 5，Noise 协议的机密性等级 5）。\n类型首选项 实现应支持多种混合类型，并协商选择双方共同支持的最强变体。偏好顺序应为：\nMLKEM768_X25519 (后量子密钥封装机制（KEM）与 X25519 的混合密钥交换套件) (Type 6) - 推荐的默认选项，安全性与性能的最佳平衡 MLKEM1024_X25519 (Type 7) - 适用于敏感应用的最高安全性 MLKEM512_X25519 (Type 5) - 面向资源受限场景的基础级后量子安全 X25519 (Type 4) - 仅经典算法，用于兼容性的回退选项 理由: 推荐将 MLKEM768_X25519 作为默认选项，因为它提供 NIST 第3类安全性（等效于 AES-192），在对抗量子计算机方面被认为足够，同时还能保持合理的消息大小。MLKEM1024_X25519 提供更高的安全性，但开销会显著增加。\n实现说明 库支持 Java：Bouncycastle 库 1.79 版（2024 年 8 月）及更高版本支持所有所需的 ML-KEM（模块格密钥封装机制）变体和 SHA3/SHAKE 函数。为符合 FIPS 203，请使用 org.bouncycastle.pqc.crypto.mlkem.MLKEMEngine。 C++：OpenSSL 3.5（2025 年 4 月）及之后的版本通过 EVP_KEM 接口包含对 ML-KEM 的支持。该版本为长期支持（LTS）版本，维护至 2030 年 4 月。 Go：有多种第三方库可用于 ML-KEM 和 SHA3，其中包括 Cloudflare 的 CIRCL 库。 迁移策略 实现应：1. 在过渡期内同时支持 X25519-only 和混合 ML-KEM（模块格密钥封装机制）变体 2. 当双方对等节点都支持时优先选择混合变体 3. 为向后兼容保留回退到 X25519-only 4. 在选择默认变体时考虑网络带宽约束\n共享 Tunnels 消息大小的增加可能会影响共享 tunnel 的使用。实现应考虑： - 在可能的情况下将握手批量处理，以摊平开销 - 对混合会话使用更短的到期时间，以减少已存储的状态 - 监控带宽使用情况并相应调整参数 - 对会话建立流量实施拥塞控制\n新会话大小注意事项 由于握手消息更大，各实现可能需要： - 增加用于会话协商的缓冲区大小（建议至少 4KB） - 为较慢的连接调整超时值（考虑到消息大小约为原来的 ~3–17 倍） - 考虑对 NS/NSR 消息中的有效载荷数据进行压缩 - 如果传输层需要，实现分片处理\n测试与验证 实现应验证: - 正确的 ML-KEM（密钥封装机制）密钥生成、封装与解封装 - 将 kem_shared_key 正确集成到 Noise KDF（密钥派生函数）中 - 消息大小的计算与规范相一致 - 与其他 I2P router 实现的互操作性 - 当 ML-KEM 不可用时的回退行为\n用于 ML-KEM（模块格密钥封装机制）操作的测试向量可在 NIST 加密算法验证计划 中获得。\n版本兼容性 I2P 版本编号： I2P 采用两套并行的版本号： - Router 发行版本: 2.x.x 格式（例如，2.10.0 于 2025 年 9 月发布） - API/协议版本: 0.9.x 格式（例如，0.9.67 对应于 router 2.10.0）\n本规范参考协议版本 0.9.67，对应于 router 发布版本 2.10.0 及更高版本。\n兼容性矩阵：\nImplementation Version ML-KEM Support Status i2pd 2.58.0+ Full (512/768/1024) Deployed September 2025 Java I2P 0.9.67 / 2.10.0 Not yet Planned for future release ## 参考资料 [ECIES]: ECIES-X25519-AEAD-Ratchet 规范 [Prop169]: 提案 169：后量子密码学 [FIPS203]: NIST FIPS 203 - ML-KEM 标准 [FIPS202]: NIST FIPS 202 - SHA-3 标准 [Noise]: Noise 协议框架 [COMMON]: 通用结构规范 [RFC7539]: RFC 7539 - ChaCha20 与 Poly1305 [RFC5869]: RFC 5869 - HKDF [OpenSSL]: OpenSSL 3.5 ML-KEM 文档 [Bouncycastle]: Bouncycastle Java 加密库 ","description":"采用 ML-KEM（基于格的密钥封装机制）的 ECIES 加密协议的后量子混合变体","id":"f6a66a37875c5b108bc5a8ea027dc0e2","section":"docs","title":"ECIES-X25519-AEAD-Ratchet 混合加密","url":"/zh/docs/specs/ecies-hybrid/"},{"categories":null,"content":"概览 目的 ECIES-X25519-AEAD-Ratchet 是 I2P 的现代端到端加密协议（基于 ECIES、X25519 与 AEAD，并采用 Ratchet（棘轮）机制），用于取代旧版 ElGamal/AES+SessionTags 系统（基于 ElGamal 与 AES 并使用 SessionTags 的旧方案）。它提供前向保密性、认证加密，并在性能和安全性方面带来显著改进。\n相较于 ElGamal/AES+SessionTags（会话标签）的关键改进 更小的密钥：32 字节密钥，对比 256 字节的 ElGamal 公钥（减少 87.5%） 前向保密性：通过 DH（Diffie–Hellman）棘轮实现（旧协议不支持） 现代密码学：X25519 DH，ChaCha20-Poly1305 AEAD（带关联数据的认证加密），SHA-256 认证加密：通过 AEAD 构造内置认证 双向协议：配对的入站/出站会话，对比单向的旧版协议 高效标签：8 字节会话标签，对比 32 字节标签（减少 75%） 流量混淆：Elligator2 编码（将椭圆曲线点伪装为随机比特串）使握手与随机数据不可区分 部署状态 初始发布: 版本 0.9.46 (2020 年 5 月 25 日) 网络部署: 截至 2020 年已完成 当前状态: 成熟，已广泛部署 (在生产环境运行 5 年以上) Router 支持: 需要 0.9.46 或更高版本 Floodfill 要求 (netDb 中的洪泛节点): 加密查询需要接近 100% 的采用率 实现状态 已完全实现: - 带绑定的 New Session (NS) 消息 - New Session Reply (NSR) 消息 - Existing Session (ES) 消息 - DH ratchet 机制（基于 Diffie-Hellman 的棘轮） - Session tag 和 symmetric key 棘轮 - DateTime、NextKey、ACK、ACK Request、Garlic Clove（I2P garlic encryption 中的子消息“蒜瓣”）和 Padding 块\n未实现 (截至 0.9.50 版本): - MessageNumbers 块 (类型 6) - Options 块 (类型 5) - Termination 块 (类型 4) - 协议层自动响应 - 零静态密钥模式 - 多播会话\n注意：版本 1.5.0 至 2.10.0（2021–2025）的实现状态需要核实，因为可能新增了一些功能。\n协议基础 Noise 协议框架 ECIES-X25519-AEAD-Ratchet 基于 Noise Protocol Framework（噪声协议框架） （修订版 34，2018-07-11），具体采用带有 I2P 特定扩展的 IK（交互式，已知远端静态密钥）握手模式。\nNoise 协议标识符 Noise_IKelg2+hs2_25519_ChaChaPoly_SHA256 标识符组件: - Noise - 基础框架 - IK - 带有已知远端静态密钥的交互式握手模式 - elg2 - 用于临时密钥的 Elligator2 编码 (I2P 扩展) - +hs2 - 在第二条消息之前调用 MixHash 以混入标签 (I2P 扩展) - 25519 - X25519 Diffie-Hellman 函数 - ChaChaPoly - ChaCha20-Poly1305 AEAD 密码 - SHA256 - SHA-256 哈希函数\nNoise 握手模式 IK 模式表示法:\n\u0026lt;- s (Bob\u0026#39;s static key known to Alice) ... -\u0026gt; e, es, s, ss (Alice sends ephemeral, DH es, static key, DH ss) \u0026lt;- e, ee, se (Bob sends ephemeral, DH ee, DH se) 记号含义: - e - 临时密钥传输 - s - 静态密钥传输 - es - Alice 的临时密钥与 Bob 的静态密钥之间的 DH（Diffie-Hellman 密钥交换） - ss - Alice 的静态密钥与 Bob 的静态密钥之间的 DH - ee - Alice 的临时密钥与 Bob 的临时密钥之间的 DH - se - Bob 的静态密钥与 Alice 的临时密钥之间的 DH\nNoise 安全属性 使用 Noise（加密协议框架）的术语，IK pattern（IK 握手模式）提供：\nMessage Authentication Level Confidentiality Level Message\u0026nbsp;1 (NS) Level\u0026nbsp;1 (sender auth, KCI vulnerable) Level\u0026nbsp;2 (weak forward secrecy) Message\u0026nbsp;2 (NSR) Level\u0026nbsp;2 (mutual auth) Level\u0026nbsp;4 (weak forward secrecy) Transport (ES) Level\u0026nbsp;2 (mutual auth) Level\u0026nbsp;5 (strong forward secrecy) **认证级别：** - **第 1 级**：有效负载被认证为属于发送方静态密钥的所有者，但仍易受 Key Compromise Impersonation (KCI，密钥泄露后冒充) 攻击 - **第 2 级**：在 NSR 之后能够抵抗 KCI 攻击 机密性级别： - 第 2 级: 如果发送方的静态密钥随后被泄露，仍能提供前向保密性 - 第 4 级: 如果发送方的临时密钥随后被泄露，仍能提供前向保密性 - 第 5 级: 在双方的临时密钥均被删除后，提供完全的前向保密性\nIK 与 XK 的差异 IK 模式不同于 NTCP2 和 SSU2 中使用的 XK 模式：\n四次 DH 运算: IK（Noise 握手模式）使用 4 次 DH（Diffie-Hellman）运算（es, ss, ee, se），而 XK（Noise 握手模式）为 3 次 即时认证: Alice 在第一条消息中即完成认证（认证级别 1） 更快的前向保密性: 在第二条消息后（1-RTT）达到完全的前向保密性（级别 5） 权衡: 第一条消息的负载不具备前向保密性（相比之下，XK 的所有负载均具备前向保密性） 摘要: IK（Noise 协议中的握手模式）使得 Bob 的响应可以在 1-RTT（一轮往返时延）内送达并具备完全的前向保密性，但代价是初始请求不具备前向保密性。\nSignal Double Ratchet（双棘轮）概念 ECIES（椭圆曲线集成加密方案）融入了来自 Signal 双重棘轮算法 的概念：\nDH 棘轮: 通过定期交换新的 DH 密钥提供前向保密性 对称密钥棘轮: 为每条消息派生新的会话密钥 会话标签棘轮: 以确定性方式生成一次性使用的会话标签 与 Signal 的关键差异： - 棘轮更新频率更低：I2P 仅在需要时执行棘轮更新（当标签接近耗尽或按策略） - 使用会话标签替代头部加密：使用确定性的标签，而非加密的头部 - 显式 ACK（确认）：使用带内的 ACK 块，而非仅依赖反向流量 - 标签棘轮与密钥棘轮分离：对接收方更高效（可延迟密钥计算）\nI2P 对 Noise 协议框架的扩展 Elligator2 Encoding（将椭圆曲线点编码为类随机字节的算法）: 将临时密钥编码为与随机数不可区分 在 NSR 前置标签: 在 NSR 消息前添加 Session tag（会话标签），用于关联 定义的负载格式: 针对所有消息类型的基于块的负载结构 I2NP 封装: 所有消息都封装在 I2NP Garlic Message（大蒜消息）头部中 独立的数据阶段: 传输消息（ES，一种传输消息类型）偏离标准的 Noise（Noise 协议框架）数据阶段 密码学原语 X25519 迪菲-赫尔曼 规范： RFC 7748 关键属性: - 私钥大小: 32 字节 - 公钥大小: 32 字节 - 共享密钥大小: 32 字节 - 字节序: 小端序 - 曲线: Curve25519\n操作：\nX25519 GENERATE_PRIVATE()（生成私钥） 生成一个随机的 32 字节私钥：\nprivkey = CSRNG(32) X25519 DERIVE_PUBLIC(privkey) 派生出相应的公钥：\npubkey = curve25519_scalarmult_base(privkey) 返回以小端字节序表示的 32 字节公钥。\nX25519 DH(privkey, pubkey)（DH：Diffie-Hellman 密钥交换） 执行 Diffie-Hellman 密钥协商：\nsharedSecret = curve25519_scalarmult(privkey, pubkey) 返回 32 字节的共享密钥。\n安全注意: 实现方必须验证共享秘密不是全零（弱密钥）。如出现这种情况，应拒绝并中止握手。\nChaCha20-Poly1305 AEAD（带关联数据的认证加密） 规范: RFC 7539 第2.8节\n参数: - 密钥长度: 32 字节 (256 位) - 随机数大小: 12 字节 (96 位) - MAC 大小: 16 字节 (128 位) - 块大小: 64 字节 (内部)\n随机数格式:\nByte 0-3: 0x00 0x00 0x00 0x00 (always zero) Byte 4-11: Little-endian counter (message number N) AEAD（带关联数据的认证加密）构造：\nAEAD（带关联数据的认证加密）将 ChaCha20 流密码与 Poly1305 MAC（消息认证码）结合起来：\n从密钥和 nonce (一次性随机数) 生成 ChaCha20 密钥流 将明文与密钥流进行异或加密 对 (关联数据 || 密文) 计算 Poly1305 MAC 将 16 字节的 MAC 附加到密文之后 ChaCha20-Poly1305 加密(k, n, plaintext, ad) 对明文进行认证加密：\n# Inputs k = 32-byte cipher key n = 12-byte nonce (first 4 bytes zero, last 8 bytes = message number) plaintext = data to encrypt (0 to 65519 bytes) ad = associated data (optional, used in MAC calculation) # Output ciphertext = chacha20_encrypt(k, n, plaintext) mac = poly1305(ad || ciphertext, poly1305_key_gen(k, n)) return ciphertext || mac # Total length = len(plaintext) + 16 属性： - 密文与明文长度相同（流密码） - 输出为 plaintext_length + 16 字节（包含 MAC） - 如果密钥是保密的，则整个输出与随机数据无法区分 - MAC（消息认证码）同时认证关联数据和密文\nChaCha20-Poly1305 解密(k, n, ciphertext, ad) 解密并验证认证信息：\n# Split ciphertext and MAC ct_without_mac = ciphertext[0:-16] received_mac = ciphertext[-16:] # Verify MAC expected_mac = poly1305(ad || ct_without_mac, poly1305_key_gen(k, n)) if not constant_time_compare(received_mac, expected_mac): raise AuthenticationError(\u0026#34;MAC verification failed\u0026#34;) # Decrypt plaintext = chacha20_decrypt(k, n, ct_without_mac) return plaintext 关键安全要求：\n对于在相同密钥下的每条消息，Nonces（一次性随机数）必须保持唯一 Nonces 绝不能被重用（重用将导致灾难性失败） MAC（消息认证码）验证必须使用常数时间比较，以防止时间侧信道攻击 MAC 验证失败时必须完全拒绝该消息（不得进行任何部分解密） SHA-256 哈希函数 规范: NIST FIPS 180-4\n属性: - 输出大小: 32 字节 (256 位) - 块大小: 64 字节 (512 位) - 安全级别: 128 位 (抗碰撞性)\n操作：\n对 H(p, d) 进行 SHA-256 哈希 带个性化字符串的 SHA-256 哈希:\nH(p, d) := SHA256(p || d) 其中 || 表示拼接，p 为个性化字符串，d 为数据。\nSHA-256 MixHash(d) 使用新数据更新 running hash（可增量更新的哈希）:\nh = SHA256(h || d) 在整个 Noise 握手过程中用于维护握手记录哈希。\nHKDF 密钥派生 规范: RFC 5869 描述: 基于 HMAC 的密钥派生函数，使用 SHA-256\n参数: - 哈希函数: HMAC-SHA256 - 盐长度: 最多 32 字节 (SHA-256 输出大小) - 输出长度: 可变 (最多 255 * 32 字节)\nHKDF 函数：\ndef HKDF(salt, ikm, info, length): \u0026#34;\u0026#34;\u0026#34; Args: salt: Salt value (32 bytes max for SHA-256) ikm: Input key material (any length) info: Context-specific info string length: Desired output length in bytes Returns: output: Derived key material (length bytes) \u0026#34;\u0026#34;\u0026#34; # Extract phase prk = HMAC-SHA256(salt, ikm) # Expand phase n = ceil(length / 32) t = b\u0026#39;\u0026#39; okm = b\u0026#39;\u0026#39; for i in range(1, n + 1): t = HMAC-SHA256(prk, t || info || byte(i)) okm = okm || t return okm[0:length] 常见使用模式：\n# Generate two keys (64 bytes total) keydata = HKDF(chainKey, sharedSecret, \u0026#34;KDFDHRatchetStep\u0026#34;, 64) nextRootKey = keydata[0:31] chainKey = keydata[32:63] # Generate session tag (8 bytes) tagdata = HKDF(chainKey, CONSTANT, \u0026#34;SessionTagKeyGen\u0026#34;, 64) nextChainKey = tagdata[0:31] sessionTag = tagdata[32:39] # Generate symmetric key (32 bytes) keydata = HKDF(chainKey, ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) nextChainKey = keydata[0:31] sessionKey = keydata[32:63] ECIES 中使用的信息字符串: - \u0026quot;KDFDHRatchetStep\u0026quot; - DH ratchet（棘轮）密钥派生 - \u0026quot;TagAndKeyGenKeys\u0026quot; - 初始化 tag（标签）和密钥链密钥 - \u0026quot;STInitialization\u0026quot; - 会话标签棘轮初始化 - \u0026quot;SessionTagKeyGen\u0026quot; - 会话标签生成 - \u0026quot;SymmetricRatchet\u0026quot; - 对称密钥生成 - \u0026quot;XDHRatchetTagSet\u0026quot; - DH 棘轮 tagset（标签集）密钥 - \u0026quot;SessionReplyTags\u0026quot; - NSR tagset 生成 - \u0026quot;AttachPayloadKDF\u0026quot; - NSR 负载密钥派生\nElligator2（将椭圆曲线点伪装为均匀随机字节串的方案）编码 用途: 将 X25519 公钥编码，使其与均匀随机的长度为 32 字节的字节串不可区分。\n规范: Elligator2 论文 问题：标准的 X25519 公钥具有可识别的结构。即使内容已被加密，观察者也可以通过检测这些密钥来识别握手消息。\n解决方案：Elligator2（将椭圆曲线点编码为看起来随机的字符串的算法）在约 50% 的有效 X25519（基于 Curve25519 的 Diffie-Hellman 密钥交换方案）公钥与看起来随机的 254 位比特串之间提供一个双射映射。\n基于 Elligator2（用于隐藏公钥的椭圆曲线映射）的密钥生成：\nElligator2 GENERATE_PRIVATE_ELG2() 生成一个私钥，其对应的公钥可由 Elligator2（一种将椭圆曲线点编码为类随机字节串的方案）编码：\nwhile True: privkey = CSRNG(32) pubkey = DERIVE_PUBLIC(privkey) # Test if public key is Elligator2-encodable try: encoded = ENCODE_ELG2(pubkey) # Success - this key pair is suitable return privkey except NotEncodableError: # Try again with new random key continue 重要: 随机生成的私钥中约有 50% 会产生无法编码的公钥。必须将其丢弃，并尝试重新生成。\n性能优化: 在后台线程中预先生成密钥，维护合适的密钥对池，避免在握手期间产生延迟。\nElligator2（隐蔽映射算法）的 ENCODE_ELG2(pubkey) 将公钥编码为 32 个看似随机的字节：\ndef ENCODE_ELG2(pubkey): \u0026#34;\u0026#34;\u0026#34; Encodes X25519 public key using Elligator2. Args: pubkey: 32-byte X25519 public key (little-endian) Returns: encoded: 32-byte encoded key indistinguishable from random Raises: NotEncodableError: If pubkey cannot be encoded \u0026#34;\u0026#34;\u0026#34; # Perform Elligator2 representative calculation # Returns 254-bit value (31.75 bytes) encodedKey = elligator2_encode(pubkey) # Add 2 random bits to MSB to make full 32 bytes randomByte = CSRNG(1) encodedKey[31] |= (randomByte \u0026amp; 0xc0) return encodedKey 编码细节： - Elligator2（椭圆曲线点编码方案）产生 254 位（不是完整的 256 位） - 第 31 个字节的最高 2 位是随机填充 - 结果在 32 字节空间内均匀分布 - 可成功编码约 50% 的有效 X25519 公钥\nElligator2 DECODE_ELG2(encodedKey) 解码得到原始公钥：\ndef DECODE_ELG2(encodedKey): \u0026#34;\u0026#34;\u0026#34; Decodes Elligator2-encoded key back to X25519 public key. Args: encodedKey: 32-byte encoded key Returns: pubkey: 32-byte X25519 public key (little-endian) \u0026#34;\u0026#34;\u0026#34; # Mask out 2 random padding bits from MSB encodedKey[31] \u0026amp;= 0x3f # Perform Elligator2 representative inversion pubkey = elligator2_decode(encodedKey) return pubkey 安全属性： - 编码后的密钥在计算上与随机字节不可区分 - 任何统计检验都无法可靠地检测到 Elligator2（隐匿映射算法）编码的密钥 - 解码是确定性的（相同的编码密钥总会产生相同的公钥） - 对可编码子集中的 ~50% 密钥，编码是双射的\n实现说明： - 在生成阶段保存已编码的密钥，以避免在握手期间重新编码 - 在 Elligator2（将椭圆曲线点/公钥编码为类随机字节的算法）生成过程中被判定为不适用的密钥，仍可用于 NTCP2（其不需要 Elligator2） - 后台进行密钥生成对性能至关重要 - 由于 50% 的拒绝率，平均生成时间会翻倍\n消息格式 概述 ECIES（椭圆曲线集成加密方案）定义了三种消息类型：\n新会话 (NS): 从 Alice 发往 Bob 的初始握手消息 新会话回复 (NSR): Bob 发给 Alice 的握手回复 现有会话 (ES): 此后在两个方向上的所有消息 所有消息都被封装在 I2NP Garlic Message 格式中，并叠加了额外的加密层。\nI2NP Garlic 消息容器 所有 ECIES 消息都封装在标准的 I2NP Garlic Message 头部中：\n+----+----+----+----+----+----+----+----+ |type| msg_id | expiration | +----+----+----+----+----+----+----+----+ | size |chks| +----+----+----+----+----+----+----+----+ | length | | +----+----+----+----+ + | encrypted data | ~ ~ 字段: - type: 0x26 (Garlic 消息) - msg_id: 4 字节 I2NP 消息 ID - expiration: 8 字节 Unix 时间戳 (毫秒) - size: 2 字节有效负载大小 - chks: 1 字节校验和 - length: 4 字节加密数据长度 - encrypted data: ECIES 加密的有效负载\n用途: 提供 I2NP 层的消息标识与路由功能。length 字段使接收方能够得知加密负载的总大小。\n新会话 (NS) 消息 “New Session（新会话）”消息用于从 Alice 向 Bob 发起一个新的会话。它有三种变体：\n带绑定 (1b): 包含 Alice 的静态密钥，用于双向通信 不带绑定 (1c): 省略静态密钥，用于单向通信 一次性 (1d): 单消息模式，无需建立会话 带绑定的 NS Message (NS 消息) (类型 1b) 用例: 流式传输, 可回复的数据报, 任何需要回复的协议\n总长度: 96 + payload_length 字节\n格式:\n+----+----+----+----+----+----+----+----+ | | + + | New Session Ephemeral Public Key | + 32 bytes + | Encoded with Elligator2 | + + | | +----+----+----+----+----+----+----+----+ | | + Static Key Section + | ChaCha20 encrypted data | + 32 bytes + | | + + | | +----+----+----+----+----+----+----+----+ | Poly1305 Message Authentication Code | + (MAC) for Static Key Section + | 16 bytes | +----+----+----+----+----+----+----+----+ | | + Payload Section + | ChaCha20 encrypted data | ~ Variable length ~ | | + + | | +----+----+----+----+----+----+----+----+ | Poly1305 Message Authentication Code | + (MAC) for Payload Section + | 16 bytes | +----+----+----+----+----+----+----+----+ 字段详情：\n临时公钥 (32 字节，明文): - Alice 的一次性 X25519 公钥 - 使用 Elligator2 编码（与随机数据不可区分） - 为每个 NS 消息新生成（绝不复用） - 小端序格式\n静态密钥部分 (加密后 32 字节，含 MAC 为 48 字节): - 包含 Alice 的 X25519 静态公钥 (32 字节) - 使用 ChaCha20 加密 - 使用 Poly1305 MAC (16 字节) 进行认证 - 由 Bob 用于将会话绑定到 Alice 的目的地\n有效载荷部分 (可变长度的加密数据，+16 字节 MAC): - 包含 Garlic Clove（I2P 中的“蒜瓣”消息单元）和其他块 - 必须包含 DateTime 块作为首个块 - 通常包含带有应用数据的 Garlic Clove 块 - 可包含用于即时密钥棘轮的 NextKey 块 - 使用 ChaCha20 加密 - 使用 Poly1305 MAC（16 字节）进行认证\n安全属性： - 临时密钥提供前向保密性 - 静态密钥对 Alice 进行认证（绑定到目标） - 两个部分各自使用独立的 MAC（消息认证码），以实现域分离 - 整个握手执行 2 次 DH（Diffie-Hellman）运算（es, ss）\n无绑定的 NS 消息（类型 1c） 用例：既不期望也不希望收到回复的原始数据报\n总长度: 96 + payload_length 字节\n格式:\n+----+----+----+----+----+----+----+----+ | | + + | New Session Ephemeral Public Key | + 32 bytes + | Encoded with Elligator2 | + + | | +----+----+----+----+----+----+----+----+ | | + Flags Section + | ChaCha20 encrypted data | + 32 bytes + | All zeros | + + | | +----+----+----+----+----+----+----+----+ | Poly1305 Message Authentication Code | + (MAC) for above section + | 16 bytes | +----+----+----+----+----+----+----+----+ | | + Payload Section + | ChaCha20 encrypted data | ~ Variable length ~ | | + + | | +----+----+----+----+----+----+----+----+ | Poly1305 Message Authentication Code | + (MAC) for Payload Section + | 16 bytes | +----+----+----+----+----+----+----+----+ 关键差异: Flags Section（标志部分）包含32个零字节，而不是静态密钥。\n检测: Bob 通过解密该 32 字节区段并检查所有字节是否为零来确定消息类型: - 全为零 → 未绑定会话 (类型 1c) - 非零 → 使用静态密钥的绑定会话 (类型 1b)\n属性： - 无静态密钥意味着不与 Alice 的目标地址绑定 - Bob 无法发送回复（未知目标地址） - 仅执行 1 次 DH（Diffie-Hellman）运算 - 遵循 Noise（协议框架）\u0026ldquo;N\u0026rdquo; 模式而非 \u0026ldquo;IK\u0026rdquo; - 在不需要回复的情况下更高效\n标志部分 (保留供将来使用): 目前全为 0。未来版本中可用于特性协商。\nNS 一次性消息（类型 1d） 使用场景: 单条匿名消息，不建立会话且不期望回复\n总长度: 96 + payload_length 字节\nFormat: 与无绑定的 NS 相同（类型 1c）\n区别: - Type 1c 可以在同一会话中发送多条消息（随后为 ES messages（即 ES 消息）） - Type 1d 仅发送一条消息且不建立会话 - 在实践中，实现最初可能将二者视为相同\n特性： - 最大匿名性（无静态密钥，无会话） - 双方均不保留会话状态 - 遵循 Noise \u0026ldquo;N\u0026rdquo; pattern（Noise 协议中的 N 模式） - 单次 DH 运算（es，临时-静态）\n新会话应答（NSR）消息 Bob 发送一个或多个 NSR 消息来响应 Alice 的 NS 消息。NSR 完成了 Noise IK handshake（Noise 协议的 IK 模式握手），并建立了双向会话。\n总长度: 72 + payload_length 字节\n格式:\n+----+----+----+----+----+----+----+----+ | Session Tag 8 bytes | +----+----+----+----+----+----+----+----+ | | + Ephemeral Public Key + | | + 32 bytes + | Encoded with Elligator2 | + + | | +----+----+----+----+----+----+----+----+ | Poly1305 Message Authentication Code | + (MAC) for Key Section (empty) + | 16 bytes | +----+----+----+----+----+----+----+----+ | | + Payload Section + | ChaCha20 encrypted data | ~ Variable length ~ | | + + | | +----+----+----+----+----+----+----+----+ | Poly1305 Message Authentication Code | + (MAC) for Payload Section + | 16 bytes | +----+----+----+----+----+----+----+----+ 字段详细信息：\nSession Tag（会话标签） (8 字节，明文): - 由 NSR 标签集生成（参见 KDF 相关章节） - 将此回复与 Alice 的 NS 消息相关联 - 使 Alice 能识别此 NSR 是对哪个 NS 的响应 - 一次性使用（绝不复用）\n临时公钥 (32 字节，明文): - Bob 的一次性 X25519 公钥 - 使用 Elligator2 编码 - 为每个 NSR 消息新生成 - 每次发送 NSR 都必须不同\nKey Section MAC（密钥区段的 MAC） (16 字节): - 认证空数据（ZEROLEN） - 属于 Noise IK 协议（se 握手模式） - 使用握手记录哈希作为关联数据 - 对将 NSR 绑定到 NS 至关重要\n有效载荷部分 (可变长度): - 包含 garlic cloves (蒜瓣) 和数据块 - 通常包含应用层回复 - 可能为空 (ACK-only NSR) - 最大大小: 65519 字节 (65535 - 16 字节 MAC)\n多条 NSR 消息：\nBob 可能会针对一个 NS（握手请求消息）发送多个 NSR（握手响应消息）： - 每个 NSR 都有唯一的临时密钥 - 每个 NSR 都有唯一的会话标签 - Alice 使用收到的第一个 NSR 来完成握手 - 其他 NSR 用于冗余（以防丢包）\n关键时序: - Alice 在发送 ES 消息之前必须先收到一条 NSR 消息 - Bob 在发送 ES 消息之前必须先收到一条 ES 消息 - NSR 通过 split() 操作建立双向会话密钥\n安全属性： - 完成 Noise IK 握手 - 进行 2 次额外的 Diffie-Hellman（DH）运算（ee、se） - 在 NS+NSR 范围内共进行 4 次 DH 运算 - 实现双向认证（级别 2） - 为 NSR 负载提供较弱的前向保密性（级别 4）\n现有会话（ES）消息 在 NS/NSR handshake（NS/NSR 握手）之后的所有消息都使用 Existing Session（现有会话）格式。ES 消息由 Alice 和 Bob 双向使用。\n总长度: 8 + payload_length + 16 字节（最小为 24 字节）\n格式:\n+----+----+----+----+----+----+----+----+ | Session Tag 8 bytes | +----+----+----+----+----+----+----+----+ | | + Payload Section + | ChaCha20 encrypted data | ~ Variable length ~ | | + + | | +----+----+----+----+----+----+----+----+ | Poly1305 Message Authentication Code | + (MAC) + | 16 bytes | +----+----+----+----+----+----+----+----+ 字段详细信息：\n会话标签 (8 字节, 明文): - 由当前出站标签集生成 - 用于标识会话和消息编号 - 接收方查找该标签以获取会话密钥和 nonce（一次性随机数） - 一次性使用（每个标签仅使用一次） - 格式: HKDF 输出的前 8 个字节\nPayload Section (可变长度): - 包含 Garlic Clove（I2P 蒜瓣消息单元）和块 - 没有必需的块（可以为空） - 常见块: Garlic Clove、NextKey、ACK、ACK Request、Padding - 最大大小: 65519 字节（65535 - 16 字节 MAC）\nMAC (16 字节): - Poly1305 认证标签 - 在整个载荷上计算 - 关联数据：8 字节的会话标签 - 必须验证通过，否则消息将被拒绝\n标签查找流程：\n接收方提取 8 字节标签 在所有当前入站标签集中查找该标签 取回关联的会话密钥与消息编号 N 构造 nonce（随机数）：[0x00, 0x00, 0x00, 0x00, N (8 bytes little-endian)] 使用 AEAD（带关联数据的认证加密），以该标签作为关联数据，解密负载 从标签集中移除该标签（一次性使用） 处理解密后的数据块 未找到会话标签：\n如果在任何标签集中都找不到该标签： - 可能是 NS 消息 → 尝试 NS 解密 - 可能是 NSR 消息 → 尝试 NSR 解密 - 可能是乱序的 ES → 短暂等待标签集更新 - 可能是重放攻击 → 拒绝 - 可能是数据损坏 → 拒绝\n空载荷:\nES 消息可以有空负载 (0 字节): - 当收到 ACK Request 时，充当显式 ACK（确认） - 提供不含应用数据的协议层响应 - 仍然会消耗一个 session tag（会话标签） - 当更高层没有可立即发送的数据时很有用\n安全属性： - 在收到 NSR 后实现完全前向保密（Level 5） - 通过 AEAD（带关联数据的认证加密）实现认证加密 - 标签充当额外的关联数据 - 在需要进行棘轮（ratchet）之前，每个标签集最多 65535 条消息\n密钥派生函数 本节记录 ECIES 中使用的全部 KDF（密钥派生函数）操作，并展示完整的密码学推导过程。\n记号与常量 常量： - ZEROLEN - 零长度字节数组（空字符串） - || - 连接运算符\n变量: - h - 握手记录的累积哈希 (32 字节) - chainKey - 用于 HKDF 的链密钥 (32 字节) - k - 对称加密密钥 (32 字节) - n - 随机数（nonce）/ 消息编号\n密钥： - ask / apk - Alice 的静态私钥/公钥 - aesk / aepk - Alice 的临时私钥/公钥 - bsk / bpk - Bob 的静态私钥/公钥 - besk / bepk - Bob 的临时私钥/公钥\nNS 消息的密钥派生函数 KDF 1：初始链密钥 在协议初始化时执行一次（可预先计算）：\n# Protocol name (40 bytes, ASCII, no null termination) protocol_name = \u0026#34;Noise_IKelg2+hs2_25519_ChaChaPoly_SHA256\u0026#34; # Initialize hash h = SHA256(protocol_name) # Initialize chaining key chainKey = h # MixHash with empty prologue h = SHA256(h) # State: chainKey and h initialized # Can be precalculated for all outbound sessions 结果： - chainKey = 用于所有后续 KDF（密钥派生函数）的初始链密钥 - h = 初始握手记录哈希\nKDF 2: Bob 的静态密钥混合 Bob 只需执行一次此操作（可以为所有入站会话预先计算）:\n# Bob\u0026#39;s static keys (published in LeaseSet) bsk = GENERATE_PRIVATE() bpk = DERIVE_PUBLIC(bsk) # Mix Bob\u0026#39;s public key into hash h = SHA256(h || bpk) # State: h updated with Bob\u0026#39;s identity # Can be precalculated by Bob for all inbound sessions KDF 3：Alice 的临时密钥生成 Alice 为每个 NS 消息生成全新的密钥：\n# Generate ephemeral key pair suitable for Elligator2 aesk = GENERATE_PRIVATE_ELG2() aepk = DERIVE_PUBLIC(aesk) # Mix ephemeral public key into hash h = SHA256(h || aepk) # Elligator2 encode for transmission elg2_aepk = ENCODE_ELG2(aepk) # State: h updated with Alice\u0026#39;s ephemeral key # Send elg2_aepk as first 32 bytes of NS message KDF 4: NS 静态密钥部分（即 DH） 派生用于加密 Alice 的静态密钥的密钥:\n# Perform first DH (ephemeral-static) sharedSecret = DH(aesk, bpk) # Alice computes # Equivalent: sharedSecret = DH(bsk, aepk) # Bob computes # Derive cipher key from shared secret keydata = HKDF(chainKey, sharedSecret, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k = keydata[32:63] # AEAD encryption parameters nonce = 0 associated_data = h # Current hash transcript # Encrypt static key section if binding_requested: plaintext = apk # Alice\u0026#39;s static public key (32 bytes) else: plaintext = bytes(32) # All zeros for unbound ciphertext = ENCRYPT(k, nonce, plaintext, associated_data) # ciphertext = 32 bytes encrypted + 16 bytes MAC = 48 bytes # Mix ciphertext into hash h = SHA256(h || ciphertext) # State: Static key section encrypted, h updated # Send ciphertext (48 bytes) as next part of NS message KDF 5：NS 有效载荷部分（ss DH，仅用于绑定） 对于已绑定的会话，执行第二次 DH（Diffie-Hellman 密钥交换）用于负载加密:\nif binding_requested: # Alice\u0026#39;s static keys ask = GENERATE_PRIVATE() # Alice\u0026#39;s long-term key apk = DERIVE_PUBLIC(ask) # Perform second DH (static-static) sharedSecret = DH(ask, bpk) # Alice computes # Equivalent: sharedSecret = DH(bsk, apk) # Bob computes # Derive cipher key keydata = HKDF(chainKey, sharedSecret, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k = keydata[32:63] nonce = 0 associated_data = h else: # Unbound: reuse keys from static key section # chainKey and k unchanged nonce = 1 # Increment nonce (reusing same key) associated_data = h # Encrypt payload payload = build_payload() # DateTime + Garlic Cloves + etc. ciphertext = ENCRYPT(k, nonce, payload, associated_data) # Mix ciphertext into hash h = SHA256(h || ciphertext) # State: Payload encrypted, h contains complete NS transcript # Save chainKey and h for NSR processing # Send ciphertext as final part of NS message 重要说明：\nBound vs Unbound:\nBound 执行 2 次 DH (Diffie-Hellman) 运算 (es + ss) Unbound 执行 1 次 DH 运算 (仅 es) Unbound 通过递增 nonce (随机数) 而不是派生新密钥 密钥重用安全性:\n不同的 nonce（一次性随机数）（0 与 1）可防止密钥/nonce 重用 不同的关联数据（h 不同）提供域分离 哈希交互记录:\nh 现在包含: protocol_name, 空的 prologue（序言）, bpk, aepk, static_key_ciphertext, payload_ciphertext 此记录将 NS 消息的所有部分绑定在一起 NSR 应答标签集 KDF（密钥派生函数） Bob 为 NSR 消息生成标签：\n# Chain key from NS payload section # chainKey = final chainKey from NS KDF # Generate tagset key tagsetKey = HKDF(chainKey, ZEROLEN, \u0026#34;SessionReplyTags\u0026#34;, 32) # Initialize NSR tagset (see DH_INITIALIZE below) tagset_nsr = DH_INITIALIZE(chainKey, tagsetKey) # Get tag for this NSR tagsetEntry = tagset_nsr.GET_NEXT_ENTRY() tag = tagsetEntry.SESSION_TAG # 8 bytes # State: tag available for NSR message # Send tag as first 8 bytes of NSR NSR 消息的密钥派生函数 KDF 6：NSR 临时密钥生成 Bob 为每个 NSR 生成一个新的临时密钥:\n# Mix tag into hash (I2P extension to Noise) h = SHA256(h || tag) # Generate ephemeral key pair besk = GENERATE_PRIVATE_ELG2() bepk = DERIVE_PUBLIC(besk) # Mix ephemeral public key into hash h = SHA256(h || bepk) # Elligator2 encode for transmission elg2_bepk = ENCODE_ELG2(bepk) # State: h updated with tag and Bob\u0026#39;s ephemeral key # Send elg2_bepk as bytes 9-40 of NSR message KDF 7: NSR 密钥部分（ee 和 se DH） 派生用于 NSR 密钥部分的密钥：\n# Perform third DH (ephemeral-ephemeral) sharedSecret_ee = DH(aesk, bepk) # Alice computes # Equivalent: sharedSecret_ee = DH(besk, aepk) # Bob computes # Mix ee into chain keydata = HKDF(chainKey, sharedSecret_ee, \u0026#34;\u0026#34;, 32) chainKey = keydata[0:31] # Perform fourth DH (static-ephemeral) sharedSecret_se = DH(ask, bepk) # Alice computes # Equivalent: sharedSecret_se = DH(besk, apk) # Bob computes # Derive cipher key from se keydata = HKDF(chainKey, sharedSecret_se, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k = keydata[32:63] # AEAD encryption of empty data (key section has no payload) nonce = 0 associated_data = h ciphertext = ENCRYPT(k, nonce, ZEROLEN, associated_data) # ciphertext = 16 bytes (MAC only, no plaintext) # Mix ciphertext into hash h = SHA256(h || ciphertext) # State: Key section encrypted, chainKey contains all 4 DH results # Send ciphertext (16 bytes MAC) as bytes 41-56 of NSR 关键: 这就完成了 Noise IK 握手（Noise 协议中的 IK 模式）。chainKey 现在包含来自全部 4 次 DH 运算（es, ss, ee, se）的贡献。\nKDF（密钥派生函数）8：NSR 有效载荷部分 派生用于 NSR 负载加密的密钥：\n# Split chainKey into bidirectional keys keydata = HKDF(chainKey, ZEROLEN, \u0026#34;\u0026#34;, 64) k_ab = keydata[0:31] # Alice → Bob key k_ba = keydata[32:63] # Bob → Alice key # Initialize ES tagsets for both directions tagset_ab = DH_INITIALIZE(chainKey, k_ab) # Alice → Bob tagset_ba = DH_INITIALIZE(chainKey, k_ba) # Bob → Alice # Derive NSR payload key (Bob → Alice) k_nsr = HKDF(k_ba, ZEROLEN, \u0026#34;AttachPayloadKDF\u0026#34;, 32) # Encrypt NSR payload nonce = 0 associated_data = h # Binds payload to entire NSR payload = build_payload() # Usually application reply ciphertext = ENCRYPT(k_nsr, nonce, payload, associated_data) # State: Bidirectional ES sessions established # tagset_ab and tagset_ba ready for ES messages # Send ciphertext as bytes 57+ of NSR message 重要说明：\n拆分操作：\n为每个方向生成独立的密钥 防止在 Alice→Bob 与 Bob→Alice 之间复用密钥 NSR 负载绑定:\n使用 h 作为关联数据，将负载与握手绑定 独立的 KDF（\u0026ldquo;AttachPayloadKDF\u0026rdquo;）实现域分离 ES 就绪:\n在 NSR 之后，双方都可以发送 ES 消息 Alice 在发送 ES 之前必须先接收 NSR Bob 在发送 ES 之前必须先接收 ES ES 消息的 KDF（密钥派生函数） ES 消息使用来自 tagsets（标签集）的预生成会话密钥：\n# Sender gets next tag and key tagsetEntry = outbound_tagset.GET_NEXT_ENTRY() tag = tagsetEntry.SESSION_TAG # 8 bytes k = tagsetEntry.SESSION_KEY # 32 bytes N = tagsetEntry.INDEX # Message number # Construct nonce (12 bytes) nonce = [0x00, 0x00, 0x00, 0x00] + little_endian_8_bytes(N) # AEAD encryption associated_data = tag # Tag is associated data payload = build_payload() ciphertext = ENCRYPT(k, nonce, payload, associated_data) # Send: tag || ciphertext (8 + len(ciphertext) bytes) 接收方流程：\n# Extract tag tag = message[0:8] # Look up tag in inbound tagsets tagsetEntry = inbound_tagset.GET_SESSION_KEY(tag) if tagsetEntry is None: # Not an ES message, try NS/NSR decryption return try_handshake_decryption(message) k = tagsetEntry.SESSION_KEY N = tagsetEntry.INDEX # Construct nonce nonce = [0x00, 0x00, 0x00, 0x00] + little_endian_8_bytes(N) # AEAD decryption associated_data = tag ciphertext = message[8:] try: payload = DECRYPT(k, nonce, ciphertext, associated_data) except AuthenticationError: # MAC verification failed, reject message return reject_message() # Process payload blocks process_payload(payload) # Remove tag from tagset (one-time use) inbound_tagset.remove(tag) DH_INITIALIZE 函数 为单一方向创建一个 tagset（标签集合）：\ndef DH_INITIALIZE(rootKey, k): \u0026#34;\u0026#34;\u0026#34; Initializes a tagset with session tag and symmetric key ratchets. Args: rootKey: Chain key from previous DH ratchet (32 bytes) k: Key material from split() or DH ratchet (32 bytes) Returns: tagset: Initialized tagset object \u0026#34;\u0026#34;\u0026#34; # Derive next root key and chain key keydata = HKDF(rootKey, k, \u0026#34;KDFDHRatchetStep\u0026#34;, 64) nextRootKey = keydata[0:31] chainKey_tagset = keydata[32:63] # Derive separate chain keys for tags and keys keydata = HKDF(chainKey_tagset, ZEROLEN, \u0026#34;TagAndKeyGenKeys\u0026#34;, 64) sessTag_ck = keydata[0:31] # Session tag chain key symmKey_ck = keydata[32:63] # Symmetric key chain key # Create tagset object tagset = Tagset() tagset.nextRootKey = nextRootKey tagset.sessTag_chainKey = sessTag_ck tagset.symmKey_chainKey = symmKey_ck tagset.lastIndex = -1 return tagset 使用场景：\nNSR 标签集: DH_INITIALIZE(chainKey_from_NS, tagsetKey_NSR) ES 标签集: DH_INITIALIZE(chainKey_from_NSR, k_ab or k_ba) 棘轮化标签集: DH_INITIALIZE(nextRootKey_from_previous, tagsetKey_from_DH) 棘轮机制 ECIES（椭圆曲线集成加密方案）使用三个同步的棘轮机制，提供前向保密性和高效的会话管理。\nRatchet（密钥棘轮）概述 三种棘轮类型：\nDH 棘轮: 执行 Diffie-Hellman 密钥交换以生成新的根密钥 会话标签棘轮: 确定性地导出一次性会话标签 对称密钥棘轮: 导出用于消息加密的会话密钥 关系：\nDH Ratchet (periodic) ↓ Creates new tagset ↓ Session Tag Ratchet (per message) ← synchronized → Symmetric Key Ratchet (per message) ↓ ↓ Session Tags (8 bytes each) Session Keys (32 bytes each) 关键属性：\n发送方: 按需生成标签和密钥（无需存储） 接收方: 为前视窗口预生成标签（需要存储） 同步: 标签索引决定密钥索引（N_tag = N_key） 前向保密性: 通过周期性的 DH ratchet 实现（DH ratchet：基于 Diffie-Hellman 的密钥棘轮机制） 效率: 接收方可将密钥计算延后至接收到标签时再进行 DH 棘轮 DH 棘轮通过定期交换新的临时密钥来提供前向保密性。\nDH 棘轮频率 所需棘轮条件： - 标签集接近耗尽（标签 65535 为最大值） - 特定于实现的策略： - 消息计数阈值（例如，每 4096 条消息） - 时间阈值（例如，每 10 分钟） - 数据量阈值（例如，每 100 MB）\n建议的 First Ratchet（首次棘轮）：标签编号约为 4096，以避免达到上限\n最大值: - 最大标签集ID: 65535 - 最大密钥ID: 32767 - 每个标签集的最大消息数: 65535 - 每个会话的理论最大数据量: ~6.9 TB (64K 标签集 × 64K 消息 × 平均 1730 字节)\nDH Ratchet（Diffie-Hellman 棘轮）标签和密钥 ID 初始标签集（握手后）： - 标签集 ID：0 - 尚未发送任何 NextKey（后续密钥）块 - 尚未分配密钥 ID\n首次棘轮之后: - 标签集 ID: 1 = (1 + Alice 的密钥 ID + Bob 的密钥 ID) = (1 + 0 + 0) - Alice 发送密钥 ID 为 0 的 NextKey - Bob 以密钥 ID 为 0 的 NextKey 回复\n后续标签集: - 标签集ID = 1 + 发送方的密钥ID + 接收方的密钥ID - 例如: 标签集 5 = (1 + sender_key_2 + receiver_key_2)\nTag Set（标签集）演进表：\nTag Set ID Sender Key ID Receiver Key ID Notes 0 n/a n/a Initial tag set (post-NSR) 1 0 * 0 * First ratchet (both generate new keys) 2 1 * 0 Sender generates new key 3 1 1 * Receiver generates new key 4 2 * 1 Sender generates new key 5 2 2 * Receiver generates new key ... ... ... Pattern repeats 65534 32767 * 32766 Second-to-last tag set 65535 32767 32767 * Final tag set \\* = 本次棘轮生成了新密钥 Key ID 规则： - ID 从 0 开始按顺序递增 - 仅在生成新密钥时 ID 才递增 - 最大密钥 ID 为 32767 (15 位) - 达到密钥 ID 32767 后，需要新建会话\nDH 棘轮消息流 角色： - 标签发送方: 持有出站标签集，发送消息 - 标签接收方: 持有入站标签集，接收消息\n模式： 标签发送方在标签集合即将耗尽时发起棘轮。\n消息流程图：\nTag Sender Tag Receiver ... using tag set #0 ... (Tag set #0 approaching exhaustion) (Generate new key #0) NextKey forward, request reverse, with key #0 --------\u0026gt; (Repeat until NextKey ACK received) (Generate new key #0) (Perform DH: sender_key_0 × receiver_key_0) (Create inbound tag set #1) \u0026lt;--------------- NextKey reverse, with key #0 (Repeat until tag from tag set #1 received) (Receive NextKey with key #0) (Perform DH: sender_key_0 × receiver_key_0) (Create outbound tag set #1) ... using tag set #1 ... (Tag set #1 approaching exhaustion) (Generate new key #1) NextKey forward, with key #1 --------\u0026gt; (Repeat until NextKey ACK received) (Reuse existing key #0) (Perform DH: sender_key_1 × receiver_key_0) (Create inbound tag set #2) \u0026lt;-------------- NextKey reverse, id 0 (ACK) (Repeat until tag from tag set #2 received) (Receive NextKey with id 0) (Perform DH: sender_key_1 × receiver_key_0) (Create outbound tag set #2) ... using tag set #2 ... (Tag set #2 approaching exhaustion) (Reuse existing key #1) NextKey forward, request reverse, id 1 --------\u0026gt; (Repeat until NextKey received) (Generate new key #1) (Perform DH: sender_key_1 × receiver_key_1) (Create inbound tag set #3) \u0026lt;-------------- NextKey reverse, with key #1 (Receive NextKey with key #1) (Perform DH: sender_key_1 × receiver_key_1) (Create outbound tag set #3) ... using tag set #3 ... (Pattern repeats: even-numbered tag sets use forward key, odd-numbered use reverse key) 棘轮模式：\n创建偶数编号的标签集 (2, 4, 6, \u0026hellip;): 1. 发送方生成新密钥 2. 发送方发送包含新密钥的 NextKey 块 3. 接收方发送包含旧密钥 ID 的 NextKey 块 (ACK 确认) 4. 双方基于 (新发送方密钥 × 旧接收方密钥) 执行 DH (Diffie-Hellman 密钥交换)\n创建奇数编号的标签集 (3, 5, 7, \u0026hellip;): 1. 发送方请求反向密钥（发送带请求标志的 NextKey） 2. 接收方生成新密钥 3. 接收方发送包含新密钥的 NextKey 块 4. 双方使用（旧的发送方密钥 × 新的接收方密钥）进行 DH（Diffie-Hellman 密钥交换）\nNextKey 块格式 请参见 Payload Format（载荷格式）部分，了解 NextKey block（NextKey 块）的详细规范。\n关键要素: - 标志字节: - 位 0: 密钥存在 (1) 或仅 ID (0) - 位 1: 反向密钥 (1) 或正向密钥 (0) - 位 2: 请求反向密钥 (1) 或不请求 (0) - 密钥 ID: 2 字节, 大端序 (0-32767) - 公钥: 32 字节 X25519 (如果位 0 = 1)\nNextKey 块示例：\n# Sender initiates ratchet with new key (key ID 0, tag set 1) NextKey(flags=0x01, key_id=0, pubkey=sender_key_0) # Receiver replies with new key (key ID 0, tag set 1) NextKey(flags=0x03, key_id=0, pubkey=receiver_key_0) # Sender ratchets again with new key (key ID 1, tag set 2) NextKey(flags=0x01, key_id=1, pubkey=sender_key_1) # Receiver ACKs with old key ID (tag set 2) NextKey(flags=0x02, key_id=0) # Sender requests reverse key (tag set 3) NextKey(flags=0x04, key_id=1) # Receiver sends new reverse key (key ID 1, tag set 3) NextKey(flags=0x03, key_id=1, pubkey=receiver_key_1) DH 棘轮密钥派生函数 当交换新密钥时：\n# Tag sender generates or reuses key if generating_new: sender_sk = GENERATE_PRIVATE() sender_pk = DERIVE_PUBLIC(sender_sk) else: # Reuse existing key pair sender_pk = existing_sender_pk # Tag receiver generates or reuses key if generating_new: receiver_sk = GENERATE_PRIVATE() receiver_pk = DERIVE_PUBLIC(receiver_sk) else: # Reuse existing key pair receiver_pk = existing_receiver_pk # Both parties perform DH sharedSecret = DH(sender_sk, receiver_pk) # Derive tagset key tagsetKey = HKDF(sharedSecret, ZEROLEN, \u0026#34;XDHRatchetTagSet\u0026#34;, 32) # Get next root key from previous tagset rootKey = previous_tagset.nextRootKey # Initialize new tagset new_tagset = DH_INITIALIZE(rootKey, tagsetKey) # Tag sender: outbound tagset # Tag receiver: inbound tagset 关键时序:\n标签发送方: - 立即创建新的出站标签集 - 立即开始使用新标签 - 删除旧的出站标签集\n标签接收方： - 创建新的入站标签集 - 在宽限期（3 分钟）内保留旧的入站标签集 - 在宽限期内同时接受来自新旧标签集的标签 - 宽限期结束后删除旧的入站标签集\nDH棘轮状态管理 发送方状态： - 当前出站标签集 - 标签集ID和密钥ID - 下一个根密钥（用于下一个 ratchet（棘轮机制）） - 当前标签集中的消息计数\n接收方状态: - 当前入站标签集（在宽限期内可能有 2 个） - 用于缺口检测的先前消息编号（PN） - 预生成标签的前瞻窗口 - 下一个根密钥（用于下一轮棘轮）\n状态转换规则：\n在首次 Ratchet（密码学棘轮机制）之前:\n使用标签集 0（来自 NSR） 未分配任何密钥 ID 启动 Ratchet（棘轮机制）:\n生成新密钥（如果本轮由发送方负责生成） 在 ES message（ES 消息）中发送 NextKey block（NextKey 块） 在创建新的出站标签集合之前等待 NextKey reply（NextKey 回复） 接收 Ratchet 请求（棘轮机制）:\n生成新密钥（如果本轮由接收方生成） 使用接收到的密钥执行 DH（Diffie-Hellman 密钥交换） 创建新的入站标签集 发送 NextKey 回复（下一轮密钥） 在宽限期内保留旧的入站标签集 完成 Ratchet（加密棘轮机制）:\n接收 NextKey（下一密钥）回复 执行 DH（Diffie-Hellman 密钥交换） 创建新的出站 tag set（标签集） 开始使用新的标签 Session Tag Ratchet（会话标签棘轮机制） Session tag ratchet（会话标签棘轮机制）以确定性的方式生成一次性使用的 8 字节会话标签。\n会话标签棘轮的目的 取代显式标签传输（ElGamal 发送 32 字节的标签） 允许接收方预生成用于前瞻窗口的标签 发送方按需生成（无需存储） 通过索引与对称密钥棘轮同步 会话标签棘轮公式 初始化：\n# From DH_INITIALIZE sessTag_ck = initial_chain_key # 32 bytes # Initialize session tag ratchet keydata = HKDF(sessTag_ck, ZEROLEN, \u0026#34;STInitialization\u0026#34;, 64) sessTag_chainKey = keydata[0:31] # First chain key SESSTAG_CONSTANT = keydata[32:63] # Constant for all tags in this tagset 标签生成（针对标签 N）：\n# Generate tag N keydata = HKDF(sessTag_chainKey_(N-1), SESSTAG_CONSTANT, \u0026#34;SessionTagKeyGen\u0026#34;, 64) sessTag_chainKey_N = keydata[0:31] # Chain key for next tag tag_N = keydata[32:39] # Session tag (8 bytes) # Chain continues for each tag # tag_0, tag_1, tag_2, ..., tag_65535 完整序列：\n# Tag 0 keydata_0 = HKDF(sessTag_chainKey, SESSTAG_CONSTANT, \u0026#34;SessionTagKeyGen\u0026#34;, 64) sessTag_chainKey_0 = keydata_0[0:31] tag_0 = keydata_0[32:39] # Tag 1 keydata_1 = HKDF(sessTag_chainKey_0, SESSTAG_CONSTANT, \u0026#34;SessionTagKeyGen\u0026#34;, 64) sessTag_chainKey_1 = keydata_1[0:31] tag_1 = keydata_1[32:39] # Tag N keydata_N = HKDF(sessTag_chainKey_(N-1), SESSTAG_CONSTANT, \u0026#34;SessionTagKeyGen\u0026#34;, 64) sessTag_chainKey_N = keydata_N[0:31] tag_N = keydata_N[32:39] 会话标签棘轮发送端实现 class OutboundTagset: def __init__(self, sessTag_ck): # Initialize keydata = HKDF(sessTag_ck, ZEROLEN, \u0026#34;STInitialization\u0026#34;, 64) self.chainKey = keydata[0:31] self.constant = keydata[32:63] self.index = -1 def get_next_tag(self): # Increment index self.index += 1 if self.index \u0026gt; 65535: raise TagsetExhausted(\u0026#34;Ratchet required\u0026#34;) # Generate tag keydata = HKDF(self.chainKey, self.constant, \u0026#34;SessionTagKeyGen\u0026#34;, 64) self.chainKey = keydata[0:31] tag = keydata[32:39] return (tag, self.index) 发送方流程： 1. 对每条消息调用 get_next_tag() 2. 在 ES 消息中使用返回的标签 3. 存储索引 N 以便潜在的 ACK（确认）跟踪 4. 无需存储标签（按需生成）\n会话标签棘轮接收端实现 class InboundTagset: def __init__(self, sessTag_ck, look_ahead=32): # Initialize keydata = HKDF(sessTag_ck, ZEROLEN, \u0026#34;STInitialization\u0026#34;, 64) self.chainKey = keydata[0:31] self.constant = keydata[32:63] self.index = -1 self.look_ahead = look_ahead self.tags = {} # Dictionary: tag -\u0026gt; index # Pre-generate initial tags self.extend(look_ahead) def extend(self, count): \u0026#34;\u0026#34;\u0026#34;Generate \u0026#39;count\u0026#39; more tags\u0026#34;\u0026#34;\u0026#34; for _ in range(count): self.index += 1 if self.index \u0026gt; 65535: return # Cannot exceed maximum # Generate tag keydata = HKDF(self.chainKey, self.constant, \u0026#34;SessionTagKeyGen\u0026#34;, 64) self.chainKey = keydata[0:31] tag = keydata[32:39] # Store tag self.tags[tag] = self.index def lookup_tag(self, tag): \u0026#34;\u0026#34;\u0026#34;Look up tag and return index\u0026#34;\u0026#34;\u0026#34; if tag in self.tags: index = self.tags[tag] # Remove tag (one-time use) del self.tags[tag] return index return None def check_and_extend(self): \u0026#34;\u0026#34;\u0026#34;Extend if tag count is low\u0026#34;\u0026#34;\u0026#34; current_count = len(self.tags) if current_count \u0026lt; self.look_ahead // 2: # Extend to restore window self.extend(self.look_ahead - current_count) 接收端流程： 1. 为前瞻窗口预先生成标签（例如 32 个标签） 2. 将标签存入哈希表或字典 3. 消息到达时，查找标签以获取索引 N 4. 从存储中移除该标签（一次性使用） 5. 若标签数量低于阈值，则扩展窗口\n会话标签前瞻策略 目的: 在内存使用与乱序消息处理之间取得平衡\n推荐的前瞻大小：\nTagset Type Initial Size Maximum Size Notes NSR tagset 12 12 Short-lived ES tagset 0 24 160 Initial ES tagset ES tagset 1+ 160 160 Ratcheted tagsets **自适应前瞻：** # Dynamic look-ahead based on highest tag received look_ahead = min(tsmax, tsmin + N // 4) # Example: # tsmin = 24, tsmax = 160 # N = 0: look_ahead = min(160, 24 + 0/4) = 24 # N = 100: look_ahead = min(160, 24 + 100/4) = 49 # N = 500: look_ahead = min(160, 24 + 500/4) = 149 # N = 544: look_ahead = min(160, 24 + 544/4) = 160 Trim Behind（向后裁剪）：\n# Trim tags far behind highest received trim_behind = look_ahead // 2 # If highest received tag is N=100, trim tags below N=50 内存计算:\n# Per tag: 8 bytes (tag) + 2 bytes (index) + overhead ≈ 16 bytes # Look-ahead of 160 tags ≈ 2.5 KB per inbound tagset # With multiple sessions: # 100 inbound sessions × 2.5 KB = 250 KB total 会话标签乱序处理 场景: 消息乱序到达\nExpected: tag_5, tag_6, tag_7, tag_8 Received: tag_5, tag_7, tag_6, tag_8 接收端行为：\n接收 tag_5:\n查找: 在索引 5 处找到 处理消息 移除 tag_5 已接收的最高编号: 5 接收 tag_7 (乱序):\n查找：在索引 7 处找到 处理消息 移除 tag_7 已接收的最高值：7 注意：tag_6 仍在存储中(尚未接收) 接收 tag_6 (延迟):\n查找: 在索引 6 处找到 处理消息 移除 tag_6 最高已接收: 7 (未变) 接收 tag_8：\n查找：在索引 8 处找到 处理消息 移除 tag_8 已接收的最高序号：8 窗口维护： - 跟踪已接收的最高索引 - 维护缺失索引（缺口）列表 - 根据最高索引扩展窗口 - 可选：在超时后使旧的缺口失效\n对称密钥棘轮 对称密钥棘轮生成与会话标签同步的 32 字节加密密钥。\n对称密钥棘轮的目的 为每条消息提供唯一的加密密钥 与会话标签棘轮同步（使用相同索引） 发送方可按需生成 接收方可延迟生成，直到收到会话标签 对称密钥棘轮公式 初始化：\n# From DH_INITIALIZE symmKey_ck = initial_chain_key # 32 bytes # No additional initialization needed # Unlike session tag ratchet, no constant is derived 密钥生成（针对密钥 N）：\n# Generate key N SYMMKEY_CONSTANT = ZEROLEN # Empty string keydata = HKDF(symmKey_chainKey_(N-1), SYMMKEY_CONSTANT, \u0026#34;SymmetricRatchet\u0026#34;, 64) symmKey_chainKey_N = keydata[0:31] # Chain key for next key key_N = keydata[32:63] # Session key (32 bytes) 完整序列：\n# Key 0 keydata_0 = HKDF(symmKey_ck, ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) symmKey_chainKey_0 = keydata_0[0:31] key_0 = keydata_0[32:63] # Key 1 keydata_1 = HKDF(symmKey_chainKey_0, ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) symmKey_chainKey_1 = keydata_1[0:31] key_1 = keydata_1[32:63] # Key N keydata_N = HKDF(symmKey_chainKey_(N-1), ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) symmKey_chainKey_N = keydata_N[0:31] key_N = keydata_N[32:63] 对称密钥棘轮发送方实现 class OutboundKeyRatchet: def __init__(self, symmKey_ck): self.chainKey = symmKey_ck self.index = -1 def get_key(self, index): \u0026#34;\u0026#34;\u0026#34;Generate key for specific index\u0026#34;\u0026#34;\u0026#34; # Fast-forward to desired index if needed while self.index \u0026lt; index: self.index += 1 keydata = HKDF(self.chainKey, ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) self.chainKey = keydata[0:31] if self.index == index: return keydata[32:63] # Should not reach here if called correctly raise ValueError(\u0026#34;Key already generated\u0026#34;) 发送方流程： 1. 获取下一个标签及其索引 N 2. 为索引 N 生成密钥 3. 使用该密钥加密消息 4. 无需存储密钥\n对称密钥棘轮接收方实现 策略 1：延迟生成（推荐）\nclass InboundKeyRatchet: def __init__(self, symmKey_ck): self.chainKey = symmKey_ck self.index = -1 self.cache = {} # Optional: cache recently used keys def get_key(self, index): \u0026#34;\u0026#34;\u0026#34;Generate key for specific index\u0026#34;\u0026#34;\u0026#34; # Check cache first (optional optimization) if index in self.cache: key = self.cache[index] del self.cache[index] return key # Fast-forward to desired index while self.index \u0026lt; index: self.index += 1 keydata = HKDF(self.chainKey, ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) self.chainKey = keydata[0:31] if self.index == index: return keydata[32:63] raise ValueError(\u0026#34;Index already passed\u0026#34;) 延迟生成流程： 1. 接收带有标签的 ES message（ES 消息） 2. 查找该标签以获得索引 N 3. 生成从 0 到 N 的密钥（如果尚未生成） 4. 使用密钥 N 解密消息 5. 链密钥现在位于索引 N\n优点: - 内存占用最小 - 仅在需要时才生成密钥 - 实现简单\n缺点： - 首次使用时必须生成从 0 到 N 的所有密钥 - 在没有缓存的情况下无法处理乱序消息\n策略 2：使用标签窗口的预生成（替代方案）\nclass InboundKeyRatchet: def __init__(self, symmKey_ck): self.chainKey = symmKey_ck self.index = -1 self.keys = {} # Dictionary: index -\u0026gt; key def extend(self, count): \u0026#34;\u0026#34;\u0026#34;Pre-generate \u0026#39;count\u0026#39; more keys\u0026#34;\u0026#34;\u0026#34; for _ in range(count): self.index += 1 keydata = HKDF(self.chainKey, ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) self.chainKey = keydata[0:31] key = keydata[32:63] self.keys[self.index] = key def get_key(self, index): \u0026#34;\u0026#34;\u0026#34;Retrieve pre-generated key\u0026#34;\u0026#34;\u0026#34; if index in self.keys: key = self.keys[index] del self.keys[index] return key return None 预生成流程： 1. 预生成与标签窗口相匹配的密钥（例如，32 个密钥） 2. 将密钥按消息编号建立索引并存储 3. 当收到标签时，查找对应的密钥 4. 随着标签被使用，扩展窗口\n优势： - 自然处理乱序消息 - 密钥检索速度快 (无生成延迟)\n缺点： - 更高的内存占用（每个密钥 32 字节，相比每个标签 8 字节） - 必须使密钥与标签保持同步\n内存比较:\n# Look-ahead of 160: # Tags only: 160 × 16 bytes = 2.5 KB # Tags+Keys: 160 × (16 + 32) bytes = 7.5 KB # # For 100 sessions: # Tags only: 250 KB # Tags+Keys: 750 KB 使用会话标签的对称棘轮同步 关键要求: 会话标签索引必须等于对称密钥索引\n# Sender tag, index = outbound_tagset.get_next_tag() key = outbound_keyratchet.get_key(index) # Same index nonce = construct_nonce(index) ciphertext = ENCRYPT(key, nonce, payload, tag) # Receiver index = inbound_tagset.lookup_tag(tag) key = inbound_keyratchet.get_key(index) # Same index nonce = construct_nonce(index) plaintext = DECRYPT(key, nonce, ciphertext, tag) 失效模式：\n如果同步中断： - 解密使用了错误的密钥 - MAC（消息认证码）验证失败 - 消息被拒绝\n预防： - 始终为标签和密钥使用相同的索引 - 绝不要在任一 ratchet（密钥棘轮）中跳过索引 - 谨慎处理乱序消息\n对称棘轮的一次性随机数构造 Nonce（一次性随机数）源自消息编号：\ndef construct_nonce(index): \u0026#34;\u0026#34;\u0026#34; Construct 12-byte nonce for ChaCha20-Poly1305 Args: index: Message number (0-65535) Returns: nonce: 12-byte nonce \u0026#34;\u0026#34;\u0026#34; # First 4 bytes are always zero nonce = bytearray(12) nonce[0:4] = b\u0026#39;\\x00\\x00\\x00\\x00\u0026#39; # Last 8 bytes are little-endian message number nonce[4:12] = index.to_bytes(8, byteorder=\u0026#39;little\u0026#39;) return bytes(nonce) 示例：\nindex = 0: nonce = 0x00000000 0000000000000000 index = 1: nonce = 0x00000000 0100000000000000 index = 255: nonce = 0x00000000 FF00000000000000 index = 256: nonce = 0x00000000 0001000000000000 index = 65535: nonce = 0x00000000 FFFF000000000000 重要属性： - Nonces（一次性随机数）对于标签集中的每条消息都是唯一的 - Nonces 永不重复（一次性标签可确保这一点） - 8 字节计数器允许 2^64 条消息（我们只使用 2^16） - Nonce 格式符合 RFC 7539 的基于计数器的构造\n会话管理 会话上下文 所有入站和出站会话都必须属于特定的上下文：\nRouter 上下文: 为 router 本身的会话 目标上下文: 为特定本地目标（客户端应用）的会话 关键规则: 为防止关联攻击，会话不得在不同上下文之间共享。\n实现：\nclass SessionKeyManager: \u0026#34;\u0026#34;\u0026#34;Context for managing sessions (router or destination)\u0026#34;\u0026#34;\u0026#34; def __init__(self, context_id): self.context_id = context_id self.inbound_sessions = {} # far_end_dest -\u0026gt; [sessions] self.outbound_sessions = {} # far_end_dest -\u0026gt; session self.static_keypair = generate_keypair() # Context\u0026#39;s identity def get_outbound_session(self, destination): \u0026#34;\u0026#34;\u0026#34;Get or create outbound session to destination\u0026#34;\u0026#34;\u0026#34; if destination not in self.outbound_sessions: self.outbound_sessions[destination] = create_outbound_session(destination) return self.outbound_sessions[destination] def add_inbound_session(self, session, destination=None): \u0026#34;\u0026#34;\u0026#34;Add inbound session, optionally bound to destination\u0026#34;\u0026#34;\u0026#34; if destination: if destination not in self.inbound_sessions: self.inbound_sessions[destination] = [] self.inbound_sessions[destination].append(session) else: # Unbound session self.inbound_sessions[None].append(session) Java I2P 实现：\n在 Java I2P 中，SessionKeyManager 类提供以下功能： - 每个 router 一个 SessionKeyManager - 每个本地 destination（目的地）一个 SessionKeyManager - 在每个上下文内分别管理 ECIES 和 ElGamal 会话\n会话绑定 绑定 将会话与特定的远端目标关联起来。\n绑定会话 特性： - 在 NS message（NS 握手消息）中包含发送方的静态密钥 - 接收方可以识别发送方的目的地 - 支持双向通信 - 每个目的地仅一个出站会话 - 可能存在多个入站会话（在过渡期间）\n用例： - 流式连接（类似 TCP） - 可回复的数据报 - 任何需要请求/响应的协议\n绑定过程：\n# Alice creates bound outbound session outbound_session = OutboundSession( destination=bob_destination, static_key=alice_static_key, bound=True ) # Alice sends NS with static key ns_message = build_ns_message( ephemeral_key=alice_ephemeral_key, static_key=alice_static_key, # Included for binding payload=data ) # Bob receives NS bob_receives_ns(ns_message) # Bob extracts Alice\u0026#39;s static key alice_static_key = decrypt_static_key_section(ns_message) # Bob looks up Alice\u0026#39;s destination (from bundled LeaseSet) alice_destination = lookup_destination_by_static_key(alice_static_key) # Bob creates bound inbound session inbound_session = InboundSession( destination=alice_destination, bound=True ) # Bob pairs with outbound session outbound_session = OutboundSession( destination=alice_destination, bound=True ) 优势: 1. Ephemeral-Ephemeral DH: 回应使用 ee DH（临时-临时 Diffie-Hellman，完全前向保密） 2. 会话连续性: Ratchets（棘轮机制）保持与同一目标的绑定 3. 安全性: 防止会话劫持（经静态密钥认证） 4. 效率: 每个目标仅有一个会话（无重复）\n未绑定会话 特性： - NS message（协议中的 NS 消息类型）中没有静态密钥（flags 字段全为 0） - 接收方无法识别发送方 - 仅支持单向通信 - 允许针对同一目标建立多个会话\n使用场景: - 原始数据报（fire-and-forget，发后不管） - 匿名发布 - 广播式消息传递\n属性： - 更匿名（无发送方身份标识） - 更高效（握手中 1 次 DH 对比 2 次 DH） - 无法回复（接收方不知道该回复到哪里） - 无会话棘轮机制（一次性或有限次使用）\n会话配对 配对 将入站会话与出站会话连接起来，以进行双向通信。\n创建配对会话 Alice 的视角（发起方）：\n# Create outbound session to Bob outbound_session = create_outbound_session(bob_destination) # Create paired inbound session inbound_session = create_inbound_session( paired_with=outbound_session, bound_to=bob_destination ) # Link them outbound_session.paired_inbound = inbound_session inbound_session.paired_outbound = outbound_session # Send NS message send_ns_message(outbound_session, payload) Bob 的视角（响应方）：\n# Receive NS message ns_message = receive_ns_message() # Create inbound session inbound_session = create_inbound_session_from_ns(ns_message) # If NS contains static key (bound): if ns_message.has_static_key(): alice_destination = extract_destination(ns_message) inbound_session.bind_to(alice_destination) # Create paired outbound session outbound_session = create_outbound_session(alice_destination) # Link them outbound_session.paired_inbound = inbound_session inbound_session.paired_outbound = outbound_session # Send NSR send_nsr_message(inbound_session, outbound_session, payload) 会话配对的优势 带内 ACK: 无需单独的 clove（garlic encryption 中的子消息）即可确认消息 高效棘轮: 双向棘轮同步推进 流量控制: 可以在配对会话之间实现背压 状态一致性: 更易维护同步状态 会话配对规则 出站会话可能未配对（未绑定的 NS） 已绑定 NS 的入站会话应当配对 配对发生在会话创建时，而不是之后 已配对的会话绑定到相同的目标 棘轮过程相互独立，但保持协调 会话生命周期 会话生命周期：创建阶段 出站会话创建 (Alice):\ndef create_outbound_session(destination, bound=True): session = OutboundSession() session.destination = destination session.bound = bound session.state = SessionState.NEW session.created_time = now() # Generate keys for NS message session.ephemeral_keypair = generate_elg2_keypair() if bound: session.static_key = context.static_keypair.public_key # Will be populated after NSR received session.outbound_tagset = None session.inbound_tagset = None return session 入站会话创建 (Bob):\ndef create_inbound_session_from_ns(ns_message): session = InboundSession() session.state = SessionState.ESTABLISHED session.created_time = now() # Extract from NS session.remote_ephemeral_key = ns_message.ephemeral_key session.remote_static_key = ns_message.static_key if session.remote_static_key: session.bound = True session.destination = lookup_destination(session.remote_static_key) else: session.bound = False session.destination = None # Generate keys for NSR session.ephemeral_keypair = generate_elg2_keypair() # Create tagsets from KDF session.inbound_tagset = create_tagset_from_nsr() session.outbound_tagset = create_tagset_from_nsr() return session 会话生命周期：活跃阶段 状态转换:\nNEW (outbound only) ↓ NS sent ↓ PENDING_REPLY (outbound only) ↓ NSR received ↓ ESTABLISHED ↓ ES messages exchanged ↓ ESTABLISHED (ongoing) ↓ (optional) RATCHETING ↓ ESTABLISHED 活跃会话维护：\ndef maintain_active_session(session): # Update last activity time session.last_activity = now() # Check for ratchet needed if session.outbound_tagset.needs_ratchet(): initiate_ratchet(session) # Check for incoming ratchet if received_nextkey_block(): process_ratchet(session) # Trim old tags from inbound tagset session.inbound_tagset.expire_old_tags() # Check session health if session.idle_time() \u0026gt; SESSION_TIMEOUT: mark_session_idle(session) 会话生命周期：过期阶段 会话超时值：\nSession Type Sender Timeout Receiver Timeout Notes NSR tagset N/A 3 minutes Short-lived ES tagset 0 8 minutes 10 minutes Initial ES tagset 1+ 8 minutes 10 minutes Ratcheted Old tagset N/A 3 minutes After ratchet **过期逻辑:** def check_session_expiration(): for session in active_sessions: # Outbound session expiration (sender) if session.is_outbound(): if session.idle_time() \u0026gt; 8 * 60: # 8 minutes expire_outbound_session(session) # Inbound session expiration (receiver) else: if session.idle_time() \u0026gt; 10 * 60: # 10 minutes expire_inbound_session(session) # Old tagsets (after ratchet) for tagset in old_tagsets: if tagset.age() \u0026gt; 3 * 60: # 3 minutes delete_tagset(tagset) 关键规则：出站会话必须先于入站会话过期，以防止不同步。\n优雅终止：\ndef terminate_session(session, reason=0): # Send Termination block (if implemented) send_termination_block(session, reason) # Mark session for deletion session.state = SessionState.TERMINATED # Keep session briefly for final messages schedule_deletion(session, delay=30) # 30 seconds # Notify paired session if session.paired_session: session.paired_session.mark_remote_terminated() 多个 NS 消息 场景：Alice 的 NS 消息丢失，或 NSR 应答丢失。\nAlice 的行为：\nclass OutboundSession: def __init__(self): self.ns_messages_sent = [] self.ns_timer = None self.max_ns_attempts = 5 def send_ns_message(self, payload): # Generate new ephemeral key for each NS ephemeral_key = generate_elg2_keypair() ns_message = build_ns_message( ephemeral_key=ephemeral_key, static_key=self.static_key, payload=payload ) # Store state for this NS ns_state = { \u0026#39;ephemeral_key\u0026#39;: ephemeral_key, \u0026#39;chainkey\u0026#39;: compute_chainkey(ns_message), \u0026#39;hash\u0026#39;: compute_hash(ns_message), \u0026#39;tagset\u0026#39;: derive_nsr_tagset(ns_message), \u0026#39;sent_time\u0026#39;: now() } self.ns_messages_sent.append(ns_state) # Send message send_message(ns_message) # Set timer for retry if not self.ns_timer: self.ns_timer = set_timer(1.0, self.on_ns_timeout) def on_ns_timeout(self): if len(self.ns_messages_sent) \u0026gt;= self.max_ns_attempts: # Give up fail_session(\u0026#34;No NSR received after {self.max_ns_attempts} attempts\u0026#34;) return # Retry with new NS message send_ns_message(self.payload) def on_nsr_received(self, nsr_message): # Cancel timer cancel_timer(self.ns_timer) # Find which NS this NSR responds to tag = nsr_message.tag for ns_state in self.ns_messages_sent: if tag in ns_state[\u0026#39;tagset\u0026#39;]: # This NSR corresponds to this NS self.active_ns_state = ns_state break # Process NSR and complete handshake complete_handshake(nsr_message, self.active_ns_state) # Discard other NS states self.ns_messages_sent = [] 重要属性：\n独立的临时密钥: 每个 NS 使用不同的临时密钥 独立的握手: 每个 NS 创建单独的握手状态 NSR 关联: NSR 标记用于标识其响应的是哪个 NS 状态清理: 在 NSR 成功后，未使用的 NS 状态将被丢弃 防范攻击：\n为防止资源耗尽：\n# Limit NS sending rate max_ns_rate = 5 per 10 seconds per destination # Limit total NS attempts max_ns_attempts = 5 # Limit total pending NS states max_pending_ns = 10 per context 多个 NSR 消息 场景：Bob 发送多个 NSRs（回复消息；例如，将回复数据拆分为多条消息）。\nBob 的行为：\nclass InboundSession: def send_nsr_replies(self, payload_chunks): # One NS received, multiple NSRs to send for chunk in payload_chunks: # Generate new ephemeral key for each NSR ephemeral_key = generate_elg2_keypair() # Get next tag from NSR tagset tag = self.nsr_tagset.get_next_tag() nsr_message = build_nsr_message( tag=tag, ephemeral_key=ephemeral_key, payload=chunk ) send_message(nsr_message) # Wait for ES message from Alice self.state = SessionState.AWAITING_ES Alice 的行为:\nclass OutboundSession: def on_nsr_received(self, nsr_message): if self.state == SessionState.PENDING_REPLY: # First NSR received complete_handshake(nsr_message) self.state = SessionState.ESTABLISHED # Create ES sessions self.es_outbound_tagset = derive_es_outbound_tagset() self.es_inbound_tagset = derive_es_inbound_tagset() # Send ES message (ACK) send_es_message(empty_payload) elif self.state == SessionState.ESTABLISHED: # Additional NSR received # Decrypt and process payload payload = decrypt_nsr_payload(nsr_message) process_payload(payload) # These NSRs are from other NS attempts, ignore handshake Bob 的清理:\nclass InboundSession: def on_es_received(self, es_message): # First ES received from Alice # This confirms which NSR Alice used # Clean up other handshake states for other_ns_state in self.pending_ns_states: if other_ns_state != self.active_ns_state: delete_ns_state(other_ns_state) # Delete unused NSR tagsets for tagset in self.nsr_tagsets: if tagset != self.active_nsr_tagset: delete_tagset(tagset) self.state = SessionState.ESTABLISHED 重要属性：\n允许多个 NSR（NS 请求）: Bob 可以针对每个 NS（会话）发送多个 NSR 使用不同的临时密钥: 每个 NSR 应使用唯一的临时密钥 相同的 NSR tagset（标签集）: 同一 NS 的所有 NSR 使用相同的 tagset 先到的 ES（响应消息）胜出: 由 Alice 首个到达的 ES 决定哪个 NSR 成功 在 ES 之后清理: 收到 ES 后，Bob 丢弃未使用的状态 会话状态机 完整状态图：\nOutbound Session Inbound Session NEW | send NS | PENDING_REPLY -------------------- receive NS ---\u0026gt; ESTABLISHED | | receive NSR send NSR | | ESTABLISHED \u0026lt;---------- receive ES ------------- AWAITING_ES | | | ┌─────┴─────┐ | receive ES | | | | send ES receive ES | ESTABLISHED | | | | └─────┬─────┘ | ┌─────────┴─────────┐ | | | | | | send ES receive ES | | | | | | └─────────┬─────────┘ | | | └─────────────────────┴──────────────────────────┘ ACTIVE | idle timeout | EXPIRED 状态描述：\nNEW: 已创建出站会话，尚未发送 NS（握手消息） PENDING_REPLY: 已发送 NS，正在等待 NSR（握手响应消息） AWAITING_ES: 已发送 NSR，正在等待来自 Alice 的首个 ES（加密数据消息） ESTABLISHED: 握手完成，可以发送/接收 ES ACTIVE: 正在主动交换 ES 消息 RATCHETING: DH ratchet（Diffie-Hellman 棘轮，密钥轮换过程）进行中（ACTIVE 的子集） EXPIRED: 会话超时，待删除 TERMINATED: 会话被显式终止 有效载荷格式 所有 ECIES（椭圆曲线集成加密方案）消息（NS、NSR、ES）的负载部分使用一种与 NTCP2 类似的基于块的格式。\n块结构 通用格式:\n+----+----+----+----+----+----+----+----+ |blk | size | data | +----+----+----+ + | | ~ ... ~ | | +----+----+----+----+----+----+----+----+ |blk | size | data | +----+----+----+ + | | ~ ... ~ | | +----+----+----+----+----+----+----+----+ 字段：\nblk: 1 字节 - 块类型编号 size: 2 字节 - 数据字段的大端序大小 (0-65516) data: 可变长度 - 块特定数据 约束：\n最大 ChaChaPoly 帧：65535 字节 Poly1305 MAC：16 字节 最大总块大小：65519 字节 (65535 - 16) 最大单个块：65519 字节 (包含 3 字节头部) 最大单个块数据：65516 字节 块类型 已定义的块类型：\nType Name Size Status Usage 0 DateTime 7 bytes Implemented Required in NS 1-3 Reserved - - Future use 4 Termination 9+ bytes Unimplemented Session termination 5 Options 21+ bytes Unimplemented Session options 6 MessageNumbers 5 bytes Unimplemented PN value 7 NextKey 3 or 35 bytes Implemented DH ratchet 8 ACK 4+ bytes Implemented Message acknowledgment 9 ACK Request 3 bytes Implemented Request ACK 10 Reserved - - Future use 11 Garlic Clove Variable Implemented Application data 12-223 Reserved - - Future use 224-253 Experimental Variable - Testing features 254 Padding Variable Implemented Traffic shaping 255 Reserved - - Future extension **未知块处理：** 各实现必须（MUST）忽略具有未知类型编号的块，并将其视为填充。这可确保前向兼容性。\n块排序规则 NS 消息排序 必需： - DateTime 块必须位于首位\n允许： - Garlic Clove (蒜瓣) (类型 11) - 选项 (类型 5) - 若已实现 - 填充 (类型 254)\n禁止： - NextKey, ACK, ACK Request, Termination, MessageNumbers\n有效的 NS 载荷示例：\nDateTime (0) | Garlic Clove (11) | Garlic Clove (11) | Padding (254) NSR 消息排序 必需： - 无（有效载荷可能为空）\n允许： - Garlic Clove（garlic encryption 的子消息） (type 11) - 选项 (type 5) - 如已实现 - 填充 (type 254)\n禁止： - DateTime, NextKey, ACK, ACK Request, Termination, MessageNumbers\n有效的 NSR 负载示例：\nGarlic Clove (11) | Garlic Clove (11) | Padding (254) 或\n(empty - ACK only) ES 消息顺序 必需： - 无（有效载荷可为空）\n允许（任意顺序）： - Garlic Clove (type 11) - NextKey (type 7) - ACK (type 8) - ACK Request (type 9) - Termination (type 4) - 如果已实现 - MessageNumbers (type 6) - 如果已实现 - Options (type 5) - 如果已实现 - Padding (type 254)\n特殊规则： - Termination（终止）必须为最后一个块（除 Padding（填充）外） - Padding 必须为最后一个块 - 允许多个 Garlic Cloves（蒜瓣） - 最多允许 2 个 NextKey blocks（NextKey 块）（正向和反向） - 不允许多个 Padding 块\nES 有效载荷示例：\nGarlic Clove (11) | ACK (8) | Padding (254) NextKey (7) | Garlic Clove (11) | Garlic Clove (11) NextKey (7) forward | NextKey (7) reverse | Garlic Clove (11) ACK Request (9) | Garlic Clove (11) | Termination (4) | Padding (254) DateTime 块（类型 0） 用途: 用于防重放和时钟偏移校验的时间戳\n大小: 7 字节（3 字节头部 + 4 字节数据）\n格式：\n+----+----+----+----+----+----+----+ | 0 | 4 | timestamp | +----+----+----+----+----+----+----+ 字段:\nblk: 0 size: 4（大端序） timestamp: 4 字节 - 以秒为单位的 Unix 时间戳（无符号，大端序） 时间戳格式：\ntimestamp = int(time.time()) # Seconds since 1970-01-01 00:00:00 UTC # Wraps around in year 2106 (4-byte unsigned maximum) 验证规则：\nMAX_CLOCK_SKEW_PAST = 5 * 60 # 5 minutes MAX_CLOCK_SKEW_FUTURE = 2 * 60 # 2 minutes def validate_datetime(timestamp): now = int(time.time()) age = now - timestamp if age \u0026lt; -MAX_CLOCK_SKEW_FUTURE: return False # Too far in future if age \u0026gt; MAX_CLOCK_SKEW_PAST: return False # Too old return True 重放防护：\nclass ReplayFilter: def __init__(self, duration=5*60): self.duration = duration # 5 minutes self.seen_messages = BloomFilter(size=100000, false_positive_rate=0.001) self.cleanup_timer = RepeatTimer(60, self.cleanup) def check_replay(self, ephemeral_key, timestamp): # Check timestamp validity if not validate_datetime(timestamp): return False # Check if ephemeral key seen recently if ephemeral_key in self.seen_messages: return False # Replay attack # Add to seen messages self.seen_messages.add(ephemeral_key) return True def cleanup(self): # Expire old entries (Bloom filter automatically ages out) pass 实现说明：\nNS Messages（NS 消息）: DateTime 必须是第一个块 NSR/ES Messages（NSR/ES 消息）: 通常不包含 DateTime 重放窗口: 建议的最小值为 5 分钟 布隆过滤器: 建议用于高效的重放检测 时钟偏差: 允许落后 5 分钟、超前 2 分钟 Garlic Clove Block（蒜瓣块） (Type 11) 目的: 封装 I2NP 消息以便传递\n格式：\n+----+----+----+----+----+----+----+----+ | 11 | size | | +----+----+----+ + | Delivery Instructions | ~ ~ | | +----+----+----+----+----+----+----+----+ |type| Message_ID | Expiration | +----+----+----+----+----+----+----+----+ | I2NP Message body | +----+ + ~ ~ | | +----+----+----+----+----+----+----+----+ 字段：\nblk: 11 size: 蒜瓣的总大小（可变） Delivery Instructions: 如 I2NP 规范所述 type: I2NP 消息类型（1 字节） Message_ID: I2NP 消息 ID（4 字节） Expiration: 以秒为单位的 Unix 时间戳（4 字节） I2NP Message body: 可变长度的消息数据 投递指令格式:\n本地投递 (1 字节):\n+----+ |0x00| +----+ 目的地递送 (33 字节):\n+----+----+----+----+----+----+----+----+ |0x01| | +----+ Destination Hash + | 32 bytes | + + | | +----+----+----+----+----+----+----+----+ Router Delivery (33 字节):\n+----+----+----+----+----+----+----+----+ |0x02| | +----+ Router Hash + | 32 bytes | + + | | +----+----+----+----+----+----+----+----+ Tunnel 投递 (37 字节):\n+----+----+----+----+----+----+----+----+ |0x03| Tunnel ID | +----+----+----+----+----+ + | Router Hash | + 32 bytes + | | + + | | +----+----+----+----+----+----+----+----+ I2NP 消息头 (共 9 字节):\n+----+----+----+----+----+----+----+----+ |type| msg_id | expiration | +----+----+----+----+----+----+----+----+ | | type: I2NP 消息类型（Database Store、Database Lookup、Data 等） msg_id: 4 字节消息标识符 expiration: 4 字节 Unix 时间戳（秒） 与 ElGamal 蒜瓣格式相比的重要差异：\n无证书: 证书字段省略（在 ElGamal（公钥加密算法）中未使用） 无 Clove ID: Clove（蒜瓣）ID 省略（过去始终为 0） 无 Clove 过期时间: 改用 I2NP 消息过期时间 紧凑头部: 9 字节的 I2NP 头部，相比更大的 ElGamal 格式 每个 Clove 为独立块: 无 CloveSet（Clove 集合）结构 多个 Cloves（蒜瓣）:\n# Multiple Garlic Cloves in one message payload = [ build_datetime_block(), build_garlic_clove(i2np_message_1), build_garlic_clove(i2np_message_2), build_garlic_clove(i2np_message_3), build_padding_block() ] Cloves（蒜瓣）中的常见 I2NP 消息类型:\nType Name Usage 1 DatabaseStore Publishing LeaseSet 2 DatabaseLookup Requesting LeaseSet 5 DeliveryStatus ACK (legacy, avoid in ECIES) 20 Data Streaming data 21 Garlic Nested garlic messages **蒜瓣处理：** def process_garlic_clove(clove_data): # Parse delivery instructions delivery_type = clove_data[0] if delivery_type == 0x00: # Local delivery offset = 1 elif delivery_type == 0x01: # Destination delivery dest_hash = clove_data[1:33] offset = 33 elif delivery_type == 0x02: # Router delivery router_hash = clove_data[1:33] offset = 33 elif delivery_type == 0x03: # Tunnel delivery tunnel_id = struct.unpack(\u0026#39;\u0026gt;I\u0026#39;, clove_data[1:5])[0] router_hash = clove_data[5:37] offset = 37 # Parse I2NP header i2np_type = clove_data[offset] msg_id = struct.unpack(\u0026#39;\u0026gt;I\u0026#39;, clove_data[offset+1:offset+5])[0] expiration = struct.unpack(\u0026#39;\u0026gt;I\u0026#39;, clove_data[offset+5:offset+9])[0] # Extract I2NP body i2np_body = clove_data[offset+9:] # Process message process_i2np_message(i2np_type, msg_id, expiration, i2np_body) NextKey (下一密钥) 块 (类型 7) 用途: DH 棘轮密钥交换\n格式（包含键 - 38 字节）：\n+----+----+----+----+----+----+----+----+ | 7 | 35 |flag| key ID | | +----+----+----+----+----+----+ + | | + Next DH Ratchet Public Key + | 32 bytes | + + | | + +----+----+ | | +----+----+----+----+----+----+ 格式 (仅密钥 ID - 6 字节):\n+----+----+----+----+----+----+ | 7 | 3 |flag| key ID | +----+----+----+----+----+----+ 字段：\nblk: 7 size: 3 (仅 ID) 或 35 (带密钥) flag: 1 字节 - 标志位 key ID: 2 字节 - 大端序的密钥标识符 (0-32767) Public Key: 32 字节 - X25519 公钥 (小端序), 若标志位 0 = 1 标志位：\nBit 7 6 5 4 3 2 1 0 | | | | | | | | | | | | | | | +-- Bit 0: Key present (1) or ID only (0) | | | | | | +---- Bit 1: Reverse key (1) or forward key (0) | | | | | +------ Bit 2: Request reverse key (1) or no request (0) | | | | | +-+-+-+-+-------- Bits 3-7: Reserved (set to 0) 标志示例：\n# Forward key present flags = 0x01 # Binary: 00000001 # Reverse key present flags = 0x03 # Binary: 00000011 # Forward key ID only (ACK) flags = 0x00 # Binary: 00000000 # Reverse key ID only (ACK) flags = 0x02 # Binary: 00000010 # Forward key ID with reverse request flags = 0x04 # Binary: 00000100 密钥 ID 规则：\nID 按顺序递增：0, 1, 2, \u0026hellip;, 32767 ID 仅在生成新密钥时递增 在下一次 ratchet（棘轮机制）之前，同一个 ID 会用于多条消息 最大 ID 为 32767（之后必须开始新的会话） 使用示例：\n# Initiating ratchet (sender generates new key) nextkey = NextKeyBlock( flags=0x01, # Key present, forward key_id=0, public_key=sender_new_pk ) # Replying to ratchet (receiver generates new key) nextkey = NextKeyBlock( flags=0x03, # Key present, reverse key_id=0, public_key=receiver_new_pk ) # Acknowledging ratchet (no new key from sender) nextkey = NextKeyBlock( flags=0x02, # ID only, reverse key_id=0 ) # Requesting reverse ratchet nextkey = NextKeyBlock( flags=0x04, # Request reverse, forward ID key_id=1 ) 处理逻辑：\ndef process_nextkey_block(block): flags = block.flags key_id = block.key_id key_present = (flags \u0026amp; 0x01) != 0 is_reverse = (flags \u0026amp; 0x02) != 0 request_reverse = (flags \u0026amp; 0x04) != 0 if key_present: public_key = block.public_key if is_reverse: # Reverse key received perform_dh_ratchet(receiver_key=public_key, key_id=key_id) # Sender should ACK with own key ID else: # Forward key received perform_dh_ratchet(sender_key=public_key, key_id=key_id) # Receiver should reply with reverse key send_reverse_key(generate_new_key()) else: # Key ID only (ACK) if is_reverse: # Reverse key ACK confirm_reverse_ratchet(key_id) else: # Forward key ACK confirm_forward_ratchet(key_id) if request_reverse: # Sender requests receiver to generate new key send_reverse_key(generate_new_key()) 多个 NextKey（下一密钥）块：\n当双向同时进行棘轮推进（ratcheting）时，单个 ES message（ES 消息）最多可包含 2 个 NextKey blocks（NextKey 块）：\n# Both directions ratcheting payload = [ NextKeyBlock(flags=0x01, key_id=2, public_key=forward_key), # Forward NextKeyBlock(flags=0x03, key_id=1, public_key=reverse_key), # Reverse build_garlic_clove(data) ] ACK（确认）块（类型 8） 目的: 在带内确认已接收的消息\n格式（单个 ACK - 7 字节）：\n+----+----+----+----+----+----+----+ | 8 | 4 |tagsetid | N | +----+----+----+----+----+----+----+ 格式（多个 ACK（确认））：\n+----+----+----+----+----+----+----+----+ | 8 | size |tagsetid | N | | +----+----+----+----+----+----+----+ + | more ACKs | ~ ... ~ | | +----+----+----+----+----+----+----+----+ 字段：\nblk: 8 size: 4 * ACK（确认）数量（最少 4） 对于每个 ACK: tagsetid: 2 字节 - 大端序的标签集 ID（0-65535） N: 2 字节 - 大端序的消息编号（0-65535） 标签集 ID 的确定:\n# Tag set 0 (initial, after NSR) tagset_id = 0 # After first ratchet (tag set 1) # Both Alice and Bob sent key ID 0 tagset_id = 1 + 0 + 0 = 1 # After second ratchet (tag set 2) # Alice sent key ID 1, Bob still using key ID 0 tagset_id = 1 + 1 + 0 = 2 # After third ratchet (tag set 3) # Alice still using key ID 1, Bob sent key ID 1 tagset_id = 1 + 1 + 1 = 3 单个 ACK（确认）示例：\n# ACK message from tag set 5, message number 127 ack_block = ACKBlock( tagset_id=5, message_number=127 ) # Wire format (7 bytes): # 08 00 04 00 05 00 7F # | | | | | | | # | | | | | | +-- N (127) # | | | | +--------- N high byte # | | | +------------ tagset_id (5) # | | +--------------- tagset_id high byte # | +------------------ size (4) # +--------------------- type (8) 多个 ACK 示例:\n# ACK three messages ack_block = ACKBlock([ (tagset_id=3, N=42), (tagset_id=3, N=43), (tagset_id=4, N=0) ]) # Wire format (15 bytes): # 08 00 0C 00 03 00 2A 00 03 00 2B 00 04 00 00 # (ts=3, N=42) (ts=3, N=43) (ts=4, N=0) 处理：\ndef process_ack_block(block): num_acks = block.size // 4 for i in range(num_acks): offset = i * 4 tagset_id = struct.unpack(\u0026#39;\u0026gt;H\u0026#39;, block.data[offset:offset+2])[0] message_num = struct.unpack(\u0026#39;\u0026gt;H\u0026#39;, block.data[offset+2:offset+4])[0] # Mark message as acknowledged mark_acked(tagset_id, message_num) # May trigger retransmission timeout cancellation cancel_retransmit_timer(tagset_id, message_num) 何时发送确认(ACK):\n显式 ACK（确认）请求: 始终对 ACK 请求块作出响应 LeaseSet 递送: 当发送方在消息中包含 LeaseSet 时 会话建立: 可对 NS/NSR 进行 ACK（尽管协议更倾向于通过 ES 实现隐式 ACK） 棘轮确认: 可对 NextKey 的接收进行 ACK 应用层: 按更高层协议的要求（例如，Streaming） ACK（确认）时序:\nclass ACKManager: def __init__(self): self.pending_acks = [] self.ack_timer = None def request_ack(self, tagset_id, message_num): self.pending_acks.append((tagset_id, message_num)) if not self.ack_timer: # Delay ACK briefly to allow higher layer to respond self.ack_timer = set_timer(0.1, self.send_acks) # 100ms def send_acks(self): if self.pending_acks and not has_outbound_data(): # No higher layer data, send explicit ACK send_es_message(build_ack_block(self.pending_acks)) # Otherwise, ACK will piggyback on next ES message self.pending_acks = [] self.ack_timer = None ACK Request Block（确认请求块）（类型 9） 目的: 请求对当前消息进行带内确认\n格式：\n+----+----+----+----+ | 9 | 1 |flg | +----+----+----+----+ 字段：\nblk: 9 size: 1 flg: 1 字节 - 标志位（所有位当前未使用，设为 0） 用法：\n# Request ACK for this message payload = [ build_ack_request_block(), build_garlic_clove(important_data) ] 接收方响应：\n收到 ACK 请求时：\n带即时数据: 将 ACK 块包含在即时响应中 无即时数据: 启动定时器（例如，100ms），如果定时器到期则发送带 ACK 的空 ES 标签集 ID: 使用当前入站标签集 ID 消息编号: 使用与接收到的会话标签关联的消息编号 处理：\ndef process_ack_request(message): # Extract message identification tagset_id = message.tagset_id message_num = message.message_num # Schedule ACK schedule_ack(tagset_id, message_num) # If no data to send immediately, start timer if not has_pending_data(): set_timer(0.1, lambda: send_ack_only(tagset_id, message_num)) 何时使用 ACK 请求：\n关键消息: 必须收到确认的消息 LeaseSet 传递: 当捆绑一个 LeaseSet 时 Session Ratchet: （会话棘轮，一种会话密钥更新机制）在发送 NextKey block（NextKey 块，用于会话密钥更新）之后 传输结束: 当发送方没有更多数据可发送但希望得到确认时 何时不应使用：\n流式协议: 流式层处理 ACK 高频消息: 避免对每条消息都发起 ACK 请求（额外开销） 不重要的数据报: 原始数据报通常不需要 ACK 终止块（类型 4） 状态: 未实现\n目的: 优雅地终止会话\n格式：\n+----+----+----+----+----+----+----+----+ | 4 | size | rsn| addl data | +----+----+----+----+ + ~ ... ~ +----+----+----+----+----+----+----+----+ 字段：\nblk: 4 size: 1 个或更多字节 rsn: 1 字节 - 原因代码 addl data: 可选的附加数据 (格式取决于原因) 原因代码：\nCode Meaning Additional Data 0 Normal close / unspecified None 1 Termination received None 2 Idle timeout None (implementation-specific) 3 Resource exhaustion None (implementation-specific) 4+ Reserved Implementation-specific **用法（实现后）：** # Normal session close termination = TerminationBlock( reason=0, additional_data=b\u0026#39;\u0026#39; ) # Session termination due to received termination termination = TerminationBlock( reason=1, additional_data=b\u0026#39;\u0026#39; ) 规则：\n除 Padding（填充）外，必须是最后一个块 如果存在，Padding 必须紧随 Termination（终止）之后 不允许出现在 NS 或 NSR 消息中 仅允许出现在 ES 消息中 选项块 (类型 5) 状态: 未实现\n目的: 协商会话参数\n格式：\n+----+----+----+----+----+----+----+----+ | 5 | size |ver |flg |STL |STimeout | +----+----+----+----+----+----+----+----+ | SOTW | RITW |tmin|tmax|rmin|rmax| +----+----+----+----+----+----+----+----+ | tdmy | rdmy | tdelay | rdelay | +----+----+----+----+----+----+----+----+ | more_options | ~ ... ~ | | +----+----+----+----+----+----+----+----+ 字段：\nblk: 5 size: 21 字节或以上 ver: 1 字节 - 协议版本（必须为 0） flg: 1 字节 - 标志位（当前所有位未使用） STL: 1 字节 - 会话标签长度（必须为 8） STimeout: 2 字节 - 会话空闲超时（以秒为单位，大端序） SOTW: 2 字节 - 发送方出站标签窗口（大端序） RITW: 2 字节 - 接收方入站标签窗口（大端序） tmin, tmax, rmin, rmax: 各 1 字节 - 填充参数（4.4 固定点） tdmy: 2 字节 - 愿意发送的最大填充流量（字节/秒，大端序） rdmy: 2 字节 - 请求的填充流量（字节/秒，大端序） tdelay: 2 字节 - 愿意插入的最大消息内延迟（毫秒，大端序） rdelay: 2 字节 - 请求的消息内延迟（毫秒，大端序） more_options: 变长 - 未来扩展 填充参数 (4.4 定点数):\ndef encode_padding_ratio(ratio): \u0026#34;\u0026#34;\u0026#34; Encode padding ratio as 4.4 fixed-point ratio: 0.0 to 15.9375 returns: 0x00 to 0xFF \u0026#34;\u0026#34;\u0026#34; return int(ratio * 16) def decode_padding_ratio(encoded): \u0026#34;\u0026#34;\u0026#34; Decode 4.4 fixed-point to ratio encoded: 0x00 to 0xFF returns: 0.0 to 15.9375 \u0026#34;\u0026#34;\u0026#34; return encoded / 16.0 # Examples: # 0x00 = 0.0 (no padding) # 0x01 = 0.0625 (6.25% padding) # 0x10 = 1.0 (100% padding - double traffic) # 0x80 = 8.0 (800% padding - 9x traffic) # 0xFF = 15.9375 (1593.75% padding) 标签窗口协商：\n# SOTW: Sender\u0026#39;s recommendation for receiver\u0026#39;s inbound window # RITW: Sender\u0026#39;s declaration of own inbound window # Receiver calculates actual inbound window: inbound_window = calculate_window( sender_suggestion=SOTW, own_constraints=MAX_INBOUND_TAGS, own_resources=available_memory() ) # Sender uses: # - RITW to know how far ahead receiver will accept # - Own SOTW to hint optimal window size 默认值（未协商选项时）：\nDEFAULT_OPTIONS = { \u0026#39;version\u0026#39;: 0, \u0026#39;session_tag_length\u0026#39;: 8, \u0026#39;session_timeout\u0026#39;: 600, # 10 minutes \u0026#39;sender_outbound_tag_window\u0026#39;: 160, \u0026#39;receiver_inbound_tag_window\u0026#39;: 160, \u0026#39;tmin\u0026#39;: 0x00, # No minimum padding \u0026#39;tmax\u0026#39;: 0x10, # Up to 100% padding \u0026#39;rmin\u0026#39;: 0x00, # No minimum requested \u0026#39;rmax\u0026#39;: 0x10, # Up to 100% requested \u0026#39;tdmy\u0026#39;: 0, # No dummy traffic \u0026#39;rdmy\u0026#39;: 0, # No dummy traffic requested \u0026#39;tdelay\u0026#39;: 0, # No delay \u0026#39;rdelay\u0026#39;: 0 # No delay requested } MessageNumbers 块 (类型 6) 状态: 未实现\n目的: 指示在前一个标签集中发送的最后一条消息（从而实现序号缺失检测）\n格式：\n+----+----+----+----+----+ | 6 | 2 | PN | +----+----+----+----+----+ 字段：\nblk: 6 size: 2 PN: 2 字节 - 上一个标签集的最后消息编号（大端序，0-65535） PN (Previous Number，前一编号) 定义：\nPN 是上一标签集中最后发送的标签的索引。\n用法（实现后）：\n# After ratcheting to new tag set # Old tag set: sent messages 0-4095 # New tag set: sending first message payload = [ MessageNumbersBlock(PN=4095), build_garlic_clove(data) ] 接收端的好处：\ndef process_message_numbers(pn_value): # Receiver can now: # 1. Determine if any messages were skipped highest_received_in_old_tagset = 4090 if pn_value \u0026gt; highest_received_in_old_tagset: missing_count = pn_value - highest_received_in_old_tagset # 5 messages were never received # 2. Delete tags higher than PN from old tagset for tag_index in range(pn_value + 1, MAX_TAG_INDEX): delete_tag(old_tagset, tag_index) # 3. Expire tags ≤ PN after grace period (e.g., 2 minutes) schedule_deletion(old_tagset, delay=120) 规则：\n在 tag set（标签集）0 中不得发送（没有先前的 tag set） 仅在 ES messages（ES 类型消息）中发送 仅在新的 tag set 的起始消息中发送 PN value（PN 值）是从发送方的视角出发的（指发送方上一次发送的 tag） 与 Signal 的关系：\n在 Signal Double Ratchet（双重棘轮算法）中，PN 位于消息头中。在 ECIES（椭圆曲线集成加密方案）中，它位于加密载荷内，且是可选的。\nPadding Block（填充块）(类型 254) Purpose: 抵抗流量分析并对消息大小进行混淆\n格式：\n+----+----+----+----+----+----+----+----+ |254 | size | padding | +----+----+----+ + | | ~ ... ~ | | +----+----+----+----+----+----+----+----+ 字段：\nblk: 254 size: 0-65516 字节（大端序） padding: 随机或全零数据 规则：\n必须是消息中的最后一个块 不允许存在多个填充块 可以为零长度（仅 3 字节头部） 填充数据可以为全零或随机字节 默认填充：\nDEFAULT_PADDING_MIN = 0 DEFAULT_PADDING_MAX = 15 def generate_default_padding(): size = random.randint(DEFAULT_PADDING_MIN, DEFAULT_PADDING_MAX) data = random.bytes(size) # or zeros return PaddingBlock(size, data) 抗流量分析策略：\n策略 1：随机大小（默认）\n# Add 0-15 bytes random padding to each message padding_size = random.randint(0, 15) padding_block = PaddingBlock(padding_size, random.bytes(padding_size)) 策略 2：四舍五入到指定倍数\n# Round total message size to next multiple of 64 target_size = ((message_size + 63) // 64) * 64 padding_size = target_size - message_size - 3 # -3 for block header padding_block = PaddingBlock(padding_size, random.bytes(padding_size)) 策略 3：固定消息大小\n# Always send 1KB messages TARGET_MESSAGE_SIZE = 1024 padding_size = TARGET_MESSAGE_SIZE - message_size - 3 padding_block = PaddingBlock(padding_size, random.bytes(padding_size)) 策略 4：协商填充（选项块）\n# Calculate padding based on negotiated parameters # tmin, tmax from Options block min_padding = int(payload_size * tmin_ratio) max_padding = int(payload_size * tmax_ratio) padding_size = random.randint(min_padding, max_padding) padding_block = PaddingBlock(padding_size, random.bytes(padding_size)) 纯填充消息：\n消息可能完全由填充组成（无应用数据）：\n# Dummy traffic message payload = [ PaddingBlock(random.randint(100, 500), random.bytes(...)) ] 实现说明:\n全零填充: 可接受 (将由 ChaCha20 加密) 随机填充: 在加密后不提供额外的安全性，但会消耗更多熵 性能: 生成随机填充的开销可能较大；可考虑使用零填充 内存: 大的填充块会消耗带宽；请谨慎设定最大尺寸 实现指南 先决条件 密码学库:\nX25519: libsodium、NaCl 或 Bouncy Castle ChaCha20-Poly1305: libsodium、OpenSSL 1.1.0+ 或 Bouncy Castle SHA-256: OpenSSL、Bouncy Castle 或编程语言内置支持 Elligator2: 库支持有限；可能需要自定义实现 Elligator2（密码学隐蔽编码算法）实现：\nElligator2（将椭圆曲线点映射为均匀随机位串的编码方法）尚未被广泛实现。可选方案：\nOBFS4：Tor 的 obfs4 可插拔传输包含对 Elligator2（用于隐藏椭圆曲线点的映射算法）的实现 自定义实现：基于 Elligator2 论文 kleshni/Elligator：GitHub 上的参考实现 Java I2P 说明： Java I2P 使用 net.i2p.crypto.eddsa 库，并包含自定义的 Elligator2（椭圆曲线点映射技术）扩展。\n推荐的实现顺序 阶段 1：核心密码学 1. X25519 DH 密钥生成与交换 2. ChaCha20-Poly1305 AEAD 加密/解密 3. SHA-256 哈希与 MixHash 4. HKDF 密钥派生 5. Elligator2 编码/解码（可先使用测试向量）\n第 2 阶段：消息格式 1. NS 消息 (未绑定) - 最简单的格式 2. NS 消息 (已绑定) - 添加静态密钥 3. NSR 消息 4. ES 消息 5. 块解析与生成\n第 3 阶段：会话管理 1. 会话创建与存储 2. 标签集管理 (发送方和接收方) 3. 会话标签棘轮 4. 对称密钥棘轮 5. 标签查找与窗口管理\n第 4 阶段：DH 棘轮 1. NextKey 块处理 2. DH 棘轮 KDF（密钥派生函数） 3. 棘轮之后的标签集创建 4. 多标签集管理\n第 5 阶段：协议逻辑 1. NS/NSR/ES 状态机 2. 重放防护 (DateTime, 布隆过滤器) 3. 重传逻辑 (多个 NS/NSR) 4. ACK 处理\n第6阶段：集成 1. I2NP Garlic Clove（蒜瓣）处理 2. LeaseSet 打包 3. 流式传输协议集成 4. 数据报协议集成\n发送端实现 出站会话生命周期：\nclass OutboundSession: def __init__(self, destination, bound=True): self.destination = destination self.bound = bound self.state = SessionState.NEW # Keys for NS message self.ephemeral_keypair = generate_elg2_keypair() if bound: self.static_key = context.static_keypair # Will be populated after NSR self.outbound_tagset = None self.outbound_keyratchet = None self.inbound_tagset = None self.inbound_keyratchet = None # Timing self.created_time = now() self.last_activity = now() # Retransmission self.ns_attempts = [] self.ns_timer = None def send_initial_message(self, payload): \u0026#34;\u0026#34;\u0026#34;Send NS message\u0026#34;\u0026#34;\u0026#34; # Build NS message ns_message = self.build_ns_message(payload) # Send send_to_network(self.destination, ns_message) # Track for retransmission self.ns_attempts.append({ \u0026#39;message\u0026#39;: ns_message, \u0026#39;time\u0026#39;: now(), \u0026#39;ephemeral_key\u0026#39;: self.ephemeral_keypair, \u0026#39;kdf_state\u0026#39;: self.save_kdf_state() }) # Start timer self.ns_timer = set_timer(1.0, self.on_ns_timeout) self.state = SessionState.PENDING_REPLY def build_ns_message(self, payload): \u0026#34;\u0026#34;\u0026#34;Construct NS message\u0026#34;\u0026#34;\u0026#34; # KDF initialization chainKey, h = self.initialize_kdf() # Ephemeral key section elg2_ephemeral = ENCODE_ELG2(self.ephemeral_keypair.public_key) h = SHA256(h || self.destination.static_key) h = SHA256(h || self.ephemeral_keypair.public_key) # es DH es_shared = DH(self.ephemeral_keypair.private_key, self.destination.static_key) keydata = HKDF(chainKey, es_shared, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k_static = keydata[32:63] # Encrypt static key section if self.bound: static_section = self.static_key.public_key else: static_section = bytes(32) static_ciphertext = ENCRYPT(k_static, 0, static_section, h) h = SHA256(h || static_ciphertext) # ss DH (if bound) if self.bound: ss_shared = DH(self.static_key.private_key, self.destination.static_key) keydata = HKDF(chainKey, ss_shared, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k_payload = keydata[32:63] nonce = 0 else: k_payload = k_static nonce = 1 # Build payload blocks payload_data = self.build_ns_payload(payload) # Encrypt payload payload_ciphertext = ENCRYPT(k_payload, nonce, payload_data, h) h = SHA256(h || payload_ciphertext) # Save KDF state for NSR processing self.ns_chainkey = chainKey self.ns_hash = h # Assemble message return elg2_ephemeral + static_ciphertext + payload_ciphertext def build_ns_payload(self, application_data): \u0026#34;\u0026#34;\u0026#34;Build NS payload blocks\u0026#34;\u0026#34;\u0026#34; blocks = [] # DateTime block (required, first) blocks.append(build_datetime_block()) # Garlic Clove(s) with application data blocks.append(build_garlic_clove(application_data)) # Optionally bundle LeaseSet if should_send_leaseset(): blocks.append(build_garlic_clove(build_leaseset_store())) # Padding blocks.append(build_padding_block(random.randint(0, 15))) return encode_blocks(blocks) def on_nsr_received(self, nsr_message): \u0026#34;\u0026#34;\u0026#34;Process NSR and establish ES session\u0026#34;\u0026#34;\u0026#34; # Cancel retransmission timer cancel_timer(self.ns_timer) # Parse NSR tag = nsr_message[0:8] elg2_bob_ephemeral = nsr_message[8:40] key_section_mac = nsr_message[40:56] payload_ciphertext = nsr_message[56:] # Find corresponding NS attempt ns_state = self.find_ns_by_tag(tag) if not ns_state: raise ValueError(\u0026#34;NSR tag doesn\u0026#39;t match any NS\u0026#34;) # Restore KDF state chainKey = ns_state[\u0026#39;chainkey\u0026#39;] h = ns_state[\u0026#39;hash\u0026#39;] # Decode Bob\u0026#39;s ephemeral key bob_ephemeral = DECODE_ELG2(elg2_bob_ephemeral) # Mix tag and Bob\u0026#39;s ephemeral into hash h = SHA256(h || tag) h = SHA256(h || bob_ephemeral) # ee DH ee_shared = DH(self.ephemeral_keypair.private_key, bob_ephemeral) keydata = HKDF(chainKey, ee_shared, \u0026#34;\u0026#34;, 32) chainKey = keydata[0:31] # se DH se_shared = DH(self.static_key.private_key, bob_ephemeral) keydata = HKDF(chainKey, se_shared, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k_key_section = keydata[32:63] # Verify key section MAC try: DECRYPT(k_key_section, 0, key_section_mac, h) except AuthenticationError: raise ValueError(\u0026#34;NSR key section MAC verification failed\u0026#34;) h = SHA256(h || key_section_mac) # Split for bidirectional ES keydata = HKDF(chainKey, ZEROLEN, \u0026#34;\u0026#34;, 64) k_ab = keydata[0:31] # Alice → Bob k_ba = keydata[32:63] # Bob → Alice # Initialize ES tagsets self.outbound_tagset = DH_INITIALIZE(chainKey, k_ab) self.inbound_tagset = DH_INITIALIZE(chainKey, k_ba) # Decrypt NSR payload k_nsr = HKDF(k_ba, ZEROLEN, \u0026#34;AttachPayloadKDF\u0026#34;, 32) try: payload = DECRYPT(k_nsr, 0, payload_ciphertext, h) except AuthenticationError: raise ValueError(\u0026#34;NSR payload MAC verification failed\u0026#34;) # Process NSR payload blocks self.process_payload_blocks(payload) # Session established self.state = SessionState.ESTABLISHED self.last_activity = now() # Send ES message (implicit ACK) self.send_es_ack() def send_es_message(self, payload): \u0026#34;\u0026#34;\u0026#34;Send ES message\u0026#34;\u0026#34;\u0026#34; if self.state != SessionState.ESTABLISHED: raise ValueError(\u0026#34;Session not established\u0026#34;) # Get next tag and key tag, index = self.outbound_tagset.get_next_tag() key = self.outbound_keyratchet.get_key(index) # Construct nonce nonce = construct_nonce(index) # Build payload blocks payload_data = self.build_es_payload(payload) # AEAD encryption ciphertext = ENCRYPT(key, nonce, payload_data, tag) # Assemble message es_message = tag + ciphertext # Send send_to_network(self.destination, es_message) # Update activity self.last_activity = now() # Check if ratchet needed if self.outbound_tagset.should_ratchet(): self.initiate_ratchet() 接收端实现 入站会话生命周期：\nclass InboundSession: def __init__(self): self.state = None self.bound = False self.destination = None # Keys self.remote_ephemeral_key = None self.remote_static_key = None self.ephemeral_keypair = None # Tagsets self.inbound_tagset = None self.outbound_tagset = None # Timing self.created_time = None self.last_activity = None # Paired session self.paired_outbound = None @staticmethod def try_decrypt_ns(message): \u0026#34;\u0026#34;\u0026#34;Attempt to decrypt as NS message\u0026#34;\u0026#34;\u0026#34; # Parse NS structure elg2_ephemeral = message[0:32] static_ciphertext = message[32:80] # 32 + 16 payload_ciphertext = message[80:] # Decode ephemeral key try: alice_ephemeral = DECODE_ELG2(elg2_ephemeral) except: return None # Not a valid Elligator2 encoding # Check replay if is_replay(alice_ephemeral): return None # KDF initialization chainKey, h = initialize_kdf() # Mix keys h = SHA256(h || context.static_keypair.public_key) h = SHA256(h || alice_ephemeral) # es DH es_shared = DH(context.static_keypair.private_key, alice_ephemeral) keydata = HKDF(chainKey, es_shared, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k_static = keydata[32:63] # Decrypt static key section try: static_data = DECRYPT(k_static, 0, static_ciphertext, h) except AuthenticationError: return None # Not a valid NS message h = SHA256(h || static_ciphertext) # Check if bound or unbound if static_data == bytes(32): # Unbound alice_static_key = None k_payload = k_static nonce = 1 else: # Bound - perform ss DH alice_static_key = static_data ss_shared = DH(context.static_keypair.private_key, alice_static_key) keydata = HKDF(chainKey, ss_shared, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k_payload = keydata[32:63] nonce = 0 # Decrypt payload try: payload = DECRYPT(k_payload, nonce, payload_ciphertext, h) except AuthenticationError: return None h = SHA256(h || payload_ciphertext) # Create session session = InboundSession() session.state = SessionState.ESTABLISHED session.created_time = now() session.last_activity = now() session.remote_ephemeral_key = alice_ephemeral session.remote_static_key = alice_static_key session.bound = (alice_static_key is not None) session.ns_chainkey = chainKey session.ns_hash = h # Extract destination if bound if session.bound: session.destination = extract_destination_from_payload(payload) # Process payload session.process_payload_blocks(payload) return session def send_nsr_reply(self, reply_payload): \u0026#34;\u0026#34;\u0026#34;Send NSR message\u0026#34;\u0026#34;\u0026#34; # Generate NSR tagset tagsetKey = HKDF(self.ns_chainkey, ZEROLEN, \u0026#34;SessionReplyTags\u0026#34;, 32) nsr_tagset = DH_INITIALIZE(self.ns_chainkey, tagsetKey) # Get tag tag, _ = nsr_tagset.get_next_tag() # Mix tag into hash h = SHA256(self.ns_hash || tag) # Generate ephemeral key self.ephemeral_keypair = generate_elg2_keypair() bob_ephemeral = self.ephemeral_keypair.public_key elg2_bob_ephemeral = ENCODE_ELG2(bob_ephemeral) # Mix ephemeral key h = SHA256(h || bob_ephemeral) chainKey = self.ns_chainkey # ee DH ee_shared = DH(self.ephemeral_keypair.private_key, self.remote_ephemeral_key) keydata = HKDF(chainKey, ee_shared, \u0026#34;\u0026#34;, 32) chainKey = keydata[0:31] # se DH se_shared = DH(context.static_keypair.private_key, self.remote_ephemeral_key) keydata = HKDF(chainKey, se_shared, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k_key_section = keydata[32:63] # Encrypt key section (empty) key_section_ciphertext = ENCRYPT(k_key_section, 0, ZEROLEN, h) h = SHA256(h || key_section_ciphertext) # Split for bidirectional ES keydata = HKDF(chainKey, ZEROLEN, \u0026#34;\u0026#34;, 64) k_ab = keydata[0:31] # Alice → Bob k_ba = keydata[32:63] # Bob → Alice # Initialize ES tagsets self.inbound_tagset = DH_INITIALIZE(chainKey, k_ab) self.outbound_tagset = DH_INITIALIZE(chainKey, k_ba) # Build reply payload payload_data = build_payload_blocks(reply_payload) # Encrypt payload k_nsr = HKDF(k_ba, ZEROLEN, \u0026#34;AttachPayloadKDF\u0026#34;, 32) payload_ciphertext = ENCRYPT(k_nsr, 0, payload_data, h) # Assemble NSR nsr_message = tag + elg2_bob_ephemeral + key_section_ciphertext + payload_ciphertext # Send send_to_network(self.destination, nsr_message) # Wait for ES self.state = SessionState.AWAITING_ES self.last_activity = now() def on_es_received(self, es_message): \u0026#34;\u0026#34;\u0026#34;Process first ES message\u0026#34;\u0026#34;\u0026#34; if self.state == SessionState.AWAITING_ES: # First ES received, confirms session self.state = SessionState.ESTABLISHED # Process ES message self.process_es_message(es_message) def process_es_message(self, es_message): \u0026#34;\u0026#34;\u0026#34;Decrypt and process ES message\u0026#34;\u0026#34;\u0026#34; # Extract tag tag = es_message[0:8] ciphertext = es_message[8:] # Look up tag index = self.inbound_tagset.lookup_tag(tag) if index is None: raise ValueError(\u0026#34;Tag not found\u0026#34;) # Get key key = self.inbound_keyratchet.get_key(index) # Construct nonce nonce = construct_nonce(index) # Decrypt try: payload = DECRYPT(key, nonce, ciphertext, tag) except AuthenticationError: raise ValueError(\u0026#34;ES MAC verification failed\u0026#34;) # Process blocks self.process_payload_blocks(payload) # Update activity self.last_activity = now() 消息分类 区分消息类型：\ndef classify_message(message): \u0026#34;\u0026#34;\u0026#34;Determine message type\u0026#34;\u0026#34;\u0026#34; # Minimum lengths if len(message) \u0026lt; 24: return None # Too short # Check for session tag (8 bytes) tag = message[0:8] # Try ES decryption first (most common) session = lookup_session_by_tag(tag) if session: return (\u0026#39;ES\u0026#39;, session) # Try NSR decryption (tag + Elligator2 key) if len(message) \u0026gt;= 72: # Check if bytes 8-40 are valid Elligator2 try: nsr_ephemeral = DECODE_ELG2(message[8:40]) nsr_session = find_pending_nsr_by_tag(tag) if nsr_session: return (\u0026#39;NSR\u0026#39;, nsr_session) except: pass # Try NS decryption (starts with Elligator2 key) if len(message) \u0026gt;= 96: try: ns_ephemeral = DECODE_ELG2(message[0:32]) ns_session = InboundSession.try_decrypt_ns(message) if ns_session: return (\u0026#39;NS\u0026#39;, ns_session) except: pass # Check ElGamal/AES (for dual-key compatibility) if len(message) \u0026gt;= 514: if (len(message) - 2) % 16 == 0: # Might be ElGamal NS return (\u0026#39;ELGAMAL_NS\u0026#39;, None) elif len(message) % 16 == 0: # Might be ElGamal ES return (\u0026#39;ELGAMAL_ES\u0026#39;, None) return None # Unknown message type 会话管理最佳实践 会话存储：\nclass SessionKeyManager: def __init__(self): # Outbound sessions (one per destination) self.outbound_sessions = {} # destination -\u0026gt; OutboundSession # Inbound sessions (multiple per destination during transition) self.inbound_sessions = [] # [InboundSession] # Session tag lookup (fast path for ES messages) self.tag_to_session = {} # tag -\u0026gt; InboundSession # Limits self.max_inbound_sessions = 1000 self.max_tags_per_session = 160 def get_outbound_session(self, destination): \u0026#34;\u0026#34;\u0026#34;Get or create outbound session\u0026#34;\u0026#34;\u0026#34; if destination not in self.outbound_sessions: session = OutboundSession(destination) self.outbound_sessions[destination] = session return self.outbound_sessions[destination] def add_inbound_session(self, session): \u0026#34;\u0026#34;\u0026#34;Add new inbound session\u0026#34;\u0026#34;\u0026#34; # Check limits if len(self.inbound_sessions) \u0026gt;= self.max_inbound_sessions: self.expire_oldest_session() self.inbound_sessions.append(session) # Add tags to lookup table self.register_session_tags(session) def register_session_tags(self, session): \u0026#34;\u0026#34;\u0026#34;Register session\u0026#39;s tags in lookup table\u0026#34;\u0026#34;\u0026#34; for tag in session.inbound_tagset.get_all_tags(): self.tag_to_session[tag] = session def lookup_tag(self, tag): \u0026#34;\u0026#34;\u0026#34;Fast tag lookup\u0026#34;\u0026#34;\u0026#34; return self.tag_to_session.get(tag) def expire_sessions(self): \u0026#34;\u0026#34;\u0026#34;Periodic session expiration\u0026#34;\u0026#34;\u0026#34; now_time = now() # Expire outbound sessions for dest, session in list(self.outbound_sessions.items()): if session.idle_time(now_time) \u0026gt; 8 * 60: del self.outbound_sessions[dest] # Expire inbound sessions expired = [] for session in self.inbound_sessions: if session.idle_time(now_time) \u0026gt; 10 * 60: expired.append(session) for session in expired: self.remove_inbound_session(session) def remove_inbound_session(self, session): \u0026#34;\u0026#34;\u0026#34;Remove inbound session and clean up tags\u0026#34;\u0026#34;\u0026#34; self.inbound_sessions.remove(session) # Remove tags from lookup for tag in session.inbound_tagset.get_all_tags(): if tag in self.tag_to_session: del self.tag_to_session[tag] 内存管理：\nclass TagMemoryManager: def __init__(self, max_memory_kb=10240): # 10 MB default self.max_memory = max_memory_kb * 1024 self.current_memory = 0 self.max_tags_per_session = 160 self.min_tags_per_session = 32 def calculate_tag_memory(self, session): \u0026#34;\u0026#34;\u0026#34;Calculate memory used by session tags\u0026#34;\u0026#34;\u0026#34; tag_count = len(session.inbound_tagset.tags) # Each tag: 8 bytes (tag) + 2 bytes (index) + 32 bytes (key, optional) # + overhead bytes_per_tag = 16 if session.defer_keys else 48 return tag_count * bytes_per_tag def check_pressure(self): \u0026#34;\u0026#34;\u0026#34;Check if under memory pressure\u0026#34;\u0026#34;\u0026#34; return self.current_memory \u0026gt; (self.max_memory * 0.9) def handle_pressure(self): \u0026#34;\u0026#34;\u0026#34;Reduce memory usage when under pressure\u0026#34;\u0026#34;\u0026#34; if not self.check_pressure(): return # Strategy 1: Reduce look-ahead windows for session in all_sessions: if session.look_ahead \u0026gt; self.min_tags_per_session: session.reduce_look_ahead(self.min_tags_per_session) # Strategy 2: Trim old tags aggressively for session in all_sessions: session.inbound_tagset.trim_behind(aggressive=True) # Strategy 3: Refuse new ratchets for session in all_sessions: if session.outbound_tagset.should_ratchet(): session.defer_ratchet = True # Strategy 4: Expire idle sessions early expire_idle_sessions(threshold=5*60) # 5 min instead of 10 测试策略 单元测试：\ndef test_x25519_dh(): \u0026#34;\u0026#34;\u0026#34;Test X25519 key exchange\u0026#34;\u0026#34;\u0026#34; alice_sk = GENERATE_PRIVATE() alice_pk = DERIVE_PUBLIC(alice_sk) bob_sk = GENERATE_PRIVATE() bob_pk = DERIVE_PUBLIC(bob_sk) # Both sides compute same shared secret alice_shared = DH(alice_sk, bob_pk) bob_shared = DH(bob_sk, alice_pk) assert alice_shared == bob_shared def test_elligator2_encode_decode(): \u0026#34;\u0026#34;\u0026#34;Test Elligator2 roundtrip\u0026#34;\u0026#34;\u0026#34; sk = GENERATE_PRIVATE_ELG2() pk = DERIVE_PUBLIC(sk) encoded = ENCODE_ELG2(pk) decoded = DECODE_ELG2(encoded) assert decoded == pk def test_chacha_poly_encrypt_decrypt(): \u0026#34;\u0026#34;\u0026#34;Test ChaCha20-Poly1305 AEAD\u0026#34;\u0026#34;\u0026#34; key = CSRNG(32) nonce = construct_nonce(42) plaintext = b\u0026#34;Hello, I2P!\u0026#34; ad = b\u0026#34;associated_data\u0026#34; ciphertext = ENCRYPT(key, nonce, plaintext, ad) decrypted = DECRYPT(key, nonce, ciphertext, ad) assert decrypted == plaintext def test_session_tag_ratchet(): \u0026#34;\u0026#34;\u0026#34;Test session tag generation\u0026#34;\u0026#34;\u0026#34; sessTag_ck = CSRNG(32) tagset = SessionTagRatchet(sessTag_ck) # Generate 100 tags tags = [tagset.get_next_tag() for _ in range(100)] # All tags should be unique assert len(set(tags)) == 100 # Each tag should be 8 bytes for tag in tags: assert len(tag) == 8 集成测试：\ndef test_ns_nsr_handshake(): \u0026#34;\u0026#34;\u0026#34;Test NS/NSR handshake\u0026#34;\u0026#34;\u0026#34; # Alice creates outbound session alice_session = OutboundSession(bob_destination, bound=True) # Alice sends NS ns_message = alice_session.build_ns_message(b\u0026#34;Hello Bob\u0026#34;) # Bob receives NS bob_session = InboundSession.try_decrypt_ns(ns_message) assert bob_session is not None assert bob_session.bound == True # Bob sends NSR nsr_message = bob_session.build_nsr_message(b\u0026#34;Hello Alice\u0026#34;) # Alice receives NSR alice_session.on_nsr_received(nsr_message) assert alice_session.state == SessionState.ESTABLISHED # Both should have matching ES tagsets # (Cannot directly compare, but can test by sending ES messages) def test_es_bidirectional(): \u0026#34;\u0026#34;\u0026#34;Test ES messages in both directions\u0026#34;\u0026#34;\u0026#34; # (After NS/NSR handshake) # Alice sends ES to Bob es_alice_to_bob = alice_session.send_es_message(b\u0026#34;Data from Alice\u0026#34;) # Bob receives ES bob_session.process_es_message(es_alice_to_bob) # Bob sends ES to Alice es_bob_to_alice = bob_session.send_es_message(b\u0026#34;Data from Bob\u0026#34;) # Alice receives ES alice_session.process_es_message(es_bob_to_alice) def test_dh_ratchet(): \u0026#34;\u0026#34;\u0026#34;Test DH ratchet\u0026#34;\u0026#34;\u0026#34; # (After established session) # Alice initiates ratchet alice_session.initiate_ratchet() nextkey_alice = build_nextkey_block( flags=0x01, key_id=0, public_key=alice_new_key ) # Send to Bob bob_session.process_nextkey_block(nextkey_alice) # Bob replies nextkey_bob = build_nextkey_block( flags=0x03, key_id=0, public_key=bob_new_key ) # Send to Alice alice_session.process_nextkey_block(nextkey_bob) # Both should now be using new tagsets assert alice_session.outbound_tagset.id == 1 assert bob_session.inbound_tagset.id == 1 测试向量：\n实现规范中的测试向量：\nNoise IK Handshake（Noise 协议 IK 握手模式）：使用标准的 Noise 测试向量 HKDF（基于 HMAC 的密钥派生函数）：使用 RFC 5869 测试向量 ChaCha20-Poly1305（由流加密 ChaCha20 与认证算法 Poly1305 组成的 AEAD 模式）：使用 RFC 7539 测试向量 Elligator2（一种将椭圆曲线点伪装为均匀随机比特串的编码方案）：使用 Elligator2 论文或 OBFS4 的测试向量 互操作性测试：\nJava I2P: 针对 Java I2P 参考实现进行测试 i2pd: 针对 C++ 的 i2pd 实现进行测试 Packet Captures: 使用 Wireshark 解析器（若可用）验证消息格式 Cross-Implementation: 创建一个可在不同实现之间进行发送/接收的测试框架 性能注意事项 密钥生成：\nElligator2（将椭圆曲线公钥伪装成随机数据的方案）的密钥生成开销较大（50% 的拒绝率）：\nclass KeyPool: \u0026#34;\u0026#34;\u0026#34;Pre-generate keys in background thread\u0026#34;\u0026#34;\u0026#34; def __init__(self, pool_size=10): self.pool = Queue(maxsize=pool_size) self.generator_thread = Thread(target=self.generate_keys, daemon=True) self.generator_thread.start() def generate_keys(self): while True: if not self.pool.full(): keypair = generate_elg2_keypair() # Also compute encoded form encoded = ENCODE_ELG2(keypair.public_key) self.pool.put((keypair, encoded)) else: sleep(0.1) def get_keypair(self): try: return self.pool.get(timeout=1.0) except Empty: # Pool exhausted, generate inline return generate_elg2_keypair() 标签查找:\n使用哈希表实现 O(1) 的标签查找：\nclass FastTagLookup: def __init__(self): self.tag_to_session = {} # Python dict is hash table def add_tag(self, tag, session, index): # 8-byte tag as bytes is hashable self.tag_to_session[tag] = (session, index) def lookup_tag(self, tag): return self.tag_to_session.get(tag) 内存优化：\n延后生成对称密钥:\nclass DeferredKeyRatchet: \u0026#34;\u0026#34;\u0026#34;Only generate keys when needed\u0026#34;\u0026#34;\u0026#34; def __init__(self, symmKey_ck): self.chainKey = symmKey_ck self.index = -1 self.cache = LRUCache(maxsize=32) # Cache recent keys def get_key(self, index): # Check cache first if index in self.cache: return self.cache[index] # Generate keys up to index while self.index \u0026lt; index: self.index += 1 keydata = HKDF(self.chainKey, ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) self.chainKey = keydata[0:31] if self.index == index: key = keydata[32:63] self.cache[index] = key return key 批处理:\n批量处理多条消息：\ndef process_message_batch(messages): \u0026#34;\u0026#34;\u0026#34;Process multiple messages efficiently\u0026#34;\u0026#34;\u0026#34; results = [] # Group by type ns_messages = [] nsr_messages = [] es_messages = [] for msg in messages: msg_type = classify_message(msg) if msg_type[0] == \u0026#39;NS\u0026#39;: ns_messages.append(msg) elif msg_type[0] == \u0026#39;NSR\u0026#39;: nsr_messages.append(msg) elif msg_type[0] == \u0026#39;ES\u0026#39;: es_messages.append(msg) # Process in batches # ES messages are most common, process first for msg in es_messages: results.append(process_es_message(msg)) for msg in nsr_messages: results.append(process_nsr_message(msg)) for msg in ns_messages: results.append(process_ns_message(msg)) return results 安全注意事项 威胁模型 对手能力：\n被动观察者：可以观察所有网络流量 主动攻击者：可以注入、修改、丢弃、重放消息 被攻陷的节点：可能攻陷 router 或目的地 流量分析：可以对流量模式进行统计分析 安全目标：\n机密性: 消息内容对观察者不可见 认证: 发送方身份已验证(适用于绑定会话) 前向保密性: 即使密钥被泄露，过去的消息仍保持机密 防重放: 旧消息无法被重放 流量混淆: 握手与随机数据不可区分 密码学假设 困难性假设：\nX25519 CDH: 在 Curve25519 上，计算性 Diffie-Hellman 问题是困难的 ChaCha20 PRF: ChaCha20 是一种伪随机函数 Poly1305 MAC: Poly1305 在选择消息攻击下不可伪造 SHA-256 CR: SHA-256 具有抗碰撞性 HKDF Security: HKDF 能够提取并扩展为均匀分布的密钥 安全级别：\nX25519: ~128 位安全强度 (曲线阶 2^252) ChaCha20: 256 位密钥, 256 位安全强度 Poly1305: 128 位安全强度 (碰撞概率) SHA-256: 128 位抗碰撞性, 256 位原像抵抗性 密钥管理 密钥生成：\n# CRITICAL: Use cryptographically secure RNG def CSRNG(length): # GOOD: os.urandom, secrets.token_bytes (Python) # GOOD: /dev/urandom (Linux) # GOOD: BCryptGenRandom (Windows) # BAD: random.random(), Math.random() (NOT cryptographically secure) return os.urandom(length) # CRITICAL: Validate keys def validate_x25519_key(pubkey): # Check for weak keys (all zeros, small order points) if pubkey == bytes(32): raise WeakKeyError(\u0026#34;All-zero public key\u0026#34;) # Perform DH to check for weak shared secrets test_shared = DH(test_private_key, pubkey) if test_shared == bytes(32): raise WeakKeyError(\u0026#34;Results in zero shared secret\u0026#34;) 密钥存储：\n# CRITICAL: Protect private keys class SecureKeyStorage: def __init__(self): # Store in memory with protection self.keys = {} # Option 1: Memory locking (prevent swapping to disk) # mlock(self.keys) # Option 2: Encrypted storage # self.encryption_key = derive_from_password() def store_key(self, key_id, private_key): # Option: Encrypt before storage # encrypted = encrypt(private_key, self.encryption_key) # self.keys[key_id] = encrypted self.keys[key_id] = private_key def delete_key(self, key_id): # Securely wipe memory if key_id in self.keys: key = self.keys[key_id] # Overwrite with zeros before deletion for i in range(len(key)): key[i] = 0 del self.keys[key_id] 密钥轮换:\n# CRITICAL: Rotate keys regularly class KeyRotationPolicy: def __init__(self): self.max_messages_per_tagset = 4096 # Ratchet before 65535 self.max_tagset_age = 10 * 60 # 10 minutes self.max_session_age = 60 * 60 # 1 hour def should_ratchet(self, tagset): return (tagset.messages_sent \u0026gt;= self.max_messages_per_tagset or tagset.age() \u0026gt;= self.max_tagset_age) def should_replace_session(self, session): return session.age() \u0026gt;= self.max_session_age 攻击缓解措施 重放攻击缓解措施 日期时间验证：\nMAX_CLOCK_SKEW_PAST = 5 * 60 MAX_CLOCK_SKEW_FUTURE = 2 * 60 def validate_datetime(timestamp): now = int(time.time()) age = now - timestamp if age \u0026lt; -MAX_CLOCK_SKEW_FUTURE: raise ReplayError(\u0026#34;Timestamp too far in future\u0026#34;) if age \u0026gt; MAX_CLOCK_SKEW_PAST: raise ReplayError(\u0026#34;Timestamp too old\u0026#34;) return True 用于 NS 消息的布隆过滤器：\nclass ReplayFilter: def __init__(self, capacity=100000, error_rate=0.001, duration=5*60): self.bloom = BloomFilter(capacity=capacity, error_rate=error_rate) self.duration = duration self.entries = [] # (timestamp, ephemeral_key) def check_replay(self, ephemeral_key, timestamp): # Validate timestamp if not validate_datetime(timestamp): return False # Check Bloom filter if ephemeral_key in self.bloom: # Potential replay (or false positive) # Check exact match in entries for ts, key in self.entries: if key == ephemeral_key: return False # Definite replay # Add to filter self.bloom.add(ephemeral_key) self.entries.append((timestamp, ephemeral_key)) # Expire old entries self.expire_old_entries() return True def expire_old_entries(self): now = int(time.time()) self.entries = [(ts, key) for ts, key in self.entries if now - ts \u0026lt; self.duration] 会话标签一次性使用：\ndef process_session_tag(tag): # Look up tag entry = tagset.lookup_tag(tag) if entry is None: raise ValueError(\u0026#34;Invalid session tag\u0026#34;) # CRITICAL: Remove tag immediately (one-time use) tagset.remove_tag(tag) # Use associated key return entry.key, entry.index 密钥妥协冒充（KCI）缓解措施 问题: NS 消息认证易受 KCI (密钥泄露冒充) 攻击 (认证级别 1)\n缓解措施:\n尽快过渡到 NSR（认证级别 2） 不要在涉及安全关键操作时信任 NS payload（NS 的载荷数据） 在执行不可逆操作之前，等待 NSR 确认 def process_ns_message(ns_message): # NS authenticated at Level 1 (KCI vulnerable) # Do NOT perform security-critical operations yet # Extract sender\u0026#39;s static key sender_key = ns_message.static_key # Mark session as pending Level 2 authentication session.auth_level = 1 session.sender_key = sender_key # Send NSR send_nsr_reply(session) def process_first_es_message(es_message): # Now we have Level 2 authentication (KCI resistant) session.auth_level = 2 # Safe to perform security-critical operations process_security_critical_operation(es_message) 拒绝服务（DoS）缓解措施 NS 泛洪防护:\nclass NSFloodProtection: def __init__(self): self.ns_count = defaultdict(int) # source -\u0026gt; count self.ns_timestamps = defaultdict(list) # source -\u0026gt; [timestamps] self.max_ns_per_source = 5 self.rate_window = 10 # seconds self.max_concurrent_ns = 100 def check_ns_allowed(self, source): # Global limit total_pending = sum(self.ns_count.values()) if total_pending \u0026gt;= self.max_concurrent_ns: return False # Per-source rate limit now = time.time() timestamps = self.ns_timestamps[source] # Remove old timestamps timestamps = [ts for ts in timestamps if now - ts \u0026lt; self.rate_window] self.ns_timestamps[source] = timestamps # Check rate if len(timestamps) \u0026gt;= self.max_ns_per_source: return False # Allow NS timestamps.append(now) self.ns_count[source] += 1 return True def on_session_established(self, source): # Decrease pending count if self.ns_count[source] \u0026gt; 0: self.ns_count[source] -= 1 标签存储限制：\nclass TagStorageLimit: def __init__(self, max_tags=1000000): self.max_tags = max_tags self.current_tags = 0 def can_create_session(self, look_ahead): if self.current_tags + look_ahead \u0026gt; self.max_tags: return False return True def add_tags(self, count): self.current_tags += count def remove_tags(self, count): self.current_tags -= count 自适应资源管理：\nclass AdaptiveResourceManager: def __init__(self): self.load_level = 0 # 0 = low, 1 = medium, 2 = high, 3 = critical def adjust_parameters(self): if self.load_level == 0: # Normal operation return { \u0026#39;max_look_ahead\u0026#39;: 160, \u0026#39;max_sessions\u0026#39;: 1000, \u0026#39;session_timeout\u0026#39;: 10 * 60 } elif self.load_level == 1: # Moderate load return { \u0026#39;max_look_ahead\u0026#39;: 80, \u0026#39;max_sessions\u0026#39;: 800, \u0026#39;session_timeout\u0026#39;: 8 * 60 } elif self.load_level == 2: # High load return { \u0026#39;max_look_ahead\u0026#39;: 32, \u0026#39;max_sessions\u0026#39;: 500, \u0026#39;session_timeout\u0026#39;: 5 * 60 } else: # load_level == 3 # Critical load return { \u0026#39;max_look_ahead\u0026#39;: 16, \u0026#39;max_sessions\u0026#39;: 200, \u0026#39;session_timeout\u0026#39;: 3 * 60 } 抗流量分析能力 Elligator2 编码：\n确保握手消息与随机数据不可区分：\n# NS and NSR start with Elligator2-encoded ephemeral keys # Observer cannot distinguish from random 32-byte string 填充策略：\n# Resist message size fingerprinting def add_padding(payload, strategy=\u0026#39;random\u0026#39;): if strategy == \u0026#39;random\u0026#39;: # Random padding 0-15 bytes size = random.randint(0, 15) elif strategy == \u0026#39;round\u0026#39;: # Round to next 64-byte boundary target = ((len(payload) + 63) // 64) * 64 size = target - len(payload) - 3 # -3 for block header elif strategy == \u0026#39;fixed\u0026#39;: # Always 1KB messages size = 1024 - len(payload) - 3 return build_padding_block(size) 计时攻击:\n# CRITICAL: Use constant-time operations def constant_time_compare(a, b): \u0026#34;\u0026#34;\u0026#34;Constant-time byte string comparison\u0026#34;\u0026#34;\u0026#34; if len(a) != len(b): return False result = 0 for x, y in zip(a, b): result |= x ^ y return result == 0 # CRITICAL: Constant-time MAC verification def verify_mac(computed_mac, received_mac): if not constant_time_compare(computed_mac, received_mac): # Always take same time regardless of where comparison fails raise AuthenticationError(\u0026#34;MAC verification failed\u0026#34;) 实现中的陷阱 常见错误：\nNonce 重用（一次性随机数）: 绝不要重用 (key, nonce) 对 # BAD: Reusing nonce with same key ciphertext1 = ENCRYPT(key, nonce, plaintext1, ad1) ciphertext2 = ENCRYPT(key, nonce, plaintext2, ad2) # CATASTROPHIC 正确：针对每条消息使用唯一的 nonce（一次性随机数） ciphertext1 = ENCRYPT(key, nonce1, plaintext1, ad1) ciphertext2 = ENCRYPT(key, nonce2, plaintext2, ad2) 2. **Ephemeral Key Reuse**: Generate fresh ephemeral key for each NS/NSR ```python # 错误：重复使用临时密钥 ephemeral_key = generate_elg2_keypair() send_ns_message(ephemeral_key) send_ns_message(ephemeral_key) # 错误 # 良好：每条消息使用新密钥 send_ns_message(generate_elg2_keypair()) send_ns_message(generate_elg2_keypair()) Weak RNG: Use cryptographically secure random number generator 不佳：非加密安全的随机数生成器 import random key = bytes([random.randint(0, 255) for _ in range(32)]) # 不安全 良好：密码学安全的随机数生成器（RNG） import os key = os.urandom(32) 4. **Timing Attacks**: Use constant-time comparisons ```python # 不当：提前退出式比较 if computed_mac == received_mac: # 时序泄漏 pass # 良好：恒定时间比较 if constant_time_compare(computed_mac, received_mac): pass Incomplete MAC Verification: Always verify before using data 错误: 在验证之前解密 plaintext = chacha20_decrypt(key, nonce, ciphertext) mac_ok = verify_mac(mac, plaintext) # 为时已晚 if not mac_ok: return error 正确：AEAD（带关联数据的认证加密）在解密前进行验证 try: plaintext = DECRYPT(key, nonce, ciphertext, ad) # Verifies MAC first except AuthenticationError:\nreturn error 6. **Key Deletion**: Securely wipe keys from memory ```python # 错误：简单删除 del private_key # 仍在内存中 # 推荐：删除前先覆盖 for i in range(len(private_key)): private_key[i] = 0 del private_key Security Audits Recommended Audits:\nCryptographic Review: Expert review of KDF chains and DH operations Implementation Audit: Code review for timing attacks, key management, RNG usage Protocol Analysis: Formal verification of handshake security properties Side-Channel Analysis: Timing, power, and cache attacks Fuzzing: Random input testing for parser robustness Test Cases:\n# 安全关键测试用例 def test_nonce_uniqueness(): \u0026#34;\u0026#34;\u0026#34;Ensure nonces are never reused\u0026#34;\u0026#34;\u0026#34; nonces = set() for i in range(10000): nonce = construct_nonce(i) assert nonce not in nonces nonces.add(nonce) def test_key_isolation(): \u0026#34;\u0026#34;\u0026#34;Ensure sessions don\u0026#39;t share keys\u0026#34;\u0026#34;\u0026#34; session1 = create_session(destination1) session2 = create_session(destination2) assert session1.key != session2.key def test_replay_prevention(): \u0026#34;\u0026#34;\u0026#34;Ensure replay attacks are detected\u0026#34;\u0026#34;\u0026#34; ns_message = create_ns_message() # First delivery succeeds assert process_ns_message(ns_message) == True # Replay fails assert process_ns_message(ns_message) == False def test_mac_verification(): \u0026#34;\u0026#34;\u0026#34;Ensure MAC verification is enforced\u0026#34;\u0026#34;\u0026#34; key = CSRNG(32) nonce = construct_nonce(0) plaintext = b\u0026#34;test\u0026#34; ad = b\u0026#34;test_ad\u0026#34; ciphertext = ENCRYPT(key, nonce, plaintext, ad) # Correct MAC verifies assert DECRYPT(key, nonce, ciphertext, ad) == plaintext # Corrupted MAC fails corrupted = ciphertext[:-1] + bytes([ciphertext[-1] ^ 0xFF]) with pytest.raises(AuthenticationError): DECRYPT(key, nonce, corrupted, ad) Configuration and Deployment I2CP Configuration Enable ECIES Encryption:\n# 仅限 ECIES（椭圆曲线集成加密方案，推荐用于新部署） i2cp.leaseSetEncType=4 # 双密钥（ECIES + ElGamal，出于兼容性考虑） i2cp.leaseSetEncType=4,0 # 仅限 ElGamal（遗留，不推荐） i2cp.leaseSetEncType=0 LeaseSet Type:\n# 标准 LS2（第二代 leaseSet，最常见） i2cp.leaseSetType=3 # 加密的 LS2（blinded destinations（盲化目的地）） i2cp.leaseSetType=5 # Meta LS2（多个目的地） i2cp.leaseSetType=7 Additional Options:\n# 用于 ECIES（椭圆曲线集成加密方案）的静态密钥（可选，未指定时自动生成） # 32 字节的 X25519 公钥，Base64 编码 i2cp.leaseSetPrivateKey=\u0026lt;base64-encoded-key\u0026gt; # 签名类型 (用于 LeaseSet) i2cp.leaseSetSigningPrivateKey=\u0026lt;base64-encoded-key\u0026gt; i2cp.leaseSetSigningType=7 # Ed25519 Java I2P Configuration router.config:\n# router 到 router 的 ECIES（椭圆曲线集成加密方案） i2p.router.useECIES=true Build Properties:\n// 适用于 I2CP 客户端 (Java) Properties props = new Properties(); props.setProperty(\u0026#34;i2cp.leaseSetEncType\u0026#34;, \u0026#34;4\u0026#34;); props.setProperty(\u0026#34;i2cp.leaseSetType\u0026#34;, \u0026#34;3\u0026#34;); I2PSession session = i2pClient.createSession(props); i2pd Configuration i2pd.conf:\n[限制] # ECIES（椭圆曲线集成加密方案）会话内存限制 ecies.memory = 128M [ecies] # 启用 ECIES（椭圆曲线集成加密方案） enabled = true # 仅限 ECIES 或双密钥 compatibility = true # true = 双密钥，false = 仅 ECIES Tunnels Configuration:\n[my-service] type = http host = 127.0.0.1 port = 8080 keys = my-service-keys.dat # 仅 ECIES（椭圆曲线集成加密方案） ecies = true Compatibility Matrix Router Version Support:\nVersion ECIES Support LS2 Support Dual-Key Notes \u0026lt; 0.9.38 ❌ No ❌ No N/A Legacy only 0.9.38-0.9.45 ❌ No ✅ Yes N/A LS2 only 0.9.46-0.9.50 ✅ Yes ✅ Yes ✅ Yes Initial ECIES 1.5.0+ ✅ Yes ✅ Yes ✅ Yes Current 2.0.0+ ✅ Yes ✅ Yes ✅ Yes Current Destination Compatibility:\nDestination Type Can Connect To Notes ECIES-only ECIES-only, Dual-key Requires 0.9.46+ routers Dual-key Any Maximum compatibility ElGamal-only ElGamal-only, Dual-key Legacy FloodFill Requirements:\nECIES-only destinations: Require majority of floodfills on 0.9.46+ for encrypted lookups Dual-key destinations: Work with any floodfill version Current status: Near 100% floodfill adoption as of 2025 Migration Guide Migrating from ElGamal to ECIES:\nStep 1: Enable Dual-Key Mode\n# 在保留 ElGamal 的同时添加 ECIES i2cp.leaseSetEncType=4,0 Step 2: Monitor Connections\n# 检查连接类型 i2prouter.exe status # 或 http://127.0.0.1:7657/peers Step 3: Switch to ECIES-Only (after testing)\n# 移除 ElGamal（ElGamal 加密算法） i2cp.leaseSetEncType=4 Step 4: Restart Application\n# 重启 I2P router 或应用程序 systemctl restart i2p # 或 i2prouter.exe restart Rollback Plan:\n# 如遇问题，回退为仅使用 ElGamal i2cp.leaseSetEncType=0 Performance Tuning Session Limits:\n# 最大入站会话数 i2p.router.maxInboundSessions=1000 # 最大出站会话数 i2p.router.maxOutboundSessions=1000 # 会话超时（秒） i2p.router.sessionTimeout=600 Memory Limits:\n# 标签存储上限（KB） i2p.ecies.maxTagMemory=10240 # 10 MB # 前瞻窗口 i2p.ecies.tagLookAhead=160 i2p.ecies.tagLookAheadMin=32 Ratchet Policy:\n# 棘轮前的消息 i2p.ecies.ratchetThreshold=4096 # ratchet（棘轮）之前的时间（秒） i2p.ecies.ratchetTimeout=600 # 10 分钟 Monitoring and Debugging Logging:\n# 启用 ECIES（椭圆曲线集成加密方案）调试日志 logger.i2p.router.transport.ecies=DEBUG Metrics:\nMonitor these metrics:\nNS Success Rate: Percentage of NS messages receiving NSR Session Establishment Time: Time from NS to first ES Tag Storage Usage: Current memory usage for tags Ratchet Frequency: How often sessions ratchet Session Lifetime: Average session duration Common Issues:\nNS Timeout: No NSR received\nCheck destination is online Check floodfill availability Verify LeaseSet published correctly High Memory Usage: Too many tags stored\nReduce look-ahead window Decrease session timeout Implement aggressive expiration Frequent Ratchets: Sessions ratcheting too often\nIncrease ratchet threshold Check for retransmissions Session Failures: ES messages failing to decrypt\nVerify tag synchronization Check for replay attacks Validate nonce construction References Specifications ECIES Proposal: Proposal 144 I2NP: I2NP Specification Common Structures: Common Structures Specification NTCP2: NTCP2 Specification SSU2: SSU2 Specification I2CP: I2CP Specification ElGamal/AES+SessionTags: ElGamal/AES Specification Cryptographic Standards Noise Protocol Framework: Noise Specification (Revision 34, 2018-07-11) Signal Double Ratchet: Signal Specification RFC 7748: Elliptic Curves for Security (X25519) RFC 7539: ChaCha20 and Poly1305 for IETF Protocols RFC 5869: HKDF (HMAC-based Key Derivation Function) RFC 2104: HMAC: Keyed-Hashing for Message Authentication Elligator2: Elligator Paper Implementation Resources Java I2P: i2p.i2p Repository i2pd (C++): i2pd Repository OBFS4 (Elligator2): obfs4proxy Repository Additional Information I2P Website: / I2P Forum: https://i2pforum.net I2P Wiki: https://wiki.i2p-projekt.de Appendix A: KDF Summary All KDF Operations in ECIES:\nOperation Input Info String Output NS Initial ChainKey protocol_name (none - SHA256) h, chainKey NS Static Key Section chainKey, es_shared \"\" chainKey, k NS Payload Section (bound) chainKey, ss_shared \"\" chainKey, k NSR Tagset chainKey \"SessionReplyTags\" tagsetKey NSR ee DH chainKey, ee_shared \"\" chainKey NSR se DH chainKey, se_shared \"\" chainKey, k NSR Split chainKey \"\" k_ab, k_ba NSR Payload k_ba \"AttachPayloadKDF\" k_nsr DH Initialize rootKey, k \"KDFDHRatchetStep\" nextRootKey, chainKey Tag and Key Chain Keys chainKey \"TagAndKeyGenKeys\" sessTag_ck, symmKey_ck Session Tag Init sessTag_ck \"STInitialization\" chainKey, CONSTANT Session Tag Gen chainKey, CONSTANT \"SessionTagKeyGen\" chainKey, tag Symmetric Key Gen chainKey \"SymmetricRatchet\" chainKey, key DH Ratchet sharedSecret \"XDHRatchetTagSet\" tagsetKey Appendix B: Message Size Calculator Calculate message sizes for capacity planning:\ndef calculate_ns_size(payload_size, bound=True): \u0026#34;\u0026#34;\u0026#34;Calculate New Session message size\u0026#34;\u0026#34;\u0026#34; ephemeral_key = 32 static_section = 32 + 16 # encrypted + MAC payload_encrypted = payload_size + 16 # + MAC return ephemeral_key + static_section + payload_encrypted def calculate_nsr_size(payload_size): \u0026#34;\u0026#34;\u0026#34;Calculate New Session Reply message size\u0026#34;\u0026#34;\u0026#34; tag = 8 ephemeral_key = 32 key_section_mac = 16 payload_encrypted = payload_size + 16 # + MAC return tag + ephemeral_key + key_section_mac + payload_encrypted def calculate_es_size(payload_size): \u0026#34;\u0026#34;\u0026#34;Calculate Existing Session message size\u0026#34;\u0026#34;\u0026#34; tag = 8 payload_encrypted = payload_size + 16 # + MAC return tag + payload_encrypted # 示例 print(\u0026#34;NS (绑定，1KB 负载):\u0026#34;, calculate_ns_size(1024, bound=True), \u0026#34;字节\u0026#34;) # 输出：1120 字节 print(\u0026#34;NSR (1KB 负载):\u0026#34;, calculate_nsr_size(1024), \u0026#34;字节\u0026#34;) # 输出：1096 字节 print(\u0026#34;ES (1KB payload):\u0026#34;, calculate_es_size(1024), \u0026#34;bytes\u0026#34;) # 输出: 1048 字节 Appendix C: Glossary AEAD: Authenticated Encryption with Associated Data - encryption mode that provides both confidentiality and authenticity\nAuthentication Level: Noise protocol security property indicating strength of sender identity verification\nBinding: Association of a session with a specific far-end destination\nChaCha20: Stream cipher designed by Daniel J. Bernstein\nChainKey: Cryptographic key used in HKDF chains to derive subsequent keys\nConfidentiality Level: Noise protocol security property indicating strength of forward secrecy\nDH: Diffie-Hellman key agreement protocol\nElligator2: Encoding technique to make elliptic curve points indistinguishable from random\nEphemeral Key: Short-lived key used only for a single handshake\nES: Existing Session message (used after handshake completion)\nForward Secrecy: Property ensuring past communications remain secure if keys are compromised\nGarlic Clove: I2NP message container for end-to-end delivery\nHKDF: HMAC-based Key Derivation Function\nIK Pattern: Noise handshake pattern where initiator sends static key immediately\nKCI: Key Compromise Impersonation attack\nKDF: Key Derivation Function - cryptographic function for generating keys from other keys\nLeaseSet: I2P structure containing a destination\u0026rsquo;s public keys and tunnel information\nLS2: LeaseSet version 2 with encryption type support\nMAC: Message Authentication Code - cryptographic checksum proving authenticity\nMixHash: Noise protocol function for maintaining running hash transcript\nNS: New Session message (initiates new session)\nNSR: New Session Reply message (response to NS)\nNonce: Number used once - ensures unique encryption even with same key\nPairing: Linking an inbound session with an outbound session for bidirectional communication\nPoly1305: Message authentication code designed by Daniel J. Bernstein\nRatchet: Cryptographic mechanism for deriving sequential keys\nSession Tag: 8-byte one-time identifier for existing session messages\nStatic Key: Long-term key associated with a destination\u0026rsquo;s identity\nTag Set: Collection of session tags derived from a common root\nX25519: Elliptic curve Diffie-Hellman key agreement using Curve25519\n","description":"适用于 I2P 的椭圆曲线集成加密方案 (X25519 + AEAD)","id":"82b727dd29ed7e2e04873dac8c2acf51","section":"docs","title":"ECIES-X25519-AEAD-Ratchet 加密规范（棘轮机制）","url":"/zh/docs/specs/ecies/"},{"categories":null,"content":" 状态： 本文档描述的是遗留的 ElGamal/AES+SessionTag 加密协议（ElGamal/AES+SessionTag，使用会话标签的加密方案）。它仅为保持向后兼容而继续受支持，因为现代 I2P 版本（2.10.0+）使用 ECIES-X25519-AEAD-Ratchet （基于 X25519 的 ECIES，采用 AEAD 棘轮）。ElGamal 协议已弃用，仅为历史与互操作性目的而保留。\n概述 ElGamal/AES+SessionTag 是 I2P 最初用于蒜式消息的端到端加密机制。它结合了：\nElGamal (2048-bit) — 用于密钥交换 AES-256/CBC — 用于负载加密 SHA-256 — 用于哈希与 IV（初始化向量）推导 Session Tags (32 bytes)（会话标签） — 用于一次性消息标识符 该协议允许 routers 和 Destination（目标标识）在无需维持持久连接的情况下进行安全通信。每个会话使用非对称的 ElGamal 交换来建立对称的 AES 密钥，随后使用轻量的“带标签”的消息来引用该会话。\n协议运行机制 会话建立（新会话） 一个新会话以一条包含两个部分的消息开始：\nSection Size Contents Purpose ElGamal-encrypted block 514 bytes 222 bytes of plaintext encrypted using the recipient's ElGamal public key Establishes the AES session key and IV seed AES-encrypted block Variable (≥128 bytes typical) Payload data, integrity hash, and session tags Carries the actual message and new tags ElGamal 块内的明文由以下组成： Field Size Description Session Key 32 bytes AES-256 key for the session Pre-IV 32 bytes Material for deriving the AES initialization vector (IV = first 16 bytes of SHA-256(Pre-IV)) Random Padding 158 bytes Filler to reach required ElGamal plaintext length ### 现有会话消息 一旦会话建立，发送方就可以使用缓存的会话标签发送existing-session（指“现有会话”的消息类型）消息：\nField Size Description Session Tag 32 bytes Single-use identifier tied to the existing session key AES-Encrypted Block Variable Encrypted payload and metadata using the established AES key Routers 在大约**15 minutes**内缓存已传送的标签，之后未使用的标签便会过期。每个标签恰好仅对**one message**有效，以防止关联攻击。 AES 加密块格式 Field Size Description Tag Count 2 bytes Number (0–200) of new session tags included Session Tags 32 × N bytes Newly generated single-use tags Payload Size 4 bytes Length of the payload in bytes Payload Hash 32 bytes SHA-256 digest of the payload Flag 1 byte 0x00 normal, 0x01 = new session key follows (unused) New Session Key 32 bytes (optional) Replacement AES key (rarely used) Payload Variable Encrypted message data Padding Variable (16-byte aligned) Random padding to block boundary router 使用从 Pre-IV（预置初始化向量，用于新会话）或会话标签（用于现有会话）派生的会话密钥和 IV 进行解密。解密后，它们通过重新计算明文负载的 SHA-256 哈希来验证完整性。 会话标签管理 标签是单向的：Alice → Bob 的标签不能被 Bob → Alice 复用。 标签会在大约15 分钟后过期。 Routers 按目标维护会话密钥管理器，用于跟踪标签、密钥和到期时间。 应用程序可以通过 I2CP 选项 控制标签行为： i2cp.tagThreshold — 触发补充前的最小缓存标签数 i2cp.tagCount — 每条消息生成的新标签数量 该机制在保持消息之间的不可关联性的同时，将开销高昂的 ElGamal 握手降到最低。\n配置与效率 为提高 I2P 的高延迟、无序传输中的效率，引入了会话标签（session tags）。一种典型的配置会为每条消息传送40 个标签，增加约 1.2 KB 的开销。应用可以根据预期流量调整传递策略：\nUse Case Recommended Tags Notes Short-lived requests (HTTP, datagrams) 0 – 5 Low overhead, may trigger ElGamal fallback Persistent streams or bulk transfer 20 – 50 Higher bandwidth use, avoids session re-establishment Long-term services 50+ Ensures steady tag supply despite loss or delay Routers 会定期清除过期的标签，并清理未使用的会话状态，以减少内存占用并缓解标签泛洪攻击。 局限性 Category Limitation Performance 514-byte ElGamal block adds heavy overhead for new sessions; session tags consume 32 bytes each. Security No forward secrecy – compromise of ElGamal private key exposes past sessions. Integrity AES-CBC requires manual hash verification; no AEAD. Quantum Resistance Vulnerable to Shor's algorithm – will not survive quantum attacks. Complexity Requires stateful tag management and careful timeout tuning. 这些缺陷直接促成了 [ECIES-X25519-AEAD-Ratchet](/docs/specs/ecies/) 协议的设计，它提供完美前向保密性、认证加密以及高效的密钥交换。 弃用与迁移状态 引入： I2P 早期版本（0.6 之前） 弃用： 在引入 ECIES-X25519（使用 X25519 的椭圆曲线集成加密方案）时被弃用（0.9.46 → 0.9.48） 移除： 自 2.4.0 起不再为默认（2023 年 12 月） 支持： 仅用于向后兼容 现代的 routers 和目标如今会通告加密类型 4 (ECIES-X25519)，而非类型 0 (ElGamal/AES)。为与过时的对等节点互通，遗留协议仍被识别，但不应用于新的部署。\n历史背景 ElGamal/AES+SessionTag（I2P 早期的一种混合加密构造）为 I2P 的早期密码学架构奠定了基础。其混合设计引入了诸如一次性会话标签和单向会话等创新，并启发了后续协议。这些理念中的许多演化为现代构造，如确定性棘轮机制和混合后量子密钥交换。\n","description":"结合 ElGamal、AES、SHA-256 和一次性会话标签的遗留端到端加密","id":"092d77bf065d0f13bb2b2a470f57a902","section":"docs","title":"ElGamal/AES + SessionTag（会话标签）加密","url":"/zh/docs/legacy/elgamal-aes/"},{"categories":null,"content":" 1. 概述 Garlic routing（大蒜路由）仍然是I2P的核心创新之一,它结合了分层加密、消息捆绑和单向tunnel。虽然在概念上与onion routing（洋葱路由）类似,但它扩展了该模型,将多个加密消息(\u0026ldquo;cloves\u0026rdquo;,瓣)捆绑在单个信封(\u0026ldquo;garlic\u0026rdquo;,蒜)中,从而提高了效率和匿名性。\n术语 garlic routing 由 Michael J. Freedman 在 Roger Dingledine 的 Free Haven 硕士论文 （2000 年 6 月,§8.1.1）中首次提出。I2P 开发者在 2000 年代初期采用了这个术语,以体现其消息捆绑增强功能和单向传输模型,将其与 Tor 的电路交换设计区分开来。\n总结： Garlic routing（洋葱路由）= 分层加密 + 消息捆绑 + 通过单向隧道匿名传递。\n2. \u0026ldquo;Garlic\u0026rdquo; 术语 历史上，术语 garlic 在 I2P 中曾在三种不同的语境下使用：\n分层加密 – tunnel 级别的洋葱式保护 捆绑多条消息 – 在一个\u0026quot;garlic message\u0026quot;中包含多个\u0026quot;cloves\u0026quot; 端到端加密 – 原为 ElGamal/AES+SessionTags,现为 ECIES‑X25519‑AEAD‑Ratchet 虽然架构保持不变，但加密方案已经完全现代化。\n3. 分层加密 Garlic routing 与洋葱路由共享其基本原理:每个 router 仅解密一层加密,只了解下一跳而不知道完整路径。\n然而，I2P 实现的是单向 tunnel，而不是双向电路：\nOutbound tunnel：从创建者发送消息出去 Inbound tunnel：将消息带回创建者 一次完整的往返通信（Alice ↔ Bob）使用四条 tunnel：Alice 的 outbound → Bob 的 inbound，然后 Bob 的 outbound → Alice 的 inbound。这种设计相比双向电路将关联数据暴露减半。\n关于隧道实现细节，请参阅隧道规范 和隧道创建（ECIES） 规范。\n4. 捆绑多个消息（\u0026ldquo;蒜瓣\u0026rdquo;） Freedman 最初的 garlic routing 设想是在一条消息中捆绑多个加密的\u0026quot;bulbs\u0026quot;。I2P 将其实现为 garlic message 内部的 cloves——每个 clove 都有自己的加密传递指令和目标(router、destination 或 tunnel)。\nGarlic 捆绑允许 I2P：\n将确认和元数据与数据消息结合 减少可观察的流量模式 支持复杂的消息结构而无需额外连接 图1：一个 Garlic Message 包含多个 clove（消息片段），每个都有自己的传递指令。\n典型的丁香包括：\n传输状态消息 — 确认传输成功或失败的应答消息。\n这些消息被包裹在各自的 garlic 层中以保持机密性。 数据库存储消息 — 自动捆绑的 LeaseSet,使对等节点无需重新查询 netDb 即可回复。 当出现以下情况时，Cloves 会被捆绑：\n必须发布新的 LeaseSet 传递新的会话标签 最近没有发生捆绑（默认约 1 分钟） Garlic 消息在单个数据包中实现多个加密组件的高效端到端传输。\n5. 加密演进 5.1 Historical Context 早期文档（≤ v0.9.12）描述了 ElGamal/AES+SessionTags 加密： - ElGamal 2048 位封装 AES 会话密钥 - AES‑256/CBC 用于有效载荷加密 - 32 字节会话标签每条消息使用一次\n该密码系统已弃用。\n5.2 ECIES‑X25519‑AEAD‑Ratchet (Current Standard) 在2019年至2023年间,I2P完全迁移到了ECIES‑X25519‑AEAD‑Ratchet。现代技术栈标准化了以下组件:\nLayer ECIES Primitive or Concept Transport Layer (NTCP2, SSU2) Noise_NX → X25519, ChaCha20/Poly1305, BLAKE2s I2NP Delivery ECIES‑X25519‑AEAD (ChaCha20/Poly1305) Session Management Ratchet with rekey records, per-clove key material Offline Authentication EdDSA (Ed25519) with LeaseSet2/MetaLeaseSet chains ECIES 迁移的好处： 前向保密性，通过每条消息的棘轮密钥实现 载荷大小减少，与 ElGamal 相比 弹性，抵抗密码分析技术的进步 兼容性，支持未来的后量子混合方案（见提案 169） 更多详情：请参阅 ECIES 规范 和 EncryptedLeaseSet 规范 。\n6. LeaseSets and Garlic Bundling Garlic envelope（大蒜信封）经常包含 leaseSet 来发布或更新目标可达性信息。\nVersion Type Key Capabilities Distribution Notes 1 LeaseSet (legacy) Single encryption/signature pair Accepted for backward compatibility 3 LeaseSet2 Multiple crypto suites, offline signing keys Default for modern routers 5 EncryptedLeaseSet Access-controlled, destination hidden from floodfill Requires shared decryption key 7 MetaLeaseSet Aggregates multiple destinations or multi-homed services Extends LeaseSet2 fields recursively 所有 LeaseSet 都通过由专用 router 维护的 *floodfill DHT* 分发。发布内容会经过验证、添加时间戳并进行速率限制，以减少元数据关联。 请参阅网络数据库文档 了解详情。\n7. Modern “Garlic” Applications within I2P garlic encryption（大蒜加密）和消息捆绑技术贯穿整个 I2P 协议栈：\ntunnel 创建和使用 — 每跳分层加密 端到端消息传递 — 捆绑的 garlic 消息,包含克隆确认和 LeaseSet cloves netDb 发布 — 用 garlic 信封包装的 LeaseSets,以保护隐私 SSU2 和 NTCP2 传输 — 使用 Noise 框架和 X25519/ChaCha20 原语的底层加密 因此，Garlic routing（大蒜路由）既是一种加密分层方法，也是一种网络消息传递模型。\n6. LeaseSet 和 Garlic 捆绑 I2P的文档中心可在此处获取 ，持续维护中。相关的活跃规范包括：\nECIES 规范 — ECIES‑X25519‑AEAD‑Ratchet Tunnel 创建（ECIES） — 现代 tunnel 构建协议 I2NP 规范 — I2NP 消息格式 SSU2 规范 — SSU2 UDP 传输 通用结构 — netDb 和 floodfill 行为 学术验证：Hoang 等人（IMC 2018，USENIX FOCI 2019）和 Muntaka 等人（2025）证实了 I2P 设计的架构稳定性和运行弹性。\n7. I2P 中的现代\u0026quot;Garlic\u0026quot;应用 正在进行的提案：\n提案 169： 混合后量子加密（ML-KEM 512/768/1024 + X25519） 提案 168： 传输带宽优化 数据报和流式传输更新： 增强的拥塞管理 未来的改进可能包括额外的消息延迟策略或在 garlic-message 级别实现多隧道冗余，这些都基于 Freedman 最初描述的未使用的传输选项。\n8. 当前文档和参考资料 Freedman, M. J. \u0026amp; Dingledine, R. (2000). Free Haven Master\u0026rsquo;s Thesis, § 8.1.1. Free Haven Papers Onion Router Publications Garlic Routing (Wikipedia) Tor Project Free Haven Anonbib Goldschlag, D. M., Reed, M. G., Syverson, P. F. (1996). Hiding Routing Information. NRL Publication. ","description":"理解 I2P 中 garlic routing 的术语、架构和现代实现","id":"ba07d93d883918641f4a69832e497bb8","section":"docs","title":"Garlic Routing（大蒜路由）","url":"/zh/docs/overview/garlic-routing/"},{"categories":null,"content":"概述 注意：已过时 - 我们现在支持三种格式，按优先顺序排列：\nMaxmind 的 geoip2（GeoLite2-Country.mmdb）随所有安装一起打包提供，Debian 软件包和 Android 除外 Maxmind 的 geoip1（GeoIP.dat）位于 Debian 的 geoip-database 软件包中 如下文所述的 IPv4 Tor 格式（geoip.txt）以及自定义的 IPv6 格式（geoipv6.dat.gz）仍受支持，但未使用 本页说明了各种 GeoIP 文件的格式，这些文件由 router 用于为某个 IP 查询所属国家/地区。\n国家名称（countries.txt）格式 该格式可从许多公共来源提供的数据文件轻松生成。例如：\n$ wget http://geolite.maxmind.com/download/geoip/database/GeoIPCountryCSV.zip $ unzip GeoIPCountryCSV.zip $ cut -d, -f5,6 \u0026lt; GeoIPCountryWhois.csv | sed \u0026#39;s/\u0026#34;//g\u0026#39; | sort | uniq \u0026gt; countries.txt 格式规范：\n编码为 UTF-8 第 1 列中的 \u0026lsquo;#\u0026rsquo; 表示注释行 条目行为 CountryCode,CountryName CountryCode 为 ISO 两位字母代码，使用大写 CountryName 为英文 IPv4 (geoip.txt) 格式 此格式借鉴自 Tor，并且可以从许多公开来源提供的数据文件轻松生成。例如：\n$ wget http://geolite.maxmind.com/download/geoip/database/GeoIPCountryCSV.zip $ unzip GeoIPCountryCSV.zip $ cut -d, -f3-5 \u0026lt; GeoIPCountryWhois.csv | sed \u0026#39;s/\u0026#34;//g\u0026#39; \u0026gt; geoip.txt $ cut -d, -f5,6 \u0026lt; GeoIPCountryWhois.csv | sed \u0026#39;s/\u0026#34;//g\u0026#39; | sort | uniq \u0026gt; countries.txt 格式规范：\n编码为 ASCII 第一列的 \u0026lsquo;#\u0026rsquo; 表示注释行 条目行的格式为 FromIP,ToIP,CountryCode FromIP 和 ToIP 是 4 字节 IP 的无符号整数表示 CountryCode 是 ISO 两字母代码，使用大写 条目行必须按 FromIP 的数值排序 IPv6 (geoipv6.dat.gz) 格式 这是为 I2P 设计的压缩二进制格式。该文件使用 gzip 压缩。解压后的格式：\nBytes 0-9: Magic number \u0026#34;I2PGeoIPv6\u0026#34; Bytes 10-11: Version (0x0001) Bytes 12-15 Options (0x00000000) (future use) Bytes 16-23: Creation date (ms since 1970-01-01) Bytes 24-xx: Optional comment (UTF-8) terminated by zero byte Bytes xx-255: null padding Bytes 256-: 18 byte records: 8 byte from (/64) 8 byte to (/64) 2 byte ISO country code LOWER case (ASCII) 注意事项：\n数据必须按（有符号 long 的二进制补码）排序，且不得重叠。因此顺序为 80000000 \u0026hellip; FFFFFFFF 00000000 \u0026hellip; 7FFFFFFF。 GeoIPv6.java 类包含一个程序，可从公共来源（例如 MaxMind 的 GeoLite 数据）生成此格式。 自 0.9.8 版本起支持 IPv6 GeoIP 查询。 ","description":"用于 IP 到国家查询的旧版 GeoIP（基于 IP 的地理定位）文件格式规范","id":"b5f34a4f13210a8caf4c4d0b5e62a828","section":"docs","title":"GeoIP 文件格式","url":"/zh/docs/legacy/geoip-%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/"},{"categories":null,"content":"在 I2P 内部克隆和推送仓库使用的 Git 命令与您已经熟悉的完全相同——您的客户端只是通过 I2P tunnel 连接,而不是通过 TCP/IP。本指南将介绍如何设置账户、配置 tunnel 以及处理慢速链接的问题。\n快速入门： 只读访问可以通过 HTTP 代理实现：http_proxy=http://127.0.0.1:4444 git clone http://example.i2p/project.git。按照以下步骤配置 SSH 读/写访问。\n1. 创建账户 选择一个 I2P Git 服务并注册：\nI2P 内部：http://git.idk.i2p 明网镜像：https://i2pgit.org 注册可能需要人工审核；请查看首页获取相关说明。审核通过后，fork 或创建一个代码仓库，以便进行测试。\n2. 配置 I2PTunnel 客户端（SSH） 打开 router console → I2PTunnel 并添加一个新的 Client tunnel。 输入服务的 destination(Base32 或 Base64)。对于 git.idk.i2p,你可以在项目主页找到 HTTP 和 SSH destinations。 选择一个本地端口(例如 localhost:7442)。 如果你计划频繁使用该 tunnel,请启用自动启动。 界面将确认新隧道并显示其状态。当隧道运行时,SSH 客户端可以连接到所选端口上的 127.0.0.1。\n3. 通过 SSH 克隆 使用 tunnel 端口配合 GIT_SSH_COMMAND 或 SSH 配置段：\nGIT_SSH_COMMAND=\u0026#34;ssh -p 7442\u0026#34; \\ git clone git@127.0.0.1:your-project/example.git 如果第一次尝试失败（隧道可能会很慢），请尝试浅克隆：\nGIT_SSH_COMMAND=\u0026#34;ssh -p 7442\u0026#34; \\ git clone --depth 1 git@127.0.0.1:your-project/example.git cd example git fetch --unshallow 配置 Git 以获取所有分支：\ngit config remote.origin.fetch \u0026#34;+refs/heads/*:refs/remotes/origin/*\u0026#34; git fetch origin 性能优化建议 在隧道编辑器中添加一到两个备份隧道以提高弹性。 对于测试或低风险的仓库，你可以将隧道长度减少到 1 跳，但要注意匿名性的权衡。 在你的环境中保留 GIT_SSH_COMMAND 或在 ~/.ssh/config 中添加一个条目: Host git.i2p HostName 127.0.0.1 Port 7442 User git 然后使用 git clone git@git.i2p:namespace/project.git 进行克隆。\n4. 工作流程建议 采用 GitLab/GitHub 上常见的 fork-and-branch 工作流程：\n设置上游远程仓库：git remote add upstream git@git.i2p:I2P_Developers/i2p.i2p 保持你的 master 分支同步：git pull upstream master 为更改创建功能分支：git checkout -b feature/new-thing 将分支推送到你的 fork：git push origin feature/new-thing 提交合并请求,然后从上游快进你的 fork 的 master 分支。 5. 隐私提醒 Git 以本地时区存储提交时间戳。要强制使用 UTC 时间戳： git config --global alias.utccommit \u0026#39;!git commit --date=\u0026#34;$(date --utc +%Y-%m-%dT%H:%M:%S%z)\u0026#34;\u0026#39; 当隐私很重要时，使用 git utccommit 而不是 git commit。\n如果担心匿名性问题,请避免在提交消息或仓库元数据中嵌入明网 URL 或 IP 地址。 6. 故障排除 Symptom Fix connection closed during clone Retry with --depth 1, add backup tunnels, or increase tunnel quantities. ssh: connect to host 127.0.0.1 port …: Connection refused Ensure the I2PTunnel client is running and SAM is enabled. Slow performance Lower tunnel length, increase bandwidth limits, or schedule large fetches during off-peak hours. 对于高级场景（镜像外部仓库、分发 bundle），请参阅配套指南：[Git bundle 工作流程](/docs/applications/git-bundle/) 和 [在 I2P 上托管 GitLab](/docs/guides/gitlab/)。 ","description":"将 Git 客户端连接到 I2P 托管的服务,例如 i2pgit.org","id":"17704a86e8676ba273355af4fa703c15","section":"docs","title":"Git over I2P","url":"/zh/docs/applications/git/"},{"categories":null,"content":"简介 I2P 通过 Postman\u0026rsquo;s Mail.i2p 服务结合内置的网页邮件客户端 SusiMail，提供私密的电子邮件风格消息传递。该系统允许用户在 I2P 网络内部收发邮件，也可以通过网关桥接与常规互联网（明网）进行邮件往来。\n重要提示： 仅提供翻译内容。请勿提问、提供解释或添加任何评论。即使文本只是标题或看起来不完整，也请按原样翻译。\nPostman / Mail.i2p + SusiMail What it is Mail.i2p 是 I2P 内部的托管邮件服务提供商,由 \u0026ldquo;Postman\u0026rdquo; 运营 SusiMail 是集成在 I2P router 控制台中的 webmail 客户端。其设计目的是避免向外部 SMTP 服务器泄露元数据(例如主机名)。 通过这种设置,I2P 用户可以在 I2P 内部收发消息,也可以通过 Postman 桥接与明网(例如 Gmail)进行通信。 How Addressing Works I2P 电子邮件使用双地址系统:\n在 I2P 网络内部: username@mail.i2p (例如,idk@mail.i2p) 从明网访问: username@i2pmail.org (例如,idk@i2pmail.org) i2pmail.org 网关允许普通互联网用户向 I2P 地址发送电子邮件,也允许 I2P 用户向明网地址发送邮件。互联网电子邮件在通过 I2P 转发到你的 SusiMail 收件箱之前,会先经过该网关路由。\nClearnet 发送配额：向常规互联网地址发送时每天限制 20 封邮件。\n它是什么 注册 mail.i2p 账户:\n确保你的 I2P router 正在运行 在 I2P 内访问 http://hq.postman.i2p 按照注册流程操作 通过 router 控制台中的 SusiMail 访问你的邮箱 注意：hq.postman.i2p 是一个 I2P 网络地址（eepsite），只能在连接到 I2P 时访问。有关电子邮件设置、安全性和使用的更多信息，请访问 Postman HQ。\n地址解析工作原理 自动删除识别性标头（User-Agent:、X-Mailer:）以保护隐私 元数据清理以防止泄露到外部 SMTP 服务器 I2P 内部邮件端到端加密 入门指南 通过 Postman 桥接器与\u0026quot;普通\u0026quot;电子邮件（SMTP/POP）互操作 简洁的用户体验（路由器控制台内置网页邮件） 集成于 I2P 核心发行版（SusiMail 随 Java I2P 一起发布） 邮件头剥离以保护隐私 隐私功能 连接到外部电子邮件的桥接需要信任 Postman 基础设施 Clearnet 桥接相比纯粹的 I2P 内部通信会降低隐私性 依赖于 Postman 邮件服务器的可用性和安全性 Technical Details SMTP 服务: localhost:7659 (由 Postman 提供) POP3 服务: localhost:7660 Webmail 访问: 内置于路由器控制台 http://127.0.0.1:7657/susimail/\n重要提示：SusiMail 仅用于阅读和发送电子邮件。账户创建和管理必须在 hq.postman.i2p 进行。\nBest Practices 注册 mail.i2p 账户后更改密码 尽可能使用 I2P 到 I2P 的电子邮件以获得最大隐私保护（无明网桥接） 注意每日 20 封的限制（向明网地址发送邮件时） 了解权衡取舍：明网桥接提供了便利，但相比纯 I2P 内部通信会降低匿名性 保持 I2P 更新以受益于 SusiMail 的安全性改进 ","description":"I2P 网络内电子邮件系统概述——历史、选项和现状","id":"31217ea91c11f98bd1997466684f9fb3","section":"docs","title":"I2P Mail（基于 I2P 的匿名电子邮件）","url":"/zh/docs/applications/i2p-mail/"},{"categories":null,"content":"I2P router 最常见的故障原因是 端口转发问题、带宽分配不足 和 引导时间不足。这三项占已报告问题的 70% 以上。该 router 启动后至少需要 10-15 分钟 才能完全融入网络、至少 128 KB/秒 的最低带宽（建议 256 KB/秒），以及正确的 UDP/TCP 端口转发，才能达到非防火墙状态（未被防火墙阻挡）。新用户常常期望立即连通并过早重启，这会重置接入进度，形成令人沮丧的循环。本指南为 2.10.0 及更高版本中所有主要 I2P 问题提供了详细的解决方案。\nI2P 的匿名架构通过多跳加密的 tunnel，从根本上以牺牲速度换取隐私。理解这一基本设计有助于用户设定合理预期并更有效地进行故障排查，而不是把正常行为误判为问题。\nRouter 无法启动或立即崩溃 最常见的启动失败通常由端口冲突、Java 版本不兼容或配置文件损坏引起。在深入排查之前，先检查是否已有其他 I2P 实例正在运行。\n确认没有冲突的进程：\nLinux: ps aux | grep i2p 或 netstat -tulpn | grep 7657\nWindows: 任务管理器 → 详细信息 → 查找命令行中包含 i2p 的 java.exe\nmacOS：活动监视器 → 搜索“i2p”\n如果存在僵尸进程，杀死它：pkill -9 -f i2p (Linux/Mac) 或 taskkill /F /IM javaw.exe (Windows)\n检查 Java 版本兼容性：\nI2P 2.10.0+ 需要 至少 Java 8，推荐使用 Java 11 或更高版本。请确认您的安装显示为 \u0026ldquo;mixed mode\u0026rdquo;（而不是 \u0026ldquo;interpreted mode\u0026rdquo;）：\njava -version 应显示：OpenJDK 或 Oracle Java，版本 8+，\u0026ldquo;mixed mode\u0026rdquo;\n避免： GNU GCJ、过时的 Java 实现、仅解释执行模式\n常见端口冲突 发生在多个服务争用 I2P 的默认端口时。router 控制台 (7657)、I2CP (7654)、SAM (7656) 和 HTTP 代理 (4444) 必须可用。检查是否存在冲突：netstat -ano | findstr \u0026quot;7657 4444 7654\u0026quot; (Windows) 或 lsof -i :7657,4444,7654 (Linux/Mac)。\n配置文件损坏 会表现为程序立即崩溃，并在日志中出现解析错误。Router.config 要求使用无 BOM（字节序标记）的 UTF-8 编码，以 = 作为分隔符（而不是 :），并禁止某些特殊字符。请先备份，然后检查：~/.i2p/router.config (Linux), %LOCALAPPDATA%\\I2P\\router.config (Windows), ~/Library/Application Support/i2p/router.config (macOS)。\n在保留身份的情况下重置配置：停止 I2P，备份 router.keys 和 keyData 目录，删除 router.config，然后重启 I2P。router 会重新生成默认配置。\nJava 堆分配过低 会导致 OutOfMemoryError（内存不足错误）崩溃。编辑 wrapper.config，将 wrapper.java.maxmemory 从默认的 128 或 256 提高到 至少 512（高带宽的 routers 建议 1024）。这需要完全关闭，等待 11 分钟，然后重新启动 - 在控制台点击 \u0026ldquo;Restart\u0026rdquo; 不会应用该更改。\n排查并解决 \u0026ldquo;Network: Firewalled\u0026rdquo; 状态 防火墙状态意味着该 router 无法接收直接的入站连接，从而不得不依赖引介者。在这种状态下，尽管 router 仍可运行，性能会显著下降，且对网络的贡献依然微乎其微。要达到非防火墙状态，需要正确配置端口转发。\nrouter 会随机选择一个端口（用于通信），范围在 9000-31000 之间。请在 http://127.0.0.1:7657/confignet 查看你的端口 - 查找 \u0026ldquo;UDP Port\u0026rdquo; 和 \u0026ldquo;TCP Port\u0026rdquo;（通常是相同的数值）。为获得最佳性能，你必须同时为 UDP 和 TCP 进行端口转发，不过仅转发 UDP 也能提供基本功能。\n启用 UPnP 自动端口转发（最简单的方法）:\n访问 http://127.0.0.1:7657/confignet 勾选 \u0026ldquo;Enable UPnP\u0026rdquo; 保存更改并重启 router 等待 5-10 分钟，并验证状态从 \u0026ldquo;Network: Firewalled\u0026rdquo; 变为 \u0026ldquo;Network: OK\u0026rdquo; UPnP 需要 router 支持（在大多数 2010 年后制造的消费级 router 上默认启用）以及适当的网络配置。\n手动端口转发（当 UPnP 失败时需要）：\n在 http://127.0.0.1:7657/confignet 中记下你的 I2P 端口（例如 22648） 查找你的本地 IP 地址：ipconfig（Windows）、ip addr（Linux）、系统偏好设置 → 网络（macOS） 访问你的 router 管理界面（通常为 192.168.1.1 或 192.168.0.1） 找到“端口转发”（可能位于 Advanced、NAT 或 Virtual Servers 下） 创建两条规则： 外部端口：[你的 I2P 端口] → 内部 IP：[你的电脑] → 内部端口：[相同] → 协议：UDP 外部端口：[你的 I2P 端口] → 内部 IP：[你的电脑] → 内部端口：[相同] → 协议：TCP 保存配置，如果需要，重启你的 router 验证端口转发，在完成配置后使用在线检测工具。如果检测失败，请检查防火墙设置 - 系统防火墙和任何杀毒软件的防火墙都必须允许 I2P 端口。\nHidden mode（隐藏模式）备选方案，适用于无法进行端口转发的受限网络：在 http://127.0.0.1:7657/confignet 启用 → 勾选 \u0026ldquo;Hidden mode\u0026rdquo;。router 仍处于防火墙后，但会仅使用 SSU 引荐者来针对该状态进行优化。性能会更慢，但仍可正常使用。\nRouter 卡在 \u0026ldquo;Starting\u0026rdquo; 或 \u0026ldquo;Testing\u0026rdquo; 状态 这些在初始引导期间出现的短暂状态通常会在**10-15 分钟（针对新安装）或3-5 分钟（针对已建立的 routers）**内自行解决。过早干预通常会使问题变得更糟。\n\u0026ldquo;Network: Testing\u0026rdquo; 表示 router 正在通过各种连接类型（直连、introducers（引荐者）、多个协议版本）探测可达性。这在启动后的前 5-10 分钟内是正常现象。router 会测试多种场景以确定最佳配置。\n\u0026ldquo;Rejecting tunnels: starting up\u0026rdquo; 会在引导阶段出现，因为 router 暂时缺少足够的对等节点信息。router 在充分融入网络之前不会参与转发流量。当 netDb 填充到包含 50+ routers 后（通常需 10-20 分钟），这条消息就会消失。\n时钟偏差会导致可达性测试失败。 I2P 要求系统时间与网络时间的差异在 ±60 秒 内。差异超过 90 秒将导致自动拒绝连接。请同步您的系统时钟：\nLinux： sudo timedatectl set-ntp true \u0026amp;\u0026amp; sudo systemctl restart systemd-timesyncd\nWindows：控制面板 → 日期和时间 → Internet 时间 → 立即更新 → 启用自动同步\nmacOS: 系统偏好设置 → 日期与时间 → 启用 \u0026ldquo;自动设置日期与时间\u0026rdquo;\n在纠正时钟偏差后，完全重启 I2P，以确保正确集成。\n带宽分配不足会阻止测试顺利进行。router 需要足够的带宽来构建测试 tunnel。请在 http://127.0.0.1:7657/config 进行配置：\n最低可行： 入站 96 KB/sec，出站 64 KB/sec 推荐标准： 入站 256 KB/sec，出站 128 KB/sec 最佳性能： 入站 512+ KB/sec，出站 256+ KB/sec 共享百分比： 80%（允许 router 向网络贡献带宽） 较低的带宽也许可行，但会将集成时间从几分钟延长到数小时。\n损坏的 netDb（由于不当关机或磁盘错误）会导致持续的测试循环。缺少有效的对等节点数据时，router 无法完成测试：\n# Stop I2P completely i2prouter stop # or systemctl stop i2p # Delete corrupted database (safe - will reseed automatically) rm -rf ~/.i2p/netDb/* # Restart and allow 10-15 minutes for reseed i2prouter start Windows：删除 %APPDATA%\\I2P\\netDb\\ 或 %LOCALAPPDATA%\\I2P\\netDb\\ 中的内容\n防火墙阻止 reseed（重新播种） 会阻止获取初始对等节点。在引导（bootstrap）期间，I2P 会从 HTTPS reseed 服务器获取 router 信息。企业/ISP 防火墙可能会阻止这些连接。如果在受限网络下运行，请在 http://127.0.0.1:7657/configreseed 配置 reseed 代理。\n速度缓慢、超时以及 tunnel 构建失败 由于多跳加密、数据包开销以及路由不可预测性，I2P 的设计天然会导致比明网慢 3-10 倍。一次 tunnel 构建会穿越多个 routers，每个都会增加延迟。理解这一点可避免将正常行为误判为问题。\n典型性能预期：\n浏览 .i2p 站点：起初页面加载需要 10-30 秒，在完成 tunnel 构建后会更快 通过 I2PSnark 下载种子：每个种子 10-100 KB/秒，具体取决于做种者数量和网络状况 大型文件下载：需要耐心 - 兆字节级文件可能需要数分钟，千兆字节级文件可能需要数小时 第一次连接最慢：构建 tunnel 需要 30-90 秒；随后连接会使用现有的 tunnels Tunnel 构建成功率 表示网络健康状况。请在 http://127.0.0.1:7657/tunnels 查看：\n高于 60%： 运行正常、健康 40-60%： 临界，考虑增加带宽或降低负载 低于 40%： 存在问题 - 表明带宽不足、网络问题或对等体选择不佳 增加带宽分配 作为首要优化措施。大多数速度慢的问题源于带宽不足。在 http://127.0.0.1:7657/config 逐步提高限值，并在 http://127.0.0.1:7657/graphs 监控图表。\n适用于 DSL/有线宽带 (1-10 Mbps 连接): - 入站: 400 KB/秒 - 出站: 200 KB/秒 - 共享比例: 80% - 内存: 384 MB (编辑 wrapper.config)\n针对高速（10-100+ Mbps 连接）： - 入站：1500 KB/sec - 出站：1000 KB/sec - 共享：80-100% - 内存：512-1024 MB - 考虑：在 http://127.0.0.1:7657/configadvanced 将参与的 tunnels 增加到 2000-5000\n优化 tunnel 配置 以获得更好的性能。在 http://127.0.0.1:7657/i2ptunnel 访问各个 tunnel 的设置，并编辑每个 tunnel：\nTunnel 数量： 从 2 增加到 3-4（可用路径更多） 备份数量： 设置为 1-2（当 tunnel 故障时可快速故障转移） Tunnel 长度： 默认 3 跳具有良好平衡；减少到 2 可提升速度但会降低匿名性 原生加密库（jbigi） 相比纯 Java 加密可带来 5-10 倍的性能提升。可在 http://127.0.0.1:7657/logs 验证是否已加载 - 查找 \u0026ldquo;jbigi loaded successfully\u0026rdquo; 或 \u0026ldquo;Using native CPUID implementation\u0026rdquo;。如果没有看到：\nLinux：通常会自动检测并从 ~/.i2p/jbigi-*.so 加载 Windows：在 I2P 安装目录中检查 jbigi.dll 若缺失：安装构建工具并从源代码编译，或从官方软件仓库下载预编译二进制文件\n保持 router 持续运行。 每次重启都会重置网络融入度，需要 30-60 分钟来重建 tunnel 网络和对等节点关系。高在线时长且稳定的 router 会在 tunnel 构建中被优先选择，从而对性能形成正向反馈。\nCPU 和内存占用过高 资源使用过高通常表明内存分配不足、缺少本地加密库，或过度参与网络。配置良好的 router 在活跃使用期间应占用 10-30% 的 CPU，并将内存占用稳定在已分配堆的 80% 以下。\n内存问题的表现为： - 平顶型内存图（一直处于最大值） - 频繁的垃圾回收（锯齿形模式，伴随陡降） - 日志中出现 OutOfMemoryError - router 在负载下变得无响应 - 由于资源耗尽而自动关闭\n增大 Java 堆内存分配 在 wrapper.config 中 (需要完全关闭):\n# Linux: ~/.i2p/wrapper.config # Windows: %APPDATA%\\I2P\\wrapper.config # Find and modify: wrapper.java.maxmemory=512 # Recommendations by usage: # Light browsing only: 256 # Standard use (browsing + light torrenting): 512 # Heavy use (multiple applications, active torrenting): 768-1024 # Floodfill or very high bandwidth: 1024-2048 重要： 编辑 wrapper.config 之后，您必须完全关闭（不是重启），等待 11 分钟以便正常终止，然后进行全新启动。Router 控制台中的 \u0026ldquo;Restart\u0026rdquo; 按钮不会重新加载 wrapper 配置。\nCPU 优化需要本地加密库。 纯 Java 的 BigInteger（大整数类）运算比原生实现多消耗 10–20 倍的 CPU。启动期间请在 http://127.0.0.1:7657/logs 检查 jbigi 状态。没有 jbigi 时，在构建 tunnel 和执行加密操作期间，CPU 会飙升至 50-100%。\n降低参与的 tunnel 负载 如果 router 不堪重负：\n访问 http://127.0.0.1:7657/configadvanced 设置 router.maxParticipatingTunnels=1000 (默认 8000) 在 http://127.0.0.1:7657/config 将共享百分比从 80% 降低到 50% 如果已启用，禁用 floodfill 模式：router.floodfillParticipant=false 限制 I2PSnark（I2P 内置的 BitTorrent 客户端）的带宽和并发种子数量。 BitTorrent 传输会消耗大量资源。在 http://127.0.0.1:7657/i2psnark：\n将活跃的种子数量限制为最多 3-5 个 将 \u0026ldquo;Up BW Limit\u0026rdquo; 和 \u0026ldquo;Down BW Limit\u0026rdquo; 设置为合理的数值 (每个 50-100 KB/秒) 在不需要时停止种子 避免同时为数十个种子做种 监控资源使用情况，可通过 http://127.0.0.1:7657/graphs 的内置图表完成。内存曲线应留有余量，而非顶部拉平。构建 tunnel（隧道）期间出现 CPU 峰值属正常；若 CPU 长时间保持高负载，则表明存在配置问题。\n对于资源严重受限的系统（Raspberry Pi、老旧硬件），可以考虑使用 i2pd（C++ 实现）作为替代。i2pd 需要 ~130 MB RAM，而 Java I2P 需要 350+ MB；在类似负载下，其 CPU 使用率为 ~7%，而 Java I2P 为 70%。请注意，i2pd 不包含内置应用，需要配合外部工具。\nI2PSnark 种子问题 要理解 I2PSnark 与 I2P router 架构的集成，需要认识到：种子下载完全取决于 router 的 tunnel 健康状况。在 router 充分接入网络（与 10 个以上活跃对等节点互联）且 tunnel 正常工作之前，种子不会开始。\n种子下载卡在 0% 通常表示：\nRouter 尚未完全加入网络： 在 I2P 启动后等待 10-15 分钟，再期望出现种子活动 DHT 已禁用： 在 http://127.0.0.1:7657/i2psnark → Configuration → 勾选 \u0026ldquo;Enable DHT\u0026rdquo;（自 0.9.2 版本起默认启用） 无效或失效的跟踪器： I2P 种子需要 I2P 专用的跟踪器 - 明网跟踪器无法工作 tunnel 配置不足： 在 I2PSnark Configuration → Tunnels 部分增加 tunnels 配置 I2PSnark tunnels 以获得更佳性能:\n入站 tunnels：3-5（Java I2P 默认 2，i2pd 为 5） 出站 tunnels：3-5 tunnel 长度：3 跳（为提高速度可降至 2，但匿名性更低） tunnel 数量：3（可提供稳定的性能） 必备的 I2P Torrent 追踪器 建议包含： - tracker2.postman.i2p（首选，最可靠） - w7tpbzncbcocrqtwwm3nezhnnsw4ozadvi2hmvzdhrqzfxfum7wa.b32.i2p/a\n移除所有明网（非 .i2p）跟踪器 - 它们没有任何价值，并会导致连接尝试超时。\n\u0026ldquo;Torrent not registered\u0026rdquo; 错误 通常发生在与跟踪器通信失败时。右键单击种子 → \u0026ldquo;Start\u0026rdquo; 可强制重新向跟踪器通告。若问题仍然存在，请在已配置 I2P 的浏览器中访问 http://tracker2.postman.i 2p 以验证跟踪器是否可达。失效的跟踪器应更换为可用的替代项。\n没有对等节点连接，即便追踪器成功，也可能表示： - Router 被防火墙阻挡（开启端口转发会改善，但并非必需） - 带宽不足（提高到 256+ KB/sec） - 资源群（swarm）过小（有些种子只有 1–2 位做种者；需要耐心） - DHT（分布式哈希表）被禁用（启用以进行无追踪器的对等节点发现）\n启用 DHT 和 PEX（Peer Exchange，对等节点交换） 在 I2PSnark 配置中。DHT（分布式哈希表）可在不依赖跟踪器的情况下发现对等节点。PEX 会从已连接的对等节点中发现更多对等节点，从而加速群体发现。\n已下载文件损坏 借助 I2PSnark 的内置完整性校验，这种情况很少发生。若检测到：\n右键单击种子 → \u0026ldquo;Check\u0026rdquo; 将强制对所有分片重新计算哈希 删除损坏的种子数据（保留 .torrent 文件） 右键单击 → \u0026ldquo;Start\u0026rdquo; 以带分片校验重新下载 若损坏仍然存在，请检查磁盘是否有错误：chkdsk (Windows), fsck (Linux) 监视目录不起作用 需要正确配置：\nI2PSnark 配置 → \u0026ldquo;监视目录\u0026rdquo;：设置绝对路径（例如：/home/user/torrents/watch） 确保 I2P 进程具有读取权限：chmod 755 /path/to/watch 将 .torrent 文件放入监视目录 - I2PSnark 会自动添加它们 配置 \u0026ldquo;自动启动\u0026rdquo;：设置是否在添加后立即启动种子 BT 下载性能优化：\n限制并发的活动种子：标准连接最多 3-5 个 优先处理重要下载：暂时停止低优先级种子 增加 router 的带宽分配：带宽越多 = 种子性能越好 请耐心等待：I2P 种子下载本质上比明网 BitTorrent 更慢 下载完成后请做种：网络靠互惠才能繁荣 通过 I2P 使用 Git 的配置与故障排除 通过 I2P 进行的 Git 操作需要 SOCKS 代理配置 或 专用的 I2P tunnel，以实现 SSH/HTTP 访问。Git 的设计假定低时延连接，因此在 I2P 的高时延架构上运行会面临挑战。\n将 Git 配置为使用 I2P 的 SOCKS 代理：\n编辑 ~/.ssh/config（如果不存在则创建）：\nHost *.i2p ProxyCommand nc -X 5 -x 127.0.0.1:4447 %h %p ServerAliveInterval 60 ServerAliveCountMax 3 Compression yes 这会将所有指向 .i2p 主机的 SSH 连接通过 I2P 的 SOCKS 代理（端口 4447）进行路由。ServerAlive 设置可在 I2P 延迟期间保持连接。\n对于通过 HTTP/HTTPS 进行的 Git 操作，请全局配置 Git：\ngit config --global http.proxy socks5h://127.0.0.1:4447 git config --global https.proxy socks5h://127.0.0.1:4447 注意：socks5h 通过代理进行 DNS 解析 - 这对 .i2p 域名至关重要。\n为 Git SSH 创建专用 I2P tunnel (比 SOCKS 更可靠):\n访问 http://127.0.0.1:7657/i2ptunnel \u0026ldquo;新建客户端 tunnel\u0026rdquo; → \u0026ldquo;Standard\u0026rdquo; 配置： 名称：Git-SSH 类型：Client 端口：2222（用于 Git 访问的本地端口） 目标： [your-git-server].i2p:22 自动启动：启用 Tunnel 数量：3-4（数量更高更可靠） 保存并启动 tunnel 配置 SSH 使用 tunnel：ssh -p 2222 git@127.0.0.1 在 I2P 上的 SSH 认证错误 通常源于：\n未将密钥添加到 ssh-agent：ssh-add ~/.ssh/id_rsa 密钥文件权限不正确：chmod 600 ~/.ssh/id_rsa Tunnel 未运行：在 http://127.0.0.1:7657/i2ptunnel 验证状态是否为绿色 Git 服务器要求特定密钥类型：如果 RSA 失败，请生成 ed25519 密钥 Git 操作超时 与 I2P 的延迟特性有关：\n提高 Git 超时时间：git config --global http.postBuffer 524288000（500MB 缓冲区） 提高低速限制：git config --global http.lowSpeedLimit 1000 和 git config --global http.lowSpeedTime 600（等待 10 分钟） 初次检出使用浅克隆：git clone --depth 1 [url]（仅获取最新提交，更快） 在低活跃时段进行克隆：网络拥塞会影响 I2P 性能 git clone/fetch 操作较慢 是 I2P 架构固有的。一个 100MB 的仓库在 I2P 上可能需要 30–60 分钟，而在明网（clearnet）上只需几秒。应对策略：\n使用浅克隆：--depth 1 可显著减少初始数据传输量 增量获取：与其进行完整克隆，不如仅获取指定分支：git fetch origin branch:branch 考虑通过 I2P 使用 rsync：对于非常大的仓库，rsync 可能表现更好 增加 tunnel 数量：更多的 tunnel 可为持续的大规模传输提供更好的吞吐量 \u0026ldquo;Connection refused\u0026rdquo; 错误 表明 tunnel 配置错误:\n验证 I2P router 正在运行：检查 http://127.0.0.1:7657 确认 tunnel 在 http://127.0.0.1:7657/i2ptunnel 上处于激活状态并显示为绿色 测试 tunnel：nc -zv 127.0.0.1 2222 (如果 tunnel 工作正常，应能连接) 检查目标是否可达：如果可用，访问目标的 HTTP 接口 在 http://127.0.0.1:7657/logs 查看 tunnel 日志，查找具体错误 通过 I2P 使用 Git 的最佳实践：\n持续运行 I2P router，以确保稳定的 Git 访问 使用 SSH 密钥而非密码认证（减少交互式提示） 配置持久的 tunnels，而不是临时的 SOCKS 连接 考虑自行托管 I2P Git 服务器，以获得更好的控制 为协作者记录你的 .i2p Git 端点 访问 eepsites 并解析 .i2p 域名 用户无法访问 .i2p 站点最常见的原因是浏览器代理配置不正确。I2P 站点仅存在于 I2P 网络内部，必须通过 I2P 的 HTTP 代理进行路由。\n严格按如下配置浏览器代理设置：\nFirefox (推荐用于 I2P):\n菜单 → 设置 → 网络设置 → 设置按钮 选择 \u0026ldquo;手动代理配置\u0026rdquo; HTTP 代理: 127.0.0.1 端口: 4444 SSL 代理: 127.0.0.1 端口: 4444 SOCKS 代理: 127.0.0.1 端口: 4447 (可选，用于 SOCKS 应用) 勾选 \u0026ldquo;使用 SOCKS v5 时代理 DNS\u0026rdquo; 点击 OK 保存 关键的 Firefox about:config 设置：\n前往 about:config 并修改：\nmedia.peerconnection.ice.proxy_only = true (防止 WebRTC 泄露 IP) keyword.enabled = false (防止 .i2p 地址被重定向到搜索引擎) network.proxy.socks_remote_dns = true (通过代理进行 DNS 解析) Chrome/Chromium 的局限性：\nChrome 使用系统级代理设置，而非特定于应用程序的设置。在 Windows 上：设置 → 搜索“代理” → “打开计算机的代理设置” → 配置 HTTP: 127.0.0.1:4444 和 HTTPS: 127.0.0.1:4445。\n更好的做法：使用 FoxyProxy 或 Proxy SwitchyOmega 扩展，对 .i2p 进行选择性路由。\n\u0026ldquo;Website Not Found In Address Book\u0026rdquo; 错误 表示 router 缺少该 .i2p 域名的加密地址。I2P 使用本地地址簿，而不是集中式 DNS。解决方案：\n方法一：使用跳转服务 (对新站点最简单):\n访问 http://stats.i 2p 并搜索该站点。点击 addresshelper 链接：http://example.i2p/?i2paddresshelper=base64destination。你的浏览器会显示 \u0026ldquo;Save to addressbook?\u0026rdquo; - 确认以添加。\n方法 2：更新地址簿订阅：\n访问 http://127.0.0.1:7657/dns (SusiDNS) 点击 \u0026ldquo;Subscriptions\u0026rdquo; 选项卡 确认活动订阅 (默认: http://i2p-projekt.i 2p/hosts.txt) 添加推荐的订阅: http://stats.i 2p/cgi-bin/newhosts.txt http://notbob.i 2p/hosts.txt http://reg.i 2p/export/hosts.txt 点击 \u0026ldquo;Update Now\u0026rdquo; 以立即强制更新订阅 等待 5-10 分钟以完成处理 方法 3：使用 base32 地址 (只要站点在线，就始终可用):\n每个 .i2p 站点都有一个 Base32 地址：由 52 个随机字符加上后缀 .b32.i2p 组成（例如，ukeu3k5oycgaauneqgtnvselmt4yemvoilkln7jpvamvfx7dnkdq.b32.i2p）。Base32 地址会绕过地址簿 - router 会直接进行基于密码学的查找。\n常见的浏览器配置错误：\n在仅支持 HTTP 的站点上尝试使用 HTTPS：大多数 .i2p 站点仅使用 HTTP - 尝试 https://example.i2p 会失败 忘记加上 http:// 前缀：浏览器可能会搜索而不是连接 - 始终使用 http://example.i2p 启用 WebRTC：可能泄露真实 IP 地址 - 可通过 Firefox 设置或扩展禁用 DNS 未通过代理：clearnet（明网）DNS 无法解析 .i2p - 必须通过代理发送 DNS 查询 代理端口错误：HTTP 用 4444（不是 4445，后者是到 clearnet 的 HTTPS outproxy（外部代理）） Router 未完全集成 将导致无法访问任何站点。请确认集成是否到位：\n检查 http://127.0.0.1:7657 是否显示 \u0026ldquo;Network: OK\u0026rdquo; 或 \u0026ldquo;Network: Firewalled\u0026rdquo;（不是 \u0026ldquo;Network: Testing\u0026rdquo;） 活动对等节点应显示至少 10 个（50+ 为最佳） 没有 \u0026ldquo;Rejecting tunnels: starting up\u0026rdquo; 消息 在 router 启动后，至少等待完整的 10-15 分钟，再期望能够访问 .i2p IRC 和电子邮件客户端配置 遵循类似的代理模式：\nIRC: 客户端连接到 127.0.0.1:6668（I2P 的 IRC 代理 tunnel（隧道））。请禁用 IRC 客户端的代理设置 - 到 localhost:6668 的连接已通过 I2P 进行代理。\n电子邮件 (Postman): - SMTP: 127.0.0.1:7659 - POP3: 127.0.0.1:7660 - 无 SSL/TLS (加密由 I2P tunnel 处理) - 使用在 postman.i2p 注册的账户凭据\n所有这些 tunnels 必须在 http://127.0.0.1:7657/i2ptunnel 显示为\u0026quot;running\u0026quot;（绿色）状态。\n安装失败与软件包问题 基于软件包的安装（Debian、Ubuntu、Arch）偶尔会因仓库变更、GPG 密钥过期或依赖冲突而失败。最近的版本中，官方软件源已从 deb.i2p2.de/deb.i2p2.no（已停止维护）变更为 deb.i2p.net。\n将 Debian/Ubuntu 软件源更新为最新：\n# Remove old repository entries sudo rm /etc/apt/sources.list.d/i2p.list # Add current repository echo \u0026#34;deb [signed-by=/usr/share/keyrings/i2p-archive-keyring.gpg] https://deb.i2p.net/ $(lsb_release -sc) main\u0026#34; | sudo tee /etc/apt/sources.list.d/i2p.list # Download and install current signing key curl -o i2p-archive-keyring.gpg https://geti2p.net/_static/i2p-archive-keyring.gpg sudo cp i2p-archive-keyring.gpg /usr/share/keyrings/ # Update and install sudo apt update sudo apt install i2p i2p-keyring GPG 签名验证失败 会在软件仓库密钥过期或发生更换时出现：\n# Error: \u0026#34;The following signatures were invalid\u0026#34; # Solution: Install current keyring package sudo apt install i2p-keyring # Manual key import if package unavailable wget https://geti2p.net/_static/i2p-debian-repo.key.asc sudo apt-key add i2p-debian-repo.key.asc 在安装软件包后服务无法启动 最常见的原因是 Debian/Ubuntu 上的 AppArmor 配置文件问题：\n# Check service status sudo systemctl status i2p.service # Common error: \u0026#34;Failed at step APPARMOR spawning\u0026#34; # Solution: Reconfigure without AppArmor sudo dpkg-reconfigure -plow i2p # Select \u0026#34;No\u0026#34; for AppArmor when prompted # Alternative: Set profile to complain mode sudo aa-complain /usr/sbin/wrapper # Check logs for specific errors sudo journalctl -xe -u i2p.service 权限问题 在通过软件包安装的 I2P 上：\n# Fix ownership (package install uses \u0026#39;i2psvc\u0026#39; user) sudo chown -R i2psvc:i2psvc /var/lib/i2p /var/log/i2p /run/i2p sudo chmod 750 /var/log/i2p /var/lib/i2p # Set file descriptor limits (add to /etc/security/limits.conf) i2psvc soft nofile 4096 i2psvc hard nofile 8192 Java 兼容性问题：\nI2P 2.10.0 需要至少 Java 8。较旧的系统可能仅有 Java 7 或更早版本：\n# Check Java version java -version # Install appropriate Java (Debian/Ubuntu) sudo apt install openjdk-11-jre-headless # Set default Java if multiple versions installed sudo update-alternatives --config java Wrapper（Java 服务包装器）配置错误 会阻止服务启动：\nWrapper.config 的位置因安装方式而异： - 用户安装：~/.i2p/wrapper.config - 软件包安装：/etc/i2p/wrapper.config 或 /var/lib/i2p/wrapper.config\n常见 wrapper.config 问题：\n路径不正确：wrapper.java.command 必须指向有效的 Java 安装 内存不足：wrapper.java.maxmemory 设置过低（提高到 512MB 以上） pid 文件位置错误：wrapper.pidfile 必须是可写位置 缺少 wrapper 二进制：某些平台没有预编译的 wrapper（使用 runplain.sh 作为后备） 更新失败与损坏的更新：\n由于网络中断，Router 控制台的更新偶尔会在下载过程中失败。手动更新步骤：\n从 https://geti2p.net/en/download 下载 i2pupdate_X.X.X.zip 验证 SHA256 校验和是否与发布的哈希一致 将其复制到 I2P 安装目录，命名为 i2pupdate.zip 重启 router - 会自动检测并解压更新 等待 5-10 分钟完成更新安装 在 http://127.0.0.1:7657 验证新版本 从非常旧的版本迁移 (pre-0.9.47) 到当前版本可能会因为签名密钥不兼容或功能被移除而失败。需要逐步更新：\n版本低于 0.9.9：无法验证当前签名 - 需要手动更新 运行在 Java 6/7 的版本：在将 I2P 更新到 2.x 之前必须先升级 Java 存在大版本跨越：先更新到中间版本（推荐以 0.9.47 作为过渡版本） 何时使用安装程序，何时使用软件包：\n软件包 (apt/yum): 最适合服务器、自动安全更新、系统集成、systemd 管理 安装程序 (.jar): 最适合用户级安装、Windows、macOS、自定义安装、可获取最新版本 配置文件损坏与恢复 I2P 的配置持久化依赖若干关键文件。损坏通常源于不当关机、磁盘错误或手动编辑失误。理解这些文件的用途能实现外科式修复，而无需完全重新安装。\n关键文件及其用途:\nrouter.keys (516+ 字节): router 的加密身份 - 丢失此文件会创建新的身份 router.info (自动生成): 已发布的 router 信息 - 可安全删除，会重新生成 router.config (文本): 主配置 - 带宽、网络设置、首选项 i2ptunnel.config (文本): tunnel 定义 - 客户端/服务器 tunnels、密钥、目的地 netDb/ (目录): 对等体数据库 - 网络参与者的 router 信息 peerProfiles/ (目录): 对等体性能统计 - 影响 tunnel 选择 keyData/ (目录): 面向 eepsites 和服务的目的地密钥 - 丢失会导致地址改变 addressbook/ (目录): 本地 .i2p 主机名映射 完整备份流程（修改前）：\n# Stop I2P first i2prouter stop # or: systemctl stop i2p # Backup directory BACKUP_DIR=~/i2p-backup-$(date +%Y%m%d-%H%M) mkdir -p $BACKUP_DIR # Copy critical files cp -r ~/.i2p/router.keys $BACKUP_DIR/ cp -r ~/.i2p/*.config $BACKUP_DIR/ cp -r ~/.i2p/keyData $BACKUP_DIR/ cp -r ~/.i2p/addressbook $BACKUP_DIR/ cp -r ~/.i2p/eepsite $BACKUP_DIR/ # if hosting sites # Optional but recommended tar -czf $BACKUP_DIR.tar.gz $BACKUP_DIR Router.config 损坏症状：\nRouter 无法启动，日志中有解析错误 重启后设置无法保存 出现了意外的默认值 查看文件时出现乱码 修复损坏的 router.config：\n备份现有文件: cp router.config router.config.broken 检查文件编码: 必须为 UTF-8 (无 BOM) 验证语法: 键使用 = 作为分隔符 (不是 :)，键名后不得有尾随空格，# 仅用于注释 常见损坏: 值中含有非 ASCII 字符，行结尾问题 (CRLF vs LF) 若无法修复: 删除 router.config - router 会生成默认配置，并保留身份标识 需要保留的关键 router.config 设置：\ni2np.bandwidth.inboundKBytesPerSecond=512 i2np.bandwidth.outboundKBytesPerSecond=256 router.updatePolicy=notify routerconsole.lang=en router.hiddenMode=false 丢失或无效的 router.keys 会创建新的 router 身份。这是可接受的，除非：\n运行 floodfill（I2P 网络中的目录泛洪节点）（会失去 floodfill 身份） 托管使用已公开地址的 eepsites（I2P 隐匿站点）（会失去连续性） 在网络中已建立的声誉 没有备份则无法恢复 - 生成新的：删除 router.keys，重启 I2P，会创建新的身份。\n关键区别： router.keys（身份）vs keyData/*（服务）。丢失 router.keys 会改变 router 身份。丢失 keyData/mysite-keys.dat 会改变你的 eepsite 的 .i2p 地址 - 如果地址已发布，将是灾难性的。\n单独备份 eepsite/服务密钥：\n# Identify your service keys ls -la ~/.i2p/keyData/ # Backup with descriptive names cp ~/.i2p/keyData/myservice-keys.dat ~/backups/myservice-keys-$(date +%Y%m%d).dat # Store securely (encrypted if sensitive) gpg -c ~/backups/myservice-keys-*.dat NetDb 和 peerProfiles 数据损坏：\n症状：0 个活跃对等节点，无法构建 tunnels，日志中出现 \u0026ldquo;Database corruption detected\u0026rdquo;\n安全的修复方法（全部将自动进行 reseed（重新引导）/重建）：\ni2prouter stop rm -rf ~/.i2p/netDb/* rm -rf ~/.i2p/peerProfiles/* i2prouter start # Wait 10-15 minutes for reseed and integration 这些目录仅包含缓存的网络信息 - 删除它们会强制进行全新引导，但不会丢失任何关键数据。\n预防策略：\n始终优雅关闭： 使用 i2prouter stop 或 router 控制台 \u0026ldquo;Shutdown\u0026rdquo; 按钮 - 切勿强制终止进程 自动备份： 使用 cron 作业（定时任务）每周将 ~/.i2p 备份到独立磁盘 磁盘健康监控： 定期检查 SMART（自监测、分析与报告技术）状态 - 故障磁盘会损坏数据 足够的磁盘空间： 保持至少 1 GB 可用空间 - 磁盘写满会导致数据损坏 建议使用 UPS（不间断电源）： 写入过程中断电会损坏文件 关键配置纳入版本控制： 为 router.config、i2ptunnel.config 建立 Git 仓库，以便回滚 文件权限很重要：\n# Correct permissions (user install) chmod 600 ~/.i2p/router.keys chmod 600 ~/.i2p/*.config chmod 700 ~/.i2p/keyData chmod 755 ~/.i2p # Never run as root - creates permission problems 常见错误消息解读 I2P 的日志记录会提供能精准定位问题的具体错误信息。理解这些信息能加快故障排查。\n\u0026ldquo;No tunnels available\u0026rdquo; 会在 router 尚未构建足够的 tunnels 以供运行时出现。这在启动后前 5-10 分钟内是正常的。如果持续超过 15 分钟：\n在 http://127.0.0.1:7657 确认 Active Peers \u0026gt; 10 检查带宽分配是否足够（至少 128 KB/秒） 在 http://127.0.0.1:7657/tunnels 查看 tunnel 成功率（应 \u0026gt;40%） 查看日志以了解 tunnel 构建被拒原因 \u0026ldquo;Clock skew detected\u0026rdquo; 或 \u0026ldquo;NTCP2 disconnect code 7\u0026rdquo; 表示系统时间与网络共识时间相差超过 90 秒。I2P 要求 ±60 秒的时间精度。与时间偏离的 router 的连接会被自动拒绝。\n立即修复：\n# Linux sudo timedatectl set-ntp true sudo systemctl restart systemd-timesyncd date # Verify correct time # Windows # Control Panel → Date and Time → Internet Time → Update now # Verify after sync http://127.0.0.1:7657/logs # Should no longer show clock skew warnings \u0026ldquo;Build timeout\u0026rdquo; 或 \u0026ldquo;Tunnel build timeout exceeded\u0026rdquo; 表示通过 peer chain（对等节点链）进行的 tunnel 构建未能在超时窗口内完成（通常为 60 秒）。可能原因：\n对等节点缓慢： Router 为 tunnel 选择了无响应的参与者 网络拥塞： I2P 网络正在承受高负载 带宽不足： 您的带宽限制导致无法及时构建 tunnel router 过载： 过多的参与中继的 tunnels 正在消耗资源 解决方案：提高带宽，减少参与的 tunnels（router.maxParticipatingTunnels 位于 http://127.0.0.1:7657/configadvanced），启用端口转发以改进对等节点选择。\n\u0026ldquo;Router is shutting down\u0026rdquo; 或 \u0026ldquo;Graceful shutdown in progress\u0026rdquo; 会在正常关机或崩溃恢复过程中出现。由于 router 会关闭 tunnels、通知对等节点并持久化状态，优雅关闭可能需要最长 10 分钟。\n如果在关闭状态卡住超过 11 分钟，请强制终止：\n# Linux kill -9 $(pgrep -f i2p) # Windows taskkill /F /IM javaw.exe \u0026ldquo;java.lang.OutOfMemoryError: Java heap space\u0026rdquo; 表示堆内存耗尽。立即的解决方案：\n编辑 wrapper.config：wrapper.java.maxmemory=512（或更高） 必须完全关闭 - 重启不会应用更改 等待 11 分钟以彻底关闭 全新启动 router 在 http://127.0.0.1:7657/graphs 验证内存分配 - 应显示余量 相关的内存错误：\n\u0026ldquo;GC overhead limit exceeded\u0026rdquo;: 垃圾回收耗时过多 - 增大堆内存 \u0026ldquo;Metaspace\u0026rdquo;: Java 类元数据空间耗尽 - 添加 wrapper.java.additional.X=-XX:MaxMetaspaceSize=256M 仅限 Windows： 无论 wrapper.config 的设置如何，卡巴斯基杀毒软件都会将 Java 堆限制为 512MB - 请卸载或将 I2P 添加到排除列表。\n\u0026ldquo;Connection timeout\u0026rdquo; 或 \u0026ldquo;I2CP Error - port 7654\u0026rdquo; 当应用程序尝试连接到 router 时：\n验证 router 正在运行: http://127.0.0.1:7657 应该有响应 检查 I2CP 端口: netstat -an | grep 7654 应显示 LISTENING 确保本地主机防火墙允许: sudo ufw allow from 127.0.0.1 验证应用程序使用了正确端口 (I2CP=7654, SAM=7656) 在 reseed 期间出现 \u0026ldquo;证书验证失败\u0026rdquo; 或 \u0026ldquo;RouterInfo 损坏\u0026rdquo;（RouterInfo：路由信息对象）：\n根因：时钟偏移（先修复）、损坏的 netDb、无效的 reseed（引导种子）证书\n# After fixing clock: i2prouter stop rm -rf ~/.i2p/netDb/* # Delete corrupted database i2prouter start # Auto-reseeds with fresh data \u0026ldquo;Database corruption detected\u0026rdquo; 表示在 netDb 或 peerProfiles 中存在磁盘级的数据损坏：\n# Safe fix - all will rebuild i2prouter stop rm -rf ~/.i2p/netDb/* ~/.i2p/peerProfiles/* i2prouter start 使用 SMART（自监测、分析与报告技术）工具检查磁盘健康状况 - 反复出现的数据损坏表明存储设备可能正在出现故障。\n平台特定的挑战 不同的操作系统在 I2P 部署方面会带来与权限、安全策略和系统集成相关的独特挑战。\nLinux 权限与服务问题 通过软件包安装的 I2P 以系统用户 i2psvc (Debian/Ubuntu) 或 i2p (其他发行版) 的身份运行，需要特定权限：\n# Fix package install permissions sudo chown -R i2psvc:i2psvc /var/lib/i2p /var/log/i2p /run/i2p sudo chmod 750 /var/log/i2p /var/lib/i2p sudo chmod 644 /var/lib/i2p/*.config # User install permissions (should be your user) chown -R $USER:$USER ~/.i2p chmod 700 ~/.i2p chmod 600 ~/.i2p/router.keys ~/.i2p/*.config 文件描述符限制 会影响router的连接承载能力。默认限制（1024）对于高带宽router来说不足：\n# Check current limits ulimit -n # Temporary increase ulimit -n 4096 # Permanent fix: Edit /etc/security/limits.conf i2psvc soft nofile 4096 i2psvc hard nofile 8192 # Systemd override sudo mkdir -p /etc/systemd/system/i2p.service.d/ sudo nano /etc/systemd/system/i2p.service.d/override.conf # Add: [Service] LimitNOFILE=8192 sudo systemctl daemon-reload sudo systemctl restart i2p 在 Debian/Ubuntu 上常见的 AppArmor 冲突 会阻止服务启动：\n# Error: \u0026#34;Failed at step APPARMOR spawning /usr/sbin/wrapper\u0026#34; # Cause: AppArmor profile missing or misconfigured # Solution 1: Disable AppArmor for I2P sudo aa-complain /usr/sbin/wrapper # Solution 2: Reconfigure package without AppArmor sudo dpkg-reconfigure -plow i2p # Select \u0026#34;No\u0026#34; when asked about AppArmor # Solution 3: LXC/Proxmox containers - disable AppArmor in container config lxc.apparmor.profile: unconfined SELinux 问题 在 RHEL/CentOS/Fedora 上:\n# Temporary: Set permissive mode sudo setenforce 0 # Permanent: Generate custom policy sudo ausearch -c \u0026#39;java\u0026#39; --raw | audit2allow -M i2p_policy sudo semodule -i i2p_policy.pp # Or disable SELinux for I2P process (less secure) sudo semanage permissive -a i2p_t SystemD（Linux 初始化系统）服务故障排查:\n# Detailed service status sudo systemctl status i2p.service -l # Full logs sudo journalctl -xe -u i2p.service # Follow logs live sudo journalctl -f -u i2p.service # Restart with logging sudo systemctl restart i2p.service \u0026amp;\u0026amp; sudo journalctl -f -u i2p.service Windows 防火墙和杀毒软件干扰 Windows Defender 和第三方防病毒产品经常会因其网络行为模式而将 I2P 标记为可疑。通过正确配置，可以在保持安全性的同时避免不必要的阻断。\n配置 Windows Defender 防火墙：\n# Run PowerShell as Administrator # Find Java path (adjust for your Java installation) $javaPath = \u0026#34;C:\\Program Files\\Eclipse Adoptium\\jdk-11.0.16.101-hotspot\\bin\\javaw.exe\u0026#34; # Create inbound rules New-NetFirewallRule -DisplayName \u0026#34;I2P Java\u0026#34; -Direction Inbound -Program $javaPath -Action Allow New-NetFirewallRule -DisplayName \u0026#34;I2P UDP\u0026#34; -Direction Inbound -Protocol UDP -LocalPort 22648 -Action Allow New-NetFirewallRule -DisplayName \u0026#34;I2P TCP\u0026#34; -Direction Inbound -Protocol TCP -LocalPort 22648 -Action Allow # Add exclusions to Windows Defender Add-MpPreference -ExclusionPath \u0026#34;C:\\Program Files\\i2p\u0026#34; Add-MpPreference -ExclusionPath \u0026#34;$env:APPDATA\\I2P\u0026#34; Add-MpPreference -ExclusionPath \u0026#34;$env:LOCALAPPDATA\\I2P\u0026#34; Add-MpPreference -ExclusionProcess \u0026#34;javaw.exe\u0026#34; 将端口 22648 替换为你在 http://127.0.0.1:7657/confignet 上的实际 I2P 端口。\nKaspersky 防病毒软件特定问题: 无论 wrapper.config 如何设置，Kaspersky 的 \u0026ldquo;Application Control\u0026rdquo; 都会将 Java 堆限制为 512MB。这会在高带宽的 router 上导致 OutOfMemoryError。\n解决方案：1. 将 I2P 添加到卡巴斯基的排除列表：Settings → Additional → Threats and Exclusions → Manage Exclusions 2. 或卸载卡巴斯基（为 I2P 正常运行所推荐）\n第三方防病毒通用指南：\n将 I2P 安装目录添加到排除项 将 %APPDATA%\\I2P 和 %LOCALAPPDATA%\\I2P 添加到排除项 将 javaw.exe 从行为分析中排除 禁用可能干扰 I2P 协议的“Network Attack Protection”功能 macOS Gatekeeper 阻止安装 macOS Gatekeeper（macOS 的应用安全机制）会阻止未签名的应用程序运行。I2P 安装程序未使用 Apple 开发者 ID 进行签名，从而触发安全警告。\n为 I2P 安装程序绕过 Gatekeeper：\n# Method 1: Remove quarantine attribute xattr -d com.apple.quarantine ~/Downloads/i2pinstall_*.jar java -jar ~/Downloads/i2pinstall_*.jar # Method 2: Use System Settings (macOS 13+) # Try to open installer → macOS blocks it # System Settings → Privacy \u0026amp; Security → scroll down # Click \u0026#34;Open Anyway\u0026#34; next to I2P warning # Confirm in dialog # Method 3: Control-click installer # Control-click (right-click) i2pinstall_*.jar # Select \u0026#34;Open\u0026#34; from menu → \u0026#34;Open\u0026#34; again in dialog # Bypasses Gatekeeper for this specific file 安装后运行 仍可能触发警告：\n# If I2P won\u0026#39;t start due to Gatekeeper: xattr -dr com.apple.quarantine ~/i2p/ 切勿永久禁用 Gatekeeper（macOS 应用安全机制） - 会给其他应用带来安全风险。仅使用针对特定文件的绕过。\nmacOS 防火墙配置：\n系统偏好设置 → 安全性与隐私 → 防火墙 → 防火墙选项 点击 \u0026ldquo;+\u0026rdquo; 以添加应用程序 导航到 Java 安装路径（例如：/Library/Java/JavaVirtualMachines/jdk-11.jdk/Contents/Home/bin/java） 添加并将其设置为 \u0026ldquo;允许传入连接\u0026rdquo; Android I2P 应用程序问题 Android 版本约束与资源限制带来了独特的挑战。\n最低要求: - 当前版本需要 Android 5.0+（API 级别 21+） - 至少 512MB RAM, 推荐 1GB+ - 应用与 router 数据占用 100MB 存储空间 - 为 I2P 禁用后台应用限制\n应用程序立即崩溃：\n检查 Android 版本： 设置 → 关于手机 → Android 版本（必须为 5.0+） 卸载所有 I2P 版本： 仅安装其中一种： net.i2p.android (Google Play) net.i2p.android.router (F-Droid)\n同时安装多个会产生冲突 清除应用数据： 设置 → 应用 → I2P → 存储 → 清除数据 从干净状态重新安装 电池优化导致 router 被杀死：\nAndroid 会为节省电量而激进地终止后台应用。I2P 需要被排除（豁免）：\n设置 → 电池 → 电池优化（或 应用电池使用情况） 找到 I2P → 不优化（或 允许后台活动） 设置 → 应用 → I2P → 电池 → 允许后台活动 + 取消限制 移动端连接问题：\nBootstrap（引导）需要 WiFi： 初始 reseed（引导获取节点数据）会下载大量数据 - 请使用 WiFi，而非蜂窝网络 网络变更： I2P 对网络切换处理不佳 - 在 WiFi/蜂窝网络切换后重启应用 移动端带宽： 建议保守配置为 64-128 KB/秒，以避免耗尽蜂窝数据流量 移动端性能优化：\nI2P 应用 → 菜单 → 设置 → 带宽 针对蜂窝网络，设置合适的限制：入站 64 KB/sec，出站 32 KB/sec 减少参与的 tunnels：设置 → 高级 → 参与的 tunnels 最大数：100-200 启用 \u0026ldquo;Stop I2P when screen off\u0026rdquo; 以节省电量 在 Android 上的 BT 下载：\n将同时进行的种子数量限制为最多 2–3 个 降低 DHT（分布式哈希表）的激进程度 仅在进行种子传输时使用 WiFi 接受在移动设备上的较慢速度 Reseed（重新播种）和 bootstrap（引导）问题 新的 I2P 安装需要 reseeding（从公共 HTTPS 服务器获取初始节点信息的网络引导过程），以便加入网络。Reseed 问题会让用户陷入 0 个节点且无法访问网络的状态。\n在全新安装后出现 \u0026ldquo;No active peers\u0026rdquo; 通常表示 reseed（初始引导获取节点）失败。症状：\n已知 peers（对等节点）: 为 0 或一直低于 5 \u0026ldquo;Network: Testing\u0026rdquo; 持续超过 15 分钟 日志显示 \u0026ldquo;Reseed failed\u0026rdquo; 或与 reseed（引导）服务器的连接错误 为什么 reseed（网络引导）会失败：\n防火墙阻止 HTTPS： 企业/ISP 防火墙阻止到 reseed server（I2P 引导服务器）的连接（端口 443） SSL 证书错误： 系统缺少最新的根证书 代理要求： 网络要求通过 HTTP/SOCKS 代理进行外部连接 时钟偏差： 当系统时间不正确时，SSL 证书验证会失败 地域封锁： 某些国家/ISP 会封锁已知的 reseed servers 强制手动执行 reseed（重新引导）:\n访问 http://127.0.0.1:7657/configreseed 点击 \u0026ldquo;Save changes and reseed now\u0026rdquo; 在 http://127.0.0.1:7657/logs 监控是否出现 \u0026ldquo;Reseed got XX router infos\u0026rdquo; 等待 5-10 分钟进行处理 检查 http://127.0.0.1:7657 - Known peers（已知对等节点）应增加到 50+ 配置 reseed（初始引导）代理 用于受限网络:\nhttp://127.0.0.1:7657/configreseed → 代理配置：\nHTTP 代理: [proxy-server]:[port] 或 SOCKS5: [socks-server]:[port] 启用 \u0026ldquo;Use proxy for reseed only\u0026rdquo;（仅在 reseed（重新引导）时使用代理） 如有需要，提供凭据 保存并强制进行 reseed 替代方案：用于 reseed（I2P 网络数据库的引导/重新播种）的 Tor 代理：\n如果 Tor Browser 或 Tor 守护进程正在运行：\n代理类型：SOCKS5 主机：127.0.0.1 端口：9050（默认 Tor SOCKS 端口） 启用并进行 reseed（重新引导） 通过 su3 文件手动 reseed（重新播种） (最后手段):\n当所有自动 reseed（重新播种）均失败时，通过带外方式获取 reseed 文件：\n在不受限制的连接上从可信来源下载 i2pseeds.su3 (https://reseed.i2p.rocks/i2pseeds.su3 , https://reseed-fr.i2pd.xyz/i2pseeds.su3 ) 完全停止 I2P 将 i2pseeds.su3 复制到 ~/.i2p/ 目录 启动 I2P - 会自动解压并处理该文件 处理完成后删除 i2pseeds.su3 在 http://127.0.0.1:7657 验证节点数量是否增加 在 reseed（引导种子获取）期间的 SSL 证书错误：\nError: \u0026#34;Reseed: Certificate verification failed\u0026#34; Cause: System root certificates outdated or missing 解决方案：\n# Linux - update certificates sudo apt install ca-certificates sudo update-ca-certificates # Windows - install KB updates for root certificate trust # Or install .NET Framework (includes certificate updates) # macOS - update system # Software Update includes certificate trust updates 超过 30 分钟仍然为 0 个已知节点：\n表示 reseed（为 netDb 获取初始 RouterInfo 的过程）完全失败。故障排查顺序：\n确认系统时间准确（最常见的问题 - 请先修复） 测试 HTTPS 连通性： 在浏览器中尝试访问 https://reseed.i2p.rocks - 如果失败，则为网络问题 检查 I2P 日志 在 http://127.0.0.1:7657/logs 查看特定的 reseed（引导）错误 尝试不同的 reseed URL： http://127.0.0.1:7657/configreseed → 添加自定义 reseed URL: https://reseed-fr.i2pd.xyz/ 使用手动 su3 文件方法 若自动化尝试已用尽 Reseed servers（用于初始引导的服务器）偶尔离线： I2P 内置多个硬编码的 reseed servers。如果其中一个不可用，router 会自动尝试其他的。所有 reseed servers 全部失效的情况极为罕见，但并非不可能。\n当前活跃的 reseed（引导）服务器 (截至2025年10月):\nhttps://reseed.i2p.rocks/ https://reseed-fr.i2pd.xyz/ https://i2p.novg.net/ https://i2p-projekt.de/ 如果默认配置存在问题，请添加为自定义 URL。\n对于身处网络审查严厉地区的用户:\n可以考虑通过 Tor 使用 Snowflake/Meek 桥进行初始 reseed（引导），随后在完成接入后切换为直接连接 I2P。或者从审查区域之外，通过隐写术、电子邮件或 U 盘获取 i2pseeds.su3。\n何时寻求进一步的帮助 本指南涵盖了绝大多数 I2P 问题，但某些问题需要开发者的关注或社区的专业知识。\n在以下情况下，请向 I2P 社区寻求帮助：\n按所有故障排除步骤操作后，Router 仍持续崩溃 内存泄漏导致内存占用持续增长，超出已分配的堆大小 尽管配置得当，tunnel 成功率仍低于 20% 日志中出现本指南未涵盖的新错误 发现安全漏洞 功能请求或增强建议 在请求帮助之前，请先收集诊断信息：\nI2P 版本: http://127.0.0.1:7657 (例如, \u0026ldquo;2.10.0\u0026rdquo;) Java 版本: java -version 输出 操作系统和版本 router 状态: 网络状态, 活跃对等节点数量, 参与的 tunnels 带宽配置: 入站/出站限制 端口转发状态: 被防火墙阻挡或 OK 相关日志摘录: 来自 http://127.0.0.1:7657/logs 的显示错误的最后 50 行 官方支持渠道:\n论坛: https://i2pforum.net (明网) 或 http://i2pforum.i 2p (I2P 网络内) IRC: #i2p 在 Irc2P 上 (irc.postman.i2p 经由 I2P) 或 irc.freenode.net (明网) Reddit: https://reddit.com/r/i2p 用于社区讨论 缺陷跟踪器: https://i2pgit.org/i2p-hackers/i2p.i2p/-/issues 用于已确认的缺陷 邮件列表: i2p-dev@lists.i2p-projekt.de 用于开发相关问题 合理预期很重要。 由于其基础设计，I2P 比明网更慢——多跳加密的 tunnel 会带来固有时延。一个 I2P router 在页面加载需 30 秒、BT 速度只有 50 KB/秒的情况下，依然是正常工作的，并非故障。无论如何进行配置优化，期待明网速度的用户都会失望。\n结论 大多数 I2P 问题源于三类情况：在引导阶段（bootstrap）缺乏耐心（需要 10–15 分钟）、资源分配不足（至少 512 MB 内存和 256 KB/秒带宽）、或端口转发配置错误。理解 I2P 的分布式架构和以匿名性为核心的设计，有助于用户区分预期行为与真正的问题。\nrouter 的 \u0026ldquo;Firewalled\u0026rdquo; 状态虽然并不理想，但并不会阻止 I2P 的使用 - 只是会限制对网络的贡献，并使性能略有下降。新用户应当优先考虑稳定性而非优化：在调整高级设置之前，先让 router 连续运行数天，因为随着在线时长的增加，与网络的整合会自然改善。\n排障时，务必先核查基础项：系统时间是否正确、带宽是否充足、router 是否持续运行，以及是否有 10 个以上的活跃对等节点。多数问题通过解决这些基础项即可排除，而不必去调整晦涩的配置参数。I2P 会随着持续运行而回报耐心：在数天乃至数周的在线时间里，router 会逐步累积声誉并优化对等节点选择，从而带来更好的性能。\n","description":"面向常见 I2P router 问题（包括连接性、性能和配置方面）的全面故障排除指南","id":"2ff67fee0173608876ccc012bf3ff6ce","section":"docs","title":"I2P Router 故障排除指南","url":"/zh/docs/troubleshooting/"},{"categories":null,"content":"当网络条件导致 git clone 不可靠时，你可以通过 BitTorrent 或任何其他文件传输方式将仓库作为 git bundles 分发。bundle 是一个包含完整仓库历史的单一文件。下载完成后，你可以从本地获取它，然后切换回上游远程仓库。\n1. 开始之前 生成 bundle 需要完整的 Git 克隆。使用 --depth 1 创建的浅克隆会静默生成看似正常但实际损坏的 bundle,当其他人尝试使用时会失败。始终从可信来源(GitHub 的 github.com/i2p/i2p.i2p 、I2P Gitea 实例 i2pgit.org ,或通过 I2P 访问 git.idk.i2p)获取代码,并在创建 bundle 之前运行 git fetch --unshallow 将任何浅克隆转换为完整克隆(如有必要)。\n如果您只是使用现有的捆绑包,只需下载即可。无需特殊准备。\n2. 下载安装包 Obtaining the Bundle File 使用 I2PSnark(I2P 内置的种子客户端)或其他兼容 I2P 的客户端(如安装了 I2P 插件的 BiglyBT)通过 BitTorrent 下载捆绑包文件。\n重要:I2PSnark 仅适用于专为 I2P 网络创建的种子文件。标准明网种子文件不兼容,因为 I2P 使用 Destination(387+ 字节地址)而非 IP 地址和端口。\nbundle 文件的位置取决于你的 I2P 安装类型:\n用户/手动安装（使用 Java 安装程序安装）：~/.i2p/i2psnark/ 系统/守护进程安装（通过 apt-get 或包管理器安装）：/var/lib/i2p/i2p-config/i2psnark/ BiglyBT 用户可以在配置的下载目录中找到已下载的文件。\nCloning from the Bundle 标准方法(适用于大多数情况):\ngit clone ~/.i2p/i2psnark/i2p.i2p.bundle 如果遇到 fatal: multiple updates for ref 错误(这是 Git 2.21.0 及更高版本中的已知问题,当全局 Git 配置包含冲突的 fetch refspec 时会出现),请使用手动初始化方法:\nmkdir i2p.i2p \u0026amp;\u0026amp; cd i2p.i2p git init git fetch ~/.i2p/i2psnark/i2p.i2p.bundle 或者,您可以使用 --update-head-ok 标志:\ngit fetch --update-head-ok ~/.i2p/i2psnark/i2p.i2p.bundle \u0026#39;*:*\u0026#39; 获取 Bundle 文件 从 bundle 克隆后,将你的克隆指向实时远程仓库,以便将来的拉取操作通过 I2P 或明网进行:\ngit remote set-url origin git@127.0.0.1:I2P_Developers/i2p.i2p 或者用于访问明网：\ngit remote set-url origin https://github.com/i2p/i2p.i2p 要访问 I2P SSH，你需要在 I2P 路由器控制台中配置一个 SSH 客户端 tunnel（通常是端口 7670），指向 g6u4vqiuy6bdc3dbu6a7gmi3ip45sqwgtbgrr6uupqaaqfyztrka.b32.i2p。如果使用非标准端口：\nGIT_SSH_COMMAND=\u0026#34;ssh -p 7670\u0026#34; git clone git@127.0.0.1:I2P_Developers/i2p.i2p 3. Creating a Bundle 从捆绑包克隆 确保您的仓库完全是最新的，使用完整克隆（不是浅克隆）：\ngit fetch --all 如果你有一个浅克隆(shallow clone),请先转换它:\ngit fetch --unshallow 切换到实时远程环境 使用 Ant 构建目标（推荐用于 I2P 源代码树）：\nant git-bundle 这将创建 i2p.i2p.bundle(bundle 文件)和 i2p.i2p.bundle.torrent(BitTorrent 元数据)。\n直接使用 git bundle:\ngit bundle create i2p.i2p.bundle --all 对于更有选择性的捆绑包:\ngit bundle create i2p.i2p.bundle --branches --tags Verifying Your Bundle 在分发之前务必验证 bundle:\ngit bundle verify i2p.i2p.bundle 这确认了 bundle 是有效的,并显示任何所需的前提 commit。\n前置要求 将 bundle 及其 torrent 元数据复制到你的 I2PSnark 目录中:\n对于用户安装:\ncp i2p.i2p.bundle* ~/.i2p/i2psnark/ 对于系统安装:\ncp i2p.i2p.bundle* /var/lib/i2p/i2p-config/i2psnark/ I2PSnark 会在几秒钟内自动检测并加载 .torrent 文件。访问 Web 界面 http://127.0.0.1:7657/i2psnark 即可开始做种。\n4. Creating Incremental Bundles 对于定期更新,创建增量包,仅包含自上次打包以来的新提交:\ngit tag lastBundleTag git bundle create update.bundle lastBundleTag..master 如果用户已经有基础仓库，可以从增量包中获取：\ngit fetch /path/to/update.bundle 始终验证增量包显示预期的前置提交:\ngit bundle verify update.bundle 5. Updating After the Initial Clone 当你从 bundle 获得一个可用的仓库后,就可以像对待其他 Git 克隆一样使用它:\ngit remote add upstream git@127.0.0.1:I2P_Developers/i2p.i2p git fetch upstream git merge upstream/master 或者对于更简单的工作流程:\ngit fetch origin git pull origin master 3. 创建 Bundle 弹性分发:大型仓库可以通过 BitTorrent 共享,它能自动处理重试、分片验证和断点续传。 点对点引导:新贡献者可以从 I2P 网络上的邻近节点引导克隆其仓库,然后直接从 Git 主机获取增量更改。 降低服务器负载:镜像可以发布定期打包文件来减轻实时 Git 主机的压力,这对大型仓库或慢速网络环境特别有用。 离线传输:打包文件可在任何文件传输方式上使用(USB 驱动器、直接传输、人肉网络),不仅限于 BitTorrent。 Bundles 不会取代实时远程仓库。它们只是为初始克隆或重大更新提供了一种更具弹性的引导方法。\n7. Troubleshooting 生成 Bundle 问题：Bundle 创建成功，但其他人无法从 bundle 克隆。\n原因:你的源代码克隆是浅克隆(使用 --depth 创建)。\n解决方案:在创建 bundle 之前转换为完全克隆:\ngit fetch --unshallow 验证您的软件包 问题：从 bundle 克隆时出现 fatal: multiple updates for ref 错误。\n原因:Git 2.21.0+ 与 ~/.gitconfig 中的全局 fetch refspecs 存在冲突。\n解决方案：1. 使用手动初始化：mkdir repo \u0026amp;\u0026amp; cd repo \u0026amp;\u0026amp; git init \u0026amp;\u0026amp; git fetch /path/to/bundle 2. 使用 --update-head-ok 标志：git fetch --update-head-ok /path/to/bundle '*:*' 3. 删除冲突的配置：git config --global --unset remote.origin.fetch\n通过 I2PSnark 分发 问题：git bundle verify 报告缺少前置条件。\n原因:增量包或不完整的源代码克隆。\n解决方案:要么获取前置提交(prerequisite commits),要么先使用基础包(base bundle),然后应用增量更新。\n","description":"使用 git bundle 和 BitTorrent 获取和分发大型代码仓库","id":"555586cb7b43c73ad912bbb01f20326b","section":"docs","title":"I2P 的 Git Bundle","url":"/zh/docs/applications/git-bundle/"},{"categories":null,"content":"什么是 I2P？ The Invisible Internet Project (I2P) 是一个匿名网络层,支持抗审查的点对点通信。通过加密用户流量并将其通过由全球志愿者运行的分布式网络发送,实现匿名连接。\n主要特性 Anonymity I2P 隐藏了消息的发送方和接收方。与传统互联网连接中您的 IP 地址对网站和服务可见不同,I2P 使用多层加密和路由来保护您的身份隐私。\nDecentralization I2P 中没有中央权威机构。网络由志愿者维护,他们贡献带宽和计算资源。这使得它能够抵御审查和单点故障。\n匿名性 I2P 内的所有流量都经过端到端加密。消息在网络中传输时会被多次加密,这与 Tor 的工作方式类似,但在实现上存在重要差异。\nHow It Works 去中心化 I2P 使用\u0026quot;隧道\u0026quot;(tunnel)来路由流量。当你发送或接收数据时:\n你的路由器创建一个出站隧道(用于发送) 你的路由器创建一个入站隧道(用于接收) 消息经过加密并通过多个 router 发送 每个 router 只知道前一跳和下一跳,不知道完整路径 端到端加密 I2P 通过\u0026quot;garlic encryption\u0026quot;改进了传统的洋葱路由:\n多个消息可以捆绑在一起(就像一头大蒜中的蒜瓣) 这提供了更好的性能和额外的匿名性 使流量分析更加困难 Network Database I2P 维护一个分布式网络数据库，包含：\n路由器信息 目标地址(类似于 .i2p 网站) 加密的路由数据 Common Use Cases 隧道 访问或托管以 .i2p 结尾的网站 - 这些网站只能在 I2P 网络内访问,为主机和访问者提供强大的匿名性保障。\nGarlic Routing 通过 I2P 使用 BitTorrent 匿名分享文件。许多种子应用程序内置了 I2P 支持。\n网络数据库 使用 I2P-Bote 或其他为 I2P 设计的电子邮件应用程序发送和接收匿名电子邮件。\nMessaging 通过 I2P 网络私密地使用 IRC、即时通讯或其他通信工具。\nGetting Started 准备尝试 I2P 了吗?查看我们的下载页面 以在您的系统上安装 I2P。\n如需了解更多技术细节，请参阅技术介绍 或浏览完整的文档 。\n工作原理 技术介绍 - 深入了解技术概念 威胁模型 - 理解 I2P 的安全模型 与 Tor 的比较 - I2P 与 Tor 的区别 密码学 - I2P 加密算法详解 ","description":"I2P匿名网络的非技术性介绍","id":"b4dafae75d4a04b2eac73ebf531f1d1b","section":"docs","title":"I2P 简介","url":"/zh/docs/overview/intro/"},{"categories":null,"content":"概览 I2CP 是 I2P router 与任意客户端进程之间的低层控制协议。它对职责进行了严格的分离：\nRouter: 管理路由、加密、tunnel 生命周期，以及网络数据库操作 客户端: 选择匿名性属性，配置 tunnels，并提交/接收消息 所有通信都通过单个 TCP 套接字（可选的 TLS 封装）进行，从而实现异步、全双工操作。\n协议版本: I2CP（I2P 客户端协议）在建立初始连接时会发送一个协议版本字节 0x2A (十进制 42)。自该协议诞生以来，这个版本字节一直保持不变。\n当前状态: 本规范适用于 router 版本 0.9.67（API 版本 0.9.67），发布于 2025-09。\n实现背景 Java 实现 参考实现位于 Java I2P: - 客户端 SDK: i2p.jar 包 - Router 实现: router.jar 包 - Javadocs 当客户端与 router 运行在同一 Java 虚拟机（JVM）时，I2CP 消息以 Java 对象的形式传递，无需序列化。外部客户端通过 TCP 使用序列化协议。\nC++ 实现 i2pd（用 C++ 编写的 I2P router）也对外实现了 I2CP，供客户端连接使用。\n非 Java 客户端 针对完整的 I2CP（I2P 客户端协议）客户端库，没有已知的非 Java 实现。非 Java 应用程序应改用更高级别的协议：\nSAM (Simple Anonymous Messaging) v3: 基于套接字的接口，提供多种语言的库 BOB (Basic Open Bridge): 比 SAM 更简单的替代方案 这些更高层的协议在内部处理 I2CP 的复杂性，并且还提供流式库（用于类似 TCP 的连接）和数据报库（用于类似 UDP 的连接）。\n连接建立 1. TCP 连接 连接到 router 的 I2CP 端口： - 默认：127.0.0.1:7654 - 可通过 router 设置进行配置 - 可选的 TLS 封装层（强烈建议用于远程连接）\n2. 协议握手 步骤 1: 发送协议版本字节 0x2A\n步骤 2: 时钟同步\nClient → Router: GetDateMessage Router → Client: SetDateMessage router 返回其当前时间戳和 I2CP API 版本字符串（自 0.8.7 起）。\n步骤 3: 身份验证（如果已启用）\n自 0.9.11 起，可以通过包含以下内容的 Mapping（映射表）在 GetDateMessage（获取日期消息）中包含身份验证信息： - i2cp.username - i2cp.password\n自 0.9.16 起，启用身份验证时，必须在发送任何其他消息之前通过 GetDateMessage 完成。\n步骤 4：会话创建\nClient → Router: CreateSessionMessage (contains SessionConfig) Router → Client: SessionStatusMessage (status=Created) 第 5 步: Tunnel 就绪信号\nRouter → Client: RequestVariableLeaseSetMessage 此消息表示入站 tunnel 已建立。在至少存在一个入站 tunnel 和一个出站 tunnel 之前，router 不会发送此消息。\n步骤 6: LeaseSet 发布\nClient → Router: CreateLeaseSet2Message 此时，会话已完全就绪，可以发送和接收消息。\n消息流模式 出站消息（客户端发送到远程目标） 使用 i2cp.messageReliability=none:\nClient → Router: SendMessageMessage (nonce=0) [No acknowledgments] 当 i2cp.messageReliability=BestEffort 时:\nClient → Router: SendMessageMessage (nonce\u0026gt;0) Router → Client: MessageStatusMessage (status=Accepted) Router → Client: MessageStatusMessage (status=Success or Failure) 入站消息（由 Router 递送给客户端） 使用 i2cp.fastReceive=true (自 0.9.4 起为默认值):\nRouter → Client: MessagePayloadMessage [No acknowledgment required] 在 i2cp.fastReceive=false 时 (已弃用):\nRouter → Client: MessageStatusMessage (status=Available) Client → Router: ReceiveMessageBeginMessage Router → Client: MessagePayloadMessage Client → Router: ReceiveMessageEndMessage 现代客户端应始终使用快速接收模式。\n常见数据结构 I2CP 消息头 所有 I2CP 消息都使用这个通用头部：\n+----+----+----+----+----+----+----+----+ | Body Length (4 bytes) | +----+----+----+----+----+----+----+----+ |Type| Message Body (variable) | +----+----+----+----+----+----+----+----+ 消息体长度: 4 字节整数，仅为消息体长度（不包括头部） 类型: 1 字节整数，消息类型标识符 消息体: 0+ 字节，格式因消息类型而异 消息大小上限: 约为 64 KB。\n会话 ID 用于在某个 router 上唯一标识会话的 2 字节整数。\n特殊值: 0xFFFF 表示 \u0026ldquo;无会话\u0026rdquo;（用于在未建立会话的情况下进行主机名解析）。\n消息 ID 由 router 生成的 4 字节整数，用于在会话内唯一标识一条消息。\n重要: 消息 ID 在全局范围内并不是唯一的，只在单个会话内是唯一的。它们也不同于客户端生成的 nonce（一次性随机数）。\n有效载荷格式 消息有效载荷使用标准 10 字节的 gzip 头部进行 gzip 压缩: - 以以下内容开头: 0x1F 0x8B 0x08 (RFC 1952) - 自 0.7.1 起: gzip 头部中未使用的部分包含协议、源端口和目标端口信息 - 这使得可以在同一目的地上使用流式传输和数据报\n压缩控制: 设置 i2cp.gzip=false 以禁用压缩 (将 gzip 压缩级别设为 0)。仍会包含 gzip 头部，但压缩开销极小。\nSessionConfig 结构 为客户端会话定义配置：\n+----------------------------------+ | Destination | +----------------------------------+ | Mapping (configuration options) | +----------------------------------+ | Creation Date | +----------------------------------+ | Signature | +----------------------------------+ 关键要求: 1. 映射必须按键排序，用于签名验证 2. 创建日期必须在 router 的当前时间±30秒内 3. 签名由 Destination（I2P 中的通信终端标识）的 SigningPrivateKey 创建\n离线签名 (自 0.9.38 起):\n如果使用离线签名，该映射必须包含: - i2cp.leaseSetOfflineExpiration - i2cp.leaseSetTransientPublicKey - i2cp.leaseSetOfflineSignature\n随后，该签名由临时的 SigningPrivateKey（签名私钥）生成。\n核心配置选项 Tunnel 配置 Option Default Description inbound.length 3 Number of hops for inbound tunnels outbound.length 3 Number of hops for outbound tunnels inbound.lengthVariance 0 Random variance in hop count (since 0.7.6) outbound.lengthVariance 0 Random variance in hop count (since 0.7.6) inbound.quantity 2 Number of concurrent inbound tunnels outbound.quantity 2 Number of concurrent outbound tunnels inbound.backupQuantity 0 Standby inbound tunnels (hot spares) outbound.backupQuantity 0 Standby outbound tunnels (hot spares) inbound.allowZeroHop true Allow 0-hop tunnels (disable for full anonymity) outbound.allowZeroHop true Allow 0-hop tunnels (disable for full anonymity) **注意**：- 当 `quantity` 的取值 \u003e 6 时，要求对等节点运行 0.9.0+，并会显著增加资源占用 - 对于高可用服务，将 `backupQuantity` 设为 1-2 - 零跳 tunnels 会牺牲匿名性以换取更低延迟，但对测试很有用 消息处理 Option Default Description clientMessageTimeout 60000\u0026nbsp;ms Legacy timeout for message delivery i2cp.messageReliability BestEffort None, BestEffort, or Guaranteed i2cp.fastReceive true Skip ReceiveMessageBegin/End handshake (default since 0.9.4) i2cp.gzip true Enable gzip compression of message payloads outbound.priority 0 Priority for outbound scheduling (-25 to +25) **消息可靠性**: - `None`: 无 router 确认（自 0.8.1 起为流式传输库的默认值） - `BestEffort`: Router 发送接受 + 成功/失败 的通知 - `Guaranteed`: 未实现（当前行为与 BestEffort 相同） 逐消息覆盖 (自 0.9.14 起): - 在 messageReliability=none 的会话中，将 nonce（随机数）设为非零会请求该特定消息的送达通知 - 在 BestEffort 会话中将 nonce=0 会禁用该消息的通知\nLeaseSet（租约集合）配置 Option Default Description i2cp.dontPublishLeaseSet false Disable automatic LeaseSet publication (for client-only destinations) i2cp.leaseSetType 1 LeaseSet variant: 1 = standard, 3 = LS2, 5 = encrypted, 7 = meta i2cp.leaseSetEncType 0 Comma-separated encryption type codes (see below) ### 遗留的 ElGamal/AES 会话标签 这些选项仅适用于遗留的 ElGamal 加密：\nOption Default Description crypto.lowTagThreshold 30 Minimum session tags before replenishing crypto.tagsToSend 40 Number of tags to send in a batch **注意**: ECIES-X25519 客户端使用不同的棘轮机制，并忽略这些选项。 加密类型 I2CP 通过 i2cp.leaseSetEncType 选项支持多种端到端加密方案。可以指定多种类型（用逗号分隔），以同时支持现代和旧版对等节点。\n支持的加密类型 Type Algorithm Key Size Since Status 0 ElGamal/AES+SessionTags 2048-bit ElGamal Original Legacy 1-3 Reserved - - Unused 4 ECIES-X25519-AEAD-Ratchet 32-byte X25519 0.9.46 Current Standard 5 ECIES-X25519-AEAD-Ratchet + ML-KEM-768 hybrid 32\u0026nbsp;+\u0026nbsp;PQ 0.9.67 Beta 6 ECIES-X25519-AEAD-Ratchet + ML-KEM-1024 hybrid 32\u0026nbsp;+\u0026nbsp;PQ 0.9.67 Beta 7 Reserved (likely ML-KEM-512 hybrid) 32\u0026nbsp;+\u0026nbsp;PQ Future Planned **推荐配置**: i2cp.leaseSetEncType=4,0 该方案支持 X25519（首选），并提供用于兼容性的 ElGamal 回退。\n加密类型详细信息 类型 0 - ElGamal/AES+SessionTags: - 2048 位 ElGamal 公钥 (256 字节) - AES-256 对称加密 - 32 字节的会话标签分批发送 - 较高的 CPU、带宽和内存开销 - 正在全网逐步淘汰\n类型 4 - ECIES-X25519-AEAD-Ratchet: - X25519 密钥交换（32 字节密钥） - ChaCha20/Poly1305 AEAD - 类似 Signal 的双棘轮 - 8 字节会话标签（相比 ElGamal 的 32 字节） - 通过同步的 PRNG（伪随机数生成器）生成标签（不提前发送） - 较 ElGamal 降低约 92% 的开销 - 现代 I2P 的标准（大多数 routers 使用它）\n类型 5-6 - 后量子混合: - 将 X25519 与 ML-KEM (NIST FIPS 203)（密钥封装机制）结合 - 提供抗量子安全性 - ML-KEM-768 用于在安全性/性能之间取得平衡 - ML-KEM-1024 用于获得最高安全性 - 由于 PQ（后量子）密钥材料，消息大小更大 - 网络支持仍在部署中\n迁移策略 I2P 网络正在积极从 ElGamal (类型 0) 迁移到 X25519 (类型 4): - NTCP → NTCP2 (已完成) - SSU → SSU2 (已完成) - ElGamal tunnels → X25519 tunnels (已完成) - ElGamal 端到端 → ECIES-X25519 (大部分已完成)\nLeaseSet2 与高级特性 LeaseSet2 选项 (自 0.9.38 起) Option Since Purpose i2cp.leaseSetType 0.9.38 Specifies LeaseSet variant (1, 3, 5, 7) i2cp.leaseSetEncType 0.9.38 Encryption types supported (comma-separated) i2cp.leaseSetAuthType 0.9.41 Per-client authentication: 0 = none, 1 = DH, 2 = PSK i2cp.leaseSetPrivKey 0.9.41 X25519 private key for decrypting LS2 with auth i2cp.leaseSetSecret 0.9.39 Base64 secret for blinded addresses i2cp.leaseSetTransientPublicKey 0.9.38 Transient signing key for offline signatures i2cp.leaseSetPrivateKey 0.9.18 Persistent LeaseSet encryption keys (type:key pairs) i2cp.leaseSetOption.nnn 0.9.66 Service records (proposal 167) i2cp.leaseSetClient.dh.nnn 0.9.41 DH client auth material (indexed from 0) i2cp.leaseSetClient.psk.nnn 0.9.41 PSK client auth material (indexed from 0) ### 盲化地址 自 0.9.39 起，目标地址可以使用“blinded（盲化）”地址（b33 format），会定期更换： - 需要 i2cp.leaseSetSecret 用于密码保护 - 可选的按客户端身份验证 - 详情参见提案 123 和 149\n服务记录（自 0.9.66 起） LeaseSet2 支持服务记录选项 (提案 167):\ni2cp.leaseSetOption.0=_smtp._tcp=1 86400 0 0 25 mail.example.b32.i2p 格式遵循 DNS 的 SRV 记录样式，但已针对 I2P 进行适配。\n多会话（自 0.9.21 起） 单个 I2CP 连接可以维护多个会话：\n主会话: 在一个连接上创建的第一个会话 子会话: 共享主会话的 tunnel 池的其他会话\nSubsession（子会话）特性 共享 tunnels: 使用与主会话相同的入站/出站 tunnel 池 共享加密密钥: 必须使用相同的 LeaseSet 加密密钥 不同的签名密钥: 必须使用不同的 Destination 签名密钥（Destination：I2P 目标标识） 不保证匿名性: 与主会话有明确关联（相同的 router、相同的 tunnels） Subsession（子会话）用例 启用与使用不同签名类型的 Destination（目标标识）进行通信： - 主：EdDSA 签名（现代） - 子会话：DSA 签名（旧版兼容）\n子会话生命周期 创建:\nClient → Router: CreateSessionMessage Router → Client: SessionStatusMessage (unique Session ID) Router → Client: RequestVariableLeaseSetMessage (separate for each destination) Client → Router: CreateLeaseSet2Message (separate for each destination) 销毁: - 销毁一个子会话：主会话保持不变 - 销毁主会话：会销毁所有子会话并关闭连接 - DisconnectMessage（断开连接消息）：会销毁所有会话\n会话 ID 处理 大多数 I2CP 消息都包含一个 Session ID 字段。例外：- DestLookup / DestReply (已弃用，请使用 HostLookup / HostReply) - GetBandwidthLimits / BandwidthLimits (响应不特定于会话)\n重要: 客户端不应同时保持多个处于未决状态的 CreateSession 消息，因为无法将响应与请求进行确定的关联。\n消息目录 消息类型概述 Type Name Direction Since Status 1 CreateSession C → R Original Current 2 ReconfigureSession C → R 0.7.1 Current 3 DestroySession C → R Original Current 4 CreateLeaseSet C → R Original Deprecated 5 SendMessage C → R Original Current 6 ReceiveMessageBegin C → R Original Deprecated 7 ReceiveMessageEnd C → R Original Deprecated 8 GetBandwidthLimits C → R 0.7.2 Current 20 SessionStatus R → C Original Current 21 RequestLeaseSet R → C Original Deprecated 22 MessageStatus R → C Original Current 23 BandwidthLimits R → C 0.7.2 Current 29 ReportAbuse Bidirectional Original Unused 30 Disconnect Bidirectional Original Current 31 MessagePayload R → C Original Current 32 GetDate C → R Original Current 33 SetDate R → C Original Current 34 DestLookup C → R 0.7 Deprecated 35 DestReply R → C 0.7 Deprecated 36 SendMessageExpires C → R 0.7.1 Current 37 RequestVariableLeaseSet R → C 0.9.7 Current 38 HostLookup C → R 0.9.11 Current 39 HostReply R → C 0.9.11 Current 41 CreateLeaseSet2 C → R 0.9.39 Current 42 BlindingInfo C → R 0.9.43 Current **图例**: C = 客户端, R = Router 关键消息详情 CreateSessionMessage（类型 1） 目的: 启动一个新的 I2CP 会话\n内容: SessionConfig（会话配置）结构\n响应: SessionStatusMessage（会话状态消息） (status=Created or Invalid)\n要求: - SessionConfig（会话配置）中的日期必须在 router 时间的 ±30 秒内 - 为进行签名验证，映射必须按键排序 - Destination（目标标识符）不得已存在活动会话\nRequestVariableLeaseSetMessage (类型 37) 目的: Router 请求客户端对入站 tunnels 的授权\n内容: - 会话 ID - Lease（租约）数量 - Lease 结构的数组（每个都有各自的到期时间）\n响应: CreateLeaseSet2Message（创建leaseSet2的消息）\n意义: 这是表明会话已正常运行的信号。router 仅在以下条件满足后才会发送： 1. 至少建立了一个入站 tunnel 2. 至少建立了一个出站 tunnel\n超时建议：如果在会话创建后超过 5 分钟仍未收到该消息，客户端应销毁该会话。\nCreateLeaseSet2Message (类型 41) 目的: 客户端将 LeaseSet 发布到 netDb（网络数据库）\n内容: - 会话 ID - LeaseSet 类型字节 (1, 3, 5, 或 7) - LeaseSet 或 LeaseSet2 或 EncryptedLeaseSet 或 MetaLeaseSet - 私钥数量 - 私钥列表 (与 LeaseSet 中的每个公钥一一对应，顺序相同)\n私钥: 用于解密传入的 garlic 消息（I2P 的一种加密消息）。格式:\nEncryption type (2 bytes) Key length (2 bytes) Private key data (variable) 注意: 取代已弃用的 CreateLeaseSetMessage (类型 4)，后者无法处理: - LeaseSet2 变体 - 非 ElGamal 加密 - 多种加密类型 - 加密的 LeaseSets - 离线签名密钥\nSendMessageExpiresMessage (类型 36) Purpose: 向目标地址发送带有过期时间和高级选项的消息\n内容: - 会话 ID - Destination（目标地址） - 有效载荷（已 gzip 压缩） - Nonce（一次性随机数，4 字节） - 标志位（2 字节）- 见下文 - 到期时间（6 字节，从 8 字节截断）\n标志字段 (2 字节，位序 15\u0026hellip;0):\n比特 15-11: 未使用，必须为 0\n位 10-9: 消息可靠性覆盖（未使用，请改用 nonce（一次性随机数））\n第 8 位: 不要捆绑 LeaseSet - 0: Router 可以在 garlic（蒜瓣消息）中捆绑 LeaseSet - 1: 不要捆绑 LeaseSet\n位 7-4：低标签阈值（仅适用于 ElGamal，ECIES 忽略）\n0000 = Use session settings 0001 = 2 tags 0010 = 3 tags ... 1111 = 192 tags 位 3-0: 若需要时要发送的标签数（仅用于 ElGamal（ElGamal 加密方案），在 ECIES（椭圆曲线集成加密方案）中忽略）\n0000 = Use session settings 0001 = 2 tags 0010 = 4 tags ... 1111 = 160 tags MessageStatusMessage（消息状态报文） (类型 22) 目的：通知客户端消息投递状态\n内容: - 会话 ID - 消息 ID（由 router 生成） - 状态码（1 字节） - 大小（4 字节，仅在状态=0时相关） - Nonce（随机数）（4 字节，与客户端的 SendMessage nonce 匹配）\n状态代码 (出站消息):\nCode Name Meaning Result 1 Accepted Router accepted message Success 2 Best Effort Success Probable delivery Success 4 Guaranteed Success Probable delivery Success 6 Local Success Delivered to local client Success 3 Best Effort Failure Probable failure Failure 5 Guaranteed Failure Generic failure Failure 7 Local Failure Local delivery failed Failure 8 Router Failure Router shutdown/error Failure 9 Network Failure No network connectivity Failure 10 Bad Session Invalid/closed session Failure 11 Bad Message Invalid payload Failure 12 Bad Options Invalid options/expiration Failure 13 Overflow Failure Queue/buffer full Failure 14 Message Expired Expired before send Failure 15 Bad Local LeaseSet Local LeaseSet problem Failure 16 No Local Tunnels No tunnels available Failure 17 Unsupported Encryption Incompatible encryption Failure 18 Bad Destination Invalid remote destination Failure 19 Bad Leaseset Invalid remote LeaseSet Failure 20 Expired Leaseset Remote LeaseSet expired Failure 21 No Leaseset Remote LeaseSet not found Failure 22 Meta Leaseset Cannot send to meta LS Failure 23 Loopback Denied Same source and destination Failure **成功代码**: 1, 2, 4, 6 **失败代码**: 其余所有代码 状态码 0 (已弃用): 有可用消息 (入站, 已禁用快速接收)\nHostLookupMessage（主机查找消息，类型 38） 目的：根据主机名或哈希查找 Destination（目标标识）（替代 DestLookup）\n内容: - 会话ID（无会话则为 0xFFFF） - 请求ID（4 字节） - 超时时间（毫秒）（4 字节，推荐最小值：10000） - 请求类型（1 字节） - 查找键（哈希、主机名字符串，或 Destination（I2P 的目的地标识））\n请求类型:\nType Lookup Key Returns Since 0 Hash Destination Original 1 Hostname String Destination Original 2 Hash Destination + Options 0.9.66 3 Hostname String Destination + Options 0.9.66 4 Destination Destination + Options 0.9.66 类型 2-4 在可用时返回 LeaseSet 选项（提案 167）。 响应: HostReplyMessage\nHostReplyMessage (类型 39) 目的: 对 HostLookupMessage（主机查找消息）的响应\n内容: - 会话 ID - 请求 ID - 结果代码（1 字节） - Destination（目标）（成功时存在，在某些特定失败时也可能存在） - 映射（仅适用于查找类型 2-4，可能为空）\n结果代码:\nCode Name Meaning 0 Success Lookup succeeded 1 Failure Generic failure 2 Lookup Password Required Blinded address requires password 3 Private Key Required Blinded address requires private key 4 Password and Key Required Blinded address requires both 5 LeaseSet Decryption Failure Cannot decrypt LeaseSet 6 LeaseSet Lookup Failure LeaseSet not found in netdb 7 Lookup Type Unsupported Router doesn't support this type #### BlindingInfoMessage（盲化信息报文） (类型 42) 目的: 通知 router 关于 blinded destination（盲化目标）的认证要求（自 0.9.43 起）\n内容: - 会话 ID - 标志（1 字节） - 端点类型（1 字节）：0=Hash, 1=hostname, 2=Destination, 3=SigType+Key - 盲签名类型（2 字节） - 过期时间（4 字节，自 Unix 纪元以来的秒数） - 端点数据（随类型不同而变化） - 私钥（32 字节，仅当标志位 0 被设置时） - 查找密码（字符串，仅当标志位 4 被设置时）\n标志（位序 76543210）:\n位 0: 0=所有人，1=按客户端 位 3-1: 认证机制（当位 0=1 时）：000=DH（Diffie-Hellman 密钥交换），001=PSK（预共享密钥） 位 4: 1=需要密钥 位 7-5: 未使用，置为 0 无响应: Router 静默处理\n用例：在向盲化目的地（b33 地址）发送之前，客户端必须选择以下之一：1. 通过 HostLookup 查询该 b33，或者 2. 发送 BlindingInfo 消息\n如果目标需要身份验证，则 BlindingInfo（盲化信息）是必需的。\nReconfigureSessionMessage (重新配置会话消息) (类型 2) 用途: 创建后更新会话配置\n内容: - Session ID - SessionConfig (仅需提供已更改的选项)\n响应: SessionStatusMessage (status=Updated 或 Invalid)\n注意: - Router 会将新的配置与现有配置合并 - Tunnel 选项 (inbound.*, outbound.*) 始终会被应用 - 某些选项在会话创建后可能不可变 - 日期必须在 router 时间的 ±30 秒内 - 映射必须按键排序\nDestroySessionMessage（会话销毁消息） (类型 3) 目的: 终止会话\n内容: 会话 ID\n预期响应: SessionStatusMessage (status=Destroyed)\n实际行为 (Java I2P 截至 0.9.66): - Router 从不发送 SessionStatus(Destroyed)（会话状态：已销毁） - 如果没有会话剩余：发送 DisconnectMessage（断开消息） - 如果仍有子会话：无回复\n重要: Java I2P 的行为与规范存在偏离。各实现在销毁单个子会话时应谨慎。\nDisconnectMessage（断开消息） (类型 30) 目的：通知连接即将被终止\n内容: 原因字符串\n效果: 该连接上的所有会话被销毁，套接字关闭\n实现：主要是 Java I2P 中的 router → 客户端\n协议版本历史 版本检测 I2CP 协议版本通过 Get/SetDate 消息进行交换（自 0.8.7 起）。对于较旧的 router，版本信息不可用。\n版本字符串: 表示“core” API 版本，不一定是 router 版本。\n功能时间线 Version Key Features 0.9.67 PQ Hybrid ML-KEM (enc types 5-7) in LeaseSet 0.9.66 Host lookup/reply extensions (proposal 167), service records 0.9.62 MessageStatus loopback error code 0.9.46 X25519 (enc type 4) in LeaseSet, ECIES end-to-end 0.9.43 BlindingInfo message, extended HostReply failure codes 0.9.41 EncryptedLeaseSet options, Meta LS error code 0.9.39 CreateLeaseSet2 message, RedDSA Ed25519 support 0.9.38 Preliminary LS2 support (format changed in 0.9.39) 0.9.21 Multiple sessions on single connection 0.9.20 Additional SetDate messages for clock shifts 0.9.16 Authentication required before other messages (when enabled) 0.9.15 EdDSA Ed25519 signature type 0.9.14 Per-message reliability override with nonzero nonce 0.9.12 ECDSA P-256/384/521 signature types, RSA support 0.9.11 HostLookup/HostReply messages, auth in GetDate 0.9.7 RequestVariableLeaseSet message 0.9.5 Additional MessageStatus codes 0.9.4 Fast receive mode default, nonce=0 allowed 0.9.2 SendMessageExpires flag tag bits 0.9 16 leases per LeaseSet (up from 6) 0.8.7 Version strings in Get/SetDate 0.8.4 SendMessageExpires flag bits 0.8.3 DestLookup in standard session, concurrent lookups 0.8.1 messageReliability=none 0.7.2 GetBandwidthLimits, BandwidthLimits 0.7.1 SendMessageExpires, ReconfigureSession, ports in gzip header 0.7 DestLookup, DestReply 0.6.5- Original protocol features ## 安全注意事项 身份验证 默认: 无需身份验证 可选: 用户名/密码身份验证 (自 0.9.11 起) 必需: 启用后，身份验证必须在其他消息之前完成 (自 0.9.16 起)\n远程连接: 始终使用 TLS (i2cp.SSL=true) 以保护凭据和私钥。\n时钟偏移 SessionConfig Date 必须在 router 时间的 ±30 秒范围内，否则会话将被拒绝。使用 Get/SetDate 进行同步。\n私钥处理 CreateLeaseSet2Message（用于发布 LeaseSet2 的消息）包含用于解密入站消息的私钥。这些密钥必须： - 安全传输（远程连接使用 TLS） - 由 router 安全地存储 - 在被泄露时及时轮换\n消息过期 始终使用 SendMessageExpires (而非 SendMessage) 以设置显式过期时间。这样做可以： - 防止消息被无限期排队 - 降低资源消耗 - 提高可靠性\n会话标签管理 ElGamal (已弃用): - 标签必须成批传输 - 标签丢失会导致解密失败 - 内存开销高\nECIES-X25519 (当前): - 通过同步的 PRNG 生成标签 - 无需预先传输 - 对消息丢失具有容错性 - 开销显著更低\n最佳实践 面向客户端开发者 使用快速接收模式: 始终设置 i2cp.fastReceive=true（或依赖默认值）\n优先使用 ECIES-X25519（基于 X25519 的 ECIES 加密套件）: 配置 i2cp.leaseSetEncType=4,0，以在保证兼容性的同时获得最佳性能\n显式设置过期时间: 使用 SendMessageExpires，而不是 SendMessage\n谨慎处理子会话: 请注意，子会话在不同目的地之间不提供匿名性\n会话创建超时: 如果在 5 分钟内未收到 RequestVariableLeaseSet（请求可变 leaseSet 的消息），则销毁会话\n排序配置映射: 在对 SessionConfig 进行签名之前，始终先对映射键进行排序\n使用合适的 Tunnel 数量: 除非必要，不要将 quantity 设为 \u0026gt; 6\n非 Java 环境考虑使用 SAM/BOB: 建议实现 SAM（I2P 的外部客户端接口），而非直接对接 I2CP\n面向 Router 开发者 验证日期: 对 SessionConfig 的日期强制执行 ±30 秒的时间窗口\n限制消息大小: 将最大消息大小限制为约 64 KB\n支持多个会话: 按 0.9.21 规范实现对 subsession（子会话）的支持\n尽快发送 RequestVariableLeaseSet（可变 leaseSet 请求消息）: 仅在入站和出站 tunnels 都已存在之后\n处理已弃用的消息: 接受但不鼓励使用 ReceiveMessageBegin/End\n支持 ECIES-X25519（基于 Curve25519 的 ECIES 算法）: 在新部署中优先采用类型 4 加密\n调试与故障排除 常见问题 会话被拒绝（无效）: - 检查时钟偏移（必须在 ±30 秒内） - 验证映射已按键名排序 - 确保 Destination（目标标识）未被占用\n没有 RequestVariableLeaseSet: - Router 可能正在构建 tunnels (最多等待 5 分钟) - 检查网络连通性问题 - 确认对等连接数量充足\n消息传递失败: - 检查 MessageStatus（消息状态）代码以确定具体失败原因 - 验证远端 LeaseSet（租约集）已发布且为最新 - 确保使用兼容的加密类型\n子会话问题: - 验证首先创建了主会话 - 确认加密密钥相同 - 检查签名密钥是否不同\n诊断信息 GetBandwidthLimits: 查询 router 带宽上限 HostLookup: 测试名称解析和 LeaseSet 可用性 MessageStatus: 端到端跟踪消息投递\n相关规范 通用结构: /docs/specs/common-structures/ I2NP（网络协议）: /docs/specs/i2np/ ECIES-X25519: /docs/specs/ecies/ Tunnel 创建: /docs/specs/implementation/ 流式传输库: /docs/specs/streaming/ 数据报库: /docs/api/datagrams/ SAM v3: /docs/api/samv3/ 引用的提案 提案 123 : 加密的 LeaseSets 与认证 提案 144 : ECIES-X25519-AEAD-Ratchet 提案 149 : 盲化地址格式（b33） 提案 152 : X25519 tunnel 的创建 提案 154 : 从 ECIES 目的地发起的数据库查找 提案 156 : Router 迁移到 ECIES-X25519 提案 161 : 目的地填充压缩 提案 167 : LeaseSet 服务记录 提案 169 : 后量子混合密码学（ML-KEM） Javadoc 参考文档 I2CP 包 MessageStatusMessage（消息状态消息） 客户端 API 弃用摘要 已弃用的消息（请勿使用） CreateLeaseSetMessage (类型 4): 使用 CreateLeaseSet2Message RequestLeaseSetMessage (类型 21): 使用 RequestVariableLeaseSetMessage ReceiveMessageBeginMessage (类型 6): 使用 快速接收模式 ReceiveMessageEndMessage (类型 7): 使用 快速接收模式 DestLookupMessage (类型 34): 使用 HostLookupMessage DestReplyMessage (类型 35): 使用 HostReplyMessage ReportAbuseMessage (类型 29): 从未实现 已弃用选项 ElGamal 加密 (类型 0): 迁移至 ECIES-X25519 (类型 4) DSA 签名: 迁移至 EdDSA 或 ECDSA i2cp.fastReceive=false: 始终使用快速接收模式 ","description":"应用程序如何与 I2P router 协商会话、tunnels 和 LeaseSets。","id":"ed43fc9da2a03819fd3c8f71e9e9a5a3","section":"docs","title":"I2P 客户端协议 (I2CP)","url":"/zh/docs/specs/i2cp/"},{"categories":null,"content":"根据我们的威胁模型 （以及其他原因）的要求，为支持我们称之为I2P的匿名通信网络而开发的软件必须是免费可用、开源且用户可修改的。为了满足这些标准，我们采用了各种法律和软件工程技术，以尽可能消除那些考虑使用或为I2P项目做出贡献的人的进入障碍。\n虽然下面的信息可能比简单地说\u0026quot;I2P是BSD\u0026quot;、\u0026ldquo;I2P是GPL\u0026quot;或\u0026quot;I2P是公共领域\u0026quot;更令人困惑,但对于\u0026quot;I2P如何授权?\u0026ldquo;这个问题的简短答案是：\nI2P 发行版中捆绑的所有软件将允许： 免费使用 使用时不受任何限制,包括使用方式、时间、地点、原因或使用者 免费访问源代码 修改源代码 大多数软件保证的更多——任何人都能以他们选择的方式分发修改后的源代码。然而，并非所有捆绑的软件都提供这种自由——GPL 限制了那些希望将 I2P 集成到自己非开源应用程序中的开发者的能力。虽然我们赞赏增加公共资源这一崇高目标，但最有利于 I2P 的做法是消除任何阻碍其采用的障碍——如果一个开发者在考虑是否可以将 I2P 集成到他们的应用程序时，不得不停下来咨询律师，或进行代码审计以确保他们自己的源代码可以作为 GPL 兼容版本发布，那我们就会失去机会。\n组件许可证 I2P 发行版包含多个资源，反映了源代码被划分为多个组件。每个组件都有自己的许可证，所有为其做出贡献的开发者都同意该许可证——要么通过明确声明以与该组件兼容的许可证提交代码，要么通过隐式地以该组件的主要许可证提交代码。每个组件都有一位首席开发者，他对什么许可证与该组件的主要许可证兼容拥有最终决定权，而 I2P 项目经理对哪些许可证符合上述四项保证以纳入 I2P 发行版拥有最终决定权。\nComponent Source path Resource Primary license Alternate licenses Lead developer I2P SDK core i2p.jar Public domain BSD, Cryptix, MIT zzz I2P Router router router.jar Public domain BSD, Cryptix, MIT zzz Ministreaming apps/ministreaming mstreaming.jar BSD Public domain, Cryptix, MIT zzz Streaming apps/streaming streaming.jar Public domain BSD, Cryptix, MIT zzz I2PTunnel apps/i2ptunnel i2ptunnel.jar GPL + exception Public domain, BSD, Cryptix, MIT zzz Routerconsole apps/routerconsole routerconsole.war Public domain — zzz Address Book apps/addressbook addressbook.war MIT Public domain, Cryptix, BSD — Susidns apps/susidns susidns.war GPL + exception — — Susimail apps/susimail susimail.war GPL + exception — — I2PSnark apps/i2psnark i2psnark.jar GPL + exception — zzz [BOB](/docs/legacy/bob/) Bridge apps/BOB BOB.jar WTFPL — sponge [SAM](/docs/api/samv3/) Bridge apps/sam sam.jar Public domain Cryptix, BSD, MIT zzz [SAM v1](/docs/legacy/sam/) Perl library apps/sam/perl SAM.pm GPL Public domain, Cryptix, BSD, MIT BrianR [SAM v1](/docs/legacy/sam/) C library apps/sam/c libSAM BSD Public domain, Cryptix, MIT Nightblade [SAM v1](/docs/legacy/sam/) Python library apps/sam/python i2p.py Public domain BSD, Cryptix, MIT Connelly [SAM v1](/docs/legacy/sam/) C# library apps/sam/csharp/ n/a Public domain BSD, Cryptix, MIT smeghead Other apps not mentioned apps/ ... Probably Public domain but check the source — — Installer installer install.jar, guiinstall.jar Public domain GPL + exception, BSD, Cryptix, MIT — GPL 例外 尽管这可能有些冗余,但为了明确起见,I2PTunnel 和其他应用程序中包含的 GPL 代码必须在 GPL 许可下发布,并附加一个\u0026quot;例外\u0026quot;条款,明确授权使用 Java 的标准库:\nIn addition, as a special exception, XXXX gives permission to link the code of this program with the proprietary Java implementation provided by Sun (or other vendors as well), and distribute linked combinations including the two. You must obey the GNU General Public License in all respects for all of the code used other than the proprietary Java implementation. If you modify this file, you may extend this exception to your version of the file, but you are not obligated to do so. If you do not wish to do so, delete this exception statement from your version. 除非在代码中另有标注,否则每个组件下的所有源代码默认遵循主许可证。以上所有内容均为许可条款的摘要 - 请查阅相关组件或源代码的具体许可证以获取权威条款。如果仓库重新组织,组件源代码位置和资源打包方式可能会发生变化。\n网站许可证 除非另有说明,本站内容采用知识共享署名-相同方式共享 4.0 国际许可协议 授权。\n提交权限 如果您获得了运行该仓库的人员的许可,开发者可以将更改推送到分布式 git 仓库。详情请参阅新开发者指南 。\n然而，要让更改被包含在发行版中，开发者必须得到发布管理员（目前是 zzz）的信任。此外，他们必须明确同意上述条款才能获得信任。这意味着他们必须向发布管理员之一发送一条签名消息，确认：\n除非另有标明,我提交的所有代码都默认按照该组件的主要许可证进行授权 如果在源代码中指定,代码可能明确按照该组件的备用许可证之一进行授权 我有权按照我提交时的条款发布我提交的代码 如果有人发现任何不符合上述条件的情况，请联系组件负责人和/或 I2P 发布经理并提供进一步信息。\n","description":"I2P 捆绑软件的许可证政策和组件许可证","id":"74bb6af167b1176b4058e46e5f8ca568","section":"docs","title":"I2P 软件许可证","url":"/zh/docs/develop/licenses/"},{"categories":null,"content":"主要的 I2P 客户端实现使用 Java。如果您在特定系统上无法或不希望使用 Java,社区成员开发和维护了其他替代的 I2P 客户端实现。这些程序使用不同的编程语言或方法提供相同的核心功能。\n对比表 Client Language Maturity Actively Maintained Suitable For Notes Java I2P Java Stable ✅ Yes (official) General users Standard full router; includes console, plugins, and tools i2pd C++ Stable ✅ Yes Low-resource systems, servers Lightweight, fully compatible with Java I2P, includes web console Go-I2P Go Experimental ⚙️ In development Developers, testing Early-stage Go implementation; not yet production ready I2P+ Java Stable (fork) ✅ Yes Advanced users Enhanced Java I2P fork with UI and performance improvements --- i2pd (C++) 网站： https://i2pd.website 描述： i2pd（I2P Daemon）是一个用 C++ 实现的全功能 I2P 客户端。它已经稳定用于生产环境多年（自2016年左右开始），并由社区积极维护。i2pd 完整实现了 I2P 网络协议和 API，使其与 Java I2P 网络完全兼容。这个 C++ router 常被用作轻量级替代方案，适用于无法使用或不希望使用 Java 运行时的系统。i2pd 包含一个内置的基于 Web 的控制台，用于配置和监控。它是跨平台的，并提供多种打包格式——甚至还有 Android 版本的 i2pd 可用（例如通过 F-Droid）。\nGo-I2P (Go) 仓库： https://github.com/go-i2p/go-i2p 描述： Go-I2P 是一个用 Go 编程语言编写的 I2P 客户端。它是 I2P router 的独立实现，旨在利用 Go 的高效性和可移植性。该项目正在积极开发中，但仍处于早期阶段，尚未完成全部功能。截至 2025 年，Go-I2P 被认为是实验性的——它正在由社区开发者积极开发，但在进一步成熟之前不建议用于生产环境。Go-I2P 的目标是在开发完成后提供一个现代化、轻量级的 I2P router，并与 I2P 网络完全兼容。\nI2P+（Java 分支） 网站： https://i2pplus.github.io 描述： I2P+ 是标准 Java I2P 客户端的一个由社区维护的分支。它不是用新语言重新实现的版本，而是 Java router 的增强版本，具有额外的特性和优化。I2P+ 专注于提供改进的用户体验和更好的性能，同时与官方 I2P 网络保持完全兼容。它引入了焕然一新的 Web 控制台界面、更加用户友好的配置选项，以及各种优化（例如，改进的种子性能和更好的网络对等节点处理，尤其是对于防火墙后面的 router）。I2P+ 与官方 I2P 软件一样需要 Java 环境，因此它不是非 Java 环境的解决方案。然而，对于拥有 Java 并希望获得具有额外功能的替代构建版本的用户来说，I2P+ 提供了一个极具吸引力的选择。这个分支与上游 I2P 发布版本保持同步更新（其版本号附加了\u0026quot;+\u0026quot;），可以从项目网站获取。\n","description":"社区维护的 I2P 客户端实现（2025年更新）","id":"fdcfc5a7a482cf9fe8fe449e9198b146","section":"docs","title":"I2P 替代客户端","url":"/zh/docs/overview/alternative-clients/"},{"categories":null,"content":"概述 I2P 网络协议（I2NP）定义了 routers（路由器）如何交换消息、选择传输协议，并在保持匿名性的同时混合流量。它运行在 I2CP（客户端 API）与传输协议（NTCP2 和 SSU2）之间。\nI2NP 是位于 I2P 传输协议之上的一层。它是一个 router 到 router 的协议，用于: - 网络数据库查询与应答 - 创建 tunnel - 加密的 router 和客户端数据消息\nI2NP 消息既可以点对点发送至另一台 router，也可以通过 tunnels 匿名地发送至该 router。\nrouter 使用本地优先级将出站任务入队。优先级数值越高，越先处理。高于标准 tunnel 数据优先级（400）的任何任务都会被视为紧急。\n当前传输协议 I2P 现在适用于 IPv4 和 IPv6，并使用 NTCP2（TCP）和 SSU2（UDP）。这两种传输采用: - X25519 密钥交换（Noise 协议框架） - ChaCha20/Poly1305 认证加密（AEAD） - SHA-256 哈希\n已移除的旧版传输: - NTCP (原始 TCP) 已在 Java router 的 0.9.50 版本 (2021 年 5 月) 中移除 - SSU v1 (原始 UDP) 已在 Java router 的 2.4.0 版本 (2023 年 12 月) 中移除 - SSU v1 已在 i2pd 的 2.44.0 版本 (2022 年 11 月) 中移除\n截至2025年，网络已完全过渡到基于 Noise（加密握手协议框架）的传输方式，不再支持任何旧版传输。\n版本编号系统 重要： I2P 使用双重版本编号体系，必须清楚理解：\n发布版本（面向用户） 以下是用户可见并可下载的版本: - 0.9.50 (2021 年 5 月) - 最后一个 0.9.x 版本 - 1.5.0 (2021 年 8 月) - 首个 1.x 版本 - 1.6.0, 1.7.0, 1.8.0, 1.9.0 (贯穿 2021-2022 年) - 2.0.0 (2022 年 11 月) - 首个 2.x 版本 - 2.1.0 至 2.9.0 (贯穿 2023-2025 年) - 2.10.0 (2025 年 9 月 8 日) - 当前版本\nAPI 版本 (协议兼容性) 以下是在 RouterInfo 属性的 \u0026ldquo;router.version\u0026rdquo; 字段中发布的内部版本号： - 0.9.50（2021 年 5 月） - 0.9.51（2021 年 8 月） - 面向 1.5.0 发行版的 API 版本 - 0.9.52 至 0.9.66（并持续到 2.x 系列发行版） - 0.9.67（2025 年 9 月） - 面向 2.10.0 发行版的 API 版本\n要点： 没有任何编号为 0.9.51 到 0.9.67 的版本发布。这些编号仅作为 API 版本标识存在。I2P 从 0.9.50 版本直接跳到 1.5.0。\n版本映射表 Release Version API Version Date Key Features 0.9.50 0.9.50 May 2021 Last 0.9.x release, removed NTCP1 1.5.0 0.9.51 August 2021 Short tunnel build messages (218 bytes) 1.6.0 0.9.52 November 2021 Various improvements 1.7.0 0.9.53 January 2022 Performance enhancements 1.8.0 0.9.54 May 2022 SSU2 introduced 1.9.0 0.9.55 August 2022 SSU2 improvements 2.0.0 0.9.56 November 2022 SSU2 enabled by default 2.1.0 0.9.57 January 2023 Stability improvements 2.2.0 0.9.58 March 2023 ElGamal routers deprecated 2.3.0 0.9.59 May 2023 Various improvements 2.4.0 0.9.61 December 2023 Removed SSU1 support 2.5.0 0.9.62 February 2024 Performance improvements 2.6.0 0.9.63 May 2024 Network optimizations 2.7.0 0.9.64 October 2024 Post-quantum preparation work 2.8.0 0.9.65 February 2025 Tunnel bandwidth parameters 2.9.0 0.9.66 June 2025 LeaseSet service records 2.10.0 0.9.67 September 2025 Post-quantum hybrid cryptography (beta) **即将发布：** 2.11.0 版本（计划于 2025 年 12 月发布）将要求 Java 17+，并默认启用后量子密码学。 协议版本 所有 router 必须在 RouterInfo（router 信息记录）的属性中的 \u0026ldquo;router.version\u0026rdquo; 字段里发布其 I2NP 协议版本。该版本字段是 API 版本，用于指示对各类 I2NP 协议特性的支持程度，并不一定等同于实际的 router 版本。\n如果替代（非 Java）的 routers 希望发布有关实际 router 实现的任何版本信息，必须在另一项属性中进行。除下文列出的版本外，允许使用其他版本。支持情况将通过数值比较来确定；例如，0.9.13 意味着支持 0.9.12 的功能。\n注意： 属性 \u0026ldquo;coreVersion\u0026rdquo; 已不再在 router 信息中发布，且从未用于确定 I2NP 协议版本。\nAPI 版本功能摘要 API Version Required I2NP Features 0.9.67Post-quantum hybrid cryptography (MLKEM ratchet) support (beta), UDP tracker support 0.9.66LeaseSet2 service record options (see proposal 167) 0.9.65Tunnel build bandwidth parameters (see proposal 168) 0.9.59Minimum peers will build tunnels through (as of 0.9.63), minimum floodfill peers will send DSM to (as of 0.9.63) 0.9.58Minimum peers will build tunnels through (as of 0.9.62), ElGamal routers deprecated 0.9.55SSU2 transport support (if published in router info) 0.9.51Short tunnel build messages for ECIES-X25519 routers, minimum peers will build tunnels through (as of 0.9.58), minimum floodfill peers will send DSM to (as of 0.9.58) 0.9.49Garlic messages to ECIES-X25519 routers 0.9.48ECIES-X25519 routers, ECIES-X25519 build request/response records 0.9.46DatabaseLookup flag bit 4 for AEAD reply 0.9.44ECIES-X25519 keys in LeaseSet2 0.9.40MetaLeaseSet may be sent in a DSM 0.9.39EncryptedLeaseSet may be sent in a DSM, RedDSA_SHA512_Ed25519 signature type supported 0.9.38DSM type bits 3-0 now contain the type; LeaseSet2 may be sent in a DSM 0.9.36NTCP2 transport support (if published in router info), minimum peers will build tunnels through (as of 0.9.46) 0.9.28RSA signature types disallowed, minimum floodfill peers will send DSM to (as of 0.9.34) 0.9.18DSM type bits 7-1 ignored 0.9.16RI key certs / ECDSA and EdDSA signature types, DLM lookup types (flag bits 3-2), minimum version compatible with the current network 0.9.15Destination/LeaseSet key certificates with EdDSA Ed25519 signature type (if floodfill) 0.9.12Destination/LeaseSet key certificates with ECDSA P-256, P-384, and P-521 signature types (if floodfill); non-zero expiration allowed in RouterAddress 0.9.7Encrypted DSM/DSRM replies supported (DLM flag bit 1) for floodfill routers 0.9.6Non-zero DLM flag bits 7-1 allowed 0.9.3Requires zero expiration in RouterAddress 0.9Supports up to 16 leases in a DSM LeaseSet store (previously 6) 0.7.12VTBM and VTBRM message support 0.7.10Floodfill supports encrypted DSM stores 0.6.1.10TBM and TBRM messages introduced; minimum version compatible with the current network **注意：** 还存在与传输相关的特性和兼容性问题。详情请参阅 NTCP2 和 SSU2 的传输文档。 消息头部 I2NP 使用逻辑上的 16 字节头部结构，而现代传输协议（NTCP2 和 SSU2）采用精简的 9 字节头部，省略了冗余的长度和校验和字段。这些字段在概念上仍然等价。\n头部格式比较 标准格式（16 字节）：\n用于旧版 NTCP 传输，以及当 I2NP 消息被嵌入到其他消息中时 (TunnelData, TunnelGateway, GarlicClove).\nBytes 0-15: +----+----+----+----+----+----+----+----+ |type| msg_id | expiration +----+----+----+----+----+----+----+----+ | size |chks| +----+----+----+----+----+----+----+----+ type :: Integer (1 byte) Identifies the message type (see message type table) msg_id :: Integer (4 bytes) Uniquely identifies this message (for some time at least) Usually a locally-generated random number, but for outgoing tunnel build messages may be derived from the incoming message expiration :: Date (8 bytes) Unix timestamp in milliseconds when this message expires size :: Integer (2 bytes) Length of the payload (0 to ~61.2 KB for tunnel messages) chks :: Integer (1 byte) SHA256 hash of payload truncated to first byte Deprecated - NTCP2/SSU2 use ChaCha20/Poly1305 AEAD for integrity SSU 的短格式（已废弃，5 字节）：\n+----+----+----+----+----+ |type| short_expiration | +----+----+----+----+----+ type :: Integer (1 byte) short_expiration :: Integer (4 bytes, seconds since epoch) NTCP2、SSU2 以及 ECIES-Ratchet Garlic Cloves (蒜瓣) 的短格式 (9 字节)：\n用于现代传输协议以及采用 ECIES（椭圆曲线集成加密方案）加密的 garlic 消息（I2P 的多消息捆绑机制）。\n+----+----+----+----+----+----+----+----+ |type| msg_id | short_expira- +----+----+----+----+----+----+----+----+ tion| +----+ type :: Integer (1 byte) msg_id :: Integer (4 bytes) short_expiration :: Integer (4 bytes, seconds since epoch, unsigned) 首部字段详细信息 Field Bytes Description Type 1 Identifies the message class (0\u0026ndash;255, see message types below) Unique ID 4 Locally unique identifier for matching replies Expiration 8 (standard) / 4 (short) Timestamp when the message expires. Routers discard expired messages. Short format uses seconds since epoch (unsigned, wraps February 7, 2106) Payload Length 2 Size in bytes (0 to ~61.2 KB for tunnel messages). NTCP2 and SSU2 encode this in their frame headers Checksum 1 Deprecated. First byte of SHA-256 hash of the payload. NTCP2/SSU2 use ChaCha20/Poly1305 AEAD for integrity ### 实现说明 在通过 SSU（已弃用）传输时，仅包含类型和 4 字节的过期时间 在通过 NTCP2 或 SSU2 传输时，使用 9 字节的短格式 当 I2NP 消息被包含在其他消息（Data, TunnelData, TunnelGateway, GarlicClove）内时，需要标准的 16 字节头部 自 0.8.12 版本起，为提高效率，协议栈的某些环节禁用了校验和验证，但为兼容性仍需生成校验和 短格式的过期时间为无符号，将在 2106 年 2 月 7 日发生回绕。该日期之后，必须加上一个偏移量才能得到正确的时间 为了与旧版本兼容，即使可能不会进行验证，也应始终生成校验和 大小限制 Tunnel 消息将 I2NP 负载分片为固定大小的片段：\n首个分片： 约 956 字节 后续分片： 每个约 996 字节 最大分片数： 64（编号 0-63） 最大负载： 约 61,200 字节（61.2 KB） 计算： 956 + (63 × 996) = 63,704 字节（理论最大值），由于开销，实际上限约为 61,200 字节。\n历史背景 旧版传输协议具有更严格的帧大小限制: - NTCP: 16 KB 帧 - SSU: 约 32 KB 帧\nNTCP2 支持约 65 KB 的帧，但 tunnel 的分片限制仍然适用。\n应用数据注意事项 Garlic messages（Garlic 消息）可能会捆绑 LeaseSets、Session Tags（会话标签）或加密的 LeaseSet2 变体，从而减少用于有效载荷数据的空间。\n建议： 为确保可靠投递，数据报应保持在 ≤ 10 KB。接近 61 KB 上限的消息可能会出现： - 因分片与重组导致的时延增加 - 更高的投递失败概率 - 更易受到流量分析\n分片技术细节 每个 tunnel 消息固定为 1,024 字节 (1 KB)，并包含： - 4 字节的 tunnel ID - 16 字节的初始化向量 (IV) - 1,004 字节的加密数据\n在加密数据中，tunnel 消息携带已分片的 I2NP 消息，并附带分片头，指示： - 分片编号 (0-63) - 是否为首个分片或后续分片 - 用于重组的整体消息 ID\n第一个分片包含完整的 I2NP 消息头部（16 字节），留给负载的空间约为 956 字节。后续分片不包含该消息头部，从而每个分片可携带约 996 字节的负载。\n常见消息类型 router 会根据消息类型和优先级来调度出站工作。优先级值越高，越先被处理。以下数值与当前 Java I2P 的默认设置一致（截至 API 版本 0.9.67）。\n注意： 优先级与实现相关。若需权威的优先级取值，请参阅 Java I2P 源代码中的 OutNetMessage 类文档。\nMessage Type Priority Typical Size Purpose DatabaseStore 1 460 Varies (LeaseSet ≈ 898\u0026nbsp;B, RouterInfo ≈ 2\u0026ndash;4\u0026nbsp;KB compressed) Publishes RouterInfo or LeaseSet objects. Supports LeaseSet2, EncryptedLeaseSet, and MetaLeaseSet DatabaseLookup 2 500 Varies Queries the network database for RouterInfo or LeaseSet entries DatabaseSearchReply 3 300 ≈161\u0026nbsp;B (5 hashes) Returns candidate floodfill router hashes (typically 3\u0026ndash;16 hashes, recommended maximum 16) DeliveryStatus 10 Varies 12\u0026nbsp;B Receipts for tunnel tests or acknowledgements inside GarlicMessages GarlicMessage 11 100 (local) Varies Bundles multiple message cloves (e.g., DataMessage, LeaseSets). Supports ElGamal/AES (deprecated) and ECIES-X25519-AEAD-Ratchet encryption TunnelData 18 400 1,028\u0026nbsp;B (fixed) Encrypted tunnel message exchanged between hops. Contains a 4-byte tunnel ID, 16-byte IV, and 1,004 bytes of encrypted data TunnelGateway 19 300\u0026ndash;400 Varies Encapsulates messages at the tunnel gateway before fragmentation DataMessage 20 425 4\u0026ndash;62\u0026nbsp;KB Carries end-to-end garlic payloads (application traffic) TunnelBuild (deprecated) 21 500 4,224\u0026nbsp;B Requests tunnel participation from routers (8 × 528-byte records). Replaced by VariableTunnelBuild for ECIES TunnelBuildReply (deprecated) 22 300 4,224\u0026nbsp;B Replies to TunnelBuild with accept/reject status per hop VariableTunnelBuild 23 500 1,057\u0026ndash;4,225\u0026nbsp;B Variable-length tunnel build for ElGamal or ECIES-X25519 routers (1\u0026ndash;8 records, API 0.9.12+) VariableTunnelBuildReply 24 300 1,057\u0026ndash;4,225\u0026nbsp;B Replies to VariableTunnelBuild ShortTunnelBuild 25 500 873\u0026ndash;1,745\u0026nbsp;B Short tunnel build messages for ECIES-X25519 routers only (1\u0026ndash;8 × 218-byte records, API 0.9.51+) OutboundTunnelBuildReply 26 300 873\u0026ndash;1,745\u0026nbsp;B Sent from outbound endpoint to originator for ECIES-X25519 routers (API 0.9.51+) **保留的消息类型：** - 类型 0：保留 - 类型 4-9：保留用于将来使用 - 类型 12-17：保留用于将来使用 - 类型 224-254：保留用于实验性消息 - 类型 255：保留用于将来扩展 消息类型说明 控制平面消息 (DatabaseLookup、TunnelBuild 等) 通常通过exploratory tunnels (探索型 tunnel) 传输，而不是通过 client tunnels (客户端 tunnel)，从而可以独立设定优先级 优先级数值是近似的，并可能因实现而异 TunnelBuild (21) 和 TunnelBuildReply (22) 已弃用，但仍然实现以兼容超长 tunnels (\u0026gt;8 跳) 标准的 tunnel 数据优先级为 400；高于该值的都视为紧急 当前网络中的典型 tunnel 长度为 3-4 跳，因此大多数 tunnel 构建使用 ShortTunnelBuild (218 字节记录) 或 VariableTunnelBuild (528 字节记录) 加密与消息封装 Routers 经常在传输前封装 I2NP 消息，从而形成多层加密。DeliveryStatus 消息可能是：1. 被封装在 GarlicMessage 中（加密） 2. 位于 DataMessage 内 3. 位于 TunnelData 消息中（再次加密）\n每一跳只解密它的那一层；最终目的地才会揭示最内层的有效载荷。\n加密算法 遗留（正逐步淘汰）: - ElGamal/AES + SessionTags（会话标签） - ElGamal-2048 用于非对称加密 - AES-256 用于对称加密 - 32 字节的 session tags\n当前（自 API 0.9.48 起为标准）： - ECIES-X25519 + ChaCha20/Poly1305 AEAD，具备棘轮式前向保密 - Noise 协议框架（用于 destinations（目标端点） 的 Noise_IK_25519_ChaChaPoly_SHA256） - 8 字节的会话标签（由 32 字节缩减） - 用于前向保密的 Signal Double Ratchet 算法 - 在 API 版本 0.9.46（2020）引入 - 自 API 版本 0.9.58（2023）起对所有 routers 强制启用\n未来 (自 2.10.0 起为测试版): - 使用 MLKEM (后量子密钥封装算法, ML-KEM-768) 与 X25519 组合的后量子混合密码学 - 结合经典与后量子密钥协商的混合棘轮 - 与 ECIES-X25519 向后兼容 - 将在 2.11.0 版本 (2025 年 12 月) 中成为默认\nElGamal Router 弃用 重要: 自 API 版本 0.9.58（发行版 2.2.0，2023 年 3 月）起，ElGamal routers 已被弃用。由于当前建议用于查询的最低 floodfill（I2P 中负责 netDb 存储与分发的特殊节点）版本为 0.9.58，各实现无需为 ElGamal floodfill routers 实现加密。\n然而： 为了向后兼容，仍然支持 ElGamal（埃尔加马尔）目的地。使用 ElGamal 加密的客户端仍可通过 ECIES（椭圆曲线集成加密方案） routers 进行通信。\nECIES-X25519-AEAD-Ratchet 详细信息 这是 I2P 的加密规范中的加密类型 4。它提供：\n关键特性： - 通过棘轮机制实现前向保密（每条消息使用新密钥） - 降低会话标签存储开销（8 字节 vs. 32 字节） - 多种会话类型（新建会话、已有会话、一次性） - 基于 Noise 协议 Noise_IK_25519_ChaChaPoly_SHA256 - 集成 Signal 的双棘轮算法\n密码学原语: - X25519 用于 Diffie-Hellman 密钥交换 - ChaCha20 用于流加密 - Poly1305 用于消息认证 (AEAD) - SHA-256 用于哈希 - HKDF 用于密钥派生\n会话管理: - 新会话: 使用静态 Destination（I2P 终端地址标识）密钥进行初始连接 - 现有会话: 后续消息使用会话标签 - 一次性会话: 单消息会话，以降低开销\n有关完整的技术细节，请参见 ECIES 规范 和 提案 144 。\n通用结构 以下结构是多个 I2NP（I2P 网络协议）消息中的组成元素。它们并非完整的消息。\nBuildRequestRecord (构建请求记录) (ElGamal) 已弃用。 仅在当前网络中，当一个 tunnel 包含 ElGamal router 时才会使用。有关现代格式，请参见 ECIES Tunnel Creation 。\n用途： 一组多条记录中的一条，用于请求在 tunnel 中创建一跳。\n格式：\n使用 ElGamal 和 AES 加密（总计 528 字节）:\n+----+----+----+----+----+----+----+----+ | encrypted data (528 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ ElGamal 加密结构（528 字节）：\n+----+----+----+----+----+----+----+----+ | toPeer (16 bytes) | +----+----+----+----+----+----+----+----+ | ElGamal encrypted data (512 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ toPeer :: First 16 bytes of SHA-256 hash of peer\u0026#39;s RouterIdentity encrypted_data :: ElGamal-2048 encrypted (bytes 1-256 and 258-513 of the 514-byte ElGamal block, with padding bytes at positions 0 and 257 removed) 明文结构（加密前为 222 字节）:\n+----+----+----+----+----+----+----+----+ | receive_tunnel (4) | our_ident (32) | +----+----+----+----+ + | | + +----+----+----+----+ | | next_tunnel (4) | +----+----+----+----+----+----+----+----+ | next_ident (32 bytes) | + + | | +----+----+----+----+----+----+----+----+ | layer_key (32 bytes) | + + | | +----+----+----+----+----+----+----+----+ | iv_key (32 bytes) | + + | | +----+----+----+----+----+----+----+----+ | reply_key (32 bytes) | + + | | +----+----+----+----+----+----+----+----+ | reply_iv (16 bytes) | + + | | +----+----+----+----+----+----+----+----+ |flag| request_time (4) | send_msg_id | +----+----+----+----+----+----+----+----+ (4) | padding (29) | +----+----+----+----+----+ + | | + +----+----+ | | +----+----+----+----+----+----+ receive_tunnel :: TunnelId (4 bytes, nonzero) our_ident :: Hash (32 bytes) next_tunnel :: TunnelId (4 bytes, nonzero) next_ident :: Hash (32 bytes) layer_key :: SessionKey (32 bytes) iv_key :: SessionKey (32 bytes) reply_key :: SessionKey (32 bytes) reply_iv :: 16 bytes flag :: Integer (1 byte) request_time :: Integer (4 bytes, hours since epoch = time / 3600) send_message_id :: Integer (4 bytes) padding :: 29 bytes random data 注意： - ElGamal-2048 加密会生成一个 514 字节的块，但会移除两个填充字节（位于位置 0 和 257），最终得到 512 字节 - 字段细节见 Tunnel 创建规范 - 源代码：net.i2p.data.i2np.BuildRequestRecord - 常量：EncryptedBuildRecord.RECORD_SIZE = 528\nBuildRequestRecord（构建请求记录） (ECIES-X25519 长格式) 适用于 ECIES-X25519 router（基于 X25519 的 ECIES 加密方案），在 API 版本 0.9.48 中引入。使用 528 字节，以与混合 tunnel 保持向后兼容。\n格式：\n+----+----+----+----+----+----+----+----+ | toPeer (16 bytes) | +----+----+----+----+----+----+----+----+ | ephemeral_key (32 bytes) | + + | | +----+----+----+----+----+----+----+----+ | ChaCha20 encrypted data (464 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ | Poly1305 MAC (16 bytes) | + + | | +----+----+----+----+----+----+----+----+ toPeer :: First 16 bytes of SHA-256 hash of peer\u0026#39;s RouterIdentity ephemeral_key :: X25519 ephemeral public key (32 bytes) encrypted_data :: ChaCha20 encrypted (464 bytes) mac :: Poly1305 message authentication code (16 bytes) 总大小： 528 字节（与 ElGamal 相同以保持兼容性）\n有关明文结构和加密细节，请参阅 ECIES Tunnel Creation 。\nBuildRequestRecord (ECIES-X25519 短格式) 仅适用于 ECIES-X25519 routers，自 API 版本 0.9.51（发行版 1.5.0）起。这是当前的标准格式。\n格式:\n+----+----+----+----+----+----+----+----+ | toPeer (16 bytes) | +----+----+----+----+----+----+----+----+ | ephemeral_key (32 bytes) | + + | | +----+----+----+----+----+----+----+----+ | ChaCha20 encrypted data (154 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ | Poly1305 MAC (16 bytes) | + + | | +----+----+----+----+----+----+----+----+ toPeer :: First 16 bytes of SHA-256 hash of peer\u0026#39;s RouterIdentity ephemeral_key :: X25519 ephemeral public key (32 bytes) encrypted_data :: ChaCha20 encrypted (154 bytes) mac :: Poly1305 message authentication code (16 bytes) 总大小: 218 字节（比 528 字节减少 59%）\n关键区别： 短记录通过 HKDF（密钥派生函数）派生所有密钥，而不是在记录中显式包含它们。这包括： - 层密钥（用于 tunnel 加密） - IV（初始向量）密钥（用于 tunnel 加密） - 回复密钥（用于构建回复） - 回复 IV（用于构建回复）\n所有密钥均通过 Noise 协议的 HKDF 机制，从 X25519 密钥交换得到的共享秘密中派生。\n优势： - 4 条短记录可装入一个 tunnel 消息 (873 字节) - 采用 3 条消息完成的 tunnel 构建，而不是为每条记录分别发送消息 - 降低带宽占用和延迟 - 与长格式具有相同的安全属性\n有关设计动机，请参见提案 157 ，完整规范请参见ECIES Tunnel 创建 。\n源代码： - net.i2p.data.i2np.ShortEncryptedBuildRecord - 常量：ShortEncryptedBuildRecord.RECORD_SIZE = 218\n构建响应记录 (ElGamal) 已弃用。 仅当 tunnel 包含 ElGamal router 时使用。\n用途： 用于对构建请求进行响应的多条记录集合中的一条记录。\n格式：\n加密（528 字节，与 BuildRequestRecord 大小相同）:\nbytes 0-527 :: AES-encrypted record 未加密的结构：\n+----+----+----+----+----+----+----+----+ | SHA-256 hash (32 bytes) | + + | (hash of bytes 32-527) | + + | | +----+----+----+----+----+----+----+----+ | random data (495 bytes) | ~ ~ | |ret | +----+----+----+----+----+----+----+----+ bytes 0-31 :: SHA-256 hash of bytes 32-527 bytes 32-526 :: Random data (could be used for congestion info) byte 527 :: Reply code (0 = accept, 30 = reject) 回复代码: - 0 - 接受 - 30 - 拒绝 (带宽超出)\n有关 reply 字段的详细信息，请参见 Tunnel Creation Specification 。\nBuildResponseRecord（构建响应记录） (ECIES-X25519) 适用于 ECIES-X25519（基于 Curve25519 的 ECIES 加密套件） routers，API 版本 0.9.48+。与对应请求大小相同（长为 528，短为 218）。\n格式：\n长格式（528 字节）:\n+----+----+----+----+----+----+----+----+ | ChaCha20 encrypted data (512 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ | Poly1305 MAC (16 bytes) | + + | | +----+----+----+----+----+----+----+----+ 短格式（218 字节）：\n+----+----+----+----+----+----+----+----+ | ChaCha20 encrypted data (202 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ | Poly1305 MAC (16 bytes) | + + | | +----+----+----+----+----+----+----+----+ 明文结构（两种格式）：\n包含一个 Mapping 结构（I2P 的键值格式），其中包括： - 应答状态码（必需） - 可用带宽参数（\u0026ldquo;b\u0026rdquo;）（可选，添加于 API 0.9.65） - 用于未来扩展的其他可选参数\n回复状态码: - 0 - 成功 - 30 - 拒绝: 带宽超限\n有关完整规范，请参阅 ECIES Tunnel Creation 。\nGarlicClove（蒜瓣消息单元） (ElGamal/AES) 警告： 这是用于 ElGamal 加密的大蒜消息中蒜瓣的格式。ECIES-AEAD-X25519-Ratchet 大蒜消息及其蒜瓣的格式有显著不同。有关现代格式，请参见 ECIES 规范 。\n针对 routers（API 0.9.58+）已弃用，仍支持用于目的地。\n格式：\n未加密：\n+----+----+----+----+----+----+----+----+ | Delivery Instructions (variable) | ~ ~ +----+----+----+----+----+----+----+----+ | I2NP Message (variable) | ~ ~ +----+----+----+----+----+----+----+----+ | Clove ID (4) | Expiration (8) |Cert| +----+----+----+----+----+----+----+----+ (3) | +----+----+----+----+----+----+----+----+ Delivery Instructions :: Variable length (typically 1, 33, or 37 bytes) I2NP Message :: Any I2NP message Clove ID :: 4-byte Integer (random, checked for duplicates) Expiration :: Date (8 bytes) Certificate :: Always NULL (3 bytes total, all zeroes) 注意： - 蒜瓣绝不会被分片 - 当传递指令标志字节的第一位为0时，该蒜瓣不加密 - 当第一位为1时，该蒜瓣会被加密（功能尚未实现） - 最大长度由所有蒜瓣的总长度和GarlicMessage的最大长度共同决定 - 证书可能会用于借助HashCash来为路由\u0026quot;付费\u0026quot;（未来的可能性） - 实践中使用的消息：DataMessage, DeliveryStatusMessage, DatabaseStoreMessage - GarlicMessage可以包含GarlicMessage（嵌套的garlic），但在实践中并不使用\n请参阅 Garlic Routing（大蒜路由） 以获取概念性概览。\nGarlicClove (ECIES-X25519-AEAD-Ratchet)（I2P garlic encryption 消息中的“蒜瓣”单元） 适用于 ECIES-X25519 的 router 和目标，API 版本 0.9.46+。这是当前的标准格式。\n关键差异: ECIES garlic 使用的是一种完全不同的结构，它基于 Noise 协议的块，而不是显式的 clove（子消息）结构。\n格式：\nECIES garlic 消息（I2P 中将多条消息封装在一起的消息形式）包含一系列块：\nBlock structure: +----+----+----+----+----+----+----+----+ |type| length | data ... +----+----+----+----+----+-//- type :: 1 byte block type length :: 2 bytes block length data :: variable length data 块类型： - 0 - Garlic Clove Block (包含一条 I2NP 消息) - 1 - 日期时间块 (时间戳) - 2 - 选项块 (传递选项) - 3 - 填充块 - 254 - 终止块 (未实现)\n蒜瓣块 (类型 0):\n+----+----+----+----+----+----+----+----+ | 0 | length | Delivery Instructions | +----+----+----+----+ + ~ ~ +----+----+----+----+----+----+----+----+ | I2NP Message | ~ ~ +----+----+----+----+----+----+----+----+ | Clove ID (4) | Expiration (4) | +----+----+----+----+----+----+----+----+ 与 ElGamal 格式的关键差异： - 使用 4 字节过期时间（自 Unix 纪元以来的秒数），而非 8 字节的 Date - 无证书字段 - 封装在具有类型和长度的块结构中 - 整条消息使用 ChaCha20/Poly1305 AEAD 加密 - 通过 ratcheting（棘轮机制）进行会话管理\n有关 Noise 协议框架和数据块结构的详尽信息，请参见 ECIES 规范 。\n蒜瓣投递指令 此格式同时用于 ElGamal 和 ECIES 的蒜瓣。它规定了如何投递所包含的消息。\n严重警告： 本规范仅适用于 Garlic Cloves（蒜瓣）内部的投递指令。\u0026ldquo;投递指令\u0026rdquo; 也用于 Tunnel 消息中，但其格式有显著不同。有关 tunnel 投递指令，请参见 Tunnel 消息规范 。切勿混淆这两种格式。\n格式：\n会话密钥和延迟未使用且从不出现，因此可能的三种长度为: - 1 字节 (LOCAL) - 33 字节 (ROUTER 和 DESTINATION) - 37 字节 (TUNNEL)\n+----+----+----+----+----+----+----+----+ |flag| | +----+ + | Session Key (optional, 32) | + + | | + +----+----+----+----+--------------+ | | | +----+ + | To Hash (optional, 32) | + + | | + +----+----+----+----+--------------+ | | Tunnel ID (4, opt)| Delay (4, opt)| +----+----+----+----+----+----+----+----+ flag :: 1 byte Bit order: 76543210 bit 7: encrypted? (Unimplemented, always 0) If 1, a 32-byte encryption session key follows bits 6-5: delivery type 0x0 = LOCAL (0) 0x1 = DESTINATION (1) 0x2 = ROUTER (2) 0x3 = TUNNEL (3) bit 4: delay included? (Not fully implemented, always 0) If 1, four delay bytes are included bits 3-0: reserved, set to 0 for compatibility Session Key :: 32 bytes (Optional, unimplemented) Present if encrypt flag bit is set To Hash :: 32 bytes (Optional) Present if delivery type is DESTINATION, ROUTER, or TUNNEL - DESTINATION: SHA256 hash of the destination - ROUTER: SHA256 hash of the router identity - TUNNEL: SHA256 hash of the gateway router identity Tunnel ID :: 4 bytes (Optional) Present if delivery type is TUNNEL The destination tunnel ID (nonzero) Delay :: 4 bytes (Optional, unimplemented) Present if delay included flag is set Specifies delay in seconds 典型长度: - 本地投递: 1 字节 (仅标志) - ROUTER / DESTINATION（目的地）投递: 33 字节 (标志 + 哈希) - TUNNEL 投递: 37 字节 (标志 + 哈希 + tunnel ID)\n投递类型描述：\nType Value Description LOCAL 0 Deliver to the local router (this router) DESTINATION 1 Deliver to a destination (client) identified by hash ROUTER 2 Deliver to another router identified by hash TUNNEL 3 Deliver to a tunnel gateway router **实现说明：** - 会话密钥加密尚未实现，标志位始终为 0 - 延迟尚未完全实现，标志位始终为 0 - 对于 TUNNEL 传递，哈希标识网关 router，tunnel ID 指定哪个入站 tunnel - 对于 DESTINATION（目的地标识）传递，哈希为该 Destination 公钥的 SHA-256 - 对于 ROUTER 传递，哈希为该 router 身份的 SHA-256 I2NP 消息 适用于所有 I2NP 消息类型的完整消息规范。\n消息类型概览 Message Type Since Status DatabaseStore10.6.1.10Active DatabaseLookup20.6.1.10Active DatabaseSearchReply30.6.1.10Active DeliveryStatus100.6.1.10Active Garlic110.6.1.10Active TunnelData180.6.1.10Active TunnelGateway190.6.1.10Active Data200.6.1.10Active TunnelBuild210.6.1.10Deprecated TunnelBuildReply220.6.1.10Deprecated VariableTunnelBuild230.7.12Active VariableTunnelBuildReply240.7.12Active ShortTunnelBuild250.9.51Active OutboundTunnelBuildReply260.9.51Active **保留:** - 类型 0: 保留 - 类型 4-9: 保留供将来使用 - 类型 12-17: 保留供将来使用 - 类型 224-254: 保留用于实验性消息 - 类型 255: 保留用于未来扩展 DatabaseStore（数据库存储，类型 1） 用途： 未经请求的数据库存储，或对成功的 DatabaseLookup（数据库查询）消息的响应。\n内容： 未压缩的 LeaseSet、LeaseSet2、MetaLeaseSet 或 EncryptedLeaseSet，或压缩的 RouterInfo。\n使用回复令牌的格式：\n+----+----+----+----+----+----+----+----+ | SHA256 Hash as key (32 bytes) | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ |type| reply token (4) | reply_tunnelId +----+----+----+----+----+----+----+----+ (4) | reply gateway | +----+----+----+----+----+ + | SHA256 hash (32 bytes) | + + | | + +----+ | | +----+----+----+----+----+----+----+ | data ... +----+-// key :: 32 bytes SHA256 hash (the \u0026#34;real\u0026#34; hash, not routing key) type :: 1 byte Type identifier bit 0: 0 = RouterInfo 1 = LeaseSet or variants bits 3-1: (as of 0.9.38) 0: RouterInfo or LeaseSet (types 0 or 1) 1: LeaseSet2 (type 3) 2: EncryptedLeaseSet (type 5) 3: MetaLeaseSet (type 7) 4-7: Unsupported, invalid bits 7-4: Reserved, set to 0 reply token :: 4 bytes If greater than zero, a DeliveryStatusMessage is requested with the Message ID set to the reply token A floodfill router is also expected to flood the data to the closest floodfill peers reply_tunnelId :: 4 bytes (only if reply token \u0026gt; 0) TunnelId of the inbound gateway of the tunnel for the response If 0, reply is sent directly to reply gateway reply gateway :: 32 bytes (only if reply token \u0026gt; 0) SHA256 hash of the RouterInfo If reply_tunnelId is nonzero: inbound gateway router If reply_tunnelId is zero: router to send reply to data :: Variable length If type == 0: 2-byte Integer length + gzip-compressed RouterInfo If type == 1: Uncompressed LeaseSet If type == 3: Uncompressed LeaseSet2 If type == 5: Uncompressed EncryptedLeaseSet If type == 7: Uncompressed MetaLeaseSet 回复令牌 == 0 时的格式：\n+----+----+----+----+----+----+----+----+ | SHA256 Hash as key (32 bytes) | + + | | +----+----+----+----+----+----+----+----+ |type| 0 | data ... +----+----+----+----+----+-// 注意： - 出于安全考虑，当消息是通过某个 tunnel 接收时，将忽略回复字段 - 该 key 是 RouterIdentity（路由器标识）或 Destination（目标标识）的“真实”哈希，而不是 routing key（路由键） - 类型 3、5 和 7（LeaseSet2（LeaseSet 第二版）变体）在 0.9.38 版本（API 0.9.38）中添加。详情参见 Proposal 123 - 这些类型应仅发送给 API 版本为 0.9.38 或更高的 routers - 作为减少连接数的优化：如果类型为 LeaseSet，且包含回复令牌、回复 tunnel ID 非零，并且在该 LeaseSet 中存在与该回复网关/tunnelID 对匹配的租约，则接收方可以将回复重新路由到该 LeaseSet 中的任何其他租约 - RouterInfo（路由器信息结构）gzip 格式： 为了隐藏 router 的操作系统和实现，可通过将修改时间设为 0、OS 字节设为 0xFF，并按照 RFC 1952 将 XFL 设为 0x02（最大压缩，最慢算法），以匹配 Java router 实现。前 10 个字节：1F 8B 08 00 00 00 00 00 02 FF\n源代码： - net.i2p.data.i2np.DatabaseStoreMessage - net.i2p.data.RouterInfo (用于 RouterInfo 结构) - net.i2p.data.LeaseSet (用于 LeaseSet 结构)\nDatabaseLookup（数据库查找，类型 2） 目的： 在网络数据库（netDb）中查找某项的请求。响应要么是 DatabaseStore，要么是 DatabaseSearchReply。\n格式：\n+----+----+----+----+----+----+----+----+ | SHA256 hash as the key (32 bytes) | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ | SHA256 hash of the from router (32) | + or reply tunnel gateway + | | + + | | + + | | +----+----+----+----+----+----+----+----+ |flag| reply_tunnelId (4)| size (2)| | +----+----+----+----+----+----+----+ + | SHA256 of key1 to exclude (32 bytes) | + + | | + +----+ | | | +----+----+----+----+----+----+----+ + | SHA256 of key2 to exclude (32) | + + ~ ~ | | + +----+ | | | +----+----+----+----+----+----+----+ + | Session key if reply encryption | + requested (32 bytes) + | | + +----+ | |tags| +----+----+----+----+----+----+----+----+ | Session tags if reply encryption | + requested (variable) + ~ ~ | | +----+----+----+----+----+----+----+----+ key :: 32 bytes SHA256 hash of the object to lookup from :: 32 bytes If deliveryFlag == 0: SHA256 hash of RouterInfo (sender) If deliveryFlag == 1: SHA256 hash of reply tunnel gateway flags :: 1 byte Bit order: 76543210 bit 0: deliveryFlag 0 = send reply directly 1 = send reply to some tunnel bit 1: encryptionFlag Through 0.9.5: must be 0 As of 0.9.6: ignored As of 0.9.7: 0 = send unencrypted reply 1 = send AES encrypted reply using key and tag bits 3-2: lookup type flags Through 0.9.5: must be 00 As of 0.9.6: ignored As of 0.9.16: 00 = ANY (deprecated, use LS or RI as of 0.9.16) 01 = LS lookup (LeaseSet or variants) 10 = RI lookup (RouterInfo) 11 = exploration lookup (RouterInfo, non-floodfill) bit 4: ECIESFlag Before 0.9.46: ignored As of 0.9.46: 0 = send unencrypted or ElGamal reply 1 = send ChaCha/Poly encrypted reply using key bits 7-5: Reserved, set to 0 reply_tunnelId :: 4 bytes (only if deliveryFlag == 1) TunnelId of the tunnel to send reply to (nonzero) size :: 2 bytes Integer (valid range: 0-512) Number of peers to exclude from DatabaseSearchReply excludedPeers :: $size SHA256 hashes of 32 bytes each If lookup fails, exclude these peers from the reply If includes a hash of all zeroes, the request is exploratory (return non-floodfill routers only) reply_key :: 32 bytes (conditional, see encryption modes below) reply_tags :: 1 byte count + variable length tags (conditional) 回复加密模式：\n注意: 自 API 0.9.58 起，ElGamal routers 已弃用。由于现在推荐查询的 floodfill 最低版本为 0.9.58，各实现无需为 ElGamal floodfill routers 实现加密。ElGamal destinations（目标地址）仍然受支持。\n标志位4（ECIESFlag）与第1位（encryptionFlag）配合使用，用于确定应答的加密模式：\nFlag bits 4,1 From To Router Reply DH? Notes 0 0 Any Any No encryption n/a No encryption 0 1 ElG ElG AES No As of 0.9.7, deprecated 0.9.58 1 0 ECIES ElG AEAD No As of 0.9.46, deprecated 0.9.58 1 0 ECIES ECIES AEAD No As of 0.9.49, current standard 1 1 ElG ECIES AES Yes TBD, future 1 1 ECIES ECIES AEAD Yes TBD, future **无加密（标志位 0,0）：** reply_key、tags 和 reply_tags 不存在。\nElG（ElGamal 加密算法）到 ElG（标志 0,1） - 已弃用：\n自 0.9.7 起受支持，自 0.9.58 起已弃用。\nreply_key :: 32 byte SessionKey (big-endian) CSRNG(32) random data tags :: 1 byte Integer (1-32, typically 1) Number of reply tags that follow reply_tags :: One or more 32-byte SessionTags Each is CSRNG(32) random data ECIES（椭圆曲线集成加密方案）到 ElG（ElGamal 加密）（标志位 1,0） - 已弃用：\n自 0.9.46 起受支持，自 0.9.58 起已弃用。\nreply_key :: 32 byte ECIES SessionKey (big-endian) CSRNG(32) random data tags :: 1 byte Integer (required value: 1) Number of reply tags that follow reply_tags :: One 8-byte ECIES SessionTag CSRNG(8) random data 该回复是根据ECIES Specification 定义的 ECIES（椭圆曲线集成加密方案）Existing Session（现有会话）消息：\n+----+----+----+----+----+----+----+----+ | Session Tag (8 bytes) | +----+----+----+----+----+----+----+----+ | ChaCha20 encrypted payload | ~ ~ | | +----+----+----+----+----+----+----+----+ | Poly1305 MAC (16 bytes) | + + | | +----+----+----+----+----+----+----+----+ tag :: 8 byte reply_tag k :: 32 byte session key (the reply_key) n :: 0 (nonce) ad :: The 8 byte reply_tag payload :: Plaintext data (DSM or DSRM) ciphertext = ENCRYPT(k, n, payload, ad) ECIES（基于椭圆曲线的集成加密方案）到 ECIES (标志位 1,0) - 当前标准:\nECIES（椭圆曲线集成加密方案）目标或 router 向 ECIES router 发送一次查找请求。自 0.9.49 起受支持。\n与上面的 \u0026ldquo;ECIES to ElG\u0026rdquo; 格式相同。查找消息的加密在 ECIES Routers 中定义。请求方是匿名的。\nECIES（椭圆曲线集成加密方案）到 ECIES，使用 DH（Diffie-Hellman 密钥交换）（标志位 1,1） - 未来：\n尚未完全定义。请参阅 Proposal 156 。\n注意： - 在 0.9.16 之前，键可能对应 RouterInfo（路由器信息）或 LeaseSet（相同的键空间，无标志可区分） - 只有当响应通过 tunnel 传输时，加密的回复才有用 - 如果实现了替代的 DHT 查找策略，包含的标签数量可能大于 1 - 查找键和排除键是\u0026quot;真实\u0026quot;的哈希，而不是路由键 - 自 0.9.38 起，可能返回类型 3、5 和 7（LeaseSet2 变体）。参见 提案 123 - 探索性查找说明： 探索性查找被定义为返回一组接近该键的非 floodfill 哈希。然而，实现存在差异：Java 确实会为 RI 查找搜索键，并在存在时返回一个 DatabaseStore（数据库存储消息）；i2pd 则不会。因此，不建议对先前接收到的哈希使用探索性查找\n源代码: - net.i2p.data.i2np.DatabaseLookupMessage - 加密: net.i2p.crypto.SessionKeyManager\nDatabaseSearchReply（数据库搜索回复） (类型 3) 用途： 对失败的 DatabaseLookup（数据库查找）消息的响应。\n内容： 与所请求键最接近的 router 哈希列表。\n格式：\n+----+----+----+----+----+----+----+----+ | SHA256 hash as query key (32 bytes) | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ | num| peer_hashes (variable) | +----+ + | | ~ ~ | | + +----+----+----+----+----+----+----+ | | from (32 bytes) | +----+ + | | + + | | + + | | + +----+----+----+----+----+----+----+ | | +----+ key :: 32 bytes SHA256 of the object being searched num :: 1 byte Integer Number of peer hashes that follow (0-255) peer_hashes :: $num SHA256 hashes of 32 bytes each (total $num*32 bytes) SHA256 of the RouterIdentity that the sender thinks is close to the key from :: 32 bytes SHA256 of the RouterInfo of the router this reply was sent from 注意： - \u0026lsquo;from\u0026rsquo; 哈希未经认证，不能被信任 - 返回的对等节点哈希不一定比正在被查询的 router 更接近该键。对于常规查询的回复，这有助于发现新的 floodfills（泛洪填充节点）以及为了稳健性进行\u0026quot;反向\u0026quot;搜索（距离该键更远） - 对于探索查询，键通常是随机生成的。响应中的非-floodfill peer_hashes 可通过优化算法选择（例如，选择接近但不一定是最近的对等节点），以避免对整个本地数据库进行低效的排序。也可以使用缓存策略。这取决于具体实现 - 典型返回的哈希数量： 3 - 建议返回的哈希数量上限： 16 - 查询键、对等节点哈希以及 \u0026lsquo;from\u0026rsquo; 哈希都是\u0026quot;真实\u0026quot;的哈希，而不是 routing keys（路由键） - 如果 num 为 0，表示未找到更近的对等节点（死路）\n源代码： - net.i2p.data.i2np.DatabaseSearchReplyMessage\nDeliveryStatus (传递状态) (类型 10) 用途： 一个简单的消息确认。通常由消息发起方创建，并与消息本身一起封装在一个Garlic Message（I2P中的“蒜瓣消息”，用于将多条子消息封装为一条）中，由目的端返回。\n内容： 已投递消息的 ID 以及创建时间或到达时间。\n格式：\n+----+----+----+----+----+----+----+----+----+----+----+----+ | msg_id (4) | time_stamp (8) | +----+----+----+----+----+----+----+----+----+----+----+----+ msg_id :: Integer (4 bytes) Unique ID of the message we deliver the DeliveryStatus for (see I2NP Message Header for details) time_stamp :: Date (8 bytes) Time the message was successfully created or delivered 注意： - 时间戳始终由创建者设置为当前时间。不过，代码中对此有多处用法，将来可能会新增 - 此消息还用作 SSU 中的会话建立确认。在这种情况下，消息 ID 设置为随机数，“到达时间”设置为当前的全网 ID，即 2（即 0x0000000000000002） - DeliveryStatus（I2NP 中用于确认投递状态的消息类型）通常被包装在 GarlicMessage（I2P 的“garlic”消息封装）中，通过 tunnel 发送，以在不暴露发送者的情况下提供确认 - 用于 tunnel 测试以测量时延和可靠性\n源代码： - net.i2p.data.i2np.DeliveryStatusMessage - 用于：net.i2p.router.tunnel.InboundEndpointProcessor 进行 tunnel 测试\nGarlicMessage（类型 11） 警告： 这是用于使用 ElGamal 加密的 garlic 消息（I2P 中的聚合消息机制）的格式。ECIES-AEAD-X25519-Ratchet garlic 消息的格式有显著不同。有关现代格式，请参见 ECIES Specification 。\n用途： 用于封装多个加密的 I2NP 消息。\n内容： 解密后，由一系列 Garlic Cloves（I2P 中“Garlic”消息的子单元，指单个封装消息）及附加数据组成，也称为 Clove Set。\n加密格式：\n+----+----+----+----+----+----+----+----+ | length (4) | data | +----+----+----+----+----+ + | | ~ ~ | | +----+----+----+----+----+----+----+----+ length :: 4 byte Integer Number of bytes that follow (0 to 64 KB) data :: $length bytes ElGamal encrypted data 解密数据 (Clove Set，蒜瓣集合):\n+----+----+----+----+----+----+----+----+ | num| clove 1 (variable) | +----+ + | | ~ ~ | | +----+----+----+----+----+----+----+----+ | clove 2 (variable) | ~ ~ | | +----+----+----+----+----+----+----+----+ | Certificate (3) | Message_ID (4) | +----+----+----+----+----+----+----+----+ Expiration (8) | +----+----+----+----+----+----+----+----+ num :: 1 byte Integer Number of GarlicCloves to follow clove :: GarlicClove (see GarlicClove structure above) Certificate :: Always NULL (3 bytes total, all zeroes) Message_ID :: 4 byte Integer Expiration :: Date (8 bytes) 注意： - 未加密时，数据包含一个或多个 Garlic Cloves（Garlic 路由中的“蒜瓣”单元） - AES 加密块会填充到至少 128 字节；加上 32 字节的 Session Tag，已加密消息的最小大小为 160 字节；再加上 4 字节长度字段，Garlic Message（Garlic 路由消息）的最小大小为 164 字节 - 实际最大长度小于 64 KB（对于 tunnel 消息，实际限制约为 61.2 KB） - 参见 ElGamal/AES Specification 以了解加密细节 - 参见 Garlic Routing 以获取概念性概览 - AES 加密块的 128 字节最小尺寸目前不可配置 - 在发送时，消息 ID 通常设置为随机数，在接收时似乎会被忽略 - 证书可能用于 HashCash 来“支付”路由（未来的可能性） - ElGamal 加密结构： 32 字节 Session Tag + 经过 ElGamal 加密的会话密钥 + 经过 AES 加密的负载\n对于 ECIES-X25519-AEAD-Ratchet 格式（当前的 router 标准）：\n参见 ECIES 规范 和 提案 144 。\n源代码： - net.i2p.data.i2np.GarlicMessage - 加密：net.i2p.crypto.elgamal.ElGamalAESEngine（已弃用） - 现代加密：net.i2p.crypto.ECIES 包\nTunnelData (类型 18) 用途： 从 tunnel 的网关或参与者发送到下一个参与者或端点的消息。数据为固定长度，包含经分片、成批打包、填充并加密的 I2NP 消息。\n格式：\n+----+----+----+----+----+----+----+----+ | tunnelID (4) | data (1024) | +----+----+----+----+----+ + | | ~ ~ | | + +----+----+----+----+ | | +----+----+----+----+ tunnelId :: 4 bytes TunnelId identifying the tunnel this message is directed at Nonzero data :: 1024 bytes Payload data, fixed to 1024 bytes 有效载荷结构 (1024 字节):\nBytes 0-15: Initialization Vector (IV) for AES encryption Bytes 16-1023: Encrypted tunnel message data (1008 bytes) 注意： - 每一跳都会将 TunnelData 的 I2NP 消息 ID 设置为一个新的随机数 - tunnel 消息格式（在加密数据中）定义见 Tunnel 消息规范 - 每一跳使用 AES-256 的 CBC 模式解密一层 - 每一跳都会使用解密后的数据更新 IV（初始化向量） - 总大小恰好为 1,028 字节（4 字节的 tunnelId + 1024 字节的数据） - 这是 tunnel 流量的基本单位 - TunnelData 消息承载分片后的 I2NP 消息（GarlicMessage, DatabaseStore 等）\n源代码： - net.i2p.data.i2np.TunnelDataMessage - 常量：TunnelDataMessage.DATA_LENGTH = 1024 - 处理：net.i2p.router.tunnel.InboundGatewayProcessor\nTunnelGateway (类型 19) 用途: 在 tunnel 的入站网关处封装另一条 I2NP 消息并送入该 tunnel。\n格式：\n+----+----+----+----+----+----+----+-// | tunnelId (4) | length (2)| data... +----+----+----+----+----+----+----+-// tunnelId :: 4 bytes TunnelId identifying the tunnel this message is directed at Nonzero length :: 2 byte Integer Length of the payload data :: $length bytes Actual payload of this message 说明： - 负载是带有标准16字节头部的 I2NP 消息 - 用于将消息从本地 router 注入到 tunnels 中 - 如有必要，网关会对所含消息进行分片 - 分片后，这些分片会被封装为 TunnelData（隧道数据）消息 - TunnelGateway（隧道网关）从不在网络上传输；它是在 tunnel 处理之前使用的内部消息类型\n源代码： - net.i2p.data.i2np.TunnelGatewayMessage - 处理： net.i2p.router.tunnel.OutboundGatewayProcessor\nDataMessage（数据消息，类型 20） 用途： 由 Garlic Messages（Garlic消息，I2P中用于将多条消息打包在一起的结构）和 Garlic Cloves（Clove子消息，打包中的单元）用于封装任意数据（通常为端到端加密的应用数据）。\n格式：\n+----+----+----+----+----+----+-//-+ | length (4) | data... | +----+----+----+----+----+----+-//-+ length :: 4 bytes Length of the payload data :: $length bytes Actual payload of this message 注意： - 此消息不包含路由信息，且绝不会以\u0026quot;未封装\u0026quot;的形式发送 - 仅在 Garlic messages（Garlic 消息）内部使用 - 通常包含端到端加密的应用数据（HTTP、IRC、电子邮件等） - 数据通常是 ElGamal/AES 或 ECIES 加密的有效载荷 - 由于 tunnel 消息分片限制，最大实际长度约为 61.2 KB\n源代码： - net.i2p.data.i2np.DataMessage\nTunnelBuild (类型 21) 已弃用。 请使用 VariableTunnelBuild（类型 23）或 ShortTunnelBuild（类型 25）。\n目的： 8 跳的固定长度 tunnel 构建请求。\n格式：\n+----+----+----+----+----+----+----+----+ | Record 0 (528 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ | Record 1 (528 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ | Record 7 (528 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ Just 8 BuildRequestRecords attached together Record size: 528 bytes Total size: 8 × 528 = 4,224 bytes 注意事项： - 自 0.9.48 起，可能包含 ECIES-X25519 BuildRequestRecords（构建请求记录）。详见 ECIES Tunnel 创建 - 详见 Tunnel 创建规范 - 此消息的 I2NP message ID 必须按照 Tunnel 创建规范进行设置 - 尽管在当前网络中很少见（已被 VariableTunnelBuild（可变长度 Tunnel 构建消息）取代），它仍可能用于非常长的 tunnels，且尚未被正式弃用 - 为了兼容性，Routers 仍必须实现此功能 - 固定的 8-记录格式缺乏灵活性，并会在较短的 tunnels 上浪费带宽\n源代码： - net.i2p.data.i2np.TunnelBuildMessage - 常量：TunnelBuildMessageBase.MAX_RECORD_COUNT = 8\nTunnelBuildReply（类型 22） 已弃用。 使用 VariableTunnelBuildReply (类型 24) 或 OutboundTunnelBuildReply (类型 26)。\n用途: 固定长度的 tunnel 构建回复，适用于 8 个跳点。\n格式：\n格式与 TunnelBuildMessage 相同，但使用 BuildResponseRecords 代替 BuildRequestRecords。\nTotal size: 8 × 528 = 4,224 bytes 注意事项： - 自 0.9.48 起，可能包含 ECIES-X25519 BuildResponseRecords（构建响应记录）。参见 ECIES Tunnel 创建 - 详见 Tunnel 创建规范 - 此消息的 I2NP 消息 ID 必须按照 Tunnel 创建规范进行设置 - 虽然在当前网络中很少见（已被 VariableTunnelBuildReply（可变 Tunnel 构建回复）取代），但它仍可能用于非常长的 tunnel，且尚未被正式弃用 - Routers 仍须实现以保持兼容性\n源代码: - net.i2p.data.i2np.TunnelBuildReplyMessage\nVariableTunnelBuild (类型 23) 目的： 适用于 1-8 跳的可变长度的 tunnel 构建。同时支持 ElGamal 和 ECIES-X25519 routers。\n格式：\n+----+----+----+----+----+----+----+----+ | num| BuildRequestRecords (variable) | +----+----+----+----+----+----+----+----+ num :: 1 byte Integer Valid values: 1-8 BuildRequestRecords :: $num records of 528 bytes each Record size: 528 bytes Total size: 1 + ($num × 528) bytes 说明： - 自 0.9.48 起，可能包含 ECIES-X25519 BuildRequestRecords。参见 ECIES Tunnel Creation - 在 router 版本 0.7.12 (2009 年) 中引入 - 不应发送给版本早于 0.7.12 的 tunnel 参与者 - 详情参见 Tunnel Creation Specification - I2NP message ID 必须根据 tunnel 创建规范进行设置 - 典型记录数： 4 (用于 4 跳 tunnel) - 典型总大小： 1 + (4 × 528) = 2,113 字节 - 这是适用于 ElGamal routers 的标准 tunnel 构建消息 - ECIES routers 通常改用 ShortTunnelBuild (type 25)\n源代码： - net.i2p.data.i2np.VariableTunnelBuildMessage\nVariableTunnelBuildReply (类型 24) 目的： 用于 1-8 跳的可变长度 tunnel 构建应答。支持 ElGamal 和 ECIES-X25519 routers。\n格式：\n与 VariableTunnelBuildMessage 格式相同，使用 BuildResponseRecords 而非 BuildRequestRecords。\n+----+----+----+----+----+----+----+----+ | num| BuildResponseRecords (variable) | +----+----+----+----+----+----+----+----+ num :: 1 byte Integer Valid values: 1-8 BuildResponseRecords :: $num records of 528 bytes each Record size: 528 bytes Total size: 1 + ($num × 528) bytes 注意： - 自 0.9.48 起，可能包含 ECIES-X25519 BuildResponseRecords（构建响应记录）。参见 ECIES Tunnel Creation - 于 router 版本 0.7.12（2009 年）引入 - 不应发送给版本早于 0.7.12 的 tunnel 参与者 - 参见 Tunnel Creation Specification 获取详细信息 - 必须根据 Tunnel 创建规范设置 I2NP 消息 ID - 典型记录数： 4 - 典型总大小： 2,113 字节\n源代码： - net.i2p.data.i2np.VariableTunnelBuildReplyMessage\nShortTunnelBuild（短 tunnel 构建，类型 25） 用途： 仅针对 ECIES-X25519 routers 的简短 tunnel 构建消息。于 API 版本 0.9.51（发布 1.5.0，2021 年 8 月）中引入。这是 ECIES（椭圆曲线集成加密方案） tunnel 构建的现行标准。\n格式:\n+----+----+----+----+----+----+----+----+ | num| ShortBuildRequestRecords (var) | +----+----+----+----+----+----+----+----+ num :: 1 byte Integer Valid values: 1-8 ShortBuildRequestRecords :: $num records of 218 bytes each Record size: 218 bytes Total size: 1 + ($num × 218) bytes 源代码： - net.i2p.data.i2np.ShortTunnelBuildMessage - 常量：ShortEncryptedBuildRecord.RECORD_SIZE = 218\nOutboundTunnelBuildReply（出站 tunnel 构建应答，类型 26） 用途： 从新的 tunnel 的出站端点发送给发起方。仅适用于 ECIES-X25519 routers。在 API 版本 0.9.51 中引入（发行版 1.5.0，2021 年 8 月）。\n格式：\n与 ShortTunnelBuildMessage 相同的格式，其中使用 ShortBuildResponseRecords 而不是 ShortBuildRequestRecords。\n+----+----+----+----+----+----+----+----+ | num| ShortBuildResponseRecords (var) | +----+----+----+----+----+----+----+----+ num :: 1 byte Integer Valid values: 1-8 ShortBuildResponseRecords :: $num records of 218 bytes each Record size: 218 bytes Total size: 1 + ($num × 218) bytes 说明： - 在 router 版本 0.9.51（发行版 1.5.0，2021 年 8 月）中引入 - 完整规范见 ECIES Tunnel Creation - 典型记录数量： 4 - 典型总大小： 873 字节 - 该回复由出站端点（OBEP）通过新创建的出站 tunnel 发送回 tunnel 创建者 - 用于确认所有跳点已接受该 tunnel 构建\n源代码: - net.i2p.data.i2np.OutboundTunnelBuildReplyMessage\n参考资料 官方规范 I2NP 规范 - 完整的 I2NP 消息格式规范 通用结构 - I2P 中使用的数据类型和结构 Tunnel 创建 - ElGamal 的 Tunnel 创建（已弃用） ECIES Tunnel 创建 - ECIES-X25519 的 Tunnel 创建（当前） Tunnel 消息 - Tunnel 消息格式与传递说明 NTCP2 规范 - TCP 传输协议 SSU2 规范 - UDP 传输协议 ECIES 规范 - ECIES-X25519-AEAD-Ratchet 加密 密码学规范 - 底层密码学原语 I2CP 规范 - 客户端协议规范 数据报规范 - Datagram2 和 Datagram3 格式 提案 提案 123 - 新的 netDB 条目 (LeaseSet2、EncryptedLeaseSet、MetaLeaseSet) 提案 144 - ECIES-X25519-AEAD-Ratchet 加密 提案 154 - 加密的数据库查询 提案 156 - ECIES routers 提案 157 - 更小的 tunnel 构建消息 (短格式) 提案 159 - SSU2 传输 提案 161 - 可压缩填充 提案 163 - Datagram2 和 Datagram3 提案 167 - LeaseSet 服务记录参数 提案 168 - Tunnel 构建带宽参数 提案 169 - 后量子混合密码学 文档 Garlic Routing （I2P 中的分层式消息打包与路由技术） - 分层消息捆绑 ElGamal/AES - 已弃用的加密方案 Tunnel 实现 - 分片与处理 网络数据库（netDb） - 分布式哈希表 NTCP2 传输 - TCP 传输规范 SSU2 传输 - UDP 传输规范 技术简介 - I2P 架构概览 源代码 Java I2P 代码仓库 - 官方 Java 实现 GitHub 镜像 - Java I2P 的 GitHub 镜像 i2pd 代码仓库 - C++ 实现 关键源代码位置 Java I2P (i2pgit.org/I2P_Developers/i2p.i2p): - core/java/src/net/i2p/data/i2np/ - I2NP 消息实现 - core/java/src/net/i2p/crypto/ - 加密实现 - router/java/src/net/i2p/router/tunnel/ - tunnel 处理 - router/java/src/net/i2p/router/transport/ - 传输实现\n常量与数值： - I2NPMessage.MAX_SIZE = 65536 - I2NP 消息的最大大小 - I2NPMessageImpl.HEADER_LENGTH = 16 - 标准头部大小 - TunnelDataMessage.DATA_LENGTH = 1024 - Tunnel 消息负载 - EncryptedBuildRecord.RECORD_SIZE = 528 - 长构建记录 - ShortEncryptedBuildRecord.RECORD_SIZE = 218 - 短构建记录 - TunnelBuildMessageBase.MAX_RECORD_COUNT = 8 - 每次构建的最大记录数\n附录 A：网络统计与当前状态 网络组成（截至 2025 年 10 月） routers 总数： 大约 60,000-70,000（有波动） Floodfill routers: 大约 500-700 个活跃 加密类型： ECIES-X25519：\u0026gt;95% 的 routers ElGamal：\u0026lt;5% 的 routers（已弃用，仅遗留用途） 传输采用情况： SSU2：\u0026gt;60% 为主要传输 NTCP2：~40% 为主要传输 旧版传输（SSU1、NTCP）：0%（已移除） 签名类型： EdDSA (Ed25519)：绝大多数 ECDSA：占比较小 RSA：不允许（已移除） Router 的最低要求 API 版本： 0.9.16+ (用于与网络保持 EdDSA 兼容性) 建议的最低版本： API 0.9.51+ (ECIES 短 tunnel 构建) 适用于 floodfills 的当前最低版本： API 0.9.58+ (ElGamal router 弃用) 即将生效的要求： Java 17+ (自 2.11.0 版本起，2025 年 12 月) 带宽要求 最低要求： 128 KBytes/sec（N 标志或更高），用于 floodfill 推荐： 256 KBytes/sec（O 标志）或更高 Floodfill 要求： 最低 128 KB/sec 带宽 稳定的在线率（建议 \u0026gt;95%） 低延迟（与对等节点 \u0026lt;500ms） 通过健康检查（队列时间、作业延迟） Tunnel 统计信息 典型 tunnel 长度: 3-4 跳 最大 tunnel 长度: 8 跳 (理论值，极少使用) 典型 tunnel 生命周期: 10 分钟 tunnel 构建成功率: \u0026gt;85%，适用于连接良好的 routers tunnel 构建消息格式: ECIES routers: ShortTunnelBuild (218 字节记录) 混合 tunnels: VariableTunnelBuild (528 字节记录) 性能指标 Tunnel 构建时间: 1-3 秒 (典型) 端到端延迟: 0.5-2 秒 (典型，总计 6-8 跳) 吞吐量: 受 tunnel 带宽限制 (通常每个 tunnel 为 10-50 KB/sec) 最大数据报大小: 建议 10 KB (理论最大值 61.2 KB) 附录 B：已弃用和已移除的功能 已完全移除（不再受支持） NTCP 传输协议 - 已在 0.9.50 版本中移除（2021 年 5 月） SSU v1 传输协议 - 已在 Java I2P 的 2.4.0 版本中移除（2023 年 12 月） SSU v1 传输协议 - 已在 i2pd 的 2.44.0 版本中移除（2022 年 11 月） RSA 签名类型 - 自 API 0.9.28 起不再允许 已弃用（受支持但不建议使用） ElGamal routers - 自 API 0.9.58 (2023 年 3 月) 起已弃用 仍支持 ElGamal 目的地，以保持向后兼容性 新的 routers 应仅使用 ECIES-X25519 TunnelBuild (类型 21) - 已弃用，改为使用 VariableTunnelBuild 和 ShortTunnelBuild 仍对超长 tunnels (\u0026gt;8 跳) 提供实现 TunnelBuildReply (类型 22) - 已弃用，改为使用 VariableTunnelBuildReply 和 OutboundTunnelBuildReply ElGamal/AES 加密 - 已弃用，改为使用 ECIES-X25519-AEAD-Ratchet 仍用于旧版目的地 Long ECIES BuildRequestRecords (528 字节) - 已弃用，改为使用短格式 (218 字节) 仍用于包含 ElGamal 跳点的混合 tunnels 旧版支持时间线 Feature Introduced Deprecated Removed Notes NTCP 2003 2018 (0.9.36) 2021 (0.9.50) Replaced by NTCP2 SSU v1 2004 2022 (0.9.54) 2023 (Java) / 2022 (i2pd) Replaced by SSU2 ElGamal routers 2003 2023 (0.9.58) TBD Destinations still supported RSA signatures 2015 2017 2017 (0.9.28) Never widely used TunnelBuild 2004 2009 (0.7.12) Not removed Still supported for long tunnels --- 附录 C：未来发展 后量子密码学 状态： 自 2.10.0 版本（2025 年 9 月）起为 Beta，将在 2.11.0（2025 年 12 月）中成为默认\n实现: - 混合方案，结合传统的 X25519 与后量子的 MLKEM (ML-KEM-768) - 与现有的 ECIES-X25519 基础设施保持向后兼容 - 使用 Signal Double Ratchet (Signal 双棘轮)，并同时采用传统和 PQ (后量子) 密钥材料 - 详情参见 Proposal 169 迁移路径： 1. 版本 2.10.0 (2025 年 9 月)：作为测试版选项提供 2. 版本 2.11.0 (2025 年 12 月)：默认启用 3. 未来版本：最终将成为必需\n计划中的功能 IPv6 改进 - 更好的 IPv6 支持和过渡机制 每个 tunnel 限速 - 针对每个 tunnel 的细粒度带宽控制 增强的度量指标 - 更好的性能监控和诊断 协议优化 - 降低开销并提升效率 改进的 floodfill 选择 - 更好的网络数据库分布 研究领域 Tunnel 长度优化 - 基于威胁模型的动态 tunnel 长度 高级填充 - 提升对流量分析的抵抗能力 新的加密方案 - 为量子计算威胁做准备 拥塞控制 - 更好地处理网络负载 移动端支持 - 针对移动设备和网络的优化 附录 D：实现指南 面向新实现 最低要求： 1. 支持 API 版本 0.9.51+ 的特性 2. 实现 ECIES-X25519-AEAD-Ratchet 加密 3. 支持 NTCP2 和 SSU2 传输协议 4. 实现 ShortTunnelBuild 消息（218 字节记录） 5. 支持 LeaseSet2 变体（类型 3、5、7） 6. 使用 EdDSA 签名（Ed25519）\n推荐： 1. 支持后量子混合密码学 (自 2.11.0 起) 2. 实现每个 tunnel(隧道) 的带宽参数 3. 支持 Datagram2 和 Datagram3 格式(数据报) 4. 在 LeaseSets(租约集) 中实现服务记录选项 5. 遵循 /docs/specs/ 上的官方规范\n非必需： 1. ElGamal router 支持（已弃用） 2. 旧版传输支持（SSU1, NTCP） 3. Long ECIES BuildRequestRecords（构建请求记录）（用于纯 ECIES tunnels 的 528 字节） 4. TunnelBuild/TunnelBuildReply 消息（使用 Variable 或 Short 变体）\n测试与验证 协议符合性: 1. 测试与官方 Java I2P router 的互操作性 2. 测试与 i2pd C++ router 的互操作性 3. 根据规范验证消息格式 4. 测试 tunnel 建立/拆除循环 5. 使用测试向量验证加密/解密\n性能测试： 1. 测量 tunnel 构建成功率（应 \u0026gt;85%） 2. 使用不同的 tunnel 长度进行测试（2-8 跳） 3. 验证分片与重组 4. 在负载下进行测试（多个并发的 tunnels） 5. 测量端到端延迟\n安全测试： 1. 验证加密实现 (使用测试向量) 2. 测试重放攻击防护 3. 验证消息过期处理 4. 针对格式错误的消息进行测试 5. 验证随机数生成的正确性\n常见实现陷阱 令人困惑的投递指令格式 - garlic clove（蒜瓣子消息）与 tunnel 消息 错误的密钥派生 - 短构建记录的 HKDF 用法 消息 ID 处理 - 在 tunnel 构建中未正确设置 分片问题 - 未遵守 61.2 KB 的实际限制 字节序错误 - Java 对所有整数使用大端序 过期处理 - 短格式将在 2106 年 2 月 7 日回绕 校验和生成 - 即使不验证也仍然需要 ","description":"I2P 内部 router 之间的消息格式、优先级和大小限制。","id":"917124900b0896942323b4effccf9b55","section":"docs","title":"I2P 网络协议 (I2NP)","url":"/zh/docs/specs/i2np/"},{"categories":null,"content":"1. \u0026ldquo;匿名\u0026quot;的含义 I2P 提供实用匿名性，而非隐身。匿名性被定义为对手难以获取您希望保密的信息：您是谁、您在哪里或您与谁交流。绝对匿名是不可能的；相反，I2P 旨在在全球被动和主动对手面前提供足够的匿名性。\n您的匿名性取决于您如何配置 I2P、如何选择节点和订阅，以及您暴露哪些应用程序。\n2. 密码学与传输演进（2003 → 2025） Era Primary Algorithms Notes 0.3 – 0.9 ElGamal + AES-256 + DSA-SHA1 Legacy stack (2003–2015) 0.9.15 Ed25519 signatures Replaced DSA 0.9.36 (2018) NTCP2 introduced Noise XK_25519_ChaChaPoly_SHA256 0.9.56 (2022) SSU2 enabled by default Noise-based UDP transport 2.4.0 (2023) NetDB Sub-DB isolation Prevents router↔client linkage 2.8.0+ (2025) Congestion-aware routing / observability reductions DoS hardening 2.10.0 (2025) Post-quantum hybrid ML-KEM support (optional) Experimental **当前加密套件 (Noise XK)：** - **X25519** 用于密钥交换 - **ChaCha20/Poly1305 AEAD** 用于加密 - **Ed25519 (EdDSA-SHA512)** 用于签名 - **SHA-256** 用于哈希和 HKDF - 可选 **ML-KEM 混合模式** 用于后量子测试 所有 ElGamal 和 AES-CBC 的使用已被淘汰。传输完全采用 NTCP2（TCP）和 SSU2（UDP）；两者均支持 IPv4/IPv6、前向保密和 DPI 混淆。\n3. 网络架构概述 自由路由混合网络: 发送者和接收者各自定义自己的 tunnel。 无中心权威: 路由和命名是去中心化的;每个 router 维护本地信任。 单向 tunnel: 入站和出站是分开的(10分钟生命周期)。 探索性 tunnel: 默认2跳; 客户端 tunnel 2-3跳。 Floodfill router: 约55,000个节点中的约1,700个(约6%)维护分布式 NetDB。 NetDB 轮换: 密钥空间在UTC午夜每日轮换。 子数据库隔离: 自2.4.0版本起,每个客户端和 router 使用单独的数据库以防止关联。 4. 攻击类别与现有防御措施 Category Current Status (2025) Primary Defenses Brute Force / Cryptanalysis Impractical with modern primitives (X25519, ChaCha20). Strong crypto, key rotation, Noise handshakes. Timing Attacks Still unsolved for low-latency systems. Unidirectional tunnels, 1024\u0026nbsp;B cells, profile recalc (45\u0026nbsp;s). Research continues for non-trivial delays (3.0+). Intersection Attacks Inherent weakness of low latency mixnets. Tunnel rotation (10\u0026nbsp;min), leaseset expirations, multihoming. Predecessor Attacks Partially mitigated. Tiered peer selection, strict XOR ordering, variable length tunnels. Sybil Attacks No comprehensive defense. IP /16 limits, profiling, diversity rules; HashCash infra exists but not required. Floodfill / NetDB Attacks Improved but still a concern. One /16 per lookup, limit 500 active, daily rotation, randomized verification delay, Sub-DB isolation. DoS / Flooding Frequent (esp. 2023 incidents). Congestion-aware routing (2.4+), aggressive leaseset removal (2.8+). Traffic ID / Fingerprinting Greatly reduced. Noise obfuscation, random padding, no plaintext headers. Censorship / Partitioning Possible with state-level blocking. Hidden mode, IPv6, multiple reseeds, mirrors. Development / Supply Chain Mitigated. Open source, signed SU3 releases (RSA-4096), multi-signer trust model. --- 5. 现代网络数据库（NetDB） 核心事实（仍然准确）： - 修改版 Kademlia DHT 存储 RouterInfo 和 LeaseSet。 - SHA-256 密钥哈希；向 2 个最近的 floodfill 并行查询，超时时间为 10 秒。 - LeaseSet 生命周期约为 10 分钟（LeaseSet2）或 18 小时（MetaLeaseSet）。\n新类型(自 0.9.38 起): - LeaseSet2 (类型 3) – 支持多种加密类型,带时间戳。 - EncryptedLeaseSet2 (类型 5) – 用于私密服务的盲化目标地址(DH 或 PSK 认证)。 - MetaLeaseSet (类型 7) – 多宿主和扩展过期时间。\n重大安全升级 – Sub-DB 隔离 (2.4.0)： - 防止 router 与客户端关联。 - 每个客户端和 router 使用独立的 netDb 分段。 - 已验证和审计 (2.5.0)。\n6. 隐藏模式和受限路由 Hidden Mode（隐藏模式）： 已实现（根据自由之家评分在严格国家自动启用）。\nRouter 不发布 RouterInfo 或转发流量。 Restricted Routes（受限路由）： 部分实现（仅基本的信任节点 tunnel）。\n全面的可信对等节点路由仍在计划中（3.0+）。 权衡：更好的隐私 ↔ 减少对网络容量的贡献。\n7. DoS 和 Floodfill 攻击 历史背景： 2013年加州大学圣巴巴拉分校的研究表明Eclipse攻击和Floodfill接管是可能的。现代防御措施包括： - 每日密钥空间轮换。 - Floodfill上限约500个，每个/16网段一个。 - 随机化存储验证延迟。 - 优先选择较新的router（2.6.0版本）。 - 自动注册修复（2.9.0版本）。 - 拥塞感知路由和lease节流（2.4.0+版本）。\nFloodfill 攻击在理论上仍然可能,但在实践中更加困难。\n8. 流量分析与审查 I2P 流量难以识别:没有固定端口,没有明文握手,并且使用随机填充。NTCP2 和 SSU2 数据包模仿常见协议并使用 ChaCha20 头部混淆。填充策略是基础的(随机大小),虚拟流量未实现(成本高)。自 2.6.0 版本起阻止来自 Tor 出口节点的连接(以保护资源)。\n9. 持久性限制（已确认） 低延迟应用的时间关联攻击仍然是一个基本风险。 针对已知公共目的地的交集攻击依然强大。 Sybil 攻击缺乏完整防御(HashCash 未强制执行)。 恒定速率流量和非平凡延迟仍未实现(计划于 3.0 版本)。 关于这些限制的透明性是有意为之的——它可以防止用户高估匿名性。\n10. 网络统计 (2025) 全球约 55,000 个活跃 router（2013 年时为 7,000 个，呈上升趋势） 约 1,700 个 floodfill router（占比约 6%） 默认情况下 95% 参与 tunnel 路由 带宽等级：K（\u0026lt;12 KB/s）→ X（\u0026gt;2 MB/s） Floodfill 最低速率要求：128 KB/s Router 控制台需要 Java 8+（必需），下一周期计划支持 Java 17+ 11. 开发与核心资源 官方网站：geti2p.net 文档：Documentation Debian 仓库：https://deb.i2pgit.org （2023年10月替代了 deb.i2p2.de） 源代码：https://i2pgit.org/I2P_Developers/i2p.i2p （Gitea）+ GitHub 镜像 所有发布版本均为签名的 SU3 容器（RSA-4096，zzz/str4d 密钥） 无活跃邮件列表；社区通过 https://i2pforum.net 和 IRC2P 交流。 更新周期：每 6-8 周发布稳定版本。 12. 自 0.8.x 以来的安全改进总结 Year Feature Effect 2015 Ed25519 signatures Removed SHA1/DSA weakness 2018 NTCP2 Noise-based TCP transport 2019 LeaseSet2 / EncryptedLeaseSet2 Hidden services privacy 2022 SSU2 Noise-based UDP transport 2023 Sub-DB Isolation + Congestion-Aware Routing Stopped NetDB linkage / improved resilience 2024 Floodfill selection improvements Reduced long-term node influence 2025 Observability reductions + PQ hybrid crypto Harder timing analysis / future-proofing --- 13. 已知未解决或计划中的工作 全面的受限路由(可信对等节点路由) → 计划3.0版本。 用于抵抗时序分析的非平凡延迟/批处理 → 计划3.0版本。 高级填充和虚拟流量 → 未实现。 HashCash身份验证 → 基础设施已存在但未激活。 R5N DHT替代方案 → 仅有提案。 14. 重要参考资料 Practical Attacks Against the I2P Network (Egger et al., RAID 2013) Privacy Implications of Performance-Based Peer Selection (Herrmann \u0026amp; Grothoff, PETS 2011) Resilience of the Invisible Internet Project (Muntaka et al., Wiley 2025) I2P 官方文档 15. 结论 I2P的核心匿名模型已经坚持了二十年：为了本地信任和安全性而放弃全局唯一性。从ElGamal到X25519，从NTCP到NTCP2，从手动reseed到Sub-DB隔离，该项目在不断演进的同时始终保持其深度防御和透明性的理念。\n许多针对任何低延迟混合网络的攻击在理论上仍然是可能的,但 I2P 的持续加固使它们变得越来越不切实际。该网络比以往任何时候都更大、更快、更安全——但仍然坦诚地面对其局限性。\n","description":"I2P 设计中考虑的攻击目录及其缓解措施","id":"8433fa179e266d091a906a9059db53f4","section":"docs","title":"I2P 威胁模型","url":"/zh/docs/overview/threat-model/"},{"categories":null,"content":"目的: 确保 I2P 技术文档的一致性、准确性和可访问性\n核心原则 1. 验证一切 切勿臆测或猜测。 所有技术陈述都必须依据以下内容进行核验： - 当前的 I2P 源代码 (https://i2pgit.org/I2P_Developers/i2p.i2p/src/branch/master ) - 官方 API 文档 (https://i2p.github.io/i2p.i2p/ - 配置规范 /docs/specs/ - 最新发行说明 /releases/ 正确验证的示例：\n❌ BAD: \u0026#34;The ClientApp interface probably requires three constructor parameters.\u0026#34; ✅ GOOD: \u0026#34;The ClientApp interface requires this constructor signature: public MyClientApp(I2PAppContext context, ClientAppManager manager, String[] args)\u0026#34; 2. 清晰优先于简洁 写给可能第一次接触 I2P 的开发者。不要假定读者已有相关知识，应当完整、充分地解释各个概念。\n示例：\n❌ BAD: \u0026#34;Use the port mapper for service discovery.\u0026#34; ✅ GOOD: \u0026#34;The port mapper offers a simple directory for internal TCP services. Register loopback ports so other applications can discover your service without hardcoded addresses.\u0026#34; 3. 无障碍优先 尽管 I2P 是一个叠加网络，文档仍必须在明网（常规互联网）上对开发者可用。请始终为 I2P 内部资源提供可在明网访问的替代方案。\n技术准确性 API 与接口文档 务必包含： 1. 首次出现时使用完整的包名：net.i2p.app.ClientApp 2. 包含返回类型的完整方法签名 3. 参数名称和类型 4. 必需参数与可选参数\n示例：\nThe `startup()` method has signature `void startup() throws IOException` and must execute without blocking. The method must call `ClientAppManager.notify()` at least once to transition from INITIALIZED state. 配置属性 在编写配置文件文档时：\n显示精确的属性名称 指定文件编码（I2P 配置文件使用 UTF-8） 提供完整的示例 记录默认值 注明属性引入/更改的版本 示例：\n### clients.config Properties **Required:** - `clientApp.N.main` - Full class name (no default) **Optional:** - `clientApp.N.delay` - Seconds before starting (default: 120) - `clientApp.N.onBoot` - Forces delay=0 if true (default: false, added in 0.9.4) 常量和枚举 在为常量编写文档时，请使用代码中的真实名称：\n❌ BAD: \u0026#34;Common registrations include console, i2ptunnel, Jetty, sam, and bob\u0026#34; ✅ GOOD: \u0026#34;Common port mapper service constants from `net.i2p.util.PortMapper`: - `SVC_CONSOLE` - Router console (default port 7657) - `SVC_HTTP_PROXY` - HTTP proxy (default port 4444) - `SVC_SAM` - SAM bridge (default port 7656)\u0026#34; 区分相似概念 I2P 包含多个相互重叠的系统。撰写文档时务必明确你所描述的是哪个系统：\n示例：\nNote that client registry and port mapper are separate systems: - **ClientAppManager registry** enables inter-application communication by name lookup - **PortMapper** maps service names to host:port combinations for service discovery - **i2ptunnel tunnel types** are configuration values (tunnel.N.type), not service registrations 文档链接与参考资料 URL 可访问性规则 主要参考 应使用可从明网访问的 URL I2P 内部 URL (.i2p 域名) 必须包含可访问性说明 始终提供替代方案，在链接 I2P 内部资源时 I2P 内部 URL 模板:\n\u0026gt; **Note:** The I2P network hosts comprehensive documentation at http://idk.i2p/javadoc-i2p/ \u0026gt; which requires an I2P router for access. For clearnet access, use the GitHub Pages \u0026gt; mirror at https://eyedeekay.github.io/javadoc-i2p/ 推荐的 I2P 参考链接 官方规范： - 配置 - 插件 - 文档索引 API 文档（选择最新的）： - 最新: https://i2p.github.io/i2p.i2p/ (在 I2P 2.10.0 中为 API 0.9.66) - 明网镜像: https://eyedeekay.github.io/javadoc-i2p/ 源代码: - GitLab (官方): https://i2pgit.org/I2P_Developers/i2p.i2p/src/branch/master - GitHub 镜像: https://github.com/i2p/i2p.i2p 链接格式标准 ✅ GOOD: [ClientApp Javadoc](https://i2p.github.io/i2p.i2p/net/i2p/app/ClientApp.html) ✅ GOOD: [Configuration Specification](https://geti2p.net/spec/configuration) ❌ BAD: See the ClientApp docs at http://idk.i2p/... ❌ BAD: [link](url) with no descriptive text 版本跟踪 文档元数据 每份技术文档都应在 frontmatter（文档头部）中包含版本元数据：\n--- title: \u0026#34;Document Title\u0026#34; description: \u0026#34;Brief description\u0026#34; slug: \u0026#34;url-slug\u0026#34; lastUpdated: \u0026#34;2025-10\u0026#34; accurateFor: \u0026#34;2.10.0\u0026#34; reviewStatus: \u0026#34;verified\u0026#34; --- 字段定义: - lastUpdated: 文档上次审阅/更新的年月 - accurateFor: 该文档已核对所对应的 I2P 版本 - reviewStatus: 取值之一：\u0026ldquo;draft\u0026rdquo;、\u0026ldquo;needs-review\u0026rdquo;、\u0026ldquo;verified\u0026rdquo;、\u0026ldquo;outdated\u0026rdquo;\n内容中的版本引用 在提及版本时: 1. 对当前版本使用加粗: \u0026ldquo;版本 2.10.0 (2025年9月)\u0026rdquo; 2. 历史参考中应同时注明版本号和日期 3. 在相关情况下，将 API 版本与 I2P 版本分开注明\n示例：\nManaged clients were introduced in **version 0.9.4** (December 17, 2012) and remain the recommended architecture as of **version 2.10.0** (September 9, 2025). The current API version is **0.9.66**. 记录随时间推移的变更 对于已经演进的特性：\n**Version history:** - **0.9.4 (December 2012)** - Managed clients introduced - **0.9.42 (2019)** - clients.config.d/ directory structure added - **1.7.0 (2021)** - ShellService added for external program tracking - **2.10.0 (September 2025)** - Current release, no API changes to managed clients 弃用通知 如果为已弃用功能编写文档：\n\u0026gt; **Deprecated:** This feature was deprecated in version X.Y.Z and will be removed \u0026gt; in version A.B.C. Use [alternative feature](link) instead. 术语标准 I2P 官方术语 请始终一致地使用这些确切术语：\nCorrect Term Avoid I2P router I2P node, I2P client (ambiguous) eepsite I2P website, hidden service (Tor term) tunnel connection, circuit (Tor term) netDb network database, DHT lease set destination info destination address, endpoint base64 destination I2P address, .i2p address ### 托管客户端术语 在为受管客户端撰写文档时：\nUse This Not This managed client managed application unmanaged client legacy client, static client ClientAppManager application manager, client manager lifecycle methods state methods, control methods client registry application registry, name service port mapper port registry, service directory ### 配置术语 Correct Incorrect clients.config clients.cfg, client.config clients.config.d/ clients.d/, config.d/ router.config router.cfg i2ptunnel.config tunnel.config ### 包和类名 首次提及时始终使用全称，此后使用简称：\nThe `net.i2p.app.ClientApp` interface requires implementation of three lifecycle methods. When a ClientApp starts, the manager calls `startup()`... 代码示例与格式 Java 代码示例 使用正确的语法高亮和完整的示例：\n### Example: Registering with Port Mapper \\`\\`\\`java // Register HTTP proxy service context.portMapper().register( PortMapper.SVC_HTTP_PROXY, \u0026#34;127.0.0.1\u0026#34;, 4444 ); // Later, retrieve the port int port = context.portMapper().getPort(PortMapper.SVC_HTTP_PROXY); if (port == -1) { // Service not registered } \\`\\`\\` 代码示例要求： 1. 包含注释以解释关键代码行 2. 在相关处展示错误处理 3. 使用贴近实际的变量名 4. 符合 I2P 编码约定 (4 空格缩进) 5. 若上下文不明显，请展示导入语句\n配置示例 展示完整、有效的配置示例：\n### Example: clients.config.d/ Entry File: `clients.config.d/00-console.config` \\`\\`\\`properties # Router console configuration clientApp.0.main=net.i2p.router.web.RouterConsoleRunner clientApp.0.name=Router Console clientApp.0.args=7657 ::1,127.0.0.1 ./webapps/ clientApp.0.delay=0 clientApp.0.onBoot=true \\`\\`\\` 命令行示例 用户命令使用 $，root 使用 #：\n\\`\\`\\`bash # Install I2P on Debian/Ubuntu $ sudo apt-get install i2p # Start the router $ i2prouter start \\`\\`\\` 行内代码 对以下内容使用反引号： - 方法名: startup() - 类名: ClientApp - 属性名: clientApp.0.main - 文件名: clients.config - 常量: SVC_HTTP_PROXY - 包名: net.i2p.app\n语气与文风 专业而易懂 面向技术受众撰写，避免居高临下：\n❌ BAD: \u0026#34;Obviously, you should implement the startup() method.\u0026#34; ✅ GOOD: \u0026#34;Managed clients must implement the startup() method to initialize resources.\u0026#34; ❌ BAD: \u0026#34;Even a junior dev knows you need to call notify().\u0026#34; ✅ GOOD: \u0026#34;The manager requires at least one notify() call during startup to track state transitions.\u0026#34; 主动语态 为清晰起见，请使用主动语态：\n❌ PASSIVE: \u0026#34;The ClientAppManager is notified by the client when state changes.\u0026#34; ✅ ACTIVE: \u0026#34;The client notifies ClientAppManager when state changes.\u0026#34; 用于指令的祈使句 在步骤性内容中使用直接祈使语气：\n✅ \u0026#34;Implement these three lifecycle methods:\u0026#34; ✅ \u0026#34;Call manager.notify() after changing state.\u0026#34; ✅ \u0026#34;Register services using context.portMapper().register()\u0026#34; 避免不必要的术语 首次出现时解释术语：\n✅ GOOD: \u0026#34;The netDb (network database) stores information about I2P routers and destinations.\u0026#34; ❌ BAD: \u0026#34;Query the netDb for peer info.\u0026#34; (no explanation) 标点符号指南 不要使用长破折号 - 请改用短横线、逗号或分号 在列表中使用牛津逗号: \u0026ldquo;console, i2ptunnel, and Jetty\u0026rdquo; 代码块内的句号 仅在语法确有必要时使用 并列列表 当列表项包含逗号时使用分号 文档结构 标准章节顺序 有关 API 文档：\n概述 - 该功能的作用及其存在的原因 实现 - 如何实现/使用它 配置 - 如何进行配置 API 参考 - 方法/属性的详细说明 示例 - 完整可运行示例 最佳实践 - 提示与建议 版本历史 - 引入时间及其随时间的变更 参考资料 - 相关文档的链接 标题层次结构 使用语义化的标题层级：\n# Document Title (h1 - only one per document) ## Major Section (h2) ### Subsection (h3) #### Detail Section (h4) **Bold text for emphasis within sections** 信息框 对于特殊通知，请使用块引用：\n\u0026gt; **Note:** Additional information that clarifies the main content. \u0026gt; **Warning:** Important information about potential issues or breaking changes. \u0026gt; **Deprecated:** This feature is deprecated and will be removed in version X.Y.Z. \u0026gt; **Status:** Current implementation status or version information. 列表与组织 无序列表 用于非顺序项：\n- First item - Second item - Third item 有序列表 用于顺序步骤：\n1. First step 2. Second step 3. Third step 定义列表 用于术语解释:\n**Term One** : Explanation of term one **Term Two** : Explanation of term two 应避免的常见陷阱 1. 容易混淆的相似系统 不要混淆： - ClientAppManager（客户端应用管理器）注册表 与 PortMapper（端口映射器） - i2ptunnel 的 tunnel（隧道）类型 与 端口映射器服务常量 - ClientApp（客户端应用） 与 RouterApp（Router 应用）（上下文不同） - 受管 与 非受管 客户端\n务必明确是哪一个系统 你正在讨论：\n✅ \u0026#34;Register with ClientAppManager using manager.register(this) for name-based lookup.\u0026#34; ✅ \u0026#34;Register with PortMapper using context.portMapper().register() for port discovery.\u0026#34; 2. 过时的版本引用 不要： - 将旧版本称为“当前” - 链接到过时的 API 文档 - 在示例中使用已弃用的方法签名\n应做： - 在发布前检查发行说明 - 验证 API 文档与当前版本一致 - 更新示例以使用当前最佳实践\n3. 无法访问的 URL 不要: - 仅链接到 .i2p 域名且没有 clearnet（公开互联网）替代方案 - 使用失效或过时的文档 URL - 链接到本地的 file:// 路径\n应当： - 为所有 I2P 内部链接提供明网替代链接 - 在发布前确认 URL 可访问 - 使用长期可用的 URL（geti2p.net，而非临时托管）\n4. 不完整的代码示例 不要： - 在没有上下文的情况下展示代码片段 - 省略错误处理 - 使用未定义的变量 - 在不明显的情况下省略 import 语句\n应当： - 展示完整、可编译的示例 - 包含必要的错误处理 - 解释每一行关键代码的作用 - 在发布前对示例进行测试\n5. 含糊不清的表述 ❌ \u0026#34;Some applications register services.\u0026#34; ✅ \u0026#34;Applications implementing ClientApp may register with ClientAppManager using manager.register(this) to enable name-based lookup.\u0026#34; ❌ \u0026#34;Configuration files go in the config directory.\u0026#34; ✅ \u0026#34;Modern I2P installations store client configurations in $I2P/clients.config.d/ as individual files.\u0026#34; Markdown 约定 文件命名 对文件名使用 kebab-case（短横线命名法）： - managed-clients.md - port-mapper-guide.md - configuration-reference.md\n前置元数据格式 始终包含 YAML 头部信息：\n--- title: \u0026#34;Document Title\u0026#34; description: \u0026#34;Brief description under 160 characters\u0026#34; slug: \u0026#34;url-slug\u0026#34; lastUpdated: \u0026#34;2025-10\u0026#34; accurateFor: \u0026#34;2.10.0\u0026#34; reviewStatus: \u0026#34;verified\u0026#34; --- 链接格式 内部链接 (文档内):\nSee [clients.config specification](https://geti2p.net/spec/configuration#clients-config) 外部链接（指向其他资源）：\nFor more details, see [ClientApp Javadoc](https://i2p.github.io/i2p.i2p/net/i2p/app/ClientApp.html) 代码仓库链接:\nView source: [ClientApp.java](https://i2pgit.org/I2P_Developers/i2p.i2p/src/branch/master/core/java/src/net/i2p/app/ClientApp.java) 表格格式设置 使用 GitHub 风格的 Markdown 表格：\n| Property | Type | Default | Description | |----------|------|---------|-------------| | `main` | String | (required) | Full class name | | `delay` | Integer | 120 | Seconds before start | | `onBoot` | Boolean | false | Force immediate start | 代码块语言标签 始终为语法高亮指定语言：\n\\`\\`\\`java // Java code \\`\\`\\` \\`\\`\\`bash # Shell commands \\`\\`\\` \\`\\`\\`properties # Configuration files \\`\\`\\` \\`\\`\\`xml \u0026lt;!-- XML files --\u0026gt; \\`\\`\\` 评审清单 在发布文档之前，请确认：\n所有技术论断均已通过源代码或官方文档验证 版本号和日期为最新 所有 URL 可从明网访问（或已提供替代方案） 代码示例完整并经过测试 术语遵循 I2P 约定 不使用 em-dash（长破折号），使用普通短横线或其他标点 Frontmatter（前置元数据）完整且准确 标题层级语义化（h1 → h2 → h3） 列表和表格格式正确 参考部分包含所有被引用的来源 文档遵循结构指南 语气专业但易于理解 相近概念有清晰区分 无失效链接或引用 配置示例有效且为最新 反馈： 如果你发现问题或对这些指南有任何建议，请通过 I2P 官方开发渠道提交。\n","description":"在整个 I2P 技术文档中保持一致性、准确性和可访问性","id":"797e1cb5256ec022a3d99eefd7eda1f4","section":"docs","title":"I2P 文档撰写指南","url":"/zh/docs/writing-guidelines/"},{"categories":null,"content":"概述 当今存在几个主要的隐私和匿名网络,每个都有不同的设计目标和威胁模型。虽然 Tor、Lokinet、GNUnet 和 Freenet 都为保护隐私的通信提供了有价值的方法,但 I2P 作为唯一一个生产就绪的、完全针对网络内隐藏服务和点对点应用优化的分组交换网络而脱颖而出。\n下表总结了截至2025年这些网络在架构和运行方面的主要区别。\n隐私网络对比（2025） Feature / Network I2P Tor Lokinet Freenet (Hyphanet) GNUnet Primary Focus Hidden services, P2P applications Clearnet anonymity via exits Hybrid VPN + hidden services Distributed storage \u0026 publishing Research framework, F2F privacy Architecture Fully distributed, packet-switched Centralized directory, circuit-switched Packet-switched LLARP with blockchain coordination DHT-based content routing DHT \u0026 F2F topology (R5N) Routing Model Unidirectional tunnels (inbound/outbound) Bidirectional circuits (3 hops) Packet-switched over staked nodes Key-based routing Random walk + DHT hybrid Directory / Peer Discovery Distributed Kademlia netDB with floodfills 9 hardcoded directory authorities Blockchain + Oxen staking Heuristic routing Distributed hash routing (R5N) Encryption ECIES-X25519-AEAD-Ratchet (ChaCha20/Poly1305) AES + RSA/ECDH Curve25519/ChaCha20 Custom symmetric encryption Ed25519/Curve25519 Participation Model All routers route traffic (democratic) Small relay subset, majority are clients Only staked nodes User-selectable trust mesh Optional F2F restriction Traffic Handling Packet-switched, multi-path, load-balanced Circuit-switched, fixed path per circuit Packet-switched, incentivized File chunk propagation Message batching and proof-of-work Garlic Routing ✅ Yes (message bundling \u0026 tagging) ❌ No Partial (message batches) ❌ No ❌ No Exit to Clearnet Limited (discouraged) Core design goal Supported (VPN-style exits) Not applicable Not applicable Built-In Apps I2PSnark, I2PTunnel, SusiMail, I2PBote Tor Browser, OnionShare Lokinet GUI, SNApps Freenet UI GNUnet CLI tools Performance Optimized for internal services, 1–3s RTT Optimized for exits, ~200–500ms RTT Low latency, staked node QoS High latency (minutes) Experimental, inconsistent Anonymity Set Size ~55,000 active routers Millions of daily users \u0026lt;1,000 service nodes Thousands (small core) Hundreds (research only) Scalability Horizontal via floodfill rotation Centralized bottleneck (directory) Dependent on token economics Limited by routing heuristics Research-scale only Funding Model Volunteer-driven nonprofit Major institutional grants Crypto-incentivized (OXEN) Volunteer community Academic research License / Codebase Open source (Java/C++/Go) Open source (C) Open source (C++) Open source (Java) Open source (C) --- 为什么 I2P 在隐私优先设计方面处于领先地位 1. Packet Switching \u0026gt; Circuit Switching Tor 的电路交换模型将流量绑定到固定的三跳路径上——对浏览来说很高效,但对长期运行的内部服务来说比较脆弱。I2P 的 packet-switched tunnels(分组交换隧道) 通过多个并发路径发送消息,自动绕过拥塞或故障进行路由,从而实现更好的正常运行时间和负载分配。\n2. Unidirectional Tunnels I2P 将入站和出站流量分离。这意味着每个参与者只能看到通信流的一半，使得时序关联攻击变得更加困难。Tor、Lokinet 和其他网络使用双向电路，其中请求和响应共享相同的路径——更简单，但更容易追踪。\n3. Fully Distributed netDB Tor 的九个目录权威节点定义了其网络拓扑。I2P 使用由轮换的 floodfill router 维护的自组织 Kademlia DHT，消除了任何中心控制点或协调服务器。\n1. 分组交换 \u0026gt; 电路交换 I2P 通过 garlic encryption 扩展了洋葱路由，将多个加密消息捆绑到一个容器中。这减少了元数据泄漏和带宽开销，同时提高了确认、数据和控制消息的效率。\n2. 单向 Tunnel 每个 I2P router 都为其他节点提供路由服务。没有专门的中继运营者或特权节点——带宽和可靠性会自动决定一个节点贡献多少路由能力。这种民主化的方式构建了网络的韧性，并随着网络的增长自然扩展。\n3. 完全分布式 netDB I2P 的 12 跳往返路径(6 跳入站 + 6 跳出站)比 Tor 的 6 跳隐藏服务电路提供更强的不可关联性。由于双方都在网络内部,连接完全避免了出口节点瓶颈,提供更快的内部托管服务和原生应用集成(I2PSnark、I2PTunnel、I2PBote)。\nArchitectural Takeaways Design Principle I2P Advantage Decentralization No trusted authorities; netDB managed by floodfill peers Traffic Separation Unidirectional tunnels prevent request/response correlation Adaptability Packet-switching allows per-message load balancing Efficiency Garlic routing reduces metadata and increases throughput Inclusiveness All peers route traffic, strengthening anonymity set Focus Built specifically for hidden services and in-network communication --- When to Use Each Network Use Case Recommended Network Anonymous web browsing (clearnet access) I2P Anonymous hosting, P2P, or DApps I2P Anonymous file publishing and storage Freenet (Hyphanet) VPN-style private routing with staking Lokinet Academic experimentation and research GNUnet --- Summary I2P的架构是独特的隐私优先设计——没有目录服务器，没有区块链依赖，没有中心化信任。它结合了单向tunnel、分组交换路由、garlic消息捆绑和分布式对等发现，使其成为当今匿名托管和点对点通信技术最先进的系统。\nI2P 不是\u0026quot;Tor 的替代品\u0026quot;。它是一类不同的网络——专为隐私网络内部发生的事情而构建,而非网络外部。\n","description":"一个现代化的技术和哲学比较，突出 I2P 独特的设计优势","id":"bc3abab13910824c59b1550aa1ce69df","section":"docs","title":"I2P 与其他隐私网络的比较","url":"/zh/docs/overview/comparison/"},{"categories":null,"content":"简介 I2P 是一个可扩展、自组织、弹性的分组交换匿名网络层,可以在其上运行任意数量的不同的注重匿名性或安全性的应用程序。这些应用程序可以各自在匿名性、延迟和吞吐量之间进行权衡,而无需担心自由路由混合网络的正确实现,从而使它们的活动能够融入已经在 I2P 上运行的更大匿名用户群体中。\n已有的应用程序提供了完整的典型互联网活动范围——匿名网页浏览、网站托管、聊天、文件共享、电子邮件、博客和内容聚合，以及其他几个正在开发中的应用程序。\n网页浏览： 使用任何支持代理的现有浏览器 聊天： IRC 和其他协议 文件共享： I2PSnark 和其他应用程序 电子邮件： Susimail 和其他应用程序 博客： 使用任何本地网络服务器，或可用的插件 与托管在内容分发网络（如 Freenet 或 GNUnet ）中的网站不同，I2P 上托管的服务是完全交互式的——有传统的网页式搜索引擎、公告板、可以评论的博客、数据库驱动的站点，以及无需在本地安装即可查询静态系统（如 Freenet）的桥接服务。\n通过所有这些支持匿名的应用程序，I2P 作为面向消息的中间件运行——应用程序指定要发送到加密标识符（一个\u0026quot;destination\u0026quot;）的数据，I2P 确保其安全且匿名地到达。I2P 还包含一个简单的流式传输库 ，允许 I2P 的匿名尽力传输消息作为可靠的、有序的流进行传输，提供针对网络高带宽延迟积调优的基于 TCP 的拥塞控制。\n虽然已经开发了简单的 SOCKS 代理来连接现有应用程序,但其价值有限,因为大多数应用程序在匿名环境中会泄露敏感信息。最安全的方法是审计和改造应用程序,使其直接使用 I2P 的 API。\nI2P 不是一个研究项目——无论是学术性、商业性还是政府性质的——而是一项旨在提供可用匿名性的工程实践。自 2003 年初以来,它一直由分布在全球的贡献者团队持续开发。所有 I2P 工作都是在官方网站 上的开源项目,主要发布到公共领域,部分组件采用宽松的 BSD 风格许可证。还有几个采用 GPL 许可的客户端应用程序可用,例如 I2PTunnel 、Susimail 和 I2PSnark 。资金完全来自用户捐赠。\n操作 Overview I2P 明确区分了 router（参与网络的节点）和 destination（应用程序的匿名端点）。运行 I2P 本身并不是秘密；隐藏的是用户正在做什么以及他们的 destination 使用哪个 router。终端用户通常运行多个 destination（例如，一个用于网页浏览，另一个用于托管服务，还有一个用于 IRC）。\nI2P 中的一个关键概念是 tunnel（隧道）——一条通过一系列 router 的单向加密路径。每个 router 只解密一层，并且只知道下一跳。Tunnel 每 10 分钟过期一次，必须重新构建。\n图1：存在两种类型的tunnel——inbound和outbound。\nOutbound tunnels 将消息从创建者发送出去。 Inbound tunnels 将消息带回创建者。 结合这些可以实现双向通信。例如，\u0026ldquo;Alice\u0026quot;使用outbound tunnel发送到\u0026quot;Bob\u0026quot;的inbound tunnel。Alice用路由指令加密她的消息发送到Bob的inbound gateway。\n另一个关键概念是网络数据库（network database 或 netDb），它分发关于 router 和目的地的元数据：\nRouterInfo: 包含路由器联系信息和密钥材料。 LeaseSet: 包含联系目标地址所需的信息(tunnel 网关、过期时间、加密密钥)。 路由器直接将其 RouterInfo 发布到 netDb；而 LeaseSet 则通过出站 tunnel 发送以保护匿名性。\n为了构建隧道，Alice 向 netDb 查询 RouterInfo 条目以选择节点，并逐跳发送加密的隧道构建消息，直到隧道建立完成。\n图 2：路由器信息用于构建隧道。\n要向 Bob 发送数据，Alice 查找 Bob 的 LeaseSet，并使用她的一条出站 tunnel 将数据路由到 Bob 的入站 tunnel 网关。\n图 3：LeaseSet 连接出站和入站隧道。\n因为 I2P 是基于消息的，它添加了**端到端 garlic encryption（大蒜加密）**来保护消息，即使从出站端点或入站网关也无法窥探。一个 garlic 消息包裹多个加密的\u0026quot;cloves\u0026rdquo;（消息片段）以隐藏元数据并提高匿名性。\n应用程序可以直接使用消息接口，或者依赖流式库 来建立可靠的连接。\nTunnels 入站和出站隧道都使用分层加密,但构建方式有所不同:\n在入站 tunnel 中，创建者（端点）解密所有层。 在出站 tunnel 中，创建者（网关）预先解密各层，以确保端点的清晰性。 I2P通过延迟和可靠性等间接指标对节点进行分析，无需直接探测。基于这些分析结果，节点被动态分组为四个层级：\n快速且高容量 高容量 未失败 失败中 Tunnel 对等节点选择通常优先选择高容量的对等节点,随机选择以平衡匿名性和性能,并采用额外的基于 XOR 的排序策略来缓解前驱攻击和 netDb 收集。\n有关更深入的细节，请参阅 Tunnel 规范 。\n概述 参与 floodfill 分布式哈希表（DHT）的 router 会存储并响应 LeaseSet 查询。该 DHT 使用 Kademlia 的一个变体。Floodfill router 会在具有足够容量和稳定性时自动选择,也可以手动配置。\nRouterInfo: 描述一个 router 的能力和传输方式。 LeaseSet: 描述一个 destination 的 tunnel 和加密密钥。 netDb 中的所有数据都由发布者签名并加上时间戳,以防止重放攻击或过期条目攻击。时间同步通过 SNTP 和传输层偏差检测来维护。\nAdditional concepts 未发布和加密的 LeaseSet：\n目的地可以通过不发布其 LeaseSet 来保持私密性，仅与受信任的对等节点共享。访问需要相应的解密密钥。\n引导启动（重新种子化）：\n新的 router 需要从可信的 HTTPS reseed 服务器获取已签名的 RouterInfo 文件来加入网络。\n查找可扩展性：\nI2P 使用迭代式而非递归式查找来提高 DHT 可扩展性和安全性。\n隧道 现代 I2P 通信使用两种完全加密的传输协议：\nNTCP2 : 基于加密 TCP 的协议 SSU2 : 基于加密 UDP 的协议 两者都构建于现代 Noise Protocol Framework 之上,提供强大的身份验证和抵抗流量指纹识别的能力。它们取代了旧版 NTCP 和 SSU 协议(自 2023 年起已完全停用)。\nNTCP2 通过 TCP 提供加密、高效的流式传输。\nSSU2 提供基于 UDP 的可靠性、NAT 穿透和可选的打洞功能。SSU2 在概念上类似于 WireGuard 或 QUIC，在可靠性和匿名性之间取得平衡。\nRouter 可能同时支持 IPv4 和 IPv6,在 netDb 中发布其传输地址和成本。连接的传输方式通过竞价系统动态选择,以优化条件和现有链接。\n网络数据库 (netDb) I2P 在所有组件中使用分层加密：传输层、tunnel、garlic 消息和 netDb。\n当前的基本组件包括：\nX25519 用于密钥交换 EdDSA (Ed25519) 用于签名 ChaCha20-Poly1305 用于认证加密 SHA-256 用于哈希 AES256 用于 tunnel 层加密 旧版算法（ElGamal、DSA-SHA1、ECDSA）保留以实现向后兼容性。\nI2P 目前正在引入混合后量子 (PQ) 密码学方案，将 X25519 与 ML-KEM 结合，以抵御\u0026quot;现在收集，以后解密\u0026quot;攻击。\nGarlic Messages Garlic 消息通过将多个加密的\u0026quot;瓣\u0026quot;（cloves）与独立的传递指令组合在一起来扩展洋葱路由。这些允许消息级别的路由灵活性和统一的流量填充。\nSession Tags 支持两种端到端加密的密码学系统：\nElGamal/AES+SessionTags (传统方式):\n使用预先传递的会话标签作为 32 字节随机数。现已弃用,因为效率低下。\nECIES-X25519-AEAD-Ratchet（当前）：\n使用 ChaCha20-Poly1305 和同步的基于 HKDF 的 PRNG 来动态生成临时会话密钥和 8 字节标签,在保持前向保密性的同时减少 CPU、内存和带宽开销。\nFuture of the Protocol 关键研究领域聚焦于维护针对国家级对手的安全性以及引入后量子保护。两个早期设计概念——受限路由和可变延迟——已被现代发展所取代。\nRestricted Route Operation 最初的受限路由概念旨在隐藏IP地址。这一需求已在很大程度上通过以下方式得到缓解:\nUPnP 自动端口转发 SSU2 中的强大 NAT 穿透 IPv6 支持 协作式介绍节点和 NAT 打洞 可选的覆盖网络（如 Yggdrasil）连接 因此，现代 I2P 无需复杂的受限路由即可更实际地实现相同目标。\nSimilar Systems I2P整合了面向消息的中间件、分布式哈希表(DHT)和混合网络(mixnet)的概念。其创新之处在于将这些技术结合成一个可用的、自组织的匿名平台。\n传输协议 网站 Tor 和 I2P 有着共同的目标，但在架构上有所不同：\nTor: 电路交换；依赖可信的目录授权机构。（约1万个中继节点） I2P: 分组交换；完全分布式的 DHT 驱动网络。（约5万个 routers） I2P的单向tunnel暴露更少的元数据并允许灵活的路由路径,而Tor专注于匿名的互联网访问(outproxying出口代理)。I2P则支持匿名的网络内托管。\n密码学 网站 Freenet 专注于匿名、持久的文件发布和检索。相比之下，I2P 提供了一个用于交互式使用（网页、聊天、种子下载）的实时通信层。这两个系统相互补充——Freenet 提供抗审查的存储；I2P 提供传输匿名性。\nOther Networks Lokinet: 基于IP的覆盖网络,使用激励性服务节点。 Nym: 下一代混合网络,强调通过覆盖流量进行元数据保护,但延迟较高。 Appendix A: Application Layer I2P 本身仅处理消息传输。应用层功能通过 API 和库在外部实现。\nStreaming Library **流式库（streaming library）**作为 I2P 的 TCP 类似物发挥作用，采用滑动窗口协议和针对高延迟匿名传输优化的拥塞控制。\n由于消息捆绑优化，典型的 HTTP 请求/响应模式通常可以在单次往返中完成。\nNaming Library and Address Book 开发者：mihi, Ragnarok 请参阅命名和地址簿 页面。\nI2P的命名系统是本地和去中心化的，避免了类似DNS的全局名称。每个router在本地维护一个从人类可读名称到目标地址的映射。可选的基于信任网络的地址簿可以从可信节点共享或导入。\n这种方法避免了中心化权威机构，并规避了全局或投票式命名系统中固有的女巫攻击(Sybil attack)漏洞。\n受限路由操作 开发者：mihi\nI2PTunnel 是主要的客户端层接口，用于实现匿名 TCP 代理。它支持：\n客户端 tunnel（出站到 I2P 目的地） HTTP 客户端 (eepproxy) 用于 \u0026ldquo;.i2p\u0026rdquo; 域名 服务器 tunnel（从 I2P 入站到本地服务） HTTP 服务器 tunnel（安全代理 Web 服务） 出站代理(到常规互联网)是可选的,由志愿者运行的\u0026quot;服务器\u0026quot;隧道实现。\nI2PSnark 开发者：jrandom 等人 — 从 Snark 移植\nI2P 自带的 I2PSnark 是一个匿名多种子 BitTorrent 客户端,支持 DHT 和 UDP,可通过 Web 界面访问。\nTor 开发者：postman, susi23, mastiejaner\nI2Pmail 通过 I2PTunnel 连接提供匿名电子邮件服务。Susimail 是一个专门构建的基于网页的客户端,用于防止传统电子邮件客户端中常见的信息泄露。mail.i2p 服务具有病毒过滤、hashcash 配额以及 outproxy 分离等功能,以提供额外的保护。\n","description":"I2P 架构和运行的技术介绍","id":"75218044125880755dabbc53c9ce4b06","section":"docs","title":"I2P: 一个可扩展的匿名通信框架","url":"/zh/docs/overview/tech-intro/"},{"categories":null,"content":"I2PControl API 文档 I2PControl 是一个 JSON-RPC 2.0 API，自 0.9.39 版本起捆绑在 I2P router 中。它通过结构化的 JSON 请求实现对 router 的身份验证监控和控制。\n默认密码： itoopie — 这是出厂默认密码，应立即更改以确保安全。\n1. 概述与访问 Implementation Default Endpoint Protocol Enabled by Default Notes Java I2P (2.10.0+) http://127.0.0.1:7657/jsonrpc/ HTTP ❌ Must be enabled via WebApps (Router Console) Bundled webapp i2pd (C++ implementation) https://127.0.0.1:7650/ HTTPS ✅ Enabled by default Legacy plugin behavior 在 Java I2P 的情况下,你必须前往 **Router Console → WebApps → I2PControl** 并启用它(设置为自动启动)。一旦激活,所有方法都要求你首先进行身份验证并接收会话令牌。 2. JSON-RPC 格式 所有请求遵循 JSON-RPC 2.0 结构：\n{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;MethodName\u0026#34;, \u0026#34;params\u0026#34;: { /* named parameters */ } } 成功的响应包含 result 字段；失败时，返回一个 error 对象：\n{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;result\u0026#34;: { /* data */ } } 或\n{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;error\u0026#34;: { \u0026#34;code\u0026#34;: -32001, \u0026#34;message\u0026#34;: \u0026#34;Invalid password\u0026#34; } } 3. 认证流程 请求（身份验证） curl -s -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;Authenticate\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;API\u0026#34;: 1, \u0026#34;Password\u0026#34;: \u0026#34;itoopie\u0026#34; } }\u0026#39; \\ http://127.0.0.1:7657/jsonrpc/ 成功响应 { \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;result\u0026#34;: { \u0026#34;Token\u0026#34;: \u0026#34;a1b2c3d4e5\u0026#34;, \u0026#34;API\u0026#34;: 1 } } 你必须在所有后续请求的 params 中包含该 Token。\n4. 方法与端点 4.1 RouterInfo 获取关于路由器的关键遥测数据。\n请求示例\ncurl -s -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;2\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;RouterInfo\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;Token\u0026#34;: \u0026#34;a1b2c3d4e5\u0026#34;, \u0026#34;i2p.router.version\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;i2p.router.status\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;i2p.router.net.status\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;i2p.router.net.tunnels.participating\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;i2p.router.net.bw.inbound.1s\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;i2p.router.net.bw.outbound.1s\u0026#34;: \u0026#34;\u0026#34; } }\u0026#39; \\ http://127.0.0.1:7657/jsonrpc/ 响应字段 (result) 根据官方文档 (GetI2P):\ni2p.router.status (String) — 人类可读的状态 i2p.router.uptime (long) — 毫秒数(或旧版 i2pd 为字符串) :contentReference[oaicite:0]{index=0} i2p.router.version (String) — 版本字符串 :contentReference[oaicite:1]{index=1} i2p.router.net.bw.inbound.1s, i2p.router.net.bw.inbound.15s (double) — 入站带宽,单位 B/s :contentReference[oaicite:2]{index=2} i2p.router.net.bw.outbound.1s, i2p.router.net.bw.outbound.15s (double) — 出站带宽,单位 B/s :contentReference[oaicite:3]{index=3} i2p.router.net.status (long) — 数值状态码(见下方枚举) :contentReference[oaicite:4]{index=4} i2p.router.net.tunnels.participating (long) — 参与的 tunnel 数量 :contentReference[oaicite:5]{index=5} i2p.router.netdb.activepeers, fastpeers, highcapacitypeers (long) — netDB 节点统计 :contentReference[oaicite:6]{index=6} i2p.router.netdb.isreseeding (boolean) — 是否正在进行 reseed :contentReference[oaicite:7]{index=7} i2p.router.netdb.knownpeers (long) — 已知节点总数 :contentReference[oaicite:8]{index=8} 状态码枚举 (i2p.router.net.status) Code Meaning 0 OK 1 TESTING 2 FIREWALLED 3 HIDDEN 4 WARN_FIREWALLED_AND_FAST 5 WARN_FIREWALLED_AND_FLOODFILL 6 WARN_FIREWALLED_WITH_INBOUND_TCP 7 WARN_FIREWALLED_WITH_UDP_DISABLED 8 ERROR_I2CP 9 ERROR_CLOCK_SKEW 10 ERROR_PRIVATE_TCP_ADDRESS 11 ERROR_SYMMETRIC_NAT 12 ERROR_UDP_PORT_IN_USE 13 ERROR_NO_ACTIVE_PEERS_CHECK_CONNECTION_AND_FIREWALL 14 ERROR_UDP_DISABLED_AND_TCP_UNSET --- 4.2 GetRate 用于获取给定时间窗口内的速率指标（例如带宽、tunnel 成功率）。\n请求示例\ncurl -s -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;3\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;GetRate\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;Token\u0026#34;: \u0026#34;a1b2c3d4e5\u0026#34;, \u0026#34;Stat\u0026#34;: \u0026#34;bw.combined\u0026#34;, \u0026#34;Period\u0026#34;: 60000 } }\u0026#39; \\ http://127.0.0.1:7657/jsonrpc/ 示例响应\n{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;3\u0026#34;, \u0026#34;result\u0026#34;: { \u0026#34;Rate\u0026#34;: 12345.67 } } 4.3 RouterManager 执行管理操作。\n允许的参数 / 方法 - Restart, RestartGraceful - Shutdown, ShutdownGraceful - Reseed, FindUpdates, Update :contentReference[oaicite:10]{index=10}\n请求示例\ncurl -s -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;4\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;RouterManager\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;Token\u0026#34;: \u0026#34;a1b2c3d4e5\u0026#34;, \u0026#34;Restart\u0026#34;: true } }\u0026#39; \\ http://127.0.0.1:7657/jsonrpc/ 成功响应\n{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;4\u0026#34;, \u0026#34;result\u0026#34;: { \u0026#34;Restart\u0026#34;: null } } 4.4 网络设置 获取或设置网络配置参数(端口、UPnP、带宽共享等)\n请求示例（获取当前值）\ncurl -s -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;5\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;NetworkSetting\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;Token\u0026#34;: \u0026#34;a1b2c3d4e5\u0026#34;, \u0026#34;i2p.router.net.ntcp.port\u0026#34;: null, \u0026#34;i2p.router.net.ssu.port\u0026#34;: null, \u0026#34;i2p.router.net.bw.share\u0026#34;: null, \u0026#34;i2p.router.net.upnp\u0026#34;: null } }\u0026#39; \\ http://127.0.0.1:7657/jsonrpc/ 示例响应\n{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;5\u0026#34;, \u0026#34;result\u0026#34;: { \u0026#34;i2p.router.net.ntcp.port\u0026#34;: \u0026#34;1234\u0026#34;, \u0026#34;i2p.router.net.ssu.port\u0026#34;: \u0026#34;5678\u0026#34;, \u0026#34;i2p.router.net.bw.share\u0026#34;: \u0026#34;50\u0026#34;, \u0026#34;i2p.router.net.upnp\u0026#34;: \u0026#34;true\u0026#34;, \u0026#34;SettingsSaved\u0026#34;: true, \u0026#34;RestartNeeded\u0026#34;: false } } 注意：2.41 版本之前的 i2pd 可能返回数字类型而非字符串——客户端应同时处理这两种类型。:contentReference[oaicite:11]{index=11}\n4.5 高级设置 允许操作内部路由器参数。\n请求示例\ncurl -s -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;6\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;AdvancedSettings\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;Token\u0026#34;: \u0026#34;a1b2c3d4e5\u0026#34;, \u0026#34;Set\u0026#34;: { \u0026#34;router.sharePercentage\u0026#34;: \u0026#34;75\u0026#34;, \u0026#34;i2np.flushInterval\u0026#34;: \u0026#34;6000\u0026#34; } } }\u0026#39; \\ http://127.0.0.1:7657/jsonrpc/ 响应示例\n{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;6\u0026#34;, \u0026#34;result\u0026#34;: { \u0026#34;Set\u0026#34;: { \u0026#34;router.sharePercentage\u0026#34;: \u0026#34;75\u0026#34;, \u0026#34;i2np.flushInterval\u0026#34;: \u0026#34;6000\u0026#34; } } } 5. 错误代码 除了标准的 JSON-RPC 错误（-32700、-32600 等）之外，I2PControl 还定义了：\nCode Meaning -32001 Invalid password -32002 Missing token -32003 Token does not exist -32004 Token expired -32005 API version missing -32006 API version unsupported --- 6. 使用方法与最佳实践 始终包含 Token 参数(身份验证时除外)。 首次使用时更改默认密码(itoopie)。 对于 Java I2P,确保通过 WebApps 启用 I2PControl webapp。 准备好应对细微差异:某些字段可能是数字或字符串,具体取决于 I2P 版本。 对长状态字符串进行换行以便于显示。 ","description":"通过 I2PControl 网页应用进行远程路由器管理 API","id":"f0e7aa57ce714931128f06f6bdb94db3","section":"docs","title":"I2PControl JSON-RPC","url":"/zh/docs/api/i2pcontrol/"},{"categories":null,"content":"概述 I2PTunnel 是 I2P 的核心组件,用于在 I2P 网络上进行接口交互和提供服务。它通过 tunnel 抽象使基于 TCP 的应用程序和媒体流应用程序能够匿名运行。tunnel 的目的地可以通过主机名 、Base32 或完整的目的地密钥来定义。\n每个已建立的 tunnel 在本地监听(例如 localhost:port)并在内部连接到 I2P 目标地址。要托管服务,请创建一个指向所需 IP 和端口的 tunnel。系统会生成相应的 I2P destination 密钥,使该服务能够在 I2P 网络内被全局访问。I2PTunnel 网页界面位于 I2P Router Tunnel Manager 。\n默认服务 服务器隧道 I2P Webserver – 一个指向 localhost:7658 的 Jetty webserver 的 tunnel,用于在 I2P 上轻松托管网站。 Unix: $HOME/.i2p/eepsite/docroot Windows: %LOCALAPPDATA%\\I2P\\I2P Site\\docroot → C:\\Users\\\u0026lt;username\u0026gt;\\AppData\\Local\\I2P\\I2P Site\\docroot 客户端隧道 I2P HTTP Proxy – localhost:4444 – 用于通过 outproxy 浏览 I2P 和互联网。 I2P HTTPS Proxy – localhost:4445 – HTTP proxy 的安全变体。 Irc2P – localhost:6668 – 默认的匿名 IRC 网络 tunnel。 Git SSH (gitssh.idk.i2p) – localhost:7670 – 用于代码仓库 SSH 访问的客户端 tunnel。 Postman SMTP – localhost:7659 – 用于发送邮件的客户端 tunnel。 Postman POP3 – localhost:7660 – 用于接收邮件的客户端 tunnel。 注意：只有 I2P Web 服务器是默认的服务器 tunnel；其他所有的都是连接到外部 I2P 服务的客户端 tunnel。\n配置 I2PTunnel 配置规范记录在 /spec/configuration 。\n客户端模式 标准 打开一个本地 TCP 端口,连接到 I2P 目标地址上的服务。支持用逗号分隔的多个目标地址条目以实现冗余。\nHTTP 用于HTTP/HTTPS请求的代理tunnel。支持本地和远程outproxy、请求头剥离、缓存、身份验证和透明压缩。\n隐私保护： - 剥离请求头：Accept-*、Referer、Via、From - 将主机头替换为 Base32 目标地址 - 强制执行符合 RFC 标准的逐跳剥离 - 添加透明解压缩支持 - 提供内部错误页面和本地化响应\n压缩行为： - 请求可使用自定义头部 X-Accept-Encoding: x-i2p-gzip - 带有 Content-Encoding: x-i2p-gzip 的响应会被透明解压 - 根据 MIME 类型和响应长度评估压缩效率\n持久连接（2.5.0 版本新增）： Hidden Services Manager 现在支持 I2P 托管服务的 HTTP Keepalive 和持久连接。这减少了延迟和连接开销，但尚未在所有跳点上实现完全符合 RFC 2616 标准的持久套接字。\n流水线（Pipelining）： 仍不受支持且没有必要；现代浏览器已弃用该功能。\nUser-Agent 行为： - Outproxy： 使用当前的 Firefox ESR User-Agent。 - 内部： 使用 MYOB/6.66 (AN/ON) 以保持匿名性一致。\nIRC 客户端 连接到基于 I2P 的 IRC 服务器。允许安全的命令子集，同时过滤标识符以保护隐私。\nSOCKS 4/4a/5 为 TCP 连接提供 SOCKS 代理功能。UDP 在 Java I2P 中尚未实现(仅在 i2pd 中可用)。\n连接 为 SSL/TLS 连接实现 HTTP CONNECT 隧道。\nStreamr 通过基于 TCP 的封装启用 UDP 风格的流式传输。当与相应的 Streamr 服务器隧道配对时，支持媒体流传输。\n服务器模式 标准服务器 创建一个映射到本地 IP:端口的 TCP destination。\nHTTP 服务器 创建一个与本地 Web 服务器交互的 destination。支持压缩（x-i2p-gzip）、请求头剥离和 DDoS 防护。现在还受益于持久连接支持（v2.5.0+）和线程池优化（v2.7.0–2.9.0）。\nHTTP 双向 已弃用 – 仍然可用但不推荐使用。同时充当 HTTP 服务器和客户端，但不进行 outproxy（出口代理）。主要用于诊断回环测试。\nIRC 服务器 为 IRC 服务创建一个过滤目标，将客户端目标密钥作为主机名传递。\nStreamr 服务器 与 Streamr 客户端 tunnel 配合使用，以处理通过 I2P 传输的 UDP 风格数据流。\n新功能（2.4.0–2.10.0） Feature Introduced Summary Keepalive/Persistent Connections 2.5.0 HTTP tunnels now support persistent sockets for I2P-hosted services, improving performance. Thread Pooling Optimization 2.7.0-2.9.0 Reduced CPU overhead and latency by improving thread management. Post-Quantum Encryption (ML-KEM) 2.10.0 Optional hybrid X25519+ML-KEM encryption to resist future quantum attacks. NetDB Segmentation 2.4.0 Isolates I2PTunnel contexts for improved security and privacy. SSU1 Removal / SSU2 Adoption 2.4.0-2.6.0 Upgraded transport layer; transparent to users. I2P-over-Tor Blocking 2.6.0 Prevents inefficient and unstable I2P-over-Tor routing. Browser Proxy (Proposal 166) 2.7.0 Introduced identity-aware proxy mode; details pending confirmation. Java 17 Requirement (upcoming) 2.11.0 Future release will require Java 17+. --- 安全特性 头部剥离以保护匿名性（Accept、Referer、From、Via） User-Agent 随机化，根据入站/出站代理而定 POST 速率限制和Slowloris 防护 流传输子系统中的连接节流 tunnel 层的网络拥塞处理 NetDB 隔离防止跨应用泄漏 技术细节 默认目标密钥大小：516 字节（扩展 LS2 证书可能超出） Base32 地址：{52–56+ 字符}.b32.i2p Server tunnels 与 Java I2P 和 i2pd 保持兼容 已弃用功能：仅 httpbidirserver；自 0.9.59 版本以来无移除项 已验证所有平台的默认端口和文档根目录正确性 摘要 I2PTunnel 仍然是应用程序与 I2P 集成的核心基础。在 0.9.59 至 2.10.0 版本之间,它获得了持久连接支持、后量子加密以及重大的线程改进。大多数配置保持兼容,但开发者应验证其设置以确保符合现代传输和安全默认值。\n","description":"用于与 I2P 交互并在 I2P 上提供服务的工具","id":"7e5d426e3eead28c1767764107b1f3d1","section":"docs","title":"I2PTunnel","url":"/zh/docs/api/i2ptunnel/"},{"categories":null,"content":"概述 关键要点\nI2P 通过其隧道为 IRC 流量提供端到端加密。在 IRC 客户端中禁用 SSL/TLS，除非你正在通过出口代理连接到明网。 预配置的 Irc2P 客户端隧道默认监听 127.0.0.1:6668。将你的 IRC 客户端连接到该地址和端口。 不要使用术语\u0026quot;router‑provided TLS\u0026quot;。使用\u0026quot;I2P\u0026rsquo;s native encryption\u0026quot;或\u0026quot;end‑to‑end encryption\u0026quot;。 快速入门（Java I2P） 在 http://127.0.0.1:7657/i2ptunnel/ 打开 Hidden Services Manager，确保 Irc2P 隧道正在运行。 在你的 IRC 客户端中，设置 server = 127.0.0.1，port = 6668，SSL/TLS = off。 连接并加入频道，如 #i2p、#i2p-dev、#i2p-help。 对于 i2pd 用户(C++ router),在 tunnels.conf 中创建一个 client tunnel(参见下面的示例)。\n网络和服务器 IRC2P (main community network) 联邦服务器:irc.postman.i2p:6667、irc.echelon.i2p:6667、irc.dg.i2p:6667。 Irc2P tunnel 位于 127.0.0.1:6668,会自动连接到其中一个服务器。 典型频道:#i2p、#i2p-chat、#i2p-dev、#i2p-help。 Ilita network 服务器：irc.ilita.i2p:6667、irc.r4sas.i2p:6667、irc.acetone.i2p:6667、rusirc.ilita.i2p:6667。 主要语言：俄语和英语。部分主机提供网页前端。 Client setup Recommended, actively maintained WeeChat（终端） — 强大的 SOCKS 支持；易于编写脚本。 Pidgin（桌面） — 仍在维护中；在 Windows/Linux 上运行良好。 Thunderbird Chat（桌面） — 在 ESR 128+ 版本中受支持。 The Lounge（自托管网页） — 现代化的网页客户端。 IRC2P (主社区网络) LimeChat（免费、开源）。 Textual（在 App Store 付费购买；可获取源代码自行构建）。 Ilita 网络 WeeChat via SOCKS5 /proxy add i2p socks5 127.0.0.1 4447 /set irc.server.i2p.addresses \u0026#34;127.0.0.1/6668\u0026#34; /set irc.server.i2p.proxy \u0026#34;i2p\u0026#34; /connect i2p Pidgin 协议：IRC 服务器：127.0.0.1 端口：6668 加密：关闭 用户名/昵称：任意 Thunderbird Chat 账户类型:IRC 服务器:127.0.0.1 端口:6668 SSL/TLS:关闭 可选:连接时自动加入频道 Dispatch (SAM v3) config.toml 默认配置示例:\n[defaults] name = \u0026#34;Irc2P\u0026#34; host = \u0026#34;irc.postman.i2p\u0026#34; port = 6667 channels = [\u0026#34;#i2p\u0026#34;,\u0026#34;#i2p-dev\u0026#34;] ssl = false Tunnel configuration Java I2P defaults Irc2P 客户端隧道:127.0.0.1:6668 → 上游服务器端口 6667。 隐藏服务管理器:http://127.0.0.1:7657/i2ptunnel/。 推荐使用，积极维护中 ~/.i2pd/tunnels.conf:\n[IRC-IRC2P] type = client address = 127.0.0.1 port = 6668 destination = irc.postman.i2p destinationport = 6667 keys = irc-keys.dat 为 Ilita 创建独立隧道(示例):\n[IRC-ILITA] type = client address = 127.0.0.1 port = 6669 destination = irc.ilita.i2p destinationport = 6667 keys = irc-ilita-keys.dat macOS 选项 启用 SAM 在 Java I2P 中(默认关闭),位置:/configclients 或 clients.config。 默认值:127.0.0.1:7656/TCP 和 127.0.0.1:7655/UDP。 推荐加密:SIGNATURE_TYPE=7(Ed25519)和 i2cp.leaseSetEncType=4,0(ECIES‑X25519 带 ElGamal 回退)或仅 4(仅现代加密)。 配置示例 Java I2P 默认值:2 条入站 / 2 条出站。 i2pd 默认值:5 条入站 / 5 条出站。 对于 IRC:每个方向 2–3 条即足够;建议明确设置以确保不同 router 间的行为一致性。 客户端设置 不要为内部 I2P IRC 连接启用 SSL/TLS。I2P 已经提供端到端加密。额外的 TLS 会增加开销,但不会带来匿名性提升。 使用持久密钥以保持稳定的身份;除非是测试,否则避免在每次重启时重新生成密钥。 如果多个应用使用 IRC,建议使用独立隧道(非共享)以减少跨服务关联。 如果必须允许远程控制(SAM/I2CP),请绑定到 localhost 并通过 SSH 隧道或经过身份验证的反向代理来保护访问。 Alternative connection method: SOCKS5 一些客户端可以通过 I2P 的 SOCKS5 代理连接：127.0.0.1:4447。为获得最佳效果，建议在 6668 端口使用专用的 IRC 客户端隧道；SOCKS 无法清理应用层标识符，如果客户端不是为匿名性设计的，可能会泄露信息。\nTroubleshooting 无法连接 — 确保 Irc2P 隧道正在运行且路由器已完全引导。 卡在解析/加入 — 再次检查 SSL 已禁用且客户端指向 127.0.0.1:6668。 高延迟 — I2P 在设计上就是高延迟的。保持适度的隧道数量(2-3 个)并避免快速重连循环。 使用 SAM 应用 — 确认 SAM 已启用(Java)或未被防火墙阻止(i2pd)。建议使用长期会话。 Appendix: Ports and naming 常见 IRC 隧道端口：6668（Irc2P 默认端口）、6667 和 6669 作为备用端口。 .b32.i2p 主机名：52 字符标准形式；LS2/高级证书存在扩展的 56+ 字符形式。除非明确需要 b32 地址，否则请使用 .i2p 主机名。 ","description":"I2P IRC 网络、客户端、隧道和服务器设置完整指南（2025年更新）","id":"f8c49a6509b36124b90dbaa1d0fbbc4b","section":"docs","title":"IRC over I2P","url":"/zh/docs/applications/irc/"},{"categories":null,"content":" 已弃用： ministreaming 库（简化的流式库）早于如今的流式库 。现代应用程序必须使用完整的流式 API 或 SAM v3。以下信息仅为审阅随 ministreaming.jar 提供的遗留源代码的开发者而保留。\n概述 Ministreaming（轻量级流式传输协议）构建在 I2CP 之上，为 I2P 的消息层提供可靠、按序的传递——就像运行在 IP 之上的 TCP 一样。它最初从早期的 I2PTunnel 应用（BSD 许可）中拆分出来，以便替代性传输机制能够独立演进。\n关键设计约束:\n经典的两阶段（SYN/ACK/FIN）连接建立流程，借鉴自 TCP 固定窗口大小为 1 个数据包 无每个数据包的 ID 或选择性确认 这些选择使实现保持精简，但也限制了吞吐量——每个数据包在发送下一个之前通常要等待将近两个往返时延（RTT）。对于长生命周期的流，这种开销尚可接受，但短的 HTTP 风格交互会明显受影响。\n与流式传输库的关系 当前的 streaming 库沿用同一 Java 包（net.i2p.client.streaming）。已弃用的类和方法仍保留在 Javadoc 文档中，并有清晰标注，以便开发者识别 ministreaming（早期精简版流式库）时代的 API。当 streaming 库取代 ministreaming 时，它新增了：\n更智能的连接建立，往返次数更少 自适应拥塞窗口与重传逻辑 在易丢包的 tunnels 上具有更佳性能 Ministreaming 曾在何时有用？ 尽管存在局限，ministreaming（精简型流式传输）在最早的部署中仍提供了可靠的传输。该 API 刻意保持精简并具有前瞻性，以便可以在不破坏调用方的情况下替换为其他流式传输引擎。Java 应用直接链接使用；非 Java 客户端则通过 SAM 对流式传输会话的支持来获取同等功能。\n目前，ministreaming.jar 仅作为兼容层使用。新的开发应当：\n选用完整的流式库（Java）或 SAM v3（STREAM 风格） 在现代化代码时，移除所有残留的固定窗口假设 优先使用更大的窗口大小和优化的连接握手，以改进对延迟敏感的工作负载 参考 Streaming 库文档 Streaming Javadoc – 包含已弃用的 ministreaming 类 SAM v3 规范 – 为非 Java 应用程序提供流式传输支持 如果你遇到仍然依赖于 ministreaming（I2P 早期的简化流式库）的代码，请计划将其移植到现代的 Streaming API——网络及其工具链都期望较新的行为。\n","description":"I2P 的首个类似 TCP 的传输层的历史注记","id":"3a258127f502d1974fadc514a60bf831","section":"docs","title":"Ministreaming（精简流式传输）库","url":"/zh/docs/legacy/ministreaming/"},{"categories":null,"content":"NTCP 与 SSU 的讨论（2007 年 3 月） NTCP 问题 改编自 zzz 与 cervantes 在 IRC 上的对话。\n为何在 NTCP 看起来会增加开销和延迟时，仍然让 NTCP 相比 SSU 具有更高优先级？\n与最初的 SSU 实现相比，NTCP 通常提供更高的可靠性。 通过 NTCP 进行流式传输会遭遇经典的 TCP-over-TCP 崩溃吗？\n有可能；但 SSU 原本旨在作为轻量级的 UDP 选项，实践中却被证明过于不可靠。 “NTCP（I2P 的旧版传输协议）被认为有害” (zzz, 2007年3月25日) 摘要：NTCP 更高的时延和开销可能导致拥塞，然而路由选择更偏向 NTCP，因为其 bid scores（竞价分值）被硬编码为比 SSU 更低。该分析提出了若干要点：\nNTCP 当前的竞价值低于 SSU，因此 routers 更倾向于 NTCP，除非已建立 SSU 会话。 SSU 通过严格受限的超时和统计来实现确认机制；NTCP 依赖 Java NIO TCP，采用可能更长的 RFC 风格超时。 大多数流量（HTTP、IRC、BitTorrent）使用 I2P 的 streaming 库，实际效果是在 NTCP 之上再叠加一层 TCP。当两层都进行重传时，可能出现拥塞崩溃。经典参考包括 在 TCP 之上再跑 TCP 是个坏主意 。 在 0.8 版中，streaming 库的超时从 10 秒增加到 45 秒；SSU 的最大超时为 3 秒，而 NTCP 的超时被认为接近 60 秒（RFC 建议）。NTCP 的参数很难从外部检查。 2007 年的实地观测显示 i2psnark 的上传吞吐量呈振荡，暗示存在周期性的拥塞崩溃。 效率测试（强制偏好 SSU）将 tunnel 开销比从约 3.5:1 降至 3:1，并改进了 streaming 指标（窗口大小、RTT、发送/确认比）。 2007 年讨论串中的提案 切换传输优先级，使 routers 更倾向于 SSU（恢复 i2np.udp.alwaysPreferred）。 为 Streaming（流式库）流量打标签，使 SSU 仅对带标签的消息降低竞价，且不损害匿名性。 收紧 SSU 重传界限，以降低崩溃（拥塞崩溃）风险。 研究半可靠的下层承载，以判断在 Streaming（流式库）之下进行重传是否总体上有利。 审查优先级队列与超时设置—例如，将 Streaming 超时提高到超过 45 s，以与 NTCP 保持一致。 jrandom 的回复 (2007年3月27日) 关键反驳点：\n之所以有 NTCP，是因为早期的 SSU 部署曾遭遇拥塞塌陷；即便是适度的每跳重传率，在多跳 tunnel 中也会呈爆炸式增长。 缺少 tunnel 级别的确认时，只有一部分消息会得到端到端投递状态；失败可能是静默的。 TCP 的拥塞控制已历经数十年的优化；NTCP 通过成熟的 TCP 协议栈加以利用。 在偏好使用 SSU 时观察到的效率提升，可能反映的是 router 的排队行为，而非协议本身的固有优势。 更大的 streaming（流式传输）超时设置已在改善稳定性；在进行重大更改之前，建议先进行更多观察并收集数据。 这场讨论有助于完善后续的传输调优，但并不能反映现代的 NTCP2/SSU2 架构。\n","description":"比较 NTCP 和 SSU 传输协议的历史说明与拟议的调优思路","id":"6fe94dc04faadfde27bcfeaaf9da5f71","section":"docs","title":"NTCP 讨论","url":"/zh/docs/ntcp/"},{"categories":null,"content":"概览 NTCP2 用基于 Noise 的握手取代了旧版 NTCP 传输，能够抵御流量指纹识别、加密长度字段，并支持现代加密套件。Routers 可以将 NTCP2 与 SSU2 一同运行，作为 I2P 网络中的两种强制性传输协议。NTCP（版本 1）在 0.9.40（2019 年 5 月）被弃用，并在 0.9.50（2021 年 5 月）被完全移除。\nNoise Protocol Framework（Noise 协议框架） NTCP2 使用 Noise 协议框架 修订版 33，2017-10-04 ，并带有 I2P 特定的扩展：\n模式: Noise_XK_25519_ChaChaPoly_SHA256 扩展标识符: Noise_XKaesobfse+hs2+hs3_25519_ChaChaPoly_SHA256（用于 KDF 初始化，KDF 为“密钥派生函数”） DH（Diffie-Hellman）函数: X25519（RFC 7748） - 32 字节密钥，小端序编码 加密算法: AEAD_CHACHA20_POLY1305（RFC 7539/RFC 8439） 12 字节 nonce（随机数）：前 4 字节为 0，后 8 字节为计数器（小端序） 最大 nonce 值：2^64 - 2（在达到 2^64 - 1 之前必须终止连接） 哈希函数: SHA-256（32 字节输出） MAC（消息认证码）: Poly1305（16 字节认证标签） I2P 特定扩展 AES 混淆: 使用 Bob 的 router 哈希和公开的 IV，以 AES-256-CBC 加密临时密钥 随机填充: 消息 1-2 中为明文填充（已认证），消息 3 及之后为 AEAD 填充（已加密） SipHash-2-4 长度混淆: 将两字节帧长度与 SipHash-2-4 的输出异或 帧结构: 数据阶段使用带长度前缀的帧（兼容 TCP 流式传输） 基于块的有效载荷: 采用带类型块的结构化数据格式 握手流程 Alice (Initiator) Bob (Responder) SessionRequest ──────────────────────► ◄────────────────────── SessionCreated SessionConfirmed ──────────────────────► 三消息握手 SessionRequest - Alice 的混淆临时密钥、选项、填充提示 SessionCreated - Bob 的混淆临时密钥、加密的选项、填充 SessionConfirmed - Alice 的加密的静态密钥和 RouterInfo（I2P router 的信息）（两个 AEAD（带关联数据的认证加密）帧） Noise（协议框架）消息模式 XK(s, rs): Authentication Confidentiality \u0026lt;- s (Bob\u0026#39;s static key known in advance) -\u0026gt; e, es 0 2 \u0026lt;- e, ee 2 1 -\u0026gt; s, se 2 5 \u0026lt;- 2 5 认证级别： - 0: 无认证（任何一方都可能是发送者） - 2: 可抵抗密钥泄露冒充（KCI）攻击的发送方认证\n保密级别： - 1: 临时（ephemeral）接收方（前向保密（forward secrecy），无接收方认证） - 2: 已知接收方，仅在发送方被攻破时提供前向保密 - 5: 强前向保密（临时-临时 + 临时-静态 DH（Diffie–Hellman））\n消息规范 密钥记法 RH_A = Alice 的 Router 哈希（32 字节，SHA-256） RH_B = Bob 的 Router 哈希（32 字节，SHA-256） || = 连接运算符 byte(n) = 值为 n 的单个字节 除非另有说明，所有多字节整数均为大端序 X25519 密钥为小端序（32 字节） 认证加密（ChaCha20-Poly1305） 加密函数：\nAEAD_ChaCha20_Poly1305(key, nonce, associatedData, plaintext) → (ciphertext || MAC) 参数： - key：来自 KDF 的 32 字节加密密钥 - nonce：12 字节（4 个零字节 + 8 字节计数器，小端序） - associatedData：握手阶段为 32 字节哈希；数据阶段为零长度 - plaintext：要加密的数据（0 个或更多字节）\n输出： - 密文：与明文长度相同 - MAC：16 字节（Poly1305 认证标签）\nNonce（随机数）管理： - 对每个密码实例的计数器从 0 开始 - 在该方向的每次 AEAD 操作后递增 - 数据阶段中 Alice→Bob 与 Bob→Alice 各自使用独立计数器 - 在计数器达到 2^64 - 1 之前必须终止连接\n消息 1：SessionRequest（会话请求） Alice 向 Bob 发起连接。\nNoise 操作: e, es (临时密钥的生成与交换)\n原始格式 +----+----+----+----+----+----+----+----+ | | + AES-256-CBC Encrypted X (32B) + | Key: RH_B, IV: Bob\u0026#39;s published IV | + + | | +----+----+----+----+----+----+----+----+ | | + ChaChaPoly Frame (48 bytes) + | Plaintext: 32B (X + options) | + k from KDF-1, n=0, ad=h + | | +----+----+----+----+----+----+----+----+ | Cleartext Padding (optional) | + Length specified in options + | 0 to 65535 - 80 bytes | ~ . . . ~ +----+----+----+----+----+----+----+----+ 大小限制： - 最小值：80 字节（32 AES + 48 AEAD） - 最大值：总计 65535 字节 - 特殊情况：连接到 \u0026ldquo;NTCP\u0026rdquo; 地址时最大 287 字节（版本检测）\n解密后的内容 +----+----+----+----+----+----+----+----+ | | + X (Alice ephemeral public key) + | 32 bytes, X25519, little-endian | + + | | +----+----+----+----+----+----+----+----+ | Options Block | + (16 bytes) + | | +----+----+----+----+----+----+----+----+ | Cleartext Padding (optional) | ~ . . . ~ +----+----+----+----+----+----+----+----+ 选项块 (16 字节，大端序) +----+----+----+----+----+----+----+----+ | id | ver| padLen | m3p2len | Rsvd(0) | +----+----+----+----+----+----+----+----+ | tsA | Reserved (0) | +----+----+----+----+----+----+----+----+ id : 1 byte - Network ID (2 for mainnet, 16-254 for testnets) ver : 1 byte - Protocol version (currently 2) padLen : 2 bytes - Padding length in this message (0-65455) m3p2len : 2 bytes - Length of SessionConfirmed part 2 frame Rsvd : 2 bytes - Reserved, set to 0 tsA : 4 bytes - Unix timestamp (seconds since epoch) Reserved: 4 bytes - Reserved, set to 0 关键字段： - Network ID（自 0.9.42 起）：快速拒绝跨网络连接 - m3p2len：消息 3 第 2 部分的精确大小（发送时必须匹配）\n密钥派生函数（KDF-1） 初始化协议：\nprotocol_name = \u0026#34;Noise_XKaesobfse+hs2+hs3_25519_ChaChaPoly_SHA256\u0026#34; h = SHA256(protocol_name) ck = h // Chaining key initialized to hash MixHash 操作：\nh = SHA256(h) // Null prologue h = SHA256(h || rs) // Bob\u0026#39;s static key (known) h = SHA256(h || e.pubkey) // Alice\u0026#39;s ephemeral key X // h is now the associated data for message 1 AEAD MixKey 操作（es pattern，临时-静态握手模式）：\ndh_result = X25519(Alice.ephemeral_private, Bob.static_public) temp_key = HMAC-SHA256(ck, dh_result) ck = HMAC-SHA256(temp_key, byte(0x01)) k = HMAC-SHA256(temp_key, ck || byte(0x02)) // k is the cipher key for message 1 // ck is retained for message 2 KDF 实现说明 AES 混淆: 仅用于抵抗 DPI（深度包检测）；任何拥有 Bob 的 router 哈希和初始向量（IV）的人都可以解密 X 重放防护: Bob 必须将 X 的取值（或其加密等价物）缓存至少 2*D 秒（D = 最大时钟偏移） 时间戳校验: Bob 必须拒绝 |tsA - current_time| \u0026gt; D 的连接（通常 D = 60 秒） 曲线校验: Bob 必须验证 X 为有效的 X25519 点 快速拒绝: Bob 可在解密前检查 X[31] \u0026amp; 0x80 == 0（有效的 X25519 密钥其最高有效位（MSB）为 0） 错误处理: 任一失败时，Bob 在随机超时并读取随机字节后以 TCP RST（复位）关闭连接 缓冲: 为提高效率，Alice 必须一次性写出整个消息（包括填充） 消息 2: SessionCreated（会话已创建） Bob 回复 Alice。\nNoise 操作: e, ee (临时-临时 DH)\n原始格式 +----+----+----+----+----+----+----+----+ | | + AES-256-CBC Encrypted Y (32B) + | Key: RH_B, IV: AES state from msg1 | + + | | +----+----+----+----+----+----+----+----+ | | + ChaChaPoly Frame (48 bytes) + | Plaintext: 32B (Y + options) | + k from KDF-2, n=0, ad=h + | | +----+----+----+----+----+----+----+----+ | Cleartext Padding (optional) | + Length specified in options + | 0 to 65535 - 80 bytes | ~ . . . ~ +----+----+----+----+----+----+----+----+ 解密内容 +----+----+----+----+----+----+----+----+ | | + Y (Bob ephemeral public key) + | 32 bytes, X25519, little-endian | + + | | +----+----+----+----+----+----+----+----+ | Options Block | + (16 bytes) + | | +----+----+----+----+----+----+----+----+ | Cleartext Padding (optional) | ~ . . . ~ +----+----+----+----+----+----+----+----+ 选项块（16 字节，大端序） +----+----+----+----+----+----+----+----+ | Rsvd(0) | padLen | Reserved (0) | +----+----+----+----+----+----+----+----+ | tsB | Reserved (0) | +----+----+----+----+----+----+----+----+ Rsvd : 2 bytes - Reserved, set to 0 padLen : 2 bytes - Padding length in this message Reserved: 10 bytes - Reserved, set to 0 tsB : 4 bytes - Unix timestamp (seconds since epoch) 密钥派生函数（KDF-2） MixHash（混合哈希）操作:\nh = SHA256(h || encrypted_payload_msg1) // 32-byte ciphertext if (msg1_padding_length \u0026gt; 0): h = SHA256(h || padding_from_msg1) h = SHA256(h || e.pubkey) // Bob\u0026#39;s ephemeral key Y // h is now the associated data for message 2 AEAD MixKey（密钥混合）操作（ee 模式）：\ndh_result = X25519(Bob.ephemeral_private, Alice.ephemeral_public) temp_key = HMAC-SHA256(ck, dh_result) ck = HMAC-SHA256(temp_key, byte(0x01)) k = HMAC-SHA256(temp_key, ck || byte(0x02)) // k is the cipher key for message 2 // ck is retained for message 3 KDF 内存清理：\n// Overwrite ephemeral keys after ee DH Alice.ephemeral_public = zeros(32) Alice.ephemeral_private = zeros(32) // Bob side Bob.received_ephemeral = zeros(32) // Bob side 实现说明 AES 链式: Y 加密使用来自消息 1 的 AES-CBC 状态（不重置） 重放防护: Alice 必须将 Y 值缓存至少 2*D 秒 时间戳验证: Alice 必须拒绝 |tsB - current_time| \u0026gt; D 的情况 曲线验证: Alice 必须验证 Y 是有效的 X25519 点 错误处理: 发生任何失败时 Alice 使用 TCP RST 关闭 缓冲: Bob 必须一次性刷新整条消息 消息 3：SessionConfirmed（会话确认） Alice 确认会话并发送 RouterInfo。\nNoise（协议框架）操作: s, se (静态密钥公开和静态-临时 DH)\n两部分结构 消息 3 由两个独立的 AEAD（带关联数据的认证加密）帧组成：\n第 1 部分: 固定长度的 48 字节帧，包含 Alice 的加密静态密钥 第 2 部分: 可变长度的帧，包含 RouterInfo（路由器信息）、选项和填充 原始格式 +----+----+----+----+----+----+----+----+ | ChaChaPoly Frame 1 (48 bytes) | + Plaintext: Alice static key (32B) + | k from KDF-2, n=1, ad=h | + + | | +----+----+----+----+----+----+----+----+ | | + ChaChaPoly Frame 2 (variable) + | Length specified in msg1.m3p2len | + k from KDF-3, n=0, ad=h + | Plaintext: RouterInfo + padding | + + | | ~ . . . ~ +----+----+----+----+----+----+----+----+ 大小限制： - 第 1 部分：恰好 48 字节 (32 明文 + 16 MAC) - 第 2 部分：长度由消息 1 指定 (m3p2len 字段) - 总上限：65535 字节 (第 1 部分最多 48，因此第 2 部分最多 65487)\n解密内容 第1部分：\n+----+----+----+----+----+----+----+----+ | | + S (Alice static public key) + | 32 bytes, X25519, little-endian | + + | | +----+----+----+----+----+----+----+----+ 第2部分：\n+----+----+----+----+----+----+----+----+ | Block: RouterInfo (required) | + Type=2, contains Alice\u0026#39;s RI + | | ~ . . . ~ +----+----+----+----+----+----+----+----+ | Block: Options (optional) | + Type=1, padding parameters + | | +----+----+----+----+----+----+----+----+ | Block: Padding (optional) | + Type=254, random data + | MUST be last block if present | ~ . . . ~ +----+----+----+----+----+----+----+----+ 密钥派生函数（KDF-3） 第1部分 (s 模式):\nh = SHA256(h || encrypted_payload_msg2) // 32-byte ciphertext if (msg2_padding_length \u0026gt; 0): h = SHA256(h || padding_from_msg2) // Encrypt static key with message 2 cipher key ciphertext = AEAD_ChaCha20_Poly1305(k_msg2, n=1, h, Alice.static_public) h = SHA256(h || ciphertext) // 48 bytes (32 + 16) // h is now the associated data for message 3 part 2 第2部分（se 模式）：\ndh_result = X25519(Alice.static_private, Bob.ephemeral_public) temp_key = HMAC-SHA256(ck, dh_result) ck = HMAC-SHA256(temp_key, byte(0x01)) k = HMAC-SHA256(temp_key, ck || byte(0x02)) // k is the cipher key for message 3 part 2 // ck is retained for data phase KDF ciphertext = AEAD_ChaCha20_Poly1305(k, n=0, h, payload) h = SHA256(h || ciphertext) // h is retained for SipHash KDF 内存清理：\n// Overwrite Bob\u0026#39;s ephemeral key after se DH Alice.received_ephemeral = zeros(32) // Alice side Bob.ephemeral_public = zeros(32) // Bob side Bob.ephemeral_private = zeros(32) // Bob side 实现说明 数据阶段 在握手完成后，所有消息都使用带有经过混淆的长度字段的可变长度 AEAD（带关联数据的认证加密）帧。\n密钥派生函数（数据阶段） 拆分函数 (Noise 协议框架):\n// Generate transmit and receive keys zerolen = \u0026#34;\u0026#34; // Zero-length byte array temp_key = HMAC-SHA256(ck, zerolen) // Alice transmits to Bob k_ab = HMAC-SHA256(temp_key, byte(0x01)) // Bob transmits to Alice k_ba = HMAC-SHA256(temp_key, k_ab || byte(0x02)) // Cleanup ck = zeros(32) temp_key = zeros(32) SipHash 密钥派生:\n// Generate additional symmetric key for SipHash ask_master = HMAC-SHA256(temp_key, \u0026#34;ask\u0026#34; || byte(0x01)) // \u0026#34;siphash\u0026#34; is 7 bytes US-ASCII temp_key2 = HMAC-SHA256(ask_master, h || \u0026#34;siphash\u0026#34;) sip_master = HMAC-SHA256(temp_key2, byte(0x01)) // Alice to Bob SipHash keys temp_key3 = HMAC-SHA256(sip_master, zerolen) sipkeys_ab = HMAC-SHA256(temp_key3, byte(0x01)) sipk1_ab = sipkeys_ab[0:7] // 8 bytes, little-endian sipk2_ab = sipkeys_ab[8:15] // 8 bytes, little-endian sipiv_ab = sipkeys_ab[16:23] // 8 bytes, IV // Bob to Alice SipHash keys sipkeys_ba = HMAC-SHA256(temp_key3, sipkeys_ab || byte(0x02)) sipk1_ba = sipkeys_ba[0:7] // 8 bytes, little-endian sipk2_ba = sipkeys_ba[8:15] // 8 bytes, little-endian sipiv_ba = sipkeys_ba[16:23] // 8 bytes, IV 帧结构 +----+----+----+----+----+----+----+----+ |Obfs Len | | +----+----+ ChaChaPoly Frame + | Encrypted Block Data | + k_ab (Alice→Bob) or k_ba (Bob→Alice)| | Nonce starts at 0, increments | + No associated data (empty string) + | | ~ . . . ~ | | +----+----+----+----+----+----+----+----+ | Poly1305 MAC (16 bytes) | +----+----+----+----+----+----+----+----+ 帧约束： - 最小值：18 字节（2 字节的混淆长度 + 0 字节明文 + 16 字节的 MAC（消息认证码）） - 最大值：65537 字节（2 字节的混淆长度 + 65535 字节的帧） - 建议：每帧几 KB（尽量降低接收端延迟）\nSipHash 长度混淆 目的：防止深度包检测（DPI）识别帧边界\n算法：\n// Initialization (per direction) IV[0] = sipiv // From KDF // For each frame: IV[n] = SipHash-2-4(sipk1, sipk2, IV[n-1]) Mask[n] = IV[n][0:1] // First 2 bytes of IV ObfuscatedLength = ActualLength XOR Mask[n] // Send 2-byte ObfuscatedLength, then ActualLength bytes 解码：\n// Receiver maintains identical IV chain IV[n] = SipHash-2-4(sipk1, sipk2, IV[n-1]) Mask[n] = IV[n][0:1] ActualLength = ObfuscatedLength XOR Mask[n] // Read ActualLength bytes (includes 16-byte MAC) 注意： - 每个方向使用独立的 IV（初始化向量）链（Alice→Bob 与 Bob→Alice） - 如果 SipHash（哈希函数）返回 uint64（无符号 64 位整数），使用最低有效的 2 个字节作为掩码 - 将 uint64 按小端字节序转换为下一个 IV\n块格式 每个帧包含零个或多个块:\n+----+----+----+----+----+----+----+----+ |Type| Length | Data | +----+----+----+ + | | ~ . . . ~ +----+----+----+----+----+----+----+----+ Type : 1 byte - Block type identifier Length: 2 bytes - Big-endian, data size (0-65516) Data : Variable length payload 大小限制: - 最大帧: 65535 字节 (包括 MAC) - 最大块空间: 65519 字节 (帧 - 16 字节的 MAC) - 最大单个块: 65519 字节 (3 字节的头部 + 65516 字节的数据)\n块类型 Type Name Description 0DateTimeTime synchronization (4-byte timestamp) 1OptionsPadding parameters, dummy traffic 2RouterInfoRouterInfo delivery/flooding 3I2NPI2NP message with shortened header 4TerminationExplicit connection close 224-253ReservedExperimental features 254PaddingRandom padding (must be last) 255ReservedFuture extensions **块排序规则：** - **消息 3 第 2 部分**：RouterInfo、选项（可选）、填充（可选） - 不得包含其他类型 - **数据阶段**：顺序任意，但以下情况除外： - 如果存在，填充必须为最后一个块 - 如果存在，终止必须为最后一个块（填充除外） - 每个帧允许包含多个 I2NP 块 - 每个帧不允许包含多个填充块 块类型 0: 日期时间 用于时钟偏移检测的时间同步。\n+----+----+----+----+----+----+----+ | 0 | 4 | timestamp | +----+----+----+----+----+----+----+ Type : 0 Length : 4 (big-endian) Timestamp: 4 bytes, Unix seconds (big-endian) 实现：将时间四舍五入到最接近的秒，以防止时钟偏差的累积。\n块类型 1：选项 填充和流量整形参数。\n+----+----+----+----+----+----+----+----+ | 1 | size |tmin|tmax|rmin|rmax|tdmy| +----+----+----+----+----+----+----+----+ |tdmy| rdmy | tdelay | rdelay | | +----+----+----+----+----+----+----+ + | more_options (TBD) | ~ . . . ~ +----+----+----+----+----+----+----+----+ Type : 1 Length: 12+ bytes (big-endian) 填充比 (4.4 fixed-point float, value/16.0; 4.4 定点浮点表示：整数部分 4 位、小数部分 4 位，数值 = value/16.0): - tmin: 发送最小填充比 (0.0 - 15.9375) - tmax: 发送最大填充比 (0.0 - 15.9375) - rmin: 接收最小填充比 (0.0 - 15.9375) - rmax: 接收最大填充比 (0.0 - 15.9375)\n示例： - 0x00 = 0% 填充 - 0x01 = 6.25% 填充 - 0x10 = 100% 填充 (1:1 比例) - 0x80 = 800% 填充 (8:1 比例)\n填充流量: - tdmy: 愿意发送的最大速率（2 字节，平均值按字节/秒计） - rdmy: 请求接收的速率（2 字节，平均值按字节/秒计）\n延迟插入: - tdelay: 愿意插入的最大值 (2 字节，以毫秒为单位的平均值) - rdelay: 请求的延迟 (2 字节，以毫秒为单位的平均值)\n指南： - 最小值表示期望的抗流量分析能力 - 最大值表示带宽约束 - 发送方应遵从接收方的最大值 - 在约束范围内，发送方可遵从接收方的最小值 - 无强制执行机制；各实现可能有所不同\n块类型 2: RouterInfo（路由信息） 用于 netdb 填充和泛洪的 RouterInfo（路由器信息）递送。\n+----+----+----+----+----+----+----+----+ | 2 | size |flg | RouterInfo | +----+----+----+----+ + | | ~ . . . ~ +----+----+----+----+----+----+----+----+ Type : 2 Length: Flag (1 byte) + RouterInfo size Flag : Bit 0 = flood request (1) or local store (0) Bits 1-7 = Reserved, set to 0 用法：\n在 Message 3 第 2 部分 (握手): - Alice 将她的 RouterInfo(路由器信息) 发送给 Bob - Flood 位通常为 0(本地存储) - RouterInfo 未进行 gzip 压缩\n在数据阶段： - 任一方都可以发送其更新后的 RouterInfo - Flood bit（Flood 位） = 1：请求由 floodfill 分发（如果接收方为 floodfill） - Flood bit = 0：仅在本地 netdb 中存储\n验证要求： 1. 验证签名类型受支持 2. 验证 RouterInfo 签名 3. 验证时间戳在可接受范围内 4. 对于握手: 验证静态密钥与 NTCP2 地址的 \u0026ldquo;s\u0026rdquo; 参数匹配 5. 对于数据阶段: 验证 router 哈希与会话对端匹配 6. 仅对包含已发布地址的 RouterInfos 进行泛洪\n注意： - 无 ACK 机制（如有需要，可使用 I2NP DatabaseStore 并携带回复令牌） - 可能包含第三方 RouterInfos（路由信息对象；floodfill 用途） - 未进行 gzip 压缩（不同于 I2NP DatabaseStore）\n块类型 3：I2NP 消息 I2NP 消息，采用缩短的 9 字节头部。\n+----+----+----+----+----+----+----+----+ | 3 | size |type| msg_id | +----+----+----+----+----+----+----+----+ | expiration | I2NP payload | +----+----+----+ + | | ~ . . . ~ +----+----+----+----+----+----+----+----+ Type : 3 Length : 9 + payload_size (big-endian) Type : 1 byte, I2NP message type Msg_ID : 4 bytes, big-endian, I2NP message ID Expiration: 4 bytes, big-endian, Unix timestamp (seconds) Payload : I2NP message body (length = size - 9) 与 NTCP1 的差异： - 过期时间：4 字节（秒） vs 8 字节（毫秒） - 长度：省略（可由块长度推导） - 校验和：省略（AEAD 提供完整性） - 头部：9 字节 vs 16 字节（减少 44%）\n分片: - I2NP 消息不得跨块分片 - I2NP 消息不得跨帧分片 - 每帧允许多个 I2NP 块\n块类型 4：终止 带原因码的显式连接关闭。\n+----+----+----+----+----+----+----+----+ | 4 | size | valid_frames_recv | +----+----+----+----+----+----+----+----+ | (continued) |rsn | additional_data | +----+----+----+----+ + | | ~ . . . ~ +----+----+----+----+----+----+----+----+ Type : 4 Length : 9+ bytes (big-endian) Valid_Frames_Recv: 8 bytes, big-endian (receive nonce value) 0 if error in handshake phase Reason : 1 byte (see table below) Additional_Data : Optional (format unspecified, for debugging) 原因代码：\nCode Reason Phase 0Normal close / unspecifiedAny 1Termination receivedData 2Idle timeoutData 3Router shutdownData 4Data phase AEAD failureData 5Incompatible optionsHandshake 6Incompatible signature typeHandshake 7Clock skewHandshake 8Padding violationAny 9AEAD framing errorData 10Payload format errorData 11Message 1 errorHandshake 12Message 2 errorHandshake 13Message 3 errorHandshake 14Intra-frame read timeoutData 15RouterInfo signature verification failHandshake 16Static key parameter mismatchHandshake 17BannedAny **规则：** - 终止块必须是帧中最后一个非填充块 - 每个帧最多一个终止块 - 发送方应在发送后关闭连接 - 接收方应在接收后关闭连接 错误处理： - 握手错误：通常使用 TCP RST 关闭（不发送终止块） - 数据阶段的 AEAD（带关联数据的认证加密）错误：随机超时 + 随机读取，然后发送终止 - 有关安全流程，参见 \u0026ldquo;AEAD 错误处理\u0026rdquo; 一节\n块类型 254：填充 用于增强对流量分析抗性的随机填充。\n+----+----+----+----+----+----+----+----+ |254 | size | random_data | +----+----+----+ + | | ~ . . . ~ +----+----+----+----+----+----+----+----+ Type: 254 Length: 0-65516 bytes (big-endian) Data: Cryptographically random bytes 规则： - 如果存在，填充必须是帧中的最后一个块 - 允许零长度填充 - 每个帧中仅允许一个填充块 - 允许仅包含填充的帧 - 应遵循在 Options 块中协商的参数\n消息 1-2 中的填充: - 位于 AEAD（带有关联数据的认证加密）帧之外（明文） - 包含在下一条消息的哈希链中（已认证） - 当下一条消息的 AEAD 校验失败时检测到篡改\n消息 3+ 和数据阶段中的填充： - 在 AEAD（带关联数据的认证加密）帧（加密并认证）内 - 用于流量整形和长度混淆\nAEAD 错误处理 关键安全要求：\n握手阶段（消息1-3） 已知消息大小: - 消息大小是预先确定或事先指定的 - AEAD（带关联数据的认证加密）认证失败是无歧义的\nBob 对消息 1 失败的响应： 1. 设置随机超时（范围取决于实现，建议 100-500ms） 2. 读取随机数量的字节（范围取决于实现，建议 1KB-64KB） 3. 使用 TCP RST（TCP复位）关闭连接（无响应） 4. 临时将源 IP 加入黑名单 5. 跟踪重复失败以实施长期封禁\nAlice 针对消息 2 失败的响应： 1. 立即使用 TCP RST（重置标志）关闭连接 2. 不向 Bob 作出任何响应\nBob 对消息 3 失败的响应: 1. 使用 TCP RST 立即关闭连接 2. 不向 Alice 发送任何响应\n数据阶段 已混淆的消息大小: - 长度字段经 SipHash 混淆 - 长度无效或 AEAD（带关联数据的认证加密）失败可能意味着: - 攻击者探测 - 网络数据损坏 - SipHash 的 IV（初始化向量）不同步 - 恶意对等节点\n针对 AEAD（带关联数据的认证加密）或长度错误的响应： 1. 设置随机超时（建议 100-500ms） 2. 读取随机数量的字节（建议 1KB-64KB） 3. 发送带有原因码 4（AEAD 失败）或 9（帧错误）的终止块 4. 关闭连接\n防止解密预言机攻击: - 在随机超时之前，绝不向对端披露错误类型 - 在进行 AEAD（带关联数据的认证加密）校验之前，绝不跳过长度验证 - 将无效长度视同 AEAD 失败 - 对这两类错误使用相同的错误处理路径\n实施注意事项： - 某些实现若 AEAD（带关联数据的认证加密）错误不频繁，可能会继续运行 - 在错误反复出现时应终止（建议阈值：每小时 3-5 次错误） - 在错误恢复与安全性之间取得平衡\n已发布的 RouterInfo（router 信息记录） Router 地址格式 通过在已发布的 RouterAddress（router 地址）条目中包含特定选项来公布对 NTCP2 的支持。\n传输样式: - \u0026quot;NTCP2\u0026quot; - 此端口仅使用 NTCP2 - \u0026quot;NTCP\u0026quot; - 此端口同时支持 NTCP 和 NTCP2（自动检测） - 注意: NTCP (v1) 支持已在 0.9.50 (May 2021) 中移除 - \u0026ldquo;NTCP\u0026rdquo; 样式现已废弃; 请改用 \u0026ldquo;NTCP2\u0026rdquo;\n必需选项 所有已发布的 NTCP2 地址：\nhost - IP 地址（IPv4 或 IPv6）或主机名\n格式：标准 IP 表示法或域名 对于仅出站或隐藏的 routers，可以省略 port - TCP 端口号\n格式：整数，1-65535 对于仅出站或隐藏的 routers 可以省略 s - 静态公钥（X25519）\n格式：Base64 编码，44 个字符 编码：I2P Base64 字母表 来源：32 字节的 X25519 公钥，小端序 i - 用于 AES 的初始化向量（IV）\n格式：Base64 编码，24 个字符 编码：I2P Base64 字母表 来源：16 字节的 IV，大端序 v - 协议版本\n格式: 整数或用逗号分隔的整数 当前: \u0026quot;2\u0026quot; 未来: \u0026quot;2,3\u0026quot;（必须按数值顺序排列） 可选选项：\ncaps - 能力（自 0.9.50 起）\n格式：由能力字符组成的字符串 取值： \u0026quot;4\u0026quot; - IPv4 出站能力 \u0026quot;6\u0026quot; - IPv6 出站能力 \u0026quot;46\u0026quot; - 同时支持 IPv4 和 IPv6（推荐顺序） 如果已发布 host 则不需要 适用于隐藏的/位于防火墙后的 routers cost - 地址优先级\n格式: 整数, 0-255 数值越低 = 优先级越高 建议: 普通地址使用 5-10 建议: 未发布的地址使用 14 RouterAddress 示例条目 已发布的 IPv4 地址:\n\u0026lt;Address cost=\u0026#34;5\u0026#34;\u0026gt; \u0026lt;transport_style\u0026gt;NTCP2\u0026lt;/transport_style\u0026gt; \u0026lt;options\u0026gt; \u0026lt;host\u0026gt;192.0.2.1\u0026lt;/host\u0026gt; \u0026lt;port\u0026gt;8887\u0026lt;/port\u0026gt; \u0026lt;s\u0026gt;9EjeG7BZeznKbL9a2fXx8JBDPgLZbLmKbqY3QrNGJCo=\u0026lt;/s\u0026gt; \u0026lt;i\u0026gt;MDEyMzQ1Njc4OUFCQ0RFRg==\u0026lt;/i\u0026gt; \u0026lt;v\u0026gt;2\u0026lt;/v\u0026gt; \u0026lt;/options\u0026gt; \u0026lt;/Address\u0026gt; 隐藏 Router (仅出站):\n\u0026lt;Address cost=\u0026#34;14\u0026#34;\u0026gt; \u0026lt;transport_style\u0026gt;NTCP2\u0026lt;/transport_style\u0026gt; \u0026lt;options\u0026gt; \u0026lt;s\u0026gt;9EjeG7BZeznKbL9a2fXx8JBDPgLZbLmKbqY3QrNGJCo=\u0026lt;/s\u0026gt; \u0026lt;v\u0026gt;2\u0026lt;/v\u0026gt; \u0026lt;caps\u0026gt;4\u0026lt;/caps\u0026gt; \u0026lt;/options\u0026gt; \u0026lt;/Address\u0026gt; 双栈 Router：\n\u0026lt;!-- IPv4 Address --\u0026gt; \u0026lt;Address cost=\u0026#34;5\u0026#34;\u0026gt; \u0026lt;transport_style\u0026gt;NTCP2\u0026lt;/transport_style\u0026gt; \u0026lt;options\u0026gt; \u0026lt;host\u0026gt;192.0.2.1\u0026lt;/host\u0026gt; \u0026lt;port\u0026gt;8887\u0026lt;/port\u0026gt; \u0026lt;s\u0026gt;9EjeG7BZeznKbL9a2fXx8JBDPgLZbLmKbqY3QrNGJCo=\u0026lt;/s\u0026gt; \u0026lt;i\u0026gt;MDEyMzQ1Njc4OUFCQ0RFRg==\u0026lt;/i\u0026gt; \u0026lt;v\u0026gt;2\u0026lt;/v\u0026gt; \u0026lt;/options\u0026gt; \u0026lt;/Address\u0026gt; \u0026lt;!-- IPv6 Address (same keys, same port) --\u0026gt; \u0026lt;Address cost=\u0026#34;5\u0026#34;\u0026gt; \u0026lt;transport_style\u0026gt;NTCP2\u0026lt;/transport_style\u0026gt; \u0026lt;options\u0026gt; \u0026lt;host\u0026gt;2001:db8::1\u0026lt;/host\u0026gt; \u0026lt;port\u0026gt;8887\u0026lt;/port\u0026gt; \u0026lt;s\u0026gt;9EjeG7BZeznKbL9a2fXx8JBDPgLZbLmKbqY3QrNGJCo=\u0026lt;/s\u0026gt; \u0026lt;i\u0026gt;MDEyMzQ1Njc4OUFCQ0RFRg==\u0026lt;/i\u0026gt; \u0026lt;v\u0026gt;2\u0026lt;/v\u0026gt; \u0026lt;/options\u0026gt; \u0026lt;/Address\u0026gt; 重要规则： - 使用相同端口的多个 NTCP2 地址必须使用完全相同的 s、i 和 v 值 - 不同端口可以使用不同的密钥 - 双栈 routers 应分别发布 IPv4 和 IPv6 地址\n未发布的 NTCP2 地址 针对仅出站的 router:\n如果一个 router 不接受传入的 NTCP2 连接，但会发起出站连接，它仍然必须发布一个包含以下内容的 RouterAddress（路由地址）：\n\u0026lt;Address cost=\u0026#34;14\u0026#34;\u0026gt; \u0026lt;transport_style\u0026gt;NTCP2\u0026lt;/transport_style\u0026gt; \u0026lt;options\u0026gt; \u0026lt;s\u0026gt;9EjeG7BZeznKbL9a2fXx8JBDPgLZbLmKbqY3QrNGJCo=\u0026lt;/s\u0026gt; \u0026lt;v\u0026gt;2\u0026lt;/v\u0026gt; \u0026lt;/options\u0026gt; \u0026lt;/Address\u0026gt; 目的: - 允许 Bob 在握手期间验证 Alice 的静态密钥 - 用于消息 3 第 2 部分的 RouterInfo 验证所必需 - 无需 i、host 或 port (仅出站)\n替代方案： - 为现有已发布的 \u0026ldquo;NTCP\u0026rdquo; 或 SSU 地址添加 s 和 v\n公钥和IV轮换 关键安全策略:\n通用规则： 1. 在 router 正在运行时切勿进行轮换 2. 持久化存储密钥和 IV（初始化向量） 跨重启 3. 跟踪先前的停机时间 以确定是否符合轮换条件\n轮换前的最小停机时间：\nRouter Type Min Downtime Reason Published NTCP2 address1 monthMany routers cache RouterInfo Published SSU only (no NTCP2)1 dayModerate caching No published addresses (hidden)2 hoursMinimal impact **附加触发条件:** - 本地 IP 地址变更: 无论是否停机，均可能轮换 - Router \"rekey\" (重新生成密钥) (新的 Router Hash): 生成新密钥 理由： - 防止通过密钥更改暴露重启时间 - 允许缓存的 RouterInfos（I2P 路由信息对象）自然过期 - 保持网络稳定性 - 减少失败的连接尝试\n实现： 1. 持久化存储密钥、IV（初始化向量）和上次关闭时间戳 2. 在启动时，计算停机时间 = current_time - last_shutdown 3. 如果停机时间 \u0026gt; 对应 router 类型的最小值，则可以轮换 4. 如果 IP 发生变化或 rekeying（重新生成密钥），则可以轮换 5. 否则，复用先前的密钥和 IV\nIV（初始化向量）轮换： - 适用与密钥轮换相同的规则 - 仅出现在已发布的地址中（非隐藏的 router） - 建议每当密钥更改时更换 IV\n版本检测 上下文： 当 transportStyle=\u0026quot;NTCP\u0026quot;（旧版）时，Bob 在同一端口上同时支持 NTCP v1 和 v2，并且必须自动检测协议版本。\n检测算法：\n1. Wait for at least 64 bytes (minimum NTCP2 message 1 size) 2. If received ≥ 288 bytes: → Connection is NTCP version 1 (NTCP1 message 1 is 288 bytes) 3. If received \u0026lt; 288 bytes: Option A (conservative, pre-NTCP2 majority): a. Wait additional short time (e.g., 100-500ms) b. If total received ≥ 288 bytes → NTCP1 c. Otherwise → Attempt NTCP2 decode Option B (aggressive, post-NTCP2 majority): a. Attempt NTCP2 decode immediately: - Decrypt first 32 bytes (X key) with AES-256-CBC - Verify valid X25519 point (X[31] \u0026amp; 0x80 == 0) - Verify AEAD frame b. If decode succeeds → NTCP2 c. If decode fails → Wait for more data or NTCP1 快速最高有效位（MSB）检查： - 在 AES 解密之前，验证：encrypted_X[31] \u0026amp; 0x80 == 0 - 有效的 X25519 密钥应当最高位为 0 - 失败表明很可能是 NTCP1（或攻击） - 在失败时实现防探测机制（随机超时 + 读取）\n实现要求:\nAlice 的职责：\n在连接到\u0026quot;NTCP\u0026quot;地址时，将消息 1 限制为最多 287 字节 将整个消息 1 缓冲并一次性写出 提高通过单个 TCP 数据包传递的可能性 Bob 的职责：\n在确定版本之前先缓冲已接收的数据 实现正确的超时处理 使用 TCP_NODELAY 以快速进行版本检测 在检测到版本后，将第 2 条消息整体一次性缓冲并刷新发送 安全考虑： - 分段攻击：Bob 应该能够抵御 TCP 分段 - 探测攻击：在失败时引入随机延迟并执行字节读取 - 拒绝服务（DoS）预防：限制并发的挂起连接数 - 读取超时：同时设置单次读取和总体超时（\u0026ldquo;slowloris\u0026rdquo;（慢速 HTTP 攻击）防护）\n时钟偏差指南 时间戳字段： - 消息 1：tsA（Alice 的时间戳） - 消息 2：tsB（Bob 的时间戳） - 消息 3+：可选的 DateTime（日期时间）块\n最大时钟偏移（D）： - 典型：±60 秒 - 可按实现配置 - 偏移量 \u0026gt; D 通常是致命的\nBob 的处理 (消息 1) 1. Receive tsA from Alice 2. skew = tsA - current_time 3. If |skew| \u0026gt; D: a. Still send message 2 (allows Alice to calculate skew) b. Include tsB in message 2 c. Do NOT initiate handshake completion d. Optionally: Temporary ban Alice\u0026#39;s IP e. After message 2 sent, close connection 4. If |skew| ≤ D: a. Continue handshake normally 理由： 即使在时钟偏差的情况下也发送消息 2，以便 Alice 诊断时钟问题。\nAlice 的处理（消息 2） 1. Receive tsB from Bob 2. RTT = (current_time_now - tsA_sent) 3. adjusted_skew = (tsB - current_time_now) - (RTT / 2) 4. If |adjusted_skew| \u0026gt; D: a. Close connection immediately b. If local clock suspect: Adjust clock or use external time source c. If Bob\u0026#39;s clock suspect: Temporary ban Bob d. Log for operator review 5. If |adjusted_skew| ≤ D: a. Continue handshake normally b. Optionally: Track skew for time synchronization RTT（往返时延）调整： - 从计算出的时钟偏移中减去一半的 RTT - 考虑网络传播时延 - 更准确的时钟偏移估计\nBob 的处理 (消息 3) 1. If message 3 received (unlikely if skew exceeded in message 1) 2. Recalculate skew = tsA_received - current_time 3. If |adjusted_skew| \u0026gt; D: a. Send termination block (reason code 7: clock skew) b. Close connection c. Ban Alice for period (e.g., 1-24 hours) 时间同步 DateTime 块 (数据阶段): - 定期发送 DateTime 块 (类型 0) - 接收方可用于时钟校准 - 将时间戳四舍五入到最近一秒 (避免偏差)\n外部时间源： - NTP（网络时间协议） - 系统时钟同步 - I2P 网络共识时间\n时钟调整策略： - 如果本地时钟异常：调整系统时间或使用偏移量 - 如果对等方的时钟持续异常：将该对等方标记为有问题 - 跟踪 skew（时钟偏差）统计用于网络健康监测\n安全属性 前向保密 通过以下方式实现： - 临时 Diffie-Hellman 密钥交换 (X25519) - 三次 DH 操作：es、ee、se (Noise XK 模式) - 握手完成后销毁临时密钥\n机密性演进： - 消息 1：级别 2（发送方被攻陷时具备前向保密性） - 消息 2：级别 1（临时接收方） - 消息 3+：级别 5（强前向保密性）\n完美前向保密: - 长期静态密钥被泄露也绝不会暴露过去的会话密钥 - 每个会话使用唯一的临时密钥 - 临时私钥从不复用 - 密钥协商后清理内存\n限制: - 如果 Bob 的静态密钥泄露，消息 1 将易受攻击（但在 Alice 的密钥被攻破的情况下仍具有前向保密性） - 消息 1 可能遭受重放攻击（可通过时间戳和重放缓存缓解）\n身份验证 相互认证: - Alice 通过第 3 条消息中的静态密钥完成认证 - Bob 通过持有静态私钥完成认证（握手成功即为隐式证明）\n密钥泄露冒充（KCI）抗性： - 认证级别 2（对 KCI 具备抗性） - 即使攻击者拥有 Alice 的静态私钥（但没有 Alice 的临时密钥），也无法冒充 Alice - 即使攻击者拥有 Bob 的静态私钥（但没有 Bob 的临时密钥），也无法冒充 Bob\n静态密钥验证: - Alice 预先知道 Bob 的静态密钥（来自 RouterInfo，I2P 路由信息文件） - Bob 在第 3 条消息中验证 Alice 的静态密钥与 RouterInfo 一致 - 防止中间人攻击\n抗流量分析能力 DPI（深度包检测）对抗措施: 1. AES 混淆: 临时密钥被加密，看起来随机 2. SipHash 长度混淆: 帧长度非明文 3. 随机填充: 消息大小可变，无固定模式 4. 加密帧: 所有负载均使用 ChaCha20 加密\n重放攻击防护： - 时间戳验证 (±60 秒) - 针对临时密钥的重放缓存 (有效期 2*D) - 随机数递增可防止会话内的数据包重放\n抗探测能力: - AEAD（带关联数据的认证加密）失败时随机超时 - 在关闭连接前随机读取字节 - 握手失败时不响应 - 对多次失败的 IP 进行黑名单处理\n填充指南： - 消息 1-2：明文填充（已认证） - 消息 3+：AEAD 帧内的加密填充 - 协商的填充参数（选项块） - 允许仅包含填充的帧\n拒绝服务攻击缓解 连接限制： - 最大活动连接数（取决于实现） - 最大待处理握手数（例如，100-1000） - 每个 IP 的连接限制（例如，同时 3-10 个）\n资源保护: - 对 DH 操作进行速率限制(开销高) - 每个套接字及全局的读取超时 - \u0026ldquo;Slowloris\u0026rdquo; 防护(总时间限制) - 针对滥用行为的 IP 黑名单\n快速拒绝: - 网络ID不匹配 → 立即关闭 - 无效的 X25519 点 → 在解密前进行快速最高有效位（MSB）检查 - 时间戳超出范围 → 不进行计算直接关闭 - AEAD（带附加数据的认证加密）验证失败 → 不响应，随机延迟\n抗探测性： - 随机超时：100-500ms（取决于实现） - 随机读取：1KB-64KB（取决于实现） - 不向攻击者提供错误信息 - 使用 TCP RST 关闭（无 FIN 握手）\n密码学安全 算法: - X25519: 128 位安全性，椭圆曲线 DH（Curve25519） - ChaCha20: 256 位密钥流密码 - Poly1305: 信息论安全的 MAC - SHA-256: 128 位抗碰撞性，256 位抗原像性 - HMAC-SHA256: 用于密钥派生的伪随机函数（PRF）\n密钥长度： - 静态密钥：32 字节 (256 位) - 临时密钥：32 字节 (256 位) - 加密密钥：32 字节 (256 位) - MAC (消息认证码)：16 字节 (128 位)\n已知问题： - ChaCha20 的 nonce 重用会造成灾难性后果（通过计数器递增加以防止） - X25519 存在小子群问题（通过曲线验证加以缓解） - SHA-256 理论上易受长度扩展攻击影响（在 HMAC 中不可利用）\n无已知漏洞（截至2025年10月）： - Noise Protocol Framework（噪声协议框架）已被广泛分析 - ChaCha20-Poly1305 已在 TLS 1.3 中部署 - X25519 已成为现代协议中的标准 - 对该构造暂无实用性攻击\n参考资料 主要规范 NTCP2 规范 - I2P 官方规范 提案 111 - 包含设计理由的原始设计文档 Noise 协议框架 - 第 33 版（2017-10-04） 密码学标准 RFC 7748 - 用于安全的椭圆曲线 (X25519) RFC 7539 - 用于 IETF 协议的 ChaCha20 和 Poly1305 RFC 8439 - ChaCha20-Poly1305（取代 RFC 7539） RFC 2104 - HMAC：用于消息认证的带密钥哈希 SipHash - 用于哈希函数应用的 SipHash-2-4 相关的 I2P 规范 I2NP 规范 - I2P 网络协议消息格式 通用结构 - RouterInfo、RouterAddress 格式 SSU 传输 - UDP 传输（最初版本，现为 SSU2） 提案 147 - 传输网络 ID 检查（0.9.42） 实现参考 I2P Java - 参考实现（Java） i2pd - C++ 实现 I2P 发布说明 - 版本历史和更新 历史背景 站到站协议 (STS) - Noise 框架的灵感来源 obfs4 - 可插拔传输 (SipHash 长度混淆先例) 实现指南 强制性要求 用于合规：\n实现完整握手:\n以正确的 KDF（密钥派生函数）链支持全部三条消息 校验所有 AEAD（附加数据认证加密）标签 验证 X25519（基于 Curve25519 的密钥交换算法）曲线点是否有效 实现数据阶段:\nSipHash 长度混淆（双向） 所有块类型: 0（日期时间）, 1（选项）, 2（RouterInfo）, 3（I2NP）, 4（终止）, 254（填充） 正确的 nonce（一次性随机数）管理（独立计数器） 安全特性：\n重放防护（缓存临时密钥 2*D 的时间） 时间戳校验（默认 ±60 秒） 在消息 1-2 中加入随机填充 AEAD（带关联数据的认证加密）错误处理采用随机超时 RouterInfo（路由信息）发布:\n发布静态密钥（\u0026ldquo;s\u0026rdquo;）、IV（初始化向量，\u0026ldquo;i\u0026rdquo;）和版本（\u0026ldquo;v\u0026rdquo;） 按照策略轮换密钥 支持用于隐藏的 router 的 capabilities（能力）字段（\u0026ldquo;caps\u0026rdquo;） 网络兼容性：\n支持 network ID 字段（当前主网为 2） 与现有的 Java 和 i2pd 实现互操作 同时处理 IPv4 和 IPv6 推荐实践 性能优化：\n缓冲策略：\n一次性发送完整消息（消息 1、2、3） 对握手消息使用 TCP_NODELAY 将多个数据块缓冲合并为单个帧 将帧大小限制在几 KB（以最小化接收端延迟） 连接管理:\n尽可能复用连接 实现连接池 监控连接健康状况 (DateTime blocks，指与日期时间相关的阻塞) 内存管理：\n在使用后将敏感数据清零（短期密钥、DH 结果） 限制并发握手（防止 DoS 拒绝服务） 为频繁分配使用内存池 安全加固：\n抗探测性:\n随机超时：100-500ms 随机字节读取：1KB-64KB 对多次失败的 IP 实施黑名单 不向对等方提供错误细节 资源限制：\n每个 IP 的最大连接数：3-10 最大待处理握手数：100-1000 读取超时：每次操作 30-60 秒 连接总超时：握手阶段 5 分钟 密钥管理：\n静态密钥和初始化向量（IV）的持久化存储 安全随机生成（使用密码学安全随机数生成器） 严格遵循密钥轮换策略 切勿重复使用临时密钥 监控与诊断：\n指标:\n握手成功/失败率 AEAD 错误率 时钟偏移分布 连接持续时间统计 日志记录:\n记录握手失败及其原因代码 记录时钟偏差事件 记录被封禁的 IP 地址 绝不记录敏感的密钥材料 测试:\n针对 KDF 链的单元测试 与其他实现的集成测试 针对数据包处理的模糊测试 针对抗 DoS 能力的负载测试 常见误区 应避免的严重错误:\n随机数重用：\n切勿在会话中途重置随机数计数器 每个方向使用独立的计数器 在达到 2^64 - 1 之前终止会话 密钥轮换:\n切勿在 router 运行时轮换密钥 切勿在不同会话间复用临时密钥 遵循最小停机时间规则 时间戳处理:\n绝不接受已过期的时间戳 计算偏差时始终根据 RTT（往返时延）进行调整 将 DateTime 时间戳舍入到秒 AEAD（带关联数据的认证加密）错误：\n切勿向攻击者透露错误类型 在关闭前始终使用随机延时 将无效长度与 AEAD 失败同等处理 填充:\n切勿在已协商范围之外发送填充数据 始终将填充块放在最后 每个帧中绝不使用多个填充块 RouterInfo:\n始终验证静态密钥是否与 RouterInfo 匹配 切勿泛洪未发布地址的 RouterInfos 始终验证签名 测试方法论 单元测试：\n密码学原语:\n针对 X25519（椭圆曲线密钥协商算法）、ChaCha20（流密码）、Poly1305（消息认证码算法/MAC）、SHA-256（哈希函数）的测试向量 HMAC-SHA256（基于密钥的哈希消息认证码，使用 SHA-256）的测试向量 SipHash-2-4（带密钥的短输入散列，用于哈希表防碰撞）的测试向量 KDF 链（Key Derivation Function，密钥派生函数）:\n针对全部三条消息的已知答案测试 验证 chaining key（链密钥）的传递 测试 SipHash IV（初始向量）的生成 消息解析:\n有效消息解码 无效消息拒绝 边界条件（空、最大大小） 集成测试：\n握手：\n成功完成三次消息交互 时钟偏移拒绝 重放攻击检测 无效密钥拒绝 数据阶段：\nI2NP 消息传输 RouterInfo（路由信息）交换 填充处理 终止消息 互操作性:\n针对 Java I2P 进行测试 针对 i2pd 进行测试 测试 IPv4 和 IPv6 测试已发布和隐藏的 routers 安全测试：\n负向测试：\n无效的 AEAD 标签 重放消息 时钟偏移攻击 畸形帧 DoS（拒绝服务）测试：\n连接泛洪 Slowloris 攻击（慢速 HTTP 头攻击） CPU 耗尽（过度使用 DH/Diffie-Hellman 密钥交换） 内存耗尽 模糊测试:\n随机握手报文 随机的数据阶段帧 随机的数据块类型和大小 无效的密码学参数 从 NTCP 迁移 关于遗留 NTCP 支持（现已移除）：\nNTCP（版本 1）已在 I2P 0.9.50（2021 年 5 月）中移除。所有当前实现都必须支持 NTCP2。历史说明：\n过渡期 (2018-2021):\n0.9.36: 引入 NTCP2（默认禁用） 0.9.37: 默认启用 NTCP2 0.9.40: NTCP 已弃用 0.9.50: NTCP 已移除 版本检测：\n\u0026ldquo;NTCP\u0026rdquo; transportStyle 表明同时支持两个版本 \u0026ldquo;NTCP2\u0026rdquo; transportStyle 表明仅支持 NTCP2 通过消息大小自动检测（287 与 288 字节） 当前状态：\n所有 router 必须支持 NTCP2 \u0026ldquo;NTCP\u0026rdquo; transportStyle 已废弃 仅使用 \u0026ldquo;NTCP2\u0026rdquo; transportStyle 附录 A：Noise XK 模式 标准 Noise XK 模式：\nXK(s, rs): \u0026lt;- s ... -\u0026gt; e, es \u0026lt;- e, ee -\u0026gt; s, se 解释：\n\u0026lt;- : 来自响应方（Bob）发往发起方（Alice）的消息 -\u0026gt; : 来自发起方（Alice）发往响应方（Bob）的消息 s : 静态密钥（长期身份密钥） rs : 远端静态密钥（对端的静态密钥，事先已知） e : 临时密钥（特定于会话，按需生成） es : 临时-静态 DH（Diffie-Hellman）（Alice 的临时 × Bob 的静态） ee : 临时-临时 DH（Alice 的临时 × Bob 的临时） se : 静态-临时 DH（Alice 的静态 × Bob 的临时） 密钥协商流程：\n预消息: Alice 知道 Bob 的静态公钥（来自 RouterInfo，I2P 的路由信息记录） 消息 1: Alice 发送临时密钥，执行 es DH（ephemeral-static，临时-静态） 消息 2: Bob 发送临时密钥，执行 ee DH（ephemeral-ephemeral，临时-临时） 消息 3: Alice 披露静态公钥，执行 se DH（static-ephemeral，静态-临时） 安全属性：\nAlice 已认证：是（由第 3 条消息） Bob 已认证：是（通过持有静态私钥） 前向保密：是（临时密钥已销毁） KCI（Key Compromise Impersonation，密钥泄露冒充攻击）抵抗能力：是（认证级别 2） 附录 B：Base64 编码 I2P Base64 字母表：\nABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-~ 与标准 Base64 的差异： - 字符 62-63：-~ 代替 +/ - 填充：相同（=）或根据上下文省略\n在 NTCP2 中的用法： - 静态密钥 (\u0026ldquo;s\u0026rdquo;): 32 字节 → 44 个字符 (无填充) - IV (初始化向量) (\u0026ldquo;i\u0026rdquo;): 16 字节 → 24 个字符 (无填充)\n编码示例：\n# 32-byte static key (hex): # f4489e1bb0597b39ca6cbf5ad9f5f1f09043e02d96cb9aa6a63742b3462429aa # I2P Base64 encoded: # 9EjeG7BZeznKbL9a2fXx8JBDPgLZbLmKbqY3QrNGJCo= 附录C：数据包捕获分析 识别 NTCP2 流量：\nTCP 握手:\n标准的 TCP SYN、SYN-ACK、ACK 目标端口通常为 8887 或类似端口 消息 1 (SessionRequest, 会话请求):\n来自 Alice 的首个应用数据 80-65535 字节（通常为几百字节） 看起来像随机数据（AES 加密的临时密钥） 如果连接到 \u0026ldquo;NTCP\u0026rdquo; 地址，最大为 287 字节 消息 2 (SessionCreated):\n来自 Bob 的响应 80-65535 字节（通常为几百字节） 同样看起来是随机的 消息 3 (SessionConfirmed，会话确认):\n来自 Alice 48 字节 + 可变 (RouterInfo (路由器信息) 大小 + 填充) 通常为 1-4 KB 数据阶段:\n可变长度帧 长度字段被混淆（看起来随机） 加密的有效载荷 填充使大小不可预测 DPI 规避: - 无明文头部 - 无固定模式 - 长度字段已混淆 - 随机填充使基于大小的启发式失效\n与 NTCP 的比较： - NTCP 消息 1 始终为 288 字节（可识别） - NTCP2 消息 1 大小可变（不可识别） - NTCP 存在可识别的模式 - NTCP2 旨在抵抗深度包检测（DPI）\n附录 D：版本历史 主要里程碑：\n0.9.36 (2018年8月23日): 引入 NTCP2，默认禁用 0.9.37 (2018年10月4日): NTCP2 默认启用 0.9.40 (2019年5月20日): NTCP 已弃用 0.9.42 (2019年8月27日): 添加了网络 ID 字段 (提案 147) 0.9.50 (2021年5月17日): 移除了 NTCP，添加了 capabilities (能力标识) 支持 2.10.0 (2025年9月9日): 最新稳定版 协议稳定性： - 自 0.9.50 起无不兼容变更 - 持续提升抗探测能力 - 重点关注性能与可靠性 - 后量子密码学开发中（默认未启用）\n当前传输状态: - NTCP2: 强制的 TCP 传输 - SSU2: 强制的 UDP 传输 - NTCP (v1): 已移除 - SSU (v1): 已移除\n","description":"用于 router 间链路的基于 Noise 的 TCP 传输","id":"4882afdd530d8c7e8da14bb97487aecc","section":"docs","title":"NTCP2 传输","url":"/zh/docs/specs/ntcp2/"},{"categories":null,"content":"概述 本文档规定了一种可重随机化的签名方案，适用于创建可盲化的 Destinations（目的地）。此外，它还可用于对现有的 Ed25519 Destinations 进行盲化，但有效性会略有降低。\n自 0.9.39 版（发布于 2019 年 3 月 21 日）起，Red25519 已在 I2P router 上全面投入运行。经过 17 个月的生产环境部署后，该规范在 0.9.47 版（2020 年 8 月）中最终定稿。该签名方案在 I2P 网络中作为签名类型 11（RedDSA_SHA512_Ed25519）运行。\n动机 提案 123（新的 netDB 条目）定义了一种加密的 LeaseSet2 格式，它体现了最小权限原则：每个网络参与者只会获得其角色所必需的信息。尤其是，发布到 floodfill 的加密 LeaseSet2 不会暴露其对应的 Destination（目标标识），并且其中的租约只能被事先知晓该 Destination 的一方查看。不过，各个 floodfill 在发布加密的 LeaseSet2 时仍需要能够对其进行认证，而客户端还需要进一步确保该认证确实由 Destination 本身强制执行。\n提案 123 通过对 Destination（目的地标识）的签名密钥进行盲化来实现这一点。盲化后的密钥可用于创建可被 floodfills 验证的签名，客户端可以确信只有该 Destination 才能创建这些签名。因此有必要指定一种可用于盲化的签名方案。\n关于提案 123 状态的说明: 自 0.9.38 版本起，提案 123 的部分内容已逐步实现并部署，并在 0.9.39 中加入了 Red25519 支持。加密的 LeaseSet2 功能已达到生产就绪状态，并已在 I2P 网络中积极用于隐私增强型隐藏服务。\n设计 核心签名方案 此处指定的签名方案 Red25519，是 Zcash 协议规范（Sapling 及之后版本）第 5.4.6 节中定义的 RedDSA 的一个实例化。RedDSA 是一种基于 Schnorr 的签名方案，支持密钥重随机化。它提供以下函数：\nGENERATE_PRIVATE() : 返回一个均匀分布的随机私钥。\nDERIVE_PUBLIC(sk) : 返回与给定私钥对应的公钥。\nGENERATE_RANDOM() : 返回一个适用于对密钥对重新随机化的随机标量。\nRANDOMIZE_PRIVATE(sk, alpha) : 使用秘密标量 alpha 对私钥进行重新随机化。\nRANDOMIZE_PUBLIC(vk, alpha) : 使用秘密标量 alpha 对公钥进行重随机化。\nSIGN(sk, m) : 返回由私钥 sk 对给定消息 m 生成的签名。\nVERIFY(vk, m, sig) : 根据公钥 vk 和消息 m 验证签名 sig。若签名有效则返回 true，否则返回 false。\n对于给定的密钥对 (sk, vk)，以下关系成立：\nRANDOMIZE_PUBLIC(vk, alpha) == DERIVE_PUBLIC(RANDOMIZE_PRIVATE(sk, alpha)) 将 Ed25519（椭圆曲线签名算法）密钥转换为 Red25519（基于 Ed25519 的签名变体） 为支持对现有的 Ed25519 Destination（目的地标识）进行重新随机化，Ed25519 密钥可以被临时地单向转换为 Red25519 密钥。其他签名类型不兼容。\n我们定义以下转换函数：\nCONVERT_ED25519_PRIVATE(privkey) : 返回与给定的 Ed25519 私钥对应的 Red25519 私钥。\nCONVERT_ED25519_PUBLIC(pubkey) : 返回与给定 Ed25519 公钥相对应的 Red25519 公钥（Ed25519 公钥的转换表示）。\n对于给定的 Ed25519 密钥对 (privkey, pubkey)，满足以下关系：\nCONVERT_ED25519_PUBLIC(pubkey) == DERIVE_PUBLIC(CONVERT_ED25519_PRIVATE(privkey)) 规范 定义 B : 与 RFC 8032 中的 Ed25519 基点相同。\nL : Ed25519 的阶为 2^252 + 27742317777372353535851937790883648493，如 RFC 8032 所述。\n[s] B : 用 s 对基点进行固定基标量乘法。\n[s] A : 用标量 s 对 A 进行可变基点标量乘法。\nx || y : 拼接两个字节数组 x 和 y。\nRed25519（I2P 中使用的一种签名算法类型） Red25519 方案对 RedDSA 的专化如下：\nG := Curve25519 的 Edwards 形式上的点群。更具体地说，这意味着 Red25519 使用阶为 L 的素阶子群，且余因子 h_G 为 8。 P_G := Ed25519 的基点 B。 l_H := 512 H(x) := SHA-512(\u0026ldquo;I2P_Red25519H(x)\u0026rdquo; || x) 关于哈希函数选择的说明：Red25519 使用 SHA-512，而非 BLAKE2b-512（Zcash 的 RedDSA 使用 BLAKE2b-512）。该设计取舍由下文所述的长度前缀保护加以弥补。I2P 提案 148 建议未来迁移到 BLAKE2b-512，以增强对重复消息识别（Duplicate Message Identification，DMI）和长度扩展攻击（Length Extension Attacks，LEA）的防护，并提升性能。\nRedDSA 假设 H(x) 由一种能抵御长度扩展攻击的密码学哈希函数实例化。SHA-512 本身并不满足这一点。为解决这一问题，我们要求在消息前加上其长度的无前缀编码作为前缀：\nlen_u16(M) || M 其中 len_u16(M) 是 M 的长度的 2 字节表示，采用小端序（以与标量和点的小端编码保持一致）。\n消息不得长于 65534 字节。长度 65535 被保留用于未来可能的扩展。\n安全说明: 在哈希函数中包含公钥（vk），并在签名过程中加入80个随机字节，可防御在早期 RedDSA 设计中发现的 SURK-CMA（在选择消息攻击下使用重新随机化密钥的强不可伪造性）漏洞。本实现采纳了 NCC Group 对 Zcash 审计中的安全修复（发现编号 NCC-Zcash2018-009）。\n编码与解码 Red25519 私钥是模 L 的标量，采用小端序表示进行编码。我们定义函数 DECODE_SCALAR 和 ENCODE_SCALAR，用于在标量的字节数组形式与整数形式之间进行转换。\nRed25519（使用 Curve25519 的 Edwards 形式）公钥是 Curve25519 的 Edwards 形式上的点。其编码为 y 坐标的 255 位小端表示，后跟一个用于指示 x 坐标符号的单个比特。这与 Ed25519 的编码相同。我们定义了函数 DECODE_POINT 和 ENCODE_POINT，用于在点的字节数组形式与坐标形式之间进行转换。\nRedDSA 函数 为便于实现，我们在下文明确列出已针对 Red25519（RedDSA 的一种特定实现）专门化的 RedDSA（数字签名算法）函数，以及若干辅助函数。实现者应参考 Zcash Protocol Specification（Zcash 协议规范）第 5.4.6 节，了解 RedDSA 函数的一般性规范。\nHStar(prefix1, prefix2, m) := h = SHA-512() h.input(\u0026#34;I2P_Red25519H(x)\u0026#34;) h.input(prefix1) h.input(prefix2) h.input(len(m) \u0026amp; 0xff) h.input((len(m) \u0026gt;\u0026gt; 8) \u0026amp; 0xff) h.input(m) s = h.digest() return s mod L GENERATE_PRIVATE := s = 64 random bytes return s mod L DERIVE_PUBLIC(sk) := [sk] B GENERATE_RANDOM := s = 64 random bytes return s mod L RANDOMIZE_PRIVATE(sk, alpha) := (sk + alpha) mod L RANDOMIZE_PUBLIC(vk, alpha) := vk + [alpha] B SIGN(sk, m) := T = 80 random bytes vkBytes = ENCODE_POINT(DERIVE_PUBLIC(sk)) r = HStar(T, vkBytes, m) R = [r] B Rbytes = ENCODE_POINT(R) c = HStar(Rbytes, vkBytes, m) S = (r + (c * sk)) mod L return Rbytes || ENCODE_SCALAR(S) VERIFY(vk, m, sig) := Rbytes = sig[0..32] Sbytes = sig[32..64] R = DECODE_POINT(Rbytes) if R is invalid: return false S = DECODE_SCALAR(Sbytes) if S \u0026gt;= L: return false vkBytes = ENCODE_POINT(vk) c = HStar(Rbytes, vkBytes, m) return ((-[S] B) + R + ([c] vk)).multiplyByCofactor().isIdentity() 转换函数 CONVERT_ED25519_PRIVATE(privkey) := s = SHA-512(privkey)[0..32] s[0] = s[0] \u0026amp; 248 s[31] = (s[31] \u0026amp; 63) | 64 return s CONVERT_ED25519_PUBLIC(pubkey) := pubkey 注意，CONVERT_ED25519_PRIVATE 的实现等同于在从 Ed25519 私钥派生 Ed25519 公钥时对秘密标量 s 的计算，如 RFC 8032 第 5.1.5 节的步骤 1-3 所述。\n安全影响 对一个 Red25519 Destination（目标地址）进行重新随机化，然后使用它创建签名，并不会泄露关于该 Destination 的任何信息，因为通过 RANDOMIZE_PRIVATE 生成的 Red25519 私钥的分布与通过 GENERATE_PRIVATE 生成的私钥分布完全相同，而且 DERIVE_PUBLIC 是确定性的。\n通过 CONVERT_ED25519_PRIVATE 将 Ed25519 私钥转换为 Red25519（Ed25519 密钥的一种重新映射/重新编码形式）并不会得到相同的分布。然而，基于以下原因，我们认为这种安全性降低是可以接受的：\nEd25519 标量的取值空间大约只有 Red25519 标量空间的一半（共有 2^251 个可能的 Ed25519 标量，而 Red25519 则有 L ~= 2^252 个可能的标量）。因此，安全性损失至多约为 2 倍，或约 1 比特（因为我们可能碰巧选到一个同时也是有效 Ed25519 标量的 Red25519 标量）。 现有的 Ed25519 Destination（I2P 目标地址标识）过去已在网络上暴露，应当假定恶意的 floodfills（负责 netDb 填充与索引的节点）已经对它们进行了枚举。 重要: 对该安全性降低感到担忧的用户应将其 Destinations（目标标识）的 sigtype 设为 Red25519（签名类型 11），而非 Ed25519（签名类型 7）。\n请注意，上述论证不适用于 re-randomization scalar alpha（再随机化用的标量 alpha）；每当选择一个有偏的 alpha 时，都会泄露关于密钥的信息，因为加性再随机化的行为类似于一次性密码本。\n安全审计状态 重要披露：I2P（包括 Red25519（基于 curve25519 的数字签名方案））从未接受过正式的第三方安全审计。其底层的 RedDSA（一种数字签名算法）设计在 2018 年作为 Zcash Sapling 协议审计的一部分由 NCC Group 进行过安全评审，当时识别并修复了安全问题。然而，I2P 使用 SHA-512（而非 BLAKE2b-512）以及 I2P 的域分离的特定实现尚未经过独立分析。\n由 str4d 编写的 ed25519-java 参考实现曾接受过一次独立的第三方审计，但该审计早于 Red25519 的实现，且仅涵盖 Ed25519（基于椭圆曲线的签名算法）的功能，未涉及 Red25519（Ed25519 的扩展）相关功能。\n部署 Red25519 的用户应了解这一限制，并根据其威胁模型评估安全权衡。\n兼容性 支持 Red25519（签名算法类型）的 I2P 版本（0.9.39 及更高版本）将能够验证使用该算法签名的网络数据结构。不支持 Red25519 的 I2P 版本会将其视为未知签名，并可能（MAY）丢弃这些数据结构。\n部署时间线: - 0.9.39 (2019 年 3 月): 首次实现，在 floodfills 中加入对 Encrypted LS2 的支持 - 0.9.40 (2019 年 5 月): 为 Encrypted LS2 提供按客户端授权 - 0.9.41 (2019 年 8 月): Meta LS2 和带离线密钥的 Encrypted LS2 - 0.9.43 (2020 年 2 月): 为 Encrypted LS2 提供 b32 支持 - 0.9.47 (2020 年 8 月): 规范定稿 - 2.10.0 (2025 年 10 月): 当前网络版本 (等同于 0.9.67+)\n用户可预期，采用 Red25519（I2P 使用的一种签名算法）签名的数据结构在加密的 LeaseSet2 用例中具有良好可靠性，因为自最初实现以来，网络已有超过六年的升级窗口。然而，关于一般 destination（I2P 目标标识）使用的采用情况指标尚未公开。\n主要使用场景: Red25519 主要用于需要密钥盲化（key blinding）的加密 LeaseSet2 功能。对于没有加密 leaseset 需求的标准目的地，Ed25519（签名类型 7）由于兼容性更广且拥有更长时间的验证记录，仍是推荐的选择。\n实现说明 Red25519 在 I2P Java router 中由 net.i2p.crypto.eddsa.RedDSAEngine 实现，并将 str4d（Jack Grigg）编写的 ed25519-java 库作为 Maven 依赖 net.i2p.crypto:eddsa（版本 0.1.0 至 0.3.0）。\ni2pd 的 C++ 实现也支持 Red25519（signaturetype=11），用于发布加密的 LeaseSet。\ni2pd 的配置示例：\nsignaturetype=11 i2cp.leaseSetType=5 加密的 LeaseSet2 兼容性: 加密的 LeaseSet 规范要求，unblinded destination（未去盲的 destination）中的签名公钥必须为 Ed25519 (signature type 7) 或 Red25519 (signature type 11)。对于加密的 leaseset 功能，不支持其他签名类型。\n测试向量 下列测试向量用于验证实现。每个向量包括：\nedsk: Ed25519 私钥（随机） edpk: 与 edsk 对应的 Ed25519 公钥 sk: CONVERT_ED25519_PRIVATE(edsk) vk: CONVERT_ED25519_PUBLIC(edpk) msg: 待签名的消息 sig: SIGN(sk, msg) alpha: GENERATE_RANDOM() rsk: RANDOMIZE_PRIVATE(sk, alpha) rvk: RANDOMIZE_PUBLIC(vk, alpha) rsig: SIGN(rsk, msg) 实现说明：这些测试向量应集成到自动化单元测试套件中，以实现持续验证。实现者应验证所有转换、签名以及重新随机化操作与这些期望值一致。\n测试向量 1 edsk: 0101010101010101010101010101010101010101010101010101010101010101 edpk: 8a88e3dd7409f195fd52db2d3cba5d72ca6709bf1d94121bf3748801b40f6f5c sk: 58e86efb75fa4e2c410f46e16de9f6acae1a1703528651b69bc176c088bef36e vk: 8a88e3dd7409f195fd52db2d3cba5d72ca6709bf1d94121bf3748801b40f6f5c msg: 0202020202020202020202020202020202020202020202020202020202020202 sig: 61f5527f4d3b46de4b2c234390370bf715ae9098907a0d191ba1b44b23a8ac1a 6a40437a5294e9503faaf9bd2b7f2fe7ba44dec487b3185aba7ff7d7a17cd40f alpha: ae9ba9cbbc047c442448fca7c9f4e288a202ed520bfad0c784b792b7773cee08 rsk: 8bb85f3c7a494a08890d7d142109c1a3501d04565d80227e2079097800fbe107 rvk: 6fe128737b8e76fa66698a748b0dc0a89168dd8a0601c2b1c0b26835d323e9b3 rsig: 533053074d3b44f08723aab988ede9880a001b7a684d4a98f2d1b88fabee07a5 b5c9430c69a690321e0cb8365d7aeb6688bcbad2c0780e0c69e8a1b4a45f3001 测试向量 2 edsk: 0202020202020202020202020202020202020202020202020202020202020202 edpk: 8139770ea87d175f56a35466c34c7ecccb8d8a91b4ee37a25df60f5b8fc9b394 sk: a83c626bc9c38c8c201878ebb1d5b0b50ac40e8986c78793db1d4ef369fca14e vk: 8139770ea87d175f56a35466c34c7ecccb8d8a91b4ee37a25df60f5b8fc9b394 msg: 0303030303030303030303030303030303030303030303030303030303030303 sig: 0829e58eb5399870f009bd1f0270264e556424bda7a93fbcec99f6d9d75db46d 5c3cb546d9947ca7c1200876c8775a90c357a2aef3d2f16388242ee1914b1a0a alpha: 98b615d9027e996cc2796c019d9c8beb46aa7d2b6eea2e5d98eb29eb1584c203 rsk: 9fcfaa734852ca40b3810ebef590e138516e8cb4f4b1b6f0730978de7f806402 rvk: 527e121090158419609e4a0d8de6f7d3271b353a8cd0b8172fe41468ea1e9177 rsig: 9a6961f35ed264a946cd6214b2326a6e6caa426c2a61bc14367fd278e0b5fb51 3ac065a69210a457f17d12ba8a496cfd835002691affa8efcdecae48135c090f 注意：附加的测试向量 3-10 遵循相同的格式，可在参考实现中找到。\n参考资料 提案 123：新的 netDB 条目 - 部分已在 0.9.38、0.9.39 及后续版本中实现并部署 Zcash 协议规范，第 5.4.6 节：RedDSA、RedJubjub 和 RedPallas - RedDSA 作为 Zcash 协议规范的一部分被定义；已由 NCC Group 进行安全审计（2019 年 1 月） RFC 8032：Edwards 曲线数字签名算法（EdDSA） 提案 148：RedDSA-BLAKE2b-Ed25519 - 已提出但尚未实现；建议未来迁移至 BLAKE2b-512 加密 LeaseSet 规范 底层密码学规范 ","description":"用于创建盲化 Destinations（I2P 中的终端标识）的可重随机化签名方案","id":"31b087e2977ad9f01f6b3b93e6af1f20","section":"docs","title":"Red25519 签名方案","url":"/zh/docs/specs/red25519-signature-scheme/"},{"categories":null,"content":"关于 Reseed（引导）主机 新的 router 需要少量对等节点才能加入 I2P 网络。Reseed hosts（用于初始引导的主机）通过加密的 HTTPS 下载提供该初始引导集合。每个 reseed 包都由主机签名，防止未认证方篡改。已加入网络的 router 若其对等节点集变得陈旧，可能会偶尔进行 reseed。\n网络引导流程 当 I2P router 首次启动或长时间离线后，需要 RouterInfo（路由信息）数据来连接到网络。由于该 router 尚无现有对等节点，它无法从 I2P 网络内部获取该信息。reseed（获取初始节点的引导）机制通过从受信任的外部 HTTPS 服务器提供 RouterInfo 文件，来解决这一引导问题。\nreseed（初始种子获取）过程会以单个经加密签名的捆绑包形式提供 75–100 个 RouterInfo 文件。这可确保新的 routers 能够快速建立连接，同时不暴露于可能将其隔离到彼此独立且不受信任的网络分区中的中间人攻击。\n当前网络状态 截至 2025 年 10 月，I2P 网络运行的 router 版本为 2.10.0（API 版本 0.9.67）。在 0.9.14 版本引入的 reseed（用于为新节点提供网络引导信息的机制）协议，其核心功能保持稳定，未发生变化。该网络维护着多台相互独立的 reseed 服务器，全球分布，以确保可用性与抗审查能力。\n服务 checki2p 每 4 小时监控所有 I2P reseed（节点引导）服务器，为 reseed 基础设施提供实时状态检查和可用性指标。\nSU3 文件格式规范 SU3 文件格式是 I2P 的 reseed（初始节点引入）协议的基础，提供带有密码学签名的内容分发。理解该格式对于实现 reseed 服务器和客户端至关重要。\n文件结构 SU3 格式由三个主要组件组成：头部（40+ 字节）、内容（可变长度）和签名（长度由头部指定）。\n头部格式（至少包含字节 0–39） Byte Range Field Description 0-5Magic NumberASCII string \"I2Psu3\" (0x493250737533) 6ReservedUnused, must be 0x00 7File Format VersionCurrent version: 0x00 8-9Signature TypeBig-endian 16-bit integer. Type 6 = RSA-4096-SHA512 (reseed standard) 10-11Signature LengthBig-endian 16-bit integer. 512 bytes (0x0200) for RSA-4096 12ReservedUnused, must be 0x00 13Version LengthMinimum 16 bytes (0x10) for compatibility 14ReservedUnused, must be 0x00 15Signer ID LengthLength of UTF-8 signer identifier string 16-23Content LengthBig-endian 64-bit integer, length of content in bytes 24ReservedUnused, must be 0x00 25File Type0x00 = ZIP, 0x01 = XML, 0x02 = HTML, 0x03 = XML.GZ, 0x04 = TXT.GZ, 0x05 = DMG, 0x06 = EXE 26ReservedUnused, must be 0x00 27Content Type0x00 = unknown, 0x01 = router update, 0x02 = plugin, 0x03 = reseed, 0x04 = news, 0x05 = blocklist 28-39PaddingUnused, must be all zeros 40-55Version StringASCII version string, padded with zeros (minimum 16 bytes) 56-...Signer IDUTF-8 encoded signer identifier (e.g., \"user@mail.i2p\") ### Reseed（获取初始 netDb 的过程）专用的 SU3 参数 对于 reseed（引导）捆绑包，SU3 文件必须具有以下特性：\n文件名：必须完全为 i2pseeds.su3 内容类型（第 27 字节）：0x03（RESEED） 文件类型（第 25 字节）：0x00（ZIP） 签名类型（第 8-9 字节）：0x0006（RSA-4096-SHA512） 版本字符串：ASCII 编码的 Unix 时间戳（自 Unix 纪元起的秒数，date +%s 格式） 签名者 ID：与 X.509 证书 CN 匹配的电子邮件风格标识符（CN 即 Common Name，通用名称） 网络ID查询参数 自 0.9.42 版本起，routers 会在 reseed（初始引导）请求后附加 ?netid=2。这可防止跨网络连接，因为测试网络使用不同的网络 ID。当前 I2P 生产网络使用网络 ID 2。\n示例请求：https://reseed.example.com/i2pseeds.su3?netid=2\nZIP 内容结构 内容部分（在头部之后、签名之前）包含一个标准的 ZIP 存档，并需满足以下要求：\n压缩: 标准 ZIP 压缩（DEFLATE） 文件数量: 通常为 75-100 个 RouterInfo（路由器信息数据结构）文件 目录结构: 所有文件必须位于顶层目录（无子目录） 文件命名: routerInfo-{44-character-base64-hash}.dat Base64 字母表: 必须使用 I2P 的修改版 base64 字母表 I2P 的 base64 字符集不同于标准 base64，它使用 - 和 ~ 代替 + 和 /，以确保与文件系统和 URL 兼容。\n数字签名 签名覆盖整个文件，从字节0一直到内容部分的末尾。签名本身追加在内容之后。\n签名算法 (RSA-4096-SHA512) 计算从字节 0 到内容末尾的 SHA-512 哈希值 使用 \u0026ldquo;raw\u0026rdquo; RSA（指不带哈希/填充的裸 RSA，Java 术语为 NONEwithRSA）对该哈希进行签名 如有必要，在签名前填充前导零，使其长度达到 512 字节 将 512 字节的签名追加到文件末尾 签名验证过程 客户端必须：\n读取字节0-11以确定签名类型和长度 读取整个头部以定位内容边界 在流式处理内容的同时计算SHA-512哈希 从文件末尾提取签名 使用签名者的RSA-4096公钥验证签名 如果签名验证失败，则拒绝该文件 证书信任模型 Reseed（用于引导初始化 netDb 的过程）签名密钥以使用 RSA-4096 密钥的自签名 X.509 证书形式分发。这些证书包含在 I2P router 软件包的 certificates/reseed/ 目录中。\n证书格式： - 密钥类型：RSA-4096 - 签名：自签名 - 主题 CN：必须与 SU3 头中的签名者 ID 匹配 - 有效期：客户端应强制执行证书的有效期\n运行 Reseed（补种）服务器 运营 reseed（引导种子）服务需要对安全性、可靠性以及网络多样性方面的要求给予细致关注。更多彼此独立的 reseed 服务器会提升韧性，并使攻击者或审查者更难阻止新的 router 加入。\n技术要求 服务器规格 操作系统: Unix/Linux (Ubuntu, Debian, FreeBSD 已测试并推荐) 网络连接: 需要静态 IPv4 地址，IPv6 建议但可选 CPU: 至少 2 核心 RAM: 至少 2 GB 带宽: 每月约 15 GB 在线时间: 需要 24/7 持续运行 I2P Router: 持续运行且良好集成的 I2P router 软件需求 Java: JDK 8 或更高版本（从 I2P 2.11.0 开始将需要 Java 17+） Web 服务器: 具有反向代理支持的 nginx 或 Apache（由于 X-Forwarded-For 头部限制，Lighttpd 不再受支持） TLS/SSL: 有效的 TLS 证书（Let\u0026rsquo;s Encrypt、自签名或商业 CA） DDoS 防护: fail2ban 或等效工具（强制要求，不可选） Reseed 工具（引导获取网络节点）: 来自 https://i2pgit.org/idk/reseed-tools 的官方 reseed-tools 安全需求 HTTPS/TLS 配置 Protocol: 仅限 HTTPS，不支持回退到 HTTP TLS Version: 最低要求 TLS 1.2 Cipher Suites: 必须支持与 Java 8+ 兼容的强密码套件 Certificate CN/SAN: 必须与所提供的 URL 的主机名匹配 Certificate Type: 如已与开发团队沟通，可使用自签名证书；或使用受认可的 CA（证书颁发机构）签发的证书 证书管理 SU3 签名证书与 TLS 证书的用途不同：\nTLS 证书 (certificates/ssl/): 保障 HTTPS 传输安全 SU3 签名证书 (certificates/reseed/): 为 reseed（引导）包签名 两份证书都必须提供给 reseed（引导）协调员（zzz@mail.i2p），以便纳入 router 软件包。\nDDoS 和反爬虫防护 Reseed 服务器（用于初始引导网络的服务器）面临来自有缺陷的实现、僵尸网络以及试图爬取 netDb（网络数据库）的恶意行为者的周期性攻击。防护措施包括：\nfail2ban: 用于速率限制与攻击缓解的必需组件 捆绑多样性: 向不同请求方提供不同的 RouterInfo（路由信息）集合 捆绑一致性: 向来自同一 IP 且在可配置时间窗口内的重复请求交付相同的捆绑 IP 日志记录限制: 不得公开日志或 IP 地址（隐私政策要求） 实现方法 方法 1：官方 reseed-tools（用于 netDb 重新播种的工具）（推荐） 由 I2P 项目维护的官方实现。代码仓库：https://i2pgit.org/idk/reseed-tools\n安装:\n# Install dependencies sudo apt-get install golang git # Clone repository git clone https://i2pgit.org/idk/reseed-tools.git cd reseed-tools # Build make # Generate keys and start server (first run) ./reseed-tools reseed \\ --signer=your-email@mail.i2p \\ --netdb=/path/to/i2p/netDb \\ --tlsHost=your-domain.tld \\ --port=8443 首次运行时，工具将生成: - your-email@mail.i2p.crt (SU3 签名证书) - your-email@mail.i2p.pem (SU3 签名私钥) - your-email@mail.i2p.crl (证书吊销列表) - TLS 证书和密钥文件\n功能: - 自动生成 SU3 包 (350 种变体，每个包含 77 个 RouterInfos) - 内置 HTTPS 服务器 - 通过 cron 每 9 小时重建缓存 - 通过 --trustProxy 标志支持 X-Forwarded-For 请求头 - 兼容反向代理配置\n生产部署:\n# Create systemd service cat \u0026gt; /etc/systemd/system/i2p-reseed.service \u0026lt;\u0026lt; EOF [Unit] Description=I2P Reseed Server After=network.target [Service] Type=simple User=i2p-reseed WorkingDirectory=/opt/i2p-reseed ExecStart=/opt/i2p-reseed/reseed-tools reseed \\ --signer=your-email@mail.i2p \\ --netdb=/var/lib/i2p/netDb \\ --port=8443 \\ --ip=127.0.0.1 \\ --trustProxy Restart=always [Install] WantedBy=multi-user.target EOF systemctl enable i2p-reseed systemctl start i2p-reseed 方法 2：Python 实现（pyseeder） 由 PurpleI2P 项目提供的替代实现: https://github.com/PurpleI2P/pyseeder pip install pyseeder # Generate SU3 file echo \u0026#34;your_password\u0026#34; | pyseeder reseed \\ --netdb /path/to/netDb \\ --private-key priv_key.pem \\ --outfile i2pseeds.su3 \\ --signer-id user@mail.i2p # Serve via built-in server pyseeder serve \\ --port 8443 \\ --host 0.0.0.0 \\ --private-key priv_key.pem \\ --cert user_at_mail.i2p.crt \\ --file i2pseeds.su3 方法三：Docker 部署 对于容器化环境，已有多种可直接用于 Docker 的实现：\nDivaExchange i2p-reseed: https://github.com/diva-exchange/i2p-reseed RTradeLtd/i2p-tools-1: 添加对 Tor onion service（洋葱服务）和 IPFS 的支持 反向代理配置 nginx 配置 upstream i2p_reseed { server 127.0.0.1:8443; } server { listen 443 ssl http2; server_name reseed.example.com; ssl_certificate /path/to/tls-cert.crt; ssl_certificate_key /path/to/tls-key.key; ssl_protocols TLSv1.2 TLSv1.3; ssl_ciphers HIGH:!aNULL:!MD5; location / { proxy_pass http://i2p_reseed; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $remote_addr; proxy_set_header Host $host; } } Apache 配置 \u0026lt;VirtualHost *:443\u0026gt; ServerName reseed.example.com SSLEngine on SSLCertificateFile /path/to/tls-cert.crt SSLCertificateKeyFile /path/to/tls-key.key SSLProtocol all -SSLv2 -SSLv3 -TLSv1 -TLSv1.1 ProxyRequests Off \u0026lt;Proxy *\u0026gt; Order deny,allow Allow from all \u0026lt;/Proxy\u0026gt; ProxyPass / http://127.0.0.1:8443/ ProxyPassReverse / http://127.0.0.1:8443/ \u0026lt;/VirtualHost\u0026gt; 注册与协调 要将你的 reseed 服务器纳入官方 I2P 软件包：\n完成部署和测试 将两份证书（SU3 签名和 TLS）发送给 reseed 协调员（reseed：网络引导种子分发） 联系：zzz@mail.i2p 或 zzz@i2pmail.org 在 IRC2P 上加入 #i2p-dev，与其他运营者协调 运维最佳实践 监控与日志记录 启用 Apache/nginx 的 combined 日志格式用于统计 启用日志轮转（日志增长很快） 监控 bundle（打包产物）的生成成功率和重建耗时 跟踪带宽使用情况和请求模式 切勿公开 IP 地址或详细访问日志 维护计划 每 9 小时：重建 SU3（I2P 更新包格式）包缓存（通过 cron 自动化） 每周：审查日志中的攻击模式 每月：更新 I2P router 和 reseed-tools（用于初始化 netDb 的工具） 按需：续订 TLS 证书（使用 Let\u0026rsquo;s Encrypt 实现自动化） 端口选择 默认：8443 (推荐) 可选：1024-49151 之间的任意端口 端口 443：需要 root 权限或端口转发 (建议使用 iptables 重定向) 端口转发示例：\niptables -A PREROUTING -t nat -p tcp --dport 443 -j REDIRECT --to-port 8443 替代的重新播种方法 其他 bootstrap（引导初始化）选项可帮助处于受限网络环境中的用户：\n基于文件的Reseed（引导） 在 0.9.16 版本中引入的基于文件的 reseed（引导种子）允许用户手动加载 RouterInfo（I2P router 的信息记录）包。这种方法对处于因审查而封锁了 HTTPS reseed 服务器的地区的用户尤其有用。\n流程: 1. 受信任的联系人使用其 router 生成一个 SU3 包 2. 通过电子邮件、USB 驱动器或其他带外渠道传输该包 3. 用户将 i2pseeds.su3 放入 I2P 配置目录中 4. Router 在重启时会自动检测并处理该包\n文档: /blog/2020/06/07/help-your-friends-join-i2p-by-sharing-reseed-bundles/\n使用场景: - 处在封锁了 reseed 服务器的国家级防火墙之后的用户 - 需要手动引导的隔离网络 - 测试与开发环境\n使用 Cloudflare 代理的重新播种 通过 Cloudflare 的 CDN（内容分发网络）路由 reseed（引导）流量，可为处于审查严格地区的运营者带来多重优势。\n优势: - 源站 IP 地址对客户端隐藏 - 通过 Cloudflare 的基础设施实现 DDoS 防护 - 通过边缘缓存实现地理负载分发 - 为全球用户提升性能\n实施要求: - 在 reseed-tools 中启用 --trustProxy 标志 - 为 DNS 记录启用 Cloudflare 代理 - 正确处理 X-Forwarded-For 请求头\n重要注意事项: - 适用 Cloudflare 端口限制（必须使用受支持的端口） - 维持 Same-client bundle（同一客户端分组/捆绑）一致性需要 X-Forwarded-For 支持 - SSL/TLS 配置由 Cloudflare 管理\n文档: https://homepage.np-tokumei.net/post/notes-i2p-reseed-over-cloudflare/ 抗审查策略 Nguyen Phong Hoang（USENIX FOCI 2019）的研究识别出用于受审查网络的额外引导方法：\n云存储服务提供商 Box, Dropbox, Google Drive, OneDrive: 通过公开链接托管 SU3 文件 优点: 在不干扰合法服务的情况下难以被封锁 局限: 需要手动向用户分发 URL IPFS 分发 在 InterPlanetary File System（星际文件系统，IPFS）上托管 reseed 包（用于初始引导的种子包） 内容寻址存储可防止篡改 对下架尝试具有抗性 Tor 洋葱服务 Reseed 服务器（用于获取初始节点信息的服务器）可通过 .onion 地址访问 能抵抗基于 IP 的封锁 需要在用户系统上运行 Tor 客户端 研究文档: https://homepage.np-tokumei.net/post/notes-censorship-resistant-i2p-reseeding/ 已知对 I2P 实施封锁的国家 截至2025年，以下国家已确认封锁 I2P reseed 服务器（用于初始引导的种子服务器）： - 中国 - 伊朗 - 阿曼 - 卡塔尔 - 科威特\n这些地区的用户应采用替代的引导方法或抗审查的 reseeding（重新获取初始节点信息）策略。\n供实现者参考的协议细节 Reseed（补种）请求规范 客户端行为 服务器选择: router 维护一份硬编码的 reseed（引导）URL 列表 随机选择: 客户端从可用列表中随机选择服务器 请求格式: GET /i2pseeds.su3?netid=2 HTTP/1.1 User-Agent: 应该模拟常见浏览器（例如，\u0026ldquo;Wget/1.11.4\u0026rdquo;） 重试逻辑: 如果 SU3 请求失败，回退到索引页解析 证书验证: 将 TLS 证书与系统信任存储进行校验 SU3 签名验证: 将签名与已知的 reseed 证书进行校验 服务器行为 捆绑包选择: 从 netDb 中选择 RouterInfos（router 信息集合）的伪随机子集 客户端跟踪: 根据源 IP 识别请求（遵循 X-Forwarded-For） 捆绑包一致性: 在时间窗口内（通常 8-12 小时）对重复请求返回相同的捆绑包 捆绑包多样性: 为了网络多样性，向不同客户端返回不同的捆绑包 Content-Type: application/octet-stream 或 application/x-i2p-reseed RouterInfo 文件格式 reseed 捆绑包中的每个 .dat 文件都包含一个 RouterInfo 结构（Router 信息结构）：\n文件命名: routerInfo-{base64-hash}.dat - 哈希长度为 44 个字符，使用 I2P base64 字母表 - 示例: routerInfo-ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmn.dat\n文件内容: - RouterIdentity (router 身份标识) (router 哈希、加密密钥、签名密钥) - 发布时间戳 - router 地址（IP、端口、传输类型） - router 能力与选项 - 覆盖上述所有数据的签名\n网络多样性要求 为防止网络中心化并启用女巫攻击检测：\n不得提供完整的 NetDb（网络数据库）导出: 切勿向单个客户端提供全部 RouterInfos（路由器信息记录） 随机抽样: 每个包包含可用节点的不同子集 最小包大小: 75 个 RouterInfos（由原来的 50 提高） 最大包大小: 100 个 RouterInfos 时效性: RouterInfos 应为近期（自生成起 24 小时内） IPv6 注意事项 当前状态 (2025): - 一些 reseed 服务器（用于初始引导的服务器）在 IPv6 上无响应 - 出于可靠性考虑，客户端应优先或强制使用 IPv4 - 建议在新部署中启用 IPv6 支持，但并非关键\n实现说明: 配置双栈服务器时，确保 IPv4 和 IPv6 的监听地址均能正常工作，或在无法正确支持 IPv6 时将其禁用。\n安全性考虑 威胁模型 reseed（用于引导获取初始 netDb 数据）协议可防御：\n中间人攻击: RSA-4096 签名可防止包被篡改 网络分区: 多个相互独立的 reseed 服务器可避免单点控制 Sybil 攻击: 包的多样性限制了攻击者隔离用户的能力 审查: 多台服务器和替代方法提供冗余 reseed 协议（用于引导加入网络的补种协议）并不能防御以下情况：\nreseed（初始引导）服务器被攻陷: 如果攻击者掌握了reseed证书私钥 网络完全封锁: 如果某地区的所有reseed方法都被封锁 长期监控: reseed请求会暴露尝试加入I2P的IP地址 证书管理 私钥安全: - 在不使用时将 SU3 签名密钥离线存储 - 为密钥加密使用强密码 - 维护密钥和证书的安全备份 - 考虑在高价值部署中使用硬件安全模块（HSM）\n证书吊销: - 证书吊销列表（CRLs）通过新闻提要分发 - 遭到泄露的证书可由协调者吊销 - Routers 随软件更新自动更新 CRLs\n攻击缓解 DDoS 防护: - 针对过多请求的 fail2ban 规则 - 在 Web 服务器层面进行限流 - 按 IP 地址设置连接数上限 - 使用 Cloudflare 或类似的 CDN 作为额外一层防护\n防爬取措施: - 对每个请求 IP 提供不同的包 - 按 IP 进行基于时间的包缓存 - 记录可表明抓取尝试的日志模式 - 就已检测到的攻击与其他运营者协同\n测试与验证 测试你的 Reseed（引导）服务器 方法 1: 全新安装 Router 在全新系统上安装 I2P 将你的 reseed（引导）URL 添加到配置中 移除或禁用其他 reseed URL 启动 router 并监控日志以确认 reseed 成功 在 5-10 分钟内验证与网络的连接 预期的日志输出：\nReseed got 77 router infos from https://your-reseed.example.com/i2pseeds.su3?netid=2 with 0 errors Reseed complete, 77 received 方法 2：手动 SU3 验证 # Download bundle curl -k -A \u0026#34;Wget/1.11.4\u0026#34; https://your-reseed.example.com/i2pseeds.su3 \u0026gt; test.su3 # Verify it\u0026#39;s a valid SU3 file hexdump -C test.su3 | head -n 3 # Should show: 49 32 50 73 75 33 (I2Psu3) # Extract content (requires su3 tools) java -cp /path/to/i2p.jar net.i2p.crypto.SU3File verify test.su3 your-cert.crt # Unzip content # (Extract content section, skip header+signature, then unzip) 方法 3：checki2p 监控 位于 https://checki2p.com/reseed 的服务会每 4 小时对所有已注册的 I2P reseed 服务器（引导服务器）进行自动化检查。其提供：\n可用性监控 响应时间指标 TLS 证书验证 SU3（I2P 更新包格式）签名验证 历史正常运行时间数据 一旦您的 reseed（用于引导 I2P 网络的种子服务器）在 I2P 项目中注册，它将在 24 小时内自动出现在 checki2p 上。\n常见问题的故障排除 Issue: \u0026ldquo;无法读取签名密钥\u0026rdquo; 在首次运行时 - Solution: 这是正常的。输入 \u0026lsquo;y\u0026rsquo; 以生成新密钥。\n问题: Router 无法验证签名 - 原因: 证书不在 router 的信任库中 - 解决方案: 将证书放入 ~/.i2p/certificates/reseed/ 目录\n问题：同一 bundle 被交付给不同客户端 - 原因：X-Forwarded-For 请求头未被正确转发 - 解决方案：启用 --trustProxy 并配置反向代理请求头\n问题: \u0026ldquo;连接被拒绝\u0026rdquo; 错误 - 原因: 端口无法从互联网访问 - 解决方案: 检查防火墙规则，验证端口转发\n问题: 在捆绑包重建期间 CPU 使用率高 - 原因: 在生成 350+ 个 SU3（I2P 更新包格式）变体时的正常行为 - 解决方案: 确保有足够的 CPU 资源，考虑降低重建频率\n参考信息 官方文档 Reseed（初始节点引导）贡献者指南: /guides/creating-and-running-an-i2p-reseed-server/ Reseed 策略要求: /guides/reseed-policy/ SU3 规范: /docs/specs/updates/ Reseed 工具仓库: https://i2pgit.org/idk/reseed-tools Reseed 工具文档: https://eyedeekay.github.io/reseed-tools/ 替代实现 PurpleI2P pyseeder: https://github.com/PurpleI2P/pyseeder DivaExchange i2p-reseed: https://github.com/diva-exchange/i2p-reseed RTradeLtd i2p-tools-1: https://github.com/RTradeLtd/i2p-tools-1 Python WSGI reseeder（重新播种服务器）: https://github.com/torbjo/i2p-reseeder 社区资源 I2P 论坛: https://i2pforum.net/ Gitea 仓库: https://i2pgit.org/I2P_Developers/i2p.i2p IRC: IRC2P 上的 #i2p-dev 状态监控: https://checki2p.com/reseed 版本历史 0.9.14 (2014): 引入 SU3 reseed（重新引导）格式 0.9.16 (2014): 新增基于文件的 reseeding 0.9.42 (2019): 网络 ID 查询参数为必需项 2.0.0 (2022): 引入 SSU2 传输协议 2.4.0 (2024): NetDB 隔离与安全性改进 2.6.0 (2024): 已阻止 I2P-over-Tor 连接 2.10.0 (2025): 当前稳定版（截至 2025 年 9 月） 签名类型参考 Type Code Algorithm Key Size Signature Size Hash DSA-SHA10DSA1024-bit40 bytesSHA-1 ECDSA-SHA256-P2561ECDSAP-25664 bytesSHA-256 ECDSA-SHA384-P3842ECDSAP-38496 bytesSHA-384 ECDSA-SHA512-P5213ECDSAP-521132 bytesSHA-512 RSA-SHA256-20484RSA2048-bit256 bytesSHA-256 RSA-SHA384-30725RSA3072-bit384 bytesSHA-384 RSA-SHA512-40966RSA4096-bit512 bytesSHA-512 EdDSA-SHA512-Ed255197EdDSAEd2551964 bytesSHA-512 **Reseed 标准（网络引导/重新播种）**: reseed 包必须使用 Type 6 (RSA-SHA512-4096). 致谢 感谢每一位 reseed 服务器运营者（提供初始路由信息的引导服务），你们让网络保持可访问且具备弹性。特别致谢以下贡献者和项目：\nzzz: 资深 I2P 开发者和 reseed（I2P 网络的初始引导/获取种子节点的机制）协调员 idk: reseed-tools 的现任维护者兼发布经理 Nguyen Phong Hoang: 研究抗审查的 reseeding 策略 PurpleI2P Team: 替代性 I2P 实现与工具 checki2p: 面向 reseed 基础设施的自动化监控服务 I2P 网络的去中心化 reseed（引导服务）基础设施体现了全球数十位运营者的协作努力，确保无论面临何种本地审查或技术障碍，新用户都能始终找到加入网络的途径。\n","description":"运行 reseed（引导种子）服务与替代性引导方法","id":"02dba83ad9e38e1355d624c0d4fa28aa","section":"docs","title":"Reseed 服务器","url":"/zh/docs/misc/reseed/"},{"categories":null,"content":"概述 本文件提供了 I2P 配置文件的全面技术规范，这些配置文件由 router 和各类应用程序使用。内容涵盖文件格式规范、属性定义，以及已根据 I2P 源代码和官方文档核实的实现细节。\n范围 Router 的配置文件与格式 客户端应用程序配置 I2PTunnel 的 tunnel 配置 文件格式规范与实现 版本特定的特性与弃用 实现说明 配置文件通过 I2P 核心库中的 DataHelper.loadProps() 和 storeProps() 方法进行读写。该文件格式与 I2P 协议中使用的序列化格式有显著差异（参见通用结构规范 - 类型映射 ）。\n通用配置文件格式 I2P 配置文件遵循经修改的 Java Properties 格式，并具有特定的例外和约束。\n格式规范 基于 Java Properties ，但有以下关键差异：\n编码 必须 使用 UTF-8 编码（不要使用 ISO-8859-1，正如标准的 Java Properties（属性文件） 所使用的那样） 实现：在所有文件操作中使用 DataHelper.getUTF8() 工具方法 转义序列 不 识别转义序列（包括反斜杠 \\） 不 支持续行 反斜杠字符按字面解释 注释字符 # 在一行的任意位置都会开始一条注释 ; 仅当 位于第 1 列（行首）时才开始注释 ! 不会 开始注释（与 Java Properties 不同） 键值分隔符 = 是唯一有效的键值分隔符 : 不被识别为分隔符 空白字符不被识别为分隔符 空白字符处理 键的前后空白字符不会被去除 值的前后空白字符会被去除 行处理 未包含 = 的行会被忽略（视为注释或空行） 自 0.9.10 版本起支持空值（key=） 值为空的键会被正常存储和读取 字符限制 键不得包含: - # (井号/英镑符号) - = (等号) - \\n (换行符) - 不得以 ; 开头 (分号)\n值不得包含: - #（井号） - \\n（换行符） - 不能以 \\r（回车符）开头或结尾 - 不能以空白字符开头或结尾（会自动去除首尾空白）\n文件排序 配置文件不必按键名排序。然而，大多数 I2P 应用程序在写入配置文件时，会按字母顺序对键名进行排序，以便： - 手动编辑 - 版本控制中的 diff（差异比较）操作 - 提高可读性\n实现细节 读取配置文件 // Method signature from net.i2p.data.DataHelper public static Properties loadProps(File file) 行为: - 读取 UTF-8 编码的文件 - 强制执行上述所有格式规则 - 验证字符限制 - 如果文件不存在，则返回空的 Properties 对象 - 读取错误时抛出 IOException\n编写配置文件 // Method signature from net.i2p.data.DataHelper public static void storeProps(Properties props, File file) 行为: - 写入 UTF-8 编码的文件 - 按字母顺序对键排序（除非使用 OrderedProperties（有序属性类）） - 将文件权限设置为 600 模式（仅用户读/写），自 0.8.1 版本起 - 对键或值中的无效字符抛出 IllegalArgumentException - 对写入错误抛出 IOException\n格式验证 该实现进行严格验证：\n键和值会被检查是否包含禁止字符 无效条目会在写入操作时引发异常 读取时会静默忽略格式不正确的行（不含=的行） 格式示例 有效的配置文件 # This is a comment ; This is also a comment (column 1 only) key.with.dots=value with spaces another_key=value=with=equals empty.value= numeric.value=12345 unicode.value=こんにちは 无效配置示例 # INVALID: Key contains equals sign invalid=key=value # INVALID: Key contains hash invalid#key=value # INVALID: Value contains newline (implicit) key=value continues here # INVALID: Semicolon comment not in column 1 (treated as key) ; not.a.comment=value 核心库与 Router 配置 客户端配置 (clients.config) 位置: $I2P_CONFIG_DIR/clients.config (旧版) 或 $I2P_CONFIG_DIR/clients.config.d/ (现代) 配置界面: Router 控制台位于 /configclients 格式变更: 版本 0.9.42 (2019 年 8 月)\n目录结构 (版本 0.9.42+) 自 0.9.42 版本起，默认的 clients.config 文件会自动拆分为单独的配置文件：\n$I2P_CONFIG_DIR/ ├── clients.config.d/ │ ├── 00-webConsole.config │ ├── 01-i2ptunnel.config │ ├── 02-i2psnark.config │ ├── 03-susidns.config │ └── ... └── clients.config (legacy, auto-migrated) 迁移行为: - 升级到 0.9.42+ 后首次运行时，将自动拆分单体文件 - 拆分文件中的属性以 clientApp.0. 为前缀 - 为向后兼容仍然支持旧格式 - 拆分格式支持模块化打包与插件管理\n属性格式 各行的形式为 clientApp.x.prop=val，其中 x 是应用编号。\n应用编号要求: - 必须从 0 开始 - 必须连续（不得跳号） - 顺序决定启动顺序\n必需属性 主要 类型: 字符串（完全限定类名） 必需: 是 描述: 将根据客户端类型（受管 vs. 非受管）调用此类中的构造函数或 main() 方法 示例: clientApp.0.main=net.i2p.router.web.RouterConsoleRunner 可选属性 名称 类型: 字符串 是否必需: 否 描述: 在 router 控制台中显示的名称 示例: clientApp.0.name=Router Console 参数 类型: 字符串（以空格或制表符分隔） 是否必需: 否 说明: 传递给主类构造函数或 main() 方法的参数 引用: 含有空格或制表符的参数可以用 \u0026rsquo; 或 \u0026quot; 括起来 示例: clientApp.0.args=-d $CONFIG/eepsite 延迟 类型: 整数（秒） 必需: 否 默认值: 120 描述: 在启动客户端之前等待的秒数 覆盖: 被 onBoot=true 覆盖（将延迟设为 0） 特殊值: \u0026lt; 0: 等待 router 达到 RUNNING 状态，然后在新线程中立即启动 = 0: 在同一线程中立即运行（异常会传播到控制台） \u0026gt; 0: 在延迟之后于新线程中启动（异常会被记录到日志，不会传播） onBoot 类型: 布尔值 必需: 否 默认值: false 说明: 将延迟强制设为 0，覆盖显式的延迟设置 用例: 在 router 启动时立即启动关键服务 startOnLoad 类型: 布尔值 是否必需: 否 默认值: true 描述: 是否启动客户端 使用场景: 在不删除配置的情况下禁用客户端 插件特定属性 这些属性仅供插件使用（非核心客户端）：\nstopargs 类型: 字符串（以空格或制表符分隔） 描述: 用于停止客户端时传递的参数 变量替换: 是（见下文） uninstallargs 类型: 字符串（以空格或制表符分隔） 描述: 用于卸载客户端时传入的参数 变量替换: 是（见下文） 类路径 类型: 字符串（逗号分隔的路径） 描述: 客户端的附加 classpath（类路径）元素 变量替换: 是（见下文） 变量替换（仅限插件） 在插件的 args、stopargs、uninstallargs 和 classpath 中，会替换以下变量：\nVariable Expands To Example $I2P Base I2P installation directory /usr/share/i2p $CONFIG User configuration directory ~/.i2p $PLUGIN Plugin directory ~/.i2p/plugins/foo $OS Operating system name linux $ARCH Architecture name amd64 **注意**：变量替换仅适用于插件，不适用于核心客户端。 客户端类型 受管客户端 构造函数会以 RouterContext 和 ClientAppManager 作为参数被调用 客户端必须实现 ClientApp 接口 生命周期由 router 控制 可动态启动、停止和重启 未托管客户端 main(String[] args) 方法被调用 在独立线程中运行 生命周期不由 router 管理 遗留客户端类型 示例配置 # Router Console (core client) clientApp.0.main=net.i2p.router.web.RouterConsoleRunner clientApp.0.name=Router Console clientApp.0.args=-d $CONFIG/eepsite clientApp.0.delay=0 clientApp.0.onBoot=true clientApp.0.startOnLoad=true # I2PTunnel (core client) clientApp.1.main=net.i2p.i2ptunnel.TunnelControllerGroup clientApp.1.name=I2PTunnel clientApp.1.args= clientApp.1.delay=120 clientApp.1.startOnLoad=true # Plugin Example clientApp.2.main=org.example.plugin.PluginMain clientApp.2.name=Example Plugin clientApp.2.args=-config $PLUGIN/config.properties clientApp.2.stopargs=-shutdown clientApp.2.uninstallargs=-remove $PLUGIN clientApp.2.classpath=$PLUGIN/lib/plugin.jar,$PLUGIN/lib/dep.jar clientApp.2.delay=240 clientApp.2.startOnLoad=true 日志记录器配置 (logger.config) 位置: $I2P_CONFIG_DIR/logger.config 配置界面: Router 控制台的 /configlogging\n属性参考 控制台缓冲区配置 logger.consoleBufferSize 类型: 整数 默认值: 20 描述: 在控制台中可缓冲的日志消息最大数量 范围: 建议 1-1000 日期和时间格式化 logger.dateFormat 类型: 字符串 (SimpleDateFormat 模式) 默认: 来自系统区域设置 示例: HH:mm:ss.SSS 文档: Java SimpleDateFormat 日志级别 logger.defaultLevel 类型: 枚举 默认: ERROR 可选值: CRIT, ERROR, WARN, INFO, DEBUG 描述: 所有类的默认日志级别 logger.minimumOnScreenLevel 类型: 枚举 默认值: CRIT 可选值: CRIT, ERROR, WARN, INFO, DEBUG 说明: 在屏幕上显示的消息的最低级别 logger.record.{class} 类型: 枚举 取值: CRIT, ERROR, WARN, INFO, DEBUG 描述: 针对各个类的日志级别覆盖 示例: logger.record.net.i2p.router.transport.udp=DEBUG 显示选项 logger.displayOnScreen 类型: 布尔值 默认值: true 描述: 是否在控制台输出中显示日志消息 logger.dropDuplicates 类型: 布尔 默认值: true 描述: 丢弃连续重复的日志消息 logger.dropOnOverflow 类型: 布尔 默认值: false 描述: 当缓冲区已满时丢弃消息（而非阻塞） 刷新行为 logger.flushInterval 类型: 整数（秒） 默认值: 29 起始版本: 0.9.18 描述: 将日志缓冲区刷新到磁盘的频率 格式配置 logger.format 类型: 字符串（字符序列） 描述: 日志消息格式模板 格式字符: d = 日期/时间 c = 类名 t = 线程名 p = 优先级（日志级别） m = 消息 示例: dctpm 会生成 [时间戳] [类] [线程] [级别] 消息 压缩（版本 0.9.56+） logger.gzip 类型: 布尔值 默认值: false 自: 版本 0.9.56 描述: 为已轮换的日志文件启用 gzip 压缩 logger.minGzipSize 类型: 整数（字节） 默认值: 65536 自版本: 0.9.56 描述: 触发压缩的最小文件大小（默认 64 KB） 文件管理 logger.logBufferSize 类型: 整数（字节） 默认值: 1024 描述: 在触发刷新前可缓冲的最大消息数 logger.logFileName 类型: 字符串（文件路径） 默认值: logs/log-@.txt 描述: 日志文件命名模式（@ 将被替换为轮转编号） logger.logFilenameOverride 类型: 字符串（文件路径） 描述: 用于覆盖日志文件名（会禁用轮转模式） logger.logFileSize 类型: 字符串（带单位的大小） 默认值: 10M 单位: K（千字节）、M（兆字节）、G（吉字节） 示例: 50M, 1G logger.logRotationLimit 类型: 整数 默认值: 2 描述: 轮转日志文件的最大编号 (log-0.txt 到 log-N.txt) 示例配置 # Basic logging configuration logger.consoleBufferSize=50 logger.dateFormat=yyyy-MM-dd HH:mm:ss.SSS logger.defaultLevel=WARN logger.displayOnScreen=true logger.dropDuplicates=true logger.dropOnOverflow=false # Flushing and format logger.flushInterval=30 logger.format=dctpm # File management logger.logBufferSize=2048 logger.logFileName=logs/log-@.txt logger.logFileSize=25M logger.logRotationLimit=5 # Compression (0.9.56+) logger.gzip=true logger.minGzipSize=131072 # On-screen filtering logger.minimumOnScreenLevel=ERROR # Per-class overrides logger.record.net.i2p.router.transport=INFO logger.record.net.i2p.router.tunnel=DEBUG logger.record.net.i2p.crypto=WARN 插件配置 单个插件配置 (plugins/*/plugin.config) 位置: $I2P_CONFIG_DIR/plugins/{plugin-name}/plugin.config 格式: 标准 I2P 配置文件格式 文档: 插件规范 必需属性 名称 类型: 字符串 必需: 是 描述: 插件显示名称 示例: name=I2P Plugin Example 密钥 类型: 字符串（公钥） 是否必需: 是（对于使用 SU3 签名的插件可省略） 说明: 用于验证插件签名的公钥 格式: Base64 编码的签名公钥 签名者 类型: 字符串 必需: 是 描述: 插件签名者身份 示例: signer=user@example.i2p 版本 类型: 字符串（VersionComparator 格式，用于比较版本号） 必需: 是 描述: 用于更新检查的插件版本 格式: 语义化版本（Semantic Versioning）或自定义可比较格式 示例: version=1.2.3 显示属性 日期 类型: Long (以毫秒为单位的 Unix 时间戳) 描述: 插件发布日期 作者 类型: 字符串 描述: 插件作者名称 websiteURL 类型: 字符串 (URL) 描述: 插件网站 URL updateURL 类型: 字符串 (URL) 描述: 用于插件的更新检查 URL updateURL.su3 类型: 字符串（URL） 自: 版本 0.9.15 起 描述: SU3 格式的更新 URL（首选） 描述 类型: 字符串 描述: 插件的英文描述 description_{language} 类型: 字符串 描述: 本地化的插件描述 示例: description_de=Deutsche Beschreibung 许可证 类型: 字符串 描述: 插件许可证标识符 示例: license=Apache 2.0 安装属性 不要在安装时启动 类型: 布尔值 默认值: false 描述: 防止在安装后自动启动 需要重启 router 类型: 布尔值 默认值: false 描述: 安装后需要重启 router 仅安装 类型: 布尔类型 默认值: false 描述: 仅安装一次（不更新） 仅更新 类型: 布尔值 默认值: false 说明: 仅更新现有安装（不进行全新安装） 示例插件配置 # Required properties name=Example I2P Plugin signer=developer@mail.i2p version=1.5.0 # Display properties author=Plugin Developer websiteURL=http://plugin.example.i2p updateURL=http://plugin.example.i2p/update.xpi2p updateURL.su3=http://plugin.example.i2p/update.su3 description=Example plugin demonstrating configuration description_de=Beispiel-Plugin zur Demonstration der Konfiguration license=MIT # Installation behavior dont-start-at-install=false router-restart-required=false 全局插件配置 (plugins.config) 位置: $I2P_CONFIG_DIR/plugins.config 用途: 全局启用/禁用已安装的插件\n属性格式 plugin.{name}.startOnLoad=true|false {name}: 来自 plugin.config 的插件名称 startOnLoad: 是否在 router 启动时自动启动插件 示例 plugin.i2psnark.startOnLoad=true plugin.susimail.startOnLoad=true plugin.susidns.startOnLoad=true plugin.i2pbote.startOnLoad=false Web 应用程序配置（webapps.config） 位置: $I2P_CONFIG_DIR/webapps.config 用途: 启用/禁用并配置 Web 应用程序\n属性格式 webapps.{name}.startOnLoad 类型: 布尔值 描述: 是否在 router 启动时启动 Web 应用 格式: webapps.{name}.startOnLoad=true|false webapps.{name}.classpath 类型: 字符串 (以空格或逗号分隔的路径) 描述: 用于 Web 应用的额外类路径元素 格式: webapps.{name}.classpath=[paths] 变量替换 路径支持以下变量替换：\nVariable Expands To Context $I2P Base I2P directory Core webapps $CONFIG User config directory All webapps $PLUGIN Plugin directory Plugin webapps #### 类路径解析 核心 Web 应用：相对于 $I2P/lib 的路径 插件 Web 应用：相对于 $CONFIG/plugins/{appname}/lib 的路径 示例配置 # Router console webapps.routerconsole.startOnLoad=true webapps.routerconsole.classpath=routerconsole.jar # I2PSnark webapps.i2psnark.startOnLoad=true webapps.i2psnark.classpath=i2psnark.jar # SusiDNS webapps.susidns.startOnLoad=true webapps.susidns.classpath=susidns.jar # Plugin webapp example webapps.exampleplugin.startOnLoad=false webapps.exampleplugin.classpath=$PLUGIN/lib/webapp.jar,$PLUGIN/lib/deps.jar Router 配置 (router.config) 位置: $I2P_CONFIG_DIR/router.config 配置界面: Router 控制台位于 /configadvanced 用途: 核心 Router 设置和网络参数\n配置类别 网络配置 带宽设置:\ni2np.bandwidth.inboundKBytesPerSecond=100 i2np.bandwidth.outboundKBytesPerSecond=50 i2np.bandwidth.share.percentage=80 传输配置：\n# NTCP (TCP-based transport) i2np.ntcp.port=8887 i2np.ntcp.enable=true i2np.ntcp.autoip=true # SSU (UDP-based transport) i2np.udp.port=8887 i2np.udp.enable=true # UPnP/NAT-PMP i2np.upnp.enable=true Router 行为 # Tunnel participation router.maxParticipatingTunnels=200 router.sharePercentage=80 # Updates router.updatePolicy=notify router.updateURL=http://update.i2p2.i2p/ # Network integration router.hiddenMode=false router.clockSkewOffset=0 控制台配置 # Language and display routerconsole.lang=en routerconsole.country=US routerconsole.summaryRefresh=60 # Browser routerconsole.browser=default # Security routerconsole.enableCompression=true 时间配置 # NTP time.disabled=false time.sntpServerList=0.pool.ntp.org,1.pool.ntp.org 注意：Router 配置内容繁多。请在 router 控制台的 /configadvanced 页面查看完整的属性参考。\n应用程序配置文件 地址簿配置 (addressbook/config.txt) 位置: $I2P_CONFIG_DIR/addressbook/config.txt 应用: SusiDNS 用途: 主机名解析和地址簿管理\n文件位置 router_addressbook 默认: ../hosts.txt 描述: 主地址簿（系统范围的主机名） 格式: 标准 hosts 文件格式 privatehosts.txt 位置: $I2P_CONFIG_DIR/addressbook/privatehosts.txt 描述: 私有主机名映射 优先级: 最高（覆盖所有其他来源） userhosts.txt 位置: $I2P_CONFIG_DIR/addressbook/userhosts.txt 描述: 用户添加的主机名映射 管理: 通过 SusiDNS 界面 hosts.txt 位置: $I2P_CONFIG_DIR/addressbook/hosts.txt 描述: 已下载的公共地址簿 来源: 订阅源 命名服务 BlockfileNamingService (自 0.8.8 起为默认) 存储格式： - 文件: hostsdb.blockfile - 位置: $I2P_CONFIG_DIR/addressbook/ - 性能: 查询速度比 hosts.txt 快约 10 倍 - 格式: 二进制数据库格式\n旧版命名服务： - 格式：纯文本 hosts.txt - 状态：已弃用但仍受支持 - 使用场景：手动编辑、版本控制\n主机名规则 I2P 主机名必须符合以下规范：\n顶级域名要求: 必须以 .i2p 结尾 最大长度: 总计 67 个字符 字符集: [a-z], [0-9], . (句点), - (连字符) 大小写: 仅限小写 开头限制: 不能以 . 或 - 开头 禁止的模式: 不能包含 ..、.- 或 -. (自 0.6.1.33 起) 保留: Base32 主机名 *.b32.i2p (52 个字符的 base32.b32.i2p) 有效示例 example.i2p my-site.i2p test.example.i2p site123.i2p 无效示例 example.com # Wrong TLD -invalid.i2p # Starts with hyphen invalid..i2p # Contains double dot invalid.-.i2p # Contains dot-hyphen UPPERCASE.I2P # Must be lowercase verylonghostnameover67charactersthatexceedsthemaximumlength.i2p # Too long 订阅管理 subscriptions.txt 位置: $I2P_CONFIG_DIR/addressbook/subscriptions.txt 格式: 每行一个 URL 默认值: http://i2p-projekt.i2p/hosts.txt 订阅源格式（自 0.9.26 起） 带有元数据的高级提要格式：\n# # I2P Address Book Subscription Feed # Format: hostname=destination [#property=value ...] # example.i2p=base64destination #added=20250101 #src=manual another.i2p=base64destination #added=20250102 #src=feed1 元数据属性: - added: 主机名添加的日期 (YYYYMMDD 格式) - src: 来源标识符 - sig: 可选签名\n向后兼容性: 简单的 hostname=destination 格式仍然受支持。\n示例配置 # Address book locations router_addressbook=../hosts.txt privatehosts.txt=$CONFIG/addressbook/privatehosts.txt userhosts.txt=$CONFIG/addressbook/userhosts.txt hosts.txt=$CONFIG/addressbook/hosts.txt # Naming service naming.service=BlockfileNamingService naming.service.blockfile.location=$CONFIG/addressbook/hostsdb.blockfile # Subscriptions subscriptions.txt=$CONFIG/addressbook/subscriptions.txt subscriptions.schedule=daily subscriptions.proxy=false I2PSnark 配置 (i2psnark.config.d/i2psnark.config) 位置: $I2P_CONFIG_DIR/i2psnark.config.d/i2psnark.config 应用程序: I2PSnark BitTorrent 客户端 配置界面: Web 界面位于 http://127.0.0.1:7657/i2psnark\n目录结构 $I2P_CONFIG_DIR/i2psnark.config.d/ ├── i2psnark.config ├── [torrent-hash-1]/ │ └── *.config ├── [torrent-hash-2]/ │ └── *.config └── ... 主配置 (i2psnark.config) 最小默认配置：\ni2psnark.dir=i2psnark 可通过 Web 界面管理的附加属性：\n# Basic settings i2psnark.dir=i2psnark i2psnark.autoStart=false i2psnark.openTrackers=true # Network settings i2psnark.uploaders=8 i2psnark.upBW=40 i2psnark.seedPct=100 # I2CP settings i2psnark.i2cpHost=127.0.0.1 i2psnark.i2cpPort=7654 单个种子配置 位置: $I2P_CONFIG_DIR/i2psnark.config.d/[torrent-hash]/*.config 格式: 每个种子的设置 管理: 自动（通过 Web GUI）\n属性包括： - 针对种子的上传/下载设置 - 文件优先级 - 跟踪器信息 - 对等节点限制\n注意: Torrent 配置主要通过 Web 界面进行管理。不建议手动编辑。\n种子数据组织 数据存储与配置彼此独立：\n$I2P_CONFIG_DIR/i2psnark/ # Data directory ├── *.torrent # Torrent metadata files ├── *.torrent.downloaded/ # Downloaded file directories ├── file1.dat # Direct file downloads └── ... $I2P_CONFIG_DIR/i2psnark.config.d/ # Configuration directory ├── i2psnark.config # Main config └── [hashes]/ # Per-torrent configs I2PTunnel 配置 (i2ptunnel.config) 位置: $I2P_CONFIG_DIR/i2ptunnel.config（旧版）或 $I2P_CONFIG_DIR/i2ptunnel.config.d/（现代版） 配置界面: Router 控制台位于 /i2ptunnel 格式变更: 版本 0.9.42（2019 年 8 月）\n目录结构 (版本 0.9.42+) 自 0.9.42 版本起，默认的 i2ptunnel.config 文件将自动拆分：\n$I2P_CONFIG_DIR/ ├── i2ptunnel.config.d/ │ ├── http-proxy/ │ │ └── tunnel.config │ ├── irc-proxy/ │ │ └── tunnel.config │ ├── ssh-service/ │ │ └── tunnel.config │ └── ... └── i2ptunnel.config (legacy, auto-migrated) 关键格式差异: - 单体格式: 属性以 tunnel.N. 为前缀 - 拆分格式: 属性不带前缀（例如，description=，而不是 tunnel.0.description=）\n迁移行为 在升级到 0.9.42 后首次运行： 1. 读取现有 i2ptunnel.config 2. 在 i2ptunnel.config.d/ 中创建各个 tunnel 的配置文件 3. 在拆分后的文件中去除属性前缀 4. 备份原始文件 5. 仍支持旧格式以保持向后兼容\n配置部分 I2PTunnel 配置的详细说明见下文的 I2PTunnel 配置参考 部分。属性说明适用于单一式（tunnel.N.property）和拆分式（property）两种格式。\nI2PTunnel 配置参考 本节提供 I2PTunnel 全部配置属性的全面技术参考。属性以拆分格式展示（不带 tunnel.N. 前缀）。若使用单体格式，则为所有属性添加 tunnel.N. 前缀，其中 N 为该 tunnel 的编号。\n重要：被描述为 tunnel.N.option.i2cp.* 的属性仅在 I2PTunnel（I2P 隧道工具）中实现，且不受其他接口（例如 I2CP protocol（I2CP 协议）或 SAM API（SAM 接口））支持。\n基本属性 tunnel.N.description (描述) 类型: 字符串 上下文: 所有 tunnels 描述: 用于 UI 显示的人类可读的 tunnel 描述 示例: description=HTTP Proxy for outproxy access tunnel.N.name (名称) 类型: 字符串 上下文: 所有 tunnel 必需: 是 描述: 唯一的 tunnel 标识符和显示名称 示例: name=I2P HTTP Proxy tunnel.N.type (类型) 类型: 枚举 上下文: 所有 tunnel 必需: 是 取值: client - 通用客户端 tunnel httpclient - HTTP 代理客户端 ircclient - IRC 客户端 tunnel socksirctunnel - SOCKS IRC 代理 sockstunnel - SOCKS 代理（版本 4、4a、5） connectclient - CONNECT 代理客户端 streamrclient - Streamr 客户端 server - 通用服务器 tunnel httpserver - HTTP 服务器 tunnel ircserver - IRC 服务器 tunnel httpbidirserver - 双向 HTTP 服务器 streamrserver - Streamr 服务器 tunnel.N.interface (接口) 类型: 字符串（IP 地址或主机名） 上下文: 仅适用于 Client tunnels（I2P 中的隧道） 默认值: 127.0.0.1 描述: 用于绑定传入连接的本地接口 安全说明: 绑定到 0.0.0.0 将允许远程连接 示例: interface=127.0.0.1 tunnel.N.listenPort (listenPort) 类型: 整数 上下文: 仅适用于 Client tunnels（客户端隧道） 范围: 1-65535 描述: 用于监听客户端连接的本地端口 示例: listenPort=4444 tunnel.N.targetHost (targetHost) 类型: 字符串（IP 地址或主机名） 上下文: 仅限 Server tunnels 描述: 用于转发连接的本地目标服务器 示例: targetHost=127.0.0.1 tunnel.N.targetPort (targetPort) 类型: 整数 上下文: 仅用于服务器 tunnels 范围: 1-65535 描述: 要连接的 targetHost 上的端口 示例: targetPort=80 tunnel.N.targetDestination (targetDestination) 类型: 字符串（以逗号或空格分隔的目标地址） 上下文: 仅限 Client tunnels 格式: destination[:port][,destination[:port]] 描述: 要连接的 I2P 目标地址（Destination） 示例: targetDestination=example.i2p targetDestination=example.i2p:8080 targetDestination=site1.i2p,site2.i2p:8080 tunnel.N.i2cpHost (i2cpHost) 类型: 字符串（IP 地址或主机名） 默认值: 127.0.0.1 描述: I2P router 的 I2CP 接口地址 注意: 在 router 上下文中运行时将被忽略 示例: i2cpHost=127.0.0.1 tunnel.N.i2cpPort (i2cpPort) 类型: 整数 默认值: 7654 范围: 1-65535 描述: I2P router 的 I2CP 端口 注意: 在 router 上下文中运行时会被忽略 示例: i2cpPort=7654 tunnel.N.startOnLoad (startOnLoad) 类型: 布尔值 默认值: true 说明: 当 I2PTunnel 加载时是否启动 tunnel 示例: startOnLoad=true 代理配置 tunnel.N.proxyList (proxyList) 类型: 字符串（以逗号或空格分隔的主机名） 适用范围: 仅限 HTTP 和 SOCKS 代理 描述: outproxy（出站代理）主机列表 示例: proxyList=outproxy.example.i2p,backup.example.i2p 服务器配置 tunnel.N.privKeyFile (privKeyFile) 类型: 字符串（文件路径） 适用范围: 服务器和持久化客户端 tunnels（隧道） 描述: 包含持久化目标私钥的文件 路径: 绝对路径或相对于 I2P 配置目录 示例: privKeyFile=eepsite/eepPriv.dat tunnel.N.spoofedHost (spoofedHost) 类型: 字符串（主机名） 上下文: 仅适用于 HTTP 服务器 默认值: 目标（destination）的 Base32 主机名 描述: 传递给本地服务器的 Host 请求头值 示例: spoofedHost=example.i2p tunnel.N.spoofedHost.NNNN (spoofedHost.NNNN) 类型: 字符串（主机名） 适用范围: 仅限 HTTP 服务器 描述: 针对特定入站端口的虚拟主机覆盖 用例: 在不同端口上托管多个站点 示例: spoofedHost.8080=site1.example.i2p 客户端特定选项 tunnel.N.sharedClient (sharedClient) 类型: 布尔值 上下文: 仅适用于 Client tunnels 默认值: false 描述: 是否允许多个客户端共享该 tunnel 示例: sharedClient=false tunnel.N.option.persistentClientKey (persistentClientKey) 类型: 布尔值 上下文: 仅适用于客户端 tunnel 默认值: false 描述: 在重启之间保存并复用目标密钥 冲突: 与 i2cp.newDestOnResume=true 互斥 示例: option.persistentClientKey=true I2CP 选项 (I2PTunnel 实现) 重要: 这些属性以 option.i2cp. 为前缀，但由 I2PTunnel 实现，而不是在 I2CP 协议层实现。它们无法通过 I2CP 或 SAM API 使用。\ntunnel.N.option.i2cp.delayOpen (option.i2cp.delayOpen) 类型: 布尔值 适用范围: 仅限客户端 tunnels 默认值: false 描述: 延迟创建 tunnel，直到首次连接 使用场景: 为很少使用的 tunnels 节省资源 示例: option.i2cp.delayOpen=false tunnel.N.option.i2cp.newDestOnResume (option.i2cp.newDestOnResume) 类型: 布尔值 上下文: 仅用于 Client tunnels 默认值: false 需要: i2cp.closeOnIdle=true 冲突: 与 persistentClientKey=true 互斥 描述: 在空闲超时后创建新的 Destination（目标地址） 示例: option.i2cp.newDestOnResume=false tunnel.N.option.i2cp.leaseSetPrivateKey (option.i2cp.leaseSetPrivateKey) 类型: 字符串（base64 编码的密钥） 上下文: 仅适用于服务器 tunnels 描述: 持久的私有 leaseset（I2P 中发布到 netDb 的可达性信息集合）加密密钥 使用场景: 跨重启保持加密的 leaseset 一致性 示例: option.i2cp.leaseSetPrivateKey=AAAA...base64... tunnel.N.option.i2cp.leaseSetSigningPrivateKey (option.i2cp.leaseSetSigningPrivateKey) Type: 字符串 (sigtype:base64) Context: 仅用于 Server tunnels Format: sigtype:base64key Description: 持久化 leaseset（I2P 的租约集合）签名私钥 Example: option.i2cp.leaseSetSigningPrivateKey=7:AAAA...base64... 服务器特定选项 tunnel.N.option.enableUniqueLocal (option.enableUniqueLocal) 类型: 布尔值 适用范围: 仅限服务器 tunnels 默认值: false 说明: 针对每个远程 I2P 目标使用唯一的本地 IP 使用场景: 在服务器日志中跟踪客户端 IP 安全提示: 可能降低匿名性 示例: option.enableUniqueLocal=false tunnel.N.option.targetForPort.NNNN (option.targetForPort.NNNN) Type: 字符串 (hostname:port) Context: 仅适用于 Server tunnels Description: 为传入端口 NNNN 覆盖 targetHost/targetPort Use Case: 基于端口将流量路由到不同的本地服务 Example: option.targetForPort.8080=localhost:8080 线程池配置 tunnel.N.option.i2ptunnel.usePool (option.i2ptunnel.usePool) 类型: 布尔值 适用范围: 仅用于 Server tunnels 默认值: true 描述: 使用线程池进行连接处理 注意: 对于标准服务器始终为 false (忽略) 示例: option.i2ptunnel.usePool=true tunnel.N.option.i2ptunnel.blockingHandlerCount (option.i2ptunnel.blockingHandlerCount) 类型: 整数 上下文: 仅用于服务器 tunnel 默认值: 65 描述: 最大线程池大小 注意: 对标准服务器无效 示例: option.i2ptunnel.blockingHandlerCount=100 HTTP 客户端选项 tunnel.N.option.i2ptunnel.httpclient.allowInternalSSL (option.i2ptunnel.httpclient.allowInternalSSL) 类型: 布尔型 上下文: 仅限 HTTP 客户端 默认值: false 说明: 允许 SSL 连接到 .i2p 地址 示例: option.i2ptunnel.httpclient.allowInternalSSL=false tunnel.N.option.i2ptunnel.httpclient.disableAddressHelper (option.i2ptunnel.httpclient.disableAddressHelper) 类型: 布尔值 上下文: 仅限 HTTP 客户端 默认值: false 描述: 在代理响应中禁用地址助手链接 示例: option.i2ptunnel.httpclient.disableAddressHelper=false tunnel.N.option.i2ptunnel.httpclient.jumpServers (option.i2ptunnel.httpclient.jumpServers) Type: 字符串 (以逗号或空格分隔的 URL) Context: 仅限 HTTP 客户端 Description: 用于主机名解析的 Jump server (I2P 的跳转服务器) URL Example: option.i2ptunnel.httpclient.jumpServers=http://jump.i2p/jump,http://stats.i2p/jump tunnel.N.option.i2ptunnel.httpclient.sendAccept (option.i2ptunnel.httpclient.sendAccept) 类型: 布尔值 上下文: 仅限 HTTP 客户端 默认值: false 描述: 传递 Accept-* 请求头（以 Accept 开头的 HTTP 请求头，除 Accept 和 Accept-Encoding 外） 示例: option.i2ptunnel.httpclient.sendAccept=false tunnel.N.option.i2ptunnel.httpclient.sendReferer (option.i2ptunnel.httpclient.sendReferer) 类型: 布尔值 上下文: 仅适用于 HTTP 客户端 默认值: false 描述: 通过代理转发 Referer 请求头 隐私提示: 可能泄露信息 示例: option.i2ptunnel.httpclient.sendReferer=false tunnel.N.option.i2ptunnel.httpclient.sendUserAgent (option.i2ptunnel.httpclient.sendUserAgent) 类型: 布尔值 适用范围: 仅限 HTTP 客户端 默认值: false 说明: 通过代理传递 User-Agent 头 隐私提示: 可能泄露浏览器信息 示例: option.i2ptunnel.httpclient.sendUserAgent=false tunnel.N.option.i2ptunnel.httpclient.sendVia (option.i2ptunnel.httpclient.sendVia) 类型: 布尔 上下文: 仅适用于 HTTP 客户端 默认值: false 说明: 通过代理传递 Via 头部 示例: option.i2ptunnel.httpclient.sendVia=false tunnel.N.option.i2ptunnel.httpclient.SSLOutproxies (option.i2ptunnel.httpclient.SSLOutproxies) 类型: 字符串（以逗号或空格分隔的目标地址） 上下文: 仅限 HTTP 客户端 描述: 用于 HTTPS 的网络内 SSL outproxies（出口代理） 示例: option.i2ptunnel.httpclient.SSLOutproxies=ssl-outproxy.i2p tunnel.N.option.i2ptunnel.useLocalOutproxy (option.i2ptunnel.useLocalOutproxy) 类型: 布尔值 适用范围: 仅限 HTTP 客户端 默认值: true 描述: 使用已注册的本地 outproxy（出口代理）插件 示例: option.i2ptunnel.useLocalOutproxy=true HTTP 客户端身份验证 tunnel.N.option.proxyAuth (option.proxyAuth) 类型: 枚举 上下文: 仅限 HTTP 客户端 默认: false 取值: true, false, basic, digest 说明: 代理访问需要本地身份验证 注意: true 等同于 basic 示例: option.proxyAuth=basic tunnel.N.option.proxy.auth.USER.md5 (option.proxy.auth.USER.md5) 类型: 字符串（32 个小写十六进制字符） 上下文: 仅限 HTTP 客户端 要求: proxyAuth=basic 或 proxyAuth=digest 说明: 用户 USER 的密码的 MD5 哈希 弃用: 请改用 SHA-256（0.9.56+） 示例: option.proxy.auth.alice.md5=5f4dcc3b5aa765d61d8327deb882cf99 tunnel.N.option.proxy.auth.USER.sha256 (option.proxy.auth.USER.sha256) 类型: 字符串（64 个字符的小写十六进制） 上下文: 仅限 HTTP 客户端 要求: proxyAuth=digest 起始版本: 0.9.56 标准: RFC 7616 描述: 用户 USER 的密码的 SHA-256 哈希 示例: option.proxy.auth.alice.sha256=5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8 出口代理认证 tunnel.N.option.outproxyAuth (option.outproxyAuth) 类型: 布尔值 上下文: 仅适用于 HTTP 客户端 默认值: false 说明: 向 outproxy（出口代理）发送认证信息 示例: option.outproxyAuth=false tunnel.N.option.outproxyUsername (option.outproxyUsername) 类型: 字符串 上下文: 仅限 HTTP 客户端 需要: outproxyAuth=true 描述: 用于 outproxy（出口代理）认证的用户名 示例: option.outproxyUsername=user tunnel.N.option.outproxyPassword (option.outproxyPassword) 类型: 字符串 上下文: 仅限 HTTP 客户端 要求: outproxyAuth=true 描述: 用于 outproxy（出口代理）认证的密码 安全性: 以明文存储 示例: option.outproxyPassword=secret SOCKS 客户端选项 tunnel.N.option.i2ptunnel.socks.proxy.default (option.i2ptunnel.socks.proxy.default) 类型: 字符串（以逗号或空格分隔的目标地址） 上下文: 仅适用于 SOCKS 客户端 描述: I2P 网络内的 outproxy（出站代理），用于未指定端口 示例: option.i2ptunnel.socks.proxy.default=outproxy.i2p tunnel.N.option.i2ptunnel.socks.proxy.NNNN (option.i2ptunnel.socks.proxy.NNNN) 类型: 字符串（以逗号或空格分隔的 destinations（I2P 目的地标识）） 上下文: 仅限 SOCKS 客户端 描述: 专用于端口 NNNN 的网络内 outproxies（出口代理） 示例: option.i2ptunnel.socks.proxy.443=ssl-outproxy.i2p tunnel.N.option.outproxyType (option.outproxyType) Type: 枚举 Context: 仅限 SOCKS 客户端 Default: socks Since: 自 0.9.57 版本起 Values: socks, connect (HTTPS) Description: 已配置的 outproxy（出口代理）的类型 Example: option.outproxyType=connect HTTP 服务器选项 tunnel.N.option.maxPosts (option.maxPosts) 类型: 整数 适用范围: 仅限 HTTP 服务器 默认值: 0（无限制） 说明: 每个 postCheckTime 内，来自同一 Destination（I2P 目标标识）的最大 POST 请求数 示例: option.maxPosts=10 tunnel.N.option.maxTotalPosts (option.maxTotalPosts) Type: 整数 Context: 仅限 HTTP 服务器 Default: 0（无限制） Description: 每个 postCheckTime 内来自所有 destinations（I2P 目标地址）的 POST 请求最大次数 Example: option.maxTotalPosts=50 tunnel.N.option.postCheckTime (option.postCheckTime) 类型: 整数（秒） 上下文: 仅限 HTTP 服务器 默认值: 300 描述: 用于检查 POST 限制的时间窗口 示例: option.postCheckTime=600 tunnel.N.option.postBanTime (option.postBanTime) Type: 整数（秒） Context: 仅限 HTTP 服务器 Default: 1800 Description: 当单个 destination（I2P 目标标识）超过 maxPosts 时的封禁时长 Example: option.postBanTime=3600 tunnel.N.option.postTotalBanTime (option.postTotalBanTime) 类型: 整数（秒） 适用范围: 仅适用于 HTTP 服务器 默认值: 600 描述: 当超过 maxTotalPosts 后的封禁时长 示例: option.postTotalBanTime=1200 HTTP 服务器安全选项 tunnel.N.option.rejectInproxy (option.rejectInproxy) 类型: 布尔 上下文: 仅适用于 HTTP 服务器 默认值: false 描述: 拒绝看似经由 inproxy（入口代理；用于从明网访问 I2P 站点的 HTTP 网关）的连接 示例: option.rejectInproxy=false tunnel.N.option.rejectReferer (option.rejectReferer) 类型: 布尔值 上下文: 仅限 HTTP 服务器 默认值: false 起始版本: 0.9.25 描述: 拒绝带有 Referer 请求头的连接 示例: option.rejectReferer=false tunnel.N.option.rejectUserAgents (option.rejectUserAgents) 类型: 布尔值 上下文: 仅适用于 HTTP 服务器 默认值: false 起始版本: 0.9.25 需要: userAgentRejectList 属性 描述: 拒绝与 User-Agent 匹配的连接 示例: option.rejectUserAgents=false tunnel.N.option.userAgentRejectList (option.userAgentRejectList) 类型: 字符串（逗号分隔的匹配字符串） 适用范围: 仅限 HTTP 服务器 自: 自版本 0.9.25 起 大小写: 大小写敏感匹配 特殊: \u0026ldquo;none\u0026rdquo;（自 0.9.33 起）匹配空的 User-Agent 描述: 要拒绝的 User-Agent 模式列表 示例: option.userAgentRejectList=Mozilla,Opera,none IRC 服务器选项 tunnel.N.option.ircserver.fakeHostname (option.ircserver.fakeHostname) 类型: 字符串（主机名模式） 上下文: 仅限 IRC 服务器 默认值: %f.b32.i2p 占位符: %f = 完整的 base32 目标地址哈希 %c = 遮蔽的目标地址哈希（参见 cloakKey） 描述: 发送给 IRC 服务器的主机名格式 示例: option.ircserver.fakeHostname=%c.irc.i2p tunnel.N.option.ircserver.cloakKey (option.ircserver.cloakKey) 类型: 字符串（密码短语） 适用范围: 仅适用于 IRC 服务器 默认值: 每个会话随机生成 限制: 不得包含引号或空格 描述: 用于实现一致主机名伪装的密码短语 使用场景: 跨重启/服务器的持久用户跟踪 示例: option.ircserver.cloakKey=mysecretkey tunnel.N.option.ircserver.method (option.ircserver.method) 类型: 枚举 适用范围: 仅限 IRC 服务器 默认值: user 可选值: user、webirc 说明: 用于 IRC 服务器的认证方法 示例: option.ircserver.method=webirc tunnel.N.option.ircserver.webircPassword (option.ircserver.webircPassword) 类型: 字符串 (密码) 上下文: 仅限 IRC 服务器 要求: method=webirc 限制: 不得包含引号或空格 描述: 用于 WEBIRC 协议认证的密码 示例: option.ircserver.webircPassword=webircpass tunnel.N.option.ircserver.webircSpoofIP (option.ircserver.webircSpoofIP) 类型: 字符串（IP 地址） 上下文: 仅限 IRC 服务器 要求: method=webirc 描述: 用于 WEBIRC 协议的伪造 IP 地址 示例: option.ircserver.webircSpoofIP=10.0.0.1 SSL/TLS 配置 tunnel.N.option.useSSL (option.useSSL) 类型: 布尔值 默认值: false 适用范围: 所有 tunnels 行为: 服务器: 对与本地服务器的连接使用 SSL 客户端: 要求本地客户端使用 SSL 示例: option.useSSL=false tunnel.N.option.keystoreFile (option.keystoreFile) 类型: 字符串 (文件路径) 上下文: 仅用于 Client tunnels 默认值: i2ptunnel-(random).ks 路径: 若非绝对路径，则相对于 $(I2P_CONFIG_DIR)/keystore/ 自动生成: 如果不存在则创建 说明: 包含 SSL 私钥的密钥库文件 示例: option.keystoreFile=my-tunnel.ks tunnel.N.option.keystorePassword (option.keystorePassword) 类型: 字符串（密码） 适用范围: 仅限客户端 tunnels 默认值: changeit 自动生成: 若创建新密钥库则随机生成密码 描述: SSL 密钥库的密码 示例: option.keystorePassword=secretpassword tunnel.N.option.keyAlias (option.keyAlias) 类型: 字符串（别名） 上下文: 仅用于 Client tunnels 自动生成: 如果生成了新密钥，则创建 描述: 密钥库中的私钥别名 示例: option.keyAlias=mytunnel-key tunnel.N.option.keyPassword (option.keyPassword) 类型: 字符串（密码） 上下文: 仅限客户端 tunnels 自动生成: 创建新密钥时生成随机密码 描述: 密钥库中私钥的密码 示例: option.keyPassword=keypass123 通用 I2CP 与 Streaming（流式传输）选项 所有 tunnel.N.option.* 属性（上文未特别说明的）在传递给 I2CP 接口和 streaming library（流式库）时，会去除 tunnel.N.option. 前缀。\n重要：这些与 I2PTunnel 特定选项是分开的。参见： - I2CP 规范 - Streaming Library 规范（流式传输库） 示例流式传输选项：\noption.i2cp.messageReliability=BestEffort option.i2p.streaming.connectDelay=1000 option.i2p.streaming.maxWindowSize=128 完整的 Tunnel 示例 # HTTP Proxy (split format without tunnel.N. prefix) name=I2P HTTP Proxy description=HTTP proxy for accessing I2P sites and outproxy type=httpclient interface=127.0.0.1 listenPort=4444 targetDestination= sharedClient=true startOnLoad=true # I2CP configuration i2cpHost=127.0.0.1 i2cpPort=7654 # HTTP client options option.i2ptunnel.httpclient.allowInternalSSL=false option.i2ptunnel.httpclient.disableAddressHelper=false option.i2ptunnel.httpclient.jumpServers=http://stats.i2p/cgi-bin/jump.cgi option.i2ptunnel.httpclient.sendAccept=false option.i2ptunnel.httpclient.sendReferer=false option.i2ptunnel.httpclient.sendUserAgent=false # Proxy authentication option.proxyAuth=false # Outproxy configuration option.i2ptunnel.httpclient.SSLOutproxies=false.i2p proxyList=false.i2p # Client behavior option.persistentClientKey=false option.i2cp.delayOpen=false # I2CP tunnel options option.inbound.length=3 option.outbound.length=3 option.inbound.quantity=2 option.outbound.quantity=2 版本历史与特性时间线 版本 0.9.10 (2013) Feature: 配置文件中的空值支持 - 现在支持具有空值的键（key=） - 此前会被忽略或导致解析错误\n版本 0.9.18 (2015) 功能: 日志记录器刷新间隔配置 - 属性: logger.flushInterval (默认 29 秒) - 在保持可接受的日志延迟的同时降低磁盘 I/O\n版本 0.9.23（2015年11月） 重大变更: 最低要求为 Java 7 - 已结束对 Java 6 的支持 - 为继续获得安全更新所必需\n版本 0.9.25（2015） 功能：HTTP 服务器安全选项 - tunnel.N.option.rejectReferer - 拒绝带有 Referer 头的连接 - tunnel.N.option.rejectUserAgents - 拒绝特定的 User-Agent 头 - tunnel.N.option.userAgentRejectList - 要拒绝的 User-Agent 模式 - 使用场景：缓解爬虫和不受欢迎客户端的访问\n版本 0.9.33 (2018年1月) 功能: 增强的 User-Agent 过滤 - userAgentRejectList 字符串 \u0026ldquo;none\u0026rdquo; 可匹配空的 User-Agent - 针对 i2psnark、i2ptunnel、streaming、SusiMail 的更多错误修复\n版本 0.9.41（2019 年） 弃用: 已从 Android 移除 BOB 协议 - Android 用户必须迁移到 SAM 或 I2CP\n版本 0.9.42（2019年8月） 重大变更：配置文件拆分 - 将 clients.config 拆分为 clients.config.d/ 目录结构 - 将 i2ptunnel.config 拆分为 i2ptunnel.config.d/ 目录结构 - 升级后首次运行时自动迁移 - 支持模块化打包和插件管理 - 仍支持传统的单体格式\n其他功能: - SSU 性能改进 - 跨网络防护 (提案 147) - 初始加密类型支持\n版本 0.9.56（2021） 功能: 安全与日志改进 - logger.gzip - 对轮转日志启用 Gzip 压缩（默认值：false） - logger.minGzipSize - 压缩的最小大小（默认值：65536 字节） - tunnel.N.option.proxy.auth.USER.sha256 - SHA-256 摘要认证（RFC 7616） - 安全: SHA-256 取代 MD5 用于摘要认证\n版本 0.9.57（2023年1月） 功能: SOCKS outproxy（出口代理）类型配置 - tunnel.N.option.outproxyType - 选择 outproxy 类型 (socks|connect) - 默认: socks - 为 HTTPS outproxy 提供 HTTPS CONNECT 支持\n版本 2.6.0 (2024年7月) 破坏性变更: I2P-over-Tor 已被阻止 - 来自 Tor 出口节点 IP 地址的连接现已被拒绝 - 原因: 降低 I2P 性能，浪费 Tor 出口资源 - 影响: 通过 Tor 出口节点访问 I2P 的用户将被阻止 - 非出口中继和 Tor 客户端不受影响\n版本 2.10.0 (2025年9月 - 至今) 主要特性: - 后量子密码学 可用（可通过 Hidden Service Manager（隐藏服务管理器）选择启用） - UDP tracker 支持，用于 I2PSnark（I2P 内置的 BitTorrent 客户端），以降低 tracker 负载 - Hidden Mode（隐藏模式）稳定性 改进，以减少 RouterInfo 耗尽 - 针对拥塞的 router 的网络改进 - 增强的 UPnP/NAT 穿透 - NetDB 改进，包含更积极的 leaseset 移除 - 降低 router 事件的可观测性\n配置: 未添加新的配置属性\n即将到来的重大变更：下一个发行版（可能为 2.11.0 或 3.0.0）将需要 Java 17 或更高版本\n弃用与不兼容变更 重大弃用 I2P-over-Tor 访问 (版本 2.6.0+) 状态: 自 2024 年 7 月起已被封锁 影响: 来自 Tor 出口节点 IP 地址的连接将被拒绝 原因: 在未提供匿名性收益的情况下，会降低 I2P 网络性能 影响范围: 仅限 Tor 出口节点，不包括中继或普通 Tor 客户端 替代方案: 单独使用 I2P 或 Tor，不要组合使用 MD5 摘要认证 状态: 已弃用（使用 SHA-256） 属性: tunnel.N.option.proxy.auth.USER.md5 原因: MD5 在密码学上已被攻破 替代项: tunnel.N.option.proxy.auth.USER.sha256（自 0.9.56 起） 时间线: 仍支持 MD5，但不推荐 配置架构变更 单体式配置文件 (版本 0.9.42+) 受影响: clients.config, i2ptunnel.config 状态: 已弃用，改用拆分目录结构 迁移: 升级到 0.9.42 后首次运行时自动进行 兼容性: 旧格式仍然可用（向后兼容） 建议: 新配置请使用拆分格式 Java 版本要求 Java 6 支持 已结束: 版本 0.9.23（2015年11月） 最低要求: 自 0.9.23 起需要 Java 7 Java 17 要求 (即将到来) 状态：重大即将变更 目标：2.10.0 之后的下一次主版本发布（可能是 2.11.0 或 3.0.0） 当前最低要求：Java 8 所需操作：为迁移到 Java 17 做好准备 时间表：将随发行说明公布 已移除的功能 BOB 协议（Android） 已移除: 版本 0.9.41 平台: 仅限 Android 替代方案: SAM 或 I2CP 协议 桌面端: BOB 在桌面平台仍可用 推荐的迁移 认证：从 MD5 迁移到 SHA-256 摘要认证 配置格式：迁移到为客户端和 tunnels 拆分的目录结构 Java 运行时：计划在下一个主要版本发布之前升级到 Java 17 Tor 集成：不要通过 Tor 的出口节点路由 I2P 参考资料 官方文档 I2P 配置规范 - 官方配置文件格式规范 I2P 插件规范 - 插件配置与打包 I2P 通用结构 - 类型映射 - 协议数据序列化格式 Java Properties 格式 - 基础格式规范 源代码 I2P Java Router 仓库 - GitHub 镜像 I2P 开发者 Gitea - 官方 I2P 源代码仓库 DataHelper.java - 配置文件 I/O 实现 社区资源 I2P 论坛 - 活跃的社区讨论与支持 I2P 网站 - 项目官方网站 API 文档 DataHelper JavaDoc - 关于配置文件方法的 API 文档 规范状态 规范上次更新: 2023年1月（版本 0.9.57） 当前 I2P 版本: 2.10.0（2025年9月） 技术准确性: 规范截至 2.10.0 仍然准确（无向后不兼容更改） 维护: 这是一个持续维护的文档，会在配置格式修改时更新 ","description":"I2P routers 和客户端的配置选项与格式","id":"b6b01c53245c0e36ca08c56f843abb7f","section":"docs","title":"Router 配置","url":"/zh/docs/specs/configuration/"},{"categories":null,"content":" 已弃用： SAM v1 仅保留用于历史参考。新应用应使用 SAM v3 或 BOB 。原始桥接程序仅支持 DSA-SHA1 Destination（目标地址）以及有限的选项集。\n库 Java I2P 源代码树仍包含面向 C、C#、Perl 和 Python 的遗留绑定。它们已不再维护，主要为了归档兼容性而随发行版提供。\n版本协商 客户端通过 TCP（默认 127.0.0.1:7656）连接并交换：\nClient → HELLO VERSION MIN=1 MAX=1 Bridge → HELLO REPLY RESULT=OK VERSION=1.0 自 Java I2P 0.9.14 起，MIN 参数是可选的，并且 MIN/MAX 都接受一位数字形式（\u0026quot;3\u0026quot; 等），适用于已升级的桥接。\n会话创建 SESSION CREATE STYLE={STREAM|DATAGRAM|RAW} DESTINATION={name|TRANSIENT} [DIRECTION={BOTH|RECEIVE|CREATE}] [option=value]* DESTINATION=name 会在 sam.keys 中加载或创建一个条目；TRANSIENT 始终创建一个临时 Destination（目标地址）。 STYLE 用于选择虚拟流（类似 TCP）、签名数据报，或原始数据报。 DIRECTION 仅适用于流会话；默认为 BOTH。 其他键/值对将作为 I2CP 选项传递（例如，tunnels.quantityInbound=3）。 网桥回复：\nSESSION STATUS RESULT=OK DESTINATION=name 失败会返回 DUPLICATED_DEST、I2P_ERROR 或 INVALID_KEY，并可附带一条可选消息。\n消息格式 SAM 消息为单行 ASCII，由以空格分隔的键/值对组成。键使用 UTF‑8 编码；如果值包含空格，可以用引号括起。未定义任何转义。\n通信类型：\n流 – 通过 I2P streaming library（I2P 的流式传输库）代理 可回复数据报 – 已签名的负载 (Datagram1) 原始数据报 – 未签名的负载 (Datagram RAW) 0.9.14 版本新增的选项 DEST GENERATE 接受 SIGNATURE_TYPE=...（允许使用 Ed25519 等） HELLO VERSION 将 MIN 视为可选，并接受一位数的版本字符串 何时使用 SAM v1 仅在需要与无法更新的遗留软件互操作时使用。对于所有新的开发，请使用：\nSAM v3 用于功能完备的流/数据报访问 BOB 用于 Destination（目的地）管理（仍然有限，但支持更现代的功能） 参考资料 SAM v2 SAM v3 数据报规范 流式协议 SAM v1 为与 router 无关的应用开发奠定了基础，但生态系统已经向前发展了。请将本文档视为兼容性参考，而非起点。\n","description":"旧版 Simple Anonymous Messaging（简单匿名消息传递）协议（已弃用）","id":"d6c20329db11e9b5a1eff3a8709b3294","section":"docs","title":"SAM v1","url":"/zh/docs/legacy/sam/"},{"categories":null,"content":" 已弃用： 随 I2P 0.6.1.31 一同发布的 SAM v2 已不再维护。新开发请使用 SAM v3 。v2 相比 v1 的唯一改进是支持在单个 SAM 连接上复用多个套接字。\n版本说明 上报的版本字符串仍为 \u0026quot;2.0\u0026quot;。 自 0.9.14 起，HELLO VERSION 消息接受一位数的 MIN/MAX 值，并且 MIN 参数是可选的。 DEST GENERATE 支持 SIGNATURE_TYPE，因此可以创建 Ed25519（椭圆曲线签名算法）目的地。 会话基础 SESSION CREATE STYLE={STREAM|DATAGRAM|RAW} DESTINATION={name|TRANSIENT} [DIRECTION={BOTH|RECEIVE|CREATE}] [option=value] 每个 Destination（I2P 目标标识）只能有一个活动的 SAM 会话（streams、datagrams 或 raw）。 STYLE 用于选择虚拟流、已签名的数据报，或原始数据报。 其他选项会传递给 I2CP（例如，tunnels.quantityInbound=3）。 响应与 v1 相同：SESSION STATUS RESULT=OK|DUPLICATED_DEST|I2P_ERROR|INVALID_KEY。 消息编码 按行组织的 ASCII，使用空格分隔的 key=value 键值对（值可以用引号括起）。通信类型与 v1 相同：\n通过 I2P streaming library (I2P 流式传输库) 提供的流 可回复数据报 (PROTO_DATAGRAM) 原始数据报 (PROTO_DATAGRAM_RAW) 何时使用 仅适用于无法迁移的遗留客户端。SAM v3 提供：\n二进制目标地址交接 (DEST GENERATE BASE64) 子会话与 DHT 支持 (v3.3) 更好的错误报告和选项协商 参见：\nSAM v1 SAM v3 数据报 API 流式协议 ","description":"遗留版简单匿名消息传递协议","id":"a21e46f2603ba3051f18eff26aa5084d","section":"docs","title":"SAM v2（Simple Anonymous Messaging，I2P 的简单匿名消息接口）","url":"/zh/docs/legacy/samv2/"},{"categories":null,"content":"SAM v3（\u0026ldquo;Simple Anonymous Messaging\u0026rdquo;，简单匿名消息传递）是当前稳定的、与路由器无关的 API，允许外部应用程序与 I2P 网络通信，而无需嵌入 router 本身。它提供对流、数据报和原始消息的统一访问，并且仍然是非 Java 软件的规范桥接层。\n1. 概述与目的 SAM v3 使开发者能够使用轻量级的 TCP/UDP 协议，以任何编程语言构建支持 I2P 的软件。它抽象了 router 内部机制，通过 TCP（7656 端口）和 UDP（7655 端口）暴露一组最小化的命令集。Java I2P 和 i2pd 都实现了 SAM v3 规范的子集，但截至 2025 年，i2pd 仍然缺少大部分 3.2 和 3.3 版本的扩展功能。\n2. 版本历史 Version Introduced Key Features 3.00.7.3 (May 2009)Streams + Datagrams; binary destinations; `SESSION CREATE STYLE=` parameter. 3.10.9.14 (Jul 2014)Signature type negotiation via `SIGNATURE_TYPE`; improved `DEST GENERATE`. 3.20.9.24 (Jan 2016)Per session encryption + tunnel options; `STREAM CONNECT ID` support. 3.30.9.25 (Mar 2016)PRIMARY / SUBSESSION architecture; multiplexing; improved datagrams. ### 命名说明 Java I2P 使用 PRIMARY/SUBSESSION。 i2pd 和 I2P+ 继续使用传统的 MASTER/SUBSESSION 术语以保持向后兼容性。 3. 核心工作流程 版本协商 HELLO VERSION MIN=3.1 MAX=3.3 HELLO REPLY RESULT=OK VERSION=3.3 目的地创建 DEST GENERATE SIGNATURE_TYPE=7 SIGNATURE_TYPE=7 → Ed25519 (EdDSA SHA512)。自 I2P 0.9.15 起强烈推荐。 会话创建 SESSION CREATE STYLE=STREAM DESTINATION=NAME OPTION=i2cp.leaseSetEncType=4,0 OPTION=inbound.quantity=3 OPTION=outbound.quantity=3 i2cp.leaseSetEncType=4,0 → 4 是 X25519 (ECIES X25519 AEAD Ratchet)，0 是 ElGamal 后备选项以保持兼容性。 明确的 tunnel 数量以保持一致性：Java I2P 默认 2，i2pd 默认 5。 协议操作 STREAM CONNECT ID=1 DESTINATION=b32address.i2p STREAM SEND ID=1 SIZE=128 STREAM CLOSE ID=1 核心消息类型包括：STREAM CONNECT、STREAM ACCEPT、STREAM FORWARD、DATAGRAM SEND、RAW SEND、NAMING LOOKUP、DEST LOOKUP、PING、QUIT。\n优雅关闭 QUIT 4. 实现差异（Java I2P vs i2pd） Feature Java I2P 2.10.0 i2pd 2.58.0 (Sept\u0026nbsp;2025) SAM enabled by default❌ Requires manual enable in router console✅ Enabled via `enabled=true` in `i2pd.conf` Default portsTCP 7656 / UDP 7655Same AUTH / USER / PASSWORD✓ Supported✗ Not implemented PING / PONG keepalive✓ Supported✗ Not implemented QUIT / STOP / EXIT commands✓ Supported✗ Not implemented FROM_PORT / TO_PORT / PROTOCOL✓ Supported✗ Not implemented PRIMARY/SUBSESSION support✓ (since 0.9.47)✗ Absent SESSION ADD / REMOVE✓ Supported✗ Not implemented Datagram2 / Datagram3 support✓ (since 2.9.0)✗ Not implemented SSL/TLSOptional✗ None Default tunnel quantitiesInbound/outbound=2Inbound/outbound=5 **建议：** 始终明确指定 tunnel 数量以确保跨 router 的一致性。 5. 支持的库（2025年快照） Library Language SAM Support Maintenance Status (2025) libsam3C3.1Maintained by I2P Project (eyedeekay) i2psamC++3.1Minimal updates since 2019 sam3Go3.3Active; migrated from `eyedeekay/sam3` onrampGo3.3Actively maintained (2025) i2plibPython3.1Modern async replacement for `i2p.socket` i2p.socketPython3.2Abandoned (last release 2017) Py2pPython3.3Unverified/inactive i2p-rsRust3.1Experimental; unstable API @diva.exchange/i2p-samTypeScript / JS3.3Most actively maintained (2024–2025) I2PSharpC#3.3Functional; light maintenance ## 6. 即将推出和新功能(2024–2025) Feature Status Introduced NAMING LOOKUP `OPTIONS=true`✓ Supported2.8.0 Datagram2 / Datagram3 formats✓ (Java only)2.9.0 Post-quantum hybrid crypto (ML KEM)Optional2.10.0 Java 17+ runtime requirementPlanned2.11.0 I2P over Tor blockingActive2.6.0 Improved floodfill selectionActive2.8.0+ ## 7. 安全与配置注意事项 仅将 SAM 绑定到 127.0.0.1。 对于持久化服务,使用带有静态密钥的 PRIMARY 会话。 使用 HELLO VERSION 来测试功能支持情况。 使用 PING 或 NAMING LOOKUP 来验证 router 存活状态。 避免未经身份验证的远程 SAM 连接(i2pd 中没有 TLS)。 8. 参考资料和规范 SAM v3 规范 SAM v2 (旧版) Streaming 规范 数据报 文档中心 i2pd 文档 9. 总结 SAM v3 仍然是所有非 Java I2P 应用程序的推荐桥接协议。它提供稳定性、跨语言绑定以及在各种 router 类型上的一致性能。\n在使用 SAM 进行开发时：- 使用 Ed25519 签名和 X25519 加密。- 通过 HELLO VERSION 动态验证功能支持。- 设计时考虑兼容性，特别是当需要同时支持 Java I2P 和 i2pd router 时。\n","description":"用于非 Java I2P 应用程序的稳定桥接协议","id":"dd6d27c1d72fe7c4333dc148d132f546","section":"docs","title":"SAM v3","url":"/zh/docs/api/samv3/"},{"categories":null,"content":" 注意： SOCKS tunnel 会直接转发应用程序负载而不对其进行清理。许多协议会泄露 IP 地址、主机名或其他标识符。只能在经过匿名性审计的软件中使用 SOCKS。\n1. 概述 I2P 通过 I2PTunnel 客户端为出站连接提供 SOCKS 4、4a 和 5 代理支持。它使标准应用程序能够访问 I2P 目的地,但无法访问明网。没有 SOCKS outproxy,所有流量都保持在 I2P 网络内。\n实现摘要 Parameter Java I2P i2pd Default Port User-defined 127.0.0.1:4447 Supported SOCKS Versions 4, 4a, 5 4, 4a, 5 UDP Mode Stubbed (non-functional) Stubbed (non-functional) Persistent Keys ✅ Since 0.9.9 ✅ Shared Client Tunnels Supported Supported Outproxy Support ❌ None ❌ None **支持的地址类型：** - `.i2p` 主机名（地址簿条目） - Base32 哈希值（`.b32.i2p`） - 不支持 Base64 或明网地址 2. 安全风险和限制 应用层泄漏 SOCKS 在应用层下方运行，无法清理协议。许多客户端（例如浏览器、IRC、电子邮件）包含会泄露您的 IP 地址、主机名或系统详细信息的元数据。\n常见的泄露包括：- 邮件头或 IRC CTCP 响应中的 IP 地址 - 协议负载中的真实姓名/用户名 - 带有操作系统指纹的用户代理字符串 - 外部 DNS 查询 - WebRTC 和浏览器遥测数据\nI2P 无法防止这些泄漏——它们发生在 tunnel 层之上。仅对经过审计的客户端使用 SOCKS,这些客户端需专为匿名性设计。\n共享隧道身份 如果多个应用程序共享同一个 SOCKS tunnel，它们将共享相同的 I2P destination 身份。这会导致不同服务之间的关联或指纹识别问题。\n缓解措施： 为每个应用程序使用非共享隧道，并启用持久密钥以在重启后保持一致的加密身份。\nUDP 模式已被移除 SOCKS5 中的 UDP 支持尚未实现。该协议会宣告 UDP 功能，但调用会被忽略。请使用仅支持 TCP 的客户端。\n设计上不提供出口代理 与 Tor 不同,I2P 不提供基于 SOCKS 的明网出口代理。尝试访问外部 IP 将会失败或暴露身份。如果需要出口代理功能,请使用 HTTP 或 HTTPS 代理。\n3. 历史背景 开发者长期以来不鼓励将 SOCKS 用于匿名用途。来自内部开发者讨论以及 2004 年的 Meeting 81 和 Meeting 82 :\n\u0026ldquo;转发任意流量是不安全的,作为匿名软件的开发者,我们有责任将终端用户的安全放在首位。\u0026rdquo;\n包含 SOCKS 支持是为了兼容性，但不建议在生产环境中使用。几乎所有互联网应用程序都会泄露不适合匿名路由的敏感元数据。\n4. 配置 Java I2P 打开 I2PTunnel Manager 创建一个类型为 \u0026ldquo;SOCKS 4/4a/5\u0026rdquo; 的新客户端 tunnel 配置选项: 本地端口(任何可用端口) 共享客户端:禁用,为每个应用程序使用独立身份 持久密钥:启用以减少密钥关联 启动 tunnel i2pd i2pd 默认启用 SOCKS5 支持，监听地址为 127.0.0.1:4447。可以在 i2pd.conf 的 [SOCKSProxy] 部分配置端口、主机地址和 tunnel 参数。\n5. 开发时间表 Version Change Date 0.7.1 Initial SOCKS 4/4a/5 support 2010 0.9.9 Added persistent keying 2013 1.7.0 BOB API deprecated and removed 2022 2.6.0 I2P-over-Tor blocked to improve network health 2024 2.10.0 Post-quantum hybrid encryption introduced 2025 SOCKS 模块本身自 2013 年以来没有进行重大的协议更新,但周围的 tunnel 栈已经获得了性能和密码学方面的改进。 6. 推荐的替代方案 对于任何生产环境、面向公众或安全关键型应用程序，请使用官方 I2P API 之一，而不是 SOCKS：\nAPI Description Recommended For SAM v3 (3.3) Simple Anonymous Messaging API Cross-language apps needing socket-like I/O Streaming Library TCP-like sockets for Java Native Java integrations I2CP Low-level router communication Custom protocols, router-level integration BOB Deprecated (removed 2022) Legacy only; migrate to SAM 这些 API 提供了适当的目标隔离、密码学身份控制以及更好的路由性能。 7. OnionCat / GarliCat OnionCat 通过其 GarliCat 模式（fd60:db4d:ddb5::/48 IPv6 范围）支持 I2P。仍然可用，但自 2019 年以来开发活动有限。\n使用注意事项： - 需要在 SusiDNS 中手动配置 .oc.b32.i2p - 需要静态 IPv6 分配 - I2P 项目未正式支持\n仅推荐用于高级 VPN-over-I2P 配置。\n8. 最佳实践 如果你必须使用 SOCKS：1. 为每个应用程序创建单独的 tunnel。2. 禁用共享客户端模式。3. 启用持久密钥。4. 强制使用 SOCKS5 DNS 解析。5. 审计协议行为以防泄漏。6. 避免明网连接。7. 监控网络流量以防泄漏。\n9. 技术摘要 Parameter Value Supported SOCKS Versions 4, 4a, 5 Transport TCP only UDP Support Stubbed (non-functional) Clearnet Access Not supported Default Ports Java I2P: user-set; i2pd: 127.0.0.1:4447 Persistent Keying Supported since 0.9.9 Shared Tunnels Supported (discouraged) --- 10. 结论 I2P 中的 SOCKS 代理提供了与现有 TCP 应用程序的基本兼容性,但并非为强匿名性保证而设计。它应仅用于受控的、经过审计的测试环境。\n对于正式部署，请迁移到 SAM v3 或 Streaming API。这些 API 隔离应用程序身份，使用现代密码学，并持续获得开发支持。\n其他资源 官方 SOCKS 文档 SAM v3 规范 Streaming 库文档 I2PTunnel 参考 I2P 开发者文档 社区论坛 ","description":"安全使用 I2P 的 SOCKS tunnel（更新至 2.10.0 版本）","id":"e71093f25f593f15b6820398338abc89","section":"docs","title":"SOCKS 代理","url":"/zh/docs/api/socks/"},{"categories":null,"content":" 已弃用： SSU 已被 SSU2（第二代 SSU 协议）取代。在 i2pd 2.44.0（API 0.9.56，2022 年 11 月）以及 Java I2P 2.4.0（API 0.9.61，2023 年 12 月）中已移除对 SSU 的支持。\nSSU 提供了基于 UDP、带有拥塞控制、NAT 穿越以及对 introducer（引荐者）支持的半可靠传输。它通过为位于 NAT/防火墙之后的 routers 提供支持并协调进行 IP 发现，与 NTCP 形成互补。\n地址元素 transport: SSU caps: 能力标志 (B, C, 4, 6 等) host / port: IPv4 或 IPv6 监听（当被防火墙阻挡时可选） key: Base64 引入密钥 mtu: 可选；默认 1484 (IPv4) / 1488 (IPv6) ihost/ikey/iport/itag/iexp: 当 router 被防火墙阻挡时的 introducer（引入者）条目 功能 使用 introducers（引介者）的协作式 NAT 穿越 通过对等节点测试和检查入站数据包来检测本地 IP 自动将防火墙状态中继到其他传输和 router 控制台 半可靠传递：消息在达到重传上限后被丢弃 使用加性增加/乘性减少和分片 ACK 位字段的拥塞控制 SSU 还处理元数据任务，如定时信标和 MTU 协商。所有功能现由 SSU2 提供（采用现代密码学）。\n","description":"最初的 Secure Semireliable UDP 传输","id":"15d4d0ea2bfc8074b5a7981b8673c420","section":"docs","title":"SSU (旧版)","url":"/zh/docs/legacy/ssu/"},{"categories":null,"content":" 已弃用： SSU (Secure Semi-Reliable UDP，安全的半可靠 UDP) 已被 SSU2 取代。Java I2P 在 2.4.0 版（API 0.9.61）中移除了 SSU，i2pd 在 2.44.0（API 0.9.56）中也将其移除。本文档仅保留作历史参考。\n亮点 UDP 传输，提供加密、认证的 I2NP 消息点对点投递。 依赖 2048 位 Diffie–Hellman 握手（与 ElGamal 使用相同的素数）。 每个数据报携带一个 16 字节的 HMAC-MD5（非标准的截断变体）+ 16 字节的 IV，随后是经 AES-256-CBC 加密的有效载荷。 重放防护与会话状态在加密的有效载荷内进行跟踪。 消息头 [16-byte MAC][16-byte IV][encrypted payload] 使用的 MAC 计算：HMAC-MD5(ciphertext || IV || (len ^ version ^ ((netid-2)\u0026lt;\u0026lt;8)))，使用 32 字节的 MAC 密钥。负载长度以大端序 16 位表示，并在 MAC 计算中附加。协议版本默认为 0；netId 默认为 2（主网络）。\n会话与 MAC 密钥 派生自 DH 共享秘密：\n将共享值转换为大端序字节数组（如果最高位被置位，则在前面加上 0x00）。 会话密钥：前 32 个字节（如果更短则用零填充）。 MAC 密钥：第 33–64 个字节；如果不足，则改用共享值的 SHA-256 哈希。 状态 router 不再通告 SSU 地址。客户端应迁移至 SSU2 或 NTCP2 传输协议。历史实现可在较早的发行版中找到：\n2.4.0 之前的 Java 源代码，位于 router/transport/udp 下 2.44.0 之前的 i2pd 源代码 有关当前 UDP 传输行为，请参阅 SSU2 规范 。\n","description":"在 SSU2 之前使用的最初 UDP 传输","id":"1eefecf66e3adc6ea013d5a5e58326da","section":"docs","title":"SSU 传输 (已弃用)","url":"/zh/docs/legacy/ssu/"},{"categories":null,"content":"1. 概览 SSU2 是一种基于 UDP 的传输层协议，用于在 I2P 中实现安全、半可靠的 router 间通信。它并非通用传输协议，而是专为I2NP 消息交换而设计。\n核心功能 通过 Noise XK pattern（Noise 协议族中的 XK 握手模式）实现认证密钥交换 加密头部以抵抗深度包检测（DPI） 使用中继与打洞实现 NAT 穿越 连接迁移与地址验证 可选的路径验证 前向保密与重放保护 遗留与兼容性 Implementation SSU2 Default SSU1 Removed i2pd2.44.02.44.0 Java I2P0.9.560.9.61 SSU1 在公共 I2P 网络中已不再使用。 2. 密码学 SSU2 使用 Noise_XK_25519_ChaChaPoly_SHA256（一种 Noise 协议的握手与加密套件组合），并带有 I2P 专用扩展。\nFunction Algorithm Notes Diffie-HellmanX25519 (RFC 7748)32-byte keys CipherChaCha20/Poly1305 (RFC 7539)AEAD encryption HashSHA-256Used for key derivation and message integrity KDFHKDF-SHA256 (RFC 5869)For session and header keys 头部和有效载荷通过 `mixHash()` 在密码学上绑定。为提高实现效率，所有密码学原语与 NTCP2 和 ECIES（椭圆曲线集成加密方案）共享。 3. 消息概述 3.1 UDP 数据报规则 每个 UDP 数据报承载恰好一个 SSU2 message。 Session Confirmed（会话确认）消息可能会被分片到多个数据报中。 最小大小： 40 字节 最大大小： 1472 字节 (IPv4) / 1452 字节 (IPv6)\n3.2 消息类型 Type Message Header Description 0Session Request32BHandshake initiation 1Session Created32BHandshake response 2Session Confirmed16BFinal handshake, may be fragmented 6Data16BEncrypted I2NP message blocks 7Peer Test32BNAT reachability testing 9Retry32BToken or rejection notice 10Token Request32BRequest for validation token 11Hole Punch32BNAT traversal signaling --- 4. 会话建立 4.1 标准流程（有效令牌） Alice Bob SessionRequest ─────────────\u0026gt; \u0026lt;────────────── SessionCreated SessionConfirmed ────────────\u0026gt; 4.2 令牌获取 Alice Bob TokenRequest ───────────────\u0026gt; \u0026lt;────────────── Retry (Token) SessionRequest ─────────────\u0026gt; \u0026lt;────────────── SessionCreated SessionConfirmed ────────────\u0026gt; 4.3 无效令牌 Alice Bob SessionRequest ─────────────\u0026gt; \u0026lt;────────────── Retry (Termination) 5. 头部结构 5.1 长首部（32 字节） 在会话建立之前使用（SessionRequest、Created、Retry、PeerTest、TokenRequest、HolePunch）。\nField Size Description Destination Connection ID8Random unique ID Packet Number4Random (ignored during handshake) Type1Message type Version1Always 2 NetID12 = main I2P network Flags1Reserved (0) Source Connection ID8Random ID distinct from destination Token8Token for address validation ### 5.2 短首部（16 字节） 在已建立的会话期间使用（SessionConfirmed、Data）。\nField Size Description Destination Connection ID8Stable throughout session Packet Number4Incrementing per message Type1Message type (2 or 6) Flags3ACK/fragment flags --- 6. 加密 6.1 AEAD（带关联数据的认证加密） 所有有效载荷均使用**ChaCha20/Poly1305 AEAD（带关联数据的认证加密）**进行加密：\nciphertext = ChaCha20_Poly1305_Encrypt(key, nonce, plaintext, associated_data) Nonce: 12 字节（4 字节全零 + 8 字节计数器） 认证标签: 16 字节 关联数据: 包含用于完整性绑定的头部 6.2 头部保护 使用由会话头部密钥导出的 ChaCha20 密钥流对头部进行掩蔽。这确保所有连接 ID 和数据包字段看起来是随机的，从而抵御深度包检测（DPI）。\n6.3 密钥派生 Phase Input Output InitialintroKey + salthandshake header key HandshakeDH(X25519)chainKey + AEAD key Data phasechainKeyTX/RX keys Key rotationoldKeynewKey --- 7. 安全性与重放防护 令牌按每个 IP 分配，约 60 秒后过期。 通过按会话的布隆过滤器防止重放攻击。 重复的临时密钥将被拒绝。 头部与载荷通过密码学方式绑定在一起。 Routers 必须丢弃任何未通过 AEAD 认证的数据包，或版本号或 NetID 无效的数据包。\n8. 数据包编号与会话生命周期 每个方向各自维护一个 32 位计数器。 - 从 0 开始，每个数据包递增一次。 - 不得回绕；在达到 2³² 之前执行 session rekey（重新协商/更换会话密钥）或终止会话。\n连接 ID 在整个会话期间保持不变，包括迁移期间。\n9. 数据阶段 类型 = 6 (数据) 短报头 (16 字节) 有效载荷包含一个或多个加密块: ACK/NACK 列表 I2NP 消息片段 填充 (0–31 字节的随机数据) 终止块 (可选) 支持选择性重传和乱序投递。可靠性仍为“半可靠” — 在达到重试上限后，丢失的数据包可能会被静默丢弃。\n10. 中继与 NAT 穿越 Message Type Purpose Peer Test7Determines inbound reachability Retry9Issues new token or rejection Token Request10Requests new address token Hole Punch11Coordinates NAT hole punching 中继router通过这些控制消息协助位于限制性NAT之后的对等节点。 11. 会话终止 任一对等方可以使用 Data message（数据消息）中的 Termination block（终止块）关闭会话。 资源必须在接收后立即释放。 确认后，重复的终止数据包可以被忽略。\n12. 实现指南 Routers MUST: - 验证 version = 2 且 NetID = 2。 - 丢弃小于 40 字节的数据包，或无效的 AEAD（带关联数据的认证加密）。 - 强制 120 秒的重放缓存。 - 拒绝重复使用的令牌或临时密钥。\nRouters 应当: - 将填充长度随机化为 0–31 字节。 - 使用自适应重传（RFC 6298）。 - 在迁移之前实现针对每个对等端的路径验证。\n13. 安全摘要 Property Achieved By Forward secrecyX25519 ephemeral keys Replay protectionTokens + Bloom filter Authenticated encryptionChaCha20/Poly1305 KCI resistanceNoise XK pattern DPI resistanceEncrypted headers NAT traversalRelay + Hole Punch MigrationStatic connection IDs --- 14. 参考资料 提案 159 – SSU2 Noise 协议框架 RFC 9000 – QUIC 传输 RFC 9001 – QUIC TLS RFC 7539 – ChaCha20/Poly1305 AEAD RFC 7748 – X25519 ECDH RFC 5869 – HKDF-SHA256 ","description":"安全且半可靠的 UDP 传输协议第2版","id":"b45756033b706b68daaee09f536f3c91","section":"docs","title":"SSU2 规范","url":"/zh/docs/specs/ssu2/"},{"categories":null,"content":" 范围： 本指南汇总了 tunnel 的实现、消息格式，以及两种 tunnel 创建规范（ECIES 和旧版 ElGamal）。现有深链接可继续通过上述别名使用。\nTunnel 模型 I2P 通过单向的 tunnel转发有效载荷：由有序的 routers 组成，只在单一方向传输流量。两个目的地之间的一次完整往返需要四条 tunnel（两条出站、两条入站）。\n先阅读 Tunnel Overview 以了解术语，然后使用本指南获取操作细节。\n消息生命周期 tunnel 网关 将一个或多个 I2NP 消息打包，对其进行分片，并写入投递指令。 该网关将负载封装为固定大小 (1024 B) 的 tunnel 消息，必要时进行填充。 每个参与者 验证前一跳，施加其加密层，并将 {nextTunnelId, nextIV, encryptedPayload} 转发到下一跳。 tunnel 端点 移除最后一层，处理投递指令，重新组装分片，并分发重建后的 I2NP 消息。 重复检测使用一种以 IV（初始向量）与第一个密文分组的异或值作为键的衰减布隆过滤器，以阻止基于 IV 交换的标记攻击。\n角色概览 Role Pre-processing Crypto Operation Post-processing Outbound gateway (creator) Fragment, batch, pad Iteratively decrypt using every hop’s keys (so downstream peers encrypt) Forward to first hop Participant — Encrypt IV and payload with hop keys Forward to next hop Outbound endpoint — Encrypt once more to reveal plaintext payload Deliver to target tunnel/destination Inbound gateway Fragment, batch, pad Encrypt with local keys Forward to next hop Inbound endpoint (creator) — Iteratively decrypt using stored hop keys Reassemble and deliver locally ### 加密工作流程 {#encryption-workflow} 入站 tunnels: 网关使用其层密钥加密一次；下游参与者继续加密，直到创建者解密最终有效载荷。 出站 tunnels: 网关预先应用每一跳加密的逆运算，使得每个参与者都进行加密。当端点完成加密时，网关的原始明文被还原。 两个方向都将 {tunnelId, IV, encryptedPayload} 转发到下一跳。\nTunnel 消息格式 Tunnel 网关将 I2NP 消息分片为固定大小的封包，以隐藏有效负载长度并简化逐跳处理。\n加密布局 +----------------+----------------+-------------------+ | Tunnel ID (4B) | IV (16B) | Encrypted payload | +----------------+----------------+-------------------+ Tunnel ID – 用于下一跳的 32 位标识符（非零，每个构建周期轮换）。 IV – 每条消息选择的 16 字节 AES IV。 加密有效负载 – 1008 字节的 AES-256-CBC 密文。 总大小：1028 字节。\n解密后的布局 当某个跳点移除了其加密层之后：\n[Checksum (4B)][Padding ... 0x00 terminator] [Delivery Instructions 1][I2NP fragment 1] [Delivery Instructions 2][I2NP fragment 2] ... 校验和用于验证解密后的数据块。 填充是由随机的非零字节组成，并以一个零字节结束。 传递指令告知端点如何处理每个分片（本地递送、转发到另一个 tunnel 等）。 分片承载底层的 I2NP 消息；端点会在将其传递到更高层之前对其进行重组。 处理步骤 网关对 I2NP 消息进行分片并排队，短暂保留未完整的片段以便重组。 网关使用相应的层密钥对载荷加密，并设置 tunnel ID 以及 IV（初始化向量）。 每个参与者先加密 IV（AES-256/ECB），再加密载荷（AES-256/CBC），随后再次加密 IV 并转发消息。 端点按相反顺序解密，验证校验和，执行投递指令，并重组这些片段。 Tunnel 建立 (ECIES-X25519，椭圆曲线集成加密方案，基于 X25519) 现代的 routers 使用 ECIES-X25519 密钥来构建 tunnels，从而缩小构建消息的大小并实现前向保密。\n构建消息： 单个 TunnelBuild（或 VariableTunnelBuild）I2NP 消息承载 1–8 条加密的构建记录，每一跳一条。 层密钥： 创建者使用该跳的静态 X25519（椭圆曲线密钥交换算法）身份以及创建者的临时密钥，通过 HKDF（基于HMAC的密钥派生函数）导出每跳的层密钥、IV（初始化向量）和回复密钥。 处理： 每一跳解密其记录，验证请求标志，写入回复块（成功或详细失败代码），重新加密其余记录，并转发该消息。 回复： 创建者会接收到一个使用 garlic encryption 封装的回复消息。标记为失败的记录包含一个严重性代码，以便 router 能够为该对等体建立画像。 兼容性： 为了向后兼容，router 仍可接受传统的 ElGamal（公钥加密算法）构建，但新的 tunnel 默认使用 ECIES（椭圆曲线集成加密方案）。 关于逐字段的常量和密钥派生说明，请参见 ECIES（椭圆曲线集成加密方案）提案历史和 router 源码；本指南涵盖操作流程。\n旧版 Tunnel 创建 (ElGamal-2048) 最初的 tunnel 构建格式使用了 ElGamal 公钥。现代的 routers 仅保留有限的向后兼容支持。\n状态： 已过时。为历史参考而保留于此，并供维护与遗留版本兼容的工具的人员使用。\nNon-interactive telescoping（非交互式逐段伸展）: 单个构建消息贯穿整个路径。每一跳解密其 528 字节的记录，更新消息并将其转发。 可变长度: 可变 Tunnel 构建消息（VTBM）允许包含 1–8 条记录。早期的固定消息始终包含八条记录，以混淆 tunnel 的长度。 请求记录布局: Bytes 0–3 : Tunnel ID (receiving ID) Bytes 4–35 : Current hop router hash Bytes 36–39 : Next tunnel ID Bytes 40–71 : Next hop router hash Bytes 72–103 : AES-256 layer key Bytes 104–135: AES-256 IV key Bytes 136–167: AES-256 reply key Bytes 168–183: AES-256 reply IV Byte 184 : Flags (bit7=IBGW, bit6=OBEP) Bytes 185–188: Request time (hours since epoch) Bytes 189–192: Next message ID Bytes 193–221: Padding 标志： 第7位表示入站网关（IBGW）；第6位表示出站端点（OBEP）。二者互斥。 加密： 每条记录使用该跳点的公钥进行 ElGamal-2048（ElGamal 2048位公钥加密算法）加密。对称的 AES-256-CBC（AES 256位CBC模式）分层确保只有预定的跳点能够读取其记录。 要点： tunnel ID 均为非零的 32 位值；创建者可以插入填充记录以隐藏实际的 tunnel 长度；可靠性取决于重试失败的构建。 Tunnel 池和生命周期 router 会为探测流量以及每个 I2CP 会话分别维护独立的入站和出站 tunnel 池。\n节点选择: 探索型 tunnels 从“active, not failing”的节点桶中选取以提升多样性; 客户端 tunnels 更偏好快速、高容量的节点。 确定性排序: 节点按 SHA256(peerHash || poolKey) 与该池随机密钥之间的 XOR 距离（按位异或距离）进行排序。该密钥在重启时轮换, 既保证单次运行内的稳定性, 又在跨运行时抑制前驱攻击。 生命周期: routers 按 {mode, direction, length, variance} 元组跟踪历史构建时间。随着 tunnels 接近到期, 会提前启动替换; 在发生失败时, router 会增加并行构建数量, 同时对未完成的尝试设定上限。 配置可调项: 活动/备份 tunnel 数量、跳数及其方差、零跳许可以及构建速率限制, 均可按池进行调节。 拥塞与可靠性 尽管 tunnels 类似于电路，routers 将它们视为消息队列。为了将时延保持在可控范围内，会使用加权随机早期丢弃（WRED）：\n当利用率接近配置的上限时，丢弃概率会上升。 参与方按固定大小的片段进行计算；网关/端点会根据片段的合计大小决定丢弃，优先丢弃大型有效负载。 出站端点会先于其他角色执行丢弃，以尽可能减少网络资源消耗。 保证交付留给更高层（例如 Streaming library ）。需要可靠性的应用必须自行处理重传和确认。\n延伸阅读 节点选择 Tunnel 概述 旧版 Tunnel 实现 ","description":"用于通过 I2P tunnels 构建、加密和传输流量的统一规范。","id":"6fb0b76b8bc10fa3e571b748f502baaa","section":"docs","title":"Tunnel 操作指南","url":"/zh/docs/specs/implementation/"},{"categories":null,"content":"概述 I2P 构建临时的单向 tunnel——由按顺序排列的 router 组成的序列,用于转发加密流量。Tunnel 分为 inbound(消息流向创建者)或 outbound(消息流向远离创建者)两种类型。\n典型的交换过程是这样的：Alice 的消息通过她的一条出站 tunnel 发出，指示出站端点将消息转发到 Bob 的某条入站 tunnel 的网关，然后 Bob 在其入站端点接收消息。\nA: Outbound Gateway（Alice） B: Outbound Participant C: Outbound Endpoint D: Inbound Gateway E: Inbound Participant F: Inbound Endpoint（Bob） 隧道具有固定的 10 分钟生命周期,并传输固定大小的 1024 字节消息(包含隧道头部为 1028 字节),以防止基于消息大小或时间模式的流量分析。\n隧道术语表 Tunnel gateway（隧道网关）： 隧道中的第一个 router。对于入站隧道，该 router 的身份会出现在已发布的 LeaseSet 中。对于出站隧道，gateway 是发起的 router（上文中的 A 和 D）。 Tunnel endpoint（隧道端点）： 隧道中的最后一个 router（上文中的 C 和 F）。 Tunnel participant（隧道参与者）： 隧道中的中间 router（上文中的 B 和 E）。参与者无法确定其位置或隧道方向。 n-hop tunnel（n 跳隧道）： router 之间的跳数。 0-hop： gateway 和 endpoint 是同一个 router——匿名性最低。 1-hop： gateway 直接连接到 endpoint——低延迟,低匿名性。 2-hop： 探索性隧道的默认设置;安全性/性能均衡。 3-hop： 推荐用于需要强匿名性的应用程序。 Tunnel ID（隧道 ID）： 每个 router 和每一跳的 4 字节唯一整数,由创建者随机选择。每一跳接收和转发使用不同的 ID。 隧道构建信息 在隧道构建消息中，充当网关、参与者和端点角色的路由器会收到不同的记录。现代 I2P 支持两种方法：\nElGamal（旧版，528字节记录） ECIES-X25519（当前版本，通过短隧道构建消息 – STBM 实现218字节记录） Information Distributed to Participants 网关接收： - Tunnel 层密钥（根据隧道类型使用 AES-256 或 ChaCha20 密钥） - Tunnel IV 密钥（用于加密初始化向量） - 应答密钥和应答 IV（用于构建应答加密） - Tunnel ID（仅入站网关） - 下一跳身份哈希和 tunnel ID（如果非终端节点）\n中间参与者接收： - 其跃点的 tunnel 层密钥和 IV 密钥 - Tunnel ID 和下一跳信息 - 用于构建响应加密的回复密钥和 IV\n端点接收： - Tunnel 层和 IV 密钥 - 应答 router 和 tunnel ID（仅限出站端点）- 应答密钥和 IV（仅限出站端点）\n详细信息请参阅 Tunnel Creation Specification 和 ECIES Tunnel Creation Specification 。\nTunnel Pooling Router 将 tunnel 分组为 tunnel pool（隧道池），以实现冗余和负载分配。每个池维护多个并行的 tunnel，当一个失败时可以进行故障转移。内部使用的池称为 exploratory tunnel（探索隧道），而特定应用的池称为 client tunnel（客户端隧道）。\n每个目标地址维护独立的入站和出站池，通过 I2CP 选项进行配置（tunnel 数量、备份数量、长度和 QoS 参数）。Router 监控 tunnel 健康状况，运行定期测试，并自动重建失败的 tunnel 以维持池的规模。\n隧道池 0-hop Tunnels（零跳隧道）：仅提供合理推诿性。流量始终在同一个 router 发起和终止——不建议用于任何匿名用途。\n1跳隧道：针对被动观察者提供基本的匿名性,但如果对手控制了那个单跳节点则容易受到攻击。\n2跳隧道：包含两个远程路由器，显著增加攻击成本。探索性隧道池的默认设置。\n3跳隧道（3-hop Tunnels）：推荐用于需要强大匿名保护的应用程序。额外的跳数会增加延迟，但不会带来有意义的安全增益。\n默认设置：路由器使用2跳探索性隧道和针对应用的2或3跳客户端隧道,在性能和匿名性之间取得平衡。\n隧道长度 Router 会定期通过出站 tunnel 向入站 tunnel 发送 DeliveryStatusMessage 来测试 tunnel。如果测试失败,两条 tunnel 都会收到负面的配置文件权重。连续失败会将 tunnel 标记为不可用;然后 router 会重建一个替代 tunnel 并发布新的 LeaseSet。测试结果会反馈到对等节点容量指标中,供对等节点选择系统 使用。\n隧道测试 Routers 使用非交互式的伸缩式方法构建 tunnels：单个 Tunnel Build Message 逐跳传播。每一跳解密其记录，添加其回复，并转发消息。最后一跳通过不同的路径返回聚合的构建回复，防止关联。现代实现对 ECIES 使用 Short Tunnel Build Messages (STBM)，对传统路径使用 Variable Tunnel Build Messages (VTBM)。每条记录使用 ElGamal 或 ECIES-X25519 进行逐跳加密。\n隧道创建 隧道流量使用多层加密。当消息穿过隧道时,每一跳都会添加或移除一层加密。\nElGamal tunnels: 使用 AES-256/CBC 加密载荷,采用 PKCS#5 填充。 ECIES tunnels: 使用 ChaCha20 或 ChaCha20-Poly1305 进行认证加密。 每个跳点有两个密钥：层密钥和 IV 密钥。路由器解密 IV，使用它来处理有效载荷,然后在转发之前重新加密 IV。这种双重 IV 方案可以防止消息标记。\n出站网关预先解密所有层，使得端点在所有参与者添加加密后接收明文。入站 tunnel 以相反方向加密。参与者无法确定 tunnel 方向或长度。\n隧道加密 动态隧道生命周期和自适应池大小调整以实现网络负载均衡 备用 tunnel 测试策略和单个跳点诊断 可选的工作量证明或带宽证书验证(在 API 0.9.65+ 中实现) 流量整形和填充数据插入研究以实现端点混合 持续淘汰 ElGamal 并迁移到 ECIES-X25519 持续开发 Tunnel 实现规范 Tunnel 创建规范 (ElGamal) Tunnel 创建规范 (ECIES-X25519) Tunnel 消息规范 Garlic 路由 I2P 网络数据库 节点评估与选择 I2P 威胁模型 ElGamal/AES + SessionTag 加密 I2CP 选项 ","description":"I2P tunnel 术语、构建和生命周期概述","id":"d2bb4d16ccaaecd4bfaae8d5b1356800","section":"docs","title":"Tunnel 路由","url":"/zh/docs/overview/tunnel-routing/"},{"categories":null,"content":" 注意： 此归档收录了早于 I2P 0.9.41 的探索性设计工作。有关生产级实现，请参阅 tunnel 文档 。\n替代的配置方案 针对未来的 tunnel 可调参数，所考虑的想法包括：\n用于消息投递的频率限流机制 填充策略（包括 chaff injection（诱饵流量注入）） Tunnel 生命周期控制 用于有效载荷分发的批处理与队列策略 这些选项未随遗留实现提供。\n填充策略 已讨论的潜在填充方案：\n不进行任何填充 随机长度填充 固定长度填充 填充到最接近的千字节 填充到 2 的幂（2^n 字节） 早期的测量（0.4 版本）促成了当前固定的 1024 字节 tunnel 消息大小。更高层的 garlic 消息（I2P 中将多个消息打包在一起的消息格式）可能会添加其自身的填充。\n分片 为防止通过消息长度进行的标记攻击，tunnel 消息固定为 1024 字节。更大的 I2NP 负载会由网关分片；端点会在短暂的超时时间内重组这些分片。router 可能会在发送前重新排列分片，以最大化填充效率。\n其他替代方案 中途调整 Tunnel 处理 考察了三种可能性：\n允许中间跳点通过授予其对解密后有效载荷的访问权限，临时终止一个 tunnel。 允许参与的 routers 在继续转发到下一跳之前，先将消息通过其自身的一条出站 tunnel 发送，以对消息进行“重混”。 使 tunnel 的创建者能够动态地重新定义某个对等方的下一跳。 双向 Tunnels 使用彼此独立的入站和出站 tunnels 可以限制任何单一组对等节点所能观测到的信息（例如，GET 请求与大型响应）。双向 tunnels 简化了对等节点管理，但会同时向两个方向暴露完整的流量模式。因此，单向 tunnels 仍是首选的设计。\n反向通道与可变大小 允许可变的 tunnel 消息大小会使串通的对等节点之间能够建立隐蔽信道（例如，通过选定的大小或频率来编码数据）。固定大小的消息可以缓解这一风险，但代价是增加额外的填充开销。\nTunnel 构建的替代方案 参考：Hashing it out in Public 遗留“并行”构建方法 在 0.6.1.10 发布之前，tunnel 构建请求会并行发送给每个参与者。该方法记录在旧版 tunnel 页面 上。\n一次性伸缩式构建（当前方法） 现代方法是通过部分构建的 tunnel 逐跳发送构建消息。尽管这与 Tor 的 telescoping（逐段扩展）相似，但通过探索型 tunnels 路由构建消息可以减少信息泄露。\n“交互式” 伸缩法 以显式的往返通信逐跳构建，会使对等节点能够统计消息数量并推断其在 tunnel 中的位置，因此这种方法被拒绝。\n非探索型管理 Tunnels 有一项提议是为构建流量维护一组单独的管理用 tunnels 池。尽管这可能有助于处于分区状态的 routers，但在网络整合充分的情况下，被认为没有必要。\n探索性投递（旧版） 在 0.6.1.10 之前，单个 tunnel 请求会使用 garlic encryption 加密，并通过 exploratory tunnels 发送，回复则单独返回。该策略已被当前的 one-shot telescoping 方法（一次性逐段扩展的方法）所取代。\n要点 固定大小的 tunnel 消息可防范基于大小的标记与隐蔽信道，尽管这会增加填充开销。 曾探索过替代性的填充、分片与构建策略，但在权衡匿名性取舍后未予采用。 Tunnel 设计继续在效率、可观测性与对前驱攻击和拥塞攻击的抗性之间进行权衡。 ","description":"对 tunnel 填充、分片和构建策略的历史性探讨","id":"e5773155afe129d73b1384e5c116ec56","section":"docs","title":"Tunnel 讨论","url":"/zh/docs/legacy/tunnel/"},{"categories":null,"content":"概述 本规范记录了 I2P 中用于 UDP BitTorrent announce（向跟踪器的通告/查询）的协议。有关 I2P 中 BitTorrent 的整体规范，请参见 I2P 上的 BitTorrent 文档 。有关本规范制定的背景和更多信息，请参见 提案 160 。\n该协议已于 2025 年 6 月 24 日正式批准，并在 I2P 2.10.0 版本（API 0.9.67）中实现，发布于 2025 年 9 月 8 日。I2P 网络目前已启用对 UDP 跟踪器的支持，已有多个生产环境的跟踪器，并提供对 i2psnark 客户端的完整支持。\n设计 本规范使用 repliable datagram2、repliable datagram3，以及 raw datagrams（原始数据报），其定义见I2P 数据报规范 。Datagram2 和 Datagram3 是 repliable datagrams（可回复数据报）的变体，定义见提案 163 。Datagram2 增加了抗重放能力和对离线签名的支持。Datagram3 比旧的数据报格式更小，但不提供认证。\nBEP 15 供参考，BEP 15 中定义的消息流程如下：\nClient Tracker Connect Req. -------------\u0026gt; \u0026lt;-------------- Connect Resp. Announce Req. -------------\u0026gt; \u0026lt;-------------- Announce Resp. Announce Req. -------------\u0026gt; \u0026lt;-------------- Announce Resp. 连接阶段是为防止 IP 地址欺骗所必需的。tracker（追踪器）会返回一个连接 ID，客户端会在后续的 announce 请求中使用它。该连接 ID 在客户端默认 1 分钟后过期，而在 tracker 端为 2 分钟。\nI2P 采用与 BEP 15 相同的消息流，这样做是为了便于现有具备 UDP 能力的客户端代码库采用、提高效率，以及出于下文将讨论的安全性考虑：\nClient Tracker Connect Req. -------------\u0026gt; (Repliable Datagram2) \u0026lt;-------------- Connect Resp. (Raw) Announce Req. -------------\u0026gt; (Repliable Datagram3) \u0026lt;-------------- Announce Resp. (Raw) Announce Req. -------------\u0026gt; (Repliable Datagram3) \u0026lt;-------------- Announce Resp. (Raw) ... 这相较于通过流式（TCP）的通告，潜在地可带来显著的带宽节省。虽然 Datagram2（数据报类型 2）的大小与一个流式 SYN 大致相当，但其原始响应要比流式的 SYN ACK 小得多。后续请求使用 Datagram3（数据报类型 3），而后续响应为原始。\nannounce 请求使用 Datagram3（I2P 的第3版数据报协议），因此跟踪器无需维护一个将连接ID映射到 announce 目的地或哈希的大型映射表。相反，跟踪器可以基于发送者哈希、当前时间戳（以某个时间间隔为基准）以及一个秘密值，以密码学方式生成连接ID。当收到 announce 请求时，跟踪器会验证该连接ID，然后将 Datagram3 的发送者哈希作为发送目标。\n连接生命周期 BEP 15 规定：在客户端侧，连接 ID 的有效期为一分钟；在追踪器侧为两分钟。该设置不可配置。除非客户端将 announce（向追踪器的通告请求）进行批处理，在一分钟的时间窗口内全部完成，否则这会限制潜在的效率提升。i2psnark 目前不会批量发送 announce；为避免流量突发，它会将它们分散开来。据报道，资深用户会同时运行上千个种子，将如此多的 announce 在一分钟内集中发送并不现实。\n在此，我们建议对连接响应进行扩展，添加一个可选的连接生存期字段。默认情况下（若未提供），为一分钟。否则，客户端将使用以秒为单位指定的生存期，而跟踪器会将该连接 ID 额外保留一分钟。\n与 BEP 15 的兼容性 该设计尽可能保持与 BEP 15 的兼容性，以尽量减少对现有客户端和跟踪器所需的更改。\n唯一必需的更改是 announce 响应中对等节点信息的格式。connect 响应中添加 lifetime 字段并非必需，但如上所述，出于效率考虑，强烈建议这样做。\n安全性分析 UDP 通告协议的一个重要目标是防止地址伪造。客户端必须真实存在，并携带一个真实的 leaseSet。它必须具有入站 tunnel，才能接收连接响应（Connect Response）。这些 tunnel 可以是 zero-hop（零跳）并可即时建立，但那会暴露创建者。该协议实现了这一目标。\n问题 该协议尚不支持 blinded destinations（盲化目的地），但可以通过扩展来实现。详见下文。\n规范 协议与端口 可回复的 Datagram2 使用 I2CP 协议 19；可回复的 Datagram3 使用 I2CP 协议 20；原始数据报使用 I2CP 协议 18。请求可以是 Datagram2 或 Datagram3。响应始终为原始数据报。较旧的可回复数据报（“Datagram1”）格式使用 I2CP 协议 17，绝不能用于请求或回复；如果在请求/回复端口上收到，必须予以丢弃。注意：Datagram1 的 I2CP 协议 17 仍用于 DHT（分布式哈希表）协议。\n请求使用来自 announce URL 的 I2CP \u0026ldquo;to port\u0026rdquo;；见下文。请求的 \u0026ldquo;from port\u0026rdquo; 由客户端选择，但应为非零，并且与 DHT（分布式哈希表）使用的端口不同，以便可轻松对响应进行分类。Tracker 应拒绝在错误端口收到的请求。\n响应会使用请求中的 I2CP \u0026ldquo;to port\u0026rdquo;（目标端口）。响应的 \u0026ldquo;from port\u0026rdquo;（源端口）是该请求的 \u0026ldquo;to port\u0026rdquo;。\n通告 URL announce URL（Tracker 公告 URL）格式未在 BEP 15 中规定，但与明网一样，UDP announce URLs 的形式为 \u0026ldquo;udp://host:port/path\u0026rdquo;。路径会被忽略，可以为空，但在明网上通常为 \u0026ldquo;/announce\u0026rdquo;。:port 部分应当始终存在；不过，如果省略了\u0026quot;:port\u0026quot;部分，则使用默认的 I2CP 端口 6969，因为那是明网上常用的端口。也可能附加 CGI 参数 \u0026amp;a=b\u0026amp;c=d；这些参数可以被处理并包含在 announce 请求中，参见 BEP 41 。如果没有参数或路径，结尾的 / 也可以省略，BEP 41 中亦有此意。\n数据报格式 所有数值均按网络字节序（大端序）发送。不要指望数据包的大小恰好等于某个固定值。未来的扩展可能会增大数据包的大小。\n连接请求 客户端发往 tracker。16 字节。必须为可回复的 Datagram2（I2P 数据报第2版）。与 BEP 15 相同。无更改。\nOffset Size Name Value 0 64-bit integer protocol_id 0x41727101980 // magic constant 8 32-bit integer action 0 // connect 12 32-bit integer transaction_id 连接响应 Tracker 到客户端。16 或 18 字节。必须为原始数据。与 BEP 15 中相同，除非下文另有说明。\nOffset Size Name Value 0 32-bit integer action 0 // connect 4 32-bit integer transaction_id 8 64-bit integer connection_id 16 16-bit integer lifetime optional // Change from BEP 15 响应必须发送到 I2CP \u0026ldquo;to port\u0026rdquo;（目标端口），该端口为请求中接收到的 \u0026ldquo;from port\u0026rdquo;（来源端口）。\nlifetime 字段是可选的，用于指示客户端的 connection_id 生命周期（单位为秒）。默认值为 60；如果指定，最小值也是 60。最大值为 65535（约 18 小时）。追踪器应将 connection_id 的维持时间设定为比客户端生命周期多 60 秒。\n通告请求 客户端到追踪器。至少 98 字节。必须为可回复的 Datagram3（I2P 的第三版数据报格式）。除下文另有说明外，与 BEP 15 相同。\nconnection_id 为在 connect response 中接收到的值。\nOffset Size Name Value 0 64-bit integer connection_id 8 32-bit integer action 1 // announce 12 32-bit integer transaction_id 16 20-byte string info_hash 36 20-byte string peer_id 56 64-bit integer downloaded 64 64-bit integer left 72 64-bit integer uploaded 80 32-bit integer event 0 // 0: none; 1: completed; 2: started; 3: stopped 84 32-bit integer IP address 0 // default, unused in I2P 88 32-bit integer key 92 32-bit integer num_want -1 // default 96 16-bit integer port // must be same as I2CP from port 98 varies options optional // As specified in BEP 41 相对于 BEP 15 的更改:\nkey 被忽略 IP 地址未使用 端口可能会被忽略，但必须与 I2CP from port 相同 如果存在，选项部分按 BEP 41 的定义 必须将响应发送到 I2CP 的 \u0026ldquo;to port\u0026rdquo;，该端口是作为请求的 \u0026ldquo;from port\u0026rdquo; 收到的。不要使用 announce request 中的端口。\n通告响应 从跟踪器到客户端。至少 20 字节。必须为原始数据。除下文注明的差异外，与 BEP 15 中相同。\nOffset Size Name Value 0 32-bit integer action 1 // announce 4 32-bit integer transaction_id 8 32-bit integer interval 12 32-bit integer leechers 16 32-bit integer seeders 20 32 * n 32-byte hash binary hashes // Change from BEP 15 ... // Change from BEP 15 与 BEP 15 相比的更改：\n我们不使用 6 字节的 IPv4+port 或 18 字节的 IPv6+port，而是返回若干个 32 字节的 \u0026ldquo;compact responses\u0026rdquo;（紧凑响应），其中包含 SHA-256 二进制对等节点哈希值。与 TCP compact responses 类似，我们不包含端口号。 响应必须发送到 I2CP 的 \u0026ldquo;to port\u0026rdquo;，其值等于该请求的 \u0026ldquo;from port\u0026rdquo;。不要使用 announce 请求（公告请求）中的端口。\nI2P 数据报的最大尺寸约为 64 KB；然而，若需可靠传输，应避免使用超过 4 KB 的数据报。为提高带宽效率，跟踪器应将最大对等节点数限制在约 50，这对应于在各层开销之前约 1600 字节的数据包，并且在分片后应能控制在两条 tunnel 消息的有效载荷上限之内。\n与 BEP 15（BitTorrent 增强提案第 15 号）一样，不包含后续对等节点地址数量的计数（BEP 15 中为 IP/端口，此处为哈希）。尽管 BEP 15 未考虑这一点，但可以定义一个全零的对等节点结束标记，以指示对等节点信息已完整，随后将跟随一些扩展数据。\n为了将来能够进行这种扩展，客户端应忽略一个 32 字节的全零哈希以及其后的任何数据。追踪器应当拒绝来自全零哈希的 announce 请求，尽管该哈希已被 Java routers 禁止。\n抓取 来自 BEP 15 的 scrape 请求/响应并非本规范所必需，但如有需要可以实现，无需任何修改。客户端必须先获取一个 connection ID。scrape 请求一律使用可回复的 Datagram3（I2P 的第3版数据报格式）。scrape 响应一律为 raw（原始数据报）。\n错误响应 从 Tracker 到客户端。最少 8 字节（当消息为空时）。必须是原始格式。与 BEP 15 中相同。无更改。\nOffset Size Name Value 0 32-bit integer action 3 // error 4 32-bit integer transaction_id 8 string message 扩展 不包含扩展位或版本字段。客户端和跟踪器不应假定数据包具有某个固定大小。这样，就可以在不破坏兼容性的情况下添加额外字段。如有需要，建议使用 BEP 41 中定义的扩展格式。\n连接响应已被修改，新增可选的连接ID有效期。\n如果需要支持 blinded destination（对目标地址进行盲化的机制），我们可以选择：要么在 announce 请求的末尾附加 blinded 的 35 字节地址，要么在响应中请求以 BEP 41 格式（参数待定）返回 blinded 哈希。可以在一个全零的 32 字节哈希之后，将一组 blinded 的 35 字节 peer 地址添加到 announce 应答的末尾。\n实现指南 有关未集成、非 I2CP 客户端和跟踪器所面临挑战的讨论，请参阅上面的设计部分。\n客户端 对于给定的跟踪器主机名，客户端应优先使用 UDP 而不是 HTTP URL，并且不应同时向两者发送 announce 请求（向跟踪器通告自身状态的请求）。\n已经支持 BEP 15（BitTorrent 增强提案第 15 号）的客户端应只需进行少量修改。\n如果客户端支持 DHT（分布式哈希表）或其他数据报协议，最好为请求选择一个不同的 \u0026ldquo;from port\u0026rdquo;（源端口），以便回复回到该端口，并且不会与 DHT 消息混淆。客户端只会以原始数据报的形式接收回复。跟踪器永远不会向客户端发送可回复的 datagram2。\n具有默认开放追踪器列表的客户端，应在确认哪些已知开放追踪器支持 UDP 之后，更新该列表以添加 UDP URL。\n客户端可以选择是否实现请求的重传。若实现了重传，初始超时时间应至少为 15 秒，并在每次重传时将超时时间加倍（指数退避）。\n客户端在收到错误响应后必须退避。\n追踪器 已支持 BEP 15（BitTorrent 增强提案 15）的跟踪器只需要进行少量修改。本规范与 2014 年的提案不同之处在于：跟踪器必须在同一端口上支持接收可回复的 datagram2（第二版数据报）和 datagram3（第三版数据报）。\n为将跟踪器的资源需求降到最低，本协议旨在消除对跟踪器的任何要求，即为后续验证而存储客户端哈希与连接ID之间的映射关系。之所以可行，是因为 announce 请求数据包是可回复的 Datagram3（数据报协议第3版）数据包，因此其中包含发送方的哈希。\n推荐的实现是：\n将当前 epoch（纪元）定义为以连接生命周期为分辨率的当前时间，epoch = now / lifetime。 定义一个密码学哈希函数 H(secret, clienthash, epoch)，其生成 8 字节输出。 生成一个用于所有连接的随机常量 secret（秘密值）。 对于连接响应，生成 connection_id = H(secret, clienthash, epoch)。 对于公告请求，在当前 epoch 中通过验证 connection_id == H(secret, clienthash, epoch) || connection_id == H(secret, clienthash, epoch - 1) 来校验接收到的连接ID。 部署状态 该协议已于2025年6月24日获批准，并自2025年9月起在 I2P 网络上全面投入运行。\n当前实现 i2psnark: I2P 2.10.0 版本（API 0.9.67）包含对 UDP tracker（UDP 追踪器）的完整支持，发布于 2025 年 9 月 8 日。自该版本起，所有 I2P 安装默认包含 UDP tracker 功能。\nzzzot tracker: 0.20.0-beta2 及更高版本支持 UDP announce（通过 UDP 向跟踪器汇报的请求）。截至 2025 年 10 月，以下生产环境的跟踪器正在运行: - opentracker.dg2.i2p - opentracker.simp.i2p - opentracker.skank.i2p\n客户端兼容性说明 SAM v3.3 限制：使用 SAM（Simple Anonymous Messaging）的外部 BitTorrent 客户端需要 SAM v3.3 对 Datagram2/3（SAM 协议中的第二/第三代无连接数据报扩展）的支持。Java I2P 已提供该支持，但 i2pd（C++ 的 I2P 实现）目前尚不支持，这可能会限制其在基于 libtorrent 的客户端（如 qBittorrent）中的采用。\nI2CP 客户端: 直接使用 I2CP 的客户端（例如 BiglyBT）可以在不受 SAM 限制的情况下实现对 UDP 追踪器的支持。\n参考资料 [BEP15]: BitTorrent UDP 跟踪器协议 [BEP41]: UDP 跟踪器协议扩展 [DATAGRAMS]: I2P 数据报规范 [Prop160]: UDP 跟踪器提案 [Prop163]: Datagram2 提案 [SPEC]: I2P 上的 BitTorrent ","description":"I2P 中的基于 UDP 的 BitTorrent 跟踪器 announce（上报请求）协议规范","id":"2413d642663e185a8a31352c9a9e8f28","section":"docs","title":"UDP BitTorrent 通告请求","url":"/zh/docs/specs/udp-bittorrent-announces/"},{"categories":null,"content":" 状态：这是 v3dgsend 工具的简明参考。它是对 数据报 API 和 SAM v3 文档的补充。\n概述 v3dgsend 是一个命令行辅助工具,用于通过 SAM v3 接口发送 I2P 数据报。它适用于测试数据报传递、服务原型设计,以及在无需编写完整客户端的情况下验证端到端行为。\n典型用途包括：\n对目标地址进行数据报可达性冒烟测试 验证防火墙和地址簿配置 试验原始数据报与签名（可回复）数据报 使用方法 基本调用方式因平台和打包方式而异。常见选项包括：\nDestination: base64 Destination 或 .i2p 名称 Protocol: raw (PROTOCOL 18) 或 signed (PROTOCOL 17) Payload: 内联字符串或文件输入 请参考您的发行版包管理或 --help 输出以获取确切的标志。\n另请参阅 Datagram API SAM v3 Streaming Library (datagram 的替代方案) ","description":"用于通过 SAM v3 发送 I2P 数据报的命令行工具","id":"3fe6f64806c4c692f530bf7fa6eb9c45","section":"docs","title":"v3dgsend","url":"/zh/docs/api/v3dgsend/"},{"categories":null,"content":"安全联系方式 如需报告安全漏洞或敏感的安全问题，请通过 security@i2p.net 联系 I2P 安全团队\n如需安全通信，请使用下方我们的 PGP 密钥。\nPGP 密钥信息 Email: security@i2p.net Key ID: 176E1941 Fingerprint: 40DF FE20 7D79 9BEC 3AE8 7DEA 5F98 BE91 176E 1941 Key Type: RSA 4096-bit 创建时间: 2025-10-19 过期时间: 2030-11-19 UID: I2P Security \u0026lt;security@i2p.net\u0026gt; 公钥 以下是 I2P 安全团队的 GPG 公钥： \u0026mdash;\u0026ndash;BEGIN PGP PUBLIC KEY BLOCK\u0026mdash;\u0026ndash;\nmQINBGj1TtUBEADKsCC54egdJgxMs4HWcsYlr4GbrevM5gjZ+QZYEDGjaz44duOc E9W+a/NNA8PsryCql893odYdqGrFX+WTUT3UuN7DbbS7qSDs7jWZzjj0lr4/pbzJ B28lC0aIx6SQTEbzsGr2hOlFq/+JD9x/fMFrHFX81cJdIz9yabcH1vg9wPuhwkUS 5v2GFtvODCmSxQEJHSWvL2PkGiYEEZMKVXF5msdqJZK5/Dwp3UgVNeAkUYEHU6px Vu/YUpGo07/LNW5FfGDGf0pWYQ/9Tu5ykno3q3EA7TwWoVwbDK0hh9mpbZYiWSoy PSbIWNpwVMwGri4+KFjCEyG8DLzDlM4UMrK3PnrPh4M4+4a+flR+CMNeM1lyioC3 +jJf3TEOjvUsMzbwoDEE6O0wxBtfFC0xzzDDCAVrPvEZ3lt0do3kVHLbYS6ZXHkX ZwZWNBDWr2mSG9GU4oWizPIlq7MIhRYKA+ADqNxznxm9rtdfidk1tcLdyNUDjOwC jk/vQ8PCORbUYfytMhHzlRk7zieK6wBwr3aFFVgE8HxhgIZkAaUEbeej+dNADo6Z IFY+OF8mjpErcfJscCNgPSDbNid87dA78qRrqL6HLU2sek9g72EFpx2OVV7drkEp +Zy9kuiML4wWfOpC+kQa1Ka66E520U8Hs++cpf1LUOUmn1ajQDSfGoJMMwARAQAB tB9JMlAgU2VjdXJpdHkgPHNlY3VyaXR5QGkycC5uZXQ+iQJXBBMBCABBFiEEQN/+ IH15m+w66H3qX5i+kRduGUEFAmj1TtUCGwMFCQmQP4EFCwkIBwICIgIGFQoJCAsC BBYCAwECHgMCF4AACgkQX5i+kRduGUEEJhAAuZECNIWnC2UbrW/AXF8nPvFjpvLe kK7VQmMgno6iHRB1HAMh5hk3ZOYSRcjghcOHRpMFT64Uuc5vc9eBoegi5TDxYDkF Y9/ciEG5j2TXk93R/rY14UiH/kjFIhBAmc2t6Fs9R1m1vHHJtgY+KLqRF9fh2hc9 43odXnCrn5nhONtW+nb086eJEnJ4vsG/yR4EGzbu+fbrMJlycA/gZS63Q0rIcEJ2 VbZPCEXAf8LmebwxPxlboEuhXJSjCt1gWZwoKZlELaWdHliL3fUrMd3ojM5y66q3 ClO+7nWuwzKxKtZGKzxvF78o0O+HR4BbC16oQGpkT0yAij7ps/3KD2FJVQ/GQLef mpNQABfdVCPgcDS1p9/hjUoVHlRSC4gyehKX/C+H8Qvem92tzmJZy8PvcXaCsK/u wRxRwkoGhv0H5rsMOxfnB06dvT1Mo+KHED5j4y8C5DOnNpzHqwxJh1nQlJvLUvh8 LWIxiiE4+CeQ5V5YH7KfJmGq5ho93GgFmOXJvAuoFCoOLwXbQt9rMpq8iXM1RHRG E1AbB+KA3zcvAdzbgPtXlrOMkIfYO9xCyc8M0sfHB8b4RgrUs2tFz1fw3g4yE7ax 5ljquRefDmqBjtvu15FcZ4CA+I8FyVnrEb9jDTXyW7DiyM2kB7ZFeLpYytShbPq3 oJQMJYaGMoxDk025Ag0EaPVO1QEQAOuZtLOlab2EnuR5St05MXBpwtQUSWJzRckf w3NpnOl55+BavqsPl63rZYiO2lH9rAkZvfcL7auddQZSjDdsuPbUpsrQgsi2P9ig a3QiJOwSZzJ1qNb4VZSXrq2AqkBhCdw9rjpXGFfPNlClgVRbWpsGaQ5KtflnOA+I RfymidNXH0mDROBQuRh+2lkEYfANshjFjIqbI05tDic0KOab46R5MRVF7cihaMWp qPdxeYmvFWZ9lAnx5lMGwDdnGgfWFkU57lAd3NuHUnYIr/ExB/YgMdDeie5lQHKu svbcws9tIucUME9n8lGY77+1HlmNOCU4V12i4ZURJ4TwjHpScMOovkumtO4nXGRq GS8j1zeG7V9+yvdkSrclHJC33Mu6SPFC5SJBqU1G39/VpTD6CZPSPowZ0RlH2AVh D77Snrn53R3gziv5uxq+LpSJoafAx5tgIrg7HB+iJYRB1YVwIIHoT4YrBF01YyH6 cclkf3TNBjKgmtsynVw/TGy56nvR5lmt2uMq0Wwl4ZEwYPp+8ZmFuLbEHsI9RSdD iAdHoK9pEsTSxvzpcDTcG0CLZ4By/4oIKra6KuLr7XcB5eBmgXxrFBw4kveNWGW0 iEdg0xUVp8dxNjdZucB8m9qXQUUSmUxVjFYu4ee8tpo8iEVzu4wm4kOiOBKlwCn2 nOI72oGxABEBAAGJAjwEGAEIACYWIQRA3/4gfXmb7DrofepfmL6RF24ZQQUCaPVO 1QIbDAUJCZA/gQAKCRBfmL6RF24ZQShLD/9BlA+nLmJvwL3FYXm8JOqN07gPKlyQ +gWdV8p22Gawoq6dJLJanWURjn5Kfy30x2CSX6QwiaQG5aHHudNBF2h4Z/qEMcO5 ml5Dq7BP9R5VKmG4vwrL5ccNwuey1/d9Rtjt1zsd+52+x6dfjFv95o9j8jviIEoS HhhbO9ujmx3QLRNlg0SkG6ZlTALGp3EcKNdrV1vpF6ccgt3pdWYFB62N7q8zObHf bfOFMITJIXJJVKICCxzw3xOW2fMashjqf4Ic2UTFsAG3Hqqf5ASGbu4TyjFS3VXV JSzvdhGnxb7qJUzBImK9mGPRXYSV5d4g7kCFfgUg6KSFxbfYreEjCZXWJyqCr/VB eLpIhUWce/AiDPD8lGVD6sNevsNw4HhO6IyQu0pqbRAo+fJZNi+wcqOUqYlMczNw tUKw73QmFj0IqvyBr8Rfq9JC9O6ipyzalwK8uO0gmqOiK79zfnNIJaZ1+LM3Gh6n 3yluwq1df40lEU171i70IbSON6ekGNLTrvhTlDg6vHCMRfQR2UjA5FYBAtFXqQNG c4IYbu2UQm/191P77oI0vBEh3YnrD9eXtdYxgyT+Lj8RBJ+aM+IykK7c2mgOmlqb vYv+KkVFCpOyXrvSwId+3jHiGP6jis7vuzTwiG0S9EyOjxf9XIDowULuY28ntBB0 hOLK7ID/AeaOxA== =39fn \u0026mdash;\u0026ndash;END PGP PUBLIC KEY BLOCK\u0026mdash;\u0026ndash; ","description":"用于联系 I2P 安全团队的 GPG 公钥","id":"c65864821d13039a727e933e7e6e2891","section":"docs","title":"安全 GPG 密钥","url":"/zh/docs/develop/security-key/"},{"categories":null,"content":"I2P 的插件框架允许您在不修改核心安装的情况下扩展 router 功能。可用的插件涵盖邮件、博客、IRC、存储、wiki、监控工具等。\n**安全提示：**插件以与路由器相同的权限运行。对待第三方下载应与对待任何已签名的软件更新一样——在安装前验证来源。\n1. 安装插件 从项目页面复制插件的下载 URL。\n打开路由器控制台的插件配置页面 。\n将 URL 粘贴到安装字段中,然后点击 Install Plugin。\n路由器会获取已签名的归档文件,验证签名,并立即激活插件。大多数插件会添加控制台链接或后台服务,无需重启路由器。\n2. 为什么插件很重要 为终端用户提供一键分发——无需手动编辑 wrapper.config 或 clients.config 保持核心 i2pupdate.su3 包的精简，同时按需提供大型或小众功能 可选的每插件 JVM 在需要时提供进程隔离 自动检查与路由器版本、Java 运行时和 Jetty 的兼容性 更新机制与路由器一致：签名包和增量下载 支持控制台集成、语言包、UI 主题和非 Java 应用程序（通过脚本） 支持策划的\u0026quot;应用商店\u0026quot;目录，如 plugins.i2p 3. 管理已安装的插件 使用 I2P Router Plugin\u0026rsquo;s 上的控制选项来:\n检查单个插件的更新 一次性检查所有插件（在 router 升级后自动触发） 一键安装所有可用更新\n为注册服务的插件启用/禁用自动启动 干净地卸载插件 4. 构建你自己的插件 查看插件规范 了解打包、签名和元数据要求。 使用 makeplugin.sh 将现有的二进制文件或 Web 应用程序封装成可安装的归档文件。 发布安装和更新 URL,以便 router 能够区分首次安装和增量升级。 在项目页面上醒目地提供校验和与签名密钥,帮助用户验证真实性。 寻找示例?浏览 plugins.i2p 上社区插件的源代码(例如 snowman 示例)。\n5. 已知限制 更新包含纯 JAR 文件的插件可能需要重启路由器,因为 Java 类加载器会缓存类。 控制台可能显示 停止 按钮,即使插件没有活动进程。 在独立 JVM 中启动的插件会在当前工作目录中创建 logs/ 目录。 签名密钥首次出现时会自动受信任;不存在中央签名机构。 Windows 有时在卸载插件后会留下空目录。 在 Java 5 JVM 上安装仅支持 Java 6 的插件会因 Pack200 压缩而报告\u0026quot;插件已损坏\u0026quot;。 主题和翻译插件基本上未经测试。 自动启动标志对于非托管插件并不总是持久保存。 6. 要求与最佳实践 I2P 0.7.12 及更新版本支持插件功能。 保持路由器和插件更新以获取安全修复。 提供简明的版本说明，让用户了解版本之间的变化。 尽可能在 I2P 内通过 HTTPS 托管插件存档，以最小化明网元数据暴露。 7. 延伸阅读 插件规范 客户端应用程序框架 I2P 脚本仓库 用于打包工具 ","description":"安装、更新和开发路由器插件","id":"f8687b90431c32a8ee7e10be9f7c44e0","section":"docs","title":"安装自定义插件","url":"/zh/docs/guides/plugins/"},{"categories":null,"content":"概述 I2P 插件是扩展 router 功能的签名归档包。它们以 .xpi2p 或 .su3 文件形式发布，安装到 ~/.i2p/plugins/\u0026lt;name\u0026gt;/（Windows 上为 %APPDIR%\\I2P\\plugins\\\u0026lt;name\u0026gt;\\），并以完整的 router 权限运行，且不使用沙箱。\n支持的插件类型 控制台 Web 应用 包含 cgi-bin、Web 应用的新 eepsites 控制台主题 控制台翻译 Java 程序（进程内或单独的 JVM） Shell 脚本和原生二进制文件 安全模型 严重： 插件在与 I2P router 相同的 JVM 中运行，并拥有与其相同的权限。它们可以不受限制地访问: - 文件系统 (读写) - Router API 和内部状态 - 网络连接 - 执行外部程序\n插件应被视为完全受信任的代码。用户在安装前必须验证插件来源和签名。\n文件格式 SU3 格式（强烈推荐） 状态： 已启用，自 I2P 0.9.15 (2014年9月) 起为首选格式\n.su3 格式提供： - RSA-4096 签名密钥 (与 xpi2p 中的 DSA-1024 相比) - 签名存储在文件头中 - 魔数：I2Psu3 - 更好的前向兼容性\n结构：\n[SU3 Header with RSA-4096 signature] [ZIP Archive] ├── plugin.config (required) ├── console/ ├── lib/ ├── webapps/ └── [other plugin files] XPI2P 格式（遗留，已弃用） 状态： 为向后兼容而提供支持，不建议用于新的插件\n.xpi2p 格式使用较旧的加密签名： - DSA-1024 签名（按 NIST-800-57 已过时） - 在 ZIP 之前前置 40 字节的 DSA 签名 - 需要在 plugin.config 中包含 key 字段\n结构：\n[40-byte DSA signature] [16-byte version string (UTF-8, zero-padded)] [ZIP Archive] 迁移路径： 当从 xpi2p 迁移到 su3 时，在过渡期间同时提供 updateURL 和 updateURL.su3。较新的 router（0.9.15+）会自动优先选择 SU3。\n归档布局与 plugin.config 必需文件 plugin.config - 标准的 I2P 配置文件，包含键值对\n必需属性 Property Description Format nameInstallation directory name, must match for updatesAlphanumeric, no spaces signerDeveloper contact informationuser@mail.i2p format recommended versionPlugin version for update comparisonMax 16 bytes, parsed by VersionComparator keyDSA public key (172 B64 chars ending with '=')Omit for SU3 format **版本格式示例：** - `1.2.3` - `1.2.3-4` - `2.0.0-beta.1` 有效的分隔符：.（点号）、-（连字符）、_（下划线）\n可选元数据属性 显示信息 date - 发布日期（Java long 类型时间戳） author - 开发者名称（建议使用 user@mail.i2p） description - 英文描述 description_xx - 本地化描述（xx = 语言代码） websiteURL - 插件主页（http://foo.i2p/） license - 许可证标识符（例如，\u0026ldquo;Apache-2.0\u0026rdquo;、\u0026ldquo;GPL-3.0\u0026rdquo;） 更新配置 updateURL - XPI2P (I2P 插件包格式) 更新位置 (遗留) updateURL.su3 - SU3 (I2P 签名更新包格式) 更新位置 (首选) min-i2p-version - 所需的最低 I2P 版本 max-i2p-version - 兼容的最高 I2P 版本 min-java-version - 最低 Java 版本 (例如，1.7、17) min-jetty-version - 最低 Jetty (Java Web 服务器) 版本 (对于 Jetty 6+ 使用 6) max-jetty-version - 最高 Jetty 版本 (对于 Jetty 5 使用 5.99999) 安装行为 dont-start-at-install - 默认值为 false。若为 true，则需要手动启动 router-restart-required - 默认值为 false。通知用户更新后需要重启 update-only - 默认值为 false。若插件尚未安装则失败 install-only - 默认值为 false。若插件已存在则失败 min-installed-version - 执行更新所需的最低已安装版本 max-installed-version - 可更新的最高已安装版本 disableStop - 默认值为 false。若为 true，隐藏停止按钮 控制台集成 consoleLinkName - 控制台摘要栏链接的文本 consoleLinkName_xx - 本地化的链接文本（xx = 语言代码） consoleLinkURL - 链接目标（例如，/appname/index.jsp） consoleLinkTooltip - 工具提示文本（自 0.7.12-6 起支持） consoleLinkTooltip_xx - 本地化的工具提示 console-icon - 32x32 图标的路径（自 0.9.20 起支持） icon-code - 用于无 Web 资源插件的 Base64 编码 32x32 PNG（自 0.9.25 起） 平台要求（仅显示） required-platform-OS - 操作系统要求（不强制执行） other-requirements - 其他要求（例如，\u0026ldquo;Python 3.8+\u0026quot;） 依赖管理 (未实现) depends - 以逗号分隔的插件依赖项 depends-version - 依赖项的版本要求 langs - 语言包内容 type - 插件类型（app/theme/locale/webapp） 更新 URL 变量替换 功能状态： 自 I2P 1.7.0 (0.9.53) 起可用\nupdateURL 和 updateURL.su3 都支持平台特定的变量：\n变量： - $OS - 操作系统: windows, linux, mac - $ARCH - 架构: 386, amd64, arm64\n示例：\nupdateURL.su3=http://foo.i2p/downloads/foo-$OS-$ARCH.su3 在 Windows AMD64 上的结果：\nhttp://foo.i2p/downloads/foo-windows-amd64.su3 这使面向特定平台的构建可以使用单个 plugin.config 文件。\n目录结构 标准布局 plugins/ └── pluginname/ ├── plugin.config (required) ├── console/ │ ├── locale/ # Translation JARs │ ├── themes/ # Console themes │ ├── webapps/ # Web applications │ └── webapps.config # Webapp configuration ├── eepsite/ │ ├── cgi-bin/ │ ├── docroot/ │ ├── logs/ │ ├── webapps/ │ └── jetty.xml ├── lib/ │ └── *.jar # Plugin libraries └── clients.config # Client startup configuration 目录用途 console/locale/ - 包含 I2P 基础翻译资源包的 JAR 文件 - 插件特定的翻译应位于 console/webapps/*.war 或 lib/*.jar\nconsole/themes/ - 每个子目录都包含一个完整的控制台主题 - 自动添加到主题搜索路径中\nconsole/webapps/ - 用于控制台集成的 .war 文件 - 除非在 webapps.config 中禁用，否则会自动启动 - WAR 名称无需与插件名称匹配\neepsite/ - 完整的 eepsite，带有自己的 Jetty 实例 - 需要带有变量替换的 jetty.xml 配置 - 参见 zzzot 和 pebble 插件示例\nlib/ - 插件 JAR 库 - 可通过 clients.config 或 webapps.config 在类路径中指定\nWeb 应用程序配置 webapps.config 格式 用于控制 Web 应用行为的标准 I2P 配置文件。\n语法：\n# Disable autostart webapps.warname.startOnLoad=false # Add classpath JARs (as of API 0.9.53, works for any warname) webapps.warname.classpath=$PLUGIN/lib/foo.jar,$I2P/lib/bar.jar 重要说明： - 在 router 0.7.12-9 之前，为兼容性请使用 plugin.warname.startOnLoad - 在 API 0.9.53 之前，仅当 warname（WAR 名称）与插件名称匹配时，classpath（类路径）才可用 - 自 0.9.53+ 起，classpath 适用于任何 Web 应用名称\nWeb 应用最佳实践 ServletContextListener 实现\n实现 javax.servlet.ServletContextListener 用于清理 或在 servlet 中重写 destroy() 确保在更新期间以及 router 停止时正确关闭 库管理\n将共享的 JAR 放在 lib/ 中，而非 WAR 包内 通过 webapps.config 的类路径进行引用 支持插件单独安装/更新 避免库冲突\n切勿打包 Jetty、Tomcat 或 servlet 的 JAR 切勿打包来自标准 I2P 安装的 JAR 请查看类路径（classpath）部分以获取标准库 编译要求\n不要包含 .java 或 .jsp 源文件 预编译所有 JSP 页面以避免启动延迟 不能假定 Java/JSP 编译器可用 Servlet API 兼容性\nI2P 支持 Servlet 3.0（自 0.9.30 起） 不支持注解扫描（@WebContent） 必须提供传统的 web.xml 部署描述符 Jetty 版本\n当前：Jetty 9 (I2P 0.9.30+) 使用 net.i2p.jetty.JettyStart 实现抽象 避免受 Jetty API 变更影响 客户端配置 clients.config 格式 定义由插件启动的客户端（服务）。\n基础客户端：\nclientApp.0.main=com.example.PluginMain clientApp.0.name=Example Plugin Service clientApp.0.delay=30 clientApp.0.args=arg1 arg2 $PLUGIN/config.properties 带有停止/卸载的客户端:\nclientApp.0.stopargs=stop clientApp.0.uninstallargs=uninstall clientApp.0.classpath=$PLUGIN/lib/plugin.jar,$I2P/lib/i2p.jar 属性参考 Property Description mainFully qualified class name implementing ClientApp interface nameDisplay name for user interface delayStartup delay in seconds (default: 0) argsSpace-separated arguments passed to constructor stopargsArguments for shutdown (must handle gracefully) uninstallargsArguments called before plugin deletion classpathComma-separated JAR paths ### 变量替换 以下变量会在 args、stopargs、uninstallargs 和 classpath 中被替换：\nVariable Replacement $I2PI2P base installation directory $CONFIGI2P configuration directory (typically ~/.i2p) $PLUGINThis plugin's directory ($CONFIG/plugins/name) $OSOperating system: windows, linux, mac $ARCHArchitecture: 386, amd64, arm64 ### 托管与非托管客户端 受管客户端（自 0.9.4 起推荐）： - 由 ClientAppManager 实例化 - 保留引用并跟踪状态 - 更易于生命周期管理 - 更好的内存管理\n非托管客户端： - 由 router 启动， 无状态跟踪 - 必须能优雅地处理多次启动/停止调用 - 使用静态状态信息或 PID 文件进行协调 - 在 router 关闭时会被调用（自 0.7.12-3 起）\nShellService（自 0.9.53 / 1.7.0 起） 用于运行外部程序并自动跟踪状态的通用解决方案。\n功能： - 管理进程生命周期 - 与 ClientAppManager 通信 - 自动 PID 管理 - 跨平台支持\n用法：\nclientApp.0.main=net.i2p.apps.ShellService clientApp.0.args=$PLUGIN/bin/myservice.sh 平台特定脚本：\nclientApp.0.args=$PLUGIN/bin/myservice-$OS.$ARCH 替代方案（遗留）： 编写一个 Java 包装器以检查操作系统类型，并使用相应的 .bat 或 .sh 文件调用 ShellCommand。\n安装过程 用户安装流程 用户将插件 URL 粘贴到 Router 控制台插件配置页面（/configplugins） Router 下载插件文件 签名验证（如果密钥未知且启用严格模式则失败） ZIP 完整性检查 解压并解析 plugin.config 版本兼容性验证（min-i2p-version、min-java-version 等） Web 应用名称冲突检测 若为更新则停止现有插件 目录验证（必须位于 plugins/ 下） 将所有文件解压到插件目录 更新 plugins.config 启动插件（除非 dont-start-at-install=true） 安全与信任 密钥管理： - 针对新签名者采用 First-key-seen 信任模型（首次见到的密钥即被信任） - 仅预置 jrandom 和 zzz 的密钥 - 自 0.9.14.1 起，默认拒绝未知密钥 - 可通过高级属性为开发用途覆盖默认设置\n安装限制： - 归档文件只能解压到插件目录 - 安装程序会拒绝 plugins/ 之外的路径 - 安装后，插件可以访问其他位置的文件 - 无沙箱或权限隔离\n更新机制 更新检查流程 router 从 plugin.config 读取 updateURL.su3（优先）或 updateURL 通过 HTTP HEAD 或部分 GET 请求获取第 41–56 字节 从远程文件提取版本字符串 使用 VersionComparator 与已安装版本比较 如果为更高版本，则根据设置提示用户或自动下载 停止插件 安装更新 启动插件（除非用户偏好已更改） 版本比较 将版本解析为以点/连字符/下划线分隔的组件： - 1.2.3 \u0026lt; 1.2.4 - 1.2.3 \u0026lt; 1.2.3-1 - 2.0.0 \u0026gt; 1.9.9\n最大长度： 16 字节（必须与 SUD/SU3 头部匹配；SUD/SU3 为 I2P 签名更新文件格式）\n更新最佳实践 每次发布都递增版本号 从上一版本测试升级路径 重大变更时考虑使用 router-restart-required 迁移期间同时提供 updateURL 和 updateURL.su3 测试时使用构建号后缀（1.2.3-456） 类路径与标准库 在类路径中始终可用 以下来自 $I2P/lib 的 JAR 包在 I2P 0.9.30+ 中始终在类路径中：\nJAR Contents Plugin Usage i2p.jarCore APIRequired for all plugins mstreaming.jarStreaming APIMost plugins need streaming.jarStreaming implementationMost plugins need i2ptunnel.jarI2PTunnelHTTP/server plugins router.jarRouter internalsRarely needed, avoid if possible javax.servlet.jarServlet 3.1, JSP 2.3 APIPlugins with servlets/JSPs jasper-runtime.jarJasper compiler/runtimePlugins with JSPs commons-el.jarEL 3.0 APIJSPs using expression language jetty-i2p.jarJetty utilitiesPlugins starting Jetty org.mortbay.jetty.jarJetty 9 baseCustom Jetty instances sam.jarSAM APIRarely needed addressbook.jarSubscription/blockfileUse NamingService instead routerconsole.jarConsole librariesNot public API, avoid jbigi.jarNative cryptoPlugins should not need systray.jarURL launcherRarely needed wrapper.jarService wrapperPlugins should not need ### 特别说明 commons-logging.jar: - 自 0.9.30 起为空 - 0.9.30 之前：Apache Tomcat JULI - 0.9.24 之前：Commons Logging + JULI - 0.9 之前：仅 Commons Logging\njasper-compiler.jar: - 自 Jetty 6 (0.9) 起为空\nsystray4j.jar: - 已在 0.9.26 版本中移除\n未在类路径中（必须指定） JAR Contents Usage jstl.jarStandard TaglibJSP tag libraries standard.jarStandard TaglibJSP tag libraries ### 类路径规范 在 clients.config 中：\nclientApp.0.classpath=$PLUGIN/lib/mylib.jar,$I2P/lib/i2p.jar 在 webapps.config 中：\nwebapps.mywebapp.classpath=$PLUGIN/lib/mylib.jar,$I2P/lib/jstl.jar 重要： 从 0.7.13-3 起，类路径是特定于线程的，而不是 JVM 全局的。请为每个客户端指定完整的类路径。\nJava 版本要求 当前系统要求（2025年10月） I2P 2.10.0 及更早版本： - 最低要求：Java 7 (自 2016 年 1 月的 0.9.24 起为必需) - 建议：Java 8 或更高版本\nI2P 2.11.0 及更高版本 (即将发布): - 最低要求: Java 17+ (已在 2.9.0 发行说明中宣布) - 已提前两个版本给出预告 (2.9.0 → 2.10.0 → 2.11.0)\n插件兼容性策略 为获得最大兼容性（适用于 I2P 2.10.x 及之前的版本）：\n\u0026lt;javac source=\u0026#34;1.7\u0026#34; target=\u0026#34;1.7\u0026#34; /\u0026gt; min-java-version=1.7 针对 Java 8+ 特性：\n\u0026lt;javac source=\u0026#34;1.8\u0026#34; target=\u0026#34;1.8\u0026#34; /\u0026gt; min-java-version=1.8 对于 Java 11+ 特性：\n\u0026lt;javac source=\u0026#34;11\u0026#34; target=\u0026#34;11\u0026#34; /\u0026gt; min-java-version=11 为 2.11.0+ 做准备：\n\u0026lt;javac source=\u0026#34;17\u0026#34; target=\u0026#34;17\u0026#34; /\u0026gt; min-java-version=17 min-i2p-version=2.11.0 编译最佳实践 使用较新 JDK 为较旧的目标版本进行编译时：\n\u0026lt;javac source=\u0026#34;1.7\u0026#34; target=\u0026#34;1.7\u0026#34; bootclasspath=\u0026#34;${java7.home}/jre/lib/rt.jar\u0026#34; includeantruntime=\u0026#34;false\u0026#34; /\u0026gt; 这可防止使用在目标 Java 版本中不可用的 API。\nPack200 压缩 - 已废弃 重要更新：请勿使用 Pack200（Java 的 JAR 压缩格式） 状态: 已弃用并移除\n原始规范强烈建议使用 Pack200 压缩，以将大小缩减 60-65%。这已不再适用。\n时间线： - JEP 336： Pack200 在 Java 11 中被弃用（2018 年 9 月） - JEP 367： Pack200 在 Java 14 中被移除（2020 年 3 月）\nI2P 官方更新规范指出： \u0026gt; \u0026ldquo;zip 中的 Jar 和 war 文件不再像上文针对 \u0026lsquo;su2\u0026rsquo; 文件所述那样使用 pack200（Java 的打包/压缩格式）进行压缩，因为较新的 Java 运行时已不再支持它。\u0026rdquo;\n该怎么做：\n立即从构建流程中移除 pack200（已弃用的 JAR 压缩格式） 使用标准 ZIP 压缩 考虑替代方案： ProGuard/R8（用于代码缩减） UPX（用于原生二进制文件的压缩） 现代压缩算法（zstd、brotli），如果提供自定义解压器 针对现有插件： - 旧版 router（0.7.11-5 至 Java 10）仍可解包 pack200 - 新版 router（Java 11+）无法解包 pack200 - 重新发布插件，不使用 pack200 压缩\n签名密钥与安全性 密钥生成（SU3 格式） 使用 i2p.scripts 仓库中的 makeplugin.sh 脚本:\n# Generate new signing key ./makeplugin.sh keygen # Keys stored in ~/.i2p-plugin-keys/ 关键信息： - 算法: RSA_SHA512_4096 - 格式: X.509 证书 - 存储: Java 密钥库格式\n插件签名 # Create signed su3 file ./makeplugin.sh sign myplugin.zip myplugin.su3 keyname # Verify signature ./makeplugin.sh verify myplugin.su3 密钥管理最佳实践 一次生成，永久保护\nRouters 会拒绝密钥名重复但密钥不同的情况 Routers 会拒绝密钥相同但密钥名不同的情况 若密钥/名称不匹配，将拒绝更新 安全存储\n安全地备份密钥库 使用强密码短语 切勿提交到版本控制系统 密钥轮换\n当前架构不支持 规划长期密钥使用 考虑用于团队开发的多重签名方案 遗留 DSA 签名（XPI2P） 状态： 功能正常但已过时\nxpi2p 格式所使用的 DSA-1024 签名： - 40 字节签名 - 172 个 base64 字符的公钥 - NIST-800-57 建议最小为 (L=2048, N=224) - I2P 使用更弱的 (L=1024, N=160)\n建议： 改用采用 RSA-4096 的 SU3（I2P 更新/插件的签名封装格式）。\n插件开发指南 必备最佳实践 文档\n提供包含安装说明的清晰 README（自述文件） 记录配置选项及其默认值 每次发布时包含变更日志 注明所需的 I2P/Java 版本 大小优化\n只包含必要的文件 切勿捆绑 router 的 JAR 包 将安装包与更新包分离（库位于 lib/） 使用 Pack200 压缩 已废弃 - 使用标准 ZIP 配置\n切勿在运行时修改 plugin.config 为运行时设置使用单独的配置文件 记录并说明所需的 router 设置（SAM 端口、tunnels 等） 尊重用户的现有配置 资源使用\n避免在默认设置下过度占用带宽 实现合理的 CPU 使用限制 在关闭时清理资源 在适当情况下使用守护线程 测试\n在所有平台上测试安装/升级/卸载 测试从上一版本更新 在更新过程中验证 Web 应用的停止/重启 使用最低支持的 I2P 版本进行测试 文件系统\n切勿写入 $I2P（可能是只读） 将运行时数据写入 $PLUGIN 或 $CONFIG 使用 I2PAppContext 进行目录发现 不要假定 $CWD 的位置 兼容性\n不要重复实现标准的 I2P 类 必要时扩展类，不要替换 在 plugin.config 中检查 min-i2p-version、min-jetty-version 如果要支持较旧的 I2P 版本，请进行测试 关闭处理\n在 clients.config 中正确配置 stopargs 注册关闭钩子: I2PAppContext.addShutdownTask() 优雅地处理多次启动/停止调用 将所有线程设置为守护线程 安全\n验证所有外部输入 切勿调用 System.exit() 尊重用户隐私 遵循安全编码实践 许可协议\n明确说明插件许可协议 遵守捆绑库的许可协议 包含必要的署名信息 如有要求，提供源代码获取途径 高级注意事项 时区处理: - Router 将 JVM 时区设置为 UTC - 用户的实际时区: I2PAppContext 属性 i2p.systemTimeZone\n目录发现：\n// Plugin directory String pluginDir = I2PAppContext.getGlobalContext() .getAppDir().getAbsolutePath() + \u0026#34;/plugins/\u0026#34; + pluginName; // Or use $PLUGIN variable in clients.config args 版本编号: - 使用语义化版本 (major.minor.patch) - 为测试添加构建号 (1.2.3-456) - 确保更新时版本号单调递增\nRouter 类访问: - 一般应避免依赖 router.jar - 改用 i2p.jar 中的公共 API - 未来的 I2P 可能会限制对 Router 类的访问\nJVM 崩溃预防（历史）： - 已在 0.7.13-3 修复 - 正确使用类加载器 - 避免在正在运行的插件中更新 JAR 文件 - 如有必要，设计为在更新时重启（restart-on-update）\neepsite 插件 概述 插件可以提供完整的 eepsites（I2P 上的匿名网站），并配有其自有的 Jetty 和 I2PTunnel 实例。\n架构 请勿尝试： - 安装到现有的 eepsite（I2P 隐匿站点） - 与 router 的默认 eepsite 合并 - 假定仅有一个 eepsite 可用\n改为： - 启动新的 I2PTunnel 实例（通过 CLI（命令行界面）方式） - 启动新的 Jetty 实例 - 在 clients.config 中配置二者\n示例结构 plugins/myeepsite/ ├── plugin.config ├── clients.config # Starts Jetty + I2PTunnel ├── eepsite/ │ ├── jetty.xml # Requires variable substitution │ ├── docroot/ │ ├── webapps/ │ └── logs/ └── lib/ └── [dependencies] jetty.xml 中的变量替换 将 $PLUGIN 变量用于路径：\n\u0026lt;Set name=\u0026#34;resourceBase\u0026#34;\u0026gt;$PLUGIN/eepsite/docroot\u0026lt;/Set\u0026gt; Router 会在插件启动时执行替换。\n示例 参考实现: - zzzot 插件 - BT 追踪器 - pebble 插件 - 博客平台\n两者都可在 zzz 的插件页面（I2P-internal）获取。\n控制台集成 摘要栏链接 为 router 控制台摘要栏添加可点击链接：\nconsoleLinkName=My Plugin consoleLinkURL=/myplugin/ consoleLinkTooltip=Open My Plugin Interface 本地化版本：\nconsoleLinkName_de=Mein Plugin consoleLinkTooltip_de=Öffne Mein Plugin Schnittstelle 控制台图标 镜像文件 (自 0.9.20 起):\nconsole-icon=/myicon.png 如果已指定，则路径相对于 consoleLinkURL（自 0.9.53 起）；否则相对于 Web 应用名称。\n嵌入式图标（自 0.9.25 起）：\nicon-code=iVBORw0KGgoAAAANSUhEUgAAA...Base64EncodedPNG... 使用以下方式生成：\nbase64 -w 0 icon-32x32.png 或者使用 Java：\njava -cp i2p.jar net.i2p.data.Base64 encode icon.png 要求：- 32x32 像素 - PNG 格式 - Base64 编码（无换行）\n国际化 翻译包 针对 I2P 基础翻译： - 将 JAR 包放置于 console/locale/ - 包含现有 I2P 应用的资源包 - 命名：messages_xx.properties (xx = 语言代码)\n针对插件特定的翻译： - 将其包含在 console/webapps/*.war - 或包含在 lib/*.jar - 使用标准的 Java ResourceBundle 方法\nplugin.config 中的本地化字符串 description=My awesome plugin description_de=Mein tolles Plugin description_fr=Mon plugin génial description_es=Mi plugin increíble 支持的字段：- description_xx - consoleLinkName_xx - consoleLinkTooltip_xx\n控制台主题翻译 位于 console/themes/ 的主题会自动添加到主题搜索路径中。\n特定于平台的插件 分离式软件包方案 为每个平台使用不同的插件名称：\n# Windows package name=myplugin-windows # Linux package name=myplugin-linux # macOS package name=myplugin-mac 变量替换方法 单个 plugin.config，包含平台变量：\nname=myplugin updateURL.su3=http://myplugin.i2p/downloads/myplugin-$OS-$ARCH.su3 在 clients.config 中：\nclientApp.0.main=net.i2p.apps.ShellService clientApp.0.args=$PLUGIN/bin/myapp-$OS-$ARCH 运行时操作系统检测 Java 中的条件执行思路：\nString os = System.getProperty(\u0026#34;os.name\u0026#34;).toLowerCase(); if (os.contains(\u0026#34;win\u0026#34;)) { // Windows-specific code } else if (os.contains(\u0026#34;nix\u0026#34;) || os.contains(\u0026#34;nux\u0026#34;)) { // Linux-specific code } else if (os.contains(\u0026#34;mac\u0026#34;)) { // macOS-specific code } 故障排除 常见问题 插件无法启动： 1. 检查 I2P 版本兼容性（min-i2p-version） 2. 验证 Java 版本（min-java-version） 3. 检查 router 日志是否有错误 4. 确认类路径中包含所有必需的 JAR 文件\nWeb 应用无法访问： 1. 确认 webapps.config 未将其禁用 2. 检查 Jetty（Java Web 服务器）版本兼容性（min-jetty-version） 3. 确认存在 web.xml（不支持注解扫描） 4. 检查是否存在冲突的 Web 应用名称\n更新失败： 1. 确认版本号已提升 2. 检查签名与签名密钥是否匹配 3. 确保插件名称与已安装的版本匹配 4. 检查 update-only/install-only 设置\n外部程序无法停止： 1. 使用 ShellService（Shell 服务组件）进行自动化生命周期管理 2. 正确实现对 stopargs 的处理 3. 检查 PID 文件清理 4. 验证进程是否已终止\n调试日志 启用 router 的调试日志：\nlogger.record.net.i2p.router.web.ConfigPluginsHandler=DEBUG 检查日志：\n~/.i2p/logs/log-router-0.txt 参考信息 官方规范 插件规范 配置格式 更新规范 密码学 I2P 版本历史 当前版本: - I2P 2.10.0 (2025年9月8日)\n自 0.9.53 以来的主要版本： - 2.10.0 (2025 年 9 月) - Java 17+ 公告 - 2.9.0 (2025 年 6 月) - Java 17+ 警告 - 2.8.0 (2024 年 10 月) - 后量子密码学测试 - 2.6.0 (2024 年 5 月) - 对 I2P-over-Tor 的阻断 - 2.4.0 (2023 年 12 月) - NetDB 安全性改进 - 2.2.0 (2023 年 3 月) - 拥塞控制 - 2.1.0 (2023 年 1 月) - 网络改进 - 2.0.0 (2022 年 11 月) - SSU2 传输协议 - 1.7.0/0.9.53 (2022 年 2 月) - ShellService, 变量替换 - 0.9.15 (2014 年 9 月) - 引入 SU3 格式\n版本编号: - 0.9.x 系列: 截至 0.9.53 版本 - 2.x 系列: 自 2.0.0 起 (引入 SSU2)\n开发者资源 源代码: - 主仓库: https://i2pgit.org/I2P_Developers/i2p.i2p - GitHub 镜像: https://github.com/i2p/i2p.i2p 插件示例: - zzzot (BitTorrent 追踪器) - pebble (博客平台) - i2p-bote (无服务器电子邮件) - orchid (Tor 客户端) - seedless (对等交换)\n构建工具： - makeplugin.sh - 密钥生成与签名 - 位于 i2p.scripts 仓库中 - 自动化 su3（签名更新文件格式）的创建与验证\n社区支持 论坛: - I2P 论坛 - zzz.i2p (I2P 内部)\nIRC/聊天: - #i2p-dev 在 OFTC 上 - I2P 网络内的 IRC\n附录 A：完整的 plugin.config 示例 # Required fields name=example-plugin signer=developer@mail.i2p version=1.2.3 # Update configuration updateURL.su3=http://example.i2p/plugins/example-$OS-$ARCH.su3 min-i2p-version=2.0.0 min-java-version=17 # Display information date=1698796800000 author=Example Developer \u0026lt;developer@mail.i2p\u0026gt; websiteURL=http://example.i2p/ license=Apache-2.0 description=An example I2P plugin demonstrating best practices description_de=Ein Beispiel-I2P-Plugin zur Demonstration bewährter Praktiken description_es=Un plugin I2P de ejemplo que demuestra las mejores prácticas # Console integration consoleLinkName=Example Plugin consoleLinkName_de=Beispiel-Plugin consoleLinkURL=/example/ consoleLinkTooltip=Open the Example Plugin control panel consoleLinkTooltip_de=Öffne das Beispiel-Plugin-Kontrollfeld console-icon=/icon.png # Installation behavior dont-start-at-install=false router-restart-required=false # Platform requirements (informational) required-platform-OS=All platforms supported other-requirements=Requires 512MB free disk space 附录B：完整的 clients.config 示例 # Main service client (managed) clientApp.0.main=com.example.plugin.MainService clientApp.0.name=Example Plugin Main Service clientApp.0.delay=30 clientApp.0.args=$PLUGIN/config.properties --port=7656 clientApp.0.stopargs=shutdown clientApp.0.uninstallargs=cleanup clientApp.0.classpath=$PLUGIN/lib/example.jar,$I2P/lib/i2p.jar,$I2P/lib/mstreaming.jar # External program via ShellService clientApp.1.main=net.i2p.apps.ShellService clientApp.1.name=Example Native Helper clientApp.1.delay=35 clientApp.1.args=$PLUGIN/bin/helper-$OS-$ARCH --config $PLUGIN/helper.conf clientApp.1.classpath=$I2P/lib/i2p.jar # Jetty eepsite clientApp.2.main=net.i2p.jetty.JettyStart clientApp.2.name=Example Eepsite clientApp.2.delay=40 clientApp.2.args=$PLUGIN/eepsite/jetty.xml clientApp.2.stopargs=$PLUGIN/eepsite/jetty.xml stop clientApp.2.classpath=$PLUGIN/lib/example-web.jar,$I2P/lib/i2p.jar # I2PTunnel for eepsite clientApp.3.main=net.i2p.i2ptunnel.TunnelControllerGroup clientApp.3.name=Example Eepsite Tunnel clientApp.3.delay=45 clientApp.3.args=$PLUGIN/eepsite/i2ptunnel.config 附录 C：完整的 webapps.config 示例 # Disable autostart for admin webapp webapps.example-admin.startOnLoad=false # Main webapp with classpath webapps.example.startOnLoad=true webapps.example.classpath=$PLUGIN/lib/example-core.jar,$PLUGIN/lib/commons-utils.jar,$I2P/lib/jstl.jar,$I2P/lib/standard.jar # Legacy support (pre-0.7.12-9) plugin.example.startOnLoad=true 附录 D: 迁移清单 (0.9.53 到 2.10.0) 必要的更改 从构建流程中移除 Pack200 压缩\n从 Ant/Maven/Gradle 脚本中移除 pack200 任务 在不使用 pack200 的情况下重新发布现有插件 审查 Java 版本要求\n考虑对新功能要求 Java 11+ 计划在 I2P 2.11.0 中要求 Java 17+ 在 plugin.config 中更新 min-java-version 更新文档\n移除对 Pack200 的引用 更新 Java 版本要求 更新 I2P 版本引用（0.9.x → 2.x） 建议的更改 加强密码学签名\n如果尚未完成，请从 XPI2P（I2P 插件打包/签名格式）迁移到 SU3（I2P 插件打包/签名格式） 为新插件使用 RSA-4096 密钥 利用新功能 (如果使用 0.9.53+)\n使用 $OS / $ARCH 变量用于特定平台的更新 使用 ShellService 运行外部程序 使用改进的 webapp 类路径 (适用于任何 WAR 名称) 测试兼容性\n在 I2P 2.10.0 上进行测试 使用 Java 8、11、17 进行验证 在 Windows、Linux、macOS 上检查 可选增强功能 实现正确的 ServletContextListener（Servlet 上下文监听器） 添加本地化说明 提供控制台图标 改进关闭处理 添加全面的日志记录 编写自动化测试 ","description":"用于 I2P 插件的 .xpi2p / .su3 打包规则","id":"b25aafc3542216f9bbc2f124d1943fbc","section":"docs","title":"插件包格式","url":"/zh/docs/specs/plugin/"},{"categories":null,"content":"I2P Router 帮助 I2P 可以在哪些系统上运行？ I2P 使用 Java 编程语言编写。它已在 Windows、Linux、FreeBSD 和 OSX 上经过测试。同时也提供了 Android 版本。\n在内存使用方面，I2P 默认配置为使用 128 MB 的 RAM。这对于浏览和 IRC 使用来说已经足够。然而，其他活动可能需要分配更多内存。例如，如果想要运行高带宽 router、参与 I2P 种子下载或提供高流量的隐藏服务，则需要更多的内存。\n就CPU使用而言,I2P已经过测试,可以在树莓派系列单板计算机等配置较低的系统上运行。由于I2P大量使用加密技术,性能更强的CPU将更适合处理I2P生成的工作负载以及系统其余部分的相关任务(即操作系统、图形界面、其他进程,如网页浏览)。\n推荐使用 Sun/Oracle Java 或 OpenJDK。\n使用 I2P 是否需要安装 Java？ 是的,使用 I2P Core 需要 Java。我们在 Windows、Mac OSX 和 Linux 的简易安装程序中已经包含了 Java。如果您运行 I2P Android 应用程序,在大多数情况下还需要安装 Java 运行时,如 Dalvik 或 ART。\n什么是\u0026quot;I2P Site\u0026quot;（I2P站点），以及如何配置我的浏览器以便使用它们？ I2P 站点是一个普通网站，只不过它托管在 I2P 内部。I2P 站点的地址看起来像普通的互联网地址，以 \u0026ldquo;.i2p\u0026rdquo; 结尾，采用人类可读的非加密方式，方便用户使用。实际连接到 I2P 站点需要加密技术，这意味着 I2P 站点地址也可以是较长的 \u0026ldquo;Base64\u0026rdquo; Destination 地址和较短的 \u0026ldquo;B32\u0026rdquo; 地址。您可能需要进行额外配置才能正确浏览。浏览 I2P 站点需要在您的 I2P 安装中激活 HTTP 代理，然后配置您的浏览器使用该代理。如需更多信息，请浏览下方的\u0026quot;浏览器\u0026quot;部分或\u0026quot;浏览器配置\u0026quot;指南。\n路由器控制台中的 Active x/y 数字是什么意思？ 在您的 router 控制台的 Peers 页面中,您可能会看到两个数字 - Active x/y。第一个数字是您在过去几分钟内发送或接收消息的对等节点数量。第二个数字是最近看到的对等节点数量,这个数字总是大于或等于第一个数字。\n我的 router 只有很少的活跃节点，这样正常吗？ 是的，这可能是正常的，尤其是当 router 刚刚启动时。新的 router 需要时间启动并连接到网络的其余部分。为了帮助改善网络集成、运行时间和性能，请查看以下设置：\n共享带宽 - 如果 router 配置为共享带宽,它将为其他 router 路由更多流量,这有助于将其集成到网络的其余部分,同时提高本地连接的性能。这可以在 http://localhost:7657/config 页面进行配置。 网络接口 - 确保在 http://localhost:7657/confignet 页面上没有指定接口。除非您的计算机是多宿主(multi-homed)且具有多个外部 IP 地址,否则这会降低性能。 I2NP 协议 - 确保 router 配置为在主机操作系统和空网络(高级)设置的有效协议上接受连接。不要在网络配置页面的\u0026quot;主机名\u0026quot;字段中输入 IP 地址。只有在您还没有可访问地址时,才会使用您在此处选择的 I2NP 协议。例如,美国的大多数 Verizon 4G 和 5G 无线连接会阻止 UDP 且无法通过它访问。其他连接即使可用也会强制使用 UDP。从列出的 I2NP 协议中选择合理的设置。 我反对某些类型的内容。如何避免分发、存储或访问它们？ 默认情况下不会安装任何此类内容。但是，由于 I2P 是一个点对点网络，您可能会意外遇到违禁内容。以下是 I2P 如何防止您不必要地卷入违反您信仰的行为的概述。\n分发 - 流量在 I2P 网络内部传输,你不是一个 出口节点 (在我们的文档中称为 outproxy)。 存储 - I2P 网络不进行内容的分布式存储,这需要用户专门安装和配置(例如使用 Tahoe-LAFS)。这是另一个匿名网络 Freenet 的特性。运行 I2P router 时,你不会为任何人存储内容。 访问 - 你的 router 不会在没有你明确指示的情况下请求任何内容。 是否可能封锁 I2P？ 是的，目前最简单和最常见的方式是通过阻止引导服务器，或称为\u0026quot;Reseed\u0026quot;服务器。完全阻止所有混淆流量也可以达到目的（尽管这会破坏许多与 I2P 无关的其他服务，而且大多数人不愿意走到这一步）。在 reseed 阻止的情况下，Github 上有一个 reseed 包，阻止它也会阻止 Github。你可以通过代理进行 reseed（如果你不想使用 Tor，可以在互联网上找到许多代理），或者以朋友间线下分享的方式共享 reseed 包。\n在 wrapper.log 中，我看到一个错误，在加载路由器控制台时显示 \u0026ldquo;Protocol family unavailable\u0026rdquo; 通常，在某些默认配置使用 IPv6 的系统上，任何启用网络的 Java 软件都可能出现此错误。有几种方法可以解决这个问题：\n在基于 Linux 的系统上,你可以执行 echo 0 \u0026gt; /proc/sys/net/ipv6/bindv6only 在 wrapper.config 中查找以下行: #wrapper.java.additional.5=-Djava.net.preferIPv4Stack=true #wrapper.java.additional.6=-Djava.net.preferIPv6Addresses=false 如果这些行存在,通过删除 \u0026ldquo;#\u0026rdquo; 来取消注释。如果这些行不存在,则在添加时不要包含 \u0026ldquo;#\u0026quot;。 另一个选项是从 ~/.i2p/clients.config 中删除 ::1\n警告：要使对 wrapper.config 的任何更改生效，您必须完全停止 router 和 wrapper。在路由器控制台点击 重启 将不会重新读取此文件！您必须点击 关闭，等待 11 分钟，然后启动 I2P。\nI2P 内的大多数 I2P 站点都无法访问？ 如果你考虑到所有曾经创建过的 I2P Site，是的，大部分都已经关闭了。人们和 I2P Site 来来去去。开始使用 I2P 的一个好方法是查看当前在线的 I2P Site 列表。identiguy.i2p 跟踪活跃的 I2P Site。\n为什么 I2P 监听 32000 端口？ 我们使用的 Tanuki Java 服务包装器会打开此端口——绑定到本地主机——以便与 JVM 内运行的软件通信。当 JVM 启动时,它会获得一个密钥以便连接到包装器。在 JVM 建立与包装器的连接后,包装器会拒绝任何额外的连接。\n更多信息可以在 wrapper 文档 中找到。\n如何配置我的浏览器？ 不同浏览器的代理配置在单独的页面上,并附有截图。使用外部工具(如浏览器插件 FoxyProxy 或代理服务器 Privoxy)进行更高级的配置是可行的,但可能会在您的设置中引入泄漏风险。\n如何在 I2P 内连接到 IRC？ 当安装 I2P 时，会创建一个连接到 I2P 内部主 IRC 服务器 Irc2P 的 tunnel（参见 I2PTunnel 配置页面 ），并且会在 I2P router 启动时自动启动。要连接到它，请配置您的 IRC 客户端连接到 localhost 6668。HexChat 类客户端用户可以创建一个新网络，服务器地址为 localhost/6668（如果配置了代理服务器，记得勾选\u0026quot;绕过代理服务器\u0026rdquo;）。Weechat 用户可以使用以下命令添加新网络：\n/server add irc2p localhost/6668 如何设置我自己的 I2P 站点？ 最简单的方法是点击路由器控制台中的 i2ptunnel 链接，然后创建一个新的\u0026quot;服务器隧道\u0026quot;。你可以通过将隧道目的地设置为现有网络服务器（如 Tomcat 或 Jetty）的端口来提供动态内容。你也可以提供静态内容。为此，将隧道目的地设置为：0.0.0.0 port 7659，并将内容放置在 ~/.i2p/eepsite/docroot/ 目录中。（在非 Linux 系统上，此目录可能位于不同位置。请查看路由器控制台。）eepsite 软件作为 I2P 安装包的一部分提供，并设置为在 I2P 启动时自动启动。创建的默认站点可以通过 http://127.0.0.1:7658 访问。然而，你的 eepsite 也可以通过你的 eepsite 密钥文件被其他人访问，该文件位于：~/.i2p/eepsite/i2p/eepsite.keys。要了解更多信息，请阅读位于 ~/.i2p/eepsite/README.txt 的自述文件。\n如果我在家里的 I2P 上托管一个只包含 HTML 和 CSS 的网站，这样做危险吗？ 这取决于你的对手和威胁模型。如果你只是担心企业\u0026quot;隐私\u0026quot;侵犯、典型犯罪和审查制度，那么实际上并不是很危险。如果执法部门真的想找到你，可能还是会找到你的。只有在你正常使用（互联网）家庭用户浏览器时才托管站点，这样才能真正增加识别托管者身份的难度。请将托管你的 I2P 站点视为托管任何其他服务一样——其危险程度或安全程度取决于你自己如何配置和管理。\n注意：已经有一种方法可以将托管 i2p 服务（destination）与 i2p router 分离。如果你理解其工作原理 ，那么你可以只需设置一台单独的机器作为网站（或服务）的服务器，该服务器将可公开访问，并通过一个[非常]安全的 SSH 隧道将其转发到 Web 服务器，或使用一个安全的共享文件系统。\nI2P 如何找到 \u0026ldquo;.i2p\u0026rdquo; 网站？ I2P 地址簿应用程序将人类可读的名称映射到与服务关联的长期目的地，使其更像是一个 hosts 文件或联系人列表，而不是网络数据库或 DNS 服务。它也是本地优先的——没有公认的全局命名空间，最终由你决定任何给定的 .i2p 域名映射到什么。折中方案是一种叫做\u0026quot;跳转服务\u0026quot;的机制，它通过重定向你到一个页面来提供人类可读的名称，在该页面上你会被问到\u0026quot;你是否授权 I2P router 将 $SITE_CRYPTO_KEY 命名为 $SITE_NAME.i2p\u0026quot;或类似的内容。一旦它被添加到你的地址簿中，你就可以生成自己的跳转 URL 来帮助与他人分享该站点。\n如何向地址簿添加地址？ 如果不知道您想访问的站点的至少 base32 或 base64 地址，您就无法添加地址。人类可读的\u0026quot;主机名\u0026quot;只是加密地址的别名，该加密地址对应于 base32 或 base64。没有加密地址，就无法访问 I2P 站点，这是设计使然。向尚不知道该地址的人分发地址通常是 Jump 服务提供商的责任。访问未知的 I2P 站点将触发 Jump 服务的使用。stats.i2p 是最可靠的 Jump 服务。\n如果你通过 i2ptunnel 托管一个站点,那么它还没有在跳转服务中注册。要在本地给它一个 URL,请访问配置页面并点击\u0026quot;添加到本地地址簿\u0026quot;按钮。然后访问 http://127.0.0.1:7657/dns 查找 addresshelper URL 并分享它。\nI2P 使用哪些端口？ I2P 使用的端口可以分为两个部分：\n面向互联网的端口,用于与其他 I2P router 通信 本地端口,用于本地连接 下面将详细介绍这些内容。\n1. 面向互联网的端口 注意：从 0.7.8 版本开始，新安装不再使用 8887 端口；程序首次运行时会随机选择 9000 到 31000 之间的端口。选定的端口显示在 router 配置页面 上。\n出站\n从配置页面 上列出的随机端口发出的 UDP 到任意远程 UDP 端口,允许接收回复 从随机高端口发出的 TCP 到任意远程 TCP 端口 端口 123 上的出站 UDP,允许接收回复。这对于 I2P 的内部时间同步是必需的(通过 SNTP - 查询 pool.ntp.org 中的随机 SNTP 主机或您指定的其他服务器) 入站\n(可选,推荐) 从任意位置到配置页面 上注明端口的 UDP 连接 (可选,推荐) 从任意位置到配置页面 上注明端口的 TCP 连接 入站 TCP 可以在配置页面 上禁用 2. 本地 I2P 端口 默认情况下，本地 I2P 端口仅监听本地连接，除非另有说明：\nPORT PURPOSE DESCRIPTION 1900 UPnP SSDP UDP multicast listener Cannot be changed. Binds to all interfaces. May be disabled on confignet. 2827 BOB bridge A higher level socket API for clients. Disabled by default. May be enabled/disabled on configclients. May be changed in the bob.config file. 4444 HTTP proxy Configured on configclients, go to the page i2ptunnel to start/stop it and on the page I2P HTTP Proxy to configure it. Include in your browser's proxy configuration for HTTP 4445 HTTPS proxy Configured on configclients, go to the page i2ptunnel to start/stop it and on the page I2P HTTPS Proxy to configure it. Include in your browser's proxy configuration for HTTPS 6668 IRC proxy A tunnel to the inside-the-I2P IRC network. Disabled by default. Configured on the page irc.postman.i2p (IRC proxy) and may be enabled/disabled on the page i2ptunnel 7654 I2CP (client protocol) port For advanced client usage. Do not expose to an external network. 7656 SAM bridge A socket API for clients. Disabled by default. May be enabled/disabled on configclients and configured on sam. 7657 (or 7658 via SSL) Router console The router console provides valuable information about your router and the network, in addition to giving you access to configure your router and its associated applications. 7659 'eepsite' - an example webserver (Jetty) Included in the i2pinstall and i2pupdate packages - may be disabled if another webserver is available. May be configured on the page eepsite and disabled on the page i2ptunnel 7660 I2PTunnel UDP port for SSH Required for Grizzled's/novg's UDP support. Instances disabled by default. May be enabled/disabled and configured to use a different port on the page i2ptunnel. 123 NTP Port Used by NTP Time Sync. May be disabled/changed. ### 我的地址簿中缺少很多主机。有哪些好的订阅链接？{#subscriptions} 地址簿位于 http://localhost:7657/dns ，在那里可以找到更多信息。\n有哪些好的地址簿订阅链接？\n您可以尝试以下操作：\nhttp://stats.i2p/cgi-bin/newhosts.txt http://identiguy.i2p/hosts.txt 如何从其他机器访问 web 控制台或为其设置密码保护？ 出于安全考虑，router 的管理控制台默认仅监听本地接口上的连接。\n有两种方法可以远程访问控制台：\nSSH 隧道 配置您的控制台以使用用户名和密码在公共 IP 地址上可用 详细说明如下：\n方法 1：SSH 隧道\n如果你运行的是类 Unix 操作系统,这是远程访问 I2P 控制台最简单的方法。(注意:运行 Windows 的系统也可以使用 SSH 服务器软件,例如 https://github.com/PowerShell/Win32-OpenSSH )\n一旦你配置好了对系统的 SSH 访问，可以使用 \u0026lsquo;-L\u0026rsquo; 参数传递给 SSH 并附带适当的参数 - 例如：\nssh -L 7657:localhost:7657 (System_IP) 其中 \u0026lsquo;(System_IP)\u0026rsquo; 替换为你的系统 IP 地址。此命令将端口 7657(第一个冒号前的数字)转发到远程系统的(由第一个和第二个冒号之间的字符串 \u0026rsquo;localhost\u0026rsquo; 指定)端口 7657(第二个冒号后的数字)。你的远程 I2P 控制台现在将在本地系统上以 \u0026lsquo;http://localhost:7657\u0026rsquo; 的形式可用,并且在 SSH 会话处于活动状态期间一直可用。\n如果您想启动 SSH 会话而不在远程系统上启动 shell，可以添加 \u0026lsquo;-N\u0026rsquo; 标志：\nssh -NL 7657:localhost:7657 (System_IP) 方法 2：配置控制台在公共 IP 地址上可用，并使用用户名和密码\n打开 ~/.i2p/clients.config 并替换：\nclientApp.0.args=7657 ::1,127.0.0.1 ./webapps/ 为：\nclientApp.0.args=7657 ::1,127.0.0.1,(System_IP) ./webapps/ 其中将 (System_IP) 替换为您系统的公网 IP 地址\n访问 http://localhost:7657/configui ,如果需要,可以添加控制台用户名和密码 - 强烈建议添加用户名和密码来保护您的 I2P 控制台免受篡改,这可能导致去匿名化。\n访问 http://localhost:7657/index 并点击\u0026quot;优雅重启\u0026quot;，这将重启 JVM 并重新加载客户端应用程序\n启动后,你现在应该能够远程访问控制台了。在浏览器中打开 router console,地址为 http://(System_IP):7657,如果你的浏览器支持身份验证弹窗,系统将提示你输入在上述第2步中指定的用户名和密码。\n注意：您可以在上述配置中指定 0.0.0.0。这指定的是一个接口，而不是网络或网络掩码。0.0.0.0 意味着\u0026quot;绑定到所有接口\u0026quot;，因此它可以在 127.0.0.1:7657 以及任何局域网/广域网 IP 上访问。使用此选项时请小心，因为控制台将在系统上配置的所有地址上可用。\n如何在其他机器上使用应用程序？ 请参阅前面关于使用 SSH 端口转发的说明，并查看控制台中的此页面：http://localhost:7657/configi2cp 是否可以将 I2P 用作 SOCKS 代理？ SOCKS 代理自 0.7.1 版本起就已经可以正常工作。支持 SOCKS 4/4a/5 协议。I2P 没有 SOCKS outproxy,因此仅限于在 I2P 内部使用。\n许多应用程序会泄露可能在互联网上识别您身份的敏感信息,这是使用 I2P SOCKS 代理时应该注意的风险。I2P 只过滤连接数据,但如果您打算运行的程序将这些信息作为内容发送,I2P 就无法保护您的匿名性。例如,某些邮件应用程序会将其运行所在机器的 IP 地址发送到邮件服务器。我们推荐使用 I2P 专用工具或应用程序(例如用于种子下载的 I2PSnark ),或已知可安全用于 I2P 的应用程序,包括 Firefox 上的流行插件。\n如何访问常规互联网上的 IRC、BitTorrent 或其他服务？ 有一些称为 Outproxy 的服务在 I2P 和互联网之间架起桥梁,类似于 Tor 的出口节点。HTTP 和 HTTPS 的默认 outproxy 功能由 exit.stormycloud.i2p 提供,由 StormyCloud Inc. 运营。它在 HTTP 代理中配置。此外,为了帮助保护匿名性,I2P 默认不允许你与常规互联网建立匿名连接。更多信息请参阅 Socks Outproxy 页面。\nReseeds（种子节点） 我的 router 已经运行了几分钟，但是连接数为零或者非常少 首先检查 Router Console 中的 http://127.0.0.1:7657/netdb 页面 – 你的网络数据库。如果你在 I2P 内没有看到任何列出的 router，但控制台显示你应该被防火墙阻挡，那么你可能无法连接到 reseed 服务器。如果你确实看到列出了其他 I2P routers，那么尝试在 http://127.0.0.1:7657/config 降低最大连接数，也许你的 router 无法处理太多连接。\n如何手动重新播种？ 在正常情况下，I2P 会使用我们的引导链接自动将您连接到网络。如果网络中断导致从重新种子服务器引导失败，一种简单的引导方法是使用 Tor 浏览器（默认情况下它会打开 localhost），它与 http://127.0.0.1:7657/configreseed 配合得很好。手动为 I2P router 重新种子也是可行的。\n当使用 Tor 浏览器进行 reseed 时,您可以一次选择多个 URL 并继续操作。虽然默认值为 2(从多个 URL 中选择)也能正常工作,但速度会比较慢。\n隐私安全 我的 router 是通向常规互联网的\u0026quot;出口节点\u0026quot;(outproxy)吗?我不希望它成为出口节点。 不会，你的 router 参与在 I2P 网络中传输端到端加密流量到随机的 tunnel 端点，通常不是 outproxy，但不会在传输层上在你的 router 和互联网之间传递流量。作为最终用户，如果你不精通系统和网络管理，就不应该运行 outproxy。\n通过分析网络流量是否容易检测到 I2P 的使用？ I2P 流量通常看起来像 UDP 流量,仅此而已——让它看起来不那么显眼正是我们的目标。它也支持 TCP。通过一些努力,被动流量分析可能能够将流量分类为\u0026quot;I2P\u0026quot;,但我们希望流量混淆技术的持续发展能进一步减少这种情况。即使是像 obfs4 这样相当简单的协议混淆层也能防止审查者封锁 I2P(这是 I2P 部署的目标)。\n使用 I2P 安全吗？ 这取决于你的个人威胁模型。对于大多数人来说,I2P 比不使用任何保护要安全得多。某些其他网络(如 Tor、mixminion/mixmaster)在面对某些攻击者时可能更安全。例如,I2P 流量不使用 TLS/SSL,因此不存在 Tor 那样的\u0026quot;最弱环节\u0026quot;问题。在\u0026quot;阿拉伯之春\u0026quot;期间,叙利亚有很多人使用 I2P,最近该项目在中东和近东地区较小语言版本的 I2P 安装中出现了更大的增长。这里最重要的一点是,I2P 是一项技术,你需要操作指南来增强你在互联网上的隐私/匿名性。还要检查你的浏览器或导入指纹搜索引擎,通过一个非常庞大(意味着:典型的长尾/非常精确的多样化数据结构)的环境数据集来阻止指纹攻击,并且不要使用 VPN 以减少其自身带来的所有风险,如自身的 TLS 缓存行为以及提供商业务的技术架构,这些比自己的桌面系统更容易被黑客攻击。在公共网络和高度个人化风险模型中,使用具有出色反指纹保护的隔离 Tor V-Browser,配合全面的应用防护实时保护(仅允许必要的系统通信),以及最后采用反间谍禁用脚本和 Live CD 的虚拟机使用来消除任何\u0026quot;几乎永久性的可能风险\u0026quot;,通过降低概率来减少所有风险,这可能是一个不错的选择,也可能是你在使用 I2P 时为实现此目标所能做的最好选择。\n我在 router 控制台中看到了所有其他 I2P 节点的 IP 地址。这是否意味着我的 IP 地址也会被其他人看到？ 是的,对于知道你的 router 的其他 I2P 节点来说是这样。我们使用这些信息与 I2P 网络的其余部分建立连接。这些地址实际上位于\u0026quot;routerInfos(键值对)对象\u0026quot;中,可以是远程获取的或从对等节点接收的。\u0026ldquo;routerInfos\u0026quot;包含一些信息(部分是可选的机会性添加的),\u0026ldquo;由对等节点发布\u0026rdquo;,关于 router 本身的引导信息。此对象中不包含关于客户端的数据。深入了解底层实现会发现,所有人都使用最新的 ID 创建方式进行计数,称为\u0026quot;SHA-256 哈希(低位=正哈希(-键),高位=负哈希(+键))\u0026quot;。I2P 网络有自己的 routerInfos 数据库,在上传和索引期间创建,但这深度依赖于键值表的实现、网络拓扑、负载状态/带宽状态以及数据库组件中存储的路由概率。\n使用出口代理安全吗？ 这取决于你对\u0026quot;安全\u0026quot;的定义。Outproxy（出口代理）在正常工作时很好用,但不幸的是它们是由志愿者运行的,这些人可能会失去兴趣或可能没有资源来维持 24/7 运行——请注意,你可能会经历服务不可用、中断或不可靠的时期,我们与此服务无关,也无法对其施加影响。\noutproxy 本身可以看到你的流量进出，但端到端加密的 HTTPS/SSL 数据除外，就像你的 ISP 可以看到你的计算机的流量进出一样。如果你信任你的 ISP，那么 outproxy 也不会更糟。\n关于\u0026quot;去匿名化\u0026quot;攻击怎么样？ 如需了解详细说明，请阅读我们关于威胁模型 的文章。一般来说，去匿名化并非易事，但如果你不够谨慎，仍然有可能发生。\n互联网访问/性能 我无法通过 I2P 访问常规互联网站点。 代理到互联网站点（指向互联网的 eepsite）是由非屏蔽提供商作为服务提供给 I2P 用户的。这项服务并非 I2P 开发的主要重点，而是在自愿的基础上提供的。托管在 I2P 上的 eepsite 应该始终能够在没有出口代理的情况下正常工作。出口代理是一种便利设施，但按照设计它们并不完美，也不是项目的主要组成部分。请注意，它们可能无法提供 I2P 其他服务所能提供的高质量服务。\n我无法通过 I2P 访问 https:// 或 ftp:// 站点。 默认的 HTTP 代理仅支持 HTTP 和 HTTPS 出站代理。\n为什么我的 router 占用过多 CPU？ 首先，确保您拥有所有 I2P 相关部分的最新版本——旧版本的代码中存在不必要的高 CPU 消耗部分。此外，还有一个性能日志 记录了 I2P 性能随时间改进的一些情况。\n我的活跃节点/已知节点/参与的隧道/连接数/带宽随时间变化很大！有什么问题吗？ I2P 网络的整体稳定性是一个持续研究的领域。其中相当一部分研究集中在配置设置的微小变化如何改变 router 的行为。由于 I2P 是一个点对点网络，其他节点的行为会对你的 router 性能产生影响。\n与常规互联网相比，是什么导致 I2P 上的下载、种子、网页浏览和其他所有操作都变慢？ I2P具有不同的保护机制，增加了额外的路由和多层加密。它还会通过其他节点（Tunnels）来跳转流量，这些节点各有不同的速度和质量，有些慢，有些快。这导致大量的开销和不同方向上不同速度的流量。从设计上来说，所有这些因素都会使其相比互联网直接连接更慢，但匿名性大大提高，而且对于大多数用途来说仍然足够快。\n下面是一个示例，附带解释以帮助理解使用 I2P 时的延迟和带宽注意事项。\n考虑下面的图表。它描绘了一个客户端通过 I2P 发起请求、服务器通过 I2P 接收请求并通过 I2P 响应的连接过程。请求传输所经过的电路也在图中展示。\n从图中可以看出,标记为\u0026quot;P\u0026rdquo;、\u0026ldquo;Q\u0026quot;和\u0026quot;R\u0026quot;的方框代表\u0026quot;A\u0026quot;的出站 tunnel,而标记为\u0026quot;X\u0026rdquo;、\u0026ldquo;Y\u0026quot;和\u0026quot;Z\u0026quot;的方框代表\u0026quot;B\u0026quot;的出站 tunnel。同样,标记为\u0026quot;X\u0026rdquo;、\u0026ldquo;Y\u0026quot;和\u0026quot;Z\u0026quot;的方框代表\u0026quot;B\u0026quot;的入站 tunnel,而标记为\u0026quot;P_1\u0026rdquo;、\u0026ldquo;Q_1\u0026quot;和\u0026quot;R_1\u0026quot;的方框代表\u0026quot;A\u0026quot;的入站 tunnel。方框之间的箭头显示流量方向。箭头上方和下方的文本详细说明了一对跳点之间的示例带宽以及示例延迟。\n当客户端和服务器端都使用3跳tunnel时,总共有12个其他I2P router参与流量中继。6个节点将流量从客户端中继到服务器,流量被分为从\u0026rsquo;A\u0026rsquo;出发的3跳outbound tunnel(\u0026lsquo;P\u0026rsquo;、\u0026lsquo;Q\u0026rsquo;、\u0026lsquo;R\u0026rsquo;)和到达\u0026rsquo;B\u0026rsquo;的3跳inbound tunnel(\u0026lsquo;X\u0026rsquo;、\u0026lsquo;Y\u0026rsquo;、\u0026lsquo;Z\u0026rsquo;)。同样,另外6个节点将流量从服务器中继回客户端。\n首先，我们可以考虑延迟——客户端的请求穿越 I2P 网络、到达服务器并返回到客户端所需的时间。将所有延迟累加起来，我们可以看到：\n40 + 100 + 20 + 60 + 80 + 10 + 30 ms (client to server) + 60 + 40 + 80 + 60 + 100 + 20 + 40 ms (server to client) ----------------------------------- TOTAL: 740 ms 在我们的示例中,总往返时间累计为 740 毫秒 - 这显然比浏览常规互联网网站时通常看到的延迟要高得多。\n其次，我们可以考虑可用带宽。这取决于客户端和服务器之间跃点的最慢链路，以及服务器向客户端传输流量时的情况。对于从客户端到服务器的流量，我们在示例中看到跃点 \u0026lsquo;R\u0026rsquo; 和 \u0026lsquo;X\u0026rsquo; 之间以及跃点 \u0026lsquo;X\u0026rsquo; 和 \u0026lsquo;Y\u0026rsquo; 之间的可用带宽为 32 KB/s。尽管其他跃点之间有更高的可用带宽，但这些跃点将成为瓶颈，并将从 \u0026lsquo;A\u0026rsquo; 到 \u0026lsquo;B\u0026rsquo; 的流量的最大可用带宽限制在 32 KB/s。同样，追踪从服务器到客户端的路径显示，最大带宽为 64 KB/s - 位于跃点 \u0026lsquo;Z_1\u0026rsquo; 和 \u0026lsquo;Y_1\u0026rsquo; 之间、\u0026lsquo;Y_1\u0026rsquo; 和 \u0026lsquo;X_1\u0026rsquo; 之间以及 \u0026lsquo;Q_1\u0026rsquo; 和 \u0026lsquo;P_1\u0026rsquo; 之间。\n我们建议您提高带宽限制。这有助于网络增加可用带宽,进而改善您的I2P使用体验。带宽设置位于http://localhost:7657/config 页面。请注意您的ISP(互联网服务提供商)所规定的网络连接限制,并相应调整您的设置。\n我们还建议设置足够的共享带宽 - 这允许参与隧道通过您的 I2P router 进行路由。允许参与流量可以使您的 router 更好地融入网络并提高您的传输速度。\nI2P 仍在持续开发中。大量的改进和修复正在实施，一般来说，运行最新版本将有助于提升性能。如果您还没有更新，请安装最新版本。\n我认为我发现了一个错误，我可以在哪里报告它？ 您可以在我们的问题跟踪系统上报告遇到的任何错误/问题,该系统可通过公网和I2P访问。我们还有一个讨论论坛,同样可以通过I2P和公网访问。您也可以加入我们的IRC频道:可以通过我们的IRC网络IRC2P,或者通过Freenode。\n我们的 Bugtracker: 非私有互联网: https://i2pgit.org/I2P_Developers/i2p.i2p/issues 在 I2P 上: http://git.idk.i2p/I2P_Developers/i2p.i2p/issues 我们的论坛: i2pforum.i2p 粘贴日志: 您可以将任何有用的日志粘贴到粘贴服务,例如 PrivateBin Wiki 上列出的非私有互联网服务,或 I2P 粘贴服务,例如这个 PrivateBin 实例 或这个 无 Javascript 粘贴服务 ,然后在 IRC 的 #i2p 频道跟进 IRC: 加入 #i2p-dev 在 IRC 上与开发者讨论 请包含来自 router 日志页面的相关信息,该页面位于:http://127.0.0.1:7657/logs 。我们请求您分享\u0026quot;I2P Version and Running Environment\u0026quot;部分下的所有文本,以及页面上显示的各种日志中的任何错误或警告信息。\n我有一个问题！ 太好了！在 IRC 上找到我们：\n在 irc.freenode.net 频道 #i2p 在 IRC2P 频道 #i2p 或者在论坛 发帖，我们会将其发布在这里（希望能附上答案）。\n","description":"I2P 综合常见问题解答：router 帮助、配置、重新播种、隐私/安全、性能和故障排除","id":"b0f8e4ee3509d229b406a0b0bb933ca4","section":"docs","title":"常见问题","url":"/zh/docs/overview/faq/"},{"categories":null,"content":" 1. 概述 在 I2P 中，传输 是在 routers 之间进行直接、点对点通信的方法。这些机制在验证 router 的身份的同时，确保机密性和完整性。\n每种传输都基于具备认证、流量控制、确认和重传能力的连接范式运行。\n2. 当前传输协议 I2P 目前支持两种主要的传输协议：\nTransport Protocol Description NTCP2 TCP Noise-based TCP transport with modern encryption (as of 0.9.36) SSU2 UDP Secure Semireliable UDP with modern encryption (as of 0.9.56) ### 2.1 旧版传输（已弃用） Transport Protocol Status NTCP TCP Replaced by NTCP2; removed in 0.9.62 SSU UDP Replaced by SSU2; removed in 0.9.62 --- 3. 传输服务 传输子系统提供以下服务：\n3.1 消息传递 可靠的 I2NP 消息投递（transports（传输层/传输模块）仅处理 I2NP 消息） 在所有情况下不保证按序交付 基于优先级的消息排队 3.2 连接管理 连接建立与关闭 带有阈值强制执行的连接上限管理 按对等节点的状态跟踪 自动与手动的对等节点封禁列表执行 3.3 网络配置 每种传输可使用多个 router 地址 (自 v0.9.8 起支持 IPv4 和 IPv6) 通过 UPnP 打开防火墙端口 支持 NAT/防火墙穿透 通过多种方法检测本地 IP 3.4 安全 用于点对点交换的加密 按本地规则进行 IP 地址验证 时钟共识确定 (NTP 作为后备) 3.5 带宽管理 入站和出站带宽限制 针对出站消息的最佳传输选择 4. 传输地址 该子系统维护 router 的联系点列表：\n传输方式 (NTCP2, SSU2) IP 地址 端口号 可选参数 每种传输方式可以有多个地址。\n4.1 常见地址配置 Configuration Description Hidden Routers with no published addresses Firewalled Routers publishing SSU2 addresses with \"introducer\" peer lists for NAT traversal Unrestricted Routers advertising both NTCP2 and SSU2 addresses on IPv4 and/or IPv6 --- 5. 传输协议选择 系统在不依赖上层协议的情况下，为I2NP messages 选择传输方式。选择采用一种竞价机制，每种传输方式提交出价，数值最低者获胜。\n5.1 出价确定因素 传输偏好设置 现有对等方连接 当前连接数与阈值的对比 近期连接尝试历史 消息大小限制 对等方 RouterInfo 的传输能力 连接的直接性（直接连接与依赖 introducer（引介者）的连接） 对等方公告的传输偏好 通常，两台 routers 会同时维持单一传输方式的连接，但也可以同时建立多传输方式的连接。\n6. NTCP2 NTCP2 (新传输协议 2) 是 I2P 的现代化、基于 TCP 的传输协议，首次在 0.9.36 版本中引入。\n6.1 关键特性 基于 Noise Protocol Framework（Noise 协议框架）（Noise_XK 模式） 使用 X25519 进行密钥交换 使用 ChaCha20/Poly1305 进行认证加密 使用 BLAKE2s 进行哈希 协议混淆以抵抗 DPI（深度包检测） 可选填充以抵抗流量分析 6.2 连接建立 会话请求 (Alice → Bob): 临时 X25519 密钥 + 加密的有效负载 会话已创建 (Bob → Alice): 临时密钥 + 加密的确认 会话确认 (Alice → Bob): 包含 RouterInfo（路由器信息）的最终握手 所有后续数据均使用从握手中派生的会话密钥进行加密。\n有关完整细节，请参见 NTCP2 规范 。\n7. SSU2 SSU2 (安全、半可靠的 UDP 2) 是用于 I2P 的现代、基于 UDP 的传输协议，在 0.9.56 版本中引入。\n7.1 关键特性 基于 Noise 协议框架 (Noise_XK 模式) 使用 X25519 进行密钥交换 使用 ChaCha20/Poly1305 进行认证加密 带选择性确认的半可靠传输 通过打洞和中继/引入实现 NAT 穿越 支持连接迁移 路径 MTU 发现 7.2 相较于 SSU (旧版) 的优势 Feature SSU (Legacy) SSU2 Encryption ElGamal + AES X25519 + ChaCha20/Poly1305 Header encryption Partial Full (ChaCha20) Connection ID Fixed Encrypted, rotatable NAT traversal Basic introduction Enhanced hole punching + relay Obfuscation Minimal Improved (variable padding) 有关完整详情，请参阅 [SSU2 规范](/docs/specs/ssu2/)。 8. NAT 穿越 两种传输协议均支持 NAT 穿透，以便位于防火墙之后的 router 也能参与网络。\n8.1 SSU2 介绍 当 router 无法直接接收入站连接时：\nRouter 在其 RouterInfo 中发布 introducer（介绍者）地址 发起连接的对等节点向 introducer 发送介绍请求 Introducer 将连接信息转发给处于防火墙后的 Router 处于防火墙后的 Router 发起出站连接（打洞） 建立直接通信 8.2 NTCP2 与防火墙 NTCP2 需要入站 TCP 连通性。位于 NAT（网络地址转换）后的 Routers 可以:\n使用 UPnP 自动打开端口 手动配置端口转发 依赖 SSU2 处理入站连接，同时使用 NTCP2 处理出站连接 9. 协议混淆 这两种现代传输协议都包含混淆功能：\n随机填充 在握手消息中 加密的头部，不暴露协议指纹 可变长度的消息 以抵抗流量分析 无固定模式 在连接建立过程中 注意：传输层混淆起到补充作用，但不能替代 I2P 的 tunnel 架构所提供的匿名性。\n10. 未来开发 计划中的研究和改进包括：\n可插拔传输 – 兼容 Tor 的混淆插件 基于 QUIC 的传输 – 研究 QUIC 协议的优势 连接数上限优化 – 研究最佳的对等节点连接数上限 增强型填充策略 – 提升抗流量分析能力 11. 参考资料 NTCP2 规范 – 基于 Noise 的 TCP 传输（Noise 协议框架） SSU2 规范 – 安全的半可靠 UDP 2 I2NP 规范 – I2P 网络协议消息 通用结构 – RouterInfo 和地址结构 NTCP 历史讨论 – 旧版传输的开发历史 遗留 SSU 文档 – 原始 SSU 规范（已弃用） ","description":"理解 I2P 的传输层 - router 之间的点对点通信方法，包括 NTCP2 和 SSU2","id":"5fbac972dc212081634c49c5e6ac0004","section":"docs","title":"传输层","url":"/zh/docs/overview/transport/"},{"categories":null,"content":"什么是 Eepsite（I2P 上的隐藏网站）？ eepsite 是仅存在于 I2P 网络中的网站（I2P 内部网站）。与可通过明网（clearnet）访问的传统网站不同，eepsite 只能通过 I2P 访问，为站点运营者和访问者提供匿名性与隐私保护。Eepsites 使用 .i2p 伪顶级域名，并可通过特殊的 .b32.i2p 地址或在 I2P 地址簿中注册的人类可读名称进行访问。\n所有 Java I2P 部署都预装并预配置了 Jetty ，一款轻量级的基于 Java 的 Web 服务器。这使您能够在几分钟内轻松开始托管自己的 eepsite——无需额外安装任何软件。\n本指南将带你逐步完成使用 I2P 内置工具创建并配置你的第一个 eepsite（I2P 上的匿名网站）的过程。\n步骤 1：访问隐藏服务管理器 隐藏服务管理器（也称为 I2P Tunnel Manager）是用于配置所有 I2P 服务器和客户端 tunnels 的地方，包括 HTTP 服务器（eepsites）。\n打开你的 I2P Router Console 前往 隐藏服务管理器 你应该会看到隐藏服务管理器界面显示: - 状态消息 - 当前 tunnel 和客户端状态 - 全局 Tunnel 控制 - 用于一次性管理所有 tunnels 的按钮 - I2P 隐藏服务 - 已配置的服务器 tunnels 列表\n默认情况下，你会看到一个已配置但未启动的 I2P Web 服务器 条目。这是一个已预先配置、可供你使用的 Jetty Web 服务器。\n步骤 2：配置你的 Eepsite（I2P 上的匿名网站）服务器设置 在隐藏服务列表中点击 I2P Web 服务器 条目以打开服务器配置页面。你可以在这里自定义你的 eepsite 设置。\n配置选项详解 Name - 这是你的 tunnel 的内部标识符 - 在你运行多个 eepsites 时，这有助于分辨哪个是哪个 - 默认: \u0026ldquo;I2P webserver\u0026rdquo;\nDescription - 对你的 eepsite 的简要描述，供你自己参考 - 仅在 Hidden Services Manager（隐藏服务管理器）中对你可见 - 示例: \u0026ldquo;My eepsite\u0026rdquo; 或 \u0026ldquo;Personal blog\u0026rdquo;\n自动启动 Tunnel - 重要：选中此复选框可在 I2P router 启动时自动启动您的 eepsite - 确保在 router 重启后无需人工干预，您的站点仍保持可用 - 建议：启用\n目标（主机和端口） - 主机：您的 Web 服务器运行所在的本地地址（默认：127.0.0.1） - 端口：您的 Web 服务器监听的端口（默认：Jetty 使用 7658） - 如果您使用的是预装的 Jetty Web 服务器，请将这些保持为默认值 - 仅在您在其他端口上运行自定义 Web 服务器时才需要更改\n网站主机名 - 这是你的 eepsite 的人类可读 .i2p 域名 - 默认：mysite.i2p（占位符） - 你可以注册一个自定义域名，例如 stormycloud.i2p 或 myblog.i2p - 如果你只想使用自动生成的 .b32.i2p 地址（供 outproxies（出口代理）使用），请留空 - 有关如何申领自定义主机名，请参见下文的注册你的 I2P 域名 Local Destination - 这是你的 eepsite 的唯一加密标识（Destination 地址） - 在首次创建 tunnel 时自动生成 - 可以把它看作你的网站在 I2P 上的永久“IP 地址” - 那串很长的字母数字字符串是你的网站 .b32.i2p 地址的编码形式\n私钥文件 - 你的 eepsite 私钥的存放位置 - 默认：eepsite/eepPriv.dat - 请确保此文件安全 - 任何能够访问此文件的人都可以冒充你的 eepsite - 切勿共享或删除此文件\n重要说明 黄色警告框提醒你：要启用二维码生成或注册认证功能，必须配置一个带有 .i2p 后缀的网站主机名（例如，mynewsite.i2p）。\n步骤 3：高级网络选项（可选） 如果你在配置页面向下滚动，你会发现高级网络选项。这些设置是可选的 - 默认设置对大多数用户来说效果良好。不过，你可以根据你的安全需求和性能需求进行调整。\nTunnel 长度选项 Tunnel 长度 - 默认: 3 跳 tunnel（高匿名性） - 控制请求在到达你的 eepsite 之前要经过多少个 router 跳 - 跳数越多 = 匿名性越高，但性能更慢 - 跳数越少 = 性能更快，但匿名性降低 - 选项范围为 0–3 跳，并可设置可变范围（variance） - 建议: 除非有特定的性能需求，请保持为 3 跳\nTunnel 变动范围 - 默认：0 跳数变动（无随机化，性能稳定） - 为提升安全性，在 tunnel 长度上加入随机化 - 示例：\u0026ldquo;0-1 hop variance\u0026rdquo; 表示 tunnels 将随机为 3 或 4 跳 - 提高不可预测性，但可能导致加载时间不一致\nTunnel 数量选项 数量 (入站/出站 tunnels) - 默认: 2 个入站、2 个出站 tunnels (标准带宽与可靠性) - 控制为你的 eepsite 分配的并行 tunnels 数量 - 更多 tunnels = 更好的可用性与负载处理能力，但资源占用更高 - 更少的 tunnels = 更低的资源占用，但冗余降低 - 大多数用户的建议值：2/2（默认） - 高流量站点使用 3/3 或更高可能更有利\n备份数量 - 默认: 0 个备份 tunnels（通道）（无冗余，不增加资源占用） - 主 tunnels 故障时自动启用的待机 tunnels - 提高可靠性，但会消耗更多带宽和 CPU - 大多数个人 eepsites（I2P 站点）不需要备份 tunnels\nPOST 限制 如果你的 eepsite 包含表单（联系表单、评论区、文件上传等），可以配置 POST 请求限制以防止滥用：\n每个客户端的限制 - 每个周期: 来自单个客户端的最大请求数（默认：每 5 分钟 6 次） - 封禁时长: 封禁滥用客户端的持续时间（默认：20 分钟）\n总限制 - 总量：所有客户端合计的最大 POST 请求数（默认：每5分钟20次） - 封禁时长：超过限制时拒绝所有 POST 请求的持续时间（默认：10分钟）\nPOST 限制周期 - 用于衡量请求速率的时间窗口 (默认: 5 分钟)\n这些限制有助于防范垃圾信息、拒绝服务攻击以及对自动化表单提交的滥用。\n何时调整高级设置 高流量社区站点: 增加 tunnel 数量 (3-4 条入站/出站) 性能关键型应用: 将 tunnel 长度降至 2 跳 (存在隐私权衡) 需要最大匿名性: 保持 3 跳，增加 0-1 的随机偏差 存在正当高频使用的表单: 相应提高 POST 限制 个人博客/作品集: 使用全部默认设置 步骤 4：向你的 Eepsite（I2P 内部网站）添加内容 现在你的 eepsite 已经配置完成，你需要将你的网站文件（HTML、CSS、图像等）添加到 Web 服务器的文档根目录中。其位置会因操作系统、安装类型以及 I2P 实现而有所不同。\n查找您的文档根目录 网站根目录（通常称为 docroot）是存放你的网站全部文件的文件夹。你的 index.html 文件应直接放在该文件夹中。\nJava I2P（标准发行版） Linux - 标准安装: ~/.i2p/eepsite/docroot/ - 软件包安装（作为服务运行）: /var/lib/i2p/i2p-config/eepsite/docroot/\nWindows - 标准安装: %LOCALAPPDATA%\\I2P\\eepsite\\docroot\\ - 典型路径: C:\\Users\\YourUsername\\AppData\\Local\\I2P\\eepsite\\docroot\\ - Windows 服务安装: %PROGRAMDATA%\\I2P\\eepsite\\docroot\\ - 典型路径: C:\\ProgramData\\I2P\\eepsite\\docroot\\\nmacOS - 标准安装: /Users/YourUsername/Library/Application Support/i2p/eepsite/docroot/\nI2P+（I2P 增强型发行版） I2P+ 使用与 Java I2P 相同的目录结构。请根据您的操作系统，按照上面的路径进行操作。\ni2pd (C++ 实现) Linux/Unix - 默认: /var/lib/i2pd/eepsite/ 或 ~/.i2pd/eepsite/ - 请检查你的 i2pd.conf 配置文件，在你的 HTTP 服务器 tunnel 下查看实际的 root 设置\nWindows - 在 i2pd 安装目录中检查 i2pd.conf\nmacOS - 通常位于： ~/Library/Application Support/i2pd/eepsite/\n添加您的网站文件 前往你的站点根目录，使用文件管理器或终端 将你的网站文件创建或复制到 docroot 文件夹中 至少创建一个 index.html 文件（这是你的主页） 按需添加 CSS、JavaScript、图像和其他资源 像为任何网站那样组织子目录： docroot/ ├── index.html ├── about.html ├── css/ │ └── style.css ├── images/ │ └── logo.png └── js/ └── script.js 快速开始：简单的 HTML 示例 如果你刚开始使用，请在你的 docroot 文件夹中创建一个基本的 index.html 文件：\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;My I2P Eepsite\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Welcome to My Eepsite!\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;This is my first website on the I2P network.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Privacy-focused and decentralized!\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 权限 (Linux/Unix/macOS) 如果你以服务或不同用户身份运行 I2P，请确保 I2P 进程对您的文件具有读取权限：\n# Set appropriate ownership (if running as i2p user) sudo chown -R i2p:i2p /var/lib/i2p/i2p-config/eepsite/docroot/ # Or set readable permissions for all users chmod -R 755 ~/.i2p/eepsite/docroot/ 提示 默认内容: 首次安装 I2P 时，docroot 目录中已经包含示例内容 - 你可以随意替换 静态站点效果最好: 虽然 Jetty 支持 Servlet 和 JSP，简单的 HTML/CSS/JavaScript 站点最易于维护 外部 Web 服务器: 高级用户可以在不同端口上运行自定义的 Web 服务器（Apache、Nginx、Node.js 等），并将 I2P tunnel 指向它们 第 5 步：启动你的 Eepsite 既然你的 eepsite（I2P 站点）已经配置完成并且有了内容，现在是时候启动它，并让它在 I2P 网络上可访问了。\n启动 Tunnel 返回到 隐藏服务管理器 在列表中找到你的 I2P Web 服务器 条目 在控制列中点击 启动 按钮 等待 Tunnel 建立 点击“开始”后，你的 eepsite tunnel 将开始构建。这个过程通常需要 30-60 秒。请留意状态指示器：\n红灯 = Tunnel 启动/构建中 黄灯 = Tunnel 部分已建立 绿灯 = Tunnel 完全运行并就绪 当你看到绿色指示灯时，你的 eepsite 已在 I2P 网络上线！\n访问你的 Eepsite 点击正在运行的 eepsite 旁边的 Preview 按钮。这会在浏览器中打开一个新标签页，显示你的 eepsite 地址。\n您的 eepsite 有两种类型的地址：\nBase32 地址 (.b32.i2p): 一个看起来像这样的较长的加密地址：\nhttp://fcyianvr325tdgiiueyg4rsq4r5iuibzovl26msox5ryoselykpq.b32.i2p 这是你的 eepsite（I2P 上的隐藏网站）的永久、基于密码学生成的地址 它无法更改，并且与你的私钥绑定 即使没有域名注册也始终可用 人类可读的域名（.i2p）：如果你设置了网站主机名（例如，testwebsite.i2p）\n仅在完成域名注册后可用（见下一节） 更易记忆和分享 映射到你的 .b32.i2p 地址 Copy Hostname 按钮可让你快速复制你的完整 .b32.i2p 地址以便分享。\n⚠️ 重要：务必备份你的私钥 在继续之前，你必须备份你的 eepsite（I2P 上的网站）的私钥文件。这因多种原因而至关重要：\n为什么要备份你的密钥？ 你的私钥（eepPriv.dat）就是你的 eepsite（I2P 内部网站）的身份。 它决定你的 .b32.i2p 地址，并证明你对 eepsite 的所有权。\n密钥 = .b32 address（.b32 地址）: 您的私钥会通过数学方式生成您唯一的 .b32.i2p 地址 无法恢复: 如果您丢失了密钥，您将永久失去该 eepsite 地址 不可更改: 如果您注册了一个指向 .b32 address 的域名，无法更新 - 注册是永久性的 迁移所需: 迁移到新电脑或重新安装 I2P 需要此密钥，才能保持相同的地址 支持 Multihoming（多宿主部署）: 要从多个地点运行您的 eepsite，需要在每台服务器上使用相同的密钥 私钥在哪里？ 默认情况下，您的私钥存储在： - Linux: ~/.i2p/eepsite/eepPriv.dat (或 对于服务安装为 /var/lib/i2p/i2p-config/eepsite/eepPriv.dat) - Windows: %LOCALAPPDATA%\\I2P\\eepsite\\eepPriv.dat 或 %PROGRAMDATA%\\I2P\\eepsite\\eepPriv.dat - macOS: /Users/YourUsername/Library/Application Support/i2p/eepsite/eepPriv.dat\n您也可以在您的 tunnel 配置中的“Private Key File”项查看/更改此路径。\n如何备份 停止你的 tunnel (可选，但更安全) 复制 eepPriv.dat 到安全的位置: 外接 USB 驱动器 加密的备份驱动器 受密码保护的归档 安全的云存储 (已加密) 保留多份备份，放在不同的物理地点 切勿分享此文件 - 任何拥有它的人都可以冒充你的 eepsite 从备份恢复 要在新系统上或重新安装后恢复您的 eepsite：\n安装 I2P 并创建/配置你的 tunnel 设置 停止 tunnel，再复制密钥 将你备份的 eepPriv.dat 复制到正确的位置 启动 tunnel - 它将使用你原来的 .b32 地址 如果你不注册域名 恭喜！ 如果你不打算注册自定义的 .i2p 域名，你的 eepsite（I2P 隐藏网站）现在已经完成并可以正常运行了。\n你可以： - 与他人分享你的 .b32.i2p 地址 - 使用任何支持 I2P 的浏览器通过 I2P 网络访问你的网站 - 随时在 docroot 文件夹中更新你的网站文件 - 在隐藏服务管理器中监控你的 tunnel 状态\n如果你想要一个人类可读的域名 (例如 mysite.i2p，而不是冗长的 .b32 地址)，请继续到下一节。\n注册您的 I2P 域名 人类可读的 .i2p 域名（例如 testwebsite.i2p）比冗长的 .b32.i2p 地址更容易记忆和分享。域名注册是免费的，并会将你选择的名称关联到你的 eepsite（I2P 隐藏站点）的加密地址。\n先决条件 您的 eepsite（I2P 隐藏站点）必须处于绿灯状态 您必须在 tunnel（隧道）配置中设置 Website Hostname（步骤 2） 例如：testwebsite.i2p 或 myblog.i2p 步骤 1：生成认证字符串 返回到你的 tunnel 配置，在 Hidden Services Manager（隐藏服务管理器）中 点击你的 I2P webserver（I2P Web 服务器） 条目以打开设置 向下滚动，找到 Registration Authentication（注册认证） 按钮 点击 Registration Authentication 复制完整的身份验证字符串，该字符串显示在 \u0026ldquo;Authentication for adding host [yourdomainhere]\u0026rdquo; 项下。 认证字符串将如下所示：\ntestwebsite.i2p=I8WiuSx1TcYAutCrhLveZ6gghdqsIJ1v9noSGPb7ItYjxaK5LHVNxgC60KuEu95nqCCF2qwgnW~2ehIY9vsi1iPForksdU3GALrQq4S73meoIIXarCCdb~Z6Ehj2-yLWI8WiuSx1TcYAutCrhLveZ6gghdqsIJ1v9noSGPb7ItYjxaK5LHVNxgC60KuEu95nqCCF2qwgnW~2ehIY9vsi1iPForksdU3GALrQq4S73meoIIXarCCdb~Z6Ehj2-yLWI8WiuSx1TcYAutCrhLveZ6gghdqsIJ1v9noSGPb7ItYjxaK5LHVNxgC60KuEu95nqCCF2qwgnW~2ehIY9vsi1iPForksdU3GALrQq4S73meoIIXarCCdb~Z6Ehj2-yLWI8WiuSx1TcYAutCrhLveZ6gghdqsIJ1v9noSGPb7ItYjxaK5LHVNxgC60KuEu95nqCCF2qwgnW~2ehIY9vsi1uNxFZ0HN7tQbbVj1pmbahepQZNxEW0ufwnMYAoFo8opBQAEAAcAAA==#!date=1762104890#sig=9DjEfrcNRxsoSxiE0Mp0-7rH~ktYWtgwU8c4J0eSo0VHbGxDxdiO9D1Cvwcx8hkherMO07UWOC9BWf-1wRyUAw== 该字符串包含： - 您的域名 (testwebsite.i2p) - 您的目标地址 (长的密码学标识符) - 一个时间戳 - 一个密码学签名，用于证明您拥有私钥\n请保存此身份验证字符串 - 在两个注册服务中都需要用到它。\n步骤 2：在 stats.i2p 注册 前往 stats.i2p 添加密钥 (在 I2P 内) 粘贴认证字符串 到 \u0026ldquo;Authentication String\u0026rdquo; 字段 添加你的姓名 (可选) - 默认为 \u0026ldquo;Anonymous\u0026rdquo; 添加描述 (推荐) - 简要描述你的 eepsite 是做什么的 示例: \u0026ldquo;新的 I2P Eepsite\u0026rdquo;, \u0026ldquo;个人博客\u0026rdquo;, \u0026ldquo;文件共享服务\u0026rdquo; 勾选 \u0026ldquo;HTTP Service?\u0026rdquo; 如果这是一个网站 (大多数 eepsites 保持勾选) 对于 IRC、NNTP、代理、XMPP、git 等请取消勾选 点击 Submit 如果成功，您将看到一条确认信息，表明您的域名已被添加到 stats.i2p 的地址簿中。\n步骤 3：在 reg.i2p 注册 为确保最大可用性，你还应当在 reg.i2p 服务上进行注册：\n前往 reg.i2p Add Domain （在 I2P 内） 将相同的认证字符串粘贴 到 \u0026ldquo;Auth string（认证字符串）\u0026rdquo; 字段 添加描述（可选，但建议提供） 这有助于其他 I2P 用户了解你的网站提供的内容 点击 Submit（提交） 你应该会收到域名已注册的确认通知。\n步骤 4：等待传播 在向这两个服务提交之后，你的域名注册信息将通过 I2P 网络的地址簿系统传播。\n传播时间线: - 初始注册: 在注册服务上立即生效 - 全网传播: 数小时到 24+ 小时 - 完全可用: 所有 routers 完成更新可能需要最长 48 小时\n这很正常！ I2P 地址簿系统会定期更新，而不是即时生效。你的 eepsite（I2P 隐藏站点）运行正常——其他用户只需收到更新后的地址簿即可。\n验证您的域名 几小时后，你可以测试你的域名：\n打开一个新的浏览器标签页 在你的 I2P 浏览器中 尝试直接访问你的域名：http://yourdomainname.i2p 如果能够加载，你的域名已注册并正在传播！ 如果仍未生效： - 多等一会儿（地址簿会按其自己的时间表更新） - 你的 router 的地址簿可能需要时间同步 - 尝试重启你的 I2P router 以强制更新地址簿\n重要说明 注册是永久的：一旦注册并完成传播，你的域名将永久指向你的.b32.i2p地址 目标不可更改：你无法更新域名所指向的.b32.i2p地址——这就是为什么备份eepPriv.dat至关重要 域名所有权：只有私钥持有者才能注册或更新该域名 免费服务：I2P上的域名注册是免费的、由社区运行且去中心化 多个注册商：同时在 stats.i2p 和 reg.i2p 注册可以提高可靠性和传播速度 恭喜！ 您的 I2P eepsite 现已全面可用，并已注册域名！\n后续步骤: - 向你的 docroot 文件夹添加更多内容 - 将你的域名分享给 I2P 社区 - 妥善保管你的 eepPriv.dat 备份 - 定期监控你的 tunnel（隧道）状态 - 考虑加入 I2P 论坛或 IRC 来推广你的网站\n欢迎来到 I2P 网络！🎉\n","description":"了解如何使用内置的 Jetty Web 服务器在 I2P 网络上创建并托管您自己的网站","id":"cdd089b486cced0cc2a37529ae0ace6b","section":"docs","title":"创建 I2P Eepsite（I2P 内部网站）","url":"/zh/docs/guides/%E5%88%9B%E5%BB%BA-i2p-eepsitei2p-%E5%86%85%E9%83%A8%E7%BD%91%E7%AB%99/"},{"categories":null,"content":"SSH 隧道提供了一个安全、加密的连接,用于访问您的远程 I2P router 控制台或其他服务。本指南向您展示如何在 Windows、Linux 和 Mac 系统上创建 SSH 隧道。\n什么是 SSH 隧道? SSH tunnel 是一种通过加密的 SSH 连接安全路由数据和信息的方法。可以将其想象为在互联网中创建一条受保护的\u0026quot;管道\u0026quot;——你的数据通过这条加密的 tunnel 传输,防止任何人在传输过程中拦截或读取数据。\nSSH 隧道特别适用于:\n访问远程 I2P router: 连接到运行在远程服务器上的 I2P 控制台 安全连接: 所有流量均经过端到端加密 绕过限制: 访问远程系统上的服务,就像它们在本地一样 端口转发: 将本地端口映射到远程服务 在 I2P 环境中,你可以使用 SSH tunnel 将远程服务器上的 I2P router console(通常在 7657 端口)转发到本地计算机的端口来访问它。\n前置要求 在创建 SSH tunnel 之前,你需要:\nSSH 客户端: Windows: PuTTY (免费下载) Linux/Mac: 内置 SSH 客户端(通过终端) 远程服务器访问: 远程服务器的用户名 远程服务器的 IP 地址或主机名 SSH 密码或基于密钥的身份验证 可用的本地端口: 选择 1-65535 之间的未使用端口(7657 是 I2P 常用端口) 理解隧道命令 SSH 隧道命令遵循以下模式:\nssh -L [local_port]:[destination_ip]:[destination_port] [username]@[remote_server] 参数说明: - local_port: 本地机器上的端口(例如,7657) - destination_ip: 通常是 127.0.0.1(远程服务器上的 localhost) - destination_port: 远程服务器上服务的端口(例如,I2P 的 7657) - username: 远程服务器上的用户名 - remote_server: 远程服务器的 IP 地址或主机名\n示例：ssh -L 7657:127.0.0.1:7657 i2p@20.228.143.58\n这将创建一个隧道，其中：- 您本地机器上的端口 7657 转发到\u0026hellip; - 远程服务器 localhost 上的端口 7657（I2P 运行所在位置）- 以用户 i2p 身份连接到服务器 20.228.143.58\n在 Windows 上创建 SSH 隧道 Windows 用户可以使用 PuTTY(一个免费的 SSH 客户端)创建 SSH tunnel。\nStep 1: Download and Install PuTTY 从 putty.org 下载 PuTTY 并将其安装到您的 Windows 系统上。\nStep 2: Configure the SSH Connection 打开 PuTTY 并配置您的连接：\n在 Session 类别中： 在 Host Name 字段中输入您远程服务器的 IP 地址或主机名 确保 Port 设置为 22（默认 SSH 端口） 连接类型应为 SSH Step 3: Configure the Tunnel 在左侧边栏中导航至 Connection → SSH → Tunnels:\n源端口:输入您要使用的本地端口(例如 7657) 目标地址:输入 127.0.0.1:7657(远程服务器上的 localhost:端口) 点击 添加 以添加 tunnel tunnel 应该会出现在\u0026quot;转发端口\u0026quot;列表中 Step 4: Connect 点击 Open 启动连接 如果这是您第一次连接，将看到安全警告 - 点击 Yes 信任该服务器 出现提示时输入您的用户名 出现提示时输入您的密码 连接成功后,您可以通过打开浏览器并访问 http://127.0.0.1:7657 来访问远程 I2P 控制台\n步骤 1:下载并安装 PuTTY 为了避免每次都重新配置:\n返回到 Session 类别 在 Saved Sessions 中输入一个名称（例如，\u0026ldquo;I2P Tunnel\u0026rdquo;） 点击 Save 下次只需加载此会话并点击 Open Creating SSH Tunnels on Linux Linux 系统在终端中内置了 SSH,使得隧道创建快速而简单。\n步骤 2:配置 SSH 连接 打开终端并运行 SSH tunnel 命令：\nssh -L 7657:127.0.0.1:7657 i2p@20.228.143.58 替换：- 7657（第一次出现）：您期望的本地端口 - 127.0.0.1:7657：远程服务器上的目标地址和端口 - i2p：您在远程服务器上的用户名 - 20.228.143.58：您的远程服务器 IP 地址\n当提示时,输入您的密码。连接后,tunnel 即处于活动状态。\n在浏览器中访问您的远程 I2P 控制台，地址为 http://127.0.0.1:7657。\n步骤 3:配置隧道 只要 SSH 会话保持运行,隧道就会保持活动状态。要让它在后台持续运行:\nssh -f -N -L 7657:127.0.0.1:7657 i2p@20.228.143.58 附加参数：- -f：在后台运行 SSH - -N：不执行远程命令(仅建立隧道)\n要关闭后台隧道,找到并终止 SSH 进程:\nps aux | grep ssh kill [process_id] 步骤 4：连接 为了更好的安全性和便利性,使用 SSH 密钥认证:\n生成 SSH 密钥对（如果你还没有）：\nssh-keygen -t ed25519 -C \u0026#34;your_email@example.com\u0026#34; 将你的公钥复制到远程服务器：\nssh-copy-id i2p@20.228.143.58 现在你可以无需密码连接：\nssh -L 7657:127.0.0.1:7657 i2p@20.228.143.58 Creating SSH Tunnels on Mac Mac 系统使用与 Linux 相同的 SSH 客户端,因此操作过程完全相同。\n可选：保存您的会话 打开终端(应用程序 → 实用工具 → 终端)并运行:\nssh -L 7657:127.0.0.1:7657 i2p@20.228.143.58 替换：- 7657（第一次出现）：你期望的本地端口 - 127.0.0.1:7657：远程服务器上的目标地址和端口 - i2p：你在远程服务器上的用户名 - 20.228.143.58：你的远程服务器的 IP 地址\n出现提示时输入您的密码。连接后,在 http://127.0.0.1:7657 访问您的远程 I2P 控制台\nBackground Tunnels on Mac 与 Linux 相同,你可以在后台运行隧道:\nssh -f -N -L 7657:127.0.0.1:7657 i2p@20.228.143.58 使用终端 Mac SSH 密钥设置与 Linux 相同:\n# Generate key (if needed) ssh-keygen -t ed25519 -C \u0026#34;your_email@example.com\u0026#34; # Copy to remote server ssh-copy-id i2p@20.228.143.58 Common Use Cases 保持隧道活跃 最常见的用例 - 访问您的远程 I2P router 控制台:\nssh -L 7657:127.0.0.1:7657 user@remote-server 然后在浏览器中打开 http://127.0.0.1:7657。\n使用 SSH 密钥(推荐) 一次转发多个端口:\nssh -L 7657:127.0.0.1:7657 -L 7658:127.0.0.1:7658 user@remote-server 这会同时转发端口 7657(I2P 控制台)和 7658(另一个服务)。\nCustom Local Port 如果 7657 端口已被占用,请使用不同的本地端口:\nssh -L 8080:127.0.0.1:7657 user@remote-server 请访问 I2P 控制台：http://127.0.0.1:8080。\nTroubleshooting 使用终端 错误：\u0026ldquo;bind: Address already in use\u0026rdquo;\n解决方案:选择不同的本地端口或终止占用该端口的进程:\n# Linux/Mac - find process on port 7657 lsof -i :7657 # Kill the process kill [process_id] Mac 上的后台隧道 错误：\u0026ldquo;Connection refused\u0026rdquo; 或 \u0026ldquo;channel 2: open failed\u0026rdquo;\n可能原因: - 远程服务未运行(检查远程服务器上的 I2P router 是否正在运行) - 防火墙阻止了连接 - 目标端口不正确\n解决方案：验证远程服务器上的 I2P router 是否正在运行：\nssh user@remote-server \u0026#34;systemctl status i2p\u0026#34; 在 Mac 上设置 SSH 密钥 错误：\u0026ldquo;Permission denied\u0026rdquo; 或 \u0026ldquo;Authentication failed\u0026rdquo;\n可能的原因：- 用户名或密码不正确 - SSH 密钥配置不当 - 远程服务器上禁用了 SSH 访问\n解决方案：验证凭据并确保远程服务器上已启用 SSH 访问。\nTunnel Drops Connection 错误：闲置一段时间后连接断开\n解决方案:在你的 SSH 配置文件(~/.ssh/config)中添加 keep-alive 设置:\nHost remote-server ServerAliveInterval 60 ServerAliveCountMax 3 Security Best Practices 使用 SSH 密钥:比密码更安全,更难被攻破 禁用密码认证:设置好 SSH 密钥后,在服务器上禁用密码登录 使用强密码:如果使用密码认证,请使用强密码且不要重复使用 限制 SSH 访问:配置防火墙规则,将 SSH 访问限制在可信 IP 范围内 保持 SSH 更新:定期更新您的 SSH 客户端和服务器软件 监控日志:检查服务器上的 SSH 日志,留意可疑活动 使用非标准 SSH 端口:更改默认 SSH 端口(22)以减少自动化攻击 在 Linux 上创建 SSH 隧道 访问 I2P 控制台 创建一个脚本来自动建立 tunnel：\n#!/bin/bash # i2p-tunnel.sh ssh -f -N -L 7657:127.0.0.1:7657 i2p@20.228.143.58 echo \u0026#34;I2P tunnel established\u0026#34; 使其可执行:\nchmod +x i2p-tunnel.sh ./i2p-tunnel.sh 多条隧道 创建一个 systemd 服务以实现自动创建 tunnel:\nsudo nano /etc/systemd/system/i2p-tunnel.service 添加:\n[Unit] Description=I2P SSH Tunnel After=network.target [Service] ExecStart=/usr/bin/ssh -NT -o ServerAliveInterval=60 -o ExitOnForwardFailure=yes -L 7657:127.0.0.1:7657 i2p@20.228.143.58 Restart=always RestartSec=10 User=your-username [Install] WantedBy=multi-user.target 启用并启动:\nsudo systemctl enable i2p-tunnel sudo systemctl start i2p-tunnel Advanced Tunneling 自定义本地端口 创建用于动态转发的 SOCKS 代理:\nssh -D 8080 user@remote-server 将浏览器配置为使用 127.0.0.1:8080 作为 SOCKS5 代理。\nReverse Tunneling 允许远程服务器访问本地机器上的服务:\nssh -R 7657:127.0.0.1:7657 user@remote-server 端口已被占用 通过中间服务器建立隧道:\nssh -J jumphost.example.com -L 7657:127.0.0.1:7657 user@final-server Conclusion SSH 隧道是一个强大的工具,用于安全访问远程 I2P router 和其他服务。无论您使用 Windows、Linux 还是 Mac,这个过程都很简单,并为您的连接提供强加密。\n如需更多帮助或有疑问,请访问 I2P 社区: - 论坛: i2pforum.net - IRC: #i2p 在各个网络上 - 文档: I2P Docs I2P 路由器控制台\n本指南最初由 Stormy Cloud 创建,已改编用于 I2P 文档。\n","description":"学习如何在 Windows、Linux 和 Mac 上创建安全的 SSH tunnel 以访问您的远程 I2P router","id":"7d461aaa86788adfcb07bfb98f6e4965","section":"docs","title":"创建 SSH 隧道以远程访问 I2P","url":"/zh/docs/guides/%E5%88%9B%E5%BB%BA-ssh-%E9%9A%A7%E9%81%93%E4%BB%A5%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE-i2p/"},{"categories":null,"content":"Reseed 主机是 I2P 网络的关键基础设施,在引导过程中为新 router 提供初始节点组。本指南将引导您完成设置和运行自己的 reseed 服务器的过程。\n什么是 I2P Reseed 服务器? I2P reseed 服务器通过以下方式帮助新的 routers 集成到 I2P 网络中：\n提供初始节点发现：新 router 接收一组初始网络节点以建立连接 Bootstrap 恢复：帮助难以维持连接的 router 安全分发：重新种子化过程经过加密和数字签名，以确保网络安全 当新的 I2P router 首次启动时(或丢失了所有对等连接),它会联系 reseed 服务器下载初始的 router 信息集。这使得新 router 能够开始构建自己的 netDb 并建立 tunnel。\n前置要求 开始之前，您需要：\n一台 Linux 服务器(推荐 Debian/Ubuntu)并具有 root 访问权限 一个指向您服务器的域名 至少 1GB 内存和 10GB 磁盘空间 服务器上运行的 I2P router 以填充 netDb 基本熟悉 Linux 系统管理 准备服务器 Step 1: Update System and Install Dependencies 首先，更新您的系统并安装所需的软件包：\nsudo apt update \u0026amp;\u0026amp; sudo apt upgrade -y \u0026amp;\u0026amp; sudo apt-get install golang-go git make docker.io docker-compose -y 这将安装: - golang-go: Go 编程语言运行时 - git: 版本控制系统 - make: 构建自动化工具 - docker.io \u0026amp; docker-compose: 用于运行 Nginx Proxy Manager 的容器平台\nStep 2: Clone and Build Reseed Tools 克隆 reseed-tools 仓库并构建应用程序:\ncd /home/i2p git clone https://i2pgit.org/idk/reseed-tools cd reseed-tools make build sudo make install reseed-tools 包提供了运行 reseed 服务器的核心功能。它负责处理：- 从本地网络数据库收集 router 信息 - 将 router info 打包成已签名的 SU3 文件 - 通过 HTTPS 提供这些文件\nStep 3: Generate SSL Certificate 生成你的 reseed 服务器的 SSL 证书和私钥:\nsu - i2p -c \u0026#39;reseed-tools reseed --signer=admin@stormycloud.org --netdb=/home/i2p/.i2p/netDb --port=8443 --ip=127.0.0.1 --trustProxy\u0026#39; 重要参数：- --signer：您的电子邮件地址（将 admin@stormycloud.org 替换为您自己的邮箱）- --netdb：您的 I2P router 的 netDb 路径 - --port：内部端口（建议使用 8443）- --ip：绑定到 localhost（我们将使用反向代理进行公共访问）- --trustProxy：信任来自反向代理的 X-Forwarded-For 头\n该命令将生成：- 用于签名 SU3 文件的私钥 - 用于安全 HTTPS 连接的 SSL 证书\n步骤 1:更新系统并安装依赖项 关键：安全备份位于 /home/i2p/.reseed/ 中生成的密钥：\nsudo tar -czf reseed-keys-backup.tar.gz /home/i2p/.reseed/ 将此备份存储在访问受限的安全加密位置。这些密钥对于您的 reseed 服务器的运行至关重要,应该妥善保护。\nConfiguring the Service 步骤 2: 克隆并构建 Reseed 工具 创建一个 systemd 服务以自动运行 reseed 服务器:\nsudo tee /etc/systemd/system/reseed.service \u0026lt;\u0026lt;EOF [Unit] Description=Reseed Service After=network.target [Service] User=i2p WorkingDirectory=/home/i2p ExecStart=/bin/bash -c \u0026#39;reseed-tools reseed --signer=admin@stormycloud.org --netdb=/home/i2p/.i2p/netDb --port=8443 --ip=127.0.0.1 --trustProxy\u0026#39; Restart=always RestartSec=10 [Install] WantedBy=multi-user.target EOF 请记得替换 admin@stormycloud.org 为您自己的电子邮件地址。\n现在启用并启动服务:\nsudo systemctl daemon-reload sudo systemctl enable reseed sudo systemctl start reseed 检查服务是否正在运行:\nsudo systemctl status reseed 步骤 3: 生成 SSL 证书 为了获得最佳性能,您可能需要定期重启 reseed 服务以刷新 router 信息:\nsudo crontab -e 添加此行以每3小时重启一次服务:\n0 */3 * * * systemctl restart reseed Setting Up Reverse Proxy reseed 服务器运行在 localhost:8443 上,需要一个反向代理来处理公共 HTTPS 流量。我们推荐使用 Nginx Proxy Manager,因为它易于使用。\n步骤 4：备份你的密钥 使用 Docker 部署 Nginx Proxy Manager:\ndocker run -d \\ --name nginx-proxy-manager \\ -p 80:80 \\ -p 81:81 \\ -p 443:443 \\ -v $(pwd)/data:/data \\ -v $(pwd)/letsencrypt:/etc/letsencrypt \\ --restart unless-stopped \\ jc21/nginx-proxy-manager:latest 这将暴露：- 端口 80：HTTP 流量 - 端口 81：管理界面 - 端口 443：HTTPS 流量\nConfigure Proxy Manager 在 http://your-server-ip:81 访问管理界面\n使用默认凭据登录:\n邮箱: admin@example.com 密码: changeme 重要提示：首次登录后请立即更改这些凭据！\n导航到 Proxy Hosts 并点击 Add Proxy Host 配置代理主机： 域名：您的 reseed 域名（例如，reseed.example.com） 协议：https 转发主机名 / IP：127.0.0.1 转发端口：8443 启用 缓存资源 启用 拦截常见攻击 启用 Websockets 支持 在 SSL 标签页中: 选择 Request a new SSL Certificate (Let\u0026rsquo;s Encrypt) 启用 Force SSL 启用 HTTP/2 Support 同意 Let\u0026rsquo;s Encrypt 服务条款 点击 保存 你的 reseed 服务器现在应该可以通过 https://reseed.example.com 访问\nRegistering Your Reseed Server 一旦你的 reseed 服务器运行正常,请联系 I2P 开发者将其添加到官方 reseed 服务器列表中。\n步骤 5：创建 Systemd 服务 请通过电子邮件向 zzz(I2P 首席开发者)提供以下信息:\nI2P 邮箱: zzz@mail.i2p 明网邮箱: zzz@i2pmail.org 步骤 6：可选 - 配置定期重启 在您的邮件中包含:\nReseed 服务器 URL：完整的 HTTPS URL（例如，https://reseed.example.com） 公共 reseed 证书：位于 /home/i2p/.reseed/（附加 .crt 文件） 联系邮箱：用于服务器维护通知的首选联系方式 服务器位置：可选但有帮助（国家/地区） 预期正常运行时间：您对维护服务器的承诺 Verification I2P 开发者将验证您的 reseed 服务器是否:\n正确配置并提供 router 信息 使用有效的 SSL 证书 提供正确签名的 SU3 文件 可访问且响应正常 一旦获得批准,您的 reseed 服务器将被添加到随 I2P router 分发的列表中,帮助新用户加入网络!\nMonitoring and Maintenance 安装 Nginx Proxy Manager 监控您的 reseed 服务:\nsudo systemctl status reseed sudo journalctl -u reseed -f 配置代理管理器 密切关注系统资源：\nhtop df -h Update Reseed Tools 定期更新 reseed-tools 以获取最新的改进：\ncd /home/i2p/reseed-tools git pull make build sudo make install sudo systemctl restart reseed 联系信息 如果通过 Nginx Proxy Manager 使用 Let\u0026rsquo;s Encrypt,证书将自动续期。验证续期是否正常工作:\ndocker logs nginx-proxy-manager | grep -i certificate 配置服务 必需信息 检查日志中的错误：\nsudo journalctl -u reseed -n 50 常见问题：- I2P router 未运行或 netDb 为空 - 端口 8443 已被占用 - /home/i2p/.reseed/ 目录的权限问题\n验证 确保你的 I2P router 正在运行并已填充其 netDb：\nls -lh /home/i2p/.i2p/netDb/ 你应该看到许多 .dat 文件。如果是空的,请等待你的 I2P router 发现对等节点。\nSSL Certificate Errors 验证您的证书是否有效:\nopenssl s_client -connect reseed.example.com:443 -servername reseed.example.com 检查服务状态 检查：- DNS 记录正确指向您的服务器 - 防火墙允许端口 80 和 443 - Nginx Proxy Manager 正在运行：docker ps\nSecurity Considerations 保护私钥安全：切勿分享或暴露 /home/i2p/.reseed/ 目录的内容 定期更新：保持系统软件包、Docker 和 reseed-tools 为最新版本 监控日志：留意可疑的访问模式 速率限制：考虑实施速率限制以防止滥用 防火墙规则：仅开放必要的端口（80、443、81 用于管理） 管理界面：将 Nginx Proxy Manager 管理界面（端口 81）限制为仅受信任的 IP 访问 Contributing to the Network 通过运行一个 reseed 服务器,您正在为 I2P 网络提供关键基础设施。感谢您为更加私密和去中心化的互联网做出贡献!\n如有问题或需要帮助,请联系 I2P 社区: - 论坛: i2pforum.net - IRC/Reddit: 各网络上的 #i2p - 开发: i2pgit.org 指南最初由 Stormy Cloud 创建,经改编用于 I2P 文档。\n","description":"完整指南：设置和运行 I2P reseed 服务器以帮助新 router 加入网络","id":"d360e14f0f61d776e3c0b0f5b1262be5","section":"docs","title":"创建和运行 I2P Reseed 服务器","url":"/zh/docs/guides/%E5%88%9B%E5%BB%BA%E5%92%8C%E8%BF%90%E8%A1%8C-i2p-reseed-%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":null,"content":" 历史说明： 本页保留了旧版“Unidirectional Tunnels（单向隧道）”讨论，供参考。有关当前行为，请参阅现行的 tunnel 实现文档 。\n概述 I2P 构建 单向的 tunnels：一个 tunnel 承载出站流量，另一个独立的 tunnel 承载入站回复。这种结构可追溯至最早的网络设计，并且至今仍是与像 Tor 这样的双向电路系统相区别的关键特征。有关术语和实现细节，请参见 tunnel 概览 和 tunnel 规范 。\n回顾 单向 tunnel 将请求与响应流量分离，因此任何一组串通的对等节点只能观察到往返路径的一半。 时序攻击必须同时交叉两个 tunnel 池（出站和入站），而不是分析单一的电路，从而提高关联分析的难度。 独立的入站和出站池使 routers 能够按方向调整延迟、容量及故障处理特性。 缺点包括对等节点管理复杂性增加，以及为确保服务可靠交付而需要维护多个 tunnel 集合。 匿名性 Hermann 和 Grothoff 的论文，I2P is Slow… and What to Do About It ，分析了针对单向 tunnels 的前驱攻击，指出有决心的对手最终可以确认长期在线的对等节点。社区反馈指出，该研究依赖于关于对手耐心和法律权力的特定假设，且没有将该方法与会影响双向设计的时序攻击进行权衡比较。持续的研究与实践经验不断强化了这样一种认识：单向 tunnels 是出于匿名性考量的有意选择，而非疏忽所致。\n","description":"I2P 的单向 tunnel 设计的历史概述。","id":"37ac13877a690f9c4635959a57451755","section":"docs","title":"单向 Tunnels","url":"/zh/docs/legacy/unidirectional/"},{"categories":null,"content":"概述 本规范通过加入命令扩展了 address subscription feed（地址订阅源），使名称服务器能够广播来自主机名持有者的条目更新。最初于Proposal 112 （2014年9月）中提出，于 0.9.26 版（2016年6月）中实现，并已在全网部署，状态为 CLOSED。\n该系统自最初实现以来一直保持稳定且未发生变化，并在 I2P 2.10.0（Router API 0.9.65，2025 年 9 月）中继续以相同方式运行。\n动机 此前，hosts.txt 订阅服务器仅以一种简单的 hosts.txt 格式发送数据：\nexample.i2p=b64destination 这种基本格式带来了几个问题：\n主机名持有者无法更新与其主机名关联的 Destination（I2P 中的目的地标识）（例如，将签名密钥升级到更强的密码学算法类型）。 主机名持有者不能任意放弃其主机名。他们必须将相应的 Destination 私钥直接交给新的持有者。 无法验证某个子域名由对应的基础主机名控制。目前这仅由某些名称服务器分别强制执行。 设计 本规范为 hosts.txt 格式新增了命令行。借助这些命令，名称服务器可以扩展其服务以提供额外功能。实现本规范的客户端可以通过常规订阅流程监听这些功能。\n所有命令都必须由相应的 Destination（目的地）签名。这确保只有在主机名持有者提出请求时才会进行更改。\n安全影响 本规范不影响匿名性。\n与丢失对 Destination（目标地址）密钥的控制相关的风险有所增加，因为获得该密钥的人可以使用这些命令对任何关联的主机名进行更改。不过，这并不比现状更糟，在现状下，获得一个 Destination 的人可以冒充某个主机名，并（部分地）接管其流量。通过赋予主机名持有者在认为 Destination 已被攻陷时更改与该主机名关联的 Destination 的能力，可以平衡这种增加的风险。而在当前系统中，这是不可能做到的。\n规范 换行类型 有两种新的线条类型：\nAdd 和 Change 命令： example.i2p=b64destination#!key1=val1#key2=val2... 删除命令： #!key1=val1#key2=val2... 顺序 feed（提要）不一定是有序或完整的。例如，change 命令可能出现在 add 命令之前，或者在没有 add 命令的情况下出现。\n键可以以任意顺序出现。不允许存在重复的键。所有键和值都区分大小写。\n常用密钥 所有命令都必须包含：\nsig : Base64 签名，使用来自目标（Destination）的签名密钥\n对第二个主机名和/或 destination（目标标识）的引用：\noldname : 第二个主机名（新的或已更改的）\nolddest : 第二个 Base64 destination（I2P 目标标识）（新的或已更改的）\noldsig : 第二个 Base64 签名，使用来自 olddest 的签名密钥\n其他常用键：\naction : 一个命令\nname : 主机名，仅当其前面没有 example.i2p=b64dest 时才会出现\ndest : Base64 destination（目标地址），仅当其前面未出现 example.i2p=b64dest 时才会出现\ndate : 自 Unix 纪元以来的秒数\nexpires : 自 Unix 纪元起的秒数\n命令 除“Add”命令外，所有命令必须包含一个action=command键/值对。\n为兼容旧版客户端，大多数命令前都加上 example.i2p=b64dest，如下所述。对于变更，均以新值为准。任何旧值都会包含在键/值部分中。\n列出的键是必需的。所有命令可能包含此处未定义的其他键/值项。\n添加主机名 以 example.i2p=b64dest 开头：是的，这是新的主机名和目标地址。\naction : 未包含，已隐含。\nsig : 签名\n示例：\nexample.i2p=b64dest#!sig=b64sig 更改主机名 以 example.i2p=b64dest 为前缀 : 是的，这是新的主机名和旧的 destination（目标标识）。\n操作 : changename\noldname : 旧的主机名，待替换\nsig : 签名\n示例：\nexample.i2p=b64dest#!action=changename#oldname=oldhostname#sig=b64sig 更改目标地址 前面带有 example.i2p=b64dest : 是的，这是旧的主机名和新的目标地址。\naction : changedest\nolddest : 旧的 Destination（目标地址），将被替换\noldsig : 使用 olddest 的签名\nsig : 签名\n示例：\nexample.i2p=b64dest#!action=changedest#olddest=oldb64dest#oldsig=b64sig#sig=b64sig 添加主机名别名 以 example.i2p=b64dest 开头 : 是的，这是新的（别名）主机名和旧的 Destination（目的地标识）。\n操作 : addname\noldname : 旧的主机名\nsig：签名\n示例：\nexample.i2p=b64dest#!action=addname#oldname=oldhostname#sig=b64sig 添加目标地址别名 (用于加密升级)\n以 example.i2p=b64dest 为前缀 : 是的，这是旧的主机名和新的（备用）destination（目标标识）。\naction : adddest\nolddest : 旧的目的地\noldsig : 使用 olddest 的签名\nsig : 使用 dest 的签名\n示例：\nexample.i2p=b64dest#!action=adddest#olddest=oldb64dest#oldsig=b64sig#sig=b64sig 添加子域名 以 subdomain.example.i2p=b64dest 开头 : 是的，这是新的子域名和 destination（目标）。\n操作 : addsubdomain\noldname : 更高层级的主机名 (example.i2p)\nolddest : 更高层级的目标地址（例如 example.i2p）\noldsig : 使用 olddest 的签名\nsig : 使用 dest 的签名\n示例：\nsubdomain.example.i2p=b64dest#!action=addsubdomain#oldname=example.i2p#olddest=oldb64dest#oldsig=b64sig#sig=b64sig 更新元数据 以 example.i2p=b64dest 为前缀 : 是的，这是旧的主机名和目标地址。\n操作 : 更新\nsig : 签名\n(在此添加任何已更新的密钥)\n示例：\nexample.i2p=b64dest#!action=update#k1=v1#k2=v2#sig=b64sig 移除主机名 需要以 example.i2p=b64dest 作为前缀 : 不，这些是在选项中指定的\n操作 : 删除\nname : 主机名\ndest : 目标\nsig : 签名\n示例：\n#!action=remove#name=example.i2p#dest=b64dest#sig=b64sig 删除所有与此目标地址（Destination）相关的条目 以 example.i2p=b64dest 作为前缀 : 否，这些是在选项中指定的\n操作 : removeall\ndest : 目标\nsig : 签名\n示例：\n#!action=removeall#dest=b64dest#sig=b64sig 签名 所有命令必须由对应的 Destination（I2P 中的通信端点标识）签名。包含两个 Destination 的命令可能需要两个签名。\noldsig 始终是“内层”签名。在不存在 oldsig 或 sig 键的情况下进行签名和验证。sig 始终是“外层”签名。在存在 oldsig 键但不存在 sig 键的情况下进行签名和验证。\n签名输入 要生成用于创建或验证签名的字节流，请按如下方式序列化：\n移除 sig 键 如果使用 oldsig 进行验证，也移除 oldsig 键 仅用于 Add 或 Change 命令，输出 example.i2p=b64dest 如果仍有任何键，输出 #! 按 UTF-8 键对选项排序，若存在重复键则失败 对每个键/值，输出 key=value，然后（如果不是最后一个键/值）再输出一个 # 注意事项\n不要输出换行符 输出编码为 UTF-8 所有 destination（I2P 目的地标识）和签名的编码均为使用 I2P 字母表的 Base 64 键和值区分大小写 主机名必须为小写 当前签名类型 自 I2P 2.10.0 起，以下用于 Destination（目标标识）的签名类型受支持：\nEdDSA_SHA512_Ed25519 (Type 7): 自 0.9.15 起在 destinations（目的地）中最常见。使用 32 字节公钥和 64 字节签名。这是新建 destinations 的推荐签名类型。 RedDSA_SHA512_Ed25519 (Type 13): 仅适用于 destinations 和加密的 leasesets（自 0.9.39 起）。 旧类型（DSA_SHA1、ECDSA 变体）：仍受支持，但自 0.9.58 起针对新的 Router Identities 已弃用。 注意：自 I2P 2.10.0 起，后量子密码学选项已可用，但尚未成为默认的签名类型。\n兼容性 在 hosts.txt 格式中，所有新增的行都通过行首注释字符（#!）实现，因此所有较旧的 I2P 版本都会将这些新命令视为注释并优雅地忽略它们。\n当 I2P router 更新到新规范时，它们不会重新解释旧的注释，而会在随后获取其订阅源时开始监听新的命令。因此，名称服务器需要以某种方式持久化命令条目，或启用 ETag 支持，以便 router 能获取过去的所有命令。\n实现状态 初始部署: 版本 0.9.26 (2016 年 6 月 7 日)\n当前状态： 截至 I2P 2.10.0，稳定且未变化（Router API 0.9.65，2025 年 9 月）\n提案状态： 已关闭 (已在全网成功部署)\n实现位置： apps/addressbook/java/src/net/i2p/addressbook/ 在 I2P Java router 中\n关键类: - SubscriptionList.java: 管理订阅处理 - Subscription.java: 处理单个订阅源 - AddressBook.java: 地址簿的核心功能 - Daemon.java: 地址簿后台服务\n默认订阅 URL: http://i2p-projekt.i2p/hosts.txt\n传输详细信息 订阅使用支持条件 GET 的 HTTP：\nETag 头： 支持高效的变更检测 Last-Modified 头： 跟踪订阅更新时间 304 Not Modified： 当内容未变更时，服务器应返回此状态 Content-Length： 强烈建议在所有响应中包含该字段 I2P router 使用标准的 HTTP 客户端行为，并提供完善的缓存支持。\n版本背景 I2P 版本编号说明： 自大约 1.5.0 版本（2021 年 8 月）起，I2P 从 0.9.x 的版本编号转为采用语义化版本（1.x、2.x 等）。不过，为了向后兼容，内部的 Router API 版本仍沿用 0.9.x 的编号。截至 2025 年 10 月，当前发布版为 I2P 2.10.0，对应的 Router API 版本为 0.9.65。\n本规范文档最初为 0.9.49 版本（2021 年 2 月）编写，并且对当前的 0.9.65 版本（I2P 2.10.0）仍完全适用，因为自从在 0.9.26 中首次实现以来，订阅提要系统未发生任何变更。\n参考资料 提案 112（原文） 官方规范 I2P 命名文档 通用结构规范 I2P 源代码仓库 I2P Gitea 仓库 相关进展 尽管订阅源系统本身并未改变，I2P 的命名基础设施中以下相关进展可能会引起兴趣：\n扩展的 Base32 名称 (0.9.40+): 支持加密的 leaseSet 使用 56+ 字符的 base32 地址。不影响订阅源格式。 .i2p.alt TLD 注册 (RFC 9476, 2023 年末): GANA 已正式将 .i2p.alt 注册为替代 TLD。未来的 router 更新可能会去除 .alt 后缀，但无需更改订阅命令。 后量子密码学 (2.10.0+): 可用但非默认。未来将考虑订阅源中的签名算法。 ","description":"用于地址簿订阅源的扩展，使主机名持有者能够更新并管理其记录","id":"fa3cedda5fbeac90d0dcf029a44ee945","section":"docs","title":"地址订阅源命令","url":"/zh/docs/specs/subscription/"},{"categories":null,"content":" 状态： 本页精炼汇总了遗留的“Low-level Cryptography Specification”。较新的 I2P 发行版（2.10.0，2025年10月）已完成向新的密码学原语的迁移。实现细节请参阅以下专项规范：ECIES 、Encrypted LeaseSets 、NTCP2 、Red25519 、SSU2 ，以及 Tunnel Creation (ECIES) 。\n演进快照 Functional Area Legacy Primitive Current / Planned Primitive Migration Status Transport key exchange Diffie–Hellman over 2048-bit prime (NTCP / SSU) X25519 (NTCP2 / SSU2) Completed (NTCP2 and SSU2 fully deployed) End-to-end encryption ElGamal/AES+SessionTags ECIES-X25519-AEAD-Ratchet Completed (2.4.0+) Symmetric cipher AES-256/CBC + HMAC-MD5 ChaCha20/Poly1305 (AEAD) Active (tunnel layer remains AES-256) Default signatures DSA-SHA1 (1024-bit) EdDSA/RedDSA on Ed25519 Fully migrated Experimental / future — Hybrid post-quantum encryption (opt-in) In testing (2.10.0) ## 非对称加密 X25519（基于 Curve25519 的椭圆曲线密钥交换算法） 用于 NTCP2、ECIES-X25519-AEAD-Ratchet、SSU2 以及基于 X25519 的 tunnel 创建。 通过 Noise 协议框架提供紧凑的密钥、常数时间操作和前向保密。 使用 32 字节密钥提供 128 位安全性，并具备高效的密钥交换。 ElGamal（旧版） 为与较旧的 routers 向后兼容而保留。 基于 2048 位 Oakley Group 14 素数模数（RFC 3526），生成元 2。 将 AES 会话密钥和 IV（初始化向量）加密为 514 字节的密文。 缺乏认证加密和前向保密；所有现代端点都已迁移到 ECIES（椭圆曲线集成加密方案）。 对称加密 ChaCha20/Poly1305（由 ChaCha20 流密码与 Poly1305 消息认证码组合的认证加密算法） 在 NTCP2、SSU2 和 ECIES 中默认使用的认证加密原语。 提供 AEAD 安全性，并且在没有 AES 硬件支持的情况下也能保持高性能。 依据 RFC 7539 实现（256‑bit 密钥，96‑bit 随机数，128‑bit 认证标签）。 AES‑256/CBC（旧版） 仍用于 tunnel 层加密，其分组密码结构契合 I2P 的分层加密模型。 使用 PKCS#5 填充和逐跳 IV（初始向量）变换。 已纳入长期审查计划，但在密码学上仍然可靠。 签名 Signature Type Usage Notes Status DSA‑SHA1 (1024‑bit) Original default; still accepted for legacy Destinations. Deprecated ECDSA‑SHA256/384/512 Used during 2014–2015 transition. Supported EdDSA‑SHA512‑Ed25519 Default for Router and Destination identities (since 0.9.15). Default RedDSA‑SHA512‑Ed25519 Used for encrypted LeaseSet signatures (0.9.39+). Specialized RSA‑SHA512‑4096 For out‑of‑band signing (su3 updates, reseeds, plugins). Application‑layer ## 哈希与密钥派生 SHA‑256: 用于 DHT（分布式哈希表）密钥、HKDF（基于 HMAC 的密钥派生函数）以及旧版签名。 SHA‑512: 由 EdDSA/RedDSA（基于 Edwards 曲线的数字签名算法/RedDSA）使用，并用于 Noise（协议框架）HKDF 推导中。 HKDF‑SHA256: 在 ECIES（椭圆曲线集成加密方案）、NTCP2 和 SSU2 中派生会话密钥。 按日轮换的 SHA‑256 派生用于保护 netDb 中 RouterInfo 和 LeaseSet 的存储位置。 传输层摘要 Transport Key Exchange Encryption Authentication Status NTCP2 X25519 ChaCha20/Poly1305 AEAD Default TCP transport SSU2 X25519 ChaCha20/Poly1305 AEAD Default UDP transport SSU (Legacy) DH‑2048 AES‑256/CBC + HMAC‑MD5 Legacy Removed (2.4.0) 两种传输协议均提供链路级前向保密和重放防护，并使用 Noise_XK 握手模式（Noise 协议框架中的 XK 模式）。 Tunnel 层加密 继续使用 AES‑256/CBC 进行逐跳分层加密。 出站网关执行迭代的 AES 解密；每一跳使用其层密钥和 IV（初始化向量）密钥重新加密。 双 IV 加密可缓解关联与确认攻击。 正在研究迁移到 AEAD，但目前尚无计划。 后量子密码学 I2P 2.10.0 引入了实验性的混合式后量子加密。 可通过 Hidden Service Manager（隐藏服务管理器）手动启用以进行测试。 将 X25519 与抗量子 KEM（密钥封装机制）相结合（混合模式）。 默认未启用；用于研究与性能评估。 可扩展性框架 加密和签名的类型标识符允许并行支持多种密码原语。 当前映射包括： 加密类型： 0 = ElGamal/AES+SessionTags，4 = ECIES‑X25519‑AEAD‑Ratchet。 签名类型： 0 = DSA‑SHA1，7 = EdDSA‑SHA512‑Ed25519，11 = RedDSA‑SHA512‑Ed25519。 该框架支持未来的升级，包括后量子密码方案，而不导致网络分裂。 密码学组合 传输层： X25519 + ChaCha20/Poly1305（Noise 框架）。 tunnel 层： 采用 AES‑256/CBC 的分层加密，以保障匿名性。 端到端： ECIES‑X25519‑AEAD‑Ratchet，用于实现机密性和前向保密性。 数据库层： EdDSA/RedDSA 签名，用于确保真实性。 这些层共同实现纵深防御：即使某一层被攻陷，其他层仍能保持机密性与不可关联性。\n摘要 I2P 2.10.0 的密码学栈以以下内容为中心：\nCurve25519 (X25519) 用于密钥交换 ChaCha20/Poly1305 用于对称加密 EdDSA / RedDSA 用于签名 SHA‑256 / SHA‑512 用于哈希与派生 实验性后量子混合模式 用于前向兼容 出于向后兼容性考虑，遗留的 ElGamal、AES‑CBC 和 DSA 仍被保留，但不再用于当前的传输协议或加密路径。\n","description":"在整个 I2P 中使用的对称、非对称和签名密码学原语概述","id":"f5b93f818161e04d49735c3df52fcbdc","section":"docs","title":"底层密码学","url":"/zh/docs/specs/cryptography/"},{"categories":null,"content":" 状态： 更新至 I2P 2.10.0（2025年10月）。此列表整合了 I2P Java Router、i2pd 及相关插件使用的所有活动、已弃用和保留端口。所有端口按数字顺序列出以保持一致性。\nPort Service / Component Description Notes 123SNTPNetwork time synchronizationUses external NTP servers; required for accurate LeaseSet timestamps. 2827BOB interfaceLegacy client API bridgeDeprecated; disabled by default. 4444HTTP ProxyStandard web proxy for eepsite browsingDefault for both HTTP and HTTPS browser traffic. 4445HTTPS ProxyDedicated SSL/TLS proxyOptional; often redundant with 4444. 6667–6669IRC ProxyAccess to I2P IRC networksDefault = 6668; alternate ports avoid conflicts. 7650I2PControl PluginJSON‑RPC management APIAuth required; default password itoopie. 7652UPnP HTTP eventsUPnP control interfaceSupports automatic port forwarding. 7653UPnP SSDP responsesUPnP discoveryUDP response listener for device search. 7654I2CPCore application APIUsed by Java apps and i2pd for router integration. 7655SAM DatagramUDP bridge for SAM APISAM v3 support for real‑time apps. 7656SAM StreamTCP bridge for SAM APIPrimary non‑Java application interface. 7657Router Console (HTTP)Web admin interfaceLoopback‑only by default (127.0.0.1). 7658EepsiteDefault web server for I2PTunnelUsed for locally hosted services. 7659SMTP ProxyOutgoing mail via I2P‑BoteBridges standard email clients. 7660POP3 ProxyIncoming mail via I2P‑BoteServerless email retrieval. 7661I2PBote SMTP / Pebble BlogPlugin dual‑use portRarely conflicts since plugins don’t co‑install. 7662I2PBote IMAP / Zzzot TrackerPlugin dual‑use portUsed by Zzzot for BitTorrent tracking. 7663—Reserved for future pluginsUnused as of 2.10.0. 7664JAMWiki PluginWiki platform for I2P sitesOptional plugin. 7667Router Console (HTTPS)Secure web admin interfaceSelf‑signed cert by default. 7672Railroad PluginPlugin port reservationLast documented plugin port in series. 7644Browser Mode ProxyHTTP proxy for I2P Browser BundleUsed when running Browser mode alongside router. 7647Browser Mode ConsoleRouter console for I2P Browser BundleAvoids conflict with 7657. 8002I2PSnark Web UI (HTTP)BitTorrent client UIIntegrated in router console. 8003I2PSnark Web UI (HTTPS)BitTorrent client UI (SSL)Optional secure mode. 8887Router Network Port (Legacy)Old default for peer connectionsReplaced by randomized 9151–30777 range. 8118Privoxy (Reserved)External web proxy integrationNot part of core I2P; reserved for compatibility. 8123Polipo (Reserved)Alternate proxy integrationLegacy Tor proxy compatibility. 8888Freenet (Reserved)Anonymous network portPrevents conflicts on privacy nodes. 9050–9053Tor SOCKS (Reserved)Tor proxy range for co‑installationAvoids conflicts with I2P. 9150–9153Tor Browser SOCKS (Reserved)Tor Browser integrationReserved for cross‑tool coexistence. 9151–30777Router Network Port (Random)Active TCP/UDP transport portRandomized per install for anti‑fingerprinting. 1488 / 1776XD BitTorrent ClientStandalone I2P torrent clientAlternate to I2PSnark. 31000–32000Java Service WrapperRouter process managementHandles service control and restart. 3456 / 3458 / 3459Tahoe‑LAFS PluginDecentralized file storageOptional third‑party plugin. 4691 / 8997–8999Monotone Version ControlDistributed VCS supportHistorical usage for developer tools. 7070i2pd ConsoleWeb console for C++ implementationEquivalent to Java router console. 767xPlugin Range (General)Recommended port block for pluginsDevelopers start from 7672 upward. 11371SKS/GPG Key Server (Reserved)Key distribution serviceUsed for PGP/GPG over I2P. ## 实现说明 所有9000以下的端口(除8887外)默认绑定到127.0.0.1以确保安全。 router网络端口(9151–30777)必须对互联网开放才能完全参与网络。 i2pd为保持兼容性使用大部分相同的端口分配(7070控制台、7654 I2CP、7656/7655 SAM)。 插件开发者应通过I2P社区协调新的端口分配以避免冲突。 ","description":"I2P 端口分配、插件端口和保留范围的综合参考。","id":"69ea4623f7bc59ab65ef7ea636966780","section":"docs","title":"端口分配","url":"/zh/docs/overview/ports/"},{"categories":null,"content":" 0.9.57 及之后的版本由 idk 签名。他当前的公钥是： 下载 PGP 公钥 版本 0.7.6 和 0.9.56 由 zzz 签名。他当前的公钥是： 下载 PGP 公钥 -----BEGIN PGP SIGNED MESSAGE----- Hash: SHA1 我创建了新的 GPG 密钥和子密钥,并使用旧密钥对新密钥进行了签名。\n旧密钥：\npub 1024D/A76E0BED 2005-12-16 Key fingerprint = 4456 EBBE C805 63FE 57E6 B310 4155 76BA A76E 0BED uid zzz (zzz) \u0026lt;zzz@mail.i2p\u0026gt; sub 2048g/74C8122D 2005-12-16 新密钥：\npub 4096R/EE7256A8 2014-05-08 [expires: 2024-05-05] Key fingerprint = 2D3D 2D03 910C 6504 C121 0C65 EE60 C0C8 EE72 56A8 uid zzz on i2p (key signing) \u0026lt;zzz@mail.i2p\u0026gt; uid zzz on i2p (key signing) \u0026lt;zzz@i2pmail.org\u0026gt; sub 4096R/1AE988AB 2014-05-08 [expires: 2019-05-07] sub 4096R/01B5610C 2014-05-08 [expires: 2019-05-07] sub 4096R/59683006 2014-05-08 [expires: 2019-05-07] 我将按如下方式使用新密钥:\nEE7256A8: key signing 1AE988AB: email signing 01B5610C email encryption 59683006 release signing 从 0.9.13 版本开始将使用发布签名密钥。此消息使用我的旧密钥签名。\nzzz 2014年5月25日\n新密钥如下：\n\u0026mdash;\u0026ndash;BEGIN PGP PUBLIC KEY BLOCK\u0026mdash;\u0026ndash; 版本：GnuPG v1.4.14 (GNU/Linux)\nmQINBFNrjZsBEADMHWiucM8ES5VDfq6n4M9DJhMyG5jVoakzSFHfzVOEpHeDYR1E eaEIFt5CEx0mbpXWy6UBoj0E7o3se5RvF81VQQ4xO0MyHZLkpotGffZo7D34uKTd 1SFbirosXwnsOxjPGLF+PuwifV+mzSoE66XRmg5UJbOJj0ZitYBn4lDKMxU1Rext WX7D79qnJW2GXv/HuzTwZ/KV3fOVB782+fNdFBDZt4XHSM32ideXedTtTJ+FXjBv 1/eQ/Ls8PMYKaYUm/j0oTI2A5aNP+6BH8/NrVvF8xQWCibrOILASWFRJE7insciJ m9eeEPPOp1D4fRDWFyjABcn00fv7T7RDBgIdpuj3gBDvGXgx8SRiWxe9CwV9TcJl WNPTAKd9XGHT13XWwc1myO/yg+yQoJB6HO1jGjqxQuu3aHCw2i4gTHflq4qZoSDV oxJWeh+mNsfx4DgmoT1UeEmh2Uq64czMGh8wJC0FqSa+FmgCKa1FxcTnYlfIjR79 qwbEKK3JZ5PPkiK5Lh4hNvkXKLrUXpG1KHm6yNVPNIWCOMd7VCDziEhsbeNPCzQc 6af8dkyI9BUeQD3fGjeHCh/QHLju9Lde77GDddYaShXVI/Wiy4AWgN0KVUk8CnEZ Uu2JbazpJBLGGiB2CujP44eJzm9VPoBx8Xc9/Pk2RFbz2bN4uQtSD6lAjQARAQAB tCd6enogb24gaTJwIChrZXkgc2lnbmluZykgPHp6ekBtYWlsLmkycD6JAj4EEwEC ACgFAlNrjyYCGwMFCRLMAwAGCwkIBwMCBhUIAgkKCwQWAgMBAh4BAheAAAoJEO5g wMjuclaoxkEP/RQRz7kWfCWcDWtKSxq1zA3HEUKUHLxhBIl1C+tmMtJypyWwiP8Y hrO/Tuk8nsnVOl9wMMtz2ZxMpUS2gTsuquZ6pIUCNtEP+IAuKsZlCcsNB+yOoi2T i71cXLBPcN/rbxyoOUMpk+fJgdsustUnSMbXJQ2sLjieurD/YpUMJZw6KoNVrhU1 1nDaJqAq/zouhSvNMvx5+GBodQ41gvtb984xbrNc8B24upCBHSF1olczWYPUtaAi oMlZTNr5XFS//Q8X3sEKAoRMbAX6UvZVdtgqQajGilMg+HM3HnbPqsHoyPWx4f8O n134ITgrVwL24y+m9XHfY+JPjcBgg9uGLuLJqMrrjYfz7jVdUJQUsy/R2+yzg1Bm Ruf3SBhHpG2dSBOTxi9GD4aL/7wXuXj9uIuFtX80EwsT4XifnIaHTdtNNzVO+obF dJyiIpF1IFmFOTgJ3ba9gcILQIWXGIp1e5C8g2MtuYO/6/jZK1lhFCLbvhpA9C4q uUp6/WXnavd3beKltkzL1v2dOjC1EkjrsFF50olV4f3d56JdS7JEnFzx7gVeSQfF uLR/t22CluxzubcYoAk/hdIWM2Ufi6v6ONVWc7D5nYBW9onNRKEquA/qOHZr3C/M QbRxTYyhaMW4Nrwck9jmpcQBE1EzscX3DAr+3W+rnKDCZL5QuI2Yq5gkiEYEEBEC AAYFAlNrl+YACgkQQVV2uqduC+1XMwCcC24MIzSxDOEpX7c/ecTKm18bOQkAmwU9 WqqUgT37bQ+U9ME322JPrBsitCp6enogb24gaTJwIChrZXkgc2lnbmluZykgPHp6 ekBpMnBtYWlsLm9yZz6JAj4EEwECACgFAlNrjZsCGwMFCRLMAwAGCwkIBwMCBhUI AgkKCwQWAgMBAh4BAheAAAoJEO5gwMjuclaobxQP/0oU+/nhTx7NRUZ3Ay/LzD7v DHqX+A1iPos1Xzmz+vq9a7z/mjjiQn0wfFiMctFc5dRf+hSM+W7BUfcG5rML+416 rEgtCDsQ0KfaFYUPRObxxNRdDv4N0j6uw2hFmAZ+KkOxKf5Z5CV7A2dwpjsO+PSc Ed0BM1iAjzNbod5b5uAn6r/Z43GSH2omRdhE8Ne5UrH58kLFSg8+iAfnnV5SSEKo bkP0f5m91esbh+vAgq0nFRsB8PeBYklw20wnAkIy6rmKJngBpiF0KfC/V6NY3g63 NDqf4wbSO8WqnrS9QWqYFzJfDsARQvx3jBqLTcQ4SlpIVWKNeogkeSeuqCVKRgvN jWBHdfABkf+DHrzlf072PK8RtDZn6wn1D91MeFCvg+Ss6XV2d0JEd+bxdK6Aj1RR X4XGv0jcH1Ftm9JRNjzXsALzndvwvEKU2xgDA2LATA7ikKbIq19VoTf90uc7i1Os 6cOXZkezZatyuJzJITGeq4llek+PVFxU/5LnRLr6h6K5D0/5F9KlgtPJKgSDOipp TN1Vof8f+v1/zWmyxpw9jtkNjM9chtOY7xhQfNxQLZuHXjQtDT3+JGo6/gTqj105 Yg+HNTJjkDYl2Y5AHb0WFHUFSn2GiBtot4V/g2ojMeQIiw2a8v17H6HUZSKYBjgR L7ln7O4oBduvaSSyZE2jiEYEEBECAAYFAlNrl+YACgkQQVV2uqduC+3d7ACgpRpk 13FSAhz/RpPnqYwRSFUiQTsAoIewgMNIxgbPQGUVDO3FpzChAfUruQINBFNrj7YB EAC8GDV5JcAcktMYnUbPxpydlWSDzzBaDUvbOAtWbrmkwQUXyij0O4ZW1W81e0R+ APT26TLuqc6Q+v6b0rWlVoZkSKYaqzm0S3mtLWUvEgPjHfYXT7VaHtzu6QUPwmVa w+o8dxkbajl5C1i9CZyr8ACziD23FSPA5nd/WQ18EAbnIjnT4cV9dP7lLqZAWtzE Cp3ze4ZHt6kg5i6rhJBJWbycHAZK2SMclC37S6MtZAwW0pJJwn/qdj7UvmL72QoV qXNHe8dfKfnxzo0/HoCKn4rlIW0W3xHgqy6VQUnyigL0blrVmxzcH5bgttXr94yh MVV1Kg9ie1GfhPf1ui86NnGHczbZB2TmTc/d2Nl1/L3TwxiWX2fv9BF+mVczRiXc 9FZRTF5JsBN0BAyxIE9vDXK/yygiWRSD1ND/0eTmKJRqOplpXoCBSDCsfvFN6/63 mx70wP92bNMmDZ/zbjFApmbMCjf+0wCZljiBtkNgT4k2nOYjb6Kt+vOeEg1XBTqo WREHEUA23xsu2DMH5Ra0OA0NwA9jrp1dg4t7fKIkSlBLNlIsZ73lNV21uuA8lVFR KHRX7y394c5/T9c8zPtJSmIZnAY52KXBFfsM3h+ExaQIWclyU375kYi0IBE9tCfF 7VuX1JgvA/9SjjtgfEWWLkhkPUAUl82e8SYQRx5Ki3RIvQARAQABiQREBBgBAgAP BQJTa4+2AhsCBQkJZgGAAikJEO5gwMjuclaowV0gBBkBAgAGBQJTa4+2AAoJEA6+ gRoa6YirbtsQAKheBU6M3oAfyAJ7i13mPEY2EvZFXdY41ct89ebdLCe4revG5Tao Fj/OmD0W+eBvRbJvOglw+0wYjpjAsnl95kYCBRL/BAr9xWt/g9SCcQqxOaYI9gM0 pFAcPjicEF44xdSMDSWGpN0PT5M6omlz5EObxuU3vaZ8y2XWYdvW8p1AwST66y/M AoACZqJUsIo7HIsz607XzNa3evIkCuGGNbTrD0OCTNUxOhwtqMIt3bHE2h4I8Hwp hptTf2eDf2z587/32gs3yp/VAeP6dCeQF3+Wduc41aRsCru7HnE2w/BiW1nzePyK 6b3RA56bZcbANIS8k/+EVOakS4uRDnweqkwBVgkWsCk17+XNeIaRaY0pWJaFs+hO f7cdp/XK+z2eFO1brEJa3BmnHHMx/lUv5YS8MgD+CcdvHvb2dirthzvyb6yDKFNn ZkMz3/Z1wnlDkMp/fjJAwXfmKT7IOqPVN5fpLcXp27Jh2BSrafvLupkIzZhrGL7R hTg8X83rLuQ0ZSn8k9cFju1pECI1atXC/kPMlSC4VffoViqwSZDLFsniFSNTaBOw EfKCLxv4s0BNovaUQfY2DUkL2BHrU18HbpGkaD3Gmb6TnzBYRTWSz15/9w8cjOc9 rr9d5SZaUeMZkGmlUdEG5q43b0MwQxYSA4Y3ZZGMgbjzEa83YN2njV7U07MP/1C2 D/tpWM2SliCGQ9ioPZVnwB43sme7J0GWjLRR085Q8+4V3/buWNG0UBc+l3MNlO0m N/zPp8ZqKCe6tLIXiExgiMSfcv9/7G3AgKxfzY+t3wFC6ISZiG5JFQIx/NI6zR+F RPUXUf8ZWH+i49p3UY564wULQMLobMuxhO2+BkjZKPkHAiXB0FTdP9WW/Gt2vWgZ L6ogdmo2bo2BQCU0VOOlCp8MxL9MlQ0FGURT/2kGoFzNFUo63UGvJc2iFmICI//9 OGBkpEMuPGrZI9W/4NTh+yMYj1b176IssWU2PWvhpempaXbcgXnlZQ5x6qcszzrw m403O814RLkIljRdtjHWOJKygXpjj8qTbDFfLXWDZ6MTtZOgFOPHFpc+Drbyzgu0 Z3dwXBeoyXQaZGOtClVJTCUYMjE6AaWZrnvsjT2TSxK+oy4XXzI4vVvDMJh2Ibfs YKiRahGQnBiYEMIrefoj/wu2GaZ71y8P6tCfdvlv9DikIVTHajdG4G2K7Sr4glgk cB9M2IsSy7bw2OGrGFvkpqriL1aYvIF5Wf4KIsxpMZ2FIUeGP4YfT3ec7zfSC5bp /yBP8J/XXaCV8NkhLF4bD9tU+XRRK54LZkoDrJwmTreHknluF6hFuJl8d0+oHyjp kHp\niEYEARECAAYFAlOB3xkACgkQQVV2uqduC+3+UgCfYZiUtx7FDGdQDhdVP8MyRf0D ANIAn2YHOQh4yv84u2Kuars1gC0j3Nr2 =Zu9F \u0026mdash;\u0026ndash;END PGP SIGNATURE\u0026mdash;\u0026ndash; 从 0.9.9 版本开始的发行版可能由 str4d 签名。他当前的公钥是： -----BEGIN PGP SIGNED MESSAGE----- Hash: SHA512 我当前的公钥如下：\npub 4096R/0EC51FCDA94FB53E 2014-03-11 [过期时间: 2019-03-10] uid [ 完全 ] str4d (http://str4d.i 2p) str4d@mail.i2p uid [ 完全 ] str4d str4d@i2pmail.org sub 4096R/1CC61D9B33C3241B 2014-03-11 [已过期: 2015-03-11] sub 4096R/803DEE491A3473E7 2014-03-12 [已过期: 2015-03-12] sub 4096R/A1B84C9B733AAC82 2015-04-05 [过期时间: 2016-04-04] sub 4096R/13B5EE58C09FB3E0 2015-04-05 [过期时间: 2016-04-04]\n我目前按如下方式使用密钥：\nA94FB53E: key signing 733AAC82: email encryption C09FB3E0: email and release signing 我每年生成新的加密和签名子密钥。任何由我签名的 I2P 版本都将始终使用发布时最新的签名子密钥进行签名。\nstr4d 2015年11月20日\n当前密钥(截至上述日期)如下:\n\u0026mdash;\u0026ndash;BEGIN PGP PUBLIC KEY BLOCK\u0026mdash;\u0026ndash; mQINBFMfofkBEADlyw6v1hGBtnIISujt/18RJcVTLAxYtfe3DsGhWqYZN3iKGGWb NJ5vZcV65FVH/70NFnmKlvYp+tVNJcoRtEYpfwiNG7nIyOC4GgaSLwkNVgLcFZhV mNj2RIJphjN5qsWm6ut9p9CyhWkVNJYDP65gqwShZQ2lPboo9s0XjUF78SrSshy2 iVij0xu6oqdjwqn1B7L3lXVYCwxReCvSdFnBMpjGUEgGnbt7euhrViFk8FrUkAje 2tZA5FAUA/t2Mnc9JREe6WlbZ44mLApOjFdw0g415FdcnS2GGaYuXNG1lJ1yOA33 n9JXT7A31wPyiw5yz7fxgl7ZNYZr2TsRjBlqEhf2SCPfqU9UlhJ9NqApaPyCEr+8 oZQfZ9r6stc98MlnmdQ7p4SmKRwCLiBtgmrB8mbgYV+iOwaKztqEoma3FoO2EJ+j Gx+UrJ0bIFVr6sL0ulfneYlY76wWWRpB/pLLgIMmZw83uB+JDBQyZFXcAHj9jMQ7 ZNn0MNQ/I+qcmX+CRAyl2+cQHUVbbQWDjB3crZlpK5TGw/x7w0YxBYAH8Us5JqJH QOsact8ADnE4IiKm5gVefFmNX6vsljkNESdpAMxnB7Ckl2XV/r5sKwrdxxUbFSxp IKGx2uKGUs4oUffOzpKULhGBWypN+3fVwvP+q896Il9hgyx6SCQ8AgPHRwARAQAB tClzdHI0ZCAoaHR0cDovL3N0cjRkLmkycCkgPHN0cjRkQG1haWwuaTJwPokCQAQT AQoAKgIbAwUJCWYBgAULCgkIBwYVCgkIAwIEFgMCAQIeAQIXgAUCUx/ZQgIZAQAK CRAOxR/NqU+1Pk9EEADHdpsmrA6ZKU4EmBZNbw62D7tAo00Fh25m8OuIkXtOqEbF /guTZiZM4nbhZpPFG9sCN1bXS8VslA7isOedbznkKnSK0BJcrzldwKzW25cwptoQ CCqTUarYbhcIzEOKNetYqICWrVTy2Yuc37maA66PnRLphV7pP3Fj7eN6aMtqwtpJ YukIU4LAjKOMJ6gwy7tjsZYbAqgSE8wRJm7i1MfO1W864a1l2a68Gooz03NC6mfY J8aW0y1F87xMJIgZeN7OyHf2AC4/Tp/cL+Gd3HcUuoRjmWBgaxH8tVNgfxSIUMNH 5pTdDs5VlRolwlOEcTW5VxOSu5C7ZbuKyFmbI0DSevDVGS0rxSSizjlyGmnxkLU1 ozpeIwTbwTUzvd26+k8cidGodKqoNoyAXzjaiBXYKgIrVeXBMHxCGeQtGeEhQR+L OXs8cEX6xpt9g7nKbNki0Cfv/lx9Byn+0v9RvMJKDa1mOSKbNOx3NJ8+ewdTVkTs iYFTZwpJexbfovPYqTdisiO7dv0i5teE8sEj25icdPtKYvn/55JCT67E8MVZaeyU YOaMPtgsiOX0v68NtrC1L37UuBykQlm7FdobN4Sg5FnLTt4IWktf0/vsaLdhRozD KsbTmsumCrScAwZfa0H3S8WqK6yCEKjPi+J4xG1OZP1WptlV41wLnFKkeFaZRIkB HAQTAQoABgUCUx/Y+AAKCRDV3jiWlKRlsmU0B/96eiPHIIvapoXKoZSt23OFjXG+ 3xp/Zzf2Ug0384FYZJ1eX/R2IWsh64CVvOR0LMFvHvPU7SCMu2OreNHfPx/B/kn8 MmusGy6JHP25A4BWzs1eeyKgYQTFz7vSCeAnytmcdBot1s099upIRw4usCLhdxzv Qyx6TogAacGC3YFj7o0agz+ApPnCQZ68kZpDOCDrtOe/DRted1LLXM661Cp15d5R d+91ZSKfQ9xjK1d2k8iMYJqWYll50DalGtzPGDB335gX7agliI5dYiu2XSLyynhw /7f8d0Bz8KVj7pgCroAVjTSdHvZfVcZJU4HST/jHx5hilVUzkr9NK5YONJ8SiQQc BBABCgAGBQJTKlm2AAoJEPvivaOtdGgqmGAgALl0eAcUSF7IuloPT4VyJeNGMuOb 7aN4yYrGBM+y7Ij/dTWSS1yjlcixsqd+s0dqGse6RtJkyhkisEmNdS7Sf62okGDl ZbmhjvMQteUO1zw+CREdfx5oMpW/eCHq/Pzw8KRdp6qY0wBRj10GFMAaMX8XCNOh 6B6Ti0AQ/424yEvcPpA0zXwvLGylFozRxjK6qWEHEmW/+knxYYN/W+8TERuwVJSN F3jBYl73DTVBZ4bzpu5jMSydhRD02nV2LbnolhbCzGllLkhQw6iFW36br8600Tba loQhcJU+cmuCId/B6xXcF+fyWqmMmm+b0UFoHGRBnXCf4gBcjCK0UwJ1lUOTY5qg IYJTrBpCrGAoGTd9s+1CtnnZFlIcwFJB7NwMZEsTWvOvO6sZPYP33ktcUwWAKqNj 3sSjy43kdfUeVip0jzV0K5uStC+DiVq8VwH7uNIH2UbkQZato67WgShUCCaSvf2p HapSRdrmwIaoANQuEluhytdafX7yqJXGkhYI0Ylh2FH3oZyTnz1XoB5y5T1OpFpi I7CgjRO677aieRsf6HACHPX5mWcq8zJQ8fuxoHZ5GJ8FEyk6ULUgFJ3u9SgG5k5I vP4pK8+lP/d90Zf98Uaq4aMgAoIlrtwz68Bv/KUlpwVWhiIgo89C5UwcTUNQOmi3 0PxCpamM81NwGPxjZAqr/+0YP3NBtJOITL0oqRCxcHCJ9N8gmqUmUEgEffP+glsJ p/mQeJEacmR9loz6WAB6GT9mu5TvX6bZ5EawnluQ1mI6Tn+v6ltjhKzPzaVhOo6d iKriQFZhcelX1qDnE3zs7driBeacuKGt4URV8A+UDGJBeIAEfrlszor3FQ0qOUPs plbcbB4YudUOhlH1REtGx7zWVFefuy80ZC7abHsPhWkJow2axWlvPqjSsd/KgpjG IAHIZxiYAozNJqDNluGx1+qa1d7/YINthZKefhkG3XDLuhgxvD8rAovyAFW/8Vy0 S+GpzUVtC8HY9FZf2gRkVtZQGboZck2uFyIaU/Ni4ahX8Z9IvtsU9JPLzp0HRgAv 9kz9EyRZt1viueeIVcmadHirUe1IKqndeslcXOX4dUF0nrqP1+shYhebgq93rMPR yH3EsoXtAP1KCN8tWPdnlDnMY0Zpy32mfCL0hMMnH+CY5rARssSbiFP9HeWk/CN+ yES7FY705QmV/2SV4rEngqnIcrcqEJFp49JPihC1pSikHCItzSVFaODbUl4qhTjn Tjtl0pdFQc9ksA/6IEOH/bufDwtxCLwAjUpqyNGEH/8FnxtwotsTmhmTWMe9vxYe YStdTLkAvJFMVEU0W+H2ZZG481P5/8tqFS9cHEU++3VvuYxfipwjpIQhm5WJARwE EAEKAAYFAlMuEVwACgkQq+DDGd8KChpPGwf/QL66k12OzqI40KQL+UbzW25vxbmE OyZ1MT9SuUVt6Th9zdoNm9Cosi9kOiq+DPLFFT751Lmm1hcM0rDDNeN+l8wpLwX9 EifD/bQ7Q5esM8NJmGVyhA/Cd3wkp5yYNdZPOu9/0xpe/Px4YgficRErhgyVh2Vs svQRQ0WcTYbgbmQFpOUsjNVOchJMFERSJaQxWgN3olYd5DTDxPDLztt3vdBCIkz0 4OAotZqbqdnmvlkjKjzrJylfCkyo9bOU471v6Hs3mfUQXo9nXC9zGETFWsvB4WCC QdWEyj+2K+PcdZU0FEPonfTouVcsR9oTqQqqfg21M7HUHSmlrOyCLqNnZ4kCHAQQ AQIABgUCU2vk5AAKCRDuYMDI7nJWqGIzD/9vdI3uUUYGCaURAprGEo4kk6JP2TcS AmyO9Pr8bBdpmt/DVFK0zWllQ+69QAWLFoCmgjOgWUPRNWA+ldG5lzExjuuP38P1 4HupPMh0yOd+QUod4Gdi+hqPCuFT4/oErWZcOGGXAw4ZcvdEGKY9E975D+3yd7sG HGskvGB/UmLIBQ2XfQOoqk0A9eXz55wLN1ia1imHd/0NkPkQOHkjTdOtHhcBhuoc ttex9HcmYy2g5oorG+7wx0EtHxIhuCcRq1wQgXm2JtbiFHXiH0MpLfBr29kpzH7y 8jompGgAJsK8uRwTC8UFWHnx0VxnFQ+4vinqlgj7/O+WMZ/siDlOZDo2RC3ts+Ct 91kYNFHsycrkJYuoPzNcMy7mmixQFj5L2VIG1Ne3OTdEPVWE5jIQ/w5IX0aYxNt4 ANIZJA/r1AqDqDEhto6gdnkrVZSJN+Mvd7yj7XTbrErpTmQeNkGgb9ult4XaEOdm bjAjE6rTQqFD3Tn8SeXNgkJFr0Zb8lZypmOL6cxU4vTG66blJPLZGuaH3yCrtA1i ynZPrV2TYiET+fhg2TBEXbjLkWHQnA+7sFFOTgK5WOqc6vK29h5ssEQKIFodDh4a e88tiGLW9lSc+YWRpKHgEc8QDXIuBrV18hZEvbITvLZnnf5uIFXJV5ZCHG+o6I+Y jQrPY4oC2HGrMIkBIgQQAQoADAUCVRRYygWDB4YfgAAKCRCFZ1M6Yr7+XbxwB/42 Kbk6DpZueEK0qtdoLUh7H+dWfwA0Gsh/vCoS6RM9iXjKPBoQGlbCBpsBpqCJkGd/ iXH+tnkU2dq4BvGc/igSHadNYmYq077l1vu3pJjDjxfQ2qZSF9D27EUzlXLd4Q6s hysZ18HoTehxr3AG33N1tEm9kBUfZjeMZxk7zbty3Lo7tK/UYN+4mIgYqLc97XIe 40Z\niQIcBAEBCgAGBQJWT6iBAAoJEBO17ljAn7PgnxIP/RevbXaCm2Q3ildI0YLjQFDr vSIGKsCjD9nZY3ETk+CNFGOL4aYWp96HWuQoMq7B6qlb/sLejN/Ssu3M0sxf2hNK pCIagZClqRchSBK+0UpAEIs98sf0sPakqKg0FlOJhuCsKHMUOxpQJ4qCDh6f24b2 cqKR8GjyUAgSeiiyN+DkDyqRYingQGAU5vzKepYzX+DMHC/izqQhrwQLVImv20wr 5pKZJDjfOpYUZRTuScV5Qwcgc0JYcMOjfgA93ZUA2zDrGIpw3dcCSMrpNQcvM6Cg 1mfiLZzkvPH3UkUOWhHCn/N2XaAF58joCaS+/bVUaXx02IbxJ1TTjqtCiH9491mE aaHeRCFYbkKCXWjuxCx1+VZN2yRk24rSkis/+LFgZm850fXgYfrqiyPRDlCMApdo 5JDUBTioyZz24vhqWpe0OZueu11DXtpU1G0BiheGrweXAAx0Yki8dRiPTXkavAMj oMBND9G7a1564KOe+t6V2qUyH50+3NaANvIiDJZbspX7yl8eVzPbwcGvtHzmHdnV pDh+38XUQEID5YJ/mdZh6evzmmTnQR1HVqPVrzs8SwIDO++tqj8DXTjID47c3VIl YhCMNlucciFxVn/sYI5qiJzCEMLMbvG+EhnoLNU4JGjfzo6I0RCpPfbrDfOsWJNi zYMz9htqusCQsGwUZSTZ =XBC5 \u0026mdash;\u0026ndash;END PGP SIGNATURE\u0026mdash;\u0026ndash; str4d 已签署以下版本： 0.9.23 0.7.6 至 0.9.12 版本由 zzz 使用以下密钥签名: -----BEGIN PGP PUBLIC KEY BLOCK----- Version: GnuPG v1.4.6 (GNU/Linux) mQGiBEOjTnURBADegKKrIP6pz4+n57dqo3l9QrKhIklCtIxgJkL06ZJq5fKAnMLv GPaGXmn5vRrbo6QzHs/lGLG+ySWFWr9SsVstNKrwk+F1yGIERutl0BqMwX1esfN2 ugiZ3wB1yRu0PIrkm5cuDAFASFE+2lBjr1lfOrhw/dV+lLTcWx4NzkMzlwCgxgIk 4cqQMGaVkmtuICQdYmmMicUD/AmNSVJEm2XUvaS5fYWsHJG3+oNkdNGcx5SOMUdk PFwcSozqvT9FeIP76OVHAshQKeftE3utOFANQ/YomXEnypmwMxLLR+GPw5pMbKlK 6p+87aJZz+SA95E3ekmh7MmndvRd5RJDboUZy2H0FKX+FgaBlpsLl0uhT6uDuM/s 7nb0A/9nEAgICOU5SeXtO3jKY+RQvKyE0AblK7xVaU+Sn8ly0zauOJD13rycVGhu vLcAUVR3FKEjxafpvZ0ZPBo7AACjSDqAoCw/s/vt9gmrhHKiqN31PhYYLhKdfKTs 4LzWKTWKIAOwErkbYsMAXWKFT3LXsrEYvxq5j5m/6zMOwz2N7rQYenp6ICh6enop IDx6enpAbWFpbC5pMnA+iF8EExECAB8FAkOjTnUCGwMGCwkIBwMCBBUCCAMDFgIB Ah4BAheAAAoJEEFVdrqnbgvtxGsAn39SvQ3+ey87WDDG+TWArN6oU8gnAJ4zeAsA LUK37WZIt8OImZSxk37uQbkCDQRDo06VEAgAy2UeqsM5a+U6ZOWS9NQiILb3KbTL FeeAd2rn9oLSLpn5gDWycwUS0Q62JmbSMWy6m9aczpnxvwaBYXz6aCIvZmTNtaU6 vyR/6wfJDyiUWSHtCyjpyFFYJimANd8Y8dDCimvceI/ihEDVyBX0kkgUGRAn8t3e unaLXqhbfiLiFw/GG1MNxUMzHt55/+9AqLOfRZg0riZvDoV79K+1sYSs8n1WeaVc T3wTb+Cb7fKNN7GT1MUhcXIoYYY6FGwsy5EWFsxYBRervqHtBJog2SoNUa/6BFGr zX+LDjK9L3xMTr3+fHIt4gPR/Lt4nnfEzL+rjClz/Fazmv38BRwPuKahFwADBQgA nD/AvZCnbWSB6khAVMqva5ROaD0gV0/UejCelZdYfgfHeCmrcMNQ+wCyww2NPsih 9vB1w+AUE0pdH37k65VZN+2falUdzN+PFugJGuH2pmlVOprH2SuC5gKpGRvzUqV5 U0nJmT2okDpW/52asUDJJLu1g//A3qBP83WGvSKUZg/ZisZA0qTiHH4QpjklopXi sSxR2hT8Fr9gF9WmDa09wbxE2xh/EL7gvVg/vk0gwOJcsFd67bNC+KUMOnjhOP0T K0/Ah4TEEs/hHNe9RsyyWlMoIUsF8AhG71ISOrJ5lLSXNe151XEb5FzZRM8sD9Zq 0E3PjmLbdVhanYvsPnWK6YhJBBgRAgAJBQJDo06VAhsMAAoJEEFVdrqnbgvtXTwA njMu9ueCFbsjme7nwsz96PdazJcHAKCce17hGI25QNXDZyHohrjha6IxDg== =fAfi \u0026mdash;\u0026ndash;END PGP PUBLIC KEY BLOCK\u0026mdash;\u0026ndash;\n版本 0.6.1.31 至 0.7.5 由 Complication 签名。他的公钥是： \u0026mdash;\u0026ndash;BEGIN PGP SIGNED MESSAGE\u0026mdash;\u0026ndash; Hash: SHA1\n你好，\n我证明以下是我的新公钥,签发于 2007-11-24,有效期至 2009-11-23,其密钥指纹为:\n73CF 2862 87A7 E7D2 19FF DB66 FA1D FC6B 79FC CE33\n如果你有我的旧公钥，并用它来验证此内容，你会注意到我的旧密钥已于 2007-11-15 过期。对于更新延迟表示歉意。\n对于想要直接从此消息中复制密钥但不是使用电子邮件程序阅读的人,请记得删除公钥块开始和结束标记中的\u0026quot;- \u0026ldquo;转义序列。否则它将无法被识别。\n复杂情况。\n\u0026mdash;\u0026ndash;BEGIN PGP PUBLIC KEY BLOCK\u0026mdash;\u0026ndash; 版本：GnuPG v1.4.7 (GNU/Linux)\nmQGiBEdH5SYRBACzCum9jIjq+/G7ckuZ/TcFmaVYeBRE6OXPQozyrmTYtoCM2qGj DmvMJvKYiNiQVM42KiwlnqvaNtlgnXIZ6rcyLyn+bCI5cdX1SD5Rr5tgsgcXYA6Z l7usiFv1bTjD67piBehF130o+LZAJnVzI7JdpbA9SBY0mUwgKXLi0DAo8wCgiKOV UXC8+9X9vU1Mh/GyIrD4c3kD/iQOkYH4ajNaehTHNB31K+61ltpK9tMmcWtUY30A Z3q38jg/nmqqup/MYCtkvOqY4X9kujKzu01eSWSNZIE+BQSSd1cSsVD17OY3TL6B EvE+UFxh8OnDKs3tzJ0COnT/2zbgTavbWwqovoUE0P0PSYOFm2Co0BEQiCt9Tabc CxU3BACRWDvq7LFMRnHT+/OOJS6M442CYzy3+tIuc3ZAmZ8QwGsh4r1kd+5P1JTN YJCun6MPQEllJbRyHRBby76vFkWearRgnkpAmk2l1T2SXw3lip/SdmI0GgIzPSfQ 8WyNbMjQXyH8/3k2Y9rgrC0DttrJPYOcTFMNKPpeTR+HN3ZnibQ+Q29tcGxpY2F0 aW9uIChodHRwOi8vY29tcGxpY2F0aW9uLmkycCkgPGNvbXBsaWNhdGlvbkBtYWls LmkycD6IZQQTEQIAJQUCR0flJgIbAwUJA8JnAAYLCQgHAwIEFQIIAwMWAgECHgEC F4AACgkQ+h38a3n8zjP1yACfWkF1zjmlD0EzLaJRnefW5OHr10MAn0fgMyElK6ee AoPl2mTfxQQYOophuQQNBEdH5SYQEACTcoMJQBhyrr+EunLmEGNMO7D6RSBAtEKZ i5ctmhr/TCXMV9qjXkWISLZ9AS6z88rKozeOOK+QPBnc2FcEf77N04O5hwSdAyPH Qt7+umhiNQFQpZycJ5W87Y0ryERJygA5XyU47g7CGvuuOLgKGk0dDGCNFZGSblwI xtSh1CsrjWp23grFiBS0xvlU2VyuYUyrBuH5ip04pxmOyeRcaelkQerFhEXSRIR7 XFxl6JpfqWt2oWHmYbYD3RT6WHU+rpSF1Hyey+zoF2zXfRb+JD90MpBL1xIkpieQ Y69Cj5U5VRjEppJJowSmwgz+UyMnT2KLl45vJesPrMUaSgduHiIQo4LM5BcbbV+2 SC5i9xqbSJ+rc19Ftt9IEUZVMLole9PJC5Ff/h1qsabyueFuMIQkbiaUiNLOKl31 I+JAiDt0Xku2PEVCERg7Jq5AsTLB9D+zKqxbvFu+JvqSdlaCvlas2BYU5rBosszH TStK2XW/+poTKnjnbJl6nGC06BNQPhRFAwuXboyUC5fyiuG1HohvPmPIi6IejLUY G8A5nZ+7um/XpKlt2i5rdVRfN1BX3+aKHQeLmrc+EIORZUU32TrP4ceLtSDf+JOW 8N3vwzqKIPu42Y5KB8vnXEFSOkyt36OfEd6CcPKmncDyA4wJmfC+X3eoKcj+Yrh7 UMr0elyw4wADBg/9F7g+bTpT4wPXj5ax1i+4BdedjVlO3YBdhc4LP6MXipNU6yLl l63TJ8q/l8pvSkUWZXrO3a7OibM/MHp0Te/7sTmKib2/3MFwHTrtjgcZBF6wx8LD T3oa6O0IK8IRnRwNqeu83SxojvVY0wLz/hpUbnIrOcHMZjWLMJEfHkNBHn+1HhT5 tk9LRGu3j1oTpGh+DpdoPF5fggNu48YJ6n7etJJGW2MXQ++33aKeQSFrx+KlMtFW DSzg3KKSroB8Ex9wiKKWybagaed0YoP9BW3vIAaOeDpqK92UuTFz1Bte1DYiYU1e Rqq1xoBVhJXE5xzGmvS4/PIZMOL/bpKcuNxAgmwOVoaYoWZuIgePUaBbNvNg84HE RBjFMyfpzRCdPlWPZ18KcLUki3T58KzXEZ7WS5hC5lezwC6ET+wJusAt0A+Ik146 igayKfVnvhedQdqufWhQWNr+hDc5Fb/az8nTyNOflAhD3yHldjxgkCOV8wjqyS+4 iO33P5wW7o2QkZNWq8pyjsKRRJCtZ/PJ7FRGkUOjoC/gwhnGvBi0KoDcyBmfnPXp 3MAgrzk9LwiA7PlS7PyhyMx5mYpa90xlXzszweCIXzGfbm6ciCUAM3G3Qb+qa2dW 0u1X5L6bVtHVpYnr+5JOxCS4qwQvoK0QnHu6ezu4+rFutUJN35z6rFquejiITwQY EQIADwUCR0flJgIbDAUJA8JnAAAKCRD6HfxrefzOMzSZAJ9PmYNkW4Ia1qPqowg9 z4Ja+hJ3dgCeL3mqvOEHG7AcUQrSlc6xlC1vbNY= =rGxK - \u0026mdash;\u0026ndash;END PGP PUBLIC KEY BLOCK\u0026mdash;\u0026ndash; \u0026mdash;\u0026ndash;BEGIN PGP SIGNATURE\u0026mdash;\u0026ndash; Version: GnuPG v1.4.7 (GNU/Linux)\niD8DBQFHR/zm4tLxqYRsGn0RAtCfAJ9rz+tsyEbeUAHcogdzgSPfuiWOAwCfWaVn Aiib6V5wOPbYTy13ADmxhfE= =mPFq \u0026mdash;\u0026ndash;END PGP SIGNATURE\u0026mdash;\u0026ndash; ","description":"用于签名 I2P 发行版的 PGP 密钥及其获取位置","id":"ae494d28c5c0216d277398ccdcc21df5","section":"docs","title":"发布签名密钥","url":"/zh/docs/develop/release-signing-key/"},{"categories":null,"content":"访问过滤器使 I2PTunnel 服务器运营者能够基于源 Destination（I2P 端点标识）以及最近的连接频率，允许、拒绝或限流入站连接。该过滤器是一个由规则组成的纯文本文件。文件自上而下读取，第一个匹配的规则生效。\n过滤器定义的更改将在 tunnel 重启时 生效。某些构建可能会在运行时重新读取基于文件的列表，但请预期需要重启以确保更改被应用。\n文件格式 每行一条规则。 空行会被忽略。 # 表示注释，直至行尾。 规则按顺序评估；采用第一个匹配。 阈值 阈值定义了在滚动时间窗口内，允许来自单个 Destination（I2P 端点标识）的连接尝试次数。\n数值： N/S 表示每 S 秒允许 N 个连接。例如：15/5 表示每 5 秒最多允许 15 个连接。在该时间窗口内，第 N+1 次尝试将被拒绝。 关键字： allow 表示不限制。deny 表示始终拒绝。 规则语法 规则采用以下形式：\n\u0026lt;threshold\u0026gt; \u0026lt;scope\u0026gt; \u0026lt;target\u0026gt; 其中：\n\u0026lt;threshold\u0026gt; 是 N/S、allow 或 deny \u0026lt;scope\u0026gt; 是 default、explicit、file 或 record 之一（见下文） \u0026lt;target\u0026gt; 取决于作用域 默认规则 当没有其他规则匹配时生效。仅允许 一条 默认规则。如果省略，则未知的 Destination（目标地址）将被允许且不受限制。\n15/5 default allow default deny default 显式规则 通过 Base32 地址（例如 example1.b32.i2p）或完整密钥来定位特定的 Destination（目标标识）。\n15/5 explicit example1.b32.i2p deny explicit example2.b32.i2p allow explicit example3.b32.i2p 基于文件的规则 针对外部文件中列出的所有 Destination（目标标识）。每行包含一个 Destination；允许 # 注释和空行。\n15/5 file /var/i2p/throttled.txt deny file /var/i2p/blocked.txt allow file /var/i2p/trusted.txt 操作提示：某些实现会定期重新读取文件列表。如果你在 tunnel 运行期间编辑列表，变更被检测到前可能会有短暂延迟。重启即可立即生效。\n录音器（渐进式控制） 一个记录器会监控连接尝试，并将超过阈值的 Destinations（I2P 中的目的地标识）写入文件。然后你可以在 file 规则中引用该文件，以对后续尝试施加限速或阻止。\n# Start permissive allow default # Record Destinations exceeding 30 connections in 5 seconds 30/5 record /var/i2p/aggressive.txt # Apply throttling to recorded Destinations 15/5 file /var/i2p/aggressive.txt 在依赖它之前，先确认你的构建对记录器的支持。使用 file 列表以保证行为一致。\n求值顺序 先把具体规则放在前面，再放通用规则。一种常见的模式：\n对受信任的对等节点的显式允许 对已知滥用者的显式拒绝 基于文件的允许/拒绝列表 用于渐进式限速的记录器 作为兜底的默认规则 完整示例 # Moderate limits by default 30/10 default # Always allow trusted peers allow explicit friend1.b32.i2p allow explicit friend2.b32.i2p # Block known bad actors deny file /var/i2p/blocklist.txt # Throttle aggressive sources 15/5 file /var/i2p/throttle.txt # Automatically populate the throttle list 60/5 record /var/i2p/throttle.txt 实现说明 访问过滤器在 tunnel 层运行，在应用处理之前，因此可以尽早拒绝滥用流量。 将过滤器文件放到你的 I2PTunnel 配置目录中，并重启该 tunnel 以应用更改。 如果你希望跨服务保持一致的策略，可以在多个 tunnel 之间共享基于文件的列表。 ","description":"tunnel 访问控制过滤器文件的语法","id":"d8b5745531fca07ea47765403a9a4d0c","section":"docs","title":"访问过滤器格式","url":"/zh/docs/specs/filter-format/"},{"categories":null,"content":"概述 本文档规定了对加密的 LeaseSet2（LS2）的盲化、加密和解密。加密的 LeaseSets 用于在 I2P 网络数据库（netDb）中以受访问控制的方式发布隐藏服务信息。\n关键特性: - 每日密钥轮换，以实现前向保密 - 两级客户端授权（基于 DH 和基于 PSK） - 在没有 AES 硬件的设备上使用 ChaCha20 加密以提升性能 - 带密钥盲化的 Red25519 签名 - 隐私保护的客户端成员资格\n相关文档： - 通用结构规范 - 加密的 LeaseSet（租约集）结构 - 提案 123：新的 netDB（网络数据库）条目 - 加密 LeaseSet 的背景 - 网络数据库文档 - NetDB 用法\n版本历史与实现状态 协议开发时间线 关于版本编号的重要说明： I2P 使用两套独立的版本编号方案：\nAPI/Router 版本： 0.9.x 系列（用于技术规范） 产品发布版本： 2.x.x 系列（用于公开发布） 技术规范会引用 API 版本（例如 0.9.41），而终端用户看到的是产品版本（例如 2.10.0）。\n实现里程碑 Version Release Date Features 0.9.38January 2019Floodfill support for standard LS2, offline keys 0.9.39March 2019Full encrypted LS2 support, Red25519 (sig type\u0026nbsp;11) 0.9.40May 2019Per-client authorization, encrypted LS2 with offline keys, B32 support 0.9.41June 2019Protocol finalized as stable 2.10.0September 2025Latest Java implementation (API version 0.9.61) i2pd 2.58.0September 2025Full C++ implementation compatibility ### 当前状态 ✅ 协议状态: 自2019年6月以来保持稳定且未变更 ✅ Java I2P: 在 0.9.40+ 版本中已完整实现 ✅ i2pd (C++): 在 2.58.0+ 版本中已完整实现 ✅ 互操作性: 各实现之间完全互通 ✅ 网络部署: 已达生产就绪，拥有6年以上的运行经验 密码学定义 记法与约定 || 表示连接（拼接） mod L 表示按 Ed25519 的阶进行模约简 除非另有说明，所有字节数组均采用网络字节序（大端） 小端序的数值会被明确标注 CSRNG(n)（密码学安全随机数生成器） 密码学安全的随机数生成器\n生成 n 字节的密码学安全随机数据，适用于密钥材料生成。\n安全要求： - 必须在密码学上安全（适用于密钥生成） - 当相邻的字节序列暴露在网络上时也必须是安全的 - 实现应当对来自可能不可信来源的输出进行哈希处理\n参考资料： - PRNG 安全考量 - Tor 开发者讨论 H(p, d) 带个性化的 SHA-256 哈希\n域分离哈希函数，接收： - p: 个性化字符串（提供域分离） - d: 待哈希的数据\n实现：\nH(p, d) := SHA-256(p || d) 用途： 提供密码学域分离，以防止在不同协议对 SHA-256 的使用之间发生碰撞攻击。\n流加密: ChaCha20 流密码：ChaCha20，如 RFC 7539 第 2.4 节所述\n参数： - S_KEY_LEN = 32 (256 位密钥) - S_IV_LEN = 12 (96 位 nonce（随机数）) - 初始计数器：1 (RFC 7539 允许为 0 或 1; 在 AEAD 场景中推荐使用 1)\n加密(k, iv, plaintext)\n使用以下参数加密明文： - k: 32 字节加密密钥 - iv: 12 字节随机数（nonce）（对于每个密钥必须唯一） - 返回的密文与明文大小相同\n安全性质: 若密钥保密，整个密文必须与随机数据不可区分。\nDECRYPT(k, iv, ciphertext)\n使用以下参数解密密文： - k: 32 字节的加密密钥 - iv: 12 字节的 nonce（一次性随机数） - 返回明文\n设计理由： 之所以选择 ChaCha20 而非 AES，原因在于： - 在没有硬件加速的设备上，比 AES 快 2.5-3 倍 - 更容易实现常数时间（constant-time） - 在可用 AES-NI（AES 指令集扩展）时，安全性和速度相当\n参考资料： - RFC 7539 - 用于 IETF 协议的 ChaCha20 和 Poly1305\n签名算法: Red25519 签名方案：Red25519（基于 Ed25519 的变体，SigType 11），并使用密钥盲化\nRed25519 基于 Ed25519 曲线上的 Ed25519 签名，使用 SHA-512 进行哈希，并按 ZCash RedDSA（ZCash 的 RedDSA 签名方案）的规范支持密钥盲化。\n功能：\nDERIVE_PUBLIC(privkey) 返回与给定私钥对应的公钥。 - 使用标准的 Ed25519 基点上的标量乘法\nSIGN(privkey, m) 返回由私钥 privkey 对消息 m 的签名。\nRed25519 与 Ed25519 的签名差异: 1. Random Nonce（一次性随机数）: 使用 80 字节的额外随机数据\nT = CSRNG(80) // 80 random bytes r = H*(T || publickey || message) 这使得每个 Red25519（随机化签名算法）签名都是唯一的，即使消息和密钥相同也不例外。\n私钥生成： Red25519 私钥由随机数生成，并在 mod L 下约简，而不是使用 Ed25519 的 bit-clamping（位钳制）方法。 VERIFY(pubkey, m, sig) 验证签名sig是否与公钥pubkey和消息m匹配。 - 如果签名有效则返回true，否则返回false - 验证过程与 Ed25519 完全相同\n密钥盲化操作：\nGENERATE_ALPHA(data, secret) 生成用于密钥盲化的 α。 - data: 通常包含签名公钥和签名类型 - secret: 可选的附加秘密（未使用时长度为零） - 结果与 Ed25519 私钥的分布一致（经过 mod L 约简后）\nBLIND_PRIVKEY(privkey, alpha) 使用秘密值 alpha 对私钥进行盲化。 - 实现：blinded_privkey = (privkey + alpha) mod L - 在该域上使用标量运算\nBLIND_PUBKEY(pubkey, alpha) 使用秘密 alpha 对公钥进行盲化。 - 实现: blinded_pubkey = pubkey + DERIVE_PUBLIC(alpha) - 使用曲线上的群元素（点）加法\n关键属性:\nBLIND_PUBKEY(pubkey, alpha) == DERIVE_PUBLIC(BLIND_PRIVKEY(privkey, alpha)) 安全注意事项：\n引自 ZCash 协议规范第 5.4.6.1 节：出于安全性考虑，alpha 必须与去盲后的私钥同分布。这确保“重新随机化的公钥与在该密钥下生成的签名的组合不会泄露它是从哪个密钥重新随机化得到的。”\n支持的签名类型: - 类型 7 (Ed25519): 支持用于现有目的地（向后兼容） - 类型 11 (Red25519): 建议用于使用加密的新目的地 - Blinded keys（盲化密钥）: 始终使用类型 11 (Red25519)\n参考资料： - ZCash 协议规范 - 第 5.4.6 节 RedDSA - I2P Red25519 规范 DH（Diffie-Hellman）: X25519 椭圆曲线迪菲-赫尔曼：X25519\n基于 Curve25519 的公钥密钥协商系统\n参数： - 私钥：32 字节 - 公钥：32 字节 - 共享密钥输出：32 字节\n功能：\nGENERATE_PRIVATE() 使用 CSRNG（密码学安全随机数生成器）生成一个新的 32 字节私钥。\nDERIVE_PUBLIC(privkey) 从给定的私钥导出 32 字节的公钥。 - 使用 Curve25519（椭圆曲线）上的标量乘法\nDH(privkey, pubkey) 执行 Diffie-Hellman 密钥协商。 - privkey: 本地 32 字节私钥 - pubkey: 远端 32 字节公钥 - 返回: 32 字节共享密钥\n安全属性： - 在 Curve25519 上的计算型 Diffie-Hellman (CDH) 假设 - 使用临时密钥时具备前向保密性 - 需要常数时间实现以防止时间侧信道攻击\n参考文献： - RFC 7748 - 用于安全的椭圆曲线\nHKDF（基于 HMAC 的提取与扩展密钥派生函数） 基于 HMAC 的密钥派生函数\n从输入的密钥材料中提取并扩展密钥材料。\n参数: - salt: 最多 32 字节（对于 SHA-256 通常为 32 字节） - ikm: 输入密钥材料（任意长度，应具有足够的熵） - info: 上下文相关的信息（域分离） - n: 输出长度（字节数）\n实现：\n使用 RFC 5869 规定的 HKDF（基于 HMAC 的密钥派生函数），其参数为:\n哈希函数: SHA-256 HMAC: 如 RFC 2104 所述 盐长度: 最多 32 字节（针对 SHA-256 的 HashLen） 使用模式：\nkeys = HKDF(salt, ikm, info, n) 域分离： info 参数为协议中 HKDF 的不同用法之间提供加密域分离。\n已验证信息值: - \u0026quot;ELS2_L1K\u0026quot; - 第 1 层（外层）加密 - \u0026quot;ELS2_L2K\u0026quot; - 第 2 层（内层）加密 - \u0026quot;ELS2_XCA\u0026quot; - DH 客户端授权 - \u0026quot;ELS2PSKA\u0026quot; - PSK 客户端授权 - \u0026quot;i2pblinding1\u0026quot; - Alpha 生成\n参考资料： - RFC 5869 - HKDF 规范 - RFC 2104 - HMAC 规范\n格式规范 加密的 LS2（第二代 leaseSet）由三个嵌套层组成：\n第0层（外层）： 用于存储和检索的明文信息 第1层（中层）： 客户端认证数据（已加密） 第2层（内层）： 实际的 LeaseSet2（LeaseSet 的第二版）数据（已加密） 整体结构：\nLayer 0 data + Enc(layer 1 data + Enc(layer 2 data)) + Signature 重要： 加密的 LS2 使用盲化密钥。Destination（目的地标识）不在首部中。DHT 的存储位置为 SHA-256(sig type || blinded public key)，每天轮换。\n第0层 (外层) - 明文 第0层不使用标准的 LS2 头部。它使用一种专为盲化密钥优化的自定义格式。\n结构：\nField Size Description Type1 byteNot in header, from DatabaseStore message field Blinded Public Key Sig Type2 bytesBig endian, always 0x000b (Red25519 type 11) Blinded Public Key32 bytesRed25519 blinded public key Published Timestamp4 bytesBig endian, seconds since epoch (rolls over in 2106) Expires2 bytesBig endian, offset from published in seconds (max 65,535 \u0026asymp; 18.2 hours) Flags2 bytesBit flags (see below) [Optional] Transient Key DataVariablePresent if flag bit\u0026nbsp;0 is set lenOuterCiphertext2 bytesBig endian, length of outer ciphertext outerCiphertextlenOuterCiphertextEncrypted Layer\u0026nbsp;1 data Signature64 bytesRed25519 signature over all preceding data **标志字段（2 字节，位 15-0）：** - **位 0：** 离线密钥指示符 - `0` = 无离线密钥 - `1` = 存在离线密钥（随后附带临时密钥数据） - **位 1-15：** 保留，必须为 0 以保证将来兼容性 临时密钥数据（当标志位 bit 0 = 1 时存在）：\nField Size Description Expires Timestamp4 bytesBig endian, seconds since epoch Transient Sig Type2 bytesBig endian, signature type Transient Signing Public KeyVariableLength implied by signature type Signature64 bytesSigned by blinded public key; covers expires timestamp, transient sig type, and transient public key **签名验证：** - **无离线密钥：** 使用盲化公钥进行验证 - **有离线密钥：** 使用临时公钥进行验证 签名覆盖从 Type 到 outerCiphertext 的所有数据（包含两者）。\n第1层（中间） - 客户端授权 解密： 参见第 1 层加密 一节。\n结构：\nField Size Description Flags1 byteAuthorization flags (see below) [Optional] Auth DataVariablePresent based on flags innerCiphertextVariableEncrypted Layer\u0026nbsp;2 data (remainder) **标志字段（1 字节，位 7-0）：** - **位 0：** 授权模式 - `0` = 无按客户端授权（所有人） - `1` = 按客户端授权（随后为授权部分） - **位 3-1：** 认证方案（仅当位 0 = 1 时） - `000` = DH 客户端认证 - `001` = PSK 客户端认证 - 其他保留 - **位 7-4：** 未使用，必须为 0 DH 客户端授权数据 (标志 = 0x01, 位 3-1 = 000):\nField Size Description ephemeralPublicKey32 bytesServer's ephemeral X25519 public key clients2 bytesBig endian, number of client entries authClient[]40 bytes eachArray of client authorization entries **authClient 条目 (40 字节):** - `clientID_i`: 8 字节 - `clientCookie_i`: 32 字节 (加密的 authCookie) PSK（预共享密钥）客户端授权数据（flags = 0x03，bits 3-1 = 001）：\nField Size Description authSalt32 bytesSalt for PSK key derivation clients2 bytesBig endian, number of client entries authClient[]40 bytes eachArray of client authorization entries **authClient 条目 (40 字节):** - `clientID_i`: 8 字节 - `clientCookie_i`: 32 字节 (加密的 authCookie (身份验证 Cookie)) 第2层（内部） - LeaseSet 数据 解密： 参见第 2 层加密 一节。\n结构：\nField Size Description Type1 byte3 (LS2) or 7 (Meta LS2) DataVariableComplete LeaseSet2 or MetaLeaseSet2 内层包含完整的 LeaseSet2 结构，包括： - LS2 头部 - 租约信息 - LS2 签名 验证要求： 解密后，实现必须验证：1. 内部时间戳与外部发布的时间戳相匹配 2. 内部过期时间与外部过期时间相匹配 3. LS2 签名有效 4. 租约数据格式正确\n参考资料： - 通用结构规范 - LeaseSet2（LeaseSet 的第二版）格式详细说明\n盲化密钥派生 概述 I2P 使用基于 Ed25519 和 ZCash RedDSA 的 additive key blinding scheme（加法型密钥盲化方案）。为实现前向保密，盲化密钥每天（UTC 午夜）轮换。\n设计依据：\nI2P 明确选择不采用 Tor 的 rend-spec-v3.txt 附录 A.2 中的方案。根据该规范：\n\u0026ldquo;我们不使用 Tor 的 rend-spec-v3.txt 的附录 A.2（其设计目标相似），因为其盲化的公钥可能不在素数阶子群上，其安全影响未知。\u0026rdquo;\nI2P 的加法盲化保证盲化后的密钥仍位于 Ed25519 曲线的素数阶子群上。\n数学定义 Ed25519 参数： - B: Ed25519 基点（生成元） = 2^255 - 19 - L: Ed25519 阶 = 2^252 + 27742317777372353535851937790883648493\n关键变量: - A: 未盲化的 32 字节签名公钥（位于 Destination（I2P 目标标识）中） - a: 未盲化的 32 字节签名私钥 - A': 已盲化的 32 字节签名公钥（用于加密的 LeaseSet） - a': 已盲化的 32 字节签名私钥 - alpha: 32 字节盲化因子（秘密）\n辅助函数：\nLEOS2IP(x) \u0026ldquo;将小端序八位字节串转换为整数\u0026rdquo;\n将小端序字节数组转换为整数表示。\nH*(x) \u0026ldquo;哈希与归约\u0026rdquo;\nH*(x) = (LEOS2IP(SHA512(x))) mod L 与 Ed25519 密钥生成中的操作相同。\nAlpha 生成 每日轮换： 必须每天在 UTC 午夜（00:00:00 UTC）生成新的 alpha（参数名）和盲化密钥。\nGENERATE_ALPHA(destination, date, secret) 算法：\n# Input parameters A = destination\u0026#39;s signing public key (32 bytes) stA = signature type of A (2 bytes, big endian) # 0x0007 for Ed25519 or 0x000b for Red25519 stA\u0026#39; = signature type of blinded key A\u0026#39; (2 bytes, big endian) # Always 0x000b (Red25519) datestring = \u0026#34;YYYYMMDD\u0026#34; (8 bytes ASCII from current UTC date) secret = optional UTF-8 encoded string (zero-length if not used) # Computation keydata = A || stA || stA\u0026#39; # 36 bytes total seed = HKDF( salt=H(\u0026#34;I2PGenerateAlpha\u0026#34;, keydata), ikm=datestring || secret, info=\u0026#34;i2pblinding1\u0026#34;, n=64 ) # Treat seed as 64-byte little-endian integer and reduce alpha = seed mod L 已验证的参数： - 盐值个性化：\u0026quot;I2PGenerateAlpha\u0026quot; - HKDF 信息：\u0026quot;i2pblinding1\u0026quot; - 输出：约简前为 64 字节 - Alpha 的分布：在 mod L 之后与 Ed25519 私钥的分布相同\n私钥盲化 BLIND_PRIVKEY(a, alpha) 算法：\n对于发布加密的 LeaseSet 的目的地（Destination）所有者：\n# For Ed25519 private key (type 7) if sigtype == 7: seed = destination\u0026#39;s signing private key (32 bytes) a = left_half(SHA512(seed)) # 32 bytes a = clamp(a) # Ed25519 clamping # For Red25519 private key (type 11) elif sigtype == 11: a = destination\u0026#39;s signing private key (32 bytes) # No clamping for Red25519 # Additive blinding using scalar arithmetic blinded_privkey = a\u0026#39; = (a + alpha) mod L # Derive blinded public key blinded_pubkey = A\u0026#39; = DERIVE_PUBLIC(a\u0026#39;) 关键： mod L 约化对于保持私钥与公钥之间正确的代数关系至关重要。\n公钥盲化 BLIND_PUBKEY(A, alpha) 算法:\n对于检索并验证加密 LeaseSet 的客户端：\nalpha = GENERATE_ALPHA(destination, date, secret) A = destination\u0026#39;s signing public key (32 bytes) # Additive blinding using group elements (curve points) blinded_pubkey = A\u0026#39; = A + DERIVE_PUBLIC(alpha) 数学等价性：\n这两种方法产生完全相同的结果：\nBLIND_PUBKEY(A, alpha) == DERIVE_PUBLIC(BLIND_PRIVKEY(a, alpha)) 这是因为：\nA\u0026#39; = A + [alpha]B = [a]B + [alpha]B = [a + alpha]B (group operation) = DERIVE_PUBLIC(a + alpha mod L) 使用盲化密钥签名 未盲化 LeaseSet 签名:\nunblinded（未盲化）的 LeaseSet（直接发送给已认证的客户端）使用以下方式签名： - 标准 Ed25519（类型 7）或 Red25519（类型 11）签名 - unblinded 签名私钥 - 使用 unblinded 公钥进行验证\n使用离线密钥： - 由去盲的临时私钥签名 - 使用去盲的临时公钥验证 - 二者都必须为类型 7 或 11\n加密的 LeaseSet（租约集）签名：\n加密的 LeaseSet 的外层部分使用带盲化密钥的 Red25519（可重随机化的 Ed25519）签名。\nRed25519 签名算法：\n# Generate per-signature random nonce T = CSRNG(80) # 80 random bytes # Calculate r (differs from Ed25519) r = H*(T || blinded_pubkey || message) # Rest is same as Ed25519 R = [r]B S = (r + H(R || A\u0026#39; || message) * a\u0026#39;) mod L signature = R || S # 64 bytes total 与 Ed25519 的关键差异： 1. 使用 80 字节的随机数据 T (而非私钥的哈希) 2. 直接使用公钥值 (而非私钥的哈希) 3. 即使针对相同的消息和密钥，每个签名也都是唯一的\n验证：\n与 Ed25519（椭圆曲线数字签名算法）相同：\n# Parse signature R = signature[0:32] S = signature[32:64] # Verify equation: [S]B = R + [H(R || A\u0026#39; || message)]A\u0026#39; return [S]B == R + [H(R || A\u0026#39; || message)]A\u0026#39; 安全注意事项 Alpha 发行版：\n为了安全起见，alpha 必须与未盲化的私钥同分布。当将 Ed25519（类型 7）盲化为 Red25519（与 Ed25519 相关的一种密钥格式）（类型 11）时，这些分布会略有不同。\n**建议：**对未盲化和盲化密钥都使用 Red25519（type 11），以满足 ZCash 的要求：“将一个再随机化（re-randomized）的公钥与在该密钥下的签名组合在一起，不会泄露其再随机化来源的密钥。”\n类型 7 支持： 为与现有 Destination（目标地址）保持向后兼容，支持 Ed25519，但对于新的加密 Destination，推荐使用类型 11。\n每日轮换的优势： - 前向保密性：即使今日的盲化密钥被攻破，也不会泄露昨日的盲化密钥 - 不可关联性：每日轮换可防止通过 DHT（分布式哈希表）进行的长期跟踪 - 密钥分离：不同时间段使用不同的密钥\n参考资料： - ZCash 协议规范 - 第 5.4.6.1 节 - Tor 密钥盲化讨论 - Tor 工单 #8106 加密与处理 Subcredential（子凭据）派生 在加密之前，我们派生出一个凭据和一个子凭据，以将加密层与持有 Destination（目的地标识）的签名公钥这一事实绑定。\n目标： 确保只有知道 Destination（I2P 目的地标识）的签名公钥的人才能解密加密的 LeaseSet。不需要完整的 Destination。\n凭证计算 A = destination\u0026#39;s signing public key (32 bytes) stA = signature type of A (2 bytes big endian) # 0x0007 for Ed25519 or 0x000b for Red25519 stA\u0026#39; = signature type of blinded key A\u0026#39; (2 bytes big endian) # Always 0x000b (Red25519) keydata = A || stA || stA\u0026#39; # 36 bytes credential = H(\u0026#34;credential\u0026#34;, keydata) # 32 bytes 域分离: 个性化字符串 \u0026quot;credential\u0026quot; 可确保此哈希不会与任何 DHT 查找键或协议中的其他用法发生碰撞。\nSubcredential（子凭据）计算 blindedPublicKey = A\u0026#39; (32 bytes, from blinding process) subcredential = H(\u0026#34;subcredential\u0026#34;, credential || blindedPublicKey) # 32 bytes 目的: subcredential（子凭据）将加密的 LeaseSet 绑定到: 1. 特定的 Destination（目标标识）（通过 credential） 2. 特定的盲化密钥（通过 blindedPublicKey） 3. 特定的日期（通过对 blindedPublicKey 的每日轮换）\n这可以防止重放攻击和跨日关联。\n第一层加密 上下文： 第1层包含客户端授权数据，并使用由 subcredential（子凭据）派生的密钥进行加密。\n加密算法 # Prepare input outerInput = subcredential || publishedTimestamp # publishedTimestamp: 4 bytes from Layer 0 # Generate random salt outerSalt = CSRNG(32) # 32 bytes # Derive encryption key and IV keys = HKDF( salt=outerSalt, ikm=outerInput, info=\u0026#34;ELS2_L1K\u0026#34;, # Domain separation n=44 # 32 bytes key + 12 bytes IV ) outerKey = keys[0:31] # 32 bytes (indices 0-31 inclusive) outerIV = keys[32:43] # 12 bytes (indices 32-43 inclusive) # Encrypt and prepend salt outerPlaintext = [Layer 1 data] outerCiphertext = outerSalt || ENCRYPT(outerKey, outerIV, outerPlaintext) 输出： outerCiphertext 为 32 + len(outerPlaintext) 字节。\n安全属性: - 盐值确保即使使用相同的子凭据也能得到唯一的密钥/IV 对 - 上下文字符串 \u0026quot;ELS2_L1K\u0026quot; 提供域分离 - ChaCha20 提供语义安全（密文与随机数不可区分）\n解密算法 # Parse salt from ciphertext outerSalt = outerCiphertext[0:31] # First 32 bytes # Derive decryption key and IV (same process as encryption) outerInput = subcredential || publishedTimestamp keys = HKDF( salt=outerSalt, ikm=outerInput, info=\u0026#34;ELS2_L1K\u0026#34;, n=44 ) outerKey = keys[0:31] # 32 bytes outerIV = keys[32:43] # 12 bytes # Decrypt (skip salt bytes) outerPlaintext = DECRYPT(outerKey, outerIV, outerCiphertext[32:end]) 验证： 解密后，先验证第 1 层结构是否正确，再继续处理第 2 层。\n二层加密 上下文： 第2层包含实际的 LeaseSet2 数据，并使用从 authCookie（如果启用了按客户端认证）或空字符串（如果未启用）派生的密钥进行加密。\n加密算法 # Determine authCookie based on authorization mode if per_client_auth_enabled: authCookie = [32-byte cookie from client authorization process] else: authCookie = b\u0026#39;\u0026#39; # Zero-length byte array # Prepare input innerInput = authCookie || subcredential || publishedTimestamp # Generate random salt innerSalt = CSRNG(32) # 32 bytes # Derive encryption key and IV keys = HKDF( salt=innerSalt, ikm=innerInput, info=\u0026#34;ELS2_L2K\u0026#34;, # Domain separation n=44 # 32 bytes key + 12 bytes IV ) innerKey = keys[0:31] # 32 bytes innerIV = keys[32:43] # 12 bytes # Encrypt and prepend salt innerPlaintext = [Layer 2 data: LS2 type byte + LeaseSet2 data] innerCiphertext = innerSalt || ENCRYPT(innerKey, innerIV, innerPlaintext) 输出: innerCiphertext 为 32 + len(innerPlaintext) 字节。\n密钥绑定: - 如果未启用客户端认证: 仅绑定到子凭据和时间戳 - 如果启用了客户端认证: 另外绑定到 authCookie (对每个已授权客户端都不同)\n解密算法 # Determine authCookie (same as encryption) if per_client_auth_enabled: authCookie = [32-byte cookie from client authorization process] else: authCookie = b\u0026#39;\u0026#39; # Zero-length byte array # Parse salt from ciphertext innerSalt = innerCiphertext[0:31] # First 32 bytes # Derive decryption key and IV innerInput = authCookie || subcredential || publishedTimestamp keys = HKDF( salt=innerSalt, ikm=innerInput, info=\u0026#34;ELS2_L2K\u0026#34;, n=44 ) innerKey = keys[0:31] # 32 bytes innerIV = keys[32:43] # 12 bytes # Decrypt (skip salt bytes) innerPlaintext = DECRYPT(innerKey, innerIV, innerCiphertext[32:end]) 验证： 解密后: 1. 验证 LS2（LeaseSet2，I2P 中 LeaseSet 的第二版）类型字节是否有效 (3 或 7) 2. 解析 LeaseSet2 结构 3. 验证内部时间戳与外部发布的时间戳一致 4. 验证内部过期时间与外部过期时间一致 5. 验证 LeaseSet2 签名\n加密层概述 ┌─────────────────────────────────────────────────┐ │ Layer 0 (Plaintext) │ │ - Blinded public key │ │ - Timestamps │ │ - Signature │ │ │ │ ┌─────────────────────────────────────────┐ │ │ │ Layer 1 (Encrypted with subcredential) │ │ │ │ - Authorization flags │ │ │ │ - Client auth data (if enabled) │ │ │ │ │ │ │ │ ┌────────────────────────────────┐ │ │ │ │ │ Layer 2 (Encrypted with │ │ │ │ │ │ authCookie + subcred) │ │ │ │ │ │ - LeaseSet2 type │ │ │ │ │ │ - LeaseSet2 data │ │ │ │ │ │ - Leases │ │ │ │ │ │ - LS2 signature │ │ │ │ │ └────────────────────────────────┘ │ │ │ └─────────────────────────────────────────┘ │ └─────────────────────────────────────────────────┘ 解密流程： 1. 使用盲化公钥验证第0层签名 2. 使用 subcredential（子凭据）解密第1层 3. 处理授权数据（如存在）以获取 authCookie（授权Cookie） 4. 使用 authCookie 和 subcredential 解密第2层 5. 验证并解析 LeaseSet2\n按客户端授权 概述 启用逐客户端授权时，服务器会维护一个已授权客户端的列表。每个客户端都拥有必须通过带外方式安全传输的密钥材料。\n两种授权机制： 1. DH（Diffie-Hellman，迪菲-赫尔曼）客户端授权： 更安全，使用 X25519 密钥协商 2. PSK（Pre-Shared Key，预共享密钥）授权： 更简单，使用对称密钥\n常见安全属性： - 客户端成员隐私：观察者可以看到客户端数量，但无法识别具体的客户端 - 匿名的客户端添加/撤销：无法追踪特定客户端何时被添加或移除 - 8 字节客户端标识符的碰撞概率：~1/（18×10^18）（可忽略不计）\nDH（Diffie-Hellman 密钥交换）客户端授权 概述: 每个客户端生成一个 X25519（椭圆曲线密钥交换算法）密钥对，并通过安全的带外通道将其公钥发送到服务器。服务器使用临时 DH（Diffie-Hellman）为每个客户端加密一个唯一的 authCookie。\n客户端密钥生成 # Client generates keypair csk_i = GENERATE_PRIVATE() # 32-byte X25519 private key cpk_i = DERIVE_PUBLIC(csk_i) # 32-byte X25519 public key # Client sends cpk_i to server via secure out-of-band channel # Client KEEPS csk_i secret (never transmitted) 安全优势： 客户端的私钥永不离开其设备。即使攻击者截获带外传输，在不攻破 X25519 DH 的情况下，也无法解密未来的加密 LeaseSets。\n服务器端处理 # Server generates new auth cookie and ephemeral keypair authCookie = CSRNG(32) # 32-byte cookie esk = GENERATE_PRIVATE() # 32-byte ephemeral private key epk = DERIVE_PUBLIC(esk) # 32-byte ephemeral public key # For each authorized client i for cpk_i in authorized_clients: # Perform DH key agreement sharedSecret = DH(esk, cpk_i) # 32 bytes # Derive client-specific encryption key authInput = sharedSecret || cpk_i || subcredential || publishedTimestamp okm = HKDF( salt=epk, # Ephemeral public key as salt ikm=authInput, info=\u0026#34;ELS2_XCA\u0026#34;, # Domain separation n=52 # 32 key + 12 IV + 8 ID ) # Extract components clientKey_i = okm[0:31] # 32 bytes clientIV_i = okm[32:43] # 12 bytes clientID_i = okm[44:51] # 8 bytes # Encrypt authCookie for this client clientCookie_i = ENCRYPT(clientKey_i, clientIV_i, authCookie) # Store [clientID_i, clientCookie_i] entry in Layer 1 第 1 层数据结构：\nephemeralPublicKey (32 bytes) clients (2 bytes) = N [clientID_1 (8 bytes) || clientCookie_1 (32 bytes)] [clientID_2 (8 bytes) || clientCookie_2 (32 bytes)] ... [clientID_N (8 bytes) || clientCookie_N (32 bytes)] 服务器端建议： - 为每个已发布的加密 LeaseSet（租约集）生成新的临时密钥对 - 随机化客户端顺序，以防止基于位置的跟踪 - 考虑添加填充条目以隐藏真实的客户端数量\n客户端处理 # Client has: csk_i (their private key), destination, date, secret # Client receives: encrypted LeaseSet with epk in Layer 1 # Perform DH key agreement with server\u0026#39;s ephemeral public key sharedSecret = DH(csk_i, epk) # 32 bytes # Derive expected client identifier and decryption key cpk_i = DERIVE_PUBLIC(csk_i) # Client\u0026#39;s own public key authInput = sharedSecret || cpk_i || subcredential || publishedTimestamp okm = HKDF( salt=epk, ikm=authInput, info=\u0026#34;ELS2_XCA\u0026#34;, n=52 ) clientKey_i = okm[0:31] # 32 bytes clientIV_i = okm[32:43] # 12 bytes clientID_i = okm[44:51] # 8 bytes # Search Layer 1 authorization data for clientID_i for (clientID, clientCookie) in layer1_auth_entries: if clientID == clientID_i: # Found matching entry, decrypt authCookie authCookie = DECRYPT(clientKey_i, clientIV_i, clientCookie) # Use authCookie to decrypt Layer 2 break else: # No matching entry - client not authorized or revoked raise AuthorizationError(\u0026#34;Client not authorized\u0026#34;) 客户端错误处理： - 如果未找到clientID_i：客户端已被撤销或从未被授权 - 如果解密失败：数据损坏或密钥错误（极其罕见） - 客户端应定期重新获取以检测是否被撤销\nPSK（预共享密钥）客户端授权 概述： 每个客户端都有一个预共享的32字节对称密钥。服务器使用每个客户端的PSK（预共享密钥）对相同的authCookie进行加密。\n密钥生成 # Option 1: Client generates key psk_i = CSRNG(32) # 32-byte pre-shared key # Client sends psk_i to server via secure out-of-band channel # Option 2: Server generates key psk_i = CSRNG(32) # 32-byte pre-shared key # Server sends psk_i to one or more clients via secure out-of-band channel 安全说明： 如果需要，同一个 PSK（预共享密钥）可以在多个客户端之间共享（会创建“组”授权）。\n服务器端处理 # Server generates new auth cookie and salt authCookie = CSRNG(32) # 32-byte cookie authSalt = CSRNG(32) # 32-byte salt # For each authorized client i for psk_i in authorized_clients: # Derive client-specific encryption key authInput = psk_i || subcredential || publishedTimestamp okm = HKDF( salt=authSalt, ikm=authInput, info=\u0026#34;ELS2PSKA\u0026#34;, # Domain separation n=52 # 32 key + 12 IV + 8 ID ) # Extract components clientKey_i = okm[0:31] # 32 bytes clientIV_i = okm[32:43] # 12 bytes clientID_i = okm[44:51] # 8 bytes # Encrypt authCookie for this client clientCookie_i = ENCRYPT(clientKey_i, clientIV_i, authCookie) # Store [clientID_i, clientCookie_i] entry in Layer 1 第1层数据结构:\nauthSalt (32 bytes) clients (2 bytes) = N [clientID_1 (8 bytes) || clientCookie_1 (32 bytes)] [clientID_2 (8 bytes) || clientCookie_2 (32 bytes)] ... [clientID_N (8 bytes) || clientCookie_N (32 bytes)] 客户端处理 # Client has: psk_i (their pre-shared key), destination, date, secret # Client receives: encrypted LeaseSet with authSalt in Layer 1 # Derive expected client identifier and decryption key authInput = psk_i || subcredential || publishedTimestamp okm = HKDF( salt=authSalt, ikm=authInput, info=\u0026#34;ELS2PSKA\u0026#34;, n=52 ) clientKey_i = okm[0:31] # 32 bytes clientIV_i = okm[32:43] # 12 bytes clientID_i = okm[44:51] # 8 bytes # Search Layer 1 authorization data for clientID_i for (clientID, clientCookie) in layer1_auth_entries: if clientID == clientID_i: # Found matching entry, decrypt authCookie authCookie = DECRYPT(clientKey_i, clientIV_i, clientCookie) # Use authCookie to decrypt Layer 2 break else: # No matching entry - client not authorized or revoked raise AuthorizationError(\u0026#34;Client not authorized\u0026#34;) 比较与建议 Feature DH Authorization PSK Authorization Key ExchangeAsymmetric (X25519)Symmetric (shared secret) SecurityHigher (forward secrecy)Lower (depends on PSK secrecy) Client PrivacyPrivate key never transmittedPSK must be transmitted securely PerformanceN+1 DH operationsNo DH operations Key SharingOne key per clientCan share key among multiple clients Revocation DetectionAdversary cannot tell when revokedAdversary can track revocation if PSK intercepted Use CaseHigh security requirementsPerformance-critical or group access **建议：** - **使用 DH 授权** 适用于前向保密性重要的高安全性应用 - **使用 PSK 授权** 当性能至关重要或需要管理客户端分组时 - **切勿重复使用 PSK** 在不同服务或不同时期 - **始终使用安全信道** 进行密钥分发（例如 Signal、OTR、PGP） 安全注意事项 客户端成员身份隐私:\n这两种机制通过以下方式为客户端成员身份提供隐私：\n加密的客户端标识符： 8 字节的 clientID，源自 HKDF（基于 HMAC 的密钥派生函数）输出 不可区分的 Cookie： 所有 32 字节的 clientCookie 值看起来都是随机的 没有特定于客户端的元数据： 无法识别哪个条目属于哪个客户端 观察者可以看到：\n授权客户端的数量（来自 clients 字段） 客户端数量随时间的变化 观察者无法看到： - 哪些具体客户端已被授权 - 具体客户端何时被添加或移除（如果数量保持不变） - 任何可用于识别客户端的信息\n随机化建议：\n服务器应当在每次生成加密的 LeaseSet 时随机化客户端顺序：\nimport random # Before serializing auth_entries = [(clientID_i, clientCookie_i) for each client] random.shuffle(auth_entries) # Now serialize in randomized order 优点： - 防止客户端获知其在列表中的位置 - 防止基于位置变化的推断攻击 - 使客户端的新增/撤销不可区分\n隐藏客户端数量:\n服务器可以插入随机的伪条目：\n# Add dummy entries num_dummies = random.randint(0, max_dummies) for _ in range(num_dummies): dummy_id = CSRNG(8) dummy_cookie = CSRNG(32) auth_entries.append((dummy_id, dummy_cookie)) # Randomize all entries (real + dummy) random.shuffle(auth_entries) 成本： 填充条目会增加加密的 LeaseSet 大小（每个 40 字节）。\nAuthCookie 轮换：\n服务器应当生成一个新的 authCookie（认证 Cookie）： - 每次发布加密的 LeaseSet 时（通常每隔数小时） - 在撤销某个客户端之后立即 - 按照固定计划（例如，每日），即使没有客户端发生变更\n优势: - 在 authCookie 遭到泄露时，限制暴露 - 确保被撤销授权的客户端能快速失去访问权限 - 为第二层提供前向保密性\n用于加密 LeaseSets 的 Base32 寻址 概述 传统的 I2P base32 地址仅包含 Destination（目的地标识）的哈希（32 字节 → 52 个字符）。这对于加密的 LeaseSets 来说是不足的，因为：\n客户端需要 未盲化公钥 才能派生出盲化公钥 客户端需要 签名类型（unblinded 和 blinded，分别为未盲化与盲化），以便正确进行密钥派生 仅凭哈希无法提供这些信息 解决方案： 包含公钥和签名类型的新 base32 格式。\n地址格式规范 解码后的结构（35 字节）：\n┌─────────────────────────────────────────────────────┐ │ Byte 0 │ Byte 1 │ Byte 2 │ Bytes 3-34 │ │ Flags │ Unblind │ Blinded │ Public Key │ │ (XOR) │ SigType │ SigType │ (32 bytes) │ │ │ (XOR) │ (XOR) │ │ └─────────────────────────────────────────────────────┘ 前3个字节（与校验和进行异或）：\n前 3 个字节包含与 CRC-32 校验和的部分按位异或后的元数据：\n# Data structure before XOR flags = 0x00 # 1 byte (reserved for future use) unblinded_sigtype = 0x07 or 0x0b # 1 byte (7 or 11) blinded_sigtype = 0x0b # 1 byte (always 11) # Compute CRC-32 checksum of public key checksum = crc32(pubkey) # 4-byte CRC-32 of bytes 3-34 # XOR first 3 bytes with parts of checksum data[0] = flags XOR (checksum \u0026gt;\u0026gt; 24) \u0026amp; 0xFF data[1] = unblinded_sigtype XOR (checksum \u0026gt;\u0026gt; 16) \u0026amp; 0xFF data[2] = blinded_sigtype XOR (checksum \u0026gt;\u0026gt; 8) \u0026amp; 0xFF # Bytes 3-34 contain the unmodified 32-byte public key data[3:34] = pubkey 校验和属性: - 使用标准 CRC-32 多项式 - 假阴性率：约为 1600 万分之一 - 可检测地址拼写错误 - 不能用作认证（不具备密码学安全性）\n编码格式：\nBase32Encode(35 bytes) || \u0026#34;.b32.i2p\u0026#34; 特性： - 总字符数：56 (35 字节 × 8 位 ÷ 每字符 5 位) - 后缀: \u0026ldquo;.b32.i2p\u0026rdquo; (与传统 base32 相同) - 总长度：56 + 8 = 64 字符 (不包含空字符终止符)\nBase32 编码： - 字母表: abcdefghijklmnopqrstuvwxyz234567 (遵循 RFC 4648 标准) - 末尾未使用的 5 个位必须为 0 - 不区分大小写 (按惯例使用小写)\n地址生成 import struct from zlib import crc32 import base64 def generate_encrypted_b32_address(pubkey, unblinded_sigtype, blinded_sigtype): \u0026#34;\u0026#34;\u0026#34; Generate base32 address for encrypted LeaseSet. Args: pubkey: 32-byte public key (bytes) unblinded_sigtype: Unblinded signature type (7 or 11) blinded_sigtype: Blinded signature type (always 11) Returns: String address ending in .b32.i2p \u0026#34;\u0026#34;\u0026#34; # Verify inputs assert len(pubkey) == 32, \u0026#34;Public key must be 32 bytes\u0026#34; assert unblinded_sigtype in [7, 11], \u0026#34;Unblinded sigtype must be 7 or 11\u0026#34; assert blinded_sigtype == 11, \u0026#34;Blinded sigtype must be 11\u0026#34; # Compute CRC-32 of public key checksum = crc32(pubkey) \u0026amp; 0xFFFFFFFF # Ensure 32-bit unsigned # Prepare metadata bytes flags = 0x00 # XOR metadata with checksum parts byte0 = flags ^ ((checksum \u0026gt;\u0026gt; 24) \u0026amp; 0xFF) byte1 = unblinded_sigtype ^ ((checksum \u0026gt;\u0026gt; 16) \u0026amp; 0xFF) byte2 = blinded_sigtype ^ ((checksum \u0026gt;\u0026gt; 8) \u0026amp; 0xFF) # Construct 35-byte data data = bytes([byte0, byte1, byte2]) + pubkey # Base32 encode (standard alphabet) # Python\u0026#39;s base64 module uses uppercase by default b32 = base64.b32encode(data).decode(\u0026#39;ascii\u0026#39;).lower().rstrip(\u0026#39;=\u0026#39;) # Construct full address address = b32 + \u0026#34;.b32.i2p\u0026#34; return address 地址解析 import struct from zlib import crc32 import base64 def parse_encrypted_b32_address(address): \u0026#34;\u0026#34;\u0026#34; Parse base32 address for encrypted LeaseSet. Args: address: String address ending in .b32.i2p Returns: Tuple of (pubkey, unblinded_sigtype, blinded_sigtype) Raises: ValueError: If address is invalid or checksum fails \u0026#34;\u0026#34;\u0026#34; # Remove suffix if not address.endswith(\u0026#39;.b32.i2p\u0026#39;): raise ValueError(\u0026#34;Invalid address suffix\u0026#34;) b32 = address[:-8] # Remove \u0026#34;.b32.i2p\u0026#34; # Verify length (56 characters for 35 bytes) if len(b32) != 56: raise ValueError(f\u0026#34;Invalid length: {len(b32)} (expected 56)\u0026#34;) # Base32 decode # Add padding if needed padding_needed = (8 - (len(b32) % 8)) % 8 b32_padded = b32.upper() + \u0026#39;=\u0026#39; * padding_needed try: data = base64.b32decode(b32_padded) except Exception as e: raise ValueError(f\u0026#34;Invalid base32 encoding: {e}\u0026#34;) # Verify decoded length if len(data) != 35: raise ValueError(f\u0026#34;Invalid decoded length: {len(data)} (expected 35)\u0026#34;) # Extract public key pubkey = data[3:35] # Compute CRC-32 for verification checksum = crc32(pubkey) \u0026amp; 0xFFFFFFFF # Un-XOR metadata bytes flags = data[0] ^ ((checksum \u0026gt;\u0026gt; 24) \u0026amp; 0xFF) unblinded_sigtype = data[1] ^ ((checksum \u0026gt;\u0026gt; 16) \u0026amp; 0xFF) blinded_sigtype = data[2] ^ ((checksum \u0026gt;\u0026gt; 8) \u0026amp; 0xFF) # Verify expected values if flags != 0x00: raise ValueError(f\u0026#34;Invalid flags: {flags:#x} (expected 0x00)\u0026#34;) if unblinded_sigtype not in [7, 11]: raise ValueError(f\u0026#34;Invalid unblinded sigtype: {unblinded_sigtype} (expected 7 or 11)\u0026#34;) if blinded_sigtype != 11: raise ValueError(f\u0026#34;Invalid blinded sigtype: {blinded_sigtype} (expected 11)\u0026#34;) return pubkey, unblinded_sigtype, blinded_sigtype 与传统 Base32 的比较 Feature Traditional B32 Encrypted LS2 B32 ContentSHA-256 hash of DestinationPublic key + signature types Decoded Size32 bytes35 bytes Encoded Length52 characters56 characters Suffix.b32.i2p.b32.i2p Total Length60 chars64 chars ChecksumNoneCRC-32 (XOR'd into first 3 bytes) Use CaseRegular destinationsEncrypted LeaseSet destinations ### 使用限制 BitTorrent 不兼容性:\n加密的 LS2 地址不能用于 BitTorrent 的紧凑型 announce 响应：\nCompact announce reply format: ┌────────────────────────────┐ │ 32-byte destination hash │ ← Only hash, no signature types │ 2-byte port │ └────────────────────────────┘ **问题：**紧凑格式仅包含哈希（32 字节），没有为签名类型或公钥信息预留空间。\n解决方案： 使用完整的 announce 响应，或使用支持完整地址的基于 HTTP 的 tracker。\n地址簿集成 如果客户端在地址簿中包含完整的 Destination（I2P 目标标识）:\n存储完整的 Destination（I2P 的目标标识；包含公钥） 支持通过哈希反向查找 当遇到加密的 LS2（LeaseSet v2）时，从地址簿获取公钥 如果已知完整的 Destination，则无需新的 base32 格式 支持加密的 LS2（LeaseSet2，第二代 leaseSet）的地址簿格式： - hosts.txt，包含完整的 destination 字符串 - SQLite 数据库，包含 destination 列 - JSON/XML 格式，包含完整的 destination 数据\n实现示例 示例 1：生成地址\n# Ed25519 destination example pubkey = bytes.fromhex(\u0026#39;a\u0026#39; * 64) # 32-byte public key unblinded_type = 7 # Ed25519 blinded_type = 11 # Red25519 (always) address = generate_encrypted_b32_address(pubkey, unblinded_type, blinded_type) print(f\u0026#34;Address: {address}\u0026#34;) # Output: 56 base32 characters + .b32.i2p 示例 2: 解析与验证\naddress = \u0026#34;abc...xyz.b32.i2p\u0026#34; # 56 chars + suffix try: pubkey, unblinded, blinded = parse_encrypted_b32_address(address) print(f\u0026#34;Public Key: {pubkey.hex()}\u0026#34;) print(f\u0026#34;Unblinded SigType: {unblinded}\u0026#34;) print(f\u0026#34;Blinded SigType: {blinded}\u0026#34;) except ValueError as e: print(f\u0026#34;Invalid address: {e}\u0026#34;) 示例 3：从 Destination（I2P 目的地标识）转换\ndef destination_to_encrypted_b32(destination): \u0026#34;\u0026#34;\u0026#34; Convert full Destination to encrypted LS2 base32 address. Args: destination: I2P Destination object Returns: Base32 address string \u0026#34;\u0026#34;\u0026#34; # Extract public key and signature type from destination pubkey = destination.signing_public_key # 32 bytes sigtype = destination.sig_type # 7 or 11 # Blinded type is always 11 (Red25519) blinded_type = 11 # Generate address return generate_encrypted_b32_address(pubkey, sigtype, blinded_type) 安全注意事项 隐私： - Base32 地址会暴露公钥 - 这是有意为之且是该协议的要求 - 不会泄露私钥，也不会危及安全性 - 公钥按设计就是公开信息\n抗碰撞性： - CRC-32 仅提供 32 位的抗碰撞性 - 不具备密码学安全性（仅用于错误检测） - 切勿依赖校验和用于认证 - 仍然需要进行完整的目标验证\n地址验证： - 在使用前务必验证校验和 - 拒绝具有无效签名类型的地址 - 验证公钥位于曲线上（取决于具体实现）\n参考资料： - 提案 149：用于加密 LS2（LeaseSet 第2版）的 B32 - B32 寻址规范 - I2P 命名规范 离线密钥支持 概述 离线密钥允许主签名密钥保持离线（冷存储），同时使用临时签名密钥处理日常操作。这对于高安全性的服务至关重要。\n加密的 LS2（LeaseSet v2）特定要求： - 临时密钥必须离线生成 - 盲化私钥必须预先生成（每天一个） - 临时密钥和盲化密钥均按批次交付 - 尚未定义标准化的文件格式（规范中待补充）\n离线密钥结构 第 0 层临时密钥数据 (当标志位第 0 位为 1 时)：\n┌───────────────────────────────────────────────────┐ │ Expires Timestamp │ 4 bytes (seconds) │ │ Transient Sig Type │ 2 bytes (big endian) │ │ Transient Signing Pubkey│ Variable (sigtype len) │ │ Signature (by blinded) │ 64 bytes (Red25519) │ └───────────────────────────────────────────────────┘ 签名覆盖范围： 离线密钥块中的签名覆盖： - 到期时间戳(4 字节) - 临时签名类型(2 字节) - 临时签名公钥(可变长度)\n该签名使用盲化公钥进行验证，证明持有盲化私钥的实体已授权此临时密钥。\n密钥生成过程 对于使用离线密钥的加密 LeaseSet：\n生成临时密钥对（离线，在冷存储中）:\n# For each day in future for date in future_dates: # Generate daily transient keypair transient_privkey = generate_red25519_privkey() # Type 11 transient_pubkey = derive_public(transient_privkey) # Store for later delivery keys[date] = (transient_privkey, transient_pubkey) Generate daily blinded keypairs (offline, in cold storage):\n遍历每一天 for date in future_dates: # Derive alpha for this date datestring = date.strftime(\u0026quot;%Y%m%d\u0026quot;) # \u0026quot;YYYYMMDD\u0026quot; alpha = GENERATE_ALPHA(destination, datestring, secret) # Blind the signing private key a = destination_signing_privkey # Type 7 or 11 blinded_privkey = BLIND_PRIVKEY(a, alpha) # Result is type 11 blinded_pubkey = DERIVE_PUBLIC(blinded_privkey) # Store for later delivery blinded_keys[date] = (blinded_privkey, blinded_pubkey) 3. **Sign transient keys with blinded keys** (offline): ```python for date in future_dates: transient_pubkey = keys[date][1] blinded_privkey = blinded_keys[date][0] # Create signature data expires = int((date + timedelta(days=1)).timestamp()) sig_data = struct.pack(\u0026#39;\u0026gt;I\u0026#39;, expires) # 4 bytes sig_data += struct.pack(\u0026#39;\u0026gt;H\u0026#39;, 11) # Transient type (Red25519) sig_data += transient_pubkey # 32 bytes # Sign with blinded private key signature = RED25519_SIGN(blinded_privkey, sig_data) # Package for delivery offline_sig_blocks[date] = { \u0026#39;expires\u0026#39;: expires, \u0026#39;transient_type\u0026#39;: 11, \u0026#39;transient_pubkey\u0026#39;: transient_pubkey, \u0026#39;signature\u0026#39;: signature } Package for delivery to router: 针对每个日期 delivery_package[date] = { 'transient_privkey': keys[date][0], 'transient_pubkey': keys[date][1], 'blinded_privkey': blinded_keys[date][0], 'blinded_pubkey': blinded_keys[date][1], 'offline_sig_block': offline_sig_blocks[date] }\n### Router Usage **Daily Key Loading:** ```python # 在 UTC 午夜（或在发布之前） date = datetime.utcnow().date() # 加载今天的密钥 today_keys = load_delivery_package(date) transient_privkey = today_keys[\u0026#39;transient_privkey\u0026#39;] transient_pubkey = today_keys[\u0026#39;transient_pubkey\u0026#39;] blinded_privkey = today_keys[\u0026#39;blinded_privkey\u0026#39;] blinded_pubkey = today_keys[\u0026#39;blinded_pubkey\u0026#39;] offline_sig_block = today_keys[\u0026#39;offline_sig_block\u0026#39;] # 将这些密钥用于今天的加密 LeaseSet Publishing Process:\n# 1. 创建内部 LeaseSet2（I2P 中用于发布目的地接入信息的数据结构） inner_ls2 = create_leaseset2( destinations, leases, expires, signing_key=transient_privkey # Use transient key ) # 2. 加密第 2 层 layer2_ciphertext = encrypt_layer2(inner_ls2, authCookie, subcredential, timestamp) # 3. 创建带有授权数据的第 1 层 layer1_plaintext = create_layer1(authorization_data, layer2_ciphertext) # 4. 加密第 1 层 layer1_ciphertext = encrypt_layer1(layer1_plaintext, subcredential, timestamp) # 5. 创建包含离线签名块的 Layer 0（第0层） layer0 = create_layer0( blinded_pubkey, timestamp, expires, flags=0x0001, # Bit 0 set (offline keys present) offline_sig_block=offline_sig_block, layer1_ciphertext=layer1_ciphertext ） # 6. 使用临时私钥对第0层签名 signature = RED25519_SIGN(transient_privkey, layer0) # 7. 附加签名并发布 encrypted_leaseset = layer0 + signature publish_to_netdb(encrypted_leaseset) Security Considerations Tracking via Offline Signature Block:\nThe offline signature block is in plaintext (Layer 0). An adversary scraping floodfills could:\nTrack the same encrypted LeaseSet across multiple days Correlate encrypted LeaseSets even though blinded keys change daily Mitigation: Generate new transient keys daily (in addition to blinded keys):\n# 每天同时生成新的临时密钥和新的盲化密钥 for date in future_dates: # New transient keypair for this day transient_privkey = generate_red25519_privkey() transient_pubkey = derive_public(transient_privkey) # New blinded keypair for this day alpha = GENERATE_ALPHA(destination, datestring, secret) blinded_privkey = BLIND_PRIVKEY(signing_privkey, alpha) blinded_pubkey = DERIVE_PUBLIC(blinded_privkey) # Sign new transient key with new blinded key sig = RED25519_SIGN(blinded_privkey, transient_pubkey || metadata) # Now offline sig block changes daily Benefits:\nPrevents tracking across days via offline signature block Provides same security as encrypted LS2 without offline keys Each day appears completely independent Cost:\nMore keys to generate and store More complex key management File Format (TODO) Current Status: No standardized file format defined for batch key delivery.\nRequirements for Future Format:\nMust support multiple dates:\nBatch delivery of 30+ days worth of keys Clear date association for each key set Must include all necessary data:\nTransient private key Transient public key Blinded private key Blinded public key Pre-computed offline signature block Expiration timestamps Should be tamper-evident:\nChecksums or signatures over entire file Integrity verification before loading Should be encrypted:\nKeys are sensitive material Encrypt file with router\u0026rsquo;s key or passphrase Proposed Format Example (JSON, encrypted):\n{ \u0026#34;version\u0026#34;: 1, \u0026#34;destination_hash\u0026#34;: \u0026#34;base64...\u0026#34;, \u0026#34;keys\u0026#34;: [ { \u0026#34;date\u0026#34;: \u0026#34;2025-10-15\u0026#34;, \u0026#34;transient\u0026#34;: { \u0026#34;type\u0026#34;: 11, \u0026#34;privkey\u0026#34;: \u0026#34;base64...\u0026#34;, \u0026#34;pubkey\u0026#34;: \u0026#34;base64...\u0026#34; }, \u0026#34;blinded\u0026#34;: { \u0026#34;privkey\u0026#34;: \u0026#34;base64...\u0026#34;, \u0026#34;pubkey\u0026#34;: \u0026#34;base64...\u0026#34; }, \u0026#34;offline_sig_block\u0026#34;: { \u0026#34;expires\u0026#34;: 1729123200, \u0026#34;signature\u0026#34;: \u0026#34;base64...\u0026#34; } } ], \u0026#34;signature\u0026#34;: \u0026#34;base64...\u0026#34; // Signature over entire structure } I2CP Protocol Enhancement (TODO) Current Status: No I2CP protocol enhancement defined for offline keys with encrypted LeaseSet.\nRequirements:\nKey delivery mechanism:\nUpload batch of keys from client to router Acknowledgment of successful key loading Key expiration notification:\nRouter notifies client when keys running low Client can generate and upload new batch Key revocation:\nEmergency revocation of future keys if compromise suspected Proposed I2CP Messages:\nUPLOAD_OFFLINE_KEYS - 一批加密的密钥材料 - 涵盖的日期范围 OFFLINE_KEY_STATUS - 剩余天数 - 下一个密钥到期日期 REVOKE_OFFLINE_KEYS - 要吊销的日期范围 - 用于替换的新密钥 (可选) Implementation Status Java I2P:\n✅ Offline keys for standard LS2: Fully supported (since 0.9.38) ⚠️ Offline keys for encrypted LS2: Implemented (since 0.9.40) ❌ File format: Not standardized ❌ I2CP protocol: Not enhanced i2pd (C++):\n✅ Offline keys for standard LS2: Fully supported ✅ Offline keys for encrypted LS2: Fully supported (since 2.58.0) ❌ File format: Not standardized ❌ I2CP protocol: Not enhanced References:\nOffline Signatures Proposal I2CP Specification Security Considerations Cryptographic Security Algorithm Selection:\nAll cryptographic primitives are based on well-studied algorithms:\nChaCha20: Modern stream cipher, constant-time, no timing attacks SHA-256: NIST-approved hash, 128-bit security level HKDF: RFC 5869 standard, proven security bounds Ed25519/Red25519: Curve25519-based, ~128-bit security level X25519: Diffie-Hellman over Curve25519, ~128-bit security level Key Sizes:\nAll symmetric keys: 256 bits (32 bytes) All public/private keys: 256 bits (32 bytes) All nonces/IVs: 96 bits (12 bytes) All signatures: 512 bits (64 bytes) These sizes provide adequate security margins against current and near-future attacks.\nForward Secrecy Daily Key Rotation:\nEncrypted LeaseSets rotate keys daily (UTC midnight):\nNew blinded public/private key pair New storage location in DHT New encryption keys for both layers Benefits:\nCompromising today\u0026rsquo;s blinded key doesn\u0026rsquo;t reveal yesterday\u0026rsquo;s Limits exposure window to 24 hours Prevents long-term tracking via DHT Enhanced with Ephemeral Keys:\nDH client authorization uses ephemeral keys:\nServer generates new ephemeral DH keypair for each publication Compromising ephemeral key only affects that publication True forward secrecy even if long-term keys compromised Privacy Properties Destination Blinding:\nThe blinded public key:\nIs unlinkable to the original destination (without knowing the secret) Changes daily, preventing long-term correlation Cannot be reversed to find the original public key Client Membership Privacy:\nPer-client authorization provides:\nAnonymity: No way to identify which clients are authorized Untraceability: Cannot track when specific clients added/revoked Size obfuscation: Can add dummy entries to hide true count DHT Privacy:\nStorage location rotates daily:\nlocation = SHA-256(sig_type || blinded_public_key) This prevents:\nCorrelation across days via DHT lookups Long-term monitoring of service availability Traffic analysis of DHT queries Threat Model Adversary Capabilities:\nNetwork Adversary:\nCan monitor all DHT traffic Can observe encrypted LeaseSet publications Cannot decrypt without proper keys Floodfill Adversary:\nCan store and analyze all encrypted LeaseSets Can track publication patterns over time Cannot decrypt Layer 1 or Layer 2 Can see client count (but not identities) Authorized Client Adversary:\nCan decrypt specific encrypted LeaseSets Can access inner LeaseSet2 data Cannot determine other clients\u0026rsquo; identities Cannot decrypt past LeaseSets (with ephemeral keys) Out of Scope:\nMalicious router implementations Compromised router host systems Side-channel attacks (timing, power analysis) Physical access to keys Social engineering attacks Attack Scenarios 1. Offline Keys Tracking Attack:\nAttack: Adversary tracks encrypted LeaseSets via unchanging offline signature block.\nMitigation: Generate new transient keys daily (in addition to blinded keys).\nStatus: Documented recommendation, implementation-specific.\n2. Client Position Inference Attack:\nAttack: If client order is static, clients can infer their position and detect when other clients added/removed.\nMitigation: Randomize client order in authorization list for each publication.\nStatus: Documented recommendation in specification.\n3. Client Count Analysis Attack:\nAttack: Adversary monitors client count changes over time to infer service popularity or client churn.\nMitigation: Add random dummy entries to authorization list.\nStatus: Optional feature, deployment-specific trade-off (size vs. privacy).\n4. PSK Interception Attack:\nAttack: Adversary intercepts PSK during out-of-band exchange and can decrypt all future encrypted LeaseSets.\nMitigation: Use DH client authorization instead, or ensure secure key exchange (Signal, OTR, PGP).\nStatus: Known limitation of PSK approach, documented in specification.\n5. Timing Correlation Attack:\nAttack: Adversary correlates publication times across days to link encrypted LeaseSets.\nMitigation: Randomize publication times, use delayed publishing.\nStatus: Implementation-specific, not addressed in core specification.\n6. Long-term Secret Compromise:\nAttack: Adversary compromises the blinding secret and can compute all past and future blinded keys.\nMitigation:\nUse optional secret parameter (not empty) Rotate secret periodically Use different secrets for different services Status: Secret parameter is optional; using it is highly recommended.\nOperational Security Key Management:\nSigning Private Key:\nStore offline in cold storage Use only for generating blinded keys (batch process) Never expose to online router Blinded Private Keys:\nGenerate offline, deliver in batches Rotate daily automatically Delete after use (forward secrecy) Transient Private Keys (with offline keys):\nGenerate offline, deliver in batches Can be longer-lived (days/weeks) Rotate regularly for enhanced privacy Client Authorization Keys:\nDH: Client private keys never leave client device PSK: Use unique keys per client, secure exchange Revoke immediately upon client removal Secret Management:\nThe optional secret parameter in GENERATE_ALPHA:\nSHOULD be used for high-security services MUST be transmitted securely to authorized clients SHOULD be rotated periodically (e.g., monthly) CAN be different for different client groups Monitoring and Auditing:\nPublication Monitoring:\nVerify encrypted LeaseSets published successfully Monitor floodfill acceptance rates Alert on publication failures Client Access Monitoring:\nLog client authorization attempts (without identifying clients) Monitor for unusual patterns Detect potential attacks early Key Rotation Auditing:\nVerify daily key rotation occurs Check blinded key changes daily Ensure old keys are deleted Implementation Security Constant-Time Operations:\nImplementations MUST use constant-time operations for:\nAll scalar arithmetic (mod L operations) Private key comparisons Signature verification DH key agreement Memory Security:\nZero sensitive key material after use Use secure memory allocation for keys Prevent keys from being paged to disk Clear stack variables containing key material Random Number Generation:\nUse cryptographically secure RNG (CSRNG) Properly seed RNG from OS entropy source Do not use predictable RNGs for key material Verify RNG output quality periodically Input Validation:\nValidate all public keys are on the curve Check all signature types are supported Verify all lengths before parsing Reject malformed encrypted LeaseSets early Error Handling:\nDo not leak information via error messages Use constant-time comparison for authentication Do not expose timing differences in decryption Log security-relevant events properly Recommendations For Service Operators:\n✅ Use Red25519 (type 11) for new destinations ✅ Use DH client authorization for high-security services ✅ Generate new transient keys daily when using offline keys ✅ Use the optional secret parameter in GENERATE_ALPHA ✅ Randomize client order in authorization lists ✅ Monitor publication success and investigate failures ⚠️ Consider dummy entries to hide client count (size trade-off) For Client Implementers:\n✅ Validate blinded public keys are on prime-order subgroup ✅ Verify all signatures before trusting data ✅ Use constant-time operations for cryptographic primitives ✅ Zero key material immediately after use ✅ Implement proper error handling without information leaks ✅ Support both Ed25519 and Red25519 destination types For Network Operators:\n✅ Accept encrypted LeaseSets in floodfill routers ✅ Enforce reasonable size limits to prevent abuse ✅ Monitor for anomalous patterns (extremely large, frequent updates) ⚠️ Consider rate limiting encrypted LeaseSet publications Implementation Notes Java I2P Implementation Repository: https://github.com/i2p/i2p.i2p Key Classes:\nnet.i2p.data.LeaseSet2 - LeaseSet2 structure net.i2p.data.EncryptedLeaseSet - Encrypted LS2 implementation net.i2p.crypto.eddsa.EdDSAEngine - Ed25519/Red25519 signatures net.i2p.crypto.HKDF - HKDF implementation net.i2p.crypto.ChaCha20 - ChaCha20 cipher Configuration:\nEnable encrypted LeaseSet in clients.config:\n# 启用加密的 LeaseSet i2cp.encryptLeaseSet=true # 可选：启用客户端授权 i2cp.enableAccessList=true # 可选：使用 DH（Diffie-Hellman）授权（默认为 PSK（预共享密钥）） i2cp.accessListType=0 # 可选：盲化密钥（强烈推荐） i2cp.blindingSecret=your-secret-here API Usage Example:\n// 创建加密的 LeaseSet EncryptedLeaseSet els = new EncryptedLeaseSet(); // 设置目标 els.setDestination(destination); // 启用按客户端授权 els.setAuthorizationEnabled(true); els.setAuthType(EncryptedLeaseSet.AUTH_DH); // 添加已授权客户端（DH（Diffie-Hellman）公钥） for (byte[] clientPubKey : authorizedClients) { els.addClient(clientPubKey); } // 设置盲化参数 els.setBlindingSecret(\u0026#34;your-secret\u0026#34;); // 签名并发布 els.sign(signingPrivateKey); netDb.publish(els); i2pd (C++) Implementation Repository: https://github.com/PurpleI2P/i2pd Key Files:\nlibi2pd/LeaseSet.h/cpp - LeaseSet implementations libi2pd/Crypto.h/cpp - Cryptographic primitives libi2pd/Ed25519.h/cpp - Ed25519/Red25519 signatures libi2pd/ChaCha20.h/cpp - ChaCha20 cipher Configuration:\nEnable in tunnel configuration (tunnels.conf):\n[my-hidden-service] type = http host = 127.0.0.1 port = 8080 keys = my-service-keys.dat # 启用加密的 LeaseSet（租约集合） encryptleaseset = true # 可选：客户端授权类型 (0=DH, 1=PSK) authtype = 0 # 可选：盲化秘密 secret = your-secret-here # 可选：已授权的客户端（每行一个，公钥为 base64 编码） client.1 = base64-编码的-客户端-公钥-1 client.2 = base64-编码的-客户端-公钥-2 API Usage Example:\n// 创建加密的 LeaseSet auto encryptedLS = std::make_shared\u0026lt;i2p::data::EncryptedLeaseSet\u0026gt;( destination, blindingSecret ); // 启用按客户端授权 encryptedLS-\u0026gt;SetAuthType(i2p::data::AUTH_TYPE_DH); // 添加已授权客户端 for (const auto\u0026amp; clientPubKey : authorizedClients) { encryptedLS-\u0026gt;AddClient(clientPubKey); } // 签名并发布 encryptedLS-\u0026gt;Sign(signingPrivKey); netdb.Publish(encryptedLS); Testing and Debugging Test Vectors:\nGenerate test vectors for implementation verification:\n# 测试向量 1：密钥盲化 destination_pubkey = bytes.fromhex(\u0026#39;a\u0026#39; * 64) sigtype = 7 blinded_sigtype = 11 date = \u0026#34;20251015\u0026#34; secret = \u0026#34;\u0026#34; alpha = generate_alpha(destination_pubkey, sigtype, blinded_sigtype, date, secret) print(f\u0026#34;Alpha: {alpha.hex()}\u0026#34;) # 预期: (对照参考实现进行验证) Unit Tests:\nKey areas to test:\nHKDF derivation with various inputs ChaCha20 encryption/decryption Red25519 signature generation and verification Key blinding (private and public) Layer 1/2 encryption/decryption Client authorization (DH and PSK) Base32 address generation and parsing Integration Tests:\nPublish encrypted LeaseSet to test network Retrieve and decrypt from client Verify daily key rotation Test client authorization (add/remove clients) Test offline keys (if supported) Common Implementation Errors:\nIncorrect mod L reduction: Must use proper modular arithmetic Endianness errors: Most fields are big-endian, but some crypto uses little-endian Off-by-one in array slicing: Verify indices are inclusive/exclusive as needed Missing constant-time comparisons: Use constant-time for all sensitive comparisons Not zeroing key material: Always zero keys after use Performance Considerations Computational Costs:\nOperation Cost Notes Key blinding (server)1 scalar multPer publication Key blinding (client)1 point add + 1 scalar multPer retrieval Layer 1 encryption1 HKDF + 1 ChaCha20Fast Layer 2 encryption1 HKDF + 1 ChaCha20Fast DH client auth (server)N+1 X25519 opsN = number of clients DH client auth (client)1 X25519 opPer retrieval PSK client auth0 DH opsOnly HKDF + ChaCha20 Signature (Red25519)1 signature opSimilar cost to Ed25519 Size Overhead:\nComponent Size Frequency Blinded public key32 bytesPer LeaseSet Layer 1 encryption overhead32 bytes (salt)Per LeaseSet Layer 2 encryption overhead32 bytes (salt)Per LeaseSet DH auth per client40 bytesPer client per LeaseSet DH ephemeral pubkey32 bytesPer LeaseSet (if DH auth) PSK auth per client40 bytesPer client per LeaseSet PSK salt32 bytesPer LeaseSet (if PSK auth) Signature64 bytesPer LeaseSet Offline sig block≈100 bytesPer LeaseSet (if offline keys) Typical Sizes:\nNo client auth: ~200 bytes overhead With 10 DH clients: ~600 bytes overhead With 100 DH clients: ~4200 bytes overhead Optimization Tips:\nBatch key generation: Generate blinded keys for multiple days in advance Cache subcredentials: Compute once per day, reuse for all publications Reuse ephemeral keys: Can reuse ephemeral DH key for short period (minutes) Parallel client encryption: Encrypt client cookies in parallel Fast path for no auth: Skip authorization layer entirely when disabled Compatibility Backward Compatibility:\nEd25519 (type 7) destinations supported for unblinded keys Red25519 (type 11) required for blinded keys Traditional LeaseSets still fully supported Encrypted LeaseSets do not break existing network Forward Compatibility:\nReserved flag bits for future features Extensible authorization scheme (3 bits allow 8 types) Version field in various structures Interoperability:\nJava I2P and i2pd fully interoperable since: Java I2P 0.9.40 (May 2019) i2pd 2.58.0 (September 2025) Encrypted LeaseSets work across implementations Client authorization works across implementations References IETF RFCs RFC 2104 - HMAC: Keyed-Hashing for Message Authentication (February 1997) RFC 5869 - HMAC-based Extract-and-Expand Key Derivation Function (HKDF) (May 2010) RFC 7539 - ChaCha20 and Poly1305 for IETF Protocols (May 2015) RFC 7748 - Elliptic Curves for Security (January 2016) I2P Specifications Common Structures Specification - LeaseSet2 and EncryptedLeaseSet structures Proposal 123: New netDB Entries - Background and design of LeaseSet2 Proposal 146: Red25519 - Red25519 signature scheme specification Proposal 149: B32 for Encrypted LS2 - Base32 addressing for encrypted LeaseSets Red25519 Specification - Detailed Red25519 implementation B32 Addressing Specification - Base32 address format Network Database Documentation - NetDB usage and operations I2CP Specification - I2P Client Protocol Cryptographic References Ed25519 Paper - \u0026ldquo;High-speed high-security signatures\u0026rdquo; by Bernstein et al. ZCash Protocol Specification - Section 5.4.6: RedDSA signature scheme Tor Rendezvous Specification v3 - Tor\u0026rsquo;s onion service specification (for comparison) Security References Key Blinding Security Discussion - Tor Project mailing list discussion Tor Ticket #8106 - Key blinding implementation discussion PRNG Security - Random number generator security considerations Tor PRNG Discussion - Discussion of PRNG usage in Tor Implementation References Java I2P Repository - Official Java implementation i2pd Repository - C++ implementation I2P Website - Official I2P project website I2P Specifications - Complete specification index Version History I2P Release Notes - Official release announcements Java I2P Releases - GitHub release history i2pd Releases - GitHub release history Appendix A: Cryptographic Constants Ed25519 / Red25519 Constants # Ed25519（椭圆曲线数字签名算法）基点（生成元） B = 2**255 - 19 # Ed25519 群阶（标量域大小） L = 2**252 + 27742317777372353535851937790883648493 # 签名类型值 SIGTYPE_ED25519 = 7 # 0x0007 SIGTYPE_RED25519 = 11 # 0x000b # 密钥长度 PRIVKEY_SIZE = 32 # bytes PUBKEY_SIZE = 32 # bytes SIGNATURE_SIZE = 64 # bytes ChaCha20 Constants # ChaCha20 参数 CHACHA20_KEY_SIZE = 32 # 字节（256 位） CHACHA20_NONCE_SIZE = 12 # 字节（96 位） CHACHA20_INITIAL_COUNTER = 1 # RFC 7539 允许 0 或 1 HKDF Constants # HKDF 参数 HKDF_HASH = \u0026#34;SHA-256\u0026#34; HKDF_SALT_MAX = 32 # 字节（HashLen） # HKDF 的 info 字符串（域分离） HKDF_INFO_ALPHA = b\u0026#34;i2pblinding1\u0026#34; HKDF_INFO_LAYER1 = b\u0026#34;ELS2_L1K\u0026#34; HKDF_INFO_LAYER2 = b\u0026#34;ELS2_L2K\u0026#34; HKDF_INFO_DH_AUTH = b\u0026#34;ELS2_XCA\u0026#34; HKDF_INFO_PSK_AUTH = b\u0026#34;ELS2PSKA\u0026#34; Hash Personalization Strings # SHA-256 个性化字符串 HASH_PERS_ALPHA = b\u0026#34;I2PGenerateAlpha\u0026#34; HASH_PERS_RED25519 = b\u0026#34;I2P_Red25519H(x)\u0026#34; HASH_PERS_CREDENTIAL = b\u0026#34;credential\u0026#34; HASH_PERS_SUBCREDENTIAL = b\u0026#34;subcredential\u0026#34; Structure Sizes # 第0层（外层）大小 BLINDED_SIGTYPE_SIZE = 2 # 字节 BLINDED_PUBKEY_SIZE = 32 # 字节（用于 Red25519） PUBLISHED_TS_SIZE = 4 # 字节 EXPIRES_SIZE = 2 # 字节 FLAGS_SIZE = 2 # 字节 LEN_OUTER_CIPHER_SIZE = 2 # 字节 SIGNATURE_SIZE = 64 # 字节（Red25519） # 离线密钥块大小 OFFLINE_EXPIRES_SIZE = 4 # 字节 OFFLINE_SIGTYPE_SIZE = 2 # 字节 OFFLINE_SIGNATURE_SIZE = 64 # 字节 # 第 1 层 (中间) 大小 AUTH_FLAGS_SIZE = 1 # 字节 EPHEMERAL_PUBKEY_SIZE = 32 # 字节 (DH 认证) AUTH_SALT_SIZE = 32 # 字节 (PSK 认证) NUM_CLIENTS_SIZE = 2 # 字节 CLIENT_ID_SIZE = 8 # 字节 CLIENT_COOKIE_SIZE = 32 # 字节 AUTH_CLIENT_ENTRY_SIZE = 40 # 字节 (CLIENT_ID + CLIENT_COOKIE) # 加密开销 SALT_SIZE = 32 # 字节（前置于每个加密层之前） # Base32 地址 B32_ENCRYPTED_DECODED_SIZE = 35 # 字节 B32_ENCRYPTED_ENCODED_LEN = 56 # 字符 B32_SUFFIX = \u0026#34;.b32.i2p\u0026#34; Appendix B: Test Vectors Test Vector 1: Alpha Generation Input:\n# 目的地公钥（Ed25519） A = bytes.fromhex(\u0026#39;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\u0026#39;) stA = 0x0007 # Ed25519 stA_prime = 0x000b # Red25519 date = \u0026#34;20251015\u0026#34; secret = \u0026#34;\u0026#34; # 空的秘密 Computation:\nkeydata = A || bytes([0x00, 0x07]) || bytes([0x00, 0x0b]) # keydata = 36 字节 salt = SHA256(b\u0026#34;I2PGenerateAlpha\u0026#34; + keydata) ikm = b\u0026#34;20251015\u0026#34; info = b\u0026#34;i2pblinding1\u0026#34; seed = HKDF(salt, ikm, info, 64) alpha = LEOS2IP(seed) mod L Expected Output:\n(与参考实现比对) alpha = [64 字节十六进制值] Test Vector 2: ChaCha20 Encryption Input:\nkey = bytes([i for i in range(32)]) # 0x00..0x1f nonce = bytes([i for i in range(12)]) # 0x00..0x0b plaintext = b\u0026#34;Hello, I2P!\u0026#34; Computation:\nciphertext = ChaCha20_Encrypt(key, nonce, plaintext, counter=1) Expected Output:\nciphertext = [与 RFC 7539 测试向量比对验证] Test Vector 3: HKDF Input:\nsalt = bytes(32) # 全零 ikm = b\u0026#34;test input keying material\u0026#34; info = b\u0026#34;ELS2_L1K\u0026#34; n = 44 Computation:\nkeys = HKDF(salt, ikm, info, n) Expected Output:\nkeys = [44字节的十六进制值] Test Vector 4: Base32 Address Input:\npubkey = bytes.fromhex(\u0026#39;bbbb\u0026#39; + \u0026#39;bb\u0026#39; * 30) # 32 字节 unblinded_sigtype = 11 # Red25519 blinded_sigtype = 11 # Red25519 Computation:\naddress = generate_encrypted_b32_address(pubkey, unblinded_sigtype, blinded_sigtype) Expected Output:\naddress = [56 个 base32 字符].b32.i2p # 确认校验和验证能正确通过 Appendix C: Glossary Alpha (α): The secret blinding factor used to blind public and private keys. Generated from the destination, date, and optional secret.\nAuthCookie: A 32-byte random value encrypted for each authorized client, used as input to Layer 2 encryption.\nB (Base Point): The generator point for the Ed25519 elliptic curve.\nBlinded Key: A public or private key that has been transformed using the alpha blinding factor. Blinded keys cannot be linked to the original keys without knowing alpha.\nChaCha20: A stream cipher providing fast, secure encryption without requiring AES hardware support.\nClientID: An 8-byte identifier derived from HKDF output, used to identify authorization entries for clients.\nClientCookie: A 32-byte encrypted value containing the authCookie for a specific client.\nCredential: A 32-byte value derived from the destination\u0026rsquo;s public key and signature types, binding encryption to knowledge of the destination.\nCSRNG: Cryptographically Secure Random Number Generator. Must provide unpredictable output suitable for key generation.\nDH (Diffie-Hellman): A cryptographic protocol for securely establishing shared secrets. I2P uses X25519.\nEd25519: An elliptic curve signature scheme providing fast signatures with 128-bit security level.\nEphemeral Key: A short-lived cryptographic key, typically used once and then discarded.\nFloodfill: I2P routers that store and serve network database entries, including encrypted LeaseSets.\nHKDF: HMAC-based Key Derivation Function, used to derive multiple cryptographic keys from a single source.\nL (Order): The order of the Ed25519 scalar field (approximately 2^252).\nLayer 0 (Outer): The plaintext portion of an encrypted LeaseSet, containing blinded key and metadata.\nLayer 1 (Middle): The first encrypted layer, containing client authorization data.\nLayer 2 (Inner): The innermost encrypted layer, containing the actual LeaseSet2 data.\nLeaseSet2 (LS2): Second version of I2P\u0026rsquo;s network database entry format, introducing encrypted variants.\nNetDB: The I2P network database, a distributed hash table storing router and destination information.\nOffline Keys: A feature allowing the main signing key to remain in cold storage while a transient key handles daily operations.\nPSK (Pre-Shared Key): A symmetric key shared in advance between two parties, used for PSK client authorization.\nRed25519: An Ed25519-based signature scheme with key blinding support, based on ZCash RedDSA.\nSalt: Random data used as input to key derivation functions to ensure unique outputs.\nSigType: A numeric identifier for signature algorithms (e.g., 7 = Ed25519, 11 = Red25519).\nSubcredential: A 32-byte value derived from the credential and blinded public key, binding encryption to a specific encrypted LeaseSet.\nTransient Key: A temporary signing key used with offline keys, with a limited validity period.\nX25519: An elliptic curve Diffie-Hellman protocol over Curve25519, providing key agreement.\nDocument Information Status: This document represents the current stable encrypted LeaseSet specification as implemented in I2P since June 2019. The protocol is mature and widely deployed.\nContributing: For corrections or improvements to this documentation, please submit issues or pull requests to the I2P specifications repository.\nSupport: For questions about implementing encrypted LeaseSets:\nI2P Forum: https://i2pforum.net/ IRC: #i2p-dev on OFTC Matrix: #i2p-dev:matrix.org Acknowledgments: This specification builds on work by the I2P development team, ZCash cryptography research, and Tor Project\u0026rsquo;s key blinding research.\n","description":"受访问控制的 LeaseSet 格式，用于私有 Destination（目标标识）","id":"14f2a4c0bb3f459df8db8dbce45508ff","section":"docs","title":"加密的 LeaseSet","url":"/zh/docs/specs/encryptedleaseset/"},{"categories":null,"content":" 遗留状态： 此内容仅保留用于历史参考。它记录了 I2P 0.6.1.10 之前发布的 tunnel 系统，不应在现代开发中使用。有关生产环境的指导，请参阅当前实现 。\n最初的 tunnel 子系统也使用单向的 tunnels，但在消息布局、重复检测和构建策略上有所不同。下文的许多章节为便于比较，沿用了该已弃用文档的结构。\n1. Tunnel 概述 Tunnels 是由创建者选择的有序节点序列构建而成。 Tunnel 的长度范围为 0–7 跳，并提供若干可调选项，用于填充、限速和干扰数据生成。 入站 tunnels 将消息从不受信任的网关传递到创建者（端点）；出站 tunnels 将数据从创建者向外推送。 Tunnel 的生命周期为 10 分钟，之后会构建新的 tunnels（通常使用相同的节点，但采用不同的 tunnel ID）。 2. 遗留设计中的运作 2.1 消息预处理 网关累积了≤32 KB 的 I2NP 负载，选择了填充，并生成了一个包含以下内容的负载：\n一个两字节的填充长度字段，以及对应数量的随机字节 一系列 {instructions, I2NP message} 对，用于描述投递目标、分片以及可选延迟 完整的 I2NP 消息，填充至 16 字节边界 投递指令将路由信息打包为位字段（投递类型、延迟标志位、分片标志位，以及可选扩展）。被分片的消息携带一个 4 字节的消息 ID，外加一个索引/是否为最后一片的标志位。\n2.2 网关加密 遗留设计在加密阶段将 tunnel 长度固定为八跳。网关以分层方式叠加 AES-256/CBC 和校验和块，使每一跳都能在不缩减负载的情况下验证完整性。校验和本身是由 SHA-256 派生的块，嵌入在消息中。\n2.3 参与者行为 参与方会跟踪入站的 tunnel ID，及早进行完整性校验，并在转发前丢弃重复消息。由于嵌入了填充与验证块，消息大小无论跳数多少都保持不变。\n2.4 端点处理 各端点按顺序解密分层块，验证校验和，并将载荷拆分回编码的指令和 I2NP 消息，以便进一步传递。\n3. Tunnel 构建（已弃用的过程） 对等节点选择： 对等节点从本地维护的档案（探索型 vs. 客户端型）中选择。原始文档已强调，通过在每个 tunnel 池内复用有序的对等节点列表来缓解前任者攻击 。 请求传递： 构建消息以逐跳方式转发，并为每个对等节点包含各自的加密段。诸如 telescopic extension（伸缩式扩展）、midstream rerouting（中途改路由）或移除校验和块等替代思路曾作为实验被讨论，但从未采纳。 池化： 本地每个目标地址各自维护独立的入站与出站池。设置包括期望数量、备用 tunnel、长度随机偏差、限速以及填充策略。 4. 限速与混合的概念 这份早期文稿提出了若干策略，为后续版本提供了参考：\n用于拥塞控制的加权随机早期丢弃 (WRED) 基于最近使用情况的移动平均值的每个 tunnel 限流 可选的 chaff（填充流量）和批处理控制（尚未完全实现） 5. 已归档的替代方案 原始文档中的一些章节探讨了从未部署过的构想：\n移除校验和块以降低逐跳处理开销 在中途对 tunnels 进行伸缩式调整，以改变对等节点构成 改用双向 tunnels（最终被否决） 使用更短的哈希或不同的填充策略 这些想法作为历史背景仍然具有价值，但并不反映现代的代码库。\n参考资料 原始遗留文档存档（0.6.1.10 之前） Tunnel 概览 以了解当前术语 对等节点画像与选择 以了解现代启发式方法 ","description":"I2P 0.6.1.10 之前使用的 tunnel 设计的归档说明。","id":"0970f5387a965fe6857e4afbb03bdc8f","section":"docs","title":"旧版 Tunnel 实现（遗留）","url":"/zh/docs/legacy/old-implementation/"},{"categories":null,"content":"请先阅读新开发者指南 。\n基本准则和编码风格 对于任何在开源项目或商业编程环境中工作过的人来说,以下大部分内容应该是常识。以下内容主要适用于主开发分支 i2p.i2p。其他分支、插件和外部应用的指南可能会有很大差异;请咨询相应的开发人员以获取指导。\n社区 请不要只是编写代码。如果可以的话,请参与其他开发活动,包括:在 IRC 和 i2pforum.i2p 上的开发讨论和支持;测试;错误报告和响应;文档编写;代码审查等。 活跃的开发者应该定期在 IRC #i2p-dev 上保持可联系。了解当前的发布周期。遵守发布里程碑,如功能冻结、标签冻结以及发布的代码提交截止日期。 发布周期 正常的发布周期为10-16周，每年四次发布。以下是典型13周周期内的大致截止日期。每次发布的实际截止日期由发布管理员在与整个团队协商后确定。\n上一版本发布后 1-2 天:允许向主干提交代码。 上一版本发布后 2-3 周:将其他分支的主要更改合并到主干的截止日期。 发布前 4-5 周:请求新主页链接的截止日期。 发布前 3-4 周:功能冻结。主要新功能的截止日期。 发布前 2-3 周:召开项目会议审查新主页链接请求(如有)。 发布前 10-14 天:字符串冻结。不再更改已翻译(已标记)的字符串。将字符串推送到 Transifex,在 Transifex 上公告翻译截止日期。 发布前 10-14 天:功能截止日期。此后仅允许错误修复。不再添加功能、重构或清理代码。 发布前 3-4 天:翻译截止日期。从 Transifex 拉取翻译并提交。 发布前 3-4 天:提交截止日期。此后未经发布构建者许可不得提交代码。 发布前数小时:代码审查截止日期。 Git 对分布式源代码控制系统有基本了解,即使你之前没有使用过 git。如果需要帮助请提出。一旦推送,提交就是永久性的;没有撤销操作。请务必小心。如果你之前没有使用过 git,请从小步骤开始。提交一些小的更改,看看效果如何。 在提交更改之前测试你的更改。如果你更喜欢先提交后测试的开发模式,请在你自己账户中使用你自己的开发分支,并在工作完成后创建一个 MR(合并请求)。不要破坏构建。不要造成回归问题。如果你确实造成了问题(这种情况会发生),请不要在推送更改后长时间消失。 如果你的更改不是微不足道的,或者你希望人们测试它并需要良好的测试报告来了解你的更改是否经过测试,请在 history.txt 中添加一个提交注释,并在 RouterVersion.java 中增加构建修订版本号。 不要在发布周期后期将重大更改提交到主 i2p.i2p 分支中。如果一个项目需要你花费超过几天时间,请在 git 中你自己的账户里创建你自己的分支,并在那里进行开发,这样你就不会阻碍发布。 对于大的更改(一般来说,超过 100 行,或涉及超过三个文件),将其提交到你自己 GitLab 账户上的新分支中,创建一个 MR,并指定一个审查者。将 MR 分配给你自己。一旦审查者批准,由你自己合并 MR。 不要在主 I2P_Developers 账户中创建 WIP(进行中的工作)分支(除了 i2p.www)。WIP 应该在你自己的账户中。当工作完成后,创建一个 MR。主账户中的分支应该仅用于真正的分叉,比如点发布版本。 以透明的方式进行开发,并考虑到社区。经常提交。在遵循上述准则的前提下,尽可能频繁地提交或合并到主分支。如果你正在自己的分支/账户中进行某个大项目,请让人们知道,以便他们可以跟进并审查/测试/评论。 编码风格 大部分代码的编码风格是使用 4 个空格缩进。不要使用制表符。不要重新格式化代码。如果你的 IDE 或编辑器想要重新格式化所有内容,请控制好它。在某些地方,编码风格有所不同。使用常识。模仿你正在修改的文件中的风格。 所有新的公共和包私有类和方法都需要 Javadocs。添加 @since 版本号。新私有方法的 Javadocs 也是需要的。 对于添加的任何 Javadocs,不得出现任何 doclint 错误或警告。使用 Oracle Java 14 或更高版本运行 ant javadoc 进行检查。所有参数必须有 @param 行,所有非 void 方法必须有 @return 行,所有声明抛出的异常必须有 @throws 行,并且不能有 HTML 错误。 core/(i2p.jar)中的类和 i2ptunnel 的部分内容是我们官方 API 的一部分。有几个树外插件和其他应用程序依赖于此 API。小心不要做出任何破坏兼容性的更改。除非具有通用实用性,否则不要向 API 添加方法。API 方法的 Javadocs 应该清晰完整。如果你添加或更改 API,还要更新网站上的文档(i2p.www 分支)。 在适当的地方标记字符串以供翻译,所有 UI 字符串都需要这样做。除非确实必要,否则不要更改现有的已标记字符串,因为这会破坏现有的翻译。在发布周期的标签冻结后,不要添加或更改已标记的字符串,以便翻译人员有机会在发布前进行更新。 尽可能使用泛型和并发类。I2P 是一个高度多线程的应用程序。 熟悉 FindBugs/SpotBugs 捕获的常见 Java 陷阱。运行 ant findbugs 了解更多信息。 从 0.9.47 版本开始,构建和运行 I2P 需要 Java 8。不要在嵌入式子系统中使用 Java 7 或 8 的类或方法:addressbook、core、i2ptunnel.jar(非 UI)、mstreaming、router、routerconsole(仅 news)、streaming。这些子系统被 Android 和仅需要 Java 6 的嵌入式应用程序使用。所有类必须在 Android API 14 中可用。如果当前版本的 Android SDK 支持并且它们编译为 Java 6 兼容的代码,则这些子系统中可以使用 Java 7 语言特性。 Try-with-resources 不能在嵌入式子系统中使用,因为它需要运行时的 java.lang.AutoCloseable,而这直到 Android API 19(KitKat 4.4)才可用。 java.nio.file 包不能在嵌入式子系统中使用,因为它直到 Android API 26(Oreo 8)才可用。 除上述限制外,Java 8 的类、方法和构造仅可在以下子系统中使用:BOB、desktopgui、i2psnark、i2ptunnel.war(UI)、jetty-i2p.jar、jsonrpc、routerconsole(除 news 外)、SAM、susidns、susimail、systray。 插件作者可以通过 plugin.config 文件要求任何最低 Java 版本。 在原始类型和类之间显式转换;不要依赖自动装箱/拆箱。 不要使用 URL。使用 URI。 不要捕获 Exception。单独捕获 RuntimeException 和已检查异常。 不要在没有 UTF-8 字符集参数的情况下使用 String.getBytes()。你也可以使用 DataHelper.getUTF8() 或 DataHelper.getASCII()。 读取或写入文件时始终指定 UTF-8 字符集。DataHelper 实用程序可能会有所帮助。 使用 String.toLowerCase() 或 String.toUpperCase() 时始终指定区域设置(例如 Locale.US)。不要使用 String.equalsIgnoreCase(),因为无法指定区域设置。 不要使用 String.split()。使用 DataHelper.split()。 不要添加格式化日期和时间的代码。使用 DataHelper.formatDate() 和 DataHelper.formatTime()。 确保在 finally 块中关闭 InputStream 和 OutputStream。 对所有 for 和 while 块使用 {},即使只有一行。如果你对 if、else 或 if-else 块中的任何一个使用 {},则对所有块都使用它。将 } else { 放在单独一行上。 尽可能将字段指定为 final。 不要在静态字段中存储 I2PAppContext、RouterContext、Log 或对 router 或 context 项的任何其他引用。 不要在构造函数中启动线程。使用 I2PAppThread 而不是 Thread。 日志记录 以下准则适用于 router、webapps 和所有插件。\n对于任何不在默认日志级别（WARN、INFO 和 DEBUG）显示的消息，除非消息是静态字符串（无拼接），否则始终在日志调用前使用 log.shouldWarn()、log.shouldInfo() 或 log.shouldDebug()，以避免不必要的对象创建开销。 可能在默认日志级别（ERROR、CRIT 和 logAlways()）显示的日志消息应该简洁、清晰，并且易于非技术用户理解。这包括可能同时显示的异常原因文本。如果错误可能发生（例如，在表单提交错误时），请考虑翻译。否则，翻译不是必需的，但搜索并重用其他地方已标记为翻译的字符串可能会有所帮助。 不在默认日志级别（WARN、INFO 和 DEBUG）显示的日志消息是供开发人员使用的，不需要满足上述要求。但是，WARN 消息在 Android 日志选项卡中可用，可能有助于用户调试问题，因此也要谨慎使用 WARN 消息。 INFO 和 DEBUG 日志消息应谨慎使用，特别是在热代码路径（频繁执行的代码）中。虽然在开发期间很有用，但在测试完成后请考虑删除或注释掉它们。 不要记录到 stdout 或 stderr（wrapper log，包装器日志）。 许可证 仅提交你自己编写的代码。在提交任何来自其他来源的代码或库 JAR 文件之前,请说明为何必要,验证许可证是否兼容,并获得发布管理者的批准。 如果你确实获得批准添加外部代码或 JAR 文件,并且在任何 Debian 或 Ubuntu 软件包中有可用的二进制文件,你必须实现构建和打包选项以使用外部软件包。需要修改的文件清单:build.properties、build.xml、debian/control、debian/i2p-router.install、debian/i2p-router.links、debian/rules、sub-build.xml。 对于从外部来源提交的任何图像,你有责任首先验证许可证是否兼容。在提交注释中包含许可证和来源信息。 错误 管理问题是每个人的工作；请提供帮助。关注 GitLab 上您可以提供帮助的问题。如果可以，请对问题进行评论、修复和关闭。 新开发者应该从修复问题开始。当您有了修复方案时，将补丁附加到问题上并添加关键词 review-needed。在成功审查并检入更改之前，不要关闭问题。一旦您顺利完成几个工单的处理后，就可以遵循上述正常流程。 当您认为已经修复问题时就关闭它。我们没有测试部门来验证和关闭工单。如果您不确定是否已修复，请关闭它并添加注释说明\u0026quot;我认为已经修复，如果仍然存在问题请测试并重新打开\u0026quot;。添加包含开发版本号或修订版本的评论，并将里程碑设置为下一个发布版本。 ","description":"为I2P贡献的端到端指南：工作流程、发布周期、编码风格、日志记录、许可证和问题处理","id":"6c8fe691caf216ba9024152afc39c5c6","section":"docs","title":"开发者指南和编码风格","url":"/zh/docs/develop/dev-guidelines/"},{"categories":null,"content":"概述 I2P Streaming Library 在 I2P 的消息层之上提供可靠的、有序的、经过身份验证的传输，类似于 IP 上的 TCP。它位于 I2CP 协议 之上,几乎所有交互式 I2P 应用程序都使用它,包括 HTTP 代理、IRC、BitTorrent 和电子邮件。\n核心特性 使用 SYN、ACK 和 FIN 标志的单阶段连接建立，可与有效载荷数据捆绑以减少往返次数。 滑动窗口拥塞控制，针对 I2P 的高延迟环境调整了慢启动和拥塞避免机制。 数据包压缩（默认 4KB 压缩段），平衡重传成本和分片延迟。 I2P destination 之间完全经过身份验证、加密且可靠的通道抽象。 这种设计使得小型 HTTP 请求和响应能够在单次往返中完成。SYN 数据包可以携带请求负载,而响应方的 SYN/ACK/FIN 可能包含完整的响应正文。\nAPI 基础 Java 流式 API 遵循标准的 Java socket 编程方式:\nI2PSocketManager mgr = I2PSocketManagerFactory.createManager(host, port, options); I2PSocket socket = mgr.connect(destination); I2PServerSocket server = mgr.getServerSocket(); I2PSocketManagerFactory 通过 I2CP 协商或复用 router 会话。 如果未提供密钥,会自动生成新的目标地址。 开发者可以通过 options 映射传递 I2CP 选项(例如 tunnel 长度、加密类型或连接设置)。 I2PSocket 和 I2PServerSocket 与标准 Java Socket 接口保持一致,使迁移过程更加简单。 完整的 Javadocs 可从 I2P router 控制台或此处 获取。\n配置与调优 您可以在通过以下方式创建套接字管理器时传递配置属性:\nI2PSocketManagerFactory.createManager(host, port, properties); 密钥选项 Option Description Default i2p.streaming.maxWindowSize Maximum send window (bytes) 128 KB i2p.streaming.initialRTO Initial retransmission timeout 9s i2p.streaming.inactivityTimeout Timeout before connection close 90s i2p.streaming.enforceProtocol Enforce protocol ID (prevents confusion) true i2p.streaming.congestionAlgorithm Congestion control method Default (AIMD TCP-like) i2p.streaming.disableRejectLogging Disable logging rejected packets false ### 按工作负载的行为 Workload Recommended Settings HTTP-like Default parameters are ideal. Bulk Transfer Increase window size to 256 KB or 512 KB; lengthen timeouts. Real-time Streaming Lower tunnel length to 1-2 hops; adjust RTO downwards. 自 0.9.4 版本以来的新功能包括拒绝日志抑制、DSA 列表支持(0.9.21)以及强制协议执行(0.9.36)。自 2.10.0 版本以来的 router 包含传输层的后量子混合加密(ML-KEM + X25519)。 协议详情 每个流由一个流ID（Stream ID）标识。数据包携带类似于TCP的控制标志：SYNCHRONIZE、ACK、FIN和RESET。数据包可以同时包含数据和控制标志，从而提高短期连接的效率。\n连接生命周期 SYN 已发送 — 发起方包含可选数据。 SYN/ACK 响应 — 响应方包含可选数据。 ACK 最终确认 — 建立可靠性和会话状态。 FIN/RESET — 用于有序关闭或突然终止。 分片与重组 由于 I2P tunnel 会引入延迟和消息重新排序，该库会缓冲来自未知或提前到达的流的数据包。缓冲的消息会被存储直到同步完成，从而确保完整且有序的传递。\n协议强制执行 选项 i2p.streaming.enforceProtocol=true(自 0.9.36 起为默认值)确保连接使用正确的 I2CP 协议号,防止共享同一 destination 的多个子系统之间发生冲突。\n互操作性和最佳实践 流式协议与 Datagram API 共存，为开发者提供了面向连接和无连接传输方式之间的选择。\nUse Case Recommended Transport Reliable, ordered data (HTTP, IRC, FTP) Streaming Connectionless or lossy data (DNS, telemetry) Datagram ### 共享客户端 应用程序可以通过作为共享客户端运行来重用现有的 tunnel，允许多个服务共享同一个 destination。虽然这减少了开销，但会增加跨服务关联的风险——请谨慎使用。\n拥塞控制 流式传输层通过基于 RTT 的反馈持续适应网络延迟和吞吐量。 当 router 作为贡献节点（启用参与 tunnel）时,应用程序性能最佳。 类 TCP 拥塞控制机制可防止慢速节点过载,并帮助平衡各 tunnel 的带宽使用。 延迟考量 由于 I2P 会增加数百毫秒的基础延迟，应用程序应该尽量减少往返次数。在可能的情况下，将数据与连接建立过程捆绑在一起（例如，在 SYN 中包含 HTTP 请求）。避免依赖许多小型顺序交换的设计。\n测试与兼容性 始终针对 Java I2P 和 i2pd 进行测试，以确保完全兼容。 尽管协议已标准化，但可能存在细微的实现差异。 优雅地处理较旧的 router——许多节点仍在运行 2.0 之前的版本。 使用 I2PSocket.getOptions() 和 getSession() 监控连接统计信息，以读取 RTT 和重传指标。 性能在很大程度上取决于 tunnel 配置： - 短 tunnel（1-2 跳） → 延迟较低，匿名性降低。 - 长 tunnel（3+ 跳） → 匿名性较高，RTT 增加。\n关键改进 (2.0.0–2.10.0) Feature Introduced Description Persistent ACK Bundling 2.0.0 Optimized round-trip reduction for HTTP workloads. Adaptive Window Scaling 2.3.0 Improved large file transfer stability. Thread Pooling and Socket Reuse 2.5.0 Reduced per-connection overhead. Protocol Enforcement Default 0.9.36 Ensures correct stream usage. Hybrid ML-KEM Ratchet 2.10.0 Adds post-quantum hybrid encryption layer. i2pd Streaming API Compatibility Fixes 2.9.0 Full parity with Java I2P library behavior. --- 概述 I2P Streaming Library 是 I2P 内所有可靠通信的支柱。它确保有序、经过身份验证、加密的消息传递,并在匿名环境中提供几乎可直接替代 TCP 的方案。\n为了实现最佳性能：- 通过 SYN+payload 捆绑来最小化往返次数。- 根据工作负载调整窗口和超时参数。- 对于延迟敏感的应用程序，优先使用较短的 tunnel。- 使用拥塞友好的设计以避免使对等节点过载。\n","description":"大多数 I2P 应用程序使用的类 TCP 传输协议","id":"d5eaf45dea26928a910e0f2b8a0e1037","section":"docs","title":"流式传输协议","url":"/zh/docs/api/streaming/"},{"categories":null,"content":"概述 I2P Streaming Library（I2P 流式传输库）在 I2P 的不可靠消息层之上提供可靠、有序且经认证的数据传送——类似于 IP 之上的 TCP。它被几乎所有交互式 I2P 应用程序所使用，例如网页浏览、IRC、电子邮件和文件共享。\n它确保在 I2P 的高延迟匿名 tunnels 之上实现可靠传输、拥塞控制、重传与流量控制。每条数据流在目的地之间均为端到端完全加密。\n核心设计原则 Streaming 库实现了单阶段连接建立，其中 SYN、ACK 和 FIN 标志可以在同一条报文中携带数据有效载荷。这在高延迟环境中可最大限度地减少往返次数 — 一个小型 HTTP 事务可以在一次往返内完成。\n拥塞控制与重传借鉴了 TCP 的设计，但已针对 I2P 的环境进行了适配。窗口大小以消息为单位，而非以字节为单位，并针对 tunnel 的时延与开销进行了调优。该协议支持慢启动、拥塞避免和指数退避，类似于 TCP 的 AIMD 算法（加性增大、乘性减小）。\n架构 流式传输库在应用程序与 I2CP 接口之间运行。\nLayer Responsibility Application Standard I2PSocket and I2PServerSocket usage Streaming Library Connection setup, sequencing, retransmission, and flow control I2CP Tunnel creation, routing, and message handling I2NP / Router Layer Transport through tunnels 大多数用户通过 I2PSocketManager（I2P 套接字管理器）、I2PTunnel 或 SAMv3 访问它。该库会透明地处理 Destination（目标地址）管理、tunnel 使用以及重传。 数据包格式 +-----------------------------------------------+ | Send Stream ID (4B) | Receive Stream ID (4B) | +-----------------------------------------------+ | Sequence Number (4B) | Ack Through (4B) | +-----------------------------------------------+ | NACK Count (1B) | optional NACK list (4B each) +-----------------------------------------------+ | Flags (1B) | Option Size (1B) | Options ... | +-----------------------------------------------+ | Payload ... | 标头详细信息 流ID: 32位值，用于唯一标识本地和远端流。 序列号: 对SYN从0开始，每条消息递增。 累计确认至: 确认直到N（含N）的所有消息，但不包括NACK（负确认）列表中的那些。 标志位: 用于控制状态和行为的位掩码。 选项: 用于RTT（往返时延）、MTU（最大传输单元）和协议协商的可变长度列表。 密钥标志位 Flag Purpose SYN Connection initiation ACK Acknowledge received packets FIN Graceful close RST Reset connection FROM_INCLUDED Sender’s destination included SIGNATURE_INCLUDED Message signed by sender ECHO / ECHO_REPLY Ping/Pong keepalive --- 流量控制与可靠性 Streaming（I2P 流式传输库）使用基于消息的窗口机制，与 TCP 的按字节方式不同。允许在途的未确认数据包数量等于当前窗口大小(默认 128)。\n机制 拥塞控制： 慢启动与基于 AIMD（加性增大/乘性减小）的拥塞避免。 Choke/Unchoke（阻塞/解除阻塞）： 基于缓冲区占用率的流量控制信令。 重传： 基于 RFC 6298 的 RTO（重传超时）计算，并采用指数退避。 重复过滤： 在消息可能发生乱序的情况下确保可靠性。 典型的配置值：\nParameter Default Description maxWindowSize 128 Max unacknowledged messages maxMessageSize 1730 Maximum payload bytes per message initialRTO 9000 ms Initial retransmission timeout inactivityTimeout 90000 ms Idle connection timeout connectTimeout 300000 ms Connection establishment timeout --- 连接建立 发起方 发送一个 SYN（可选携带负载并包含 FROM_INCLUDED）。 应答方 以 SYN+ACK 应答（可能包含负载）。 发起方 发送最终的 ACK，以确认已建立连接。 可选的初始有效载荷允许在完整握手完成之前传输数据。\n实现细节 重传与超时 重传算法遵循 RFC 6298。 - 初始 RTO： 9s - 最小 RTO： 100ms - 最大 RTO： 45s - Alpha（平滑系数）： 0.125 - Beta（偏差系数）： 0.25\n控制块共享 对同一对等端的后续连接会复用之前的RTT（往返时延）和窗口数据，以更快实现速率爬升，避免“冷启动”延迟。控制块会在数分钟后过期。\nMTU 与分片 默认 MTU：1730 字节（可容纳两个 I2NP 消息）。 ECIES（椭圆曲线集成加密方案）目标地址：1812 字节（降低了开销）。 最小支持的 MTU：512 字节。 有效负载大小不包括 22 字节的最小流式传输头部。\n版本历史 Router Version Feature 0.7.1 Protocol numbers defined in I2CP 0.9.11 Variable-length signatures 0.9.12 ECDSA signature support 0.9.15 Ed25519 signature support 0.9.18 Ping/Pong payloads 0.9.20 FROM_INCLUDED not required in RESET 0.9.36 Protocol enforcement enabled by default 0.9.39 OFFLINE_SIGNATURE support 0.9.58 Bob’s hash added to NACK field in SYN 2.10.0 Post-Quantum hybrid encryption (experimental) --- 应用层使用 Java 示例 Properties props = new Properties(); props.setProperty(\u0026#34;i2p.streaming.maxWindowSize\u0026#34;, \u0026#34;512\u0026#34;); I2PSocketManager mgr = I2PSocketManagerFactory.createManager(props); I2PSocket socket = mgr.connect(destination); InputStream in = socket.getInputStream(); OutputStream out = socket.getOutputStream(); SAMv3 和 i2pd 支持 SAMv3: 为非Java客户端提供 STREAM 和 DATAGRAM 模式。 i2pd: 通过配置文件选项（例如 i2p.streaming.maxWindowSize、profile 等）提供相同的流式传输参数。 在流式传输与数据报之间进行选择 Use Case Recommended Transport Reason HTTP, IRC, Email Streaming Requires reliability DNS Repliable Datagram Single request/response Telemetry, Logging Raw Datagram Best-effort acceptable P2P DHT Datagram High connection churn --- 安全与后量子未来 流式会话在 I2CP 层进行端到端加密。 在 2.10.0 中对后量子混合加密（ML-KEM + X25519）提供实验性支持，但默认禁用。\n参考资料 Streaming（流式传输）API 概览 Streaming 协议规范 I2CP 规范 提案 144：Streaming MTU 计算 I2P 2.10.0 发行说明 ","description":"被大多数 I2P 应用使用的可靠、类似 TCP 的传输","id":"100837c91cc0808ee048c86902b36251","section":"docs","title":"流式协议","url":"/zh/docs/specs/streaming/"},{"categories":null,"content":"本指南概述了 I2P Router Console 及其配置页面。每个部分解释了页面的功能和用途,帮助您了解如何监控和配置您的 I2P router。\n访问路由器控制台 I2P Router Console 是管理和监控你的 I2P router 的中心枢纽。默认情况下,一旦你的 I2P router 运行起来,就可以通过 I2P Router Console 访问它。\n主页显示几个关键部分：\n应用程序 - 快速访问内置的 I2P 应用程序，如电子邮件、种子下载、Hidden Services Manager 和 Web 服务器 I2P 社区站点 - 链接到重要的社区资源，包括论坛、文档和项目网站 配置和帮助 - 用于配置带宽设置、管理插件和访问帮助资源的工具 网络和开发者信息 - 访问图表、日志、技术文档和网络统计信息 地址簿 URL: Address Book I2P 地址簿的功能类似于明网上的 DNS,允许你为 I2P 目标地址(eepsite)管理人类可读的名称。在这里你可以查看和添加 I2P 地址到你的个人地址簿。\n地址簿系统通过多个层次工作:\n本地记录 - 仅存储在您路由器上的个人地址簿\n本地地址簿 - 您手动添加或保存供自己使用的主机 私有地址簿 - 您不想与他人共享的地址；永远不会公开分发 订阅 - 远程地址簿来源（如 http://i2p-projekt.i2p/hosts.txt），可自动更新你的 router 地址簿中已知的 I2P 站点信息\n路由器地址簿 - 本地记录和订阅合并后的结果，可供路由器上所有 I2P 应用程序搜索\n已发布地址簿 - 可选的公开分享你的地址簿供他人订阅使用(如果你运行 I2P 站点会很有用)\n地址簿会定期轮询你的订阅源并将内容合并到你的 router 地址簿中,使你的 hosts.txt 文件与 I2P 网络保持同步。\n配置 URL: 高级配置 配置部分通过多个专门的选项卡提供对所有 router 设置的访问。\nAdvanced 高级配置页面提供了对底层 router 设置的访问权限,这些设置通常不需要用于正常操作。大多数用户不应修改这些设置,除非他们了解具体的配置选项及其对 router 行为的影响。\n主要特性：\nFloodfill 配置 - 控制您的路由器是否作为 floodfill 节点参与网络,这通过存储和分发网络数据库信息来帮助网络。这可能会使用更多系统资源,但会增强 I2P 网络。\n高级 I2P 配置 - 直接访问 router.config 文件，显示所有高级配置参数，包括：\n带宽限制和突发设置 传输设置（NTCP2、SSU2、UDP 端口和密钥） Router 标识和版本信息 控制台首选项和更新设置 大多数高级配置选项在用户界面中不显示,因为很少需要用到它们。要启用这些设置的编辑功能,您必须手动在 router.config 文件中添加 routerconsole.advanced=true。\n警告： 不正确地修改高级设置可能会对你的 router 性能或连接性产生负面影响。只有在你清楚自己在做什么的情况下才应更改这些设置。\nBandwidth URL: 带宽配置 带宽配置页面允许你控制路由器为 I2P 网络贡献多少带宽。当你将速率配置为与互联网连接速度相匹配时,I2P 的运行效果最佳。\n关键设置：\nKBps In - 路由器接受的最大入站带宽(下载速度) KBps Out - 路由器使用的最大出站带宽(上传速度) Share - 用于参与流量的出站带宽百分比(帮助为他人路由流量) 重要说明：\n所有数值单位均为每秒字节数（KBps），而非每秒比特数 您提供的带宽越多，对网络的帮助就越大，同时也能提升您自己的匿名性 您的上行共享量（KBps Out）决定了您对网络的整体贡献 如果您不确定网络速度，请使用带宽测试进行测量 更高的共享带宽既能提升您的匿名性，也有助于增强 I2P 网络 配置页面会根据您的设置显示预估的月度数据传输量,帮助您根据互联网套餐限制规划带宽分配。\nClient Configuration URL: 客户端配置 客户端配置页面允许您控制启动时运行哪些 I2P 应用程序和服务。您可以在此处启用或禁用内置的 I2P 客户端,而无需卸载它们。\n重要警告： 更改此处的设置时请务必小心。router console 和应用程序 tunnel 是 I2P 大多数用途所必需的。只有高级用户才应修改这些设置。\n可用客户端:\n应用程序隧道 - I2PTunnel 系统，用于管理客户端和服务器隧道（HTTP 代理、IRC 等） I2P 路由器控制台 - 您当前正在使用的基于网页的管理界面 I2P 网络服务器 (eepsite) - 内置的 Jetty 网络服务器，用于托管您自己的 I2P 网站 启动时在网页浏览器中打开路由器控制台 - 自动启动浏览器并打开控制台主页 SAM 应用程序桥接 - API 桥接，供第三方应用程序连接到 I2P 每个客户端显示: - 开机启动? - 复选框用于启用/禁用自动启动 - 控制 - 启动/停止按钮用于即时控制 - 类和参数 - 关于客户端启动方式的技术细节\n对\u0026quot;开机启动?\u0026ldquo;设置的更改需要重启 router 才能生效。所有修改都会保存到 /var/lib/i2p/i2p-config/clients.config.d/。\n高级 URL: I2CP Configuration I2CP (I2P Client Protocol) 配置页面允许您配置外部应用程序如何连接到您的 I2P router。I2CP 是应用程序用来与 router 通信以创建 tunnel 并通过 I2P 发送/接收数据的协议。\n重要： 默认设置适用于大多数用户。此处所做的任何更改也必须在外部客户端应用程序中进行配置。许多客户端不支持 SSL 或身份验证。所有更改都需要重启后才能生效。\n配置选项：\n外部 I2CP 接口配置\n启用（不使用 SSL） - 标准 I2CP 访问（默认且兼容性最好） 启用（需要 SSL） - 仅允许加密的 I2CP 连接 禁用 - 阻止外部客户端通过 I2CP 连接 I2CP Interface - 监听的网络接口(默认:127.0.0.1 仅限本地主机)\nI2CP Port - I2CP 连接的端口号(默认:7654)\n授权\n需要用户名和密码 - 为 I2CP 连接启用身份验证 用户名 - 设置 I2CP 访问所需的用户名 密码 - 设置 I2CP 访问所需的密码 安全提示： 如果你只在运行 I2P router 的同一台机器上运行应用程序，请将接口保持设置为 127.0.0.1 以防止远程访问。仅当你需要允许来自其他设备的 I2P 应用程序连接到你的 router 时才更改这些设置。\n带宽 URL: 网络配置 网络配置页面允许您配置 I2P router 如何连接到互联网,包括 IP 地址检测、IPv4/IPv6 偏好设置,以及 UDP 和 TCP 传输的端口设置。\n外部可达 IP 地址：\n使用所有自动检测方法 - 使用多种方法自动检测您的公网 IP（推荐） 禁用 UPnP IP 地址检测 - 防止使用 UPnP 发现您的 IP 忽略本地接口 IP 地址 - 不使用您的本地网络 IP 仅使用 SSU IP 地址检测 - 仅使用 SSU2 传输协议进行 IP 检测 隐藏模式 - 不发布 IP - 防止参与网络流量（会降低匿名性） 指定主机名或 IP - 手动设置您的公网 IP 或主机名 IPv4 配置：\n禁用入站连接（防火墙模式） - 如果你处于防火墙、家庭网络、ISP、DS-Lite 或运营商级 NAT 后面，导致入站连接被阻止，请勾选此项 IPv6 配置：\n优先使用 IPv4 而非 IPv6 - 优先选择 IPv4 连接 优先使用 IPv6 而非 IPv4 - 优先选择 IPv6 连接(双栈网络的默认设置) 启用 IPv6 - 允许 IPv6 连接 禁用 IPv6 - 禁用所有 IPv6 连接 仅使用 IPv6(禁用 IPv4) - 实验性的纯 IPv6 模式 禁用入站连接(防火墙阻挡) - 检查您的 IPv6 是否被防火墙阻挡 IP 变更时的操作：\n笔记本电脑模式 - 实验性功能,当你的 IP 地址变化时会更改 router 身份和 UDP 端口,以增强匿名性 UDP 配置：\n指定端口 - 为 SSU2 传输设置特定的 UDP 端口（必须在防火墙中开放） 完全禁用 - 仅在位于阻止所有出站 UDP 的防火墙后时选择 TCP 配置：\n指定端口 - 为 NTCP2 传输设置特定的 TCP 端口(必须在防火墙中打开) 使用为 UDP 配置的相同端口 - 通过对两种传输使用同一端口来简化配置 使用自动检测的 IP 地址 - 自动检测您的公网 IP(如果尚未检测到或被防火墙阻止,则显示\u0026quot;currently unknown\u0026rdquo;) 始终使用自动检测的 IP 地址(无防火墙) - 最适合可直接访问互联网的路由器 禁用入站(有防火墙) - 如果 TCP 连接被防火墙阻止,请勾选此项 完全禁用 - 仅在防火墙限速或阻止出站 TCP 的情况下选择 指定主机名或 IP - 手动配置您的外部可访问地址 重要： 网络设置的更改可能需要重启 router 才能完全生效。正确配置端口转发可以显著提升你的 router 性能并帮助 I2P 网络。\n客户端配置 URL: 对等节点配置 Peer Configuration 页面提供了手动控制功能,用于管理 I2P 网络上的单个 peer。这是一个高级功能,通常仅用于排查有问题的 peer。\n手动对等节点控制：\n路由器哈希 (Router Hash) - 输入您想要管理的对等节点的44字符base64路由器哈希值 手动封禁 / 解除封禁一个 Peer:\n封禁节点会阻止其参与您创建的任何隧道。此操作：- 阻止该节点被用于您的客户端或探索性隧道 - 立即生效，无需重启 - 持续有效，直到您手动解除封禁或重启 router - 封禁节点直到重启 - 临时封禁该节点 - 解除封禁节点 - 移除对先前被封禁节点的封禁\n调整配置文件奖励：\nProfile bonuses 影响 peer 被选择参与 tunnel 的方式。Bonuses 可以是正数或负数：- 快速 peers - 用于需要高速度的客户端 tunnels - 高容量 peers - 用于一些需要可靠路由的探索性 tunnels - 当前 bonuses 显示在 profiles 页面\n配置： - 速度 - 调整此对等节点的速度加成（0 = 中性） - 容量 - 调整此对等节点的容量加成（0 = 中性） - 调整对等节点加成 - 应用加成设置\n使用场景： - 封禁持续导致连接问题的节点 - 临时排除你怀疑存在恶意的节点 - 调整加成值以降低表现不佳节点的优先级 - 通过排除特定节点来调试隧道构建问题\n注意： 大多数用户永远不需要使用此功能。I2P router 会根据性能指标自动管理节点选择和性能分析。\nI2CP 配置 URL: Reseed 配置 Reseed 配置页面允许您在自动重新播种失败时手动为路由器重新播种。重新播种是一个引导过程,用于在您首次安装 I2P 时或当您的 router 剩余的 router 引用过少时查找其他 router。\n何时使用手动重新种子（Reseed）：\n如果重新播种失败，您应该首先检查您的网络连接\n如果防火墙阻止了您连接到重新播种主机，您可以尝试使用代理：\n代理可以是远程公共代理，也可以运行在您的计算机上（localhost） 要使用代理，请在重新播种配置部分配置类型、主机和端口 如果您正在运行 Tor Browser，请通过配置 SOCKS 5、localhost、端口 9150 来通过它进行重新播种 如果您正在运行命令行 Tor，请通过配置 SOCKS 5、localhost、端口 9050 来通过它进行重新播种 如果您已有一些节点但需要更多，可以尝试 I2P Outproxy 选项。将主机和端口留空。这不适用于您完全没有节点时的初始重新播种 然后，点击\u0026quot;保存更改并立即重新播种\u0026quot; 默认设置适用于大多数用户。仅在 HTTPS 被限制性防火墙阻止且重新播种失败时才更改这些设置 如果你认识并信任某个运行 I2P 的人，请让他们使用其路由器控制台上的此页面生成一个 reseed 文件并发送给你。然后，使用此页面通过你收到的文件进行 reseed。首先，在下方选择文件。然后，点击\u0026quot;从文件 Reseed\u0026quot;\n如果你认识并信任某个发布 reseed 文件的人,向他们索要 URL。然后,使用此页面通过你收到的 URL 进行 reseed。首先,在下方输入 URL。然后,点击\u0026quot;从 URL 进行 Reseed\u0026quot;\n查看 FAQ 了解手动重新播种的说明\n手动 Reseed 选项：\n从 URL 重新播种 - 输入来自可信来源的 zip 或 su3 URL，然后点击\u0026quot;从 URL 重新播种\u0026quot;\n推荐使用 su3 格式，因为它会被验证为由可信来源签名 zip 格式未签名；仅使用来自您信任的来源的 zip 文件 从文件重新播种 - 浏览并选择本地 zip 或 su3 文件,然后点击\u0026quot;从文件重新播种\u0026quot;\n你可以在 checki2p.com/reseed 找到重新播种文件 创建重新播种文件 - 生成一个新的重新播种 zip 文件，您可以分享给他人用于手动重新播种\n此文件永远不会包含您自己路由器的身份或 IP Reseeding 配置：\n默认设置适用于大多数用户。仅当 HTTPS 被限制性防火墙阻止且 reseed 失败时才需要更改这些设置。\nReseed URLs - Reseed 服务器的 HTTPS URL 列表(默认列表为内置且定期更新) Proxy Configuration - 如果需要通过代理访问 reseed 服务器,可配置 HTTP/HTTPS/SOCKS 代理 Reset URL list - 恢复默认 reseed 服务器列表 **重要提示：**手动重新播种(reseeding)仅在自动重新播种反复失败的罕见情况下才有必要。大多数用户永远不需要使用此页面。\n网络配置 URL: 路由器家族配置 Router Family 配置页面允许你管理 router family。同一 family 中的 router 共享一个 family key,用于标识它们由同一个人或组织运营。这可以防止你控制的多个 router 被选入同一条 tunnel,从而避免降低匿名性。\n什么是路由器家族(Router Family)?\n当您运行多个 I2P router 时，应该将它们配置为同一个家族的一部分。这样可以确保：\n您的 router 不会被同时用于同一条 tunnel 路径中 当其他用户的 tunnel 使用您的 router 时，他们能保持适当的匿名性 网络可以正确分配 tunnel 参与度 当前家族：\n该页面显示您当前的路由器家族名称。如果您不属于任何家族,此处将为空。\n导出家族密钥：\n导出密钥家族密钥以导入到您控制的其他路由器中 点击\u0026quot;导出家族密钥\u0026quot;下载您的家族密钥文件 在您的其他 router 上导入此密钥,将它们添加到同一家族 离开路由器家族：\n不再是家族成员 点击\u0026quot;离开家族\u0026quot;将此路由器从当前家族中移除 此操作无法撤销，除非重新导入家族密钥 重要注意事项：\n需要公开注册： 为了让你的family在整个网络中被识别，你的family密钥必须由开发团队添加到I2P代码库中。这可以确保网络上的所有router都知道你的family。 联系I2P团队 注册你的family密钥（如果你运营多个公共router） 大多数只运行一个router的用户永远不需要使用此功能 Family配置主要供运营多个公共router的运营商或基础设施提供商使用 使用场景：\n运行多个 I2P 路由器以实现冗余 在多台机器上运行基础设施,如重新种子服务器或出口代理 为组织管理 I2P 路由器网络 节点配置 URL: Tunnel 配置 Tunnel Configuration 页面允许您调整探索性隧道(用于路由器通信)和客户端隧道(用于应用程序)的默认隧道设置。默认设置适用于大多数人,只有在您了解权衡取舍的情况下才应更改。\n重要警告：\n⚠️ 匿名性与性能权衡: 匿名性和性能之间存在根本性的权衡。超过3跳的tunnel(例如2跳 + 0-2跳、3跳 + 0-1跳、3跳 + 0-2跳),或者过高的数量+备份数量,可能会严重降低性能或可靠性。可能导致高CPU占用和/或高出站带宽使用。请谨慎修改这些设置,如果遇到问题请进行调整。\n⚠️ 持久性： 探索性 tunnel 设置更改会存储在 router.config 文件中。客户端 tunnel 更改是临时的，不会被保存。要进行永久性的客户端 tunnel 更改，请参阅 I2PTunnel 页面 。\n探索性隧道 (Exploratory Tunnels):\n探索隧道(Exploratory tunnels)用于您的路由器与网络数据库(netDb)通信并参与 I2P 网络。\n入站和出站的配置选项：- Length（长度） - tunnel 中的跳数（默认值：2-3 跳）- Randomization（随机化） - tunnel 长度的随机变化范围（默认值：0-1 跳）- Quantity（数量） - 活动 tunnel 的数量（默认值：2 个 tunnel）- Backup quantity（备用数量） - 准备激活的备用 tunnel 数量（默认值：0 个 tunnel）\nI2P Web 服务器的客户端隧道：\n这些设置控制内置 I2P 网络服务器(eepsite)的隧道。\n⚠️ 匿名性警告 - 设置包含 1-hop tunnel。⚠️ 性能警告 - 设置包含大量 tunnel。\n入站和出站的配置选项：- Length - Tunnel 长度（默认：webserver 为 1 跳）- Randomization - Tunnel 长度的随机变化 - Quantity - 活动 tunnel 数量 - Backup quantity - 备用 tunnel 数量\n用于共享客户端的客户端 Tunnel:\n这些设置适用于共享客户端应用程序(HTTP 代理、IRC 等)。\n入站和出站的配置选项：- Length - 隧道长度（默认：3 跳）- Randomization - 隧道长度的随机变化 - Quantity - 活跃隧道数量 - Backup quantity - 备用隧道数量\n理解隧道参数：\n长度： 隧道越长提供的匿名性越高，但会降低性能和可靠性 随机化： 为隧道路径增加不可预测性，提高安全性 数量： 更多隧道可以提高可靠性和负载分配，但会增加资源使用 备用数量： 预先构建的隧道用于替换失效隧道，提高弹性 最佳实践：\n除非有特定需求，否则保持默认设置 仅在匿名性至关重要且可以接受较慢性能时增加 tunnel 长度 仅在频繁遇到 tunnel 故障时增加数量/备份 更改后监控 router 性能 点击\u0026quot;保存更改\u0026quot;以应用修改 Reseed 配置 URL: UI 配置 UI 配置页面允许你自定义路由器控制台的外观和可访问性,包括主题选择、语言偏好和密码保护。\n路由器控制台主题:\n为路由器控制台界面选择深色或浅色主题:\n深色 - 深色模式主题(在弱光环境中更护眼) 浅色 - 浅色模式主题(传统外观) 附加主题选项：- 在所有应用中统一设置主题 - 将所选主题应用于所有 I2P 应用程序，而不仅仅是路由器控制台 - 强制使用移动端控制台 - 即使在桌面浏览器上也使用移动优化界面 - 在控制台中嵌入邮件和种子应用程序 - 将 Susimail 和 I2PSnark 直接集成到控制台界面中，而不是在单独的标签页中打开它们\n路由器控制台语言:\n从下拉菜单中选择路由器控制台界面的首选语言。I2P 支持多种语言,包括英语、德语、法语、西班牙语、俄语、中文、日语等。\n欢迎贡献翻译： 如果您发现翻译不完整或不正确，您可以通过为翻译项目做贡献来帮助改进 I2P。请通过 IRC 上的 #i2p-dev 联系开发者，或查看翻译状态报告（页面上有链接）。\n路由器控制台密码：\n添加用户名和密码认证以保护对你的 router 控制台的访问:\n用户名 - 输入用于访问控制台的用户名 密码 - 输入用于访问控制台的密码 添加用户 - 使用指定的凭据创建新用户 删除所选 - 删除现有用户账户 为什么要添加密码?\n防止未经授权的本地访问您的路由器控制台 如果多人使用您的计算机则必不可少 如果您的路由器控制台可在本地网络上访问则建议启用 保护您的 I2P 配置和隐私设置免遭篡改 安全说明： 密码保护仅影响对 I2P Router Console 路由器控制台网页界面的访问。它不会加密 I2P 流量或阻止应用程序使用 I2P。如果您是计算机的唯一用户,并且 router console 仅监听 localhost(默认设置),则可能不需要设置密码。\n路由器家族配置 URL: WebApp 配置 WebApp 配置页面允许您管理在 I2P router 中运行的 Java Web 应用程序。这些应用程序由 webConsole 客户端启动，并在与 router 相同的 JVM 中运行，提供可通过 router 控制台访问的集成功能。\n什么是 WebApps?\nWebApps 是基于 Java 的应用程序，可以是：- 完整的应用程序（例如用于种子下载的 I2PSnark）- 其他客户端的前端，需要单独启用（例如 Susidns、I2PTunnel）- 没有 Web 界面的 Web 应用程序（例如地址簿）\n重要说明：\n一个 webapp 可能会被完全禁用,或者只是被禁止在启动时运行 从 webapps 目录中删除 war 文件将完全禁用该 webapp 但是,当你将路由器更新到新版本时,.war 文件和 webapp 目录将会重新出现 **永久禁用 webapp:**在此处禁用,这是首选方法 可用的 WebApps:\nWebApp Description i2psnark Torrents - Built-in BitTorrent client for I2P i2ptunnel Hidden Services Manager - Configure client and server tunnels imagegen Identification Image Generator - Creates unique identicons jsonrpc jsonrpc.war - JSON-RPC API interface (disabled by default) routerconsole I2P Router Console - The main administrative interface susidns Address Book - Manage I2P addresses and subscriptions susimail Email - Web-based email client for I2P 控制： 对于每个网页应用程序: - 启动时运行? - 复选框以启用/禁用自动启动 - 控制 - 用于即时控制的启动/停止按钮 - 停止 - 停止当前运行的网页应用程序 - 启动 - 启动已停止的网页应用程序\n配置按钮：\n取消 - 放弃更改并返回上一页 保存 WebApp 配置 - 保存您的更改并应用 使用场景：\n如果不使用种子文件，停止 I2PSnark 以节省资源 如果不需要 API 访问，禁用 jsonrpc 如果使用外部邮件客户端，停止 Susimail 临时停止 webapps 以释放内存或排查问题 性能提示： 禁用未使用的 web 应用程序可以减少内存使用并提高 router 性能，特别是在低资源系统上。\nHelp URL: 帮助 帮助页面提供全面的文档和资源,帮助您有效地理解和使用 I2P。它作为故障排除、学习和获取支持的中心枢纽。\n您将在此找到：\n快速入门指南 - 为新用户提供开始使用 I2P 的基本信息 常见问题解答 (FAQ) - 关于 I2P 安装、配置和使用的常见问题解答 故障排除 - 常见问题和连接问题的解决方案 技术文档 - 关于 I2P 协议、架构和规范的详细信息 应用程序指南 - 使用 I2P 应用程序(如种子下载、电子邮件和隐藏服务)的说明 网络信息 - 了解 I2P 的工作原理及其安全性 支持资源 - 论坛、IRC 频道和社区支持的链接 获取帮助：\n如果您在使用 I2P 时遇到问题: 1. 查看 FAQ 了解常见问题和解答 2. 查阅故障排除部分寻找您的具体问题 3. 访问 I2P 论坛 i2pforum.i2p 或 i2pforum.net 4. 加入 IRC 频道 #i2p 获取实时社区支持 5. 搜索文档获取详细的技术信息\n**提示：**帮助页面始终可以从路由器控制台侧边栏访问，使您能够随时轻松找到帮助信息。\nPerformance Graphs URL: 性能图表 性能图表页面提供了对您的 I2P router 性能和网络活动的实时可视化监控。这些图表帮助您了解带宽使用情况、对等连接、内存消耗以及整体 router 健康状况。\n可用图表：\n带宽使用情况\n底层发送速率 (字节/秒) - 出站流量速率 底层接收速率 (字节/秒) - 入站流量速率 显示当前、平均和最大带宽利用率 帮助监控是否接近配置的带宽限制 活动节点\nrouter.activePeers averaged for 60 sec - 你正在主动通信的节点数量 显示你的网络连接健康状况 更多的活动节点通常意味着更好的 tunnel 构建和网络参与度 路由器内存使用情况\nrouter.memoryUsed averaged for 60 sec - JVM 内存消耗 显示当前、平均和最大内存使用量(单位:MB) 用于识别内存泄漏或判断是否需要增加 Java 堆大小 配置图表显示：\n自定义图表的显示和刷新方式:\n图表大小 - 设置宽度(默认:400 像素)和高度(默认:100 像素) 显示周期 - 显示的时间范围(默认:60 分钟) 刷新延迟 - 图表更新频率(默认:5 分钟) 绘图类型 - 在平均值或事件显示之间选择 隐藏图例 - 从图表中移除图例以节省空间 UTC - 在图表上使用 UTC 时间而非本地时间 持久化 - 将图表数据存储到磁盘以供历史分析 高级选项：\n点击 [Select Stats] 选择要绘制图表的统计信息：- Tunnel 指标（构建成功率、tunnel 数量等）- 网络数据库统计 - 传输统计（NTCP2、SSU2）- 客户端 tunnel 性能 - 以及更多详细指标\n使用场景：\n监控带宽以确保不超过配置的限制 在排查网络问题时验证对等节点连接性 跟踪内存使用情况以优化 Java 堆设置 识别随时间变化的性能模式 通过关联图表诊断 tunnel 建立问题 提示： 在进行更改后点击\u0026quot;Save settings and redraw graphs\u0026quot;以应用您的配置。图表将根据您的刷新延迟设置自动刷新。\n","description":"全面指南：理解和配置 I2P Router Console","id":"c46f1b6edeab9b686fd57cf9b311df1c","section":"docs","title":"路由器控制台配置指南","url":"/zh/docs/guides/router-console-config/"},{"categories":null,"content":" 背景： 本页汇集并存档了 I2P 早期设计阶段的长期争论。它解释了为何该项目更倾向于使用本地信任的地址簿，而不是采用类 DNS 的查询或多数投票式注册表。关于当前的使用指导，请参见命名文档 。\n已放弃的备选方案 I2P 的安全目标排除了常见的命名方案：\nDNS 风格解析。 在查询路径上的任何解析器都可能伪造或审查应答。即便有 DNSSEC（DNS 安全扩展），被攻陷的注册商或证书颁发机构（CA）仍然是单点故障。在 I2P 中，destinations（目标标识）就是公钥—劫持一次查询就会彻底攻陷一个身份。 基于投票的命名。 对手可以批量创建无限数量的身份（女巫攻击 Sybil attack），并让热门名称在投票中“胜出”。基于工作量证明（Proof-of-Work，PoW）的缓解措施会抬高成本，但会引入沉重的协调开销。 相反，I2P 刻意将命名维持在传输层之上。捆绑的命名库提供了一个服务提供者接口（SPI），从而允许替代方案并存——由用户决定他们信任哪些地址簿或跳转服务。\n本地与全局名称 (jrandom, 2005) I2P 中的名称是在本地唯一且便于人类阅读。你的 boss.i2p 可能与他人的 boss.i2p 不一致，这是设计使然。 如果恶意行为者诱骗你更改某个名称背后对应的 Destination（I2P 中服务的公钥标识），他们就能实质上劫持该服务。拒绝全局唯一性可以防止这类攻击。 将名称视为书签或即时通讯昵称——你可以通过订阅特定地址簿或手动添加密钥，来选择你信任的 Destination。 常见异议与回应 (zzz) Concern Response “Downloading hosts.txt is inefficient.” At ~400\u0026nbsp;KB for ~800 hosts the bandwidth impact is minor (~10\u0026nbsp;B/s if refreshed twice daily). ETags already avoid unnecessary transfers. Alternate formats (for example recenthosts.cgi) can deliver only new entries. “It won’t scale.” A hosts.txt entry is ~500\u0026nbsp;bytes; storing thousands locally is practical. Real-time lookups would dramatically slow browsing. “Requires trust and manual setup.” True—and intentional. Users must choose address book providers they trust. Trust is not binary; forcing configuration encourages users to think about it. “Why not just use DNS?” DNS depends on short TTLs and can be hijacked mid-path. I2P destinations are immutable public keys, so DNS semantics map poorly. “Subscriptions rely on specific servers.” Subscriptions are decentralised—you can add multiple providers or run your own. Completely decentralised systems struggle with conflict resolution and hijacking. “Jump services and hosts.txt feel awkward.” They are pragmatic trade-offs. Jump services provide just-in-time lookups; subscriptions keep a local cache for performance. ## 已讨论的效率改进思路 提供增量更新（仅包含自上次获取后新增的目标地址）。 在完整的 hosts 文件之外提供补充源（recenthosts.cgi）。 探索可脚本化的工具（例如 i2host.i2p），用于合并源或按信任级别过滤。 要点 安全性优先于全局共识：本地维护的地址簿可最大限度降低劫持风险。 通过命名 API，多种命名方式可以并存——由用户决定信任什么。 完全去中心化的全局命名仍然是一个未解决的研究问题；在安全性、人类可记忆性与全局唯一性之间的权衡，仍然反映了 Zooko’s triangle（Zooko 三角） 。 参考资料 命名文档 Zooko 的《名称：去中心化、安全、人类可读：三者取其二》 示例增量订阅源：stats.i2p/cgi-bin/newhosts.txt ","description":"关于 I2P 命名模型的历史性争论，以及为何拒绝了类 DNS 的全局方案","id":"952b10ba82200ff92e5ddeed512d6afb","section":"docs","title":"命名讨论","url":"/zh/docs/legacy/naming/"},{"categories":null,"content":"I2P 地址是长的加密密钥。命名系统在这些密钥之上提供了一个更友好的层，而不引入中央权威机构。所有名称都是本地的——每个 router 独立决定主机名指向哪个目的地。\n需要背景知识？ 命名讨论 文档记录了原始设计辩论、替代方案以及 I2P 去中心化命名背后的哲学基础。\n1. 组件 I2P 的命名层由几个独立但相互协作的子系统组成：\n命名服务 – 将主机名解析为 destination，并处理 Base32 主机名 。 HTTP 代理 – 将 .i2p 查询传递给 router，并在名称未知时建议跳转服务。 主机添加服务 – 以 CGI 样式表单将新条目追加到本地地址簿中。 跳转服务 – 远程辅助工具，为提供的主机名返回 destination。 地址簿 – 使用本地信任的\u0026quot;信任网络\u0026quot;定期获取并合并远程主机列表。 SusiDNS – 基于网页的用户界面，用于管理地址簿、订阅和本地覆盖设置。 这种模块化设计让用户可以定义自己的信任边界，并根据自己的偏好自动化命名过程的多少部分。\n2. 命名服务 router的命名API（net.i2p.client.naming）通过可配置属性i2p.naming.impl=\u0026lt;class\u0026gt;支持多个后端。每个实现可能提供不同的查找策略，但都共享相同的信任和解析模型。\n2.1 Hosts.txt (legacy format) 传统模式使用三个按顺序检查的纯文本文件：\nprivatehosts.txt userhosts.txt hosts.txt 每一行存储一个 hostname=base64-destination 映射。这种简单的文本格式仍然完全支持导入/导出,但由于在主机列表超过几千个条目后性能较差,它不再是默认格式。\n2.2 Blockfile Naming Service (default backend) 在 0.8.8 版本中引入的 Blockfile 命名服务现在是默认后端。它用基于跳表(skiplist)的高性能磁盘键值存储(hostsdb.blockfile)替代了平面文件,实现了大约 10 倍的查找速度提升。\n主要特点： - 在一个二进制数据库中存储多个逻辑地址簿（私有、用户和hosts）。- 保持与传统hosts.txt导入/导出的兼容性。- 支持反向查找、元数据（添加日期、来源、注释）和高效缓存。- 使用相同的三层搜索顺序：私有 → 用户 → hosts。\n这种方法在保持向后兼容性的同时,显著提高了解析速度和可扩展性。\n2.1 Hosts.txt（传统格式） 开发者可以实现自定义后端，例如：- Meta – 聚合多个命名系统。- PetName – 支持存储在 petnames.txt 中的 petname（个人名称）。- AddressDB、Exec、Eepget 和 Dummy – 用于外部或后备解析。\nblockfile 实现仍然是通用场景下推荐的后端，因为其性能和可靠性表现出色。\n3. Base32 Hostnames Base32 主机名（*.b32.i2p）的功能类似于 Tor 的 .onion 地址。当你访问一个 .b32.i2p 地址时：\nrouter 解码 Base32 载荷。 它直接从密钥重建目标地址——无需地址簿查找。 这保证了即使不存在可读性好的主机名，仍然可以访问。在0.9.40 版本中引入的扩展 Base32 名称支持 LeaseSet2 和加密目的地。\n4. Address Book \u0026amp; Subscriptions 地址簿应用程序通过 HTTP 获取远程主机列表,并根据用户配置的信任规则在本地合并它们。\n2.2 Blockfile 命名服务（默认后端） 订阅是指向 hosts.txt 或增量更新源的标准 .i2p URL。 更新会定期获取(默认每小时一次)并在合并前进行验证。 冲突按照先到先得原则解决,遵循以下优先级顺序:\nprivatehosts.txt → userhosts.txt → hosts.txt。 Default Providers 自 I2P 2.3.0 (2023年6月) 起,包含两个默认的订阅提供者: - http://i2p-projekt.i2p/hosts.txt - http://notbob.i2p/hosts.txt\n这种冗余提高了可靠性,同时保留了本地信任模型。用户可以通过 SusiDNS 添加或删除订阅。\nIncremental Updates 增量更新通过 newhosts.txt 获取(取代了旧的 recenthosts.cgi 概念)。此端点提供高效的基于 ETag 的增量更新——仅返回自上次请求以来的新条目,或在未更改时返回 304 Not Modified。\n2.3 替代后端和插件 Host-add services（add*.cgi）允许手动提交名称到目标地址的映射。在接受之前始终验证目标地址。 Jump services 使用适当的密钥响应，并可以通过 HTTP 代理使用 ?i2paddresshelper= 参数进行重定向。 常见示例：stats.i2p、identiguy.i2p 和 notbob.i2p。 这些服务不是可信权威机构——用户必须自行决定使用哪个服务。 5. Managing Entries Locally (SusiDNS) SusiDNS 可在以下地址访问：http://127.0.0.1:7657/susidns/\n您可以：- 查看和编辑本地地址簿。- 管理和设置订阅优先级。- 导入/导出主机列表。- 配置获取计划。\nI2P 2.8.1 新增功能（2025年3月）： - 添加了\u0026quot;按最新排序\u0026quot;功能。 - 改进了订阅处理（修复了 ETag 不一致问题）。\n所有更改都保持本地——每个 router 的地址簿都是唯一的。\n3. Base32 主机名 根据 RFC 9476，I2P 已于 2025 年 3 月（I2P 2.8.1） 向 GNUnet 编号分配机构（GANA）注册了 .i2p.alt。\n目的： 防止配置错误的软件意外泄露 DNS 信息。\n符合 RFC 9476 标准的 DNS 解析器不会转发 .alt 域名到公共 DNS。 I2P 软件将 .i2p.alt 视为等同于 .i2p,在解析过程中会去除 .alt 后缀。 .i2p.alt 并非旨在取代 .i2p;它是一种技术保障措施,而非品牌重塑。 4. 地址簿与订阅 Destination 密钥： 516–616 字节（Base64） 主机名： 最多 67 个字符（包括 .i2p） 允许的字符： a–z、0–9、-、.（不允许连续两个点，不允许大写字母） 保留： *.b32.i2p ETag 和 Last-Modified： 积极使用以最小化带宽消耗 平均 hosts.txt 大小： 约 800 个主机占用约 400 KB（示例数据） 带宽使用： 如果每 12 小时获取一次，约 10 字节/秒 8. Security Model and Philosophy I2P 有意牺牲全局唯一性以换取去中心化和安全性——这是 Zooko\u0026rsquo;s Triangle（佐科三角） 的直接应用。\n核心原则： - 无中心化权威： 所有查询都在本地进行。 - 抵御 DNS 劫持： 查询使用目标公钥加密。 - 防止女巫攻击： 无投票或基于共识的命名机制。 - 不可变映射： 一旦本地关联建立，就无法被远程覆盖。\n基于区块链的命名系统（例如 Namecoin、ENS）已经探索过解决佐科三角的全部三个方面，但 I2P 有意避免使用它们，原因是延迟、复杂性以及与其本地信任模型在理念上不兼容。\n9. Compatibility and Stability 在 2023–2025 年间，没有任何命名功能被弃用。 Hosts.txt 格式、跳转服务、订阅以及所有命名 API 实现均保持功能正常。 I2P 项目在引入性能和安全改进（NetDB 隔离、Sub-DB 分离等）的同时，严格保持向后兼容性。 10. Best Practices 仅保留可信的订阅源；避免使用大型、未知的主机列表。 在升级或重新安装之前备份 hostsdb.blockfile 和 privatehosts.txt。 定期检查跳转服务并禁用任何你不再信任的服务。 请记住：你的地址簿定义了你所看到的 I2P 世界——每个主机名都是本地的。 Further Reading 命名讨论 Blockfile 规范 配置文件格式 命名服务 Javadoc ","description":"I2P 如何将人类可读的主机名映射到目标地址","id":"fc2ecb5df890709d0740d866d03a6250","section":"docs","title":"命名与地址簿","url":"/zh/docs/overview/naming/"},{"categories":null,"content":"概述 router 会自动通过轮询在 I2P 网络中分发的已签名新闻源来检查更新。当有更高版本被公告时，router 会下载经密码学签名的更新归档（.su3），并将其暂存以待安装。 该系统确保官方发布的分发具有经认证、防篡改，以及多通道的特性。\n自 I2P 2.10.0 起，更新系统使用: - RSA-4096 / SHA-512 签名 - SU3 容器格式（取代旧版 SUD/SU2） - 冗余镜像： I2P 网络内的 HTTP、明网 HTTPS，以及 BitTorrent\n1. 新闻源 各个 router 每隔数小时轮询已签名的 Atom 提要，以发现新版本和安全公告。 该提要会被签名，并作为一个 .su3 文件分发，其中可能包含：\n\u0026lt;i2p:version\u0026gt; — 新版本号 \u0026lt;i2p:minVersion\u0026gt; — 最低支持的 router 版本 \u0026lt;i2p:minJavaVersion\u0026gt; — 所需的最低 Java 运行时 \u0026lt;i2p:update\u0026gt; — 列出多个下载镜像（I2P、HTTPS、torrent） \u0026lt;i2p:revocations\u0026gt; — 证书吊销数据 \u0026lt;i2p:blocklist\u0026gt; — 针对被攻陷节点的网络级封锁列表 订阅源分发 Channel Description Usage I2P HTTP (eepsite) Primary update source Private, resilient Clearnet HTTPS Fallback mirror Public fallback BitTorrent magnet Distributed channel Reduces mirror load Routers 首选 I2P 源，但在必要时可以回退到明网或 BitTorrent 分发。 2. 文件格式 SU3 (当前标准) 在 0.9.9 中引入的 SU3 已取代旧版的 SUD 和 SU2 格式。 每个文件包含一个文件头、负载和尾部签名。\n头部结构 \u0026lt;tr\u0026gt; \u0026lt;th style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem; text-align:left; background:var(--color-bg-secondary);\u0026quot;\u0026gt;Field\u0026lt;/th\u0026gt; \u0026lt;th style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem; text-align:left; background:var(--color-bg-secondary);\u0026quot;\u0026gt;Description\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Magic\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;\u0026lt;code\u0026gt;\u0026quot;I2Psu3\u0026quot;\u0026lt;/code\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Format Version\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;\u0026lt;code\u0026gt;0\u0026lt;/code\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Signature Type\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;e.g., \u0026lt;code\u0026gt;0x000B\u0026lt;/code\u0026gt; (RSA-SHA512-4096)\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Signature Length\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;\u0026lt;code\u0026gt;512 bytes\u0026lt;/code\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Version String\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Router version\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Signer ID\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Certificate name\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Content Type\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;1 = router update, 3 = reseed, 4 = news feed\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; 签名验证步骤 1. 解析头部并识别签名算法。 2. 使用已存储的签名者证书核验哈希与签名。 3. 确认签名者未被吊销。 4. 将嵌入的版本字符串与有效载荷元数据进行比对。\nRouters 随附受信任的签名者证书（目前为 zzz 和 str4d），并拒绝任何未签名或已吊销的来源。\nSU2（已废弃） .su2 扩展名用于 Pack200（Java 的 Pack200 压缩格式）压缩的 JAR 包。 在 Java 14 将 Pack200（JEP 367）标记为弃用后被移除。 在 I2P 0.9.48+ 中已禁用；现已完全由 ZIP 压缩取代。 SUD (旧版) 早期的 DSA-SHA1 签名 ZIP 格式（0.9.9 之前）。 无签名者 ID 或头部，完整性保障有限。 由于加密强度较弱且缺乏版本强制机制而被取代。 3. 更新流程 3.1 头部验证 router 仅获取 SU3 header（SU3 文件头），在下载完整文件之前用于验证版本字符串。 这可避免在过期的镜像或过时的版本上浪费带宽。\n3.2 完整下载 在验证头部之后，router 会从以下来源下载完整的 .su3 文件： - 网络内 eepsite 镜像 (优先) - HTTPS 明网镜像 (备用) - BitTorrent (可选的对等协助分发)\n下载使用标准的 I2PTunnel HTTP 客户端，具备重试、超时处理和镜像回退功能。\n3.3 签名验证 每个下载的文件都会经过： - 签名检查： RSA-4096/SHA512 验证 - 版本匹配： 头部与有效载荷版本对比检查 - 防降级： 确保更新版本高于已安装版本\n无效或不匹配的文件会被立即丢弃。\n3.4 安装阶段 验证完成后： 1. 将 ZIP 压缩包内容解压到临时目录 2. 删除 deletelist.txt 中列出的文件 3. 如果包含 lib/jbigi.jar，则替换原生库 4. 将签名者证书复制到 ~/.i2p/certificates/ 5. 将更新移动到 i2pupdate.zip，以便在下次重启时应用\n更新将在下次启动时自动安装，或在手动触发“立即安装更新”时安装。\n4. 文件管理 deletelist.txt 一份纯文本列表，列出在解包新内容之前应删除的过时文件。\n规则： - 每行一个路径（仅限相对路径） - 以 # 开头的行将被忽略 - 拒绝 .. 和绝对路径\n本地库 为防止陈旧或不匹配的原生二进制文件： - 如果 lib/jbigi.jar 存在，将删除旧的 .so 或 .dll 文件 - 确保平台特定的库被重新提取\n5. 证书管理 router 可以通过更新或新闻源中的撤销通知接收新的签名者证书。\n新的 .crt 文件会被复制到证书目录。 在后续验证之前，会删除已吊销的证书。 支持密钥轮换，无需用户手动干预。 所有更新均使用air-gapped（物理隔离）签名系统进行离线签名。 私钥绝不会存储在构建服务器上。\n6. 开发者指南 Topic Details Signing Use RSA-4096 (SHA-512) via apps/jetty/news SU3 tooling. Mirror Policy I2P eepsite preferred, clearnet HTTPS fallback, torrent optional. Testing Validate updates from prior releases, across all OS platforms. Version Enforcement minVersion prevents incompatible upgrades. Certificate Rotation Distribute new certs in updates and revocation lists. 未来的版本将探索后量子签名的集成（参见 Proposal 169）以及可复现构建。 7. 安全概述 Threat Mitigation Tampering Cryptographic signature (RSA-4096/SHA512) Key Compromise Feed-based certificate revocation Downgrade Attack Version comparison enforcement Mirror Hijack Signature verification, multiple mirrors DoS Fallback to alternate mirrors/torrents MITM HTTPS transport + signature-level integrity --- 8. 版本管理 Router: 2.10.0 (API 0.9.67) 采用 Major.Minor.Patch 的语义化版本控制。 最小版本强制机制可防止不安全的升级。 支持的 Java: Java 8–17。未来的 2.11.0+ 将要求 Java 17+。 ","description":"面向 I2P router 的安全签名更新机制与更新源结构","id":"aea843f73d809c9546b3d675324af161","section":"docs","title":"软件更新规范","url":"/zh/docs/specs/updates/"},{"categories":null,"content":"本词汇表定义了 I2P 文档和讨论中使用的常见术语。\nB Blockchain 一种分布式账本,能够高效、可验证且永久地记录多方之间的交易。\nD 去中心化 避免依赖单一方的网络架构。包括点对点、区块链、联邦式和分布式技术。\nDestination 隧道的密码学身份。这些是 I2P 网络中客户端和服务器的身份。\nDHT (Distributed Hash Table) 在某些项目中用于通过以分布式方式存储键值对形式的信息来连接对等节点。\n分布式系统（Distributed Systems） 计算机科学中的学术主题，研究由通过网络连接的众多独立计算机组成的计算机系统的设计。\nF 联邦式 联邦式架构允许服务的独立部署通过通用协议相互通信。\nH Hash（哈希） 一个数字，通常显示为字母和数字组成的字符串。它可以作为唯一标识数据的\u0026quot;指纹\u0026quot;。\nI I2P Invisible Internet Project(隐形网计划):一个旨在提供匿名层的项目,使用户能够使用各种应用程序进行匿名通信。\nIP Address (IP地址) 计算机或网络的唯一编号,可用于对其进行寻址。\nL LeaseSet 与特定目的地(Destination)的客户端或服务器进行通信所需的信息集合。\nP Peer-to-Peer (P2P) 对等节点将其部分资源直接提供给其他网络参与者,无需通过服务器或稳定主机进行中央协调。\nR Router 核心 I2P 软件,用于在 I2P 网络上路由加密数据包。\nRouterIdentity 与路由器直接通信所需的信息集合。\nT TCP/UDP 互联网上使用的两种基础传输协议。\nTunnel（隧道） 客户端或服务器与 I2P 网络之间的匿名通信路径。\nU UX 用户体验（User Experience），指用户使用产品或服务的整体体验。\nW WebRTC 一种协议标准,用于在网页浏览器中建立连接,使数据能够在用户之间直接传递。\n","description":"I2P 文档中使用的常见术语和定义","id":"2235ec8f316773700ef08dd43b19a1c0","section":"docs","title":"术语表","url":"/zh/docs/overview/%E6%9C%AF%E8%AF%AD%E8%A1%A8/"},{"categories":null,"content":"概述 数据报在 I2CP 之上提供面向消息的通信，与流式库并行。它们支持可回复的、经过身份验证的或原始数据包，而无需面向连接的流。router 将数据报封装到 I2NP 消息和 tunnel 消息中，无论是 NTCP2 还是 SSU2 承载流量。\n核心动机是允许应用程序（如tracker、DNS解析器或游戏）发送能够标识发送者的自包含数据包。\n2025年新增： I2P项目批准了Datagram2（协议19）和Datagram3（协议20），这是十年来首次增加重放保护和更低开销的可回复消息传递功能。\n1. 协议常量 Protocol Value Description Introduced PROTO_DATAGRAM 17 Signed (repliable) datagram – “Datagram1” Original PROTO_DATAGRAM_RAW 18 Unsigned (raw) datagram – no sender info Original PROTO_DATAGRAM2 19 Signed + replay-protected datagram API 0.9.66 (2025) PROTO_DATAGRAM3 20 Repliable (no signature, hash only) API 0.9.66 (2025) 协议 19 和 20 在 **提案 163（2025 年 4 月）** 中正式确定。它们与 Datagram1 / RAW 共存以保持向后兼容性。 2. 数据报类型 Type Protocol Repliable Authenticated Replay Protection Min Overhead Notes Raw 18 No No No 0 Minimal size; spoofable. Datagram1 17 Yes Yes No ≈ 427 Full Destination + signature. Datagram2 19 Yes Yes Yes ≈ 457 Replay prevention + offline signatures; PQ-ready. Datagram3 20 Yes No No ≈ 34 Sender hash only; low overhead. ### 典型设计模式 请求 → 响应： 发送一个签名的 Datagram2（请求 + nonce），接收一个原始或 Datagram3 回复（回显 nonce）。 高频率/低开销： 优先使用 Datagram3 或 RAW。 经过身份验证的控制消息： Datagram2。 传统兼容性： Datagram1 仍然完全支持。 3. Datagram2 和 Datagram3 详细信息（2025） Datagram2（协议 19） Datagram1 的增强替代版本。特性：- 防重放： 4 字节防重放令牌。 - 离线签名支持： 支持离线签名的 Destination 使用。 - 扩展签名覆盖范围： 包括目标哈希、标志、选项、离线签名块、有效载荷。 - 后量子就绪： 兼容未来的 ML-KEM 混合方案。 - 开销： ≈ 457 字节（X25519 密钥）。\nDatagram3（协议 20） 弥合原始类型和签名类型之间的差距。特性：- **可在无签名情况下回复：**包含发送者的 32 字节哈希 + 2 字节标志。- **极小开销：**约 34 字节。- 无重放防御 — 应用程序必须自行实现。\n这两种协议都是 API 0.9.66 的特性，自 2.9.0 版本起在 Java router 中实现；目前尚无 i2pd 或 Go 实现（截至 2025 年 10 月）。\n4. 大小和分片限制 Tunnel 消息大小： 1 028 字节（4 B Tunnel ID + 16 B IV + 1 008 B 有效载荷）。 初始分片： 956 B（典型的 TUNNEL 传输）。 后续分片： 996 B。 最大分片数： 63–64。 实际限制： ≈ 62 708 B（约 61 KB）。 推荐限制： ≤ 10 KB 以确保可靠传输（超过此限制丢包率呈指数增长）。 开销总结： - 数据报1 ≈ 427 B（最小）。- 数据报2 ≈ 457 B。- 数据报3 ≈ 34 B。- 附加层（I2CP gzip 头、I2NP、Garlic、Tunnel）：最坏情况下约 +5.5 KB。\n5. I2CP / I2NP 集成 消息路径：1. 应用程序创建数据报（通过 I2P API 或 SAM）。2. I2CP 使用 gzip 头部（0x1F 0x8B 0x08，RFC 1952）和 CRC-32 校验和进行封装。3. 协议 + 端口号存储在 gzip 头部字段中。4. Router 封装为 I2NP 消息 → Garlic clove → 1 KB tunnel 片段。5. 片段穿越 outbound → 网络 → inbound tunnel。6. 重组后的数据报根据协议号传递给应用程序处理器。\n完整性： CRC-32（来自 I2CP）+ 可选的加密签名（Datagram1/2）。数据报本身内部没有单独的校验和字段。\n6. 编程接口 Java API 包 net.i2p.client.datagram 包含：- I2PDatagramMaker – 构建签名数据报。 - I2PDatagramDissector – 验证并提取发送者信息。 - I2PInvalidDatagramException – 验证失败时抛出。\nI2PSessionMuxedImpl (net.i2p.client.impl.I2PSessionMuxedImpl) 为共享一个 Destination 的应用程序管理协议和端口复用。\nJavadoc 访问： - idk.i2p Javadoc （仅限 I2P 网络） - Javadoc 镜像 （明网镜像） - 官方 Javadocs （官方文档）\nSAM v3 支持 SAM 3.2 (2016): 添加了 PORT 和 PROTOCOL 参数。 SAM 3.3 (2016): 引入了 PRIMARY/subsession 模型；允许在一个 Destination 上同时使用流和数据报。 对 Datagram2 / 3 会话样式的支持已添加到 2025 年规范（实现待定）。 官方规范：SAM v3 规范 i2ptunnel 模块 udpTunnel： I2P UDP 应用的完全功能基础（net.i2p.i2ptunnel.udpTunnel）。 streamr： 可用于音视频流传输（net.i2p.i2ptunnel.streamr）。 SOCKS UDP： 截至 2.10.0 版本不可用（仅有 UDP 存根）。 对于通用 UDP，请使用 Datagram API 或直接使用 udpTunnel——不要依赖 SOCKS UDP。\n7. 生态系统和语言支持 (2025) Language Library / Package SAM Version Status Javacore API (net.i2p.client.datagram)3.3✓ full support C++i2pd / libsam33.2 partialLimited Gogo-i2p / sam33.1–3.2Active Pythoni2plib, i2p.socket, txi2p3.2Active Rusti2p-rs, i2p_client3.3Active C#I2PSharp3.3Active JS/TSnode-i2p, i2p-sam3.2Active Haskellnetwork-anonymous-i2p3.2Experimental Luamooni2p3.2Experimental Java I2P 是目前唯一支持完整 SAM 3.3 subsessions 和 Datagram2 API 的 router。 8. 示例用法 – UDP Tracker (I2PSnark 2.10.0) Datagram2/3 的首个实际应用：\nOperation Datagram Type Purpose Announce RequestDatagram3Repliable but low-overhead update ResponseRaw DatagramMinimal payload return 模式演示了如何混合使用经过身份验证的数据报和轻量级数据报，以平衡安全性和性能。 9. 安全性和最佳实践 对于任何需要身份验证的交换或当重放攻击很重要时，使用 Datagram2。 对于需要快速可回复响应且具有中等信任度的场景，优先使用 Datagram3。 对于公共广播或匿名数据，使用 RAW。 保持有效载荷 ≤ 10 KB 以确保可靠传输。 请注意 SOCKS UDP 仍然无法正常工作。 始终在接收时验证 gzip CRC 和数字签名。 10. 技术规范 本节介绍底层数据报格式、封装和协议细节。\n10.1 协议识别 数据报格式不共享通用头部。Router 无法仅从有效载荷字节推断类型。\n当混合使用多种数据报类型时——或者当将数据报与流式传输结合使用时——需要明确设置：- 协议号（通过 I2CP 或 SAM）- 可选的 端口号，如果您的应用程序需要复用多个服务\n不建议将协议保持未设置状态（0 或 PROTO_ANY），这可能会导致路由或传递错误。\n10.2 原始数据报 不可回复数据报不携带发送者或认证数据。它们是不透明的有效载荷,在更高级别的数据报 API 之外处理,但通过 SAM 和 I2PTunnel 提供支持。\n协议： 18 (PROTO_DATAGRAM_RAW)\n格式：\n+----+----+----+----+----// | payload... +----+----+----+----+----// 负载长度受传输限制约束（实际最大约 32 KB，通常远小于此值）。\n10.3 Datagram1（可回复数据报） 嵌入发送者的 Destination 和用于身份验证及回复寻址的 Signature。\n协议： 17 (PROTO_DATAGRAM)\n开销： ≥427 字节 有效载荷： 最多 ~31.5 KB（受传输层限制）\n格式：\n+----+----+----+----+----+----+----+----+ | from | + + | | ~ Destination bytes ~ | | +----+----+----+----+----+----+----+----+ | signature | + + | | +----+----+----+----+----+----+----+----+ | payload... +----+----+----+----// from: 一个 Destination (387+ 字节) signature: 与密钥类型匹配的签名 对于 DSA_SHA1: 对载荷的 SHA-256 哈希值的签名 对于其他密钥类型: 直接对载荷的签名 注意： - 非DSA类型的签名在I2P 0.9.14中标准化。- LS2（提案123）离线签名目前在Datagram1中不受支持。\n10.4 Datagram2 格式 一个改进的可回复数据报，增加了提案 163 中定义的重放抵抗功能。\n协议： 19 (PROTO_DATAGRAM2)\n实现正在进行中。应用程序应包含随机数（nonce）或时间戳检查以提供冗余保护。\n10.5 Datagram3 格式 提供可回复但未认证的数据报。依赖于 router 维护的会话认证,而非嵌入的 destination 和签名。\n协议： 20 (PROTO_DATAGRAM3) 状态： 自 0.9.66 版本起开发中\n适用于以下情况：- 目标地址较大（例如，后量子密钥）- 在其他层进行身份验证 - 带宽效率至关重要\n10.6 数据完整性 数据报的完整性通过 I2CP 层中的 gzip CRC-32 校验和来保护。数据报有效载荷格式本身不存在显式的校验和字段。\n10.7 数据包封装 每个数据报都被封装为单个 I2NP 消息或作为 Garlic Message 中的单个 clove。I2CP、I2NP 和 tunnel 层处理长度和帧 —— 数据报协议中没有内部分隔符或长度字段。\n10.8 后量子（PQ）考虑因素 如果实施 Proposal 169（ML-DSA 签名），签名和目标地址的大小将急剧增加——从约 455 字节增加到 ≥3739 字节。这一变化将大幅增加数据报开销并降低有效载荷容量。\nDatagram3 依赖会话级认证(而非嵌入式签名),很可能成为后量子 I2P 环境中的首选设计。\n11. 参考文献 提案 163 – Datagram2 和 Datagram3 提案 160 – UDP Tracker 集成 提案 144 – Streaming MTU 计算 提案 169 – 后量子签名 I2CP 规范 I2NP 规范 Tunnel 消息规范 SAM v3 规范 i2ptunnel 文档 12. 更新日志要点（2019 – 2025） Year Release Change 20190.9.43Datagram API stabilization 20210.9.50Protocol port handling reworked 20222.0.0SSU2 adoption completed 20242.6.0Legacy transport removal simplified UDP code 20252.9.0Datagram2/3 support added (Java API) 20252.10.0UDP Tracker implementation released --- 13. 总结 数据报子系统现在支持四种协议变体,提供从完全认证到轻量级原始传输的全方位选择。开发者应针对安全敏感的使用场景迁移至 Datagram2,针对需要高效回复的流量迁移至 Datagram3。所有旧类型保持兼容以确保长期互操作性。\n","description":"I2CP 之上的认证、可回复和原始消息格式","id":"b3c644204c779b5d6fc6a41438a3eb1b","section":"docs","title":"数据报","url":"/zh/docs/api/datagrams/"},{"categories":null,"content":"概述 本文档规定了适用于所有 I2P 协议的基础数据结构，包括 I2NP 、I2CP 、SSU2 、NTCP2 等。这些通用结构确保不同 I2P 实现与协议层之间的互操作性。\n自 0.9.58 以来的关键变更 在 Router 标识中弃用 ElGamal 和 DSA-SHA1（使用 X25519 + EdDSA） 后量子 ML-KEM（密钥封装机制）支持处于测试版阶段（自 2.10.0 起需用户主动启用） 服务记录选项已标准化（提案 167 ，在 0.9.66 中实现） 可压缩填充规范已最终确定（提案 161 ，在 0.9.57 中实现） 通用类型规范 整数 描述： 表示一个以网络字节序（大端序）编码的非负整数。\n内容： 长度为 1 到 8 个字节，表示一个无符号整数。\n用法： I2P 协议各处的字段长度、计数、类型标识符和数值。\n日期 描述: 时间戳，表示自 Unix 纪元（1970 年 1 月 1 日 00:00:00 GMT）以来的毫秒数。\n内容： 8 字节整数（无符号长整型）\n特殊值： - 0 = 未定义或空日期 - 最大值: 0xFFFFFFFFFFFFFFFF (年份 584,942,417,355)\n实现注意事项: - 始终使用 UTC/GMT 时区 - 需要毫秒级精度 - 用于租约过期、RouterInfo 发布以及时间戳验证\n字符串 描述： 带有长度前缀的 UTF-8 编码字符串。\n格式:\n+----+----+----+----+----+----+ |len | UTF-8 encoded data... | +----+----+----+----+----+----+ len :: Integer (1 byte) Value: 0-255 (string length in bytes, NOT characters) data :: UTF-8 encoded bytes Length: 0-255 bytes 约束条件： - 最大长度：255 字节（不是字符 - 多字节 UTF-8 序列按多个字节计算） - 长度可以为零（空字符串） - 不包含空字符终止符（null terminator） - 字符串不是以空字符结尾\n重要： UTF-8 编码序列每个字符可以使用多个字节。一个包含 100 个字符的字符串，如果使用多字节字符，可能会超过 255 字节的限制。\n密码学密钥结构 公钥 描述： 用于非对称加密的公钥。密钥类型和长度取决于上下文，或在密钥证书中指定。\n默认类型： ElGamal (自 0.9.58 起在 Router 身份中已弃用)\n支持的类型：\nType Code Length (bytes) Since Endianness Usage Status ElGamal0256-BigDestinations only (unused field)Deprecated for RIs P256164TBDBigReservedSee Proposal 145 P384296TBDBigReservedSee Proposal 145 P5213132TBDBigReservedSee Proposal 145 X255194320.9.38LittleCurrent standardRecommended MLKEM512_X255195320.9.67MixedHybrid PQ, LeaseSets onlyBeta MLKEM768_X255196320.9.67MixedHybrid PQ, LeaseSets onlyBeta MLKEM1024_X255197320.9.67MixedHybrid PQ, LeaseSets onlyBeta MLKEM512-8000.9.67TBDHandshakes onlyBeta MLKEM768-11840.9.67TBDHandshakes onlyBeta MLKEM1024-15680.9.67TBDHandshakes onlyBeta MLKEM512_CT-7680.9.67TBDHandshakes onlyBeta MLKEM768_CT-10880.9.67TBDHandshakes onlyBeta MLKEM1024_CT-15680.9.67TBDHandshakes onlyBeta **实现要求:** X25519 (类型 4) - 当前标准:\n用于 ECIES-X25519-AEAD-Ratchet 加密 自 0.9.48 起对 Router 标识为强制要求 小端序编码 (与其他类型不同) 参见 ECIES 和 ECIES-ROUTERS ElGamal (Type 0) - 遗留:\n自 0.9.58 起，已弃用于 Router 身份 对 Destination（目标）仍然有效（该字段自 0.6/2005 起未使用） 使用 ElGamal 规范 中定义的固定素数 为向后兼容而保留支持 MLKEM（后量子） - 测试版：\n混合方案将 ML-KEM 与 X25519 结合 在 2.10.0 中默认未启用 需要通过 Hidden Service Manager（隐藏服务管理器）手动启用 参见 ECIES-HYBRID 和 Proposal 169 类型代码和规范可能会变更 JavaDoc： PublicKey 私钥 Description: 用于非对称解密、与 PublicKey 类型相对应的私钥。\n存储： 类型和长度由上下文推断，或单独保存在数据结构/密钥文件中。\n支持的类型：\nType Code Length (bytes) Since Endianness Usage Status ElGamal0256-BigDestinations onlyDeprecated for RIs P256132TBDBigReservedSee Proposal 145 P384248TBDBigReservedSee Proposal 145 P521366TBDBigReservedSee Proposal 145 X255194320.9.38LittleCurrent standardRecommended MLKEM512_X255195320.9.67MixedHybrid PQ, LeaseSets onlyBeta MLKEM768_X255196320.9.67MixedHybrid PQ, LeaseSets onlyBeta MLKEM1024_X255197320.9.67MixedHybrid PQ, LeaseSets onlyBeta MLKEM512-16320.9.67TBDHandshakes onlyBeta MLKEM768-24000.9.67TBDHandshakes onlyBeta MLKEM1024-31680.9.67TBDHandshakes onlyBeta **安全注意事项：** - 私钥必须使用密码学安全的随机数生成器生成 - X25519 私钥按 RFC 7748 的定义采用标量夹紧（scalar clamping） - 在不再需要时，必须从内存中安全地擦除密钥材料 JavaDoc： PrivateKey 会话密钥 说明： 用于 I2P 的 tunnel 与 garlic encryption 中进行 AES-256 加密与解密的对称密钥。\n内容： 32 字节（256 位）\n用途： - tunnel 层加密 (AES-256/CBC with IV) - garlic 消息加密 - 端到端会话加密\n生成: 必须使用密码学安全的随机数生成器。\nJavaDoc： SessionKey SigningPublicKey 描述: 用于验证签名的公钥。类型和长度由 Destination（I2P 目标标识）的密钥证书指定，或由上下文推断。\n默认类型： DSA_SHA1 (自 0.9.58 起已弃用)\n支持的类型：\nType Code Length (bytes) Since Endianness Usage Status DSA_SHA10128-BigLegacy onlyDeprecated ECDSA_SHA256_P2561640.9.12BigOlder DestinationsDeprecated ECDSA_SHA384_P3842960.9.12BigRareDeprecated ECDSA_SHA512_P52131320.9.12BigRareDeprecated RSA_SHA256_204842560.9.12BigOffline signing onlyDeprecated RSA_SHA384_307253840.9.12BigOffline signing onlyDeprecated RSA_SHA512_409665120.9.12BigOffline signing onlyRecommended for SU3 EdDSA_SHA512_Ed255197320.9.15LittleCurrent standardRecommended EdDSA_SHA512_Ed25519ph8320.9.25LittleOffline signing onlyRare RedDSA_SHA512_Ed2551911320.9.39LittleEncrypted leasesets onlySpecialized Reserved (GOST)964-BigReservedProposal 134 Reserved (GOST)10128-BigReservedProposal 134 Reserved (MLDSA)12-20TBD-TBDReservedProposal 169 Experimental65280-65534Varies-VariesTesting onlyNever production Reserved65535---Future expansion- **实现要求:** EdDSA_SHA512_Ed25519 (Type 7) - 当前标准：\n自 2015 年末以来，默认用于所有新的 router 身份和 Destination（目的地） 使用 Ed25519 曲线与 SHA-512 哈希 32 字节公钥，64 字节签名 小端序编码（与大多数其他类型不同） 高性能与高安全性 RedDSA_SHA512_Ed25519 (Type 11) - 专用:\n仅用于加密的 leaseSet 和盲化 绝不用于 Router 身份标识或标准目标 与 EdDSA 的关键差异： 私钥采用模约减（而非钳位） 签名包含 80 字节的随机数据 直接使用公钥（而非私钥的哈希） 参见 [Red25519 规范](//docs/specs/red25519-signature-scheme/ DSA_SHA1 (Type 0) - 遗留：\n自 0.9.58 起，对 Router 身份标识已弃用 不建议用于新的 Destinations（目标） 1024 位 DSA 与 SHA-1（已知弱点） 仅为兼容性而保留支持 多元素密钥：\n由两个元素组成时（例如，ECDSA 点 X、Y） 每个元素在前面用零填充至 length/2 的长度 示例：64 字节的 ECDSA 密钥 = 32 字节的 X + 32 字节的 Y JavaDoc： SigningPublicKey SigningPrivateKey 说明： 用于创建签名的私钥，对应于 SigningPublicKey 类型。\n存储： 类型和长度在创建时指定。\n支持的类型：\nType Code Length (bytes) Since Endianness Usage Status DSA_SHA1020-BigLegacy onlyDeprecated ECDSA_SHA256_P2561320.9.12BigOlder DestinationsDeprecated ECDSA_SHA384_P3842480.9.12BigRareDeprecated ECDSA_SHA512_P5213660.9.12BigRareDeprecated RSA_SHA256_204845120.9.12BigOffline signing onlyDeprecated RSA_SHA384_307257680.9.12BigOffline signing onlyDeprecated RSA_SHA512_4096610240.9.12BigOffline signing onlyRecommended for SU3 EdDSA_SHA512_Ed255197320.9.15LittleCurrent standardRecommended EdDSA_SHA512_Ed25519ph8320.9.25LittleOffline signing onlyRare RedDSA_SHA512_Ed2551911320.9.39LittleEncrypted leasesets onlySpecialized **安全要求：** - 使用密码学安全的随机数源生成 - 使用适当的访问控制进行保护 - 完成后从内存中安全擦除 - 对于 EdDSA：将 32 字节种子经 SHA-512 哈希，取前 32 字节作为标量（经 clamping 位约束处理） - 对于 RedDSA：密钥生成方式不同（使用模约简而非 clamping） JavaDoc： SigningPrivateKey （签名私钥）\n签名 说明: 对数据的密码学签名，使用与 SigningPrivateKey 类型相对应的签名算法。\n类型和长度： 根据用于签名的密钥类型推断。\n支持的类型:\nType Code Length (bytes) Since Endianness Usage Status DSA_SHA1040-BigLegacy onlyDeprecated ECDSA_SHA256_P2561640.9.12BigOlder DestinationsDeprecated ECDSA_SHA384_P3842960.9.12BigRareDeprecated ECDSA_SHA512_P52131320.9.12BigRareDeprecated RSA_SHA256_204842560.9.12BigOffline signing onlyDeprecated RSA_SHA384_307253840.9.12BigOffline signing onlyDeprecated RSA_SHA512_409665120.9.12BigOffline signing onlyCurrent for SU3 EdDSA_SHA512_Ed255197640.9.15LittleCurrent standardRecommended EdDSA_SHA512_Ed25519ph8640.9.25LittleOffline signing onlyRare RedDSA_SHA512_Ed2551911640.9.39LittleEncrypted leasesets onlySpecialized **格式说明：** - 多元素签名（例如 ECDSA 的 R、S 值）使用前导零将每个元素填充到 length/2 的长度 - EdDSA 和 RedDSA 使用小端序编码 - 其他所有类型使用大端序编码 验证: - 使用相应的 SigningPublicKey - 遵循该密钥类型的签名算法规范 - 检查签名长度是否与该密钥类型的预期长度匹配\nJavaDoc： Signature 哈希 描述： 对数据的 SHA-256 哈希，在 I2P 中广泛用于完整性校验和标识。\n内容： 32 字节 (256 位)\n用途： - Router Identity 哈希（网络数据库键） - Destination 哈希（网络数据库键） - 在 Leases 中的 Tunnel 网关标识 - 数据完整性验证 - Tunnel ID 生成\n算法： 根据 FIPS 180-4 定义的 SHA-256\nJavaDoc: 哈希 会话标签 描述: 用于会话标识和基于标签的加密的随机数。\n重要: Session Tag（会话标签）的大小会因加密类型而异: - ElGamal/AES+SessionTag: 32 字节（遗留） - ECIES-X25519: 8 字节（当前标准）\n当前标准（ECIES，椭圆曲线集成加密方案）：\nContents: 8 bytes Usage: Ratchet-based encryption for Destinations and Routers 有关详细规范，请参见 ECIES 和 ECIES-ROUTERS 。\n旧版（ElGamal/AES）：\nContents: 32 bytes Usage: Deprecated encryption scheme 生成： 必须使用密码学安全的随机数生成器。\nJavaDoc： SessionTag TunnelId **描述：**用于标识 router 在 tunnel 中位置的唯一标识符。一个 tunnel 中的每一跳都有其自己的 TunnelId。\n格式:\nContents: 4-byte Integer (unsigned 32-bit) Range: Generally \u0026gt; 0 (zero reserved for special cases) 用途： - 在每个 router 识别入站/出站 tunnel 连接 - 在 tunnel 链的每一跳使用不同的 TunnelId - 用于 Lease（租约）结构中以标识网关 tunnel\n特殊值： - 0 = 保留用于协议的特殊用途（在正常运行中应避免使用） - TunnelIds 对每个 router 仅具有本地意义\nJavaDoc 文档: TunnelId 证书规范 证书 描述： 在整个 I2P 中使用的收据、工作量证明或密码学元数据的容器。\n格式：\n+----+----+----+----+----+----+-// |type| length | payload +----+----+----+----+----+----+-// type :: Integer (1 byte) Values: 0-5 (see types below) length :: Integer (2 bytes, big-endian) Size of payload in bytes payload :: data length -\u0026gt; $length bytes 总大小： 最少 3 字节 (NULL certificate，空证书), 最多 65538 字节\n证书类型 Type Code Payload Length Total Size Status Usage NULL003CurrentDefault/empty certificate HASHCASH1VariesVariesDeprecatedUnused (was for proof-of-work) HIDDEN203DeprecatedUnused (hidden routers don't advertise) SIGNED340 or 7243 or 75DeprecatedUnused (DSA signature ± destination hash) MULTIPLE4VariesVariesDeprecatedUnused (multiple certificates) KEY54+7+CurrentSpecifies key types (see below) ### 密钥证书（类型5） 简介: 版本 0.9.12 (2013年12月)\n目的： 指定非默认的密钥类型，并在标准 384 字节的 KeysAndCert 结构之外存储额外的密钥数据。\n有效载荷结构：\n+----+----+----+----+----+----+----+----+-// |SPKtype|CPKtype| Excess SPK data | +----+----+----+----+----+----+----+----+-// | Excess CPK data... | +----+----+----+----+----+----+----+----+ SPKtype :: Signing Public Key Type (2 bytes) See SigningPublicKey table above CPKtype :: Crypto Public Key Type (2 bytes) See PublicKey table above Excess SPK data :: Signing key bytes beyond 128 bytes Length: 0 to 65531 bytes Excess CPK data :: Crypto key bytes beyond 256 bytes Length: 0 to remaining space 关键实现注意事项：\n密钥类型顺序：\n**警告：**签名密钥类型在加密密钥类型之前 这看起来反直觉，但为兼容性而保留 顺序：SPKtype, CPKtype（不是 CPKtype, SPKtype） KeysAndCert（密钥与证书结构）中的密钥数据布局：\n[Crypto Public Key (partial/complete)] [Padding (if total key lengths \u0026lt; 384)] [Signing Public Key (partial/complete)] [Certificate Header (3 bytes)] [Key Certificate (4+ bytes)] [Excess Signing Key Data] [Excess Crypto Key Data] 计算超出部分的密钥数据:\n如果 Crypto Key \u0026gt; 256 字节: Excess = (Crypto Length - 256) 如果 Signing Key \u0026gt; 128 字节: Excess = (Signing Length - 128) Padding = max(0, 384 - Crypto Length - Signing Length) 示例（ElGamal 加密密钥）：\nSigning Key Type Total SPK Length Padding Excess in Cert Total Structure Size DSA_SHA112800387 + 7 = 394 ECDSA_P25664640387 + 7 = 394 ECDSA_P38496320387 + 7 = 394 ECDSA_P52113204387 + 11 = 398 RSA_20482560128387 + 135 = 522 RSA_40965120384387 + 391 = 778 EdDSA32960387 + 7 = 394 **Router 身份要求：** - 使用 NULL 证书直到 0.9.15 版本 - 自 0.9.16 起，非默认密钥类型需要密钥证书 - 自 0.9.48 起，支持 X25519 加密密钥 Destination（目的地标识）要求： - 按需使用 NULL 证书或密钥证书 - 自 0.9.12 起，非默认的签名密钥类型需要密钥证书 - 自 0.6（2005）起，加密公钥字段不再使用，但仍必须存在\n重要警告：\nNULL 与 KEY 证书：\n带有类型 (0,0) 并指定 ElGamal+DSA_SHA1 的 KEY 证书是允许的，但不建议使用 对于 ElGamal+DSA_SHA1，应始终使用 NULL 证书（规范表示） 带有 (0,0) 的 KEY 证书会多出 4 字节，并可能引发兼容性问题 某些实现可能无法正确处理带有 (0,0) 的 KEY 证书 多余数据验证:\n实现必须验证证书长度与对应密钥类型的预期长度相匹配 拒绝包含与密钥类型不对应的多余数据的证书 禁止在有效证书结构之后出现尾随垃圾数据 JavaDoc： 证书 映射 描述： 用于配置和元数据的键值对属性集合。\n格式:\n+----+----+----+----+----+----+----+----+ | size | key_string (len + data)| = | +----+----+----+----+----+----+----+----+ | val_string (len + data) | ; | ... +----+----+----+----+----+----+----+ size :: Integer (2 bytes, big-endian) Total number of bytes that follow (not including size field) Range: 0 to 65535 key_string :: String Format: 1-byte length + UTF-8 data Length: 0-255 bytes = :: Single byte (0x3D, \u0026#39;=\u0026#39; character) val_string :: String Format: 1-byte length + UTF-8 data Length: 0-255 bytes ; :: Single byte (0x3B, \u0026#39;;\u0026#39; character) [Repeat key_string = val_string ; for additional entries] 大小限制： - 键长度：0-255 字节 (+ 1 个长度字节) - 值长度：0-255 字节 (+ 1 个长度字节) - 映射总大小：0-65535 字节 (+ 2 个大小字段字节) - 最大结构大小：65537 字节\n关键排序要求：\n当映射出现在签名结构（RouterInfo、RouterAddress、Destination 属性、I2CP SessionConfig）中时，为确保签名不变性，条目必须按键排序：\n排序方法: 使用 Unicode 码点值的字典序排序（等同于 Java String.compareTo()） 大小写敏感性: 键和值通常区分大小写（取决于应用程序） 重复键: 在已签名的结构中不允许（会导致签名验证失败） 字符编码: UTF-8 字节级比较 为什么排序很重要: - 签名是基于字节表示来计算的 - 不同的键顺序会产生不同的签名 - 未签名的映射不要求排序，但应遵循相同的约定\n实现说明：\n编码冗余:\n同时存在 = 和 ; 分隔符以及字符串长度字节 这虽然低效，但为兼容性而保留 以长度字节为准；分隔符是必需的，但属于冗余 字符支持：\n尽管文档中另有说明，字符串内的 = 和 ; 确实受到支持（由长度字节处理） UTF-8 编码支持完整的 Unicode **警告：**I2CP 使用 UTF-8，但 I2NP 在历史上并未正确处理 UTF-8 为获得最大兼容性，在可能情况下对 I2NP 映射使用 ASCII 特殊上下文：\nRouterInfo/RouterAddress： 必须排序，不得重复 I2CP SessionConfig： 必须排序，不得重复 应用映射： 建议排序，但并非总是必须 示例（RouterInfo（路由器信息）选项）：\nMapping size: 45 bytes Sorted entries: caps=L (capabilities) netId=2 (network ID) router.version=0.9.67 JavaDoc： DataHelper 通用结构规范 密钥与证书 Description: 组合了加密密钥、签名密钥和证书的基础结构。可同时用作 RouterIdentity（路由标识）和 Destination（目的地）。\n结构：\n+----+----+----+----+----+----+----+----+ | public_key | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | padding (optional) | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | signing_key | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | certificate | +----+----+----+-// public_key :: PublicKey (partial or full) Default: 256 bytes (ElGamal) Other sizes: As specified in Key Certificate padding :: Random data Length: 0 bytes or as needed CONSTRAINT: public_key + padding + signing_key = 384 bytes signing_key :: SigningPublicKey (partial or full) Default: 128 bytes (DSA_SHA1) Other sizes: As specified in Key Certificate certificate :: Certificate Minimum: 3 bytes (NULL certificate) Common: 7 bytes (Key Certificate with default keys) TOTAL LENGTH: 387+ bytes (never assume exactly 387!) 密钥对齐: - 加密公钥: 从开头对齐（字节 0） - 填充: 位于中间（如有需要） - 签名公钥: 对齐到末尾（字节 256 到字节 383） - 证书: 从字节 384 开始\n大小计算：\nTotal size = 384 + 3 + key_certificate_length For NULL certificate (ElGamal + DSA_SHA1): Total = 384 + 3 = 387 bytes For Key Certificate (EdDSA + X25519): Total = 384 + 3 + 4 = 391 bytes For larger keys (e.g., RSA_4096): Total = 384 + 3 + 4 + excess_key_data_length 填充生成指南 (Proposal 161 ) 实现版本： 0.9.57（2023年1月，发行版 2.1.0）\n背景： - 对于非 ElGamal+DSA 密钥，填充存在于 384 字节的固定结构中 - 对于 Destination（I2P 目的地标识），自 0.6（2005 年）以来 256 字节的公钥字段一直未使用 - 填充应以便于压缩且仍然安全的方式生成\n要求:\n随机数据的最低要求：\n使用至少 32 字节的密码学安全随机数据 这可为安全性提供足够的熵 压缩策略：\n在整个填充/公钥字段内重复这 32 字节 诸如 I2NP Database Store、Streaming SYN（I2P Streaming 子系统中的 SYN 握手消息）、SSU2 handshake 等协议会使用压缩 在不牺牲安全性的前提下可显著节省带宽 示例：\nRouter 标识 (X25519 + EdDSA):\nStructure: - 32 bytes X25519 public key - 320 bytes padding (10 copies of 32-byte random data) - 32 bytes EdDSA public key - 7 bytes Key Certificate Compression savings: ~288 bytes when compressed 目的地 (ElGamal-unused + EdDSA):\nStructure: - 256 bytes unused ElGamal field (11 copies of 32-byte random data, truncated to 256) - 96 bytes padding (3 copies of 32-byte random data) - 32 bytes EdDSA public key - 7 bytes Key Certificate Compression savings: ~320 bytes when compressed 为什么这可行：\n完整结构的 SHA-256 哈希仍然包含全部熵 网络数据库 DHT 的分布仅依赖该哈希 签名密钥（32 bytes 的 EdDSA/X25519）提供 256 比特熵 额外 32 字节的重复随机数据 = 总熵 512 比特 对密码学强度而言绰绰有余 实现说明:\n必须存储并传输完整的 387+ 字节结构 针对完整的未压缩结构计算 SHA-256 哈希 在协议层应用压缩 (I2NP, Streaming, SSU2) 与自 0.6 (2005) 起的所有版本向后兼容 JavaDoc： KeysAndCert RouterIdentity（Router 身份标识） 说明： 在 I2P 网络中唯一标识一个 router。其结构与 KeysAndCert（密钥与证书）相同。\n格式: 请参阅上文的 KeysAndCert 结构\n当前要求（截至 0.9.58）：\n强制的密钥类型：\n加密： X25519 (类型 4，32 字节) 签名： EdDSA_SHA512_Ed25519 (类型 7，32 字节) 证书： 密钥证书 (类型 5) 已弃用的密钥类型：\n自 0.9.58 起，ElGamal（类型 0）用于 Router 身份时已弃用 自 0.9.58 起，DSA_SHA1（类型 0）用于 Router 身份时已弃用 这些切勿用于新的 router 典型大小：\n带密钥证书的 X25519（基于 Curve25519 的密钥交换算法） + EdDSA（椭圆曲线数字签名算法的一种） = 391 字节 32 字节 X25519 公钥 320 字节填充（可按 Proposal 161 压缩） 32 字节 EdDSA 公钥 7 字节证书（3 字节头部 + 4 字节密钥类型） 历史演进: - 0.9.16 之前: 始终为 NULL 证书（ElGamal + DSA_SHA1） - 0.9.16-0.9.47: 新增 Key Certificate（密钥证书）支持 - 0.9.48+: 支持 X25519 加密密钥 - 0.9.58+: 弃用 ElGamal 和 DSA_SHA1\n网络数据库键： - RouterInfo（路由器信息对象）以完整的 RouterIdentity（路由器身份）的 SHA-256 哈希作为键 - 哈希在完整的 391+ 字节结构上计算（包括填充）\n另见： - 填充生成指南 (提案 161 ) - 上文的密钥证书规范\nJavaDoc 文档: RouterIdentity 目的地 描述： 用于安全消息传递的端点标识符。在结构上与 KeysAndCert 相同，但其使用语义不同。\n格式： 参见上面的 KeysAndCert 结构\n与 RouterIdentity（路由标识）之间的关键区别： - 公钥字段未使用，且可能包含随机数据 - 自 0.6 版（2005 年）起该字段一直未被使用 - 最初用于旧的 I2CP-to-I2CP 加密（已禁用） - 目前仅在已弃用的 LeaseSet（租约集）加密中作为 IV（初始化向量）使用\n当前建议：\n签名密钥：\n推荐： EdDSA_SHA512_Ed25519（类型 7，32 字节） 可选：用于与旧版本兼容的 ECDSA 类型 避免：DSA_SHA1（已弃用，不建议使用） 加密密钥：\n该字段未被使用，但必须存在 建议： 根据提案 161 填充随机数据（可压缩） 大小：始终为 256 字节（ElGamal 槽位，尽管并未用于 ElGamal） 证书：\n用于 ElGamal + DSA_SHA1 的 NULL certificate（NULL 证书）（仅限旧版） 适用于所有其他签名密钥类型的 Key Certificate（密钥证书） 典型的现代目的地：\nStructure: - 256 bytes unused field (random data, compressible) - 96 bytes padding (random data, compressible) - 32 bytes EdDSA signing public key - 7 bytes Key Certificate Total: 391 bytes Compression savings: ~320 bytes 实际用于加密的密钥：\nDestination（目标标识）的加密密钥位于 LeaseSet 中，而不在 Destination 内 LeaseSet 包含当前的加密公钥（可能为多个） 有关加密密钥处理，请参阅 LeaseSet2 规范 网络数据库键： - LeaseSet 以完整的 Destination（I2P 目标标识）的 SHA-256 哈希为键 - 哈希基于完整的 387+ 字节结构计算\nJavaDoc： Destination（目标地址） 网络数据库结构 租约 描述： 授权特定的 tunnel 接收发往某个 Destination（目标地址）的消息。是最初的 LeaseSet 格式（type 1）的一部分。\n格式：\n+----+----+----+----+----+----+----+----+ | tunnel_gw | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ | tunnel_id | end_date +----+----+----+----+----+----+----+----+ | +----+----+----+----+ tunnel_gw :: Hash (32 bytes) SHA-256 hash of the gateway RouterIdentity tunnel_id :: TunnelId (4 bytes) Tunnel identifier at the gateway router end_date :: Date (8 bytes) Expiration timestamp in milliseconds since epoch 总大小： 44 字节\n用法： - 仅用于原始 LeaseSet（I2P 中的租约集合）（类型 1，已弃用） - 对于 LeaseSet2 及后续变体，请改用 Lease2\nJavaDoc： Lease（租约） LeaseSet (类型 1) 描述： 原始的 LeaseSet 格式。包含某个 Destination（I2P 目的地）的授权 tunnels 和密钥。存储在网络数据库中。状态：已弃用（请改用 LeaseSet2）。\n结构:\n+----+----+----+----+----+----+----+----+ | destination | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | encryption_key | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | signing_key | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | num| Lease 0 | +----+ + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | Lease 1 | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | Lease ($num-1) | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | signature | + + | | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ destination :: Destination Length: 387+ bytes encryption_key :: PublicKey (256 bytes, ElGamal) Used for end-to-end ElGamal/AES+SessionTag encryption Generated anew at each router startup (not persistent) signing_key :: SigningPublicKey (128+ bytes) Same type as Destination signing key Used for LeaseSet revocation (unimplemented) Generated anew at each router startup (not persistent) num :: Integer (1 byte) Number of Leases to follow Range: 0-16 leases :: Array of Lease structures Length: $num × 44 bytes Each Lease is 44 bytes signature :: Signature (40+ bytes) Length determined by Destination signing key type Signed by Destination\u0026#39;s SigningPrivateKey 数据库存储: - 数据库类型: 1 - 键: Destination（目标标识）的 SHA-256 哈希 - 值: 完整的 LeaseSet 结构\n重要说明：\nDestination（目标地址）公钥未使用：\nDestination 中的加密公钥字段未被使用 LeaseSet 中的加密密钥才是实际的加密密钥 临时密钥:\nencryption_key 是临时的 (在 router 启动时重新生成) signing_key 是临时的 (在 router 启动时重新生成) 两个密钥在重启之间都不会持久保存 撤销（未实现）：\nsigning_key 原本用于撤销 LeaseSet 撤销机制从未实现 Zero-lease（零租约） LeaseSet 原本用于撤销，但未被使用 版本控制/时间戳:\nLeaseSet 没有显式的 published 时间戳字段 版本是所有 lease（租约）中最早的到期时间 新的 LeaseSet 必须具有更早的 lease 到期时间才会被接受 Lease（租约）到期信息发布:\nPre-0.9.7: 所有已发布的 lease 采用相同的到期时间（取最早） 0.9.7+: 发布各个 lease 的实际到期时间 这是实现细节，不属于规范的一部分 零个 Lease:\n在技术上允许具有零个 Lease（租约）的 LeaseSet（租约集合） 用于撤销（尚未实现） 在实践中未使用 LeaseSet2 变体至少需要一个 Lease 弃用： LeaseSet 类型 1 已被弃用。新的实现应当使用 LeaseSet2 (类型 3)，它提供： - 发布时间戳字段（更好的版本控制） - 支持多个加密密钥 - 离线签名能力 - 4 字节的租约到期时间（相对于 8 字节） - 更灵活的选项\nJavaDoc： LeaseSet LeaseSet 变体 Lease2 描述： 采用 4 字节过期时间的改进租约格式。用于 LeaseSet2（类型 3）和 MetaLeaseSet（类型 7）。\n简介： 版本 0.9.38 (参见 提案 123 )\n格式：\n+----+----+----+----+----+----+----+----+ | tunnel_gw | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ | tunnel_id | end_date | +----+----+----+----+----+----+----+----+ tunnel_gw :: Hash (32 bytes) SHA-256 hash of gateway RouterIdentity tunnel_id :: TunnelId (4 bytes) Tunnel identifier at gateway end_date :: 4-byte timestamp (seconds since epoch) Rolls over in year 2106 总大小： 40 字节 (比原始的 Lease 小 4 字节)\n与原始租约的比较：\nFeature Lease (Type\u0026nbsp;1) Lease2 (Type\u0026nbsp;3+) Size44 bytes40 bytes Expiration Size8 bytes (ms)4 bytes (seconds) PrecisionMillisecondSecond RolloverYear\u0026nbsp;292,277,026,596Year\u0026nbsp;2106 Used InLeaseSet (deprecated)LeaseSet2, MetaLeaseSet **JavaDoc 文档：** [Lease2](http://docs.i2p-projekt.de/javadoc/net/i2p/data/Lease2.html) 离线签名 说明： 一种可选结构，用于预先签名的临时密钥，使得在无需在线访问 Destination（I2P 的目标标识）的私有签名密钥的情况下也可发布 LeaseSet。\n简介: 版本 0.9.38 (参见 提案 123 )\n格式：\n+----+----+----+----+----+----+----+----+ | expires | sigtype | | +----+----+----+----+----+----+ + | transient_public_key | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | signature | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ expires :: 4-byte timestamp (seconds since epoch) Expiration of transient key validity Rolls over in year 2106 sigtype :: 2-byte signature type Type of transient_public_key (see SigningPublicKey types) transient_public_key :: SigningPublicKey Length determined by sigtype Temporary signing key for LeaseSet signature :: Signature Length determined by Destination\u0026#39;s signing key type Signature of (expires || sigtype || transient_public_key) Signed by Destination\u0026#39;s permanent SigningPrivateKey 目的： - 支持离线生成 LeaseSet - 保护 Destination（I2P 的地址标识）主密钥免于在线暴露 - 可通过发布不带离线签名的新 LeaseSet 来撤销临时密钥\n使用场景:\n高安全性目标地址：\n主签名密钥离线存储（硬件安全模块 HSM、冷存储） 临时密钥离线生成，仅在限定时间段内使用 即使临时密钥被攻破也不会泄露主密钥 加密的 LeaseSet 发布：\nEncryptedLeaseSet 可以包含离线签名 盲化公钥（blinded public key）+ 离线签名可提供额外的安全性 安全注意事项：\n有效期管理:\n设置合理的有效期 (以天到数周为宜，而不是数年) 在到期前生成新的临时密钥 更短的有效期 = 更高的安全性，但需要更多维护 密钥生成:\n在安全环境中离线生成临时密钥 使用主密钥离线签名 仅将已签名的临时密钥 + 签名传输到在线 router 撤销：\n发布新的 LeaseSet，且不带离线签名，以隐式撤销 或者发布使用不同临时密钥的新 LeaseSet 签名验证：\nData to sign: expires (4 bytes) || sigtype (2 bytes) || transient_public_key Verification: 1. Extract Destination from LeaseSet 2. Get Destination\u0026#39;s SigningPublicKey 3. Verify signature over (expires || sigtype || transient_public_key) 4. Check that current time \u0026lt; expires 5. If valid, use transient_public_key to verify LeaseSet signature 实现说明： - 总大小取决于 sigtype 和 Destination（I2P 目标标识）的签名密钥类型 - 最小大小：4 + 2 + 32 (EdDSA 密钥) + 64 (EdDSA 签名) = 102 字节 - 最大实用大小：~600 字节 (RSA-4096 临时密钥 + RSA-4096 签名)\n兼容性： - LeaseSet2 (类型 3) - EncryptedLeaseSet (类型 5) - MetaLeaseSet (类型 7)\n另请参阅： 提案 123 ，了解离线签名协议的详细说明。\nLeaseSet2Header（LeaseSet2 头部） 说明： 通用头部结构，适用于 LeaseSet2（类型 3）和 MetaLeaseSet（类型 7）。\n简介： 版本 0.9.38（参见 提案 123 ）\n格式：\n+----+----+----+----+----+----+----+----+ | destination | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | published | expires | flags | +----+----+----+----+----+----+----+----+ | offline_signature (optional) | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ destination :: Destination Length: 387+ bytes published :: 4-byte timestamp (seconds since epoch) Publication time of this LeaseSet Rolls over in year 2106 expires :: 2-byte offset (seconds) Offset from published timestamp Maximum: 65535 seconds (18.2 hours) flags :: 2 bytes (bit flags) See flag definitions below offline_signature :: OfflineSignature (optional) Present only if flags bit 0 is set Variable length 最小总大小： 395 字节（不含离线签名）\n标志位定义 (位顺序: 15 14 \u0026hellip; 3 2 1 0):\nBit Name Description 0Offline Keys0 = No offline keys, 1 = Offline signature present 1Unpublished0 = Standard published, 1 = Unpublished (client-side only) 2Blinded0 = Standard, 1 = Will be blinded when published 3-15ReservedMust be 0 for compatibility **标志详细信息:** 位 0 - 离线密钥: - 0: 无离线签名，使用 Destination（目的地）的签名密钥验证 LeaseSet 签名 - 1: OfflineSignature 结构紧随 flags 字段之后\n第 1 位 - 未发布： - 0: 标准的已发布 LeaseSet，应当被洪泛到 floodfills - 1: 未发布的 LeaseSet（仅限客户端） - 不应被洪泛、不应发布，也不应在响应查询时发送 - 如果过期，不要向 netdb 查询替代项（除非第 2 位也被设置） - 用于本地 tunnels 或测试\n位 2 - 盲化 (自 0.9.42 起): - 0: 标准 LeaseSet - 1: 此未加密的 LeaseSet 在发布时将被盲化并加密 - 发布的版本将为 EncryptedLeaseSet（加密的 LeaseSet） (type 5) - 如果过期，请在 netdb 中查询盲化位置以进行替换 - 还必须将位 1 设为 1（未发布 + 盲化） - 用于加密的隐藏服务\n过期限制：\nLeaseSet Type Maximum Expires Value Maximum Actual Time LeaseSet2 (type 3)≈660 seconds≈11 minutes MetaLeaseSet (type 7)65,535 seconds≈18.2 hours **发布时间戳要求：** LeaseSet（租约集合）（类型 1）没有 published 字段，因此在进行版本化时需要搜索最早的租约到期时间。LeaseSet2 增加了显式的 published 时间戳，精度为 1 秒。\n关键实现注意事项： - Routers 必须将 LeaseSet 的发布速率限制为每个 Destination（I2P 目的地）远低于每秒一次 - 如果发布更快，确保每个新的 LeaseSet 的 published 时间至少晚 1 秒 - 如果 published 时间不比当前版本更新，Floodfills 将拒绝该 LeaseSet - 建议的最小间隔：两次发布之间为 10-60 秒\n计算示例：\nLeaseSet2 (最长 11 分钟):\npublished = 1704067200 (2024-01-01 00:00:00 UTC) expires = 660 (seconds) Actual expiration = 1704067200 + 660 = 1704067860 (2024-01-01 00:11:00 UTC) MetaLeaseSet (最长 18.2 小时):\npublished = 1704067200 (2024-01-01 00:00:00 UTC) expires = 65535 (seconds) Actual expiration = 1704067200 + 65535 = 1704132735 (2024-01-01 18:12:15 UTC) 版本管理： - 如果 published 时间戳更大，则将该 LeaseSet（租约集合）视为“更新的” - Floodfills 仅存储并对最新版本进行泛洪 - 当最旧的 Lease（租约）与先前 LeaseSet 的最旧 Lease 相匹配时需注意\nLeaseSet2 (类型 3) 说明： 现代的 LeaseSet 格式，支持多个加密密钥、离线签名和服务记录。是 I2P 隐藏服务的现行标准。\n简介： 版本 0.9.38（参见 提案 123 ）\n结构：\n+----+----+----+----+----+----+----+----+ | ls2_header | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | options | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ |numk| keytype0| keylen0 | | +----+----+----+----+----+ + | encryption_key_0 | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | keytypen| keylenn | | +----+----+----+----+ + | encryption_key_n | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | num| Lease2 0 | +----+ + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | Lease2($num-1) | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | signature | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ ls2header :: LeaseSet2Header Length: 395+ bytes (varies with offline signature) options :: Mapping Key-value pairs for service records and metadata Length: 2+ bytes (size field + data) numk :: Integer (1 byte) Number of encryption keys Range: 1 to (implementation-defined maximum, typically 8) keytype :: 2-byte encryption type See PublicKey type table keylen :: 2-byte key length Must match keytype specification encryption_key :: PublicKey Length: keylen bytes Type: keytype [Repeat keytype/keylen/encryption_key for each key] num :: Integer (1 byte) Number of Lease2s Range: 1-16 (at least one required) leases :: Array of Lease2 structures Length: $num × 40 bytes signature :: Signature Length determined by signing key type Signed over entire structure including database type prefix 数据库存储: - 数据库类型: 3 - 键: Destination（目标标识）的 SHA-256 哈希值 - 值: 完整的 LeaseSet2 结构\n签名计算：\nData to sign: database_type (1 byte, value=3) || complete LeaseSet2 data Verification: 1. Prepend database type byte (0x03) to LeaseSet2 data 2. If offline signature present: - Verify offline signature against Destination key - Verify LeaseSet2 signature against transient key 3. Else: - Verify LeaseSet2 signature against Destination key 加密密钥偏好顺序 针对已发布 (服务器端) LeaseSet (租约集): - 按服务器偏好顺序列出密钥 (最优先的在前) - 支持多种类型的客户端应当遵循服务器的偏好 - 从列表中选择第一个受支持的类型 - 一般而言, 编号更高 (较新) 的密钥类型更安全/更高效 - 建议的顺序: 按类型代码的逆序列出密钥 (最新的在前)\n示例服务器首选项：\nnumk = 2 Key 0: X25519 (type 4, 32 bytes) [Most preferred] Key 1: ElGamal (type 0, 256 bytes) [Legacy compatibility] 对于未发布（客户端）LeaseSet： - 密钥顺序基本无关紧要（很少会向客户端发起连接） - 为保持一致性，遵循相同的约定\n客户端密钥选择： - 遵循服务器偏好（选择第一个受支持的类型） - 或使用由实现定义的偏好 - 或基于双方的能力确定综合偏好\n选项映射 要求： - 选项必须按键排序（字典序，UTF-8 字节顺序） - 排序确保签名不变 - 不允许重复键\n标准格式（提案 167 ）：\n自 API 0.9.66（2025 年 6 月，发行版 2.9.0）起，服务记录选项采用标准化格式。完整规范参见提案 167 。\n服务记录选项格式：\nKey: _service._proto Value: record_type ttl [priority weight] port target [appoptions] service :: Symbolic name of service (lowercase, [a-z0-9-]) Examples: smtp, http, irc, mumble Use standard identifiers from IANA Service Name Registry or Linux /etc/services when available proto :: Transport protocol (lowercase, [a-z0-9-]) \u0026#34;tcp\u0026#34; = streaming protocol \u0026#34;udp\u0026#34; = repliable datagrams Protocol indicators for raw datagrams may be defined later record_type :: \u0026#34;0\u0026#34; (self-reference) or \u0026#34;1\u0026#34; (SRV record) ttl :: Time to live in seconds (positive integer) Recommended minimum: 86400 (one day) Prevents frequent re-queries For record_type = 0 (self-reference): port :: I2CP port number (non-negative integer) appoptions :: Optional application-specific data (no spaces or commas) For record_type = 1 (SRV record): priority :: Lower value = more preferred (non-negative integer) weight :: Relative weight for same priority, higher = more likely (non-negative) port :: I2CP port number (non-negative integer) target :: Hostname or b32 of destination (lowercase) Format: \u0026#34;example.i2p\u0026#34; or \u0026#34;aaaaa...aaaa.b32.i2p\u0026#34; Recommend b32 unless hostname is \u0026#34;well known\u0026#34; appoptions :: Optional application-specific data (no spaces or commas) 示例服务记录：\n1. 自引用型 SMTP 服务器：\nDestination: aaaa...aaaa.b32.i2p (this LeaseSet) Option: \u0026#34;_smtp._tcp\u0026#34; = \u0026#34;0 999999 25\u0026#34; Meaning: This destination provides SMTP service on I2CP port 25 2. 单一外部 SMTP 服务器：\nDestination: aaaa...aaaa.b32.i2p (this LeaseSet) Option: \u0026#34;_smtp._tcp\u0026#34; = \u0026#34;1 86400 0 0 25 bbbb...bbbb.b32.i2p\u0026#34; Meaning: SMTP service provided by bbbb...bbbb on port 25 TTL = 1 day, single server (priority=0, weight=0) 3. 多个 SMTP 服务器（负载均衡）：\nDestination: aaaa...aaaa.b32.i2p (this LeaseSet) Option: \u0026#34;_smtp._tcp\u0026#34; = \u0026#34;1 86400 0 0 25 bbbb...bbbb.b32.i2p,1 86400 1 0 25 cccc...cccc.b32.i2p\u0026#34; Meaning: Two SMTP servers bbbb...bbbb (priority=0, preferred) cccc...cccc (priority=1, backup) 4. 带有应用选项的 HTTP 服务：\nOption: \u0026#34;_http._tcp\u0026#34; = \u0026#34;0 86400 80 tls=1.3;cert=ed25519\u0026#34; Meaning: HTTP on port 80 with TLS 1.3 and EdDSA certificates TTL 建议: - 最小值: 86400 秒 (1 天) - 更长的 TTL 可降低 netdb 查询负载 - 在查询减少与服务更新传播之间取得平衡 - 对于稳定的服务: 604800 (7 天) 或更长\n实现说明：\n加密密钥（截至 0.9.44）：\nElGamal（类型 0，256 字节）：向后兼容 X25519（类型 4，32 字节）：当前标准 MLKEM（基于模格的密钥封装机制）变体：后量子（测试版，未最终定稿） 密钥长度验证:\nfloodfill 与客户端必须能够解析未知的密钥类型 使用 keylen 字段跳过未知密钥 不要因密钥类型未知而导致解析失败 发布时间戳：\n参见 LeaseSet2Header（LeaseSet v2 头部）关于速率限制的说明 两次发布之间的最小间隔为 1 秒 建议：两次发布之间间隔 10-60 秒 加密类型迁移:\n通过多密钥支持实现渐进式迁移 在过渡期同时列出旧密钥和新密钥 在给予客户端足够的升级周期后移除旧密钥 JavaDoc： LeaseSet2 MetaLease（元租约） 说明： 用于 MetaLeaseSet（元 LeaseSet）的 Lease（租约）结构，可引用其他 LeaseSets，而非引用 tunnels。用于负载均衡和冗余。\n简介： 版本 0.9.38，计划在 0.9.40 中投入使用（参见 Proposal 123 ）\n格式：\n+----+----+----+----+----+----+----+----+ | tunnel_gw | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ | flags |cost| end_date | +----+----+----+----+----+----+----+----+ tunnel_gw :: Hash (32 bytes) SHA-256 hash of: - Gateway RouterIdentity (for type 1), OR - Another MetaLeaseSet destination (for type 3/5/7) flags :: 3 bytes Bit order: 23 22 ... 3 2 1 0 Bits 3-0: Entry type (see table below) Bits 23-4: Reserved (must be 0) cost :: 1 byte (0-255) Lower value = higher priority Used for load balancing end_date :: 4-byte timestamp (seconds since epoch) Expiration time Rolls over in year 2106 总大小： 40 字节\n条目类型（标志位 3-0）：\nType Code Description Unknown0Unknown/invalid entry LeaseSet1Points to LeaseSet (type 1, deprecated) LeaseSet23Points to LeaseSet2 (type 3) EncryptedLeaseSet5Points to EncryptedLeaseSet (type 5) MetaLeaseSet7Points to another MetaLeaseSet (type 7) **使用场景：** 负载均衡：\nMetaLeaseSet（元租约集）包含多个 MetaLease（元租约）条目 每个条目都指向不同的 LeaseSet2 客户端根据 cost 字段进行选择 冗余：\n多个条目指向备用 LeaseSets 如果主 LeaseSet 不可用则回退 服务迁移:\nMetaLeaseSet（元 LeaseSet）指向新的 LeaseSet 允许在不同的 Destinations（I2P 目的地）之间平滑过渡 成本字段用法： - 成本越低 = 优先级越高 - 成本为 0 = 最高优先级 - 成本为 255 = 最低优先级 - 客户端应当（SHOULD）优先选择较低成本的条目 - 成本相同的条目可以随机进行负载均衡\n与 Lease2 的比较：\nFeature Lease2 MetaLease Size40 bytes40 bytes Tunnel ID4 bytesReplaced by flags (3 bytes) + cost (1 byte) Points ToSpecific tunnelLeaseSet or MetaLeaseSet UsageDirect tunnel referenceIndirection/load balancing **JavaDoc:** [MetaLease](http://docs.i2p-projekt.de/javadoc/net/i2p/data/MetaLease.html) MetaLeaseSet (元租约集) (类型 7) 描述： 包含 MetaLease（元租约）条目的 LeaseSet 变体，提供对其他 LeaseSets 的间接引用。用于负载均衡、冗余和服务迁移。\n简介： 在 0.9.38 中定义，计划在 0.9.40 中投入使用 (参见 提案 123 )\n状态: 规范已完成。应使用当前 I2P 发行版验证生产部署状态。\n结构：\n+----+----+----+----+----+----+----+----+ | ls2_header | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | options | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | num| MetaLease 0 | +----+ + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | MetaLease($num-1) | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ |numr| | +----+ + | revocation_0 | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | revocation_n | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | signature | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ ls2header :: LeaseSet2Header Length: 395+ bytes options :: Mapping Length: 2+ bytes (size + data) MUST be sorted by key num :: Integer (1 byte) Number of MetaLease entries Range: 1 to (implementation-defined, recommend 1-16) metaleases :: Array of MetaLease structures Length: $num × 40 bytes numr :: Integer (1 byte) Number of revocation hashes Range: 0 to (implementation-defined, recommend 0-16) revocations :: Array of Hash structures Length: $numr × 32 bytes SHA-256 hashes of revoked LeaseSet Destinations 数据库存储： - 数据库类型： 7 - 键： Destination（I2P 的目标地址）的 SHA-256 哈希 - 值： 完整的 MetaLeaseSet（I2P 中的 leaseSet 元集合）结构\n签名计算：\nData to sign: database_type (1 byte, value=7) || complete MetaLeaseSet data Verification: 1. Prepend database type byte (0x07) to MetaLeaseSet data 2. If offline signature present in header: - Verify offline signature against Destination key - Verify MetaLeaseSet signature against transient key 3. Else: - Verify MetaLeaseSet signature against Destination key 使用场景：\n1. 负载均衡:\nMetaLeaseSet for primary.i2p: MetaLease 0: cost=0, points to server1.i2p LeaseSet2 MetaLease 1: cost=0, points to server2.i2p LeaseSet2 MetaLease 2: cost=0, points to server3.i2p LeaseSet2 Clients randomly select among equal-cost entries 2. 故障切换:\nMetaLeaseSet for service.i2p: MetaLease 0: cost=0, points to primary.i2p LeaseSet2 MetaLease 1: cost=100, points to backup.i2p LeaseSet2 Clients prefer cost=0 (primary), fall back to cost=100 (backup) 3. 服务迁移：\nMetaLeaseSet for old-domain.i2p: MetaLease 0: cost=0, points to new-domain.i2p LeaseSet2 Transparently redirects clients from old to new destination 4. 多层架构：\nMetaLeaseSet for service.i2p: MetaLease 0: cost=0, points to region1-meta.i2p (another MetaLeaseSet) MetaLease 1: cost=0, points to region2-meta.i2p (another MetaLeaseSet) Each region MetaLeaseSet points to regional servers Allows hierarchical load balancing 撤销列表：\n撤销列表允许 MetaLeaseSet 明确撤销先前发布的 LeaseSets：\n用途: 将特定的 Destination（I2P 的地址标识）标记为不再有效 内容: 已吊销的 Destination 结构的 SHA-256 哈希 用法: 客户端不得使用其 Destination 哈希出现在吊销列表中的 LeaseSets 典型值: 在大多数部署中为空（numr=0） 撤销示例:\nService migrates from dest-v1.i2p to dest-v2.i2p: MetaLease 0: points to dest-v2.i2p Revocations: [hash(dest-v1.i2p)] Clients will use v2 and ignore v1 even if cached 过期处理：\nMetaLeaseSet（元 LeaseSet）使用 LeaseSet2Header（LeaseSet2 的头部），其 expires 最大为 65535 秒（约 18.2 小时）：\n比 LeaseSet2 长得多（最长约 11 分钟） 适用于相对静态的间接引用 被引用的 LeaseSets 可以有更短的到期时间 客户端必须同时检查 MetaLeaseSet 和被引用的 LeaseSets 的到期时间 选项映射:\n使用与 LeaseSet2 选项相同的格式 可以包含服务记录（提案 167 ） 必须按键排序 服务记录通常描述最终的目标服务，而不是间接结构 客户端实现注意事项：\n解析流程：\n1. Query netdb for MetaLeaseSet using SHA-256(Destination) 2. Parse MetaLeaseSet, extract MetaLease entries 3. Sort entries by cost (lower = better) 4. For each entry in cost order: a. Extract LeaseSet hash from tunnel_gw field b. Determine entry type from flags c. Query netdb for referenced LeaseSet (may be another MetaLeaseSet) d. Check revocation list e. Check expiration f. If valid, use the LeaseSet; else try next entry 缓存：\n同时缓存 MetaLeaseSet（元租约集合）和其引用的 LeaseSets 检查这两个层级的过期时间 监控是否有更新的 MetaLeaseSet 发布 故障切换:\n如果首选条目失败，尝试成本次低的下一个条目 考虑将失败的条目标记为暂时不可用 定期重新检查以确认是否已恢复 实现状态:\n提案 123 指出部分内容仍处于“开发中”。实现者应当： - 在目标 I2P 版本中验证生产就绪性 - 在部署前测试对 MetaLeaseSet（I2P 中用于聚合多个 leaseSet 的元集合）的支持 - 在较新的 I2P 版本中检查是否有更新的规范\nJavaDoc: MetaLeaseSet （MetaLeaseSet：用于聚合多个 leaseSet 的元数据集合）\nEncryptedLeaseSet（加密的 LeaseSet，类型 5） 描述： 加密且盲化的 LeaseSet，用于增强隐私。仅盲化的公钥和元数据可见；实际的租约和加密密钥均被加密。\n简介： 在 0.9.38 中定义，自 0.9.39 起可用（参见 提案 123 ）\n结构：\n+----+----+----+----+----+----+----+----+ | sigtype | | +----+----+ + | blinded_public_key | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | published | expires | flags | +----+----+----+----+----+----+----+----+ | offline_signature (optional) | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | len | | +----+----+ + | encrypted_data | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | signature | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ sigtype :: 2-byte signature type Type of blinded_public_key MUST be RedDSA_SHA512_Ed25519 (type 11) blinded_public_key :: SigningPublicKey (32 bytes for RedDSA) Blinded version of Destination signing key Used to verify signature on EncryptedLeaseSet published :: 4-byte timestamp (seconds since epoch) Publication time Rolls over in year 2106 expires :: 2-byte offset (seconds) Offset from published Maximum: 65535 seconds (18.2 hours) Practical maximum for LeaseSet data: ~660 seconds (~11 min) flags :: 2 bytes Bit 0: Offline signature present (0=no, 1=yes) Bit 1: Unpublished (0=published, 1=client-side only) Bits 15-2: Reserved (must be 0) offline_signature :: OfflineSignature (optional) Present only if flags bit 0 = 1 Variable length len :: 2-byte integer Length of encrypted_data Range: 1 to 65535 encrypted_data :: Encrypted payload Length: len bytes Contains encrypted LeaseSet2 or MetaLeaseSet signature :: Signature (64 bytes for RedDSA) Length determined by sigtype Signed by blinded_public_key or transient key 数据库存储: - 数据库类型: 5 - 键: 对 blinded Destination (经盲化的 Destination) 的 SHA-256 哈希 (非原始的 Destination) - 值: 完整的 EncryptedLeaseSet (加密的 leaseSet) 结构\n与 LeaseSet2 的关键差异：\n不使用 LeaseSet2Header 结构（字段相似，但布局不同） 盲化的公钥，而不是完整的 Destination（目标标识） 加密的有效载荷，而非明文的租约和密钥 数据库键为盲化 Destination 的哈希，而不是原始的 Destination 签名计算：\nData to sign: database_type (1 byte, value=5) || complete EncryptedLeaseSet data Verification: 1. Prepend database type byte (0x05) to EncryptedLeaseSet data 2. If offline signature present (flags bit 0 = 1): - Verify offline signature against blinded public key - Verify EncryptedLeaseSet signature against transient key 3. Else: - Verify EncryptedLeaseSet signature against blinded public key 签名类型要求：\n必须使用 RedDSA_SHA512_Ed25519 (类型 11)： - 32 字节的盲化公钥 - 64 字节的签名 - 为实现盲化的安全属性所必需 - 参见 [Red25519 规范](//docs/specs/red25519-signature-scheme/\n与 EdDSA 的关键差异： - 通过模约简（modular reduction）得到私钥（而非 clamping（位约束）） - 签名包含 80 字节的随机数据 - 直接使用公钥（而非哈希） - 支持安全的盲化操作\n盲化与加密:\n完整详情请参见 EncryptedLeaseSet 规范 ：\n1. 密钥盲化：\nBlinding process (daily rotation): secret = HKDF(original_signing_private_key, date_string, \u0026#34;i2pblinding1\u0026#34;) alpha = SHA-256(secret) mod L (where L is Ed25519 group order) blinded_private_key = alpha * original_private_key blinded_public_key = alpha * original_public_key 2. 数据库位置：\nClient publishes to: Key = SHA-256(blinded_destination) Where blinded_destination uses: - Blinded public key (signing key) - Same unused public key field (random) - Same certificate structure 3. 加密层（三层）：\n第 1 层 - 认证层（客户端访问）： - 加密：ChaCha20 流密码 - 密钥派生：HKDF（使用每个客户端的机密） - 已认证的客户端可以解密外层\n第2层 - 加密层: - 加密算法：ChaCha20 - 密钥：由客户端与服务器之间的 DH（Diffie-Hellman 密钥交换）导出 - 包含实际的 LeaseSet2 或 MetaLeaseSet\n第 3 层 - 内部 LeaseSet: - 完整的 LeaseSet2 或 MetaLeaseSet - 包含所有 tunnels、加密密钥、选项 - 仅在成功解密后可访问\n加密密钥派生:\nClient has: ephemeral_client_private_key Server has: ephemeral_server_public_key (in encrypted_data) Shared secret = X25519(client_private, server_public) Encryption key = HKDF(shared_secret, context_info, \u0026#34;i2pblinding2\u0026#34;) 发现过程：\n适用于已授权的客户端：\n1. Client knows original Destination 2. Client computes current blinded Destination (based on current date) 3. Client computes database key: SHA-256(blinded_destination) 4. Client queries netdb for EncryptedLeaseSet using blinded key 5. Client decrypts layer 1 using authorization credentials 6. Client decrypts layer 2 using DH shared secret 7. Client extracts inner LeaseSet2/MetaLeaseSet 8. Client uses tunnels from inner LeaseSet for communication 对于未授权的客户端： - 即使找到 EncryptedLeaseSet（加密的 leaseSet），也无法解密 - 无法从盲化版本确定原始 Destination（目标地址） - 无法在不同的盲化周期（每日轮换）之间关联 EncryptedLeaseSets\n过期时间：\nContent Type Maximum Expires Notes EncryptedLeaseSet (outer)65,535 sec (≈18.2 hr)Full 2-byte expires field Inner LeaseSet2≈660 sec (≈11 min)Actual lease data practical maximum Inner MetaLeaseSet65,535 sec (≈18.2 hr)Indirection can be longer-lived **发布时间：** 与 LeaseSet2Header 的要求相同：\n每次发布之间必须至少增加 1 秒 如果不比当前版本新，Floodfills 将拒绝 建议：每次发布之间间隔 10-60 秒 使用加密 LeaseSets 的离线签名：\n使用离线签名时的特别注意事项： - 盲化公钥每日轮换 - 离线签名必须每日使用新的盲化密钥重新生成 - 或者将离线签名用于内部 LeaseSet，而不是外层 EncryptedLeaseSet（加密的 LeaseSet） - 参见 Proposal 123 的说明\n实现说明：\n客户端授权:\n可为多个客户端使用不同的密钥进行授权 每个获授权的客户端都拥有唯一的解密凭据 通过更改授权密钥撤销客户端的授权 每日密钥轮换：\n盲化密钥在 UTC 午夜轮换 客户端必须每天重新计算盲化 Destination（目标标识） 旧的 EncryptedLeaseSets 在轮换后将无法被发现 隐私属性:\nFloodfills（floodfill 路由）无法确定原始 Destination（目的地标识） 未授权的客户端无法访问该服务 不同的 blinding periods（盲化周期）之间无法关联 除了到期时间之外没有明文元数据 性能：\n客户端必须执行每日盲化计算 三层加密会增加计算开销 考虑缓存已解密的内部 LeaseSet（租约集） 安全注意事项：\n授权密钥管理:\n安全分发客户端授权凭据 为每个客户端使用唯一凭据，以实现细粒度撤销 定期轮换授权密钥 时钟同步:\n每日 blinding（盲化）依赖于同步的 UTC 日期 时钟偏移可能导致查询失败 考虑为容差支持前一天/后一天的 blinding 元数据泄露：\nPublished 和 expires 字段是明文 模式分析可能会揭示服务特征 如果担心，可将发布间隔随机化 JavaDoc： EncryptedLeaseSet Router 结构 RouterAddress（router 地址） 描述： 定义通过特定传输协议与 router 建立连接所需的信息。\n格式:\n+----+----+----+----+----+----+----+----+ |cost| expiration +----+----+----+----+----+----+----+----+ | transport_style | +----+----+----+----+-//-+----+----+----+ | | + + | options | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ cost :: Integer (1 byte) Relative cost, 0=free, 255=expensive Typical values: 5-6: SSU2 10-11: NTCP2 expiration :: Date (8 bytes) MUST BE ALL ZEROS (see critical note below) transport_style :: String (1-256 bytes) Transport protocol name Current values: \u0026#34;SSU2\u0026#34;, \u0026#34;NTCP2\u0026#34; Legacy: \u0026#34;SSU\u0026#34;, \u0026#34;NTCP\u0026#34; (removed) options :: Mapping Transport-specific configuration Common options: \u0026#34;host\u0026#34;, \u0026#34;port\u0026#34; Transport-specific options vary 严重 - Expiration 字段:\n⚠️ 过期字段必须设置为全零（8个零字节）。\n原因： 自 0.9.3 版本起，非零的到期时间会导致签名验证失败 历史： 到期时间字段最初未被使用，始终为 null 当前状态： 自 0.9.12 起该字段再次被识别，但必须等待网络升级 实现： 始终设置为 0x0000000000000000 任何非零的过期值都会导致 RouterInfo（I2P router 的信息记录）签名验证失败。\n传输协议 当前协议（截至 2.10.0）：\nProtocol Status Introduced Removed Notes SSU2Current0.9.54 (May 2022)-Default since 0.9.56 NTCP2Current0.9.36 (Aug 2018)-Active NTCPRemoved-0.9.50 (May 2021)Use NTCP2 SSURemoved-2.4.0 (Dec 2023)Use SSU2 **传输样式取值:** - `\"SSU2\"`: 当前基于 UDP 的传输方式 - `\"NTCP2\"`: 当前基于 TCP 的传输方式 - `\"NTCP\"`: 遗留，已移除（请勿使用） - `\"SSU\"`: 遗留，已移除（请勿使用） 通用选项 所有传输方式通常包括：\n\u0026#34;host\u0026#34; = IPv4 or IPv6 address or hostname \u0026#34;port\u0026#34; = Port number (1-65535) SSU2 特定选项 完整细节请参见 SSU2 规范 。\n必需选项：\n\u0026#34;host\u0026#34; = IP address (IPv4 or IPv6) \u0026#34;port\u0026#34; = UDP port number \u0026#34;s\u0026#34; = Static X25519 public key (Base64, 44 characters = 32 bytes) \u0026#34;i\u0026#34; = Introduction key X25519 (Base64, 44 characters = 32 bytes) \u0026#34;v\u0026#34; = \u0026#34;2\u0026#34; (protocol version) 可选选项:\n\u0026#34;caps\u0026#34; = Capability string (e.g., \u0026#34;B\u0026#34; for bandwidth tier) \u0026#34;ihost0\u0026#34;, \u0026#34;ihost1\u0026#34;, ... = Introducer IP addresses \u0026#34;iport0\u0026#34;, \u0026#34;iport1\u0026#34;, ... = Introducer ports \u0026#34;ikey0\u0026#34;, \u0026#34;ikey1\u0026#34;, ... = Introducer static keys (Base64, 44 chars) \u0026#34;itag0\u0026#34;, \u0026#34;itag1\u0026#34;, ... = Introducer relay tags \u0026#34;iexp0\u0026#34;, \u0026#34;iexp1\u0026#34;, ... = Introducer expiration timestamps \u0026#34;mtu\u0026#34; = Maximum transmission unit (default 1500, min 1280) \u0026#34;mtu6\u0026#34; = IPv6 MTU (if different from IPv4) 示例 SSU2 RouterAddress（路由地址）：\ncost: 5 expiration: 0x0000000000000000 transport_style: \u0026#34;SSU2\u0026#34; options: host=198.51.100.42 port=12345 s=SGVsbG8gV29ybGQhIFRoaXMgaXMgYSBzYW1wbGUga2V5IQ== i=QW5vdGhlciBTYW1wbGUgS2V5IGZvciBJbnRyb2R1Y3Rpb24= v=2 caps=BC mtu=1472 NTCP2 特定选项 完整说明请参见 NTCP2 规范 。\n必需选项:\n\u0026#34;host\u0026#34; = IP address (IPv4 or IPv6) \u0026#34;port\u0026#34; = TCP port number \u0026#34;s\u0026#34; = Static X25519 public key (Base64, 44 characters = 32 bytes) \u0026#34;i\u0026#34; = Initialization vector (Base64, 24 characters = 16 bytes) \u0026#34;v\u0026#34; = \u0026#34;2\u0026#34; (protocol version) 可选选项（自 0.9.50 起）：\n\u0026#34;caps\u0026#34; = Capability string NTCP2 RouterAddress 示例:\ncost: 10 expiration: 0x0000000000000000 transport_style: \u0026#34;NTCP2\u0026#34; options: host=198.51.100.42 port=23456 s=SGVsbG8gV29ybGQhIFRoaXMgaXMgYSBzYW1wbGUga2V5IQ== i=U2FtcGxlIElWIGhlcmU= v=2 实现说明 成本值：\nUDP (SSU2) 由于效率更高，通常成本更低（5-6） TCP (NTCP2) 由于开销更大，通常成本更高（10-11） 成本越低 = 更优先的传输方式 多个地址：\nRouters 可能会发布多个 RouterAddress（路由地址条目） 不同的传输协议（SSU2 和 NTCP2） 不同的 IP 版本（IPv4 和 IPv6） 客户端会根据开销和能力进行选择 主机名 vs IP:\n出于性能考虑，优先使用 IP 地址 支持主机名，但会增加 DNS 解析开销 可考虑在已发布的 RouterInfos（I2P 路由信息条目）中使用 IP Base64 编码：\n所有密钥和二进制数据均以 Base64 编码 标准 Base64（RFC 4648） 无填充或非标准字符 JavaDoc： RouterAddress RouterInfo（路由器信息） 描述: 关于 router 的完整已发布信息，存储在网络数据库中。包含身份标识、地址和能力。\n格式：\n+----+----+----+----+----+----+----+----+ | router_ident | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | published | +----+----+----+----+----+----+----+----+ |size| RouterAddress 0 | +----+ + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | RouterAddress 1 | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | RouterAddress ($size-1) | + + | | ~ ~ ~ ~ | | +----+----+----+----+-//-+----+----+----+ |psiz| options | +----+----+----+----+-//-+----+----+----+ | signature | + + | | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ router_ident :: RouterIdentity Length: 387+ bytes (typically 391 for X25519+EdDSA) published :: Date (8 bytes) Publication timestamp (milliseconds since epoch) size :: Integer (1 byte) Number of RouterAddress entries Range: 0-255 addresses :: Array of RouterAddress Variable length Each RouterAddress has variable size peer_size :: Integer (1 byte) Number of peer hashes (ALWAYS 0) Historical, unused feature options :: Mapping Router capabilities and metadata MUST be sorted by key signature :: Signature Length determined by router_ident signing key type Typically 64 bytes (EdDSA) Signed by router_ident\u0026#39;s SigningPrivateKey 数据库存储： - 数据库类型： 0 - 键： RouterIdentity（I2P router 的身份标识）的 SHA-256 哈希 - 值： 完整的 RouterInfo 结构（I2P router 的信息结构）\n发布时间戳: - 8 字节日期（自 Unix 纪元以来的毫秒数） - 用于 RouterInfo（路由信息）的版本管理 - Routers（路由器）会周期性地发布新的 RouterInfo - Floodfills（floodfill 路由器）会根据发布时间戳保留最新版本\n地址排序: - 历史: 非常早期的 routers 要求按其数据的 SHA-256 哈希对地址进行排序 - 当前: 不需要排序，为了兼容性而实现并不值得 - 地址可以按任意顺序\n对等体数量字段（历史）： - 始终为 0 在现代 I2P 中 - 原本用于受限路由（未实现） - 若实现，其后将跟随相应数量的 Router 哈希 - 某些旧实现可能要求已排序的对等体列表\n选项映射：\n选项必须按键名排序。标准选项包括：\n能力选项：\n\u0026#34;caps\u0026#34; = Capability string Common values: f = Floodfill (network database) L or M or N or O = Bandwidth tier (L=lowest, O=highest) R = Reachable U = Unreachable/firewalled Example: \u0026#34;fLRU\u0026#34; = Floodfill, Low bandwidth, Reachable, Unreachable 网络选项：\n\u0026#34;netId\u0026#34; = Network ID (default \u0026#34;2\u0026#34; for main I2P network) Different values for test networks \u0026#34;router.version\u0026#34; = I2P version string Example: \u0026#34;0.9.67\u0026#34; or \u0026#34;2.10.0\u0026#34; 统计选项：\n\u0026#34;stat_uptime\u0026#34; = Uptime in milliseconds \u0026#34;coreVersion\u0026#34; = Core I2P version \u0026#34;router.version\u0026#34; = Full router version string 有关标准选项的完整列表，请参阅网络数据库 RouterInfo（路由器信息）文档 。\n签名计算:\nData to sign: Complete RouterInfo structure from router_ident through options Verification: 1. Extract RouterIdentity from RouterInfo 2. Get SigningPublicKey from RouterIdentity (type determines algorithm) 3. Verify signature over all data preceding signature field 4. Signature must match signing key type and length 典型的现代 RouterInfo（I2P router 信息记录）:\nRouterIdentity: 391 bytes (X25519+EdDSA with Key Certificate) Published: 8 bytes Size: 1 byte (typically 1-4 addresses) RouterAddress × N: Variable (typically 200-500 bytes each) Peer Size: 1 byte (value=0) Options: Variable (typically 50-200 bytes) Signature: 64 bytes (EdDSA) Total: ~1000-2500 bytes typical 实现说明:\n多个地址:\nRouters 通常发布 1-4 个地址 IPv4 和 IPv6 变体 SSU2 和/或 NTCP2 传输协议 每个地址相互独立 版本控制：\n较新的 RouterInfo（路由器信息）具有更晚的 published 时间戳 Routers（路由器）约每 2 小时或在地址更改时重新发布 Floodfills（泛洪节点）只存储并泛洪最新版本 验证：\n在接受 RouterInfo（路由信息记录）之前验证签名 检查每个 RouterAddress（路由地址记录）中的过期字段是否全为零 验证选项映射是否按键名排序 检查证书和密钥类型是否为已知/受支持 网络数据库（netDb）：\nFloodfills 以 Hash(RouterIdentity) 为索引存储 RouterInfo 在上次发布后保留约 2 天 Routers 查询 floodfills 以发现其他 routers JavaDoc： RouterInfo 实现说明 字节序（Endianness） 默认：大端序（网络字节序）\n大多数 I2P 结构使用大端字节序: - 所有整数类型（1-8 字节） - 日期时间戳 - TunnelId（隧道 ID） - 字符串长度前缀 - 证书类型和长度 - 密钥类型代码 - 映射大小字段\n例外：小端序\n以下密钥类型使用小端序编码： - X25519 加密密钥 (类型 4) - EdDSA_SHA512_Ed25519 签名密钥 (类型 7) - EdDSA_SHA512_Ed25519ph 签名密钥 (类型 8) - RedDSA_SHA512_Ed25519 签名密钥 (类型 11)\n实现：\n// Big-endian (most structures) int value = ((bytes[0] \u0026amp; 0xFF) \u0026lt;\u0026lt; 24) | ((bytes[1] \u0026amp; 0xFF) \u0026lt;\u0026lt; 16) | ((bytes[2] \u0026amp; 0xFF) \u0026lt;\u0026lt; 8) | (bytes[3] \u0026amp; 0xFF); // Little-endian (X25519, EdDSA, RedDSA) int value = (bytes[0] \u0026amp; 0xFF) | ((bytes[1] \u0026amp; 0xFF) \u0026lt;\u0026lt; 8) | ((bytes[2] \u0026amp; 0xFF) \u0026lt;\u0026lt; 16) | ((bytes[3] \u0026amp; 0xFF) \u0026lt;\u0026lt; 24); 结构版本控制 切勿假设固定大小：\n许多结构具有可变长度: - RouterIdentity（路由器身份）: 387+ 字节（并非总是 387） - Destination（目的地标识）: 387+ 字节（并非总是 387） - LeaseSet2（租约集2）: 变化幅度很大 - Certificate（证书）: 3+ 字节\n始终读取大小字段： - 证书长度位于第 1-2 字节 - 映射大小位于开头 - KeysAndCert 始终按 384 + 3 + certificate_length 计算\n检查是否有多余数据: - 禁止在有效结构之后出现尾随垃圾数据 - 验证证书长度与密钥类型匹配 - 对固定大小类型强制执行精确的预期长度\n当前建议（2025年10月） 针对新的 Router 身份：\nEncryption: X25519 (type 4, 32 bytes) Signing: EdDSA_SHA512_Ed25519 (type 7, 32 bytes) Certificate: Key Certificate (type 5) Total Size: 391 bytes Padding: Compressible per [Proposal 161](/zh/proposals/161-ri-dest-padding/) 对于新的 Destination（目标标识）：\nUnused Public Key Field: 256 bytes random (compressible) Signing: EdDSA_SHA512_Ed25519 (type 7, 32 bytes) Certificate: Key Certificate (type 5) Total Size: 391 bytes Padding: Compressible per [Proposal 161](/zh/proposals/161-ri-dest-padding/) 针对新的 LeaseSets：\nType: LeaseSet2 (type 3) Encryption Keys: X25519 (type 4, 32 bytes) Leases: At least 1, typically 3-5 Options: Include service records per [Proposal 167](/proposals/167-service-records/) Signature: EdDSA (64 bytes) 适用于加密服务：\nType: EncryptedLeaseSet (type 5) Blinding: RedDSA_SHA512_Ed25519 (type 11) Inner LeaseSet: LeaseSet2 (type 3) Rotation: Daily blinding key rotation Authorization: Per-client encryption keys 已弃用功能 - 请勿使用 已弃用的加密: - ElGamal (type 0) 用于 Router 身份（自 0.9.58 起弃用） - ElGamal/AES+SessionTag（会话标签）加密（使用 ECIES-X25519）\n已弃用的签名： - 用于 Router 身份的 DSA_SHA1（类型 0）（自 0.9.58 起弃用） - ECDSA 变体（类型 1-3），不用于新的实现 - RSA 变体（类型 4-6），SU3 文件除外\n已弃用的网络格式: - LeaseSet 类型 1 (使用 LeaseSet2) - Lease (44 字节, 使用 Lease2) - 原始 Lease 到期时间格式\n已弃用的传输协议： - NTCP (已在 0.9.50 中移除) - SSU (已在 2.4.0 中移除)\n已弃用的证书： - HASHCASH (type 1)（使用 Hashcash 机制的证书类型） - HIDDEN (type 2)（隐藏证书类型） - SIGNED (type 3)（签名证书类型） - MULTIPLE (type 4)（多重证书类型）\n安全注意事项 密钥生成： - 始终使用密码学安全的随机数生成器 - 切勿在不同上下文中复用密钥 - 通过适当的访问控制保护私钥 - 完成后从内存中安全擦除密钥材料\n签名验证： - 在信任数据之前务必验证签名 - 检查签名长度与密钥类型匹配 - 验证已签名的数据包含预期字段 - 对于已排序的映射，在签名/验证前先验证排序顺序\n时间戳验证： - 检查发布时间是否合理（不是过远的未来时间） - 验证租约未过期 - 考虑时钟偏差容差（典型值为 ±30 秒）\n网络数据库： - 在存储之前验证所有结构 - 强制执行大小限制以防止 DoS - 对查询和发布实施速率限制 - 验证数据库键与结构哈希匹配\n兼容性说明 向后兼容性： - ElGamal 和 DSA_SHA1 仍支持旧版 routers - 已弃用的密钥类型仍可用，但不建议使用 - 可压缩填充（Proposal 161 ）与 0.6 版本向后兼容\n前向兼容性: - 未知的密钥类型可以使用长度字段进行解析 - 未知的证书类型可以通过长度跳过 - 未知的签名类型应当被稳妥地处理 - 实现不应因未知的可选特性而失败\n迁移策略: - 在过渡期间同时支持新旧密钥类型 - LeaseSet2（LeaseSet 的第二版）可以列出多个加密密钥 - 离线签名实现安全的密钥轮换 - MetaLeaseSet（用于透明服务迁移的元 LeaseSet）实现透明的服务迁移\n测试与验证 结构验证： - 验证所有长度字段都在预期范围内 - 检查可变长度结构能被正确解析 - 验证签名能够成功通过校验 - 使用最小和最大尺寸的结构进行测试\n边界情况: - 零长度字符串 - 空映射 - 最小和最大租约数 - 有效载荷为零长度的证书 - 非常大的结构（接近最大大小）\n互操作性： - 对照官方 Java I2P 实现进行测试 - 验证与 i2pd 的兼容性 - 使用各种网络数据库（netDb）内容进行测试 - 对照已知正确的测试向量进行验证\n参考资料 规范 I2NP 协议 I2CP 协议 SSU2 传输 NTCP2 传输 Tunnel 协议 数据报协议 密码学 密码学概览 ElGamal/AES 加密 ECIES-X25519 加密 面向 Routers 的 ECIES ECIES 混合（后量子） Red25519 签名 加密的 LeaseSet 提案 提案 123：新的 netDB 条目 提案 134：GOST 签名类型 提案 136：实验性签名类型 提案 145：ECIES-P256 提案 156：ECIES Routers 提案 161：填充生成 提案 167：服务记录 提案 169：后量子密码学 全部提案索引 网络数据库 netDb 概览 RouterInfo 标准选项 JavaDoc API 参考 外部标准 RFC 7748 (X25519): 用于安全的椭圆曲线 RFC 7539 (ChaCha20): 用于 IETF 协议的 ChaCha20 和 Poly1305 RFC 4648 (Base64): Base16、Base32 和 Base64 数据编码 FIPS 180-4 (SHA-256): 安全散列标准 FIPS 204 (ML-DSA): 基于模格的数字签名标准 IANA 服务注册表 社区资源 I2P 网站 I2P 论坛 I2P GitLab I2P GitHub 镜像 技术文档索引 发布信息 I2P 2.10.0 发布 发布历史 更新日志 附录：快速参考表 密钥类型快速参考 当前标准（建议所有新的实现采用）： - 加密： X25519 (类型 4, 32 字节, 小端序) - 签名： EdDSA_SHA512_Ed25519 (类型 7, 32 字节, 小端序)\n旧版（受支持但已弃用）： - 加密： ElGamal (类型 0，256 字节，大端序) - 签名： DSA_SHA1 (类型 0，20 字节私钥 / 128 字节公钥，大端序)\n专用: - 签名（加密的 LeaseSet）: RedDSA_SHA512_Ed25519 (类型 11, 32 字节, 小端序)\n后量子（测试版，尚未最终确定）： - 混合加密： MLKEM_X25519 变体（类型 5-7） - 纯后量子加密： MLKEM（模块格密钥封装机制，Kyber）变体（尚未分配类型代码）\n结构大小速查表 Structure Minimum Size Typical Size Maximum Size Integer1 byteVaries8 bytes Date8 bytes8 bytes8 bytes String1 byteVaries256 bytes SessionKey32 bytes32 bytes32 bytes Hash32 bytes32 bytes32 bytes TunnelId4 bytes4 bytes4 bytes Certificate3 bytes7 bytes65,538 bytes KeysAndCert387 bytes391 bytes≈1000+ bytes RouterIdentity387 bytes391 bytes≈1000+ bytes Destination387 bytes391 bytes≈1000+ bytes Lease44 bytes44 bytes44 bytes Lease240 bytes40 bytes40 bytes LeaseSet≈1000 bytes≈1200 bytes≈2000+ bytes LeaseSet2≈500 bytes≈800 bytes≈2000+ bytes EncryptedLeaseSet≈600 bytes≈1000 bytes≈3000+ bytes RouterAddress≈150 bytes≈300 bytes≈600 bytes RouterInfo≈1000 bytes≈1500 bytes≈3000+ bytes ### 数据库类型速查表 Type Structure Status Notes 0RouterInfoCurrentStored under Hash(RouterIdentity) 1LeaseSetDeprecatedUse LeaseSet2 instead 3LeaseSet2CurrentStored under Hash(Destination) 5EncryptedLeaseSetCurrentStored under Hash(Blinded Destination) 7MetaLeaseSetDefinedVerify production status ### 传输协议快速参考 Protocol Status Port Type Since Notes SSU2CurrentUDP0.9.54Default since 0.9.56 NTCP2CurrentTCP0.9.36Active SSURemovedUDP-Removed in 2.4.0 NTCPRemovedTCP-Removed in 0.9.50 ### 版本里程碑快速参考 Version API Date Key Changes 0.60.6.x2005Destination encryption disabled 0.9.120.9.12Dec 2013Key Certificates introduced 0.9.150.9.15Sep 2015EdDSA support added 0.9.160.9.16Nov 2015Router Key Certificates 0.9.360.9.36Aug 2018NTCP2 introduced 0.9.380.9.38Nov 2018LeaseSet2, X25519 for Destinations 0.9.390.9.39Dec 2018EncryptedLeaseSet working 0.9.480.9.48Jul 2020X25519 for Router Identities 0.9.500.9.50May 2021NTCP removed 0.9.540.9.54May 2022SSU2 testing 0.9.570.9.57Jan 2023[Proposal 161](/zh/proposals/161-ri-dest-padding/) padding (release 2.1.0) 0.9.580.9.58Mar 2023ElGamal/DSA deprecated for RIs (2.2.0) 0.9.660.9.66Jun 2025[Proposal 167](/proposals/167-service-records/) service records (2.9.0) 0.9.670.9.67Sep 2025ML-KEM beta support (2.10.0) --- ","description":"I2P 规范中通用的共享数据类型与序列化格式","id":"178a1cfe9e5d2970a6e9f8d07c374b78","section":"docs","title":"通用结构","url":"/zh/docs/specs/common-structures/"},{"categories":null,"content":"1. 概述 clients.config 中的条目告诉 router 在启动时启动哪些应用程序。每个条目可以作为托管客户端(首选)或非托管客户端运行。托管客户端与 ClientAppManager 协作，后者：\n实例化应用程序并跟踪路由器控制台的生命周期状态 向用户提供启动/停止控制,并在路由器退出时强制执行干净的关闭 托管一个轻量级的客户端注册表和端口映射器,以便应用程序能够发现彼此的服务 非托管客户端仅调用 main() 方法;仅在无法现代化的遗留代码中使用它们。\n2. 实现托管客户端 托管客户端必须实现 net.i2p.app.ClientApp(用于面向用户的应用程序)或 net.i2p.router.app.RouterApp(用于 router 扩展)。提供以下构造函数之一,以便管理器可以提供上下文和配置参数:\npublic MyClientApp(I2PAppContext context, ClientAppManager manager, String[] args) public MyRouterApp(RouterContext context, ClientAppManager manager, String[] args) args 数组包含在 clients.config 或 clients.config.d/ 中各个文件里配置的值。尽可能扩展 ClientApp / RouterApp 辅助类以继承默认的生命周期连接。\n2.1 Lifecycle Methods 托管客户端应当实现:\nstartup() - 执行初始化并快速返回。必须至少调用一次 manager.notify() 以从 INITIALIZED 状态转换。 shutdown(String[] args) - 释放资源并停止后台线程。必须至少调用一次 manager.notify() 以将状态更改为 STOPPING 或 STOPPED。 getState() - 告知控制台应用程序是正在运行、启动中、停止中还是失败 当用户与控制台交互时,管理器会调用这些方法。\n2.2 Advantages 路由器控制台中的准确状态报告 干净的重启,无线程泄漏或静态引用 应用程序停止后更低的内存占用 通过注入的上下文实现集中式日志记录和错误报告 3. Unmanaged Clients (Fallback Mode) 如果配置的类未实现托管接口，路由器将通过调用 main(String[] args) 来启动它，并且无法跟踪生成的进程。控制台显示的信息有限，且关闭钩子可能不会运行。此模式仅保留给无法采用托管 API 的脚本或一次性实用程序使用。\n4. Client Registry 托管客户端和非托管客户端可以向管理器注册自身,以便其他组件可以通过名称检索引用:\nmanager.register(this); 注册使用客户端的 getName() 返回值作为注册表键。已知的注册包括 console、i2ptunnel、Jetty、outproxy 和 update。使用 ClientAppManager.getRegisteredApp(String name) 检索客户端以协调功能（例如，console 查询 Jetty 以获取状态详情）。\n注意，客户端注册表和端口映射器是两个独立的系统。客户端注册表通过名称查找实现应用程序间通信，而端口映射器将服务名称映射到主机:端口组合以实现服务发现。\n3. 非托管客户端(回退模式) 端口映射器为内部 TCP 服务提供了一个简单的目录。注册回环端口,以便协作者避免使用硬编码地址:\ncontext.portMapper().register(PortMapper.SVC_HTTPS_PROXY, 4445); 或使用显式主机指定:\ncontext.portMapper().register(PortMapper.SVC_HTTP_PROXY, \u0026#34;127.0.0.1\u0026#34;, 4444); 使用 PortMapper.getPort(String name)(如果未找到则返回 -1)或 getPort(String name, int defaultPort)(如果未找到则返回默认值)查找服务。使用 isRegistered(String name) 检查注册状态,并使用 getActualHost(String name) 获取已注册的主机。\n来自 net.i2p.util.PortMapper 的常见端口映射服务常量:\nSVC_CONSOLE - Router console(路由器控制台)(默认端口 7657) SVC_HTTP_PROXY - HTTP 代理(默认端口 4444) SVC_HTTPS_PROXY - HTTPS 代理(默认端口 4445) SVC_I2PTUNNEL - I2PTunnel 管理器 SVC_SAM - SAM bridge(默认端口 7656) SVC_SAM_SSL - SAM bridge SSL SVC_SAM_UDP - SAM UDP SVC_BOB - BOB bridge(默认端口 2827) SVC_EEPSITE - 标准 eepsite(默认端口 7658) SVC_HTTPS_EEPSITE - HTTPS eepsite SVC_IRC - IRC tunnel(默认端口 6668) SVC_SUSIDNS - SusiDNS 注意：httpclient、httpsclient 和 httpbidirclient 是 i2ptunnel tunnel 类型（用于 tunnel.N.type 配置），而不是端口映射器服务常量。\n4. 客户端注册表 2.1 生命周期方法 从 0.9.42 版本开始,router 支持将配置拆分为 clients.config.d/ 目录中的单个文件。每个文件包含单个客户端的属性,所有属性都以 clientApp.0. 为前缀:\nclientApp.0.main=net.i2p.router.web.RouterConsoleRunner clientApp.0.name=Router Console clientApp.0.args=7657 ::1,127.0.0.1 ./webapps/ clientApp.0.delay=0 clientApp.0.onBoot=true 这是新安装和插件的推荐方法。\n2.2 优势 为了向后兼容,传统格式使用顺序编号:\nclientApp.0.main=net.i2p.router.web.RouterConsoleRunner clientApp.0.name=Router Console clientApp.0.args=7657 ::1,127.0.0.1 ./webapps/ clientApp.1.main=net.i2p.apps.systray.UrlLauncher clientApp.1.name=URL Launcher clientApp.1.delay=5 6.3 Configuration Properties 必需： - main - 实现 ClientApp 或 RouterApp 的完整类名，或包含静态 main(String[] args) 方法的类名\n可选： - name - router console 的显示名称（默认为类名）- args - 空格或制表符分隔的参数（支持带引号的字符串）- delay - 启动前的延迟秒数（默认 120）- onBoot - 如果为 true 则强制 delay=0 - startOnLoad - 启用/禁用客户端（默认 true）\n插件特定配置： - stopargs - 关闭时传递的参数 - uninstallargs - 插件卸载时传递的参数 - classpath - 以逗号分隔的额外 classpath 条目\n插件的变量替换： - $I2P - I2P 基础目录 - $CONFIG - 用户配置目录（例如，~/.i2p） - $PLUGIN - 插件目录 - $OS - 操作系统名称 - $ARCH - 架构名称\n5. 端口映射器 优先使用托管客户端；仅在绝对必要时才回退到非托管客户端。 保持初始化和关闭过程轻量化,以确保控制台操作保持响应。 使用描述性的注册表和端口名称,以便诊断工具(和最终用户)了解服务的作用。 避免使用静态单例 - 依赖注入的上下文和管理器来共享资源。 在所有状态转换时调用 manager.notify() 以维护准确的控制台状态。 如果必须在单独的 JVM 中运行,请记录如何将日志和诊断信息呈现到主控制台。 对于外部程序,考虑使用 ShellService(在 1.7.0 版本中添加)以获得托管客户端的优势。 6. 配置格式 托管客户端在 0.9.4 版本（2012 年 12 月 17 日）中引入，并且截至 2.10.0 版本（2025 年 9 月 9 日）仍然是推荐的架构。在此期间，核心 API 保持稳定，没有任何破坏性变更：\n构造函数签名保持不变 生命周期方法(startup、shutdown、getState)保持不变 ClientAppManager 注册方法保持不变 PortMapper 注册和查找方法保持不变 重要改进： - 0.9.42 (2019) - clients.config.d/ 目录结构，用于存放独立配置文件 - 1.7.0 (2021) - 新增 ShellService，用于外部程序状态跟踪 - 2.10.0 (2025) - 当前版本，managed client API 无变更\n下一个主要版本将要求至少 Java 17+（基础设施要求,而非 API 变更）。\nReferences clients.config 规范 配置文件规范 I2P 技术文档索引 ClientAppManager Javadoc (API 0.9.66) PortMapper Javadoc (API 0.9.66) ClientApp 接口 (API 0.9.66) RouterApp 接口 (API 0.9.66) 备用 Javadoc (稳定版) 备用 Javadoc (明网镜像) 注意： I2P 网络在 http://idk.i 2p/javadoc-i2p/ 托管了完整的文档，访问需要 I2P router。如需通过明网访问，请使用上述 GitHub Pages 镜像。\n","description":"路由器管理的应用程序如何与 ClientAppManager 和端口映射器集成","id":"f9e2324a49e9ed9bf413b4c636d5d1b6","section":"docs","title":"托管客户端","url":"/zh/docs/applications/managed-clients/"},{"categories":null,"content":" 1. 概述 netDb 是一个专用的分布式数据库，仅包含两类数据： - RouterInfos – router 的联系信息 - LeaseSets – 目的地的联系信息\n所有数据都经过密码学签名且可验证。每个条目都包含存活性信息，用于丢弃过时条目并替换陈旧条目，从而防范某些类别的攻击。\n分发采用 floodfill 机制，其中一部分 routers 负责维护分布式数据库。\n2. RouterInfo（路由器信息） 当 routers 需要联系其他 routers 时，它们会交换包含以下内容的 RouterInfo 包：\nRouter 身份 – 加密密钥、签名密钥、证书 联系地址 – 如何联系该 router 发布时间戳 – 该信息的发布时间 任意文本选项 – 能力标志与设置 密码学签名 – 证明真实性 2.1 能力标志位 各 Router 会通过其 RouterInfo（Router 信息）中的字母代码来通告其能力：\nFlag Meaning f Floodfill participation R Reachable U Unreachable D, E, G, H Various capability indicators ### 2.2 带宽分类 Code Bandwidth K Under 12 KBps L 12–48 KBps (default) M 48–64 KBps N 64–128 KBps O 128–256 KBps P 256–2000 KBps X Over 2000 KBps ### 2.3 网络ID取值 Value Purpose 0 Reserved 1 Current Network (default) 2 Reserved for Future Networks 3–15 Forks and Test Networks 16–254 Reserved 255 Reserved ### 2.4 RouterInfo 统计 Routers 发布可选的健康统计数据，用于网络分析： - 探索性 tunnel 构建成功/拒绝/超时率 - 1 小时平均参与 tunnel 数量\n统计数据遵循 stat_(statname).(statperiod) 格式，值以分号分隔。\n示例统计：\nstat_tunnel.buildExploratoryExpire.60m = 0;0;0;53.14 stat_tunnel.buildExploratoryReject.60m = 0;0;0;15.51 stat_tunnel.buildExploratorySuccess.60m = 0;0;0;31.35 stat_tunnel.participatingTunnels.60m = 289.20 Floodfill routers 还可能发布：netdb.knownLeaseSets 和 netdb.knownRouters\n2.5 家族选项 自 0.9.24 版本起，routers 可以声明家族成员关系（同一运营者）：\nfamily: 家族名称 family.key: 签名类型代码与 base64 编码的签名公钥拼接而成 family.sig: 对家族名称与 32 字节的 router 哈希的签名 同一家族中的多个 router 不会用于同一个 tunnel。\n2.6 RouterInfo（路由器信息）过期 启动后的第一个小时内不过期 当已存储的 RouterInfos（路由信息对象）不超过 25 个时不过期 随着本地存储数量增加，过期时间会缩短（少于 120 个 routers 时为 72 小时；300 个 routers 时约为 30 小时） SSU 引介者约在 1 小时后过期 Floodfills 对所有本地 RouterInfos 使用 1 小时的过期时间 3. LeaseSet（用于描述目的地可达性与入站 tunnel 租约的元数据） LeaseSets 会记录针对特定目的地的 tunnel 入口点，并指定：\nTunnel 网关 router 身份 4 字节的 tunnel ID Tunnel 过期时间 LeaseSets 包含： - Destination – 加密密钥、签名密钥、证书 - 附加加密公钥 – 用于端到端 garlic encryption（大蒜加密） - 附加签名公钥 – 用于吊销（当前未使用） - 密码学签名\n3.1 LeaseSet 变体 Type Description Unpublished Destinations used only for outgoing connections aren't published to floodfill routers Revoked Published with zero leases, signed by additional signing key (not fully implemented) LeaseSet2 (LS2) As of 0.9.38, supports new encryption types, multiple encryption types, options, offline signing keys ([Proposal 123](/proposals/123-new-netdb-entries/)) Meta LeaseSet Tree-like DHT structure for multihomed services, supporting hundreds/thousands of destinations with long expirations (up to 18.2 hours) Encrypted LeaseSet (LS1) All leases encrypted with separate key; only those with the key can decode and contact the destination Encrypted LeaseSet (LS2) As of 0.9.38, destination hidden with only blinded public key and expiration visible to floodfill ### 3.2 LeaseSet 过期 常规 LeaseSets 会在其最晚的租约到期时过期。LeaseSet2 的到期时间在头部中指定。EncryptedLeaseSet 和 MetaLeaseSet 的到期时间可能不同，并可能会施加最大值限制。\n4. 引导 去中心化的 netDb 需要至少一个对等节点引用才能接入。Reseeding（重新引导） 会从志愿者的 netDb 目录中获取 RouterInfo 文件（routerInfo-$hash.dat）。首次启动会自动从随机选取的硬编码 URL 获取。\n5. Floodfill 机制 floodfill netDb 采用简单的分布式存储：将数据发送给最接近的 floodfill 节点。当非 floodfill 节点发送存储消息（store）时，floodfill 会将其转发给与该特定键最接近的那部分 floodfill 节点。\nFloodfill 的参与情况在 RouterInfo 中以能力标志（f）表示。\n5.1 Floodfill 选择加入要求 不同于 Tor 的硬编码的可信目录服务器，I2P 的 floodfill（在 I2P 中用于分发 netDb 的节点角色）集合是不受信任的，并且会随着时间变化。\nFloodfill 仅会在满足以下要求的高带宽 router 上自动启用: - 至少 128 KBytes/sec 的共享带宽 (手动配置) - 必须通过额外的健康检查 (出站消息队列时间、作业延迟)\n当前的自动选择加入带来约6% 的网络 floodfill 参与率。\n手动配置的 floodfill 与自动志愿成为 floodfill 的 routers 并存。当 floodfill 数量低于阈值时，高带宽的 routers 会自动志愿成为 floodfill。当 floodfill 数量过多时，它们会停止充当 floodfill。\n5.2 Floodfill 角色 除了接受 netDb 的存储操作并响应查询之外，floodfills 还执行标准的 router 功能。它们更高的带宽通常意味着更高的 tunnel 参与度，但这与数据库服务并无直接关系。\n6. Kademlia 接近度度量 netDb 使用基于 XOR（异或）的 Kademlia 风格 距离度量。RouterIdentity 或 Destination 的 SHA256 哈希用于生成 Kademlia 键（LS2 加密的 LeaseSets 除外；对于这类情况，键为对“类型字节 3 与盲化公钥拼接”的 SHA256）。\n6.1 键空间轮换 为了提高 Sybil 攻击成本，系统不使用 SHA256(key)，而是使用：\nSHA256(key + yyyyMMdd) 其中，日期是一个 8 字节的 ASCII UTC 日期。这会生成 routing key（路由密钥），在每天的 UTC 午夜更换——称为 keyspace rotation（密钥空间轮换）。\nRouting keys（路由密钥）从不会在 I2NP 消息中传输；它们仅用于本地距离判定。\n7. 网络数据库分段 传统的 Kademlia DHT 无法保证存储信息的不可关联性。I2P 通过实现分段来防止将客户端 tunnels 与 routers 关联起来的攻击。\n7.1 分段策略 router 会跟踪：\n条目是通过 client tunnel 到达，还是直接到达 如果是通过 tunnel，到达的是哪个 client tunnel/目标 会跟踪通过多个 tunnel 到达的情况 会区分存储与查找的回复 Java 和 C++ 的实现都使用： - 一个 \u0026ldquo;Main\u0026rdquo; netDb，用于在 router 上下文中进行直接查找/floodfill 操作 - 在客户端上下文中的 \u0026ldquo;Client Network Databases\u0026rdquo; 或 \u0026ldquo;Sub-Databases\u0026rdquo;，用于捕获发送到客户端 tunnel 的条目\n客户端的 netDbs（网络数据库）仅在客户端的生命周期内存在，只包含客户端 tunnel（隧道）条目。来自客户端 tunnel 的条目不能与直接到达的条目重叠。\n每个 netDb 都会记录条目是以存储（可响应查找请求）的形式到达，还是以查找回复（仅在此前已向同一目标存储过时才响应）的形式到达。客户端从不使用主 netDb 中的条目来回答查询，只会使用客户端网络数据库条目。\n综合策略会将 netDb 分片，以抵御客户端与 router 的关联攻击。\n8. 存储、验证与查找 8.1 将 RouterInfo（路由器信息）存储到对等节点 在 NTCP（I2P 基于 TCP 的传输协议）或 SSU 传输连接初始化期间用于交换本地 RouterInfo（路由器信息）的 I2NP DatabaseStoreMessage。\n8.2 向对等节点存储 LeaseSet 包含本地 LeaseSet 的 I2NP DatabaseStoreMessage 会通过捆绑在 Destination 流量中的、经由 garlic encryption（I2P 特有的“garlic”聚合加密）加密的消息定期交换，从而在无需进行 LeaseSet 查找的情况下即可获得响应。\n8.3 Floodfill 选择 DatabaseStoreMessage 会被发送到最接近当前路由键的 floodfill。通过本地数据库搜索来找到最近的 floodfill。即使实际上并非最近，泛洪也会通过向多个 floodfill 发送，使其“更接近”。\n传统 Kademlia 在插入之前使用“find-closest（查找最近）”搜索。尽管 I2NP 缺少此类消息，routers 仍可通过将键的最低有效位取反（key ^ 0x01）来进行迭代式搜索，以确保真正发现最近邻节点。\n8.4 将 RouterInfo（路由信息）存储到 floodfills router 通过直接连接到一个 floodfill，发送带有非零 Reply Token 的 I2NP DatabaseStoreMessage 来发布 RouterInfo（路由信息）。该消息未进行端到端的 garlic encryption（直接连接，无中间节点）。floodfill 使用 Reply Token 作为 Message ID，回复一个 DeliveryStatusMessage。\nrouters 也可能通过探索型 tunnel 发送 RouterInfo（连接数限制、不兼容、隐藏 IP）。floodfill 节点在过载时可能会拒绝此类存储请求。\n8.5 将 LeaseSet 存储到 Floodfills LeaseSet（I2P 租约集合）的存储比 RouterInfo（I2P 路由信息记录）更为敏感。Routers（I2P 路由器）必须防止 LeaseSet 与其自身发生关联。\nRouters 通过出站客户端 tunnel 发送带非零 Reply Token（回复令牌）的 DatabaseStoreMessage 来发布 LeaseSet。该消息使用 Destination\u0026rsquo;s Session Key Manager（Destination 的会话密钥管理器）进行端到端的 garlic encryption，从而对该 tunnel 的出站端点不可见。floodfill 通过入站 tunnel 返回 DeliveryStatusMessage 进行回复。\n8.6 洪泛过程 floodfill（目录填充节点）在本地存储之前，会使用依赖于负载、netdb 大小及其他因素的自适应准则验证 RouterInfo/LeaseSet。\n在接收到有效的较新数据后，floodfill 会查找与路由键最近的 3 个 floodfill router，并对其进行\u0026quot;flood\u0026quot;传播。它会通过直接连接发送带零 Reply Token（回复令牌）的 I2NP DatabaseStoreMessage。其他 router 不会回复，也不会再次泛洪。\n重要约束： - Floodfills 不得通过 tunnels 进行泛洪；仅允许直接连接 - Floodfills 从不泛洪已过期的 LeaseSet，或发布超过一小时的 RouterInfo（路由器信息数据结构）\n8.7 RouterInfo（路由器信息）与 LeaseSet 查找 I2NP DatabaseLookupMessage 会向 floodfill routers（负责存储和传播 netdb 的特殊 router）请求 netdb 条目。查询通过出站探索 tunnel 发送；回复会指定入站探索 tunnel 作为返回路径。\n查询通常会并行发送到两个距离所请求键最近的“良好”的 floodfill routers。\n本地匹配: 接收 I2NP DatabaseStoreMessage 响应 无本地匹配: 接收 I2NP DatabaseSearchReplyMessage，其中包含接近该键的其他 floodfill router 的引用 自 0.9.5 起，LeaseSet 查找使用端到端 garlic encryption。由于 ElGamal 的开销，RouterInfo（路由信息）查找未加密，因此容易遭受出站端点嗅探。\n自 0.9.7 起，查找响应包含会话密钥和标签，从而对入站网关隐藏响应。\n8.8 迭代查找 0.8.9 之前：两个并行的冗余查找，不使用递归或迭代路由。\n自 0.8.9 起：迭代查找 采用无冗余实现——更高效、更可靠，且更适合 floodfill 知识不完整的情况。随着网络规模增长且 routers 了解的 floodfills 更少，查找的复杂度趋近于 O(log n)。\n即使没有更近的节点引用，迭代查询也会继续，从而防止恶意黑洞行为。当前的最大查询次数和超时设置仍然适用。\n8.9 验证 RouterInfo 验证: 自 0.9.7.1 起已禁用，以防止 \u0026ldquo;Practical Attacks Against the I2P Network\u0026rdquo; 论文中描述的攻击。\nLeaseSet 验证: Routers 等待约 10 秒，然后通过出站客户端 tunnel 向不同的 floodfill 进行查找。端到端的 garlic encryption（大蒜式加密，一种将多条消息封装在一起的 I2P 加密方式）使其对出站端点不可见。响应通过入站 tunnels 返回。\n自 0.9.7 起，回复以会话密钥/标签隐藏（session key/tag hiding）的方式加密，从而对入站网关（inbound gateway）不可见。\n8.10 探索 探索（Exploration） 涉及使用随机键进行 netdb 查询，以发现新的 routers。Floodfills 会返回包含与所请求键接近的非 floodfill router 哈希的 DatabaseSearchReplyMessage。Exploration 查询会在 DatabaseLookupMessage 中设置一个特殊标志位。\n9. 多宿主 使用相同私钥/公钥（传统的 eepPriv.dat）的 Destination（目标地址）可以在多个 router 上同时托管。每个实例都会定期发布已签名的 LeaseSet；对查找请求的响应会返回最新发布的 LeaseSet。 在 LeaseSet 的最长有效期为 10 分钟的情况下，中断最多持续约 10 分钟。\n自 0.9.38 起，Meta LeaseSets（元 LeaseSet，指可聚合多个 Destination 的 LeaseSet 类型）支持使用提供相同服务的独立 Destinations（I2P 目的地标识）的大型多宿主服务。Meta LeaseSet 条目可以是 Destinations 或其他 Meta LeaseSets，且有效期可长达 18.2 小时，从而允许数百/数千个 Destinations 承载相同的服务。\n10. 威胁分析 目前约有 1700 个 floodfill routers 正在运行。随着网络的增长，大多数攻击变得更难实施，或影响更小。\n10.1 通用缓解措施 增长: 更多的 floodfill routers 会使攻击更难实施或影响更小 冗余: 所有 netdb 条目会通过泛洪存储在距离该密钥最近的 3 个 floodfill routers 上 签名: 所有条目均由创建者签名；无法伪造 10.2 缓慢或无响应的 Routers Routers 为 floodfills 维护扩展的对等节点档案统计信息： - 平均响应时间 - 查询应答百分比 - 存储验证成功百分比 - 上次成功存储 - 上次成功查找 - 上次响应\nrouter 在为选择最近的 floodfill 判定 \u0026ldquo;goodness\u0026rdquo;（优良度）时，会使用这些度量指标。完全无响应的 router 会被迅速识别并规避；部分恶意的 router 则带来更大的挑战。\n10.3 女巫攻击 (完整键空间) 攻击者可能在整个键空间中创建大量 floodfill routers，从而实施一种有效的拒绝服务（DoS）攻击。\nIf 行为不足以被指定为\u0026quot;bad\u0026quot;，可能的应对包括: - 通过控制台新闻、网站、论坛公布并汇编不良 router 哈希/IP 列表 - 在全网启用 floodfill (\u0026ldquo;用更多的 Sybil（女巫攻击）对抗 Sybil\u0026rdquo;) - 在新软件版本中硬编码\u0026quot;bad\u0026quot;列表 - 改进 peer profile（对等节点画像）的指标与阈值以便自动识别 - 基于 IP 网段的资格限制，禁止同一 IP 网段内存在多个 floodfill - 基于订阅的自动黑名单（类似 Tor 的共识）\n更大的网络会使这变得更难。\n10.4 Sybil 攻击（部分键空间） 攻击者可能创建 8–15 个在键空间中紧密聚集的 floodfill routers。针对该键空间的所有查找/存储都会被定向到攻击者的 routers，从而能够对特定的 I2P 站点实施 DoS（拒绝服务）攻击。\n由于键空间对加密的 SHA256 哈希进行索引，攻击者需要采用暴力穷举，才能生成与目标在键空间中足够接近的 routers。\n防御：Kademlia（分布式哈希表 DHT 算法）的接近度算法会随时间变化，使用 SHA256(key + YYYYMMDD)，并在 UTC 午夜每日变更。这样的键空间轮换迫使攻击者每天重新构建其攻击。\n注意: 最新研究表明，密钥空间轮换的效果并不显著——攻击者可以预先计算 router 哈希值，只需几个 routers 即可在轮换后半小时内对密钥空间的部分区域实施日蚀。\n每日轮换的后果：分布式 netdb 在轮换后的几分钟内会变得不可靠——在新的最近 router 接收到存储条目之前，查询会失败。\n10.5 引导攻击 攻击者可能接管 reseed 网站（用于新节点初始引导获取网络信息的站点），或诱骗开发者添加带有敌意的 reseed 网站，从而使新的 router 在启动时进入被隔离/多数控制的网络。\n已实施的防御措施： - 从多个 reseed（重新播种）站点获取 RouterInfo 子集，而不是单一站点 - 网络外部的 reseed 监控定期轮询站点 - 自 0.9.14 起，reseed 数据包为签名的 zip 文件，并对下载的签名进行验证（参见 su3 specification ）\n10.6 查询捕获 Floodfill routers 可能会通过所返回的引用将对等节点\u0026quot;引导\u0026quot;至攻击者控制的 routers。\n由于频率较低，通过探索获得的可能性不大；router 获取对等节点引用主要依赖于正常的 tunnel 构建。\n自 0.8.9 起，已实现迭代查找。DatabaseSearchReplyMessage 中返回的 floodfill 引用如果更接近查找键，则会被继续跟进。发起请求的 router 不会信任这些引用所声称的接近度。即便没有更近的键，查找仍会继续，直到超时或达到查询上限，从而防止恶意黑洞攻击。\n10.7 信息泄露 I2P 中的 DHT（分布式哈希表）信息泄露需要进一步调查。Floodfill routers 会通过观察查询来收集信息。当恶意节点占比达到 20% 时，先前描述的 Sybil 攻击威胁会因多种原因而变得严重。\n11. 未来工作 对额外的 netDb 查询和响应进行端到端加密 更好的查询响应跟踪方法 针对键空间轮换可靠性问题的缓解方法 12. 参考文献 通用结构规范 – RouterInfo（路由器信息）和 LeaseSet（租约集合）结构 I2NP（I2P 网络协议）规范 – 数据库消息类型 提案 123：新的 netDb（网络数据库）条目 – LeaseSet2（第二代 LeaseSet）规范 历史 netDb 讨论 – 开发历史和已归档的讨论 ","description":"理解 I2P 的分布式网络数据库（netDb） - 一种用于 router 联系信息与目的地（Destination）查找的专用 DHT（分布式哈希表）","id":"ef0a5e8bee4372a50a7f4562af717b0c","section":"docs","title":"网络数据库","url":"/zh/docs/overview/network-database/"},{"categories":null,"content":" 注意： 本存档讨论概述了针对网络数据库（netDb）的历史性方法。有关当前行为和指导，请参阅netDb 主文档 。\n历史 I2P 的 netDb 使用一种简单的 floodfill 算法进行分发。早期版本还保留了一个 Kademlia DHT 的后备实现，但事实证明它不可靠，并在 0.6.1.20 版本中被完全禁用。floodfill 的设计会将发布的条目转发给一个参与的 router，等待确认，并在必要时与其他 floodfill 对等体重试。floodfill 对等体会将来自非 floodfill router 的存储消息广播给所有其他 floodfill 参与者。\n在2009年末，为了减轻各个 floodfill routers 的存储负担，Kademlia 查询被部分重新引入。\nfloodfill 简介 floodfill 最初出现在 0.6.0.4 版本中，而 Kademlia（一种分布式哈希表算法）仍作为后备方案可用。当时，严重的丢包和受限的路由使得从四个最近的对等节点获取确认变得困难，往往需要进行数十次冗余的存储尝试。转而采用由外部可达 routers 组成的 floodfill 子集，提供了一个务实的短期解决方案。\n重新思考 Kademlia（分布式哈希表协议） 曾考虑的替代方案包括：\n将 netDb 作为 Kademlia DHT（Kademlia 分布式哈希表）运行，且仅限选择参与并可达的 routers 保留 floodfill 模型，但将参与限制为有能力的 routers，并通过随机检查验证分布情况 floodfill 方法之所以胜出，是因为它更易于部署，而且 netDb 只承载元数据，而不承载用户数据。大多数目的地从不发布 LeaseSet，因为发送方通常会在 garlic messages（I2P 中用于将多条消息捆绑的封装机制）中捆绑其 LeaseSet。\n当前状态（历史视角） netDb（网络数据库）算法经过针对网络需求的调优，并且从历史上看可以从容应对几百个 router。早期的估算表明，3–5 个 floodfill router（负责存储和分发 netDb 条目的特殊 router）即可支撑大约 10,000 个节点。\n更新的计算（2008年3月） recvKBps = N * (L + 1) * (1 + F) * (1 + R) * S / T 其中：\nN: 网络中的 Routers 数量 L: 每个 router 的客户端目的地平均数量（另加一个用于 RouterInfo） F: Tunnel 失败百分比 R: 以 Tunnel 生命周期的分数表示的重建周期 S: 平均 netDb 条目大小 T: Tunnel 生命周期 使用 2008 年时期的参数取值（N = 700，L = 0.5，F = 0.33，R = 0.5，S = 4 KB，T = 10 minutes）得到：\nrecvKBps ≈ 700 * (0.5 + 1) * (1 + 0.33) * (1 + 0.5) * 4 KB / 10m ≈ 28 KBps Kademlia（DHT 分布式哈希表算法）会回归吗？ 开发者在2007年初左右讨论了重新引入 Kademlia（分布式哈希表算法）。共识是：可以按需逐步扩展 floodfill 的容量，而 Kademlia 会为普通的 router 群体带来显著的复杂性和资源需求。除非 floodfill 容量变得不足，否则后备机制保持休眠状态。\nFloodfill 容量规划 将带宽等级为 O 的 routers 自动纳入 floodfill，虽然很有诱惑力，但如果敌对节点选择加入，则可能引发拒绝服务（DoS）场景的风险。历史分析表明，限制 floodfill 池（例如由 3–5 个对等体处理 ~10K 个 routers）更为安全。为维持一个既充足又受控的 floodfill 集，曾采用受信任的运营者或自动启发式方法。\nFloodfill 待办事项（历史） 本部分保留以作存档。netDb（网络数据库）主页面跟踪当前的路线图和设计考量。\n诸如 2008 年 3 月 13 日期间仅有一个可用的 floodfill router 之类的运行事件，促使在 0.6.1.33 至 0.7.x 版本中交付了多项改进，包括：\n随机化用于搜索的 floodfill 选择，并优先选择响应迅速的节点 在 router 控制台的 \u0026ldquo;Profiles\u0026rdquo; 页面显示更多 floodfill 指标 逐步缩小 netDb 条目大小，以降低 floodfill 带宽占用 基于通过节点档案数据收集到的性能，为部分 class O routers 自动选择加入 增强的封锁列表、floodfill 节点选择及探索启发式 那个时期遗留下来的想法包括：\n使用 dbHistory 统计数据以更好地评估并选择 floodfill 对等节点 改进重试行为，避免反复联系故障对等节点 在选择过程中利用时延指标和 integration（集成）评分 更快速地检测并响应故障的 floodfill routers 继续降低对高带宽节点和 floodfill 节点的资源需求 即便在撰写这些说明时，网络仍被认为具有较强的弹性，并已建立起相应的基础设施，可以快速应对敌对的 floodfills 或以 floodfill 为目标的拒绝服务攻击。\n补充说明 router 控制台长期提供了增强的画像数据，以帮助分析 floodfill 的可靠性。 虽然历史上的一些评论曾推测采用 Kademlia 或其他分布式哈希表（DHT）方案，但在生产网络中，floodfill 仍然是主要算法。 前瞻性研究致力于在限制滥用机会的同时，使 floodfill 的准入具备自适应能力。 ","description":"关于 floodfill、Kademlia（分布式哈希表算法）实验，以及对 netDb 的未来调优的历史说明","id":"0ddefeec5b7108b36649c4d989bf474e","section":"docs","title":"网络数据库讨论","url":"/zh/docs/netdb/"},{"categories":null,"content":"本指南展示如何配置常见浏览器通过 I2P 内置的 HTTP 代理发送流量。内容涵盖 Safari、Firefox 和 Chrome/Chromium 浏览器，并提供详细的分步说明。\n重要说明：\nI2P 的默认 HTTP 代理监听在 127.0.0.1:4444。 I2P 保护 I2P 网络内部的流量(.i2p 站点)。 在配置浏览器之前,请确保你的 I2P router 正在运行。 Safari (macOS) Safari 在 macOS 上使用系统级代理设置。\nStep 1: Open Network Settings 打开 Safari 并前往 Safari → 设置（或 偏好设置） 点击 高级 标签页 在 代理 部分，点击 更改设置\u0026hellip; 这将打开您 Mac 的系统网络设置。\n步骤 1:打开网络设置 在网络设置中,勾选 Web 代理 (HTTP) 复选框 输入以下内容: Web 代理服务器: 127.0.0.1 端口: 4444 点击 确定 保存设置 现在您可以在 Safari 中浏览 .i2p 站点了!\n注意:这些代理设置将影响所有使用 macOS 系统代理的应用程序。如果您想隔离 I2P 浏览,请考虑创建单独的用户账户或使用专门用于 I2P 的浏览器。\nFirefox (Desktop) Firefox 拥有独立于系统的代理设置,非常适合用于专门的 I2P 浏览。\n步骤 2：配置 HTTP 代理 点击右上角的菜单按钮(☰) 选择设置 Step 2: Find Proxy Settings 在设置搜索框中，输入 \u0026ldquo;proxy\u0026rdquo; 滚动到 网络设置 点击 设置\u0026hellip; 按钮 步骤 1：打开设置 选择 手动代理配置 输入以下内容: HTTP 代理: 127.0.0.1 端口: 4444 将 SOCKS 主机 留空(除非您特别需要 SOCKS 代理) 仅在使用 SOCKS 代理时勾选 使用 SOCKS 时代理 DNS 点击 确定 保存 您现在可以在 Firefox 中浏览 .i2p 站点了!\n提示: 考虑创建一个专门用于 I2P 浏览的独立 Firefox 配置文件。这样可以将您的 I2P 浏览与常规浏览隔离开来。要创建配置文件,请在 Firefox 地址栏中输入 about:profiles。\nChrome / Chromium (Desktop) Chrome 和基于 Chromium 的浏览器(Brave、Edge 等)在 Windows 和 macOS 上通常使用系统代理设置。本指南展示 Windows 配置。\n步骤 2:查找代理设置 点击右上角的三点菜单（⋮） 选择设置 步骤 3：配置手动代理 在设置搜索框中，输入 \u0026ldquo;proxy\u0026rdquo; 点击 打开计算机的代理设置 Step 3: Open Manual Proxy Setup 这将打开 Windows 网络和 Internet 设置。\n向下滚动到 手动代理设置 点击 设置 步骤 1:打开 Chrome 设置 将使用代理服务器切换为开启 输入以下内容: 代理 IP 地址: 127.0.0.1 端口: 4444 可选操作:在**\u0026ldquo;对于以下开头的地址不使用代理服务器\u0026rdquo;**中添加例外(例如 localhost;127.*) 点击保存 你现在可以在 Chrome 中浏览 .i2p 站点了!\n注意：这些设置会影响 Windows 上所有基于 Chromium 的浏览器以及其他一些应用程序。为避免这种情况，请考虑使用 Firefox 并配置专用的 I2P 配置文件。\n步骤 2:打开代理设置 在 Linux 上,你可以使用代理参数启动 Chrome/Chromium,以避免更改系统设置:\nchromium \\ --proxy-server=\u0026#34;http=127.0.0.1:4444 \\ --proxy-bypass-list=\u0026#34;\u0026lt;-loopback\u0026gt;\u0026#34; 或者创建一个桌面启动器脚本:\n#!/bin/bash chromium --proxy-server=\u0026#34;http=127.0.0.1:4444\u0026#34; --user-data-dir=\u0026#34;$HOME/.config/chromium-i2p\u0026#34; --user-data-dir 标志为 I2P 浏览创建一个独立的 Chrome 配置文件。\nFirefox (桌面版) 现代的 \u0026ldquo;Fenix\u0026rdquo; Firefox 版本默认限制 about:config 和扩展功能。IceRaven 是一个 Firefox 分支，它启用了一组精选的扩展，使代理设置变得简单。\n基于扩展的配置 (IceRaven):\n如果您已经在使用 IceRaven,请考虑先清除浏览历史记录(菜单 → 历史记录 → 删除历史记录)。2) 打开菜单 → 附加组件 → 附加组件管理器。3) 安装扩展程序\u0026quot;I2P Proxy for Android and Other Systems\u0026quot;。4) 浏览器现在将通过 I2P 代理。 如果从 AMO 安装,此扩展也可在基于 Fenix 之前版本的 Firefox 浏览器上使用。\n在 Firefox Nightly 中启用广泛的扩展支持需要单独的步骤，Mozilla 已有文档说明 。\nInternet Explorer / Windows System Proxy 在 Windows 上,系统代理对话框适用于 IE,并且可以被基于 Chromium 的浏览器在继承系统设置时使用。\n打开\u0026quot;网络和 Internet 设置\u0026quot;→\u0026ldquo;代理\u0026rdquo;。2) 启用\u0026quot;为局域网使用代理服务器\u0026quot;。3) 设置地址 127.0.0.1,端口 4444 用于 HTTP。4) 可选择勾选\u0026quot;对于本地地址不使用代理服务器\u0026quot;。 ","description":"在桌面和 Android 上配置常用浏览器以使用 I2P 的 HTTP/HTTPS 代理","id":"a40410c542dc82558c1c1a8be78d2e62","section":"docs","title":"网页浏览器配置","url":"/zh/docs/guides/browser-config/"},{"categories":null,"content":"所以你想开始为 I2P 做贡献？太好了！这里有一个快速指南，帮助你开始为网站或软件做贡献、进行开发或创建翻译。\n还没准备好编程？先尝试参与进来 。\n了解 Java I2P router及其嵌入式应用程序使用Java作为主要开发语言。如果您没有Java经验,可以随时查看Thinking in Java 学习操作入门、其他\u0026quot;操作指南\u0026quot;文档、技术介绍以及相关文档：\n介绍指南：I2P 简介 文档中心：文档 技术介绍：技术简介 这些将为您提供关于 I2P 结构以及其不同功能的良好概述。\n获取 I2P 代码 对于 I2P router 或嵌入式应用程序的开发,您需要获取源代码。\n我们当前的方式：Git I2P 拥有官方的 Git 服务，并通过我们自己的 GitLab 接受贡献：\nI2P 内部：http://git.idk.i2p I2P 外部：https://i2pgit.org 克隆主仓库：\ngit clone https://i2pgit.org/I2P_Developers/i2p.i2p.git GitHub 上也提供只读镜像：\nGitHub 镜像：github.com/i2p/i2p.i2p git clone https://github.com/i2p/i2p.i2p.git 构建 I2P 要编译代码,你需要 Sun/Oracle Java Development Kit 6 或更高版本,或等效的 JDK(强烈推荐使用 Sun/Oracle JDK 6)以及 Apache Ant 1.7.0 或更高版本。如果你正在处理主要的 I2P 代码,请进入 i2p.i2p 目录并运行 ant 来查看构建选项。\n要构建或处理控制台翻译，您需要 GNU gettext 软件包中的 xgettext、msgfmt 和 msgmerge 工具。\n对于新应用程序的开发，请参阅应用程序开发指南 。\n开发想法 查看项目 TODO 列表或 GitLab 上的问题列表以获取想法：\nGitLab 问题：i2pgit.org/I2P_Developers/i2p.i2p/issues 提供结果 请参阅许可证页面底部了解提交权限要求。您需要这些权限才能将代码提交到 i2p.i2p（网站不需要！）。\n许可证页面 了解我们！ 开发者们经常在 IRC 上活动。您可以在各种网络以及 I2P 内部网络上找到他们。通常可以在 #i2p-dev 频道找到他们。加入频道并打个招呼吧!我们还为常规开发者提供了额外的指南 。\n翻译 网站和路由器控制台翻译者：请查看新翻译者指南 了解后续步骤。\n工具 I2P是开源软件,主要使用开源工具包开发。I2P项目最近获得了YourKit Java Profiler的许可证。开源项目有资格获得免费许可证,前提是在项目网站上引用YourKit。如果您有兴趣对I2P代码库进行性能分析,请与我们联系。\nYourKit 慷慨地以其全功能分析器支持开源项目。YourKit, LLC 是用于分析 Java 和 .NET 应用程序的创新智能工具的创造者。了解一下 YourKit 的领先软件产品：\nYourKit Java Profiler YourKit .NET Profiler ","description":"如何开始为 I2P 做贡献：学习材料、源代码、构建、想法、发布、社区、翻译和工具","id":"e74ff72be9767cc925c6712e11e5e1c5","section":"docs","title":"新开发者指南","url":"/zh/docs/develop/new-developers/"},{"categories":null,"content":"想要帮助让 I2P 惠及全球更多的人吗?翻译是您能为项目做出的最有价值的贡献之一。本指南将引导您完成 router console 的翻译工作。\n翻译方法 有两种方式可以贡献翻译：\n方法1：Transifex（推荐） 这是翻译 I2P 最简单的方法。 Transifex 提供了一个基于网页的界面,使翻译变得简单易用。\n在 Transifex 注册 申请加入 I2P 翻译团队 直接在浏览器中开始翻译 无需技术知识 - 只需注册即可开始翻译!\n方法 2：手动翻译 对于喜欢使用 git 和本地文件工作的翻译人员,或者对于尚未在 Transifex 上设置的语言。\n要求： - 熟悉 git 版本控制 - 文本编辑器或翻译工具（推荐使用 POEdit） - 命令行工具：git、gettext\n设置： 1. 加入 IRC 上的 #i2p-dev 并介绍自己 2. 在 wiki 上更新翻译状态（在 IRC 中请求访问权限）3. 克隆相应的仓库（见下面的章节）\n路由器控制台翻译 路由器控制台是运行 I2P 时看到的网页界面。翻译它可以帮助那些不熟悉英语的用户。\n使用 Transifex（推荐） 访问 Transifex 上的 I2P 选择 router console 项目 选择你的语言 开始翻译 手动翻译路由器控制台 前提条件： - 与网站翻译相同（git、gettext） - GPG密钥（用于提交访问） - 已签署的开发者协议\n克隆 I2P 主仓库：\ngit clone https://i2pgit.org/I2P_Developers/i2p.i2p.git cd i2p.i2p 待翻译文件：\n路由器控制台大约有 15 个文件需要翻译:\n核心界面文件：\napps/routerconsole/locale/messages_*.po - 主控制台消息 apps/routerconsole/locale-news/messages_*.po - 新闻消息 代理文件：\napps/i2ptunnel/locale/messages_*.po - Tunnel 配置界面 应用程序语言包：\napps/susidns/locale/messages_*.po - 地址簿界面 apps/susimail/locale/messages_*.po - 电子邮件界面 其他应用程序特定的语言包目录 文档文件：\ninstaller/resources/readme/readme_*.html - 安装说明文档 各种应用程序中的帮助文件 翻译工作流程：\n# Update .po files from source ant extractMessages # Edit .po files with POEdit or text editor poedit apps/routerconsole/locale/messages_es.po # Build and test ant updaters # Install the update and check translations in the console 提交您的工作： - 在 GitLab 上创建合并请求 - 或在 IRC 上与开发团队分享文件\n翻译工具 POEdit（强力推荐） POEdit 是一个专门用于 .po 翻译文件的编辑器。\n功能： - 可视化翻译工作界面 - 显示翻译上下文 - 自动验证 - 支持 Windows、macOS 和 Linux\n文本编辑器 您也可以使用任何文本编辑器： - VS Code（配合 i18n 扩展） - Sublime Text - vim/emacs（适合终端用户）\n质量检查 提交前：1. 检查格式： 确保占位符如 %s 和 {0} 保持不变 2. 测试您的翻译： 安装并运行 I2P 以查看显示效果 3. 一致性： 保持各文件术语的一致性 4. 长度： 某些字符串在用户界面中有空间限制\n翻译者提示 通用指南 保持一致性： 在整个翻译过程中对常用术语使用相同的译法 保持格式： 保留 HTML 标签、占位符（%s、{0}）和换行符 注重上下文： 仔细阅读英文原文以理解上下文 提出问题： 如果有不清楚的地方，可以使用 IRC 或论坛提问 常见 I2P 术语 某些术语应保持英文或谨慎音译：\nI2P - 保持不变 eepsite - I2P网站(一种匿名网站) tunnel - 连接路径(避免使用Tor术语如\u0026quot;电路\u0026quot;) netDb - 网络数据库 floodfill - 一种router类型 destination - I2P地址端点 测试您的翻译 使用你的翻译构建 I2P 在路由器控制台设置中更改语言 浏览所有页面以检查: 文本适合 UI 元素 没有乱码字符(编码问题) 翻译在上下文中有意义 常见问题 为什么翻译过程如此复杂？ 该流程使用版本控制（git）和标准翻译工具（.po 文件），因为：\n问责制： 跟踪谁在何时更改了什么 质量： 在更改上线之前进行审核 一致性： 维护正确的文件格式和结构 可扩展性： 高效管理多语言翻译 协作： 多个译者可以同时处理同一种语言 我需要编程技能吗？ 不需要！ 如果您使用 Transifex，您只需要：- 精通英语和您的目标语言 - 一个网页浏览器 - 基本的计算机技能\n对于手动翻译，你需要基本的命令行知识，但不需要编写代码。\n需要多长时间? Router console（路由控制台）： 所有文件大约需要 15-20 小时 维护： 每月需要几小时来更新新字符串 多个人可以共同翻译一种语言吗? 是的！协调工作是关键：- 使用 Transifex 进行自动协调 - 对于手动工作，在 #i2p-dev IRC 频道中沟通 - 按章节或文件划分工作\n如果我的语言没有列出怎么办？ 在 Transifex 上请求或通过 IRC 联系团队。开发团队可以快速设置新语言。\n在提交之前，我如何测试我的翻译？ 使用你的翻译从源码构建 I2P 在本地安装并运行 在控制台设置中更改语言 获取帮助 IRC 支持 加入 IRC 上的 #i2p-dev 获取：- 翻译工具的技术帮助 - I2P 术语相关问题解答 - 与其他翻译者协调 - 开发者的直接支持\n论坛 在 I2P Forums 上进行翻译讨论 I2P 内部：zzz.i2p 上的翻译论坛（需要 I2P router） 文档 Transifex 文档 POEdit 文档 gettext 手册 致谢 所有译者将获得署名，署名位置包括：\nI2P router 控制台（关于页面） 网站致谢页面 Git 提交历史 发布公告 您的工作直接帮助世界各地的人们安全、私密地使用I2P。感谢您的贡献!\n下一步 准备好开始翻译了吗？\n选择你的方式：\n快速开始：在 Transifex 上注册 手动方式：加入 IRC 上的 #i2p-dev 频道 从小做起： 先翻译几个字符串以熟悉流程\n寻求帮助： 不要犹豫在 IRC 或论坛上寻求帮助\n感谢您帮助让 I2P 为每个人所用！\n","description":"如何通过 Transifex 或手动方法为 I2P 网站和 router console（路由控制台）贡献翻译","id":"a436f7ab16669c43b076458496d70009","section":"docs","title":"新译者指南","url":"/zh/docs/develop/new-translators/"},{"categories":null,"content":"I2P 网络性能：速度、连接和资源管理 I2P 网络是完全动态的。每个客户端都被其他节点所知晓,并在本地测试已知节点的可达性和容量。只有可达且具备足够容量的节点才会被保存到本地 NetDB 中。在隧道构建过程中,会从这个节点池中选择最佳资源来构建隧道。由于测试是持续进行的,节点池会不断变化。每个 I2P 节点都知道 NetDB 的不同部分,这意味着每个 router 都有一组不同的 I2P 节点可用于隧道构建。即使两个 router 拥有相同的已知节点子集,可达性和容量测试也可能显示出不同的结果,因为当一个 router 进行测试时,其他 router 可能正处于负载状态,而当第二个 router 测试时,它们可能又处于空闲状态。\n这说明了为什么每个 I2P 节点会选择不同的节点来构建 tunnel。因为每个 I2P 节点都有不同的延迟和带宽,tunnel(通过这些节点构建)具有不同的延迟和带宽值。并且由于每个 I2P 节点构建的 tunnel 不同,没有两个 I2P 节点拥有相同的 tunnel 集合。\n服务器/客户端被称为\u0026quot;destination\u0026quot;，每个 destination 至少有一个入站 tunnel 和一个出站 tunnel。默认情况下每个 tunnel 有 3 跳。这意味着一次完整的往返通信（客户端 → 服务器 → 客户端）总共需要 12 跳（经过 12 个不同的 I2P 节点）。\n每个数据包会经过 6 个其他 I2P 节点才能到达服务器：\nclient - hop1 - hop2 - hop3 - hopa1 - hopa2 - hopa3 - server\n并且在返回路径上经过 6 个不同的 I2P 节点:\nserver - hopb1 - hopb2 - hopb3 - hopc1 - hopc2 - hopc3 - client\n网络上的流量在发送新数据之前需要一个 ACK；它需要等待服务器返回 ACK：发送数据，等待 ACK，发送更多数据，等待 ACK。由于 RTT (Round Trip Time，往返时间) 累积了这个往返过程中每个 I2P 节点和每个连接的延迟，通常需要 1-3 秒 ACK 才能返回到客户端。由于 TCP 和 I2P 传输设计的原因，数据包的大小是有限的。这些条件综合起来为每个 tunnel 设置了大约 20-50 kB/s 的最大带宽限制。然而，如果 tunnel 中只有一个跳只能分配 5 kB/s 的带宽，那么整个 tunnel 就被限制为 5 kB/s，与延迟和其他限制无关。\n加密、延迟以及隧道的构建方式使得建立隧道需要消耗大量 CPU 时间。这就是为什么一个目标节点只允许拥有最多 6 条入站隧道和 6 条出站隧道来传输数据。每条隧道最大速率为 50 kB/s,一个目标节点总共可以使用大约 300 kB/s 的流量(实际上,如果使用较短的隧道且可用匿名性较低或无匿名性,流量可能会更多)。使用中的隧道每 10 分钟会被丢弃,并建立新的隧道。这种隧道更换,以及有时客户端关闭或失去与网络的连接,有时会导致隧道和连接中断。这种情况的一个例子可以在 IRC2P Network 中看到,表现为连接丢失(ping 超时)或使用 eepget 时出现问题。\n由于目的地数量有限，且每个目的地的隧道数量有限，一个 I2P 节点仅使用经过其他 I2P 节点的有限数量的隧道。例如，如果一个 I2P 节点是上述小例子中的\u0026quot;hop1\u0026quot;，它只能看到一条源自客户端的参与隧道。如果我们对整个 I2P 网络进行汇总，只有相当有限数量的参与隧道可以用总共有限的带宽来构建。如果将这些有限的数量分配到 I2P 节点的数量上，那么只有一小部分可用带宽/容量可供使用。\n为了保持匿名性,整个网络不应该使用单个router来构建隧道。如果一个router充当所有I2P节点的隧道router,它就会成为一个非常现实的单点故障,同时也成为收集客户端IP和数据的中心点。这就是为什么网络在隧道构建过程中会将流量分散到各个节点上。\n性能方面的另一个考量是 I2P 处理网状网络的方式。每个逐跳连接在 I2P 节点上使用一个 TCP 或 UDP 连接。当有 1000 个连接时,就会看到 1000 个 TCP 连接。这是相当多的,而一些家用和小型办公室路由器只允许少量连接。I2P 试图将这些连接限制在每种 UDP 和 TCP 类型各 1500 个以下。这也限制了通过 I2P 节点路由的流量。\n如果一个节点是可达的，带宽设置为共享 \u0026gt;128 kB/s 并且全天候在线，它应该会在一段时间后被用于参与流量转发。如果中间出现下线，其他节点对该 I2P 节点进行的测试会告知它们该节点不可达。这会在其他节点上阻止该节点至少 24 小时。因此，测试到该节点下线的其他节点将在 24 小时内不会使用该节点来构建 tunnel。这就是为什么在重启/关闭 I2P router 后，你的流量在至少 24 小时内会较低的原因。\n此外，其他 I2P 节点需要知道某个 I2P router 才能测试其可达性和容量。当你与网络互动时，例如使用应用程序或访问 I2P 站点，这个过程会变得更快，这将导致更多的 tunnel 构建，从而使网络上的节点有更多的活动和可达性进行测试。\n性能历史记录（精选） 多年来,I2P 已经实现了许多显著的性能改进:\nNative math 通过 JNI 绑定到 GNU MP 库（GMP）来加速 BigInteger modPow 运算，该运算此前占据了主要的 CPU 时间。早期结果显示公钥密码学性能获得了显著提升。参见：/misc/jbigi/\nGarlic wrapping a \u0026ldquo;reply\u0026rdquo; LeaseSet (tuned) 以前,回复通常需要在网络数据库中查找发送者的 LeaseSet。在初始 garlic 中捆绑发送者的 LeaseSet 可以改善回复延迟。现在这是有选择性地进行的(连接开始时或当 LeaseSet 发生变化时),以减少开销。\n原生数学库 在传输握手过程中将一些验证步骤提前,以便更早地拒绝有问题的节点(时钟错误、NAT/防火墙配置不当、版本不兼容),从而节省CPU和带宽资源。\n对\u0026quot;回复\u0026quot;LeaseSet 进行 Garlic 封装(调优) 使用上下文感知的隧道测试:避免测试已知正在传输数据的隧道;优先在空闲时进行测试。这可以减少开销并加快检测失效隧道的速度。\n更高效的 TCP 拒绝 为给定连接持久化选择可减少乱序传递，并允许流式传输库增加窗口大小，从而提高吞吐量。\n隧道测试调整 GZip 或类似压缩方式用于冗长结构(例如 RouterInfo 选项),在适当情况下可减少带宽占用。\n持久化隧道/租约选择 替代简单的\u0026quot;ministreaming\u0026quot;协议。现代 streaming 包含选择性 ACK 和针对 I2P 匿名、面向消息基础设施量身定制的拥塞控制。参见：/docs/api/streaming/\nFuture Performance Improvements (historical ideas) 以下是历史上记录的潜在改进想法。其中许多已经过时、已实现，或已被架构变更所取代。\n压缩选定的数据结构 改进路由器为隧道构建选择对等节点的方式,以避免选择慢速或过载的节点,同时保持对强大对手发起的女巫攻击(Sybil attacks)的抵抗能力。\n完整流式协议 当密钥空间稳定时减少不必要的探索;调整查找中返回多少对等节点以及执行多少并发搜索。\nSession Tag tuning and improvements (legacy) 对于传统的 ElGamal/AES+SessionTag 方案,更智能的过期和补充策略可减少 ElGamal 回退和标签浪费。\n更好的节点分析和选择 从新会话建立期间种子化的同步 PRNG 生成标签,将每条消息开销从预先交付的标签中减少。\n网络数据库调优 更长的隧道生命周期配合修复机制可以减少重建开销;需要在匿名性和可靠性之间取得平衡。\nSession Tag 调优和改进 (legacy) 更早地拒绝无效的 peer,并使隧道测试更具上下文感知能力,以减少争用和延迟。\n将 SessionTag 迁移到同步 PRNG(旧版) 选择性 LeaseSet 捆绑、压缩的 RouterInfo 选项以及完整 streaming 协议的采用,共同提升了感知性能。\n另请参阅：\nTunnel Routing（隧道路由） Peer Selection（节点选择） Transports（传输协议） SSU2 Specification 和 NTCP2 Specification ","description":"I2P 网络性能：当前表现、历史改进以及未来优化思路","id":"eb296d22dd7b2414170601d7c73a1613","section":"docs","title":"性能","url":"/zh/docs/overview/performance/"},{"categories":null,"content":"I2P的这个实现(本站分发的Java实现)包含一个\u0026quot;严格国家列表\u0026quot;,用于在法律可能限制为他人提供路由服务的地区调整router行为。虽然我们不知道有禁止使用I2P的司法管辖区,但有几个国家/地区对中继流量有广泛的禁令。位于\u0026quot;严格\u0026quot;国家/地区的router会自动进入隐藏模式。\n该项目在做出这些决定时参考了民权和数字权利组织的研究。特别是，自由之家（Freedom House）正在进行的研究为我们的选择提供了依据。一般指导原则是纳入公民自由（CL）评分为 16 分或以下，或互联网自由评分为 39 分或以下（不自由）的国家。\n隐藏模式概述 当路由器被置于隐藏模式时,其行为会发生三个关键变化:\n它不会将 RouterInfo 发布到 netDb。 它不接受参与隧道。 它拒绝与同一国家的路由器建立直接连接。 这些防御措施使得路由器更难以被可靠地枚举,并降低了违反当地禁止为他人中继流量规定的风险。\n严格国家列表(截至2024年) /* Afghanistan */ \u0026#34;AF\u0026#34;, /* Azerbaijan */ \u0026#34;AZ\u0026#34;, /* Bahrain */ \u0026#34;BH\u0026#34;, /* Belarus */ \u0026#34;BY\u0026#34;, /* Brunei */ \u0026#34;BN\u0026#34;, /* Burundi */ \u0026#34;BI\u0026#34;, /* Cameroon */ \u0026#34;CM\u0026#34;, /* Central African Republic */ \u0026#34;CF\u0026#34;, /* Chad */ \u0026#34;TD\u0026#34;, /* China */ \u0026#34;CN\u0026#34;, /* Cuba */ \u0026#34;CU\u0026#34;, /* Democratic Republic of the Congo */ \u0026#34;CD\u0026#34;, /* Egypt */ \u0026#34;EG\u0026#34;, /* Equatorial Guinea */ \u0026#34;GQ\u0026#34;, /* Eritrea */ \u0026#34;ER\u0026#34;, /* Ethiopia */ \u0026#34;ET\u0026#34;, /* Iran */ \u0026#34;IR\u0026#34;, /* Iraq */ \u0026#34;IQ\u0026#34;, /* Kazakhstan */ \u0026#34;KZ\u0026#34;, /* Laos */ \u0026#34;LA\u0026#34;, /* Libya */ \u0026#34;LY\u0026#34;, /* Myanmar */ \u0026#34;MM\u0026#34;, /* North Korea */ \u0026#34;KP\u0026#34;, /* Palestinian Territories */ \u0026#34;PS\u0026#34;, /* Pakistan */ \u0026#34;PK\u0026#34;, /* Rwanda */ \u0026#34;RW\u0026#34;, /* Saudi Arabia */ \u0026#34;SA\u0026#34;, /* Somalia */ \u0026#34;SO\u0026#34;, /* South Sudan */ \u0026#34;SS\u0026#34;, /* Sudan */ \u0026#34;SD\u0026#34;, /* Eswatini (Swaziland) */ \u0026#34;SZ\u0026#34;, /* Syria */ \u0026#34;SY\u0026#34;, /* Tajikistan */ \u0026#34;TJ\u0026#34;, /* Thailand */ \u0026#34;TH\u0026#34;, /* Turkey */ \u0026#34;TR\u0026#34;, /* Turkmenistan */ \u0026#34;TM\u0026#34;, /* Venezuela */ \u0026#34;VE\u0026#34;, /* United Arab Emirates */ \u0026#34;AE\u0026#34;, /* Uzbekistan */ \u0026#34;UZ\u0026#34;, /* Vietnam */ \u0026#34;VN\u0026#34;, /* Western Sahara */ \u0026#34;EH\u0026#34;, /* Yemen */ \u0026#34;YE\u0026#34; 如果您认为某个国家应该被添加到或从严格列表中移除,请提交一个 issue:https://i2pgit.org/i2p/i2p.i2p/\n参考：自由之家 – https://freedomhouse.org/ ","description":"I2P 在对路由或匿名工具有限制的司法管辖区中的行为表现(隐藏模式和严格列表)","id":"483dc8380c381981cff8df178412f086","section":"docs","title":"严格/限制性国家","url":"/zh/docs/overview/restrictive-countries/"},{"categories":null,"content":"为什么要编写专门针对 I2P 的代码？ 在 I2P 中使用应用程序有多种方式。使用 I2PTunnel 可以让常规应用程序无需编程实现显式的 I2P 支持。这对于客户端-服务器场景非常有效,当你需要连接到单个网站时。你可以简单地使用 I2PTunnel 创建一个 tunnel 来连接该网站,如图 1 所示。\n如果你的应用程序是分布式的,它将需要连接到大量的对等节点。使用 I2PTunnel 时,你需要为每个想要联系的对等节点创建一个新的 tunnel,如图 2 所示。这个过程当然可以自动化,但运行大量的 I2PTunnel 实例会产生大量开销。此外,对于许多协议,你需要强制每个人为所有对等节点使用相同的端口集——例如,如果你想可靠地运行 DCC 聊天,每个人都需要约定端口 10001 是 Alice,端口 10002 是 Bob,端口 10003 是 Charlie,依此类推,因为该协议包含 TCP/IP 特定信息(主机和端口)。\n通用网络应用程序通常会发送大量可能被用于识别用户的额外数据。主机名、端口号、时区、字符集等信息往往在用户不知情的情况下被发送。因此,在设计网络协议时专门考虑匿名性可以避免暴露用户身份。\n在确定如何在 I2P 上进行交互时,还需要考虑效率问题。streaming 库及其之上构建的应用使用类似于 TCP 的握手机制,而核心 I2P 协议(I2NP 和 I2CP)则严格基于消息(类似于 UDP,或在某些情况下类似于原始 IP)。重要的区别在于,I2P 的通信是在长肥网络(long fat network,高延迟高带宽网络)上运行的——每个端到端的消息都会有不小的延迟,但可以包含最多几 KB 的有效载荷。对于只需要简单请求和响应的应用,可以通过使用(尽力而为的)数据报来消除任何状态,并避免启动和关闭握手带来的延迟,而无需担心 MTU 检测或消息分片问题。\nFigure 1: Creating a server-client connection using I2PTunnel only requires creating a single tunnel. Figure 2: Setting up connections for a peer-to-peer applications requires a very large amount of tunnels. 总结来说，编写I2P特定代码有以下几个原因： 创建大量的 I2PTunnel 实例会消耗相当可观的资源,这对分布式应用来说是个问题(每个对等节点都需要一个新的 tunnel)。 通用网络协议通常会发送大量可用于识别用户身份的额外数据。专门为 I2P 编程可以创建不会泄露此类信息的网络协议,从而保护用户的匿名性和安全性。 为常规互联网设计的网络协议在 I2P 上可能效率低下,因为 I2P 是一个延迟要高得多的网络。 I2P 为开发者提供了标准的插件接口 ，以便应用程序可以轻松集成和分发。\n用 Java 编写并可通过标准 webapps/app.war 使用 HTML 界面访问/运行的应用程序可能会被考虑纳入 I2P 发行版。\n重要概念 使用 I2P 时需要适应一些变化：\n目的地 运行在 I2P 上的应用程序从一个唯一的、具有加密安全性的端点（即\u0026quot;destination\u0026quot;）发送和接收消息。从 TCP 或 UDP 的角度来看,destination 在很大程度上可以被视为等同于主机名加端口号对,尽管存在一些差异。\nI2P destination 本身是一个密码学构造——发送到 destination 的所有数据都会被加密,就像普遍部署了 IPsec 一样,并且端点的(匿名化)位置会被签名,就像普遍部署了 DNSSEC 一样。 I2P destination 是可移动的标识符——它们可以从一个 I2P router 移动到另一个(甚至可以\u0026quot;多宿主\u0026quot;——同时在多个 router 上运行)。这与 TCP 或 UDP 世界完全不同,在那里单个端点(端口)必须保持在单个主机上。 I2P destination 又丑又大——在幕后,它们包含一个用于加密的 2048 位 ElGamal 公钥、一个用于签名的 1024 位 DSA 公钥,以及一个可变大小的证书,该证书可能包含工作量证明或盲化数据。 现有一些方法可以用简短易记的名称（例如\u0026quot;irc.duck.i2p\u0026quot;）来引用这些冗长难看的目标地址，但这些技术无法保证全局唯一性（因为它们存储在每个人机器上的本地数据库中），并且当前机制在可扩展性和安全性方面都不够理想（主机列表的更新是通过\u0026quot;订阅\u0026quot;命名服务来管理的）。将来可能会出现某种安全、人类可读、可扩展且全局唯一的命名系统，但应用程序不应依赖于它的存在。有关命名系统的更多信息 可供查阅。\n虽然大多数应用程序不需要区分协议和端口,但 I2P 确实支持它们。复杂的应用程序可以在每条消息的基础上指定协议、源端口和目标端口,以便在单个目标上复用流量。详细信息请参见 datagram 页面 。简单的应用程序通过监听目标的\u0026quot;所有协议\u0026quot;和\u0026quot;所有端口\u0026quot;来运行。\n匿名性与保密性 I2P 对网络上传输的所有数据都提供透明的端到端加密和身份验证——如果 Bob 发送数据到 Alice 的 destination（目标节点），只有 Alice 的 destination 能够接收它，并且如果 Bob 使用数据报或流式库，Alice 可以确定数据就是由 Bob 的 destination 发送的。\n当然，I2P 透明地匿名化了 Alice 和 Bob 之间发送的数据，但它无法匿名化他们发送的内容本身。例如，如果 Alice 向 Bob 发送一个包含她的全名、政府身份证件和信用卡号码的表单，I2P 对此无能为力。因此，协议和应用程序应该清楚它们试图保护哪些信息以及它们愿意暴露哪些信息。\nI2P 数据报可达数 KB 使用 I2P 数据报（无论是原始数据报还是可回复数据报）的应用程序本质上可以按照 UDP 的方式来理解——数据报是无序的、尽力而为的、无连接的——但与 UDP 不同的是,应用程序不需要担心 MTU 检测,可以直接发送大型数据报。虽然上限名义上是 32 KB,但消息会被分片传输,从而降低整体可靠性。目前不建议使用超过 10 KB 的数据报。详情请参阅数据报页面 。对于许多应用程序来说,10 KB 的数据足以容纳整个请求或响应,使它们能够在 I2P 中作为类似 UDP 的应用程序透明地运行,而无需编写分片、重发等功能。\n开发选项 在I2P上有多种发送数据的方式,各有优缺点。streaming lib(流式库)是推荐的接口,被大多数I2P应用程序使用。\n流媒体库 完整的流式传输库 现在是标准接口。它允许使用类似 TCP 的套接字进行编程,具体说明请参见流式传输开发指南 。\nBOB BOB 是 Basic Open Bridge ，允许任何语言的应用程序与 I2P 建立流式连接。目前它缺少 UDP 支持，但在不久的将来计划添加 UDP 支持。BOB 还包含几个工具，例如目标密钥生成，以及验证地址是否符合 I2P 规范。最新信息和使用 BOB 的应用程序可以在这个 I2P 站点 找到。\nSAM, SAM V2, SAM V3 不推荐使用 SAM。SAM V2 可以接受，推荐使用 SAM V3。\nSAM 是 Simple Anonymous Messaging 协议,允许用任何语言编写的应用程序通过普通 TCP socket 与 SAM bridge 通信,并让该 bridge 多路复用其所有 I2P 流量,透明地协调加密/解密和基于事件的处理。SAM 支持三种操作方式:\n流(streams),用于当 Alice 和 Bob 想要可靠且有序地相互发送数据时 可回复数据报(repliable datagrams),用于当 Alice 想要向 Bob 发送一条 Bob 可以回复的消息时 原始数据报(raw datagrams),用于当 Alice 想要尽可能获得最大带宽和性能,而 Bob 不关心数据发送者是否经过身份验证时(例如传输的数据本身具有自身验证能力) SAM V3 的目标与 SAM 和 SAM V2 相同,但不需要多路复用/解复用。每个 I2P 流都通过应用程序与 SAM 桥接之间各自独立的套接字来处理。此外,应用程序可以通过与 SAM 桥接的数据报通信来发送和接收数据报。\nSAM V2 是 imule 使用的新版本,修复了 SAM 中的一些问题。\nSAM V3 从 1.4.0 版本开始被 imule 使用。\nI2PTunnel I2PTunnel 应用程序允许应用通过创建 I2PTunnel \u0026ldquo;客户端\u0026quot;应用程序（监听特定端口，并在打开该端口的套接字时连接到特定的 I2P destination）或 I2PTunnel \u0026ldquo;服务器\u0026quot;应用程序（监听特定的 I2P destination，每当收到新的 I2P 连接时就转发到特定的 TCP 主机/端口）来构建特定的类 TCP tunnel 到对等节点。这些数据流是 8 位清洁的，并通过与 SAM 使用的相同 streaming 库进行身份验证和保护，但创建多个独立的 I2PTunnel 实例会产生不小的开销，因为每个实例都有自己独立的 I2P destination 和自己的 tunnel 集、密钥等。\nSOCKS I2P 支持 SOCKS V4 和 V5 代理。出站连接运行良好。入站（服务器）和 UDP 功能可能不完整且未经测试。\nMinistreaming（迷你流传输） 已移除\n曾经有一个简单的\u0026quot;ministreaming\u0026quot;库,但现在 ministreaming.jar 只包含完整 streaming 库的接口。\n数据报 推荐用于类 UDP 应用\n数据报库 允许发送类似UDP的数据包。可以使用：\n可回复数据报 原始数据报 I2CP 不推荐\nI2CP 本身是一个与语言无关的协议，但要用 Java 以外的语言实现 I2CP 库需要编写大量代码（加密例程、对象编组、异步消息处理等）。虽然可以用 C 或其他语言编写 I2CP 库，但使用 C 语言的 SAM 库可能会更加实用。\nWeb 应用程序 I2P 自带 Jetty 网络服务器,改用 Apache 服务器配置起来也很简单。任何标准的 Web 应用技术都应该可以使用。\n开始开发——简单指南 使用 I2P 进行开发需要一个正常运行的 I2P 安装和您自己选择的开发环境。如果您使用 Java，可以使用 streaming library 或 datagram library 开始开发。使用其他编程语言时，可以使用 SAM 或 BOB。\n使用 Streaming 库进行开发 以下是原始页面示例的精简和现代化版本。完整示例请参见旧版页面或代码库中的 Java 示例。\n// Server example (excerpt) I2PSocketManager manager = I2PSocketManagerFactory.createManager(); I2PServerSocket server = manager.getServerSocket(); I2PSocket socket = server.accept(); BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream())); String s; while ((s = br.readLine()) != null) { System.out.println(\u0026#34;Received: \u0026#34; + s); } 代码示例：接收数据的基本服务器。\n// Client example (excerpt) I2PSocketManager manager = I2PSocketManagerFactory.createManager(); Destination dest = new Destination(serverDestBase64); I2PSocket socket = manager.connect(dest); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream())); bw.write(\u0026#34;Hello I2P!\\n\u0026#34;); bw.flush(); 代码示例：客户端连接并发送一行数据。\n","description":"为什么要编写 I2P 专用应用程序、关键概念、开发选项以及简单的入门指南","id":"d137fc4f3bedf693b877aa1ba9bde3eb","section":"docs","title":"应用程序开发","url":"/zh/docs/develop/applications/"},{"categories":null,"content":"概览 标准 Base 32 (\u0026ldquo;b32\u0026rdquo;) 地址包含目标（Destination）的哈希值。这对加密的 LS2（LeaseSet 2，I2P 的新一代 leaseSet 格式；提案 123）不起作用。\n对于加密的 LS2（提案 123），我们不能使用传统的 Base32 地址，因为它仅包含 destination（目标标识）的哈希。 它不提供非盲化公钥。 客户端必须知道 destination 的公钥、签名类型、盲化签名类型，以及一个可选的 secret（共享密钥）或私钥，才能获取并解密 leaseset。 因此，仅有一个 Base32 地址是不够的。 客户端需要完整的 destination（其中包含公钥），或者单独的公钥。 如果客户端在地址簿中保存了完整的 destination，且该地址簿支持按哈希反向查询，则可以取回公钥。\n这种格式将公钥而不是哈希放入 base32 地址中。这种格式还必须包含公钥所使用的签名算法类型，以及盲化方案所使用的签名算法类型。\n本文档为这些地址规定了 b32 格式。虽然我们在讨论中将这种新格式称为 \u0026ldquo;b33\u0026rdquo; 地址，但实际的新格式仍保留通常的 \u0026ldquo;.b32.i2p\u0026rdquo; 后缀。\n实现状态 提案 123（新的 netDB 条目）在 0.9.43 版（2019 年 10 月）中已全部实现。加密的 LS2（第二代 leaseSet）功能集一直保持稳定，直至 2.10.0 版（2025 年 9 月），未对寻址格式或密码规范引入任何破坏性变更。\n关键实现里程碑: - 0.9.38: 对带离线密钥的标准 LS2 的 Floodfill 支持 - 0.9.39: RedDSA 签名类型 11 与基本的加密/解密 - 0.9.40: 完整的 B32 地址支持 (提案 149) - 0.9.41: 基于 X25519 的逐客户端认证 - 0.9.42: 全部盲化（blinding）功能可用 - 0.9.43: 宣布实现完成 (2019 年 10 月)\n设计 新格式包含未盲化公钥、未盲化签名类型以及盲化签名类型。 可选地指示私有链接对 secret（共享密钥）和/或私钥的要求。 使用现有的 \u0026ldquo;.b32.i2p\u0026rdquo; 后缀，但长度更长。 包含用于错误检测的校验和。 加密的 leaseSet 的地址由 56 个或更多编码字符（35 个或更多解码字节）标识，相比之下，传统 Base32 地址为 52 个字符（32 字节）。 规范 创建与编码 按如下方式构造一个形如 {56+ chars}.b32.i2p 的主机名（对应的二进制为 35+ 个字符）：\nflag (1 byte) bit 0: 0 for one-byte sigtypes, 1 for two-byte sigtypes bit 1: 0 for no secret, 1 if secret is required bit 2: 0 for no per-client auth, 1 if client private key is required bits 7-3: Unused, set to 0 public key sigtype (1 or 2 bytes as indicated in flags) If 1 byte, the upper byte is assumed zero blinded key sigtype (1 or 2 bytes as indicated in flags) If 1 byte, the upper byte is assumed zero public key Number of bytes as implied by sigtype 后处理和校验和：\nConstruct the binary data as above. Treat checksum as little-endian. Calculate checksum = CRC-32(data[3:end]) data[0] ^= (byte) checksum data[1] ^= (byte) (checksum \u0026gt;\u0026gt; 8) data[2] ^= (byte) (checksum \u0026gt;\u0026gt; 16) hostname = Base32.encode(data) || \u0026#34;.b32.i2p\u0026#34; b32 末尾的任何未使用位都必须为 0。对于标准的 56 个字符（35 字节）地址，不存在未使用的位。\n解码与验证 strip the \u0026#34;.b32.i2p\u0026#34; from the hostname data = Base32.decode(hostname) Calculate checksum = CRC-32(data[3:end]) Treat checksum as little-endian. flags = data[0] ^ (byte) checksum if 1 byte sigtypes: pubkey sigtype = data[1] ^ (byte) (checksum \u0026gt;\u0026gt; 8) blinded sigtype = data[2] ^ (byte) (checksum \u0026gt;\u0026gt; 16) else (2 byte sigtypes): pubkey sigtype = data[1] ^ ((byte) (checksum \u0026gt;\u0026gt; 8)) || data[2] ^ ((byte) (checksum \u0026gt;\u0026gt; 16)) blinded sigtype = data[3] || data[4] parse the remainder based on the flags to get the public key 秘密与私钥位数 共享密钥和私钥的标志位用于向客户端、代理或其他客户端代码表明：解密该 leaseset 需要提供共享密钥和/或私钥。具体实现可能会提示用户提供所需数据，或者在缺少所需数据时拒绝连接尝试。\n这些比特仅用作标识。绝不能在 B32 地址（基于 Base32 编码的 I2P 地址）本身中包含对称密钥或私钥，否则会危及安全。\n密码学细节 盲化方案 该盲化方案采用基于 Ed25519 并借鉴 ZCash 设计的 RedDSA，使用 SHA-512 在 Ed25519 曲线上生成 Red25519 签名。这种方法确保被盲化的公钥仍然处于素数阶子群上，从而避免了一些替代设计中的安全隐患。\n盲化密钥根据 UTC 日期每日轮换，使用以下公式：\nblinded_key = BLIND(unblinded_key, date, optional_secret) DHT 存储位置的计算方式如下：\nSHA256(type_byte || blinded_public_key) 加密 加密的 leaseset 使用 ChaCha20 流密码进行加密，之所以选择它，是因为在缺乏 AES 硬件加速的设备上具有更优的性能。该规范采用 HKDF 进行密钥派生，并使用 X25519 进行 Diffie-Hellman 运算。\n加密的 leasesets 具有三层结构: - 外层: 明文元数据 - 中间层: 客户端认证（DH 或 PSK 方法） - 内层: 包含租约信息的实际 LS2 数据\n身份验证方法 针对每个客户端的身份验证支持两种方法：\nDH 认证: 使用 X25519（基于 Curve25519 的密钥协商算法）进行密钥协商。每个已授权的客户端向服务器提供其公钥，服务器使用由 ECDH（椭圆曲线 Diffie-Hellman 密钥交换）派生的共享密钥对中间层进行加密。\nPSK 身份验证: 直接使用预共享密钥进行加密。\nB32 地址中的第 2 个标志位表示是否需要针对每个客户端的身份验证。\n缓存 虽然这超出了本规范的范围，但 routers 和客户端必须记住并缓存（建议持久化）从公钥到 Destination（目标标识）的映射，以及反向映射。\nblockfile naming service（blockfile 命名服务）作为自 0.9.8 版起 I2P 的默认地址簿系统，维护多个地址簿，并包含专用的反向查找映射，支持按哈希的快速查找。 当最初只知道哈希时，此功能对于加密的 leaseSet 解析至关重要。\n签名类型 截至 I2P 版本 2.10.0，签名类型 0 至 11 已定义。单字节编码仍然是标准，双字节编码虽可用，但在实践中未使用。\n常用类型： - 类型 0 (DSA_SHA1)：对 router 已弃用，仍支持用于目的地 - 类型 7 (EdDSA_SHA512_Ed25519)：当前用于 router 身份和目的地的标准 - 类型 11 (RedDSA_SHA512_Ed25519)：仅用于支持盲化的加密 LS2 leasesets\n重要说明：只有 Ed25519（类型 7）和 Red25519（类型 11）支持加密的 leaseSet 所需的盲化。其他签名类型不能用于此功能。\n类型 9-10（GOST 算法）仍为保留状态，但尚未实现。类型 4-6 和 8 被标记为 \u0026ldquo;offline only\u0026rdquo;，用于离线签名密钥。\n备注 通过长度区分旧版与新版变体。旧版 b32 地址始终为 {52 chars}.b32.i2p。新版为 {56+ chars}.b32.i2p base32 编码遵循 RFC 4648 标准，解码不区分大小写，输出优先使用小写 当使用具有更大公钥的签名类型时，地址可能超过 200 个字符（例如 ECDSA P521，132 字节密钥） 如有需要，新格式可用于 jump links（跳转链接）（并可由 jump servers（跳转服务器）提供），与标准 b32 一样 为增强隐私，blinded keys（盲化密钥）会基于 UTC 日期每日轮换 该格式与 Tor 的 rend-spec-v3.txt 附录 A.2 的方法不同，这种差异在使用不在曲线上的（off-curve）盲化公钥时可能带来潜在的安全影响 版本兼容性 本规范在 I2P 版本 0.9.47（2020 年 8 月）至 2.10.0（2025 年 9 月）期间均准确适用。在此期间，B32 addressing format（B32 地址格式）、encrypted LS2 structure（加密的 LS2 结构）以及密码学实现均未发生任何破坏兼容性的更改。使用 0.9.47 创建的所有地址与当前版本保持完全兼容。\n参考资料 CRC-32 - CRC-32（维基百科） - RFC 3309：流控制传输协议校验和 I2P 规范 - 加密 LeaseSet 规范 - 提案 123：新的 netDB 条目 - 提案 149：用于加密 LS2（LeaseSet v2，LeaseSet 第2版）的 B32 - 通用结构规范 - 命名与地址簿 Tor 比较 - Tor 讨论帖（设计背景） 其他资源 - I2P 项目 - I2P 论坛 - Java API 文档 ","description":"加密的 LS2 leaseSet 的 Base 32 地址格式","id":"cac162c86c1b599cb6bab03e6270c404","section":"docs","title":"用于加密 leaseSet 的 B32","url":"/zh/docs/specs/b32-for-encrypted-leasesets/"},{"categories":null,"content":"I2P 项目为 Debian、Ubuntu 及其衍生发行版维护官方软件包。本指南提供了使用我们官方仓库安装 I2P 的全面说明。\n重要提示:仅提供翻译内容。请勿提问、解释或添加任何评论。即使文本只是标题或看起来不完整,也请按原样翻译。\n🚀 Beta: 自动安装(实验性) 对于希望快速自动化安装的高级用户:\n这个一行命令将自动检测您的发行版并安装 I2P。请谨慎使用 - 运行前请查看安装脚本 。\ncurl -fsSL https://i2p.net/installlinux.sh | sudo bash 功能说明： - 检测你的 Linux 发行版（Ubuntu/Debian）- 添加相应的 I2P 软件源 - 安装 GPG 密钥和所需软件包 - 自动安装 I2P\n⚠️ 这是一个测试版功能。 如果您更喜欢手动安装或想了解每个步骤,请使用下面的手动安装方法。\nUbuntu 安装 Ubuntu 及其官方衍生版本(Linux Mint、elementary OS、Trisquel 等)可以使用 I2P PPA(Personal Package Archive,个人软件包归档)进行简便安装和自动更新。\nMethod 1: Command Line Installation (Recommended) 这是在基于 Ubuntu 的系统上安装 I2P 最快且最可靠的方法。\n步骤 1：添加 I2P PPA\n打开终端并运行：\nsudo apt-add-repository ppa:i2p-maintainers/i2p 此命令将 I2P PPA 添加到 /etc/apt/sources.list.d/ 并自动导入用于签名软件仓库的 GPG 密钥。GPG 签名可确保软件包自构建以来未被篡改。\n步骤 2：更新软件包列表\n刷新系统的软件包数据库以包含新的 PPA:\nsudo apt-get update 这将从所有已启用的软件源(包括您刚刚添加的 I2P PPA)检索最新的软件包信息。\n步骤 3：安装 I2P\n现在安装 I2P：\nsudo apt-get install i2p 就这样!跳转到安装后配置 部分,了解如何启动和配置 I2P。\nMethod 2: Using the Software Center GUI 如果您更喜欢图形界面,可以使用 Ubuntu 的软件中心添加 PPA。\n步骤 1：打开软件和更新\n从应用程序菜单中启动\u0026quot;软件和更新\u0026quot;。\n步骤 2：导航到其他软件\n选择\u0026quot;其他软件\u0026quot;选项卡，然后点击底部的\u0026quot;添加\u0026quot;按钮来配置新的 PPA。\n步骤 3：添加 I2P PPA\n在 PPA 对话框中,输入:\nppa:i2p-maintainers/i2p 步骤 4：重新加载仓库信息\n点击\u0026quot;重新加载\u0026quot;按钮以下载更新的仓库信息。\n步骤 5：安装 I2P\n从应用程序菜单中打开\u0026quot;软件\u0026quot;应用程序,搜索\u0026quot;i2p\u0026quot;,然后点击安装。\n安装完成后,请继续进行安装后配置 。\nDebian Installation Debian 及其下游发行版(LMDE、Kali Linux、ParrotOS、Knoppix 等)应使用位于 deb.i2p.net 的官方 I2P Debian 软件源。\nImportant Notice 我们在 deb.i2p2.de 和 deb.i2p2.no 的旧仓库已停止维护。 如果您正在使用这些旧版仓库,请按照以下说明迁移到位于 deb.i2p.net 的新仓库。\nPrerequisites 以下所有步骤都需要 root 权限。可以使用 su 切换到 root 用户,或在每条命令前加上 sudo。\n方法 1：命令行安装（推荐） 步骤 1：安装所需软件包\n确保您已安装必要的工具：\nsudo apt-get update sudo apt-get install apt-transport-https lsb-release curl 这些软件包提供安全的 HTTPS 仓库访问、发行版检测和文件下载功能。\n步骤 2：添加 I2P 仓库\n您使用的命令取决于您的 Debian 版本。首先,确定您正在运行的版本:\ncat /etc/debian_version 将此与 Debian 发行版信息 交叉参照,以确定您的发行版代号(例如 Bookworm、Bullseye、Buster)。\n对于 Debian Bullseye (11) 或更新版本:\necho \u0026#34;deb [signed-by=/usr/share/keyrings/i2p-archive-keyring.gpg] https://deb.i2p.net/ $(lsb_release -sc) main\u0026#34; \\ | sudo tee /etc/apt/sources.list.d/i2p.list 对于基于 Debian Bullseye 或更新版本的衍生发行版(LMDE、Kali、ParrotOS 等):\necho \u0026#34;deb [signed-by=/usr/share/keyrings/i2p-archive-keyring.gpg] https://deb.i2p.net/ $(dpkg --status tzdata | grep Provides | cut -f2 -d\u0026#39;-\u0026#39;) main\u0026#34; \\ | sudo tee /etc/apt/sources.list.d/i2p.list 对于 Debian Buster (10) 或更早版本：\necho \u0026#34;deb https://deb.i2p.net/ $(lsb_release -sc) main\u0026#34; \\ | sudo tee /etc/apt/sources.list.d/i2p.list 对于基于 Debian 的系统(Buster 或更早版本):\necho \u0026#34;deb https://deb.i2p.net/ $(dpkg --status tzdata | grep Provides | cut -f2 -d\u0026#39;-\u0026#39;) main\u0026#34; \\ | sudo tee /etc/apt/sources.list.d/i2p.list 步骤 3：下载仓库签名密钥\ncurl -o i2p-archive-keyring.gpg https://geti2p.net/_static/i2p-archive-keyring.gpg 步骤 4：验证密钥指纹\n在信任该密钥之前,请验证其指纹是否与官方 I2P 签名密钥匹配:\ngpg --keyid-format long --import --import-options show-only --with-fingerprint i2p-archive-keyring.gpg 验证输出显示此指纹：\n7840 E761 0F28 B904 7535 49D7 67EC E560 5BCF 1346 ⚠️ 如果指纹不匹配，请勿继续操作。 这可能表明下载文件已被篡改。\n步骤 5：安装仓库密钥\n将已验证的密钥环复制到系统密钥环目录：\nsudo cp i2p-archive-keyring.gpg /usr/share/keyrings 仅适用于 Debian Buster 或更早版本,您还需要创建一个符号链接:\nsudo ln -sf /usr/share/keyrings/i2p-archive-keyring.gpg /etc/apt/trusted.gpg.d/i2p-archive-keyring.gpg 步骤 6：更新软件包列表\n刷新系统的软件包数据库以包含 I2P 软件源:\nsudo apt-get update 步骤 7：安装 I2P\n同时安装 I2P router 和密钥环软件包(以确保您能够接收未来的密钥更新):\nsudo apt-get install i2p i2p-keyring 太好了!I2P 现在已经安装完成。继续进行安装后配置 部分。\nPost-Installation Configuration 安装 I2P 后,您需要启动 router 并进行一些初始配置。\n方法 2:使用软件中心图形界面 I2P 软件包提供三种方式来运行 I2P router：\nOption 1: On-Demand (Basic) 需要时使用 i2prouter 脚本手动启动 I2P:\ni2prouter start 重要提示：不要使用 sudo 或以 root 身份运行！I2P 应该以普通用户身份运行。\n停止 I2P:\ni2prouter stop Option 2: On-Demand (Without Java Service Wrapper) 如果您使用的是非 x86 系统或 Java Service Wrapper 在您的平台上无法运行,请使用:\ni2prouter-nowrapper 再次强调，不要使用 sudo 或以 root 身份运行。\nOption 3: System Service (Recommended) 为获得最佳体验,请配置 I2P 在系统启动时自动运行,甚至在登录之前:\nsudo dpkg-reconfigure i2p 这将打开一个配置对话框。选择\u0026quot;是\u0026quot;以启用 I2P 作为系统服务。\n这是推荐的方法，因为：- I2P 在启动时自动启动 - 你的 router 保持更好的网络集成 - 你为网络稳定性做出贡献 - I2P 在你需要时立即可用\nInitial Router Configuration 首次启动 I2P 后,需要几分钟时间才能融入网络。在此期间,请配置以下基本设置:\n1. Configure NAT/Firewall 为了获得最佳性能和网络参与度,请通过您的 NAT/防火墙转发 I2P 端口:\n打开 I2P Router Console 导航到 Network Configuration page 记录列出的端口号(通常是 9000-31000 之间的随机端口) 在您的路由器/防火墙中转发这些 UDP 和 TCP 端口 如果您需要端口转发方面的帮助，portforward.com 提供了针对特定路由器的指南。\n2. Adjust Bandwidth Settings 默认带宽设置较为保守。请根据你的互联网连接调整这些设置:\n访问配置页面 找到带宽设置部分 默认值为 96 KB/s 下载 / 40 KB/s 上传 如果您的网络速度更快,请提高这些数值(例如,对于典型的宽带连接,可设置为 250 KB/s 下载 / 100 KB/s 上传) 注意：设置更高的限制有助于网络并提高您自己的性能。\n3. Configure Your Browser 要访问 I2P 站点 (eepsite) 和服务,请配置您的浏览器使用 I2P 的 HTTP 代理:\n请参阅我们的浏览器配置指南 ，了解 Firefox、Chrome 和其他浏览器的详细设置说明。\nDebian 安装 重要通知 确保您没有以 root 身份运行 I2P：ps aux | grep i2p 检查日志：tail -f ~/.i2p/wrapper.log 验证 Java 是否已安装：java -version 前置要求 如果在安装过程中收到 GPG 密钥错误:\n重新下载并验证密钥指纹(上述步骤 3-4) 确保 keyring 文件具有正确的权限:sudo chmod 644 /usr/share/keyrings/i2p-archive-keyring.gpg 安装步骤 如果 I2P 没有接收到更新:\n验证仓库已配置：cat /etc/apt/sources.list.d/i2p.list 更新软件包列表：sudo apt-get update 检查 I2P 更新：sudo apt-get upgrade Migrating from old repositories 如果你正在使用旧的 deb.i2p2.de 或 deb.i2p2.no 软件源:\n删除旧的软件源：sudo rm /etc/apt/sources.list.d/i2p.list 按照上面的 Debian 安装 步骤操作 更新：sudo apt-get update \u0026amp;\u0026amp; sudo apt-get install i2p i2p-keyring Next Steps 现在 I2P 已安装并运行：\n配置你的浏览器 以访问 I2P 站点 探索 I2P router console 来监控你的 router 了解你可以使用的 I2P 应用程序 阅读 I2P 的工作原理 以理解网络运作机制 欢迎来到隐形网络!\n","description":"使用官方软件源在 Debian、Ubuntu 及其衍生版本上安装 I2P 的完整指南","id":"88fb5f6d2f5129ce7be2a42b1e9fb9af","section":"docs","title":"在 Debian 和 Ubuntu 上安装 I2P","url":"/zh/docs/guides/%E5%9C%A8-debian-%E5%92%8C-ubuntu-%E4%B8%8A%E5%AE%89%E8%A3%85-i2p/"},{"categories":null,"content":"在 I2P 内托管 GitLab 非常简单:运行 GitLab omnibus 容器,在 loopback 上暴露服务,然后通过 I2P tunnel 转发流量。以下步骤反映了 git.idk.i2p 使用的配置,但适用于任何自托管实例。\n1. 前置要求 Debian 或其他已安装 Docker Engine 的 Linux 发行版（通过 sudo apt install docker.io 或从 Docker 官方仓库安装 docker-ce）。 一个具有足够带宽服务用户的 I2P router（Java I2P 或 i2pd）。 可选：一个专用虚拟机，以便将 GitLab 和 router 与桌面环境隔离。 2. 拉取 GitLab 镜像 docker pull gitlab/gitlab-ce:latest 官方镜像基于 Ubuntu 基础层构建,并定期更新。如果您需要额外保证,可以审查 Dockerfile 。\n3. 决定使用桥接模式还是纯I2P模式 仅 I2P 实例永远不会联系明网主机。用户可以从其他 I2P 服务镜像仓库，但不能从 GitHub/GitLab.com 镜像。这最大化了匿名性。 桥接 实例通过 HTTP 代理访问明网 Git 主机。这对于将公共项目镜像到 I2P 中很有用，但会使服务器的出站请求去匿名化。 如果您选择桥接模式，请配置 GitLab 使用绑定在 Docker 主机上的 I2P HTTP 代理（例如 http://172.17.0.1:4446）。默认的 router 代理仅监听 127.0.0.1；需要添加一个新的代理 tunnel 绑定到 Docker 网关地址。\n4. 启动容器 docker run --detach \\ --env HTTP_PROXY=http://172.17.0.1:4446 \\ # omit for I2P-only --publish 127.0.0.1:8443:443 \\ --publish 127.0.0.1:8080:80 \\ --publish 127.0.0.1:8022:22 \\ --name gitlab \\ --restart always \\ --volume /srv/gitlab/config:/etc/gitlab:Z \\ --volume /srv/gitlab/logs:/var/log/gitlab:Z \\ --volume /srv/gitlab/data:/var/opt/gitlab:Z \\ gitlab/gitlab-ce:latest 将发布的端口绑定到回环地址;I2P 隧道将根据需要暴露它们。 将 /srv/gitlab/... 替换为适合您主机的存储路径。 容器运行后,访问 https://127.0.0.1:8443/,设置管理员密码并配置账户限制。\n5. 通过 I2P 暴露 GitLab 创建三个 I2PTunnel 服务器隧道:\nPurpose Local target Suggested inbound port HTTPS web UI 127.0.0.1:8443 auto-generated HTTP web UI (optional) 127.0.0.1:8080 auto-generated SSH push/pull 127.0.0.1:8022 auto-generated 为每个 tunnel 配置适当的 tunnel 长度和带宽。对于公共实例，3 跳配合每个方向 4-6 个 tunnel 是一个不错的起点。在您的着陆页上发布生成的 Base32/Base64 目标地址，以便用户可以配置客户端 tunnel。 Destination Enforcement 如果您使用 HTTP(S) tunnel,请启用目的地强制验证,以便只有预期的主机名才能访问该服务。这可以防止 tunnel 被滥用为通用代理。\n6. Maintenance Tips 每次更改 GitLab 设置时运行 docker exec gitlab gitlab-ctl reconfigure。 监控磁盘使用情况(/srv/gitlab/data)——Git 仓库增长很快。 定期备份配置和数据目录。GitLab 的 备份 rake 任务 可在容器内运行。 考虑在客户端模式下放置一个外部监控 tunnel,以确保服务可从更广泛的网络访问。 6. 维护提示 在你的应用程序中嵌入 I2P 通过 I2P 使用 Git（客户端指南） 用于离线/慢速网络的 Git bundles 一个配置良好的 GitLab 实例可以在 I2P 内部提供一个完整的协作开发中心。保持 router 健康运行,及时更新 GitLab 安全补丁,并随着用户群体的增长与社区保持协调。\n","description":"使用 Docker 和 I2P router 在 I2P 内部署 GitLab","id":"0c6aba5984de265324df6360a00204c9","section":"docs","title":"在 I2P 上运行 GitLab","url":"/zh/docs/guides/gitlab/"},{"categories":null,"content":" 主要的 I2P 开发分支（i2p.i2p）已经配置完毕，使开发者能够轻松设置两个常用的 Java 开发 IDE：Eclipse 和 NetBeans。\nEclipse 主要的 I2P 开发分支(i2p.i2p 及其派生分支)包含 build.gradle 文件,以便在 Eclipse 中轻松设置该分支。\n确保你安装了较新版本的 Eclipse。2017 年之后的任何版本都可以。 将 I2P 分支检出到某个目录(例如 $HOME/dev/i2p.i2p)。 选择\"File → Import...\",然后在\"Gradle\"下选择\"Existing Gradle Project\"。 在\"Project root directory:\"中选择 I2P 分支检出到的目录。 在\"Import Options\"对话框中,选择\"Gradle Wrapper\"并按 Continue。 在\"Import Preview\"对话框中,你可以查看项目结构。在\"i2p.i2p\"下应该会出现多个项目。按\"Finish\"。 完成!你的工作空间现在应该包含 I2P 分支中的所有项目,并且它们的构建依赖关系应该已正确设置。 NetBeans I2P 的主要开发分支(i2p.i2p 及其派生分支)包含 NetBeans 项目文件。\n","description":"使用 Gradle 和捆绑项目文件为开发 I2P 配置 Eclipse 和 NetBeans","id":"59847e4ae7ce8d8ccadb441422ecc856","section":"docs","title":"在 I2P 中使用 IDE","url":"/zh/docs/guides/ides/"},{"categories":null,"content":"您需要准备的内容 运行 macOS 10.14 (Mojave) 或更高版本的 Mac 安装应用程序所需的管理员权限 大约 15-20 分钟时间 用于下载安装程序的互联网连接 概述 此安装过程包含四个主要步骤:\n安装 Java - 下载并安装 Oracle Java Runtime Environment 安装 I2P - 下载并运行 I2P 安装程序 配置 I2P 应用 - 设置启动器并添加到程序坞 配置 I2P 带宽 - 运行设置向导以优化您的连接 第一部分:安装 Java I2P 需要 Java 才能运行。如果你已经安装了 Java 8 或更高版本,可以跳到第二部分 。\nStep 1: Download Java 访问 Oracle Java 下载页面 并下载适用于 macOS 的 Java 8 或更高版本的安装程序。\nStep 2: Run the Installer 在\u0026quot;下载\u0026quot;文件夹中找到已下载的 .dmg 文件,双击打开它。\nStep 3: Allow Installation macOS 可能会显示安全提示,因为安装程序来自已识别的开发者。点击打开继续。\n步骤 1：下载 Java 点击 Install 开始 Java 安装过程。\n步骤 2：运行安装程序 安装程序将复制文件并在您的系统上配置 Java。这通常需要 1-2 分钟。\n步骤 3：允许安装 当您看到成功消息时,Java 已安装完成!点击 关闭 以完成操作。\nPart Two: Download and Install I2P 现在 Java 已经安装完成，你可以安装 I2P router 了。\n步骤 4：安装 Java 访问下载页面 并下载 I2P for Unix/Linux/BSD/Solaris 安装程序（.jar 文件）。\n步骤 5：等待安装完成 双击下载的 i2pinstall_X.X.X.jar 文件。安装程序将启动并要求您选择首选语言。\n步骤 6：安装完成 阅读欢迎信息并点击 Next 继续。\nStep 4: Important Notice 安装程序将显示一条关于更新的重要通知。I2P 更新是端到端签名和验证的,即使安装程序本身未签名。点击 Next。\n步骤 1：下载 I2P 阅读 I2P 许可协议（BSD 风格许可证）。点击下一步接受。\n步骤 2:运行安装程序 选择 I2P 的安装位置。推荐使用默认位置（/Applications/i2p）。点击下一步。\n步骤 3:欢迎界面 保持所有组件被选中以进行完整安装。点击 Next。\n步骤 4：重要提示 检查您的选择并点击 Next 开始安装 I2P。\n步骤 5:许可协议 安装程序将复制 I2P 文件到您的系统。这大约需要 1-2 分钟。\n步骤 6：选择安装目录 安装程序会创建用于启动 I2P 的启动脚本。\n步骤 7：选择组件 安装程序会询问是否创建桌面快捷方式和菜单条目。做出选择后点击下一步。\n步骤 8：开始安装 成功！I2P 现已安装完成。点击 完成 结束安装。\nPart Three: Configure I2P App 现在让我们将 I2P 添加到你的\u0026quot;应用程序\u0026quot;文件夹和程序坞，以便轻松启动。\n步骤 9：安装文件 打开访达并导航到您的应用程序文件夹。\n步骤 10：生成启动脚本 在 /Applications/i2p/ 目录中查找 I2P 文件夹或 Start I2P Router 应用程序。\n步骤 11：安装快捷方式 将 Start I2P Router 应用程序拖动到您的程序坞以便快速访问。您也可以在桌面上创建一个替身。\n提示：右键点击 Dock 中的 I2P 图标,选择 选项 → 在 Dock 中保留,使其永久固定。\nPart Four: Configure I2P Bandwidth 当您首次启动 I2P 时,您将进入一个设置向导来配置您的带宽设置。这有助于为您的连接优化 I2P 的性能。\n步骤 12:安装完成 点击 Dock 中的 I2P 图标（或双击启动器）。您的默认网络浏览器将打开 I2P Router Console。\nStep 2: Welcome Wizard 设置向导将会欢迎您。点击 Next 开始配置 I2P。\n步骤 1：打开应用程序文件夹 选择您首选的界面语言并在浅色或深色主题之间进行选择。点击下一步。\n步骤 2：找到 I2P 启动器 向导将解释带宽测试。此测试连接到 M-Lab 服务以测量您的互联网速度。点击下一步继续。\n步骤 3：添加到程序坞 点击 Run Test 来测量你的上传和下载速度。测试大约需要 30-60 秒。\nStep 6: Test Results 查看您的测试结果。I2P 将根据您的连接速度推荐带宽设置。\n步骤 1：启动 I2P 选择您想要与 I2P 网络共享多少带宽:\n自动（推荐）：I2P 根据你的使用情况管理带宽 受限：设置特定的上传/下载限制 无限制：尽可能多地共享（适用于快速连接） 点击 Next 保存您的设置。\n步骤 2:欢迎向导 您的 I2P router 现在已配置完成并正在运行!router console 将显示您的连接状态,并允许您浏览 I2P 站点。\nGetting Started with I2P 现在 I2P 已安装并配置完成,您可以:\n浏览 I2P 站点:访问 I2P 主页 查看热门 I2P 服务的链接 配置浏览器:设置浏览器配置文件 以访问 .i2p 站点 探索服务:体验 I2P 电子邮件、论坛、文件共享等更多功能 监控 router:控制台 显示网络状态和统计信息 步骤 3:语言和主题 Router Console: http://127.0.0.1:7657/ 配置: http://127.0.0.1:7657/config 地址簿: http://127.0.0.1:7657/susidns/addressbook 带宽设置: http://127.0.0.1:7657/config Re-running the Setup Wizard 如果您想更改带宽设置或稍后重新配置 I2P,可以从 Router Console 重新运行欢迎向导:\n访问 I2P 设置向导 再次按照向导步骤操作 Troubleshooting 步骤 4:带宽测试信息 检查 Java：在终端运行 java -version 确保已安装 Java 检查权限：确保 I2P 文件夹具有正确的权限 检查日志：查看 ~/.i2p/wrapper.log 中的错误信息 步骤 5：运行带宽测试 确保 I2P 正在运行(检查 Router Console) 配置浏览器的代理设置,使用 HTTP 代理 127.0.0.1:4444 启动后等待 5-10 分钟,让 I2P 集成到网络中 步骤 6：测试结果 再次运行带宽测试并调整您的设置 确保您与网络共享了一些带宽 在路由器控制台中检查您的连接状态 第二部分:下载和安装 I2P 从 Mac 中移除 I2P:\n如果 I2P router 正在运行,请先退出 删除 /Applications/i2p 文件夹 删除 ~/.i2p 文件夹(你的 I2P 配置和数据) 从程序坞中移除 I2P 图标 Next Steps 加入社区：访问 i2pforum.net 或在 Reddit 上查看 I2P 了解更多：阅读 I2P 文档 以理解网络的工作原理 参与其中：考虑为 I2P 做贡献 ，参与开发或运行基础设施 恭喜！您现在已经是 I2P 网络的一部分了。欢迎来到隐形互联网！\n","description":"在 macOS 上手动安装 I2P 及其依赖项的分步指南","id":"f88100195c365b18735e1ea12826a97e","section":"docs","title":"在 macOS 上安装 I2P(详细方式)","url":"/zh/docs/guides/%E5%9C%A8-macos-%E4%B8%8A%E5%AE%89%E8%A3%85-i2p%E8%AF%A6%E7%BB%86%E6%96%B9%E5%BC%8F/"},{"categories":null,"content":"选择您的安装方式 在 Windows 上安装 I2P 有两种方式。请根据你的需求选择最合适的方法：\n🚀 Easy Install Bundle (Recommended) Best for most users\n✅ All-in-one installer ✅ Java included (no separate install) ✅ Firefox profiles included ✅ Fastest setup\nChoose this if:\nYou want the simplest installation You don\u0026rsquo;t have Java installed You\u0026rsquo;re new to I2P Easy Install Guide →\n⚙️ Standard Installation For advanced users\n📦 Java-based JAR installer 🔧 More control over installation 💾 Smaller download size\nChoose this if:\nYou already have Java installed You want more control You prefer the traditional method Standard Install Guide →\n--- 简易安装包 什么是 Easy Install Bundle（简易安装套件）？ I2P 简易安装包是 Windows 用户的推荐安装方式。这个一体化安装程序包含开始使用 I2P 所需的一切：\nI2P Router - I2P 的核心软件 内置 Java 运行时 - 无需单独安装 Java Firefox 配置文件与扩展 - 针对 I2P 优化的浏览器配置文件与扩展，用于安全浏览 简易安装程序 - 无需手动配置 自动更新 - 让你的 I2P 软件保持最新 这个测试版安装程序通过直接捆绑 Java 来简化安装流程，因此您无需另行下载或配置 Java。\n步骤 1：选择语言 启动 Easy Install Bundle 安装程序后，您会看到语言选择界面。\n从下拉菜单中选择你偏好的语言 可用语言包括英语、德语、西班牙语、法语，以及许多其他语言 点击 OK 继续 安装程序界面将在后续的所有步骤中使用您选择的语言。\n步骤 2：接受许可协议 接下来，您将看到 I2P 的许可证信息。Easy Install Bundle 包含采用多种自由和开源许可证的组件。\n继续安装：1. 查看许可条款（可选但推荐） 2. 点击我同意以接受许可条款并继续 3. 如果不希望安装，请点击取消\n步骤 3：选择安装文件夹 现在，您将选择在计算机上安装 I2P 的位置。\n安装选项:\n使用默认位置（推荐）\n默认路径：C:\\Users\\[YourUsername]\\AppData\\Local\\I2peasy\\ 这会将 I2P 安装在你的用户配置文件目录中 更新不需要管理员权限 选择自定义位置\n单击**浏览\u0026hellip;**以选择其他文件夹 如果你想安装到不同的驱动器上，这会很有用 确保你对所选文件夹具有写入权限 空间要求: - 安装程序会显示所需的空间大小 (通常少于 1 GB) - 确保所选驱动器上有足够的可用空间\n点击Install以开始安装过程 安装程序现在会将所有必要的文件复制到您选择的位置。这可能需要几分钟。\n第 4 步：完成安装并启动 I2P 安装完成后，您将看到完成界面。\n安装向导确认 \u0026ldquo;I2P - i2peasy 已安装在您的计算机上。\u0026rdquo;\n重要: 请确认已勾选 \u0026ldquo;Start I2P?\u0026rdquo; 复选框（默认情况下应已勾选）。\n已勾选 (推荐): 当你点击 Finish 时，I2P 会自动启动 未勾选: 你需要稍后从开始菜单或桌面快捷方式手动启动 I2P 单击 完成 以完成安装并启动 I2P。\n接下来会发生什么 在勾选“启动 I2P？”后点击“完成”：\nI2P Router 启动 - I2P router（I2P 路由器进程）开始在后台运行 系统托盘图标出现 - 在 Windows 系统托盘（右下角）中查找 I2P 图标 Router 控制台打开 - 您的默认浏览器会自动打开到 I2P Router Console（通常为 http://127.0.0.1:7657） 初始连接 - I2P 将开始连接到网络并构建 tunnels（首次启动可能需要 5-10 分钟） 恭喜！ I2P 现已在您的 Windows 计算机上安装并运行。\n推荐：端口转发（可选但很重要） 虽然并非严格要求，端口转发会显著提升你的 I2P 使用体验，因为它使你的 router 能与其他 I2P routers 更高效地通信。没有端口转发，你仍然可以使用 I2P，但性能会降低，对网络的贡献也会减少。\n为什么要进行端口转发？ 更好的连通性: 允许来自其他 I2P routers 的入站连接 更快融入: 帮助你更快地融入网络 网络贡献: 使你成为 I2P 网络中更好的参与者 性能提升: 通常会带来更好的 tunnel 可靠性和速度 查找你的 I2P 端口 首先，您需要确定 I2P 正在使用的是哪个端口（默认情况下会随机分配）。\n找到 I2P 图标，它位于屏幕右下角的 Windows 系统托盘（通知区域）中 右键单击 I2P 图标 以打开上下文菜单 单击 \u0026ldquo;Launch I2P Browser\u0026rdquo; 以打开 I2P router 控制台 菜单还显示了如下实用选项： - 网络：处于防火墙后 - 显示您当前的网络状态 - 配置 I2P 系统托盘 - 自定义托盘图标设置 - 停止 I2P / 立即停止 I2P - 关停选项\n查找您的端口号 当 I2P 浏览器打开后，你需要检查 I2P 正在使用哪些端口：\n进入网络配置页面:\n在浏览器中访问 I2P Router 网络配置 或从 router 控制台侧边栏进入: Configuration → Network 向下滚动 到端口配置部分\n注意所示的端口号: UDP 配置: - UDP 端口: 此处显示的端口（示例：13697） - 默认情况下，此项设置为“Specify Port”（指定端口），并随机分配一个端口号\nTCP 配置: - 外部可达的 TCP 端口：通常设置为使用与 UDP 相同的端口 - 在上述示例中：\u0026ldquo;使用为 UDP 配置的相同端口（当前为 13697）\u0026rdquo;\n重要: 你需要在你的 router/防火墙上，将 UDP 和 TCP 都 在同一个端口号上进行端口转发（本例中为端口 13697）。\n如何进行端口转发 由于各个 router 和防火墙各不相同，我们无法提供通用的说明。不过，portforward.com 提供了针对数千种 router 型号的详细指南：\n访问 portforward.com 选择你的 router 厂商和型号 按照逐步指南进行端口转发 在 I2P 配置中显示的端口号上同时转发 UDP 和 TCP 协议 通用步骤 (因 router 而异): - 登录到你的 router 管理界面 (通常为 192.168.1.1 或 192.168.0.1) - 找到 \u0026ldquo;Port Forwarding\u0026rdquo; (端口转发) 或 \u0026ldquo;Virtual Servers\u0026rdquo; (虚拟服务器) 部分 - 为你的 I2P 端口号创建新的端口转发规则 - 同时设置 UDP 和 TCP 协议 - 将该规则指向你计算机的本地 IP 地址 - 保存配置\n在设置好端口转发后，I2P 应该会在系统托盘菜单中从 \u0026ldquo;Network: Firewalled\u0026rdquo; 变为 \u0026ldquo;Network: OK\u0026rdquo;（这可能需要几分钟）。\n后续步骤 等待网络集成: 给 I2P 5-10 分钟以接入网络并建立 tunnels 配置浏览器: 使用随附的 Firefox 配置文件进行 I2P 浏览 设置端口转发: 参阅 portforward.com 获取特定于 router 的关于如何转发 I2P 所使用端口的说明 探索 router 控制台: 了解 I2P 的功能、服务和配置选项 访问 eepsites（I2P 内部网站）: 尝试通过 I2P 网络访问 .i2p 网站 阅读文档: 查看 I2P 文档 以了解更多信息 欢迎来到 I2P 网络！🎉\n标准安装 什么是标准安装？ 标准 I2P 安装 是在 Windows 上安装 I2P 的传统方法。不同于 Easy Install Bundle（简易安装包），此方法需要你：\n单独安装 Java - 在安装 I2P 之前下载并安装 Java 运行时环境（JRE） 运行 JAR 安装程序 - 使用基于 Java 的图形安装程序 手动配置 - 自行设置浏览器配置（可选） 此方法适用于： - 已经安装了 Java 的用户 - 希望对安装过程有更多控制的高级用户 - 偏好传统安装方式的用户 - 无法与 Easy Install Bundle（简易安装包）兼容的系统\n先决条件 在安装 I2P 之前，需确保系统已安装 Java。\nJava 要求 Java 版本: 需要 Java 8 (1.8) 或更高版本 推荐: Java 11 或更高版本（LTS，长期支持） 类型: Java 运行环境 (JRE) 或 Java 开发工具包 (JDK) 安装 Java 如果你尚未安装 Java，你可以从多个来源下载：\n选项 1：Oracle Java - 官方来源：java.com/download - 最广泛使用的发行版\n选项 2：OpenJDK - 开源实现: openjdk.org - 免费且开源\n选项 3: Adoptium (Eclipse Temurin) - 推荐的替代方案：adoptium.net - 免费、开源，并提供维护良好的 LTS 版本\n验证 Java 是否已安装: 1. 打开命令提示符 (按 Windows + R, 输入 cmd, 按 Enter) 2. 输入: java -version 3. 你应该会看到显示 Java 版本的输出\n第 1 步: 安装 Java 在安装 I2P 之前，你需要在系统上安装 Java。\n选择一个 Java 发行版:\nOracle Java: java.com/download OpenJDK: openjdk.org Adoptium: adoptium.net 下载 Windows 安装程序，适用于你选择的发行版\n运行安装程序，并按照安装提示进行操作\n验证安装:\n打开命令提示符 输入 java -version 并按 Enter 键 确认已安装 Java 8 或更高版本 安装好 Java 后，你就可以开始安装 I2P 了。\n第 2 步：下载并启动 I2P 安装程序 下载 I2P 安装程序:\n访问 I2P 下载页面 下载 Windows 安装程序（JAR 文件）：i2pinstall_X.X.X.jar 将其保存到便于查找的位置（例如：Downloads 文件夹） 启动安装程序:\n双击已下载的 JAR 文件以启动安装程序 如果双击无效，右键单击该文件并选择 \u0026ldquo;打开方式 → Java(TM) Platform SE binary\u0026rdquo; 或者，打开命令提示符并运行: java -jar i2pinstall_X.X.X.jar 第 3 步：选择您的语言 启动安装程序后，您将看到“语言选择”对话框。\n选择你的首选语言，从下拉菜单中 可用语言包括英语、德语、西班牙语、法语，以及许多其他语言 点击 OK 以继续 安装程序会在所有后续步骤中使用您选择的语言。\n步骤 4：欢迎使用 I2P 安装程序 这是安装过程中的第 1 步（共 8 步）。\n单击 Next 继续安装。\n步骤 5：接受许可协议 这是安装过程中的第 2 步（共 8 步）。\n单击Next以接受许可协议并继续。\n步骤 6：选择安装路径 选择您希望在计算机上安装 I2P 的位置。\n默认安装路径: C:\\Program Files (x86)\\i2p\\\n你可以选择： - 使用默认位置（推荐） - 点击**浏览\u0026hellip;**以选择其他文件夹\n这是安装过程中的第3步（共8步）。\n单击下一步以继续。\n注意: 如果这是你第一次安装 I2P，你会看到一个确认创建目录的弹出窗口：\n单击 OK 以创建安装目录。\n步骤 7：选择安装包 选择要安装的组件。\n重要: 请确保同时勾选这两个组件: - Base (必选) - I2P 核心软件 (27.53 MB) - Windows Service (推荐) - 开机时自动启动 I2P\nWindows 服务 选项确保 I2P 会在计算机启动时自动运行，因此您无需每次手动启动它。\n这是安装过程中的第 4 步（共 8 步）。\n点击下一步以继续。\n第 8 步：安装进度 安装程序现在将把文件复制到您的系统。\n您将看到两个进度条： - 软件包安装进度：显示当前正在安装的软件包 - 总体安装进度：显示总体进度（例如，\u0026ldquo;2 / 2\u0026rdquo;）\n这是安装过程中的第5步（共8步）。\n等待安装完成，然后点击 下一步。\n步骤 9：设置快捷方式 配置要在何处创建 I2P 快捷方式。\n快捷方式选项: - ✓ 在开始菜单中创建快捷方式 (推荐) - ✓ 在桌面上创建额外的快捷方式 (可选)\n程序组: 选择或创建用于快捷方式的文件夹名称 - 默认: I2P - 您可以选择现有的程序组或创建一个新的\n为以下对象创建快捷方式: - 当前用户 - 只有你可以访问这些快捷方式 - 所有用户 - 系统中的所有用户都可以访问这些快捷方式 (需要管理员权限)\n这是安装过程中的第 6 步（共 8 步）。\n单击 下一步 以继续。\n第 10 步：安装完成 安装已完成！\n您将看到： - ✓ 安装已成功完成 - 将会在以下位置创建卸载程序: C:\\Program Files (x86)\\i2p\\Uninstaller\n这是第 8/8 步——安装过程中的最后一步。\n点击完成以结束。\n接下来会发生什么 点击“完成”后：\nI2P Router 启动 - 如果你安装了 Windows 服务，I2P 将会自动启动 Router 控制台打开 - 你的默认网络浏览器将打开并访问 I2P Router 控制台，地址为 http://127.0.0.1:7657 初始连接 - I2P 将开始连接到网络并构建 tunnels（首次启动可能需要 5-10 分钟） 恭喜！ I2P 现已安装在您的 Windows 计算机上。\n手动启动 I2P 如果 I2P 未能自动启动，或者将来你需要手动启动它，你有两种方法：\n选项 1：开始菜单 打开 Windows 开始菜单 导航到 I2P 文件夹 选择以下启动选项之一： I2P router console - 在浏览器中打开 router 控制台 Start I2P (no window) - 在后台静默启动 I2P Start I2P (restartable) - 启动具有自动重启功能的 I2P 你也可以访问 Open I2P Profile Folder (service) 来查看 I2P 的配置文件。\n选项 2：Windows 服务 按下 Windows + R 打开运行对话框 输入 services.msc 并按 Enter 键 向下滚动找到 I2P Service 右键单击 I2P Service 并选择： 启动 - 启动 I2P 服务 停止 - 停止 I2P 服务 重新启动 - 重新启动 I2P 服务 属性 - 配置服务设置 (启动类型等) 通过 Windows 服务的方法有助于将 I2P 作为后台服务进行管理，尤其是在你已将其安装为 Windows 服务时。\n后续步骤 等待接入: 给 I2P 5-10 分钟接入网络并建立 tunnels 配置端口转发: 请参阅端口转发指南 获取说明 配置浏览器: 将你的网页浏览器设置为使用 I2P 的 HTTP 代理 探索 router 控制台: 了解 I2P 的功能、服务和配置选项 访问 eepsites（I2P 内部网站）: 尝试通过 I2P 网络访问 .i2p 网站 阅读文档: 查看 I2P 文档 了解更多信息 欢迎来到 I2P 网络！🎉\n","description":"选择你的 Windows 安装方式：Easy Install Bundle（简易安装包）或标准安装","id":"4aa0b74199a71c11718a9986e74b3a26","section":"docs","title":"在 Windows 上安装 I2P","url":"/zh/docs/guides/%E5%9C%A8-windows-%E4%B8%8A%E5%AE%89%E8%A3%85-i2p/"},{"categories":null,"content":"将 I2P 与您的应用程序捆绑是引导用户的强大方式——但前提是 router 配置得当且负责任。\n1. 与路由器团队协调 在打包之前联系 Java I2P 和 i2pd 的维护者。他们可以审查你的默认配置并指出兼容性问题。 选择适合你技术栈的 router 实现: Java/Scala → Java I2P C/C++ → i2pd 其他语言 → 打包一个 router 并使用 SAM v3 或 I2CP 进行集成 验证 router 二进制文件和依赖项(Java 运行时、ICU 等)的再分发条款。 2. 推荐的配置默认值 力求\u0026quot;贡献大于消耗\u0026quot;。现代默认设置优先考虑网络健康和稳定性。\nSetting Recommended Default (2025) Bandwidth share 80% for participating tunnels Tunnel quantities i2pd: 3 inbound / 3 outbound; Java I2P: 2 inbound / 2 outbound. Signature \u0026amp; encryption Use Ed25519 (SIGNATURE_TYPE=7) and advertise ECIES-X25519 + ElGamal (i2cp.leaseSetEncType=4,0). Client protocols Use SAM v3 or I2CP. API listeners Bind SAM/I2CP to 127.0.0.1 only. Disable if not needed. UI toggles Expose bandwidth controls, logs, and an opt-in checkbox for participating tunnels. ### 参与隧道仍然至关重要 不要禁用参与隧道（participating tunnels）。\n不中继数据的路由器自身性能会更差。 网络依赖于志愿者的容量分享。 掩护流量(中继流量)可以提升匿名性。 官方最低要求： - 共享带宽：≥ 12 KB/s - Floodfill 自动加入：≥ 128 KB/s - 推荐配置：2 条入站 / 2 条出站 tunnel（Java I2P 默认值）\n3. 持久化与重新播种 持久化状态目录(netDb/、profiles、certificates)必须在运行之间保留。\n如果没有持久化，您的用户将在每次启动时触发 reseed（重新获取种子）——这会降低性能并增加 reseed 服务器的负载。\n如果无法保持持久性（例如，容器或临时安装）：\n在安装程序中捆绑 1,000–2,000 个 router infos。 运行一个或多个自定义 reseed 服务器以分担公共服务器的负载。 配置变量：- 基础目录：i2p.dir.base - 配置目录：i2p.dir.config - 包含用于重新种子的 certificates/。\n4. 安全性和暴露风险 保持 router console (127.0.0.1:7657) 仅限本地访问。 如果需要对外暴露 UI,请使用 HTTPS。 除非必需,否则禁用外部 SAM/I2CP。 检查包含的插件——仅打包您的应用程序支持的插件。 始终为远程 console 访问添加身份验证。 自2.5.0版本以来引入的安全功能： - 应用程序之间的NetDB隔离（2.4.0+） - DoS缓解和Tor黑名单（2.5.1） - NTCP2探测抵抗（2.9.0） - Floodfill router选择改进（2.6.0+）\n5. 支持的 API（2025） API Status Notes SAM v3 (3.3) ✅ Active Recommended bridge for non-Java apps. I2CP ✅ Active Stable protocol core, used internally by Java I2P. I2PControl ✅ Active JSON-RPC API; plugin maintained. BOB ⚠️ Deprecated Removed from Java I2P since 1.7.0; use SAM v3 instead. 所有官方文档位于 `/docs/api/` 目录下 — 旧的 `/spec/samv3/` 路径**不**存在。 6. 网络和端口 典型默认端口：- 4444 – HTTP 代理 - 4445 – HTTPS 代理 - 7654 – I2CP - 7656 – SAM Bridge - 7657 – Router Console - 7658 – 本地 I2P 站点 - 6668 – IRC 代理 - 9000–31000 – 随机 router 端口（UDP/TCP 入站）\n路由器在首次运行时会随机选择一个入站端口。端口转发可以提高性能,但 UPnP 可能会自动处理此操作。\n7. 现代变化（2024–2025） Change Status Details SSU1 Transport Removed SSU2 is now the exclusive UDP transport. I2P-over-Tor Blocked Since 2.6.0 (July 2024). Datagram2/3 Added Authenticated, repliable datagram formats (2.9.0). LeaseSet service records Added Enables service discovery (Proposal 167). Tunnel build parameters Improved Adaptive congestion handling (2.9.0+). Post-quantum crypto Introduced (beta) ML-KEM hybrid ratchet, opt-in from 2.10.0. Java 17 requirement Announced Becomes mandatory in 2.11.0 (early 2026). ## 8. 用户体验与测试 说明 I2P 的功能以及为什么要共享带宽。 提供 router 诊断信息(带宽、tunnel、reseed 状态)。 在 Windows、macOS 和 Linux(包括低内存配置)上测试安装包。 验证与 Java I2P 和 i2pd 节点的互操作性。 测试从网络中断和非正常退出中的恢复能力。 9. 社区资源 论坛：i2pforum.net 或在 I2P 内访问 http://i2pforum.i2p。 代码：i2pgit.org/I2P_Developers/i2p.i2p 。 IRC（Irc2P 网络）：#i2p-dev、#i2pd。 #i2papps 未经验证；可能不存在。 请明确您的频道托管在哪个网络（Irc2P 还是 ilita.i2p）。 负责任的嵌入意味着在用户体验、性能和网络贡献之间取得平衡。使用这些默认值,与 router 维护者保持同步,并在发布前进行实际负载测试。\n","description":"更新了与您的应用程序捆绑 I2P router 的实用指南（负责任地）","id":"f67f27efbc9bb7bff8d34001c14105ff","section":"docs","title":"在您的应用程序中嵌入 I2P","url":"/zh/docs/applications/embedding/"}]
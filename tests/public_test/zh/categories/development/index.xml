<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Development on I2P - 隐形互联网项目</title>
    <link>/zh/categories/development/</link>
    <description>Recent content in Development on I2P - 隐形互联网项目</description>
    <generator>Hugo</generator>
    <language>zh-CN</language>
    <lastBuildDate>Fri, 29 Mar 2024 00:00:00 +0000</lastBuildDate>
    <atom:link href="/zh/categories/development/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>众多面具，同一意志：确保 NetDB 的安全</title>
      <link>/zh/blog/2024/03/29/%E4%BC%97%E5%A4%9A%E9%9D%A2%E5%85%B7%E5%90%8C%E4%B8%80%E6%84%8F%E5%BF%97%E7%A1%AE%E4%BF%9D-netdb-%E7%9A%84%E5%AE%89%E5%85%A8/</link>
      <pubDate>Fri, 29 Mar 2024 00:00:00 +0000</pubDate>
      <guid>/zh/blog/2024/03/29/%E4%BC%97%E5%A4%9A%E9%9D%A2%E5%85%B7%E5%90%8C%E4%B8%80%E6%84%8F%E5%BF%97%E7%A1%AE%E4%BF%9D-netdb-%E7%9A%84%E5%AE%89%E5%85%A8/</guid>
      <description>&lt;p&gt;作者注：本文所提及的攻击无法针对当前的 I2P 版本实施。&lt;/p&gt;&#xA;&lt;p&gt;作为一个自组织的点对点网络，I2P 依赖参与网络的 router（路由器）具备一种共享机制，用于共享网络上有哪些内容以及如何到达这些内容的信息。I2P router 借助 NetDB（网络数据库）实现这种信息共享，NetDB 是一种基于 Kademlia 的 DHT，但已经过修改以适用于 I2P。NetDB 需要共享两类主要的条目：“RouterInfos”，对等体将使用它来直接与其他 router 通信；以及“LeaseSets（租约集）”，其他对等体将使用它通过匿名的 tunnel（隧道）与 I2P 客户端通信。router 之间经常相互交换 NetDB 条目，可以向某个 router 或客户端发送信息，或者从某个 router 或客户端请求信息。这意味着这些条目可能直接或间接地、以匿名或非匿名的方式抵达，具体取决于网络的需要以及客户端的能力。然而，作为一个匿名化网络，确保以匿名方式发送的信息不可能被以非匿名方式请求回来也很重要。同时，以非匿名方式发送的信息也必须不可能被匿名地请求回。如果上述任一情况成为可能，则可能实施关联攻击，使攻击者能够判断客户端与 router 是否共享对 NetDB 的共同视图。如果能够可靠地确定这两个目标共享对 NetDB 的共同视图，那么它们很有可能位于同一个 router 上，从而大幅削弱目标的匿名性。由于匿名化网络寥寥无几，而且 I2P 是唯一一个通过 DHT 的运作来共享路由表的网络，这类攻击几乎是 I2P 所独有的，解决这一问题对 I2P 的成功至关重要。&lt;/p&gt;&#xA;&lt;p&gt;考虑以下场景：有一个 I2P router（路由器）托管着一个 I2P 客户端。该 router 发布了一个 RouterInfo（路由信息），而 I2P 客户端发布它的 LeaseSet（租约集）。由于它们都发布在 NetDB（网络数据库）中，其他 I2P routers 可以查询 NetDB 以了解如何与它们通信。这对于 I2P 所实现的这种类型的覆盖网络来说是正常且必不可少的。攻击者运行一个 I2P router，并在 NetDB 中查询目标 RouterInfo 和目标 LeaseSet。随后它构造一个新的 LeaseSet，该 LeaseSet 唯一，甚至可能是伪造的，并通过一个 tunnel（隧道）发送到其打算攻击的客户端对应的 LeaseSet。客户端处理该构造的 LeaseSet，并将其添加到自己的 NetDB 中。随后，攻击者使用其从 NetDB 获得的 RouterInfo，直接从该 router 请求取回其构造的 LeaseSet。如果收到该构造的 LeaseSet 作为回复，则攻击者可以断定目标客户端与目标 router 对 NetDB 的视图是一致的。&lt;/p&gt;</description>
    </item>
    <item>
      <title>SSU2 传输</title>
      <link>/zh/blog/2022/10/11/ssu2-%E4%BC%A0%E8%BE%93/</link>
      <pubDate>Tue, 11 Oct 2022 00:00:00 +0000</pubDate>
      <guid>/zh/blog/2022/10/11/ssu2-%E4%BC%A0%E8%BE%93/</guid>
      <description>&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;&#xA;&lt;p&gt;自 2005 年以来，I2P 一直使用一种抗审查的 UDP 传输协议“SSU”。在过去的 17 年里，我们几乎没有收到（如果有的话）关于 SSU 被封锁的报告。然而，以当今在安全性、抗封锁能力和性能方面的标准来看，我们还能做得更好。好得多。&lt;/p&gt;&#xA;&lt;p&gt;因此，我们与&lt;a href=&#34;https://i2pd.xyz/&#34;&gt;i2pd 项目&lt;/a&gt;&#xA;合作，创建并实现了 &amp;ldquo;SSU2&amp;rdquo;，这是一种按最高的安全与抗封锁标准设计的现代 UDP 协议。该协议将取代 SSU。&lt;/p&gt;&#xA;&lt;p&gt;我们将业界标准的加密与基于 UDP 的 WireGuard 和 QUIC 协议的最佳特性相结合，并融合了我们基于 TCP 的协议“NTCP2”的抗审查特性。SSU2 可能是有史以来设计出的最安全的传输协议之一。&lt;/p&gt;&#xA;&lt;p&gt;Java I2P 和 i2pd 团队正在完成 SSU2 传输，我们将在下一个版本中为所有 router 启用它。这将完成我们长达十年的计划，即对可追溯至 2003 年的 Java I2P 最初实现中的全部密码学机制进行升级。SSU2 将取代 SSU，而 SSU 是我们唯一仍在使用 ElGamal 加密的部分。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Signature types and ECDSA signatures (0.9.8, 2013)&lt;/li&gt;&#xA;&lt;li&gt;Ed25519 signatures and leasesets (0.9.15, 2014)&lt;/li&gt;&#xA;&lt;li&gt;Ed25519 routers (0.9.22, 2015)&lt;/li&gt;&#xA;&lt;li&gt;Destination encryption types and X25519 leasesets (0.9.46, 2020)&lt;/li&gt;&#xA;&lt;li&gt;Router encryption types and X25519 routers (0.9.49, 2021)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;在完成向 SSU2 的过渡之后，我们将已经把我们所有经过认证和加密的协议迁移到标准的 &lt;a href=&#34;https://noiseprotocol.org/&#34;&gt;Noise Protocol&lt;/a&gt;&#xA; 握手：&lt;/p&gt;</description>
    </item>
    <item>
      <title>使用 git bundle 获取 I2P 源代码</title>
      <link>/zh/blog/2020/03/18/%E4%BD%BF%E7%94%A8-git-bundle-%E8%8E%B7%E5%8F%96-i2p-%E6%BA%90%E4%BB%A3%E7%A0%81/</link>
      <pubDate>Wed, 18 Mar 2020 00:00:00 +0000</pubDate>
      <guid>/zh/blog/2020/03/18/%E4%BD%BF%E7%94%A8-git-bundle-%E8%8E%B7%E5%8F%96-i2p-%E6%BA%90%E4%BB%A3%E7%A0%81/</guid>
      <description>&lt;p&gt;通过 I2P 克隆大型软件仓库可能比较困难，而使用 git 有时会让事情更难。好在，它有时也能让事情更容易。Git 提供了一个 &lt;code&gt;git bundle&lt;/code&gt; 命令，可以把一个 git 仓库打包成一个文件，随后 git 可以从你本地磁盘上的某个位置对该文件执行 clone、fetch 或 import。将这一能力与 bittorrent 下载结合，我们就能解决使用 &lt;code&gt;git clone&lt;/code&gt; 时剩下的问题。&lt;/p&gt;&#xA;&lt;h2 id=&#34;在开始之前&#34;&gt;在开始之前&lt;/h2&gt;&#xA;&lt;p&gt;如果你打算生成一个 git bundle（捆绑包），你&lt;strong&gt;必须&lt;/strong&gt;已经拥有 &lt;strong&gt;git&lt;/strong&gt; 仓库的完整副本，而不是 mtn 仓库。你可以从 github 或从 git.idk.i2p 获取它，但浅克隆（使用 &amp;ndash;depth=1 进行的克隆）&lt;em&gt;将无法工作&lt;/em&gt;。它会静默失败，创建看起来像是一个 bundle 的东西，但当你尝试克隆它时会失败。如果你只是获取一个预先生成的 git bundle，那么本节不适用于你。&lt;/p&gt;&#xA;&lt;h2 id=&#34;通过-bittorrent-获取-i2p-源代码&#34;&gt;通过 Bittorrent 获取 I2P 源代码&lt;/h2&gt;&#xA;&lt;p&gt;需要有人向你提供一个与他们已为你生成的现有 &lt;code&gt;git bundle&lt;/code&gt; 相对应的种子文件或磁力链接。一旦你通过 BitTorrent 获得了该 bundle，你需要使用 git 从它创建一个可用的仓库。&lt;/p&gt;&#xA;&lt;h2 id=&#34;使用-git-clone&#34;&gt;使用 &lt;code&gt;git clone&lt;/code&gt;&lt;/h2&gt;&#xA;&lt;p&gt;从 git bundle（Git 打包文件）克隆很简单，只需：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;git clone $HOME/.i2p/i2psnark/i2p.i2p.bundle&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果你遇到以下错误，请尝试改为手动使用 git init 和 git fetch：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;fatal: multiple updates for ref &amp;#39;refs/remotes/origin/master&amp;#39; not allowed&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;使用-git-init-和-git-fetch&#34;&gt;使用 &lt;code&gt;git init&lt;/code&gt; 和 &lt;code&gt;git fetch&lt;/code&gt;&lt;/h2&gt;&#xA;&lt;p&gt;首先，创建一个名为 i2p.i2p 的目录，以便将其变成一个 Git 仓库：&lt;/p&gt;</description>
    </item>
    <item>
      <title>在 I2P 上设置 Gitlab</title>
      <link>/zh/blog/2020/03/16/%E5%9C%A8-i2p-%E4%B8%8A%E8%AE%BE%E7%BD%AE-gitlab/</link>
      <pubDate>Mon, 16 Mar 2020 00:00:00 +0000</pubDate>
      <guid>/zh/blog/2020/03/16/%E5%9C%A8-i2p-%E4%B8%8A%E8%AE%BE%E7%BD%AE-gitlab/</guid>
      <description>&lt;p&gt;这是我用于配置 Gitlab 和 I2P 的设置流程，使用 Docker 来管理服务本身。以这种方式在 I2P 上托管 Gitlab 非常容易，由一人管理也并不困难。这些说明适用于任何基于 Debian 的系统，并且可以很容易地移植到任何具备 Docker 和 I2P router 的系统上。&lt;/p&gt;&#xA;&lt;h2 id=&#34;依赖项与-docker&#34;&gt;依赖项与 Docker&lt;/h2&gt;&#xA;&lt;p&gt;由于 Gitlab 在容器中运行，我们只需在主系统上安装容器所需的依赖项。方便的是，可以通过以下方式安装所需的一切：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo apt install docker.io&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;获取-docker-容器&#34;&gt;获取 Docker 容器&lt;/h2&gt;&#xA;&lt;p&gt;安装好 Docker 后，你可以获取 GitLab 所需的 Docker 容器。&lt;em&gt;先不要运行它们。&lt;/em&gt;&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;docker pull gitlab/gitlab-ce&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;为-gitlab-设置-i2p-http-代理重要信息可选步骤&#34;&gt;为 Gitlab 设置 I2P HTTP 代理（重要信息，可选步骤）&lt;/h2&gt;&#xA;&lt;p&gt;I2P 内的 Gitlab 服务器可以在有或没有与 I2P 之外的互联网服务器交互能力的情况下运行。若 Gitlab 服务器&lt;em&gt;不允许&lt;/em&gt;与 I2P 之外的服务器交互，则无法通过从 I2P 之外的互联网上的 git 服务器克隆一个 git 仓库来对其进行去匿名化。&lt;/p&gt;&#xA;&lt;p&gt;在 Gitlab 服务器被&lt;em&gt;允许&lt;/em&gt;与 I2P 之外的服务器交互的情况下，它可以作为用户的&amp;quot;Bridge（桥接器）&amp;quot;，用户可以利用它将 I2P 之外的内容镜像到 I2P 可访问的源，不过在这种情况下它&lt;em&gt;并非匿名&lt;/em&gt;。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;如果你想要一个桥接的、非匿名的 Gitlab 实例，并且能够访问 Web 仓库&lt;/strong&gt;，无需进一步修改。&lt;/p&gt;</description>
    </item>
    <item>
      <title>通过 I2P 使用 Git（面向用户）</title>
      <link>/zh/blog/2020/03/06/%E9%80%9A%E8%BF%87-i2p-%E4%BD%BF%E7%94%A8-git%E9%9D%A2%E5%90%91%E7%94%A8%E6%88%B7/</link>
      <pubDate>Fri, 06 Mar 2020 00:00:00 +0000</pubDate>
      <guid>/zh/blog/2020/03/06/%E9%80%9A%E8%BF%87-i2p-%E4%BD%BF%E7%94%A8-git%E9%9D%A2%E5%90%91%E7%94%A8%E6%88%B7/</guid>
      <description>&lt;p&gt;通过 I2P Tunnel（隧道）设置 git 访问的教程。这个 tunnel 将作为你在 I2P 上访问单个 git 服务的接入点。它是将 I2P 从 monotone 迁移到 Git 的整体工作的一部分。&lt;/p&gt;&#xA;&lt;h2 id=&#34;在做任何其他事情之前了解该服务向公众提供的功能&#34;&gt;在做任何其他事情之前：了解该服务向公众提供的功能&lt;/h2&gt;&#xA;&lt;p&gt;取决于 Git 服务的配置方式，它不一定会在同一地址上提供所有服务。以 git.idk.i2p 为例，它提供一个公共的 HTTP URL，以及一个供你的 Git SSH 客户端配置使用的 SSH URL。两者均可用于推送或拉取，但推荐使用 SSH。&lt;/p&gt;&#xA;&lt;h2 id=&#34;首先在-git-服务上注册一个账户&#34;&gt;首先：在 Git 服务上注册一个账户&lt;/h2&gt;&#xA;&lt;p&gt;要在远程 git 服务上创建你的仓库，请先在该服务注册一个用户账户。当然，也可以在本地创建仓库，然后将其推送到远程 git 服务，但大多数服务都会要求你拥有账户，并且先在服务器上为其创建对应的远程仓库。&lt;/p&gt;&#xA;&lt;h2 id=&#34;第二步创建一个用于测试的项目&#34;&gt;第二步：创建一个用于测试的项目&lt;/h2&gt;&#xA;&lt;p&gt;为了确保设置流程正常工作，建议在服务器上创建一个用于测试的仓库。访问 i2p-hackers/i2p.i2p 仓库，并将其 fork（派生）到你的账户下。&lt;/p&gt;&#xA;&lt;h2 id=&#34;第三步设置你的-git-客户端-tunnel&#34;&gt;第三步：设置你的 git 客户端 tunnel&lt;/h2&gt;&#xA;&lt;p&gt;要获得对服务器的读写访问权限，你需要为你的 SSH 客户端设置一个 tunnel。如果你只需要通过 HTTP/S 进行只读克隆，那么你可以跳过这些，直接使用 http_proxy 环境变量，把 git 配置为使用预先配置好的 I2P HTTP Proxy。例如：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;http_proxy=http://localhost:4444 git clone --depth=1 http://git.idk.i2p/youruser/i2p.i2p&#xA;git fetch --unshallow&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;要进行 SSH 访问，请从 http://127.0.0.1:7657/i2ptunnelmgr 启动 &amp;ldquo;New Tunnel Wizard&amp;rdquo;，并设置一个指向该 Git 服务的 SSH base32 地址的客户端 tunnel。&lt;/p&gt;</description>
    </item>
    <item>
      <title>如何通过帮助 I2P-Bote 引导（bootstrap）来参与志愿服务</title>
      <link>/zh/blog/2019/05/20/%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E5%B8%AE%E5%8A%A9-i2p-bote-%E5%BC%95%E5%AF%BCbootstrap%E6%9D%A5%E5%8F%82%E4%B8%8E%E5%BF%97%E6%84%BF%E6%9C%8D%E5%8A%A1/</link>
      <pubDate>Mon, 20 May 2019 00:00:00 +0000</pubDate>
      <guid>/zh/blog/2019/05/20/%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E5%B8%AE%E5%8A%A9-i2p-bote-%E5%BC%95%E5%AF%BCbootstrap%E6%9D%A5%E5%8F%82%E4%B8%8E%E5%BF%97%E6%84%BF%E6%9C%8D%E5%8A%A1/</guid>
      <description>&lt;p&gt;帮助人们进行私密通信的一个简单方法，是运行一个 I2P-Bote 节点，它可以供新的 I2P-Bote 用户用来 bootstrap（引导）他们自己的 I2P-Bote 节点。不幸的是，直到现在，搭建一个 I2P-Bote bootstrap 节点的流程一直比它本该的更晦涩。其实这非常简单！&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;什么是 I2P-bote？&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;I2P-bote 是一个构建在 i2p 之上的私人消息系统，它具备额外的功能，使外界更难以辨别所传输消息的相关信息。基于此，它可以在容忍高延迟的情况下安全地传递私人消息，并且当发送方离线时，无需依赖集中式中继来发送消息。这与几乎所有其他流行的私人消息系统形成对比：后者要么要求双方同时在线，要么依赖于半可信的服务，在发送方离线时代为转发消息。&lt;/p&gt;&#xA;&lt;p&gt;或者，通俗地说：它的使用方式类似于电子邮件，但没有电子邮件在隐私方面的缺陷。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;第一步：安装 I2P-Bote&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;I2P-Bote 是一个 I2P 插件，安装非常容易。原始说明可在 &lt;a href=&#34;http://bote.i2p/install/&#34;&gt;bote eepSite, bote.i2p&lt;/a&gt;&#xA; 找到（eepSite 指 I2P 内部网站），但如果你想在明网阅读，以下说明由 bote.i2p 提供：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Go to the plugin install form in your routerconsole: http://127.0.0.1:7657/configclients#plugin&lt;/li&gt;&#xA;&lt;li&gt;Paste in the URL &lt;a href=&#34;http://bote.i&#34;&gt;http://bote.i&lt;/a&gt;&#xA;2p/i2pbote.su3&lt;/li&gt;&#xA;&lt;li&gt;Click Install Plugin.&lt;/li&gt;&#xA;&lt;li&gt;Once installed, click SecureMail in the routerconsole sidebar or homepage, or go to http://127.0.0.1:7657/i2pbote/&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;&lt;strong&gt;第二步：获取你的 I2P-Bote 节点的 base64 地址&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;这一步可能会让人卡住，但别担心。尽管相关说明不太好找，其实操作并不复杂，而且根据你的具体情况，有多种工具和选项可供使用。对于想以志愿者身份帮助运行引导节点的人来说，最佳方法是从 Bote tunnel 使用的私钥文件中提取所需信息。&lt;/p&gt;</description>
    </item>
    <item>
      <title>I2P 实验室</title>
      <link>/zh/blog/2019/02/14/i2p-%E5%AE%9E%E9%AA%8C%E5%AE%A4/</link>
      <pubDate>Thu, 14 Feb 2019 00:00:00 +0000</pubDate>
      <guid>/zh/blog/2019/02/14/i2p-%E5%AE%9E%E9%AA%8C%E5%AE%A4/</guid>
      <description>&lt;p&gt;大家好，&lt;/p&gt;&#xA;&lt;p&gt;在 I2P 世界里有许多让我们兴奋的项目，但它们并非都已成熟到可以广泛使用。我们决定创建一个地方，把这些项目提供给任何有兴趣尝试的人，同时作为那些未来有望成为官方 I2P 产品的项目的试验场。这个地方就是 &lt;a href=&#34;https://geti2p.net/en/download/lab&#34;&gt;I2P 实验室&lt;/a&gt;&#xA;。&lt;/p&gt;&#xA;&lt;p&gt;在实验室中，我们会提供可供您试用的下载。请注意，它们不会达到“正式版（release）”的质量标准，有些甚至可能达不到“测试版（beta）”的质量。我们不为其提供官方支持。任何实验室项目都可能随时被中止。&lt;/p&gt;&#xA;&lt;p&gt;如果你富有冒险精神，我们邀请你来尝试我们的想法。我们欢迎你在 &lt;a href=&#34;https://i2pforum.net/viewforum.php?f=36&#34;&gt;I2P Lab Forum&lt;/a&gt;&#xA; 提出反馈。&lt;/p&gt;</description>
    </item>
    <item>
      <title>使用 Python 和 I2P 开发注重隐私的应用程序</title>
      <link>/zh/blog/2018/10/23/%E4%BD%BF%E7%94%A8-python-%E5%92%8C-i2p-%E5%BC%80%E5%8F%91%E6%B3%A8%E9%87%8D%E9%9A%90%E7%A7%81%E7%9A%84%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/</link>
      <pubDate>Tue, 23 Oct 2018 00:00:00 +0000</pubDate>
      <guid>/zh/blog/2018/10/23/%E4%BD%BF%E7%94%A8-python-%E5%92%8C-i2p-%E5%BC%80%E5%8F%91%E6%B3%A8%E9%87%8D%E9%9A%90%E7%A7%81%E7%9A%84%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/</guid>
      <description>&lt;p&gt;&lt;figure&gt;&#xA;  &lt;img &#xA;    src=&#34;https://geti2p.net/images/blog/i2plib.jpeg&#34; &#xA;    alt=&#34;i2plib&#34;loading=&#34;lazy&#34;&#xA;    decoding=&#34;async&#34;&gt;&lt;/figure&gt;&#xA;&#xA;&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://geti2p.net/&#34;&gt;Invisible Internet Project&lt;/a&gt;&#xA;（I2P）提供用于开发注重隐私的应用程序的框架。它是构建在常规互联网之上的虚拟网络，在其中，主机可以在不泄露其“真实”IP 地址的情况下交换数据。I2P 网络内部的连接是在称为&lt;em&gt;I2P destinations&lt;/em&gt;（I2P 目标地址）的虚拟地址之间建立的。可以根据需要拥有任意数量的 destinations，甚至可以为每次连接使用一个新的 destination；它们不会向对端透露任何关于真实 IP 地址的信息。&lt;/p&gt;&#xA;&lt;p&gt;本文介绍开发 I2P 应用程序时需要了解的基本概念。代码示例使用 Python 编写，并使用内置的异步框架 asyncio。&lt;/p&gt;&#xA;&lt;h2 id=&#34;启用-sam-api-并安装-i2plib&#34;&gt;启用 SAM API 并安装 i2plib&lt;/h2&gt;&#xA;&lt;p&gt;I2P 为客户端应用程序提供了多种不同的 API。常规的客户端-服务器应用可以使用 I2PTunnel、HTTP 和 Socks 代理，Java 应用通常使用 I2CP。对于使用其他语言（例如 Python）进行开发，最佳选择是 &lt;a href=&#34;../../../zh/docs/api/samv3/&#34;&gt;SAM&lt;/a&gt;&#xA;。在原始的 Java 客户端实现中，默认禁用 SAM，因此需要将其启用。进入 Router Console，打开页面 &amp;ldquo;I2P internals&amp;rdquo; -&amp;gt; &amp;ldquo;Clients&amp;rdquo;。勾选 &amp;ldquo;Run at Startup&amp;rdquo;，点击 &amp;ldquo;Start&amp;rdquo;，然后 &amp;ldquo;Save Client Configuration&amp;rdquo;。&lt;/p&gt;&#xA;&lt;p&gt;&lt;figure&gt;&#xA;  &lt;img &#xA;    src=&#34;https://geti2p.net/images/enable-sam.jpeg&#34; &#xA;    alt=&#34;启用 SAM API&#34;loading=&#34;lazy&#34;&#xA;    decoding=&#34;async&#34;&gt;&lt;/figure&gt;&#xA;&#xA;&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://i2pd.website&#34;&gt;C++ 实现 i2pd&lt;/a&gt;&#xA; 默认启用 SAM。&lt;/p&gt;&#xA;&lt;p&gt;我开发了一个用于 SAM API 的实用 Python 库，名为 &lt;a href=&#34;https://github.com/l-n-s/i2plib&#34;&gt;i2plib&lt;/a&gt;&#xA;。你可以通过 pip 安装，或从 GitHub 手动下载源代码。&lt;/p&gt;</description>
    </item>
    <item>
      <title>NTCP2 实现细节</title>
      <link>/zh/blog/2018/08/20/ntcp2-%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82/</link>
      <pubDate>Mon, 20 Aug 2018 00:00:00 +0000</pubDate>
      <guid>/zh/blog/2018/08/20/ntcp2-%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82/</guid>
      <description>&lt;p&gt;I2P 的传输协议最初是在大约 15 年前开发的。当时的主要目标是隐藏传输的数据，而不是隐藏正在使用该协议这一事实。那时几乎没人认真考虑如何抵御 DPI（深度包检测）和对协议的审查。时代变了，尽管最初的传输协议仍然提供很强的安全性，但人们也需要一种新的传输协议。NTCP2 的设计旨在抵御当下的审查威胁，尤其是针对 DPI 对数据包长度的分析。此外，该新协议采用了最新的密码学成果。NTCP2 基于 &lt;a href=&#34;https://noiseprotocol.org/noise.html&#34;&gt;Noise Protocol Framework&lt;/a&gt;&#xA;（Noise 协议框架），使用 SHA256 作为哈希函数，并采用 x25519 作为椭圆曲线 Diffie–Hellman（DH）密钥交换。&lt;/p&gt;&#xA;&lt;p&gt;NTCP2 协议的完整规范可在&lt;a href=&#34;../../../zh/docs/specs/ntcp2/&#34;&gt;此处&lt;/a&gt;&#xA;找到。&lt;/p&gt;&#xA;&lt;h2 id=&#34;新的密码学&#34;&gt;新的密码学&lt;/h2&gt;&#xA;&lt;p&gt;NTCP2 要求在 I2P 的实现中添加以下加密算法：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;x25519&lt;/li&gt;&#xA;&lt;li&gt;HMAC-SHA256&lt;/li&gt;&#xA;&lt;li&gt;Chacha20&lt;/li&gt;&#xA;&lt;li&gt;Poly1305&lt;/li&gt;&#xA;&lt;li&gt;AEAD&lt;/li&gt;&#xA;&lt;li&gt;SipHash&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;与我们最初的协议 NTCP 相比，NTCP2 在 DH（Diffie-Hellman）功能上使用 x25519 替代 ElGamal，采用 AEAD/Chaha20/Poly1305 替代 AES-256-CBC/Adler32，并使用 SipHash 来混淆数据包的长度信息。NTCP2 所使用的密钥派生函数更加复杂，现在会使用大量的 HMAC-SHA256 调用。&lt;/p&gt;&#xA;&lt;p&gt;&lt;em&gt;i2pd（C++）实现说明：上述所有算法（除 SipHash 外）均已在 OpenSSL 1.1.0 中实现。SipHash 将在即将发布的 OpenSSL 1.1.1 版本中加入。为兼容当前大多数系统使用的 OpenSSL 1.0.2，i2pd 核心开发者 &lt;a href=&#34;https://github.com/majestrate&#34;&gt;Jeff Becker&lt;/a&gt;&#xA; 贡献了缺失密码算法的独立实现。&lt;/em&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;routerinfo-变更&#34;&gt;RouterInfo 变更&lt;/h2&gt;&#xA;&lt;p&gt;NTCP2 需要在现有的两把（加密密钥和签名密钥）之外再增加第三把（x25519）密钥。它称为静态密钥（static key），必须作为&amp;quot;s&amp;quot;参数添加到 RouterInfo 的地址中。该要求适用于 NTCP2 的发起方（Alice）和响应方（Bob）。如果有多个地址支持 NTCP2，例如 IPv4 和 IPv6，则所有这些地址的&amp;quot;s&amp;quot;必须相同。允许 Alice 的地址仅包含&amp;quot;s&amp;quot;参数，而不设置&amp;quot;host&amp;quot;和&amp;quot;port&amp;quot;。此外，还需要一个&amp;quot;v&amp;quot;参数，目前总是设为&amp;quot;2&amp;quot;。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>

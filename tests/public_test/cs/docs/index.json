[{"categories":null,"content":"Hlavní implementace I2P klienta používá Java. Pokud na konkrétním systému nemůžete nebo nechcete používat Javu, existují alternativní implementace I2P klienta vyvíjené a udržované členy komunity. Tyto programy poskytují stejnou základní funkčnost s využitím různých programovacích jazyků nebo přístupů.\nSrovnávací tabulka Client Language Maturity Actively Maintained Suitable For Notes Java I2P Java Stable ✅ Yes (official) General users Standard full router; includes console, plugins, and tools i2pd C++ Stable ✅ Yes Low-resource systems, servers Lightweight, fully compatible with Java I2P, includes web console Go-I2P Go Experimental ⚙️ In development Developers, testing Early-stage Go implementation; not yet production ready I2P+ Java Stable (fork) ✅ Yes Advanced users Enhanced Java I2P fork with UI and performance improvements --- i2pd (C++) Webové stránky: https://i2pd.website Popis: i2pd (I2P Daemon) je plně vybavený I2P klient implementovaný v C++. Je stabilní pro produkční použití již mnoho let (přibližně od roku 2016) a je aktivně udržován komunitou. i2pd plně implementuje síťové protokoly a API I2P, což ho činí zcela kompatibilním se sítí Java I2P. Tento C++ router je často používán jako odlehčená alternativa na systémech, kde Java runtime není k dispozici nebo není žádoucí. i2pd obsahuje vestavěnou webovou konzoli pro konfiguraci a monitorování. Je multiplatformní a dostupný v mnoha balíčkovacích formátech — existuje dokonce i Android verze i2pd (například prostřednictvím F-Droid).\nGo-I2P (Go) Repozitář: https://github.com/go-i2p/go-i2p Popis: Go-I2P je I2P klient napsaný v programovacím jazyce Go. Jedná se o nezávislou implementaci I2P routeru, která se snaží využít efektivity a přenositelnosti jazyka Go. Projekt je aktivně vyvíjen, ale stále se nachází v rané fázi a zatím není plně funkční. K roku 2025 je Go-I2P považován za experimentální — je aktivně vyvíjen komunitními vývojáři, ale není doporučen pro produkční použití, dokud nedosáhne vyšší úrovně zralosti. Cílem Go-I2P je poskytnout moderní, odlehčený I2P router s plnou kompatibilitou se sítí I2P po dokončení vývoje.\nI2P+ (Java fork) Webová stránka: https://i2pplus.github.io Popis: I2P+ je komunitou udržovaná odnož standardního Java I2P klienta. Nejedná se o reimplementaci v novém jazyce, ale spíše o vylepšenou verzi Java routeru s dodatečnými funkcemi a optimalizacemi. I2P+ se zaměřuje na poskytování vylepšené uživatelské zkušenosti a lepšího výkonu při zachování plné kompatibility s oficiální I2P sítí. Přináší osvěženější rozhraní webové konzole, uživatelsky přívětivější možnosti konfigurace a různé optimalizace (například zlepšený výkon torrentů a lepší správu síťových peerů, zejména pro routery za firewally). I2P+ vyžaduje Java prostředí stejně jako oficiální I2P software, takže není řešením pro prostředí bez Javy. Pro uživatele, kteří však Java mají a chtějí alternativní sestavení s extra možnostmi, poskytuje I2P+ přesvědčivou volbu. Tato odnož je udržována aktuální s upstream I2P vydáními (s číslem verze doplněným o \u0026ldquo;+\u0026rdquo;) a lze ji získat z webové stránky projektu.\n","description":"Komunitou spravované implementace I2P klienta (aktualizováno pro rok 2025)","id":"fdcfc5a7a482cf9fe8fe449e9198b146","section":"docs","title":"Alternativní I2P klienti","url":"/cs/docs/overview/alternative-clients/"},{"categories":null,"content":"Přehled Standardní adresy Base 32 (\u0026ldquo;b32\u0026rdquo;) obsahují hash destinace. To nebude fungovat pro šifrované LS2 (návrh 123).\nTradiční adresu Base32 nemůžeme použít pro šifrovaný LS2 (LeaseSet2; návrh 123), protože obsahuje pouze hash destinace. Neposkytuje nezaslepený veřejný klíč. Klienti musí znát veřejný klíč destinace, typ podpisu, typ zaslepeného podpisu a volitelné tajemství nebo soukromý klíč, aby bylo možné leaseset získat a dešifrovat. Samotná adresa Base32 tedy nestačí. Klient potřebuje buď úplnou destinaci (která obsahuje veřejný klíč), nebo samotný veřejný klíč. Pokud má klient úplnou destinaci v adresáři a adresář podporuje reverzní vyhledávání podle hashe, pak lze veřejný klíč získat.\nTento formát ukládá do adresy ve formátu base32 namísto hashe veřejný klíč. Tento formát musí také obsahovat typ podpisu veřejného klíče a typ podpisu schématu zaslepení.\nTento dokument specifikuje formát b32 pro tyto adresy. Ačkoli jsme se během diskusí na tento nový formát odkazovali jako na adresu \u0026ldquo;b33\u0026rdquo;, skutečný nový formát si ponechává obvyklou příponu \u0026ldquo;.b32.i2p\u0026rdquo;.\nStav implementace Návrh 123 (New netDB Entries) byl plně implementován ve verzi 0.9.43 (říjen 2019). Sada funkcí šifrovaného LS2 (nová verze leaseSet v I2P) zůstala stabilní až do verze 2.10.0 (září 2025) bez zpětně nekompatibilních změn ve formátu adresace ani v kryptografických specifikacích.\nKlíčové milníky implementace: - 0.9.38: Podpora Floodfill pro standardní LS2 s offline klíči - 0.9.39: RedDSA typ podpisu 11 a základní šifrování/dešifrování - 0.9.40: Kompletní podpora adresování B32 (Návrh 149) - 0.9.41: Ověřování na bázi X25519 pro jednotlivé klienty - 0.9.42: Všechny funkce zaslepení jsou v provozu - 0.9.43: Dokončená implementace oznámena (říjen 2019)\nNávrh Nový formát obsahuje odslepený veřejný klíč, typ odslepeného podpisu a typ zaslepeného podpisu. Volitelně uvádí požadavky na secret (tajemství) a/nebo soukromý klíč pro soukromé odkazy. Používá stávající příponu \u0026ldquo;.b32.i2p\u0026rdquo;, ale s delší délkou. Obsahuje kontrolní součet pro detekci chyb. Adresy šifrovaných leaseSet se poznají podle 56 a více zakódovaných znaků (35 a více dekódovaných bajtů), oproti 52 znakům (32 bajtům) u tradičních adres base 32. Specifikace Vytváření a kódování Sestavte název hostitele ve tvaru {56+ chars}.b32.i2p (35+ znaků v binární podobě) následovně:\nflag (1 byte) bit 0: 0 for one-byte sigtypes, 1 for two-byte sigtypes bit 1: 0 for no secret, 1 if secret is required bit 2: 0 for no per-client auth, 1 if client private key is required bits 7-3: Unused, set to 0 public key sigtype (1 or 2 bytes as indicated in flags) If 1 byte, the upper byte is assumed zero blinded key sigtype (1 or 2 bytes as indicated in flags) If 1 byte, the upper byte is assumed zero public key Number of bytes as implied by sigtype Následné zpracování a kontrolní součet:\nConstruct the binary data as above. Treat checksum as little-endian. Calculate checksum = CRC-32(data[3:end]) data[0] ^= (byte) checksum data[1] ^= (byte) (checksum \u0026gt;\u0026gt; 8) data[2] ^= (byte) (checksum \u0026gt;\u0026gt; 16) hostname = Base32.encode(data) || \u0026#34;.b32.i2p\u0026#34; Jakékoli nevyužité bity na konci b32 (kódování base32) musí být 0. U standardní 56znakové (35bajtové) adresy žádné nevyužité bity nejsou.\nDekódování a ověření strip the \u0026#34;.b32.i2p\u0026#34; from the hostname data = Base32.decode(hostname) Calculate checksum = CRC-32(data[3:end]) Treat checksum as little-endian. flags = data[0] ^ (byte) checksum if 1 byte sigtypes: pubkey sigtype = data[1] ^ (byte) (checksum \u0026gt;\u0026gt; 8) blinded sigtype = data[2] ^ (byte) (checksum \u0026gt;\u0026gt; 16) else (2 byte sigtypes): pubkey sigtype = data[1] ^ ((byte) (checksum \u0026gt;\u0026gt; 8)) || data[2] ^ ((byte) (checksum \u0026gt;\u0026gt; 16)) blinded sigtype = data[3] || data[4] parse the remainder based on the flags to get the public key Bity tajného a soukromého klíče Příznakové bity „secret“ a „private key“ se používají k indikaci klientům, proxy serverům nebo jinému klientskému kódu, že k dešifrování leaseSet bude vyžadováno tajemství a/nebo soukromý klíč. Konkrétní implementace mohou uživatele vyzvat k poskytnutí požadovaných údajů, nebo pokusy o připojení odmítnout, pokud požadované údaje chybí.\nTyto bity slouží pouze jako indikátory. Tajný ani soukromý klíč nesmí být nikdy součástí samotné B32 adresy, protože by to ohrozilo bezpečnost.\nKryptografické podrobnosti Schéma zaslepení Zaslepovací schéma používá RedDSA (varianta digitálního podpisu založená na EdDSA) vycházející z Ed25519 a návrhu ZCash, přičemž vytváří podpisy Red25519 nad křivkou Ed25519 s využitím SHA-512. Tento postup zajišťuje, že zaslepené veřejné klíče zůstávají v podgrupě s prvočíselným řádem, čímž se vyhýbá bezpečnostním rizikům, která se vyskytují v některých alternativních návrzích.\nBlinded keys (zaslepené klíče) se rotují denně na základě data UTC podle vzorce:\nblinded_key = BLIND(unblinded_key, date, optional_secret) Umístění úložiště v DHT se vypočítá takto:\nSHA256(type_byte || blinded_public_key) Šifrování Šifrovaný leaseset používá pro šifrování proudovou šifru ChaCha20, zvolenou kvůli vyššímu výkonu na zařízeních bez hardwarové akcelerace AES. Specifikace používá HKDF pro odvozování klíčů a X25519 pro operace Diffie‑Hellman.\nŠifrované leasesets mají třívrstvou strukturu: - Vnější vrstva: metadata v prostém textu - Střední vrstva: autentizace klienta (metody DH nebo PSK) - Vnitřní vrstva: vlastní data LS2 s informacemi o leasech (záznam o použitelnosti tunelu v I2P)\nMetody autentizace Ověřování pro jednotlivé klienty podporuje dvě metody:\nOvěřování DH: Využívá dohodu o klíči X25519. Každý autorizovaný klient poskytne serveru svůj veřejný klíč a server zašifruje prostřední vrstvu pomocí sdíleného tajemství odvozeného z ECDH.\nOvěřování pomocí PSK: Používá předem sdílené klíče přímo k šifrování.\nPříznakový bit 2 v adrese B32 určuje, zda je vyžadováno ověřování jednotlivých klientů.\nUkládání do mezipaměti Byť je to mimo rozsah této specifikace, routers a klienti si musí pamatovat a ukládat do mezipaměti (doporučeno trvalé uložení) mapování veřejného klíče na destinaci a naopak.\nblockfile naming service (pojmenovávací služba využívající formát blockfile), výchozí systém adresářů I2P od verze 0.9.8, spravuje více adresářů s vyhrazenou mapou pro zpětné vyhledávání, která umožňuje rychlé vyhledávání podle hashe. Tato funkce je zásadní pro získání šifrovaného leaseSet, když je zpočátku znám pouze hash.\nTypy podpisů Od verze I2P 2.10.0 jsou definovány typy podpisů 0 až 11. Jednobajtové kódování zůstává standardem, přičemž dvojbajtové kódování je k dispozici, ale v praxi se nepoužívá.\nBěžně používané typy: - Typ 0 (DSA_SHA1): Zastaralý pro routers, podporovaný pro destinace - Typ 7 (EdDSA_SHA512_Ed25519): Současný standard pro identity routers i destinace - Typ 11 (RedDSA_SHA512_Ed25519): Výhradně pro šifrované LS2 leasesets s podporou zaslepení\nDůležité upozornění: Pouze Ed25519 (typ 7) a Red25519 (typ 11) podporují zaslepení nezbytné pro šifrované leasesets. Jiné typy podpisů nelze s touto funkcí použít.\nTypy 9-10 (algoritmy GOST) zůstávají vyhrazené, ale neimplementované. Typy 4-6 a 8 jsou označeny jako \u0026ldquo;pouze offline\u0026rdquo; pro offline podpisové klíče.\nPoznámky Kompatibilita verzí Tato specifikace je přesná pro I2P verzi 0.9.47 (srpen 2020) až po verzi 2.10.0 (září 2025). Během tohoto období nedošlo k žádným nekompatibilním změnám v adresním formátu B32, šifrované struktuře LS2 ani v kryptografických implementacích. Všechny adresy vytvořené ve verzi 0.9.47 zůstávají plně kompatibilní s aktuálními verzemi.\nReference CRC-32 - CRC-32 (Wikipedie) - RFC 3309: Kontrolní součet SCTP (Stream Control Transmission Protocol) Specifikace I2P - Specifikace šifrovaného LeaseSetu - Návrh 123: Nové záznamy netDB - Návrh 149: B32 pro šifrovaný LS2 - Specifikace společných struktur - Pojmenovávání a adresář Srovnání s Torem - Diskusní vlákno o Toru (kontext návrhu) Další zdroje - Projekt I2P - Fórum I2P - Dokumentace Java API ","description":"Formát adresy Base 32 pro šifrované LS2 leasesets","id":"cac162c86c1b599cb6bab03e6270c404","section":"docs","title":"B32 pro šifrované leaseSets","url":"/cs/docs/specs/b32-for-encrypted-leasesets/"},{"categories":null,"content":"Bezpečnostní kontakt Pro nahlášení bezpečnostních zranitelností nebo citlivých bezpečnostních problémů prosím kontaktujte I2P Security Team na adrese security@i2p.net Pro bezpečnou komunikaci prosím použijte náš PGP klíč níže.\nInformace o PGP klíči Email: security@i2p.net ID klíče: 176E1941 Otisk: 40DF FE20 7D79 9BEC 3AE8 7DEA 5F98 BE91 176E 1941 Typ klíče: RSA 4096-bit Vytvořeno: 19. října 2025 Vyprší: 19. listopadu 2030 UID: I2P Security \u0026lt;security@i2p.net\u0026gt; Veřejný klíč Následuje veřejný GPG klíč pro I2P Security Team: \u0026mdash;\u0026ndash;BEGIN PGP PUBLIC KEY BLOCK\u0026mdash;\u0026ndash;\nmQINBGj1TtUBEADKsCC54egdJgxMs4HWcsYlr4GbrevM5gjZ+QZYEDGjaz44duOc E9W+a/NNA8PsryCql893odYdqGrFX+WTUT3UuN7DbbS7qSDs7jWZzjj0lr4/pbzJ B28lC0aIx6SQTEbzsGr2hOlFq/+JD9x/fMFrHFX81cJdIz9yabcH1vg9wPuhwkUS 5v2GFtvODCmSxQEJHSWvL2PkGiYEEZMKVXF5msdqJZK5/Dwp3UgVNeAkUYEHU6px Vu/YUpGo07/LNW5FfGDGf0pWYQ/9Tu5ykno3q3EA7TwWoVwbDK0hh9mpbZYiWSoy PSbIWNpwVMwGri4+KFjCEyG8DLzDlM4UMrK3PnrPh4M4+4a+flR+CMNeM1lyioC3 +jJf3TEOjvUsMzbwoDEE6O0wxBtfFC0xzzDDCAVrPvEZ3lt0do3kVHLbYS6ZXHkX ZwZWNBDWr2mSG9GU4oWizPIlq7MIhRYKA+ADqNxznxm9rtdfidk1tcLdyNUDjOwC jk/vQ8PCORbUYfytMhHzlRk7zieK6wBwr3aFFVgE8HxhgIZkAaUEbeej+dNADo6Z IFY+OF8mjpErcfJscCNgPSDbNid87dA78qRrqL6HLU2sek9g72EFpx2OVV7drkEp +Zy9kuiML4wWfOpC+kQa1Ka66E520U8Hs++cpf1LUOUmn1ajQDSfGoJMMwARAQAB tB9JMlAgU2VjdXJpdHkgPHNlY3VyaXR5QGkycC5uZXQ+iQJXBBMBCABBFiEEQN/+ IH15m+w66H3qX5i+kRduGUEFAmj1TtUCGwMFCQmQP4EFCwkIBwICIgIGFQoJCAsC BBYCAwECHgMCF4AACgkQX5i+kRduGUEEJhAAuZECNIWnC2UbrW/AXF8nPvFjpvLe kK7VQmMgno6iHRB1HAMh5hk3ZOYSRcjghcOHRpMFT64Uuc5vc9eBoegi5TDxYDkF Y9/ciEG5j2TXk93R/rY14UiH/kjFIhBAmc2t6Fs9R1m1vHHJtgY+KLqRF9fh2hc9 43odXnCrn5nhONtW+nb086eJEnJ4vsG/yR4EGzbu+fbrMJlycA/gZS63Q0rIcEJ2 VbZPCEXAf8LmebwxPxlboEuhXJSjCt1gWZwoKZlELaWdHliL3fUrMd3ojM5y66q3 ClO+7nWuwzKxKtZGKzxvF78o0O+HR4BbC16oQGpkT0yAij7ps/3KD2FJVQ/GQLef mpNQABfdVCPgcDS1p9/hjUoVHlRSC4gyehKX/C+H8Qvem92tzmJZy8PvcXaCsK/u wRxRwkoGhv0H5rsMOxfnB06dvT1Mo+KHED5j4y8C5DOnNpzHqwxJh1nQlJvLUvh8 LWIxiiE4+CeQ5V5YH7KfJmGq5ho93GgFmOXJvAuoFCoOLwXbQt9rMpq8iXM1RHRG E1AbB+KA3zcvAdzbgPtXlrOMkIfYO9xCyc8M0sfHB8b4RgrUs2tFz1fw3g4yE7ax 5ljquRefDmqBjtvu15FcZ4CA+I8FyVnrEb9jDTXyW7DiyM2kB7ZFeLpYytShbPq3 oJQMJYaGMoxDk025Ag0EaPVO1QEQAOuZtLOlab2EnuR5St05MXBpwtQUSWJzRckf w3NpnOl55+BavqsPl63rZYiO2lH9rAkZvfcL7auddQZSjDdsuPbUpsrQgsi2P9ig a3QiJOwSZzJ1qNb4VZSXrq2AqkBhCdw9rjpXGFfPNlClgVRbWpsGaQ5KtflnOA+I RfymidNXH0mDROBQuRh+2lkEYfANshjFjIqbI05tDic0KOab46R5MRVF7cihaMWp qPdxeYmvFWZ9lAnx5lMGwDdnGgfWFkU57lAd3NuHUnYIr/ExB/YgMdDeie5lQHKu svbcws9tIucUME9n8lGY77+1HlmNOCU4V12i4ZURJ4TwjHpScMOovkumtO4nXGRq GS8j1zeG7V9+yvdkSrclHJC33Mu6SPFC5SJBqU1G39/VpTD6CZPSPowZ0RlH2AVh D77Snrn53R3gziv5uxq+LpSJoafAx5tgIrg7HB+iJYRB1YVwIIHoT4YrBF01YyH6 cclkf3TNBjKgmtsynVw/TGy56nvR5lmt2uMq0Wwl4ZEwYPp+8ZmFuLbEHsI9RSdD iAdHoK9pEsTSxvzpcDTcG0CLZ4By/4oIKra6KuLr7XcB5eBmgXxrFBw4kveNWGW0 iEdg0xUVp8dxNjdZucB8m9qXQUUSmUxVjFYu4ee8tpo8iEVzu4wm4kOiOBKlwCn2 nOI72oGxABEBAAGJAjwEGAEIACYWIQRA3/4gfXmb7DrofepfmL6RF24ZQQUCaPVO 1QIbDAUJCZA/gQAKCRBfmL6RF24ZQShLD/9BlA+nLmJvwL3FYXm8JOqN07gPKlyQ +gWdV8p22Gawoq6dJLJanWURjn5Kfy30x2CSX6QwiaQG5aHHudNBF2h4Z/qEMcO5 ml5Dq7BP9R5VKmG4vwrL5ccNwuey1/d9Rtjt1zsd+52+x6dfjFv95o9j8jviIEoS HhhbO9ujmx3QLRNlg0SkG6ZlTALGp3EcKNdrV1vpF6ccgt3pdWYFB62N7q8zObHf bfOFMITJIXJJVKICCxzw3xOW2fMashjqf4Ic2UTFsAG3Hqqf5ASGbu4TyjFS3VXV JSzvdhGnxb7qJUzBImK9mGPRXYSV5d4g7kCFfgUg6KSFxbfYreEjCZXWJyqCr/VB eLpIhUWce/AiDPD8lGVD6sNevsNw4HhO6IyQu0pqbRAo+fJZNi+wcqOUqYlMczNw tUKw73QmFj0IqvyBr8Rfq9JC9O6ipyzalwK8uO0gmqOiK79zfnNIJaZ1+LM3Gh6n 3yluwq1df40lEU171i70IbSON6ekGNLTrvhTlDg6vHCMRfQR2UjA5FYBAtFXqQNG c4IYbu2UQm/191P77oI0vBEh3YnrD9eXtdYxgyT+Lj8RBJ+aM+IykK7c2mgOmlqb vYv+KkVFCpOyXrvSwId+3jHiGP6jis7vuzTwiG0S9EyOjxf9XIDowULuY28ntBB0 hOLK7ID/AeaOxA== =39fn \u0026mdash;\u0026ndash;END PGP PUBLIC KEY BLOCK\u0026mdash;\u0026ndash; ","description":"Veřejný klíč GPG pro kontaktování Bezpečnostního týmu I2P","id":"c65864821d13039a727e933e7e6e2891","section":"docs","title":"Bezpečnostní GPG klíč","url":"/cs/docs/develop/security-key/"},{"categories":null,"content":"Přehled BitTorrent přes I2P umožňuje anonymní sdílení souborů prostřednictvím šifrovaných tunelů pomocí I2P streaming vrstvy. Všichni účastníci jsou identifikováni kryptografickými I2P destinacemi místo IP adres. Systém podporuje HTTP a UDP trackery, hybridní magnet odkazy a post-kvantové hybridní šifrování.\n1. Zásobník protokolů Layer Function Example Application BitTorrent i2psnark, BiglyBT Transport Streaming / SAM v3 I2CP, NTCP2 Network Garlic routing I2NP Všechna spojení probíhají přes šifrovanou transportní vrstvu I2P (NTCP2 nebo SSU2). Dokonce i UDP tracker pakety jsou zapouzdřeny v rámci I2P streaming. 2. Trackery HTTP trackery Standardní .i2p trackery reagují na HTTP GET požadavky jako:\nhttp://tracker2.postman.i2p/announce?info_hash=\u0026lt;20-byte\u0026gt;\u0026amp;peer_id=\u0026lt;20-byte\u0026gt;\u0026amp;port=6881\u0026amp;uploaded=0\u0026amp;downloaded=0\u0026amp;left=1234\u0026amp;compact=1 Odpovědi jsou bencoded a používají I2P destination hashe pro peery.\nUDP Trackery UDP trackery byly standardizovány v roce 2025 (Návrh 160).\nPrimární UDP Trackery - udp://tracker2.postman.i2p/announce - udp://opentracker.simp.i2p/a - http://opentracker.skank.i2p/a - http://opentracker.dg2.i2p/a \u0026mdash;\n3. Magnetové odkazy magnet:?xt=urn:btih:\u0026lt;infohash\u0026gt;\u0026amp;dn=\u0026lt;name\u0026gt;\u0026amp;tr=http://tracker2.postman.i2p/announce\u0026amp;tr=udp://denpa.i2p/announce\u0026amp;xs=i2p:\u0026lt;destination.b32.i2p\u0026gt; Parameter Meaning xs=i2p:\u0026lt;dest\u0026gt; Explicit I2P destination tr= Tracker URLs (HTTP or UDP) dn= Display name Magnet odkazy podporují hybridní roje napříč I2P a clearnetem, pokud jsou nakonfigurovány. 4. Implementace DHT Implementation Type Status Java I2P Experimental overlay Stable i2pd UDP-based internal overlay Active BiglyBT SAM v3.3-based Fully supported --- 5. Implementace klientů I2PSnark Součástí všech routerů Podpora pouze HTTP trackerů Vestavěný tracker na http://127.0.0.1:7658/ Bez podpory UDP trackerů BiglyBT Plně vybavený s I2P pluginem Podporuje HTTP + UDP trackery Podpora hybridních torrentů Využívá rozhraní SAM v3.3 Tixati / XD Odlehčení klienti Tunelování založené na SAM Experimentální hybridní šifrování ML-KEM 6. Konfigurace I2PSnark i2psnark.dir=/home/user/torrents i2psnark.autostart=true i2psnark.maxUpBW=128 i2psnark.maxDownBW=256 i2psnark.enableDHT=false BiglyBT SAMHost=127.0.0.1 SAMPort=7656 SAMNickname=BiglyBT-I2P SAMAutoStart=true DHTEnabled=true 7. Bezpečnostní model Component Description Encryption NTCP2 / SSU2 with X25519+ML-KEM hybrid Identity I2P destinations replace IP addresses Anonymity Peer info hidden; traffic multiplexed Leak Prevention Remove headers (X-Forwarded-For, Client-IP, Via) Hybridní (clearnet + I2P) torrenty by měly být používány pouze pokud anonymita není kritická. 8. Výkon Factor Impact Recommendation Tunnel length Adds latency 1-hop client, 2-hop server Peers Boosts speed 20+ active peers Compression Minimal gain Usually off Bandwidth Router-limited Default settings optimal Typické rychlosti se pohybují v rozmezí **30–80 KB/s**, v závislosti na protistranách a stavu sítě. 9. Známé problémy Částečná interoperabilita DHT mezi Java I2P a i2pd Zpoždění načítání magnet metadat při vysokém zatížení NTCP1 zastaralý, ale stále používaný starými uzly UDP simulované přes streaming zvyšuje latenci 10. Budoucí plán QUIC-like multiplexing Plná integrace ML-KEM Sjednocená logika hybridního swarmu Vylepšené reseed zrcadla Adaptivní opakování DHT Reference BEP 15 – UDP Tracker Protocol Návrh 160 – UDP Tracker přes I2P Dokumentace I2PSnark Specifikace Streaming Library ","description":"Podrobná specifikace a přehled ekosystému pro BitTorrent v síti I2P","id":"5d0ca50c8763996448d3099a14dc36b0","section":"docs","title":"BitTorrent přes I2P","url":"/cs/docs/applications/bittorrent/"},{"categories":null,"content":" Upozornění: BOB (rozhraní Basic Open Bridge pro I2P) podporuje pouze zastaralý typ podpisu DSA-SHA1. Projekt Java I2P přestal dodávat BOB ve verzi 1.7.0 (2022-02); zůstává pouze na instalacích, které začínaly na verzi 1.6.1 nebo starší, a na některých sestaveních i2pd. Nové aplikace musí používat SAM v3 .\nJazykové vazby Go – ccondom Python – i2py-bob Twisted – txi2p C++ – bobcpp Poznámky k protokolu KEYS označuje destinaci v base64 (veřejné + soukromé klíče). KEY je veřejný klíč v base64. ERROR odpovědi mají tvar ERROR \u0026lt;description\u0026gt;\\n. OK značí dokončení příkazu; volitelná data následují na stejném řádku. DATA řádky průběžně posílají dodatečný výstup před závěrečným OK. Příkaz help je jedinou výjimkou: může nevrátit žádný výstup, aby signalizoval, že „takový příkaz neexistuje“.\nBanner při připojení BOB používá řádky ASCII ukončené znakem nového řádku (LF nebo CRLF). Po navázání spojení odešle:\nBOB \u0026lt;version\u0026gt; OK Aktuální verze: 00.00.10. Starší sestavení používala hexadecimální číslice psané velkými písmeny a nestandardní číslování.\nBOB Version Router Version Notes 00.00.100.9.8Latest defined version 00.00.00 – 00.00.0F—Development builds ## Základní příkazy Pro úplné podrobnosti o příkazech se připojte pomocí telnet localhost 2827 a spusťte help.\nCOMMAND OPERAND RETURNS help [command] NOTHING | OK \u0026lt;info\u0026gt; clear ERROR | OK getdest ERROR | OK \u0026lt;KEY\u0026gt; getkeys ERROR | OK \u0026lt;KEYS\u0026gt; getnick \u0026lt;tunnelname\u0026gt; ERROR | OK inhost \u0026lt;hostname | IP\u0026gt; ERROR | OK inport \u0026lt;port\u0026gt; ERROR | OK list ERROR | DATA... + OK lookup \u0026lt;hostname\u0026gt; ERROR | OK \u0026lt;KEY\u0026gt; nick \u0026lt;friendlyname\u0026gt; ERROR | OK outhost \u0026lt;hostname | IP\u0026gt; ERROR | OK outport \u0026lt;port\u0026gt; ERROR | OK quit ERROR | OK setkey \u0026lt;base64 destination\u0026gt; ERROR | OK start ERROR | OK status ERROR | DATA... + OK stop ERROR | OK Přehled zastarání BOB nepodporuje moderní typy podpisů, šifrované LeaseSets ani funkce transportní vrstvy. Rozhraní API je zmrazené; žádné nové příkazy nebudou přidány. Aplikace, které se stále spoléhají na BOB, by měly co nejdříve migrovat na SAM v3. ","description":"Zastaralé API pro správu destinací (zastaralé)","id":"97b881216518f8e2516b859bbca19c0b","section":"docs","title":"BOB – Basic Open Bridge (základní otevřený most)","url":"/cs/docs/legacy/bob/"},{"categories":null,"content":"Nápověda pro I2P Router Na jakých systémech poběží I2P? I2P je napsáno v programovacím jazyce Java. Bylo testováno na Windows, Linux, FreeBSD a OSX. K dispozici je také verze pro Android.\nPokud jde o využití paměti, I2P je ve výchozím nastavení nakonfigurováno tak, aby používalo 128 MB RAM. To je dostačující pro procházení webu a používání IRC. Jiné aktivity však mohou vyžadovat větší přidělení paměti. Například pokud chce někdo provozovat router s vysokou šířkou pásma, účastnit se I2P torrentů nebo provozovat skryté služby s vysokým provozem, je potřeba vyšší množství paměti.\nPokud jde o využití CPU, I2P bylo testováno na skromných systémech, jako je řada jednodeskových počítačů Raspberry Pi. Protože I2P intenzivně využívá kryptografické techniky, výkonnější CPU bude lépe zvládat zátěž generovanou I2P i úkoly související se zbytkem systému (tj. operační systém, GUI, další procesy např. prohlížení webu).\nDoporučuje se použít Sun/Oracle Java nebo OpenJDK.\nJe pro používání I2P vyžadována instalace Javy? Ano, Java je vyžadována pro používání I2P Core. Do našich jednoduchých instalátorů pro Windows, Mac OSX a Linux zahrnujeme Javu. Pokud používáte aplikaci I2P pro Android, budete ve většině případů potřebovat také Java runtime jako Dalvik nebo ART.\nCo je \u0026ldquo;I2P Site\u0026rdquo; a jak nakonfiguruji svůj prohlížeč, abych je mohl používat? I2P Site je běžná webová stránka s tím rozdílem, že je hostována uvnitř I2P. I2P sites mají adresy, které vypadají jako běžné internetové adresy, končící na \u0026ldquo;.i2p\u0026rdquo; v lidsky čitelné, nekryptografické podobě pro usnadnění lidem. Samotné připojení k I2P Site vyžaduje kryptografii, což znamená, že adresy I2P Site jsou také dlouhé \u0026ldquo;Base64\u0026rdquo; Destinations a kratší \u0026ldquo;B32\u0026rdquo; adresy. Možná budete muset provést dodatečnou konfiguraci pro správné procházení. Procházení I2P Sites vyžaduje aktivaci HTTP Proxy ve vaší instalaci I2P a následnou konfiguraci prohlížeče pro její použití. Pro více informací prozkoumejte sekci \u0026ldquo;Prohlížeče\u0026rdquo; níže nebo průvodce \u0026ldquo;Konfigurace prohlížeče\u0026rdquo;.\nCo znamenají čísla Aktivní x/y v konzoli routeru? Na stránce Peers ve vaší konzoli routeru můžete vidět dvě čísla - Active x/y. První číslo je počet peerů, kterým jste odeslali nebo od kterých jste obdrželi zprávu v posledních několika minutách. Druhé číslo je počet peerů viděných nedávno, toto číslo bude vždy větší nebo rovno prvnímu číslu.\nMůj router má velmi málo aktivních peerů, je to v pořádku? Ano, to může být normální, zejména když byl router právě spuštěn. Nové routery potřebují čas na spuštění a připojení ke zbytku sítě. Pro zlepšení integrace do sítě, doby provozu a výkonu zkontrolujte tato nastavení:\nSdílení šířky pásma - Pokud je router nakonfigurován ke sdílení šířky pásma, bude směrovat více provozu pro ostatní routery, což pomáhá integrovat ho se zbytkem sítě a zároveň zlepšuje výkon místního připojení. Lze nakonfigurovat na stránce http://localhost:7657/config . Síťové rozhraní - Ujistěte se, že na stránce http://localhost:7657/confignet není zadáno žádné rozhraní. To může snížit výkon, pokud váš počítač nemá více domovských připojení s více externími IP adresami. I2NP protokol - Ujistěte se, že router je nakonfigurován tak, aby očekával připojení na platném protokolu pro operační systém hostitele a prázdném nastavení sítě (Pokročilé). Nevyplňujte IP adresu do pole \u0026lsquo;Hostname\u0026rsquo; na stránce konfigurace sítě. I2NP protokol, který zde vyberete, bude použit pouze v případě, že ještě nemáte dostupnou adresu. Například většina bezdrátových připojení Verizon 4G a 5G ve Spojených státech blokuje UDP a nelze se k nim přes něj dostat. Jiní by používali UDP násilně, i když je pro ně dostupné. Vyberte rozumné nastavení ze seznamu I2NP protokolů. Jsem proti určitým typům obsahu. Jak mohu zabránit jejich distribuci, ukládání nebo přístupu k nim? Žádný takový obsah není ve výchozím nastavení nainstalován. Protože je však I2P peer-to-peer síť, je možné, že můžete náhodně narazit na zakázaný obsah. Zde je shrnutí, jak vás I2P chrání před nežádoucím zapojením do porušování vašich přesvědčení.\nDistribuce - Provoz je interní v rámci sítě I2P, nejste exit node (v naší dokumentaci označovaný jako outproxy). Úložiště - Síť I2P neprovádí distribuované ukládání obsahu, to musí být specificky nainstalováno a nakonfigurováno uživatelem (například s Tahoe-LAFS). To je funkce jiné anonymní sítě, Freenet . Provozováním I2P routeru neukládáte obsah pro nikoho. Přístup - Váš router nebude vyžadovat žádný obsah bez vašeho konkrétního pokynu k tomu. Je možné zablokovat I2P? Ano, zdaleka nejjednodušší a nejběžnější způsob je blokování bootstrap serverů, neboli \u0026ldquo;Reseed\u0026rdquo; serverů. Úplné blokování veškerého obfuskovaného provozu by také fungovalo (ačkoli by to narušilo mnoho dalších věcí, které nejsou I2P, a většina není ochotna zajít tak daleko). V případě blokování reseed serverů existuje reseed balíček na Github, jeho zablokováním zablokujete také Github. Můžete provést reseed přes proxy (mnoho jich lze najít na internetu, pokud nechcete použít Tor) nebo sdílet reseed balíčky na základě přátelství offline.\nV souboru wrapper.log se zobrazuje chyba s textem \u0026ldquo;Protocol family unavailable\u0026rdquo; při načítání konzole routeru Tato chyba se často vyskytuje u jakéhokoli síťového java softwaru na některých systémech, které jsou ve výchozím nastavení nakonfigurovány pro použití IPv6. Existuje několik způsobů, jak toto vyřešit:\nNa systémech založených na Linuxu můžete použít echo 0 \u0026gt; /proc/sys/net/ipv6/bindv6only Vyhledejte následující řádky v wrapper.config: #wrapper.java.additional.5=-Djava.net.preferIPv4Stack=true #wrapper.java.additional.6=-Djava.net.preferIPv6Addresses=false Pokud tam tyto řádky jsou, odkomentujte je odstraněním \u0026ldquo;#\u0026rdquo;. Pokud tam řádky nejsou, přidejte je bez \u0026ldquo;#\u0026rdquo;. Další možností by bylo odstranit ::1 z ~/.i2p/clients.config\nVAROVÁNÍ: Aby se jakékoli změny v wrapper.config projevily, musíte zcela zastavit router i wrapper. Kliknutí na Restart v konzoli routeru tento soubor NEPŘEČTE znovu! Musíte kliknout na Shutdown, počkat 11 minut a poté spustit I2P.\nVětšina I2P Sites v rámci I2P nefunguje? Pokud vezmete v úvahu každý I2P Site, který kdy byl vytvořen, ano, většina z nich je nedostupná. Lidé i I2P Sites přicházejí a odcházejí. Dobrým způsobem, jak začít v I2P, je podívat se na seznam I2P Sites, které jsou aktuálně v provozu. identiguy.i2p sleduje aktivní I2P Sites.\nProč I2P naslouchá na portu 32000? Tanuki java service wrapper, který používáme, otevírá tento port — vázaný na localhost — aby mohl komunikovat se softwarem běžícím uvnitř JVM. Když je JVM spuštěn, obdrží klíč, aby se mohl připojit k wrapperu. Poté, co JVM naváže své spojení s wrapperem, wrapper odmítne jakákoli další připojení.\nVíce informací naleznete v dokumentaci wrapperu .\nJak nakonfiguruji svůj prohlížeč? Konfigurace proxy pro různé prohlížeče je na samostatné stránce se snímky obrazovky. Pokročilejší konfigurace s externími nástroji, jako je rozšíření prohlížeče FoxyProxy nebo proxy server Privoxy, jsou možné, ale mohou do vašeho nastavení vnést bezpečnostní rizika.\nJak se připojím k IRC v rámci I2P? Tunel k hlavnímu IRC serveru v rámci I2P, Irc2P, je vytvořen při instalaci I2P (viz konfigurační stránka I2PTunnel ) a je automaticky spuštěn při startu I2P routeru. Pro připojení nastavte ve svém IRC klientovi připojení na localhost 6668. Uživatelé klientů typu HexChat mohou vytvořit novou síť se serverem localhost/6668 (nezapomeňte zaškrtnout \u0026ldquo;Obejít proxy server\u0026rdquo;, pokud máte nakonfigurovaný proxy server). Uživatelé Weechat mohou použít následující příkaz pro přidání nové sítě:\n/server add irc2p localhost/6668 Jak si mohu nastavit vlastní I2P Site? Nejjednodušší metodou je kliknout na odkaz i2ptunnel v konzoli routeru a vytvořit nový \u0026lsquo;Server Tunnel\u0026rsquo;. Dynamický obsah můžete poskytovat nastavením cílové destinace tunelu na port existującího webového serveru, například Tomcat nebo Jetty. Můžete také poskytovat statický obsah. Pro tento účel nastavte cílovou destinaci tunelu na: 0.0.0.0 port 7659 a umístěte obsah do adresáře ~/.i2p/eepsite/docroot/. (Na systémech jiných než Linux může být umístění jiné. Zkontrolujte konzoli routeru.) Software \u0026rsquo;eepsite\u0026rsquo; je součástí instalačního balíčku I2P a je nastaven tak, aby se automaticky spustil při startu I2P. Výchozí stránka, která se tímto vytvoří, je přístupná na http://127.0.0.1:7658. Váš \u0026rsquo;eepsite\u0026rsquo; je však přístupný i ostatním prostřednictvím vašeho souboru s klíčem eepsite, který se nachází v: ~/.i2p/eepsite/i2p/eepsite.keys. Pro více informací si přečtěte soubor readme na adrese: ~/.i2p/eepsite/README.txt.\nPokud na I2P doma hostím webovou stránku obsahující pouze HTML a CSS, je to nebezpečné? Záleží na vašem protivníkovi a vašem modelu hrozeb. Pokud se obáváte pouze korporátního porušování „soukromí\u0026quot;, běžných zločinců a cenzury, pak to není opravdu nebezpečné. Orgány činné v trestním řízení vás pravděpodobně stejně najdou, pokud budou skutečně chtít. Pouze hostování, když máte spuštěný běžný (internetový) domácí uživatelský prohlížeč, ztíží skutečné zjištění, kdo danou část hostuje. Považujte prosím hostování vaší I2P stránky stejně jako hostování jakékoli jiné služby - je to stejně nebezpečné - nebo bezpečné - jak to sami nakonfigurujete a spravujete.\nPoznámka: Již existuje způsob, jak oddělit hostování i2p služby (destination) od i2p routeru. Pokud rozumíte tomu, jak to funguje, můžete jednoduše nastavit samostatný stroj jako server pro webovou stránku (nebo službu), která bude veřejně přístupná, a přesměrovat ji na webserver přes [velmi] zabezpečený SSH tunel nebo použít zabezpečený, sdílený souborový systém.\nJak I2P nachází webové stránky „.i2p\u0026quot;? Aplikace I2P Adresář mapuje lidsky čitelná jména na dlouhodobé destinace spojené se službami, což ji činí podobnější souboru hosts nebo seznamu kontaktů než síťové databázi nebo DNS službě. Je také zaměřená na lokální úložiště – neexistuje uznávaný globální jmenný prostor, vy sami rozhodujete, na co se kterákoli daná .i2p doména nakonec mapuje. Střední cestou je něco, čemu se říká \u0026ldquo;Jump Service\u0026rdquo; (služba pro přesměrování), která poskytuje lidsky čitelné jméno tím, že vás přesměruje na stránku, kde budete dotázáni: \u0026ldquo;Dáváte I2P routeru oprávnění nazývat $SITE_CRYPTO_KEY jménem $SITE_NAME.i2p\u0026rdquo; nebo něco v tom smyslu. Jakmile je záznam v adresáři, můžete si generovat vlastní jump URL adresy, které pomohou sdílet web s ostatními.\nJak přidám adresy do Adresáře? Nemůžete přidat adresu, aniž byste znali alespoň base32 nebo base64 stránky, kterou chcete navštívit. \u0026ldquo;Hostname\u0026rdquo; (název hostitele), který je čitelný pro člověka, je pouze alias pro kryptografickou adresu, která odpovídá base32 nebo base64. Bez kryptografické adresy neexistuje způsob, jak přistupovat k I2P Site (I2P stránce), to je záměrné. Distribuce adresy lidem, kteří ji ještě neznají, je obvykle zodpovědností poskytovatele služby Jump. Návštěva neznámé I2P Site spustí použití služby Jump. stats.i2p je nejspolehlivější služba Jump.\nPokud hostujete stránku přes i2ptunnel, zatím nebude mít registraci u jump service. Chcete-li ji dát lokální URL, navštivte konfigurační stránku a klikněte na tlačítko \u0026ldquo;Add to Local Address Book\u0026rdquo; (Přidat do místního adresáře). Poté přejděte na http://127.0.0.1:7657/dns, kde najdete addresshelper URL a můžete ji sdílet.\nJaké porty I2P používá? Porty používané I2P lze rozdělit do 2 sekcí:\nPorty s přístupem k internetu, které se používají pro komunikaci s ostatními I2P routery Lokální porty pro místní připojení Ty jsou podrobně popsány níže.\n1. Porty otevřené do internetu Poznámka: Od verze 0.7.8 nové instalace nepoužívají port 8887; při prvním spuštění programu je vybrán náhodný port mezi 9000 a 31000. Vybraný port je zobrazen na konfigurační stránce routeru.\nODCHOZÍ\nUDP z náhodného portu uvedeného na konfigurační stránce na libovolné vzdálené UDP porty, umožňující odpovědi TCP z náhodných vysokých portů na libovolné vzdálené TCP porty Odchozí UDP na portu 123, umožňující odpovědi. To je nezbytné pro interní časovou synchronizaci I2P (prostřednictvím SNTP - dotazování na náhodný SNTP host v pool.ntp.org nebo jiný server, který určíte) PŘÍCHOZÍ\n(Volitelné, doporučeno) UDP na port uvedený na konfigurační stránce z libovolných umístění (Volitelné, doporučeno) TCP na port uvedený na konfigurační stránce z libovolných umístění Příchozí TCP může být zakázáno na konfigurační stránce 2. Lokální I2P porty Lokální I2P porty ve výchozím nastavení naslouchají pouze lokálním připojením, kromě případů, kde je uvedeno jinak:\nPORT PURPOSE DESCRIPTION 1900 UPnP SSDP UDP multicast listener Cannot be changed. Binds to all interfaces. May be disabled on confignet. 2827 BOB bridge A higher level socket API for clients. Disabled by default. May be enabled/disabled on configclients. May be changed in the bob.config file. 4444 HTTP proxy Configured on configclients, go to the page i2ptunnel to start/stop it and on the page I2P HTTP Proxy to configure it. Include in your browser's proxy configuration for HTTP 4445 HTTPS proxy Configured on configclients, go to the page i2ptunnel to start/stop it and on the page I2P HTTPS Proxy to configure it. Include in your browser's proxy configuration for HTTPS 6668 IRC proxy A tunnel to the inside-the-I2P IRC network. Disabled by default. Configured on the page irc.postman.i2p (IRC proxy) and may be enabled/disabled on the page i2ptunnel 7654 I2CP (client protocol) port For advanced client usage. Do not expose to an external network. 7656 SAM bridge A socket API for clients. Disabled by default. May be enabled/disabled on configclients and configured on sam. 7657 (or 7658 via SSL) Router console The router console provides valuable information about your router and the network, in addition to giving you access to configure your router and its associated applications. 7659 'eepsite' - an example webserver (Jetty) Included in the i2pinstall and i2pupdate packages - may be disabled if another webserver is available. May be configured on the page eepsite and disabled on the page i2ptunnel 7660 I2PTunnel UDP port for SSH Required for Grizzled's/novg's UDP support. Instances disabled by default. May be enabled/disabled and configured to use a different port on the page i2ptunnel. 123 NTP Port Used by NTP Time Sync. May be disabled/changed. ### V adresáři mi chybí spousta hostitelů. Jaké jsou dobré odkazy pro odběr? {#subscriptions} Adresář se nachází na http://localhost:7657/dns , kde najdete další informace.\nJaké jsou dobré odkazy na odběr adresáře?\nMůžete zkusit následující:\nhttp://stats.i2p/cgi-bin/newhosts.txt http://identiguy.i2p/hosts.txt Jak mohu přistupovat k webové konzoli z jiných počítačů nebo ji chránit heslem? Z bezpečnostních důvodů admin konzole routeru ve výchozím nastavení přijímá připojení pouze na lokálním rozhraní.\nExistují dvě metody pro vzdálený přístup ke konzoli:\nSSH tunel Konfigurace vaší konzole tak, aby byla dostupná na veřejné IP adrese s uživatelským jménem a heslem Níže jsou uvedeny podrobnosti:\nMetoda 1: SSH tunel\nPokud používáte unixový operační systém, toto je nejjednodušší metoda pro vzdálený přístup k vaší I2P konzoli. (Poznámka: SSH serverový software je k dispozici i pro systémy se systémem Windows, například https://github.com/PowerShell/Win32-OpenSSH )\nJakmile nakonfigurujete SSH přístup k vašemu systému, příznak \u0026lsquo;-L\u0026rsquo; se předává SSH s odpovídajícími argumenty - například:\nssh -L 7657:localhost:7657 (System_IP) kde \u0026lsquo;(System_IP)\u0026rsquo; je nahrazeno IP adresou vašeho systému. Tento příkaz přesměruje port 7657 (číslo před první dvojtečkou) na port 7657 vzdáleného systému (specifikovaného řetězcem \u0026rsquo;localhost\u0026rsquo; mezi první a druhou dvojtečkou) (číslo za druhou dvojtečkou). Vaše vzdálená konzole I2P bude nyní dostupná na vašem lokálním systému jako \u0026lsquo;http://localhost:7657\u0026rsquo; a bude k dispozici po celou dobu trvání vaší SSH relace.\nPokud chcete spustit SSH relaci bez inicializace shellu na vzdáleném systému, můžete přidat příznak \u0026lsquo;-N\u0026rsquo;:\nssh -NL 7657:localhost:7657 (System_IP) Metoda 2: Konfigurace vaší konzole tak, aby byla dostupná na veřejné IP adrese s uživatelským jménem a heslem\nOtevřete ~/.i2p/clients.config a nahraďte:\nclientApp.0.args=7657 ::1,127.0.0.1 ./webapps/ za:\nclientApp.0.args=7657 ::1,127.0.0.1,(System_IP) ./webapps/ kde nahradíte (System_IP) veřejnou IP adresou vašeho systému\nPřejděte na http://localhost:7657/configui a v případě potřeby přidejte uživatelské jméno a heslo pro konzoli - Přidání uživatelského jména a hesla je vysoce doporučeno pro zabezpečení vaší I2P konzole proti neoprávněným zásahům, které by mohly vést k deanonymizaci.\nPřejděte na http://localhost:7657/index a klikněte na „Graceful restart\u0026quot;, což restartuje JVM a znovu načte klientské aplikace\nJakmile se to spustí, měli byste nyní být schopni vzdáleně přistupovat ke své konzoli. Načtěte konzoli routeru na adrese http://(IP_systému):7657 a budete vyzváni k zadání uživatelského jména a hesla, které jste zadali v kroku 2 výše, pokud váš prohlížeč podporuje automatické ověřovací okno.\nPOZNÁMKA: V uvedené konfiguraci můžete zadat 0.0.0.0. Toto specifikuje rozhraní, ne síť nebo masku sítě. 0.0.0.0 znamená \u0026ldquo;navázat se na všechna rozhraní\u0026rdquo;, takže konzole bude dostupná jak na 127.0.0.1:7657, tak i na jakékoli LAN/WAN IP adrese. Buďte opatrní při používání této možnosti, protože konzole bude dostupná na VŠECH adresách nakonfigurovaných ve vašem systému.\nJak mohu používat aplikace z jiných počítačů? Prosím podívejte se na předchozí odpověď pro instrukce k používání přesměrování portů SSH a také se podívejte na tuto stránku ve vaší konzoli: http://localhost:7657/configi2cp Je možné použít I2P jako SOCKS proxy? SOCKS proxy je funkční od verze 0.7.1. Podporovány jsou SOCKS 4/4a/5. I2P nemá SOCKS outproxy, takže je omezeno pouze na použití v rámci I2P.\nMnoho aplikací prozrazuje citlivé informace, které vás mohou identifikovat na internetu, a to je riziko, kterého byste si měli být vědomi při používání I2P SOCKS proxy. I2P filtruje pouze data spojení, ale pokud program, který hodláte používat, odesílá tyto informace jako obsah, I2P nemá žádnou možnost ochránit vaši anonymitu. Například některé e-mailové aplikace odešlou IP adresu počítače, na kterém běží, na poštovní server. Doporučujeme používat nástroje nebo aplikace specifické pro I2P (jako je I2PSnark pro torrenty), nebo aplikace, o kterých je známo, že jsou bezpečné pro použití s I2P, včetně populárních doplňků dostupných pro Firefox .\nJak mohu přistupovat k IRC, BitTorrentu nebo jiným službám na běžném Internetu? Existují služby zvané Outproxy, které propojují I2P a Internet, podobně jako Tor Exit Nodes. Výchozí funkcionalitu outproxy pro HTTP a HTTPS poskytuje exit.stormycloud.i2p a provozuje ji StormyCloud Inc. Je nakonfigurována v HTTP Proxy. Navíc, pro ochranu anonymity, I2P ve výchozím nastavení neumožňuje vytvářet anonymní připojení k běžnému Internetu. Pro více informací prosím navštivte stránku Socks Outproxy .\nReseeds Můj router běží už několik minut a má nula nebo velmi málo připojení Nejprve zkontrolujte stránku http://127.0.0.1:7657/netdb v Router Console – vaši síťovou databázi. Pokud nevidíte ani jeden router uvedený v rámci I2P, ale konzole hlásí, že byste měli být za firewallem, pak se pravděpodobně nemůžete připojit k reseed serverům. Pokud vidíte jiné I2P routery uvedené, zkuste snížit počet maximálních připojení http://127.0.0.1:7657/config – možná váš router nezvládá tolik připojení.\nJak provést ruční reseed? Za normálních okolností vás I2P připojí k síti automaticky pomocí našich bootstrapových odkazů. Pokud přerušené internetové připojení způsobí selhání bootstrapování ze reseed serverů, jednoduchým způsobem bootstrapování je použití prohlížeče Tor (ve výchozím nastavení otevírá localhost), který funguje velmi dobře s http://127.0.0.1:7657/configreseed . Je také možné provést reseed I2P routeru ručně.\nPři použití prohlížeče Tor k reseedu můžete vybrat více URL najednou a pokračovat. Ačkoli výchozí hodnota, která je 2 (z více url), bude také fungovat, ale bude to pomalé.\nOchrana soukromí a bezpečnost Je můj router \u0026ldquo;výstupní uzel\u0026rdquo; (outproxy) do běžného internetu? Nechci, aby byl. Ne, váš router se podílí na přenosu end-to-end šifrovaného provozu přes síť i2p ke koncovému bodu náhodného tunelu, obvykle ne k outproxy, ale žádný provoz není předáván mezi vaším routerem a internetem přes transportní vrstvu. Jako koncový uživatel byste neměli provozovat outproxy, pokud nemáte zkušenosti se správou systémů a sítí.\nJe snadné detekovat používání I2P analýzou síťového provozu? Provoz I2P obvykle vypadá jako UDP provoz a o moc víc toho neodhaluje – a právě to, aby toho moc neodhaloval, je cílem. Také podporuje TCP. S určitým úsilím může pasivní analýza provozu klasifikovat provoz jako \u0026ldquo;I2P\u0026rdquo;, ale doufáme, že pokračující vývoj obfuskace provozu to dále omezí. Dokonce i poměrně jednoduchá vrstva obfuskace protokolu jako obfs4 zabrání cenzorům v blokování I2P (je to cíl, který I2P sleduje).\nJe používání I2P bezpečné? Záleží na vašem osobním modelu hrozeb. Pro většinu lidí je I2P mnohem bezpečnější než nepoužívat žádnou ochranu. Některé jiné sítě (jako Tor, mixminion/mixmaster) jsou pravděpodobně bezpečnější proti určitým protivníkům. Například I2P provoz nepoužívá TLS/SSL, takže nemá problémy s \u0026ldquo;nejslabším článkem\u0026rdquo;, které má Tor. I2P používalo hodně lidí v Sýrii během \u0026ldquo;Arabského jara\u0026rdquo; a v poslední době projekt zaznamenal větší růst v menších jazykových instalacích I2P na Blízkém a Středním východě. Nejdůležitější věc, kterou je třeba zde poznamenat, je, že I2P je technologie a potřebujete návod/průvodce pro zvýšení vašeho soukromí/anonymity na internetu. Také zkontrolujte svůj prohlížeč nebo importujte vyhledávač otisků (fingerprint) pro blokování útoků pomocí otisků s velmi velkou (což znamená: typicky dlouhé chvosty / velmi přesná rozmanitá datová struktura) databází o mnoha environmentálních věcech a nepoužívejte VPN, abyste snížili všechna rizika, která z ní sama plynou, jako je vlastní chování TLS cache a technická konstrukce poskytovatele služeb, který může být hacknut snadněji než vlastní desktopový systém. Možná použití izolovaného Tor V-Browseru s jeho skvělými anti-fingerprint ochranami a celkovou appguard-livetime-protection (ochrana aplikační stráže po dobu života) s povolením pouze pro nezbytnou systémovou komunikaci a poslední záchrannou vm-use (použití virtuálního stroje) s anti-spy disable skripty a live-cd pro odstranění jakéhokoli \u0026ldquo;téměř trvale možného rizika\u0026rdquo; a snížení všech rizik pomocí klesající pravděpodobnosti jsou dobrou volbou ve veřejné síti a top individuálním modelu rizik a může to být to nejlepší, co můžete udělat s tímto cílem pro použití i2p.\nV konzoli routeru vidím IP adresy všech ostatních I2P uzlů. Znamená to, že moji IP adresu vidí ostatní? Ano, pro ostatní I2P uzly, které znají váš router. Používáme to pro připojení ke zbytku I2P sítě. Adresy jsou fyzicky umístěny v objektech \u0026ldquo;routerInfos (klíč, hodnota)\u0026rdquo;, buď vzdáleně načtených nebo přijatých od partnera. \u0026ldquo;routerInfos\u0026rdquo; obsahuje některé informace (některé volitelné oportunisticky přidané), \u0026ldquo;publikované partnerem\u0026rdquo;, o samotném routeru pro bootstrapping (inicializaci). V tomto objektu nejsou žádné údaje o klientech. Bližší pohled pod kapotu vám řekne, že všichni jsou počítáni s nejnovějším typem vytváření identifikátorů zvaným \u0026ldquo;SHA-256 Hashes (nízké=Pozitivní hash(-klíč), vysoké=Negativní hash(+klíč))\u0026rdquo;. I2P síť má vlastní databázi dat routerInfos vytvořených během nahrávání a indexování, ale to závisí hluboce na realizaci tabulek klíč/hodnota a topologii sítě a stavu zatížení / stavu šířky pásma a pravděpodobnostech směrování pro uložení v databázových komponentách.\nJe používání outproxy bezpečné? Záleží na tom, jak definujete \u0026ldquo;bezpečné\u0026rdquo;. Outproxy servery jsou skvělé, když fungují, ale bohužel jsou provozovány dobrovolně lidmi, kteří mohou ztratit zájem nebo nemusí mít zdroje na jejich nepřetržitou údržbu – prosím mějte na paměti, že se můžete setkat s obdobími, kdy budou služby nedostupné, přerušované nebo nespolehlivé, a my nejsme s touto službou nijak spojeni a nemáme na ni žádný vliv.\nSamotné outproxy mohou vidět váš přicházející a odcházející provoz, s výjimkou end-to-end šifrovaných HTTPS/SSL dat, stejně jako váš poskytovatel internetu může vidět provoz přicházející a odcházející z vašeho počítače. Pokud vám váš poskytovatel internetu nevadí, s outproxy to nebude o nic horší.\nA co útoky typu \u0026ldquo;De-Anonymizing\u0026rdquo; (odhalení anonymity)? Pro velmi podrobné vysvětlení si přečtěte více v našich článcích o Modelu hrozeb . Obecně platí, že deanonymizace není triviální, ale je možná, pokud nejste dostatečně opatrní.\nPřístup k Internetu/Výkon Nemohu přistupovat k běžným internetovým stránkám přes I2P. Proxying na internetové stránky (eepsites, které vedou ven na internet) je poskytováno jako služba uživatelům I2P poskytovateli, kteří neblokují. Tato služba není hlavním zaměřením vývoje I2P a je poskytována dobrovolně. Eepsites, které jsou hostovány na I2P, by měly vždy fungovat bez outproxy. Outproxy jsou pohodlné, ale nejsou záměrně dokonalé ani velkou částí projektu. Mějte na paměti, že nemusí být schopny poskytovat vysoce kvalitní služby, jaké mohou poskytovat jiné služby I2P.\nNemohu přistupovat k https:// nebo ftp:// stránkám přes I2P. Výchozí HTTP proxy podporuje pouze outproxying HTTP a HTTPS.\nProč můj router využívá příliš mnoho procesoru? Nejprve se ujistěte, že máte nejnovější verzi všech součástí souvisejících s I2P – starší verze měly v kódu zbytečné sekce, které zatěžovaly procesor. Existuje také Log výkonu , který dokumentuje některá vylepšení výkonu I2P v průběhu času.\nMoje aktivní partnery / známé partnery / účastnické tunely / připojení / šířka pásma se dramaticky mění v čase! Je něco špatně? Celková stabilita sítě I2P je předmětem průběžného výzkumu. Značná část tohoto výzkumu se zaměřuje na to, jak drobné změny konfiguračních nastavení mění chování routeru. Jelikož je I2P peer-to-peer síť, akce ostatních uzlů budou mít vliv na výkon vašeho routeru.\nCo zpomaluje stahování, torrenty, procházení webu a vše ostatní na I2P ve srovnání s běžným internetem? I2P má různé ochranné mechanismy, které přidávají další směrování a další vrstvy šifrování. Také směruje provoz přes jiné uzly (tunnels), které mají svou vlastní rychlost a kvalitu, některé jsou pomalé, jiné rychlé. To vše vytváří značnou režii a provoz různou rychlostí v různých směrech. Záměrně všechny tyto věci způsobují, že je I2P pomalejší ve srovnání s přímým připojením na internetu, ale mnohem anonymnější a stále dostatečně rychlé pro většinu účelů.\nNíže je uveden příklad s vysvětlením, který pomůže poskytnout určitý kontext k úvahám o latenci a šířce pásma při používání I2P.\nPodívejte se na diagram níže. Znázorňuje spojení mezi klientem provádějícím požadavek přes I2P, serverem přijímajícím požadavek přes I2P a následně odpovídajícím zpět také přes I2P. Je zde také znázorněn okruh, kterým požadavek putuje.\nZ diagramu vyplývá, že boxy označené \u0026lsquo;P\u0026rsquo;, \u0026lsquo;Q\u0026rsquo; a \u0026lsquo;R\u0026rsquo; reprezentují odchozí tunnel pro \u0026lsquo;A\u0026rsquo; a boxy označené \u0026lsquo;X\u0026rsquo;, \u0026lsquo;Y\u0026rsquo; a \u0026lsquo;Z\u0026rsquo; reprezentují odchozí tunnel pro \u0026lsquo;B\u0026rsquo;. Podobně boxy označené \u0026lsquo;X\u0026rsquo;, \u0026lsquo;Y\u0026rsquo; a \u0026lsquo;Z\u0026rsquo; reprezentují příchozí tunnel pro \u0026lsquo;B\u0026rsquo;, zatímco boxy označené \u0026lsquo;P_1\u0026rsquo;, \u0026lsquo;Q_1\u0026rsquo; a \u0026lsquo;R_1\u0026rsquo; reprezentují příchozí tunnel pro \u0026lsquo;A\u0026rsquo;. Šipky mezi boxy ukazují směr provozu. Text nad a pod šipkami uvádí příklady šířky pásma mezi párem skoků a také příklady latencí.\nKdyž klient i server používají 3-hop tunnely po celou dobu, celkem 12 dalších I2P routerů se podílí na přeposílání provozu. 6 uzlů přeposílá provoz z klienta na server, který je rozdělen do 3-hop odchozího tunnelu z \u0026lsquo;A\u0026rsquo; (\u0026lsquo;P\u0026rsquo;, \u0026lsquo;Q\u0026rsquo;, \u0026lsquo;R\u0026rsquo;) a 3-hop příchozího tunnelu do \u0026lsquo;B\u0026rsquo; (\u0026lsquo;X\u0026rsquo;, \u0026lsquo;Y\u0026rsquo;, \u0026lsquo;Z\u0026rsquo;). Podobně 6 uzlů přeposílá provoz ze serveru zpět na klienta.\nNejprve můžeme zvážit latenci - čas, který trvá, než požadavek od klienta projde sítí I2P, dorazí na server a vrátí se zpět ke klientovi. Sečtením všech latencí vidíme, že:\n40 + 100 + 20 + 60 + 80 + 10 + 30 ms (client to server) + 60 + 40 + 80 + 60 + 100 + 20 + 40 ms (server to client) ----------------------------------- TOTAL: 740 ms Celková doba odezvy v našem příkladu činí 740 ms - což je rozhodně mnohem více, než by člověk normálně zaznamenal při prohlížení běžných internetových stránek.\nZadruhé můžeme zvážit dostupnou šířku pásma. Ta je určena nejpomalejším spojem mezi uzly od klienta k serveru, stejně jako při přenosu provozu ze serveru ke klientovi. U provozu směřujícího od klienta k serveru vidíme, že dostupná šířka pásma v našem příkladu mezi uzly \u0026lsquo;R\u0026rsquo; a \u0026lsquo;X\u0026rsquo; a také mezi uzly \u0026lsquo;X\u0026rsquo; a \u0026lsquo;Y\u0026rsquo; je 32 KB/s. Navzdory vyšší dostupné šířce pásma mezi ostatními uzly budou tyto uzly působit jako úzké hrdlo a omezí maximální dostupnou šířku pásma pro provoz z \u0026lsquo;A\u0026rsquo; do \u0026lsquo;B\u0026rsquo; na 32 KB/s. Podobně sledování cesty ze serveru ke klientovi ukazuje, že maximální šířka pásma je 64 KB/s - mezi uzly \u0026lsquo;Z_1\u0026rsquo; a \u0026lsquo;Y_1\u0026rsquo;, \u0026lsquo;Y_1\u0026rsquo; a \u0026lsquo;X_1\u0026rsquo; a \u0026lsquo;Q_1\u0026rsquo; a \u0026lsquo;P_1\u0026rsquo;.\nDoporučujeme zvýšit vaše limity šířky pásma. To pomáhá síti zvýšením množství dostupné šířky pásma, což následně zlepší váš zážitek s I2P. Nastavení šířky pásma najdete na stránce http://localhost:7657/config . Mějte prosím na paměti limity vašeho internetového připojení stanovené vaším poskytovatelem internetu a podle toho upravte své nastavení.\nDoporučujeme také nastavit dostatečné množství sdílené šířky pásma - to umožňuje směrování participujících tunelů přes váš I2P router. Povolení participujícího provozu udržuje váš router dobře integrovaný v síti a zlepšuje rychlost přenosu dat.\nI2P je průběžně vyvíjený projekt. Implementuje se mnoho vylepšení a oprav, a obecně platí, že používání nejnovější verze pomůže vašemu výkonu. Pokud jste tak ještě neučinili, nainstalujte nejnovější verzi.\nMyslím, že jsem našel chybu, kde ji mohu nahlásit? Můžete nahlásit jakékoli chyby/problémy, se kterými se setkáte, na našem bugtrackeru, který je dostupný jak přes běžný internet, tak přes I2P. Máme diskuzní fórum, které je také dostupné na I2P i běžném internetu. Můžete se také připojit k našemu IRC kanálu: buď přes naši IRC síť IRC2P, nebo na Freenode.\nNáš Bugtracker: Mimo soukromý internet: https://i2pgit.org/I2P_Developers/i2p.i2p/issues Na I2P: http://git.idk.i2p/I2P_Developers/i2p.i2p/issues Naše fóra: i2pforum.i2p Vložení logů: Můžete vložit jakékoli zajímavé logy do služby pro vkládání textu, jako jsou služby mimo soukromý internet uvedené na PrivateBin Wiki , nebo I2P služby pro vkládání textu, jako je tato instance PrivateBin nebo tato služba pro vkládání bez Javascriptu a pokračujte na IRC v #i2p IRC: Připojte se k #i2p-dev Diskutujte s vývojáři na IRC Prosím, uveďte relevantní informace ze stránky logů routeru, která je dostupná na: http://127.0.0.1:7657/logs . Žádáme vás, abyste sdíleli veškerý text v sekci \u0026lsquo;I2P Version and Running Environment\u0026rsquo; (Verze I2P a běhové prostředí) a také všechny chyby nebo varování zobrazené v různých logech na této stránce.\nMám otázku! Skvělé! Najdete nás na IRC:\nna irc.freenode.net kanálu #i2p na IRC2P kanálu #i2p nebo zveřejněte na fóru a my to zde zveřejníme (doufejme s odpovědí).\n","description":"Komplexní I2P FAQ: pomoc s routerem, konfigurace, reseedy, soukromí/bezpečnost, výkon a řešení problémů","id":"b0f8e4ee3509d229b406a0b0bb933ca4","section":"docs","title":"Často kladené otázky","url":"/cs/docs/overview/faq/"},{"categories":null,"content":"Přehled Datagramy poskytují komunikaci orientovanou na zprávy nad I2CP a paralelně s knihovnou pro streamování. Umožňují odpovídatelné, autentizované nebo surové pakety bez nutnosti spojově orientovaných streamů. Routery zapouzdřují datagramy do I2NP zpráv a tunnel zpráv bez ohledu na to, zda je přenos přenášen přes NTCP2 nebo SSU2.\nHlavní motivací je umožnit aplikacím (jako jsou trackery, DNS resolvery nebo hry) odesílat samostatné pakety, které identifikují svého odesílatele.\nNové v roce 2025: Projekt I2P schválil Datagram2 (protokol 19) a Datagram3 (protokol 20), které po deseti letech poprvé přidávají ochranu proti opakování zpráv a zasílání zpráv s nižší režijní zátěží, na které lze odpovědět.\n1. Konstanty protokolu Protocol Value Description Introduced PROTO_DATAGRAM 17 Signed (repliable) datagram – “Datagram1” Original PROTO_DATAGRAM_RAW 18 Unsigned (raw) datagram – no sender info Original PROTO_DATAGRAM2 19 Signed + replay-protected datagram API 0.9.66 (2025) PROTO_DATAGRAM3 20 Repliable (no signature, hash only) API 0.9.66 (2025) Protokoly 19 a 20 byly formalizovány v **Návrhu 163 (duben 2025)**. Koexistují s Datagram1 / RAW kvůli zpětné kompatibilitě. 2. Typy datagramů Type Protocol Repliable Authenticated Replay Protection Min Overhead Notes Raw 18 No No No 0 Minimal size; spoofable. Datagram1 17 Yes Yes No ≈ 427 Full Destination + signature. Datagram2 19 Yes Yes Yes ≈ 457 Replay prevention + offline signatures; PQ-ready. Datagram3 20 Yes No No ≈ 34 Sender hash only; low overhead. ### Typické návrhové vzory Požadavek → Odpověď: Odešlete podepsaný Datagram2 (požadavek + nonce), obdržíte odpověď RAW nebo Datagram3 (echo nonce). Vysoká frekvence/nízká režie: Preferujte Datagram3 nebo RAW. Autentizované kontrolní zprávy: Datagram2. Kompatibilita se starším systémem: Datagram1 stále plně podporován. 3. Podrobnosti o Datagram2 a Datagram3 (2025) Datagram2 (Protokol 19) Vylepšená náhrada za Datagram1. Funkce: - Ochrana proti opakování: 4-bajtový token proti opakování. - Podpora offline podpisů: umožňuje použití offline podepsaných Destinací. - Rozšířené pokrytí podpisem: zahrnuje hash destinace, příznaky, možnosti, blok offline podpisu, payload. - Připraveno pro post-kvantovou kryptografii: kompatibilní s budoucími ML-KEM hybridy. - Režie: ≈ 457 bajtů (klíče X25519).\nDatagram3 (Protokol 20) Překlenuje propast mezi čistými a podepsanými typy. Vlastnosti: - Odpověditelné bez podpisu: obsahuje 32-bajtový hash odesílatele + 2-bajtové příznaky. - Minimální režie: ≈ 34 bajtů. - Žádná ochrana proti opakování — musí implementovat aplikace.\nOba protokoly jsou funkcemi API 0.9.66 a jsou implementovány v Java routeru od vydání 2.9.0; zatím neexistují implementace v i2pd ani Go (říjen 2025).\n4. Limity velikosti a fragmentace Velikost tunnel zprávy: 1 028 bajtů (4 B Tunnel ID + 16 B IV + 1 008 B datová část). Počáteční fragment: 956 B (typické TUNNEL doručení). Následující fragment: 996 B. Maximální počet fragmentů: 63–64. Praktický limit: ≈ 62 708 B (~61 KB). Doporučený limit: ≤ 10 KB pro spolehlivé doručení (ztráty se za touto hranicí exponenciálně zvyšují). Shrnutí režie: - Datagram1 ≈ 427 B (minimum). - Datagram2 ≈ 457 B. - Datagram3 ≈ 34 B. - Další vrstvy (I2CP gzip hlavička, I2NP, Garlic, Tunnel): + ~5,5 KB v nejhorším případě.\n5. Integrace I2CP / I2NP Cesta zprávy: 1. Aplikace vytvoří datagram (přes I2P API nebo SAM). 2. I2CP zabalí s gzip hlavičkou (0x1F 0x8B 0x08, RFC 1952) a CRC-32 kontrolním součtem. 3. Čísla protokolu + portu jsou uložena v polích gzip hlavičky. 4. Router zapouzdří jako I2NP zprávu → Garlic clove → 1 KB tunnel fragmenty. 5. Fragmenty procházejí odchozím → sítí → příchozím tunelem. 6. Znovu sestavený datagram je doručen handleru aplikace na základě čísla protokolu.\nIntegrita: CRC-32 (z I2CP) + volitelný kryptografický podpis (Datagram1/2). V samotném datagramu není samostatné pole kontrolního součtu.\n6. Programovací rozhraní Java API Balíček net.i2p.client.datagram obsahuje: - I2PDatagramMaker – vytváří podepsané datagramy. - I2PDatagramDissector – ověřuje a extrahuje informace o odesílateli. - I2PInvalidDatagramException – vyvolána při selhání ověření.\nI2PSessionMuxedImpl (net.i2p.client.impl.I2PSessionMuxedImpl) spravuje multiplexování protokolu a portů pro aplikace sdílející Destination.\nPřístup k Javadoc: - idk.i2p Javadoc (pouze síť I2P) - Javadoc Mirror (clearnet zrcadlo) - Oficiální Javadocs (oficiální dokumentace)\nPodpora SAM v3 SAM 3.2 (2016): přidány parametry PORT a PROTOCOL. SAM 3.3 (2016): zaveden model PRIMARY/subsession; umožňuje streamy + datagramy na jednom Destination. Podpora pro styly relací Datagram2 / 3 přidána do specifikace 2025 (implementace probíhá). Oficiální specifikace: SAM v3 Specification i2ptunnel moduly udpTunnel: Plně funkční základ pro I2P UDP aplikace (net.i2p.i2ptunnel.udpTunnel). streamr: Funkční pro A/V streaming (net.i2p.i2ptunnel.streamr). SOCKS UDP: Nefunkční od verze 2.10.0 (pouze UDP stub). Pro obecné UDP použijte Datagram API nebo přímo udpTunnel—nespoléhejte na SOCKS UDP.\n7. Ekosystém a jazyková podpora (2025) Language Library / Package SAM Version Status Javacore API (net.i2p.client.datagram)3.3✓ full support C++i2pd / libsam33.2 partialLimited Gogo-i2p / sam33.1–3.2Active Pythoni2plib, i2p.socket, txi2p3.2Active Rusti2p-rs, i2p_client3.3Active C#I2PSharp3.3Active JS/TSnode-i2p, i2p-sam3.2Active Haskellnetwork-anonymous-i2p3.2Experimental Luamooni2p3.2Experimental Java I2P je v současné době jediný router podporující plné SAM 3.3 subsessions a Datagram2 API. 8. Příklad použití – UDP Tracker (I2PSnark 2.10.0) První aplikace Datagram2/3 v reálném světě:\nOperation Datagram Type Purpose Announce RequestDatagram3Repliable but low-overhead update ResponseRaw DatagramMinimal payload return Vzor demonstruje smíšené použití autentizovaných a lehkých datagramů pro vyvážení bezpečnosti a výkonu. 9. Bezpečnost a osvědčené postupy Použijte Datagram2 pro jakoukoliv autentizovanou výměnu nebo když záleží na replay útocích. Upřednostněte Datagram3 pro rychlé odpovědi s možností odpovědět při střední důvěryhodnosti. Použijte RAW pro veřejné vysílání nebo anonymní data. Udržujte velikost payloadů ≤ 10 KB pro spolehlivé doručení. Mějte na paměti, že SOCKS UDP zůstává nefunkční. Vždy ověřujte gzip CRC a digitální podpisy při příjmu. 10. Technická specifikace Tato sekce pokrývá nízkoúrovňové formáty datagramů, zapouzdření a detaily protokolů.\n10.1 Identifikace protokolu Formáty datagramů nemají společnou hlavičku. Routery nemohou odvodit typ pouze z bajtů datové části.\nPři kombinaci více typů datagramů—nebo při kombinaci datagramů se streamováním—explicitně nastavte: - Číslo protokolu (přes I2CP nebo SAM) - Volitelně číslo portu, pokud vaše aplikace multiplexuje služby\nPonechání protokolu nenastavené hodnoty (0 nebo PROTO_ANY) se nedoporučuje a může vést k chybám směrování nebo doručení.\n10.2 Hrubé datagramy Non-repliable datagramy nenesou žádná data odesílatele ani autentizační data. Jedná se o neprůhledné datové náklady, zpracovávané mimo vyšší úroveň datagram API, ale podporované prostřednictvím SAM a I2PTunnel.\nProtokol: 18 (PROTO_DATAGRAM_RAW)\nFormát:\n+----+----+----+----+----// | payload... +----+----+----+----+----// Délka payload je omezena limity transportu (≈32 KB praktické maximum, často mnohem méně).\n10.3 Datagram1 (Odpověditelné datagramy) Obsahuje Destination odesílatele a Signature pro autentizaci a zpětnou adresaci.\nProtokol: 17 (PROTO_DATAGRAM)\nRežie: ≥427 bajtů Datová část: až ~31,5 KB (omezeno transportem)\nFormát:\n+----+----+----+----+----+----+----+----+ | from | + + | | ~ Destination bytes ~ | | +----+----+----+----+----+----+----+----+ | signature | + + | | +----+----+----+----+----+----+----+----+ | payload... +----+----+----+----// from: Destination (387+ bajtů) signature: podpis odpovídající typu klíče Pro DSA_SHA1: Podpis SHA-256 hashe užitečného zatížení Pro ostatní typy klíčů: Podpis přímo nad užitečným zatížením Poznámky: - Podpisy pro typy jiné než DSA byly standardizovány v I2P 0.9.14. - LS2 (Návrh 123) offline podpisy nejsou v současnosti podporovány v Datagram1.\n10.4 Formát Datagram2 Vylepšený replikovatelný datagram, který přidává odolnost proti replay útokům jak je definováno v Proposal 163 .\nProtokol: 19 (PROTO_DATAGRAM2)\nImplementace probíhá. Aplikace by měly zahrnovat kontroly nonce nebo časového razítka pro zajištění redundance.\n10.5 Formát Datagram3 Poskytuje odpověditelné, ale neautentizované datagramy. Spoléhá na autentizaci relace udržovanou routerem místo vestavěné destinace a podpisu.\nProtokol: 20 (PROTO_DATAGRAM3) Stav: Ve vývoji od verze 0.9.66\nUžitečné když: - Destinace jsou velké (např. post-kvantové klíče) - Autentizace probíhá na jiné vrstvě - Efektivita šířky pásma je kritická\n10.6 Integrita dat Integrita datagramu je chráněna gzip CRC-32 kontrolním součtem ve vrstvě I2CP. V samotném formátu datagramové zátěže neexistuje žádné explicitní pole kontrolního součtu.\n10.7 Zapouzdření paketů Každý datagram je zapouzdřen jako jediná I2NP zpráva nebo jako jednotlivý clove (segment) v Garlic Message. I2CP, I2NP a vrstvy tunelů zpracovávají délku a rámování — v datagramovém protokolu není žádný interní oddělovač ani pole délky.\n10.8 Úvahy o post-kvantové kryptografii (PQ) Pokud bude implementován Proposal 169 (ML-DSA podpisy), velikost podpisů a destinací se dramaticky zvýší — z ~455 bajtů na ≥3739 bajtů. Tato změna podstatně zvýší režii datagramu a sníží efektivní kapacitu datové části.\nDatagram3, který se spoléhá na autentizaci na úrovni relace (nikoli na vestavěné podpisy), se pravděpodobně stane preferovaným návrhem v postkvantových prostředích I2P.\n11. Reference Návrh 163 – Datagram2 a Datagram3 Návrh 160 – Integrace UDP Trackeru Návrh 144 – Výpočty MTU pro Streaming Návrh 169 – Post-kvantové podpisy Specifikace I2CP Specifikace I2NP Specifikace Tunnel zpráv Specifikace SAM v3 Dokumentace i2ptunnel 12. Hlavní body změnového protokolu (2019 – 2025) Year Release Change 20190.9.43Datagram API stabilization 20210.9.50Protocol port handling reworked 20222.0.0SSU2 adoption completed 20242.6.0Legacy transport removal simplified UDP code 20252.9.0Datagram2/3 support added (Java API) 20252.10.0UDP Tracker implementation released --- 13. Shrnutí Subsystém datagramů nyní podporuje čtyři varianty protokolu nabízející spektrum od plně autentizovaného až po lehký přenos surových dat. Vývojáři by měli přejít na Datagram2 pro bezpečnostně citlivé použití a Datagram3 pro efektivní provoz s možností odpovědi. Všechny starší typy zůstávají kompatibilní pro zajištění dlouhodobé interoperability.\n","description":"Autentizované, zodpověditelné a neupravené formáty zpráv nad I2CP","id":"b3c644204c779b5d6fc6a41438a3eb1b","section":"docs","title":"Datagramy","url":"/cs/docs/api/datagrams/"},{"categories":null,"content":"NTCP vs. SSU Diskuse (březen 2007) Otázky k NTCP Upraveno podle konverzace na IRC mezi zzz a cervantes.\nProč má NTCP prioritu před SSU, když NTCP zdánlivě přidává režii a latenci?\nNTCP obecně poskytuje lepší spolehlivost než původní implementace SSU. Naráží streamování přes NTCP na klasický TCP-over-TCP collapse (kolaps TCP při vrstvení TCP v TCP)?\nJe to možné, ale SSU byl zamýšlen jako lehká možnost na bázi UDP a v praxi se ukázal jako příliš nespolehlivý. “NTCP považováno za škodlivé” (zzz, 25. března 2007) Shrnutí: Vyšší latence a režie NTCP mohou způsobovat přetížení, přesto směrování upřednostňuje NTCP, protože jeho hodnoty skóre nabídek jsou pevně nastavené nižší než u SSU. Analýza poukázala na několik bodů:\nNTCP má aktuálně nižší bid (hodnota nabídky používaná při výběru transportu) než SSU, takže routery preferují NTCP, pokud už není navázána relace SSU. SSU implementuje potvrzení přijetí s přísně omezenými časovými limity a statistikami; NTCP se spoléhá na Java NIO TCP s časovými limity ve stylu RFC, které mohou být mnohem delší. Většina provozu (HTTP, IRC, BitTorrent) používá streamovací knihovnu I2P, což fakticky vrství TCP nad NTCP. Když obě vrstvy provádějí retransmise, může dojít ke kolapsu. Klasické odkazy zahrnují TCP over TCP is a bad idea . Časové limity ve streamovací knihovně byly ve verzi 0.8 zvýšeny z 10 s na 45 s; maximální časový limit SSU je 3 s, zatímco časové limity NTCP se předpokládají až kolem 60 s (doporučení RFC). Parametry NTCP je zvenčí těžké zkoumat. Terénní pozorování v roce 2007 ukázala, že propustnost odesílání i2psnarku oscilovala, což naznačuje periodický kolaps z přetížení. Testy efektivity (vynucení preference SSU) snížily poměry režie tunnelu zhruba z 3.5:1 na 3:1 a zlepšily streamovací metriky (velikost okna, RTT, poměr send/ack). Návrhy z vlákna z roku 2007 Přehodit priority transportů tak, aby routers preferovaly SSU (obnovením i2np.udp.alwaysPreferred). Označit streamingový provoz tak, aby SSU snižovalo prioritu pouze u označených zpráv, aniž by to ohrozilo anonymitu. Zpřísnit limity retransmisí SSU pro snížení rizika kolapsu. Prostudovat semi-reliable underlays (polospolehlivé spodní vrstvy) a určit, zda retransmise pod streamingovou knihovnou jsou čistým přínosem. Zrevidovat prioritní fronty a časové limity—například zvýšit časové limity pro streaming nad 45 s, aby se sladily s NTCP. Odpověď od jrandom (27. března 2007) Klíčové protiargumenty:\nNTCP existuje, protože raná nasazení SSU trpěla kolapsem způsobeným zahlcením. I poměrně nízké per‑hop míry retransmisí se mohou napříč vícehopovými tunnels lavinovitě násobit. Bez potvrzení na úrovni tunnelu obdrží stav end‑to‑end doručení jen část zpráv; selhání mohou zůstat bez povšimnutí. Řízení zahlcení v TCP má za sebou desetiletí optimalizací; NTCP je využívá prostřednictvím vyzrálých implementací TCP. Pozorovaná zlepšení efektivity při preferování SSU mohou spíše odrážet chování front v routeru než vlastní výhody protokolu. Delší časové limity pro streaming již zlepšovaly stabilitu; před zásadními změnami byly doporučeny další pozorování a sběr dat. Debata pomohla upřesnit následné ladění transportních protokolů, ale neodráží moderní architekturu NTCP2/SSU2.\n","description":"Historické poznámky k porovnání transportů NTCP a SSU a návrhy na ladění","id":"6fe94dc04faadfde27bcfeaaf9da5f71","section":"docs","title":"Diskuse o NTCP","url":"/cs/docs/ntcp/"},{"categories":null,"content":" Kontext: Tato stránka archivuje dlouhodobé diskuse z rané éry návrhu I2P. Vysvětluje, proč projekt upřednostnil lokálně důvěryhodné adresáře před vyhledáváním ve stylu DNS nebo registry založenými na většinovém hlasování. Aktuální pokyny k používání najdete v dokumentaci k pojmenovávání .\nZamítnuté alternativy Bezpečnostní cíle I2P vylučují obvyklá schémata pojmenování:\nPřeklad názvů ve stylu DNS. Jakýkoli resolver na trase dotazu může podvrhovat nebo cenzurovat odpovědi. I s DNSSEC zůstávají kompromitovaní registrátoři nebo certifikační autority jediným bodem selhání. V I2P jsou destinace veřejné klíče—únos dotazu by zcela kompromitoval identitu. Pojmenování založené na hlasování. Útočník může vytvářet neomezené množství identit (útok Sybil) a “vyhrát” hlasování pro populární názvy. Mitigace pomocí proof-of-work (důkaz o vykonané práci) zvyšují náklady, ale zavádějí výraznou koordinační režii. Namísto toho I2P záměrně ponechává pojmenovávání nad transportní vrstvou. Přibalená knihovna pro pojmenovávání nabízí rozhraní pro poskytovatele služeb, díky čemuž mohou koexistovat alternativní schémata — uživatelé rozhodují, kterým seznamům adres nebo jump services (službám pro dohledání jmen) důvěřují.\nLokální vs globální jména (jrandom, 2005) Názvy v I2P jsou lokálně jedinečné, ale lidsky čitelné. Vaše boss.i2p se nemusí shodovat s boss.i2p někoho jiného, a je to tak záměrně. Pokud by vás zlovolný útočník přiměl změnit destinaci skrytou za názvem, fakticky by tím unesl službu. Nevyžadování globální jedinečnosti tomuto typu útoku brání. Zacházejte s názvy jako se záložkami nebo přezdívkami v chatovacích aplikacích—vy si vybíráte, kterým destinacím budete důvěřovat, a to přihlášením k odběru konkrétních adresářů adres nebo ručním přidáním klíčů. Časté námitky \u0026amp; odpovědi (zzz) Concern Response “Downloading hosts.txt is inefficient.” At ~400\u0026nbsp;KB for ~800 hosts the bandwidth impact is minor (~10\u0026nbsp;B/s if refreshed twice daily). ETags already avoid unnecessary transfers. Alternate formats (for example recenthosts.cgi) can deliver only new entries. “It won’t scale.” A hosts.txt entry is ~500\u0026nbsp;bytes; storing thousands locally is practical. Real-time lookups would dramatically slow browsing. “Requires trust and manual setup.” True—and intentional. Users must choose address book providers they trust. Trust is not binary; forcing configuration encourages users to think about it. “Why not just use DNS?” DNS depends on short TTLs and can be hijacked mid-path. I2P destinations are immutable public keys, so DNS semantics map poorly. “Subscriptions rely on specific servers.” Subscriptions are decentralised—you can add multiple providers or run your own. Completely decentralised systems struggle with conflict resolution and hijacking. “Jump services and hosts.txt feel awkward.” They are pragmatic trade-offs. Jump services provide just-in-time lookups; subscriptions keep a local cache for performance. ## Probrané nápady na zvýšení efektivity Poskytovat přírůstkové aktualizace (pouze destinace přidané od posledního načtení). Nabízet doplňkové kanály (recenthosts.cgi) vedle kompletních souborů hosts. Prozkoumat skriptovatelné nástroje (například i2host.i2p) pro slučování kanálů nebo filtrování podle úrovní důvěry. Hlavní poznatky Bezpečnost má přednost před globálním konsensem: lokálně spravované adresáře minimalizují riziko únosu. Více přístupů k pojmenování může koexistovat prostřednictvím naming API (rozhraní pro pojmenování)—uživatelé rozhodují, čemu budou důvěřovat. Zcela decentralizované globální pojmenování zůstává otevřeným výzkumným problémem; kompromisy mezi bezpečností, lidskou zapamatovatelností a globální jedinečností stále odrážejí Zookův trojúhelník . Reference Dokumentace k pojmenování Zookův „Jména: decentralizovaná, bezpečná, srozumitelná pro člověka: vyberte dvě“ Ukázkový inkrementální kanál: stats.i2p/cgi-bin/newhosts.txt ","description":"Historická debata o modelu pojmenování I2P a proč byla globální schémata ve stylu DNS odmítnuta","id":"952b10ba82200ff92e5ddeed512d6afb","section":"docs","title":"Diskuse o pojmenování","url":"/cs/docs/legacy/naming/"},{"categories":null,"content":" Poznámka: Tato archivní diskuse nastiňuje historické přístupy k síťové databázi (netDb). Podrobnosti o aktuálním chování a pokynech najdete v hlavní dokumentaci netDb .\nHistorie netDb projektu I2P je distribuována pomocí jednoduchého algoritmu floodfill. Ranější vydání také ponechávala implementaci Kademlia DHT jako záložní možnost, ale ta se ukázala jako nespolehlivá a byla ve verzi 0.6.1.20 zcela deaktivována. Návrh floodfill předá publikovaný záznam účastnickému routeru, počká na potvrzení a v případě potřeby to zkusí znovu s dalšími floodfill uzly. Floodfill uzly rozposílají \u0026lsquo;store\u0026rsquo; (zprávy pro uložení) z non-floodfill routerů všem ostatním účastníkům floodfill.\nKoncem roku 2009 byly dotazy Kademlia (distribuovaná hašovací tabulka) částečně znovu zavedeny, aby se snížily požadavky na úložiště jednotlivých floodfill routers.\nÚvod do Floodfill Floodfill se poprvé objevil ve vydání 0.6.0.4, zatímco Kademlia zůstala k dispozici jako záloha. Tehdy velká ztráta paketů a omezené směrovací cesty ztěžovaly získání potvrzení od čtyř nejbližších protějšků, což často vyžadovalo desítky redundantních pokusů o uložení. Přechod na podmnožinu floodfill tvořenou zvenčí dosažitelnými routers poskytl pragmatické krátkodobé řešení.\nPřehodnocení Kademlia (distribuovaná hašovací tabulka, DHT) Mezi zvažované alternativy patřily:\nProvoz netDb jako Kademlia DHT, omezený na dosažitelné routers, které se k účasti přihlásí Zachování modelu floodfill, ale omezení účasti na schopné routers a ověřování distribuce náhodnými kontrolami Přístup floodfill zvítězil, protože byl snazší nasadit a netDb uchovává pouze metadata, nikoli uživatelská data. Většina destinací nikdy nepublikuje LeaseSet, protože odesílatel typicky zahrne svůj LeaseSet do garlic messages (garlic zprávy).\nSoučasný stav (z historického hlediska) Algoritmy netDb jsou vyladěny pro potřeby sítě a historicky bez potíží zvládaly několik stovek routerů. Rané odhady naznačovaly, že 3–5 floodfill routerů by dokázalo obsloužit zhruba 10 000 uzlů.\nAktualizované výpočty (březen 2008) recvKBps = N * (L + 1) * (1 + F) * (1 + R) * S / T Kde:\nN: Routery v síti L: Průměrný počet klientských destinací na router (plus jedna pro RouterInfo) F: Procento selhání tunnelů R: Období přestavby tunnelu jako zlomek životnosti tunnelu S: Průměrná velikost záznamu netDb T: Životnost tunnelu Při použití hodnot platných v roce 2008 (N = 700, L = 0.5, F = 0.33, R = 0.5, S = 4 KB, T = 10 minutes) vychází:\nrecvKBps ≈ 700 * (0.5 + 1) * (1 + 0.33) * (1 + 0.5) * 4 KB / 10m ≈ 28 KBps Vrátí se Kademlia? Vývojáři zhruba na začátku roku 2007 diskutovali o opětovném zavedení Kademlia. Panoval konsenzus, že kapacitu floodfill lze podle potřeby postupně rozšiřovat, zatímco Kademlia přidávala značnou složitost a nároky na zdroje pro základní populaci routerů. Záložní varianta zůstává nečinná, dokud je kapacita floodfill dostačující.\nPlánování kapacity floodfillu (uzel v I2P, který spravuje netDb) Automatické zařazování routerů třídy šířky pásma O do floodfill, byť lákavé, představuje riziko scénářů odepření služby (denial-of-service), pokud se do něj zapojí nepřátelské uzly. Historická analýza naznačila, že omezení skupiny floodfill (například 3–5 uzlů obsluhujících ~10K routers) bylo bezpečnější. K udržení dostatečné, avšak kontrolované sady floodfill byli nasazováni důvěryhodní provozovatelé nebo se uplatňovaly automatické heuristiky.\nFloodfill TODO (Historické) Tato sekce je zachována pro historické účely. Hlavní stránka netDb sleduje aktuální plán rozvoje a návrhové úvahy.\nProvozní incidenty, jako například období 13. března 2008, kdy byl k dispozici pouze jeden floodfill router, vedly k několika vylepšením zahrnutým ve verzích 0.6.1.33 až 0.7.x, včetně:\nNáhodný výběr floodfill pro vyhledávání a upřednostnění rychle reagujících peerů Zobrazení dalších metrik floodfill na stránce \u0026ldquo;Profiles\u0026rdquo; konzole routeru Postupné zmenšování velikosti záznamů v netDb za účelem snížení využití šířky pásma u floodfill Automatické zapojení (opt-in) podmnožiny routerů třídy O na základě výkonu zjištěného z profilových dat Vylepšené blokování pomocí blokovacích seznamů, výběr floodfill peerů a heuristiky průzkumu Zbývající nápady z daného období zahrnovaly:\nVyužití statistik dbHistory pro lepší hodnocení a výběr floodfill protějšků Zlepšení chování při opakování pokusů, aby se předešlo opakovanému kontaktování selhávajících protějšků Využití metrik latence a skóre integrace při výběru Rychlejší detekce a reakce na selhávající floodfill routery Pokračování ve snižování nároků na zdroje u uzlů s vysokou šířkou pásma a u floodfill uzlů I v době sepsání těchto poznámek byla síť považována za odolnou, s připravenou infrastrukturou pro rychlou reakci na nepřátelské floodfills nebo na útoky typu odmítnutí služby cílené na floodfill.\nDalší poznámky Konzole routeru dlouhodobě zpřístupňuje rozšířená profilová data, která pomáhají při analýze spolehlivosti floodfill. Ačkoli se v historických komentářích spekulovalo o Kademlia a alternativních schématech DHT, floodfill zůstal hlavním algoritmem pro produkční sítě. Na budoucnost zaměřený výzkum se soustředil na to, aby byl mechanismus přijímání do floodfill adaptivní, zároveň aby se omezily příležitosti ke zneužití. ","description":"Historické poznámky k floodfill, experimentům s Kademlií a budoucímu ladění netDb","id":"0ddefeec5b7108b36649c4d989bf474e","section":"docs","title":"Diskuse o síťové databázi","url":"/cs/docs/netdb/"},{"categories":null,"content":" Poznámka: Tento archiv zachycuje spekulativní návrhové práce vzniklé před verzí I2P 0.9.41. Pro produkční implementaci konzultujte dokumentaci k tunnelu .\nAlternativy konfigurace Zvažované nápady na budoucí parametry pro tunnel zahrnovaly:\nOmezování frekvence pro doručování zpráv Zásady vyplňování (včetně chaff injection (vkládání balastních dat)) Řízení životnosti pro tunnel Strategie dávkování a frontování pro odesílání užitečných dat Žádná z těchto možností nebyla součástí starší implementace.\nStrategie výplně Projednávané možné přístupy k paddingu:\nŽádný padding (doplnění dat) Padding náhodné délky Padding pevné délky Padding na nejbližší kilobajt Padding na mocniny dvou (2^n bajtů) Raná měření (verze 0.4) vedla k současné pevně stanovené velikosti zprávy pro tunnel 1024 bajtů. Na vyšší úrovni mohou garlic messages (garlic zprávy) přidat vlastní výplň.\nFragmentace Aby se zabránilo tagging attacks (útokům na základě označování) využívajícím délku zprávy, mají tunnelové zprávy pevnou velikost 1024 bajtů. Větší I2NP užitečná data fragmentuje vstupní brána tunnelu; koncový bod tunnelu fragmenty znovu sestaví v rámci krátkého časového limitu. Routery mohou fragmenty před odesláním přeuspořádat, aby maximalizovaly využití kapacity.\nDalší alternativy Upravit zpracování Tunnel za běhu Byly prozkoumány tři možnosti:\nUmožnit, aby prostřední skok mohl dočasně přerušit tunnel udělením přístupu k dešifrovaným užitečným datům. Povolit účastnícím se routerům “remixovat” zprávy tím, že je pošlou přes jeden ze svých vlastních odchozích tunnelů, než budou pokračovat k dalšímu skoku. Umožnit tvůrci tunnelu dynamicky předefinovat další skok protějšku. Obousměrné Tunnels Používání oddělených příchozích a odchozích tunnels omezuje množství informací, které může pozorovat jediná skupina uzlů (např. požadavek GET vs. velká odpověď). Obousměrné tunnels zjednodušují správu uzlů, ale zároveň odhalují úplné vzorce provozu v obou směrech. Jednosměrné tunnels proto zůstaly preferovaným návrhem.\nZpětné kanály a proměnlivé velikosti Povolení proměnlivých velikostí zpráv v rámci tunnel by umožnilo skryté kanály mezi spřaženými uzly (např. kódování dat prostřednictvím zvolených velikostí nebo frekvencí). Zprávy s pevnou velikostí toto riziko zmírňují za cenu dodatečné režie na vyplňovací data.\nAlternativy pro budování Tunnel Odkaz: Hashing it out in Public Starší „paralelní“ metoda sestavení Před vydáním verze 0.6.1.10 byly požadavky na sestavení tunnelu odesílány paralelně každému účastníkovi. Tato metoda je zdokumentována na staré stránce o tunnelu .\nJednorázové teleskopické budování (současná metoda) Moderní přístup odesílá sestavovací zprávy po jednotlivých uzlech (hop-by-hop) skrz částečně sestavený tunnel. Ačkoli je podobný mechanismu Toru zvanému „telescoping“ (teleskopické vytváření okruhu), směrování sestavovacích zpráv přes explorační tunnely snižuje únik informací.\n“Interaktivní” Teleskopování Budování po jednom skoku s explicitními round-trips (komunikací tam a zpět) umožňuje uzlům počítat zprávy a odvodit svou pozici v tunnel, proto byl tento přístup odmítnut.\nNeprůzkumné správní Tunnels Jedním z návrhů bylo udržovat samostatný pool řídicích tunnels pro sestavovací provoz. Ačkoli by to mohlo pomoci odděleným routers, při dostatečné integraci sítě bylo vyhodnoceno jako zbytečné.\nPrůzkumné doručování (zastaralé) Před verzí 0.6.1.10 byly samostatné požadavky na tunnel zašifrovány pomocí garlic encryption a doručovány prostřednictvím průzkumných tunnels, přičemž odpovědi se vracely odděleně. Tato strategie byla nahrazena současnou metodou one-shot telescoping (jednorázového teleskopického navazování).\nHlavní poznatky Zprávy v rámci tunnelu s pevnou velikostí chrání před označováním podle velikosti a skrytými kanály, a to navzdory dodatečným nákladům na výplň. Alternativní strategie vyplňování, fragmentace a sestavování byly prozkoumány, ale při zohlednění kompromisů v oblasti anonymity nebyly přijaty. Návrh tunnelu nadále vyvažuje efektivitu, pozorovatelnost a odolnost vůči útokům predecessor (útoky zaměřené na identifikaci předchůdce) a útokům využívajícím zahlcení. ","description":"Historický přehled výplně pro tunnel, fragmentace a strategií sestavení","id":"e5773155afe129d73b1384e5c116ec56","section":"docs","title":"Diskuse o tunnel","url":"/cs/docs/legacy/tunnel/"},{"categories":null,"content":"Stav implementace Aktuální nasazení: - i2pd (implementace v C++): Plně implementováno ve verzi 2.58.0 (září 2025) s podporou ML-KEM-512, ML-KEM-768 a ML-KEM-1024. Postkvantové end-to-end šifrování je ve výchozím nastavení povoleno, pokud je k dispozici OpenSSL 3.5.0 nebo novější. - Java I2P: Zatím neimplementováno k verzi 0.9.67 / 2.10.0 (září 2025). Specifikace schválena a implementace plánována do budoucích vydání.\nTato specifikace popisuje schválenou funkcionalitu, která je v současnosti nasazena v i2pd a je plánována pro implementace Java I2P.\nPřehled Jedná se o postkvantovou hybridní variantu protokolu ECIES-X25519-AEAD-Ratchet ECIES . Představuje první fázi Návrhu 169 Prop169 , která má být schválena. Podrobnosti o celkových cílech, modelech hrozeb, analýze, alternativách a dalších informacích viz tento návrh.\nStav návrhu 169: Otevřeno (první fáze byla schválena pro hybridní implementaci ECIES (šifrovací schéma na eliptických křivkách)).\nTato specifikace obsahuje pouze rozdíly oproti standardu ECIES a je třeba ji číst ve spojení s danou specifikací.\nNávrh Používáme standard NIST FIPS 203 FIPS203 , který je založen na CRYSTALS-Kyberu (verze 3.1, 3 a starší), ale není s ním kompatibilní.\nHybridní handshaky kombinují klasickou výměnu klíčů X25519 Diffie-Hellman s postkvantovými mechanismy zapouzdření klíče ML-KEM (NIST standard pro postkvantové zapouzdření klíče). Tento přístup vychází z konceptů hybridního dopředného utajení popsaných ve výzkumu PQNoise (výzkum postkvantové varianty protokolu Noise) a z podobných implementací v TLS 1.3, IKEv2 a WireGuard.\nVýměna klíčů Definujeme hybridní výměnu klíčů pro Ratchet (mechanismus postupné obnovy klíčů). Postkvantové KEM poskytuje pouze efemérní klíče a přímo nepodporuje navázání spojení se statickými klíči, jako je Noise IK.\nDefinujeme tři varianty ML-KEM podle specifikace v FIPS203 , celkem tedy tři nové typy šifrování. Hybridní typy jsou definovány pouze v kombinaci s X25519.\nNové typy šifrování jsou:\nType Code Security Level ML-KEM Variant MLKEM512_X25519 5 NIST Category 1 (AES-128 equivalent) ML-KEM-512 MLKEM768_X25519 6 NIST Category 3 (AES-192 equivalent) ML-KEM-768 (Recommended) MLKEM1024_X25519 7 NIST Category 5 (AES-256 equivalent) ML-KEM-1024 **Poznámka:** MLKEM768_X25519 (Type 6) je doporučená výchozí varianta, která zajišťuje silné postkvantové zabezpečení při rozumné režii. Režie je značná ve srovnání se šifrováním pouze pomocí X25519. Typické velikosti zpráv 1 a 2 (pro IK pattern (schéma IK)) jsou aktuálně okolo 96–103 bajtů (před přidáním dodatečných užitečných dat). To se zvýší přibližně 9–12× u MLKEM512, 13–16× u MLKEM768 a 17–23× u MLKEM1024, v závislosti na typu zprávy.\nVyžadováno nové šifrování ML-KEM (dříve CRYSTALS-Kyber) FIPS203 - Standard mechanismu zapouzdření klíčů založený na modulových mřížích SHA3-256 (dříve Keccak-512) FIPS202 - Součást standardu SHA-3 SHAKE128 a SHAKE256 (XOF (funkce s rozšiřitelným výstupem) rozšíření pro SHA3) FIPS202 - Funkce s rozšiřitelným výstupem Testovací vektory pro SHA3-256, SHAKE128 a SHAKE256 jsou k dispozici v rámci NIST Cryptographic Algorithm Validation Program .\nPodpora knihoven: - Java: knihovna Bouncycastle ve verzi 1.79 a novější podporuje všechny varianty ML-KEM (mechanismus zapouzdření klíče na bázi mřížek) a funkce SHA3/SHAKE - C++: OpenSSL 3.5 a novější zahrnuje plnou podporu ML-KEM (vydáno v dubnu 2025) - Go: Pro implementaci ML-KEM a SHA3 je k dispozici více knihoven\nSpecifikace Společné struktury Viz Common Structures Specification pro informace o délkách klíčů a identifikátorech.\nVzory navázání spojení Navazování spojení používá vzory handshake z Noise Protocol Framework s úpravami specifickými pro I2P pro hybridní postkvantové zabezpečení.\nPoužívá se následující mapování písmen:\ne = jednorázový efemérní klíč (X25519) s = statický klíč p = datová část zprávy e1 = jednorázový efemérní PQ (postkvantový) klíč, odeslaný od Alice Bobovi (token specifický pro I2P) ekem1 = šifrotext KEM, odeslaný od Boba Alici (token specifický pro I2P) Důležité upozornění: Názvy vzorců \u0026ldquo;IKhfs\u0026rdquo; a \u0026ldquo;IKhfselg2\u0026rdquo; a tokeny \u0026ldquo;e1\u0026rdquo; a \u0026ldquo;ekem1\u0026rdquo; jsou úpravy specifické pro I2P, které nejsou zdokumentovány v oficiální specifikaci Noise Protocol Framework. Představují vlastní definice pro integraci ML-KEM (postkvantový mechanismus zapouzdření klíče) do vzorce Noise IK. Ačkoli je hybridní přístup X25519 + ML-KEM široce uznáván ve výzkumu postkvantové kryptografie a v dalších protokolech, konkrétní názvosloví použité zde je specifické pro I2P.\nNásledující úpravy IK pro hybridní dopředné utajení se uplatňují:\nStandard IK: I2P IKhfs (Hybrid): \u0026lt;- s \u0026lt;- s ... ... -\u0026gt; e, es, s, ss, p -\u0026gt; e, es, e1, s, ss, p \u0026lt;- e, ee, se, p \u0026lt;- e, ee, ekem1, se, p \u0026lt;- p \u0026lt;- p p -\u0026gt; p -\u0026gt; Note: e1 and ekem1 are encrypted within ChaCha20-Poly1305 AEAD blocks. Note: e1 (ML-KEM public key) and ekem1 (ML-KEM ciphertext) have different sizes. Vzor e1 je definován následovně:\nFor Alice (sender): (encap_key, decap_key) = PQ_KEYGEN() // EncryptAndHash(encap_key) ciphertext = ENCRYPT(k, n, encap_key, ad) n++ MixHash(ciphertext) For Bob (receiver): // DecryptAndHash(ciphertext) encap_key = DECRYPT(k, n, ciphertext, ad) n++ MixHash(ciphertext) Vzor ekem1 je definován následovně:\nFor Bob (receiver of encap_key): (kem_ciphertext, kem_shared_key) = ENCAPS(encap_key) // EncryptAndHash(kem_ciphertext) ciphertext = ENCRYPT(k, n, kem_ciphertext, ad) MixHash(ciphertext) // MixKey MixKey(kem_shared_key) For Alice (sender of encap_key): // DecryptAndHash(ciphertext) kem_ciphertext = DECRYPT(k, n, ciphertext, ad) MixHash(ciphertext) // MixKey kem_shared_key = DECAPS(kem_ciphertext, decap_key) MixKey(kem_shared_key) Definované operace ML-KEM Definujeme následující funkce odpovídající kryptografickým stavebním prvkům v souladu s FIPS203 .\n(encap_key, decap_key) = PQ_KEYGEN() : Alice vytvoří klíče pro enkapsulaci a dekapsulaci. Klíč pro enkapsulaci je odeslán ve zprávě NS. Velikosti klíčů: - ML-KEM-512: encap_key = 800 bajtů, decap_key = 1632 bajtů - ML-KEM-768: encap_key = 1184 bajtů, decap_key = 2400 bajtů - ML-KEM-1024: encap_key = 1568 bajtů, decap_key = 3168 bajtů\n(ciphertext, kem_shared_key) = ENCAPS(encap_key) : Bob vypočítá šifrotext a sdílený klíč pomocí zapouzdřovacího klíče přijatého ve zprávě NS. Šifrotext je odeslán ve zprávě NSR. Velikosti šifrotextu: - ML-KEM-512: 768 bajtů - ML-KEM-768: 1088 bajtů - ML-KEM-1024: 1568 bajtů\nkem_shared_key má vždy délku 32 bajtů u všech tří variant.\nkem_shared_key = DECAPS(ciphertext, decap_key) : Alice vypočítá sdílený klíč pomocí šifrotextu obdrženého ve zprávě NSR. kem_shared_key má vždy délku 32 bajtů.\nDůležité: Jak encap_key, tak ciphertext jsou zašifrovány uvnitř bloků ChaCha20-Poly1305 v handshake zprávách 1 a 2 protokolu Noise (kryptografický protokol pro handshake). Budou dešifrovány v rámci procesu handshaku.\nkem_shared_key je smíchán do řetězicího klíče pomocí MixKey(). Podrobnosti viz níže.\nKDF (funkce pro odvozování klíčů) pro handshake protokolu Noise Přehled Hybridní handshake (navázání spojení) kombinuje klasické X25519 ECDH s postkvantovým ML-KEM. První zpráva, od Alice Bobovi, obsahuje e1 (zapouzdřovací klíč ML-KEM) před datovou částí zprávy. S tímto se zachází jako s dodatečným klíčovým materiálem; zavolejte na něj EncryptAndHash() (jako Alice) nebo DecryptAndHash() (jako Bob). Poté zpracujte datovou část zprávy jako obvykle.\nDruhá zpráva, od Boba k Alici, obsahuje ekem1 (ML-KEM šifrotext) před datovou částí zprávy. S tímto se zachází jako s dodatečným klíčovým materiálem; použijte na něj EncryptAndHash() (jako Bob) nebo DecryptAndHash() (jako Alice). Poté vypočítejte kem_shared_key a zavolejte MixKey(kem_shared_key). Následně zpracujte datovou část zprávy jako obvykle.\nIdentifikátory protokolu Noise Toto jsou inicializační řetězce pro Noise (kryptografický protokol) (specifické pro I2P):\nNoise_IKhfselg2_25519+MLKEM512_ChaChaPoly_SHA256 Noise_IKhfselg2_25519+MLKEM768_ChaChaPoly_SHA256 Noise_IKhfselg2_25519+MLKEM1024_ChaChaPoly_SHA256 Alice KDF (funkce odvození klíče) pro zprávu NS Za vzorem zprávy \u0026rsquo;es\u0026rsquo; a před vzorem zprávy \u0026rsquo;s\u0026rsquo; přidejte:\nThis is the \u0026#34;e1\u0026#34; message pattern: (encap_key, decap_key) = PQ_KEYGEN() // EncryptAndHash(encap_key) // AEAD parameters k = keydata[32:63] n = 0 ad = h ciphertext = ENCRYPT(k, n, encap_key, ad) n++ // MixHash(ciphertext) h = SHA256(h || ciphertext) End of \u0026#34;e1\u0026#34; message pattern. NOTE: For the next section (payload for XK or static key for IK), the keydata and chain key remain the same, and n now equals 1 (instead of 0 for non-hybrid). Bobův KDF (funkce pro odvozování klíčů) pro zprávu NS Po vzoru zprávy \u0026rsquo;es\u0026rsquo; a před vzorem zprávy \u0026rsquo;s\u0026rsquo; přidejte:\nThis is the \u0026#34;e1\u0026#34; message pattern: // DecryptAndHash(encap_key_section) // AEAD parameters k = keydata[32:63] n = 0 ad = h encap_key = DECRYPT(k, n, encap_key_section, ad) n++ // MixHash(encap_key_section) h = SHA256(h || encap_key_section) End of \u0026#34;e1\u0026#34; message pattern. NOTE: For the next section (payload for XK or static key for IK), the keydata and chain key remain the same, and n now equals 1 (instead of 0 for non-hybrid). Bobův KDF (funkce pro odvozování klíčů) pro zprávu NSR Za vzorem zprávy \u0026rsquo;ee\u0026rsquo; a před vzorem zprávy \u0026lsquo;se\u0026rsquo; přidejte:\nThis is the \u0026#34;ekem1\u0026#34; message pattern: (kem_ciphertext, kem_shared_key) = ENCAPS(encap_key) // EncryptAndHash(kem_ciphertext) // AEAD parameters k = keydata[32:63] n = 0 ad = h ciphertext = ENCRYPT(k, n, kem_ciphertext, ad) // MixHash(ciphertext) h = SHA256(h || ciphertext) // MixKey(kem_shared_key) keydata = HKDF(chainKey, kem_shared_key, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] End of \u0026#34;ekem1\u0026#34; message pattern. Alice KDF (funkce pro odvozování klíčů) pro zprávu NSR Po schématu zprávy \u0026rsquo;ee\u0026rsquo; a před schématem zprávy \u0026lsquo;ss\u0026rsquo; přidejte:\nThis is the \u0026#34;ekem1\u0026#34; message pattern: // DecryptAndHash(kem_ciphertext_section) // AEAD parameters k = keydata[32:63] n = 0 ad = h kem_ciphertext = DECRYPT(k, n, kem_ciphertext_section, ad) // MixHash(kem_ciphertext_section) h = SHA256(h || kem_ciphertext_section) // MixKey(kem_shared_key) kem_shared_key = DECAPS(kem_ciphertext, decap_key) keydata = HKDF(chainKey, kem_shared_key, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] End of \u0026#34;ekem1\u0026#34; message pattern. KDF (funkce derivace klíče) pro split() Funkce split() zůstává nezměněna oproti standardní specifikaci ECIES. Po dokončení handshake (úvodního navázání spojení):\nkeydata = HKDF(chainKey, ZEROLEN, \u0026#34;\u0026#34;, 64) k_ab = keydata[0:31] k_ba = keydata[32:63] Toto jsou obousměrné klíče používané pro probíhající komunikaci v rámci relace.\nFormát zprávy Formát NS (New Session) Změny: Aktuální ratchet (kryptografický mechanismus pro postupné odvozování klíčů) obsahuje statický klíč v první sekci ChaCha20-Poly1305 a užitečná data ve druhé sekci. S ML-KEM jsou nyní tři sekce. První sekce obsahuje šifrovaný veřejný klíč ML-KEM (encap_key). Druhá sekce obsahuje statický klíč. Třetí sekce obsahuje užitečná data.\nVelikosti zpráv:\nType Type Code X25519 len NS len NS Enc len NS Dec len PQ key len pl len X25519 4 32 96+pl 64+pl pl -- pl MLKEM512_X25519 5 32 912+pl 880+pl 800+pl 800 pl MLKEM768_X25519 6 32 1296+pl 1264+pl 1184+pl 1184 pl MLKEM1024_X25519 7 32 1680+pl 1648+pl 1568+pl 1568 pl **Poznámka:** Užitečná data musí obsahovat blok DateTime (minimálně 7 bajtů: 1 bajt na typ, 2 bajty na velikost, 4 bajty na časové razítko). Minimální velikosti NS lze podle toho vypočítat. Minimální praktická velikost NS je tedy 103 bajtů pro X25519 a u hybridních variant se pohybuje od 919 do 1687 bajtů. Nárůsty velikosti o 816, 1200 a 1584 bajtů u všech tří variant ML-KEM jsou způsobeny veřejným klíčem ML-KEM a 16bajtovým Poly1305 MAC pro autentizované šifrování.\nFormát NSR (New Session Reply – odpověď na novou relaci) Změny: Současný ratchet (kryptografický ráčnový mechanismus) má prázdná užitečná data pro první sekci ChaCha20-Poly1305 a užitečná data ve druhé sekci. S ML-KEM jsou nyní tři sekce. První sekce obsahuje zašifrovaný ML-KEM šifrotext. Druhá sekce má prázdná užitečná data. Třetí sekce obsahuje užitečná data.\nVelikosti zpráv:\nType Type Code X25519 len NSR len NSR Enc len NSR Dec len PQ ct len pl len X25519 4 32 72+pl 40+pl pl -- pl MLKEM512_X25519 5 32 856+pl 824+pl 784+pl 768 pl MLKEM768_X25519 6 32 1176+pl 1144+pl 1104+pl 1088 pl MLKEM1024_X25519 7 32 1656+pl 1624+pl 1584+pl 1568 pl Navýšení velikosti o 784, 1104 a 1584 bajtů u tří variant ML-KEM odpovídají součtu šifrotextu ML-KEM a 16bajtového Poly1305 MAC (ověřovací kód zprávy) pro autentizované šifrování. Analýza režie Výměna klíčů Režie u hybridního šifrování je značná ve srovnání se samotným X25519:\nMLKEM512_X25519: Přibližně 9-12x nárůst velikosti zprávy pro handshake (navázání spojení) (NS: 9.5x, NSR: 11.9x) MLKEM768_X25519: Přibližně 13-16x nárůst velikosti zprávy pro handshake (NS: 13.5x, NSR: 16.3x) MLKEM1024_X25519: Přibližně 17-23x nárůst velikosti zprávy pro handshake (NS: 17.5x, NSR: 23x) Tato režie je přijatelná vzhledem k dodatečným přínosům postkvantového zabezpečení. Násobicí faktory se liší podle typu zprávy, protože základní velikosti zpráv se liší (NS minimálně 96 bajtů, NSR minimálně 72 bajtů).\nÚvahy o šířce pásma Pro typické zřízení relace s minimálními užitečnými daty: - X25519 pouze: ~200 bajtů celkem (NS + NSR) - MLKEM512_X25519: ~1,800 bajtů celkem (zvýšení 9×) - MLKEM768_X25519: ~2,500 bajtů celkem (zvýšení 12,5×) - MLKEM1024_X25519: ~3,400 bajtů celkem (zvýšení 17×)\nPo navázání relace používá průběžné šifrování zpráv stejný formát přenosu dat jako relace pouze s X25519, takže pro následné zprávy nevzniká žádná dodatečná režie.\nBezpečnostní analýza Navazování spojení Hybridní handshake poskytuje jak klasickou (X25519), tak postkvantovou (ML-KEM) bezpečnost. Útočník musí prolomit obojí, tedy jak klasické ECDH, tak postkvantové KEM (mechanismus zapouzdření klíče), aby kompromitoval klíče relace.\nTo poskytuje: - Současná bezpečnost: X25519 ECDH poskytuje bezpečnost proti klasickým útočníkům (úroveň bezpečnosti 128 bitů) - Budoucí bezpečnost: ML-KEM (postkvantový mechanismus zapouzdření klíče) poskytuje bezpečnost proti kvantovým útočníkům (liší se podle sady parametrů) - Hybridní bezpečnost: Obě musí být prolomeny, aby došlo ke kompromitaci relace (úroveň bezpečnosti = maximum z obou komponent)\nÚrovně zabezpečení Variant NIST Category Classical Security PQ Security Hybrid Security MLKEM512_X25519 Category 1 128-bit (X25519) AES-128 equivalent 128-bit MLKEM768_X25519 Category 3 128-bit (X25519) AES-192 equivalent 128-bit MLKEM1024_X25519 Category 5 128-bit (X25519) AES-256 equivalent 128-bit **Poznámka:** Hybridní úroveň bezpečnosti je dána slabší ze dvou komponent. Ve všech případech poskytuje X25519 (eliptická křivka pro výměnu klíčů) 128bitovou klasickou úroveň bezpečnosti. Pokud bude k dispozici kryptograficky relevantní kvantový počítač, úroveň bezpečnosti by závisela na zvolené sadě parametrů ML-KEM (postkvantový mechanismus zapouzdření klíče). Dopředné utajení Hybridní přístup zachovává vlastnosti dopředné bezpečnosti. Relační klíče jsou odvozeny jak z efemérní výměny klíčů X25519, tak z efemérní výměny klíčů ML-KEM (postkvantní mechanismus zapouzdření klíče). Pokud jsou po navázání spojení zničeny efemérní soukromé klíče X25519 nebo ML-KEM, minulé relace nelze dešifrovat, i kdyby byly kompromitovány dlouhodobé statické klíče.\nVzor IK (vzor handshake „IK“ v Noise) poskytuje dokonalé dopředné utajení (úroveň důvěrnosti Noise 5) po odeslání druhé zprávy (NSR).\nPředvolby typu Implementace by měly podporovat více hybridních typů a vyjednat nejsilnější vzájemně podporovanou variantu. Pořadí preferencí by mělo být:\nMLKEM768_X25519 (Type 6) - Doporučená výchozí volba, nejlepší rovnováha mezi zabezpečením a výkonem MLKEM1024_X25519 (Type 7) - Nejvyšší úroveň zabezpečení pro citlivé aplikace MLKEM512_X25519 (Type 5) - Základní postkvantové zabezpečení pro scénáře s omezenými prostředky X25519 (Type 4) - Pouze klasická kryptografie, záložní varianta pro kompatibilitu Odůvodnění: MLKEM768_X25519 se doporučuje jako výchozí, protože poskytuje zabezpečení NIST Category 3 (ekvivalent AES-192), které je považováno za dostatečnou ochranu proti kvantovým počítačům při zachování přiměřené velikosti zpráv. MLKEM1024_X25519 poskytuje vyšší úroveň zabezpečení, ale za cenu podstatně vyšší režie.\nPoznámky k implementaci Podpora knihoven Java: Knihovna Bouncycastle od verze 1.79 (srpen 2024) podporuje všechny požadované varianty ML-KEM a funkce SHA3/SHAKE. Pro zajištění shody s FIPS 203 použijte org.bouncycastle.pqc.crypto.mlkem.MLKEMEngine. C++: OpenSSL 3.5 (duben 2025) a novější zahrnuje podporu ML-KEM prostřednictvím rozhraní EVP_KEM. Jedná se o vydání s dlouhodobou podporou, udržované do dubna 2030. Go: K dispozici je několik knihoven třetích stran pro ML-KEM a SHA3, včetně knihovny CIRCL od Cloudflare. Migrační strategie Implementace by měly: 1. Podporovat během přechodného období jak variantu pouze X25519, tak hybridní varianty ML-KEM 2. Preferovat hybridní varianty, pokud je podporují obě strany 3. Zachovat fallback (záložní varianta) na variantu pouze X25519 kvůli zpětné kompatibilitě 4. Zohlednit omezení šířky pásma sítě při volbě výchozí varianty\nSdílené Tunnels Zvýšené velikosti zpráv mohou ovlivnit využití sdíleného tunnelu. Implementace by měly zvážit: - Sdružovat handshake (úvodní navázání spojení), kde je to možné, aby se rozložila režie - Používat kratší doby platnosti u hybridních relací ke snížení udržovaného stavu - Sledovat využití šířky pásma a podle toho upravovat parametry - Zavést řízení přetížení pro provoz při navazování relace\nÚvahy o velikosti nové relace Vzhledem k větším zprávám handshake (navázání spojení) mohou implementace potřebovat: - Zvýšit velikosti vyrovnávacích pamětí pro vyjednávání relace (doporučené minimum 4KB) - Upravit hodnoty časových limitů pro pomalejší připojení (počítat s ~3-17x většími zprávami) - Zvážit kompresi užitečných dat v NS/NSR zprávách - Implementovat zpracování fragmentace, pokud to vyžaduje transportní vrstva\nTestování a ověřování Implementace by měly ověřit: - Správné generování klíčů ML-KEM, zapouzdření a decapsulaci - Správnou integraci kem_shared_key do Noise KDF - Shodu výpočtů velikosti zpráv se specifikací - Interoperabilitu s jinými implementacemi I2P routeru - Záložní chování při nedostupnosti ML-KEM\nTestovací vektory pro operace ML-KEM jsou k dispozici v programu NIST Cryptographic Algorithm Validation Program (program ověřování kryptografických algoritmů).\nKompatibilita verzí Číslování verzí I2P: I2P udržuje dvě paralelní číselné řady verzí: - Verze vydání routeru: formát 2.x.x (např. 2.10.0 vydáno v září 2025) - Verze API/protokolu: formát 0.9.x (např. 0.9.67 odpovídá routeru 2.10.0)\nTato specifikace odkazuje na verzi protokolu 0.9.67, která odpovídá vydání routeru 2.10.0 a novějším.\nMatice kompatibility:\nImplementation Version ML-KEM Support Status i2pd 2.58.0+ Full (512/768/1024) Deployed September 2025 Java I2P 0.9.67 / 2.10.0 Not yet Planned for future release ## Reference [ECIES]: Specifikace ECIES-X25519-AEAD-Ratchet [Prop169]: Návrh 169: postkvantová kryptografie [FIPS203]: NIST FIPS 203 - standard ML-KEM [FIPS202]: NIST FIPS 202 - standard SHA-3 [Noise]: Rámec protokolu Noise [COMMON]: Specifikace společných struktur [RFC7539]: RFC 7539 - ChaCha20 a Poly1305 [RFC5869]: RFC 5869 - HKDF [OpenSSL]: Dokumentace OpenSSL 3.5 ML-KEM [Bouncycastle]: Java kryptografická knihovna Bouncycastle ","description":"Postkvantová hybridní varianta šifrovacího protokolu ECIES využívající ML‑KEM (mechanismus zapouzdření klíče založený na modulech mříží)","id":"f6a66a37875c5b108bc5a8ea027dc0e2","section":"docs","title":"ECIES-X25519-AEAD-Ratchet hybridní šifrování","url":"/cs/docs/specs/ecies-hybrid/"},{"categories":null,"content":"Přehled I2P pluginy jsou podepsané archivy, které rozšiřují funkčnost routeru. Dodávají se jako soubory .xpi2p nebo .su3, instalují se do ~/.i2p/plugins/\u0026lt;name\u0026gt;/ (nebo na Windows do %APPDIR%\\I2P\\plugins\\\u0026lt;name\u0026gt;\\) a běží s plnými oprávněními routeru bez sandboxingu (bez izolace).\nPodporované typy zásuvných modulů Webové aplikace konzole Nové eepsites s cgi-bin, webovými aplikacemi Motivy konzole Překlady konzole Programy v Javě (v rámci procesu nebo v samostatné JVM) Shell skripty a nativní binární soubory Bezpečnostní model KRITICKÉ: Zásuvné moduly běží ve stejné JVM se stejnými oprávněními jako I2P router. Mají neomezený přístup k: - souborovému systému (čtení a zápis) - API routeru a internímu stavu - síťovým připojením - spouštění externích programů\nZásuvné moduly by měly být považovány za plně důvěryhodný kód. Uživatelé musí před instalací ověřit zdroje a podpisy zásuvných modulů.\nFormáty souborů Formát SU3 (důrazně doporučeno) Stav: Aktivní, preferovaný formát od I2P 0.9.15 (září 2014)\nFormát .su3 poskytuje: - RSA-4096 podpisové klíče (oproti DSA-1024 v xpi2p) - Podpis uložený v hlavičce souboru - Magické číslo: I2Psu3 - Lepší dopředná kompatibilita\nStruktura:\n[SU3 Header with RSA-4096 signature] [ZIP Archive] ├── plugin.config (required) ├── console/ ├── lib/ ├── webapps/ └── [other plugin files] Formát XPI2P (starší, nedoporučovaný) Stav: Podporováno kvůli zachování zpětné kompatibility, nedoporučuje se pro nové zásuvné moduly\nFormát .xpi2p používá starší kryptografické podpisy: - Podpisy DSA-1024 (zastaralé dle NIST-800-57) - 40bajtový podpis DSA předřazený souboru ZIP - Vyžaduje pole key v plugin.config\nStruktura:\n[40-byte DSA signature] [16-byte version string (UTF-8, zero-padded)] [ZIP Archive] Postup migrace: Při migraci z xpi2p na su3 uveďte během přechodu obě updateURL i updateURL.su3. Moderní routery (0.9.15+) automaticky upřednostňují SU3.\nStruktura archivu a plugin.config Požadované soubory plugin.config - Standardní konfigurační soubor I2P s páry klíč–hodnota\nPovinné vlastnosti Property Description Format nameInstallation directory name, must match for updatesAlphanumeric, no spaces signerDeveloper contact informationuser@mail.i2p format recommended versionPlugin version for update comparisonMax 16 bytes, parsed by VersionComparator keyDSA public key (172 B64 chars ending with '=')Omit for SU3 format **Příklady formátu verzí:** - `1.2.3` - `1.2.3-4` - `2.0.0-beta.1` Platné oddělovače: . (tečka), - (pomlčka), _ (podtržítko)\nVolitelné vlastnosti metadat Zobrazit informace date - Datum vydání (časové razítko typu long v Javě) author - Jméno vývojáře (doporučeno user@mail.i2p) description - Popis v angličtině description_xx - Lokalizovaný popis (xx = kód jazyka) websiteURL - Domovská stránka zásuvného modulu (http://foo.i2p/) license - Identifikátor licence (např. \u0026ldquo;Apache-2.0\u0026rdquo;, \u0026ldquo;GPL-3.0\u0026rdquo;) Aktualizovat konfiguraci updateURL - Umístění aktualizace XPI2P (zastaralé) updateURL.su3 - Umístění aktualizace SU3 (formát aktualizačního balíčku I2P) (preferované) min-i2p-version - Minimální požadovaná verze I2P max-i2p-version - Maximální kompatibilní verze I2P min-java-version - Minimální verze Javy (např. 1.7, 17) min-jetty-version - Minimální verze Jetty (použijte 6 pro Jetty 6+) max-jetty-version - Maximální verze Jetty (použijte 5.99999 pro Jetty 5) Chování instalace dont-start-at-install - Výchozí hodnota false. Pokud true, vyžaduje ruční spuštění router-restart-required - Výchozí hodnota false. Informuje uživatele, že je po aktualizaci nutný restart update-only - Výchozí hodnota false. Selže, pokud zásuvný modul ještě není nainstalován install-only - Výchozí hodnota false. Selže, pokud zásuvný modul již existuje min-installed-version - Minimální verze vyžadovaná pro aktualizaci max-installed-version - Maximální verze, kterou lze aktualizovat disableStop - Výchozí hodnota false. Skryje tlačítko Stop, pokud true Integrace konzole consoleLinkName - Text odkazu na liště přehledu konzole consoleLinkName_xx - Lokalizovaný text odkazu (xx = kód jazyka) consoleLinkURL - Cíl odkazu (např. /appname/index.jsp) consoleLinkTooltip - Text při najetí myší (podporováno od 0.7.12-6) consoleLinkTooltip_xx - Lokalizovaný text nápovědy console-icon - Cesta k ikoně 32x32 (podporováno od 0.9.20) icon-code - Base64-kódované 32x32 PNG pro pluginy bez webových zdrojů (od 0.9.25) Požadavky na platformu (pouze pro zobrazení) required-platform-OS - Požadavek na operační systém (není vynuceno) other-requirements - Dodatečné požadavky (např. \u0026ldquo;Python 3.8+\u0026rdquo;) Správa závislostí (neimplementováno) depends - Závislosti zásuvného modulu oddělené čárkou depends-version - Požadavky na verze závislostí langs - Obsah jazykového balíčku type - Typ zásuvného modulu (app/theme/locale/webapp) Substituce proměnných v aktualizační adrese URL Stav funkce: K dispozici od I2P 1.7.0 (0.9.53)\nJak updateURL, tak updateURL.su3 podporují platformově specifické proměnné:\nProměnné: - $OS - Operační systém: windows, linux, mac - $ARCH - Architektura: 386, amd64, arm64\nPříklad:\nupdateURL.su3=http://foo.i2p/downloads/foo-$OS-$ARCH.su3 Výsledek na Windows AMD64:\nhttp://foo.i2p/downloads/foo-windows-amd64.su3 Tím je možné mít u platformně specifických sestavení jediný soubor plugin.config.\nStruktura adresářů Standardní rozložení plugins/ └── pluginname/ ├── plugin.config (required) ├── console/ │ ├── locale/ # Translation JARs │ ├── themes/ # Console themes │ ├── webapps/ # Web applications │ └── webapps.config # Webapp configuration ├── eepsite/ │ ├── cgi-bin/ │ ├── docroot/ │ ├── logs/ │ ├── webapps/ │ └── jetty.xml ├── lib/ │ └── *.jar # Plugin libraries └── clients.config # Client startup configuration Účely adresáře console/locale/ - Soubory JAR obsahující balíčky lokalizačních prostředků pro základní překlady I2P - překlady specifické pro zásuvné moduly by měly být v console/webapps/*.war nebo lib/*.jar\nconsole/themes/ - Každá podsložka obsahuje kompletní motiv konzole - Automaticky přidáno do vyhledávací cesty motivů\nconsole/webapps/ - soubory .war pro integraci s konzolí - Spouští se automaticky, pokud nejsou zakázány v webapps.config - Název WAR nemusí odpovídat názvu pluginu\neepsite/ - Kompletní eepsite s vlastní instancí Jetty - Vyžaduje konfiguraci jetty.xml se substitucí proměnných - Viz příklady pluginů zzzot a pebble\nlib/ - JAR knihovny pluginu - Zadejte do classpath (cesta ke třídám) prostřednictvím clients.config nebo webapps.config\nKonfigurace webové aplikace Formát webapps.config Standardní konfigurační soubor I2P, který určuje chování webové aplikace.\nSyntaxe:\n# Disable autostart webapps.warname.startOnLoad=false # Add classpath JARs (as of API 0.9.53, works for any warname) webapps.warname.classpath=$PLUGIN/lib/foo.jar,$I2P/lib/bar.jar Důležité poznámky: - Před verzí routeru 0.7.12-9 použijte kvůli kompatibilitě plugin.warname.startOnLoad - Před verzí API 0.9.53 fungoval classpath pouze tehdy, když se warname shodoval s názvem pluginu - Od verze 0.9.53+ funguje classpath pro libovolný název webové aplikace\nOsvědčené postupy pro webové aplikace Implementace ServletContextListener\nImplementujte javax.servlet.ServletContextListener pro úklid prostředků Nebo přepište destroy() v servletu Zajistí korektní ukončení během aktualizací a při zastavení routeru Správa knihoven\nSdílené JARy umisťujte do lib/, ne do WARu Odkazujte přes classpath (vyhledávací cesta tříd) v webapps.config Umožňuje samostatnou instalaci/aktualizaci pluginů Vyhněte se konfliktům knihoven\nNikdy nepřibalujte JARy Jetty, Tomcat ani se servletovým API Nikdy nepřibalujte JARy ze standardní instalace I2P Zkontrolujte sekci classpath kvůli standardním knihovnám Požadavky na kompilaci\nNezahrnujte zdrojové soubory .java ani .jsp Předkompilujte všechny JSP, abyste předešli zpoždění při spuštění Nelze předpokládat dostupnost kompilátorů pro Java/JSP Kompatibilita se Servlet API\nI2P podporuje Servlet 3.0 (od 0.9.30) Skenování anotací NENÍ podporováno (@WebContent) Je nutné poskytnout tradiční deskriptor nasazení web.xml Verze Jetty\nAktuální: Jetty 9 (I2P 0.9.30+) Použijte net.i2p.jetty.JettyStart pro abstrakci Chrání před změnami v API Jetty Konfigurace klienta Formát clients.config Definuje klienty (služby) spouštěné pomocí zásuvného modulu.\nZákladní klient:\nclientApp.0.main=com.example.PluginMain clientApp.0.name=Example Plugin Service clientApp.0.delay=30 clientApp.0.args=arg1 arg2 $PLUGIN/config.properties Klient s funkcemi Zastavit/Odinstalovat:\nclientApp.0.stopargs=stop clientApp.0.uninstallargs=uninstall clientApp.0.classpath=$PLUGIN/lib/plugin.jar,$I2P/lib/i2p.jar Reference vlastností Property Description mainFully qualified class name implementing ClientApp interface nameDisplay name for user interface delayStartup delay in seconds (default: 0) argsSpace-separated arguments passed to constructor stopargsArguments for shutdown (must handle gracefully) uninstallargsArguments called before plugin deletion classpathComma-separated JAR paths ### Nahrazování proměnných Následující proměnné jsou nahrazeny v args, stopargs, uninstallargs a classpath:\nVariable Replacement $I2PI2P base installation directory $CONFIGI2P configuration directory (typically ~/.i2p) $PLUGINThis plugin's directory ($CONFIG/plugins/name) $OSOperating system: windows, linux, mac $ARCHArchitecture: 386, amd64, arm64 ### Spravovaní vs. nespravovaní klienti Spravovaní klienti (Doporučeno, od verze 0.9.4): - Instanciováni pomocí ClientAppManager - Udržují reference a sledování stavu - Snazší správa životního cyklu - Lepší správa paměti\nNespravovaní klienti: - Spouštěni routerem, bez sledování stavu - Musí korektně zvládat vícenásobná volání start/stop - K koordinaci používejte statický stav nebo PID soubory - Voláno při vypnutí routeru (od verze 0.7.12-3)\nShellService (od verze 0.9.53 / 1.7.0) Generalizované řešení pro spouštění externích programů s automatickým sledováním stavu.\nFunkce: - Spravuje životní cyklus procesu - Komunikuje s ClientAppManager (správcem klientských aplikací) - Automatická správa PID - Víceplatformní podpora\nPoužití:\nclientApp.0.main=net.i2p.apps.ShellService clientApp.0.args=$PLUGIN/bin/myservice.sh Pro skripty specifické pro platformu:\nclientApp.0.args=$PLUGIN/bin/myservice-$OS.$ARCH Alternativa (starší): Napište Java wrapper (obalovací vrstva), který zjišťuje typ operačního systému, a zavolejte ShellCommand s příslušným souborem .bat nebo .sh.\nPostup instalace Postup instalace pro uživatele Uživatel vloží adresu URL zásuvného modulu na stránku konfigurace zásuvných modulů konzole routeru (/configplugins) Router stáhne soubor zásuvného modulu Ověření podpisu (selže, pokud je klíč neznámý a je povolen striktní režim) Kontrola integrity archivu ZIP Rozbalit a parsovat plugin.config Ověření kompatibility verzí (min-i2p-version, min-java-version atd.) Detekce konfliktu názvu webové aplikace Zastavení stávajícího zásuvného modulu v případě aktualizace Validace adresáře (musí být pod plugins/) Rozbalit všechny soubory do adresáře zásuvného modulu Aktualizovat plugins.config Spustit zásuvný modul (pokud není nastaveno dont-start-at-install=true) Zabezpečení a důvěra Správa klíčů: - Model důvěry „first-key-seen“ (důvěra v první spatřený klíč) pro nové podepisovatele - Předinstalované jsou pouze klíče jrandom a zzz - Od verze 0.9.14.1 jsou neznámé klíče ve výchozím nastavení odmítány - Pokročilá konfigurační volba může toto chování pro účely vývoje přepsat\nOmezení instalace: - Archivy se smějí rozbalit pouze do adresáře pluginů - Instalátor odmítá cesty mimo plugins/ - Pluginy mohou po instalaci přistupovat k souborům i jinde - Žádné sandboxování ani izolace oprávnění\nMechanismus aktualizace Proces kontroly aktualizací Router čte updateURL.su3 (preferované) nebo updateURL z plugin.config Požadavek HTTP HEAD nebo částečný GET k načtení bajtů 41–56 Extrahovat řetězec verze ze vzdáleného souboru Porovnat s nainstalovanou verzí pomocí VersionComparator Je-li novější, vyzvat uživatele nebo ji automaticky stáhnout (dle nastavení) Zastavit zásuvný modul Nainstalovat aktualizaci Spustit zásuvný modul (pokud se uživatelská předvolba nezměnila) Srovnání verzí Verze jsou parsovány jako komponenty oddělené tečkou/pomlčkou/podtržítkem: - 1.2.3 \u0026lt; 1.2.4 - 1.2.3 \u0026lt; 1.2.3-1 - 2.0.0 \u0026gt; 1.9.9\nMaximální délka: 16 bajtů (musí odpovídat hlavičce SUD/SU3)\nOsvědčené postupy pro aktualizace Při každém vydání zvyšte verzi Otestujte postup aktualizace z předchozí verze Zvažte router-restart-required pro zásadní změny Během migrace poskytněte jak updateURL, tak updateURL.su3 Pro testování použijte příponu čísla sestavení (1.2.3-456) Classpath a standardní knihovny Vždy k dispozici v Classpath (seznam cest, kde JVM hledá třídy) Následující JARy z $I2P/lib jsou v I2P 0.9.30+ vždy v classpath (vyhledávací cestě pro třídy):\nJAR Contents Plugin Usage i2p.jarCore APIRequired for all plugins mstreaming.jarStreaming APIMost plugins need streaming.jarStreaming implementationMost plugins need i2ptunnel.jarI2PTunnelHTTP/server plugins router.jarRouter internalsRarely needed, avoid if possible javax.servlet.jarServlet 3.1, JSP 2.3 APIPlugins with servlets/JSPs jasper-runtime.jarJasper compiler/runtimePlugins with JSPs commons-el.jarEL 3.0 APIJSPs using expression language jetty-i2p.jarJetty utilitiesPlugins starting Jetty org.mortbay.jetty.jarJetty 9 baseCustom Jetty instances sam.jarSAM APIRarely needed addressbook.jarSubscription/blockfileUse NamingService instead routerconsole.jarConsole librariesNot public API, avoid jbigi.jarNative cryptoPlugins should not need systray.jarURL launcherRarely needed wrapper.jarService wrapperPlugins should not need ### Zvláštní poznámky commons-logging.jar: - Prázdný od 0.9.30 - Před 0.9.30: Apache Tomcat JULI - Před 0.9.24: Commons Logging + JULI - Před 0.9: Pouze Commons Logging\njasper-compiler.jar: - Prázdné od Jetty 6 (0.9)\nsystray4j.jar: - Odstraněno ve verzi 0.9.26\nNení na Classpath (musí být uvedeno) JAR Contents Usage jstl.jarStandard TaglibJSP tag libraries standard.jarStandard TaglibJSP tag libraries ### Specifikace Classpath (seznam cest k třídám v Javě) V souboru clients.config:\nclientApp.0.classpath=$PLUGIN/lib/mylib.jar,$I2P/lib/i2p.jar V webapps.config:\nwebapps.mywebapp.classpath=$PLUGIN/lib/mylib.jar,$I2P/lib/jstl.jar Důležité: Od verze 0.7.13-3 je classpath (vyhledávací cesta pro třídy) vázán na vlákno, nikoli na celou JVM. U každého klienta uveďte úplný classpath.\nPožadavky na verzi Javy Aktuální požadavky (říjen 2025) I2P 2.10.0 a starší: - Minimální: Java 7 (vyžadováno od verze 0.9.24, leden 2016) - Doporučeno: Java 8 nebo novější\nI2P 2.11.0 a novější (PŘIPRAVUJE SE): - Minimálně: Java 17+ (oznáměno v poznámkách k vydání 2.9.0) - Poskytnuto upozornění dvě vydání dopředu (2.9.0 → 2.10.0 → 2.11.0)\nStrategie kompatibility zásuvných modulů Pro maximální kompatibilitu (až do I2P 2.10.x včetně):\n\u0026lt;javac source=\u0026#34;1.7\u0026#34; target=\u0026#34;1.7\u0026#34; /\u0026gt; min-java-version=1.7 Pro funkce Javy 8+:\n\u0026lt;javac source=\u0026#34;1.8\u0026#34; target=\u0026#34;1.8\u0026#34; /\u0026gt; min-java-version=1.8 Pro funkce Java 11+:\n\u0026lt;javac source=\u0026#34;11\u0026#34; target=\u0026#34;11\u0026#34; /\u0026gt; min-java-version=11 Příprava na 2.11.0+:\n\u0026lt;javac source=\u0026#34;17\u0026#34; target=\u0026#34;17\u0026#34; /\u0026gt; min-java-version=17 min-i2p-version=2.11.0 Osvědčené postupy kompilace Při kompilaci s novějším JDK pro starší cílovou verzi:\n\u0026lt;javac source=\u0026#34;1.7\u0026#34; target=\u0026#34;1.7\u0026#34; bootclasspath=\u0026#34;${java7.home}/jre/lib/rt.jar\u0026#34; includeantruntime=\u0026#34;false\u0026#34; /\u0026gt; Tím se zabrání použití rozhraní API, která nejsou dostupná v cílové verzi Javy.\nKomprese Pack200 - ZASTARALÉ Kritická aktualizace: Nepoužívejte Pack200 Stav: ZASTARALÉ A ODSTRANĚNO\nPůvodní specifikace důrazně doporučovala kompresi Pack200 (formát komprese pro JAR balíčky) pro snížení velikosti o 60–65 %. To již neplatí.\nČasová osa: - JEP 336: Pack200 označen jako zastaralý v Javě 11 (září 2018) - JEP 367: Pack200 odstraněn v Javě 14 (březen 2020)\nOficiální specifikace aktualizací I2P uvádí: \u0026gt; \u0026ldquo;Soubory JAR a WAR v zipu už nejsou komprimovány pomocí pack200, jak je popsáno výše pro soubory \u0026lsquo;su2\u0026rsquo;, protože novější běhová prostředí Javy už pack200 nepodporují.\u0026rdquo;\nCo dělat:\nOdstraňte pack200 z procesů sestavení okamžitě Použijte standardní kompresi ZIP Zvažte alternativy: ProGuard/R8 pro zmenšení kódu UPX pro nativní binární soubory Moderní kompresní algoritmy (zstd, brotli), pokud je k dispozici vlastní dekompresor Pro stávající pluginy: - Staré routers (0.7.11-5 až po Java 10) stále umí rozbalit pack200 - Nové routers (Java 11+) neumí rozbalit pack200 - Znovu vydávejte pluginy bez komprese pack200\nPodpisové klíče a zabezpečení Generování klíčů (formát SU3) Použijte skript makeplugin.sh z repozitáře i2p.scripts:\n# Generate new signing key ./makeplugin.sh keygen # Keys stored in ~/.i2p-plugin-keys/ Klíčové údaje: - Algoritmus: RSA_SHA512_4096 - Formát: certifikát X.509 - Uložení: formát úložiště klíčů Java\nPodepisování zásuvných modulů # Create signed su3 file ./makeplugin.sh sign myplugin.zip myplugin.su3 keyname # Verify signature ./makeplugin.sh verify myplugin.su3 Osvědčené postupy pro správu klíčů Vygenerujte jednou, chraňte navždy\nRouters odmítají duplicitní názvy klíčů s odlišnými klíči Routers odmítají duplicitní klíče s odlišnými názvy klíčů Aktualizace jsou odmítnuty, pokud se klíč a název neshodují Bezpečné ukládání\nBezpečně zálohujte úložiště klíčů Používejte silnou heslovou frázi Nikdy neukládejte do systému správy verzí Rotace klíčů\nNení podporována současnou architekturou Plánujte dlouhodobé používání klíčů Zvažte vícepodpisová schémata pro týmový vývoj Zastaralé podepisování DSA (XPI2P) Stav: Funkční, ale zastaralé\nPodpisy DSA-1024 používané formátem xpi2p: - 40bajtový podpis - veřejný klíč o délce 172 znaků base64 - NIST-800-57 doporučuje jako minimum (L=2048, N=224) - I2P používá slabší (L=1024, N=160)\nDoporučení: Místo toho použijte SU3 s RSA-4096.\nPokyny pro vývoj pluginů Základní osvědčené postupy Dokumentace\nPoskytněte srozumitelný soubor README s pokyny k instalaci Zdokumentujte konfigurační volby a výchozí hodnoty Zahrňte seznam změn ke každému vydání Uveďte požadované verze I2P/Java Optimalizace velikosti\nZahrňte pouze nezbytné soubory Nikdy nepřibalujte router JARy Oddělte instalační vs. aktualizační balíčky (knihovny v lib/) Použijte kompresi Pack200 ZASTARALÉ - Použijte standardní ZIP Konfigurace\nNikdy neupravujte plugin.config za běhu Použijte samostatný konfigurační soubor pro nastavení za běhu Zdokumentujte požadovaná nastavení pro router (SAM porty, tunnels, atd.) Respektujte stávající nastavení uživatele Využití prostředků\nVyhněte se agresivní spotřebě šířky pásma ve výchozím nastavení Zaveďte rozumné limity využití procesoru Při ukončení uvolněte prostředky Používejte daemon threads (vlákna na pozadí) tam, kde je to vhodné Testování\nOtestovat instalaci/aktualizaci/odinstalaci na všech platformách Otestovat aktualizace z předchozí verze Ověřit zastavení/opětovné spuštění webové aplikace během aktualizací Otestovat s minimální podporovanou verzí I2P Souborový systém\nNikdy nezapisujte do $I2P (může být pouze pro čtení) Data za běhu zapisujte do $PLUGIN nebo $CONFIG Pro zjištění umístění adresářů použijte I2PAppContext Nepředpokládejte umístění $CWD Kompatibilita\nNeduplikujte standardní třídy I2P Rozšiřujte třídy, pokud je to nutné; nenahrazujte je Zkontrolujte min-i2p-version, min-jetty-version v plugin.config Testujte se staršími verzemi I2P, pokud je podporujete Obsluha ukončení\nImplementujte správné stopargs v souboru clients.config Zaregistrujte shutdown hooks (háčky pro ukončení): I2PAppContext.addShutdownTask() Ošetřete vícečetná volání spuštění/zastavení korektně Nastavte všechna vlákna do režimu daemon (démon) Bezpečnost\nOvěřujte veškerý externí vstup Nikdy nevolejte System.exit() Respektujte soukromí uživatelů Dodržujte zásady bezpečného programování Licencování\nJasně uveďte licenci zásuvného modulu Dodržujte licence přibalených knihoven Zahrňte požadované uvedení autorství Poskytněte přístup ke zdrojovému kódu, je-li to vyžadováno Pokročilé úvahy Zpracování časových pásem: - Router nastaví časové pásmo JVM na UTC - Skutečné časové pásmo uživatele: I2PAppContext vlastnost i2p.systemTimeZone\nDetekce adresáře:\n// Plugin directory String pluginDir = I2PAppContext.getGlobalContext() .getAppDir().getAbsolutePath() + \u0026#34;/plugins/\u0026#34; + pluginName; // Or use $PLUGIN variable in clients.config args Číslování verzí: - Použijte semantické verzování (major.minor.patch) - Přidejte číslo sestavení pro testování (1.2.3-456) - Zajistěte monotónní zvyšování při aktualizacích\nPřístup ke třídám routeru: - Obecně se vyhněte závislostem na router.jar - Místo toho používejte veřejná API v i2p.jar - Budoucí verze I2P mohou omezit přístup ke třídám routeru\nPrevence pádů JVM (historické): - Opraveno ve verzi 0.7.13-3 - Správně používejte ClassLoader (načítací mechanismus tříd) - Vyhněte se aktualizaci souborů JAR v běžícím zásuvném modulu - Navrhněte podporu restartu při aktualizaci, pokud je to nutné\nZásuvné moduly pro Eepsite Přehled Pluginy mohou poskytovat plnohodnotné eepsites s vlastními instancemi Jetty a I2PTunnel.\nArchitektura Nepokoušejte se: - Instalovat do existujícího eepsite - Slučovat s výchozím eepsite routeru - Předpokládat dostupnost jediného eepsite\nMísto toho: - Spusťte novou instanci I2PTunnel (pomocí CLI) - Spusťte novou instanci Jetty - Nakonfigurujte obě v clients.config\nUkázková struktura plugins/myeepsite/ ├── plugin.config ├── clients.config # Starts Jetty + I2PTunnel ├── eepsite/ │ ├── jetty.xml # Requires variable substitution │ ├── docroot/ │ ├── webapps/ │ └── logs/ └── lib/ └── [dependencies] Nahrazování proměnných v jetty.xml Použijte proměnnou $PLUGIN pro cesty:\n\u0026lt;Set name=\u0026#34;resourceBase\u0026#34;\u0026gt;$PLUGIN/eepsite/docroot\u0026lt;/Set\u0026gt; Router provádí nahrazení během spuštění zásuvného modulu.\nPříklady Referenční implementace: - zzzot plugin - torrentový tracker - pebble plugin - blogová platforma\nObojí je k dispozici na stránce pluginů uživatele zzz (interní v I2P).\nIntegrace konzole Odkazy na přehledovém panelu Přidat kliknutelný odkaz do souhrnného panelu konzole routeru:\nconsoleLinkName=My Plugin consoleLinkURL=/myplugin/ consoleLinkTooltip=Open My Plugin Interface Lokalizované verze:\nconsoleLinkName_de=Mein Plugin consoleLinkTooltip_de=Öffne Mein Plugin Schnittstelle Ikony konzole Obrazový soubor (od 0.9.20):\nconsole-icon=/myicon.png Cesta relativní k consoleLinkURL, pokud je uvedena (od verze 0.9.53), jinak relativní k názvu webové aplikace.\nVložená ikona (od verze 0.9.25):\nicon-code=iVBORw0KGgoAAAANSUhEUgAAA...Base64EncodedPNG... Vygenerujte pomocí:\nbase64 -w 0 icon-32x32.png Nebo v Javě:\njava -cp i2p.jar net.i2p.data.Base64 encode icon.png Požadavky: - 32x32 pixelů - formát PNG - zakódováno v Base64 (bez zalomení řádků)\nInternacionalizace Balíčky překladů Pro základní překlady I2P: - Umístěte soubory JAR do console/locale/ - Obsahují balíčky prostředků pro stávající aplikace I2P - Pojmenování: messages_xx.properties (xx = kód jazyka)\nPro překlady specifické pro zásuvné moduly: - Zahrňte do console/webapps/*.war - Nebo zahrňte do lib/*.jar - Použijte standardní mechanismus Java ResourceBundle\nLokalizované řetězce v souboru plugin.config description=My awesome plugin description_de=Mein tolles Plugin description_fr=Mon plugin génial description_es=Mi plugin increíble Podporovaná pole: - description_xx - consoleLinkName_xx - consoleLinkTooltip_xx\nPřeklad motivu konzole Motivy v console/themes/ se automaticky přidávají do vyhledávací cesty motivů.\nPlatformově specifické zásuvné moduly Přístup s oddělenými balíčky Použijte různé názvy pluginů pro každou platformu:\n# Windows package name=myplugin-windows # Linux package name=myplugin-linux # macOS package name=myplugin-mac Přístup založený na nahrazování proměnných Jediný plugin.config s proměnnými platformy:\nname=myplugin updateURL.su3=http://myplugin.i2p/downloads/myplugin-$OS-$ARCH.su3 V clients.config:\nclientApp.0.main=net.i2p.apps.ShellService clientApp.0.args=$PLUGIN/bin/myapp-$OS-$ARCH Detekce operačního systému za běhu Přístup v jazyce Java k podmíněnému provádění:\nString os = System.getProperty(\u0026#34;os.name\u0026#34;).toLowerCase(); if (os.contains(\u0026#34;win\u0026#34;)) { // Windows-specific code } else if (os.contains(\u0026#34;nix\u0026#34;) || os.contains(\u0026#34;nux\u0026#34;)) { // Linux-specific code } else if (os.contains(\u0026#34;mac\u0026#34;)) { // macOS-specific code } Řešení problémů Časté problémy Zásuvný modul se nespouští: 1. Zkontrolujte kompatibilitu s verzí I2P (min-i2p-version) 2. Ověřte verzi Javy (min-java-version) 3. Zkontrolujte logy routeru kvůli chybám 4. Ověřte, že všechny požadované JARy jsou v classpath (třídní cesta v Javě)\nWebová aplikace není přístupná: 1. Ověřte, že webapps.config ji nezakazuje 2. Zkontrolujte kompatibilitu verze Jetty (min-jetty-version) 3. Ověřte, že je přítomen soubor web.xml (prohledávání anotací není podporováno) 4. Zkontrolujte konflikty v názvech webových aplikací\nAktualizace selhává: 1. Ověřte, že se řetězec verze zvýšil 2. Zkontrolujte, že podpis odpovídá podpisovému klíči 3. Ujistěte se, že název zásuvného modulu odpovídá nainstalované verzi 4. Zkontrolujte nastavení update-only/install-only\nExterní program nelze zastavit: 1. Použijte ShellService pro automatické řízení životního cyklu 2. Implementujte správné zpracování stopargs 3. Zkontrolujte vyčištění souboru s PID 4. Ověřte ukončení procesu\nProtokolování ladění Povolit ladicí protokolování v routeru:\nlogger.record.net.i2p.router.web.ConfigPluginsHandler=DEBUG Zkontrolujte protokoly:\n~/.i2p/logs/log-router-0.txt Referenční informace Oficiální specifikace Specifikace zásuvného modulu Formát konfigurace Specifikace aktualizace Kryptografie Historie verzí I2P Aktuální vydání: - I2P 2.10.0 (8. září 2025)\nHlavní vydání od 0.9.53: - 2.10.0 (září 2025) - oznámení o Java 17+ - 2.9.0 (červen 2025) - upozornění na Java 17+ - 2.8.0 (říjen 2024) - testování postkvantové kryptografie - 2.6.0 (květen 2024) - blokování I2P-over-Tor - 2.4.0 (prosinec 2023) - vylepšení zabezpečení NetDB - 2.2.0 (březen 2023) - řízení přetížení - 2.1.0 (leden 2023) - vylepšení sítě - 2.0.0 (listopad 2022) - transportní protokol SSU2 - 1.7.0/0.9.53 (únor 2022) - ShellService, nahrazování proměnných - 0.9.15 (září 2014) - zaveden formát SU3\nČíslování verzí: - řada 0.9.x: do verze 0.9.53 včetně - řada 2.x: od verze 2.0.0 (zavedení SSU2)\nZdroje pro vývojáře Zdrojový kód: - Hlavní repozitář: https://i2pgit.org/I2P_Developers/i2p.i2p - Zrcadlo na GitHubu: https://github.com/i2p/i2p.i2p Příklady pluginů: - zzzot (BitTorrent tracker) - pebble (blogová platforma) - i2p-bote (bezserverový e-mail) - orchid (klient Tor) - seedless (výměna peerů)\nNástroje pro sestavení: - makeplugin.sh - Generování a podepisování klíčů - Nachází se v repozitáři i2p.scripts - Automatizuje vytváření a ověřování su3\nPodpora komunity Fóra: - I2P Forum - zzz.i2p (pouze uvnitř I2P)\nIRC/Chat: - #i2p-dev na OFTC - I2P IRC v rámci sítě\nPříloha A: Kompletní příklad plugin.config # Required fields name=example-plugin signer=developer@mail.i2p version=1.2.3 # Update configuration updateURL.su3=http://example.i2p/plugins/example-$OS-$ARCH.su3 min-i2p-version=2.0.0 min-java-version=17 # Display information date=1698796800000 author=Example Developer \u0026lt;developer@mail.i2p\u0026gt; websiteURL=http://example.i2p/ license=Apache-2.0 description=An example I2P plugin demonstrating best practices description_de=Ein Beispiel-I2P-Plugin zur Demonstration bewährter Praktiken description_es=Un plugin I2P de ejemplo que demuestra las mejores prácticas # Console integration consoleLinkName=Example Plugin consoleLinkName_de=Beispiel-Plugin consoleLinkURL=/example/ consoleLinkTooltip=Open the Example Plugin control panel consoleLinkTooltip_de=Öffne das Beispiel-Plugin-Kontrollfeld console-icon=/icon.png # Installation behavior dont-start-at-install=false router-restart-required=false # Platform requirements (informational) required-platform-OS=All platforms supported other-requirements=Requires 512MB free disk space Příloha B: Úplný příklad souboru clients.config # Main service client (managed) clientApp.0.main=com.example.plugin.MainService clientApp.0.name=Example Plugin Main Service clientApp.0.delay=30 clientApp.0.args=$PLUGIN/config.properties --port=7656 clientApp.0.stopargs=shutdown clientApp.0.uninstallargs=cleanup clientApp.0.classpath=$PLUGIN/lib/example.jar,$I2P/lib/i2p.jar,$I2P/lib/mstreaming.jar # External program via ShellService clientApp.1.main=net.i2p.apps.ShellService clientApp.1.name=Example Native Helper clientApp.1.delay=35 clientApp.1.args=$PLUGIN/bin/helper-$OS-$ARCH --config $PLUGIN/helper.conf clientApp.1.classpath=$I2P/lib/i2p.jar # Jetty eepsite clientApp.2.main=net.i2p.jetty.JettyStart clientApp.2.name=Example Eepsite clientApp.2.delay=40 clientApp.2.args=$PLUGIN/eepsite/jetty.xml clientApp.2.stopargs=$PLUGIN/eepsite/jetty.xml stop clientApp.2.classpath=$PLUGIN/lib/example-web.jar,$I2P/lib/i2p.jar # I2PTunnel for eepsite clientApp.3.main=net.i2p.i2ptunnel.TunnelControllerGroup clientApp.3.name=Example Eepsite Tunnel clientApp.3.delay=45 clientApp.3.args=$PLUGIN/eepsite/i2ptunnel.config Příloha C: Úplný příklad webapps.config # Disable autostart for admin webapp webapps.example-admin.startOnLoad=false # Main webapp with classpath webapps.example.startOnLoad=true webapps.example.classpath=$PLUGIN/lib/example-core.jar,$PLUGIN/lib/commons-utils.jar,$I2P/lib/jstl.jar,$I2P/lib/standard.jar # Legacy support (pre-0.7.12-9) plugin.example.startOnLoad=true Příloha D: Kontrolní seznam migrace (z 0.9.53 na 2.10.0) Požadované změny Odstranit kompresi Pack200 (formát komprese JAR v Javě) z procesu sestavení\nOdstranit úlohy pack200 ze skriptů Ant/Maven/Gradle Znovu vydat stávající zásuvné moduly bez pack200 Zkontrolovat požadavky na verzi Javy\nZvážit vyžadování Javy 11+ pro nové funkce Naplánovat požadavek na Javu 17+ v I2P 2.11.0 Aktualizovat min-java-version v plugin.config Aktualizovat dokumentaci\nOdstranit zmínky o Pack200 Aktualizovat požadavky na verzi Javy Aktualizovat zmínky o verzích I2P (0.9.x → 2.x) Doporučené změny Posilte kryptografické podpisy\nPřejděte z XPI2P na SU3, pokud jste tak dosud neučinili Používejte klíče RSA-4096 pro nové zásuvné moduly Využijte nové funkce (pokud používáte 0.9.53+)\nPoužijte proměnné $OS / $ARCH pro aktualizace specifické pro platformu Použijte ShellService (služba shellu) pro externí programy Použijte vylepšený classpath webové aplikace (funguje pro libovolný název WAR) Otestovat kompatibilitu\nOtestovat na I2P 2.10.0 Ověřit s Javou 8, 11, 17 Zkontrolovat na Windows, Linuxu, macOS Volitelná vylepšení Správně implementovat ServletContextListener Přidat lokalizované popisy Dodat ikonu konzole Zlepšit obsluhu ukončování Přidat komplexní logování Napsat automatizované testy ","description":".xpi2p / .su3 pravidla balení pro zásuvné moduly I2P","id":"b25aafc3542216f9bbc2f124d1943fbc","section":"docs","title":"Formát balíčku zásuvného modulu","url":"/cs/docs/specs/plugin/"},{"categories":null,"content":"Přístupové filtry umožňují správcům serveru I2PTunnel povolit, zakázat nebo omezit příchozí spojení na základě zdrojové Destination (identifikátor koncového bodu v I2P) a nedávné rychlosti navazování spojení. Filtr je prostý textový soubor s pravidly. Soubor se čte shora dolů a první odpovídající pravidlo rozhoduje.\nZměny v definici filtru se projeví při restartu tunnelu. Některá sestavení mohou za běhu znovu načítat seznamy uložené v souborech, ale počítejte s restartem, abyste měli jistotu, že se změny uplatní.\nFormát souboru Jedno pravidlo na řádek. Prázdné řádky se ignorují. # začíná komentář, který pokračuje až do konce řádku. Pravidla se vyhodnocují v daném pořadí; použije se první shoda. Prahové hodnoty Práh určuje, kolik pokusů o připojení od jedné Destinace je povoleno v klouzavém časovém okně.\nČíselné: N/S znamená povolit N připojení za S sekund. Příklad: 15/5 umožňuje až 15 připojení každých 5 sekund. Pokus N+1 v rámci tohoto okna je zamítnut. Klíčová slova: allow znamená bez omezení. deny znamená vždy zamítnout. Syntaxe pravidel Pravidla mají tento tvar:\n\u0026lt;threshold\u0026gt; \u0026lt;scope\u0026gt; \u0026lt;target\u0026gt; Kde:\n\u0026lt;threshold\u0026gt; je N/S, allow nebo deny \u0026lt;scope\u0026gt; je jedno z default, explicit, file nebo record (viz níže) \u0026lt;target\u0026gt; závisí na rozsahu Výchozí pravidlo Použije se, když žádné jiné pravidlo neodpovídá. Je povoleno pouze jedno výchozí pravidlo. Pokud není zadáno, jsou neznámé destinace povoleny bez omezení.\n15/5 default allow default deny default Explicitní pravidlo Cílí na konkrétní Destination (cílovou adresu v I2P) podle Base32 adresy (například example1.b32.i2p) nebo plného klíče.\n15/5 explicit example1.b32.i2p deny explicit example2.b32.i2p allow explicit example3.b32.i2p Pravidlo založené na souboru Cílí na všechny Destinations (cílová identita v I2P) uvedené v externím souboru. Každý řádek obsahuje jednu Destination; komentáře # a prázdné řádky jsou povoleny.\n15/5 file /var/i2p/throttled.txt deny file /var/i2p/blocked.txt allow file /var/i2p/trusted.txt Provozní poznámka: Některé implementace pravidelně znovu načítají seznamy souborů. Pokud upravíte seznam, zatímco tunnel běží, počítejte s krátkým zpožděním, než jsou změny zaznamenány. Pro okamžité uplatnění změn restartujte.\nNahrávač (plynulé ovládání) recorder sleduje pokusy o připojení a zapisuje Destinations (identifikátory cíle v I2P), které překročí prahovou hodnotu, do souboru. Poté můžete na tento soubor odkázat v pravidle file, abyste na budoucí pokusy uplatnili omezení nebo blokování.\n# Start permissive allow default # Record Destinations exceeding 30 connections in 5 seconds 30/5 record /var/i2p/aggressive.txt # Apply throttling to recorded Destinations 15/5 file /var/i2p/aggressive.txt Než se na ni budete spoléhat, ověřte si podporu funkce záznamu ve svém sestavení. Pro zaručené chování použijte seznamy file.\nPořadí vyhodnocování Nejprve uveďte specifická pravidla, poté obecná. Běžný vzor:\nExplicitní povolení pro důvěryhodné uzly Explicitní zákazy pro známé zneuživatele Seznamy povolení/zákazů v souborech Záznamníky pro postupné omezování rychlosti Výchozí pravidlo jako záchytné Kompletní příklad # Moderate limits by default 30/10 default # Always allow trusted peers allow explicit friend1.b32.i2p allow explicit friend2.b32.i2p # Block known bad actors deny file /var/i2p/blocklist.txt # Throttle aggressive sources 15/5 file /var/i2p/throttle.txt # Automatically populate the throttle list 60/5 record /var/i2p/throttle.txt Poznámky k implementaci Přístupový filtr pracuje na vrstvě tunnel, před aplikačním zpracováním, takže škodlivý provoz lze odmítnout včas. Umístěte soubor filtru do konfiguračního adresáře I2PTunnel a restartujte tunnel, aby se změny projevily. Sdílejte souborové seznamy napříč více tunnel, pokud chcete konzistentní zásady napříč službami. ","description":"Syntaxe souborů filtrů řízení přístupu pro tunnel","id":"d8b5745531fca07ea47765403a9a4d0c","section":"docs","title":"Formát přístupového filtru","url":"/cs/docs/specs/filter-format/"},{"categories":null,"content":"Přehled POZNÁMKA: ZASTARALÉ - Nyní podporujeme tři formáty, v pořadí podle preferencí:\nMaxmind geoip2 (GeoLite2-Country.mmdb) je součástí všech instalací s výjimkou balíčků pro Debian a instalací pro Android Maxmind geoip1 (GeoIP.dat) v balíčku Debianu geoip-database Formát Tor pro IPv4 (geoip.txt) a vlastní formát pro IPv6 (geoipv6.dat.gz), popsané níže, jsou stále podporovány, ale nepoužívají se. Tato stránka určuje formát různých souborů GeoIP, které router používá k vyhledání země podle IP adresy.\nFormát názvu země (countries.txt) Tento formát lze snadno vytvořit z datových souborů dostupných z mnoha veřejných zdrojů. Například:\n$ wget http://geolite.maxmind.com/download/geoip/database/GeoIPCountryCSV.zip $ unzip GeoIPCountryCSV.zip $ cut -d, -f5,6 \u0026lt; GeoIPCountryWhois.csv | sed \u0026#39;s/\u0026#34;//g\u0026#39; | sort | uniq \u0026gt; countries.txt Specifikace formátu:\nKódování je UTF-8 \u0026lsquo;#\u0026rsquo; v prvním sloupci označuje komentářový řádek Řádky záznamů mají formát CountryCode,CountryName CountryCode je dvoupísmenný kód ISO, psaný velkými písmeny CountryName je v angličtině Formát IPv4 (geoip.txt) Tento formát je převzat z projektu Tor a lze jej snadno vygenerovat z datových souborů dostupných z mnoha veřejných zdrojů. Například:\n$ wget http://geolite.maxmind.com/download/geoip/database/GeoIPCountryCSV.zip $ unzip GeoIPCountryCSV.zip $ cut -d, -f3-5 \u0026lt; GeoIPCountryWhois.csv | sed \u0026#39;s/\u0026#34;//g\u0026#39; \u0026gt; geoip.txt $ cut -d, -f5,6 \u0026lt; GeoIPCountryWhois.csv | sed \u0026#39;s/\u0026#34;//g\u0026#39; | sort | uniq \u0026gt; countries.txt Specifikace formátu:\nKódování je ASCII \u0026lsquo;#\u0026rsquo; v prvním sloupci označuje komentářový řádek Řádky záznamů mají tvar FromIP,ToIP,CountryCode FromIP a ToIP jsou neznaménkové celočíselné reprezentace 4bajtové IP adresy CountryCode je dvoupísmenný kód ISO, psaný velkými písmeny Řádky záznamů musí být seřazeny podle číselného FromIP Formát IPv6 (geoipv6.dat.gz) Toto je komprimovaný binární formát navržený pro I2P. Soubor je komprimován pomocí gzipu. Formát po rozbalení:\nBytes 0-9: Magic number \u0026#34;I2PGeoIPv6\u0026#34; Bytes 10-11: Version (0x0001) Bytes 12-15 Options (0x00000000) (future use) Bytes 16-23: Creation date (ms since 1970-01-01) Bytes 24-xx: Optional comment (UTF-8) terminated by zero byte Bytes xx-255: null padding Bytes 256-: 18 byte records: 8 byte from (/64) 8 byte to (/64) 2 byte ISO country code LOWER case (ASCII) POZNÁMKY:\nData musí být seřazena (typ long se znaménkem, ve dvojkovém doplňku), bez překryvů. Pořadí je tedy 80000000 \u0026hellip; FFFFFFFF 00000000 \u0026hellip; 7FFFFFFF. Třída GeoIPv6.java obsahuje program pro vygenerování tohoto formátu z veřejných zdrojů, jako jsou data Maxmind GeoLite. Vyhledávání GeoIP pro IPv6 je podporováno od verze 0.9.8. ","description":"Specifikace zastaralého formátu souboru GeoIP pro vyhledávání země podle IP adres","id":"b5f34a4f13210a8caf4c4d0b5e62a828","section":"docs","title":"Formáty souborů GeoIP","url":"/cs/docs/legacy/form%C3%A1ty-soubor%C5%AF-geoip/"},{"categories":null,"content":" 1. Přehled Garlic routing (česneková směrování) zůstává jednou ze základních inovací I2P, kombinující vrstvené šifrování, sdružování zpráv a jednosměrné tunely. I když je koncepčně podobný cibulové směrování (onion routing), rozšiřuje tento model tak, že sdružuje více šifrovaných zpráv („cloves\u0026quot; – stroužky) do jediné obálky („garlic\u0026quot; – česnek), čímž zlepšuje efektivitu a anonymitu.\nTermín garlic routing (česneková směrování) byl vytvořen Michaelem J. Freedmanem v diplomové práci Rogera Dingledina Free Haven (červen 2000, §8.1.1). Vývojáři I2P přijali tento termín na začátku 2000. let, aby vyjádřili jeho vylepšení sdružování zpráv a jednosměrný transportní model, který ho odlišuje od architektury s přepínáním okruhů v síti Tor.\nShrnutí: Garlic routing = vrstvené šifrování + sdružování zpráv + anonymní doručování prostřednictvím jednosměrných tunelů.\n2. Terminologie „Garlic\u0026quot; Historicky byl termín garlic používán ve třech různých kontextech v rámci I2P:\nVrstvené šifrování – ochrana ve stylu onion na úrovni tunelu Sdružování více zpráv – více \u0026ldquo;cloves\u0026rdquo; uvnitř \u0026ldquo;garlic message\u0026rdquo; End‑to‑end šifrování – dříve ElGamal/AES+SessionTags, nyní ECIES‑X25519‑AEAD‑Ratchet Zatímco architektura zůstává nedotčena, šifrovací schéma bylo zcela modernizováno.\n3. Vrstvené šifrování Garlic routing sdílí svůj základní princip s onion routingem: každý router dešifruje pouze jednu vrstvu šifrování a dozví se pouze další hop, nikoli celou cestu.\nNicméně I2P implementuje jednosměrné tunely, nikoli obousměrné okruhy:\nOdchozí tunel: odesílá zprávy pryč od tvůrce Příchozí tunel: přenáší zprávy zpět k tvůrci Celá cesta tam i zpět (Alice ↔ Bob) využívá čtyři tunnely: odchozí Alice → příchozí Bob, poté odchozí Bob → příchozí Alice. Tento design snižuje odhalení korelačních dat na polovinu ve srovnání s obousměrnými okruhy.\nPro podrobnosti implementace tunelů viz specifikace tunelů a specifikace vytváření tunelů (ECIES) .\n4. Sdružování více zpráv („Cloves\u0026quot;) Freedmanova původní koncepce garlic routing předpokládala spojení více zašifrovaných \u0026ldquo;bulbů\u0026rdquo; do jedné zprávy. I2P to implementuje jako cloves (hřebíčky) uvnitř garlic message (česneková zpráva) — každý clove má své vlastní zašifrované instrukce pro doručení a cíl (router, destination nebo tunnel).\nGarlic bundling umožňuje I2P:\nKombinovat potvrzení a metadata s datovými zprávami Snížit pozorovatelné vzory provozu Podporovat komplexní struktury zpráv bez dodatečných spojení Obrázek 1: Garlic Message obsahující několik cloves, každý s vlastními pokyny pro doručení.\nTypické hřebíčky zahrnují:\nZpráva o stavu doručení — potvrzení úspěšného nebo neúspěšného doručení.\nTyto zprávy jsou zabaleny do vlastní garlic vrstvy pro zachování důvěrnosti. Zpráva Database Store — automaticky přibalené LeaseSets, aby protějšky mohly odpovědět bez opětovného dotazování netDb. Hřebíčky se sdružují, když:\nMusí být publikován nový LeaseSet Jsou doručeny nové session tagy V poslední době nedošlo k žádnému bundlování (~1 minuta ve výchozím nastavení) Garlic zprávy dosahují efektivního end-to-end doručení více šifrovaných komponent v jediném paketu.\n5. Vývoj šifrování 5.1 Historical Context Raná dokumentace (≤ v0.9.12) popisovala šifrování ElGamal/AES+SessionTags: - ElGamal 2048‑bit obalující AES session keys - AES‑256/CBC pro šifrování datové části - 32‑bajtové session tags použité jednou na zprávu\nTento kryptosystém je zastaralý.\n5.2 ECIES‑X25519‑AEAD‑Ratchet (Current Standard) Mezi lety 2019 a 2023 I2P kompletně přešel na ECIES‑X25519‑AEAD‑Ratchet. Moderní stack standardizuje následující komponenty:\nLayer ECIES Primitive or Concept Transport Layer (NTCP2, SSU2) Noise_NX → X25519, ChaCha20/Poly1305, BLAKE2s I2NP Delivery ECIES‑X25519‑AEAD (ChaCha20/Poly1305) Session Management Ratchet with rekey records, per-clove key material Offline Authentication EdDSA (Ed25519) with LeaseSet2/MetaLeaseSet chains Výhody migrace na ECIES: Forward secrecy prostřednictvím per-message ratcheting keys Zmenšená velikost datové části ve srovnání s ElGamal Odolnost proti pokrokům v kryptoanalýze Kompatibilita s budoucími post-quantum hybridy (viz Proposal 169) Další podrobnosti: viz specifikace ECIES a specifikace EncryptedLeaseSet .\n6. LeaseSets and Garlic Bundling Garlic obálky často zahrnují LeaseSets pro publikování nebo aktualizaci dosažitelnosti cílového místa.\nVersion Type Key Capabilities Distribution Notes 1 LeaseSet (legacy) Single encryption/signature pair Accepted for backward compatibility 3 LeaseSet2 Multiple crypto suites, offline signing keys Default for modern routers 5 EncryptedLeaseSet Access-controlled, destination hidden from floodfill Requires shared decryption key 7 MetaLeaseSet Aggregates multiple destinations or multi-homed services Extends LeaseSet2 fields recursively Všechny LeaseSety jsou distribuovány prostřednictvím *floodfill DHT* spravované specializovanými routery. Publikace jsou ověřovány, opatřovány časovými razítky a omezovány frekvencí, aby se snížila korelace metadat. Viz dokumentace Network Database pro podrobnosti.\n7. Modern “Garlic” Applications within I2P Garlic encryption a seskupování zpráv jsou používány v celém protokolovém stacku I2P:\nVytváření a využívání tunelů — vrstvené šifrování na každém skoku Doručování zpráv mezi koncovými body — seskupené garlic zprávy s klonem potvrzení a LeaseSet cloves Publikování v síťové databázi — LeaseSety zabalené v garlic obálkách pro ochranu soukromí Transporty SSU2 a NTCP2 — podkladové šifrování pomocí frameworku Noise a primitiv X25519/ChaCha20 Garlic routing je tedy jak metoda vrstvení šifrování, tak model síťového zasílání zpráv.\n6. LeaseSets a sdružování Garlic Centrum dokumentace I2P je dostupné zde , průběžně udržované. Relevantní živé specifikace zahrnují:\nSpecifikace ECIES — ECIES‑X25519‑AEAD‑Ratchet Vytváření tunelů (ECIES) — moderní protokol pro vytváření tunelů Specifikace I2NP — formáty zpráv I2NP Specifikace SSU2 — transportní protokol SSU2 UDP Společné struktury — chování netDb a floodfill Akademické ověření: Hoang et al. (IMC 2018, USENIX FOCI 2019) a Muntaka et al. (2025) potvrzují architektonickou stabilitu a provozní odolnost designu I2P.\n7. Moderní aplikace \u0026ldquo;Garlic\u0026rdquo; v rámci I2P Probíhající návrhy:\nNávrh 169: Hybridní post-kvantová (ML-KEM 512/768/1024 + X25519) Návrh 168: Optimalizace šířky pásma pro transport Aktualizace datagramů a streamingu: Vylepšená správa přetížení Budoucí adaptace mohou zahrnovat dodatečné strategie zpoždění zpráv nebo redundanci více tunelů na úrovni garlic zpráv, navazující na nevyužité možnosti doručení původně popsané Freedmanem.\n8. Aktuální dokumentace a odkazy Freedman, M. J. \u0026amp; Dingledine, R. (2000). Free Haven Master\u0026rsquo;s Thesis, § 8.1.1. Free Haven Papers Onion Router Publications Garlic Routing (Wikipedia) Tor Project Free Haven Anonbib Goldschlag, D. M., Reed, M. G., Syverson, P. F. (1996). Hiding Routing Information. NRL Publication. ","description":"Porozumění terminologii garlic routing, architektuře a moderní implementaci v I2P","id":"ba07d93d883918641f4a69832e497bb8","section":"docs","title":"Garlic Routing","url":"/cs/docs/overview/garlic-routing/"},{"categories":null,"content":"Když síťové podmínky znesnadňují spolehlivé použití git clone, můžete distribuovat repozitáře jako git bundles přes BitTorrent nebo jakýkoliv jiný způsob přenosu souborů. Bundle je jediný soubor obsahující celou historii repozitáře. Po stažení z něj fetchujete lokálně a poté se přepnete zpět na upstream remote.\n1. Než začnete Generování balíčku vyžaduje úplný Git clone. Shallow clony vytvořené pomocí --depth 1 tiše vytvoří nefunkční balíčky, které se zdají fungovat, ale selžou, když je zkusí použít ostatní. Vždy stahujte z důvěryhodného zdroje (GitHub na github.com/i2p/i2p.i2p , instance I2P Gitea na i2pgit.org , nebo git.idk.i2p přes I2P) a v případě potřeby spusťte git fetch --unshallow pro převod jakéhokoli shallow clone na úplný clone před vytvořením balíčků.\nPokud pouze používáte existující balíček, stačí jej stáhnout. Není potřeba žádná zvláštní příprava.\n2. Stahování balíčku Obtaining the Bundle File Stáhněte soubor balíčku přes BitTorrent pomocí I2PSnark (vestavěný torrent klient v I2P) nebo jiných I2P-kompatibilních klientů jako BiglyBT s I2P pluginem.\nDůležité: I2PSnark funguje pouze s torrenty specificky vytvořenými pro síť I2P. Standardní clearnetové torrenty nejsou kompatibilní, protože I2P používá Destinations (adresy o délce 387+ bytů) místo IP adres a portů.\nUmístění souboru balíčku závisí na typu vaší instalace I2P:\nUživatelské/manuální instalace (instalováno pomocí Java instalátoru): ~/.i2p/i2psnark/ Systémové/démonové instalace (instalováno přes apt-get nebo správce balíčků): /var/lib/i2p/i2p-config/i2psnark/ Uživatelé BiglyBT najdou stažené soubory ve svém nakonfigurovaném adresáři pro stahování.\nCloning from the Bundle Standardní metoda (funguje ve většině případů):\ngit clone ~/.i2p/i2psnark/i2p.i2p.bundle Pokud narazíte na chyby fatal: multiple updates for ref (známý problém v Gitu 2.21.0 a novějších verzích, kdy globální konfigurace Gitu obsahuje konfliktní fetch refspecs), použijte ruční způsob inicializace:\nmkdir i2p.i2p \u0026amp;\u0026amp; cd i2p.i2p git init git fetch ~/.i2p/i2psnark/i2p.i2p.bundle Alternativně můžete použít příznak --update-head-ok:\ngit fetch --update-head-ok ~/.i2p/i2psnark/i2p.i2p.bundle \u0026#39;*:*\u0026#39; Získání souboru Bundle Po naklonování z balíčku nasměrujte svůj klon na živý remote, aby budoucí stahování probíhala přes I2P nebo clearnet:\ngit remote set-url origin git@127.0.0.1:I2P_Developers/i2p.i2p Nebo pro přístup k čistému internetu:\ngit remote set-url origin https://github.com/i2p/i2p.i2p Pro přístup k SSH přes I2P potřebujete v konzoli vašeho I2P routeru nakonfigurovaný SSH klientský tunel (obvykle port 7670) směřující na g6u4vqiuy6bdc3dbu6a7gmi3ip45sqwgtbgrr6uupqaaqfyztrka.b32.i2p. Pokud používáte nestandardní port:\nGIT_SSH_COMMAND=\u0026#34;ssh -p 7670\u0026#34; git clone git@127.0.0.1:I2P_Developers/i2p.i2p 3. Creating a Bundle Klonování z balíčku Ujistěte se, že je váš repozitář plně aktuální s úplným klonem (ne mělkým):\ngit fetch --all Pokud máte mělký klon, nejprve jej převeďte:\ngit fetch --unshallow Přepnutí na živý vzdálený systém Použití cíle sestavení Ant (doporučeno pro zdrojový strom I2P):\nant git-bundle Toto vytvoří jak i2p.i2p.bundle (soubor bundle), tak i2p.i2p.bundle.torrent (metadata BitTorrent).\nPřímé použití git bundle:\ngit bundle create i2p.i2p.bundle --all Pro selektivnější balíčky:\ngit bundle create i2p.i2p.bundle --branches --tags Verifying Your Bundle Vždy před distribucí ověřte bundle:\ngit bundle verify i2p.i2p.bundle Toto potvrzuje, že bundle je platný a zobrazuje všechny potřebné předchozí commity.\nPředpoklady Zkopírujte bundle a jeho torrentová metadata do vašeho adresáře I2PSnark:\nPro uživatelské instalace:\ncp i2p.i2p.bundle* ~/.i2p/i2psnark/ Pro systémové instalace:\ncp i2p.i2p.bundle* /var/lib/i2p/i2p-config/i2psnark/ I2PSnark automaticky detekuje a načítá .torrent soubory během několika sekund. Pro zahájení seedování přejděte na webové rozhraní na adrese http://127.0.0.1:7657/i2psnark .\n4. Creating Incremental Bundles Pro pravidelné aktualizace vytvořte inkrementální balíčky obsahující pouze nové commity od posledního balíčku:\ngit tag lastBundleTag git bundle create update.bundle lastBundleTag..master Uživatelé mohou stáhnout z inkrementálního balíčku, pokud již mají základní repozitář:\ngit fetch /path/to/update.bundle Vždy ověřte, že inkrementální balíčky zobrazují očekávané nezbytné commity:\ngit bundle verify update.bundle 5. Updating After the Initial Clone Jakmile máte funkční repozitář z balíčku, pracujte s ním jako s jakýmkoli jiným Git klonem:\ngit remote add upstream git@127.0.0.1:I2P_Developers/i2p.i2p git fetch upstream git merge upstream/master Nebo pro jednodušší pracovní postupy:\ngit fetch origin git pull origin master 3. Vytvoření balíčku Odolná distribuce: Velké repozitáře lze sdílet přes BitTorrent, který automaticky řeší opakované pokusy, ověřování částí a pokračování v přenosu. Peer-to-peer bootstrap: Noví přispěvatelé mohou bootstrapovat svůj klon z blízkých peerů v síti I2P a poté získávat inkrementální změny přímo z Git hostů. Snížené zatížení serveru: Zrcadla mohou publikovat periodické balíčky pro uvolnění tlaku na živé Git hosty, což je zvláště užitečné pro velké repozitáře nebo pomalé síťové podmínky. Offline přenos: Balíčky fungují na jakémkoliv souborovém přenosu (USB disky, přímé přenosy, sneakernet), nejen na BitTorrentu. Bundly nenahrazují živá vzdálená úložiště. Poskytují pouze odolnější metodu bootstrappingu pro počáteční klonování nebo větší aktualizace.\n7. Troubleshooting Generování balíčku Problém: Vytvoření bundle je úspěšné, ale ostatní nemohou klonovat z bundle.\nPříčina: Váš zdrojový klon je mělký (vytvořen s parametrem --depth).\nŘešení: Před vytvořením balíčků převeďte na úplný klon:\ngit fetch --unshallow Ověření vašeho balíčku Problém: fatal: multiple updates for ref při klonování z bundle.\nPříčina: Git 2.21.0+ je v konfliktu s globálními fetch refspecs v ~/.gitconfig.\nŘešení: 1. Použijte ruční inicializaci: mkdir repo \u0026amp;\u0026amp; cd repo \u0026amp;\u0026amp; git init \u0026amp;\u0026amp; git fetch /path/to/bundle 2. Použijte příznak --update-head-ok: git fetch --update-head-ok /path/to/bundle '*:*' 3. Odstraňte konfliktní konfiguraci: git config --global --unset remote.origin.fetch\nDistribuce přes I2PSnark Problém: git bundle verify hlásí chybějící prerekvizity.\nPříčina: Inkrementální balíček nebo neúplný klon zdroje.\nŘešení: Buď stáhněte nezbytné předchozí commity, nebo nejprve použijte základní bundle a poté aplikujte inkrementální aktualizace.\n","description":"Získávání a distribuce velkých repozitářů pomocí git bundle a BitTorrent","id":"555586cb7b43c73ad912bbb01f20326b","section":"docs","title":"Git Bundles pro I2P","url":"/cs/docs/applications/git-bundle/"},{"categories":null,"content":"Klonování a nahrávání repozitářů v rámci I2P používá stejné příkazy Gitu, které již znáte—váš klient se jednoduše připojuje přes I2P tunely místo TCP/IP. Tento návod vás provede vytvořením účtu, konfigurací tunelů a řešením pomalých připojení.\nRychlý start: Přístup pouze pro čtení funguje přes HTTP proxy: http_proxy=http://127.0.0.1:4444 git clone http://example.i2p/project.git. Pro SSH přístup pro čtení/zápis postupujte podle níže uvedených kroků.\n1. Vytvořit účet Vyberte si I2P Git službu a zaregistrujte se:\nUvnitř I2P: http://git.idk.i2p Clearnet zrcadlo: https://i2pgit.org Registrace může vyžadovat manuální schválení; zkontrolujte úvodní stránku pro instrukce. Po schválení vytvořte fork nebo vytvořte repozitář, abyste měli něco k testování.\n2. Konfigurace I2PTunnel klienta (SSH) Otevřete konzoli routeru → I2PTunnel a přidejte nový Client tunel. Zadejte cílovou adresu služby (Base32 nebo Base64). Pro git.idk.i2p najdete HTTP i SSH cílové adresy na domovské stránce projektu. Zvolte lokální port (například localhost:7442). Povolte automatické spuštění, pokud plánujete tunel používat často. UI potvrdí nový tunel a zobrazí jeho stav. Když běží, SSH klienti se mohou připojit k 127.0.0.1 na zvoleném portu.\n3. Klonování přes SSH Použijte port tunelu s GIT_SSH_COMMAND nebo konfigurační stanzou SSH:\nGIT_SSH_COMMAND=\u0026#34;ssh -p 7442\u0026#34; \\ git clone git@127.0.0.1:your-project/example.git Pokud první pokus selže (tunely mohou být pomalé), zkuste mělké klonování:\nGIT_SSH_COMMAND=\u0026#34;ssh -p 7442\u0026#34; \\ git clone --depth 1 git@127.0.0.1:your-project/example.git cd example git fetch --unshallow Nakonfigurujte Git pro stažení všech větví:\ngit config remote.origin.fetch \u0026#34;+refs/heads/*:refs/remotes/origin/*\u0026#34; git fetch origin Tipy pro výkon Přidejte jeden nebo dva záložní tunnely v editoru tunnelů pro zlepšení odolnosti. Pro testování nebo repozitáře s nízkým rizikem můžete snížit délku tunnelu na 1 hop, ale mějte na paměti kompromis v anonymitě. Udržujte GIT_SSH_COMMAND ve svém prostředí nebo přidejte záznam do ~/.ssh/config: Host git.i2p HostName 127.0.0.1 Port 7442 User git Poté naklonujte pomocí git clone git@git.i2p:namespace/project.git.\n4. Návrhy pracovních postupů Použijte pracovní postup fork-and-branch běžný na GitLabu/GitHubu:\nNastavte upstream remote: git remote add upstream git@git.i2p:I2P_Developers/i2p.i2p Udržujte svůj master synchronizovaný: git pull upstream master Vytvářejte feature větve pro změny: git checkout -b feature/new-thing Pushujte větve do svého forku: git push origin feature/new-thing Odešlete merge request a poté proveďte fast-forward master větve vašeho forku z upstream. 5. Připomínky o soukromí Git ukládá časové značky commitů v místním časovém pásmu. Pro vynucení UTC časových značek: git config --global alias.utccommit \u0026#39;!git commit --date=\u0026#34;$(date --utc +%Y-%m-%dT%H:%M:%S%z)\u0026#34;\u0026#39; Použijte git utccommit místo git commit, když záleží na soukromí.\nVyhněte se vkládání clearnet URL nebo IP adres do commit zpráv nebo metadat repozitáře, pokud je anonymita důležitá. 6. Řešení problémů Symptom Fix connection closed during clone Retry with --depth 1, add backup tunnels, or increase tunnel quantities. ssh: connect to host 127.0.0.1 port …: Connection refused Ensure the I2PTunnel client is running and SAM is enabled. Slow performance Lower tunnel length, increase bandwidth limits, or schedule large fetches during off-peak hours. Pro pokročilé scénáře (zrcadlení externích repozitářů, seedování bundlů) viz doprovodné návody: [Pracovní postupy Git bundle](/docs/applications/git-bundle/) a [Hosting GitLabu přes I2P](/docs/guides/gitlab/). ","description":"Připojení Git klientů k službám hostovaným na I2P, jako je i2pgit.org","id":"17704a86e8676ba273355af4fa703c15","section":"docs","title":"Git přes I2P","url":"/cs/docs/applications/git/"},{"categories":null,"content":"Úvod I2P poskytuje soukromé zasílání zpráv ve stylu e-mailu prostřednictvím služby Postman\u0026rsquo;s Mail.i2p v kombinaci s SusiMail, vestavěným webmailovým klientem. Tento systém umožňuje uživatelům odesílat a přijímat e-maily jak v rámci sítě I2P, tak do/z běžného internetu (clearnet) prostřednictvím gateway mostu.\nRychlý start Postman / Mail.i2p + SusiMail What it is Mail.i2p je poskytovatel e-mailových služeb uvnitř I2P, provozovaný uživatelem \u0026ldquo;Postman\u0026rdquo; SusiMail je webmailový klient integrovaný v konzoli I2P routeru. Je navržen tak, aby zabránil úniku metadat (např. hostname) k externím SMTP serverům. Prostřednictvím tohoto nastavení mohou uživatelé I2P odesílat/přijímat zprávy jak uvnitř I2P, tak do/z clearnetu (např. Gmail) přes most Postman. How Addressing Works I2P email používá systém dvojí adresy:\nUvnitř sítě I2P: username@mail.i2p (např. idk@mail.i2p) Z clearnetu: username@i2pmail.org (např. idk@i2pmail.org) Brána i2pmail.org umožňuje běžným uživatelům internetu posílat e-maily na I2P adresy a uživatelům I2P posílat e-maily na clearnet adresy. Internetové e-maily jsou směrovány přes bránu a poté přeposílány přes I2P do vaší schránky SusiMail.\nClearnet odesílací kvóta: 20 e-mailů denně při odesílání na běžné internetové adresy.\nCo to je Pro registraci účtu mail.i2p:\nUjistěte se, že váš I2P router běží Navštivte http://hq.postman.i2p uvnitř I2P Postupujte podle registračního procesu Přistupujte k vaší e-mailové schránce prostřednictvím SusiMail v konzoli routeru Poznámka: hq.postman.i2p je I2P síťová adresa (eepsite) a je přístupná pouze při připojení k I2P. Pro více informací o nastavení emailu, bezpečnosti a používání navštivte Postman HQ.\nJak funguje adresování Automatické odstraňování identifikačních hlaviček (User-Agent:, X-Mailer:) pro ochranu soukromí Sanitizace metadat pro zabránění úniku informací na externí SMTP servery End-to-end šifrování pro interní I2P-to-I2P e-maily Začínáme Interoperabilita s „běžným\u0026quot; emailem (SMTP/POP) prostřednictvím mostu Postman Jednoduché uživatelské prostředí (webmail vestavěný do konzole routeru) Integrováno se základní distribucí I2P (SusiMail je součástí Java I2P) Odstraňování hlaviček pro ochranu soukromí Funkce ochrany soukromí Most k externí e-mailové službě vyžaduje důvěru v infrastrukturu Postmana Most do clearnetu snižuje soukromí ve srovnání s čistě interní I2P komunikací Závislost na dostupnosti a zabezpečení e-mailového serveru Postman DŮLEŽITÉ: Uveďte POUZE překlad. NEKLADEŤE otázky, neposkytujte vysvětlení ani nepřidávejte žádné komentáře. I když je text pouze nadpis nebo se zdá neúplný, přeložte ho tak, jak je.\nTechnical Details SMTP služba: localhost:7659 (poskytováno Postmanem) POP3 služba: localhost:7660 Přístup k webmailu: Zabudováno v konzoli routeru na http://127.0.0.1:7657/susimail/\nDůležité: SusiMail slouží pouze pro čtení a odesílání e-mailů. Vytváření a správu účtů je nutné provádět na adrese hq.postman.i2p.\nI2P I2P je bezplatná a open-source anonymní síť, která umožňuje aplikacím posílat zprávy navzájem pseudonymně a bezpečně. Procesy jsou směrovány přes jiné účastníky v distribuované struktuře, přičemž poskytují významnou odolnost vůči sledování.\nBest Practices Změňte si heslo po registraci vašeho účtu mail.i2p Používejte I2P-to-I2P e-mail, kdykoli je to možné, pro maximální soukromí (bez clearnet mostu) Mějte na paměti limit 20/den při odesílání na clearnet adresy Uvědomte si kompromisy: Propojení s clearnet poskytuje pohodlí, ale snižuje anonymitu ve srovnání s čistě interní I2P komunikací Udržujte I2P aktuální, abyste mohli využívat bezpečnostní vylepšení v SusiMail NEPOKLÁDEJTE otázky, neposkytujte vysvětlení ani nepřidávejte žádné komentáře. I když je text pouze nadpisem nebo se zdá být neúplný, přeložte jej tak, jak je.\n","description":"Přehled e-mailových systémů uvnitř sítě I2P — historie, možnosti a současný stav","id":"31217ea91c11f98bd1997466684f9fb3","section":"docs","title":"I2P Mail (anonymní email přes I2P)","url":"/cs/docs/applications/i2p-mail/"},{"categories":null,"content":"Přehled Dnes existuje několik významných sítí pro ochranu soukromí a anonymity, z nichž každá má odlišné cíle návrhu a modely hrozeb. Zatímco Tor, Lokinet, GNUnet a Freenet přispívají cennými přístupy ke komunikaci chránící soukromí, I2P vyniká jako jediná produkčně připravená síť s přepínáním paketů plně optimalizovaná pro skryté služby uvnitř sítě a peer-to-peer aplikace.\nNásledující tabulka shrnuje klíčové architektonické a provozní rozdíly mezi těmito sítěmi k roku 2025.\nSrovnání síťí pro ochranu soukromí (2025) Feature / Network I2P Tor Lokinet Freenet (Hyphanet) GNUnet Primary Focus Hidden services, P2P applications Clearnet anonymity via exits Hybrid VPN + hidden services Distributed storage \u0026 publishing Research framework, F2F privacy Architecture Fully distributed, packet-switched Centralized directory, circuit-switched Packet-switched LLARP with blockchain coordination DHT-based content routing DHT \u0026 F2F topology (R5N) Routing Model Unidirectional tunnels (inbound/outbound) Bidirectional circuits (3 hops) Packet-switched over staked nodes Key-based routing Random walk + DHT hybrid Directory / Peer Discovery Distributed Kademlia netDB with floodfills 9 hardcoded directory authorities Blockchain + Oxen staking Heuristic routing Distributed hash routing (R5N) Encryption ECIES-X25519-AEAD-Ratchet (ChaCha20/Poly1305) AES + RSA/ECDH Curve25519/ChaCha20 Custom symmetric encryption Ed25519/Curve25519 Participation Model All routers route traffic (democratic) Small relay subset, majority are clients Only staked nodes User-selectable trust mesh Optional F2F restriction Traffic Handling Packet-switched, multi-path, load-balanced Circuit-switched, fixed path per circuit Packet-switched, incentivized File chunk propagation Message batching and proof-of-work Garlic Routing ✅ Yes (message bundling \u0026 tagging) ❌ No Partial (message batches) ❌ No ❌ No Exit to Clearnet Limited (discouraged) Core design goal Supported (VPN-style exits) Not applicable Not applicable Built-In Apps I2PSnark, I2PTunnel, SusiMail, I2PBote Tor Browser, OnionShare Lokinet GUI, SNApps Freenet UI GNUnet CLI tools Performance Optimized for internal services, 1–3s RTT Optimized for exits, ~200–500ms RTT Low latency, staked node QoS High latency (minutes) Experimental, inconsistent Anonymity Set Size ~55,000 active routers Millions of daily users \u0026lt;1,000 service nodes Thousands (small core) Hundreds (research only) Scalability Horizontal via floodfill rotation Centralized bottleneck (directory) Dependent on token economics Limited by routing heuristics Research-scale only Funding Model Volunteer-driven nonprofit Major institutional grants Crypto-incentivized (OXEN) Volunteer community Academic research License / Codebase Open source (Java/C++/Go) Open source (C) Open source (C++) Open source (Java) Open source (C) --- Proč je I2P lídrem v designu zaměřeném na soukromí 1. Packet Switching \u0026gt; Circuit Switching Model spínaných okruhů v síti Tor váže provoz na pevné tříhopové cesty—efektivní pro prohlížení webu, ale křehký pro dlouhodobě běžící interní služby. Paketově spínané tunely I2P odesílají zprávy přes více současných cest a automaticky směrují obchází přetížení či výpadky pro lepší dostupnost a distribuci zátěže.\n2. Unidirectional Tunnels I2P odděluje příchozí a odchozí provoz. To znamená, že každý účastník vidí vždy pouze polovinu komunikačního toku, což výrazně ztěžuje korelační útoky založené na časování. Tor, Lokinet a další používají obousměrné okruhy, kde požadavky a odpovědi sdílejí stejnou cestu—je to jednodušší, ale lépe sledovatelné.\n3. Fully Distributed netDB Devět adresářových autorit Toru definuje topologii jeho sítě. I2P používá samořídící se Kademlia DHT (distribuovanou hash tabulku) spravovanou rotujícími floodfill routery, čímž eliminuje jakékoli centrální kontrolní body nebo koordinační servery.\n1. Přepínání paketů \u0026gt; Přepínání okruhů I2P rozšiřuje onion routing o garlic routing, který sdružuje více šifrovaných zpráv do jednoho kontejneru. To snižuje únik metadat a režii šířky pásma a zároveň zvyšuje efektivitu pro potvrzovací, datové a řídicí zprávy.\n2. Jednosměrné tunely Každý I2P router směruje provoz pro ostatní. Neexistují žádní vyhrazení operátoři přeposílacích uzlů ani privilegované uzly—šířka pásma a spolehlivost automaticky určují, kolik směrování uzel přispívá. Tento demokratický přístup buduje odolnost a přirozeně škáluje s růstem sítě.\n3. Plně distribuovaná netDB 12-skokový okruh I2P tam a zpět (6 příchozích + 6 odchozích) vytváří silnější nepropojitelnost než 6-skokové obvody skrytých služeb Tor. Protože obě strany jsou interní, spojení se zcela vyhýbají úzkému hrdlu výstupních uzlů, což poskytuje rychlejší interní hosting a nativní integraci aplikací (I2PSnark, I2PTunnel, I2PBote).\nArchitectural Takeaways Design Principle I2P Advantage Decentralization No trusted authorities; netDB managed by floodfill peers Traffic Separation Unidirectional tunnels prevent request/response correlation Adaptability Packet-switching allows per-message load balancing Efficiency Garlic routing reduces metadata and increases throughput Inclusiveness All peers route traffic, strengthening anonymity set Focus Built specifically for hidden services and in-network communication --- When to Use Each Network Use Case Recommended Network Anonymous web browsing (clearnet access) I2P Anonymous hosting, P2P, or DApps I2P Anonymous file publishing and storage Freenet (Hyphanet) VPN-style private routing with staking Lokinet Academic experimentation and research GNUnet --- Summary Architektura I2P je unikátně zaměřena na soukromí—žádné adresářové servery, žádné závislosti na blockchainu, žádná centralizovaná důvěra. Jeho kombinace unidirectional tunnels (jednosměrných tunelů), packet-switched routingu (přepojování paketů), garlic message bundlingu (seskupování zpráv) a distribuovaného peer discovery (objevování uzlů) z něj dělá technicky nejpokročilejší systém pro anonymní hosting a peer-to-peer komunikaci dnes.\nI2P není „alternativa k Toru.\u0026quot; Jedná se o jinou třídu sítě – postavenou pro to, co se děje uvnitř privátní sítě, ne mimo ni.\n","description":"Moderní technické a filozofické srovnání zdůrazňující jedinečné designové výhody I2P","id":"bc3abab13910824c59b1550aa1ce69df","section":"docs","title":"I2P vs jiné sítě pro ochranu soukromí","url":"/cs/docs/overview/comparison/"},{"categories":null,"content":"Úvod I2P je škálovatelná, samospravující se a odolná paketově přepínaná anonymní síťová vrstva, na které může fungovat libovolný počet různých aplikací zaměřených na anonymitu nebo bezpečnost. Každá z těchto aplikací může provádět vlastní kompromisy mezi anonymitou, latencí a propustností, aniž by se musela starat o správnou implementaci mixnet se svobodným směrováním, což jim umožňuje splynout jejich aktivitu s větší množinou anonymních uživatelů již běžících nad I2P.\nJiž dostupné aplikace poskytují plnou škálu typických internetových aktivit — anonymní prohlížení webu, webhosting, chat, sdílení souborů, e-mail, blogování a sdílení obsahu, stejně jako několik dalších aplikací ve vývoji.\nProhlížení webu: pomocí jakéhokoli existujícího prohlížeče, který podporuje proxy Chat: IRC a další protokoly Sdílení souborů: I2PSnark a další aplikace E-mail: Susimail a další aplikace Blog: pomocí jakéhokoli lokálního webového serveru nebo dostupných pluginů Na rozdíl od webových stránek hostovaných v sítích pro distribuci obsahu jako Freenet nebo GNUnet , jsou služby hostované v I2P plně interaktivní — existují tradiční webové vyhledávače, diskuzní fóra, blogy, ke kterým můžete přidávat komentáře, stránky založené na databázích a mosty pro dotazování statických systémů jako Freenet bez nutnosti jejich lokální instalace.\nSe všemi těmito aplikacemi s podporou anonymity funguje I2P jako message-oriented middleware (middleware orientované na zprávy) — aplikace specifikují data k odeslání na kryptografický identifikátor („destination\u0026quot;), a I2P zajistí jejich bezpečné a anonymní doručení. I2P také obsahuje jednoduchou streaming library (knihovnu pro streamování), která umožňuje převést anonymní zprávy I2P s best-effort doručováním na spolehlivé, uspořádané datové toky, nabízející řízení přetížení založené na TCP a vyladěné pro vysoký bandwidth-delay product (součin šířky pásma a zpoždění) sítě.\nAčkoli byly vyvinuty jednoduché SOCKS proxy pro připojení existujících aplikací, jejich hodnota je omezená, protože většina aplikací uniká citlivé informace v anonymním kontextu. Nejbezpečnějším přístupem je auditovat a přizpůsobit aplikaci pro přímé použití I2P API.\nI2P není výzkumný projekt — akademický, komerční ani vládní — ale inženýrské úsilí zaměřené na poskytování použitelné anonymity. Je neustále vyvíjen od začátku roku 2003 distribuovanou skupinou přispěvatelů z celého světa. Veškerá práce na I2P je open source na oficiální webové stránce , primárně uvolněná do veřejné domény, přičemž některé komponenty jsou pod permisivními licencemi ve stylu BSD. K dispozici je několik klientských aplikací pod licencí GPL, jako například I2PTunnel , Susimail a I2PSnark . Financování pochází výhradně z darů uživatelů.\nProvoz Overview I2P jasně rozlišuje mezi routery (uzly účastnící se sítě) a destinacemi (anonymní koncové body pro aplikace). Samotné provozování I2P není tajné; co je skryté, je co uživatel dělá a který router jeho destinace používají. Koncoví uživatelé obvykle provozují několik destinací (např. jednu pro prohlížení webu, další pro hosting, další pro IRC).\nKlíčovým konceptem v I2P je tunnel — jednosměrná šifrovaná cesta skrze sérii routerů. Každý router dešifruje pouze jednu vrstvu a dozví se pouze další hop. Tunnely vyprší každých 10 minut a musí být znovu vybudovány.\nObrázek 1: Existují dva typy tunelů — vstupní (inbound) a výstupní (outbound).\nOdchozí tunely odesílají zprávy pryč od tvůrce. Příchozí tunely přinášejí zprávy zpět k tvůrci. Kombinace těchto prvků umožňuje obousměrnou komunikaci. Například \u0026ldquo;Alice\u0026rdquo; používá odchozí tunnel k odeslání zprávy do příchozího tunnelu \u0026ldquo;Boba\u0026rdquo;. Alice zašifruje svou zprávu s routovacími instrukcemi do Bobovy příchozí brány.\nDalším klíčovým konceptem je síťová databáze neboli netDb, která distribuuje metadata o routerech a cílech:\nRouterInfo: Obsahuje kontaktní informace routeru a klíčový materiál. LeaseSet: Obsahuje informace potřebné ke kontaktování destinace (tunnel brány, časy vypršení, šifrovací klíče). Routery publikují své RouterInfo přímo do netDb; LeaseSety jsou odesílány přes odchozí tunnely pro zajištění anonymity.\nPro vybudování tunelů Alice dotazuje netDb na záznamy RouterInfo pro výběr uzlů a odesílá šifrované zprávy pro vybudování tunelu hop-by-hop, dokud není tunel dokončen.\nObrázek 2: Informace o routeru se používají k vytváření tunnelů.\nPro odeslání Bobovi Alice vyhledá Bobův LeaseSet a použije jeden ze svých odchozích tunelů pro směrování dat přes vstupní bránu Bobova příchozího tunelu.\nObrázek 3: LeaseSets spojují odchozí a příchozí tunely.\nProtože I2P je založeno na zprávách, přidává end-to-end garlic encryption (koncové šifrování cibulového typu) pro ochranu zpráv dokonce i před odchozím koncovým bodem nebo příchozí bránou. Garlic zpráva zabaluje více šifrovaných \u0026ldquo;cloves\u0026rdquo; (jednotlivých zpráv) pro skrytí metadat a zlepšení anonymity.\nAplikace mohou buď použít rozhraní zpráv přímo, nebo se spolehnout na streamovací knihovnu pro spolehlivá připojení.\nTunnels Jak příchozí, tak odchozí tunely používají vrstvové šifrování, ale liší se v konstrukci:\nV příchozích tunelech tvůrce (koncový bod) dešifruje všechny vrstvy. V odchozích tunelech tvůrce (brána) předem dešifruje vrstvy, aby byla zajištěna srozumitelnost na koncovém bodě. I2P profiluje uzly pomocí nepřímých metrik, jako je latence a spolehlivost, bez přímého dotazování. Na základě těchto profilů jsou uzly dynamicky seskupovány do čtyř úrovní:\nRychlý a s vysokou kapacitou Vysoká kapacita Nefungující Selhávající Výběr uzlů pro tunel obvykle upřednostňuje uzly s vysokou kapacitou, náhodně vybrané pro vyvážení anonymity a výkonu, s dodatečnými strategiemi řazení založenými na XOR pro zmírnění predecessor útoků a sklízení netDb.\nPro podrobnější informace viz Specifikace tunnelů .\nPřehled Routery účastnící se floodfill distribuované hash tabulky (DHT) ukládají a odpovídají na vyhledávání LeaseSet. DHT používá variantu Kademlia . Floodfill routery jsou vybírány automaticky, pokud mají dostatečnou kapacitu a stabilitu, nebo mohou být nakonfigurovány ručně.\nRouterInfo: Popisuje schopnosti routeru a jeho transporty. LeaseSet: Popisuje tunely a šifrovací klíče cíle. Všechna data v netDb jsou podepsána vydavatelem a opatřena časovým razítkem, aby se předešlo útokům opakováním nebo zastaralými záznamy. Synchronizace času je udržována pomocí SNTP a detekce časového posunu na transportní vrstvě.\nAdditional concepts Nepublikované a šifrované LeaseSets:\nDestinace může zůstat soukromá tím, že nepublikuje svůj LeaseSet a sdílí ho pouze s důvěryhodnými protějšky. Přístup vyžaduje příslušný dešifrovací klíč.\nBootstrapping (reseeding):\nPro připojení k síti si nový router stáhne podepsané RouterInfo soubory z důvěryhodných HTTPS reseed serverů.\nŠkálovatelnost vyhledávání:\nI2P používá iterativní, nikoli rekurzivní vyhledávání pro zlepšení škálovatelnosti a bezpečnosti DHT.\nTunely Moderní I2P komunikace využívá dva plně šifrované transporty:\nNTCP2 : Šifrovaný protokol založený na TCP SSU2 : Šifrovaný protokol založený na UDP Oba jsou postaveny na moderním Noise Protocol Framework , který poskytuje silné ověření a odolnost vůči identifikaci provozu. Nahradily zastaralé protokoly NTCP a SSU (plně vyřazeny od roku 2023).\nNTCP2 nabízí šifrované, efektivní streamování přes TCP.\nSSU2 poskytuje spolehlivost založenou na UDP, procházení NAT a volitelné proražení firewallu (hole punching). SSU2 je koncepčně podobný WireGuard nebo QUIC, vyvažuje spolehlivost a anonymitu.\nRoutery mohou podporovat jak IPv4, tak IPv6 a publikují své transportní adresy a náklady v netDb. Transportní protokol spojení je vybírán dynamicky pomocí systému nabídek, který optimalizuje podle podmínek a existujících spojení.\nSíťová databáze (netDb) I2P používá vrstvené šifrování pro všechny komponenty: transporty, tunely, garlic zprávy a síťovou databázi.\nAktuální primitiva zahrnují:\nX25519 pro výměnu klíčů EdDSA (Ed25519) pro podpisy ChaCha20-Poly1305 pro autentizované šifrování SHA-256 pro hashování AES256 pro šifrování vrstvy tunelů Starší algoritmy (ElGamal, DSA-SHA1, ECDSA) zůstávají kvůli zpětné kompatibilitě.\nI2P v současnosti zavádí hybridní post-kvantová (PQ) kryptografická schémata kombinující X25519 s ML-KEM za účelem ochrany proti útokům typu \u0026ldquo;harvest-now, decrypt-later\u0026rdquo; (sklizeň nyní, dešifrování později).\nGarlic Messages Garlic zprávy rozšiřují onion routing seskupením více šifrovaných \u0026ldquo;cloves\u0026rdquo; s nezávislými pokyny pro doručení. To umožňuje flexibilitu směrování na úrovni zpráv a jednotné doplňování provozu.\nSession Tags Pro end-to-end šifrování jsou podporovány dva kryptografické systémy:\nElGamal/AES+SessionTags (zastaralé):\nPoužívá předem dodané session tags jako 32-bajtové nonces. Nyní zastaralé kvůli neefektivitě.\nECIES-X25519-AEAD-Ratchet (současný):\nPoužívá ChaCha20-Poly1305 a synchronizované PRNG založené na HKDF pro dynamické generování dočasných session klíčů a 8-bajtových tagů, čímž snižuje nároky na CPU, paměť a šířku pásma při zachování forward secrecy (dopředné utajení).\nFuture of the Protocol Klíčové oblasti výzkumu se zaměřují na udržení bezpečnosti proti protivníkům na státní úrovni a zavedení post-kvantové ochrany. Dva rané designové koncepty — restricted routes a variable latency — byly nahrazeny moderním vývojem.\nRestricted Route Operation Původní koncepty omezeného směrování měly za cíl skrýt IP adresy. Tato potřeba byla do značné míry zmírněna:\nUPnP pro automatické přesměrování portů Robustní průchod NAT v SSU2 Podpora IPv6 Kooperativní introducers a NAT hole-punching Volitelné připojení přes overlay (např. Yggdrasil) Moderní I2P tedy dosahuje stejných cílů praktičtěji bez složitého omezeného směrování.\nSimilar Systems I2P integruje koncepty z message-oriented middleware (middlewaru orientovaného na zprávy), DHT (distribuovaných hash tabulek) a mixnets (směšovacích sítí). Jeho inovace spočívá v kombinaci těchto prvků do použitelné, samoorganizující se platformy pro anonymitu.\nTransportní protokoly Webová stránka Tor a I2P sdílejí cíle, ale liší se architektonicky:\nTor: Přepínání okruhů; spoléhá na důvěryhodné adresářové autority. (~10 tis. přenosových uzlů) I2P: Přepínání paketů; plně distribuovaná síť řízená DHT. (~50 tis. routerů) Jednosměrné tunnely I2P odhalují méně metadat a umožňují flexibilní směrovací cesty, zatímco Tor se zaměřuje na anonymní přístup k internetu (outproxying). I2P místo toho podporuje anonymní hosting v síti.\nKryptografie Webová stránka Freenet se zaměřuje na anonymní, trvalé publikování a získávání souborů. I2P naproti tomu poskytuje komunikační vrstvu v reálném čase pro interaktivní použití (web, chat, torrenty). Společně se oba systémy doplňují — Freenet poskytuje úložiště odolné proti cenzuře; I2P poskytuje anonymitu při přenosu dat.\nOther Networks Lokinet: IP-založená překryvná síť využívající motivované servisní uzly. Nym: Mixnet nové generace zdůrazňující ochranu metadat s krycím provozem při vyšší latenci. Appendix A: Application Layer I2P samo o sobě zajišťuje pouze přenos zpráv. Funkcionalita aplikační vrstvy je implementována externě prostřednictvím API a knihoven.\nStreaming Library Streaming library (knihovna pro proudové přenosy) funguje jako TCP analogie v I2P, se slidingovým okénkovým protokolem a řízením zahlcení optimalizovaným pro anonymní přenos s vysokou latencí.\nTypické vzory HTTP požadavků/odpovědí mohou často být dokončeny v jediném přenosu tam a zpět díky optimalizacím sdružování zpráv.\nNaming Library and Address Book Vyvinuli: mihi, Ragnarok Viz stránka Naming and Address Book .\nSystém pojmenování I2P je lokální a decentralizovaný, čímž se vyhýbá globálním názvům ve stylu DNS. Každý router udržuje lokální mapování lidsky čitelných názvů na destinace. Volitelné adresáře založené na síti důvěry mohou být sdíleny nebo importovány od důvěryhodných uzlů.\nTento přístup se vyhýbá centralizovaným autoritám a obchází zranitelnosti typu Sybil inherentní v globálních nebo hlasovacích systémech pojmenování.\nProvoz v omezeném režimu tras Vyvinul: mihi\nI2PTunnel je hlavní rozhraní klientské vrstvy umožňující anonymní TCP proxying. Podporuje:\nTunely klienta (odchozí k I2P destinacím) HTTP klient (eepproxy) pro \u0026ldquo;.i2p\u0026rdquo; domény Tunely serveru (příchozí z I2P k lokální službě) Tunely HTTP serveru (bezpečný proxy pro webové služby) Outproxying (směrem k běžnému internetu) je volitelné, implementované dobrovolnicky provozovanými \u0026ldquo;serverovými\u0026rdquo; tunnely.\nI2PSnark Vyvinuto: jrandom a další — portováno ze Snark Součástí I2P je I2PSnark, anonymní BitTorrent klient podporující více torrentů současně s DHT a UDP, přístupný přes webové rozhraní.\nTor Vyvinuli: postman, susi23, mastiejaner\nI2Pmail poskytuje anonymní e-mail prostřednictvím I2PTunnel připojení. Susimail je webový klient vytvořený speciálně pro zabránění únikům informací běžným u tradičních e-mailových klientů. Služba mail.i2p nabízí filtrování virů, hashcash kvóty a oddělení outproxy pro dodatečnou ochranu.\n","description":"Technický úvod do architektury a provozu I2P","id":"75218044125880755dabbc53c9ce4b06","section":"docs","title":"I2P: Škálovatelný framework pro anonymní komunikaci","url":"/cs/docs/overview/tech-intro/"},{"categories":null,"content":"Dokumentace API I2PControl I2PControl je JSON-RPC 2.0 API přibalené k I2P routeru (od verze 0.9.39). Umožňuje autentizované monitorování a ovládání routeru prostřednictvím strukturovaných JSON požadavků.\nVýchozí heslo: itoopie — toto je tovární výchozí nastavení a mělo by být okamžitě změněno z bezpečnostních důvodů.\n1. Přehled a přístup Implementation Default Endpoint Protocol Enabled by Default Notes Java I2P (2.10.0+) http://127.0.0.1:7657/jsonrpc/ HTTP ❌ Must be enabled via WebApps (Router Console) Bundled webapp i2pd (C++ implementation) https://127.0.0.1:7650/ HTTPS ✅ Enabled by default Legacy plugin behavior V případě Java I2P musíte přejít do **Router Console → WebApps → I2PControl** a povolit jej (nastavit automatické spuštění). Po aktivaci vyžadují všechny metody nejprve autentizaci a přijetí tokenu relace. 2. Formát JSON-RPC Všechny požadavky následují strukturu JSON-RPC 2.0:\n{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;MethodName\u0026#34;, \u0026#34;params\u0026#34;: { /* named parameters */ } } Úspěšná odpověď obsahuje pole result; při selhání je vrácen objekt error:\n{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;result\u0026#34;: { /* data */ } } nebo\n{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;error\u0026#34;: { \u0026#34;code\u0026#34;: -32001, \u0026#34;message\u0026#34;: \u0026#34;Invalid password\u0026#34; } } 3. Průběh ověřování Požadavek (Autentizace) curl -s -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;Authenticate\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;API\u0026#34;: 1, \u0026#34;Password\u0026#34;: \u0026#34;itoopie\u0026#34; } }\u0026#39; \\ http://127.0.0.1:7657/jsonrpc/ Úspěšná odpověď { \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;result\u0026#34;: { \u0026#34;Token\u0026#34;: \u0026#34;a1b2c3d4e5\u0026#34;, \u0026#34;API\u0026#34;: 1 } } Tento Token musíte zahrnout do všech následujících požadavků v params.\n4. Metody a koncové body 4.1 RouterInfo Načte klíčovou telemetrii o routeru.\nPříklad požadavku\ncurl -s -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;2\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;RouterInfo\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;Token\u0026#34;: \u0026#34;a1b2c3d4e5\u0026#34;, \u0026#34;i2p.router.version\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;i2p.router.status\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;i2p.router.net.status\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;i2p.router.net.tunnels.participating\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;i2p.router.net.bw.inbound.1s\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;i2p.router.net.bw.outbound.1s\u0026#34;: \u0026#34;\u0026#34; } }\u0026#39; \\ http://127.0.0.1:7657/jsonrpc/ Pole odpovědi (result) Podle oficiální dokumentace (GetI2P): - i2p.router.status (String) — stav čitelný pro člověka - i2p.router.uptime (long) — milisekundy (nebo řetězec u staršího i2pd) :contentReference[oaicite:0]{index=0} - i2p.router.version (String) — řetězec verze :contentReference[oaicite:1]{index=1} - i2p.router.net.bw.inbound.1s, i2p.router.net.bw.inbound.15s (double) — příchozí šířka pásma v B/s :contentReference[oaicite:2]{index=2} - i2p.router.net.bw.outbound.1s, i2p.router.net.bw.outbound.15s (double) — odchozí šířka pásma v B/s :contentReference[oaicite:3]{index=3} - i2p.router.net.status (long) — číselný stavový kód (viz výčet níže) :contentReference[oaicite:4]{index=4} - i2p.router.net.tunnels.participating (long) — počet zúčastněných tunnelů :contentReference[oaicite:5]{index=5} - i2p.router.netdb.activepeers, fastpeers, highcapacitypeers (long) — statistiky netDB peerů :contentReference[oaicite:6]{index=6} - i2p.router.netdb.isreseeding (boolean) — zda je aktivní reseed :contentReference[oaicite:7]{index=7} - i2p.router.netdb.knownpeers (long) — celkový počet známých peerů :contentReference[oaicite:8]{index=8}\nVýčet stavových kódů (i2p.router.net.status) Code Meaning 0 OK 1 TESTING 2 FIREWALLED 3 HIDDEN 4 WARN_FIREWALLED_AND_FAST 5 WARN_FIREWALLED_AND_FLOODFILL 6 WARN_FIREWALLED_WITH_INBOUND_TCP 7 WARN_FIREWALLED_WITH_UDP_DISABLED 8 ERROR_I2CP 9 ERROR_CLOCK_SKEW 10 ERROR_PRIVATE_TCP_ADDRESS 11 ERROR_SYMMETRIC_NAT 12 ERROR_UDP_PORT_IN_USE 13 ERROR_NO_ACTIVE_PEERS_CHECK_CONNECTION_AND_FIREWALL 14 ERROR_UDP_DISABLED_AND_TCP_UNSET --- 4.2 GetRate Používá se k získání metrik rychlosti (např. šířka pásma, úspěšnost tunelů) za dané časové období.\nPříklad požadavku\ncurl -s -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;3\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;GetRate\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;Token\u0026#34;: \u0026#34;a1b2c3d4e5\u0026#34;, \u0026#34;Stat\u0026#34;: \u0026#34;bw.combined\u0026#34;, \u0026#34;Period\u0026#34;: 60000 } }\u0026#39; \\ http://127.0.0.1:7657/jsonrpc/ Ukázková odpověď\n{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;3\u0026#34;, \u0026#34;result\u0026#34;: { \u0026#34;Rate\u0026#34;: 12345.67 } } 4.3 RouterManager Provádět administrativní akce.\nPovolené parametry / metody - Restart, RestartGraceful - Shutdown, ShutdownGraceful - Reseed, FindUpdates, Update :contentReference[oaicite:10]{index=10}\nPříklad požadavku\ncurl -s -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;4\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;RouterManager\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;Token\u0026#34;: \u0026#34;a1b2c3d4e5\u0026#34;, \u0026#34;Restart\u0026#34;: true } }\u0026#39; \\ http://127.0.0.1:7657/jsonrpc/ Úspěšná odpověď\n{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;4\u0026#34;, \u0026#34;result\u0026#34;: { \u0026#34;Restart\u0026#34;: null } } 4.4 NetworkSetting Získat nebo nastavit parametry síťové konfigurace (porty, upnp, sdílení šířky pásma atd.)\nPříklad požadavku (získání aktuálních hodnot)\ncurl -s -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;5\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;NetworkSetting\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;Token\u0026#34;: \u0026#34;a1b2c3d4e5\u0026#34;, \u0026#34;i2p.router.net.ntcp.port\u0026#34;: null, \u0026#34;i2p.router.net.ssu.port\u0026#34;: null, \u0026#34;i2p.router.net.bw.share\u0026#34;: null, \u0026#34;i2p.router.net.upnp\u0026#34;: null } }\u0026#39; \\ http://127.0.0.1:7657/jsonrpc/ Ukázková odpověď\n{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;5\u0026#34;, \u0026#34;result\u0026#34;: { \u0026#34;i2p.router.net.ntcp.port\u0026#34;: \u0026#34;1234\u0026#34;, \u0026#34;i2p.router.net.ssu.port\u0026#34;: \u0026#34;5678\u0026#34;, \u0026#34;i2p.router.net.bw.share\u0026#34;: \u0026#34;50\u0026#34;, \u0026#34;i2p.router.net.upnp\u0026#34;: \u0026#34;true\u0026#34;, \u0026#34;SettingsSaved\u0026#34;: true, \u0026#34;RestartNeeded\u0026#34;: false } } Poznámka: verze i2pd starší než 2.41 mohou vracet číselné typy místo řetězců — klienti by měli zpracovávat obojí. :contentReference[oaicite:11]{index=11}\n4.5 Pokročilá nastavení Umožňuje manipulaci s interními parametry routeru.\nPříklad požadavku\ncurl -s -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;6\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;AdvancedSettings\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;Token\u0026#34;: \u0026#34;a1b2c3d4e5\u0026#34;, \u0026#34;Set\u0026#34;: { \u0026#34;router.sharePercentage\u0026#34;: \u0026#34;75\u0026#34;, \u0026#34;i2np.flushInterval\u0026#34;: \u0026#34;6000\u0026#34; } } }\u0026#39; \\ http://127.0.0.1:7657/jsonrpc/ Příklad odpovědi\n{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;6\u0026#34;, \u0026#34;result\u0026#34;: { \u0026#34;Set\u0026#34;: { \u0026#34;router.sharePercentage\u0026#34;: \u0026#34;75\u0026#34;, \u0026#34;i2np.flushInterval\u0026#34;: \u0026#34;6000\u0026#34; } } } 5. Chybové kódy Kromě standardních JSON-RPC chyb (-32700, -32600, atd.) definuje I2PControl:\nCode Meaning -32001 Invalid password -32002 Missing token -32003 Token does not exist -32004 Token expired -32005 API version missing -32006 API version unsupported --- 6. Použití a doporučené postupy Vždy zahrňte parametr Token (kromě případů, kdy se autentizujete). Při prvním použití změňte výchozí heslo (itoopie). Pro Java I2P se ujistěte, že je I2PControl webapp povolena přes WebApps. Buďte připraveni na mírné odchylky: některá pole mohou být čísla nebo řetězce v závislosti na verzi I2P. Zalamujte dlouhé stavové řetězce pro přehledný výstup. ","description":"API pro vzdálenou správu routeru prostřednictvím webové aplikace I2PControl","id":"f0e7aa57ce714931128f06f6bdb94db3","section":"docs","title":"I2PControl JSON-RPC","url":"/cs/docs/api/i2pcontrol/"},{"categories":null,"content":"Přehled I2PTunnel je základní komponenta I2P pro rozhraní a poskytování služeb v síti I2P. Umožňuje aplikacím založeným na TCP a streamování médií pracovat anonymně prostřednictvím abstrakce tunelů. Cíl tunelu lze definovat pomocí názvu hostitele , Base32 nebo úplného klíče cíle.\nKaždý vytvořený tunnel naslouchá lokálně (např. localhost:port) a připojuje se interně k I2P destinacím. Pro hostování služby vytvořte tunnel směřující na požadovanou IP adresu a port. Vygeneruje se odpovídající I2P destination key, který umožní službě být globálně dostupnou v rámci I2P sítě. Webové rozhraní I2PTunnel je k dispozici na adrese I2P Router Tunnel Manager .\nVýchozí služby Serverový tunel I2P Webserver – Tunnel k Jetty webserveru na localhost:7658 pro snadný hosting na I2P. Unix: $HOME/.i2p/eepsite/docroot Windows: %LOCALAPPDATA%\\I2P\\I2P Site\\docroot → C:\\Users\\\u0026lt;username\u0026gt;\\AppData\\Local\\I2P\\I2P Site\\docroot Klientské tunely I2P HTTP Proxy – localhost:4444 – Používá se pro prohlížení I2P a internetu prostřednictvím outproxies. I2P HTTPS Proxy – localhost:4445 – Zabezpečená varianta HTTP proxy. Irc2P – localhost:6668 – Výchozí tunel anonymní IRC sítě. Git SSH (gitssh.idk.i2p) – localhost:7670 – Klientský tunel pro SSH přístup k repozitářům. Postman SMTP – localhost:7659 – Klientský tunel pro odchozí poštu. Postman POP3 – localhost:7660 – Klientský tunel pro příchozí poštu. Poznámka: Pouze I2P Webserver je výchozí server tunnel; všechny ostatní jsou klientské tunnely připojující se k externím I2P službám.\nKonfigurace Specifikace konfigurace I2PTunnel je dokumentována na /spec/configuration .\nKlientské režimy Standardní Otevře lokální TCP port, který se připojí ke službě na I2P destinaci. Podporuje více záznamů destinací oddělených čárkami pro redundanci.\nHTTP Proxy tunel pro HTTP/HTTPS požadavky. Podporuje lokální a vzdálené outproxy, odstranění hlaviček, ukládání do mezipaměti, autentizaci a transparentní kompresi.\nOchrana soukromí: - Odstraňuje hlavičky: Accept-*, Referer, Via, From - Nahrazuje hlavičky hostitele Base32 destinacemi - Vynucuje odstranění hop-by-hop podle RFC - Přidává podporu pro transparentní dekompresi - Poskytuje interní chybové stránky a lokalizované odpovědi\nChování komprese: - Požadavky mohou používat vlastní hlavičku X-Accept-Encoding: x-i2p-gzip - Odpovědi s Content-Encoding: x-i2p-gzip jsou transparentně dekomprimovány - Komprese je vyhodnocována podle MIME typu a délky odpovědi pro efektivitu\nPersistence (nové od verze 2.5.0): HTTP Keepalive a trvalá spojení jsou nyní podporována pro služby hostované v I2P prostřednictvím správce skrytých služeb (Hidden Services Manager). To snižuje latenci a režii spojení, ale zatím neumožňuje plně RFC 2616-kompatibilní trvalé sokety přes všechny skoky (hops).\nPipelining: Zůstává nepodporován a nepotřebný; moderní prohlížeče ho opustily.\nChování User-Agent: - Outproxy: Používá aktuální User-Agent z Firefox ESR. - Interní: MYOB/6.66 (AN/ON) pro konzistenci anonymity.\nIRC klient Připojuje se k IRC serverům v síti I2P. Umožňuje bezpečnou podmnožinu příkazů a filtruje identifikátory pro zachování soukromí.\nSOCKS 4/4a/5 Poskytuje funkcionalitu SOCKS proxy pro TCP připojení. UDP zůstává neimplementováno v Java I2P (pouze v i2pd).\nPŘIPOJIT Implementuje HTTP CONNECT tunelování pro SSL/TLS připojení.\nStreamr Umožňuje streamování ve stylu UDP prostřednictvím zapouzdření založeného na TCP. Podporuje streamování médií při použití s odpovídajícím serverovým tunelem Streamr.\nRežimy serveru Standardní server Vytvoří TCP destinaci mapovanou na lokální IP:port.\nHTTP Server Vytváří destinaci, která komunikuje s lokálním webovým serverem. Podporuje kompresi (x-i2p-gzip), odstraňování hlaviček a ochranu proti DDoS útokům. Nyní těží z podpory trvalých spojení (v2.5.0+) a optimalizace sdružování vláken (v2.7.0–2.9.0).\nHTTP Obousměrné Zastaralé – Stále funkční, ale nedoporučuje se. Funguje jako HTTP server i klient bez outproxingu. Používá se především pro diagnostické loopback testy.\nIRC Server Vytvoří filtrovanou destinaci pro IRC služby, předávající klíče klientských destinací jako názvy hostitelů.\nStreamr Server Páruje se s tunelem Streamr klienta pro zpracování UDP-stylových datových streamů přes I2P.\nNové funkce (2.4.0–2.10.0) Feature Introduced Summary Keepalive/Persistent Connections 2.5.0 HTTP tunnels now support persistent sockets for I2P-hosted services, improving performance. Thread Pooling Optimization 2.7.0-2.9.0 Reduced CPU overhead and latency by improving thread management. Post-Quantum Encryption (ML-KEM) 2.10.0 Optional hybrid X25519+ML-KEM encryption to resist future quantum attacks. NetDB Segmentation 2.4.0 Isolates I2PTunnel contexts for improved security and privacy. SSU1 Removal / SSU2 Adoption 2.4.0-2.6.0 Upgraded transport layer; transparent to users. I2P-over-Tor Blocking 2.6.0 Prevents inefficient and unstable I2P-over-Tor routing. Browser Proxy (Proposal 166) 2.7.0 Introduced identity-aware proxy mode; details pending confirmation. Java 17 Requirement (upcoming) 2.11.0 Future release will require Java 17+. --- Bezpečnostní funkce Odstranění hlaviček pro anonymitu (Accept, Referer, From, Via) Randomizace User-Agent v závislosti na in/outproxy Omezení rychlosti POST a ochrana proti Slowloris Omezování připojení v streamovacích subsystémech Zvládání přetížení sítě na vrstvě tunelů Izolace NetDB zabraňující únikům mezi aplikacemi Technické podrobnosti Výchozí velikost klíče destinace: 516 bajtů (může být větší u rozšířených LS2 certifikátů) Base32 adresy: {52–56+ znaků}.b32.i2p Server tunnely zůstávají kompatibilní s Java I2P i i2pd Zastaralá funkce: pouze httpbidirserver; žádné odstranění od verze 0.9.59 Ověřeny správné výchozí porty a kořenové adresáře dokumentů pro všechny platformy Shrnutí I2PTunnel zůstává základem integrace aplikací s I2P. Mezi verzemi 0.9.59 a 2.10.0 získal podporu perzistentních spojení, postkvantovou šifru a významná vylepšení vláknování. Většina konfigurací zůstává kompatibilní, ale vývojáři by měli ověřit svá nastavení, aby zajistili soulad s moderními výchozími hodnotami pro transport a zabezpečení.\n","description":"Nástroj pro propojení s I2P a poskytování služeb na I2P","id":"7e5d426e3eead28c1767764107b1f3d1","section":"docs","title":"I2PTunnel","url":"/cs/docs/api/i2ptunnel/"},{"categories":null,"content":"Projekt I2P udržuje oficiální balíčky pro Debian, Ubuntu a jejich odvozené distribuce. Tento průvodce poskytuje komplexní pokyny pro instalaci I2P pomocí našich oficiálních repozitářů.\nNEPOKLÁDEJTE otázky, neposkytujte vysvětlení ani nepřidávejte žádné komentáře. I když je text pouze nadpis nebo se zdá být neúplný, přeložte ho tak, jak je.\n🚀 Beta: Automatická instalace (Experimentální) Pro pokročilé uživatele, kteří chtějí rychlou automatizovanou instalaci:\nTento jednořádkový příkaz automaticky rozpozná vaši distribuci a nainstaluje I2P. Používejte obezřetně - před spuštěním si prohlédněte instalační skript .\ncurl -fsSL https://i2p.net/installlinux.sh | sudo bash Co to dělá: - Detekuje vaši linuxovou distribuci (Ubuntu/Debian) - Přidá příslušné I2P repozitáře - Nainstaluje GPG klíče a požadované balíčky - Nainstaluje I2P automaticky\n⚠️ Toto je beta funkce. Pokud preferujete ruční instalaci nebo chcete porozumět každému kroku, použijte níže uvedené metody ruční instalace.\nNEKLADEŤE otázky, neposkytujte vysvětlení ani nepřidávejte žádné komentáře. I když je text pouze nadpis nebo se zdá neúplný, přeložte jej tak, jak je.\nPodporované platformy Balíčky pro Debian jsou kompatibilní s:\nUbuntu 18.04 (Bionic) a novější Linux Mint 19 (Tara) a novější Debian Buster (10) a novější Knoppix Další distribuce založené na Debianu (LMDE, ParrotOS, Kali Linux atd.) Podporované architektury: amd64, i386, armhf, arm64, powerpc, ppc64el, s390x\nBalíčky I2P mohou fungovat i na jiných systémech založených na Debianu, které nejsou výslovně uvedeny výše. Pokud narazíte na problémy, prosím nahlaste je na našem GitLabu .\nMetody instalace Vyberte způsob instalace, který odpovídá vaší distribuci:\nMožnost 1: Ubuntu a odvozeniny (Linux Mint, elementary OS, Pop!_OS, atd.) Možnost 2: Debian a distribuce založené na Debianu (včetně LMDE, Kali, ParrotOS) NEPOKLÁDEJTE otázky, neposkytujte vysvětlení ani nepřidávejte žádné komentáře. I když je text pouze nadpis nebo se zdá být neúplný, přeložte jej tak, jak je.\nInstalace na Ubuntu Ubuntu a jeho oficiální deriváty (Linux Mint, elementary OS, Trisquel atd.) mohou využít I2P PPA (Personal Package Archive) pro snadnou instalaci a automatické aktualizace.\nMethod 1: Command Line Installation (Recommended) Toto je nejrychlejší a nejspolehlivější metoda pro instalaci I2P na systémech založených na Ubuntu.\nKrok 1: Přidání I2P PPA\nOtevřete terminál a spusťte:\nsudo apt-add-repository ppa:i2p-maintainers/i2p Tento příkaz přidá I2P PPA do /etc/apt/sources.list.d/ a automaticky importuje GPG klíč, který podepisuje repozitář. GPG podpis zajišťuje, že balíčky nebyly od jejich sestavení změněny.\nKrok 2: Aktualizace seznamu balíčků\nAktualizujte databázi balíčků vašeho systému, aby zahrnovala nové PPA:\nsudo apt-get update Toto stáhne nejnovější informace o balíčcích ze všech povolených repozitářů, včetně PPA I2P, které jste právě přidali.\nKrok 3: Instalace I2P\nNyní nainstalujte I2P:\nsudo apt-get install i2p To je vše! Přeskočte do sekce Konfigurace po instalaci , kde se dozvíte, jak spustit a nastavit I2P.\nMethod 2: Using the Software Center GUI Pokud upřednostňujete grafické rozhraní, můžete přidat PPA pomocí Ubuntu Software Center.\nKrok 1: Otevřete Software a aktualizace\nSpusťte \u0026ldquo;Software a aktualizace\u0026rdquo; z nabídky aplikací.\nKrok 2: Přejděte do sekce Další software\nVyberte záložku \u0026ldquo;Other Software\u0026rdquo; a klikněte na tlačítko \u0026ldquo;Add\u0026rdquo; ve spodní části pro konfiguraci nového PPA.\nKrok 3: Přidání I2P PPA\nV dialogovém okně PPA zadejte:\nppa:i2p-maintainers/i2p Krok 4: Obnovit informace o repozitáři\nKlikněte na tlačítko „Reload\u0026quot; pro stažení aktualizovaných informací z repozitáře.\nKrok 5: Instalace I2P\nOtevřete aplikaci „Software\u0026quot; z nabídky aplikací, vyhledejte „i2p\u0026quot; a klikněte na Instalovat.\nPo dokončení instalace pokračujte na Konfiguraci po instalaci .\nI2P I2P je decentralizovaná síť pro anonymní komunikaci, která šifruje a směruje provoz přes dobrovolníky provozující routery po celém světě.\nKlíčové vlastnosti Skrytá umístění: Služby (eepsites) jsou přístupné pouze v síti I2P Garlic encryption: Mnoho zpráv zabalených společně pro lepší soukromí Distribuovaná síť: Žádný centrální bod selhání Šifrování end-to-end: Provoz je šifrován od zdroje k cíli Nízká latence: Optimalizováno pro interaktivní provoz Jak to funguje I2P používá tunnely pro odesílání a přijímání provozu. Každý tunnel prochází několika routery, přičemž každý router zná pouze předchozí a následující hop. To vytváří vrstvenou anonymitu podobnou Tor, ale s důležitými rozdíly:\nI2P je síť uvnitř sítě (overlay network) - běží nad internetem Routery jsou provozovány dobrovolníky, nikoli centrální autoritou Síť je určena primárně pro služby uvnitř I2P, nikoli pro přístup na běžný internet Debian Installation Debian a jeho downstream distribuce (LMDE, Kali Linux, ParrotOS, Knoppix atd.) by měly používat oficiální I2P Debian repozitář na deb.i2p.net.\nImportant Notice Naše staré repozitáře na deb.i2p2.de a deb.i2p2.no již nejsou podporovány. Pokud používáte tyto zastaralé repozitáře, postupujte prosím podle níže uvedených pokynů pro migraci na nový repozitář na deb.i2p.net.\nPrerequisites Všechny níže uvedené kroky vyžadují root přístup. Buď přepněte na uživatele root pomocí su, nebo před každý příkaz přidejte sudo.\nMetoda 1: Instalace z příkazové řádky (doporučeno) Krok 1: Nainstalujte požadované balíčky\nUjistěte se, že máte nainstalované potřebné nástroje:\nsudo apt-get update sudo apt-get install apt-transport-https lsb-release curl Tyto balíčky umožňují bezpečný HTTPS přístup k repozitáři, detekci distribuce a stahování souborů.\nKrok 2: Přidejte repozitář I2P\nPříkaz, který použijete, závisí na vaší verzi Debianu. Nejprve zjistěte, kterou verzi používáte:\ncat /etc/debian_version Zkontrolujte to proti informacím o vydáních Debianu pro identifikaci kódového názvu vaší distribuce (např. Bookworm, Bullseye, Buster).\nPro Debian Bullseye (11) nebo novější:\necho \u0026#34;deb [signed-by=/usr/share/keyrings/i2p-archive-keyring.gpg] https://deb.i2p.net/ $(lsb_release -sc) main\u0026#34; \\ | sudo tee /etc/apt/sources.list.d/i2p.list Pro deriváty Debianu (LMDE, Kali, ParrotOS atd.) na Bullseye nebo novějších:\necho \u0026#34;deb [signed-by=/usr/share/keyrings/i2p-archive-keyring.gpg] https://deb.i2p.net/ $(dpkg --status tzdata | grep Provides | cut -f2 -d\u0026#39;-\u0026#39;) main\u0026#34; \\ | sudo tee /etc/apt/sources.list.d/i2p.list Pro Debian Buster (10) nebo starší:\necho \u0026#34;deb https://deb.i2p.net/ $(lsb_release -sc) main\u0026#34; \\ | sudo tee /etc/apt/sources.list.d/i2p.list Pro deriváty Debianu na Buster-ekvivalentu nebo starším:\necho \u0026#34;deb https://deb.i2p.net/ $(dpkg --status tzdata | grep Provides | cut -f2 -d\u0026#39;-\u0026#39;) main\u0026#34; \\ | sudo tee /etc/apt/sources.list.d/i2p.list Krok 3: Stáhněte podpisový klíč repozitáře\ncurl -o i2p-archive-keyring.gpg https://geti2p.net/_static/i2p-archive-keyring.gpg Krok 4: Ověřte otisk klíče\nPřed důvěřováním klíči ověřte, že jeho otisk odpovídá oficiálnímu podpisovému klíči I2P:\ngpg --keyid-format long --import --import-options show-only --with-fingerprint i2p-archive-keyring.gpg Ověřte, že výstup zobrazuje tento otisk:\n7840 E761 0F28 B904 7535 49D7 67EC E560 5BCF 1346 ⚠️ Nepokračujte, pokud se otisk neshoduje. To by mohlo indikovat kompromitované stažení.\nKrok 5: Instalace klíče repozitáře\nZkopírujte ověřenou klíčenku do systémového adresáře klíčenek:\nsudo cp i2p-archive-keyring.gpg /usr/share/keyrings Pouze pro Debian Buster nebo starší je také potřeba vytvořit symbolický odkaz:\nsudo ln -sf /usr/share/keyrings/i2p-archive-keyring.gpg /etc/apt/trusted.gpg.d/i2p-archive-keyring.gpg Krok 6: Aktualizace seznamů balíčků\nObnovte databázi balíčků vašeho systému, aby zahrnovala repozitář I2P:\nsudo apt-get update Krok 7: Instalace I2P\nNainstalujte jak I2P router, tak balíček s klíčenkou (který zajistí, že budete dostávat budoucí aktualizace klíčů):\nsudo apt-get install i2p i2p-keyring Skvělé! I2P je nyní nainstalováno. Pokračujte do sekce Konfigurace po instalaci .\nNEKLASTĚ otázky, neposkytujte vysvětlení ani nepřidávejte žádné komentáře. I když je text pouze nadpisem nebo se zdá neúplný, přeložte ho tak, jak je.\nPost-Installation Configuration Po instalaci I2P budete muset spustit router a provést počáteční konfiguraci.\nMetoda 2: Pomocí grafického rozhraní Software Center Balíčky I2P poskytují tři způsoby spuštění I2P routeru:\nOption 1: On-Demand (Basic) Spusťte I2P manuálně podle potřeby pomocí skriptu i2prouter:\ni2prouter start Důležité: Nepoužívejte sudo ani toto nespouštějte jako root! I2P by mělo běžet pod vaším běžným uživatelským účtem.\nZastavení I2P:\ni2prouter stop Option 2: On-Demand (Without Java Service Wrapper) Pokud používáte systém jiný než x86 nebo Java Service Wrapper na vaší platformě nefunguje, použijte:\ni2prouter-nowrapper Znovu, nepoužívejte sudo ani nespouštějte jako root.\nOption 3: System Service (Recommended) Pro nejlepší zkušenost nakonfigurujte I2P tak, aby se spouštěl automaticky při startu systému, ještě před přihlášením:\nsudo dpkg-reconfigure i2p Toto otevře dialogové okno konfigurace. Vyberte „Ano\u0026quot; pro povolení I2P jako systémové služby.\nToto je doporučená metoda, protože: - I2P se spustí automaticky při startu systému - Váš router udržuje lepší integraci se sítí - Přispíváte ke stabilitě sítě - I2P je okamžitě dostupné, když ho potřebujete\nInitial Router Configuration Po prvním spuštění I2P bude trvat několik minut, než se integruje do sítě. Mezitím nakonfigurujte tato základní nastavení:\n1. Configure NAT/Firewall Pro optimální výkon a účast v síti přesměrujte porty I2P skrz svůj NAT/firewall:\nOtevřete I2P Router Console Přejděte na stránku konfigurace sítě Poznamenejte si čísla portů (obvykle náhodné porty mezi 9000-31000) Přesměrujte tyto UDP a TCP porty ve vašem routeru/firewallu Pokud potřebujete pomoc s přesměrováním portů, portforward.com nabízí příručky specifické pro jednotlivé routery.\n2. Adjust Bandwidth Settings Výchozí nastavení šířky pásma je konzervativní. Upravte je podle vašeho internetového připojení:\nNavštivte konfigurační stránku Najděte sekci nastavení šířky pásma Výchozí hodnoty jsou 96 KB/s pro stahování / 40 KB/s pro odesílání Zvyšte tyto hodnoty, pokud máte rychlejší internetové připojení (např. 250 KB/s pro stahování / 100 KB/s pro odesílání u typického širokopásmového připojení) Poznámka: Nastavení vyšších limitů pomáhá síti a zlepšuje váš vlastní výkon.\n3. Configure Your Browser Pro přístup k I2P stránkám (eepsite) a službám nakonfigurujte svůj prohlížeč tak, aby používal HTTP proxy I2P:\nPřečtěte si náš Průvodce konfigurací prohlížeče s podrobnými pokyny pro nastavení Firefoxu, Chrome a dalších prohlížečů.\nZabezpečení I2P Instalace na Debianu Důležité upozornění Ujistěte se, že I2P neběží jako root: ps aux | grep i2p Zkontrolujte logy: tail -f ~/.i2p/wrapper.log Ověřte, že je nainstalována Java: java -version Předpoklady Pokud během instalace obdržíte chyby GPG klíče:\nZnovu stáhněte a ověřte otisk klíče (Krok 3-4 výše) Ujistěte se, že soubor s klíčenkou má správná oprávnění: sudo chmod 644 /usr/share/keyrings/i2p-archive-keyring.gpg Kroky instalace Pokud I2P nepřijímá aktualizace:\nOvěřte, že je repozitář nakonfigurován: cat /etc/apt/sources.list.d/i2p.list Aktualizujte seznam balíčků: sudo apt-get update Zkontrolujte aktualizace I2P: sudo apt-get upgrade Migrating from old repositories Pokud používáte staré repozitáře deb.i2p2.de nebo deb.i2p2.no:\nOdstraňte starý repozitář: sudo rm /etc/apt/sources.list.d/i2p.list Postupujte podle kroků Instalace pro Debian výše Aktualizujte: sudo apt-get update \u0026amp;\u0026amp; sudo apt-get install i2p i2p-keyring NEPTEJTE se na otázky, neposkytujte vysvětlení ani nepřidávejte žádné komentáře. I když je text pouze nadpisem nebo se zdá neúplný, přeložte jej tak, jak je.\nNext Steps Nyní, když je I2P nainstalováno a spuštěno:\nNakonfigurujte svůj prohlížeč pro přístup k I2P stránkám Prozkoumejte konzoli I2P routeru pro sledování vašeho routeru Zjistěte více o I2P aplikacích , které můžete používat Přečtěte si o tom, jak I2P funguje , abyste porozuměli síti Vítejte v Invisible Internetu!\n","description":"Kompletní průvodce instalací I2P na Debian, Ubuntu a jejich derivátech pomocí oficiálních repozitářů","id":"88fb5f6d2f5129ce7be2a42b1e9fb9af","section":"docs","title":"Instalace I2P na Debianu a Ubuntu","url":"/cs/docs/guides/instalace-i2p-na-debianu-a-ubuntu/"},{"categories":null,"content":"Co budete potřebovat Mac se systémem macOS 10.14 (Mojave) nebo novějším Administrátorská práva pro instalaci aplikací Přibližně 15-20 minut času Připojení k internetu pro stažení instalátorů Přehled Tento instalační proces má čtyři hlavní kroky:\nNainstalujte Javu - Stáhněte a nainstalujte Oracle Java Runtime Environment Nainstalujte I2P - Stáhněte a spusťte instalátor I2P Nakonfigurujte aplikaci I2P - Nastavte spouštěč a přidejte ho do doku Nakonfigurujte šířku pásma I2P - Spusťte průvodce nastavením pro optimalizaci vašeho připojení Část první: Instalace Java I2P vyžaduje ke spuštění Javu. Pokud již máte nainstalovanou Javu 8 nebo novější, můžete přeskočit na druhou část .\nStep 1: Download Java Navštivte stránku pro stažení Oracle Java a stáhněte si instalátor pro macOS pro Javu 8 nebo novější.\nStep 2: Run the Installer Najděte stažený soubor .dmg ve složce Stažené a dvojitým kliknutím ho otevřete.\nStep 3: Allow Installation macOS může zobrazit bezpečnostní upozornění, protože instalátor pochází od identifikovaného vývojáře. Klikněte na Otevřít pro pokračování.\nKrok 1: Stáhněte Javu Klikněte na Install pro zahájení procesu instalace Javy.\nKrok 2: Spusťte instalátor Instalátor zkopíruje soubory a nakonfiguruje Javu ve vašem systému. Obvykle to trvá 1-2 minuty.\nKrok 3: Povolit instalaci Když se zobrazí zpráva o úspěchu, Java je nainstalována! Klikněte na Zavřít a dokončete instalaci.\nPart Two: Download and Install I2P Nyní, když je Java nainstalována, můžete nainstalovat I2P router.\nKrok 4: Instalace Javy Navštivte stránku ke stažení a stáhněte si instalátor I2P pro Unix/Linux/BSD/Solaris (soubor .jar).\n![Stáhnout instalátor I2P](/images/guides/macos-install/0-i2p.png) Krok 5: Počkejte na dokončení instalace Dvojklikem spusťte stažený soubor i2pinstall_X.X.X.jar. Instalátor se spustí a požádá vás o výběr preferovaného jazyka.\nKrok 6: Instalace dokončena Přečtěte si uvítací zprávu a pokračujte kliknutím na Next.\nStep 4: Important Notice Instalátor zobrazí důležité upozornění týkající se aktualizací. Aktualizace I2P jsou end-to-end podepsané a ověřené, i když je samotný instalátor nepodepsaný. Klikněte na Další.\nKrok 1: Stáhnout I2P Přečtěte si licenční smlouvu I2P (licence typu BSD). Klikněte na Next pro přijetí.\nKrok 2: Spusťte instalátor Zvolte, kam nainstalovat I2P. Doporučuje se výchozí umístění (/Applications/i2p). Klikněte na Další.\nKrok 3: Úvodní obrazovka Ponechte všechny komponenty vybrané pro úplnou instalaci. Klikněte na Další.\nKrok 4: Důležité upozornění Zkontrolujte své volby a klikněte na Next (Další) pro zahájení instalace I2P.\nKrok 5: Licenční smlouva Instalátor zkopíruje soubory I2P do vašeho systému. Trvá to přibližně 1-2 minuty.\nKrok 6: Vyberte adresář pro instalaci Instalátor vytváří spouštěcí skripty pro spuštění I2P.\nKrok 7: Výběr komponent Instalátor nabízí vytvoření zástupců na ploše a položek v nabídce. Proveďte svůj výběr a klikněte na Další.\nKrok 8: Spuštění instalace Úspěch! I2P je nyní nainstalováno. Klikněte na Hotovo pro dokončení.\nPart Three: Configure I2P App Nyní usnadníme spouštění I2P jeho přidáním do složky Aplikace a do Docku.\nKrok 9: Instalace souborů Otevřete Finder a přejděte do složky Aplikace.\nKrok 10: Vygenerování spouštěcích skriptů Vyhledejte složku I2P nebo aplikaci Start I2P Router uvnitř /Applications/i2p/.\nKrok 11: Instalační zkratky Přetáhněte aplikaci Start I2P Router do Docku pro snadný přístup. Můžete také vytvořit alias na ploše.\nTip: Klikněte pravým tlačítkem na ikonu I2P v Docku a vyberte Možnosti → Ponechat v Docku, aby zůstala trvale.\nPart Four: Configure I2P Bandwidth Když poprvé spustíte I2P, projdete průvodcem nastavením pro konfiguraci vašich nastavení šířky pásma. To pomáhá optimalizovat výkon I2P pro vaše připojení.\nKrok 12: Instalace dokončena Klikněte na ikonu I2P v Docku (nebo dvakrát klikněte na spouštěč). Ve vašem výchozím webovém prohlížeči se otevře I2P Router Console.\nStep 2: Welcome Wizard Průvodce nastavením vás přivítá. Klikněte na Další a zahajte konfiguraci I2P.\nKrok 1: Otevřete složku Aplikace Vyberte preferovaný jazyk rozhraní a zvolte světlý nebo tmavý motiv. Klikněte na Další.\nKrok 2: Najít I2P Launcher Průvodce vysvětlí test šířky pásma. Tento test se připojí ke službě M-Lab pro měření rychlosti vašeho internetového připojení. Klikněte na Další pro pokračování.\nKrok 3: Přidat do Docku Klikněte na Run Test pro změření rychlosti uploadu a downloadu. Test trvá přibližně 30-60 sekund.\nStep 6: Test Results Zkontrolujte výsledky testu. I2P doporučí nastavení šířky pásma na základě rychlosti vašeho připojení.\nKrok 1: Spusťte I2P Vyberte, kolik šířky pásma chcete sdílet se sítí I2P:\nAutomatická (Doporučeno): I2P spravuje šířku pásma podle vašeho využití Omezená: Nastavte konkrétní limity pro upload/download Neomezená: Sdílejte co nejvíce (pro rychlá připojení) Klikněte na Další pro uložení vašeho nastavení.\nKrok 2: Uvítací průvodce Váš I2P router je nyní nakonfigurován a běží! Konzole routeru zobrazí stav vašeho připojení a umožní vám procházet I2P stránky.\nGetting Started with I2P Nyní, když je I2P nainstalováno a nakonfigurováno, můžete:\nProcházejte I2P stránky: Navštivte domovskou stránku I2P a prohlédněte si odkazy na populární I2P služby Nakonfigurujte svůj prohlížeč: Nastavte profil prohlížeče pro přístup ke stránkám .i2p Prozkoumejte služby: Vyzkoušejte I2P e-mail, fóra, sdílení souborů a další Sledujte svůj router: Konzole zobrazuje stav vaší sítě a statistiky Krok 3: Jazyk a motiv Router Console: http://127.0.0.1:7657/ Konfigurace: http://127.0.0.1:7657/config Adresář: http://127.0.0.1:7657/susidns/addressbook Nastavení šířky pásma: http://127.0.0.1:7657/config Re-running the Setup Wizard Pokud chcete později změnit nastavení šířky pásma nebo překonfigurovat I2P, můžete znovu spustit průvodce nastavením z Konzole routeru:\nPřejděte na I2P Setup Wizard Znovu projděte kroky průvodce Troubleshooting Krok 4: Informace o testu šířky pásma Zkontrolujte Javu: Ujistěte se, že je Java nainstalována spuštěním příkazu java -version v Terminálu Zkontrolujte oprávnění: Ujistěte se, že složka I2P má správná oprávnění Zkontrolujte logy: Podívejte se do ~/.i2p/wrapper.log na chybové hlášky Krok 5: Spuštění testu šířky pásma Ujistěte se, že I2P běží (zkontrolujte Router Console) Nakonfigurujte nastavení proxy ve vašem prohlížeči na HTTP proxy 127.0.0.1:4444 Počkejte 5-10 minut po spuštění, než se I2P integruje do sítě Krok 6: Výsledky testů Spusťte test šířky pásma znovu a upravte svá nastavení Ujistěte se, že sdílíte část šířky pásma se sítí Zkontrolujte stav vašeho připojení v Router Console Část druhá: Stažení a instalace I2P Jak odebrat I2P z vašeho Macu:\nUkončete I2P router, pokud běží Smažte složku /Applications/i2p Smažte složku ~/.i2p (vaše konfigurace a data I2P) Odstraňte ikonu I2P z vašeho Docku Next Steps Připojte se ke komunitě: Navštivte i2pforum.net nebo se podívejte na I2P na Redditu Dozvědět se více: Přečtěte si dokumentaci I2P , abyste pochopili, jak síť funguje Zapojte se: Zvažte přispívání do vývoje I2P nebo provozování infrastruktury Gratulujeme! Nyní jste součástí sítě I2P. Vítejte na neviditelném internetu!\nNEPTEJTE se, neposkytujte vysvětlení ani nepřidávejte žádné komentáře. I když je text pouze nadpis nebo se zdá neúplný, přeložte jej tak, jak je.\n","description":"Podrobný průvodce ruční instalací I2P a jeho závislostí na macOS","id":"f88100195c365b18735e1ea12826a97e","section":"docs","title":"Instalace I2P na macOS (Dlouhá cesta)","url":"/cs/docs/guides/instalace-i2p-na-macos-dlouh%C3%A1-cesta/"},{"categories":null,"content":"Zvolte způsob instalace Existují dva způsoby, jak nainstalovat I2P na Windows. Vyberte metodu, která nejlépe vyhovuje vašim potřebám:\nNEKLADEŤE otázky, neposkytujte vysvětlení ani nepřidávejte žádné komentáře. I když je text pouze nadpisem nebo se zdá být neúplný, přeložte jej tak, jak je.\n🚀 Easy Install Bundle (Recommended) Nejlepší pro většinu uživatelů\n✅ Instalátor vše v jednom ✅ Java je součástí (není třeba samostatná instalace) ✅ Profily Firefoxu jsou součástí ✅ Nejrychlejší nastavení\nVyberte tuto možnost, pokud: - Chcete nejjednodušší instalaci - Nemáte nainstalovanou Javu - Jste v I2P začátečník\nPrůvodce snadnou instalací →\nNEPTEJTE se, nevysvětlujte ani nepřidávejte žádné komentáře. I pokud je text pouze nadpisem nebo se zdá neúplný, přeložte jej tak, jak je.\n🚀 Snadná instalace (Doporučeno) Pro pokročilé uživatele\n📦 Instalátor JAR založený na Javě 🔧 Větší kontrola nad instalací 💾 Menší velikost ke stažení\nZvolte tuto možnost pokud: - Již máte nainstalovanou Javu - Chcete větší kontrolu - Dáváte přednost tradiční metodě\nPrůvodce standardní instalací →\nNEPTEJTE se, neposkytujte vysvětlení ani nepřidávejte žádné komentáře. I když je text jen nadpis nebo se zdá neúplný, přeložte jej tak, jak je.\nEasy Install Bundle ⚙️ Standardní instalace I2P Easy Install Bundle je doporučená instalační metoda pro uživatele Windows. Tento komplexní instalátor obsahuje vše, co potřebujete pro začátek s I2P:\nI2P Router - Základní software I2P Vestavěné Java Runtime - Není nutná samostatná instalace Javy Profily a rozšíření pro Firefox - Pro I2P optimalizované profily prohlížeče a rozšíření pro bezpečné prohlížení Jednoduchý instalátor - Není nutná ruční konfigurace Automatické aktualizace - Udržujte svůj I2P software aktuální Tento beta instalátor zjednodušuje proces instalace tím, že přímo obsahuje Javu, takže není potřeba stahovat nebo konfigurovat Javu samostatně.\nNEKLATTE otázky, neposkytujte vysvětlení ani nepřidávejte žádné komentáře. I když je text pouze nadpis nebo se zdá neúplný, přeložte jej tak, jak je.\nStep 1: Select Your Language Po spuštění instalátoru Easy Install Bundle se zobrazí obrazovka pro výběr jazyka.\nVyberte si preferovaný jazyk z rozbalovací nabídky K dispozici jsou jazyky včetně angličtiny, němčiny, španělštiny, francouzštiny a mnoha dalších Klikněte na OK pro pokračování Rozhraní instalačního programu použije vámi vybraný jazyk pro všechny následující kroky.\nI\u0026rsquo;d be happy to help translate I2P documentation to Czech, but I notice the text content between the dashes appears to be empty. Could you please provide the actual text you\u0026rsquo;d like me to translate?\nBalíček pro snadnou instalaci Dále se vám zobrazí licenční informace I2P. Easy Install Bundle obsahuje komponenty pod různými svobodnými a open-source licencemi.\nPokračování v instalaci: 1. Prostudujte si licenční informace (volitelné, ale doporučené) 2. Klikněte na Souhlasím pro přijetí licencí a pokračování 3. Klikněte na Zrušit, pokud si nepřejete instalovat\nNEPOKLÁDEJTE otázky, neposkytujte vysvětlení ani nepřidávejte žádné komentáře. I když je text pouze nadpisem nebo se zdá neúplný, přeložte jej tak, jak je.\nStep 3: Choose Installation Folder Nyní vyberete, kam nainstalovat I2P na váš počítač.\nMožnosti instalace:\nPoužít výchozí umístění (doporučeno)\nVýchozí cesta: C:\\Users\\[YourUsername]\\AppData\\Local\\I2peasy\\ Tímto se I2P nainstaluje do adresáře vašeho uživatelského profilu Pro aktualizace nejsou vyžadována oprávnění správce Zvolte vlastní umístění\nKlikněte na Procházet\u0026hellip; pro výběr jiné složky Užitečné, pokud chcete instalovat na jiný disk Ujistěte se, že máte oprávnění k zápisu do vybrané složky Požadavky na místo na disku: - Instalátor zobrazuje, kolik místa je potřeba (obvykle méně než 1 GB) - Ověřte, že máte dostatek volného místa na vybraném disku\nKlikněte na Install pro zahájení instalačního procesu Instalátor nyní zkopíruje všechny potřebné soubory do vybraného umístění. Může to trvat několik minut.\nDŮLEŽITÉ: Poskytněte POUZE překlad. NEPOKLÁDEJTE otázky, neposkytujte vysvětlení ani nepřidávejte žádné komentáře. I když je text pouze nadpis nebo se zdá neúplný, přeložte ho tak, jak je.\nKrok 1: Vyberte svůj jazyk Po dokončení instalace se zobrazí dokončovací obrazovka.\nPrůvodce instalací potvrzuje, že „I2P - i2peasy byl nainstalován do vašeho počítače.\u0026quot;\nDůležité: Ujistěte se, že je zaškrtnuto políčko \u0026ldquo;Start I2P?\u0026rdquo; (mělo by být zaškrtnuto ve výchozím nastavení).\nZaškrtnuto (doporučeno): I2P se spustí automaticky po kliknutí na Dokončit Nezaškrtnuto: I2P budete muset spustit ručně později z nabídky Start nebo zástupce na ploše Klikněte na Dokončit pro dokončení instalace a spuštění I2P.\nNEPTEJTE se na otázky, neposkytujte vysvětlení ani nepřidávejte žádné komentáře. I když je text pouze nadpisem nebo se zdá neúplný, přeložte jej tak, jak je.\nKrok 2: Přijměte licenční smlouvu Po kliknutí na Dokončit se zaškrtnutou volbou „Spustit I2P?\u0026quot;:\nI2P Router se spustí - I2P router začne běžet na pozadí Zobrazí se ikona v systémové liště - Vyhledejte ikonu I2P ve vaší systémové liště Windows (pravý dolní roh) Otevře se konzole routeru - Váš výchozí webový prohlížeč se automaticky otevře na I2P Router Console (typicky na http://127.0.0.1:7657) Počáteční připojení - I2P začne navazovat spojení se sítí a budovat tunnely (při prvním spuštění to může trvat 5-10 minut) Gratulujeme! I2P je nyní nainstalováno a spuštěno na vašem počítači se systémem Windows.\nI2P I2P je softwarová vrstva, která umožňuje aplikacím posílat zprávy anonymně a bezpečně pomocí koncových šifer mezi poskytovateli koncových bodů. Návštěvníci webu mohou být anonymní vůči operátorům webů a naopak.\nKrok 3: Zvolte instalační složku Ačkoli to není striktně vyžadováno, přesměrování portů výrazně vylepšuje vaši práci s I2P, protože umožňuje vašemu routeru komunikovat efektivněji s ostatními I2P routery. Bez přesměrování portů budete moci I2P stále používat, ale s nižším výkonem a menším přínosem pro síť.\nWhy Forward a Port? Lepší konektivita: Umožňuje příchozí spojení od ostatních I2P routerů Rychlejší integrace: Pomáhá vám rychleji se integrovat do sítě Přínos pro síť: Dělá z vás lepšího účastníka sítě I2P Vylepšený výkon: Obecně vede k lepší spolehlivosti a rychlosti tunelů Co je Easy Install Bundle? Nejprve musíte zjistit, který port I2P používá (ve výchozím nastavení je náhodně přiřazen).\nNajděte ikonu I2P v oblasti oznámení Windows (system tray) v pravém dolním rohu obrazovky Klikněte pravým tlačítkem na ikonu I2P pro otevření kontextové nabídky Klikněte na \u0026ldquo;Launch I2P Browser\u0026rdquo; pro otevření konzole I2P routeru Menu také zobrazuje užitečné možnosti jako: - Network: Firewalled - Zobrazuje aktuální stav sítě - Configure I2P System Tray - Přizpůsobení nastavení ikony v systémové liště - Stop I2P / Stop I2P Immediately - Možnosti vypnutí\nFinding Your Port Numbers Jakmile se otevře I2P prohlížeč, je potřeba zkontrolovat, které porty I2P používá:\nPřejděte na stránku konfigurace sítě:\nV prohlížeči otevřete I2P Router Network Configuration Nebo z postranního panelu konzole routeru: Konfigurace → Síť Posuňte se dolů do sekce konfigurace portů\nPoznamenejte si čísla portů, která se zobrazí: Konfigurace UDP: - UDP port: Port zobrazený zde (příklad: 13697) - Ve výchozím nastavení je nastaven na \u0026ldquo;Specify Port\u0026rdquo; s náhodně přiřazeným číslem\nKonfigurace TCP: - Externě dostupný TCP port: Obvykle nastaven na použití stejného portu jako UDP - V příkladu výše: \u0026ldquo;Použít stejný port nakonfigurovaný pro UDP (aktuálně 13697)\u0026rdquo;\nDůležité: Musíte přesměrovat UDP i TCP na stejném čísle portu (v tomto příkladu port 13697) ve vašem routeru/firewallu.\nHow to Forward Your Port Protože každý router a firewall je jiný, nemůžeme poskytnout univerzální návod. Nicméně portforward.com nabízí podrobné návody pro tisíce modelů routerů:\nNavštivte portforward.com Vyberte výrobce a model vašeho routeru Postupujte podle podrobného průvodce pro přesměrování portu Přesměrujte oba protokoly UDP i TCP na čísle portu zobrazeném ve vaší konfiguraci I2P Obecné kroky (liší se podle routeru): - Přihlaste se do administračního rozhraní vašeho routeru (obvykle na 192.168.1.1 nebo 192.168.0.1) - Najděte sekci \u0026ldquo;Přesměrování portů\u0026rdquo; nebo \u0026ldquo;Virtuální servery\u0026rdquo; - Vytvořte nové pravidlo pro přesměrování portů pro číslo vašeho I2P portu - Nastavte protokoly UDP i TCP - Nasměrujte pravidlo na lokální IP adresu vašeho počítače - Uložte konfiguraci\nPo přesměrování portu by se I2P mělo změnit z \u0026ldquo;Network: Firewalled\u0026rdquo; na \u0026ldquo;Network: OK\u0026rdquo; v menu systémové lišty (může to trvat několik minut).\nI2P I2P je anonymní síť overlay - síť v rámci sítě. Je určena k ochraně komunikace před drakonickým dohledem a monitorováním třetích stran, jako jsou poskytovatelé internetového připojení.\nJak I2P funguje I2P používá několik vrstev šifrování k ochraně síťové komunikace. Data jsou směrována přes několik uzlů v síti I2P, přičemž každý uzel odstraní jednu vrstvu šifrování, dokud data nedorazí do cíle. Tímto způsobem žádný jednotlivý uzel nezná jak zdroj, tak cíl dat.\nKrok 4: Dokončete instalaci a spusťte I2P Počkejte na integraci: Dejte I2P 5-10 minut na integraci do sítě a vybudování tunnelů Nakonfigurujte svůj prohlížeč: Použijte přiložený Firefox profil pro procházení I2P Přesměrujte svůj port: Navštivte portforward.com pro instrukce specifické pro váš router, jak přesměrovat port, který I2P používá Prozkoumejte router console: Seznamte se s funkcemi, službami a možnostmi konfigurace I2P Navštivte eepsites: Zkuste přistupovat k webovým stránkám s doménou .i2p prostřednictvím sítě I2P Přečtěte si dokumentaci: Prohlédněte si dokumentaci I2P pro více informací Vítejte v síti I2P! 🎉\nNEKLADEJTĚ otázky, neposkytujte vysvětlení ani nepřidávejte žádné komentáře. I pokud je text pouze nadpis nebo se zdá neúplný, přeložte jej tak, jak je.\nCo se stane dále What is the Standard Installation? Standardní instalace I2P je tradiční metoda instalace I2P na Windows. Na rozdíl od Easy Install Bundle tato metoda vyžaduje:\nNainstalujte Javu samostatně - Před instalací I2P si stáhněte a nainstalujte Java Runtime Environment (JRE) Spusťte JAR instalátor - Použijte grafický instalátor založený na Javě Nakonfigurujte ručně - Nastavte konfigurace prohlížeče sami (volitelné) Tato metoda je doporučena pro: - Uživatele, kteří již mají nainstalovanou Javu - Pokročilé uživatele, kteří chtějí větší kontrolu nad instalací - Uživatele, kteří upřednostňují tradiční metodu instalace - Systémy, kde není Easy Install Bundle kompatibilní\nDoporučeno: Přesměrování portů (volitelné, ale důležité) Před instalací I2P je nutné mít v systému nainstalovanou Javu.\nJava Requirements Verze Java: vyžadována Java 8 (1.8) nebo vyšší Doporučeno: Java 11 nebo novější (LTS verze) Typ: Java Runtime Environment (JRE) nebo Java Development Kit (JDK) Installing Java Pokud ještě nemáte nainstalovanou Javu, můžete si ji stáhnout z několika zdrojů:\nMožnost 1: Oracle Java - Oficiální zdroj: java.com/download - Nejrozšířenější distribuce\nMožnost 2: OpenJDK - Open-source implementace: openjdk.org - Zdarma a open-source\nMožnost 3: Adoptium (Eclipse Temurin) - Doporučená alternativa: adoptium.net - Bezplatné, open-source a dobře udržované LTS verze\nOvěření instalace Javy: 1. Otevřete příkazový řádek (stiskněte Windows + R, napište cmd, stiskněte Enter) 2. Napište: java -version 3. Měli byste vidět výstup zobrazující vaši verzi Javy\nNEPTEJTE se na otázky, neposkytujte vysvětlení ani nepřidávejte žádné komentáře. I když je text jen nadpisem nebo se zdá neúplný, přeložte jej tak, jak je.\nStep 1: Install Java Před instalací I2P je nutné na váš systém nainstalovat Javu.\nVyberte distribuci Javy:\nOracle Java: java.com/download OpenJDK: openjdk.org Adoptium: adoptium.net Stáhněte si instalátor pro Windows pro vámi zvolenou distribuci\nSpusťte instalátor a postupujte podle pokynů k instalaci\nOvěřte instalaci:\nOtevřete Příkazový řádek Zadejte java -version a stiskněte Enter Ověřte, že je nainstalována Java 8 nebo vyšší Jakmile je Java nainstalována, jste připraveni nainstalovat I2P.\nNEPOKLÁDEJTE otázky, neposkytujte vysvětlení ani nepřidávejte žádné komentáře. I když je text pouze nadpis nebo se zdá nekompletní, přeložte jej tak, jak je.\nStep 2: Download and Launch the I2P Installer Stáhněte instalátor I2P:\nNavštivte stránku ke stažení I2P Stáhněte instalátor pro Windows (soubor JAR): i2pinstall_X.X.X.jar Uložte jej na místo, kde jej snadno najdete (např. složka Stažené soubory) Spusťte instalátor:\nDvojklikem spusťte stažený soubor JAR a otevřete instalátor Pokud dvojklik nefunguje, klikněte pravým tlačítkem na soubor a vyberte „Otevřít v programu → Java(TM) Platform SE binary\u0026quot; Alternativně otevřete Příkazový řádek a spusťte: java -jar i2pinstall_X.X.X.jar Step 3: Select Your Language Po spuštění instalátoru se zobrazí dialog pro výběr jazyka.\nVyberte váš preferovaný jazyk z rozbalovací nabídky Dostupné jazyky zahrnují angličtinu, němčinu, španělštinu, francouzštinu a mnoho dalších Klikněte na OK pro pokračování Instalátor bude pro všechny následující kroky používat vámi vybraný jazyk.\nKonfigurace I2PTunnel I2PTunnel je flexibilní systém tunelování postavený na I2P, který vám umožňuje provozovat služby skryté uvnitř I2P sítě nebo přistupovat k nim. Tato příručka pokrývá základní koncept a pokročilé možnosti konfigurace.\nZákladní koncept I2PTunnel funguje jako proxy mezi běžnými síťovými protokoly (HTTP, IRC, SOCKS atd.) a I2P sítí. Může fungovat ve dvou režimech:\nKlientské tunely – přeposílají místní připojení na vzdálený I2P destination Serverové tunely – zpřístupňují místní služby jako I2P služby (eepsite) Vytvoření klientského tunelu Klientský tunel vám umožňuje přistupovat ke službám uvnitř I2P z vašeho prohlížeče nebo aplikace.\nOtevřete konzoli routeru (obvykle http://127.0.0.1:7657) Přejděte na I2PTunnel Klikněte na Nový klientský tunel Vyberte typ (HTTP, IRC, SOCKS atd.) Zadejte: Název tunelu Lokální port (např. 4444) Cílový destination (.i2p adresa nebo Base64 klíč) Uložte a spusťte tunel Vytvoření serverového tunelu Serverový tunel zveřejňuje vaši lokální službu jako hidden service v I2P.\nOtevřete I2PTunnel v konzoli routeru Klikněte na Nový serverový tunel Vyberte typ (HTTP, IRC, Standard atd.) Zadejte: Název tunelu Lokální host (obvykle 127.0.0.1) Lokální port (port vaší služby) Konfigurujte nastavení tunelu (viz níže) Uložte a spusťte – váš destination klíč bude vygenerován automaticky Pokročilá nastavení tunelu Počet hopů (délka tunelu) Určuje počet routerů v tunelu. Větší počet = větší anonymita, ale pomalejší rychlost.\nDélka: 0-7 hopů (výchozí: 3 pro odchozí, 3 pro příchozí) Variance: náhodná odchylka délky (výchozí: 0) Počet tunelů Více paralelních tunelů může zvýšit propustnost a spolehlivost.\nMnožství: 1-6 tunelů (výchozí: 2-3 podle typu) Záloha: dodatečné tunely v pohotovosti Šířka pásma Kontroluje alokaci šířky pásma pro tento tunel.\nSdílet šířku pásma: rozdělit pásmo mezi všechny tunely (doporučeno) Priorita: nízká, normální, vysoká Šifrování a podpisy Typ šifrování: ELGAMAL_2048 (starší) nebo ECIES_X25519 (doporučeno) Typ podpisu: EdDSA_SHA512_Ed25519 (výchozí, doporučeno) Persistence Klíčový soubor: určuje umístění pro uložení klíčů destination (pro trvalou identitu) Alternativní destination: použít jiný destination než výchozí Filtrování a přístup Pouze pro serverové tunely:\nWhitelista: povolí pouze určité destination Blacklista: blokuje specifické destination Limitované připojení: maximální počet souběžných připojení Použití proxy Pro klientské tunely – použít odchozí I2P HTTP nebo SOCKS proxy:\nOutproxy: povolí přístup k clearnet přes výstupní uzel (použijte opatrně) Proxy host a port: externí proxy nastavení Nejlepší postupy Používejte ECIES_X25519 šifrování pro nové tunely (lepší výkon) Nenastavujte délku tunelu příliš vysoko – 3 hopy poskytují dobrý kompromis Zálohujte soubory klíčů svých serverových tunelů pro zachování identity Nepoužívejte outproxy, pokud nerozumíte důsledkům pro soukromí Používejte Auto Close u nepoužívaných tunelů pro úsporu zdrojů Řešení problémů Tunel se nespustí Zkontrolujte, zda port není již používán Ověřte, že I2P router běží Zkontrolujte logy v konzoli routeru Pomalé připojení Snižte délku tunelu Zvyšte počet tunelů Zkontrolujte celkové nastavení šířky pásma v routeru Destination není dosažitelný Ověřte .i2p adresu nebo Base64 klíč Zkontrolujte, zda je vzdálená služba online (I2P služby mohou být občas offline) Počkejte na inicializaci tunelu (může trvat 1-2 minuty) Příklady použití HTTP proxy pro procházení eepsite Typ: HTTP klientský tunel Port: 4444 Destination: výchozí (pro všechny .i2p weby) IRC tunel na Irc2P Typ: IRC klientský tunel Port: 6668 Destination: irc.echelon.i2p (nebo aktuální IRC server) Hostování webové stránky (eepsite) Typ: HTTP serverový tunel Host: 127.0.0.1 Port: 8080 (váš lokální webserver) Pro více informací navštivte oficiální dokumentaci I2P .\nStep 4: Welcome to I2P Installation Toto je Krok 1 z 8 v procesu instalace.\nKlikněte na Next pro pokračování instalace.\nKonfigurace Níže naleznete některé základní příklady konfigurace pro I2P. Pro podrobnější informace se podívejte do dokumentace .\nRychlý start Po instalaci I2P se routeru obvykle trvá několik minut, než se integruje do sítě. Buďte trpěliví a sledujte konzolu routeru, aby se váš router plně nastartoval.\nŠířka pásma Je důležité správně nastavit vaše omezení šířky pásma, aby router fungoval optimálně. Pokud nastavíte příliš vysoké hodnoty, bude váš router nestabilní. Pokud nastavíte příliš nízké hodnoty, nebudete efektivně využívat vaše připojení.\nDobrým pravidlem je nastavit vaši sdílenou šířku pásma na 75 % vaší dostupné šířky pásma.\nPorty Pokud jste za firewallem nebo NATem, měli byste přesměrovat příchozí porty do vašeho I2P routeru. Defaultně I2P používá port 12345 pro NTCP2 a náhodný port pro SSU.\nMůžete nastavit vaše porty v konzole routeru pod \u0026ldquo;Konfigurace sítě\u0026rdquo;.\nDalší kroky Toto je Krok 2 z 8 v procesu instalace.\nKlikněte na Next (Další) pro přijetí licence a pokračování.\nI2P Protokoly Standardní instalace Vyberte, kam chcete na svém počítači nainstalovat I2P.\nVýchozí instalační cesta: C:\\Program Files (x86)\\i2p\\\nMůžete buď: - Použít výchozí umístění (doporučeno) - Kliknout na Procházet\u0026hellip; a vybrat jinou složku\nToto je Krok 3 z 8 v procesu instalace.\nKlikněte na Další pro pokračování.\nPoznámka: Pokud instalujete I2P poprvé, zobrazí se vyskakovací okno potvrzující vytvoření adresáře:\nKlikněte na OK pro vytvoření instalačního adresáře.\nNEPTEJTE se na otázky, nevysvětlujte ani nepřidávejte žádné komentáře. I pokud je text jen nadpis nebo se zdá neúplný, přeložte jej tak, jak je.\nStep 7: Select Installation Packs Vyberte, které komponenty chcete nainstalovat.\nDůležité: Ujistěte se, že jsou vybrány oba balíčky: - Base (vyžadováno) - Základní software I2P (27,53 MB) - Windows Service (doporučeno) - Automatické spuštění I2P při startu systému\nMožnost Windows Service zajišťuje, že se I2P spustí automaticky při startu počítače, takže ji nemusíte pokaždé spouštět ručně.\nToto je krok 4 z 8 v procesu instalace.\nKlikněte na Další pro pokračování.\nDŮLEŽITÉ: Poskytněte POUZE překlad. NEPOKLÁDEJTE otázky, neposkytujte vysvětlení ani nepřidávejte žádné komentáře. I když je text pouze nadpis nebo se zdá neúplný, přeložte ho tak, jak je.\nPředpoklady Instalátor nyní zkopíruje soubory do vašeho systému.\nUvidíte dva indikátory průběhu: - Průběh instalace balíčku: Zobrazuje právě instalovaný balíček - Celkový průběh instalace: Zobrazuje celkový průběh (např. „2 / 2\u0026quot;)\nToto je Krok 5 z 8 instalačního procesu.\nPočkejte na dokončení instalace a poté klikněte na Další.\nPokročilé Step 9: Setup Shortcuts Nakonfigurujte, kam chcete vytvořit zástupce I2P.\nMožnosti zástupců: - ✓ Vytvořit zástupce v nabídce Start (doporučeno) - ✓ Vytvořit další zástupce na ploše (volitelné)\nSkupina programů: Vyberte nebo vytvořte název složky pro zástupce - Výchozí: I2P - Můžete zvolit existující skupinu programů nebo vytvořit novou\nVytvořit zástupce pro: - Aktuálního uživatele - Pouze vy můžete přistupovat k zástupci - Všechny uživatele - Všichni uživatelé v systému mohou přistupovat k zástupci (vyžaduje oprávnění správce)\nToto je Krok 6 z 8 v procesu instalace.\nKlikněte na Další pro pokračování.\nStep 10: Installation Complete Instalace je nyní dokončena!\nUvidíte: - ✓ Instalace byla úspěšně dokončena - Odinstalační program bude vytvořen v: C:\\Program Files (x86)\\i2p\\Uninstaller\nToto je Krok 8 z 8 - závěrečný krok procesu instalace.\nKlikněte na Done pro dokončení.\nI2P konference Krok 1: Instalace Javy Po kliknutí na Hotovo:\nI2P Router se spustí - Pokud jste nainstalovali službu Windows, I2P se spustí automaticky Otevře se konzole routeru - Váš výchozí webový prohlížeč otevře I2P Router Console na adrese http://127.0.0.1:7657 Počáteční připojení - I2P začne připojovat k síti a budovat tunnely (při prvním spuštění to může trvat 5-10 minut) Gratulujeme! I2P je nyní nainstalováno na vašem počítači s Windows.\nNEKLADTE otázky, neposkytujte vysvětlení ani nepřidávejte žádné komentáře. I když je text pouze nadpis nebo se zdá být neúplný, přeložte ho tak, jak je.\nKrok 2: Stažení a spuštění instalátoru I2P Pokud se I2P nespustí automaticky, nebo pokud jej budete potřebovat v budoucnu spustit ručně, máte dvě možnosti:\nOption 1: Start Menu Otevřete nabídku Start ve Windows Přejděte do složky I2P Zvolte jednu z možností spuštění: I2P router console - Otevře konzoli routeru ve vašem prohlížeči Start I2P (no window) - Spustí I2P tiše na pozadí Start I2P (restartable) - Spustí I2P s možností automatického restartování Můžete také přistupovat k Otevřít složku profilu I2P (služba) pro zobrazení konfiguračních souborů I2P.\nProč přeposílat port? Stiskněte Windows + R pro otevření dialogu Spustit Zadejte services.msc a stiskněte Enter Sjeďte dolů a najděte I2P Service Klikněte pravým tlačítkem na I2P Service a vyberte: Start - Spustit službu I2P Stop - Zastavit službu I2P Restart - Restartovat službu I2P Properties - Konfigurovat nastavení služby (typ spuštění atd.) Metoda Windows Services je užitečná pro správu I2P jako služby na pozadí, zejména pokud jste ji nainstalovali jako Windows Service.\nKrok 3: Vyberte svůj jazyk Počkejte na integraci: Dejte I2P 5-10 minut na integraci do sítě a vybudování tunelů Nakonfigurujte přesměrování portů: Pokyny naleznete v průvodci přesměrováním portů Nakonfigurujte svůj prohlížeč: Nastavte webový prohlížeč pro použití HTTP proxy I2P Prozkoumejte konzoli routeru: Seznamte se s funkcemi, službami a možnostmi konfigurace I2P Navštivte eepsites: Zkuste přistupovat k webovým stránkám .i2p prostřednictvím sítě I2P Přečtěte si dokumentaci: Pro více informací se podívejte na dokumentaci I2P Vítejte v síti I2P! 🎉\n","description":"Vyberte si metodu instalace pro Windows: Easy Install Bundle nebo Standardní instalace","id":"4aa0b74199a71c11718a9986e74b3a26","section":"docs","title":"Instalace I2P na Windows","url":"/cs/docs/guides/instalace-i2p-na-windows/"},{"categories":null,"content":"I2P plugin framework umožňuje rozšířit router bez zásahu do základní instalace. Dostupné pluginy pokrývají e-mail, blogy, IRC, úložiště, wiki, monitorovací nástroje a další.\nBezpečnostní upozornění: Pluginy běží se stejnými oprávněními jako router. Zacházejte se staženými soubory od třetích stran stejně, jako byste zacházeli s jakoukoli aktualizací podepsaného softwaru—před instalací ověřte zdroj.\n1. Instalace pluginu Zkopírujte URL pro stažení pluginu ze stránky projektu.\nOtevřete stránku konfigurace pluginů v konzoli routeru.\nVložte URL do pole pro instalaci a klikněte na Install Plugin.\nRouter stáhne podepsaný archiv, ověří podpis a plugin aktivuje okamžitě. Většina pluginů přidá odkazy v konzoli nebo služby na pozadí, aniž by vyžadovala restart routeru.\n2. Proč na pluginech záleží Distribuce jedním kliknutím pro koncové uživatele—žádné ruční úpravy wrapper.config nebo clients.config Udržuje základní balík i2pupdate.su3 malý a zároveň poskytuje velké nebo specializované funkce na vyžádání Volitelné JVM per plugin poskytují izolaci procesů v případě potřeby Automatické kontroly kompatibility s verzí routeru, Java runtime a Jetty Aktualizační mechanismus zrcadlí router: podepsané balíčky a inkrementální stahování Podporovány jsou console integrace, jazykové balíčky, UI témata a aplikace mimo Javu (přes skripty) Umožňuje kurátorované adresáře „app store\u0026quot;, jako je plugins.i2p 3. Správa nainstalovaných pluginů Použijte ovládací prvky na stránce I2P Router Plugin k:\nZkontrolovat aktualizace jednoho pluginu Zkontrolovat všechny pluginy najednou (spouští se automaticky po aktualizaci routeru) Nainstalovat všechny dostupné aktualizace jedním kliknutím\nPovolit/zakázat automatické spuštění pro pluginy, které registrují služby Čistě odinstalovat pluginy 4. Vytvořte si vlastní plugin Projděte si specifikaci pluginu pro požadavky na balíčkování, podepisování a metadata. Použijte makeplugin.sh k zabalení existujícího binárního souboru nebo webové aplikace do instalovatelného archivu. Zveřejněte URL adresy pro instalaci i aktualizaci, aby router mohl rozlišit mezi první instalací a postupnými upgrady. Umístěte kontrolní součty a podpisové klíče viditelně na stránku vašeho projektu, abyste pomohli uživatelům ověřit autenticitu. Hledáte příklady? Prohlédněte si zdrojový kód komunitních pluginů na plugins.i2p (například ukázku snowman).\n5. Známá omezení Aktualizace pluginu, který obsahuje běžné JAR soubory, může vyžadovat restart routeru, protože Java class loader cachuje třídy. Konzole může zobrazovat tlačítko Stop, i když plugin nemá žádný aktivní proces. Pluginy spuštěné v samostatném JVM vytvoří adresář logs/ v aktuálním pracovním adresáři. Při prvním výskytu je klíč podepisujícího automaticky důvěryhodný; neexistuje žádná centrální autorita pro podepisování. Windows někdy zanechává po odinstalaci pluginu prázdné adresáře. Instalace pluginu určeného pouze pro Java 6 na JVM Java 5 hlásí „plugin je poškozený\u0026quot; kvůli kompresi Pack200. Pluginy pro témata a překlady zůstávají z velké části netestované. Příznaky automatického startu ne vždy přetrvávají u nespravovaných pluginů. 6. Požadavky a doporučené postupy Podpora pluginů je dostupná v I2P 0.7.12 a novějších verzích. Udržujte svůj router a pluginy aktuální, abyste získali bezpečnostní opravy. Dodávejte stručné poznámky k vydání, aby uživatelé pochopili, co se mezi verzemi změnilo. Pokud je to možné, hostujte archivy pluginů přes HTTPS uvnitř I2P, abyste minimalizovali vystavení metadat v čisté síti. 7. Další čtení Specifikace pluginů Framework klientských aplikací Repozitář I2P skriptů pro balíčkovací utility ","description":"Instalace, aktualizace a vývoj pluginů routeru","id":"f8687b90431c32a8ee7e10be9f7c44e0","section":"docs","title":"Instalace vlastních pluginů","url":"/cs/docs/guides/plugins/"},{"categories":null,"content":"Přehled Klíčové body\nI2P poskytuje end-to-end šifrování pro IRC provoz skrze své tunely. Vypněte SSL/TLS v IRC klientech, pokud nepoužíváte outproxy do clearnetu. Předkonfigurovaný Irc2P klientský tunel poslouchá na 127.0.0.1:6668 ve výchozím nastavení. Připojte svého IRC klienta na tuto adresu a port. Nepoužívejte termín \u0026ldquo;router‑provided TLS.\u0026rdquo; Používejte \u0026ldquo;nativní šifrování I2P\u0026rdquo; nebo \u0026ldquo;end‑to‑end šifrování.\u0026rdquo; Rychlý start (Java I2P) Otevřete Hidden Services Manager na adrese http://127.0.0.1:7657/i2ptunnel/ a ujistěte se, že tunel Irc2P je spuštěný. Ve svém IRC klientovi nastavte server = 127.0.0.1, port = 6668, SSL/TLS = vypnuto. Připojte se a vstupte do kanálů jako #i2p, #i2p-dev, #i2p-help. Pro uživatele i2pd (router v C++), vytvořte klientský tunnel v souboru tunnels.conf (viz příklady níže).\nSítě a servery IRC2P (main community network) Federované servery: irc.postman.i2p:6667, irc.echelon.i2p:6667, irc.dg.i2p:6667. Tunel Irc2P na 127.0.0.1:6668 se připojuje k jednomu z těchto serverů automaticky. Typické kanály: #i2p, #i2p-chat, #i2p-dev, #i2p-help. Ilita network Servery: irc.ilita.i2p:6667, irc.r4sas.i2p:6667, irc.acetone.i2p:6667, rusirc.ilita.i2p:6667. Primární jazyky: ruština a angličtina. Na některých hostitelích existují webová rozhraní. Client setup Recommended, actively maintained WeeChat (terminál) — silná podpora SOCKS; snadné skriptování. Pidgin (desktop) — stále udržovaný; dobře funguje pro Windows/Linux. Thunderbird Chat (desktop) — podporováno v ESR 128+. The Lounge (self‑hosted web) — moderní webový klient. IRC2P (hlavní komunitní síť) LimeChat (zdarma, open source). Textual (placená v App Store; zdrojový kód dostupný ke kompilaci). Síť Ilita WeeChat via SOCKS5 /proxy add i2p socks5 127.0.0.1 4447 /set irc.server.i2p.addresses \u0026#34;127.0.0.1/6668\u0026#34; /set irc.server.i2p.proxy \u0026#34;i2p\u0026#34; /connect i2p Pidgin Protokol: IRC Server: 127.0.0.1 Port: 6668 Šifrování: vypnuto Uživatelské jméno/přezdívka: libovolné Thunderbird Chat Typ účtu: IRC Server: 127.0.0.1 Port: 6668 SSL/TLS: vypnuto Volitelné: automatické připojení ke kanálům při navázání spojení Dispatch (SAM v3) Příklad výchozích hodnot config.toml:\n[defaults] name = \u0026#34;Irc2P\u0026#34; host = \u0026#34;irc.postman.i2p\u0026#34; port = 6667 channels = [\u0026#34;#i2p\u0026#34;,\u0026#34;#i2p-dev\u0026#34;] ssl = false Tunnel configuration Java I2P defaults Irc2P klientský tunel: 127.0.0.1:6668 → upstream server na portu 6667. Hidden Services Manager: http://127.0.0.1:7657/i2ptunnel/. Doporučené, aktivně udržované ~/.i2pd/tunnels.conf:\n[IRC-IRC2P] type = client address = 127.0.0.1 port = 6668 destination = irc.postman.i2p destinationport = 6667 keys = irc-keys.dat Samostatný tunel pro Ilitu (příklad):\n[IRC-ILITA] type = client address = 127.0.0.1 port = 6669 destination = irc.ilita.i2p destinationport = 6667 keys = irc-ilita-keys.dat Možnosti pro macOS Povolit SAM v Java I2P (ve výchozím nastavení vypnuto) na /configclients nebo clients.config. Výchozí hodnoty: 127.0.0.1:7656/TCP a 127.0.0.1:7655/UDP. Doporučená kryptografie: SIGNATURE_TYPE=7 (Ed25519) a i2cp.leaseSetEncType=4,0 (ECIES‑X25519 s ElGamal fallbackem) nebo pouze 4 pro výhradně moderní. Příklady konfigurací Java I2P výchozí: 2 příchozí / 2 odchozí. i2pd výchozí: 5 příchozích / 5 odchozích. Pro IRC: 2–3 každý je dostačující; nastavte explicitně pro konzistentní chování napříč routery. Nastavení klienta Nepovolujte SSL/TLS pro interní I2P IRC připojení. I2P již poskytuje end‑to‑end šifrování. Dodatečné TLS přidává režii bez přínosu pro anonymitu. Používejte trvalé klíče pro stabilní identitu; vyhněte se opětovnému generování klíčů při každém restartu, pokud netestujete. Pokud více aplikací používá IRC, preferujte samostatné tunnely (nesdílené), abyste snížili korelaci mezi službami. Pokud musíte povolit vzdálené ovládání (SAM/I2CP), svažte na localhost a zabezpečte přístup pomocí SSH tunnelů nebo autentizovaných reverse proxy. Alternative connection method: SOCKS5 Někteří klienti se mohou připojit přes I2P SOCKS5 proxy: 127.0.0.1:4447. Pro nejlepší výsledky preferujte dedikovaný IRC client tunnel na portu 6668; SOCKS nemůže sanitizovat identifikátory aplikační vrstvy a může uniklé informace, pokud klient není navržen pro anonymitu.\nTroubleshooting Nelze se připojit — ujistěte se, že tunel Irc2P běží a router je plně zabootstrapován. Zamrzne při resolve/join — znovu zkontrolujte, že SSL je vypnuto a klient směřuje na 127.0.0.1:6668. Vysoká latence — I2P má záměrně vyšší latenci. Udržujte počet tunelů rozumný (2–3) a vyhněte se rychlým smyčkám opětovného připojení. Používání SAM aplikací — potvrďte, že SAM je povolen (Java) nebo není blokován firewallem (i2pd). Dlouhodobé relace jsou doporučeny. Appendix: Ports and naming Běžné porty IRC tunelů: 6668 (výchozí pro Irc2P), 6667 a 6669 jako alternativy. .b32.i2p hostnames: standardní forma 52 znaků; existují rozšířené formy s 56+ znaky pro LS2/pokročilé certifikáty. Používejte .i2p hostnames, pokud výslovně nepotřebujete b32 adresy. ","description":"Kompletní průvodce I2P IRC sítěmi, klienty, tunely a nastavením serveru (aktualizováno 2025)","id":"f8c49a6509b36124b90dbaa1d0fbbc4b","section":"docs","title":"IRC přes I2P","url":"/cs/docs/applications/irc/"},{"categories":null,"content":" Historická poznámka: Tato stránka pro referenci uchovává starší diskusi „Unidirectional Tunnels“. Pro aktuální chování nahlédněte do aktivní dokumentace implementace tunnel .\nPřehled I2P vytváří jednosměrné tunnels: jeden tunnel přenáší odchozí provoz a samostatný tunnel přenáší příchozí odpovědi. Tato struktura sahá až k nejranějším návrhům sítě a nadále představuje klíčový odlišující prvek oproti systémům s obousměrnými okruhy, jako je Tor. Pro terminologii a podrobnosti o implementaci viz přehled tunnel a specifikace tunnel .\nKontrola Jednosměrné tunnels udržují provoz požadavků a odpovědí odděleně, takže jakákoli jednotlivá skupina spolupracujících peers (účastníků sítě) pozoruje jen polovinu cesty tam a zpět. Časovací útoky musejí protnout dva pooly tunnelů (odchozí a příchozí) namísto analýzy jediného okruhu, což zvyšuje náročnost korelace. Nezávislé příchozí a odchozí pooly umožňují routers ladit latenci, kapacitu a chování při selháních pro každý směr. Mezi nevýhody patří vyšší složitost správy peers a potřeba udržovat více sad tunnelů pro spolehlivé poskytování služby. Anonymita Článek Hermanna a Grothoffa, I2P je pomalé… a co s tím dělat , analyzuje útoky předchůdce proti jednosměrným tunnels a naznačuje, že odhodlaní protivníci mohou postupem času potvrdit dlouhodobě aktivní uzly. Zpětná vazba komunity upozorňuje, že studie se opírá o specifické předpoklady týkající se trpělivosti protivníka a jeho právních pravomocí a neporovnává tento přístup s časovacími útoky, které dopadají na obousměrné návrhy. Pokračující výzkum a praktické zkušenosti nadále posilují jednosměrné tunnels jako záměrnou volbu pro anonymitu, nikoli jako opomenutí.\n","description":"Historické shrnutí architektury jednosměrného tunnelu v I2P.","id":"37ac13877a690f9c4635959a57451755","section":"docs","title":"Jednosměrné tunnels","url":"/cs/docs/legacy/unidirectional/"},{"categories":null,"content":"Přehled I2CP je nízkoúrovňový řídicí protokol mezi I2P routerem a libovolným klientským procesem. Definuje přísné oddělení odpovědností:\nRouter: Spravuje směrování, kryptografii, životní cykly pro tunnel a operace síťové databáze Klient: Volí parametry anonymity, konfiguruje tunnels a odesílá/přijímá zprávy Veškerá komunikace probíhá přes jediný TCP socket (volitelně obalený protokolem TLS), což umožňuje asynchronní, plně duplexní provoz.\nVerze protokolu: I2CP používá bajt verze protokolu 0x2A (42 v desítkové soustavě), který je odesílán při počátečním navázání spojení. Tento bajt verze zůstal stabilní od vzniku protokolu.\nAktuální stav: Tato specifikace je platná pro verzi routeru 0.9.67 (verzi API 0.9.67), vydanou 2025-09.\nKontext implementace Implementace v Javě Referenční implementace je v Java I2P: - Klientské SDK: i2p.jar balíček - Implementace routeru: router.jar balíček - Javadocs Když klient a router běží ve stejné JVM, zprávy I2CP se předávají jako objekty jazyka Java bez serializace. Externí klienti používají serializovaný protokol přes TCP.\nImplementace v C++ i2pd (C++ I2P router) také externě implementuje I2CP pro klientská připojení.\nKlienti nepsaní v Javě Neexistují žádné známé implementace mimo Javu úplné klientské knihovny I2CP. Aplikace, které nejsou v Javě, by měly místo toho používat protokoly vyšší úrovně:\nSAM (Simple Anonymous Messaging) v3: Soketové rozhraní s knihovnami v různých jazycích BOB (Basic Open Bridge): Jednodušší alternativa k SAM Tyto protokoly vyšší úrovně interně řeší složitost I2CP a také poskytují streamovací knihovnu (pro spojení podobná TCP) a datagramovou knihovnu (pro spojení podobná UDP).\nNavázání spojení 1. TCP spojení Připojte se k portu I2CP routeru: - Výchozí: 127.0.0.1:7654 - Lze konfigurovat v nastavení routeru - Volitelná obalovací vrstva TLS (důrazně doporučeno pro vzdálená připojení)\n2. Protokolový handshake Krok 1: Odešlete bajt verze protokolu 0x2A\nKrok 2: Synchronizace hodin\nClient → Router: GetDateMessage Router → Client: SetDateMessage Router vrací své aktuální časové razítko a řetězec verze I2CP API (od 0.8.7).\nKrok 3: Ověření (pokud je povoleno)\nOd verze 0.9.11 lze autentizaci zahrnout do GetDateMessage prostřednictvím Mapping (mapování) obsahujícího: - i2cp.username - i2cp.password\nOd verze 0.9.16, pokud je ověřování povoleno, musí být dokončeno prostřednictvím GetDateMessage (zpráva GetDate) dříve, než budou odeslány jakékoli jiné zprávy.\nKrok 4: Vytvoření relace\nClient → Router: CreateSessionMessage (contains SessionConfig) Router → Client: SessionStatusMessage (status=Created) Krok 5: Signál připravenosti pro tunnel\nRouter → Client: RequestVariableLeaseSetMessage Tato zpráva indikuje, že byly vytvořeny příchozí tunnels. Router to NEODEŠLE, dokud nebude existovat alespoň jeden příchozí a jeden odchozí tunnel.\nKrok 6: Publikace leaseSet\nClient → Router: CreateLeaseSet2Message V tomto okamžiku je relace plně funkční pro odesílání a přijímání zpráv.\nVzory toků zpráv Odchozí zpráva (klient odesílá na vzdálený cíl) S nastavením i2cp.messageReliability=none:\nClient → Router: SendMessageMessage (nonce=0) [No acknowledgments] Při nastavení i2cp.messageReliability=BestEffort (nejlepší snaha):\nClient → Router: SendMessageMessage (nonce\u0026gt;0) Router → Client: MessageStatusMessage (status=Accepted) Router → Client: MessageStatusMessage (status=Success or Failure) Příchozí zpráva (Router doručuje klientovi) S i2cp.fastReceive=true (výchozí od verze 0.9.4):\nRouter → Client: MessagePayloadMessage [No acknowledgment required] Při i2cp.fastReceive=false (ZASTARALÉ):\nRouter → Client: MessageStatusMessage (status=Available) Client → Router: ReceiveMessageBeginMessage Router → Client: MessagePayloadMessage Client → Router: ReceiveMessageEndMessage Moderní klienti by měli vždy používat rychlý režim příjmu.\nSpolečné datové struktury Hlavička zprávy I2CP Všechny zprávy I2CP používají tuto společnou hlavičku:\n+----+----+----+----+----+----+----+----+ | Body Length (4 bytes) | +----+----+----+----+----+----+----+----+ |Type| Message Body (variable) | +----+----+----+----+----+----+----+----+ Délka těla: 4bajtové celé číslo, pouze délka těla zprávy (nezahrnuje hlavičku) Typ: 1bajtové celé číslo, identifikátor typu zprávy Tělo zprávy: 0+ bajtů, formát se liší podle typu zprávy Limit velikosti zprávy: Přibližně 64 KB maximálně.\nID relace 2bajtové celé číslo, které jedinečně identifikuje relaci na routeru.\nSpeciální hodnota: 0xFFFF označuje \u0026ldquo;žádná relace\u0026rdquo; (používá se pro vyhledávání názvů hostitelů bez navázané relace).\nID zprávy 4bajtové celé číslo generované routerem k jednoznačné identifikaci zprávy v rámci relace.\nDůležité: ID zpráv nejsou globálně jedinečná, pouze jedinečná v rámci relace. Jsou také odlišná od nonce (jednorázová hodnota) generované klientem.\nFormát užitečných dat Užitečná data zprávy jsou komprimována gzipem se standardním 10bajtovým záhlavím gzip: - Začíná: 0x1F 0x8B 0x08 (RFC 1952) - Od verze 0.7.1: Nevyužité části záhlaví gzip obsahují informace o protokolu, from-port a to-port - To umožňuje streamování a datagramy na stejné Destination (cílový identifikátor v I2P)\nŘízení komprese: Nastavte i2cp.gzip=false pro vypnutí komprese (nastaví úroveň komprese gzip na 0). Hlavička gzip je stále zahrnuta, ale s minimální režií komprese.\nStruktura SessionConfig Určuje konfiguraci klientské relace:\n+----------------------------------+ | Destination | +----------------------------------+ | Mapping (configuration options) | +----------------------------------+ | Creation Date | +----------------------------------+ | Signature | +----------------------------------+ Kritické požadavky: 1. Mapping musí být seřazen podle klíče pro ověření podpisu 2. Creation Date musí být v rozmezí ±30 sekund od aktuálního času routeru 3. Signature je vytvořen pomocí SigningPrivateKey (soukromého podepisovacího klíče) objektu Destination (cílové identity)\nOffline podpisy (od verze 0.9.38):\nPokud používáte offline podepisování, musí mapování obsahovat: - i2cp.leaseSetOfflineExpiration - i2cp.leaseSetTransientPublicKey - i2cp.leaseSetOfflineSignature\nSignature se poté vygeneruje dočasným SigningPrivateKey (soukromým klíčem pro podepisování).\nMožnosti konfigurace jádra Konfigurace tunnelu Option Default Description inbound.length 3 Number of hops for inbound tunnels outbound.length 3 Number of hops for outbound tunnels inbound.lengthVariance 0 Random variance in hop count (since 0.7.6) outbound.lengthVariance 0 Random variance in hop count (since 0.7.6) inbound.quantity 2 Number of concurrent inbound tunnels outbound.quantity 2 Number of concurrent outbound tunnels inbound.backupQuantity 0 Standby inbound tunnels (hot spares) outbound.backupQuantity 0 Standby outbound tunnels (hot spares) inbound.allowZeroHop true Allow 0-hop tunnels (disable for full anonymity) outbound.allowZeroHop true Allow 0-hop tunnels (disable for full anonymity) **Poznámky**: - Hodnoty pro `quantity` \u003e 6 vyžadují peery běžící na verzi 0.9.0+ a výrazně zvyšují nároky na zdroje - Nastavte `backupQuantity` na 1-2 pro služby s vysokou dostupností - tunnels s nulovým počtem skoků obětují anonymitu ve prospěch latence, ale jsou užitečné pro testování Zpracování zpráv Option Default Description clientMessageTimeout 60000\u0026nbsp;ms Legacy timeout for message delivery i2cp.messageReliability BestEffort None, BestEffort, or Guaranteed i2cp.fastReceive true Skip ReceiveMessageBegin/End handshake (default since 0.9.4) i2cp.gzip true Enable gzip compression of message payloads outbound.priority 0 Priority for outbound scheduling (-25 to +25) **Spolehlivost zpráv**: - `None`: Žádná potvrzení od routeru (výchozí nastavení streamovací knihovny od verze 0.8.1) - `BestEffort`: Router posílá informaci o přijetí + oznámení o úspěchu/neúspěchu - `Guaranteed`: Neimplementováno (aktuálně se chová jako BestEffort) Přebití pro jednotlivé zprávy (od verze 0.9.14): - V relaci s messageReliability=none, nastavení nenulového nonce vyžádá potvrzení o doručení pro danou zprávu - Nastavení nonce=0 v relaci BestEffort vypne oznámení pro tuto zprávu\nKonfigurace LeaseSet (záznam s parametry doručování cílové služby v I2P) Option Default Description i2cp.dontPublishLeaseSet false Disable automatic LeaseSet publication (for client-only destinations) i2cp.leaseSetType 1 LeaseSet variant: 1 = standard, 3 = LS2, 5 = encrypted, 7 = meta i2cp.leaseSetEncType 0 Comma-separated encryption type codes (see below) ### Zastaralé značky relace ElGamal/AES Tyto možnosti platí pouze pro zastaralé šifrování ElGamal:\nOption Default Description crypto.lowTagThreshold 30 Minimum session tags before replenishing crypto.tagsToSend 40 Number of tags to send in a batch **Poznámka**: klienti ECIES-X25519 používají odlišný ráčnový mechanismus a tato nastavení ignorují. Typy šifrování I2CP podporuje více end-to-end šifrovacích schémat prostřednictvím volby i2cp.leaseSetEncType. Lze zadat více typů (oddělených čárkou) pro podporu jak moderních, tak i starších peerů.\nPodporované typy šifrování Type Algorithm Key Size Since Status 0 ElGamal/AES+SessionTags 2048-bit ElGamal Original Legacy 1-3 Reserved - - Unused 4 ECIES-X25519-AEAD-Ratchet 32-byte X25519 0.9.46 Current Standard 5 ECIES-X25519-AEAD-Ratchet + ML-KEM-768 hybrid 32\u0026nbsp;+\u0026nbsp;PQ 0.9.67 Beta 6 ECIES-X25519-AEAD-Ratchet + ML-KEM-1024 hybrid 32\u0026nbsp;+\u0026nbsp;PQ 0.9.67 Beta 7 Reserved (likely ML-KEM-512 hybrid) 32\u0026nbsp;+\u0026nbsp;PQ Future Planned **Doporučená konfigurace**: i2cp.leaseSetEncType=4,0 Toto poskytuje X25519 (preferované; eliptická výměna klíčů na křivce Curve25519) se záložní variantou ElGamal (asymetrické šifrování) pro kompatibilitu.\nPodrobnosti o typech šifrování Typ 0 - ElGamal/AES+SessionTags: - 2048bitové veřejné klíče ElGamal (256 bajtů) - Symetrické šifrování AES-256 - 32bajtové session tags (dočasné značky relace) odesílané v dávkách - Vysoká režie CPU, šířky pásma a paměti - Postupně vyřazováno napříč sítí\nTyp 4 - ECIES-X25519-AEAD-Ratchet: - Výměna klíčů X25519 (32bajtové klíče) - ChaCha20/Poly1305 AEAD - Dvojitý ratchet ve stylu Signal - 8bajtové session tags (značky relace) (oproti 32bajtovým u ElGamalu) - Tagy generované pomocí synchronizovaného PRNG (pseudonáhodný generátor) (nejsou posílány předem) - ~92% snížení režie oproti ElGamalu - Standard pro moderní I2P (většina routers to používá)\nTypy 5-6 - postkvantový hybrid: - Kombinuje X25519 s ML-KEM (NIST FIPS 203) - Poskytuje zabezpečení odolné vůči kvantovým počítačům - ML-KEM-768 pro vyvážený poměr zabezpečení/výkonu - ML-KEM-1024 pro maximální zabezpečení - Větší velikosti zpráv kvůli postkvantovému (PQ) klíčovému materiálu - Podpora v síti je stále zaváděna\nMigrační strategie Síť I2P aktivně přechází z ElGamal (typ 0) na X25519 (typ 4): - NTCP → NTCP2 (dokončeno) - SSU → SSU2 (dokončeno) - ElGamal tunnels → X25519 tunnels (dokončeno) - ElGamal end-to-end (mezi koncovými body) → ECIES-X25519 (z větší části dokončeno)\nLeaseSet2 a pokročilé funkce Možnosti LeaseSet2 (od 0.9.38) Option Since Purpose i2cp.leaseSetType 0.9.38 Specifies LeaseSet variant (1, 3, 5, 7) i2cp.leaseSetEncType 0.9.38 Encryption types supported (comma-separated) i2cp.leaseSetAuthType 0.9.41 Per-client authentication: 0 = none, 1 = DH, 2 = PSK i2cp.leaseSetPrivKey 0.9.41 X25519 private key for decrypting LS2 with auth i2cp.leaseSetSecret 0.9.39 Base64 secret for blinded addresses i2cp.leaseSetTransientPublicKey 0.9.38 Transient signing key for offline signatures i2cp.leaseSetPrivateKey 0.9.18 Persistent LeaseSet encryption keys (type:key pairs) i2cp.leaseSetOption.nnn 0.9.66 Service records (proposal 167) i2cp.leaseSetClient.dh.nnn 0.9.41 DH client auth material (indexed from 0) i2cp.leaseSetClient.psk.nnn 0.9.41 PSK client auth material (indexed from 0) ### Zaslepené adresy Od verze 0.9.39 mohou destinace používat \u0026ldquo;blinded\u0026rdquo; (zaslepené) adresy (formát b33), které se pravidelně mění: - Vyžaduje i2cp.leaseSetSecret pro ochranu heslem - Volitelné ověřování pro jednotlivé klienty - Podrobnosti viz návrhy 123 a 149\nZáznamy služeb (od verze 0.9.66) LeaseSet2 podporuje možnosti záznamu služby (návrh 167):\ni2cp.leaseSetOption.0=_smtp._tcp=1 86400 0 0 25 mail.example.b32.i2p Formát vychází ze stylu záznamu DNS SRV, ale je přizpůsoben pro I2P.\nVíce relací (od verze 0.9.21) Jedno připojení I2CP může udržovat více relací:\nPrimární relace: První relace vytvořená v rámci spojení Podrelace: Další relace sdílející tunnel pool primární relace\nVlastnosti podrelace Sdílené Tunnels: Použijte stejné pooly příchozích/odchozích tunnels jako primární relace Sdílené šifrovací klíče: Musí používat totožné LeaseSet šifrovací klíče Odlišné podpisové klíče: Musí používat odlišné podpisové klíče Destination (identifikátor služby v I2P) Bez záruky anonymity: Jednoznačně propojeno s primární relací (stejný router, stejné tunnels) Případ použití Subsession (podrelace) Povolit komunikaci s destinacemi používajícími různé typy podpisů: - Hlavní: podpis EdDSA (moderní) - Subsession (podřízená relace): podpis DSA (zpětná kompatibilita)\nŽivotní cyklus podrelace Vytvoření:\nClient → Router: CreateSessionMessage Router → Client: SessionStatusMessage (unique Session ID) Router → Client: RequestVariableLeaseSetMessage (separate for each destination) Client → Router: CreateLeaseSet2Message (separate for each destination) Zrušení: - Zrušení podrelace: Ponechá primární relaci nedotčenou - Zrušení primární relace: Zruší všechny podrelace a uzavře spojení - DisconnectMessage (zpráva pro odpojení): Zruší všechny relace\nZpracování ID relace Většina zpráv I2CP obsahuje pole Session ID. Výjimky: - DestLookup / DestReply (zastaralé, použijte HostLookup / HostReply) - GetBandwidthLimits / BandwidthLimits (odpověď není specifická pro relaci)\nDůležité: Klienti by současně neměli mít více nevyřízených zpráv CreateSession, protože odpovědi nelze jednoznačně spárovat s požadavky.\nKatalog zpráv Přehled typů zpráv Type Name Direction Since Status 1 CreateSession C → R Original Current 2 ReconfigureSession C → R 0.7.1 Current 3 DestroySession C → R Original Current 4 CreateLeaseSet C → R Original Deprecated 5 SendMessage C → R Original Current 6 ReceiveMessageBegin C → R Original Deprecated 7 ReceiveMessageEnd C → R Original Deprecated 8 GetBandwidthLimits C → R 0.7.2 Current 20 SessionStatus R → C Original Current 21 RequestLeaseSet R → C Original Deprecated 22 MessageStatus R → C Original Current 23 BandwidthLimits R → C 0.7.2 Current 29 ReportAbuse Bidirectional Original Unused 30 Disconnect Bidirectional Original Current 31 MessagePayload R → C Original Current 32 GetDate C → R Original Current 33 SetDate R → C Original Current 34 DestLookup C → R 0.7 Deprecated 35 DestReply R → C 0.7 Deprecated 36 SendMessageExpires C → R 0.7.1 Current 37 RequestVariableLeaseSet R → C 0.9.7 Current 38 HostLookup C → R 0.9.11 Current 39 HostReply R → C 0.9.11 Current 41 CreateLeaseSet2 C → R 0.9.39 Current 42 BlindingInfo C → R 0.9.43 Current **Legenda**: C = Klient, R = Router Podrobnosti o klíčové zprávě CreateSessionMessage (Typ 1) Účel: Zahájit novou relaci I2CP\nObsah: struktura SessionConfig\nOdpověď: SessionStatusMessage (status=Created nebo Invalid)\nPožadavky: - Datum v SessionConfig musí být v rozmezí ±30 sekund od času routeru - Mapování musí být seřazeno podle klíče pro ověření podpisu - Destination (identifikátor cíle v I2P) nesmí již mít aktivní relaci\nRequestVariableLeaseSetMessage (Typ 37) Účel: Router vyžaduje autorizaci klienta pro příchozí tunnels\nObsah: - ID relace - Počet Lease (záznamů o vstupních tunelech) - Pole struktur Lease (každá s vlastním časem vypršení platnosti)\nOdpověď: CreateLeaseSet2Message\nVýznam: Toto je signál, že relace je v provozu. Router toto odešle až poté, co: 1. je sestaven alespoň jeden inbound tunnel 2. je sestaven alespoň jeden outbound tunnel\nDoporučení pro časový limit: Klienti by měli relaci ukončit, pokud tato zpráva není přijata během 5+ minut od vytvoření relace.\nCreateLeaseSet2Message (Typ 41) Účel: Klient publikuje LeaseSet do síťové databáze\nObsah: - ID relace - bajt typu LeaseSet (1, 3, 5 nebo 7) - LeaseSet nebo LeaseSet2 nebo EncryptedLeaseSet nebo MetaLeaseSet - Počet soukromých klíčů - Seznam soukromých klíčů (jeden pro každý veřejný klíč v LeaseSet, ve stejném pořadí)\nSoukromé klíče: Nezbytné pro dešifrování příchozích garlic messages (I2P zprávy typu „garlic“). Formát:\nEncryption type (2 bytes) Key length (2 bytes) Private key data (variable) Poznámka: Nahrazuje zastaralou zprávu CreateLeaseSetMessage (typ 4), která nepodporuje: - varianty LeaseSet2 - šifrování jiné než ElGamal - více typů šifrování - šifrované LeaseSets - offline podpisové klíče\nSendMessageExpiresMessage (Typ 36) Účel: Odeslat zprávu na cílovou adresu s nastavením expirace a pokročilými možnostmi\nObsah: - ID relace - Cíl - Užitečná data (komprimovaná gzipem) - Nonce (jednorázová hodnota) (4 bajty) - Příznaky (2 bajty) - viz níže - Datum vypršení (6 bajtů, zkráceno z 8)\nPole příznaků (2 bajty, pořadí bitů 15\u0026hellip;0):\nBity 15-11: Nepoužité, musí být 0\nBity 10-9: Přebití spolehlivosti zprávy (nepoužito, místo toho použijte nonce (jednorázovou hodnotu))\nBit 8: Nezahrnovat LeaseSet - 0: Router může zahrnout LeaseSet do garlic (I2P technika seskupování zpráv) - 1: Nezahrnovat LeaseSet\nBity 7-4: Nízký práh tagů (pouze pro ElGamal, u ECIES se ignoruje)\n0000 = Use session settings 0001 = 2 tags 0010 = 3 tags ... 1111 = 192 tags Bity 3-0: Tagy k odeslání v případě potřeby (pouze ElGamal, ignorováno pro ECIES)\n0000 = Use session settings 0001 = 2 tags 0010 = 4 tags ... 1111 = 160 tags MessageStatusMessage (Typ 22) Účel: Informovat klienta o stavu doručení zprávy\nObsah: - ID relace - ID zprávy (generované routerem) - Kód stavu (1 bajt) - Velikost (4 bajty, relevantní pouze pro status=0) - Nonce (4 bajty, odpovídá nonce klienta pro SendMessage)\nStavové kódy (Odchozí zprávy):\nCode Name Meaning Result 1 Accepted Router accepted message Success 2 Best Effort Success Probable delivery Success 4 Guaranteed Success Probable delivery Success 6 Local Success Delivered to local client Success 3 Best Effort Failure Probable failure Failure 5 Guaranteed Failure Generic failure Failure 7 Local Failure Local delivery failed Failure 8 Router Failure Router shutdown/error Failure 9 Network Failure No network connectivity Failure 10 Bad Session Invalid/closed session Failure 11 Bad Message Invalid payload Failure 12 Bad Options Invalid options/expiration Failure 13 Overflow Failure Queue/buffer full Failure 14 Message Expired Expired before send Failure 15 Bad Local LeaseSet Local LeaseSet problem Failure 16 No Local Tunnels No tunnels available Failure 17 Unsupported Encryption Incompatible encryption Failure 18 Bad Destination Invalid remote destination Failure 19 Bad Leaseset Invalid remote LeaseSet Failure 20 Expired Leaseset Remote LeaseSet expired Failure 21 No Leaseset Remote LeaseSet not found Failure 22 Meta Leaseset Cannot send to meta LS Failure 23 Loopback Denied Same source and destination Failure **Kódy úspěchu**: 1, 2, 4, 6 **Kódy selhání**: Všechny ostatní Kód stavu 0 (ZASTARALÉ): Dostupná zpráva (příchozí, rychlý příjem deaktivován)\nHostLookupMessage (Typ 38) Účel: Vyhledání destination (I2P adresa) podle názvu hostitele nebo hashe (nahrazuje DestLookup)\nObsah: - ID relace (nebo 0xFFFF, pokud není relace) - ID požadavku (4 bajty) - Časový limit v milisekundách (4 bajty, min. doporučeno: 10000) - Typ požadavku (1 bajt) - Vyhledávací klíč (Hash, řetězec názvu hostitele, nebo Destination (cílový identifikátor v I2P))\nTypy požadavků:\nType Lookup Key Returns Since 0 Hash Destination Original 1 Hostname String Destination Original 2 Hash Destination + Options 0.9.66 3 Hostname String Destination + Options 0.9.66 4 Destination Destination + Options 0.9.66 Typy 2-4 vracejí možnosti LeaseSet (návrh 167), pokud jsou k dispozici. Odpověď: HostReplyMessage (zpráva s odpovědí hostitele)\nHostReplyMessage (Typ 39) Účel: Odpověď na HostLookupMessage (zpráva pro vyhledání hostitele)\nObsah: - ID relace - ID požadavku - Kód výsledku (1 bajt) - Destination (identita cíle v I2P) (přítomno při úspěchu, někdy i u specifických selhání) - Mapování (pouze pro typy vyhledávání 2-4, může být prázdné)\nKódy výsledků:\nCode Name Meaning 0 Success Lookup succeeded 1 Failure Generic failure 2 Lookup Password Required Blinded address requires password 3 Private Key Required Blinded address requires private key 4 Password and Key Required Blinded address requires both 5 LeaseSet Decryption Failure Cannot decrypt LeaseSet 6 LeaseSet Lookup Failure LeaseSet not found in netdb 7 Lookup Type Unsupported Router doesn't support this type #### BlindingInfoMessage (zpráva s informacemi o zaslepení) (Typ 42) Účel: Informovat router o požadavcích na autentizaci pro blinded destination (oslepenou destinaci) (od verze 0.9.43)\nObsah: - ID relace - Příznaky (1 bajt) - Typ koncového bodu (1 bajt): 0=Hash, 1=hostname, 2=Destination, 3=SigType+Key - Typ zaslepeného podpisu (2 bajty) - Vypršení platnosti (4 bajty, sekundy od epochy) - Data koncového bodu (liší se podle typu) - Soukromý klíč (32 bajtů, pouze pokud je v příznacích nastaven bit 0) - Heslo pro vyhledávání (String, pouze pokud je v příznacích nastaven bit 4)\nPříznaky (pořadí bitů 76543210):\nBit 0: 0=pro všechny, 1=pro jednotlivé klienty Bity 3-1: Autentizační schéma (pokud bit 0=1): 000=DH, 001=PSK Bit 4: 1=vyžadován secret (tajemství) Bity 7-5: Nepoužito, nastavte na 0 Žádná odpověď: Router zpracovává tiše\nPřípad použití: Před odesláním na blinded destination (zaslepená destinace) (b33 address - adresa b33) musí klient buď: 1. vyhledat b33 pomocí HostLookup, NEBO 2. odeslat zprávu BlindingInfo\nPokud cíl vyžaduje autentizaci, BlindingInfo je povinné.\nReconfigureSessionMessage (Typ 2) Účel: Aktualizovat konfiguraci relace po vytvoření\nObsah: - ID relace - SessionConfig (stačí pouze změněné volby)\nOdpověď: SessionStatusMessage (status=Updated nebo Invalid)\nPoznámky: - Router sloučí novou konfiguraci se stávající konfigurací - Možnosti tunnelu (inbound.*, outbound.*) se vždy uplatní - Některé možnosti mohou být po vytvoření relace neměnné - Datum musí být v rámci ±30 sekund od času routeru - Mapování musí být seřazeno podle klíče\nDestroySessionMessage (Typ 3) Účel: Ukončit relaci\nObsah: ID relace\nOčekávaná odpověď: SessionStatusMessage (status=Destroyed)\nSkutečné chování (Java I2P až do verze 0.9.66 včetně): - Router nikdy neodesílá SessionStatus(Destroyed) - Pokud nezůstane žádná relace: Odešle DisconnectMessage - Pokud zůstanou subsessions (podrelace): Žádná odpověď\nDůležité: Chování Java I2P se odchyluje od specifikace. Implementace by měly být obezřetné při ukončování jednotlivých subsessions (podrelací).\nDisconnectMessage (typ 30) Účel: Oznámit, že spojení bude brzy ukončeno\nObsah: text důvodu\nDůsledek: Všechny relace na spojení jsou ukončeny, socket se uzavře\nImplementace: Převážně router → klient v Java I2P\nHistorie verzí protokolu Detekce verze Verze protokolu I2CP se vyměňuje ve zprávách Get/SetDate (od verze 0.8.7). U starších routerů nejsou informace o verzi k dispozici.\nŘetězec verze: Udává verzi API „core“, nikoli nutně verzi routeru.\nČasová osa funkcí Version Key Features 0.9.67 PQ Hybrid ML-KEM (enc types 5-7) in LeaseSet 0.9.66 Host lookup/reply extensions (proposal 167), service records 0.9.62 MessageStatus loopback error code 0.9.46 X25519 (enc type 4) in LeaseSet, ECIES end-to-end 0.9.43 BlindingInfo message, extended HostReply failure codes 0.9.41 EncryptedLeaseSet options, Meta LS error code 0.9.39 CreateLeaseSet2 message, RedDSA Ed25519 support 0.9.38 Preliminary LS2 support (format changed in 0.9.39) 0.9.21 Multiple sessions on single connection 0.9.20 Additional SetDate messages for clock shifts 0.9.16 Authentication required before other messages (when enabled) 0.9.15 EdDSA Ed25519 signature type 0.9.14 Per-message reliability override with nonzero nonce 0.9.12 ECDSA P-256/384/521 signature types, RSA support 0.9.11 HostLookup/HostReply messages, auth in GetDate 0.9.7 RequestVariableLeaseSet message 0.9.5 Additional MessageStatus codes 0.9.4 Fast receive mode default, nonce=0 allowed 0.9.2 SendMessageExpires flag tag bits 0.9 16 leases per LeaseSet (up from 6) 0.8.7 Version strings in Get/SetDate 0.8.4 SendMessageExpires flag bits 0.8.3 DestLookup in standard session, concurrent lookups 0.8.1 messageReliability=none 0.7.2 GetBandwidthLimits, BandwidthLimits 0.7.1 SendMessageExpires, ReconfigureSession, ports in gzip header 0.7 DestLookup, DestReply 0.6.5- Original protocol features ## Bezpečnostní hlediska Autentizace Výchozí: Ověřování není vyžadováno Volitelné: Ověřování pomocí uživatelského jména a hesla (od 0.9.11) Povinné: Pokud je povoleno, ověřování se musí dokončit před ostatními zprávami (od 0.9.16)\nVzdálená připojení: Vždy používejte TLS (i2cp.SSL=true) k ochraně přihlašovacích údajů a soukromých klíčů.\nČasová odchylka SessionConfig Date musí být v rozmezí ±30 sekund od času routeru, jinak bude relace odmítnuta. K synchronizaci použijte Get/SetDate.\nZacházení se soukromými klíči CreateLeaseSet2Message obsahuje soukromé klíče pro dešifrování příchozích zpráv. Tyto klíče musí být:\nBezpečně přenášeny (TLS pro vzdálená připojení) Bezpečně ukládány routerem Vyměněny v případě kompromitace Vypršení platnosti zprávy Vždy používejte SendMessageExpires (nikoli SendMessage) k nastavení explicitního vypršení platnosti. To:\nZabrání tomu, aby byly zprávy zařazeny do fronty na neurčito Snižuje spotřebu prostředků Zvyšuje spolehlivost Správa značek relace ElGamal (zastaralé): - Tagy musí být přenášeny po dávkách - Ztracené tagy způsobují selhání dešifrování - Vysoká paměťová režie\nECIES-X25519 (aktuální): - Tagy generované synchronizovaným PRNG - Není nutný žádný předběžný přenos - Odolné vůči ztrátám zpráv - Výrazně nižší režie\nOsvědčené postupy Pro vývojáře klientských aplikací Použijte režim rychlého příjmu: Vždy nastavte i2cp.fastReceive=true (nebo se spolehněte na výchozí nastavení)\nUpřednostněte ECIES-X25519: Nastavte i2cp.leaseSetEncType=4,0 pro nejlepší výkon při zachování kompatibility\nNastavte explicitní expiraci: Použijte SendMessageExpires, nikoli SendMessage\nZacházejte se Subsessions (podrelacemi) opatrně: Mějte na paměti, že subsessions neposkytují žádnou anonymitu mezi cíli\nČasový limit pro vytvoření relace: Ukončit relaci, pokud není do 5 minut přijat RequestVariableLeaseSet\nSeřaďte konfigurační mapování: Vždy seřaďte klíče mapování před podepsáním SessionConfig (konfigurace relace)\nPoužívejte vhodný počet Tunnel: Nenastavujte quantity \u0026gt; 6, pokud to není nutné\nZvažte SAM/BOB pro prostředí mimo Javu: Implementujte raději SAM než přímo I2CP\nPro vývojáře routeru Ověřit datumy: Vynutit časové okno ±30 sekund u datumů v SessionConfig\nOmezení velikosti zprávy: Vynutit maximální velikost zprávy ~64 KB\nPodpora více relací: Implementovat podporu subsession (podrelace) podle specifikace 0.9.21\nOdešlete RequestVariableLeaseSet neprodleně: Teprve poté, co existují jak příchozí, tak odchozí tunnels\nOšetřete zastaralé zprávy: Přijímejte, ale nedoporučujte používání ReceiveMessageBegin/End\nPodporujte ECIES-X25519: Upřednostněte šifrování typu 4 pro nová nasazení\nLadění a odstraňování problémů Časté problémy Relace odmítnuta (neplatná): - Zkontrolujte odchylku hodin (musí být v rozmezí ±30 sekund) - Ověřte, že mapování je seřazeno podle klíče - Ujistěte se, že Destinace není již používána\nNo RequestVariableLeaseSet: - Router může vytvářet tunnels (počkejte až 5 minut) - Zkontrolujte problémy s připojením k síti - Ověřte, že je k dispozici dostatečný počet připojení k uzlům\nSelhání doručení zpráv: - Zkontrolujte kódy MessageStatus (stavové kódy zpráv) pro konkrétní důvod selhání - Ověřte, že vzdálený LeaseSet je zveřejněn a aktuální - Zajistěte kompatibilní typy šifrování\nProblémy s podrelacemi: - Ověřte, že primární relace byla vytvořena jako první - Potvrďte, že šifrovací klíče jsou stejné - Zkontrolujte, zda jsou podpisové klíče odlišné\nDiagnostické zprávy GetBandwidthLimits: Zjištění kapacity routeru HostLookup: Test rozlišení názvů a dostupnosti LeaseSetu (záznam o dostupnosti cíle v I2P) MessageStatus: Sledování doručování zpráv end-to-end\nSouvisející specifikace Společné struktury: /docs/specs/common-structures/ I2NP (síťový protokol): /docs/specs/i2np/ ECIES-X25519: /docs/specs/ecies/ Vytváření Tunnel: /docs/specs/implementation/ Streamovací knihovna: /docs/specs/streaming/ Datagramová knihovna: /docs/api/datagrams/ SAM v3: /docs/api/samv3/ Citované návrhy Návrh 123 : Šifrované LeaseSets a autentizace Návrh 144 : ECIES-X25519-AEAD-Ratchet Návrh 149 : Zaslepený formát adresy (b33) Návrh 152 : Vytváření X25519 tunnelů Návrh 154 : Vyhledávání v databázi z ECIES destinací Návrh 156 : Migrace routerů na ECIES-X25519 Návrh 161 : Komprese paddingu destinace Návrh 167 : Záznamy služeb LeaseSet Návrh 169 : Postkvantová hybridní kryptografie (ML-KEM) Referenční dokumentace Javadoc Balíček I2CP MessageStatusMessage Klientské API Shrnutí zastarání Zastaralé zprávy (nepoužívat) CreateLeaseSetMessage (typ 4): Použijte CreateLeaseSet2Message RequestLeaseSetMessage (typ 21): Použijte RequestVariableLeaseSetMessage ReceiveMessageBeginMessage (typ 6): Použijte rychlý režim příjmu ReceiveMessageEndMessage (typ 7): Použijte rychlý režim příjmu DestLookupMessage (typ 34): Použijte HostLookupMessage DestReplyMessage (typ 35): Použijte HostReplyMessage ReportAbuseMessage (typ 29): Nikdy nebylo implementováno Zastaralé volby Šifrování ElGamalem (typ 0): Přejděte na ECIES-X25519 (typ 4) Podpisy DSA: Přejděte na EdDSA nebo ECDSA i2cp.fastReceive=false: Vždy používejte režim rychlého příjmu ","description":"Jak aplikace vyjednávají relace, tunnels a LeaseSets s I2P routerem.","id":"ed43fc9da2a03819fd3c8f71e9e9a5a3","section":"docs","title":"Klientský protokol I2P (I2CP)","url":"/cs/docs/specs/i2cp/"},{"categories":null,"content":"Přehled Tento dokument poskytuje komplexní technickou specifikaci konfiguračních souborů I2P používaných routerem a různými aplikacemi. Pokrývá specifikace formátů souborů, definice vlastností a implementační detaily ověřené na základě zdrojového kódu I2P a oficiální dokumentace.\nRozsah Konfigurační soubory a formáty pro Router Konfigurace klientských aplikací Konfigurace pro I2PTunnel tunnel Specifikace formátů souborů a implementace Funkce specifické pro jednotlivé verze a označení za zastaralé Poznámky k implementaci Konfigurační soubory se čtou a zapisují pomocí metod DataHelper.loadProps() a storeProps() v jádrové knihovně I2P. Formát souboru se výrazně liší od serializovaného formátu používaného v protokolech I2P (viz Specifikace obecných struktur – mapování typů ).\nObecný formát konfiguračního souboru Konfigurační soubory I2P používají upravený formát Java Properties s konkrétními výjimkami a omezeními.\nSpecifikace formátu Vychází z Java Properties s následujícími zásadními rozdíly:\nKódování MUSÍ používat kódování UTF-8 (NE ISO-8859-1 jako ve standardních Java Properties) Implementace: Pro všechny operace se soubory používá pomocnou funkci DataHelper.getUTF8() Escape sekvence ŽÁDNÉ escape sekvence nejsou rozpoznávány (včetně zpětného lomítka \\) Pokračování řádku NENÍ podporováno Znaky zpětného lomítka jsou považovány za doslovné Znaky komentáře # začíná komentář na libovolné pozici na řádku ; začíná komentář pouze pokud je v prvním sloupci ! NE začíná komentář (na rozdíl od Java Properties) Oddělovače klíč-hodnota = je JEDINÝ platný oddělovač klíč–hodnota : NENÍ rozpoznáván jako oddělovač Prázdné znaky NEJSOU rozpoznávány jako oddělovače Zpracování bílých znaků Počáteční a koncové bílé znaky u klíčů NEJSOU ořezávány Počáteční a koncové bílé znaky u hodnot JSOU ořezávány Zpracování řádků Řádky bez = jsou ignorovány (považovány za komentáře nebo prázdné řádky) Prázdné hodnoty (key=) jsou podporovány od verze 0.9.10 Klíče s prázdnými hodnotami se běžně ukládají a načítají Omezení znaků Klíče NESMÍ obsahovat: - # (křížek) - = (znak rovná se) - \\n (znak nového řádku) - Nesmí začínat znakem ; (středník)\nHodnoty NESMÍ obsahovat: - # (symbol hash/pound) - \\n (znak nového řádku) - Nesmí začínat ani končit znakem \\r (návrat vozíku) - Nesmí začínat ani končit bílými znaky (automaticky ořezány)\nŘazení souborů Konfigurační soubory nemusí být seřazeny podle klíče. Nicméně většina aplikací I2P řadí klíče abecedně při zápisu konfiguračních souborů pro usnadnění: - Ručních úprav - Operací diff ve verzovacích systémech - Čitelnosti pro člověka\nPodrobnosti implementace Čtení konfiguračních souborů // Method signature from net.i2p.data.DataHelper public static Properties loadProps(File file) Chování: - Čte soubory kódované v UTF-8 - Vynucuje všechna výše popsaná pravidla formátu - Ověřuje omezení znaků - Vrací prázdný objekt Properties, pokud soubor neexistuje - Vyvolá IOException při chybách čtení\nPsaní konfiguračních souborů // Method signature from net.i2p.data.DataHelper public static void storeProps(Properties props, File file) Chování: - Zapisuje soubory v kódování UTF-8 - Řadí klíče abecedně (pokud není použito OrderedProperties) - Nastavuje oprávnění souborů na režim 600 (pouze čtení/zápis pro uživatele) od verze 0.8.1 - Vyvolává IllegalArgumentException při neplatných znacích v klíčích nebo hodnotách - Vyvolává IOException při chybách zápisu\nOvěření formátu Implementace provádí přísnou validaci: - Klíče a hodnoty se kontrolují na zakázané znaky - Neplatné položky vyvolávají výjimky při zápisových operacích - Čtení tiše ignoruje chybně formátované řádky (řádky bez =)\nPříklady formátu Platný konfigurační soubor # This is a comment ; This is also a comment (column 1 only) key.with.dots=value with spaces another_key=value=with=equals empty.value= numeric.value=12345 unicode.value=こんにちは Příklady neplatné konfigurace # INVALID: Key contains equals sign invalid=key=value # INVALID: Key contains hash invalid#key=value # INVALID: Value contains newline (implicit) key=value continues here # INVALID: Semicolon comment not in column 1 (treated as key) ; not.a.comment=value Základní knihovna a konfigurace Routeru Konfigurace klientů (clients.config) Umístění: $I2P_CONFIG_DIR/clients.config (starší) nebo $I2P_CONFIG_DIR/clients.config.d/ (moderní) Konfigurační rozhraní: konzole routeru na /configclients Změna formátu: Verze 0.9.42 (srpen 2019)\nAdresářová struktura (verze 0.9.42+) Od verze 0.9.42 je výchozí soubor clients.config automaticky rozdělen na jednotlivé konfigurační soubory:\n$I2P_CONFIG_DIR/ ├── clients.config.d/ │ ├── 00-webConsole.config │ ├── 01-i2ptunnel.config │ ├── 02-i2psnark.config │ ├── 03-susidns.config │ └── ... └── clients.config (legacy, auto-migrated) Chování při migraci: - Při prvním spuštění po aktualizaci na verzi 0.9.42+ se monolitický soubor automaticky rozdělí - V rozdělených souborech mají vlastnosti předponu clientApp.0. - Zastaralý formát je nadále podporován kvůli zpětné kompatibilitě - Rozdělený formát umožňuje modulární balíčkování a správu zásuvných modulů\nFormát vlastností Řádky jsou ve tvaru clientApp.x.prop=val, kde x je číslo aplikace.\nPožadavky na číslování aplikací: - MUSÍ začínat od 0 - MUSÍ být po sobě jdoucí (bez mezer) - Pořadí určuje sekvenci spouštění\nPovinné vlastnosti hlavní Typ: Řetězec (plně kvalifikovaný název třídy) Povinné: Ano Popis: V závislosti na typu klienta (spravovaný vs. nespravovaný) bude spuštěn konstruktor nebo metoda main() v této třídě Příklad: clientApp.0.main=net.i2p.router.web.RouterConsoleRunner Volitelné vlastnosti název Typ: Řetězec Povinné: Ne Popis: Název zobrazený v router console Příklad: clientApp.0.name=Router Console args Typ: Řetězec (oddělený mezerou nebo tabulátorem) Povinné: Ne Popis: Argumenty předávané konstruktoru hlavní třídy nebo metodě main() Uvozování: Argumenty obsahující mezery nebo tabulátory lze uzavřít do uvozovek ' nebo \u0026quot; Příklad: clientApp.0.args=-d $CONFIG/eepsite zpoždění Typ: Integer (sekundy) Povinné: Ne Výchozí: 120 Popis: Počet sekund čekání před spuštěním klienta Přebíjí: Přebito onBoot=true (nastaví zpoždění na 0) Speciální hodnoty: \u0026lt; 0: Čekat, než router dosáhne stavu RUNNING, potom spustit ihned v novém vlákně = 0: Spustit ihned ve stejném vlákně (výjimky se propagují do konzole) \u0026gt; 0: Spustit po zpoždění v novém vlákně (výjimky jsou zaznamenány do logu, nepropagují se) onBoot Typ: Boolean (logická hodnota) Povinné: Ne Výchozí: false Popis: Vynutí zpoždění 0 a přepíše explicitně zadané nastavení zpoždění Použití: Spustí kritické služby okamžitě při startu routeru startOnLoad Typ: Boolean Povinné: Ne Výchozí: true Popis: Zda vůbec spustit klienta Případ použití: Zakázat klienty bez odstranění konfigurace Vlastnosti specifické pro zásuvný modul Tyto vlastnosti používají pouze zásuvné moduly (nikoli základní klienti):\nstopargs Typ: String (oddělený mezerami nebo tabulátory) Popis: Argumenty předané pro zastavení klienta Nahrazování proměnných: Ano (viz níže) uninstallargs Typ: Řetězec (oddělený mezerou nebo tabulátorem) Popis: Argumenty předávané při odinstalaci klienta Substituce proměnných: Ano (viz níže) classpath (vyhledávací cesta pro třídy) Typ: Řetězec (cesty oddělené čárkami) Popis: Další položky classpath pro klienta Nahrazování proměnných: Ano (viz níže) Substituce proměnných (pouze pro pluginy) Následující proměnné se nahrazují v args, stopargs, uninstallargs a classpath u zásuvných modulů:\nVariable Expands To Example $I2P Base I2P installation directory /usr/share/i2p $CONFIG User configuration directory ~/.i2p $PLUGIN Plugin directory ~/.i2p/plugins/foo $OS Operating system name linux $ARCH Architecture name amd64 **Poznámka**: Nahrazování proměnných se provádí pouze u pluginů, nikoli u klientů jádra. Typy klientů Spravovaní klienti Konstruktor se volá s parametry RouterContext a ClientAppManager Klient musí implementovat rozhraní ClientApp Životní cyklus řídí router Lze dynamicky spouštět, zastavovat a restartovat Nespravovaní klienti Je volána metoda main(String[] args) Běží v samostatném vlákně Životní cyklus není spravován routerem Zastaralý typ klienta Ukázková konfigurace # Router Console (core client) clientApp.0.main=net.i2p.router.web.RouterConsoleRunner clientApp.0.name=Router Console clientApp.0.args=-d $CONFIG/eepsite clientApp.0.delay=0 clientApp.0.onBoot=true clientApp.0.startOnLoad=true # I2PTunnel (core client) clientApp.1.main=net.i2p.i2ptunnel.TunnelControllerGroup clientApp.1.name=I2PTunnel clientApp.1.args= clientApp.1.delay=120 clientApp.1.startOnLoad=true # Plugin Example clientApp.2.main=org.example.plugin.PluginMain clientApp.2.name=Example Plugin clientApp.2.args=-config $PLUGIN/config.properties clientApp.2.stopargs=-shutdown clientApp.2.uninstallargs=-remove $PLUGIN clientApp.2.classpath=$PLUGIN/lib/plugin.jar,$PLUGIN/lib/dep.jar clientApp.2.delay=240 clientApp.2.startOnLoad=true Konfigurace protokolování (logger.config) Umístění: $I2P_CONFIG_DIR/logger.config Konfigurační rozhraní: konzole routeru na /configlogging\nReference vlastností Konfigurace vyrovnávací paměti konzole logger.consoleBufferSize Typ: Celé číslo Výchozí: 20 Popis: Maximální počet logových zpráv ukládaných do vyrovnávací paměti v konzoli Rozsah: 1-1000 doporučeno Formátování data a času logger.dateFormat Typ: String (vzor SimpleDateFormat) Výchozí: Z místního nastavení systému Příklad: HH:mm:ss.SSS Dokumentace: Java SimpleDateFormat Úrovně logování logger.defaultLevel Typ: výčtový typ Výchozí: ERROR Hodnoty: CRIT, ERROR, WARN, INFO, DEBUG Popis: Výchozí úroveň protokolování pro všechny třídy logger.minimumOnScreenLevel Typ: výčet Výchozí: CRIT Hodnoty: CRIT, ERROR, WARN, INFO, DEBUG Popis: Minimální úroveň pro zprávy zobrazované na obrazovce logger.record.{class} Typ: výčtový typ Hodnoty: CRIT, ERROR, WARN, INFO, DEBUG Popis: Předefinování úrovně logování pro jednotlivé třídy Příklad: logger.record.net.i2p.router.transport.udp=DEBUG Možnosti zobrazení logger.displayOnScreen Typ: logická hodnota Výchozí: true Popis: Zda zobrazovat zprávy logu v konzolovém výstupu logger.dropDuplicates Typ: Logická hodnota Výchozí hodnota: true Popis: Zahazuje duplicitní po sobě jdoucí záznamy v logu logger.dropOnOverflow Typ: Boolean Výchozí: false Popis: Zahazovat zprávy, když je vyrovnávací paměť plná (namísto blokování) Chování vyprázdňování vyrovnávací paměti logger.flushInterval Typ: Celé číslo (v sekundách) Výchozí hodnota: 29 Od: Verze 0.9.18 Popis: Jak často vyprazdňovat vyrovnávací paměť logu na disk Konfigurace formátu logger.format Typ: Řetězec (sekvence znaků) Popis: Šablona formátu logovací zprávy Formátovací znaky: d = datum/čas c = název třídy t = název vlákna p = priorita (úroveň logu) m = zpráva Příklad: dctpm vytvoří [časové razítko] [třída] [vlákno] [úroveň] zpráva Komprese (Verze 0.9.56+) logger.gzip Typ: Boolean Výchozí: false Od: Verze 0.9.56 Popis: Povolit kompresi gzip pro rotované soubory protokolu logger.minGzipSize Typ: Celé číslo (v bajtech) Výchozí: 65536 Od: verze 0.9.56 Popis: Minimální velikost souboru pro aktivaci komprese (výchozí 64 KB) Správa souborů logger.logBufferSize Typ: Celé číslo (v bajtech) Výchozí: 1024 Popis: Maximální počet zpráv, které se mají ukládat do vyrovnávací paměti před jejím vyprázdněním logger.logFileName Typ: Řetězec (cesta k souboru) Výchozí: logs/log-@.txt Popis: Vzor pojmenování logovacího souboru (@ se nahradí číslem rotace) logger.logFilenameOverride Typ: Řetězec (cesta k souboru) Popis: Přepíše název logovacího souboru (zakáže vzor rotace) logger.logFileSize Typ: Řetězec (velikost s jednotkou) Výchozí: 10M Jednotky: K (kilobajty), M (megabajty), G (gigabajty) Příklad: 50M, 1G logger.logRotationLimit Typ: Celé číslo Výchozí hodnota: 2 Popis: Nejvyšší číslo rotovaného souboru logu (log-0.txt až log-N.txt) Příklad konfigurace # Basic logging configuration logger.consoleBufferSize=50 logger.dateFormat=yyyy-MM-dd HH:mm:ss.SSS logger.defaultLevel=WARN logger.displayOnScreen=true logger.dropDuplicates=true logger.dropOnOverflow=false # Flushing and format logger.flushInterval=30 logger.format=dctpm # File management logger.logBufferSize=2048 logger.logFileName=logs/log-@.txt logger.logFileSize=25M logger.logRotationLimit=5 # Compression (0.9.56+) logger.gzip=true logger.minGzipSize=131072 # On-screen filtering logger.minimumOnScreenLevel=ERROR # Per-class overrides logger.record.net.i2p.router.transport=INFO logger.record.net.i2p.router.tunnel=DEBUG logger.record.net.i2p.crypto=WARN Konfigurace pluginu Konfigurace jednotlivého zásuvného modulu (plugins/*/plugin.config) Umístění: $I2P_CONFIG_DIR/plugins/{plugin-name}/plugin.config Formát: Standardní formát konfiguračního souboru I2P Dokumentace: Specifikace zásuvného modulu Povinné vlastnosti název Typ: Řetězec Povinné: Ano Popis: Zobrazovaný název zásuvného modulu Příklad: name=I2P Plugin Example klíč Typ: Řetězec (veřejný klíč) Povinné: Ano (vynechte u zásuvných modulů podepsaných pomocí SU3) Popis: Veřejný klíč používaný k ověření podpisu zásuvného modulu Formát: Podpisový klíč kódovaný v Base64 podepisovatel Typ: řetězec Povinné: Ano Popis: Identita signatáře pluginu Příklad: signer=user@example.i2p verze Typ: String (formát VersionComparator) Povinné: Ano Popis: Verze pluginu pro kontrolu aktualizací Formát: sémantické verzování nebo vlastní porovnatelný formát Příklad: version=1.2.3 Vlastnosti zobrazení datum Typ: Long (Unixové časové razítko v milisekundách) Popis: Datum vydání zásuvného modulu autor Typ: String Popis: Jméno autora zásuvného modulu websiteURL Typ: Řetězec (URL) Popis: URL webu zásuvného modulu updateURL Typ: Řetězec (URL) Popis: URL pro kontrolu aktualizací zásuvného modulu updateURL.su3 Type: Řetězec (URL) Since: Verze 0.9.15 Description: Aktualizační URL ve formátu SU3 (upřednostňováno) popis Typ: String Popis: Anglický popis zásuvného modulu description_{language} Typ: řetězec Popis: Lokalizovaný popis zásuvného modulu Příklad: description_de=Deutsche Beschreibung licence Typ: řetězec Popis: Identifikátor licence zásuvného modulu Příklad: license=Apache 2.0 Instalační vlastnosti nespouštět-při-instalaci Typ: logická hodnota Výchozí: false Popis: Zabrání automatickému spuštění po instalaci Je vyžadován restart routeru Typ: Boolean Výchozí: false Popis: Vyžaduje restart routeru po instalaci pouze pro instalaci Typ: Logická hodnota Výchozí: false Popis: Instalovat pouze jednou (bez aktualizací) pouze pro aktualizace Typ: Boolean Výchozí: false Popis: Aktualizovat pouze stávající instalaci (bez čisté instalace) Příklad konfigurace pluginu # Required properties name=Example I2P Plugin signer=developer@mail.i2p version=1.5.0 # Display properties author=Plugin Developer websiteURL=http://plugin.example.i2p updateURL=http://plugin.example.i2p/update.xpi2p updateURL.su3=http://plugin.example.i2p/update.su3 description=Example plugin demonstrating configuration description_de=Beispiel-Plugin zur Demonstration der Konfiguration license=MIT # Installation behavior dont-start-at-install=false router-restart-required=false Globální konfigurace zásuvných modulů (plugins.config) Umístění: $I2P_CONFIG_DIR/plugins.config Účel: Globální povolení/zakázání nainstalovaných zásuvných modulů\nFormát vlastnosti plugin.{name}.startOnLoad=true|false {name}: Název pluginu z plugin.config startOnLoad: Zda se má plugin spustit při spuštění routeru Příklad plugin.i2psnark.startOnLoad=true plugin.susimail.startOnLoad=true plugin.susidns.startOnLoad=true plugin.i2pbote.startOnLoad=false Konfigurace webových aplikací (webapps.config) Umístění: $I2P_CONFIG_DIR/webapps.config Účel: Povolit/zakázat a konfigurovat webové aplikace\nFormát vlastnosti webapps.{name}.startOnLoad Typ: Boolean Popis: Zda spustit webovou aplikaci při spuštění routeru Formát: webapps.{name}.startOnLoad=true|false webapps.{name}.classpath Typ: Řetězec (cesty oddělené mezerou nebo čárkou) Popis: Další položky classpath pro webovou aplikaci Formát: webapps.{name}.classpath=[paths] Nahrazování proměnných Cesty podporují následující nahrazování proměnných:\nVariable Expands To Context $I2P Base I2P directory Core webapps $CONFIG User config directory All webapps $PLUGIN Plugin directory Plugin webapps #### Prohledávání classpathu (vyhledávací cesta pro třídy) Základní webové aplikace: Cesty relativní k $I2P/lib Webové aplikace zásuvných modulů: Cesty relativní k $CONFIG/plugins/{appname}/lib Ukázková konfigurace # Router console webapps.routerconsole.startOnLoad=true webapps.routerconsole.classpath=routerconsole.jar # I2PSnark webapps.i2psnark.startOnLoad=true webapps.i2psnark.classpath=i2psnark.jar # SusiDNS webapps.susidns.startOnLoad=true webapps.susidns.classpath=susidns.jar # Plugin webapp example webapps.exampleplugin.startOnLoad=false webapps.exampleplugin.classpath=$PLUGIN/lib/webapp.jar,$PLUGIN/lib/deps.jar Konfigurace routeru (router.config) Umístění: $I2P_CONFIG_DIR/router.config Konfigurační rozhraní: Konzole routeru na /configadvanced Účel: Základní nastavení routeru a síťové parametry\nKategorie konfigurace Konfigurace sítě Nastavení šířky pásma:\ni2np.bandwidth.inboundKBytesPerSecond=100 i2np.bandwidth.outboundKBytesPerSecond=50 i2np.bandwidth.share.percentage=80 Konfigurace transportu:\n# NTCP (TCP-based transport) i2np.ntcp.port=8887 i2np.ntcp.enable=true i2np.ntcp.autoip=true # SSU (UDP-based transport) i2np.udp.port=8887 i2np.udp.enable=true # UPnP/NAT-PMP i2np.upnp.enable=true Chování routeru # Tunnel participation router.maxParticipatingTunnels=200 router.sharePercentage=80 # Updates router.updatePolicy=notify router.updateURL=http://update.i2p2.i2p/ # Network integration router.hiddenMode=false router.clockSkewOffset=0 Konfigurace konzole # Language and display routerconsole.lang=en routerconsole.country=US routerconsole.summaryRefresh=60 # Browser routerconsole.browser=default # Security routerconsole.enableCompression=true Konfigurace času # NTP time.disabled=false time.sntpServerList=0.pool.ntp.org,1.pool.ntp.org Poznámka: Konfigurace routeru je rozsáhlá. Kompletní referenci vlastností najdete v konzoli routeru na /configadvanced.\nKonfigurační soubory aplikací Konfigurace adresáře (addressbook/config.txt) Umístění: $I2P_CONFIG_DIR/addressbook/config.txt Aplikace: SusiDNS Účel: Rozlišení názvů hostitelů a správa knihy adres\nUmístění souborů router_addressbook Výchozí: ../hosts.txt Popis: Hlavní adresář (celosystémové názvy hostitelů) Formát: Standardní formát souboru hosts privatehosts.txt Umístění: $I2P_CONFIG_DIR/addressbook/privatehosts.txt Popis: Soukromé mapování názvů hostitelů Priorita: Nejvyšší (přebíjí všechny ostatní zdroje) userhosts.txt Umístění: $I2P_CONFIG_DIR/addressbook/userhosts.txt Popis: Uživatelem přidaná mapování názvů hostitelů Správa: Prostřednictvím rozhraní SusiDNS hosts.txt Umístění: $I2P_CONFIG_DIR/addressbook/hosts.txt Popis: Stažený veřejný adresář adres Zdroj: Odběrové kanály Služba názvů BlockfileNamingService (Výchozí od verze 0.8.8) Formát úložiště: - Soubor: hostsdb.blockfile - Umístění: $I2P_CONFIG_DIR/addressbook/ - Výkon: ~10x rychlejší vyhledávání než hosts.txt - Formát: Binární databázový formát\nZastaralá jmenná služba: - Formát: Prostý text hosts.txt - Stav: Zastaralé, ale stále podporované - Případ použití: Ruční úpravy, správa verzí\nPravidla pro názvy hostitelů Názvy hostitelů v I2P musí splňovat:\nPožadavek na TLD: Musí končit na .i2p Maximální délka: Celkem 67 znaků Znaková sada: [a-z], [0-9], . (tečka), - (spojovník) Velikost písmen: Pouze malá Omezení začátku: Nesmí začínat . ani - Zakázané vzory: Nesmí obsahovat .., .- ani -. (od verze 0.6.1.33) Vyhrazeno: Base32 názvy hostitelů *.b32.i2p (52 znaků base32.b32.i2p) Platné příklady example.i2p my-site.i2p test.example.i2p site123.i2p Neplatné příklady example.com # Wrong TLD -invalid.i2p # Starts with hyphen invalid..i2p # Contains double dot invalid.-.i2p # Contains dot-hyphen UPPERCASE.I2P # Must be lowercase verylonghostnameover67charactersthatexceedsthemaximumlength.i2p # Too long Správa odběrů subscriptions.txt Umístění: $I2P_CONFIG_DIR/addressbook/subscriptions.txt Formát: Jedna adresa URL na řádek Výchozí: http://i2p-projekt.i2p/hosts.txt Formát odběrového kanálu (od verze 0.9.26) Pokročilý formát kanálu s metadaty:\n# # I2P Address Book Subscription Feed # Format: hostname=destination [#property=value ...] # example.i2p=base64destination #added=20250101 #src=manual another.i2p=base64destination #added=20250102 #src=feed1 Vlastnosti metadat: - added: Datum, kdy byl název hostitele přidán (formát YYYYMMDD) - src: Identifikátor zdroje - sig: Volitelný podpis\nZpětná kompatibilita: Jednoduchý formát hostname=destination je nadále podporován.\nPříklad konfigurace # Address book locations router_addressbook=../hosts.txt privatehosts.txt=$CONFIG/addressbook/privatehosts.txt userhosts.txt=$CONFIG/addressbook/userhosts.txt hosts.txt=$CONFIG/addressbook/hosts.txt # Naming service naming.service=BlockfileNamingService naming.service.blockfile.location=$CONFIG/addressbook/hostsdb.blockfile # Subscriptions subscriptions.txt=$CONFIG/addressbook/subscriptions.txt subscriptions.schedule=daily subscriptions.proxy=false Konfigurace I2PSnarku (i2psnark.config.d/i2psnark.config) Umístění: $I2P_CONFIG_DIR/i2psnark.config.d/i2psnark.config Aplikace: I2PSnark BitTorrent klient Konfigurační rozhraní: Webové GUI na http://127.0.0.1:7657/i2psnark\nStruktura adresářů $I2P_CONFIG_DIR/i2psnark.config.d/ ├── i2psnark.config ├── [torrent-hash-1]/ │ └── *.config ├── [torrent-hash-2]/ │ └── *.config └── ... Hlavní konfigurace (i2psnark.config) Minimální výchozí konfigurace:\ni2psnark.dir=i2psnark Další vlastnosti spravované přes webové rozhraní:\n# Basic settings i2psnark.dir=i2psnark i2psnark.autoStart=false i2psnark.openTrackers=true # Network settings i2psnark.uploaders=8 i2psnark.upBW=40 i2psnark.seedPct=100 # I2CP settings i2psnark.i2cpHost=127.0.0.1 i2psnark.i2cpPort=7654 Konfigurace jednotlivého torrentu Umístění: $I2P_CONFIG_DIR/i2psnark.config.d/[torrent-hash]/*.config Formát: Nastavení pro jednotlivé torrenty Správa: Automatická (přes webové GUI)\nMezi vlastnosti patří: - Nastavení nahrávání/stahování specifická pro torrent - Priority souborů - Informace o trackeru - Limity peerů\nPoznámka: Konfigurace torrentů se primárně spravují prostřednictvím webového rozhraní. Ruční úpravy se nedoporučují.\nUspořádání dat torrentu Úložiště dat je oddělené od konfigurace:\n$I2P_CONFIG_DIR/i2psnark/ # Data directory ├── *.torrent # Torrent metadata files ├── *.torrent.downloaded/ # Downloaded file directories ├── file1.dat # Direct file downloads └── ... $I2P_CONFIG_DIR/i2psnark.config.d/ # Configuration directory ├── i2psnark.config # Main config └── [hashes]/ # Per-torrent configs Konfigurace I2PTunnel (i2ptunnel.config) Umístění: $I2P_CONFIG_DIR/i2ptunnel.config (starší) nebo $I2P_CONFIG_DIR/i2ptunnel.config.d/ (moderní) Konfigurační rozhraní: Router console na /i2ptunnel Změna formátu: Verze 0.9.42 (srpen 2019)\nStruktura adresářů (verze 0.9.42+) Od verze 0.9.42 je výchozí soubor i2ptunnel.config automaticky rozdělen:\n$I2P_CONFIG_DIR/ ├── i2ptunnel.config.d/ │ ├── http-proxy/ │ │ └── tunnel.config │ ├── irc-proxy/ │ │ └── tunnel.config │ ├── ssh-service/ │ │ └── tunnel.config │ └── ... └── i2ptunnel.config (legacy, auto-migrated) Zásadní rozdíl ve formátu: - Monolitický formát: Vlastnosti s prefixem tunnel.N. - Rozdělený formát: Vlastnosti NEJSOU s prefixem (např. description=, nikoli tunnel.0.description=)\nChování při migraci Při prvním spuštění po aktualizaci na 0.9.42: 1. Stávající i2ptunnel.config se načte 2. V i2ptunnel.config.d/ se vytvoří jednotlivé konfigurace pro každý tunnel 3. V rozdělených souborech jsou u vlastností odstraněny předpony 4. Původní soubor je zálohován 5. Starší formát je nadále podporován kvůli zpětné kompatibilitě\nKonfigurační sekce Konfigurace I2PTunnel je podrobně popsána v níže uvedené části Referenční příručka konfigurace I2PTunnel . Popisy vlastností platí jak pro monolitický (tunnel.N.property), tak i pro dělený (property) formát.\nReferenční příručka ke konfiguraci I2PTunnel Tato část poskytuje kompletní technickou referenci ke všem konfiguračním vlastnostem I2PTunnel. Vlastnosti jsou uvedeny v rozděleném formátu (bez prefixu tunnel.N.). Pro monolitický formát přidejte ke všem vlastnostem prefix tunnel.N., kde N je číslo pro daný tunnel.\nDůležité: Vlastnosti popsané ve tvaru tunnel.N.option.i2cp.* jsou implementovány v I2PTunnel a NEJSOU podporovány prostřednictvím jiných rozhraní, jako je protokol I2CP nebo SAM API.\nZákladní vlastnosti tunnel.N.description (popis) Typ: Řetězec Kontext: Všechny tunnels Popis: Člověku srozumitelný popis tunnelu pro zobrazení v UI Příklad: description=HTTP Proxy for outproxy access tunnel.N.name (název) Typ: Řetězec Kontext: Všechny tunnels Povinné: Ano Popis: Jedinečný identifikátor pro tunnel a zobrazovaný název Příklad: name=I2P HTTP Proxy tunnel.N.type (typ) Typ: Výčet Kontext: Všechny tunnel Povinné: Ano Hodnoty: client - Obecný klientský tunnel httpclient - Klient HTTP proxy ircclient - IRC klientský tunnel socksirctunnel - SOCKS IRC proxy sockstunnel - SOCKS proxy (verze 4, 4a, 5) connectclient - Klient CONNECT proxy streamrclient - Klient Streamr server - Obecný serverový tunnel httpserver - HTTP serverový tunnel ircserver - IRC serverový tunnel httpbidirserver - Obousměrný HTTP server streamrserver - Streamr server tunnel.N.interface (rozhraní) Typ: Řetězec (IP adresa nebo název hostitele) Kontext: Pouze pro Client tunnels Výchozí: 127.0.0.1 Popis: Místní rozhraní, na které se má navázat pro příchozí připojení Bezpečnostní poznámka: Vázání na 0.0.0.0 umožňuje vzdálená připojení Příklad: interface=127.0.0.1 tunnel.N.listenPort (listenPort) Typ: Celé číslo Kontext: Pouze klientské tunnels Rozsah: 1-65535 Popis: Místní port, na kterém se naslouchá pro klientská spojení Příklad: listenPort=4444 tunnel.N.targetHost (targetHost) Typ: Řetězec (IP adresa nebo název hostitele) Kontext: Pouze server tunnels Popis: Místní server, na který se mají přeposílat připojení Příklad: targetHost=127.0.0.1 tunnel.N.targetPort (targetPort) Typ: Celé číslo Kontext: Pouze serverové tunnels Rozsah: 1-65535 Popis: Port na targetHost, ke kterému se připojit Příklad: targetPort=80 tunnel.N.targetDestination (targetDestination) Typ: Řetězec (destinace oddělené čárkou nebo mezerou) Kontext: Pouze klientské tunnels Formát: destination[:port][,destination[:port]] Popis: I2P destinace, ke kterým se připojit Příklady: targetDestination=example.i2p targetDestination=example.i2p:8080 targetDestination=site1.i2p,site2.i2p:8080 tunnel.N.i2cpHost (i2cpHost) Typ: Řetězec (IP adresa nebo název hostitele) Výchozí: 127.0.0.1 Popis: adresa rozhraní I2CP pro I2P router Poznámka: Ignorováno při běhu v kontextu routeru Příklad: i2cpHost=127.0.0.1 tunnel.N.i2cpPort (i2cpPort) Typ: celé číslo Výchozí: 7654 Rozsah: 1-65535 Popis: port I2CP routeru I2P Poznámka: Ignorováno při běhu v kontextu routeru Příklad: i2cpPort=7654 tunnel.N.startOnLoad (startOnLoad) Typ: Logická hodnota Výchozí: true Popis: Zda spustit tunnel při načtení I2PTunnel Příklad: startOnLoad=true Konfigurace proxy tunnel.N.proxyList (proxyList) Typ: Řetězec (názvy hostitelů oddělené čárkami nebo mezerami) Kontext: Pouze proxy HTTP a SOCKS Popis: Seznam hostitelů outproxy Příklad: proxyList=outproxy.example.i2p,backup.example.i2p Konfigurace serveru tunnel.N.privKeyFile (privKeyFile) Type: Řetězec (cesta k souboru) Context: Servery a trvalé klientské tunnels Description: Soubor obsahující soukromé klíče Destination (identifikátor cíle) pro trvalé použití Path: Absolutní nebo relativní vzhledem ke konfiguračnímu adresáři I2P Example: privKeyFile=eepsite/eepPriv.dat tunnel.N.spoofedHost (spoofedHost) Typ: Řetězec (název hostitele) Kontext: Pouze pro HTTP servery Výchozí: Base32 název hostitele cíle Popis: Hodnota hlavičky Host předaná lokálnímu serveru Příklad: spoofedHost=example.i2p tunnel.N.spoofedHost.NNNN (spoofedHost.NNNN) Typ: Řetězec (název hostitele) Kontext: Pouze servery HTTP Popis: Přepsání virtuálního hostitele pro konkrétní příchozí port Případ použití: Hostovat více webů na různých portech Příklad: spoofedHost.8080=site1.example.i2p Možnosti specifické pro klienta tunnel.N.sharedClient (sharedClient) Typ: Boolean Kontext: Pouze client tunnels Výchozí: false Popis: Zda může být tento tunnel sdílen více klienty Příklad: sharedClient=false tunnel.N.option.persistentClientKey (persistentClientKey) Typ: Boolean Kontext: Pouze klientské tunnels Výchozí: false Popis: Ukládat a znovu používat klíče destinace napříč restarty Konflikt: Vzájemně se vylučuje s i2cp.newDestOnResume=true Příklad: option.persistentClientKey=true Možnosti I2CP (implementace I2PTunnel) Důležité: Tyto vlastnosti mají předponu option.i2cp., ale jsou implementovány v I2PTunnel, nikoli ve vrstvě protokolu I2CP. Nejsou k dispozici prostřednictvím I2CP ani SAM API.\ntunnel.N.option.i2cp.delayOpen (option.i2cp.delayOpen) Typ: Logická hodnota Kontext: Pouze klientské tunnely Výchozí: false Popis: Odloží vytvoření tunnelu až do prvního připojení Scénář použití: Šetří prostředky u zřídka používaných tunnelů Příklad: option.i2cp.delayOpen=false tunnel.N.option.i2cp.newDestOnResume (option.i2cp.newDestOnResume) Typ: Boolean Kontext: Pouze pro client tunnels Výchozí: false Vyžaduje: i2cp.closeOnIdle=true Konflikt: Vzájemně se vylučuje s persistentClientKey=true Popis: Vytvořit nový cíl po vypršení časového limitu nečinnosti Příklad: option.i2cp.newDestOnResume=false tunnel.N.option.i2cp.leaseSetPrivateKey (option.i2cp.leaseSetPrivateKey) Typ: Řetězec (base64-kódovaný klíč) Kontext: Pouze serverové tunnels Popis: Trvalý soukromý šifrovací klíč pro leaseset Použití: Zachovat konzistentní šifrovaný leaseset mezi restarty Příklad: option.i2cp.leaseSetPrivateKey=AAAA...base64... tunnel.N.option.i2cp.leaseSetSigningPrivateKey (option.i2cp.leaseSetSigningPrivateKey) Typ: Řetězec (sigtype:base64) Kontext: Pouze pro serverové tunnels Formát: sigtype:base64key Popis: Trvalý soukromý klíč pro podepisování leaseset Příklad: option.i2cp.leaseSetSigningPrivateKey=7:AAAA...base64... Možnosti specifické pro server tunnel.N.option.enableUniqueLocal (option.enableUniqueLocal) Typ: Boolean Kontext: Pouze serverové tunnels Výchozí: false Popis: Použít jedinečnou místní IP pro každou vzdálenou I2P destinaci Případ použití: Sledovat IP klientů v serverových protokolech Poznámka k zabezpečení: Může snížit anonymitu Příklad: option.enableUniqueLocal=false tunnel.N.option.targetForPort.NNNN (option.targetForPort.NNNN) Typ: Řetězec (název hostitele:port) Kontext: Pouze pro serverové tunnels Popis: Přepíše targetHost/targetPort pro příchozí port NNNN Použití: Směrování podle portu na různé lokální služby Příklad: option.targetForPort.8080=localhost:8080 Konfigurace fondu vláken tunnel.N.option.i2ptunnel.usePool (option.i2ptunnel.usePool) Typ: Logická hodnota Kontext: Pouze pro serverové tunnels Výchozí: true Popis: Použít pool vláken pro zpracování spojení Poznámka: Vždy false pro standardní servery (ignorováno) Příklad: option.i2ptunnel.usePool=true tunnel.N.option.i2ptunnel.blockingHandlerCount (option.i2ptunnel.blockingHandlerCount) Typ: Celé číslo Kontext: Pouze pro server tunnels Výchozí: 65 Popis: Maximální velikost fondu vláken Poznámka: Ignorováno u standardních serverů Příklad: option.i2ptunnel.blockingHandlerCount=100 Možnosti klienta HTTP tunnel.N.option.i2ptunnel.httpclient.allowInternalSSL (option.i2ptunnel.httpclient.allowInternalSSL) Typ: Boolean Kontext: Pouze pro klienty HTTP Výchozí: false Popis: Povolit SSL připojení k adresám .i2p Příklad: option.i2ptunnel.httpclient.allowInternalSSL=false tunnel.N.option.i2ptunnel.httpclient.disableAddressHelper (option.i2ptunnel.httpclient.disableAddressHelper) Typ: Logická hodnota Kontext: Pouze klienti HTTP Výchozí: false Popis: Zakázat odkazy address helper (pomocník s adresami) v odpovědích proxy Příklad: option.i2ptunnel.httpclient.disableAddressHelper=false tunnel.N.option.i2ptunnel.httpclient.jumpServers (option.i2ptunnel.httpclient.jumpServers) Typ: Řetězec (URL oddělené čárkami nebo mezerami) Kontext: pouze klienti HTTP Popis: Adresy URL Jump serverů (serverů poskytujících \u0026ldquo;jump\u0026rdquo; odkazy pro rozlišení názvů hostitelů) Příklad: option.i2ptunnel.httpclient.jumpServers=http://jump.i2p/jump,http://stats.i2p/jump tunnel.N.option.i2ptunnel.httpclient.sendAccept (option.i2ptunnel.httpclient.sendAccept) Typ: logická hodnota (Boolean) Kontext: pouze pro HTTP klienty Výchozí: false Popis: Předávat hlavičky Accept-* (kromě Accept a Accept-Encoding) Příklad: option.i2ptunnel.httpclient.sendAccept=false tunnel.N.option.i2ptunnel.httpclient.sendReferer (option.i2ptunnel.httpclient.sendReferer) Typ: Logická hodnota Kontext: Jen pro klienty HTTP Výchozí: false Popis: Předávat hlavičky Referer přes proxy Poznámka k ochraně soukromí: Může vést k úniku informací Příklad: option.i2ptunnel.httpclient.sendReferer=false tunnel.N.option.i2ptunnel.httpclient.sendUserAgent (option.i2ptunnel.httpclient.sendUserAgent) Typ: Booleovská hodnota Kontext: pouze klienti HTTP Výchozí: false Popis: Propouštět hlavičky User-Agent přes proxy Poznámka k ochraně soukromí: Může unikat informace o prohlížeči Příklad: option.i2ptunnel.httpclient.sendUserAgent=false tunnel.N.option.i2ptunnel.httpclient.sendVia (option.i2ptunnel.httpclient.sendVia) Typ: Boolean Kontext: Pouze klienti HTTP Výchozí: false Popis: Předávat hlavičky Via přes proxy Příklad: option.i2ptunnel.httpclient.sendVia=false tunnel.N.option.i2ptunnel.httpclient.SSLOutproxies (option.i2ptunnel.httpclient.SSLOutproxies) Typ: Řetězec (destinace oddělené čárkou nebo mezerou) Kontext: Pouze klienti HTTP Popis: SSL výstupní proxy v rámci sítě pro HTTPS Příklad: option.i2ptunnel.httpclient.SSLOutproxies=ssl-outproxy.i2p tunnel.N.option.i2ptunnel.useLocalOutproxy (option.i2ptunnel.useLocalOutproxy) Typ: Boolean Kontext: Pouze HTTP klienti Výchozí: true Popis: Použít registrované lokální zásuvné moduly outproxy Příklad: option.i2ptunnel.useLocalOutproxy=true Autentizace klienta HTTP tunnel.N.option.proxyAuth (option.proxyAuth) Typ: výčtový typ Kontext: Pouze klienti HTTP Výchozí: false Hodnoty: true, false, basic, digest Popis: Vyžaduje lokální autentizaci pro přístup k proxy Poznámka: true je ekvivalentní basic Příklad: option.proxyAuth=basic tunnel.N.option.proxy.auth.USER.md5 (option.proxy.auth.USER.md5) Typ: Řetězec (32znakový hexadecimální řetězec malými písmeny) Kontext: pouze HTTP klienti Vyžaduje: proxyAuth=basic nebo proxyAuth=digest Popis: MD5 hash hesla pro uživatele USER Zastaralé: místo toho použijte SHA-256 (0.9.56+) Příklad: option.proxy.auth.alice.md5=5f4dcc3b5aa765d61d8327deb882cf99 tunnel.N.option.proxy.auth.USER.sha256 (option.proxy.auth.USER.sha256) Typ: Řetězec (64 znaků, hexadecimální, malými písmeny) Kontext: Pouze klienti HTTP Vyžaduje: proxyAuth=digest Od verze: Verze 0.9.56 Standard: RFC 7616 Popis: SHA-256 hash hesla pro uživatele USER Příklad: option.proxy.auth.alice.sha256=5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8 Autentizace outproxy (proxy z I2P do běžného internetu) tunnel.N.option.outproxyAuth (option.outproxyAuth) Typ: Boolean Kontext: Pouze pro HTTP klienty Výchozí: false Popis: Odesílat údaje pro ověření na outproxy (výstupní proxy) Příklad: option.outproxyAuth=false tunnel.N.option.outproxyUsername (option.outproxyUsername) Typ: řetězec Kontext: pouze klienti HTTP Vyžaduje: outproxyAuth=true Popis: Uživatelské jméno pro ověření u outproxy (výstupní proxy) Příklad: option.outproxyUsername=user tunnel.N.option.outproxyPassword (option.outproxyPassword) Typ: řetězec Kontext: pouze pro klienty HTTP Vyžaduje: outproxyAuth=true Popis: Heslo pro ověření u outproxy (výstupní proxy do clearnetu) Zabezpečení: Uloženo v prostém textu Příklad: option.outproxyPassword=secret Možnosti klienta SOCKS tunnel.N.option.i2ptunnel.socks.proxy.default (option.i2ptunnel.socks.proxy.default) Typ: Řetězec (destinace oddělené čárkami nebo mezerami) Kontext: pouze pro klienty SOCKS Popis: Outproxy v rámci I2P pro nespecifikované porty Příklad: option.i2ptunnel.socks.proxy.default=outproxy.i2p tunnel.N.option.i2ptunnel.socks.proxy.NNNN (option.i2ptunnel.socks.proxy.NNNN) Typ: Řetězec (destinace oddělené čárkami nebo mezerami) Kontext: pouze pro klienty SOCKS Popis: výstupní proxy v rámci sítě konkrétně pro port NNNN Příklad: option.i2ptunnel.socks.proxy.443=ssl-outproxy.i2p tunnel.N.option.outproxyType (option.outproxyType) Typ: výčtový typ Kontext: pouze klienti SOCKS Výchozí: socks Od: verze 0.9.57 Hodnoty: socks, connect (HTTPS) Popis: Typ konfigurované výstupní proxy Příklad: option.outproxyType=connect Možnosti serveru HTTP tunnel.N.option.maxPosts (option.maxPosts) Typ: Celé číslo Kontext: Pouze pro HTTP servery Výchozí: 0 (neomezeno) Popis: Maximální počet požadavků POST z jedné destinace za postCheckTime Příklad: option.maxPosts=10 tunnel.N.option.maxTotalPosts (option.maxTotalPosts) Typ: Celé číslo Kontext: Pouze HTTP servery Výchozí: 0 (neomezeno) Popis: Maximální počet požadavků POST ze všech destinací za postCheckTime Příklad: option.maxTotalPosts=50 tunnel.N.option.postCheckTime (option.postCheckTime) Typ: Celé číslo (sekundy) Kontext: Pouze pro HTTP servery Výchozí: 300 Popis: Časové okno pro kontrolu limitů POST Příklad: option.postCheckTime=600 tunnel.N.option.postBanTime (option.postBanTime) Typ: celé číslo (sekundy) Kontext: pouze pro HTTP servery Výchozí: 1800 Popis: Doba blokace po překročení limitu maxPosts pro jednu destinaci Příklad: option.postBanTime=3600 tunnel.N.option.postTotalBanTime (option.postTotalBanTime) Typ: celé číslo (sekundy) Kontext: jen pro HTTP servery Výchozí: 600 Popis: Doba trvání banu po překročení maxTotalPosts Příklad: option.postTotalBanTime=1200 Možnosti zabezpečení HTTP serveru tunnel.N.option.rejectInproxy (option.rejectInproxy) Typ: Boolean Kontext: Pouze pro HTTP servery Výchozí: false Popis: Odmítat připojení, která zřejmě přicházejí přes inproxy (vstupní proxy) Příklad: option.rejectInproxy=false tunnel.N.option.rejectReferer (option.rejectReferer) Typ: Logická hodnota Kontext: Pouze HTTP servery Výchozí: false Od: Verze 0.9.25 Popis: Odmítá připojení s hlavičkou Referer Příklad: option.rejectReferer=false tunnel.N.option.rejectUserAgents (option.rejectUserAgents) Typ: Boolean Kontext: Pouze pro HTTP servery Výchozí: false Od: verze 0.9.25 Vyžaduje: vlastnost userAgentRejectList Popis: Odmítne připojení, pokud User-Agent odpovídá Příklad: option.rejectUserAgents=false tunnel.N.option.userAgentRejectList (option.userAgentRejectList) Typ: Řetězec (řetězce pro porovnání oddělené čárkami) Kontext: Pouze HTTP servery Od: Verze 0.9.25 Rozlišování velikosti písmen: Porovnávání rozlišující velikost písmen Speciální: \u0026ldquo;none\u0026rdquo; (od 0.9.33) odpovídá prázdnému User-Agent (HTTP hlavička identifikující klienta) Popis: Seznam vzorů User-Agent, které se mají odmítnout Příklad: option.userAgentRejectList=Mozilla,Opera,none Možnosti IRC serveru tunnel.N.option.ircserver.fakeHostname (option.ircserver.fakeHostname) Typ: Řetězec (vzor názvu hostitele) Kontext: pouze IRC servery Výchozí: %f.b32.i2p Tokeny: %f = Úplný hash cíle v base32 %c = Zastřený hash cíle (viz cloakKey) Popis: Formát názvu hostitele odesílaný IRC serveru Příklad: option.ircserver.fakeHostname=%c.irc.i2p tunnel.N.option.ircserver.cloakKey (option.ircserver.cloakKey) Typ: Řetězec (heslová fráze) Kontext: Pouze IRC servery Výchozí: Náhodné pro každou relaci Omezení: Bez uvozovek ani mezer Popis: Heslová fráze pro konzistentní maskování názvu hostitele Případ použití: Trvalé sledování uživatele napříč restarty/servery Příklad: option.ircserver.cloakKey=mysecretkey tunnel.N.option.ircserver.method (option.ircserver.method) Typ: výčtový typ Kontext: pouze pro servery IRC Výchozí: user Hodnoty: user, webirc Popis: Metoda ověřování pro server IRC Příklad: option.ircserver.method=webirc tunnel.N.option.ircserver.webircPassword (option.ircserver.webircPassword) Typ: Řetězec (heslo) Kontext: Pouze pro servery IRC Vyžaduje: method=webirc Omezení: Bez uvozovek ani mezer Popis: Heslo pro autentizaci protokolu WEBIRC Příklad: option.ircserver.webircPassword=webircpass tunnel.N.option.ircserver.webircSpoofIP (option.ircserver.webircSpoofIP) Typ: Řetězec (IP adresa) Kontext: Pouze pro servery IRC Vyžaduje: method=webirc Popis: Podvržená IP adresa pro protokol WEBIRC Příklad: option.ircserver.webircSpoofIP=10.0.0.1 Konfigurace SSL/TLS tunnel.N.option.useSSL (option.useSSL) Typ: Boolean Výchozí hodnota: false Kontext: Všechny tunnels Chování: Servery: Používat SSL pro připojení k místnímu serveru Klienti: Vyžadovat SSL od místních klientů Příklad: option.useSSL=false tunnel.N.option.keystoreFile (option.keystoreFile) Typ: Řetězec (cesta k souboru) Kontext: Pouze client tunnels Výchozí: i2ptunnel-(random).ks Cesta: Relativní vůči $(I2P_CONFIG_DIR)/keystore/, pokud není absolutní Automaticky generováno: Vytvoří se, pokud neexistuje Popis: Soubor keystore (úložiště klíčů) obsahující soukromý klíč SSL Příklad: option.keystoreFile=my-tunnel.ks tunnel.N.option.keystorePassword (option.keystorePassword) Typ: Řetězec (heslo) Kontext: Pouze pro klientské tunnels Výchozí: changeit Automaticky generováno: Náhodné heslo, pokud je vytvořen nový keystore (úložiště klíčů) Popis: Heslo pro SSL keystore Příklad: option.keystorePassword=secretpassword tunnel.N.option.keyAlias (option.keyAlias) Typ: Řetězec (alias) Kontext: Pouze klientské tunnels Automaticky generováno: Vytvořeno, pokud je vygenerován nový klíč Popis: Alias pro soukromý klíč v úložišti klíčů Příklad: option.keyAlias=mytunnel-key tunnel.N.option.keyPassword (option.keyPassword) Typ: Řetězec (heslo) Kontext: Pouze pro Client tunnels Automaticky generováno: Náhodné heslo, pokud je vytvořen nový klíč Popis: Heslo pro soukromý klíč v úložišti klíčů Příklad: option.keyPassword=keypass123 Obecné možnosti I2CP a streamování Všechny vlastnosti tunnel.N.option.* (které nejsou výše výslovně dokumentovány) jsou předávány rozhraní I2CP a streamovací knihovně s odstraněným prefixem tunnel.N.option..\nDůležité: Tato nastavení jsou oddělená od nastavení specifických pro I2PTunnel. Viz: - Specifikace I2CP - Specifikace streamingové knihovny Ukázkové možnosti streamování:\noption.i2cp.messageReliability=BestEffort option.i2p.streaming.connectDelay=1000 option.i2p.streaming.maxWindowSize=128 Kompletní příklad pro Tunnel # HTTP Proxy (split format without tunnel.N. prefix) name=I2P HTTP Proxy description=HTTP proxy for accessing I2P sites and outproxy type=httpclient interface=127.0.0.1 listenPort=4444 targetDestination= sharedClient=true startOnLoad=true # I2CP configuration i2cpHost=127.0.0.1 i2cpPort=7654 # HTTP client options option.i2ptunnel.httpclient.allowInternalSSL=false option.i2ptunnel.httpclient.disableAddressHelper=false option.i2ptunnel.httpclient.jumpServers=http://stats.i2p/cgi-bin/jump.cgi option.i2ptunnel.httpclient.sendAccept=false option.i2ptunnel.httpclient.sendReferer=false option.i2ptunnel.httpclient.sendUserAgent=false # Proxy authentication option.proxyAuth=false # Outproxy configuration option.i2ptunnel.httpclient.SSLOutproxies=false.i2p proxyList=false.i2p # Client behavior option.persistentClientKey=false option.i2cp.delayOpen=false # I2CP tunnel options option.inbound.length=3 option.outbound.length=3 option.inbound.quantity=2 option.outbound.quantity=2 Historie verzí a časová osa funkcí Verze 0.9.10 (2013) Funkce: Podpora prázdných hodnot v konfiguračních souborech - Klíče s prázdnými hodnotami (key=) jsou nyní podporovány - Dříve byly ignorovány nebo způsobovaly chyby při parsování\nVerze 0.9.18 (2015) Funkce: Konfigurace intervalu vyprazdňování vyrovnávací paměti loggeru - Vlastnost: logger.flushInterval (výchozí 29 sekund) - Snižuje diskové I/O při zachování přijatelné latence zapisování do logu\nVerze 0.9.23 (listopad 2015) Zásadní změna: Java 7 je minimální požadavek - podpora Javy 6 ukončena - vyžadováno pro další aktualizace zabezpečení\nVerze 0.9.25 (2015) Funkce: Možnosti zabezpečení HTTP serveru - tunnel.N.option.rejectReferer - Odmítat požadavky s hlavičkou Referer - tunnel.N.option.rejectUserAgents - Odmítat vybrané hlavičky User-Agent - tunnel.N.option.userAgentRejectList - Vzory User-Agent k odmítnutí - Případ použití: Omezit webové roboty (crawlers) a nežádoucí klienty\nVerze 0.9.33 (leden 2018) Funkce: Vylepšené filtrování User-Agentu - řetězec userAgentRejectList \u0026ldquo;none\u0026rdquo; odpovídá prázdnému User-Agentu - Další opravy chyb pro i2psnark, i2ptunnel, streaming, SusiMail\nVerze 0.9.41 (2019) Zrušení podpory: BOB Protocol (protokol BOB) byl odstraněn z Androidu - uživatelé systému Android musí přejít na SAM (rozhraní Simple Anonymous Messaging) nebo I2CP\nVerze 0.9.42 (srpen 2019) Zásadní změna: Rozdělení konfiguračních souborů - clients.config rozdělen do adresářové struktury clients.config.d/ - i2ptunnel.config rozdělen do adresářové struktury i2ptunnel.config.d/ - Automatická migrace při prvním spuštění po aktualizaci - Umožňuje modulární balíčkování a správu zásuvných modulů - Původní monolitický formát je nadále podporován\nDalší funkce: - vylepšení výkonu SSU - prevence propojování napříč sítěmi (Proposal 147) - počáteční podpora typu šifrování\nVerze 0.9.56 (2021) Funkce: Vylepšení zabezpečení a protokolování - logger.gzip - Komprese Gzip pro rotované logy (výchozí: false) - logger.minGzipSize - Minimální velikost pro kompresi (výchozí: 65536 bajtů) - tunnel.N.option.proxy.auth.USER.sha256 - Digest autentizace se SHA-256 (RFC 7616) - Zabezpečení: SHA-256 nahrazuje MD5 pro Digest autentizaci\nVerze 0.9.57 (leden 2023) Funkce: Konfigurace typu SOCKS outproxy (výstupní proxy) - tunnel.N.option.outproxyType - Vyberte typ outproxy (socks|connect) - Výchozí: socks - Podpora HTTPS CONNECT pro HTTPS outproxy\nVerze 2.6.0 (červenec 2024) Zpětně nekompatibilní změna: I2P-over-Tor zablokováno - Připojení z IP adres výstupních uzlů Tor jsou nyní odmítána - Důvod: zhoršuje výkon I2P, plýtvá prostředky výstupních uzlů Tor - Dopad: Uživatelé, kteří přistupují k I2P přes výstupní uzly Tor, budou blokováni - Nevýstupní uzly a klienti Tor nejsou ovlivněni\nVerze 2.10.0 (září 2025 - současnost) Hlavní funkce: - Post-kvantová kryptografie k dispozici (volitelně přes Hidden Service Manager) - Podpora UDP trackeru pro I2PSnark ke snížení zátěže trackeru - Stabilita Hidden Mode vylepšení ke snížení vyčerpávání RouterInfo - Vylepšení sítě pro přetížené routery - Vylepšené procházení UPnP/NAT - Vylepšení NetDB s agresivním odstraňováním leaseset - Snížení pozorovatelnosti u událostí routeru\nKonfigurace: Nebyly přidány žádné nové konfigurační vlastnosti\nKritická nadcházející změna: Příští vydání (pravděpodobně 2.11.0 nebo 3.0.0) bude vyžadovat Javu 17 nebo novější\nZastarání a zpětně nekompatibilní změny Kritická zastarání Přístup I2P-over-Tor (Verze 2.6.0+) Stav: BLOKOVÁNO od července 2024 Dopad: Připojení z IP adres výstupních uzlů Toru jsou odmítána Důvod: Zhoršuje výkon sítě I2P, aniž by poskytovalo výhody v oblasti anonymity Týká se: Pouze výstupních uzlů Toru, nikoli přeposílacích uzlů (relay) ani běžných klientů Toru Alternativa: Používejte I2P nebo Tor samostatně, ne dohromady Ověřování Digest (MD5) Stav: Zastaralé (použijte SHA-256) Vlastnost: tunnel.N.option.proxy.auth.USER.md5 Důvod: MD5 je kryptograficky prolomený Náhrada: tunnel.N.option.proxy.auth.USER.sha256 (od verze 0.9.56) Časová osa: MD5 je stále podporován, ale nedoporučuje se Změny v architektuře konfigurace Monolitické konfigurační soubory (Verze 0.9.42+) Dotčeno: clients.config, i2ptunnel.config Stav: Zastaralé ve prospěch rozdělené adresářové struktury Migrace: Automatická při prvním spuštění po upgradu na 0.9.42 Kompatibilita: Původní formát stále funguje (zpětně kompatibilní) Doporučení: Pro nové konfigurace používejte rozdělený formát Požadavky na verzi Javy Podpora Javy 6 Ukončeno: Verze 0.9.23 (listopad 2015) Minimum: Java 7 je vyžadována od verze 0.9.23 Požadavek na Javu 17 (nadcházející) Stav: KRITICKÁ NADCHÁZEJÍCÍ ZMĚNA Cíl: Další hlavní vydání po 2.10.0 (pravděpodobně 2.11.0 nebo 3.0.0) Aktuální minimum: Java 8 Vyžadovaná akce: Připravte se na migraci na Javu 17 Časový plán: Bude oznámen spolu s poznámkami k vydání Odebrané funkce Protokol BOB (Android) Odstraněno: Verze 0.9.41 Platforma: Pouze Android Alternativa: protokoly SAM nebo I2CP Desktop: BOB je stále dostupný na desktopových platformách Doporučené migrace Ověřování: Přejít z MD5 na digest autentizaci se SHA-256 Formát konfigurace: Přejít na rozdělenou adresářovou strukturu pro klienty a tunnels Běhové prostředí Java: Naplánovat aktualizaci na Java 17 před příštím hlavním vydáním Integrace s Tor: Nesměrovat I2P přes výstupní uzly Toru Reference Oficiální dokumentace Specifikace konfigurace I2P - Oficiální specifikace formátu konfiguračního souboru Specifikace zásuvných modulů I2P - Konfigurace a balení zásuvných modulů Společné struktury I2P - mapování typů - Formát serializace dat protokolu Formát Java Properties - Specifikace základního formátu Zdrojový kód Repozitář I2P Java Routeru - zrcadlo na GitHubu Gitea vývojářů I2P - Oficiální repozitář zdrojových kódů I2P DataHelper.java - Implementace I/O pro konfigurační soubory Komunitní zdroje Fórum I2P - Aktivní komunitní diskuse a podpora Web I2P - Oficiální web projektu Dokumentace API DataHelper JavaDoc - Dokumentace API k metodám konfiguračních souborů Stav specifikace Poslední aktualizace specifikace: leden 2023 (verze 0.9.57) Aktuální verze I2P: 2.10.0 (září 2025) Technická přesnost: Specifikace zůstává přesná do verze 2.10.0 (bez zpětně nekompatibilních změn) Údržba: Živý dokument, aktualizovaný při změně formátu konfigurace ","description":"Konfigurační možnosti a formáty pro I2P routery a klienty","id":"b6b01c53245c0e36ca08c56f843abb7f","section":"docs","title":"Konfigurace routeru","url":"/cs/docs/specs/configuration/"},{"categories":null,"content":"Tento průvodce ukazuje, jak nakonfigurovat běžné prohlížeče pro odesílání provozu přes vestavěnou HTTP proxy I2P. Pokrývá prohlížeče Safari, Firefox a Chrome/Chromium s podrobnými pokyny krok za krokem.\nDůležité poznámky:\nVýchozí HTTP proxy I2P naslouchá na 127.0.0.1:4444. I2P chrání provoz uvnitř sítě I2P (stránky .i2p). Ujistěte se, že váš I2P router běží před konfigurací prohlížeče. Safari (macOS) Safari používá celostystémová nastavení proxy na macOS.\nStep 1: Open Network Settings Otevřete Safari a přejděte do Safari → Nastavení (nebo Předvolby) Klikněte na záložku Pokročilé V sekci Proxy klikněte na Změnit nastavení\u0026hellip; Toto otevře síťová nastavení vašeho Macu.\nKrok 1: Otevřete nastavení sítě V nastavení sítě zaškrtněte políčko Web Proxy (HTTP) Zadejte následující údaje: Web Proxy Server: 127.0.0.1 Port: 4444 Klikněte na OK pro uložení nastavení Nyní můžete procházet stránky .i2p v Safari!\nPoznámka: Tato nastavení proxy ovlivní všechny aplikace, které používají systémové proxy macOS. Zvažte vytvoření samostatného uživatelského účtu nebo použití jiného prohlížeče výhradně pro I2P, pokud chcete izolovat procházení I2P.\nFirefox (Desktop) Firefox má vlastní nastavení proxy nezávislé na systému, což z něj činí ideální volbu pro vyhrazené procházení I2P.\nKrok 2: Konfigurace HTTP Proxy Klikněte na tlačítko nabídky (☰) v pravém horním rohu Vyberte Nastavení Step 2: Find Proxy Settings Do vyhledávacího pole Nastavení napište \u0026ldquo;proxy\u0026rdquo; Přejděte na Nastavení sítě Klikněte na tlačítko Nastavení\u0026hellip; Krok 1: Otevřete Nastavení Vyberte Ruční konfigurace proxy Zadejte následující: HTTP Proxy: 127.0.0.1 Port: 4444 Nechte SOCKS Host prázdné (pokud specificky nepotřebujete SOCKS proxy) Zaškrtněte Proxy DNS when using SOCKS pouze pokud používáte SOCKS proxy Klikněte na OK pro uložení Nyní můžete procházet .i2p stránky ve Firefoxu!\nTip: Zvažte vytvoření samostatného profilu Firefoxu věnovaného prohlížení I2P. Tím udržíte prohlížení I2P oddělené od běžného prohlížení. Pro vytvoření profilu zadejte about:profiles do adresního řádku Firefoxu.\nChrome / Chromium (Desktop) Chrome a prohlížeče založené na Chromiu (Brave, Edge atd.) obvykle používají systémová nastavení proxy na Windows a macOS. Tento průvodce ukazuje konfiguraci pro Windows.\nKrok 2: Najděte nastavení proxy Klikněte na menu tří teček (⋮) v pravém horním rohu Vyberte Nastavení Krok 3: Konfigurace manuálního proxy Do vyhledávacího pole Nastavení napište \u0026ldquo;proxy\u0026rdquo; Klikněte na Otevřít nastavení proxy serveru počítače Step 3: Open Manual Proxy Setup Toto otevře nastavení sítě a internetu ve Windows.\nPosuňte se dolů na Ruční nastavení proxy Klikněte na Nastavit Krok 1: Otevřete nastavení prohlížeče Chrome Přepněte Použít proxy server na Zapnuto Zadejte následující: IP adresa proxy: 127.0.0.1 Port: 4444 Volitelně přidejte výjimky do \u0026ldquo;Nepoužívat proxy server pro adresy začínající\u0026rdquo; (např. localhost;127.*) Klikněte na Uložit Nyní můžete prohlížet .i2p stránky v Chromu!\nPoznámka: Tato nastavení ovlivňují všechny prohlížeče založené na Chromiu a některé další aplikace ve Windows. Chcete-li tomu zabránit, zvažte použití Firefoxu s vyhrazeným I2P profilem.\nKrok 2: Otevřete nastavení proxy Na Linuxu můžete spustit Chrome/Chromium s proxy příznaky, abyste se vyhnuli změně systémových nastavení:\nchromium \\ --proxy-server=\u0026#34;http=127.0.0.1:4444 \\ --proxy-bypass-list=\u0026#34;\u0026lt;-loopback\u0026gt;\u0026#34; Nebo vytvořte spouštěcí skript pro plochu:\n#!/bin/bash chromium --proxy-server=\u0026#34;http=127.0.0.1:4444\u0026#34; --user-data-dir=\u0026#34;$HOME/.config/chromium-i2p\u0026#34; Příznak --user-data-dir vytváří samostatný profil Chrome pro procházení I2P.\nFirefox (Desktop) Moderní buildy Firefoxu \u0026ldquo;Fenix\u0026rdquo; ve výchozím nastavení omezují about:config a rozšíření. IceRaven je fork Firefoxu, který umožňuje kurátorovanou sadu rozšíření a zjednodušuje nastavení proxy.\nKonfigurace založená na rozšíření (IceRaven):\nPokud již používáte IceRaven, zvažte nejprve vymazání historie prohlížení (Menu → Historie → Smazat historii). 2) Otevřete Menu → Doplňky → Správce doplňků. 3) Nainstalujte rozšíření „I2P Proxy for Android and Other Systems\u0026quot;. 4) Prohlížeč nyní bude směrovat provoz přes I2P. Toto rozšíření funguje také v prohlížečích založených na Firefox před verzí Fenix, pokud je nainstalováno z AMO .\nPovolení podpory širokého spektra rozšíření ve Firefox Nightly vyžaduje samostatný proces zdokumentovaný Mozillou .\nInternet Explorer / Windows System Proxy Na Windows se dialogové okno systémového proxy vztahuje na IE a může být použito prohlížeči založenými na Chromiu, když dědí systémová nastavení.\nOtevřete „Nastavení sítě a internetu\u0026quot; → „Proxy\u0026quot;. 2) Povolte „Použít proxy server pro vaši síť LAN\u0026quot;. 3) Nastavte adresu 127.0.0.1, port 4444 pro HTTP. 4) Volitelně zaškrtněte „Obejít proxy server pro místní adresy\u0026quot;. ","description":"Nakonfigurujte oblíbené prohlížeče pro použití HTTP/HTTPS proxy I2P na desktopu a Androidu","id":"a40410c542dc82558c1c1a8be78d2e62","section":"docs","title":"Konfigurace webového prohlížeče","url":"/cs/docs/guides/browser-config/"},{"categories":null,"content":"Jak vyžaduje náš model hrozeb (mimo jiné důvody), software vyvinutý pro podporu anonymní komunikační sítě, kterou nazýváme I2P, musí být volně dostupný, s otevřeným zdrojovým kódem a uživatelsky upravitelný. Abychom splnili tato kritéria, využíváme různé právní a softwarové inženýrské techniky, abychom odstranili co nejvíce překážek pro ty, kteří zvažují využití nebo přispění k projektu I2P.\nAčkoli níže uvedené informace mohou být matoucí spíše než jednoduché prohlášení \u0026ldquo;I2P je BSD\u0026rdquo;, \u0026ldquo;I2P je GPL\u0026rdquo; nebo \u0026ldquo;I2P je veřejná doména\u0026rdquo;, krátká odpověď na otázku \u0026ldquo;Jak je I2P licencováno?\u0026rdquo; zní takto:\nVeškerý software obsažený v distribucích I2P umožní: použití bez poplatku použití bez omezení jak, kdy, kde, proč nebo kým je provozováno přístup ke zdrojovému kódu bez poplatku úpravy zdrojového kódu Většina softwaru zaručuje mnohem více - možnost kohokoli distribuovat upravený zdrojový kód jakýmkoli způsobem, který si zvolí. Ne všechen software, který je součástí balíčku, však poskytuje tuto svobodu - GPL omezuje možnosti vývojářů, kteří si přejí integrovat I2P se svými vlastními aplikacemi, které samy nejsou aplikacemi s otevřeným zdrojovým kódem. Zatímco oceňujeme ušlechtilé cíle zvyšování zdrojů ve veřejném prostoru, I2P je nejlépe slouženo odstraněním jakýchkoli překážek, které stojí v cestě jeho přijetí - pokud vývojář zvažující, zda může integrovat I2P se svou aplikací, musí zastavit a poradit se se svým právníkem nebo provést audit kódu, aby se ujistil, že jejich vlastní zdrojový kód může být zveřejněn jako kompatibilní s GPL, přicházíme zkrátka.\nLicence komponent Distribuce I2P obsahuje několik zdrojů, které odrážejí rozdělení zdrojového kódu do komponent. Každá komponenta má svou vlastní licenci, se kterou všichni vývojáři, kteří k ní přispívají, souhlasí - buď explicitním prohlášením o vydání kódu zapsaného pod licencí kompatibilní s danou komponentou, nebo implicitním vydáním kódu zapsaného pod primární licencí komponenty. Každá z těchto komponent má vedoucího vývojáře, který má konečné slovo ohledně toho, která licence je kompatibilní s primární licencí komponenty, a projektový manažer I2P má konečné slovo ohledně toho, které licence splňují výše uvedené čtyři záruky pro zařazení do distribuce I2P.\nComponent Source path Resource Primary license Alternate licenses Lead developer I2P SDK core i2p.jar Public domain BSD, Cryptix, MIT zzz I2P Router router router.jar Public domain BSD, Cryptix, MIT zzz Ministreaming apps/ministreaming mstreaming.jar BSD Public domain, Cryptix, MIT zzz Streaming apps/streaming streaming.jar Public domain BSD, Cryptix, MIT zzz I2PTunnel apps/i2ptunnel i2ptunnel.jar GPL + exception Public domain, BSD, Cryptix, MIT zzz Routerconsole apps/routerconsole routerconsole.war Public domain — zzz Address Book apps/addressbook addressbook.war MIT Public domain, Cryptix, BSD — Susidns apps/susidns susidns.war GPL + exception — — Susimail apps/susimail susimail.war GPL + exception — — I2PSnark apps/i2psnark i2psnark.jar GPL + exception — zzz [BOB](/docs/legacy/bob/) Bridge apps/BOB BOB.jar WTFPL — sponge [SAM](/docs/api/samv3/) Bridge apps/sam sam.jar Public domain Cryptix, BSD, MIT zzz [SAM v1](/docs/legacy/sam/) Perl library apps/sam/perl SAM.pm GPL Public domain, Cryptix, BSD, MIT BrianR [SAM v1](/docs/legacy/sam/) C library apps/sam/c libSAM BSD Public domain, Cryptix, MIT Nightblade [SAM v1](/docs/legacy/sam/) Python library apps/sam/python i2p.py Public domain BSD, Cryptix, MIT Connelly [SAM v1](/docs/legacy/sam/) C# library apps/sam/csharp/ n/a Public domain BSD, Cryptix, MIT smeghead Other apps not mentioned apps/ ... Probably Public domain but check the source — — Installer installer install.jar, guiinstall.jar Public domain GPL + exception, BSD, Cryptix, MIT — Výjimka GPL Ačkoli to může být nadbytečné, jen pro jistotu musí být kód pod licencí GPL zahrnutý v I2PTunnel a dalších aplikacích vydán pod GPL s dodatečnou \u0026ldquo;výjimkou\u0026rdquo;, která explicitně povoluje použití standardních knihoven Javy:\nIn addition, as a special exception, XXXX gives permission to link the code of this program with the proprietary Java implementation provided by Sun (or other vendors as well), and distribute linked combinations including the two. You must obey the GNU General Public License in all respects for all of the code used other than the proprietary Java implementation. If you modify this file, you may extend this exception to your version of the file, but you are not obligated to do so. If you do not wish to do so, delete this exception statement from your version. Veškerý zdrojový kód každé komponenty bude ve výchozím nastavení licencován pod primární licencí, pokud není v kódu označeno jinak. Vše výše uvedené je shrnutím licenčních podmínek – pro závazné podmínky se prosím podívejte na konkrétní licenci dané komponenty nebo zdrojového kódu. Umístění zdrojových kódů komponent a balení zdrojů může být změněno v případě reorganizace repozitáře.\nLicence webu Pokud není uvedeno jinak, obsah těchto stránek je licencován pod Creative Commons Attribution-ShareAlike 4.0 International License .\nPřístup k commitům Vývojáři mohou odesílat změny do distribuovaného git repozitáře, pokud získají oprávnění od osoby spravující daný repozitář. Podrobnosti naleznete v Průvodci pro nové vývojáře .\nAby však byly změny zahrnuty do vydání, musí vývojáři získat důvěru správce vydání (v současnosti zzz). Kromě toho musí výslovně souhlasit s výše uvedenými podmínkami, aby získali důvěru. To znamená, že musí poslat jednomu ze správců vydání podepsanou zprávu potvrzující, že:\nPokud není označeno jinak, veškerý kód, který commituji, je implicitně licencován pod primární licencí komponenty Pokud je to uvedeno ve zdrojovém kódu, kód může být explicitně licencován pod jednou z alternativních licencí komponenty Mám právo uvolnit kód, který commituji, za podmínek, pod kterými jej commituji Pokud je vám známa jakákoli situace, kdy výše uvedené podmínky nejsou splněny, kontaktujte prosím vedoucího komponenty a/nebo správce vydání I2P s dalšími informacemi.\n","description":"Licenční politika a licence komponent pro software dodávaný s I2P","id":"74bb6af167b1176b4058e46e5f8ca568","section":"docs","title":"Licence softwaru I2P","url":"/cs/docs/develop/licenses/"},{"categories":null,"content":" Zastaralé: Knihovna ministreaming předchází současné streamovací knihovně . Moderní aplikace musí používat plné streamovací API nebo SAM v3. Informace níže jsou ponechány pro vývojáře, kteří provádějí revizi zastaralého zdrojového kódu dodávaného v ministreaming.jar.\nPřehled Ministreaming (minimalistická streamovací vrstva) běží nad I2CP a zajišťuje spolehlivé doručování ve správném pořadí napříč zprávovou vrstvou I2P — podobně jako TCP nad IP. Původně byl vyčleněn z rané aplikace I2PTunnel (pod licencí BSD), aby se alternativní transporty mohly vyvíjet nezávisle.\nKlíčová návrhová omezení:\nKlasické dvoufázové navazování spojení (SYN/ACK/FIN) převzaté z TCP Pevná velikost okna 1 paketu Žádná ID pro jednotlivé pakety ani selektivní potvrzování Tyto volby udržely implementaci malou, ale omezují propustnost—každý paket obvykle čeká téměř dvě RTT, než je odeslán další. U dlouhotrvajících spojení je tato režie přijatelná, ale krátké výměny ve stylu HTTP tím znatelně trpí.\nVztah ke streamovací knihovně Aktuální streamovací knihovna rozšiřuje tentýž balíček Java (net.i2p.client.streaming). Zastaralé třídy a metody zůstávají v dokumentaci Javadoc, jasně označené, aby vývojáři mohli identifikovat rozhraní API z éry ministreaming (starší streamovací knihovna). Když streamovací knihovna nahradila ministreaming, přidala:\nEfektivnější navazování spojení s menším počtem kol komunikace Adaptivní okna zahlcení a logika retransmise Lepší výkon přes ztrátové tunnels Kdy byl Ministreaming užitečný? Navzdory svým omezením poskytoval ministreaming (minimalistické streamovací rozhraní) spolehlivý přenos v nejranějších nasazeních. API bylo záměrně malé a odolné vůči budoucím změnám, aby bylo možné zaměňovat alternativní streamovací enginy, aniž by došlo k porušení kompatibility pro volající. Aplikace v jazyce Java jej linkovaly přímo; klienti mimo Javu ke stejné funkcionalitě přistupovali prostřednictvím podpory SAM pro streamovací relace.\nV současnosti považujte ministreaming.jar pouze za kompatibilní vrstvu. Nový vývoj by měl:\nPoužijte plnou streamingovou knihovnu (Java) nebo SAM v3 (styl STREAM) Při modernizaci kódu odstraňte veškeré přetrvávající předpoklady pevné velikosti okna Upřednostněte větší velikosti okna a optimalizované handshake (navázání spojení) pro zlepšení výkonu u zátěží citlivých na latenci Referenční dokumentace Dokumentace knihovny pro streamování Javadoc knihovny pro streamování – včetně zastaralých tříd \u0026ldquo;ministreaming\u0026rdquo; (zjednodušené streamování) Specifikace SAMv3 – podpora streamování pro aplikace nepsané v Javě Pokud narazíte na kód, který stále závisí na ministreaming (starší minimalistické streamovací rozhraní), plánujte jej převést na moderní streamovací API — síť a její nástroje očekávají novější chování.\n","description":"Historické poznámky k první TCP-podobné transportní vrstvě I2P","id":"3a258127f502d1974fadc514a60bf831","section":"docs","title":"Ministreamingová knihovna","url":"/cs/docs/legacy/ministreaming/"},{"categories":null,"content":"1. Co znamená „Anonymní\u0026quot; I2P poskytuje praktickou anonymitu—nikoli neviditelnost. Anonymita je definována jako obtížnost pro protivníka zjistit informace, které si přejete udržet v soukromí: kdo jste, kde jste, nebo s kým komunikujete. Absolutní anonymita je nemožná; místo toho se I2P zaměřuje na dostatečnou anonymitu vůči globálním pasivním i aktivním protivníkům.\nVaše anonymita závisí na tom, jak nakonfigurujete I2P, jak si vyberete peery a odběry a jaké aplikace zpřístupníte.\n2. Kryptografická a transportní evoluce (2003 → 2025) Era Primary Algorithms Notes 0.3 – 0.9 ElGamal + AES-256 + DSA-SHA1 Legacy stack (2003–2015) 0.9.15 Ed25519 signatures Replaced DSA 0.9.36 (2018) NTCP2 introduced Noise XK_25519_ChaChaPoly_SHA256 0.9.56 (2022) SSU2 enabled by default Noise-based UDP transport 2.4.0 (2023) NetDB Sub-DB isolation Prevents router↔client linkage 2.8.0+ (2025) Congestion-aware routing / observability reductions DoS hardening 2.10.0 (2025) Post-quantum hybrid ML-KEM support (optional) Experimental **Současná kryptografická sada (Noise XK):** - **X25519** pro výměnu klíčů - **ChaCha20/Poly1305 AEAD** pro šifrování - **Ed25519 (EdDSA-SHA512)** pro podpisy - **SHA-256** pro hashování a HKDF - Volitelné **ML-KEM hybridy** pro testování post-kvantové kryptografie Veškeré použití ElGamal a AES-CBC bylo vyřazeno. Transport je zcela založen na NTCP2 (TCP) a SSU2 (UDP); oba podporují IPv4/IPv6, forward secrecy a obfuskaci DPI.\n3. Shrnutí síťové architektury Mixnet s volnou trasou: Odesílatelé a příjemci si každý definují vlastní tunnely. Žádná centrální autorita: Směrování a pojmenování jsou decentralizované; každý router udržuje lokální důvěru. Jednosměrné tunnely: Příchozí a odchozí jsou oddělené (životnost 10 minut). Explorační tunnely: Standardně 2 přeskoky; klientské tunnely 2–3 přeskoky. Floodfill routery: ~1 700 z ~55 000 uzlů (~6 %) udržuje distribuovanou NetDB. Rotace NetDB: Klíčový prostor se rotuje denně o půlnoci UTC. Izolace sub-DB: Od verze 2.4.0 používá každý klient a router samostatné databáze, aby se zabránilo propojení. 4. Kategorie útoků a současná obrana Category Current Status (2025) Primary Defenses Brute Force / Cryptanalysis Impractical with modern primitives (X25519, ChaCha20). Strong crypto, key rotation, Noise handshakes. Timing Attacks Still unsolved for low-latency systems. Unidirectional tunnels, 1024\u0026nbsp;B cells, profile recalc (45\u0026nbsp;s). Research continues for non-trivial delays (3.0+). Intersection Attacks Inherent weakness of low latency mixnets. Tunnel rotation (10\u0026nbsp;min), leaseset expirations, multihoming. Predecessor Attacks Partially mitigated. Tiered peer selection, strict XOR ordering, variable length tunnels. Sybil Attacks No comprehensive defense. IP /16 limits, profiling, diversity rules; HashCash infra exists but not required. Floodfill / NetDB Attacks Improved but still a concern. One /16 per lookup, limit 500 active, daily rotation, randomized verification delay, Sub-DB isolation. DoS / Flooding Frequent (esp. 2023 incidents). Congestion-aware routing (2.4+), aggressive leaseset removal (2.8+). Traffic ID / Fingerprinting Greatly reduced. Noise obfuscation, random padding, no plaintext headers. Censorship / Partitioning Possible with state-level blocking. Hidden mode, IPv6, multiple reseeds, mirrors. Development / Supply Chain Mitigated. Open source, signed SU3 releases (RSA-4096), multi-signer trust model. --- 5. Moderní síťová databáze (NetDB) Základní fakta (stále platná): - Modifikované Kademlia DHT ukládá RouterInfo a LeaseSets. - Hashování klíčů SHA-256; paralelní dotazy na 2 nejbližší floodfilly s timeoutem 10 s. - Životnost LeaseSet ≈ 10 min (LeaseSet2) nebo 18 h (MetaLeaseSet).\nNové typy (od verze 0.9.38): - LeaseSet2 (Typ 3) – více typů šifrování, s časovým razítkem. - EncryptedLeaseSet2 (Typ 5) – zastíněná destinace pro soukromé služby (autentizace DH nebo PSK). - MetaLeaseSet (Typ 7) – multihoming a prodloužené doby platnosti.\nVýznamné bezpečnostní vylepšení – izolace Sub-DB (2.4.0): - Zabraňuje asociaci router↔klient. - Každý klient a router používá oddělené segmenty netDb. - Ověřeno a auditováno (2.5.0).\n6. Skrytý režim a omezené trasy Skrytý režim: Implementováno (automaticky v přísných zemích podle skóre Freedom House).\nRoutery nepublikují RouterInfo ani nesměrují provoz. Omezené trasy: Částečně implementováno (pouze základní tunnely založené na důvěře).\nKomplexní směrování důvěryhodných uzlů zůstává plánováno (3.0+). Kompromis: Lepší soukromí ↔ snížený příspěvek k kapacitě sítě.\n7. Útoky DoS a útoky na Floodfill Historické: Výzkum UCSB z roku 2013 ukázal možnost Eclipse a Floodfill převzetí. Moderní obrana zahrnuje: - Denní rotaci klíčového prostoru. - Floodfill limit ≈ 500, jeden na /16. - Randomizované zpoždění ověřování úložiště. - Preference novějších routerů (2.6.0). - Oprava automatického zařazení (2.9.0). - Směrování vnímaní přetížení a omezování lease (2.4.0+).\nÚtoky na floodfill uzly zůstávají teoreticky možné, ale prakticky obtížnější.\n8. Analýza provozu a cenzura Provoz I2P je obtížné identifikovat: žádný pevný port, žádný handshake v čitelném textu a náhodné vyplnění. Pakety NTCP2 a SSU2 napodobují běžné protokoly a používají obfuskaci hlaviček ChaCha20. Strategie vyplňování jsou základní (náhodné velikosti), fiktivní provoz není implementován (nákladné). Připojení z výstupních uzlů Tor jsou od verze 2.6.0 blokována (na ochranu zdrojů).\n9. Trvalá omezení (uznávaná) Korelace časování u aplikací s nízkou latencí zůstává základním rizikem. Průnikové útoky jsou stále účinné proti známým veřejným cílům. Sybil útoky postrádají úplnou ochranu (HashCash není vynucován). Konstantní tok dat a netriviální zpoždění zůstávají neimplementované (plánováno pro verzi 3.0). Transparentnost ohledně těchto omezení je záměrná — brání uživatelům v přeceňování anonymity.\n10. Statistiky sítě (2025) ~55 000 aktivních routerů po celém světě (↑ ze 7 000 v roce 2013) ~1 700 floodfill routerů (~6 %) 95 % se standardně účastní směrování tunelů Úrovně šířky pásma: K (\u0026lt;12 KB/s) → X (\u0026gt;2 MB/s) Minimální rychlost pro floodfill: 128 KB/s Konzole routeru Java 8+ (vyžadováno), Java 17+ plánováno pro další cyklus 11. Vývoj a centrální zdroje Oficiální stránky: geti2p.net Dokumentace: Documentation Debian repositář: https://deb.i2pgit.org ( nahradil deb.i2p2.de v říjnu 2023 ) Zdrojový kód: https://i2pgit.org/I2P_Developers/i2p.i2p (Gitea) + GitHub mirror Všechny vydání jsou podepsané SU3 kontejnery (RSA-4096, zzz/str4d klíče) Žádné aktivní mailing listy; komunita přes https://i2pforum.net a IRC2P. Cyklus aktualizací: 6–8 týdnů stabilní vydání. 12. Shrnutí vylepšení zabezpečení od verze 0.8.x Year Feature Effect 2015 Ed25519 signatures Removed SHA1/DSA weakness 2018 NTCP2 Noise-based TCP transport 2019 LeaseSet2 / EncryptedLeaseSet2 Hidden services privacy 2022 SSU2 Noise-based UDP transport 2023 Sub-DB Isolation + Congestion-Aware Routing Stopped NetDB linkage / improved resilience 2024 Floodfill selection improvements Reduced long-term node influence 2025 Observability reductions + PQ hybrid crypto Harder timing analysis / future-proofing --- 13. Známé nevyřešené nebo plánované práce Komplexní omezené trasy (trusted-peer routing) → plánováno pro 3.0. Netriviální zpoždění/dávkování pro odolnost proti časové analýze → plánováno pro 3.0. Pokročilé vyplňování a fiktivní provoz → neimplementováno. Ověření identity pomocí HashCash → infrastruktura existuje, ale je neaktivní. Náhrada R5N DHT → pouze návrh. 14. Klíčové reference Practical Attacks Against the I2P Network (Egger et al., RAID 2013) Privacy Implications of Performance-Based Peer Selection (Herrmann \u0026amp; Grothoff, PETS 2011) Resilience of the Invisible Internet Project (Muntaka et al., Wiley 2025) Oficiální dokumentace I2P 15. Závěr Základní model anonymity I2P obstál po dvě desetiletí: obětovat globální jedinečnost ve prospěch lokální důvěry a bezpečnosti. Od ElGamal po X25519, od NTCP po NTCP2 a od manuálních reseedů po izolaci Sub-DB se projekt vyvíjel při zachování své filozofie důkladné obrany a transparentnosti.\nMnoho útoků zůstává teoreticky možných proti jakékoli mixnet síti s nízkou latencí, ale průběžné zpevňování I2P je činí stále nepraktičtějšími. Síť je větší, rychlejší a bezpečnější než kdy dříve — a přesto stále upřímná ohledně svých limitů.\n","description":"Katalog útoků zvažovaných v návrhu I2P a zavedená protiopatření","id":"8433fa179e266d091a906a9059db53f4","section":"docs","title":"Model hrozeb I2P","url":"/cs/docs/overview/threat-model/"},{"categories":null,"content":" Stav: Tato stránka stručně shrnuje zastaralou \u0026ldquo;Low-level Cryptography Specification\u0026rdquo;. Moderní vydání I2P (2.10.0, říjen 2025) dokončila přechod na nová kryptografická primitiva. Pro implementační detaily použijte specializované specifikace, jako ECIES , Šifrované LeaseSets , NTCP2 , Red25519 , SSU2 , a Tunnel Creation (ECIES) pro implementační detaily.\nSnímek vývoje Functional Area Legacy Primitive Current / Planned Primitive Migration Status Transport key exchange Diffie–Hellman over 2048-bit prime (NTCP / SSU) X25519 (NTCP2 / SSU2) Completed (NTCP2 and SSU2 fully deployed) End-to-end encryption ElGamal/AES+SessionTags ECIES-X25519-AEAD-Ratchet Completed (2.4.0+) Symmetric cipher AES-256/CBC + HMAC-MD5 ChaCha20/Poly1305 (AEAD) Active (tunnel layer remains AES-256) Default signatures DSA-SHA1 (1024-bit) EdDSA/RedDSA on Ed25519 Fully migrated Experimental / future — Hybrid post-quantum encryption (opt-in) In testing (2.10.0) ## Asymetrické šifrování X25519 (algoritmus výměny klíčů ECDH nad eliptickou křivkou Curve25519) Používá se pro NTCP2, ECIES-X25519-AEAD-Ratchet, SSU2 a vytváření tunnel na bázi X25519. Poskytuje kompaktní klíče, operace v konstantním čase a dopředné utajení prostřednictvím rámce protokolu Noise. Nabízí 128bitovou bezpečnost s 32bajtovými klíči a efektivní výměnu klíčů. ElGamal (zastaralé) Zachováno kvůli zpětné kompatibilitě se staršími routery. Operuje nad 2048bitovým prvočíslem Oakley Group 14 (RFC 3526) s generátorem 2. Šifruje relanční klíče AES a IV (inicializační vektory) do šifrotextů o velikosti 514 bajtů. Postrádá autentizované šifrování a dopředné utajení; všechny moderní koncové body přešly na ECIES. Symetrické šifrování ChaCha20/Poly1305 (AEAD šifra, kombinace ChaCha20 a Poly1305) Výchozí primitivum pro autentizované šifrování napříč NTCP2, SSU2 a ECIES. Poskytuje zabezpečení AEAD a vysoký výkon i bez hardwarové podpory AES. Implementováno dle RFC 7539 (256‑bitový klíč, 96‑bitová nonce (jednorázová hodnota), 128‑bitový autentizační tag). AES‑256/CBC (zastaralé) Stále se používá pro šifrování na vrstvě tunnelu, kde jeho struktura blokové šifry zapadá do vrstveného šifrovacího modelu I2P. Používá PKCS#5 padding a transformace IV na každém hopu. Je určeno k dlouhodobé revizi, ale nadále zůstává kryptograficky bezpečné. Podpisy Signature Type Usage Notes Status DSA‑SHA1 (1024‑bit) Original default; still accepted for legacy Destinations. Deprecated ECDSA‑SHA256/384/512 Used during 2014–2015 transition. Supported EdDSA‑SHA512‑Ed25519 Default for Router and Destination identities (since 0.9.15). Default RedDSA‑SHA512‑Ed25519 Used for encrypted LeaseSet signatures (0.9.39+). Specialized RSA‑SHA512‑4096 For out‑of‑band signing (su3 updates, reseeds, plugins). Application‑layer ## Hašování a odvozování klíčů SHA‑256: Používá se pro klíče DHT (distribuovaná hašovací tabulka), HKDF (funkce odvozování klíčů na bázi HMAC) a starší podpisy. SHA‑512: Používá se v EdDSA/RedDSA (schémata digitálních podpisů na eliptických křivkách) a při odvozeních HKDF v rámci Noise (kryptografický rámec pro handshaky). HKDF‑SHA256: Odvozuje relační klíče v ECIES (integrované šifrování na eliptických křivkách), NTCP2 a SSU2. Denně rotující odvození SHA‑256 zabezpečují lokace uložení RouterInfo a LeaseSet v netDb. Souhrn transportní vrstvy Transport Key Exchange Encryption Authentication Status NTCP2 X25519 ChaCha20/Poly1305 AEAD Default TCP transport SSU2 X25519 ChaCha20/Poly1305 AEAD Default UDP transport SSU (Legacy) DH‑2048 AES‑256/CBC + HMAC‑MD5 Legacy Removed (2.4.0) Oba transporty poskytují dopředné utajení na linkové úrovni a ochranu proti replay útokům pomocí Noise_XK handshake pattern (vzor handshaku). Šifrování vrstvy tunnel Nadále používá AES‑256/CBC pro vrstvené šifrování na úrovni jednotlivých skoků. Odchozí brány provádějí iterativní dešifrování AES; každý skok znovu šifruje pomocí svého klíče vrstvy a klíče IV (inicializační vektor). Šifrování s dvojitým IV zmírňuje korelační a potvrzovací útoky. Přechod na AEAD (autentizované šifrování s přidruženými daty) je zkoumán, ale aktuálně se neplánuje. Postkvantová kryptografie I2P 2.10.0 zavádí experimentální hybridní post‑kvantové šifrování. Lze ručně povolit prostřednictvím Hidden Service Manager (Správce skrytých služeb) pro testování. Kombinuje X25519 s kvantově odolným KEM (hybridní režim). Není ve výchozím nastavení; je určeno pro výzkum a hodnocení výkonu. Rámec rozšiřitelnosti Šifrovací a podpisové identifikátory typů umožňují paralelní podporu více kryptografických primitiv. Aktuální mapování zahrnuje: Typy šifrování: 0 = ElGamal/AES+SessionTags, 4 = ECIES‑X25519‑AEAD‑Ratchet. Typy podpisů: 0 = DSA‑SHA1, 7 = EdDSA‑SHA512‑Ed25519, 11 = RedDSA‑SHA512‑Ed25519. Tento rámec umožňuje budoucí aktualizace, včetně postkvantových schémat, bez rozdělení sítě. Kryptografická kompozice Transportní vrstva: X25519 + ChaCha20/Poly1305 (rámec Noise). Vrstva tunnel: AES‑256/CBC vrstvené šifrování pro anonymitu. End‑to‑end: ECIES‑X25519‑AEAD‑Ratchet pro důvěrnost a dopředné utajení. Databázová vrstva: podpisy EdDSA/RedDSA pro autenticitu. Tyto vrstvy společně zajišťují obranu do hloubky: i když je jedna vrstva kompromitována, ostatní udrží důvěrnost a nepropojitelnost.\nShrnutí Kryptografický stack I2P 2.10.0 se soustředí na:\nCurve25519 (X25519) pro výměnu klíčů ChaCha20/Poly1305 pro symetrické šifrování EdDSA / RedDSA pro podpisy SHA‑256 / SHA‑512 pro hašování a derivaci Experimentální post‑kvantové hybridní režimy pro budoucí kompatibilitu Starší ElGamal, AES‑CBC a DSA zůstávají kvůli zpětné kompatibilitě, ale již se nepoužívají v aktivních transportech ani v šifrovacích cestách.\n","description":"Souhrn symetrických, asymetrických a podpisových primitiv používaných napříč I2P","id":"f5b93f818161e04d49735c3df52fcbdc","section":"docs","title":"Nízkoúrovňová kryptografie","url":"/cs/docs/specs/cryptography/"},{"categories":null,"content":"Přehled Tento dokument specifikuje re-randomizovatelné podpisové schéma vhodné pro vytváření Destinací, které lze zaslepit. Kromě toho jej lze použít k zaslepení existujících Destinací Ed25519, avšak s mírným snížením účinnosti.\nRed25519 je v I2P routerech plně funkční od verze 0.9.39 (vydáno 21. března 2019). Tato specifikace byla po 17 měsících produkčního nasazení dokončena ve verzi 0.9.47 (srpen 2020). Schéma podpisu v síti I2P funguje jako typ podpisu 11 (RedDSA_SHA512_Ed25519).\nMotivace Návrh 123 (New netDB Entries) definuje šifrovaný formát LeaseSet2, který ztělesňuje princip minimálních oprávnění: každý účastník sítě dostává pouze informace nezbytné pro svou roli. Konkrétně šifrovaný LeaseSet2 publikovaný do floodfillu neprozrazuje Destination (cílová identita), pro kterou je určen, a Leases (záznamy pronájmu tunelu) si může zobrazit pouze ten, kdo má předchozí znalost této Destination. Floodfilly však stále musí být schopny ověřit šifrované LeaseSet2 při jejich publikování a klienti navíc musí zajistit, že ověření bylo vynuceno samotnou Destination.\nToho dosahuje Návrh 123 zaslepením podpisových klíčů Destinací. Zaslepené klíče lze použít k vytváření podpisů, které mohou floodfills ověřit, a klienti si mohou být jisti, že tyto podpisy mohla vytvořit pouze daná Destinace. Je proto nutné specifikovat podpisové schéma, které lze použít pro zaslepení.\nPoznámka ke stavu návrhu 123: Části návrhu 123 byly postupně implementovány a nasazovány od verze 0.9.38, přičemž podpora Red25519 byla přidána ve verzi 0.9.39. Šifrovaná funkcionalita LeaseSet2 (datová struktura I2P popisující dosažitelnost služby) je připravena pro produkční nasazení a je v síti I2P aktivně využívána pro skryté služby se zvýšeným soukromím.\nNávrh Základní podpisové schéma Podpisové schéma specifikované zde, Red25519, je instancí RedDSA, jak je definováno v oddíle 5.4.6 dokumentu Zcash Protocol Specification (Sapling and later). RedDSA je podpisové schéma založené na Schnorrově konstrukci, které podporuje key re-randomization (re-randomizaci klíče). Má následující funkce:\nGENERATE_PRIVATE() : Vrací rovnoměrně náhodný soukromý klíč.\nDERIVE_PUBLIC(sk) : Vrátí veřejný klíč odpovídající danému soukromému klíči.\nGENERATE_RANDOM() : Vrací náhodný skalár vhodný pro re-randomizing (opětovné náhodnění) klíčového páru.\nRANDOMIZE_PRIVATE(sk, alpha) : Znovu náhodně upraví soukromý klíč pomocí tajné skalární hodnoty alpha.\nRANDOMIZE_PUBLIC(vk, alpha) : Re-randomizuje veřejný klíč s použitím tajné skalární hodnoty alpha.\nSIGN(sk, m) : Vrátí podpis vytvořený soukromým klíčem sk nad zadanou zprávou m.\nVERIFY(vk, m, sig) : Ověří podpis sig vůči veřejnému klíči vk a zprávě m. Vrátí true, pokud je podpis platný, jinak false.\nPro danou dvojici klíčů (sk, vk) platí následující vztah:\nRANDOMIZE_PUBLIC(vk, alpha) == DERIVE_PUBLIC(RANDOMIZE_PRIVATE(sk, alpha)) Převod klíčů Ed25519 na Red25519 Klíče Ed25519 MOHOU být dočasně jednosměrně převedeny na klíče Red25519, za účelem podpory opětovné randomizace existujících Ed25519 Destinations (adresy v I2P). Jiné typy podpisů nejsou kompatibilní.\nDefinujeme následující převodní funkce:\nCONVERT_ED25519_PRIVATE(privkey) : Vrací soukromý klíč Red25519 odpovídající zadanému soukromému klíči Ed25519.\nCONVERT_ED25519_PUBLIC(pubkey) : Vrátí veřejný klíč Red25519 odpovídající danému veřejnému klíči Ed25519.\nPro daný klíčový pár Ed25519 (privkey, pubkey) platí následující vztah:\nCONVERT_ED25519_PUBLIC(pubkey) == DERIVE_PUBLIC(CONVERT_ED25519_PRIVATE(privkey)) Specifikace Definice B : Základní bod Ed25519 podle RFC 8032 .\nL : Řád Ed25519 2^252 + 27742317777372353535851937790883648493 podle RFC 8032 .\n[s] B : Skalární násobení s pevnou bází základního bodu skalárem s.\n[s] A : Skalární násobení s proměnlivou bází A skalárem s.\nx || y : Zřetězí dvě bajtová pole x a y.\nRed25519 (označení pro variantu založenou na křivce Ed25519) Schéma Red25519 specializuje RedDSA pomocí:\nG := skupina bodů na Edwardsově formě křivky Curve25519. Konkrétně to znamená, že Red25519 používá podskupinu o prvočíselném řádu L a koefaktor h_G je 8. P_G := základní bod Ed25519 B. l_H := 512 H(x) := SHA-512(\u0026ldquo;I2P_Red25519H(x)\u0026rdquo; || x) Poznámka k volbě hašovací funkce: Red25519 používá SHA-512 namísto BLAKE2b-512 (jak je tomu v Zcash RedDSA). Toto konstrukční rozhodnutí je vyváženo ochranou length-prefixing (prefixování délkou) popsanou níže. I2P Proposal 148 navrhuje do budoucna přechod na BLAKE2b-512 pro posílení ochrany proti Duplicate Message Identification (DMI, identifikace duplicitních zpráv) a Length Extension Attacks (LEA, útoky rozšířením délky), a také pro zlepšení výkonu.\nRedDSA předpokládá, že H(x) je realizována kryptografickou hashovací funkcí, která je odolná vůči útokům prodloužením délky. SHA-512 tento požadavek sama o sobě nesplňuje. Abychom to napravili, požadujeme, aby před každou zprávou byla uvedena její délka v prefixově jednoznačném kódování:\nlen_u16(M) || M kde len_u16(M) je dvoubajtová reprezentace délky M v little-endian (uspořádání bajtů od nejméně významného k nejvíce významnému), aby byla v souladu s little-endian kódováním skalárů a bodů.\nZprávy nesmí být delší než 65534 bajtů. Délka 65535 je vyhrazena pro možné budoucí rozšíření.\nBezpečnostní poznámka: Zahrnutí veřejného klíče (vk) do hashovací funkce, v kombinaci s 80 náhodnými bajty při podepisování, zajišťuje ochranu proti zranitelnostem typu SURK-CMA (Strong Unforgeability with Re-randomized Keys under Chosen Message Attack – silná nefalšovatelnost s přerandomizovanými klíči při útoku s volbou zprávy) objeveným v raných návrzích RedDSA. Tato implementace zahrnuje bezpečnostní opravy z auditu NCC Group pro Zcash (Finding NCC-Zcash2018-009).\nKódování a dekódování Soukromé klíče Red25519 jsou skalární hodnoty modulo L, kódované v reprezentaci little-endian. Definujeme funkce DECODE_SCALAR a ENCODE_SCALAR pro převod mezi polem bajtů a celočíselnou formou skalární hodnoty.\nVeřejné klíče Red25519 jsou body na Edwardsově formě křivky Curve25519. Kódují se jako 255bitová little-endian reprezentace souřadnice y, následovaná jediným bitem udávajícím znaménko souřadnice x. Jde o stejné kódování jako u Ed25519. Definujeme funkce DECODE_POINT a ENCODE_POINT pro převod mezi bajtovým polem a souřadnicovým vyjádřením bodu.\nFunkce RedDSA (digitální podpisové schéma) Pro usnadnění implementace níže výslovně uvádíme funkce RedDSA (digitální podpisové schéma), stejně jako několik pomocných funkcí, již specializované pro Red25519. Implementátoři by měli pro obecnou specifikaci funkcí RedDSA nahlédnout do oddílu 5.4.6 dokumentu Zcash Protocol Specification.\nHStar(prefix1, prefix2, m) := h = SHA-512() h.input(\u0026#34;I2P_Red25519H(x)\u0026#34;) h.input(prefix1) h.input(prefix2) h.input(len(m) \u0026amp; 0xff) h.input((len(m) \u0026gt;\u0026gt; 8) \u0026amp; 0xff) h.input(m) s = h.digest() return s mod L GENERATE_PRIVATE := s = 64 random bytes return s mod L DERIVE_PUBLIC(sk) := [sk] B GENERATE_RANDOM := s = 64 random bytes return s mod L RANDOMIZE_PRIVATE(sk, alpha) := (sk + alpha) mod L RANDOMIZE_PUBLIC(vk, alpha) := vk + [alpha] B SIGN(sk, m) := T = 80 random bytes vkBytes = ENCODE_POINT(DERIVE_PUBLIC(sk)) r = HStar(T, vkBytes, m) R = [r] B Rbytes = ENCODE_POINT(R) c = HStar(Rbytes, vkBytes, m) S = (r + (c * sk)) mod L return Rbytes || ENCODE_SCALAR(S) VERIFY(vk, m, sig) := Rbytes = sig[0..32] Sbytes = sig[32..64] R = DECODE_POINT(Rbytes) if R is invalid: return false S = DECODE_SCALAR(Sbytes) if S \u0026gt;= L: return false vkBytes = ENCODE_POINT(vk) c = HStar(Rbytes, vkBytes, m) return ((-[S] B) + R + ([c] vk)).multiplyByCofactor().isIdentity() Konverzní funkce CONVERT_ED25519_PRIVATE(privkey) := s = SHA-512(privkey)[0..32] s[0] = s[0] \u0026amp; 248 s[31] = (s[31] \u0026amp; 63) | 64 return s CONVERT_ED25519_PUBLIC(pubkey) := pubkey Všimněte si, že implementace CONVERT_ED25519_PRIVATE je ekvivalentní výpočtu tajné skalární hodnoty s, který se provádí při odvozování veřejného klíče Ed25519 z privátního klíče Ed25519, jak je specifikováno v krocích 1-3 v oddílu 5.1.5 RFC 8032 .\nBezpečnostní dopady Rerandomizace Red25519 Destination (identifikátor cíle v I2P) a následné vytváření podpisů pomocí ní neprozrazuje žádné informace o Destination, protože pravděpodobnostní rozdělení soukromých klíčů Red25519 generovaných pomocí RANDOMIZE_PRIVATE je totožné s rozdělením soukromých klíčů generovaných pomocí GENERATE_PRIVATE a DERIVE_PUBLIC je deterministická.\nPřevod soukromých klíčů Ed25519 (schéma digitálního podpisu na eliptické křivce) na Red25519 (odvozený formát klíčů) pomocí CONVERT_ED25519_PRIVATE nevede ke stejnému rozdělení. Snížení bezpečnosti však považujeme z následujících důvodů za přijatelné:\nProstor skalárů Ed25519 je přibližně poloviční oproti prostoru skalárů Red25519 (existuje 2^251 možných skalárů Ed25519 a L ~= 2^252 možných skalárů Red25519). Ztráta bezpečnosti je tedy nanejvýš přibližně dvojnásobná, tj. zhruba o 1 bit (protože jsme mohli náhodou zvolit skalár Red25519, který je zároveň platným skalárem Ed25519). Existující destinace Ed25519 byly v minulosti na síti již vystaveny a mělo by se předpokládat, že je škodlivé floodfills již zmapovaly. Důležité: Uživatelé, kteří se obávají tohoto oslabení bezpečnosti, by měli jako sigtype pro své Destinations (identifikátory služeb v I2P) používat Red25519 (signature type 11) místo Ed25519 (signature type 7).\nVšimněte si, že výše uvedený argument se nevztahuje na rerandomizační skalár alpha; při každé volbě zkreslené alpha unikají informace o klíči, protože aditivní rerandomizace se chová jako jednorázová šifra.\nStav bezpečnostního auditu Důležité sdělení: I2P, včetně Red25519, nikdy neprošlo formálním bezpečnostním auditem provedeným třetí stranou. Základní návrh RedDSA prošel bezpečnostní revizí společností NCC Group jako součást auditu protokolu Zcash Sapling v roce 2018, při níž byly identifikovány a opraveny bezpečnostní problémy. Konkrétní implementace I2P se SHA-512 (namísto BLAKE2b-512) a doménovou separací I2P však nebyla nezávisle analyzována.\nReferenční implementace ed25519-java od str4d prošla jedním nezávislým auditem třetí strany, ale ten předcházel implementaci Red25519 a pokrýval pouze funkcionalitu Ed25519, nikoli rozšíření Red25519.\nUživatelé, kteří nasazují Red25519, by měli rozumět tomuto omezení a vyhodnotit bezpečnostní kompromisy podle svého modelu hrozeb.\nKompatibilita Verze I2P, které podporují Red25519 (verze 0.9.39 a novější), budou schopny ověřit síťové datové struktury, které jsou jím podepsané. Verze I2P, které Red25519 nepodporují, budou takový podpis považovat za neznámý a SMÍ tyto datové struktury zahodit.\nČasová osa nasazení: - 0.9.39 (březen 2019): První implementace s podporou Encrypted LS2 ve floodfills - 0.9.40 (květen 2019): Autorizace na úrovni klienta pro Encrypted LS2 - 0.9.41 (srpen 2019): Meta LS2 a Encrypted LS2 s offline klíči - 0.9.43 (únor 2020): Podpora b32 pro Encrypted LS2 - 0.9.47 (srpen 2020): Finalizace specifikace - 2.10.0 (říjen 2025): Aktuální verze sítě (ekvivalent k 0.9.67+)\nUživatelé by měli očekávat, že spolehlivost datových struktur podepsaných pomocí Red25519 (typ digitálního podpisu) bude pro případy použití Encrypted LeaseSet2 dobrá, protože síť měla od počáteční implementace více než šest let na aktualizaci. Metriky adopce pro obecné používání destinací však nejsou veřejně dostupné.\nHlavní případ použití: Red25519 se primárně používá pro funkci Encrypted LeaseSet2, kde je vyžadováno zaslepení klíče. Pro standardní destinace bez požadavků na šifrovaný leaseset zůstává Ed25519 (typ podpisu 7) doporučenou volbou díky širší kompatibilitě a delší prokázané historii.\nPoznámky k implementaci Implementace Red25519 je v I2P Java routeru v net.i2p.crypto.eddsa.RedDSAEngine a používá knihovnu ed25519-java od str4d (Jack Grigg) jako Maven závislost net.i2p.crypto:eddsa (ve verzích 0.1.0 až 0.3.0).\nImplementace i2pd v C++ také podporuje Red25519 (signaturetype=11) pro publikování šifrovaného LeaseSetu.\nPříklad konfigurace pro i2pd:\nsignaturetype=11 i2cp.leaseSetType=5 Kompatibilita Encrypted LeaseSet2: Specifikace Encrypted LeaseSet vyžaduje, aby podpisový veřejný klíč v unblinded destination (nezaslepený cíl) byl typu Ed25519 (typ podpisu 7) nebo Red25519 (typ podpisu 11). Žádné jiné typy podpisů nejsou podporovány pro funkcionalitu encrypted leaseset.\nTestovací vektory Následující testovací vektory jsou k dispozici pro ověření implementace. Každý vektor obsahuje:\nedsk: soukromý klíč Ed25519 (náhodný) edpk: veřejný klíč Ed25519 odpovídající edsk sk: CONVERT_ED25519_PRIVATE(edsk) vk: CONVERT_ED25519_PUBLIC(edpk) msg: zpráva k podepsání sig: SIGN(sk, msg) alpha: GENERATE_RANDOM() rsk: RANDOMIZE_PRIVATE(sk, alpha) rvk: RANDOMIZE_PUBLIC(vk, alpha) rsig: SIGN(rsk, msg) Poznámka k implementaci: Tyto testovací vektory by měly být integrovány do automatizovaných sad jednotkových testů pro průběžné ověřování. Implementátoři by měli ověřit, že všechny konverze, podpisy a operace re-randomization (opětovné náhodnění) odpovídají těmto očekávaným hodnotám.\nTestovací vektor 1 edsk: 0101010101010101010101010101010101010101010101010101010101010101 edpk: 8a88e3dd7409f195fd52db2d3cba5d72ca6709bf1d94121bf3748801b40f6f5c sk: 58e86efb75fa4e2c410f46e16de9f6acae1a1703528651b69bc176c088bef36e vk: 8a88e3dd7409f195fd52db2d3cba5d72ca6709bf1d94121bf3748801b40f6f5c msg: 0202020202020202020202020202020202020202020202020202020202020202 sig: 61f5527f4d3b46de4b2c234390370bf715ae9098907a0d191ba1b44b23a8ac1a 6a40437a5294e9503faaf9bd2b7f2fe7ba44dec487b3185aba7ff7d7a17cd40f alpha: ae9ba9cbbc047c442448fca7c9f4e288a202ed520bfad0c784b792b7773cee08 rsk: 8bb85f3c7a494a08890d7d142109c1a3501d04565d80227e2079097800fbe107 rvk: 6fe128737b8e76fa66698a748b0dc0a89168dd8a0601c2b1c0b26835d323e9b3 rsig: 533053074d3b44f08723aab988ede9880a001b7a684d4a98f2d1b88fabee07a5 b5c9430c69a690321e0cb8365d7aeb6688bcbad2c0780e0c69e8a1b4a45f3001 Testovací vektor 2 edsk: 0202020202020202020202020202020202020202020202020202020202020202 edpk: 8139770ea87d175f56a35466c34c7ecccb8d8a91b4ee37a25df60f5b8fc9b394 sk: a83c626bc9c38c8c201878ebb1d5b0b50ac40e8986c78793db1d4ef369fca14e vk: 8139770ea87d175f56a35466c34c7ecccb8d8a91b4ee37a25df60f5b8fc9b394 msg: 0303030303030303030303030303030303030303030303030303030303030303 sig: 0829e58eb5399870f009bd1f0270264e556424bda7a93fbcec99f6d9d75db46d 5c3cb546d9947ca7c1200876c8775a90c357a2aef3d2f16388242ee1914b1a0a alpha: 98b615d9027e996cc2796c019d9c8beb46aa7d2b6eea2e5d98eb29eb1584c203 rsk: 9fcfaa734852ca40b3810ebef590e138516e8cb4f4b1b6f0730978de7f806402 rvk: 527e121090158419609e4a0d8de6f7d3271b353a8cd0b8172fe41468ea1e9177 rsig: 9a6961f35ed264a946cd6214b2326a6e6caa426c2a61bc14367fd278e0b5fb51 3ac065a69210a457f17d12ba8a496cfd835002691affa8efcdecae48135c090f Poznámka: Další testovací vektory 3-10 mají stejný formát a lze je nalézt v referenční implementaci.\nReference Návrh 123: Nové záznamy netDB - Částečně implementováno a nasazeno ve verzích 0.9.38, 0.9.39 a novějších Specifikace protokolu Zcash, oddíl 5.4.6: RedDSA, RedJubjub a RedPallas - RedDSA je definován jako součást specifikace protokolu Zcash; bezpečnostní audit provedla společnost NCC Group (leden 2019) RFC 8032: Algoritmus digitálního podpisu na Edwardsově křivce (EdDSA) Návrh 148: RedDSA-BLAKE2b-Ed25519 - Navrženo, ale dosud neimplementováno; navrhuje budoucí migraci na BLAKE2b-512 Specifikace šifrovaného LeaseSet Specifikace kryptografie na nízké úrovni ","description":"Rerandomizovatelné podpisové schéma pro vytváření zaslepených destinací","id":"31b087e2977ad9f01f6b3b93e6af1f20","section":"docs","title":"Podpisové schéma Red25519","url":"/cs/docs/specs/red25519-signature-scheme/"},{"categories":null,"content":" Vydání 0.9.57 a novější jsou podepsána idk. Jeho aktuální veřejný klíč je: Stáhnout veřejný PGP klíč Verze 0.7.6 a 0.9.56 jsou podepsány zzz. Jeho aktuální veřejný klíč je: Stáhnout veřejný klíč PGP -----BEGIN PGP SIGNED MESSAGE----- Hash: SHA1 Vytvořil jsem nové GPG klíče a podklíče a podepsal jsem nové klíče starým klíčem.\nStaré klíče:\npub 1024D/A76E0BED 2005-12-16 Key fingerprint = 4456 EBBE C805 63FE 57E6 B310 4155 76BA A76E 0BED uid zzz (zzz) \u0026lt;zzz@mail.i2p\u0026gt; sub 2048g/74C8122D 2005-12-16 Nové klíče:\npub 4096R/EE7256A8 2014-05-08 [expires: 2024-05-05] Key fingerprint = 2D3D 2D03 910C 6504 C121 0C65 EE60 C0C8 EE72 56A8 uid zzz on i2p (key signing) \u0026lt;zzz@mail.i2p\u0026gt; uid zzz on i2p (key signing) \u0026lt;zzz@i2pmail.org\u0026gt; sub 4096R/1AE988AB 2014-05-08 [expires: 2019-05-07] sub 4096R/01B5610C 2014-05-08 [expires: 2019-05-07] sub 4096R/59683006 2014-05-08 [expires: 2019-05-07] Nové klíče použiji následovně:\nEE7256A8: key signing 1AE988AB: email signing 01B5610C email encryption 59683006 release signing Podpisový klíč pro vydání bude použit počínaje verzí 0.9.13. Tato zpráva je podepsána mým starým klíčem.\nzzz 25. května 2014\nNásledují nové klíče:\n\u0026mdash;\u0026ndash;BEGIN PGP PUBLIC KEY BLOCK\u0026mdash;\u0026ndash; Version: GnuPG v1.4.14 (GNU/Linux)\nmQINBFNrjZsBEADMHWiucM8ES5VDfq6n4M9DJhMyG5jVoakzSFHfzVOEpHeDYR1E eaEIFt5CEx0mbpXWy6UBoj0E7o3se5RvF81VQQ4xO0MyHZLkpotGffZo7D34uKTd 1SFbirosXwnsOxjPGLF+PuwifV+mzSoE66XRmg5UJbOJj0ZitYBn4lDKMxU1Rext WX7D79qnJW2GXv/HuzTwZ/KV3fOVB782+fNdFBDZt4XHSM32ideXedTtTJ+FXjBv 1/eQ/Ls8PMYKaYUm/j0oTI2A5aNP+6BH8/NrVvF8xQWCibrOILASWFRJE7insciJ m9eeEPPOp1D4fRDWFyjABcn00fv7T7RDBgIdpuj3gBDvGXgx8SRiWxe9CwV9TcJl WNPTAKd9XGHT13XWwc1myO/yg+yQoJB6HO1jGjqxQuu3aHCw2i4gTHflq4qZoSDV oxJWeh+mNsfx4DgmoT1UeEmh2Uq64czMGh8wJC0FqSa+FmgCKa1FxcTnYlfIjR79 qwbEKK3JZ5PPkiK5Lh4hNvkXKLrUXpG1KHm6yNVPNIWCOMd7VCDziEhsbeNPCzQc 6af8dkyI9BUeQD3fGjeHCh/QHLju9Lde77GDddYaShXVI/Wiy4AWgN0KVUk8CnEZ Uu2JbazpJBLGGiB2CujP44eJzm9VPoBx8Xc9/Pk2RFbz2bN4uQtSD6lAjQARAQAB tCd6enogb24gaTJwIChrZXkgc2lnbmluZykgPHp6ekBtYWlsLmkycD6JAj4EEwEC ACgFAlNrjyYCGwMFCRLMAwAGCwkIBwMCBhUIAgkKCwQWAgMBAh4BAheAAAoJEO5g wMjuclaoxkEP/RQRz7kWfCWcDWtKSxq1zA3HEUKUHLxhBIl1C+tmMtJypyWwiP8Y hrO/Tuk8nsnVOl9wMMtz2ZxMpUS2gTsuquZ6pIUCNtEP+IAuKsZlCcsNB+yOoi2T i71cXLBPcN/rbxyoOUMpk+fJgdsustUnSMbXJQ2sLjieurD/YpUMJZw6KoNVrhU1 1nDaJqAq/zouhSvNMvx5+GBodQ41gvtb984xbrNc8B24upCBHSF1olczWYPUtaAi oMlZTNr5XFS//Q8X3sEKAoRMbAX6UvZVdtgqQajGilMg+HM3HnbPqsHoyPWx4f8O n134ITgrVwL24y+m9XHfY+JPjcBgg9uGLuLJqMrrjYfz7jVdUJQUsy/R2+yzg1Bm Ruf3SBhHpG2dSBOTxi9GD4aL/7wXuXj9uIuFtX80EwsT4XifnIaHTdtNNzVO+obF dJyiIpF1IFmFOTgJ3ba9gcILQIWXGIp1e5C8g2MtuYO/6/jZK1lhFCLbvhpA9C4q uUp6/WXnavd3beKltkzL1v2dOjC1EkjrsFF50olV4f3d56JdS7JEnFzx7gVeSQfF uLR/t22CluxzubcYoAk/hdIWM2Ufi6v6ONVWc7D5nYBW9onNRKEquA/qOHZr3C/M QbRxTYyhaMW4Nrwck9jmpcQBE1EzscX3DAr+3W+rnKDCZL5QuI2Yq5gkiEYEEBEC AAYFAlNrl+YACgkQQVV2uqduC+1XMwCcC24MIzSxDOEpX7c/ecTKm18bOQkAmwU9 WqqUgT37bQ+U9ME322JPrBsitCp6enogb24gaTJwIChrZXkgc2lnbmluZykgPHp6 ekBpMnBtYWlsLm9yZz6JAj4EEwECACgFAlNrjZsCGwMFCRLMAwAGCwkIBwMCBhUI AgkKCwQWAgMBAh4BAheAAAoJEO5gwMjuclaobxQP/0oU+/nhTx7NRUZ3Ay/LzD7v DHqX+A1iPos1Xzmz+vq9a7z/mjjiQn0wfFiMctFc5dRf+hSM+W7BUfcG5rML+416 rEgtCDsQ0KfaFYUPRObxxNRdDv4N0j6uw2hFmAZ+KkOxKf5Z5CV7A2dwpjsO+PSc Ed0BM1iAjzNbod5b5uAn6r/Z43GSH2omRdhE8Ne5UrH58kLFSg8+iAfnnV5SSEKo bkP0f5m91esbh+vAgq0nFRsB8PeBYklw20wnAkIy6rmKJngBpiF0KfC/V6NY3g63 NDqf4wbSO8WqnrS9QWqYFzJfDsARQvx3jBqLTcQ4SlpIVWKNeogkeSeuqCVKRgvN jWBHdfABkf+DHrzlf072PK8RtDZn6wn1D91MeFCvg+Ss6XV2d0JEd+bxdK6Aj1RR X4XGv0jcH1Ftm9JRNjzXsALzndvwvEKU2xgDA2LATA7ikKbIq19VoTf90uc7i1Os 6cOXZkezZatyuJzJITGeq4llek+PVFxU/5LnRLr6h6K5D0/5F9KlgtPJKgSDOipp TN1Vof8f+v1/zWmyxpw9jtkNjM9chtOY7xhQfNxQLZuHXjQtDT3+JGo6/gTqj105 Yg+HNTJjkDYl2Y5AHb0WFHUFSn2GiBtot4V/g2ojMeQIiw2a8v17H6HUZSKYBjgR L7ln7O4oBduvaSSyZE2jiEYEEBECAAYFAlNrl+YACgkQQVV2uqduC+3d7ACgpRpk 13FSAhz/RpPnqYwRSFUiQTsAoIewgMNIxgbPQGUVDO3FpzChAfUruQINBFNrj7YB EAC8GDV5JcAcktMYnUbPxpydlWSDzzBaDUvbOAtWbrmkwQUXyij0O4ZW1W81e0R+ APT26TLuqc6Q+v6b0rWlVoZkSKYaqzm0S3mtLWUvEgPjHfYXT7VaHtzu6QUPwmVa w+o8dxkbajl5C1i9CZyr8ACziD23FSPA5nd/WQ18EAbnIjnT4cV9dP7lLqZAWtzE Cp3ze4ZHt6kg5i6rhJBJWbycHAZK2SMclC37S6MtZAwW0pJJwn/qdj7UvmL72QoV qXNHe8dfKfnxzo0/HoCKn4rlIW0W3xHgqy6VQUnyigL0blrVmxzcH5bgttXr94yh MVV1Kg9ie1GfhPf1ui86NnGHczbZB2TmTc/d2Nl1/L3TwxiWX2fv9BF+mVczRiXc 9FZRTF5JsBN0BAyxIE9vDXK/yygiWRSD1ND/0eTmKJRqOplpXoCBSDCsfvFN6/63 mx70wP92bNMmDZ/zbjFApmbMCjf+0wCZljiBtkNgT4k2nOYjb6Kt+vOeEg1XBTqo WREHEUA23xsu2DMH5Ra0OA0NwA9jrp1dg4t7fKIkSlBLNlIsZ73lNV21uuA8lVFR KHRX7y394c5/T9c8zPtJSmIZnAY52KXBFfsM3h+ExaQIWclyU375kYi0IBE9tCfF 7VuX1JgvA/9SjjtgfEWWLkhkPUAUl82e8SYQRx5Ki3RIvQARAQABiQREBBgBAgAP BQJTa4+2AhsCBQkJZgGAAikJEO5gwMjuclaowV0gBBkBAgAGBQJTa4+2AAoJEA6+ gRoa6YirbtsQAKheBU6M3oAfyAJ7i13mPEY2EvZFXdY41ct89ebdLCe4revG5Tao Fj/OmD0W+eBvRbJvOglw+0wYjpjAsnl95kYCBRL/BAr9xWt/g9SCcQqxOaYI9gM0 pFAcPjicEF44xdSMDSWGpN0PT5M6omlz5EObxuU3vaZ8y2XWYdvW8p1AwST66y/M AoACZqJUsIo7HIsz607XzNa3evIkCuGGNbTrD0OCTNUxOhwtqMIt3bHE2h4I8Hwp hptTf2eDf2z587/32gs3yp/VAeP6dCeQF3+Wduc41aRsCru7HnE2w/BiW1nzePyK 6b3RA56bZcbANIS8k/+EVOakS4uRDnweqkwBVgkWsCk17+XNeIaRaY0pWJaFs+hO f7cdp/XK+z2eFO1brEJa3BmnHHMx/lUv5YS8MgD+CcdvHvb2dirthzvyb6yDKFNn ZkMz3/Z1wnlDkMp/fjJAwXfmKT7IOqPVN5fpLcXp27Jh2BSrafvLupkIzZhrGL7R hTg8X83rLuQ0ZSn8k9cFju1pECI1atXC/kPMlSC4VffoViqwSZDLFsniFSNTaBOw EfKCLxv4s0BNovaUQfY2DUkL2BHrU18HbpGkaD3Gmb6TnzBYRTWSz15/9w8cjOc9 rr9d5SZaUeMZkGmlUdEG5q43b0MwQxYSA4Y3ZZGMgbjzEa83YN2njV7U07MP/1C2 D/tpWM2SliCGQ9ioPZVnwB43sme7J0GWjLRR085Q8+4V3/buWNG0UBc+l3MNlO0m N/zPp8ZqKCe6tLIXiExgiMSfcv9/7G3AgKxfzY+t3wFC6ISZiG5JFQIx/NI6zR+F RPUXUf8ZWH+i49p3UY564wULQMLobMuxhO2+BkjZKPkHAiXB0FTdP9WW/Gt2vWgZ L6ogdmo2bo2BQCU0VOOlCp8MxL9MlQ0FGURT/2kGoFzNFUo63UGvJc2iFmICI//9 OGBkpEMuPGrZI9W/4NTh+yMYj1b176IssWU2PWvhpempaXbcgXnlZQ5x6qcszzrw m403O814RLkIljRdtjHWOJKygXpjj8qTbDFfLXWDZ6MTtZOgFOPHFpc+Drbyzgu0 Z3dwXBeoyXQaZGOtClVJTCUYMjE6AaWZrnvsjT2TSxK+oy4XXzI4vVvDMJh2Ibfs YKiRahGQnBiYEMIrefoj/wu2GaZ71y8P6tCfdvlv9DikIVTHajdG4G2K7Sr4glgk cB9M2IsSy7bw2OGrGFvkpqriL1aYvIF5Wf4KIsxpMZ2FIUeGP4YfT3ec7zfSC5bp /yBP8J/XXaCV8NkhLF4bD9tU+XRRK54LZkoDrJwmTreHknluF6hFuJl8d0+oHyjp kHp\niEYEARECAAYFAlOB3xkACgkQQVV2uqduC+3+UgCfYZiUtx7FDGdQDhdVP8MyRf0D ANIAn2YHOQh4yv84u2Kuars1gC0j3Nr2 =Zu9F \u0026mdash;\u0026ndash;END PGP SIGNATURE\u0026mdash;\u0026ndash; Vydání od 0.9.9 mohla být podepsána uživatelem str4d. Jeho aktuální veřejný klíč je: -----BEGIN PGP SIGNED MESSAGE----- Hash: SHA512 Moje aktuální veřejné klíče jsou následující:\npub 4096R/0EC51FCDA94FB53E 2014-03-11 [platnost do: 2019-03-10] uid [ úplné ] str4d (http://str4d.i 2p) str4d@mail.i2p uid [ úplné ] str4d str4d@i2pmail.org sub 4096R/1CC61D9B33C3241B 2014-03-11 [platnost skončila: 2015-03-11] sub 4096R/803DEE491A3473E7 2014-03-12 [platnost skončila: 2015-03-12] sub 4096R/A1B84C9B733AAC82 2015-04-05 [platnost do: 2016-04-04] sub 4096R/13B5EE58C09FB3E0 2015-04-05 [platnost do: 2016-04-04]\nAktuálně používám klíče následovně:\nA94FB53E: key signing 733AAC82: email encryption C09FB3E0: email and release signing Každoročně generuji nové šifrovací a podepisovací podklíče. Každé vydání I2P, které jsem podepsal, bude vždy podepsáno nejnovějším podepisovacím podklíčem platným v době vydání.\nstr4d 20. lis 2015\nAktuální klíče (k výše uvedenému datu) následují:\n\u0026mdash;\u0026ndash;BEGIN PGP PUBLIC KEY BLOCK\u0026mdash;\u0026ndash; mQINBFMfofkBEADlyw6v1hGBtnIISujt/18RJcVTLAxYtfe3DsGhWqYZN3iKGGWb NJ5vZcV65FVH/70NFnmKlvYp+tVNJcoRtEYpfwiNG7nIyOC4GgaSLwkNVgLcFZhV mNj2RIJphjN5qsWm6ut9p9CyhWkVNJYDP65gqwShZQ2lPboo9s0XjUF78SrSshy2 iVij0xu6oqdjwqn1B7L3lXVYCwxReCvSdFnBMpjGUEgGnbt7euhrViFk8FrUkAje 2tZA5FAUA/t2Mnc9JREe6WlbZ44mLApOjFdw0g415FdcnS2GGaYuXNG1lJ1yOA33 n9JXT7A31wPyiw5yz7fxgl7ZNYZr2TsRjBlqEhf2SCPfqU9UlhJ9NqApaPyCEr+8 oZQfZ9r6stc98MlnmdQ7p4SmKRwCLiBtgmrB8mbgYV+iOwaKztqEoma3FoO2EJ+j Gx+UrJ0bIFVr6sL0ulfneYlY76wWWRpB/pLLgIMmZw83uB+JDBQyZFXcAHj9jMQ7 ZNn0MNQ/I+qcmX+CRAyl2+cQHUVbbQWDjB3crZlpK5TGw/x7w0YxBYAH8Us5JqJH QOsact8ADnE4IiKm5gVefFmNX6vsljkNESdpAMxnB7Ckl2XV/r5sKwrdxxUbFSxp IKGx2uKGUs4oUffOzpKULhGBWypN+3fVwvP+q896Il9hgyx6SCQ8AgPHRwARAQAB tClzdHI0ZCAoaHR0cDovL3N0cjRkLmkycCkgPHN0cjRkQG1haWwuaTJwPokCQAQT AQoAKgIbAwUJCWYBgAULCgkIBwYVCgkIAwIEFgMCAQIeAQIXgAUCUx/ZQgIZAQAK CRAOxR/NqU+1Pk9EEADHdpsmrA6ZKU4EmBZNbw62D7tAo00Fh25m8OuIkXtOqEbF /guTZiZM4nbhZpPFG9sCN1bXS8VslA7isOedbznkKnSK0BJcrzldwKzW25cwptoQ CCqTUarYbhcIzEOKNetYqICWrVTy2Yuc37maA66PnRLphV7pP3Fj7eN6aMtqwtpJ YukIU4LAjKOMJ6gwy7tjsZYbAqgSE8wRJm7i1MfO1W864a1l2a68Gooz03NC6mfY J8aW0y1F87xMJIgZeN7OyHf2AC4/Tp/cL+Gd3HcUuoRjmWBgaxH8tVNgfxSIUMNH 5pTdDs5VlRolwlOEcTW5VxOSu5C7ZbuKyFmbI0DSevDVGS0rxSSizjlyGmnxkLU1 ozpeIwTbwTUzvd26+k8cidGodKqoNoyAXzjaiBXYKgIrVeXBMHxCGeQtGeEhQR+L OXs8cEX6xpt9g7nKbNki0Cfv/lx9Byn+0v9RvMJKDa1mOSKbNOx3NJ8+ewdTVkTs iYFTZwpJexbfovPYqTdisiO7dv0i5teE8sEj25icdPtKYvn/55JCT67E8MVZaeyU YOaMPtgsiOX0v68NtrC1L37UuBykQlm7FdobN4Sg5FnLTt4IWktf0/vsaLdhRozD KsbTmsumCrScAwZfa0H3S8WqK6yCEKjPi+J4xG1OZP1WptlV41wLnFKkeFaZRIkB HAQTAQoABgUCUx/Y+AAKCRDV3jiWlKRlsmU0B/96eiPHIIvapoXKoZSt23OFjXG+ 3xp/Zzf2Ug0384FYZJ1eX/R2IWsh64CVvOR0LMFvHvPU7SCMu2OreNHfPx/B/kn8 MmusGy6JHP25A4BWzs1eeyKgYQTFz7vSCeAnytmcdBot1s099upIRw4usCLhdxzv Qyx6TogAacGC3YFj7o0agz+ApPnCQZ68kZpDOCDrtOe/DRted1LLXM661Cp15d5R d+91ZSKfQ9xjK1d2k8iMYJqWYll50DalGtzPGDB335gX7agliI5dYiu2XSLyynhw /7f8d0Bz8KVj7pgCroAVjTSdHvZfVcZJU4HST/jHx5hilVUzkr9NK5YONJ8SiQQc BBABCgAGBQJTKlm2AAoJEPvivaOtdGgqmGAgALl0eAcUSF7IuloPT4VyJeNGMuOb 7aN4yYrGBM+y7Ij/dTWSS1yjlcixsqd+s0dqGse6RtJkyhkisEmNdS7Sf62okGDl ZbmhjvMQteUO1zw+CREdfx5oMpW/eCHq/Pzw8KRdp6qY0wBRj10GFMAaMX8XCNOh 6B6Ti0AQ/424yEvcPpA0zXwvLGylFozRxjK6qWEHEmW/+knxYYN/W+8TERuwVJSN F3jBYl73DTVBZ4bzpu5jMSydhRD02nV2LbnolhbCzGllLkhQw6iFW36br8600Tba loQhcJU+cmuCId/B6xXcF+fyWqmMmm+b0UFoHGRBnXCf4gBcjCK0UwJ1lUOTY5qg IYJTrBpCrGAoGTd9s+1CtnnZFlIcwFJB7NwMZEsTWvOvO6sZPYP33ktcUwWAKqNj 3sSjy43kdfUeVip0jzV0K5uStC+DiVq8VwH7uNIH2UbkQZato67WgShUCCaSvf2p HapSRdrmwIaoANQuEluhytdafX7yqJXGkhYI0Ylh2FH3oZyTnz1XoB5y5T1OpFpi I7CgjRO677aieRsf6HACHPX5mWcq8zJQ8fuxoHZ5GJ8FEyk6ULUgFJ3u9SgG5k5I vP4pK8+lP/d90Zf98Uaq4aMgAoIlrtwz68Bv/KUlpwVWhiIgo89C5UwcTUNQOmi3 0PxCpamM81NwGPxjZAqr/+0YP3NBtJOITL0oqRCxcHCJ9N8gmqUmUEgEffP+glsJ p/mQeJEacmR9loz6WAB6GT9mu5TvX6bZ5EawnluQ1mI6Tn+v6ltjhKzPzaVhOo6d iKriQFZhcelX1qDnE3zs7driBeacuKGt4URV8A+UDGJBeIAEfrlszor3FQ0qOUPs plbcbB4YudUOhlH1REtGx7zWVFefuy80ZC7abHsPhWkJow2axWlvPqjSsd/KgpjG IAHIZxiYAozNJqDNluGx1+qa1d7/YINthZKefhkG3XDLuhgxvD8rAovyAFW/8Vy0 S+GpzUVtC8HY9FZf2gRkVtZQGboZck2uFyIaU/Ni4ahX8Z9IvtsU9JPLzp0HRgAv 9kz9EyRZt1viueeIVcmadHirUe1IKqndeslcXOX4dUF0nrqP1+shYhebgq93rMPR yH3EsoXtAP1KCN8tWPdnlDnMY0Zpy32mfCL0hMMnH+CY5rARssSbiFP9HeWk/CN+ yES7FY705QmV/2SV4rEngqnIcrcqEJFp49JPihC1pSikHCItzSVFaODbUl4qhTjn Tjtl0pdFQc9ksA/6IEOH/bufDwtxCLwAjUpqyNGEH/8FnxtwotsTmhmTWMe9vxYe YStdTLkAvJFMVEU0W+H2ZZG481P5/8tqFS9cHEU++3VvuYxfipwjpIQhm5WJARwE EAEKAAYFAlMuEVwACgkQq+DDGd8KChpPGwf/QL66k12OzqI40KQL+UbzW25vxbmE OyZ1MT9SuUVt6Th9zdoNm9Cosi9kOiq+DPLFFT751Lmm1hcM0rDDNeN+l8wpLwX9 EifD/bQ7Q5esM8NJmGVyhA/Cd3wkp5yYNdZPOu9/0xpe/Px4YgficRErhgyVh2Vs svQRQ0WcTYbgbmQFpOUsjNVOchJMFERSJaQxWgN3olYd5DTDxPDLztt3vdBCIkz0 4OAotZqbqdnmvlkjKjzrJylfCkyo9bOU471v6Hs3mfUQXo9nXC9zGETFWsvB4WCC QdWEyj+2K+PcdZU0FEPonfTouVcsR9oTqQqqfg21M7HUHSmlrOyCLqNnZ4kCHAQQ AQIABgUCU2vk5AAKCRDuYMDI7nJWqGIzD/9vdI3uUUYGCaURAprGEo4kk6JP2TcS AmyO9Pr8bBdpmt/DVFK0zWllQ+69QAWLFoCmgjOgWUPRNWA+ldG5lzExjuuP38P1 4HupPMh0yOd+QUod4Gdi+hqPCuFT4/oErWZcOGGXAw4ZcvdEGKY9E975D+3yd7sG HGskvGB/UmLIBQ2XfQOoqk0A9eXz55wLN1ia1imHd/0NkPkQOHkjTdOtHhcBhuoc ttex9HcmYy2g5oorG+7wx0EtHxIhuCcRq1wQgXm2JtbiFHXiH0MpLfBr29kpzH7y 8jompGgAJsK8uRwTC8UFWHnx0VxnFQ+4vinqlgj7/O+WMZ/siDlOZDo2RC3ts+Ct 91kYNFHsycrkJYuoPzNcMy7mmixQFj5L2VIG1Ne3OTdEPVWE5jIQ/w5IX0aYxNt4 ANIZJA/r1AqDqDEhto6gdnkrVZSJN+Mvd7yj7XTbrErpTmQeNkGgb9ult4XaEOdm bjAjE6rTQqFD3Tn8SeXNgkJFr0Zb8lZypmOL6cxU4vTG66blJPLZGuaH3yCrtA1i ynZPrV2TYiET+fhg2TBEXbjLkWHQnA+7sFFOTgK5WOqc6vK29h5ssEQKIFodDh4a e88tiGLW9lSc+YWRpKHgEc8QDXIuBrV18hZEvbITvLZnnf5uIFXJV5ZCHG+o6I+Y jQrPY4oC2HGrMIkBIgQQAQoADAUCVRRYygWDB4YfgAAKCRCFZ1M6Yr7+XbxwB/42 Kbk6DpZueEK0qtdoLUh7H+dWfwA0Gsh/vCoS6RM9iXjKPBoQGlbCBpsBpqCJkGd/ iXH+tnkU2dq4BvGc/igSHadNYmYq077l1vu3pJjDjxfQ2qZSF9D27EUzlXLd4Q6s hysZ18HoTehxr3AG33N1tEm9kBUfZjeMZxk7zbty3Lo7tK/UYN+4mIgYqLc97XIe 40Z\niQIcBAEBCgAGBQJWT6iBAAoJEBO17ljAn7PgnxIP/RevbXaCm2Q3ildI0YLjQFDr vSIGKsCjD9nZY3ETk+CNFGOL4aYWp96HWuQoMq7B6qlb/sLejN/Ssu3M0sxf2hNK pCIagZClqRchSBK+0UpAEIs98sf0sPakqKg0FlOJhuCsKHMUOxpQJ4qCDh6f24b2 cqKR8GjyUAgSeiiyN+DkDyqRYingQGAU5vzKepYzX+DMHC/izqQhrwQLVImv20wr 5pKZJDjfOpYUZRTuScV5Qwcgc0JYcMOjfgA93ZUA2zDrGIpw3dcCSMrpNQcvM6Cg 1mfiLZzkvPH3UkUOWhHCn/N2XaAF58joCaS+/bVUaXx02IbxJ1TTjqtCiH9491mE aaHeRCFYbkKCXWjuxCx1+VZN2yRk24rSkis/+LFgZm850fXgYfrqiyPRDlCMApdo 5JDUBTioyZz24vhqWpe0OZueu11DXtpU1G0BiheGrweXAAx0Yki8dRiPTXkavAMj oMBND9G7a1564KOe+t6V2qUyH50+3NaANvIiDJZbspX7yl8eVzPbwcGvtHzmHdnV pDh+38XUQEID5YJ/mdZh6evzmmTnQR1HVqPVrzs8SwIDO++tqj8DXTjID47c3VIl YhCMNlucciFxVn/sYI5qiJzCEMLMbvG+EhnoLNU4JGjfzo6I0RCpPfbrDfOsWJNi zYMz9htqusCQsGwUZSTZ =XBC5 \u0026mdash;\u0026ndash;END PGP SIGNATURE\u0026mdash;\u0026ndash; str4d podepsal následující vydání: 0.9.23 Vydání 0.7.6 až 0.9.12 byla podepsána uživatelem zzz následujícím klíčem: -----BEGIN PGP PUBLIC KEY BLOCK----- Version: GnuPG v1.4.6 (GNU/Linux) mQGiBEOjTnURBADegKKrIP6pz4+n57dqo3l9QrKhIklCtIxgJkL06ZJq5fKAnMLv GPaGXmn5vRrbo6QzHs/lGLG+ySWFWr9SsVstNKrwk+F1yGIERutl0BqMwX1esfN2 ugiZ3wB1yRu0PIrkm5cuDAFASFE+2lBjr1lfOrhw/dV+lLTcWx4NzkMzlwCgxgIk 4cqQMGaVkmtuICQdYmmMicUD/AmNSVJEm2XUvaS5fYWsHJG3+oNkdNGcx5SOMUdk PFwcSozqvT9FeIP76OVHAshQKeftE3utOFANQ/YomXEnypmwMxLLR+GPw5pMbKlK 6p+87aJZz+SA95E3ekmh7MmndvRd5RJDboUZy2H0FKX+FgaBlpsLl0uhT6uDuM/s 7nb0A/9nEAgICOU5SeXtO3jKY+RQvKyE0AblK7xVaU+Sn8ly0zauOJD13rycVGhu vLcAUVR3FKEjxafpvZ0ZPBo7AACjSDqAoCw/s/vt9gmrhHKiqN31PhYYLhKdfKTs 4LzWKTWKIAOwErkbYsMAXWKFT3LXsrEYvxq5j5m/6zMOwz2N7rQYenp6ICh6enop IDx6enpAbWFpbC5pMnA+iF8EExECAB8FAkOjTnUCGwMGCwkIBwMCBBUCCAMDFgIB Ah4BAheAAAoJEEFVdrqnbgvtxGsAn39SvQ3+ey87WDDG+TWArN6oU8gnAJ4zeAsA LUK37WZIt8OImZSxk37uQbkCDQRDo06VEAgAy2UeqsM5a+U6ZOWS9NQiILb3KbTL FeeAd2rn9oLSLpn5gDWycwUS0Q62JmbSMWy6m9aczpnxvwaBYXz6aCIvZmTNtaU6 vyR/6wfJDyiUWSHtCyjpyFFYJimANd8Y8dDCimvceI/ihEDVyBX0kkgUGRAn8t3e unaLXqhbfiLiFw/GG1MNxUMzHt55/+9AqLOfRZg0riZvDoV79K+1sYSs8n1WeaVc T3wTb+Cb7fKNN7GT1MUhcXIoYYY6FGwsy5EWFsxYBRervqHtBJog2SoNUa/6BFGr zX+LDjK9L3xMTr3+fHIt4gPR/Lt4nnfEzL+rjClz/Fazmv38BRwPuKahFwADBQgA nD/AvZCnbWSB6khAVMqva5ROaD0gV0/UejCelZdYfgfHeCmrcMNQ+wCyww2NPsih 9vB1w+AUE0pdH37k65VZN+2falUdzN+PFugJGuH2pmlVOprH2SuC5gKpGRvzUqV5 U0nJmT2okDpW/52asUDJJLu1g//A3qBP83WGvSKUZg/ZisZA0qTiHH4QpjklopXi sSxR2hT8Fr9gF9WmDa09wbxE2xh/EL7gvVg/vk0gwOJcsFd67bNC+KUMOnjhOP0T K0/Ah4TEEs/hHNe9RsyyWlMoIUsF8AhG71ISOrJ5lLSXNe151XEb5FzZRM8sD9Zq 0E3PjmLbdVhanYvsPnWK6YhJBBgRAgAJBQJDo06VAhsMAAoJEEFVdrqnbgvtXTwA njMu9ueCFbsjme7nwsz96PdazJcHAKCce17hGI25QNXDZyHohrjha6IxDg== =fAfi \u0026mdash;\u0026ndash;END PGP PUBLIC KEY BLOCK\u0026mdash;\u0026ndash;\nVerze 0.6.1.31 až 0.7.5 byly podepsány Complicationem. Jeho veřejný klíč je: \u0026mdash;\u0026ndash;BEGIN PGP SIGNED MESSAGE\u0026mdash;\u0026ndash; Hash: SHA1\nAhoj,\nPotvrzuji, že níže uvedený veřejný klíč je můj nový veřejný klíč, vydaný dne 24. 11. 2007, platný do 23. 11. 2009, a jeho otisk klíče je:\n73CF 2862 87A7 E7D2 19FF DB66 FA1D FC6B 79FC CE33\nPokud máte můj starý veřejný klíč a použijete ho k ověření, všimnete si, že můj starý klíč vypršel 15. 11. 2007. Omlouvám se za zpoždění s touto aktualizací.\nPro ty, kteří chtějí zkopírovat klíč přímo z této zprávy, ale nečtou ji pomocí e-mailového programu, nezapomeňte prosím odstranit escape sekvence \u0026ldquo;- \u0026quot; ze značek začátku a konce bloku veřejného klíče. Jinak nebude rozpoznán.\nKomplikace.\n\u0026mdash;\u0026ndash;BEGIN PGP PUBLIC KEY BLOCK\u0026mdash;\u0026ndash; Version: GnuPG v1.4.7 (GNU/Linux)\nmQGiBEdH5SYRBACzCum9jIjq+/G7ckuZ/TcFmaVYeBRE6OXPQozyrmTYtoCM2qGj DmvMJvKYiNiQVM42KiwlnqvaNtlgnXIZ6rcyLyn+bCI5cdX1SD5Rr5tgsgcXYA6Z l7usiFv1bTjD67piBehF130o+LZAJnVzI7JdpbA9SBY0mUwgKXLi0DAo8wCgiKOV UXC8+9X9vU1Mh/GyIrD4c3kD/iQOkYH4ajNaehTHNB31K+61ltpK9tMmcWtUY30A Z3q38jg/nmqqup/MYCtkvOqY4X9kujKzu01eSWSNZIE+BQSSd1cSsVD17OY3TL6B EvE+UFxh8OnDKs3tzJ0COnT/2zbgTavbWwqovoUE0P0PSYOFm2Co0BEQiCt9Tabc CxU3BACRWDvq7LFMRnHT+/OOJS6M442CYzy3+tIuc3ZAmZ8QwGsh4r1kd+5P1JTN YJCun6MPQEllJbRyHRBby76vFkWearRgnkpAmk2l1T2SXw3lip/SdmI0GgIzPSfQ 8WyNbMjQXyH8/3k2Y9rgrC0DttrJPYOcTFMNKPpeTR+HN3ZnibQ+Q29tcGxpY2F0 aW9uIChodHRwOi8vY29tcGxpY2F0aW9uLmkycCkgPGNvbXBsaWNhdGlvbkBtYWls LmkycD6IZQQTEQIAJQUCR0flJgIbAwUJA8JnAAYLCQgHAwIEFQIIAwMWAgECHgEC F4AACgkQ+h38a3n8zjP1yACfWkF1zjmlD0EzLaJRnefW5OHr10MAn0fgMyElK6ee AoPl2mTfxQQYOophuQQNBEdH5SYQEACTcoMJQBhyrr+EunLmEGNMO7D6RSBAtEKZ i5ctmhr/TCXMV9qjXkWISLZ9AS6z88rKozeOOK+QPBnc2FcEf77N04O5hwSdAyPH Qt7+umhiNQFQpZycJ5W87Y0ryERJygA5XyU47g7CGvuuOLgKGk0dDGCNFZGSblwI xtSh1CsrjWp23grFiBS0xvlU2VyuYUyrBuH5ip04pxmOyeRcaelkQerFhEXSRIR7 XFxl6JpfqWt2oWHmYbYD3RT6WHU+rpSF1Hyey+zoF2zXfRb+JD90MpBL1xIkpieQ Y69Cj5U5VRjEppJJowSmwgz+UyMnT2KLl45vJesPrMUaSgduHiIQo4LM5BcbbV+2 SC5i9xqbSJ+rc19Ftt9IEUZVMLole9PJC5Ff/h1qsabyueFuMIQkbiaUiNLOKl31 I+JAiDt0Xku2PEVCERg7Jq5AsTLB9D+zKqxbvFu+JvqSdlaCvlas2BYU5rBosszH TStK2XW/+poTKnjnbJl6nGC06BNQPhRFAwuXboyUC5fyiuG1HohvPmPIi6IejLUY G8A5nZ+7um/XpKlt2i5rdVRfN1BX3+aKHQeLmrc+EIORZUU32TrP4ceLtSDf+JOW 8N3vwzqKIPu42Y5KB8vnXEFSOkyt36OfEd6CcPKmncDyA4wJmfC+X3eoKcj+Yrh7 UMr0elyw4wADBg/9F7g+bTpT4wPXj5ax1i+4BdedjVlO3YBdhc4LP6MXipNU6yLl l63TJ8q/l8pvSkUWZXrO3a7OibM/MHp0Te/7sTmKib2/3MFwHTrtjgcZBF6wx8LD T3oa6O0IK8IRnRwNqeu83SxojvVY0wLz/hpUbnIrOcHMZjWLMJEfHkNBHn+1HhT5 tk9LRGu3j1oTpGh+DpdoPF5fggNu48YJ6n7etJJGW2MXQ++33aKeQSFrx+KlMtFW DSzg3KKSroB8Ex9wiKKWybagaed0YoP9BW3vIAaOeDpqK92UuTFz1Bte1DYiYU1e Rqq1xoBVhJXE5xzGmvS4/PIZMOL/bpKcuNxAgmwOVoaYoWZuIgePUaBbNvNg84HE RBjFMyfpzRCdPlWPZ18KcLUki3T58KzXEZ7WS5hC5lezwC6ET+wJusAt0A+Ik146 igayKfVnvhedQdqufWhQWNr+hDc5Fb/az8nTyNOflAhD3yHldjxgkCOV8wjqyS+4 iO33P5wW7o2QkZNWq8pyjsKRRJCtZ/PJ7FRGkUOjoC/gwhnGvBi0KoDcyBmfnPXp 3MAgrzk9LwiA7PlS7PyhyMx5mYpa90xlXzszweCIXzGfbm6ciCUAM3G3Qb+qa2dW 0u1X5L6bVtHVpYnr+5JOxCS4qwQvoK0QnHu6ezu4+rFutUJN35z6rFquejiITwQY EQIADwUCR0flJgIbDAUJA8JnAAAKCRD6HfxrefzOMzSZAJ9PmYNkW4Ia1qPqowg9 z4Ja+hJ3dgCeL3mqvOEHG7AcUQrSlc6xlC1vbNY= =rGxK - \u0026mdash;\u0026ndash;END PGP PUBLIC KEY BLOCK\u0026mdash;\u0026ndash; \u0026mdash;\u0026ndash;BEGIN PGP SIGNATURE\u0026mdash;\u0026ndash; Version: GnuPG v1.4.7 (GNU/Linux)\niD8DBQFHR/zm4tLxqYRsGn0RAtCfAJ9rz+tsyEbeUAHcogdzgSPfuiWOAwCfWaVn Aiib6V5wOPbYTy13ADmxhfE= =mPFq \u0026mdash;\u0026ndash;END PGP SIGNATURE\u0026mdash;\u0026ndash; ","description":"PGP klíče používané k podepisování vydání I2P a kde je získat","id":"ae494d28c5c0216d277398ccdcc21df5","section":"docs","title":"Podpisový klíč vydání","url":"/cs/docs/develop/release-signing-key/"},{"categories":null,"content":"I2P adresy jsou dlouhé kryptografické klíče. Systém pojmenování poskytuje přívětivější vrstvu nad těmito klíči bez zavedení centrální autority. Všechna jména jsou lokální—každý router nezávisle rozhoduje, na jakou destinaci se název hostitele odkazuje.\nPotřebujete kontext? Diskuse o pojmenování dokumentuje původní designové debaty, alternativní návrhy a filozofické základy decentralizovaného pojmenování v I2P.\n1. Komponenty Vrstva pojmenování I2P se skládá z několika nezávislých, ale spolupracujících subsystémů:\nSlužba překladu názvů – překládá názvy hostitelů na destinace a zpracovává Base32 názvy hostitelů . HTTP proxy – předává vyhledávání .i2p do routeru a navrhuje jump služby, když je název neznámý. Služby přidání hostitele – formuláře ve stylu CGI, které připojují nové záznamy do místního adresáře. Jump služby – vzdálení pomocníci, kteří vrací destinaci pro zadaný název hostitele. Adresář – pravidelně stahuje a slučuje vzdálené seznamy hostitelů pomocí místně důvěryhodné \u0026ldquo;sítě důvěry\u0026rdquo;. SusiDNS – webové uživatelské rozhraní pro správu adresářů, odběrů a místních přepsání. Tento modulární design umožňuje uživatelům definovat vlastní hranice důvěry a automatizovat libovolnou část procesu pojmenovávání podle jejich preferencí.\n2. Služby jmenování API routeru pro jmenování (net.i2p.client.naming) podporuje více backendů prostřednictvím konfigurovatelné vlastnosti i2p.naming.impl=\u0026lt;class\u0026gt;. Každá implementace může nabídnout různé strategie vyhledávání, ale všechny sdílejí stejný model důvěry a rozlišení.\n2.1 Hosts.txt (legacy format) Starší model používal tři textové soubory kontrolované v pořadí:\nprivatehosts.txt userhosts.txt hosts.txt Každý řádek ukládá mapování hostname=base64-destination. Tento jednoduchý textový formát zůstává plně podporován pro import/export, ale již není výchozí kvůli nízké výkonnosti při překročení několika tisíc položek v seznamu hostitelů.\n2.2 Blockfile Naming Service (default backend) Představena ve vydání 0.8.8, služba Blockfile Naming Service je nyní výchozím backendem. Nahrazuje ploché soubory vysoce výkonným skiplist-based on-disk úložištěm klíč/hodnota (hostsdb.blockfile), které poskytuje přibližně 10× rychlejší vyhledávání.\nKlíčové charakteristiky: - Ukládá více logických adresářů (soukromý, uživatelský a hosts) v jedné binární databázi. - Udržuje kompatibilitu se starším importem/exportem hosts.txt. - Podporuje reverzní vyhledávání, metadata (datum přidání, zdroj, komentáře) a efektivní ukládání do mezipaměti. - Používá stejné třístupňové pořadí vyhledávání: soukromý → uživatelský → hosts.\nTento přístup zachovává zpětnou kompatibilitu a zároveň výrazně zlepšuje rychlost překladu a škálovatelnost.\n2.1 Hosts.txt (starší formát) Vývojáři mohou implementovat vlastní backendy jako například: - Meta – agreguje více systémů jmen. - PetName – podporuje petnames uložené v souboru petnames.txt. - AddressDB, Exec, Eepget a Dummy – pro externí nebo záložní překlad adres.\nImplementace blockfile zůstává doporučeným backendem pro obecné použití díky výkonu a spolehlivosti.\n3. Base32 Hostnames Base32 názvy hostitelů (*.b32.i2p) fungují podobně jako Torové adresy .onion. Když přistupujete k adrese .b32.i2p:\nRouter dekóduje Base32 payload. Rekonstruuje cíl přímo z klíče—není vyžadováno vyhledávání v adresáři. To zaručuje dosažitelnost, i když neexistuje lidsky čitelný název hostitele. Rozšířené Base32 názvy zavedené ve verzi 0.9.40 podporují LeaseSet2 a šifrované destinace.\n4. Address Book \u0026amp; Subscriptions Aplikace adresáře načítá vzdálené seznamy hostitelů přes HTTP a sloučí je lokálně podle uživatelem nakonfigurovaných pravidel důvěry.\n2.2 Blockfile Naming Service (výchozí backend) Odběry jsou standardní .i2p URL adresy odkazující na hosts.txt nebo kanály přírůstkových aktualizací. Aktualizace se stahují pravidelně (standardně každou hodinu) a před sloučením se validují. Konflikty se řeší podle principu kdo dřív přijde, ten dřív mele, v tomto pořadí priority:\nprivatehosts.txt → userhosts.txt → hosts.txt. Default Providers Od verze I2P 2.3.0 (červen 2023) jsou zahrnuty dva výchozí poskytovatelé odběrů: - http://i2p-projekt.i2p/hosts.txt - http://notbob.i2p/hosts.txt\nTato redundance zlepšuje spolehlivost při zachování modelu lokální důvěry. Uživatelé mohou přidávat nebo odebírat odběry prostřednictvím SusiDNS.\nIncremental Updates Inkrementální aktualizace se získávají prostřednictvím newhosts.txt (nahrazuje starší koncept recenthosts.cgi). Tento endpoint poskytuje efektivní delta aktualizace založené na ETag—vrací pouze nové záznamy od posledního požadavku nebo 304 Not Modified, pokud nedošlo ke změnám.\n2.3 Alternativní Backendy a Plug-iny Host-add služby (add*.cgi) umožňují ruční odeslání mapování názvu na cíl. Vždy ověřte cíl před přijetím. Jump služby odpovídají příslušným klíčem a mohou přesměrovat přes HTTP proxy s parametrem ?i2paddresshelper=.\nBěžné příklady: stats.i2p, identiguy.i2p a notbob.i2p.\nTyto služby nejsou důvěryhodné autority—uživatelé musí rozhodnout, které použít. 5. Managing Entries Locally (SusiDNS) SusiDNS je dostupný na: http://127.0.0.1:7657/susidns/\nMůžete: - Zobrazit a upravovat místní adresáře. - Spravovat a upřednostňovat odběry. - Importovat/exportovat seznamy hostitelů. - Konfigurovat plány stahování.\nNové v I2P 2.8.1 (březen 2025): - Přidána funkce \u0026ldquo;řazení podle nejnovějších\u0026rdquo;. - Vylepšená správa odběrů (oprava pro nekonzistence ETag).\nVšechny změny zůstávají lokální—adresář každého routeru je jedinečný.\n3. Base32 Hostnames Podle RFC 9476 I2P zaregistroval .i2p.alt u GNUnet Assigned Numbers Authority (GANA) k březnu 2025 (I2P 2.8.1).\nÚčel: Zabránit náhodnému úniku DNS z nesprávně nakonfigurovaného softwaru.\nDNS resolvery kompatibilní s RFC 9476 nebudou přeposílat domény .alt do veřejného DNS. Software I2P zachází s .i2p.alt jako s ekvivalentem .i2p, při překladu odstraňuje příponu .alt. .i2p.alt není určena k nahrazení .i2p; je to technické opatření, ne rebrandování. 4. Adresář \u0026amp; Odběry Destination keys: 516–616 bajtů (Base64) Názvy hostitelů: Max 67 znaků (včetně .i2p) Povolené znaky: a–z, 0–9, -, . (žádné dvojité tečky, žádná velká písmena) Vyhrazeno: *.b32.i2p ETag a Last-Modified: aktivně používány pro minimalizaci šířky pásma Průměrná velikost hosts.txt: ~400 KB pro ~800 hostitelů (ukázkový údaj) Využití šířky pásma: ~10 bajtů/sec při stahování každých 12 hodin 8. Security Model and Philosophy I2P záměrně obětuje globální jedinečnost výměnou za decentralizaci a bezpečnost—přímou aplikaci Zookova trojúhelníku.\nKlíčové principy: - Žádná centrální autorita: všechna vyhledávání jsou lokální. - Odolnost vůči únosům DNS: dotazy jsou šifrovány na veřejné klíče cílových adres. - Prevence Sybil útoků: žádné hlasování ani pojmenování založené na konsenzu. - Neměnné mapování: jakmile lokální asociace existuje, nelze ji vzdáleně přepsat.\nSystémy pojmenování založené na blockchainu (např. Namecoin, ENS) zkoumaly řešení všech tří stran Zookova trojúhelníku, ale I2P se jim záměrně vyhýbá kvůli latenci, složitosti a filozofické nekompatibilitě s jeho modelem lokální důvěry.\n9. Compatibility and Stability Mezi lety 2023–2025 nebyly žádné funkce jmenných služeb označeny jako zastaralé. Formát hosts.txt, jump služby, odběry a všechny implementace API jmenných služeb zůstávají funkční. Projekt I2P udržuje přísnou zpětnou kompatibilitu při zavádění vylepšení výkonu a bezpečnosti (izolace NetDB, oddělení Sub-DB atd.). 10. Best Practices Udržujte pouze důvěryhodné odběry; vyhněte se velkým, neznámým seznamům hostitelů. Před aktualizací nebo přeinstalací zálohujte hostsdb.blockfile a privatehosts.txt. Pravidelně kontrolujte jump services a zakažte ty, kterým již nedůvěřujete. Pamatujte: váš adresář definuje vaši verzi světa I2P—každý název hostitele je lokální. Further Reading Diskuze o jménných službách Specifikace formátu blockfile Formát konfiguračního souboru Javadoc jménné služby ","description":"Jak I2P mapuje lidsky čitelné názvy hostitelů na destinace","id":"fc2ecb5df890709d0740d866d03a6250","section":"docs","title":"Pojmenování a Adresář","url":"/cs/docs/overview/naming/"},{"categories":null,"content":"Účel: Zajistit konzistenci, přesnost a přístupnost napříč technickou dokumentací I2P\nZákladní principy 1. Ověřte vše Nikdy nepředpokládejte ani nehádejte. Všechna technická tvrzení musí být ověřena podle: - Aktuální zdrojový kód I2P (https://i2pgit.org/I2P_Developers/i2p.i2p/src/branch/master ) - Oficiální dokumentace API (https://i2p.github.io/i2p.i2p/ - Specifikace konfigurace /docs/specs/ - Poznámky k nejnovějším verzím /releases/ Příklad správného ověření:\n❌ BAD: \u0026#34;The ClientApp interface probably requires three constructor parameters.\u0026#34; ✅ GOOD: \u0026#34;The ClientApp interface requires this constructor signature: public MyClientApp(I2PAppContext context, ClientAppManager manager, String[] args)\u0026#34; 2. Srozumitelnost před stručností Pište pro vývojáře, kteří se mohou s I2P setkat poprvé. Koncepty vysvětlujte do hloubky a nepředpokládejte žádné předchozí znalosti.\nPříklad:\n❌ BAD: \u0026#34;Use the port mapper for service discovery.\u0026#34; ✅ GOOD: \u0026#34;The port mapper offers a simple directory for internal TCP services. Register loopback ports so other applications can discover your service without hardcoded addresses.\u0026#34; 3. Přístupnost především Dokumentace musí být pro vývojáře dostupná na clearnetu (běžný internet), ačkoli I2P je překryvná síť. Vždy poskytujte alternativy přístupné z clearnetu k interním zdrojům I2P.\nTechnická správnost Dokumentace API a rozhraní Vždy uveďte: 1. Plné názvy balíčků při prvním uvedení: net.i2p.app.ClientApp 2. Úplné signatury metod včetně návratových typů 3. Názvy a typy parametrů 4. Povinné vs volitelné parametry\nPříklad:\nThe `startup()` method has signature `void startup() throws IOException` and must execute without blocking. The method must call `ClientAppManager.notify()` at least once to transition from INITIALIZED state. Konfigurační vlastnosti Při dokumentaci konfiguračních souborů: 1. Uveďte přesné názvy vlastností 2. Uveďte kódování souboru (UTF-8 pro konfigurační soubory I2P) 3. Uveďte úplné příklady 4. Uveďte výchozí hodnoty 5. Uveďte verzi, ve které byly vlastnosti zavedeny nebo změněny\nPříklad:\n### clients.config Properties **Required:** - `clientApp.N.main` - Full class name (no default) **Optional:** - `clientApp.N.delay` - Seconds before starting (default: 120) - `clientApp.N.onBoot` - Forces delay=0 if true (default: false, added in 0.9.4) Konstanty a výčty Při dokumentování konstant používejte skutečné názvy z kódu:\n❌ BAD: \u0026#34;Common registrations include console, i2ptunnel, Jetty, sam, and bob\u0026#34; ✅ GOOD: \u0026#34;Common port mapper service constants from `net.i2p.util.PortMapper`: - `SVC_CONSOLE` - Router console (default port 7657) - `SVC_HTTP_PROXY` - HTTP proxy (default port 4444) - `SVC_SAM` - SAM bridge (default port 7656)\u0026#34; Rozlišujte mezi podobnými pojmy I2P má několik překrývajících se systémů. Vždy upřesněte, který systém dokumentujete:\nPříklad:\nNote that client registry and port mapper are separate systems: - **ClientAppManager registry** enables inter-application communication by name lookup - **PortMapper** maps service names to host:port combinations for service discovery - **i2ptunnel tunnel types** are configuration values (tunnel.N.type), not service registrations Adresy URL a odkazy na dokumentaci Pravidla přístupnosti adres URL Primární odkazy by měly používat adresy URL dostupné z clearnetu I2P-interní adresy URL (domény .i2p) musí obsahovat poznámky k dostupnosti Vždy poskytujte alternativy při odkazování na interní zdroje v I2P Šablona pro interní adresy URL v I2P:\n\u0026gt; **Note:** The I2P network hosts comprehensive documentation at http://idk.i2p/javadoc-i2p/ \u0026gt; which requires an I2P router for access. For clearnet access, use the GitHub Pages \u0026gt; mirror at https://eyedeekay.github.io/javadoc-i2p/ Doporučené referenční URL pro I2P Oficiální specifikace: - Konfigurace - Zásuvný modul - Index dokumentace Dokumentace k API (vyberte nejaktuálnější): - Nejaktuálnější: https://i2p.github.io/i2p.i2p/ (API 0.9.66 k verzi I2P 2.10.0) - Zrcadlo na clearnetu: https://eyedeekay.github.io/javadoc-i2p/ Zdrojový kód: - GitLab (oficiální): https://i2pgit.org/I2P_Developers/i2p.i2p/src/branch/master - Zrcadlo na GitHubu: https://github.com/i2p/i2p.i2p Standardy formátu odkazů ✅ GOOD: [ClientApp Javadoc](https://i2p.github.io/i2p.i2p/net/i2p/app/ClientApp.html) ✅ GOOD: [Configuration Specification](https://geti2p.net/spec/configuration) ❌ BAD: See the ClientApp docs at http://idk.i2p/... ❌ BAD: [link](url) with no descriptive text Sledování verzí Metadata dokumentu Každý technický dokument by měl obsahovat metadata o verzi v oddílu frontmatter (úvodní hlavička souboru):\n--- title: \u0026#34;Document Title\u0026#34; description: \u0026#34;Brief description\u0026#34; slug: \u0026#34;url-slug\u0026#34; lastUpdated: \u0026#34;2025-10\u0026#34; accurateFor: \u0026#34;2.10.0\u0026#34; reviewStatus: \u0026#34;verified\u0026#34; --- Definice polí: - lastUpdated: Rok-měsíc, kdy byl dokument naposledy revidován/aktualizován - accurateFor: Verze I2P, vůči které byl dokument ověřen - reviewStatus: Jedna z hodnot \u0026ldquo;draft\u0026rdquo;, \u0026ldquo;needs-review\u0026rdquo;, \u0026ldquo;verified\u0026rdquo;, \u0026ldquo;outdated\u0026rdquo;\nOdkazy na verze v obsahu Při uvádění verzí: 1. Pro aktuální verzi použijte tučné písmo: \u0026ldquo;verze 2.10.0 (září 2025)\u0026rdquo; 2. U historických odkazů uveďte jak číslo verze, tak datum 3. Pokud je to relevantní, uvádějte verzi API odděleně od verze I2P\nPříklad:\nManaged clients were introduced in **version 0.9.4** (December 17, 2012) and remain the recommended architecture as of **version 2.10.0** (September 9, 2025). The current API version is **0.9.66**. Dokumentování změn v průběhu času U funkcí, které se vyvíjely:\n**Version history:** - **0.9.4 (December 2012)** - Managed clients introduced - **0.9.42 (2019)** - clients.config.d/ directory structure added - **1.7.0 (2021)** - ShellService added for external program tracking - **2.10.0 (September 2025)** - Current release, no API changes to managed clients Upozornění na zastarání Pokud dokumentujete zastaralé funkce:\n\u0026gt; **Deprecated:** This feature was deprecated in version X.Y.Z and will be removed \u0026gt; in version A.B.C. Use [alternative feature](link) instead. Standardy terminologie Oficiální pojmy I2P Používejte tyto přesné termíny důsledně:\nCorrect Term Avoid I2P router I2P node, I2P client (ambiguous) eepsite I2P website, hidden service (Tor term) tunnel connection, circuit (Tor term) netDb network database, DHT lease set destination info destination address, endpoint base64 destination I2P address, .i2p address ### Terminologie spravovaného klienta Při dokumentování spravovaných klientů:\nUse This Not This managed client managed application unmanaged client legacy client, static client ClientAppManager application manager, client manager lifecycle methods state methods, control methods client registry application registry, name service port mapper port registry, service directory ### Terminologie konfigurace Correct Incorrect clients.config clients.cfg, client.config clients.config.d/ clients.d/, config.d/ router.config router.cfg i2ptunnel.config tunnel.config ### Názvy balíčků a tříd Při prvním výskytu vždy používejte plně kvalifikované názvy, poté krátké názvy:\nThe `net.i2p.app.ClientApp` interface requires implementation of three lifecycle methods. When a ClientApp starts, the manager calls `startup()`... Ukázky kódu a formátování Příklady kódu v jazyce Java Používejte správné zvýrazňování syntaxe a úplné příklady:\n### Example: Registering with Port Mapper \\`\\`\\`java // Register HTTP proxy service context.portMapper().register( PortMapper.SVC_HTTP_PROXY, \u0026#34;127.0.0.1\u0026#34;, 4444 ); // Later, retrieve the port int port = context.portMapper().getPort(PortMapper.SVC_HTTP_PROXY); if (port == -1) { // Service not registered } \\`\\`\\` Požadavky na ukázky kódu: 1. Přidejte komentáře vysvětlující klíčové řádky 2. Ukažte zpracování chyb tam, kde je to vhodné 3. Používejte realistické názvy proměnných 4. Dodržujte I2P konvence kódování (odsazení čtyřmi mezerami) 5. Uveďte importy, pokud nejsou z kontextu zřejmé\nPříklady konfigurace Zobrazte kompletní, platné příklady konfigurace:\n### Example: clients.config.d/ Entry File: `clients.config.d/00-console.config` \\`\\`\\`properties # Router console configuration clientApp.0.main=net.i2p.router.web.RouterConsoleRunner clientApp.0.name=Router Console clientApp.0.args=7657 ::1,127.0.0.1 ./webapps/ clientApp.0.delay=0 clientApp.0.onBoot=true \\`\\`\\` Příklady příkazového řádku Používejte $ pro uživatelské příkazy, # pro root:\n\\`\\`\\`bash # Install I2P on Debian/Ubuntu $ sudo apt-get install i2p # Start the router $ i2prouter start \\`\\`\\` Vložený kód Používejte zpětné apostrofy pro: - Názvy metod: startup() - Názvy tříd: ClientApp - Názvy vlastností: clientApp.0.main - Názvy souborů: clients.config - Konstanty: SVC_HTTP_PROXY - Názvy balíčků: net.i2p.app\nTón a hlas Profesionální, ale přístupný Pište pro technické publikum bez blahosklonného tónu:\n❌ BAD: \u0026#34;Obviously, you should implement the startup() method.\u0026#34; ✅ GOOD: \u0026#34;Managed clients must implement the startup() method to initialize resources.\u0026#34; ❌ BAD: \u0026#34;Even a junior dev knows you need to call notify().\u0026#34; ✅ GOOD: \u0026#34;The manager requires at least one notify() call during startup to track state transitions.\u0026#34; Činný rod Používejte činný rod pro větší srozumitelnost:\n❌ PASSIVE: \u0026#34;The ClientAppManager is notified by the client when state changes.\u0026#34; ✅ ACTIVE: \u0026#34;The client notifies ClientAppManager when state changes.\u0026#34; Rozkazovací způsob v pokynech Používejte přímé rozkazy v procedurálním obsahu:\n✅ \u0026#34;Implement these three lifecycle methods:\u0026#34; ✅ \u0026#34;Call manager.notify() after changing state.\u0026#34; ✅ \u0026#34;Register services using context.portMapper().register()\u0026#34; Vyhněte se zbytečnému žargonu Vysvětlete pojmy při prvním výskytu:\n✅ GOOD: \u0026#34;The netDb (network database) stores information about I2P routers and destinations.\u0026#34; ❌ BAD: \u0026#34;Query the netDb for peer info.\u0026#34; (no explanation) Pokyny k interpunkci Žádné em pomlčky - místo nich používejte běžné pomlčky, čárky nebo středníky Používejte oxfordskou čárku v seznamech: \u0026ldquo;console, i2ptunnel, and Jetty\u0026rdquo; Tečky uvnitř bloků kódu pouze pokud jsou gramaticky nezbytné Složené výčty používají středníky, pokud položky obsahují čárky Struktura dokumentu Standardní pořadí sekcí Pro dokumentaci API:\nPřehled - co funkce dělá, proč existuje Implementace - jak ji implementovat/použít Konfigurace - jak ji nakonfigurovat Reference API - podrobné popisy metod a vlastností Příklady - kompletní funkční příklady Osvědčené postupy - tipy a doporučení Historie verzí - kdy byla zavedena, změny v průběhu času Odkazy - odkazy na související dokumentaci Hierarchie nadpisů Používejte sémantické úrovně nadpisů:\n# Document Title (h1 - only one per document) ## Major Section (h2) ### Subsection (h3) #### Detail Section (h4) **Bold text for emphasis within sections** Informační boxy Používejte blokové citace pro zvláštní upozornění:\n\u0026gt; **Note:** Additional information that clarifies the main content. \u0026gt; **Warning:** Important information about potential issues or breaking changes. \u0026gt; **Deprecated:** This feature is deprecated and will be removed in version X.Y.Z. \u0026gt; **Status:** Current implementation status or version information. Seznamy a organizace Neuspořádané seznamy pro položky bez pořadí:\n- First item - Second item - Third item Číslované seznamy pro postupné kroky:\n1. First step 2. Second step 3. Third step Seznamy definic pro vysvětlení pojmů:\n**Term One** : Explanation of term one **Term Two** : Explanation of term two Časté chyby, kterým je třeba se vyhnout 1. Snadno zaměnitelné podobné systémy Nezaměňujte: - registr ClientAppManager vs. PortMapper - typy i2ptunnel tunnel vs. konstanty služby port mapperu - ClientApp vs. RouterApp (různé kontexty) - Spravovaní vs. nespravovaní klienti\nVždy upřesněte, o jakém systému mluvíte:\n✅ \u0026#34;Register with ClientAppManager using manager.register(this) for name-based lookup.\u0026#34; ✅ \u0026#34;Register with PortMapper using context.portMapper().register() for port discovery.\u0026#34; 2. Zastaralé odkazy na verze Nedělejte: - Označovat staré verze jako „aktuální“ - Odkazovat na zastaralou dokumentaci API - Používat zastaralé signatury metod v příkladech\nDělejte: - Před zveřejněním zkontrolujte poznámky k vydání - Ověřte, že dokumentace API odpovídá aktuální verzi - Aktualizujte příklady tak, aby používaly aktuální osvědčené postupy\n3. Nedostupné adresy URL Nedělejte: - Neodkazujte pouze na domény .i2p bez alternativ na clearnetu (veřejném internetu) - Nepoužívejte nefunkční nebo zastaralé adresy URL dokumentace - Neodkazujte na místní cesty file://\nDoporučeno: - Poskytněte clearnetové alternativy pro všechny interní odkazy I2P - Ověřte, že jsou adresy URL dostupné před zveřejněním - Používejte trvalé adresy URL (geti2p.net, nikoli dočasný hosting)\n4. Neúplné příklady kódu Nedělejte: - Uvádět fragmenty bez kontextu - Vynechávat zpracování chyb - Používat nedefinované proměnné - Přeskakovat importní příkazy, když nejsou zřejmé\nDělejte: - Uveďte úplné, kompilovatelné příklady - Zahrňte potřebné ošetření chyb - Vysvětlete, co dělá každý důležitý řádek - Otestujte příklady před zveřejněním\n5. Dvojznačná tvrzení ❌ \u0026#34;Some applications register services.\u0026#34; ✅ \u0026#34;Applications implementing ClientApp may register with ClientAppManager using manager.register(this) to enable name-based lookup.\u0026#34; ❌ \u0026#34;Configuration files go in the config directory.\u0026#34; ✅ \u0026#34;Modern I2P installations store client configurations in $I2P/clients.config.d/ as individual files.\u0026#34; Konvence Markdownu Pojmenování souborů Použijte kebab-case (styl pojmenování slov oddělených pomlčkami) pro názvy souborů: - managed-clients.md - port-mapper-guide.md - configuration-reference.md\nFormát Frontmatter (úvodní metadata) Vždy zahrňte YAML frontmatter (YAMLové záhlaví s metadaty):\n--- title: \u0026#34;Document Title\u0026#34; description: \u0026#34;Brief description under 160 characters\u0026#34; slug: \u0026#34;url-slug\u0026#34; lastUpdated: \u0026#34;2025-10\u0026#34; accurateFor: \u0026#34;2.10.0\u0026#34; reviewStatus: \u0026#34;verified\u0026#34; --- Formátování odkazů Interní odkazy (v rámci dokumentace):\nSee [clients.config specification](https://geti2p.net/spec/configuration#clients-config) Externí odkazy (na další zdroje):\nFor more details, see [ClientApp Javadoc](https://i2p.github.io/i2p.i2p/net/i2p/app/ClientApp.html) Odkazy na repozitáře kódu:\nView source: [ClientApp.java](https://i2pgit.org/I2P_Developers/i2p.i2p/src/branch/master/core/java/src/net/i2p/app/ClientApp.java) Formátování tabulek Použijte tabulky ve formátu GitHub Flavored Markdown (GFM):\n| Property | Type | Default | Description | |----------|------|---------|-------------| | `main` | String | (required) | Full class name | | `delay` | Integer | 120 | Seconds before start | | `onBoot` | Boolean | false | Force immediate start | Jazykové značky pro bloky kódu Vždy uveďte jazyk pro zvýrazňování syntaxe:\n\\`\\`\\`java // Java code \\`\\`\\` \\`\\`\\`bash # Shell commands \\`\\`\\` \\`\\`\\`properties # Configuration files \\`\\`\\` \\`\\`\\`xml \u0026lt;!-- XML files --\u0026gt; \\`\\`\\` Kontrolní seznam pro revizi Před zveřejněním dokumentace ověřte:\nVšechna technická tvrzení ověřena proti zdrojovému kódu nebo oficiální dokumentaci Čísla verzí a data jsou aktuální Všechny URL jsou dostupné z clearnetu (veřejný internet) (nebo jsou uvedeny alternativy) Ukázky kódu jsou úplné a otestované Terminologie odpovídá konvencím I2P Žádné em‑pomlčky (použijte běžné pomlčky nebo jinou interpunkci) Frontmatter (úvodní metadata) je úplný a přesný Hierarchie nadpisů je sémantická (h1 → h2 → h3) Seznamy a tabulky jsou správně naformátované Sekce Reference obsahuje všechny citované zdroje Dokument se řídí pokyny ke struktuře Tón je profesionální, ale srozumitelný Podobné koncepty jsou jasně odlišeny Žádné nefunkční odkazy ani reference Konfigurační příklady jsou platné a aktuální Zpětná vazba: Pokud narazíte na problémy nebo máte návrhy k těmto pokynům, odešlete je prosím prostřednictvím oficiálních vývojových kanálů I2P.\n","description":"Udržujte jednotnost, přesnost a přístupnost napříč technickou dokumentací I2P","id":"797e1cb5256ec022a3d99eefd7eda1f4","section":"docs","title":"Pokyny pro psaní dokumentace I2P","url":"/cs/docs/writing-guidelines/"},{"categories":null,"content":"Nejprve si přečtěte Průvodce pro nové vývojáře .\nZákladní pokyny a styl kódování Většina z následujícího by měla být samozřejmostí pro každého, kdo pracoval na open source projektu nebo v komerčním programátorském prostředí. Následující se týká především hlavní vývojové větve i2p.i2p. Směrnice pro ostatní větve, pluginy a externí aplikace se mohou podstatně lišit; obraťte se na příslušného vývojáře pro bližší informace.\nKomunita Prosím, nepište jen kód. Pokud můžete, zapojte se i do dalších vývojových aktivit, včetně: vývojových diskusí a podpory na IRC a i2pforum.i2p; testování; hlášení chyb a odpovědí; dokumentace; revizí kódu; atd. Aktivní vývojáři by měli být pravidelně dostupní na IRC #i2p-dev. Buďte si vědomi aktuálního vývojového cyklu. Dodržujte milníky vydání, jako jsou zmrazení funkcí, zmrazení tagů a termín pro odevzdání kódu pro vydání. Cyklus vydání Běžný cyklus vydání trvá 10–16 týdnů, čtyři vydání ročně. Následují přibližné termíny v rámci typického 13týdenního cyklu. Konkrétní termíny pro každé vydání stanovuje správce vydání po konzultaci s celým týmem.\n1–2 dny po předchozím vydání: Začlenění do hlavní větve jsou povolena. 2–3 týdny po předchozím vydání: Termín pro přenos zásadních změn z jiných větví do hlavní větve. 4–5 týdnů před vydáním: Termín pro požadavky na nové odkazy na domovské stránce. 3–4 týdny před vydáním: Zmrazení funkcí. Termín pro zásadní nové funkce. 2–3 týdny před vydáním: Svolání projektové schůzky k přezkoumání požadavků na nové odkazy na domovské stránce, pokud existují. 10–14 dní před vydáním: Zmrazení řetězců. Žádné další změny přeložených (označených) řetězců. Odeslání řetězců do Transifexu, oznámení termínu překladu na Transifexu. 10–14 dní před vydáním: Termín pro funkce. Po tomto okamžiku pouze opravy chyb. Žádné další funkce, refaktoring ani úpravy. 3–4 dny před vydáním: Termín pro překlady. Stažení překladů z Transifexu a začlenění. 3–4 dny před vydáním: Termín pro začlenění. Po tomto okamžiku žádná začlenění bez povolení tvůrce vydání. Hodiny před vydáním: Termín pro kontrolu kódu. Git Mějte základní povědomí o distribuovaných systémech správy verzí, i když jste git dosud nepoužívali. Požádejte o pomoc, pokud ji potřebujete. Jakmile je změna odeslána, check-iny jsou navždy; neexistuje vrácení zpět. Buďte prosím opatrní. Pokud jste git dosud nepoužívali, začněte malými krůčky. Commitněte nějaké malé změny a uvidíte, jak to funguje. Otestujte své změny před jejich commitnutím. Pokud preferujete vývojový model commit‑před‑testováním, použijte vlastní vývojovou větev ve svém vlastním účtu a vytvořte MR, jakmile je práce hotová. Nerozbijte build. Nezpůsobujte regrese. V případě, že se to stane (stává se to), prosím nezmizíte na dlouhou dobu poté, co odešlete svou změnu. Pokud je vaše změna netriviální, nebo chcete, aby ji lidé otestovali, a potřebujete kvalitní testovací reporty, abyste věděli, zda byla vaše změna otestována či nikoli, přidejte komentář k commitu do history.txt a zvyšte revizi buildu v RouterVersion.java. Necommitujte zásadní změny do hlavní větve i2p.i2p pozdě v cyklu vydání. Pokud vám projekt zabere více než pár dní, vytvořte si vlastní větev v gitu ve svém vlastním účtu a proveďte vývoj tam, abyste neblokovali vydání. U velkých změn (obecně řečeno více než 100 řádků nebo dotýkajících se více než tří souborů) je commitněte do nové větve ve svém vlastním účtu na GitLabu, vytvořte MR a přiřaďte reviewera. Přiřaďte MR sobě. Mergněte MR sami, jakmile jej reviewer schválí. Nevytvářejte WIP větve v hlavním účtu I2P_Developers (kromě i2p.www). WIP patří do vašeho vlastního účtu. Když je práce hotová, vytvořte MR. Jediné větve v hlavním účtu by měly být pro skutečné forky, jako je bodové vydání. Vyvíjejte transparentním způsobem a s ohledem na komunitu. Commitujte často. Commitujte nebo mergujte do hlavní větve tak často, jak je to možné, při dodržení výše uvedených pokynů. Pokud pracujete na nějakém velkém projektu ve své vlastní větvi/účtu, informujte ostatní, aby mohli sledovat a provádět review/testování/komentáře. Styl kódování Styl kódování ve většině kódu je 4 mezery pro odsazení. Nepoužívejte tabulátory. Nepřeformátovujte kód. Pokud vaše IDE nebo editor chce vše přeformátovat, získejte nad ním kontrolu. Na některých místech je styl kódování odlišný. Používejte zdravý rozum. Napodobujte styl v souboru, který upravujete. Všechny nové veřejné a package-private třídy a metody vyžadují Javadocs. Přidejte @since číslo-vydání. Javadocs pro nové privátní metody jsou žádoucí. Pro jakékoliv přidané Javadocs nesmí existovat žádné chyby ani varování doclint. Spusťte ant javadoc s Oracle Java 14 nebo vyšší pro kontrolu. Všechny parametry musí mít řádky @param, všechny non-void metody musí mít řádky @return, všechny deklarované vyhazované výjimky musí mít řádky @throws a žádné HTML chyby. Třídy v core/ (i2p.jar) a části i2ptunnel jsou součástí našeho oficiálního API. Existuje několik out-of-tree pluginů a dalších aplikací, které se na toto API spoléhají. Buďte opatrní, abyste neprovedli žádné změny, které by narušily kompatibilitu. Nepřidávejte metody do API, pokud nejsou obecně užitečné. Javadocs pro API metody by měly být jasné a úplné. Pokud přidáte nebo změníte API, aktualizujte také dokumentaci na webových stránkách (větev i2p.www). Označte řetězce pro překlad tam, kde je to vhodné, což platí pro všechny UI řetězce. Neměňte existující označené řetězce, pokud to není opravdu nutné, protože to naruší existující překlady. Nepřidávejte ani neměňte označené řetězce po zmrazení tagů ve vydávacím cyklu, aby měli překladatelé šanci aktualizovat před vydáním. Používejte generika a souběžné třídy, kde je to možné. I2P je vysoce multi-threadová aplikace. Buďte obeznámeni s běžnými úskalími Javy, které odhaluje FindBugs/SpotBugs. Spusťte ant findbugs pro více informací. Java 8 je vyžadována pro sestavení a spuštění I2P od vydání 0.9.47. Nepoužívejte třídy nebo metody Java 7 nebo 8 v embedded subsystémech: addressbook, core, i2ptunnel.jar (non‑UI), mstreaming, router, routerconsole (pouze news), streaming. Tyto subsystémy jsou používány Androidem a embedded aplikacemi, které vyžadují pouze Java 6. Všechny třídy musí být dostupné v Android API 14. Jazykové funkce Java 7 jsou v těchto subsystémech přijatelné, pokud jsou podporovány aktuální verzí Android SDK a kompilují se do kódu kompatibilního s Java 6. Try‑with‑resources nelze použít v embedded subsystémech, protože vyžaduje java.lang.AutoCloseable v runtime a to není dostupné až do Android API 19 (KitKat 4.4). Balíček java.nio.file nelze použít v embedded subsystémech, protože není dostupný až do Android API 26 (Oreo 8). Kromě výše uvedených omezení mohou být třídy, metody a konstrukce Java 8 použity pouze v následujících subsystémech: BOB, desktopgui, i2psnark, i2ptunnel.war (UI), jetty‑i2p.jar, jsonrpc, routerconsole (kromě news), SAM, susidns, susimail, systray. Autoři pluginů mohou vyžadovat jakoukoli minimální verzi Javy prostřednictvím souboru plugin.config. Explicitně převádějte mezi primitivními typy a třídami; nespoléhejte se na autoboxing/unboxing. Nepoužívejte URL. Použijte URI. Nechytejte Exception. Chytejte RuntimeException a checked výjimky individuálně. Nepoužívejte String.getBytes() bez argumentu UTF‑8 charset. Můžete také použít DataHelper.getUTF8() nebo DataHelper.getASCII(). Vždy specifikujte UTF‑8 charset při čtení nebo zápisu souborů. Utility DataHelper mohou být užitečné. Vždy specifikujte locale (například Locale.US) při použití String.toLowerCase() nebo String.toUpperCase(). Nepoužívejte String.equalsIgnoreCase(), protože locale nelze specifikovat. Nepoužívejte String.split(). Použijte DataHelper.split(). Nepřidávejte kód pro formátování dat a časů. Použijte DataHelper.formatDate() a DataHelper.formatTime(). Zajistěte, aby InputStreamy a OutputStreamy byly uzavřeny v finally blocích. Používejte {} pro všechny for a while bloky, i když mají jen jeden řádek. Pokud používáte {} pro buď if, else, nebo if-else blok, použijte je pro všechny bloky. Umístěte } else { na jeden řádek. Specifikujte pole jako final všude, kde je to možné. Neukládejte I2PAppContext, RouterContext, Log nebo jakékoli jiné reference na router nebo context položky do statických polí. Nespouštějte vlákna v konstruktorech. Použijte I2PAppThread místo Thread. Logování Následující pravidla platí pro router, webové aplikace a všechny pluginy.\nPro všechny zprávy nezobrazené na výchozí úrovni logování (WARN, INFO a DEBUG), pokud zpráva není statický řetězec (bez zřetězení), vždy použijte log.shouldWarn(), log.shouldInfo() nebo log.shouldDebug() před voláním logu, abyste předešli zbytečnému vytváření objektů. Logovací zprávy, které mohou být zobrazeny na výchozí úrovni logování (ERROR, CRIT a logAlways()), by měly být stručné, jasné a srozumitelné i pro netechnického uživatele. To zahrnuje text důvodu výjimky, který může být také zobrazen. Zvažte překlad, pokud se chyba pravděpodobně stane (například při chybách odesílání formuláře). V opačném případě není překlad nutný, ale může být užitečné vyhledat a znovu použít řetězec, který je již jinde označen k překladu. Logovací zprávy nezobrazené na výchozí úrovni logování (WARN, INFO a DEBUG) jsou určeny pro použití vývojáři a nemají výše uvedené požadavky. Nicméně zprávy WARN jsou dostupné v záložce Android log a mohou pomoci uživatelům při ladění problémů, proto používejte zprávy WARN také s určitou opatrností. Logovací zprávy INFO a DEBUG by měly být používány střídmě, zejména v často prováděných částech kódu. I když jsou užitečné během vývoje, zvažte jejich odstranění nebo zakomentování po dokončení testování. Nelogujte do stdout nebo stderr (wrapper log). Licence Commitujte pouze kód, který jste napsali sami. Před commitnutím jakéhokoli kódu nebo knihoven JARů z jiných zdrojů zdůvodněte, proč je to nezbytné, ověřte kompatibilitu licence a získejte souhlas od správce vydání. Pokud získáte souhlas k přidání externího kódu nebo JARů a binární soubory jsou dostupné v jakémkoli balíčku Debianu nebo Ubuntu, musíte implementovat možnosti sestavení a balíčkování pro použití externího balíčku. Kontrolní seznam souborů k úpravě: build.properties, build.xml, debian/control, debian/i2p-router.install, debian/i2p-router.links, debian/rules, sub-build.xml. U jakýchkoli obrázků commitnutých z externích zdrojů je vaší odpovědností nejprve ověřit kompatibilitu licence. Uveďte informace o licenci a zdroji v komentáři k commitu. Chyby Správa problémů je úkolem každého; prosím pomozte. Sledujte GitLab pro problémy, se kterými můžete pomoci. Komentujte, opravujte a zavírejte problémy, pokud můžete. Noví vývojáři by měli začít opravováním problémů. Když máte opravu, připojte svůj patch k problému a přidejte klíčové slovo review-needed. Nezavírejte problém, dokud nebyl úspěšně zkontrolován a neověřili jste své změny. Jakmile to provedete hladce pro pár tiketů, můžete následovat běžný postup výše. Zavřete problém, když si myslíte, že jste ho opravili. Nemáme testovací oddělení, které by ověřovalo a zavíralo tikety. Pokud si nejste jisti, že jste ho opravili, zavřete ho a přidejte poznámku \u0026ldquo;Myslím, že jsem to opravil, prosím otestujte a znovu otevřete, pokud je to stále nefunkční\u0026rdquo;. Přidejte komentář s číslem dev buildu nebo revizí a nastavte milník na další vydání. ","description":"Kompletní návod pro přispívání do I2P: pracovní postup, cyklus vydání, styl kódování, logování, licencování a řešení problémů","id":"6c8fe691caf216ba9024152afc39c5c6","section":"docs","title":"Pokyny pro vývojáře a styl kódování","url":"/cs/docs/develop/dev-guidelines/"},{"categories":null,"content":" Hlavní vývojová větev I2P (i2p.i2p) byla nastavena tak, aby umožnila vývojářům snadno nastavit dvě běžně používané IDE pro vývoj v Javě: Eclipse a NetBeans. Eclipse Hlavní vývojové větve I2P (i2p.i2p a větve z ní odvozené) obsahují build.gradle, aby mohla být větev snadno nastavena v Eclipse. Ujistěte se, že máte aktuální verzi Eclipse. Jakákoliv novější než 2017 by měla stačit. Stáhněte větev I2P do nějakého adresáře (např. $HOME/dev/i2p.i2p). Vyberte \"File → Import...\" a poté pod \"Gradle\" vyberte \"Existing Gradle Project\". Pro \"Project root directory:\" zvolte adresář, do kterého byla stažena větev I2P. V dialogu \"Import Options\" vyberte \"Gradle Wrapper\" a stiskněte Continue. V dialogu \"Import Preview\" můžete zkontrolovat strukturu projektu. Pod \"i2p.i2p\" by se mělo objevit více projektů. Stiskněte \"Finish\". Hotovo! Váš workspace by nyní měl obsahovat všechny projekty v rámci větve I2P a jejich build závislosti by měly být správně nastaveny. NetBeans Hlavní vývojové větve I2P (i2p.i2p a větve z ní vycházející) obsahují projektové soubory NetBeans. ","description":"Nastavení Eclipse a NetBeans pro vývoj I2P s Gradle a přiloženými projektovými soubory","id":"59847e4ae7ce8d8ccadb441422ecc856","section":"docs","title":"Použití IDE s I2P","url":"/cs/docs/guides/ides/"},{"categories":null,"content":"Hostování GitLabu uvnitř I2P je jednoduché: spusťte GitLab omnibus kontejner, zpřístupněte ho na loopback a přesměrujte provoz přes I2P tunnel. Níže uvedené kroky odpovídají konfiguraci použité pro git.idk.i2p, ale fungují pro jakoukoli self-hosted instanci.\n1. Předpoklady Debian nebo jiná Linuxová distribuce s nainstalovaným Docker Engine (sudo apt install docker.io nebo docker-ce z repozitáře Docker). I2P router (Java I2P nebo i2pd) s dostatečnou šířkou pásma pro obsluhu vašich uživatelů. Volitelné: dedikovaný VM, aby GitLab a router zůstaly izolované od vašeho desktopového prostředí. 2. Stáhněte GitLab Image docker pull gitlab/gitlab-ce:latest Oficiální obraz je vytvořen z Ubuntu základních vrstev a pravidelně aktualizován. Pokud potřebujete další ujištění, prostudujte si Dockerfile .\n3. Rozhodněte se mezi Bridgingem a čistě I2P Pouze I2P instance nikdy nekontaktují hosty na clearnetu. Uživatelé mohou zrcadlit repozitáře z jiných I2P služeb, ale ne z GitHub/GitLab.com. To maximalizuje anonymitu. Propojené instance se připojují k Git hostům na clearnetu přes HTTP proxy. To je užitečné pro zrcadlení veřejných projektů do I2P, ale deanonymizuje odchozí požadavky serveru. Pokud zvolíte bridged režim, nakonfigurujte GitLab tak, aby používal I2P HTTP proxy svázané na Docker hostiteli (například http://172.17.0.1:4446). Výchozí router proxy naslouchá pouze na 127.0.0.1; přidejte nový proxy tunnel svázaný s Docker gateway adresou.\n4. Spuštění kontejneru docker run --detach \\ --env HTTP_PROXY=http://172.17.0.1:4446 \\ # omit for I2P-only --publish 127.0.0.1:8443:443 \\ --publish 127.0.0.1:8080:80 \\ --publish 127.0.0.1:8022:22 \\ --name gitlab \\ --restart always \\ --volume /srv/gitlab/config:/etc/gitlab:Z \\ --volume /srv/gitlab/logs:/var/log/gitlab:Z \\ --volume /srv/gitlab/data:/var/opt/gitlab:Z \\ gitlab/gitlab-ce:latest Svažte publikované porty na loopback; tunely I2P je zpřístupní podle potřeby. Nahraďte /srv/gitlab/... cestami k úložišti, které vyhovují vašemu hostiteli. Jakmile je kontejner spuštěn, navštivte https://127.0.0.1:8443/, nastavte administrátorské heslo a nakonfigurujte omezení účtů.\n5. Zpřístupnění GitLabu přes I2P Vytvořte tři I2PTunnel server tunely:\nPurpose Local target Suggested inbound port HTTPS web UI 127.0.0.1:8443 auto-generated HTTP web UI (optional) 127.0.0.1:8080 auto-generated SSH push/pull 127.0.0.1:8022 auto-generated Nakonfigurujte každý tunnel s odpovídající délkou a šířkou pásma. Pro veřejné instance je dobrým výchozím bodem 3 hopy se 4–6 tunnely na směr. Zveřejněte výsledné Base32/Base64 destinace na své úvodní stránce, aby si uživatelé mohli nakonfigurovat klientské tunnely. Destination Enforcement Pokud používáte HTTP(S) tunely, aktivujte vynucení cílové destinace, aby k službě měl přístup pouze zamýšlený hostname. To zabrání zneužití tunelu jako generické proxy.\n6. Maintenance Tips Spusťte docker exec gitlab gitlab-ctl reconfigure vždy, když změníte nastavení GitLabu. Sledujte využití disku (/srv/gitlab/data) – Git repozitáře rychle rostou. Pravidelně zálohujte konfigurační a datové adresáře. GitLabové backup rake tasks fungují uvnitř kontejneru. Zvažte umístění externího monitorovacího tunelu v klientském režimu, abyste zajistili dostupnost služby ze širší sítě. 6. Tipy pro údržbu Embedding I2P ve vaší aplikaci Git přes I2P (průvodce pro klienty) Git bundle soubory pro offline/pomalé sítě Dobře nakonfigurovaná instance GitLabu poskytuje centrum pro společný vývoj zcela uvnitř I2P. Udržujte router v dobrém stavu, průběžně aktualizujte bezpečnostní záplaty GitLabu a koordinujte se s komunitou, jak vaše uživatelská základna roste.\n","description":"Nasazení GitLabu uvnitř I2P pomocí Dockeru a I2P routeru","id":"0c6aba5984de265324df6360a00204c9","section":"docs","title":"Provoz GitLabu přes I2P","url":"/cs/docs/guides/gitlab/"},{"categories":null,"content":"Tento průvodce poskytuje přehled konzoly I2P routeru a jeho konfiguračních stránek. Každá sekce vysvětluje, co daná stránka dělá a k čemu je určena, což vám pomůže pochopit, jak monitorovat a konfigurovat váš I2P router.\nPřístup ke konzoli routeru I2P Router Console je centrální rozbočovač pro správu a monitorování vašeho I2P routeru. Ve výchozím nastavení je přístupná na I2P Router Console , jakmile je váš I2P router spuštěný.\nDomovská stránka zobrazuje několik klíčových sekcí:\nAplikace - Rychlý přístup k vestavěným I2P aplikacím jako Email, Torrenty, Správce skrytých služeb a Webový server Komunitní stránky I2P - Odkazy na důležité komunitní zdroje včetně fór, dokumentace a webových stránek projektu Konfigurace a nápověda - Nástroje pro konfiguraci nastavení šířky pásma, správu pluginů a přístup ke zdrojům nápovědy Síťové informace a informace pro vývojáře - Přístup ke grafům, záznamům, technické dokumentaci a statistikám sítě Adresář URL: Address Book Adresář I2P funguje podobně jako DNS na clearnetu a umožňuje vám spravovat lidsky čitelná jména pro I2P destinace (eepsites). Zde můžete prohlížet a přidávat I2P adresy do svého osobního adresáře.\nSystém adresáře funguje prostřednictvím několika vrstev:\nMístní záznamy - Vaše osobní adresáře, které jsou uloženy pouze na vašem routeru\nMístní adresář - Hostitele, které ručně přidáváte nebo ukládáte pro vlastní použití Soukromý adresář - Adresy, které nechcete sdílet s ostatními; nikdy nejsou veřejně distribuovány Předplatné - Vzdálené zdroje adresáře (jako http://i2p-projekt.i2p/hosts.txt), které automaticky aktualizují adresář vašeho routeru o známé I2P stránky\nAdresář routeru - Sloučený výsledek vašich lokálních záznamů a odběrů, prohledávatelný všemi I2P aplikacemi na vašem routeru\nPublikovaný adresář - Volitelné veřejné sdílení vašeho adresáře, který mohou ostatní používat jako zdroj předplatného (užitečné, pokud provozujete I2P stránku)\nAdresář pravidelně kontroluje vaše odběry a slučuje obsah do adresáře vašeho routeru, čímž udržuje váš soubor hosts.txt aktuální se sítí I2P.\nKonfigurace URL: Pokročilá konfigurace Sekce Konfigurace poskytuje přístup ke všem nastavením routeru prostřednictvím několika specializovaných záložek.\nAdvanced Stránka Pokročilá konfigurace poskytuje přístup k nízkoúrovňovým nastavením routeru, která obvykle nejsou potřebná pro běžný provoz. Většina uživatelů by neměla tato nastavení měnit, pokud nerozumí konkrétní možnosti konfigurace a jejímu dopadu na chování routeru.\nKlíčové vlastnosti:\nKonfigurace Floodfill - Určuje, zda se váš router účastní jako floodfill peer, který pomáhá síti tím, že ukládá a distribuuje informace ze síťové databáze (netDb). Může to využívat více systémových prostředků, ale posiluje to síť I2P.\nPokročilá konfigurace I2P - Přímý přístup k souboru router.config, zobrazující všechny pokročilé konfigurační parametry včetně:\nLimitů šířky pásma a nastavení shluků Nastavení transportu (NTCP2, SSU2, UDP porty a klíče) Identifikace routeru a informace o verzi Předvoleb konzole a nastavení aktualizací Většina pokročilých konfiguračních možností není zobrazena v uživatelském rozhraní, protože jsou jen zřídka potřeba. Pro povolení úprav těchto nastavení musíte ručně přidat routerconsole.advanced=true do souboru router.config.\nUpozornění: Nesprávná úprava pokročilých nastavení může negativně ovlivnit výkon vašeho routeru nebo jeho konektivitu. Měňte tato nastavení pouze tehdy, pokud víte, co děláte.\nBandwidth URL: Konfigurace šířky pásma Stránka konfigurace šířky pásma umožňuje řídit, kolik šířky pásma váš router přispívá do sítě I2P. I2P funguje nejlépe, když nakonfigurujete své rychlosti tak, aby odpovídaly rychlosti vašeho internetového připojení.\nKlíčová nastavení:\nKBps In - Maximální šířka příchozího pásma, kterou váš router přijme (rychlost stahování) KBps Out - Maximální šířka odchozího pásma, kterou váš router využije (rychlost odesílání) Share - Procento vaší odchozí šířky pásma věnované participující komunikaci (pomoc při směrování komunikace pro ostatní) Důležité poznámky:\nVšechny hodnoty jsou v bajtech za sekundu (KBps), nikoliv v bitech za sekundu Čím více šířky pásma zpřístupníte, tím více pomáháte síti a zlepšujete vlastní anonymitu Vaše množství sdílení pro odesílání (KBps Out) určuje váš celkový příspěvek k síti Pokud si nejste jisti rychlostí vaší sítě, použijte Bandwidth Test k jejímu změření Vyšší sdílená šířka pásma zlepšuje jak vaši anonymitu, tak pomáhá posílit síť I2P Stránka konfigurace zobrazuje odhadovaný měsíční přenos dat na základě vašeho nastavení, což vám pomůže naplánovat alokaci šířky pásma podle limitů vašeho internetového tarifu.\nClient Configuration URL: Konfigurace klienta Stránka Konfigurace klienta umožňuje ovládat, které aplikace a služby I2P se spustí při startu. Zde můžete povolit nebo zakázat vestavěné klienty I2P bez jejich odinstalace.\nDůležité upozornění: Při změně nastavení zde buďte opatrní. Konzole routeru a aplikační tunely jsou vyžadovány pro většinu použití I2P. Pouze pokročilí uživatelé by měli měnit tato nastavení.\nDostupní klienti:\nAplikační tunely - Systém I2PTunnel, který spravuje klientské a serverové tunely (HTTP proxy, IRC atd.) Konzole I2P routeru - Webové administrační rozhraní, které právě používáte I2P webserver (eepsite) - Vestavěný Jetty webserver pro hostování vlastní I2P webové stránky Otevřít konzoli routeru ve webovém prohlížeči při spuštění - Automaticky spustí váš prohlížeč na domovské stránce konzole SAM application bridge - API most pro připojení aplikací třetích stran k I2P Každý klient zobrazuje: - Spustit při startu? - Zaškrtávací políčko pro povolení/zakázání automatického spuštění - Ovládání - Tlačítka Start/Stop pro okamžité ovládání - Třída a argumenty - Technické detaily o tom, jak je klient spouštěn\nZměny nastavení „Spustit při startu?\u0026quot; vyžadují restart routeru, aby se projevily. Všechny úpravy jsou uloženy do /var/lib/i2p/i2p-config/clients.config.d/.\nPokročilé URL: Konfigurace I2CP Stránka konfigurace I2CP (I2P Client Protocol) umožňuje nastavit, jak se externí aplikace připojují k vašemu I2P routeru. I2CP je protokol, který aplikace používají ke komunikaci s routerem za účelem vytváření tunelů a odesílání/přijímání dat přes I2P.\nDůležité: Výchozí nastavení bude fungovat pro většinu uživatelů. Jakékoliv změny provedené zde musí být také nakonfigurovány v externí klientské aplikaci. Mnoho klientů nepodporuje SSL ani autorizaci. Všechny změny vyžadují restart, aby se projevily.\nMožnosti konfigurace:\nKonfigurace externího I2CP rozhraní\nPovoleno bez SSL - Standardní I2CP přístup (výchozí a nejkompatibilnější) Povoleno s vyžadovaným SSL - Pouze šifrovaná I2CP připojení Zakázáno - Blokuje připojení externích klientů přes I2CP I2CP rozhraní - Síťové rozhraní, na kterém se má naslouchat (výchozí: 127.0.0.1 pouze pro localhost)\nI2CP port - Číslo portu pro I2CP připojení (výchozí: 7654)\nAutorizace\nVyžadovat uživatelské jméno a heslo - Povolit autentizaci pro I2CP připojení Uživatelské jméno - Nastavit požadované uživatelské jméno pro přístup k I2CP Heslo - Nastavit požadované heslo pro přístup k I2CP Bezpečnostní upozornění: Pokud provozujete aplikace pouze na stejném počítači jako váš I2P router, ponechte rozhraní nastavené na 127.0.0.1, abyste zabránili vzdálenému přístupu. Tato nastavení měňte pouze v případě, že potřebujete umožnit I2P aplikacím z jiných zařízení připojení k vašemu routeru.\nŠířka pásma URL: Konfigurace sítě Stránka Konfigurace sítě umožňuje nastavit, jak se váš I2P router připojuje k internetu, včetně detekce IP adresy, preferencí IPv4/IPv6 a nastavení portů pro UDP i TCP transporty.\nExterně Dostupná IP Adresa:\nPoužít všechny metody automatické detekce - Automaticky detekuje vaši veřejnou IP pomocí více metod (doporučeno) Zakázat detekci IP adresy pomocí UPnP - Zabrání použití UPnP k zjištění vaší IP Ignorovat IP adresu lokálního rozhraní - Nepoužívat IP adresu vaší lokální sítě Použít pouze detekci IP adresy SSU - Používat pouze transport SSU2 pro detekci IP Skrytý režim - nepublikovat IP - Zabrání účasti na síťovém provozu (snižuje anonymitu) Zadat hostname nebo IP - Manuálně nastavit vaši veřejnou IP nebo hostname Konfigurace IPv4:\nZakázat příchozí spojení (za firewallem) - Zaškrtněte tuto možnost, pokud jste za firewallem, domácí sítí, ISP, DS-Lite nebo carrier-grade NAT, který blokuje příchozí spojení Konfigurace IPv6:\nUpřednostnit IPv4 před IPv6 - Upřednostňuje IPv4 připojení Upřednostnit IPv6 před IPv4 - Upřednostňuje IPv6 připojení (výchozí pro sítě s dual-stack) Povolit IPv6 - Umožňuje IPv6 připojení Zakázat IPv6 - Zakáže veškerou IPv6 konektivitu Používat pouze IPv6 (zakázat IPv4) - Experimentální režim pouze s IPv6 Zakázat příchozí spojení (Firewalled) - Zkontrolujte, zda je vaše IPv6 za firewallem Akce při změně IP adresy:\nRežim notebooku - Experimentální funkce, která mění identitu routeru a UDP port při změně vaší IP adresy pro zvýšenou anonymitu Konfigurace UDP:\nSpecify Port - Nastavte specifický UDP port pro SSU2 transport (musí být otevřený ve vašem firewallu) Completely disable - Vyberte pouze pokud jste za firewallem, který blokuje veškerý odchozí UDP provoz Konfigurace TCP:\nZadat port - Nastavit konkrétní TCP port pro NTCP2 transport (musí být otevřen ve vašem firewallu) Použít stejný port nakonfigurovaný pro UDP - Zjednodušuje konfiguraci použitím jednoho portu pro oba transporty Použít automaticky detekovanou IP adresu - Automaticky detekuje vaši veřejnou IP (zobrazuje \u0026ldquo;currently unknown\u0026rdquo;, pokud ještě nebyla detekována nebo je za firewallem) Vždy použít automaticky detekovanou IP adresu (Není za firewallem) - Nejlepší pro routery s přímým přístupem k internetu Zakázat příchozí spojení (Za firewallem) - Zaškrtněte, pokud jsou TCP spojení blokována vaším firewallem Zcela zakázat - Vyberte pouze v případě, že jste za firewallem, který omezuje nebo blokuje odchozí TCP Zadat hostname nebo IP - Ručně nakonfigurovat vaši externě dostupnou adresu Důležité: Změny nastavení sítě mohou vyžadovat restart routeru, aby se plně projevily. Správná konfigurace přesměrování portů výrazně zlepšuje výkon vašeho routeru a pomáhá síti I2P.\nKonfigurace klienta URL: Konfigurace peerů Stránka Konfigurace peerů poskytuje ruční ovládací prvky pro správu jednotlivých peerů v síti I2P. Jedná se o pokročilou funkci, která se obvykle používá pouze pro řešení problémů s problematickými peery.\nManuální ovládání peerů:\nRouter Hash - Zadejte 44znakový base64 router hash peera, kterého chcete spravovat Manuální zablokování / odblokování peera:\nZablokování peer mu zabrání účastnit se jakýchkoliv tunnelů, které vytvoříte. Tato akce: - Zabrání použití peer ve vašich klientských nebo exploratorních tunnelech - Nabývá účinnosti okamžitě bez nutnosti restartu - Trvá, dokud peer ručně neodblokujete nebo nerestartujete svůj router - Zablokovat peer do restartu - Dočasně zablokuje peer - Odblokovat peer - Odstraní blokaci dříve zablokovaného peer\nUpravit bonusy profilu:\nBonusy profilů ovlivňují způsob, jakým jsou vybíráni peeři pro účast v tunelech. Bonusy mohou být kladné nebo záporné: - Rychlí peeři - Používáni pro klientské tunely vyžadující vysokou rychlost - Peeři s vysokou kapacitou - Používáni pro některé exploratory tunely vyžadující spolehlivé směrování - Aktuální bonusy jsou zobrazeny na stránce profilů\nKonfigurace: - Rychlost - Upravit bonus rychlosti pro tento peer (0 = neutrální) - Kapacita - Upravit bonus kapacity pro tento peer (0 = neutrální) - Upravit bonusy peera - Použít nastavení bonusů\nPřípady použití: - Zakázat peer, který konzistentně způsobuje problémy s připojením - Dočasně vyloučit peer, u kterého máte podezření, že je škodlivý - Upravit bonusy pro snížení priority podprůměrných peerů - Ladit problémy s budováním tunelů vyloučením konkrétních peerů\nPoznámka: Většina uživatelů tuto funkci nikdy nebude potřebovat. I2P router automaticky spravuje výběr peerů a jejich profilování na základě metrik výkonu.\nKonfigurace I2CP URL: Konfigurace reseed Stránka Konfigurace reseedu vám umožňuje ručně provést reseed vašeho routeru, pokud automatický reseed selže. Reseeding je bootstrapovací proces používaný k nalezení dalších routerů při první instalaci I2P nebo když váš router má příliš málo zbývajících odkazů na routery.\nKdy použít manuální reseed:\nPokud reseed selhal, měli byste nejprve zkontrolovat své síťové připojení\nPokud firewall blokuje vaše připojení k reseed hostitelům, můžete mít přístup k proxy:\nProxy může být vzdálená veřejná proxy, nebo může běžet na vašem počítači (localhost) Pro použití proxy nakonfigurujte typ, hostitele a port v sekci Konfigurace Reseedingu Pokud používáte Tor Browser, proveďte reseed přes něj nakonfigurováním SOCKS 5, localhost, port 9150 Pokud používáte Tor z příkazové řádky, proveďte reseed přes něj nakonfigurováním SOCKS 5, localhost, port 9050 Pokud máte nějaké uzly (peers), ale potřebujete více, můžete zkusit možnost I2P Outproxy. Nechte hostitele a port prázdné. Toto nebude fungovat pro počáteční reseed, když nemáte vůbec žádné uzly Poté klikněte na \u0026ldquo;Uložit změny a provést reseed nyní\u0026rdquo; Výchozí nastavení bude fungovat pro většinu uživatelů. Změňte je pouze pokud HTTPS je blokováno restriktivním firewallem a reseed selhal Pokud znáte a důvěřujete někomu, kdo provozuje I2P, požádejte jej, aby vám poslal soubor reseed vygenerovaný pomocí této stránky v jejich router console. Poté použijte tuto stránku k provedení reseed pomocí souboru, který jste obdrželi. Nejprve vyberte soubor níže. Poté klikněte na \u0026ldquo;Reseed from file\u0026rdquo;\nPokud znáte a důvěřujete někomu, kdo publikuje reseed soubory, požádejte jej o URL. Poté použijte tuto stránku k reseedování pomocí získané URL adresy. Nejprve zadejte URL níže. Pak klikněte na \u0026ldquo;Reseed from URL\u0026rdquo;\nViz FAQ pro návod na manuální reseed\nManuální možnosti reseedu:\nReseed z URL - Zadejte URL adresu zip nebo su3 souboru z důvěryhodného zdroje a klikněte na \u0026ldquo;Reseed from URL\u0026rdquo;\nFormát su3 je preferován, protože bude ověřen jako podepsaný důvěryhodným zdrojem Formát zip není podepsaný; použijte zip soubor pouze ze zdroje, kterému důvěřujete Reseed ze souboru - Procházejte a vyberte lokální zip nebo su3 soubor, poté klikněte na \u0026ldquo;Reseed from file\u0026rdquo;\nReseed soubory můžete najít na checki2p.com/reseed Vytvořit Reseed soubor - Vygeneruje nový reseed zip soubor, který můžete sdílet s ostatními pro ruční reseed\nTento soubor nikdy nebude obsahovat identitu ani IP adresu vašeho vlastního routeru Konfigurace reseedingu:\nVýchozí nastavení budou fungovat pro většinu uživatelů. Změňte je pouze v případě, že HTTPS je blokováno restriktivním firewallem a reseed selhal.\nURL adresy pro reseed - Seznam HTTPS URL adres k reseed serverům (výchozí seznam je vestavěný a pravidelně aktualizovaný) Konfigurace proxy - Nastavení HTTP/HTTPS/SOCKS proxy, pokud potřebujete přistupovat k reseed serverům přes proxy Obnovit seznam URL - Obnovení výchozího seznamu reseed serverů Důležité: Ruční reseed by měl být nutný pouze ve vzácných případech, kdy automatický reseed opakovaně selže. Většina uživatelů nikdy nebude potřebovat používat tuto stránku.\nKonfigurace sítě URL: Konfigurace rodiny routerů Stránka Konfigurace rodiny routerů umožňuje spravovat rodiny routerů. Routery ve stejné rodině sdílejí rodinný klíč, který je identifikuje jako provozované stejnou osobou nebo organizací. To zabraňuje tomu, aby byly vybrány více routerů, které ovládáte, pro stejný tunnel, což by snížilo anonymitu.\nCo je Router Family?\nKdyž provozujete více I2P routerů, měli byste je nakonfigurovat jako součást stejné rodiny. To zajistí: - Vaše routery nebudou použity společně ve stejné tunnel cestě - Ostatní uživatelé si zachovají správnou anonymitu, když jejich tunnely používají vaše routery - Síť může správně distribuovat účast v tunnelech\nAktuální rodina:\nStránka zobrazuje aktuální název rodiny vašeho routeru. Pokud nejste součástí rodiny, bude toto pole prázdné.\nExportovat rodinný klíč:\nExportujte tajný rodinný klíč pro import do dalších routerů, které ovládáte Klikněte na \u0026ldquo;Export Family Key\u0026rdquo; pro stažení souboru s rodinným klíčem Importujte tento klíč na svých dalších routerech, abyste je přidali do stejné rodiny Opustit rodinu routerů:\nJiž nebýt členem rodiny Klikněte na „Opustit rodinu\u0026quot; pro odebrání tohoto routeru z jeho současné rodiny Tuto akci nelze vrátit zpět bez opětovného importu klíče rodiny Důležité aspekty:\nVyžadována veřejná registrace: Aby byla vaše rodina rozpoznána v celé síti, musí být váš rodinný klíč přidán do kódové základny I2P vývojovým týmem. Tím je zajištěno, že všechny routery v síti o vaší rodině vědí. Kontaktujte tým I2P pro registraci vašeho rodinného klíče, pokud provozujete více veřejných routerů Většina uživatelů provozujících pouze jeden router tuto funkci nikdy nebude potřebovat Konfigurace rodiny se primárně používá provozovateli více veřejných routerů nebo poskytovateli infrastruktury Případy použití:\nProvozování více I2P routerů pro redundanci Provozování infrastruktury jako reseed servery nebo outproxy na více strojích Správa sítě I2P routerů pro organizaci Konfigurace peerů URL: Konfigurace tunelu Stránka Konfigurace tunelů umožňuje upravit výchozí nastavení tunelů jak pro exploratory tunnels (používané pro komunikaci routeru), tak pro client tunnels (používané aplikacemi). Výchozí nastavení vyhovuje většině uživatelů a mělo by být měněno pouze tehdy, pokud rozumíte kompromisům.\nDůležitá upozornění:\n⚠️ Kompromis mezi anonymitou a výkonem: Existuje základní kompromis mezi anonymitou a výkonem. Tunnely delší než 3 hopy (například 2 hopy + 0-2 hopy, 3 hopy + 0-1 hopy, 3 hopy + 0-2 hopy), nebo vysoké množství + záložní množství, mohou výrazně snížit výkon nebo spolehlivost. Může dojít k vysokému využití CPU a/nebo velké šířce odchozího pásma. Tato nastavení měňte opatrně a upravte je, pokud budete mít problémy.\n⚠️ Trvalost: Změny nastavení průzkumných tunnelů jsou uloženy v souboru router.config. Změny klientských tunnelů jsou dočasné a nejsou ukládány. Pro trvalé změny klientských tunnelů viz stránka I2PTunnel .\nPrůzkumné tunely:\nExplorační tunely jsou využívány vaším routerem ke komunikaci se síťovou databází a k účasti v síti I2P.\nMožnosti konfigurace pro Inbound i Outbound: - Length - Počet hopů v tunelu (výchozí: 2-3 hopy) - Randomization - Náhodná odchylka v délce tunelu (výchozí: 0-1 hopů) - Quantity - Počet aktivních tunelů (výchozí: 2 tunely) - Backup quantity - Počet záložních tunelů připravených k aktivaci (výchozí: 0 tunelů)\nKlientské tunely pro I2P webserver:\nTato nastavení řídí tunely pro vestavěný I2P webserver (eepsite).\n⚠️ VAROVÁNÍ ANONYMITY - Nastavení zahrnuje 1-hop tunely. ⚠️ VAROVÁNÍ VÝKONU - Nastavení zahrnuje vysoké množství tunelů.\nMožnosti konfigurace pro Inbound i Outbound: - Length - Délka tunelu (výchozí: 1 hop pro webserver) - Randomization - Náhodná odchylka v délce tunelu - Quantity - Počet aktivních tunelů - Backup quantity - Počet záložních tunelů\nKlientské tunely pro sdílené klienty:\nTato nastavení se vztahují na sdílené klientské aplikace (HTTP proxy, IRC atd.).\nMožnosti konfigurace pro Inbound i Outbound: - Length - Délka tunelu (výchozí: 3 skoky) - Randomization - Náhodná odchylka v délce tunelu - Quantity - Počet aktivních tunelů - Backup quantity - Počet záložních tunelů\nPorozumění parametrům tunelů:\nDélka: Delší tunely poskytují vyšší anonymitu, ale snižují výkon a spolehlivost Randomizace: Přidává nepředvídatelnost do cest tunelů, čímž zlepšuje zabezpečení Množství: Více tunelů zlepšuje spolehlivost a distribuci zátěže, ale zvyšuje spotřebu zdrojů Záložní množství: Předem vytvořené tunely připravené k nahrazení selhavších tunelů, zlepšující odolnost Osvědčené postupy:\nPonechte výchozí nastavení, pokud nemáte specifické potřeby Zvyšte délku tunelu pouze v případě, že je anonymita kritická a můžete akceptovat pomalejší výkon Zvyšte počet/zálohy pouze v případě, že dochází k častým selháním tunelů Sledujte výkon routeru po provedení změn Klikněte na \u0026ldquo;Save changes\u0026rdquo; pro aplikaci úprav Konfigurace Reseed URL: Konfigurace uživatelského rozhraní Stránka Konfigurace UI vám umožňuje přizpůsobit vzhled a přístupnost vaší konzole routeru, včetně výběru tématu, jazykových předvoleb a ochrany heslem.\nTéma konzole routeru:\nVyberte si mezi tmavým a světlým tématem pro rozhraní konzole routeru:\nTmavý - Tmavý režim (šetrnější k očím při slabém osvětlení) Světlý - Světlý režim (tradiční vzhled) Další možnosti motivu: - Nastavit motiv univerzálně pro všechny aplikace - Použít zvolený motiv pro všechny I2P aplikace, nejen pro konzoli routeru - Vynutit použití mobilní konzole - Používat rozhraní optimalizované pro mobilní zařízení i v prohlížečích na počítači - Integrovat aplikace Email a Torrent do konzole - Začlenit Susimail a I2PSnark přímo do rozhraní konzole místo jejich otevírání v samostatných záložkách\nJazyk konzole routeru:\nVyberte si preferovaný jazyk pro rozhraní konzole routeru z rozbalovací nabídky. I2P podporuje mnoho jazyků včetně angličtiny, němčiny, francouzštiny, španělštiny, ruštiny, čínštiny, japonštiny a dalších.\nPříspěvky k překladům jsou vítány: Pokud si všimnete neúplných nebo nesprávných překladů, můžete pomoci vylepšit I2P tím, že přispějete do překladatelského projektu. Kontaktujte vývojáře v #i2p-dev na IRC nebo zkontrolujte zprávu o stavu překladu (odkaz na stránce).\nHeslo pro Router Console:\nPřidejte autentizaci pomocí uživatelského jména a hesla pro ochranu přístupu ke konzoli vašeho routeru:\nUživatelské jméno - Zadejte uživatelské jméno pro přístup ke konzoli Heslo - Zadejte heslo pro přístup ke konzoli Přidat uživatele - Vytvořit nového uživatele se zadanými přihlašovacími údaji Smazat vybrané - Odstranit existující uživatelské účty Proč přidat heslo?\nZabraňuje neoprávněnému místnímu přístupu ke konzoli vašeho routeru Nezbytné, pokud váš počítač používá více osob Doporučeno, pokud je konzole vašeho routeru přístupná v místní síti Chrání vaši I2P konfiguraci a nastavení soukromí před neoprávněnými změnami Bezpečnostní upozornění: Ochrana heslem ovlivňuje pouze přístup k webovému rozhraní konzole routeru na adrese I2P Router Console . Nešifruje provoz I2P ani nebrání aplikacím v použití I2P. Pokud jste jediným uživatelem svého počítače a konzole routeru naslouchá pouze na localhost (výchozí nastavení), heslo nemusí být nutné.\nKonfigurace rodiny routerů URL: Konfigurace WebApp Stránka Konfigurace webových aplikací umožňuje spravovat Java webové aplikace, které běží ve vašem I2P routeru. Tyto aplikace jsou spouštěny klientem webConsole a běží ve stejném JVM jako router, poskytující integrovanou funkcionalitu přístupnou prostřednictvím konzole routeru.\nCo jsou WebApps?\nWebApps jsou aplikace založené na Javě, které mohou být: - Kompletní aplikace (např. I2PSnark pro torrenty) - Front-endy k dalším klientům, které musí být samostatně povoleny (např. Susidns, I2PTunnel) - Webové aplikace bez webového rozhraní (např. adresář kontaktů)\nDůležité poznámky:\nWebová aplikace může být zcela zakázána, nebo může být pouze zakázáno její spuštění při startu Odstranění war souboru z adresáře webapps zakáže webovou aplikaci úplně War soubor a adresář webové aplikace se však znovu objeví, když aktualizujete svůj router na novější verzi Pro trvalé zakázání webové aplikace: Zakažte ji zde, což je preferovaná metoda Dostupné WebAplikace:\nWebApp Description i2psnark Torrents - Built-in BitTorrent client for I2P i2ptunnel Hidden Services Manager - Configure client and server tunnels imagegen Identification Image Generator - Creates unique identicons jsonrpc jsonrpc.war - JSON-RPC API interface (disabled by default) routerconsole I2P Router Console - The main administrative interface susidns Address Book - Manage I2P addresses and subscriptions susimail Email - Web-based email client for I2P Ovládání: Pro každou webovou aplikaci: - Spustit při startu? - Zaškrtávací políčko pro povolení/zakázání automatického spuštění - Ovládání - Tlačítka Start/Stop pro okamžité ovládání - Stop - Zastaví aktuálně běžící webovou aplikaci - Start - Spustí zastavenou webovou aplikaci\nTlačítka konfigurace:\nZrušit - Zahodit změny a vrátit se na předchozí stránku Uložit konfiguraci WebApp - Uložit změny a aplikovat je Případy použití:\nZastavte I2PSnark, pokud nepoužíváte torrenty, abyste ušetřili zdroje Zakažte jsonrpc, pokud nepotřebujete API přístup Zastavte Susimail, pokud používáte externí emailového klienta Dočasně zastavte webapps pro uvolnění paměti nebo řešení problémů Tip pro výkon: Vypnutí nepoužívaných webových aplikací může snížit spotřebu paměti a zlepšit výkon routeru, zejména na systémech s nízkými prostředky.\nHelp URL: Nápověda Stránka Nápověda poskytuje komplexní dokumentaci a zdroje, které vám pomohou pochopit a efektivně používat I2P. Slouží jako centrální rozcestník pro řešení problémů, učení a získávání podpory.\nCo zde naleznete:\nRychlý průvodce - Základní informace pro nové uživatele začínající s I2P Často kladené otázky (FAQ) - Odpovědi na běžné dotazy týkající se instalace, konfigurace a používání I2P Řešení problémů - Řešení běžných problémů a potíží s připojením Technická dokumentace - Podrobné informace o protokolech I2P, architektuře a specifikacích Průvodce aplikacemi - Návody pro používání aplikací I2P jako torrenty, e-mail a skryté služby Informace o síti - Pochopení fungování I2P a toho, co ji činí bezpečnou Zdroje podpory - Odkazy na fóra, IRC kanály a komunitní podporu Získání pomoci:\nPokud máte problémy s I2P: 1. Zkontrolujte FAQ pro běžné otázky a odpovědi 2. Projděte si sekci řešení problémů pro váš konkrétní problém 3. Navštivte I2P fórum na i2pforum.i2p nebo i2pforum.net 4. Připojte se na IRC kanál #i2p pro podporu komunity v reálném čase 5. Prohledejte dokumentaci pro podrobné technické informace\nTip: Nápověda je vždy dostupná z postranního panelu konzole routeru, takže můžete snadno najít pomoc, kdykoli ji potřebujete.\nPerformance Graphs URL: Grafy výkonu Stránka Grafy výkonu poskytuje vizuální monitoring v reálném čase výkonu vašeho I2P routeru a síťové aktivity. Tyto grafy vám pomáhají pochopit využití šířky pásma, připojení k peerům, spotřebu paměti a celkové zdraví routeru.\nDostupné grafy:\nVyužití šířky pásma\nRychlost odesílání na nízké úrovni (bajty/s) - Rychlost odchozího provozu Rychlost přijímání na nízké úrovni (bajty/s) - Rychlost příchozího provozu Zobrazuje aktuální, průměrné a maximální využití šířky pásma Pomáhá sledovat, zda se blížíte k nakonfigurovaným limitům šířky pásma Aktivní protějšky\nrouter.activePeers průměrováno za 60 sec - Počet protějšků, se kterými aktivně komunikujete Ukazuje stav vašeho síťového připojení Více aktivních protějšků obecně znamená lepší budování tunelů a účast v síti Využití paměti routeru\nrouter.memoryUsed průměr za 60 sec - spotřeba paměti JVM Zobrazuje aktuální, průměrné a maximální využití paměti v MB Užitečné pro identifikaci úniků paměti nebo určení, zda je třeba zvýšit velikost Java heap Konfigurace zobrazení grafu:\nPřizpůsobte způsob zobrazení a aktualizace grafů:\nVelikost grafu - Nastavte šířku (výchozí: 400 pixelů) a výšku (výchozí: 100 pixelů) Zobrazované období - Časový rozsah k zobrazení (výchozí: 60 minut) Interval obnovení - Jak často se grafy aktualizují (výchozí: 5 minut) Typ grafu - Vyberte mezi zobrazením průměrů nebo událostí Skrýt legendu - Odebere legendu z grafů pro ušetření místa UTC - Použije UTC čas místo lokálního času v grafech Persistence - Ukládá data grafů na disk pro historickou analýzu Pokročilé možnosti:\nKlikněte na [Select Stats] pro výběr statistik k zobrazení v grafu: - Metriky tunelů (úspěšnost vytváření, počet tunelů atd.) - Statistiky síťové databáze - Statistiky transportu (NTCP2, SSU2) - Výkon klientských tunelů - A mnoho dalších podrobných metrik\nPřípady použití:\nSledujte šířku pásma, abyste zajistili, že nepřekračujete nastavené limity Ověřte konektivitu s peery při řešení problémů se sítí Sledujte využití paměti pro optimalizaci nastavení Java heap Identifikujte výkonnostní vzory v průběhu času Diagnostikujte problémy s budováním tunnelů korelací grafů Tip: Klikněte na „Uložit nastavení a překreslit grafy\u0026quot; po provedení změn pro aplikaci vaší konfigurace. Grafy se automaticky obnoví na základě vašeho nastavení obnovovacího zpoždění.\n","description":"Komplexní průvodce pochopením a konfigurací konzole I2P routeru","id":"c46f1b6edeab9b686fd57cf9b311df1c","section":"docs","title":"Průvodce konfigurací Routerové konzole","url":"/cs/docs/guides/router-console-config/"},{"categories":null,"content":"Chcete pomoci zpřístupnit I2P více lidem po celém světě? Překlad je jeden z nejcennějších příspěvků, které můžete projektu poskytnout. Tento průvodce vás provede překladem konzole routeru.\nMetody překladu Existují dva způsoby, jak přispět k překladům:\nMetoda 1: Transifex (Doporučeno) Toto je nejjednodušší způsob, jak přeložit I2P. Transifex poskytuje webové rozhraní, které činí překlad jednoduchým a přístupným.\nZaregistrujte se na Transifex Požádejte o připojení k překladatelskému týmu I2P Začněte překládat přímo ve vašem prohlížeči Nejsou potřeba žádné technické znalosti - stačí se zaregistrovat a můžete začít překládat!\nMetoda 2: Ruční překlad Pro překladatele, kteří preferují práci s git a lokálními soubory, nebo pro jazyky, které ještě nejsou nastaveny na Transifexu.\nPožadavky: - Znalost systému správy verzí git - Textový editor nebo nástroj pro překlady (doporučuje se POEdit) - Nástroje příkazového řádku: git, gettext\nNastavení: 1. Připojte se na #i2p-dev na IRC a představte se 2. Aktualizujte stav překladu na wiki (požádejte o přístup na IRC) 3. Naklonujte příslušný repozitář (viz sekce níže)\nPřeklad konzole routeru Konzole routeru je webové rozhraní, které vidíte při spuštění I2P. Překlad pomáhá uživatelům, kteří neovládají angličtinu.\nPoužití Transifexu (doporučeno) Přejděte na I2P na Transifex Vyberte projekt router console Zvolte svůj jazyk Začněte překládat Manuální překlad konzole routeru Předpoklady: - Stejné jako pro překlad webových stránek (git, gettext) - GPG klíč (pro přístup k commitování) - Podepsaná vývojářská smlouva\nKlonujte hlavní I2P repozitář:\ngit clone https://i2pgit.org/I2P_Developers/i2p.i2p.git cd i2p.i2p Soubory k překladu:\nKonzole routeru má přibližně 15 souborů, které je třeba přeložit:\nHlavní soubory rozhraní:\napps/routerconsole/locale/messages_*.po - Hlavní zprávy konzole apps/routerconsole/locale-news/messages_*.po - Zprávy novinek Soubory proxy:\napps/i2ptunnel/locale/messages_*.po - Rozhraní pro konfiguraci tunelů Lokalizace aplikací:\napps/susidns/locale/messages_*.po - Rozhraní adresáře kontaktů apps/susimail/locale/messages_*.po - Rozhraní e-mailu Další adresáře lokalizací specifické pro aplikace Soubory dokumentace:\ninstaller/resources/readme/readme_*.html - Instalační readme Soubory nápovědy v různých aplikacích Pracovní postup překladu:\n# Update .po files from source ant extractMessages # Edit .po files with POEdit or text editor poedit apps/routerconsole/locale/messages_es.po # Build and test ant updaters # Install the update and check translations in the console Odešlete svou práci: - Vytvořte merge request na GitLabu - Nebo sdílejte soubory s vývojovým týmem na IRC\nNástroje pro překlad POEdit (Vysoce doporučeno) POEdit je specializovaný editor pro překladové soubory .po.\nFunkce: - Vizuální rozhraní pro překladatelskou práci - Zobrazuje kontext překladu - Automatická validace - Dostupné pro Windows, macOS a Linux\nTextové editory Můžete také použít libovolný textový editor: - VS Code (s rozšířeními pro i18n) - Sublime Text - vim/emacs (pro uživatele terminálu)\nKontroly kvality Před odesláním: 1. Zkontrolujte formátování: Ujistěte se, že zástupné znaky jako %s a {0} zůstávají beze změny 2. Otestujte své překlady: Nainstalujte a spusťte I2P, abyste viděli, jak vypadají 3. Konzistence: Udržujte terminologii konzistentní napříč soubory 4. Délka: Některé řetězce mají omezení délky v uživatelském rozhraní\nTipy pro překladatele Obecné pokyny Buďte konzistentní: Používejte stejné překlady pro běžné termíny v celém dokumentu Zachovejte formátování: Ponechte HTML tagy, zástupné symboly (%s, {0}) a zalomení řádků Kontext je důležitý: Pečlivě si přečtěte zdrojový anglický text, abyste porozuměli kontextu Ptejte se: Použijte IRC nebo fóra, pokud je něco nejasné Běžné pojmy I2P Některé výrazy by měly zůstat v angličtině nebo být pečlivě transliterovány:\nI2P - Keep as is eepsite - I2P webová stránka (může vyžadovat vysvětlení ve vašem jazyce) tunnel - Cesta spojení (vyhněte se terminologii Tor jako \u0026ldquo;circuit\u0026rdquo;) netDb - Síťová databáze floodfill - Typ routeru destination - Koncový bod I2P adresy Testování vašich překladů Sestavte I2P s vašimi překlady Změňte jazyk v nastavení router console Procházejte všechny stránky a kontrolujte: Text se vejde do prvků uživatelského rozhraní Žádné nečitelné znaky (problémy s kódováním) Překlady dávají smysl v kontextu Často kladené otázky Proč je proces překladu tak složitý? Proces využívá správu verzí (git) a standardní překladatelské nástroje (.po soubory), protože:\nOdpovědnost: Sledujte, kdo co a kdy změnil Kvalita: Zkontrolujte změny před jejich zveřejněním Konzistence: Udržujte správné formátování a strukturu souborů Škálovatelnost: Efektivně spravujte překlady napříč více jazyky Spolupráce: Více překladatelů může pracovat na stejném jazyce Potřebuji znalosti programování? Ne! Pokud používáte Transifex, potřebujete pouze: - Plynulost v angličtině i ve vašem cílovém jazyce - Webový prohlížeč - Základní počítačové dovednosti\nPro ruční překlad budete potřebovat základní znalost práce s příkazovým řádkem, ale programování není vyžadováno.\nJak dlouho to trvá? Konzole routeru: Přibližně 15-20 hodin pro všechny soubory Údržba: Několik hodin měsíčně pro aktualizaci nových řetězců Může na jednom jazyku pracovat více lidí? Ano! Koordinace je klíčová: - Používejte Transifex pro automatickou koordinaci - Pro manuální práci komunikujte v IRC kanálu #i2p-dev - Rozdělte práci podle sekcí nebo souborů\nCo když můj jazyk není v seznamu? Požádejte o to na Transifexu nebo kontaktujte tým na IRC. Vývojový tým může nový jazyk nastavit rychle.\nJak mohu otestovat své překlady před odesláním? Sestavte I2P ze zdrojového kódu s vašimi překlady Nainstalujte a spusťte lokálně Změňte jazyk v nastavení konzole Získání pomoci IRC podpora Připojte se k #i2p-dev na IRC pro: - Technickou pomoc s nástroji pro překlad - Dotazy ohledně terminologie I2P - Koordinaci s dalšími překladateli - Přímou podporu od vývojářů\nFóra Diskuse o překladech na I2P Forums Inside I2P: Překladatelské fórum na zzz.i2p (vyžaduje I2P router) Dokumentace Dokumentace Transifex Dokumentace POEdit Příručka gettext Uznání Všichni překladatelé jsou uvedeni v: - Konzoli I2P routeru (stránka O programu) - Stránce s kredity na webu - Historii Git commitů - Oznámeních o vydání\nVaše práce přímo pomáhá lidem po celém světě používat I2P bezpečně a soukromě. Děkujeme za váš příspěvek!\nDalší kroky Připraveni začít překládat?\nVyberte si svou metodu:\nRychlý start: Zaregistrujte se na Transifexu Manuální přístup: Připojte se na #i2p-dev na IRC Začněte pomalu: Přeložte několik řetězců, abyste se seznámili s procesem\nPožádejte o pomoc: Neváhejte se obrátit na IRC nebo fóra\nDěkujeme, že pomáháte zpřístupnit I2P všem!\n","description":"Jak přispět překlady na web I2P a do konzole routeru pomocí Transifexu nebo manuálními metodami","id":"a436f7ab16669c43b076458496d70009","section":"docs","title":"Průvodce pro nové překladatele","url":"/cs/docs/develop/new-translators/"},{"categories":null,"content":"Takže chcete začít pracovat na I2P? Skvělé! Zde je rychlý průvodce, jak začít přispívat na webové stránky nebo software, vyvíjet nebo vytvářet překlady.\nJeště nejste připraveni na programování? Zkuste se nejprve zapojit .\nPoznejte Javu I2P router a jeho vestavěné aplikace používají jako hlavní programovací jazyk Javu. Pokud nemáte zkušenosti s Javou, můžete se vždy podívat na Thinking in Java Prostudujte si úvodní dokument \u0026ldquo;jak na to\u0026rdquo;, další dokumenty \u0026ldquo;jak na to\u0026rdquo;, technický úvod a související dokumenty:\nJak začít: Úvod do I2P Centrum dokumentace: Dokumentace Technický úvod: Technický úvod Toto vám poskytne dobrý přehled o tom, jak je I2P strukturován a jaké různé funkce vykonává.\nZískání kódu I2P Pro vývoj I2P routeru nebo vestavěných aplikací potřebujete získat zdrojový kód.\nNáš současný způsob: Git I2P má oficiální Git služby a přijímá příspěvky přes Git na našem vlastním GitLabu:\nUvnitř I2P: http://git.idk.i2p Mimo I2P: https://i2pgit.org Naklonujte hlavní repozitář:\ngit clone https://i2pgit.org/I2P_Developers/i2p.i2p.git Zrcadlo pouze pro čtení je také dostupné na GitHubu:\nGitHub mirror: github.com/i2p/i2p.i2p git clone https://github.com/i2p/i2p.i2p.git Sestavení I2P Pro kompilaci kódu potřebujete Sun/Oracle Java Development Kit 6 nebo vyšší, případně ekvivalentní JDK (Sun/Oracle JDK 6 silně doporučeno) a Apache Ant verze 1.7.0 nebo vyšší. Pokud pracujete na hlavním kódu I2P, přejděte do adresáře i2p.i2p a spusťte ant, abyste viděli možnosti sestavení.\nPro sestavení nebo práci na překladech konzole potřebujete nástroje xgettext, msgfmt a msgmerge z balíčku GNU gettext.\nPro vývoj nových aplikací se podívejte do průvodce vývojem aplikací .\nNápady pro vývoj Podívejte se na seznam TODO projektu nebo na seznam problémů na GitLabu pro nápady:\nGitLab issues: i2pgit.org/I2P_Developers/i2p.i2p/issues Zpřístupnění výsledků Požadavky na práva k provádění commitů najdete na konci stránky s licencemi. Tyto práva potřebujete k vkládání kódu do i2p.i2p (pro webové stránky není vyžadováno!).\nStránka licencí Poznejte nás! Vývojáři se zdržují na IRC. Lze je zastihnout na různých sítích a na interních sítích I2P. Obvyklým místem je kanál #i2p-dev. Připojte se na kanál a pozdravte! Máme také další pokyny pro pravidelné vývojáře .\nPřeklady Překladatelé webových stránek a routerové konzole: Další kroky najdete v Příručce pro nové překladatele .\nNástroje I2P je open source software, který je většinou vyvíjen pomocí open-source nástrojů. Projekt I2P nedávno získal licenci pro YourKit Java Profiler. Open source projekty mají nárok na bezplatnou licenci za podmínky, že YourKit je zmíněn na webových stránkách projektu. Pokud máte zájem o profilování I2P codebase, kontaktujte nás.\nYourKit laskavě podporuje open source projekty svými plně vybavенými profilery. YourKit, LLC je tvůrcem inovativních a inteligentních nástrojů pro profilování Java a .NET aplikací. Podívejte se na přední softwarové produkty YourKit:\nYourKit Java Profiler YourKit .NET Profiler ","description":"Jak začít přispívat do I2P: studijní materiály, zdrojový kód, sestavování, nápady, publikování, komunita, překlady a nástroje","id":"e74ff72be9767cc925c6712e11e5e1c5","section":"docs","title":"Průvodce pro nové vývojáře","url":"/cs/docs/develop/new-developers/"},{"categories":null,"content":" Rozsah: Tato příručka sjednocuje implementaci tunnelu, formát zpráv a obě specifikace pro vytváření tunnelů (ECIES a starší ElGamal). Stávající hluboké odkazy nadále fungují prostřednictvím výše uvedených aliasů.\nModel Tunnel I2P přeposílá užitečná data prostřednictvím jednosměrných tunnels: uspořádaných sad routers, které přenášejí provoz jedním směrem. Plná cesta tam a zpět mezi dvěma cíli vyžaduje čtyři tunnels (dva odchozí, dva příchozí).\nZačněte s Tunnel Overview pro seznámení s terminologií, poté použijte tuto příručku pro provozní podrobnosti.\nŽivotní cyklus zprávy tunnel brána seskupí jednu nebo více zpráv I2NP, rozdělí je na fragmenty a zapíše pokyny pro doručení. Brána zapouzdří užitečná data do zprávy tunnel pevné velikosti (1024 B), v případě potřeby doplní výplň. Každý účastník ověří předchozí skok, aplikuje svou šifrovací vrstvu a předá {nextTunnelId, nextIV, encryptedPayload} dalšímu skoku. tunnel koncový bod odstraní poslední vrstvu, zpracuje pokyny pro doručení, znovu sestaví fragmenty a odešle rekonstruované zprávy I2NP. Detekce duplikátů používá stárnoucí Bloomův filtr, klíčovaný bitovým XORem IV (inicializačního vektoru) a prvního bloku šifrotextu, aby zabránila značkovacím útokům založeným na záměně IV.\nRychlý přehled rolí Role Pre-processing Crypto Operation Post-processing Outbound gateway (creator) Fragment, batch, pad Iteratively decrypt using every hop’s keys (so downstream peers encrypt) Forward to first hop Participant — Encrypt IV and payload with hop keys Forward to next hop Outbound endpoint — Encrypt once more to reveal plaintext payload Deliver to target tunnel/destination Inbound gateway Fragment, batch, pad Encrypt with local keys Forward to next hop Inbound endpoint (creator) — Iteratively decrypt using stored hop keys Reassemble and deliver locally ### Postup šifrování {#encryption-workflow} Inbound tunnels: brána jednou zašifruje svým klíčem vrstvy; následující účastníci pokračují v šifrování, dokud tvůrce tunnelu nedešifruje finální užitečná data. Outbound tunnels: brána předem aplikuje inverzi šifrování každého skoku, takže každý účastník šifruje. Když koncový bod zašifruje, odhalí se původní otevřený text brány. Oba směry předávají {tunnelId, IV, encryptedPayload} dalšímu uzlu.\nFormát zprávy pro tunnel Vstupní brány tunelu fragmentují zprávy I2NP do obálek pevné velikosti, aby skryly délku užitečných dat a zjednodušily zpracování na každém skoku.\nŠifrované uspořádání +----------------+----------------+-------------------+ | Tunnel ID (4B) | IV (16B) | Encrypted payload | +----------------+----------------+-------------------+ Tunnel ID – 32bitový identifikátor pro další uzel (nenulový, obměňuje se v každém cyklu sestavení). IV – 16bajtový AES IV (inicializační vektor) zvolený pro každou zprávu. Šifrovaná užitečná data – 1008 bajtů šifrotextu AES-256-CBC. Celková velikost: 1028 bajtů.\nDešifrované uspořádání Poté, co uzel odstraní svou vrstvu šifrování:\n[Checksum (4B)][Padding ... 0x00 terminator] [Delivery Instructions 1][I2NP fragment 1] [Delivery Instructions 2][I2NP fragment 2] ... Kontrolní součet ověřuje dešifrovaný blok. Výplň jsou náhodné nenulové bajty ukončené nulovým bajtem. Pokyny pro doručení sdělují koncovému bodu, jak nakládat s každým fragmentem (doručit lokálně, předat do jiného tunnelu apod.). Fragmenty nesou podkladové zprávy I2NP; koncový bod je znovu sestaví předtím, než je předá vyšším vrstvám. Kroky zpracování Brány fragmentují a řadí do fronty zprávy I2NP, přičemž dočasně uchovávají částečné fragmenty pro opětovné sestavení. Brána šifruje užitečná data příslušnými klíči vrstvy a nastaví tunnel ID a IV (inicializační vektor). Každý účastník zašifruje IV (AES-256/ECB) a poté užitečná data (AES-256/CBC), následně znovu zašifruje IV a zprávu předá dál. Koncový uzel dešifruje v opačném pořadí, ověří kontrolní součet, zpracuje pokyny pro doručení a znovu sestaví fragmenty. Vytváření tunnelu (ECIES-X25519) Moderní routers vytvářejí tunnels s klíči ECIES-X25519, čímž zmenšují velikost sestavovacích zpráv a umožňují dopředné utajení.\nSestavovací zpráva: jediná zpráva I2NP TunnelBuild (nebo VariableTunnelBuild) nese 1–8 šifrovaných sestavovacích záznamů, jeden na hop. Klíče vrstvy: tvůrce odvozuje pro každý hop klíče vrstvy, IV a odpovědi pomocí HKDF s využitím statické identity X25519 daného hopu a svého efemérního klíče. Zpracování: každý hop dešifruje svůj záznam, ověří příznaky požadavku, zapíše odpovědní blok (úspěch nebo podrobný kód selhání), znovu zašifruje zbývající záznamy a předá zprávu dál. Odpovědi: tvůrce obdrží odpovědní zprávu zabalenou pomocí garlic encryption. Záznamy označené jako neúspěšné obsahují kód závažnosti, aby mohl router profilovat protějšek. Kompatibilita: routery mohou kvůli zpětné kompatibilitě nadále přijímat starší sestavení na bázi ElGamalu, ale nové tunnely ve výchozím nastavení používají ECIES. Pro konstanty pro jednotlivá pole a poznámky k derivaci klíčů viz historii návrhu ECIES a zdrojový kód routeru; tato příručka popisuje provozní tok.\nZastaralé vytváření Tunnel (ElGamal-2048) Původní formát pro vytváření tunnel používal ElGamalovy veřejné klíče. Moderní routers zachovávají omezenou podporu kvůli zpětné kompatibilitě.\nStav: Zastaralé. Ponecháno zde pro historickou referenci a pro každého, kdo udržuje nástroje kompatibilní se staršími verzemi.\nNeinteraktivní teleskopování: jediná sestavovací zpráva prochází celou trasu. Každý hop dešifruje svůj 528bajtový záznam, aktualizuje zprávu a předá ji dál. Proměnná délka: Variable Tunnel Build Message (VTBM; proměnná zpráva pro sestavení Tunnelu) umožňovala 1–8 záznamů. Dřívější pevná zpráva vždy obsahovala osm záznamů, aby zamaskovala délku tunnelu. Struktura záznamu požadavku: Bytes 0–3 : Tunnel ID (receiving ID) Bytes 4–35 : Current hop router hash Bytes 36–39 : Next tunnel ID Bytes 40–71 : Next hop router hash Bytes 72–103 : AES-256 layer key Bytes 104–135: AES-256 IV key Bytes 136–167: AES-256 reply key Bytes 168–183: AES-256 reply IV Byte 184 : Flags (bit7=IBGW, bit6=OBEP) Bytes 185–188: Request time (hours since epoch) Bytes 189–192: Next message ID Bytes 193–221: Padding Příznaky: bit 7 označuje vstupní bránu (inbound gateway, IBGW); bit 6 označuje výstupní koncový bod (outbound endpoint, OBEP). Navzájem se vylučují. Šifrování: každý záznam je šifrován algoritmem ElGamal-2048 veřejným klíčem příslušného uzlu. Symetrické vrstvení AES-256-CBC zajišťuje, že záznam si přečte pouze zamýšlený uzel. Klíčová fakta: identifikátory tunnelu jsou nenulové 32bitové hodnoty; tvůrci mohou vkládat falešné záznamy, aby skryli skutečnou délku tunnelu; spolehlivost závisí na opakování neúspěšných pokusů o sestavení. Pooly tunnelů a životní cyklus Routers udržují nezávislé příchozí a odchozí tunnel pooly pro průzkumný provoz a pro každou relaci I2CP.\nVýběr peerů: průzkumné tunnels čerpají ze skupiny peerů „active, not failing“ pro podporu diverzity; klientské tunnels preferují rychlé peery s vysokou kapacitou. Deterministické řazení: peery jsou seřazeny podle XOR vzdálenosti mezi SHA256(peerHash || poolKey) a náhodným klíčem daného poolu. Klíč se při restartu rotuje, což zajišťuje stabilitu v rámci jednoho běhu a zároveň ztěžuje predecessor attacks (útoky předchůdce) napříč běhy. Životní cyklus: routers sledují historické časy sestavování pro n-tici {mode, direction, length, variance}. Jak se tunnels blíží expiraci, náhrady začínají dříve; router zvyšuje počet paralelních sestavení při výskytu selhání, zároveň omezuje počet otevřených pokusů. Konfigurační parametry: počty aktivních/záložních tunnels, délka a odchylka počtu hopů, povolení zero-hop (nulový počet hopů) a limity rychlosti sestavování jsou nastavitelné pro každý pool. Přetížení a spolehlivost Ačkoli tunnels připomínají okruhy, routers s nimi zacházejí jako s frontami zpráv. K udržení latence v mezích se používá Weighted Random Early Discard (WRED; vážené náhodné předčasné zahazování):\nPravděpodobnost zahazování roste, jak se zatížení blíží nakonfigurovaným limitům. Účastníci uvažují fragmenty pevné velikosti; brány/koncové body zahazují podle souhrnné velikosti fragmentů a přednostně zahazují velká užitečná data. Výstupní koncové body zahazují dříve než jiné role, aby se co nejméně plýtvalo síťovými prostředky. Zaručené doručování je ponecháno vyšším vrstvám, jako je Streaming library (knihovna pro streamování) . Aplikace, které vyžadují spolehlivost, si musí samy zajišťovat retransmise a potvrzování.\nDalší čtení Výběr peerů Přehled Tunnel Stará implementace Tunnel ","description":"Jednotná specifikace pro vytváření, šifrování a přenášení provozu pomocí I2P tunnels.","id":"6fb0b76b8bc10fa3e571b748f502baaa","section":"docs","title":"Průvodce provozem tunnel","url":"/cs/docs/specs/implementation/"},{"categories":null,"content":"Přehled Tato specifikace rozšiřuje odběrný kanál adresáře o příkazy, které umožňují jmenným serverům distribuovat aktualizace záznamů od držitelů názvů hostitelů (hostname). Původně navržena v Návrh 112 (září 2014), implementována ve verzi 0.9.26 (červen 2016) a nasazena v celé síti se statusem CLOSED.\nSystém zůstal stabilní a beze změn od své počáteční implementace a nadále funguje totožně v I2P 2.10.0 (Router API 0.9.65, září 2025).\nMotivace Dříve servery pro odběr hosts.txt zasílaly data pouze v jednoduchém formátu hosts.txt:\nexample.i2p=b64destination Tento základní formát způsobil několik problémů:\nDržitelé názvů hostitelů nemohou aktualizovat Destination (I2P cílový identifikátor) spojenou s jejich názvy hostitelů (například kvůli přechodu podpisového klíče na silnější kryptografický typ). Držitelé názvů hostitelů se nemohou svých názvů hostitelů libovolně vzdát. Odpovídající soukromé klíče Destination musí předat přímo novému držiteli. Neexistuje způsob, jak ověřit, že subdoména je spravována odpovídajícím základním názvem hostitele. To je v současnosti vynucováno pouze jednotlivě některými jmennými servery. Návrh Tato specifikace přidává do formátu hosts.txt řádky s příkazy. Pomocí těchto příkazů mohou jmenné servery rozšířit své služby a poskytovat další funkce. Klienti, kteří tuto specifikaci implementují, mohou o těchto funkcích získávat informace prostřednictvím běžného procesu odběru.\nVšechny příkazové řádky musí být podepsány příslušnou Destination (cílovou identitou v I2P). To zajišťuje, že změny jsou prováděny pouze na žádost držitele názvu hostitele.\nBezpečnostní dopady Tato specifikace nemá vliv na anonymitu.\nDochází ke zvýšení rizika spojeného se ztrátou kontroly nad Destination key (klíčem k Destination – identitě cílové služby v I2P), protože kdokoli, kdo jej získá, může pomocí těchto příkazů provádět změny u libovolných k němu přiřazených názvů hostitele. To však nepředstavuje větší problém než status quo, kdy někdo, kdo získá Destination, se může vydávat za název hostitele a (částečně) převzít jeho provoz. Zvýšené riziko je vyváženo tím, že držitelům názvů hostitele dává možnost změnit Destination přiřazenou k názvu hostitele v případě, že se domnívají, že Destination byla kompromitována. To je v současném systému nemožné.\nSpecifikace Nové typy řádků Existují dva nové typy řádků:\nPříkazy Add a Change: example.i2p=b64destination#!key1=val1#key2=val2... Odstranit příkazy: #!key1=val1#key2=val2... Pořadí Kanál nemusí být nutně seřazený ani úplný. Například příkaz change se může objevit na řádku před příkazem add, nebo i bez příkazu add.\nKlíče mohou být v libovolném pořadí. Duplicitní klíče nejsou povoleny. Všechny klíče i hodnoty rozlišují velká a malá písmena.\nObecné klíče Povinné u všech příkazů:\nsig : Podpis v Base64, s použitím podpisového klíče destination (cílová adresa)\nOdkazy na druhý název hostitele a/nebo destinaci:\noldname : Druhý název hostitele (nový nebo změněný)\nolddest : Druhá destinace v Base64 (nová nebo změněná)\noldsig : Druhý podpis v kódování Base64, s použitím podpisového klíče z olddest\nDalší běžné klíče:\nakce : Příkaz\nname : Název hostitele, uveden pouze pokud mu nepředchází example.i2p=b64dest\ndest : Base64 Destination (cílová adresa v I2P), je přítomná pouze v případě, že jí nepředchází example.i2p=b64dest\ndate : V sekundách od epochy\nexpires : V sekundách od epochy\nPříkazy Všechny příkazy kromě příkazu \u0026ldquo;Add\u0026rdquo; musí obsahovat dvojici klíč/hodnota action=command.\nPro kompatibilitu se staršími klienty je většině příkazů předřazeno example.i2p=b64dest, jak je uvedeno níže. U změn jde vždy o nové hodnoty. Případné staré hodnoty jsou zahrnuty v sekci klíč/hodnota.\nUvedené klíče jsou povinné. Všechny příkazy mohou obsahovat další položky klíč/hodnota, které zde nejsou definovány.\nPřidat název hostitele Předcházeno řetězcem example.i2p=b64dest : ANO, toto je nový název hostitele a cíl.\nakce : NENÍ zahrnuta, je implicitní.\nsig : podpis\nPříklad:\nexample.i2p=b64dest#!sig=b64sig Změnit název hostitele Předchází example.i2p=b64dest : ANO, jde o nový název hostitele a starou destinaci.\naction : changename\noldname : starý název hostitele, který má být nahrazen\nsig : podpis\nPříklad:\nexample.i2p=b64dest#!action=changename#oldname=oldhostname#sig=b64sig Změnit cíl Předchází example.i2p=b64dest : ANO, toto je starý název hostitele a nový destination (cílový identifikátor).\nakce : changedest\nolddest : původní destinace, která má být nahrazena\noldsig : podpis pomocí olddest\nsig : podpis\nPříklad:\nexample.i2p=b64dest#!action=changedest#olddest=oldb64dest#oldsig=b64sig#sig=b64sig Přidat alias hostitele Předchází example.i2p=b64dest : ANO, toto je nový (alias) název hostitele a stará destinace.\nakce : addname\noldname : původní název hostitele\nsig : podpis\nPříklad:\nexample.i2p=b64dest#!action=addname#oldname=oldhostname#sig=b64sig Přidat alias cíle (Použito pro kryptografickou aktualizaci)\nUvedeno ve tvaru example.i2p=b64dest : ANO, toto je starý název hostitele a nová (alternativní) cílová adresa.\naction : adddest\nolddest : předchozí destinace\noldsig : podpis vytvořený pomocí olddest\nsig : podpis pomocí dest\nPříklad:\nexample.i2p=b64dest#!action=adddest#olddest=oldb64dest#oldsig=b64sig#sig=b64sig Přidat subdoménu Uvozeno subdomain.example.i2p=b64dest : ANO, toto je nový název subdomény a destinace.\nakce : addsubdomain\noldname : název hostitele vyšší úrovně (example.i2p)\nolddest : nadřazený cíl (například example.i2p)\noldsig : podpis s použitím olddest\nsig : podpis s použitím dest\nPříklad:\nsubdomain.example.i2p=b64dest#!action=addsubdomain#oldname=example.i2p#olddest=oldb64dest#oldsig=b64sig#sig=b64sig Aktualizovat metadata Předcházeno řetězcem example.i2p=b64dest : ANO, toto je původní název hostitele a destination (cílový identifikátor).\nakce : aktualizace\nsig : podpis\n(zde přidejte všechny aktualizované klíče)\nPříklad:\nexample.i2p=b64dest#!action=update#k1=v1#k2=v2#sig=b64sig Odstranit název hostitele Předcházeno řetězcem example.i2p=b64dest : NE, to se uvádí v možnostech\nakce : odstranit\nname : název hostitele\ndest : cíl\nsig : podpis\nPříklad:\n#!action=remove#name=example.i2p#dest=b64dest#sig=b64sig Odstranit vše s touto destinací S předponou example.i2p=b64dest : NE, tyto se zadávají v parametrech\nakce : removeall\ndest : cíl\nsig : podpis\nPříklad:\n#!action=removeall#dest=b64dest#sig=b64sig Podpisy Všechny příkazy musí být podepsány odpovídající Destination (cílovou identitou v I2P). Příkazy se dvěma cíli mohou vyžadovat dva podpisy.\noldsig je vždy \u0026ldquo;vnitřní\u0026rdquo; podpis. Podepisujte a ověřujte bez přítomnosti klíčů oldsig a sig. sig je vždy \u0026ldquo;vnější\u0026rdquo; podpis. Podepisujte a ověřujte s přítomným klíčem oldsig, ale bez klíče sig.\nVstup pro podpisy Chcete‑li vygenerovat bajtový proud pro vytvoření nebo ověření podpisu, serializujte následovně:\nOdstraňte klíč sig Pokud ověřujete pomocí oldsig, odstraňte také klíč oldsig Pouze pro příkazy Add nebo Change vypište example.i2p=b64dest Pokud nějaké klíče zbývají, vypište #! Seřaďte volby podle klíče v UTF-8, pokud se vyskytnou duplicitní klíče, skončete chybou Pro každý pár klíč/hodnota vypište key=value, následovaný (pokud nejde o poslední pár klíč/hodnota) znakem # Poznámky\nNevypisujte znak nového řádku Kódování výstupu je UTF-8 Veškeré kódování destination (cílové identity) a podpisu je v Base 64 s použitím abecedy I2P Klíče a hodnoty rozlišují velká a malá písmena Názvy hostitelů musí být psány malými písmeny Aktuální typy podpisů Od verze I2P 2.10.0 jsou pro destinace podporovány následující typy podpisů:\nEdDSA_SHA512_Ed25519 (Typ 7): Nejběžnější pro destinace od verze 0.9.15. Používá veřejný klíč o délce 32 bajtů a podpis o délce 64 bajtů. Toto je doporučený typ podpisu pro nové destinace. RedDSA_SHA512_Ed25519 (Typ 13): Dostupné pouze pro destinace a šifrované leaseSety (sada pronájmů) (od 0.9.39). Starší typy (DSA_SHA1, varianty ECDSA): Stále podporované, ale od 0.9.58 označené jako zastaralé pro nové identity routeru. Poznámka: Postkvantové kryptografické možnosti jsou k dispozici od verze I2P 2.10.0, ale zatím nejsou výchozími typy podpisů.\nKompatibilita Všechny nové řádky ve formátu hosts.txt jsou implementovány pomocí počátečních znaků komentáře (#!), takže všechny starší verze I2P budou nové příkazy interpretovat jako komentáře a bez problémů je budou ignorovat.\nKdyž se I2P routers aktualizují na novou specifikaci, nebudou znovu interpretovat staré komentáře, ale při následných načteních jejich odběrových kanálů začnou přijímat nové příkazy. Proto je důležité, aby jmenné servery nějakým způsobem trvale uchovávaly záznamy příkazů, nebo aby povolily podporu ETag (HTTP identifikátor entity), aby si routers mohly načíst všechny dřívější příkazy.\nStav implementace Počáteční nasazení: Verze 0.9.26 (7. června 2016)\nAktuální stav: Stabilní a beze změn až do verze I2P 2.10.0 včetně (Router API 0.9.65, září 2025)\nStav návrhu: UZAVŘENO (úspěšně nasazeno napříč sítí)\nUmístění implementace: apps/addressbook/java/src/net/i2p/addressbook/ v I2P Java routeru\nKlíčové třídy: - SubscriptionList.java: Spravuje zpracování odběrů - Subscription.java: Obsluhuje jednotlivé kanály odběrů - AddressBook.java: Základní funkcionalita adresáře - Daemon.java: Služba adresáře běžící na pozadí\nVýchozí URL odběru: http://i2p-projekt.i2p/hosts.txt\nPodrobnosti o přenosu Odběry používají HTTP s podporou podmíněného GET:\nHlavička ETag: Podporuje efektivní detekci změn Hlavička Last-Modified: Sleduje časy aktualizací odběru 304 Not Modified: Servery by měly vracet tento kód, když se obsah nezměnil Content-Length: Důrazně doporučeno pro všechny odpovědi I2P router používá standardní chování klienta HTTP se správnou podporou ukládání do mezipaměti.\nKontext verze Poznámka k verzování I2P: Přibližně od verze 1.5.0 (srpen 2021) přešlo I2P z verzování 0.9.x na sémantické verzování (1.x, 2.x atd.). Interní verze Router API však nadále používá číslování 0.9.x kvůli zpětné kompatibilitě. K říjnu 2025 je aktuálním vydáním I2P 2.10.0 s verzí Router API 0.9.65.\nTento specifikační dokument byl původně napsán pro verzi 0.9.49 (únor 2021) a zůstává plně aktuální i pro současnou verzi 0.9.65 (I2P 2.10.0), protože systém odběru informačních kanálů neprošel od své původní implementace ve verzi 0.9.26 žádnými změnami.\nReference Návrh 112 (původní) Oficiální specifikace Dokumentace k pojmenování v I2P Specifikace společných struktur Repozitář zdrojových kódů I2P Gitea repozitář I2P Související vývoj Ačkoli se samotný systém odběrových kanálů nezměnil, následující související novinky v jmenné infrastruktuře I2P by vás mohly zajímat:\nRozšířené názvy Base32 (0.9.40+): Podpora pro base32 adresy o délce 56+ znaků pro šifrované leaseSet. Neovlivňuje formát odběrového kanálu. Registrace TLD .i2p.alt (RFC 9476, koncem roku 2023): Oficiální registrace .i2p.alt u GANA jako alternativní TLD. Budoucí aktualizace routeru mohou odstranit sufix .alt, ale nejsou vyžadovány žádné změny příkazů odběru. Postkvantová kryptografie (2.10.0+): K dispozici, ale není výchozí. Do budoucna se zvažuje pro podpisové algoritmy v odběrových kanálech. ","description":"Rozšíření odběrových kanálů s adresami, které umožňuje držitelům názvů hostitelů aktualizovat a spravovat své záznamy","id":"fa3cedda5fbeac90d0dcf029a44ee945","section":"docs","title":"Příkazy pro kanál odběru adres","url":"/cs/docs/specs/subscription/"},{"categories":null,"content":"I2P routery nejčastěji selhávají kvůli problémům s přesměrováním portů, nedostatečnému vyhrazení šířky pásma a nedostatečnému času pro bootstrap. Tyto tři faktory představují více než 70 % nahlášených problémů. Router po startu potřebuje alespoň 10-15 minut k plné integraci do sítě, minimální šířku pásma 128 KB/sec (doporučeno 256 KB/sec) a správné přesměrování portů UDP/TCP k dosažení stavu neblokovaného firewallem. Noví uživatelé často očekávají okamžité připojení a předčasně restartují, což resetuje průběh integrace a vytváří frustrující smyčku. Tato příručka poskytuje podrobná řešení všech hlavních problémů I2P, které ovlivňují verze 2.10.0 a novější.\nArchitektura anonymity I2P ze své podstaty vyměňuje rychlost za soukromí prostřednictvím víceskokových šifrovaných tunnelů. Pochopení tohoto základního návrhu pomáhá uživatelům nastavit si realistická očekávání a efektivně řešit potíže, místo aby běžné chování mylně považovali za problémy.\nRouter se nespustí nebo se okamžitě zhroutí Nejčastější potíže při spuštění pramení z konfliktů portů, nekompatibility verzí Javy nebo poškozených konfiguračních souborů. Než budete pátrat po hlubších příčinách, ověřte, zda už neběží jiná instance I2P.\nZkontrolujte, zda neběží žádné kolidující procesy:\nLinux: ps aux | grep i2p nebo netstat -tulpn | grep 7657\nWindows: Správce úloh → Podrobnosti → najděte java.exe s i2p v příkazovém řádku\nmacOS: Monitor aktivity → vyhledejte \u0026ldquo;i2p\u0026rdquo;\nPokud existuje zombie proces, ukončete ho: pkill -9 -f i2p (Linux/Mac) nebo taskkill /F /IM javaw.exe (Windows)\nZkontrolujte kompatibilitu verze Javy:\nI2P 2.10.0+ vyžaduje minimálně Java 8, doporučena je Java 11 nebo novější. Ověřte, že vaše instalace zobrazuje \u0026ldquo;mixed mode\u0026rdquo; (nikoli \u0026ldquo;interpreted mode\u0026rdquo;):\njava -version Mělo by se zobrazit: OpenJDK nebo Oracle Java, verze 8+, \u0026ldquo;mixed mode\u0026rdquo;\nVyhněte se: GNU GCJ, zastaralým implementacím Javy, pouze interpretovaným režimům\nBěžné konflikty portů nastávají, když se více služeb přetahuje o výchozí porty I2P. Konzole routeru (7657), I2CP (7654), SAM (7656) a HTTP proxy (4444) musí být volné. Zkontrolujte konflikty: netstat -ano | findstr \u0026quot;7657 4444 7654\u0026quot; (Windows) nebo lsof -i :7657,4444,7654 (Linux/Mac).\nPoškození konfiguračního souboru se projevuje jako okamžité pády s chybami parsování v logech. Router.config vyžaduje kódování UTF-8 bez BOM, používá = jako oddělovač (nikoli :) a zakazuje určité speciální znaky. Zálohujte a poté zkontrolujte: ~/.i2p/router.config (Linux), %LOCALAPPDATA%\\I2P\\router.config (Windows), ~/Library/Application Support/i2p/router.config (macOS).\nPro resetování konfigurace při zachování identity: Zastavte I2P, zálohujte router.keys a adresář keyData, smažte router.config a restartujte. Router znovu vygeneruje výchozí konfiguraci.\nPříliš nízké přidělení haldy Javy způsobuje pády s chybou OutOfMemoryError (chyba nedostatku paměti). Upravte wrapper.config a zvyšte wrapper.java.maxmemory z výchozích 128 nebo 256 na minimálně 512 (1024 pro routery s vysokou šířkou pásma). To vyžaduje úplné vypnutí, vyčkání 11 minut a poté restart - kliknutí na \u0026ldquo;Restart\u0026rdquo; v konzoli změnu neaplikuje.\nŘešení stavu \u0026ldquo;Network: Firewalled\u0026rdquo; Stav blokovaný firewallem znamená, že router nemůže přijímat přímá příchozí spojení, což nutí spoléhat se na introducers (uzly zprostředkovávající navázání příchozího spojení). I když router v tomto stavu funguje, výkon se výrazně zhoršuje a přínos pro síť zůstává minimální. Dosažení stavu bez blokování firewallem vyžaduje správné přesměrování portů.\nRouter náhodně vybere port v rozmezí 9000-31000 pro komunikaci. Svůj port najdete na http://127.0.0.1:7657/confignet - hledejte \u0026ldquo;UDP Port\u0026rdquo; a \u0026ldquo;TCP Port\u0026rdquo; (obvykle stejné číslo). Pro optimální výkon musíte přesměrovat porty pro jak UDP, tak TCP, i když samotné UDP umožňuje základní funkčnost.\nPovolit automatické přesměrování portů přes UPnP (nejjednodušší metoda):\nPřejděte na http://127.0.0.1:7657/confignet Zaškrtněte \u0026ldquo;Enable UPnP\u0026rdquo; Uložte změny a restartujte router Počkejte 5-10 minut a ověřte, že se stav změní z \u0026ldquo;Network: Firewalled\u0026rdquo; na \u0026ldquo;Network: OK\u0026rdquo; UPnP vyžaduje podporu ze strany routeru (která je ve výchozím nastavení povolena u většiny spotřebitelských routerů vyrobených po roce 2010) a správnou konfiguraci sítě.\nRuční přesměrování portů (vyžaduje se, pokud selže UPnP):\nPoznamenejte si svůj port I2P z http://127.0.0.1:7657/confignet (např. 22648) Zjistěte svou místní IP adresu: ipconfig (Windows), ip addr (Linux), Předvolby systému → Síť (macOS) Otevřete administrační rozhraní routeru (obvykle 192.168.1.1 nebo 192.168.0.1) Přejděte do Port Forwarding (může být v části Advanced, NAT nebo Virtual Servers) Vytvořte dvě pravidla: External Port: [váš port I2P] → Internal IP: [váš počítač] → Internal Port: [stejný] → Protocol: UDP External Port: [váš port I2P] → Internal IP: [váš počítač] → Internal Port: [stejný] → Protocol: TCP Uložte konfiguraci a případně restartujte router Ověřte přesměrování portů pomocí online testovacích nástrojů po konfiguraci. Pokud zjišťování selže, zkontrolujte nastavení firewallu – jak systémový firewall, tak případný firewall antiviru musí povolit port I2P.\nAlternativa Hidden mode pro restriktivní sítě, kde není možné přesměrování portů: Povolte na http://127.0.0.1:7657/confignet → zaškrtněte \u0026ldquo;Hidden mode\u0026rdquo;. Router zůstane za firewallem, ale optimalizuje se pro tento stav tím, že bude výhradně používat SSU introducers (zprostředkovatele SSU). Výkon bude pomalejší, ale funkční.\nRouter uvízl ve stavu \u0026ldquo;Spouštění\u0026rdquo; nebo \u0026ldquo;Testování\u0026rdquo; Tyto přechodné stavy během počátečního bootstrapu se obvykle vyřeší do 10-15 minut u nových instalací nebo 3-5 minut u zavedených routers. Předčasný zásah často problémy zhoršuje.\n\u0026ldquo;Network: Testing\u0026rdquo; označuje, že router ověřuje dosažitelnost prostřednictvím různých typů připojení (přímé, introducers (zprostředkovatelé), více verzí protokolu). To je normální během prvních 5–10 minut po spuštění. Router testuje více scénářů, aby určil optimální konfiguraci.\n\u0026ldquo;Rejecting tunnels: starting up\u0026rdquo; se zobrazuje během bootstrapu, když router nemá dostatek informací o peerech. Router nebude přeposílat provoz, dokud nebude dostatečně integrován. Tato zpráva by měla zmizet po 10-20 minutách, jakmile bude v netDb 50+ routers.\nOdchylka hodin znemožňuje testování dosažitelnosti. I2P vyžaduje, aby systémový čas byl v odchylce ±60 sekund vůči síťovému času. Rozdíl přesahující 90 sekund způsobí automatické odmítnutí spojení. Synchronizujte systémové hodiny:\nLinux: sudo timedatectl set-ntp true \u0026amp;\u0026amp; sudo systemctl restart systemd-timesyncd\nWindows: Ovládací panely → Datum a čas → Internetový čas → Aktualizovat nyní → Povolit automatickou synchronizaci\nmacOS: Předvolby systému → Datum a čas → Povolte \u0026ldquo;Nastavit datum a čas automaticky\u0026rdquo;\nPo opravě odchylky systémového času úplně restartujte I2P pro správnou integraci.\nNedostatečné přidělení šířky pásma brání úspěšnému testování. Router potřebuje dostatečnou kapacitu pro sestavení testovacích tunnels. Nastavte na http://127.0.0.1:7657/config:\nMinimální použitelné: Příchozí 96 KB/sec, Odchozí 64 KB/sec Doporučený standard: Příchozí 256 KB/sec, Odchozí 128 KB/sec Optimální výkon: Příchozí 512+ KB/sec, Odchozí 256+ KB/sec Procento sdílení: 80% (umožňuje, aby router přispíval šířkou pásma do sítě) Nižší šířka pásma může sice fungovat, ale prodlužuje dobu integrace z minut na hodiny.\nPoškozená netDb v důsledku nesprávného vypnutí nebo chyb disku způsobuje neustálé testovací smyčky. Router nemůže dokončit testování bez platných dat o uzlech:\n# Stop I2P completely i2prouter stop # or systemctl stop i2p # Delete corrupted database (safe - will reseed automatically) rm -rf ~/.i2p/netDb/* # Restart and allow 10-15 minutes for reseed i2prouter start Windows: Odstraňte obsah %APPDATA%\\I2P\\netDb\\ nebo %LOCALAPPDATA%\\I2P\\netDb\\\nFirewall blokující reseed (počáteční získávání peerů) znemožňuje získání počátečních peerů. Během bootstrapu I2P načítá informace o routeru z HTTPS reseed serverů. Firewally v korporátních sítích nebo u ISP mohou tato spojení blokovat. Nastavte reseed proxy na adrese http://127.0.0.1:7657/configreseed, pokud se nacházíte v restriktivní síti.\nNízké rychlosti, vypršení časových limitů a selhání při vytváření tunnelů Architektura I2P přirozeně vede k 3-10x pomalejším rychlostem než clearnet (běžný otevřený internet) kvůli vícehopovému šifrování, režii paketů a nepředvídatelnosti tras. Při sestavení tunnelu se prochází více routerů, z nichž každý přidává latenci. Pochopení toho pomáhá předejít záměně normálního chování za problémy.\nTypická očekávání ohledně výkonu:\nProhlížení .i2p webů: zpočátku se stránky načítají 10-30 sekund, rychlejší, jakmile jsou tunnel vytvořeny Torrentování přes I2PSnark: 10-100 KB/s na torrent podle počtu seederů a podmínek sítě Stahování velkých souborů: vyžaduje trpělivost - soubory v řádu megabajtů mohou trvat minuty, v řádu gigabajtů hodiny První připojení je nejpomalejší: budování tunnel trvá 30-90 sekund; následující připojení používají existující tunnels Míra úspěšnosti sestavování tunnelů naznačuje zdraví sítě. Zkontrolujte na http://127.0.0.1:7657/tunnels:\nNad 60%: Normální, zdravý provoz 40-60%: Hraniční, zvažte navýšení šířky pásma nebo snížení zátěže Pod 40%: Problematické - naznačuje nedostatečnou šířku pásma, síťové problémy nebo špatný výběr peerů Zvyšte přidělení šířky pásma jako první krok optimalizace. Většina problémů s pomalým výkonem pramení z nedostatku šířky pásma. Na adrese http://127.0.0.1:7657/config limity navyšujte postupně a sledujte grafy na http://127.0.0.1:7657/graphs.\nPro DSL/Kabel (1-10 Mbps připojení): - Příchozí: 400 KB/sec - Odchozí: 200 KB/sec - Sdílení: 80% - Paměť: 384 MB (upravte wrapper.config)\nPro vysokorychlostní (10-100+ Mbps připojení): - Příchozí: 1500 KB/sec - Odchozí: 1000 KB/sec - Sdílení: 80-100% - Paměť: 512-1024 MB - Zvažte: Zvyšte počet participating tunnels (účastnické tunely) na 2000-5000 na adrese http://127.0.0.1:7657/configadvanced\nOptimalizujte konfiguraci tunnel pro lepší výkon. Otevřete konkrétní nastavení tunnel na http://127.0.0.1:7657/i2ptunnel a upravte každý tunnel:\nPočet Tunnel: Zvyšte z 2 na 3-4 (více dostupných cest) Počet záloh: Nastavte na 1-2 (rychlé přepnutí při selhání tunnel) Délka Tunnel: Výchozí 3 skoky poskytují dobrou rovnováhu; snížení na 2 zlepší rychlost, ale sníží anonymitu Nativní kryptografická knihovna (jbigi) poskytuje 5-10x lepší výkon než šifrování implementované čistě v Javě. Ověřte, že je načtená, na http://127.0.0.1:7657/logs - hledejte \u0026ldquo;jbigi loaded successfully\u0026rdquo; nebo \u0026ldquo;Using native CPUID implementation\u0026rdquo;. Pokud chybí:\nLinux: Obvykle automaticky detekováno a načteno z ~/.i2p/jbigi-*.so Windows: Zkontrolujte jbigi.dll v instalačním adresáři I2P Pokud chybí: Nainstalujte nástroje pro sestavení a zkompilujte ze zdrojového kódu, nebo stáhněte předkompilované binární soubory z oficiálních repozitářů\nNechte router běžet nepřetržitě. Každý restart resetuje integraci do sítě a vyžaduje 30-60 minut na znovuvybudování sítě tunnel a vztahů s peery. Stabilní routery s vysokou dobou provozu jsou při stavbě tunnel vybírány přednostně, což vytváří pozitivní zpětnou vazbu pro výkon.\nVysoké využití procesoru a paměti Nadměrné využití prostředků obvykle naznačuje nedostatečné přidělení paměti, chybějící nativní kryptografické knihovny nebo nadměrné zapojení do účasti v síti. Dobře nakonfigurovaný router by měl během aktivního používání využívat 10-30% CPU a udržovat stabilní využití paměti pod 80% přiděleného heapu.\nProblémy s pamětí se projevují následovně: - Paměťové grafy s „plochým vrcholem“ (držené na maximu) - Častá garbage collection (odklízení paměti) (pilovitý průběh se strmými poklesy) - OutOfMemoryError v logech - Router při zátěži přestává reagovat - Automatické vypnutí kvůli vyčerpání prostředků\nZvyšte alokaci haldy Javy v wrapper.config (vyžaduje úplné vypnutí):\n# Linux: ~/.i2p/wrapper.config # Windows: %APPDATA%\\I2P\\wrapper.config # Find and modify: wrapper.java.maxmemory=512 # Recommendations by usage: # Light browsing only: 256 # Standard use (browsing + light torrenting): 512 # Heavy use (multiple applications, active torrenting): 768-1024 # Floodfill or very high bandwidth: 1024-2048 Kritické: Po úpravě wrapper.config musíte zcela vypnout (ne restartovat), počkejte 11 minut na korektní ukončení a poté spusťte načisto. Tlačítko \u0026ldquo;Restart\u0026rdquo; v Router console nenačte znovu nastavení wrapperu.\nOptimalizace CPU vyžaduje nativní kryptografickou knihovnu. Operace s BigInteger v čisté Javě spotřebují 10–20× více CPU než nativní implementace. Ověřte stav jbigi na http://127.0.0.1:7657/logs během spouštění. Bez jbigi CPU vyskočí na 50–100 % během budování tunnel a šifrovacích operací.\nSnižte zátěž participujících tunnel pokud je router přetížen:\nPřejděte na http://127.0.0.1:7657/configadvanced Nastavte router.maxParticipatingTunnels=1000 (výchozí 8000) Snižte procento sdílení na http://127.0.0.1:7657/config z 80% na 50% Vypněte režim floodfill, pokud je povolen: router.floodfillParticipant=false Omezte šířku pásma I2PSnark a počet současně běžících torrentů. Torrentování spotřebovává značné prostředky. Na adrese http://127.0.0.1:7657/i2psnark:\nOmezte počet aktivních torrentů na maximálně 3–5 Nastavte \u0026ldquo;Up BW Limit\u0026rdquo; a \u0026ldquo;Down BW Limit\u0026rdquo; na rozumné hodnoty (každý 50–100 KB/sec) Zastavte torrenty, když je zrovna nepotřebujete Vyhněte se seedování desítek torrentů najednou Sledujte využití prostředků pomocí vestavěných grafů na http://127.0.0.1:7657/graphs. Paměť by měla vykazovat rezervu, ne plochý strop. Špičky CPU během vytváření tunnel jsou normální; dlouhodobě vysoké využití CPU naznačuje problémy s konfigurací.\nPro systémy s výrazně omezenými prostředky (Raspberry Pi, starší hardware) zvažte i2pd (implementace v C++) jako alternativu. i2pd vyžaduje ~130 MB RAM oproti 350+ MB u Java I2P a při podobné zátěži používá ~7% CPU oproti 70%. Mějte na paměti, že i2pd nemá vestavěné aplikace a vyžaduje externí nástroje.\nProblémy s torrenty v I2PSnarku Integrace I2PSnark s architekturou I2P router vyžaduje pochopení, že torrentování závisí zcela na zdraví router tunnel. Torrenty se nespustí, dokud router nedosáhne dostatečné integrace s 10+ aktivními peery a funkčními tunnels.\nTorrenty zaseknuté na 0 % obvykle naznačují:\nRouter není plně integrován: Po spuštění I2P počkejte 10-15 minut, než se objeví aktivita torrentů DHT je vypnuté: Povolte na http://127.0.0.1:7657/i2psnark → Configuration → zaškrtněte \u0026ldquo;Enable DHT\u0026rdquo; (ve výchozím nastavení povoleno od verze 0.9.2) Neplatné nebo nefunkční trackery: Torrenty v I2P vyžadují trackery specifické pro I2P - trackery z clearnet (veřejný internet) nebudou fungovat Nedostatečná konfigurace tunnel: Zvyšte počet tunnel v I2PSnark Configuration → sekci Tunnels Nakonfigurujte I2PSnark tunnels pro lepší výkon:\nPříchozí tunnels: 3-5 (výchozí 2 pro Java I2P, 5 pro i2pd) Odchozí tunnels: 3-5 Délka tunnels: 3 skoky (snižte na 2 pro vyšší rychlost, nižší anonymita) Počet tunnels: 3 (zajišťuje stabilní výkon) Nezbytné I2P torrentové trackery k zahrnutí: - tracker2.postman.i2p (primární, nejspolehlivější) - w7tpbzncbcocrqtwwm3nezhnnsw4ozadvi2hmvzdhrqzfxfum7wa.b32.i2p/a\nOdstraňte všechny clearnet trackery (non-.i2p; veřejný internet) - nepřinášejí žádný užitek a vedou k pokusům o připojení, které končí vypršením časového limitu.\nChyby \u0026ldquo;Torrent not registered\u0026rdquo; nastávají, když selže komunikace s trackerem. Klikněte pravým tlačítkem na torrent → \u0026ldquo;Start\u0026rdquo; vynutí opětovné ohlášení u trackeru. Pokud to přetrvává, ověřte dostupnost trackeru návštěvou http://tracker2.postman.i 2p v prohlížeči nakonfigurovaném pro I2P. Mrtvé trackery nahraďte funkčními alternativami.\nŽádní vrstevníci (peers) se nepřipojují přestože tracker funguje, naznačuje, že: - Router za firewallem (zlepší se s přesměrováním portů, ale není vyžadováno) - Nedostatečná šířka pásma (zvyšte na 256+ KB/sec) - Roj je příliš malý (některé torrenty mají 1-2 seedeři; je třeba trpělivost) - DHT je vypnuté (povolte pro vyhledávání vrstevníků bez trackeru)\nPovolte DHT a PEX (Peer Exchange – výměna peerů) v nastavení I2PSnark. DHT umožňuje nalézat peery bez závislosti na trackeru. PEX zjišťuje peery prostřednictvím již připojených peerů, což urychluje objevování roje.\nPoškození stažených souborů se díky vestavěné kontrole integrity v I2PSnarku vyskytuje jen zřídka. Pokud je zjištěno:\nKlikněte pravým tlačítkem na torrent → \u0026ldquo;Zkontrolovat\u0026rdquo; vynutí opětovné přepočítání hashů všech částí Smažte poškozená data torrentu (ponechá soubor .torrent) Klikněte pravým tlačítkem → \u0026ldquo;Spustit\u0026rdquo; pro opětovné stažení s ověřováním částí Zkontrolujte disk na chyby, pokud poškození přetrvává: chkdsk (Windows), fsck (Linux) Nefunkční sledovaná složka vyžaduje správné nastavení:\nKonfigurace I2PSnark → \u0026ldquo;Sledovaný adresář\u0026rdquo;: Nastavte absolutní cestu (např. /home/user/torrents/watch) Ujistěte se, že proces I2P má oprávnění ke čtení: chmod 755 /path/to/watch Umístěte soubory .torrent do sledovaného adresáře - I2PSnark je automaticky přidá Nastavte \u0026ldquo;Automatické spuštění\u0026rdquo;: Zaškrtněte, mají-li se torrenty spouštět ihned po přidání Optimalizace výkonu pro torrentování:\nOmezte současně aktivní torrenty: maximálně 3-5 pro standardní připojení Upřednostněte důležité stahování: Dočasně zastavte torrenty s nízkou prioritou Zvyšte přidělení šířky pásma pro router: Více šířky pásma = lepší výkon torrentů Buďte trpěliví: torrentování v I2P je ze své podstaty pomalejší než BitTorrent na clearnetu (veřejném internetu) Seedujte po dokončení stahování: Síť prosperuje díky reciprocitě Git přes I2P konfigurace a odstraňování problémů Operace Gitu přes I2P vyžadují buď konfiguraci SOCKS proxy, nebo dedicated I2P tunnels pro přístup přes SSH/HTTP. Návrh Gitu předpokládá spojení s nízkou latencí, což činí architekturu I2P s vysokou latencí náročnou.\nNakonfigurujte Git tak, aby používal I2P SOCKS proxy:\nUpravte ~/.ssh/config (vytvořte, pokud neexistuje):\nHost *.i2p ProxyCommand nc -X 5 -x 127.0.0.1:4447 %h %p ServerAliveInterval 60 ServerAliveCountMax 3 Compression yes Tím se směrují všechna připojení SSH na hosty .i2p přes SOCKS proxy I2P (port 4447). Nastavení ServerAlive udržují spojení i při latenci I2P.\nPro operace gitu přes HTTP/HTTPS nakonfigurujte git globálně:\ngit config --global http.proxy socks5h://127.0.0.1:4447 git config --global https.proxy socks5h://127.0.0.1:4447 Poznámka: socks5h provádí rozlišení DNS přes proxy - zásadní pro domény .i2p.\nVytvořte vyhrazený I2P tunnel pro Git SSH (spolehlivější než SOCKS):\nPřejděte na http://127.0.0.1:7657/i2ptunnel \u0026ldquo;Nový klientský tunnel\u0026rdquo; → \u0026ldquo;Standard\u0026rdquo; Nakonfigurujte: Název: Git-SSH Typ: Klient Port: 2222 (lokální port pro přístup ke Gitu) Cíl: [your-git-server].i2p:22 Automatické spuštění: Zapnuto Počet tunnelů: 3-4 (vyšší pro spolehlivost) Uložte a spusťte tunnel Nastavte SSH tak, aby používalo tunnel: ssh -p 2222 git@127.0.0.1 Chyby autentizace SSH přes I2P obvykle pramení z:\nKlíč není přidán do ssh-agentu: ssh-add ~/.ssh/id_rsa Nesprávná oprávnění souboru s klíčem: chmod 600 ~/.ssh/id_rsa Tunnel neběží: Ověřte na http://127.0.0.1:7657/i2ptunnel, že je stav zelený Git server vyžaduje konkrétní typ klíče: Vygenerujte klíč ed25519, pokud RSA selže Vypršení časového limitu u operací Git souvisí s charakteristikami latence I2P:\nZvyšte časový limit Gitu: git config --global http.postBuffer 524288000 (vyrovnávací paměť 500 MB) Zvyšte limit nízké rychlosti: git config --global http.lowSpeedLimit 1000 a git config --global http.lowSpeedTime 600 (čeká 10 minut) Pro počáteční klonování použijte shallow clone (mělký klon): git clone --depth 1 [url] (stáhne pouze poslední commit, rychlejší) Klonujte v obdobích nižší aktivity: Přetížení sítě ovlivňuje výkon I2P Pomalé operace git clone/fetch vyplývají z architektury I2P. Repozitář o velikosti 100MB může přes I2P trvat 30-60 minut, zatímco na clearnetu (veřejném internetu) jen sekundy. Strategie:\nPoužijte mělké klony: --depth 1 výrazně snižuje počáteční objem přenesených dat Načítejte postupně: Místo úplného klonování načítejte konkrétní větve: git fetch origin branch:branch Zvažte rsync přes I2P: U velmi velkých repozitářů může rsync dosahovat lepšího výkonu Zvyšte počet tunnel (tunelů): Vyšší počet poskytne lepší propustnost při dlouhotrvajících velkých přenosech Chyby \u0026ldquo;Connection refused\u0026rdquo; naznačují nesprávné nastavení tunnelu:\nOvěřte, že I2P router běží: Zkontrolujte http://127.0.0.1:7657 Potvrďte, že tunnel je aktivní a zelený na http://127.0.0.1:7657/i2ptunnel Otestujte tunnel: nc -zv 127.0.0.1 2222 (mělo by se připojit, pokud tunnel funguje) Zkontrolujte, zda je cíl dostupný: Otevřete v prohlížeči HTTP rozhraní cíle, pokud je k dispozici Zkontrolujte logy tunnelu na http://127.0.0.1:7657/logs kvůli konkrétním chybám Osvědčené postupy pro Git přes I2P:\nUdržujte I2P router v nepřetržitém provozu pro stabilní přístup k Git repozitářům Používejte klíče SSH místo ověřování heslem (méně interaktivních výzev) Nakonfigurujte trvalé tunnels namísto dočasných připojení SOCKS Zvažte hostování vlastního I2P git serveru pro lepší kontrolu Zdokumentujte své .i2p git koncové body pro spolupracovníky Přístup k eepsites a překlad domén .i2p Nejčastějším důvodem, proč uživatelé nemohou přistupovat ke stránkám .i2p, je nesprávná konfigurace proxy v prohlížeči. Stránky I2P existují pouze v rámci sítě I2P a vyžadují směrování přes HTTP proxy I2P.\nPřesně nakonfigurujte nastavení proxy v prohlížeči:\nFirefox (doporučeno pro I2P):\nMenu → Nastavení → Síťová nastavení → tlačítko Nastavení Vyberte \u0026ldquo;Ruční nastavení proxy\u0026rdquo; HTTP proxy: 127.0.0.1 Port: 4444 SSL proxy: 127.0.0.1 Port: 4444 SOCKS proxy: 127.0.0.1 Port: 4447 (volitelné, pro aplikace SOCKS) Zaškrtněte \u0026ldquo;Proxy DNS při použití SOCKS v5\u0026rdquo; OK pro uložení Zásadní nastavení about:config ve Firefoxu:\nPřejděte na about:config a upravte:\nmedia.peerconnection.ice.proxy_only = true (zabraňuje únikům IP přes WebRTC) keyword.enabled = false (zabraňuje přesměrování adres .i2p na vyhledávače) network.proxy.socks_remote_dns = true (DNS přes proxy) Omezení pro Chrome/Chromium:\nChrome používá systémová nastavení proxy, nikoli nastavení specifická pro aplikaci. Ve Windows: Nastavení → vyhledejte \u0026ldquo;proxy\u0026rdquo; → \u0026ldquo;Otevřít nastavení proxy vašeho počítače\u0026rdquo; → Nastavte HTTP: 127.0.0.1:4444 a HTTPS: 127.0.0.1:4445.\nLepší postup: Použijte rozšíření FoxyProxy nebo Proxy SwitchyOmega pro selektivní směrování domén .i2p.\n\u0026ldquo;Website Not Found In Address Book\u0026rdquo; chyby znamenají, že routeru chybí kryptografická adresa domény .i2p. I2P používá místní adresáře místo centralizovaného DNS. Řešení:\nMetoda 1: Použijte jump služby (nejjednodušší pro nové stránky):\nPřejděte na http://stats.i 2p a vyhledejte daný web. Klikněte na odkaz addresshelper: http://example.i2p/?i2paddresshelper=base64destination. Váš prohlížeč zobrazí „Save to addressbook?“ – potvrďte pro přidání.\nMetoda 2: Aktualizujte odběry adresáře:\nPřejděte na http://127.0.0.1:7657/dns (SusiDNS) Klikněte na záložku \u0026ldquo;Subscriptions\u0026rdquo; Ověřte aktivní odběry (výchozí: http://i2p-projekt.i 2p/hosts.txt) Přidejte doporučené odběry: http://stats.i 2p/cgi-bin/newhosts.txt http://notbob.i 2p/hosts.txt http://reg.i 2p/export/hosts.txt Klikněte na \u0026ldquo;Update Now\u0026rdquo; pro vynucení okamžité aktualizace odběrů Počkejte 5-10 minut na zpracování Metoda 3: Použijte adresy base32 (vždy funguje, pokud je stránka online):\nKaždý .i2p web má adresu Base32: 52 náhodných znaků následovaných .b32.i2p (např. ukeu3k5oycgaauneqgtnvselmt4yemvoilkln7jpvamvfx7dnkdq.b32.i2p). Adresy Base32 obcházejí adresář - router provádí přímé kryptografické vyhledání.\nBěžné chyby v konfiguraci prohlížeče:\nPokus o HTTPS na webech pouze s HTTP: Většina .i2p webů používá pouze HTTP - pokus o https://example.i2p selže Zapomenutí prefixu http://: Prohlížeč může místo připojení vyhledávat - vždy použijte http://example.i2p WebRTC zapnuté: Může prozradit skutečnou IP adresu - zakažte ho v nastavení Firefoxu nebo pomocí rozšíření DNS není přes proxy: Clearnet (veřejný internet) DNS neumí přeložit .i2p - je nutné posílat DNS dotazy přes proxy Špatný port proxy: 4444 pro HTTP (ne 4445, který je HTTPS outproxy do clearnetu) Router není plně integrován znemožňuje přístup na jakékoli weby. Ověřte, že je integrace dostatečná:\nZkontrolujte, že http://127.0.0.1:7657 zobrazuje \u0026ldquo;Network: OK\u0026rdquo; nebo \u0026ldquo;Network: Firewalled\u0026rdquo; (ne \u0026ldquo;Network: Testing\u0026rdquo;) Active peers zobrazuje minimálně 10 (optimálně 50+) Žádná zpráva \u0026ldquo;Rejecting tunnels: starting up\u0026rdquo; Počkejte plných 10-15 minut po spuštění routeru, než budete očekávat přístup k .i2p Konfigurace IRC a e-mailového klienta se řídí podobnými vzory nastavení proxy:\nIRC: Klienti se připojují k 127.0.0.1:6668 (IRC proxy tunnel v I2P). Vypněte v IRC klientu nastavení proxy - připojení na localhost:6668 už je vedeno přes I2P.\nE-mail (Postman): - SMTP: 127.0.0.1:7659 - POP3: 127.0.0.1:7660 - Bez SSL/TLS (šifrování zajišťuje I2P tunnel) - Přihlašovací údaje z registrace účtu na postman.i2p\nVšechny tyto tunnels musí na http://127.0.0.1:7657/i2ptunnel zobrazovat stav \u0026ldquo;running\u0026rdquo; (zelený).\nSelhání instalace a problémy s balíčky Instalace z balíčků (Debian, Ubuntu, Arch) občas selhávají kvůli změnám v repozitářích, vypršení platnosti klíče GPG nebo konfliktům závislostí. Oficiální repozitáře se v novějších verzích změnily z deb.i2p2.de/deb.i2p2.no (ukončená podpora) na deb.i2p.net.\nAktualizujte repozitář Debian/Ubuntu na aktuální stav:\n# Remove old repository entries sudo rm /etc/apt/sources.list.d/i2p.list # Add current repository echo \u0026#34;deb [signed-by=/usr/share/keyrings/i2p-archive-keyring.gpg] https://deb.i2p.net/ $(lsb_release -sc) main\u0026#34; | sudo tee /etc/apt/sources.list.d/i2p.list # Download and install current signing key curl -o i2p-archive-keyring.gpg https://geti2p.net/_static/i2p-archive-keyring.gpg sudo cp i2p-archive-keyring.gpg /usr/share/keyrings/ # Update and install sudo apt update sudo apt install i2p i2p-keyring Selhání ověřování podpisů GPG nastávají, když klíče repozitáře vyprší nebo se změní:\n# Error: \u0026#34;The following signatures were invalid\u0026#34; # Solution: Install current keyring package sudo apt install i2p-keyring # Manual key import if package unavailable wget https://geti2p.net/_static/i2p-debian-repo.key.asc sudo apt-key add i2p-debian-repo.key.asc Služba se po instalaci balíčku nespustí – nejčastěji je to způsobeno problémy s profilem AppArmor na Debianu/Ubuntu:\n# Check service status sudo systemctl status i2p.service # Common error: \u0026#34;Failed at step APPARMOR spawning\u0026#34; # Solution: Reconfigure without AppArmor sudo dpkg-reconfigure -plow i2p # Select \u0026#34;No\u0026#34; for AppArmor when prompted # Alternative: Set profile to complain mode sudo aa-complain /usr/sbin/wrapper # Check logs for specific errors sudo journalctl -xe -u i2p.service Problémy s oprávněními u I2P nainstalovaného z balíčku:\n# Fix ownership (package install uses \u0026#39;i2psvc\u0026#39; user) sudo chown -R i2psvc:i2psvc /var/lib/i2p /var/log/i2p /run/i2p sudo chmod 750 /var/log/i2p /var/lib/i2p # Set file descriptor limits (add to /etc/security/limits.conf) i2psvc soft nofile 4096 i2psvc hard nofile 8192 Problémy s kompatibilitou Javy:\nI2P 2.10.0 vyžaduje minimálně Javu 8. Starší systémy mohou mít Javu 7 nebo starší:\n# Check Java version java -version # Install appropriate Java (Debian/Ubuntu) sudo apt install openjdk-11-jre-headless # Set default Java if multiple versions installed sudo update-alternatives --config java Chyby konfigurace Wrapperu (nástroj pro spouštění služeb) zabraňují spuštění služby:\nUmístění Wrapper.config se liší podle metody instalace: - Uživatelská instalace: ~/.i2p/wrapper.config - Instalace z balíčku: /etc/i2p/wrapper.config nebo /var/lib/i2p/wrapper.config\nČasté problémy s wrapper.config:\nNesprávné cesty: wrapper.java.command musí ukazovat na platnou instalaci Javy Nedostatečná paměť: wrapper.java.maxmemory je nastaveno příliš nízko (zvyšte na 512+) Nesprávné umístění pidfile (soubor PID): wrapper.pidfile musí ukazovat na zapisovatelné umístění Chybí binární soubor wrapperu: Na některých platformách chybí předkompilovaný wrapper (použijte záložní variantu runplain.sh) Selhání aktualizací a poškozené aktualizace:\nAktualizace konzole routeru mohou občas uprostřed stahování selhat kvůli výpadkům sítě. Postup ruční aktualizace:\nStáhněte si i2pupdate_X.X.X.zip z https://geti2p.net/en/download Ověřte, že kontrolní součet SHA256 odpovídá zveřejněné hodnotě hash Zkopírujte do instalačního adresáře I2P jako i2pupdate.zip Restartujte router - automaticky detekuje a rozbalí aktualizaci Počkejte 5-10 minut na instalaci aktualizace Ověřte novou verzi na http://127.0.0.1:7657 Migrace z velmi starých verzí (před 0.9.47) na aktuální verze může selhat kvůli nekompatibilním podpisovým klíčům nebo odebraným funkcím. Jsou nutné postupné aktualizace:\nVerze starší než 0.9.9: Nelze ověřit aktuální podpisy - je nutná ruční aktualizace Verze na Javě 6/7: Před aktualizací I2P na 2.x je nutné nejprve aktualizovat Javu Velké skoky mezi hlavními verzemi: Nejprve aktualizujte na mezilehlou verzi (doporučený mezikrok 0.9.47) Kdy použít instalátor vs. balíček:\nBalíčky (apt/yum): Nejlepší pro servery, automatické bezpečnostní aktualizace, systémová integrace, správa systemd Instalátor (.jar): Nejlepší pro instalaci na úrovni uživatele, Windows, macOS, vlastní instalace, dostupnost nejnovější verze Poškození konfiguračního souboru a jeho obnova Trvalé uložení konfigurace I2P se opírá o několik zásadních souborů. Poškození obvykle vzniká v důsledku nesprávného vypnutí, chyb disku nebo chyb při ručních úpravách. Pochopení účelu jednotlivých souborů umožňuje cílenou opravu namísto úplné přeinstalace.\nKritické soubory a jejich účely:\nrouter.keys (516+ bajtů): Kryptografická identita routeru - ztráta tohoto souboru vytvoří novou identitu router.info (automaticky generováno): Publikované informace o routeru - bezpečné smazat, znovu se vygeneruje router.config (text): Hlavní konfigurace - šířka pásma, síťová nastavení, předvolby i2ptunnel.config (text): Definice tunnelů - client/server tunnely, klíče, destinace netDb/ (adresář): Databáze peerů - informace o routerech účastníků sítě peerProfiles/ (adresář): Statistiky výkonu peerů - ovlivňují výběr tunnelů keyData/ (adresář): Klíče destinací pro eepsites a služby - ztráta změní adresy addressbook/ (adresář): Místní mapování názvů hostitelů .i2p Kompletní postup zálohování před provedením změn:\n# Stop I2P first i2prouter stop # or: systemctl stop i2p # Backup directory BACKUP_DIR=~/i2p-backup-$(date +%Y%m%d-%H%M) mkdir -p $BACKUP_DIR # Copy critical files cp -r ~/.i2p/router.keys $BACKUP_DIR/ cp -r ~/.i2p/*.config $BACKUP_DIR/ cp -r ~/.i2p/keyData $BACKUP_DIR/ cp -r ~/.i2p/addressbook $BACKUP_DIR/ cp -r ~/.i2p/eepsite $BACKUP_DIR/ # if hosting sites # Optional but recommended tar -czf $BACKUP_DIR.tar.gz $BACKUP_DIR Příznaky poškození Router.config:\nRouter se nespustí; v logech jsou chyby parsování Nastavení se po restartu neuchovají Objevují se neočekávané výchozí hodnoty Zkomolené znaky při zobrazení souboru Oprava poškozeného router.config:\nZálohujte stávající: cp router.config router.config.broken Zkontrolujte kódování souboru: Musí být UTF-8 bez BOM Ověřte syntaxi: Klíče používají oddělovač = (ne :), žádné koncové mezery u klíčů, # pouze pro komentáře Časté chyby: Znaky mimo ASCII v hodnotách, problémy s konci řádků (CRLF vs LF) Pokud nelze opravit: Smažte router.config - router vygeneruje výchozí router.config a zachová identitu Zásadní nastavení v router.config, která je třeba zachovat:\ni2np.bandwidth.inboundKBytesPerSecond=512 i2np.bandwidth.outboundKBytesPerSecond=256 router.updatePolicy=notify routerconsole.lang=en router.hiddenMode=false Ztracený nebo neplatný router.keys vytvoří novou identitu routeru. To je přijatelné, ledaže:\nProvozování floodfill (ztrácí status floodfill) Hostování eepsites s publikovanou adresou (ztrácí kontinuitu) Vybudovaná reputace v síti Obnova bez zálohy není možná – vygenerujte novou: smažte router.keys, restartujte I2P; vytvoří se nová identita.\nZásadní rozdíl: router.keys (identita) vs keyData/* (služby). Ztráta souboru router.keys změní identitu routeru. Ztráta souboru keyData/mysite-keys.dat změní .i2p adresu vašeho eepsite - katastrofální, pokud je adresa zveřejněna.\nZálohujte klíče pro eepsite/službu samostatně:\n# Identify your service keys ls -la ~/.i2p/keyData/ # Backup with descriptive names cp ~/.i2p/keyData/myservice-keys.dat ~/backups/myservice-keys-$(date +%Y%m%d).dat # Store securely (encrypted if sensitive) gpg -c ~/backups/myservice-keys-*.dat Poškození NetDb (síťová databáze) a peerProfiles (profily peerů):\nPříznaky: Žádné aktivní protějšky, nelze sestavit tunnels, \u0026ldquo;Zjištěno poškození databáze\u0026rdquo; v logech\nBezpečná oprava (vše se automaticky reseeduje (znovu získá počáteční seznam uzlů)/znovu sestaví):\ni2prouter stop rm -rf ~/.i2p/netDb/* rm -rf ~/.i2p/peerProfiles/* i2prouter start # Wait 10-15 minutes for reseed and integration Tyto adresáře obsahují pouze informace o síti uložené v mezipaměti - jejich smazání vynutí nový bootstrap (počáteční inicializační proces), ale nezpůsobí ztrátu žádných kritických dat.\nStrategie prevence:\nVždy provádějte korektní ukončení: Použijte i2prouter stop nebo tlačítko „Shutdown“ v router konzoli - nikdy proces neukončujte násilně Automatické zálohy: Cron úloha s týdenní zálohou ~/.i2p na samostatný disk Monitorování stavu disku: Průběžně kontrolujte stav SMART - selhávající disky poškozují data Dostatečné místo na disku: Udržujte alespoň 1+ GB volného místa - plné disky způsobují poškození dat UPS doporučena: Výpadky napájení během zápisu poškozují soubory Verzování kritických konfigurací: Git repozitář pro router.config, i2ptunnel.config umožňuje návrat k předchozím verzím Na oprávněních souborů záleží:\n# Correct permissions (user install) chmod 600 ~/.i2p/router.keys chmod 600 ~/.i2p/*.config chmod 700 ~/.i2p/keyData chmod 755 ~/.i2p # Never run as root - creates permission problems Vysvětlení běžných chybových hlášení Logování v I2P poskytuje konkrétní chybová hlášení, která přesně identifikují problémy. Porozumění těmto hlášením urychluje odstraňování problémů.\n\u0026ldquo;No tunnels available\u0026rdquo; se zobrazí, když router nesestavil dostatek tunnels pro provoz. To je normální během prvních 5-10 minut po spuštění. Pokud přetrvává déle než 15 minut:\nOvěřte, že Active Peers \u0026gt; 10 na http://127.0.0.1:7657 Zkontrolujte, že přidělení šířky pásma je dostatečné (128+ KB/sec minimum) Prozkoumejte míru úspěšnosti tunnelů na http://127.0.0.1:7657/tunnels (měla by být \u0026gt;40%) Zkontrolujte protokoly kvůli důvodům odmítnutí při sestavování tunnelů \u0026ldquo;Clock skew detected\u0026rdquo; nebo \u0026ldquo;NTCP2 disconnect code 7\u0026rdquo; znamená, že systémový čas se liší od síťového konsenzu o více než 90 sekund. I2P vyžaduje přesnost ±60 sekund. Připojení k routerům s odchýleným časem jsou automaticky odmítána.\nOpravit okamžitě:\n# Linux sudo timedatectl set-ntp true sudo systemctl restart systemd-timesyncd date # Verify correct time # Windows # Control Panel → Date and Time → Internet Time → Update now # Verify after sync http://127.0.0.1:7657/logs # Should no longer show clock skew warnings \u0026ldquo;Build timeout\u0026rdquo; nebo \u0026ldquo;Tunnel build timeout exceeded\u0026rdquo; znamená, že budování tunnelu skrze řetězec peerů nebylo dokončeno v rámci časového okna pro timeout (obvykle 60 sekund). Příčiny:\nPomalé uzly: Router vybral nereagující účastníky pro tunnel Přetížení sítě: Síť I2P je silně vytížená Nedostatečná šířka pásma: Vaše limity šířky pásma brání včasnému sestavení tunnel Přetížený router: Příliš mnoho zapojených tunnel spotřebovává prostředky Řešení: Zvyšte šířku pásma, snižte počet participujících tunnels (router.maxParticipatingTunnels na http://127.0.0.1:7657/configadvanced), povolte přesměrování portů pro lepší výběr peerů.\n\u0026ldquo;Router is shutting down\u0026rdquo; nebo \u0026ldquo;Graceful shutdown in progress\u0026rdquo; se může zobrazit během běžného ukončení nebo obnovy po pádu. Řízené ukončení (graceful shutdown) může trvat až 10 minut, protože router uzavírá tunnels, informuje protějšky a trvale ukládá stav.\nPokud zůstane ve stavu vypínání déle než 11 minut, vynutit ukončení:\n# Linux kill -9 $(pgrep -f i2p) # Windows taskkill /F /IM javaw.exe \u0026ldquo;java.lang.OutOfMemoryError: Java heap space\u0026rdquo; signalizuje vyčerpání paměťové haldy. Okamžitá řešení:\nUpravte wrapper.config: wrapper.java.maxmemory=512 (nebo vyšší) Je vyžadováno úplné vypnutí - restart změnu neuplatní Počkejte 11 minut na úplné vypnutí Spusťte router načisto Ověřte přidělení paměti na http://127.0.0.1:7657/graphs - měla by být vidět rezerva Související chyby paměti:\n\u0026ldquo;GC overhead limit exceeded\u0026rdquo;: Tráví se příliš mnoho času v garbage collection (uvolňování paměti) - zvyšte velikost haldy \u0026ldquo;Metaspace\u0026rdquo;: Metaspace (prostor pro metadata tříd v Javě) je vyčerpán - přidejte wrapper.java.additional.X=-XX:MaxMetaspaceSize=256M Specifické pro Windows: Kaspersky Antivirus omezuje paměťovou haldu Javy na 512MB bez ohledu na nastavení v wrapper.config - odinstalujte ho nebo přidejte I2P do výjimek.\n\u0026ldquo;Connection timeout\u0026rdquo; nebo \u0026ldquo;I2CP Error - port 7654\u0026rdquo;, když se aplikace pokoušejí připojit k routeru:\nOvěřte, že router běží: http://127.0.0.1:7657 by měl být dostupný Zkontrolujte port I2CP: netstat -an | grep 7654 by měl zobrazit LISTENING Ujistěte se, že firewall na localhostu povoluje: sudo ufw allow from 127.0.0.1 Ověřte, že aplikace používá správný port (I2CP=7654, SAM=7656) \u0026ldquo;Certificate validation failed\u0026rdquo; nebo \u0026ldquo;RouterInfo corrupt\u0026rdquo; během reseedu (počátečního bootstrapu sítě):\nKořenové příčiny: odchylka systémových hodin (nejprve opravte), poškozená netDb, neplatné certifikáty pro reseed (počáteční naplnění netDb z veřejných bootstrap serverů)\n# After fixing clock: i2prouter stop rm -rf ~/.i2p/netDb/* # Delete corrupted database i2prouter start # Auto-reseeds with fresh data \u0026ldquo;Database corruption detected\u0026rdquo; značí poškození dat na úrovni disku v netDb nebo peerProfiles:\n# Safe fix - all will rebuild i2prouter stop rm -rf ~/.i2p/netDb/* ~/.i2p/peerProfiles/* i2prouter start Zkontrolujte stav disku pomocí nástrojů SMART - opakované poškození dat naznačuje selhávající úložiště.\nVýzvy specifické pro platformu Různé operační systémy představují při nasazení I2P specifické výzvy související s oprávněními, bezpečnostními zásadami a systémovou integrací.\nProblémy s oprávněními a službami v Linuxu I2P nainstalované z balíčku běží jako systémový uživatel i2psvc (Debian/Ubuntu) nebo i2p (ostatní distribuce) a vyžaduje specifická oprávnění:\n# Fix package install permissions sudo chown -R i2psvc:i2psvc /var/lib/i2p /var/log/i2p /run/i2p sudo chmod 750 /var/log/i2p /var/lib/i2p sudo chmod 644 /var/lib/i2p/*.config # User install permissions (should be your user) chown -R $USER:$USER ~/.i2p chmod 700 ~/.i2p chmod 600 ~/.i2p/router.keys ~/.i2p/*.config Limity deskriptorů souborů ovlivňují kapacitu routeru pro spojení. Výchozí limity (1024) jsou nedostatečné pro routery s vysokou propustností:\n# Check current limits ulimit -n # Temporary increase ulimit -n 4096 # Permanent fix: Edit /etc/security/limits.conf i2psvc soft nofile 4096 i2psvc hard nofile 8192 # Systemd override sudo mkdir -p /etc/systemd/system/i2p.service.d/ sudo nano /etc/systemd/system/i2p.service.d/override.conf # Add: [Service] LimitNOFILE=8192 sudo systemctl daemon-reload sudo systemctl restart i2p Konflikty AppArmor běžné na Debianu/Ubuntu zabraňují spuštění služby:\n# Error: \u0026#34;Failed at step APPARMOR spawning /usr/sbin/wrapper\u0026#34; # Cause: AppArmor profile missing or misconfigured # Solution 1: Disable AppArmor for I2P sudo aa-complain /usr/sbin/wrapper # Solution 2: Reconfigure package without AppArmor sudo dpkg-reconfigure -plow i2p # Select \u0026#34;No\u0026#34; when asked about AppArmor # Solution 3: LXC/Proxmox containers - disable AppArmor in container config lxc.apparmor.profile: unconfined Problémy se SELinuxem na RHEL/CentOS/Fedora:\n# Temporary: Set permissive mode sudo setenforce 0 # Permanent: Generate custom policy sudo ausearch -c \u0026#39;java\u0026#39; --raw | audit2allow -M i2p_policy sudo semodule -i i2p_policy.pp # Or disable SELinux for I2P process (less secure) sudo semanage permissive -a i2p_t Řešení problémů se službou SystemD:\n# Detailed service status sudo systemctl status i2p.service -l # Full logs sudo journalctl -xe -u i2p.service # Follow logs live sudo journalctl -f -u i2p.service # Restart with logging sudo systemctl restart i2p.service \u0026amp;\u0026amp; sudo journalctl -f -u i2p.service Rušení brány firewall systému Windows a antiviru Windows Defender a antivirové produkty třetích stran často vyhodnocují I2P jako hrozbu kvůli vzorcům síťového chování. Správné nastavení brání zbytečným blokacím při zachování bezpečnosti.\nNakonfigurujte bránu firewall systému Windows Defender:\n# Run PowerShell as Administrator # Find Java path (adjust for your Java installation) $javaPath = \u0026#34;C:\\Program Files\\Eclipse Adoptium\\jdk-11.0.16.101-hotspot\\bin\\javaw.exe\u0026#34; # Create inbound rules New-NetFirewallRule -DisplayName \u0026#34;I2P Java\u0026#34; -Direction Inbound -Program $javaPath -Action Allow New-NetFirewallRule -DisplayName \u0026#34;I2P UDP\u0026#34; -Direction Inbound -Protocol UDP -LocalPort 22648 -Action Allow New-NetFirewallRule -DisplayName \u0026#34;I2P TCP\u0026#34; -Direction Inbound -Protocol TCP -LocalPort 22648 -Action Allow # Add exclusions to Windows Defender Add-MpPreference -ExclusionPath \u0026#34;C:\\Program Files\\i2p\u0026#34; Add-MpPreference -ExclusionPath \u0026#34;$env:APPDATA\\I2P\u0026#34; Add-MpPreference -ExclusionPath \u0026#34;$env:LOCALAPPDATA\\I2P\u0026#34; Add-MpPreference -ExclusionProcess \u0026#34;javaw.exe\u0026#34; Nahraďte port 22648 svým skutečným I2P portem z http://127.0.0.1:7657/confignet.\nSpecifický problém s Kaspersky Antivirus: „Application Control“ od Kaspersky omezuje haldu paměti Javy na 512 MB bez ohledu na nastavení v wrapper.config. To způsobuje OutOfMemoryError na routers s vysokou propustností.\nŘešení: 1. Přidejte I2P do vyloučení v Kaspersky: Nastavení → Další → Hrozby a vyloučení → Spravovat vyloučení 2. Nebo odinstalujte Kaspersky (doporučeno pro provoz I2P)\nObecná doporučení pro antivirový software třetích stran:\nPřidat instalační adresář I2P do výjimek Přidat %APPDATA%\\I2P a %LOCALAPPDATA%\\I2P do výjimek Vyloučit javaw.exe z analýzy chování Vypnout funkce \u0026ldquo;Network Attack Protection\u0026rdquo;, které mohou narušovat protokoly I2P Gatekeeper v macOS blokuje instalaci macOS Gatekeeper (bezpečnostní mechanismus macOS) brání spouštění nepodepsaných aplikací. Instalátory I2P nejsou podepsané pomocí Apple Developer ID, což vyvolává bezpečnostní varování.\nObejít Gatekeeper pro instalační program I2P:\n# Method 1: Remove quarantine attribute xattr -d com.apple.quarantine ~/Downloads/i2pinstall_*.jar java -jar ~/Downloads/i2pinstall_*.jar # Method 2: Use System Settings (macOS 13+) # Try to open installer → macOS blocks it # System Settings → Privacy \u0026amp; Security → scroll down # Click \u0026#34;Open Anyway\u0026#34; next to I2P warning # Confirm in dialog # Method 3: Control-click installer # Control-click (right-click) i2pinstall_*.jar # Select \u0026#34;Open\u0026#34; from menu → \u0026#34;Open\u0026#34; again in dialog # Bypasses Gatekeeper for this specific file Po instalaci spuštění může stále vyvolávat varování:\n# If I2P won\u0026#39;t start due to Gatekeeper: xattr -dr com.apple.quarantine ~/i2p/ Nikdy natrvalo nevypínejte Gatekeeper - bezpečnostní riziko pro ostatní aplikace. Používejte pouze výjimky pro jednotlivé soubory.\nKonfigurace firewallu v macOS:\nPředvolby systému → Zabezpečení a soukromí → Firewall → Možnosti firewallu Klikněte na \u0026ldquo;+\u0026rdquo; pro přidání aplikace Přejděte k instalaci Javy (např. /Library/Java/JavaVirtualMachines/jdk-11.jdk/Contents/Home/bin/java) Přidejte ji a nastavte na \u0026ldquo;Povolit příchozí připojení\u0026rdquo; Problémy s aplikací I2P pro Android Omezení verzí Androidu a limity prostředků vytvářejí jedinečné výzvy.\nMinimální požadavky: - Android 5.0+ (úroveň API 21+) je vyžadován pro aktuální verze - 512MB RAM minimálně, 1GB+ doporučeno - 100MB úložiště pro aplikaci + data routeru - Omezení aplikací na pozadí musí být pro I2P vypnutá\nAplikace se okamžitě zhroutí:\nZkontrolujte verzi Androidu: Nastavení → O telefonu → Verze systému Android (musí být 5.0+) Odinstalujte všechny verze I2P: Instalujte pouze jednu variantu: net.i2p.android (Google Play) net.i2p.android.router (F-Droid)\nSoučasná instalace více variant vede ke konfliktům Vymažte data aplikace: Nastavení → Aplikace → I2P → Úložiště → Vymazat data Znovu nainstalujte z čistého stavu Optimalizace baterie ukončuje router:\nAndroid agresivně ukončuje aplikace na pozadí, aby šetřil baterii. I2P potřebuje výjimku:\nNastavení → Baterie → Optimalizace baterie (nebo Využití baterie aplikace) Najděte I2P → Neoptimalizovat (nebo Povolit aktivitu na pozadí) Nastavení → Aplikace → I2P → Baterie → Povolit aktivitu na pozadí + Odstranit omezení Problémy s připojením na mobilu:\nBootstrap (počáteční zavedení) vyžaduje WiFi: Počáteční reseed stahuje značné množství dat - použijte WiFi, ne mobilní data Změny sítě: I2P nezvládá přepínání sítí bez problémů - po přechodu mezi WiFi a mobilní sítí aplikaci restartujte Šířka pásma pro mobil: Nastavte konzervativně na 64-128 KB/sec, abyste předešli vyčerpání mobilních dat Optimalizace výkonu pro mobilní zařízení:\nAplikace I2P → Menu → Nastavení → Šířka pásma Nastavte vhodné limity: 64 KB/s příchozí, 32 KB/s odchozí pro mobilní data Snižte počet participating tunnels (tunnels, kterými prochází cizí provoz): Nastavení → Pokročilé → Max participating tunnels: 100-200 Povolte \u0026ldquo;Stop I2P when screen off\u0026rdquo; pro úsporu baterie Torrentování na Androidu:\nOmezte na maximálně 2-3 současně aktivní torrenty Snižte agresivitu DHT (distribuovaná hašovací tabulka) Pro torrentování používejte pouze WiFi Smířte se s nižšími rychlostmi na mobilním hardwaru Problémy s reseedem a bootstrapem Nové instalace I2P vyžadují reseeding (počáteční načtení informací o uzlech) - získání počátečních informací o uzlech z veřejných serverů HTTPS pro připojení k síti. Problémy s reseedingem mohou uvěznit uživatele s nulovým počtem uzlů a bez přístupu k síti.\n\u0026ldquo;No active peers\u0026rdquo; po čerstvé instalaci obvykle znamená selhání reseed (počáteční získání seznamu uzlů). Příznaky:\nZnámí peerové: 0 nebo zůstává pod 5 \u0026ldquo;Network: Testing\u0026rdquo; přetrvává déle než 15 minut Logy ukazují \u0026ldquo;Reseed failed\u0026rdquo; (reseed = bootstrap sítě, počáteční stažení dat netDb z reseed serverů) nebo chyby připojení k reseed serverům Proč reseed selhává:\nFirewall blokuje HTTPS: Korporátní/ISP firewally blokují spojení k reseed serverům (servery pro počáteční načtení seznamu uzlů; port 443) Chyby certifikátů SSL: Systému chybí aktuální kořenové certifikáty Požadavek na proxy: Síť vyžaduje proxy HTTP/SOCKS pro externí připojení Časová odchylka: Ověření certifikátů SSL selže, pokud je systémový čas nesprávný Geografická cenzura: Některé země/ISP blokují známé reseed servery Vynutit ruční reseed (opětovné stažení počátečních uzlů):\nOtevřete http://127.0.0.1:7657/configreseed Klikněte na \u0026ldquo;Save changes and reseed now\u0026rdquo; Sledujte http://127.0.0.1:7657/logs a hledejte \u0026ldquo;Reseed got XX router infos\u0026rdquo; Počkejte 5-10 minut na zpracování Zkontrolujte http://127.0.0.1:7657 - počet známých peerů by se měl zvýšit na 50+ Nakonfigurujte reseed proxy pro restriktivní sítě:\nhttp://127.0.0.1:7657/configreseed → Konfigurace proxy:\nHTTP proxy: [proxy-server]:[port] Nebo SOCKS5: [socks-server]:[port] Povolit \u0026ldquo;Use proxy for reseed only\u0026rdquo; Přihlašovací údaje, pokud je to vyžadováno Uložit a vynutit reseed (získání počátečních uzlů) Alternativa: Tor proxy pro reseed (získání počátečních dat o síti):\nPokud běží Tor Browser nebo démon Toru:\nTyp proxy: SOCKS5 Hostitel: 127.0.0.1 Port: 9050 (výchozí port SOCKS pro Tor) Povolit a provést reseed (obnovení počátečních uzlů sítě) Ruční reseed (obnovení počátečních uzlů) prostřednictvím souboru su3 (krajní možnost):\nKdyž selže veškerý automatický reseed (počáteční načtení netDb), získejte reseed soubor mimo běžné kanály:\nStáhněte i2pseeds.su3 z důvěryhodného zdroje při neomezeném připojení k internetu (https://reseed.i2p.rocks/i2pseeds.su3 , https://reseed-fr.i2pd.xyz/i2pseeds.su3 ) Zcela ukončete I2P Zkopírujte i2pseeds.su3 do adresáře ~/.i2p/ Spusťte I2P - soubor se automaticky rozbalí a zpracuje Smažte i2pseeds.su3 po zpracování Ověřte, že počet peerů na http://127.0.0.1:7657 roste Chyby certifikátu SSL během reseed (počátečního zavedení do sítě):\nError: \u0026#34;Reseed: Certificate verification failed\u0026#34; Cause: System root certificates outdated or missing Řešení:\n# Linux - update certificates sudo apt install ca-certificates sudo update-ca-certificates # Windows - install KB updates for root certificate trust # Or install .NET Framework (includes certificate updates) # macOS - update system # Software Update includes certificate trust updates Zaseknuto na 0 známých peerů po více než 30 minutách:\nOznačuje úplné selhání reseedu (počáteční stažení informací o uzlech). Postup odstraňování problémů:\nOvěřte, že systémový čas je přesný (nejčastější problém - opravte jako PRVNÍ) Otestujte připojení přes HTTPS: Zkuste v prohlížeči otevřít https://reseed.i2p.rocks - pokud selže, jde o problém se sítí Zkontrolujte logy I2P na http://127.0.0.1:7657/logs kvůli konkrétním chybám reseed (stažení počátečních dat sítě) Vyzkoušejte jinou reseed URL: http://127.0.0.1:7657/configreseed → přidejte vlastní reseed URL: https://reseed-fr.i2pd.xyz/ Použijte ruční metodu se souborem su3 pokud selhaly všechny automatizované pokusy Reseed servery jsou občas nedostupné: I2P obsahuje několik natvrdo definovaných reseed serverů. Pokud jeden selže, router automaticky zkusí ostatní. Úplné selhání všech reseed serverů je velmi vzácné, ale možné.\nAktuálně aktivní reseed servery (stav k říjnu 2025):\nhttps://reseed.i2p.rocks/ https://reseed-fr.i2pd.xyz/ https://i2p.novg.net/ https://i2p-projekt.de/ Přidejte je jako vlastní adresy URL, pokud máte problémy s výchozími.\nPro uživatele v přísně cenzurovaných regionech:\nZvažte použití mostů Snowflake/Meek přes Tor pro počáteční reseed (počáteční stažení seedů), poté přepněte na přímé I2P po integraci. Nebo získejte i2pseeds.su3 prostřednictvím steganografie, e-mailem nebo přes USB z místa mimo cenzurní zónu.\nKdy vyhledat další pomoc Tento průvodce pokrývá drtivou většinu problémů souvisejících s I2P, ale některé vyžadují pozornost vývojářů nebo odborné znalosti komunity.\nObraťte se na komunitu I2P o pomoc, když:\nRouter opakovaně padá i po provedení všech kroků pro řešení problémů Úniky paměti způsobující trvalý růst nad rámec alokované haldy Míra úspěšnosti Tunnel zůstává pod 20 % navzdory odpovídajícímu nastavení Nové chyby v logech, které tato příručka nezahrnuje Zjištěné bezpečnostní zranitelnosti Požadavky na nové funkce nebo návrhy na vylepšení Než požádáte o pomoc, shromážděte diagnostické informace:\nVerze I2P: http://127.0.0.1:7657 (např. \u0026ldquo;2.10.0\u0026rdquo;) Verze Javy: výstup java -version Operační systém a verze Stav routeru: Stav sítě, Počet aktivních peerů, Participující tunnels Konfigurace šířky pásma: příchozí/odchozí limity Stav přesměrování portů: za firewallem nebo OK Relevantní výpisy z logu: posledních 50 řádků zobrazujících chyby z http://127.0.0.1:7657/logs Oficiální kanály podpory:\nFórum: https://i2pforum.net (clearnet) nebo http://i2pforum.i 2p (v rámci I2P) IRC: #i2p na Irc2P (irc.postman.i2p přes I2P) nebo irc.freenode.net (clearnet) Reddit: https://reddit.com/r/i2p pro komunitní diskusi Sledovač chyb: https://i2pgit.org/i2p-hackers/i2p.i2p/-/issues pro potvrzené chyby E-mailová konference: i2p-dev@lists.i2p-projekt.de pro dotazy k vývoji Realistická očekávání jsou důležitá. I2P je z podstaty svého návrhu pomalejší než clearnet (běžný internet mimo I2P) - víceskokové šifrované \u0026rsquo;tunnel\u0026rsquo; propojení vytváří inherentní latenci. Funkční I2P router s načítáním stránek trvajícím 30 sekund a rychlostí torrentu 50 KB/sec funguje správně, není rozbitý. Uživatelé očekávající rychlosti clearnetu budou zklamaní bez ohledu na optimalizaci konfigurace.\nZávěr Většina problémů v I2P pramení ze tří kategorií: nedostatek trpělivosti během bootstrapu (počáteční inicializace; vyžaduje 10–15 minut), nedostatečné přidělení prostředků (minimálně 512 MB RAM, 256 KB/sec šířky pásma) nebo chybně nastavené přesměrování portů. Pochopení distribuované architektury I2P a na anonymitu zaměřeného designu pomáhá uživatelům rozlišit očekávané chování od skutečných problémů.\nStav „Firewalled“ routeru, ačkoli není ideální, nebrání používání I2P - pouze omezuje přínos do sítě a mírně zhoršuje výkon. Noví uživatelé by měli upřednostnit stabilitu před optimalizací: nechte router běžet nepřetržitě několik dní, než začnete upravovat pokročilá nastavení, protože integrace se s dobou provozu přirozeně zlepšuje.\nPři odstraňování problémů vždy nejprve ověřte základní věci: správný systémový čas, dostatečnou šířku pásma, router běžící nepřetržitě a alespoň 10 aktivních uzlů. Většinu problémů vyřešíte tím, že se zaměříte na tyto základy, nikoli úpravami málo srozumitelných konfiguračních parametrů. I2P odměňuje trpělivost a nepřetržitý provoz lepším výkonem, protože si router v průběhu dnů a týdnů provozu buduje reputaci a optimalizuje výběr uzlů.\n","description":"Komplexní průvodce odstraňováním běžných problémů I2P routeru, včetně potíží s konektivitou, výkonem a konfigurací","id":"2ff67fee0173608876ccc012bf3ff6ce","section":"docs","title":"Příručka pro odstraňování problémů I2P routeru","url":"/cs/docs/troubleshooting/"},{"categories":null,"content":" Stav: Aktualizováno pro I2P 2.10.0 (říjen 2025). Tento seznam konsoliduje všechny aktivní, zastaralé a rezervované porty používané I2P Java Routerem, i2pd a souvisejícími pluginy. Všechny porty jsou uvedeny v numerickém pořadí pro konzistenci.\nPort Service / Component Description Notes 123SNTPNetwork time synchronizationUses external NTP servers; required for accurate LeaseSet timestamps. 2827BOB interfaceLegacy client API bridgeDeprecated; disabled by default. 4444HTTP ProxyStandard web proxy for eepsite browsingDefault for both HTTP and HTTPS browser traffic. 4445HTTPS ProxyDedicated SSL/TLS proxyOptional; often redundant with 4444. 6667–6669IRC ProxyAccess to I2P IRC networksDefault = 6668; alternate ports avoid conflicts. 7650I2PControl PluginJSON‑RPC management APIAuth required; default password itoopie. 7652UPnP HTTP eventsUPnP control interfaceSupports automatic port forwarding. 7653UPnP SSDP responsesUPnP discoveryUDP response listener for device search. 7654I2CPCore application APIUsed by Java apps and i2pd for router integration. 7655SAM DatagramUDP bridge for SAM APISAM v3 support for real‑time apps. 7656SAM StreamTCP bridge for SAM APIPrimary non‑Java application interface. 7657Router Console (HTTP)Web admin interfaceLoopback‑only by default (127.0.0.1). 7658EepsiteDefault web server for I2PTunnelUsed for locally hosted services. 7659SMTP ProxyOutgoing mail via I2P‑BoteBridges standard email clients. 7660POP3 ProxyIncoming mail via I2P‑BoteServerless email retrieval. 7661I2PBote SMTP / Pebble BlogPlugin dual‑use portRarely conflicts since plugins don’t co‑install. 7662I2PBote IMAP / Zzzot TrackerPlugin dual‑use portUsed by Zzzot for BitTorrent tracking. 7663—Reserved for future pluginsUnused as of 2.10.0. 7664JAMWiki PluginWiki platform for I2P sitesOptional plugin. 7667Router Console (HTTPS)Secure web admin interfaceSelf‑signed cert by default. 7672Railroad PluginPlugin port reservationLast documented plugin port in series. 7644Browser Mode ProxyHTTP proxy for I2P Browser BundleUsed when running Browser mode alongside router. 7647Browser Mode ConsoleRouter console for I2P Browser BundleAvoids conflict with 7657. 8002I2PSnark Web UI (HTTP)BitTorrent client UIIntegrated in router console. 8003I2PSnark Web UI (HTTPS)BitTorrent client UI (SSL)Optional secure mode. 8887Router Network Port (Legacy)Old default for peer connectionsReplaced by randomized 9151–30777 range. 8118Privoxy (Reserved)External web proxy integrationNot part of core I2P; reserved for compatibility. 8123Polipo (Reserved)Alternate proxy integrationLegacy Tor proxy compatibility. 8888Freenet (Reserved)Anonymous network portPrevents conflicts on privacy nodes. 9050–9053Tor SOCKS (Reserved)Tor proxy range for co‑installationAvoids conflicts with I2P. 9150–9153Tor Browser SOCKS (Reserved)Tor Browser integrationReserved for cross‑tool coexistence. 9151–30777Router Network Port (Random)Active TCP/UDP transport portRandomized per install for anti‑fingerprinting. 1488 / 1776XD BitTorrent ClientStandalone I2P torrent clientAlternate to I2PSnark. 31000–32000Java Service WrapperRouter process managementHandles service control and restart. 3456 / 3458 / 3459Tahoe‑LAFS PluginDecentralized file storageOptional third‑party plugin. 4691 / 8997–8999Monotone Version ControlDistributed VCS supportHistorical usage for developer tools. 7070i2pd ConsoleWeb console for C++ implementationEquivalent to Java router console. 767xPlugin Range (General)Recommended port block for pluginsDevelopers start from 7672 upward. 11371SKS/GPG Key Server (Reserved)Key distribution serviceUsed for PGP/GPG over I2P. ## Poznámky k implementaci Všechny porty pod 9000 (kromě 8887) jsou ve výchozím nastavení kvůli bezpečnosti navázány na 127.0.0.1. Síťový port routeru (9151–30777) musí být otevřený pro internet pro plnou účast v síti. i2pd používá z důvodu kompatibility většinou stejná přiřazení (7070 konzole, 7654 I2CP, 7656/7655 SAM). Vývojáři pluginů by měli koordinovat nová přiřazení prostřednictvím I2P komunity, aby se předešlo konfliktům. ","description":"Komplexní referenční příručka přiřazení portů I2P, portů pluginů a vyhrazených rozsahů.","id":"69ea4623f7bc59ab65ef7ea636966780","section":"docs","title":"Přiřazení portů","url":"/cs/docs/overview/ports/"},{"categories":null,"content":" Zastaralé: SAM v1 je zachován pouze pro historické účely. Nové aplikace by měly používat SAM v3 nebo BOB . Původní můstek podporuje pouze cíle DSA-SHA1 a omezenou sadu možností.\nKnihovny Strom zdrojových kódů Java I2P stále obsahuje zastaralé vazby pro C, C#, Perl a Python. Už nejsou udržovány a jsou distribuovány převážně kvůli archivní kompatibilitě.\nVyjednávání verze Klienti se připojují přes TCP (výchozí 127.0.0.1:7656) a vyměňují si:\nClient → HELLO VERSION MIN=1 MAX=1 Bridge → HELLO REPLY RESULT=OK VERSION=1.0 Od verze Java I2P 0.9.14 je parametr MIN nepovinný a oba MIN/MAX přijímají jednociferné tvary (\u0026quot;3\u0026quot; apod.) pro aktualizované mosty.\nVytvoření relace SESSION CREATE STYLE={STREAM|DATAGRAM|RAW} DESTINATION={name|TRANSIENT} [DIRECTION={BOTH|RECEIVE|CREATE}] [option=value]* DESTINATION=name načte nebo vytvoří položku v sam.keys; TRANSIENT vždy vytvoří dočasnou destinaci. STYLE vybírá virtuální streamy (podobné TCP), podepsané datagramy nebo surové datagramy. DIRECTION se vztahuje pouze na streamové relace; výchozí hodnota je BOTH. Další páry klíč/hodnota jsou předány jako volby I2CP (například tunnels.quantityInbound=3). Most odpovídá:\nSESSION STATUS RESULT=OK DESTINATION=name Chybové stavy vracejí DUPLICATED_DEST, I2P_ERROR nebo INVALID_KEY a volitelnou zprávu.\nFormáty zpráv Zprávy SAM jsou jednořádkové ASCII s páry klíč/hodnota oddělenými mezerami. Klíče jsou v UTF‑8; hodnoty mohou být uzavřeny v uvozovkách, pokud obsahují mezery. Nejsou definovány žádné escape sekvence.\nTypy komunikace:\nDatové proudy – proxyované přes I2P streaming library Datagramy s možností odpovědi – podepsaná užitečná data (Datagram1) Surové datagramy – nepodepsaná užitečná data (Datagram RAW) Možnosti přidané ve verzi 0.9.14 DEST GENERATE přijímá SIGNATURE_TYPE=... (umožňuje použít Ed25519 apod.) HELLO VERSION považuje MIN za volitelné a přijímá jednociferné řetězce verzí Kdy použít SAM v1 Pouze kvůli interoperabilitě se zastaralým softwarem, který nelze aktualizovat. Pro veškerý nový vývoj používejte:\nSAM v3 pro funkčně kompletní přístup ke streamům/datagramům BOB pro správu destinací (stále omezený, ale podporuje modernější funkce) Reference SAM v2 SAM v3 Specifikace datagramů Streamovací protokol SAM v1 položil základy pro vývoj aplikací nezávislý na routeru, ale ekosystém se posunul dál. Tento dokument berte spíše jako pomůcku pro kompatibilitu než jako výchozí bod.\n","description":"Zastaralý protokol Simple Anonymous Messaging (deprecated)","id":"d6c20329db11e9b5a1eff3a8709b3294","section":"docs","title":"SAM (rozhraní Simple Anonymous Messaging) v1","url":"/cs/docs/legacy/sam/"},{"categories":null,"content":" Zastaralé: SAM v2 byl součástí I2P 0.6.1.31 a již není udržován. Pro nový vývoj použijte SAM v3 . Jediným vylepšením v2 oproti v1 byla podpora více socketů multiplexovaných přes jedno připojení SAM.\nPoznámky k verzi Hlášený řetězec verze zůstává \u0026ldquo;2.0\u0026rdquo;. Od verze 0.9.14 zpráva HELLO VERSION přijímá jednociferné hodnoty MIN/MAX a parametr MIN je volitelný. DEST GENERATE podporuje SIGNATURE_TYPE, takže lze vytvářet destinace Ed25519. Základy relace SESSION CREATE STYLE={STREAM|DATAGRAM|RAW} DESTINATION={name|TRANSIENT} [DIRECTION={BOTH|RECEIVE|CREATE}] [option=value] Každá destinace může mít pouze jednu aktivní relaci SAM (streamy, datagramy nebo režim raw (surový)). STYLE volí virtuální streamy, podepsané datagramy nebo raw datagramy. Dodatečné volby se předávají do I2CP (například tunnels.quantityInbound=3). Odpovědi odpovídají v1: SESSION STATUS RESULT=OK|DUPLICATED_DEST|I2P_ERROR|INVALID_KEY. Kódování zpráv Řádkově orientované ASCII s dvojicemi key=value oddělenými mezerami (hodnoty mohou být v uvozovkách). Typy komunikace jsou stejné jako ve verzi v1:\nDatové proudy přes streamovací knihovnu I2P Repliable datagrams (datagramy s možností odpovědi) (PROTO_DATAGRAM) Surové datagramy (PROTO_DATAGRAM_RAW) Kdy použít Pouze pro starší klienty, které nelze migrovat. SAM v3 nabízí:\nPředání destinace v binární podobě (DEST GENERATE BASE64) Subsessions (podrelace) a podpora DHT (v3.3) Lepší hlášení chyb a vyjednávání parametrů Viz:\nSAM v1 SAM v3 Datagramové API Streamovací protokol ","description":"Zastaralý protokol Simple Anonymous Messaging (jednoduché anonymní zasílání zpráv)","id":"a21e46f2603ba3051f18eff26aa5084d","section":"docs","title":"SAM v2","url":"/cs/docs/legacy/samv2/"},{"categories":null,"content":"SAM v3 („Simple Anonymous Messaging\u0026quot;) je aktuální stabilní, na routeru nezávislé API, které umožňuje externím aplikacím komunikovat se sítí I2P bez nutnosti vkládat samotný router. Poskytuje jednotný přístup ke streamům, datagramům a raw zprávám a zůstává kanonickou překlenovací vrstvou pro software napsaný v jiných jazycích než Java.\n1. Přehled a účel SAM v3 umožňuje vývojářům vytvářet software podporující I2P v jakémkoli jazyce pomocí lehkého TCP/UDP protokolu. Abstrahuje vnitřní strukturu routeru a poskytuje minimální sadu příkazů přes TCP (7656) a UDP (7655). Java I2P i i2pd implementují podmnožiny specifikace SAM v3, i když i2pd k roku 2025 stále postrádá většinu rozšíření 3.2 a 3.3.\n2. Historie verzí Version Introduced Key Features 3.00.7.3 (May 2009)Streams + Datagrams; binary destinations; `SESSION CREATE STYLE=` parameter. 3.10.9.14 (Jul 2014)Signature type negotiation via `SIGNATURE_TYPE`; improved `DEST GENERATE`. 3.20.9.24 (Jan 2016)Per session encryption + tunnel options; `STREAM CONNECT ID` support. 3.30.9.25 (Mar 2016)PRIMARY / SUBSESSION architecture; multiplexing; improved datagrams. ### Poznámka k pojmenování Java I2P používá PRIMARY/SUBSESSION. i2pd a I2P+ nadále používají starší terminologii MASTER/SUBSESSION kvůli zpětné kompatibilitě. 3. Základní pracovní postup Vyjednávání verze HELLO VERSION MIN=3.1 MAX=3.3 HELLO REPLY RESULT=OK VERSION=3.3 Vytvoření Destinace DEST GENERATE SIGNATURE_TYPE=7 SIGNATURE_TYPE=7 → Ed25519 (EdDSA SHA512). Silně doporučeno od I2P 0.9.15. Vytvoření relace SESSION CREATE STYLE=STREAM DESTINATION=NAME OPTION=i2cp.leaseSetEncType=4,0 OPTION=inbound.quantity=3 OPTION=outbound.quantity=3 i2cp.leaseSetEncType=4,0 → 4 je X25519 (ECIES X25519 AEAD Ratchet) a 0 je ElGamal záložní varianta pro kompatibilitu. Explicitní množství tunnelů pro konzistenci: výchozí hodnota Java I2P 2, výchozí hodnota i2pd 5. Operace protokolu STREAM CONNECT ID=1 DESTINATION=b32address.i2p STREAM SEND ID=1 SIZE=128 STREAM CLOSE ID=1 Mezi základní typy zpráv patří: STREAM CONNECT, STREAM ACCEPT, STREAM FORWARD, DATAGRAM SEND, RAW SEND, NAMING LOOKUP, DEST LOOKUP, PING, QUIT.\nElegantní vypnutí QUIT 4. Rozdíly v implementaci (Java I2P vs i2pd) Feature Java I2P 2.10.0 i2pd 2.58.0 (Sept\u0026nbsp;2025) SAM enabled by default❌ Requires manual enable in router console✅ Enabled via `enabled=true` in `i2pd.conf` Default portsTCP 7656 / UDP 7655Same AUTH / USER / PASSWORD✓ Supported✗ Not implemented PING / PONG keepalive✓ Supported✗ Not implemented QUIT / STOP / EXIT commands✓ Supported✗ Not implemented FROM_PORT / TO_PORT / PROTOCOL✓ Supported✗ Not implemented PRIMARY/SUBSESSION support✓ (since 0.9.47)✗ Absent SESSION ADD / REMOVE✓ Supported✗ Not implemented Datagram2 / Datagram3 support✓ (since 2.9.0)✗ Not implemented SSL/TLSOptional✗ None Default tunnel quantitiesInbound/outbound=2Inbound/outbound=5 **Doporučení:** Vždy explicitně specifikujte množství tunelů, abyste zajistili konzistenci mezi routery. 5. Podporované knihovny (stav k roku 2025) Library Language SAM Support Maintenance Status (2025) libsam3C3.1Maintained by I2P Project (eyedeekay) i2psamC++3.1Minimal updates since 2019 sam3Go3.3Active; migrated from `eyedeekay/sam3` onrampGo3.3Actively maintained (2025) i2plibPython3.1Modern async replacement for `i2p.socket` i2p.socketPython3.2Abandoned (last release 2017) Py2pPython3.3Unverified/inactive i2p-rsRust3.1Experimental; unstable API @diva.exchange/i2p-samTypeScript / JS3.3Most actively maintained (2024–2025) I2PSharpC#3.3Functional; light maintenance ## 6. Připravované a nové funkce (2024–2025) Feature Status Introduced NAMING LOOKUP `OPTIONS=true`✓ Supported2.8.0 Datagram2 / Datagram3 formats✓ (Java only)2.9.0 Post-quantum hybrid crypto (ML KEM)Optional2.10.0 Java 17+ runtime requirementPlanned2.11.0 I2P over Tor blockingActive2.6.0 Improved floodfill selectionActive2.8.0+ ## 7. Bezpečnostní a konfigurační poznámky Navažte SAM pouze na 127.0.0.1. Pro trvalé služby používejte PRIMARY relace se statickými klíči. Použijte HELLO VERSION k otestování podpory funkcí. Použijte PING nebo NAMING LOOKUP k ověření funkčnosti routeru. Vyhněte se neautentizovaným vzdáleným SAM připojením (i2pd nepodporuje TLS). 8. Reference a specifikace Specifikace SAM v3 SAM v2 (Legacy) Specifikace streamování Datagramy Centrum dokumentace Dokumentace i2pd 9. Shrnutí SAM v3 zůstává doporučeným protokolem mostu pro všechny aplikace I2P, které nejsou napsané v Javě. Nabízí stabilitu, vazby pro více programovacích jazyků a konzistentní výkon napříč různými typy routerů.\nPři vývoji s SAM: - Používejte podpisy Ed25519 a šifrování X25519. - Dynamicky ověřujte podporu funkcí pomocí HELLO VERSION. - Navrhujte s ohledem na kompatibilitu, zejména při podpoře routerů Java I2P i i2pd.\n","description":"Stabilní protokol mostu pro aplikace I2P, které nejsou v Javě","id":"dd6d27c1d72fe7c4333dc148d132f546","section":"docs","title":"SAM v3","url":"/cs/docs/api/samv3/"},{"categories":null,"content":"O reseed serverech Nové routery potřebují hrstku uzlů, aby se připojily k síti I2P. Reseed servery poskytují tuto počáteční sadu pro bootstrap (počáteční zavedení) prostřednictvím šifrovaných stahování přes HTTPS. Každý reseed balíček je podepsán serverem, což brání manipulaci neověřenými stranami. Zavedené routery mohou příležitostně provést reseed, pokud jejich sada uzlů zastará.\nProces bootstrapu sítě Když se I2P router poprvé spustí nebo byl po delší dobu offline, potřebuje data RouterInfo, aby se připojil k síti. Protože router nemá žádné existující peery, nemůže tyto informace získat ze samotné sítě I2P. Mechanismus reseed (mechanismus počátečního zavedení do sítě) řeší problém s počátečním zavedením tím, že poskytuje soubory RouterInfo z důvěryhodných externích serverů HTTPS.\nProces reseedu (počáteční stažení důvěryhodných RouterInfo pro počáteční připojení do sítě) doručuje 75-100 souborů RouterInfo v jednom kryptograficky podepsaném balíčku. Tím je zajištěno, že nové routery mohou rychle navázat spojení, aniž by byly vystaveny útokům typu man-in-the-middle, které by je mohly izolovat do oddělených, nedůvěryhodných částí sítě.\nAktuální stav sítě K říjnu 2025 běží síť I2P na verzi routeru 2.10.0 (verze API 0.9.67). reseed protocol (protokol pro počáteční naplnění informacemi o síti) zavedený ve verzi 0.9.14 zůstává stabilní a ve své základní funkčnosti nezměněný. Síť udržuje více nezávislých reseed serverů rozmístěných po celém světě, aby byla zajištěna dostupnost a odolnost vůči cenzuře.\nSlužba checki2p monitoruje všechny I2P reseed servery každé 4 hodiny a poskytuje kontroly stavu v reálném čase a metriky dostupnosti pro infrastrukturu reseed.\nSpecifikace formátu souboru SU3 Formát souboru SU3 je základem protokolu reseed I2P (proces doplnění počátečních dat sítě), který zajišťuje doručování kryptograficky podepsaného obsahu. Porozumění tomuto formátu je zásadní pro implementaci reseed serverů a klientů.\nStruktura souborů Formát SU3 se skládá ze tří hlavních částí: hlavičky (40+ bajtů), obsahu (proměnná délka) a podpisu (délka určená v hlavičce).\nFormát hlavičky (bajty 0-39 minimálně) Byte Range Field Description 0-5Magic NumberASCII string \"I2Psu3\" (0x493250737533) 6ReservedUnused, must be 0x00 7File Format VersionCurrent version: 0x00 8-9Signature TypeBig-endian 16-bit integer. Type 6 = RSA-4096-SHA512 (reseed standard) 10-11Signature LengthBig-endian 16-bit integer. 512 bytes (0x0200) for RSA-4096 12ReservedUnused, must be 0x00 13Version LengthMinimum 16 bytes (0x10) for compatibility 14ReservedUnused, must be 0x00 15Signer ID LengthLength of UTF-8 signer identifier string 16-23Content LengthBig-endian 64-bit integer, length of content in bytes 24ReservedUnused, must be 0x00 25File Type0x00 = ZIP, 0x01 = XML, 0x02 = HTML, 0x03 = XML.GZ, 0x04 = TXT.GZ, 0x05 = DMG, 0x06 = EXE 26ReservedUnused, must be 0x00 27Content Type0x00 = unknown, 0x01 = router update, 0x02 = plugin, 0x03 = reseed, 0x04 = news, 0x05 = blocklist 28-39PaddingUnused, must be all zeros 40-55Version StringASCII version string, padded with zeros (minimum 16 bytes) 56-...Signer IDUTF-8 encoded signer identifier (e.g., \"user@mail.i2p\") ### Parametry SU3 specifické pro Reseed (počáteční zavedení sítě I2P) U balíčků reseed (doplnění počátečních uzlů) musí mít soubor SU3 následující vlastnosti:\nFile name: Musí být přesně i2pseeds.su3 Content Type (bajt 27): 0x03 (RESEED) File Type (bajt 25): 0x00 (ZIP) Signature Type (bajty 8-9): 0x0006 (RSA-4096-SHA512) Version String: Unixové časové razítko v ASCII (sekundy od epochy, formát date +%s) Signer ID: ID ve formátu e-mailové adresy odpovídající CN certifikátu X.509 Parametr dotazu ID sítě Od verze 0.9.42 routers připojují k požadavkům na reseed (počáteční stažení seznamu uzlů) parametr ?netid=2. To brání navazování spojení napříč sítěmi, protože testovací sítě používají odlišná ID sítě. Aktuální produkční síť I2P používá ID sítě 2.\nUkázkový požadavek: https://reseed.example.com/i2pseeds.su3?netid=2\nStruktura obsahu archivu ZIP Sekce obsahu (za hlavičkou, před podpisem) obsahuje standardní archiv ZIP s následujícími požadavky:\nKomprese: Standardní komprese ZIP (DEFLATE) Počet souborů: Obvykle 75–100 souborů RouterInfo (informační soubory routeru) Adresářová struktura: Všechny soubory musí být na nejvyšší úrovni (bez podadresářů) Pojmenování souborů: routerInfo-{44-character-base64-hash}.dat Abeceda Base64: Musí používat upravenou abecedu base64 systému I2P Abeceda I2P base64 se liší od standardní base64 tím, že používá - a ~ místo + a /, aby byla zajištěna kompatibilita se souborovým systémem a adresami URL.\nKryptografický podpis Podpis pokrývá celý soubor od bajtu 0 až po konec sekce obsahu. Samotný podpis je připojen za obsah.\nAlgoritmus podpisu (RSA-4096-SHA512) Vypočítejte hash SHA-512 bajtů od bajtu 0 až po konec obsahu Podepište hash pomocí \u0026ldquo;raw\u0026rdquo; RSA (v terminologii Javy NONEwithRSA) Je-li to nutné, doplňte podpis počátečními nulami na 512 bajtů K souboru připojte 512bajtový podpis Proces ověřování podpisu Klienti musí:\nPřečtěte bajty 0-11 k určení typu a délky podpisu Přečtěte celou hlavičku k určení hranic obsahu Streamujte obsah při výpočtu hashe SHA-512 Extrahujte podpis z konce souboru Ověřte podpis pomocí veřejného klíče RSA-4096 podepisujícího Odmítněte soubor, pokud ověření podpisu selže Model důvěry certifikátů Podpisové klíče pro Reseed (úvodní bootstrap sítě) jsou distribuovány jako samopodepsané certifikáty X.509 s klíči RSA-4096. Tyto certifikáty jsou součástí balíčků routeru I2P v adresáři certificates/reseed/.\nFormát certifikátu: - Typ klíče: RSA-4096 - Podpis: Samopodepsaný - Subject CN: Musí odpovídat ID podepisovatele v hlavičce SU3 - Data platnosti: Klienti by měli vynucovat dobu platnosti certifikátu\nProvozování Reseed Host (serveru pro počáteční bootstrap I2P) Provozování reseed služby (služby, která poskytuje novým routerům počáteční data pro připojení do sítě) vyžaduje pečlivou pozornost věnovanou bezpečnosti, spolehlivosti a požadavkům na různorodost sítě. Více nezávislých reseed serverů zvyšuje odolnost a ztěžuje útočníkům či cenzorům bránit novým routerům v připojení do sítě.\nTechnické požadavky Specifikace serveru Operační systém: Unix/Linux (Ubuntu, Debian, FreeBSD otestované a doporučené) Konektivita: Statická IPv4 adresa je vyžadována, IPv6 je doporučeno, ale volitelné CPU: Minimálně 2 jádra RAM: Minimálně 2 GB Šířka pásma: Přibližně 15 GB měsíčně Dostupnost: Vyžadován nepřetržitý provoz 24/7 I2P Router: Dobře integrovaný I2P router běžící nepřetržitě Požadavky na software Java: JDK 8 nebo novější (Java 17+ bude vyžadována počínaje I2P 2.11.0) Webový server: nginx nebo Apache s podporou reverzní proxy (Lighttpd již není podporován kvůli omezením hlavičky X-Forwarded-For) TLS/SSL: Platný certifikát TLS (Let\u0026rsquo;s Encrypt, samopodepsaný nebo od komerční certifikační autority (CA)) Ochrana proti DDoS: fail2ban nebo ekvivalent (povinné, nikoli volitelné) Nástroje pro reseed: Oficiální reseed-tools z https://i2pgit.org/idk/reseed-tools Bezpečnostní požadavky Konfigurace HTTPS/TLS Protokol: pouze HTTPS, bez nouzového přechodu na HTTP Verze TLS: minimálně TLS 1.2 Sady šifer: musí podporovat silné šifry kompatibilní s prostředím Java 8+ CN/SAN certifikátu: musí odpovídat názvu hostitele (hostname) obsluhované adresy URL Typ certifikátu: může být self-signed (vlastnoručně podepsaný), pokud je to domluveno s vývojářským týmem, nebo vydaný uznávanou certifikační autoritou Správa certifikátů Podpisové certifikáty SU3 a certifikáty TLS slouží k různým účelům:\nCertifikát TLS (certificates/ssl/): Zabezpečuje HTTPS přenos Certifikát pro podpis SU3 (certificates/reseed/): Podepisuje reseed balíčky (pro počáteční zprovoznění sítě) Oba certifikáty musí být poskytnuty koordinátorovi reseedu (počáteční zavedení do sítě) (zzz@mail.i2p ) pro zařazení do balíčků routeru.\nOchrana proti DDoS a scrapingu Reseed servery čelí periodickým útokům ze strany chybných implementací, botnetů i škodlivých aktérů, přičemž cílem je sklízet síťovou databázi (netDb). Mezi ochranná opatření patří:\nfail2ban: Vyžadováno pro omezování rychlosti a zmírňování útoků Různorodost balíčků: Doručovat různé sady RouterInfo (informace o routeru) různým žadatelům Konzistence balíčků: Doručovat stejný balíček při opakovaných požadavcích ze stejné IP v rámci konfigurovatelného časového okna Omezení logování IP: Nezveřejňovat logy ani IP adresy (požadavek zásad ochrany soukromí) Metody implementace Metoda 1: Oficiální reseed-tools (doporučeno) Kanonická implementace udržovaná projektem I2P. Repozitář: https://i2pgit.org/idk/reseed-tools Instalace:\n# Install dependencies sudo apt-get install golang git # Clone repository git clone https://i2pgit.org/idk/reseed-tools.git cd reseed-tools # Build make # Generate keys and start server (first run) ./reseed-tools reseed \\ --signer=your-email@mail.i2p \\ --netdb=/path/to/i2p/netDb \\ --tlsHost=your-domain.tld \\ --port=8443 Při prvním spuštění nástroj vygeneruje: - your-email@mail.i2p.crt (podpisový certifikát SU3) - your-email@mail.i2p.pem (soukromý klíč pro podepisování SU3) - your-email@mail.i2p.crl (seznam odvolaných certifikátů) - soubory s TLS certifikátem a klíčem\nFunkce: - Automatické generování SU3 bundle (aktualizačního balíčku I2P) (350 variant, každá s 77 RouterInfo) - Vestavěný HTTPS server - Obnovovat mezipaměť každých 9 hodin pomocí plánovače cron - Podpora hlavičky X-Forwarded-For s přepínačem --trustProxy - Kompatibilní s konfiguracemi reverse proxy\nProdukční nasazení:\n# Create systemd service cat \u0026gt; /etc/systemd/system/i2p-reseed.service \u0026lt;\u0026lt; EOF [Unit] Description=I2P Reseed Server After=network.target [Service] Type=simple User=i2p-reseed WorkingDirectory=/opt/i2p-reseed ExecStart=/opt/i2p-reseed/reseed-tools reseed \\ --signer=your-email@mail.i2p \\ --netdb=/var/lib/i2p/netDb \\ --port=8443 \\ --ip=127.0.0.1 \\ --trustProxy Restart=always [Install] WantedBy=multi-user.target EOF systemctl enable i2p-reseed systemctl start i2p-reseed Metoda 2: Implementace v Pythonu (pyseeder) Alternativní implementace od projektu PurpleI2P: https://github.com/PurpleI2P/pyseeder pip install pyseeder # Generate SU3 file echo \u0026#34;your_password\u0026#34; | pyseeder reseed \\ --netdb /path/to/netDb \\ --private-key priv_key.pem \\ --outfile i2pseeds.su3 \\ --signer-id user@mail.i2p # Serve via built-in server pyseeder serve \\ --port 8443 \\ --host 0.0.0.0 \\ --private-key priv_key.pem \\ --cert user_at_mail.i2p.crt \\ --file i2pseeds.su3 Metoda 3: Nasazení pomocí Dockeru Pro kontejnerová prostředí existuje několik implementací připravených pro Docker:\nDivaExchange i2p-reseed: https://github.com/diva-exchange/i2p-reseed RTradeLtd/i2p-tools-1: Přidává Tor onion službu a podporu pro IPFS Konfigurace reverzní proxy Konfigurace nginxu upstream i2p_reseed { server 127.0.0.1:8443; } server { listen 443 ssl http2; server_name reseed.example.com; ssl_certificate /path/to/tls-cert.crt; ssl_certificate_key /path/to/tls-key.key; ssl_protocols TLSv1.2 TLSv1.3; ssl_ciphers HIGH:!aNULL:!MD5; location / { proxy_pass http://i2p_reseed; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $remote_addr; proxy_set_header Host $host; } } Konfigurace Apache \u0026lt;VirtualHost *:443\u0026gt; ServerName reseed.example.com SSLEngine on SSLCertificateFile /path/to/tls-cert.crt SSLCertificateKeyFile /path/to/tls-key.key SSLProtocol all -SSLv2 -SSLv3 -TLSv1 -TLSv1.1 ProxyRequests Off \u0026lt;Proxy *\u0026gt; Order deny,allow Allow from all \u0026lt;/Proxy\u0026gt; ProxyPass / http://127.0.0.1:8443/ ProxyPassReverse / http://127.0.0.1:8443/ \u0026lt;/VirtualHost\u0026gt; Registrace a koordinace Chcete-li zahrnout svůj reseed server (server pro počáteční získání informací o síti) do oficiálního balíčku I2P:\nDokončete nastavení a testování Zašlete oba certifikáty (SU3 signing a TLS) koordinátorovi reseedu Kontakt: zzz@mail.i2p nebo zzz@i2pmail.org Připojte se do #i2p-dev na IRC2P pro koordinaci s ostatními operátory Provozní osvědčené postupy Monitoring a logování Povolit kombinovaný formát logů Apache/nginx pro statistiky Zavést rotaci logů (logy rychle rostou) Sledovat úspěšnost generování balíčků a časy znovusestavení Sledovat využití šířky pásma a vzorce požadavků Nikdy nezveřejňovat IP adresy ani podrobné přístupové logy Harmonogram údržby Každých 9 hodin: Přestavět mezipaměť balíčku SU3 (automatizováno pomocí cron) Týdně: Kontrolovat logy kvůli vzorcům útoků Měsíčně: Aktualizovat I2P router a reseed-tools Podle potřeby: Obnovit TLS certifikáty (automatizovat pomocí Let\u0026rsquo;s Encrypt) Výběr portu Výchozí: 8443 (doporučeno) Alternativa: Libovolný port v rozsahu 1024-49151 Port 443: Vyžaduje práva roota nebo přesměrování portu (doporučeno přesměrování pomocí iptables) Příklad přesměrování portů:\niptables -A PREROUTING -t nat -p tcp --dport 443 -j REDIRECT --to-port 8443 Alternativní metody reseedu (počátečního naplnění netDb) Další možnosti bootstrapu (počátečního zavádění) pomáhají uživatelům v restriktivních sítích:\nReseed ze souboru (počáteční načtení uzlů) Zavedeno ve verzi 0.9.16, reseed (počáteční naplnění netDb) založený na souborech umožňuje uživatelům ručně načítat balíčky RouterInfo (informace o routeru). Tato metoda je obzvlášť užitečná pro uživatele v cenzurovaných regionech, kde jsou blokovány HTTPS reseed servery.\nPostup: 1. Důvěryhodný kontakt vygeneruje balíček SU3 pomocí svého routeru 2. Balíček je předán e-mailem, přes USB disk nebo jiným out-of-band kanálem (oddělený kanál mimo běžné spojení) 3. Uživatel umístí i2pseeds.su3 do konfiguračního adresáře I2P 4. Router po restartu balíček automaticky rozpozná a zpracuje\nDokumentace: /blog/2020/06/07/help-your-friends-join-i2p-by-sharing-reseed-bundles/\nPřípady použití: - Uživatelé za národními firewally blokujícími reseed servers (servery pro počáteční inicializaci sítě) - Izolované sítě vyžadující ruční bootstrap (počáteční inicializaci sítě) - Testovací a vývojová prostředí\nReseeding (úvodní získání seznamu uzlů) přes proxy Cloudflare Směrování provozu reseed (stažení počátečních informací o uzlech) přes CDN společnosti Cloudflare přináší pro provozovatele v regionech s vysokou mírou cenzury několik výhod.\nVýhody: - IP adresa původního serveru skryta před klienty - Ochrana proti DDoS prostřednictvím infrastruktury Cloudflare - Geografická distribuce zátěže pomocí edge cachingu (kešování na okraji sítě) - Lepší výkon pro klienty po celém světě\nPožadavky na implementaci: - přepínač --trustProxy povolen v reseed-tools - Cloudflare proxy povoleno pro DNS záznam - Správné zpracování hlavičky X-Forwarded-For\nDůležité poznámky: - Platí omezení portů Cloudflare (je nutné použít podporované porty) - Konzistence balíčku pro stejného klienta vyžaduje podporu X-Forwarded-For - Konfiguraci SSL/TLS spravuje Cloudflare\nDokumentace: https://homepage.np-tokumei.net/post/notes-i2p-reseed-over-cloudflare/ Strategie odolné vůči cenzuře Výzkum Nguyen Phong Hoanga (USENIX FOCI 2019) identifikuje další inicializační metody pro cenzurované sítě:\nPoskytovatelé cloudového úložiště Box, Dropbox, Google Drive, OneDrive: Hostovat soubory SU3 na veřejných odkazech Výhoda: Obtížné blokovat bez narušení legitimních služeb Omezení: Vyžaduje ruční distribuci adres URL uživatelům Distribuce IPFS (decentralizovaný souborový systém) Hostovat balíčky pro reseed (počáteční zavedení sítě) na InterPlanetary File System Obsahově adresované úložiště zabraňuje pozměňování Odolné vůči pokusům o stažení z provozu Onion služby Toru Reseed servery (servery pro počáteční načtení informací o uzlech) přístupné přes adresy .onion Odolné vůči blokování na základě IP adresy Vyžaduje klienta Tor v systému uživatele Výzkumná dokumentace: https://homepage.np-tokumei.net/post/notes-censorship-resistant-i2p-reseeding/ Země se známým blokováním I2P K roku 2025 je potvrzeno, že následující země blokují I2P reseed servery (servery pro počáteční stažení informací o síti): - Čína - Írán - Omán - Katar - Kuvajt\nUživatelé v těchto regionech by měli využívat alternativní metody bootstrapu nebo cenzuře odolné strategie reseedingu (počáteční stažení kontaktů do sítě).\nPodrobnosti protokolu pro implementátory Specifikace požadavku na reseed (počáteční zavedení do sítě I2P) Chování klienta Výběr serveru: Router udržuje pevně zakódovaný seznam URL pro reseed Náhodný výběr: Klient náhodně vybírá server z dostupného seznamu Formát požadavku: GET /i2pseeds.su3?netid=2 HTTP/1.1 User-Agent: Měl by napodobovat běžné prohlížeče (např. \u0026ldquo;Wget/1.11.4\u0026rdquo;) Logika opakování: Pokud požadavek na SU3 selže, přejde se k parsování indexové stránky Ověření certifikátu: Ověřit certifikát TLS vůči systémovému úložišti důvěryhodných certifikátů Ověření podpisu SU3: Ověřit podpis vůči známým certifikátům pro reseed Chování serveru Výběr balíčku: Vybrat pseudonáhodnou podmnožinu RouterInfos (záznamy o I2P routerech) z netDb Sledování klientů: Identifikovat požadavky podle zdrojové IP adresy (s ohledem na X-Forwarded-For) Konzistence balíčku: Vrátit stejný balíček pro opakované požadavky v časovém okně (typicky 8-12 hodin) Různorodost balíčků: Vrátit různé balíčky různým klientům pro rozmanitost sítě Content-Type: application/octet-stream nebo application/x-i2p-reseed Formát souboru RouterInfo Každý soubor .dat v balíčku reseed (počáteční naplnění netDb) obsahuje strukturu RouterInfo:\nPojmenování souborů: routerInfo-{base64-hash}.dat - Hash má 44 znaků a používá abecedu I2P Base64 - Příklad: routerInfo-ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmn.dat\nObsah souboru: - RouterIdentity (hash routeru, šifrovací klíč, podpisový klíč) - Časové razítko publikace - Adresy routeru (IP, port, typ transportu) - Schopnosti a volby routeru - Podpis pokrývající všechna výše uvedená data\nPožadavky na diverzitu sítě Za účelem prevence centralizace sítě a umožnění detekce útoků Sybil:\nŽádné úplné výpisy NetDb: Nikdy neposkytujte všechny RouterInfo (informace o routeru) jedinému klientovi Náhodný výběr: Každý balíček obsahuje odlišnou podmnožinu dostupných uzlů Minimální velikost balíčku: 75 záznamů RouterInfo (zvýšeno z původních 50) Maximální velikost balíčku: 100 záznamů RouterInfo Aktuálnost: RouterInfo by měly být aktuální (do 24 hodin od vytvoření) Úvahy o IPv6 Aktuální stav (2025): - Několik reseed serverů (servery pro počáteční připojení do sítě) je přes IPv6 nedostupných - Klienti by kvůli spolehlivosti měli upřednostnit nebo vynutit IPv4 - Podpora IPv6 je pro nová nasazení doporučená, ale není kritická\nPoznámka k implementaci: Při konfiguraci dual-stackových serverů zajistěte, aby obě naslouchací adresy IPv4 i IPv6 fungovaly správně, nebo IPv6 zakažte, pokud jej nelze řádně podporovat.\nBezpečnostní hlediska Model hrozeb Protokol reseed (počáteční bootstrap sítě I2P) chrání proti:\nÚtoky typu man-in-the-middle: Podpisy RSA-4096 zabraňují manipulaci s balíčkem Rozdělení sítě: Více nezávislých reseed serverů (servery pro počáteční získání seznamu uzlů) zabraňuje jedinému bodu kontroly Útoky typu Sybil: Různorodost balíčků omezuje schopnost útočníka izolovat uživatele Cenzura: Více serverů a alternativní metody poskytují redundanci reseed protocol (mechanismus pro získání počátečních routerů) NEchrání proti:\nKompromitované reseed servery (reseed = počáteční bootstrap do sítě): Pokud útočník ovládá soukromé klíče k reseed certifikátům Úplné blokování sítě: Pokud jsou v regionu zablokovány všechny metody reseed Dlouhodobé sledování: Žádosti o reseed odhalují IP adresu pokoušející se připojit k I2P Správa certifikátů Zabezpečení soukromých klíčů: - Uchovávejte SU3 podpisové klíče offline, když se nepoužívají - Používejte silná hesla pro šifrování klíčů - Zajišťujte bezpečné zálohy klíčů a certifikátů - Zvažte hardwarové bezpečnostní moduly (HSM) pro nasazení s vysokou hodnotou\nOdvolání certifikátů: - Seznamy odvolaných certifikátů (CRLs) distribuované přes informační kanál - Kompromitované certifikáty může odvolat koordinátor - Routers automaticky aktualizují CRLs v rámci aktualizací softwaru\nZmírnění útoků Ochrana proti DDoS: - pravidla fail2ban pro nadměrné požadavky - omezování počtu požadavků na úrovni webového serveru - omezení počtu připojení na IP adresu - Cloudflare nebo podobné CDN pro další vrstvu\nPrevence scrapingu: - Různé balíčky pro každou zdrojovou IP adresu - Časově řízené ukládání balíčků do mezipaměti podle IP - Logování vzorců naznačujících pokusy o scraping - Koordinace s ostatními operátory ohledně detekovaných útoků\nTestování a ověřování Testování vašeho Reseed Serveru (serveru pro počáteční naplnění netDb při bootstrapu) Metoda 1: Čistá instalace routeru Nainstalujte I2P na čistý systém Přidejte svůj reseed URL (odkaz pro počáteční stažení seznamu uzlů) do konfigurace Odstraňte nebo zakažte ostatní reseed URL Spusťte router a sledujte logy kvůli úspěšnému reseedu Ověřte připojení k síti do 5-10 minut Očekávaný výstup logu:\nReseed got 77 router infos from https://your-reseed.example.com/i2pseeds.su3?netid=2 with 0 errors Reseed complete, 77 received Metoda 2: Ruční ověření SU3 (souborový formát podepsaných aktualizací I2P) # Download bundle curl -k -A \u0026#34;Wget/1.11.4\u0026#34; https://your-reseed.example.com/i2pseeds.su3 \u0026gt; test.su3 # Verify it\u0026#39;s a valid SU3 file hexdump -C test.su3 | head -n 3 # Should show: 49 32 50 73 75 33 (I2Psu3) # Extract content (requires su3 tools) java -cp /path/to/i2p.jar net.i2p.crypto.SU3File verify test.su3 your-cert.crt # Unzip content # (Extract content section, skip header+signature, then unzip) Metoda 3: checki2p Monitoring Služba na adrese https://checki2p.com/reseed provádí automatizované kontroly každé 4 hodiny u všech registrovaných I2P reseed serverů (reseed: počáteční stažení seznamu peerů pro připojení k síti). To poskytuje:\nMonitorování dostupnosti Metriky doby odezvy Ověření certifikátu TLS Ověření podpisu SU3 Historická data o době provozu Jakmile bude váš reseed (server pro počáteční připojení k síti I2P) zaregistrován u projektu I2P, automaticky se do 24 hodin objeví na checki2p.\nOdstraňování běžných problémů Problém: \u0026ldquo;Unable to read signing key\u0026rdquo; při prvním spuštění - Řešení: To je očekávané. Zadejte \u0026lsquo;y\u0026rsquo; pro vygenerování nových klíčů.\nProblém: Router nedokáže ověřit podpis - Příčina: Certifikát není v důvěryhodném úložišti routeru - Řešení: Umístěte certifikát do adresáře ~/.i2p/certificates/reseed/\nProblém: Stejný balíček je doručován různým klientům - Příčina: Hlavička X-Forwarded-For není správně předávána - Řešení: Povolte --trustProxy a nakonfigurujte hlavičky reverzní proxy\nProblém: chyby \u0026ldquo;Connection refused\u0026rdquo; - Příčina: Port není přístupný z internetu - Řešení: Zkontrolujte pravidla firewallu, ověřte přesměrování portů\nProblém: Vysoké využití CPU během znovusestavování balíčku - Příčina: Normální chování při generování 350+ variant SU3 (formát podepsaných aktualizačních balíčků v I2P) - Řešení: Zajistěte dostatečný výkon CPU, zvažte snížení frekvence znovusestavování\nReferenční informace Oficiální dokumentace Příručka pro přispěvatele k Reseed (počáteční zavedení klienta I2P stažením výchozích uzlů): /guides/creating-and-running-an-i2p-reseed-server/ Požadavky na zásady Reseed: /guides/reseed-policy/ Specifikace SU3: /docs/specs/updates/ Repozitář nástrojů pro Reseed: https://i2pgit.org/idk/reseed-tools Dokumentace k nástrojům pro Reseed: https://eyedeekay.github.io/reseed-tools/ Alternativní implementace PurpleI2P pyseeder: https://github.com/PurpleI2P/pyseeder DivaExchange i2p-reseed: https://github.com/diva-exchange/i2p-reseed RTradeLtd i2p-tools-1: https://github.com/RTradeLtd/i2p-tools-1 Python WSGI reseeder: https://github.com/torbjo/i2p-reseeder Komunitní zdroje I2P fórum: https://i2pforum.net/ Repozitář Gitea: https://i2pgit.org/I2P_Developers/i2p.i2p IRC: #i2p-dev na IRC2P Monitorování stavu: https://checki2p.com/reseed Historie verzí 0.9.14 (2014): Zaveden formát SU3 pro reseedování 0.9.16 (2014): Přidáno reseedování ze souborů 0.9.42 (2019): Vyžadován parametr dotazu Network ID 2.0.0 (2022): Zaveden transportní protokol SSU2 2.4.0 (2024): Izolace NetDB a vylepšení zabezpečení 2.6.0 (2024): Zablokována připojení I2P-over-Tor 2.10.0 (2025): Aktuální stabilní vydání (k září 2025) Referenční přehled typů podpisů Type Code Algorithm Key Size Signature Size Hash DSA-SHA10DSA1024-bit40 bytesSHA-1 ECDSA-SHA256-P2561ECDSAP-25664 bytesSHA-256 ECDSA-SHA384-P3842ECDSAP-38496 bytesSHA-384 ECDSA-SHA512-P5213ECDSAP-521132 bytesSHA-512 RSA-SHA256-20484RSA2048-bit256 bytesSHA-256 RSA-SHA384-30725RSA3072-bit384 bytesSHA-384 RSA-SHA512-40966RSA4096-bit512 bytesSHA-512 EdDSA-SHA512-Ed255197EdDSAEd2551964 bytesSHA-512 **Reseed Standard (standard pro reseed)**: Typ 6 (RSA-SHA512-4096) je vyžadován pro balíčky reseedu. Poděkování Díky všem provozovatelům reseedu za to, že udržují síť přístupnou a odolnou. Zvláštní poděkování následujícím přispěvatelům a projektům:\nzzz: Dlouholetý vývojář I2P a koordinátor reseedu (počáteční získání netDb z veřejných serverů) idk: Současný správce reseed-tools a správce vydání Nguyen Phong Hoang: Výzkum strategií reseedu odolných vůči cenzuře PurpleI2P Team: Alternativní implementace I2P a nástroje checki2p: Automatizovaná monitorovací služba pro infrastrukturu reseedu Decentralizovaná infrastruktura reseed (počátečního zavedení do sítě) sítě I2P představuje společné úsilí desítek provozovatelů po celém světě a zajišťuje, že noví uživatelé vždy najdou cestu, jak se k síti připojit, bez ohledu na místní cenzuru či technické překážky.\n","description":"Provozování služeb reseed (počáteční získání seznamu uzlů) a alternativních metod bootstrap (počáteční připojení k síti)","id":"02dba83ad9e38e1355d624c0d4fa28aa","section":"docs","title":"Servery pro reseed (počáteční naplnění sítě)","url":"/cs/docs/misc/reseed/"},{"categories":null,"content":" 1. Přehled netDb je specializovaná distribuovaná databáze obsahující pouze dva typy dat: - RouterInfos – kontaktní informace routeru - LeaseSets – kontaktní informace destinace\nVšechna data jsou kryptograficky podepsaná a ověřitelná. Každá položka obsahuje informace o liveness (živosti) pro vyřazování zastaralých položek a nahrazování neaktuálních, což chrání proti určitým třídám útoků.\nDistribuce používá mechanismus floodfill, kde podmnožina routers udržuje distribuovanou databázi.\n2. RouterInfo (informace o routeru) Když routers potřebují kontaktovat jiné routers, vyměňují si balíčky RouterInfo obsahující:\nIdentita routeru – šifrovací klíč, podpisový klíč, certifikát Kontaktní adresy – jak se spojit s routerem Časové razítko publikace – kdy byly tyto informace publikovány Libovolné textové možnosti – příznaky schopností a nastavení Kryptografický podpis – prokazuje pravost 2.1 Příznaky schopností Routers uvádějí své schopnosti pomocí písmenných kódů ve svém RouterInfo (záznam informací o routeru):\nFlag Meaning f Floodfill participation R Reachable U Unreachable D, E, G, H Various capability indicators ### 2.2 Klasifikace šířky pásma Code Bandwidth K Under 12 KBps L 12–48 KBps (default) M 48–64 KBps N 64–128 KBps O 128–256 KBps P 256–2000 KBps X Over 2000 KBps ### 2.3 Hodnoty ID sítě Value Purpose 0 Reserved 1 Current Network (default) 2 Reserved for Future Networks 3–15 Forks and Test Networks 16–254 Reserved 255 Reserved ### 2.4 Statistiky RouterInfo Routers zveřejňují volitelné statistiky stavu pro analýzu sítě: - Míry úspěchu/odmítnutí/vypršení časového limitu při sestavování Exploratory tunnel - 1hodinový průměr počtu účastnických tunnel\nStatistiky se řídí formátem stat_(statname).(statperiod) s hodnotami oddělenými středníkem.\nPříklad statistik:\nstat_tunnel.buildExploratoryExpire.60m = 0;0;0;53.14 stat_tunnel.buildExploratoryReject.60m = 0;0;0;15.51 stat_tunnel.buildExploratorySuccess.60m = 0;0;0;31.35 stat_tunnel.participatingTunnels.60m = 289.20 Floodfill routers mohou také publikovat: netdb.knownLeaseSets a netdb.knownRouters\n2.5 Možnosti rodiny Od verze 0.9.24 mohou routers deklarovat příslušnost k rodině (stejný provozovatel):\nfamily: Název rodiny family.key: Kód typu podpisu zřetězený s veřejným podpisovým klíčem kódovaným Base64 family.sig: Podpis názvu rodiny a 32bajtového hashe routeru Z jedné rodiny nebude v žádném jednotlivém tunnel použito více než jeden router.\n2.6 Vypršení platnosti RouterInfo Žádné vypršení platnosti během první hodiny od spuštění Žádné vypršení platnosti při 25 nebo méně uložených RouterInfos Doba vypršení se zkracuje, jak roste místní počet (72 hodin při \u0026lt;120 routers; ~30 hodin při 300 routers) SSU introducers (zprostředkovatelé připojení) vyprší za ~1 hodinu Floodfills používají 1hodinové vypršení platnosti pro všechny místní RouterInfos 3. LeaseSet LeaseSets dokumentují vstupní body pro tunnel pro konkrétní destinace a uvádějí:\nIdentita routeru brány tunnelu 4bajtové ID tunnelu Čas vypršení platnosti tunnelu LeaseSets (struktury s údaji o dosažitelnosti cíle v I2P) zahrnují:\nDestination (identifikátor cíle) – šifrovací klíč, podpisový klíč, certifikát Dodatečný veřejný šifrovací klíč – pro end‑to‑end garlic encryption (technika sdružování zpráv v I2P) Dodatečný veřejný podpisový klíč – určen pro revokaci (aktuálně se nepoužívá) Kryptografický podpis 3.1 Varianty LeaseSet Type Description Unpublished Destinations used only for outgoing connections aren't published to floodfill routers Revoked Published with zero leases, signed by additional signing key (not fully implemented) LeaseSet2 (LS2) As of 0.9.38, supports new encryption types, multiple encryption types, options, offline signing keys ([Proposal 123](/proposals/123-new-netdb-entries/)) Meta LeaseSet Tree-like DHT structure for multihomed services, supporting hundreds/thousands of destinations with long expirations (up to 18.2 hours) Encrypted LeaseSet (LS1) All leases encrypted with separate key; only those with the key can decode and contact the destination Encrypted LeaseSet (LS2) As of 0.9.38, destination hidden with only blinded public key and expiration visible to floodfill ### 3.2 Vypršení platnosti LeaseSet Běžné LeaseSets vyprší při nejpozdějším vypršení jejich lease (časově omezený záznam). Expirace LeaseSet2 je uvedena v hlavičce. Expirace u EncryptedLeaseSet a MetaLeaseSet se mohou lišit, s možným vynucením maximálního limitu.\n4. Bootstrapping (inicializace) Aby se router mohl začlenit do decentralizované netDb, je nutná alespoň jedna reference na peer. Reseeding (získání počátečních kontaktů) stahuje soubory RouterInfo (routerInfo-$hash.dat) z adresářů netDb dobrovolníků. Při prvním spuštění se automaticky stahuje z natvrdo zadaných URL vybraných náhodně.\n5. Mechanismus Floodfill floodfill netDb používá jednoduché distribuované ukládání: data se posílají nejbližšímu floodfill uzlu. Když uzly, které nejsou floodfill, posílají data k uložení, floodfill uzly je přepošlou podmnožině floodfill uzlů, které jsou nejblíže konkrétnímu klíči.\nÚčast v režimu floodfill je v RouterInfo označena jako příznak schopnosti (f).\n5.1 Požadavky pro dobrovolné zapojení do Floodfill Na rozdíl od natvrdo zabudovaných důvěryhodných adresářových serverů Toru je sada floodfillu (speciálních uzlů pro šíření netDb dat) v I2P nedůvěryhodná a v čase se mění.\nFloodfill se automaticky aktivuje pouze na routers s vysokou šířkou pásma, které splňují tyto požadavky: - Minimálně 128 KBytes/sec sdílené šířky pásma (ručně nakonfigurované) - Musí projít dalšími testy stavu (čas fronty odchozích zpráv, zpoždění úloh)\nSoučasné automatické opt-in (dobrovolné přihlášení) má za následek přibližně 6% účasti na floodfill v síti.\nRučně nakonfigurované uzly floodfill existují souběžně s automatickými dobrovolníky. Když počet uzlů floodfill klesne pod práh, routers s vysokou šířkou pásma se automaticky přihlásí jako dobrovolníci. Když existuje příliš mnoho uzlů floodfill, zruší svůj status floodfill.\n5.2 Role pro floodfill Kromě přijímání zápisů do netDb a odpovídání na dotazy vykonávají floodfill uzly standardní funkce routeru. Jejich vyšší šířka pásma obvykle znamená větší zapojení do tunnel, ale to přímo nesouvisí s databázovými službami.\n6. Metrika blízkosti v Kademlii netDb používá měření vzdálenosti ve stylu Kademlia založené na XOR. Hash SHA256 z RouterIdentity (identita routeru) nebo Destination (cílová identita) vytváří klíč Kademlia (s výjimkou LS2 Encrypted LeaseSets, které používají SHA256 s typovým bajtem o hodnotě 3 a oslepený veřejný klíč).\n6.1 Rotace klíčového prostoru Aby se zvýšily náklady na útoky typu Sybil, namísto použití SHA256(key) systém používá:\nSHA256(key + yyyyMMdd) kde datum je osmibajtové ASCII datum UTC. Tím se vytvoří směrovací klíč, který se každý den o půlnoci UTC mění — což se nazývá rotace klíčového prostoru.\nSměrovací klíče se nikdy nepřenášejí v I2NP zprávách; slouží pouze k lokálnímu určení vzdálenosti.\n7. Segmentace síťové databáze Tradiční Kademlia DHT nezachovávají nepropojitelnost uložených informací. I2P brání útokům, které spojují klientské tunnels s routers, implementací segmentace.\n7.1 Strategie segmentace Routers sledují: - Zda záznamy dorazily přes client tunnels nebo přímo - Pokud přes tunnel, který client tunnel/destinaci - Vícenásobné příchody přes tunnel se sledují - Rozlišují se odpovědi na uložení vs. na vyhledání\nObě implementace v Javě a C++ používají: - \u0026ldquo;Hlavní\u0026rdquo; netDb pro přímá vyhledávání/operace floodfill v kontextu routeru - \u0026ldquo;Klientské síťové databáze\u0026rdquo; nebo \u0026ldquo;Podřízené databáze\u0026rdquo; v klientských kontextech, zachycující záznamy zasílané do klientských tunnels\nKlientské netDbs (databáze sítě) existují pouze po dobu životního cyklu klienta a obsahují jen záznamy z klientských tunnels. Záznamy z klientských tunnels se nesmí překrývat s těmi, které dorazí přímo.\nKaždá netDb sleduje, zda záznamy dorazily jako uložení (odpovídají na požadavky na vyhledávání) nebo jako odpovědi na vyhledávání (odpovídají pouze tehdy, pokud byly dříve uloženy pro stejný cíl). Klienti nikdy neodpovídají na dotazy pomocí záznamů hlavního netDb, pouze pomocí záznamů klientské síťové databáze.\nKombinované strategie segmentují netDb proti útokům na propojení klienta s routerem.\n8. Ukládání, ověřování a vyhledávání 8.1 Ukládání RouterInfo u peerů I2NP DatabaseStoreMessage obsahující lokální RouterInfo (informace o routeru) pro výměnu během inicializace transportního spojení NTCP nebo SSU.\n8.2 Ukládání LeaseSet peerům I2NP DatabaseStoreMessage obsahující lokální LeaseSet se periodicky vyměňují prostřednictvím zpráv šifrovaných pomocí garlic encryption, které jsou součástí provozu Destination (identifikátor cíle v I2P), což umožňuje odpovědi bez nutnosti vyhledávání LeaseSet.\n8.3 Výběr floodfill DatabaseStoreMessage odesílá na floodfill nejblíže aktuálnímu směrovacímu klíči. Nejbližší floodfill je nalezen prostřednictvím vyhledávání v místní databázi. I když ve skutečnosti nemusí být nejbližší, zaplavování jej rozšíří \u0026ldquo;blíže\u0026rdquo; tím, že jej odešle na více floodfill uzlů.\nTradiční Kademlia používá před vložením vyhledávání \u0026ldquo;find-closest\u0026rdquo;. Zatímco I2NP takové zprávy nemá, routers mohou provádět iterativní vyhledávání s překlopeným nejméně významným bitem (key ^ 0x01), aby zajistily nalezení skutečně nejbližšího uzlu.\n8.4 Ukládání RouterInfo do Floodfills Routery publikují RouterInfo (informace o routeru) tak, že se přímo připojí k floodfillu a odešlou I2NP DatabaseStoreMessage s nenulovým Reply Tokenem (token pro odpověď). Zpráva není end-to-end garlic encrypted (přímé spojení, bez prostředníků). Floodfill odpoví DeliveryStatusMessage s použitím Reply Tokenu jako ID zprávy.\nRoutery mohou také posílat RouterInfo (datový záznam o routeru) přes průzkumný tunnel (limity připojení, nekompatibilita, skrývání IP). Floodfills mohou taková uložení během přetížení odmítnout.\n8.5 Ukládání LeaseSet do Floodfillů Ukládání LeaseSet je citlivější než RouterInfo. Routers musí zabránit přiřazení LeaseSet k sobě samým.\nRouters publikují LeaseSet přes odchozí client tunnel pomocí DatabaseStoreMessage s Reply Token (odpovědní token), který je nenulový. Zpráva je end-to-end garlic encrypted pomocí Session Key Manager (správce klíčů relace) Destination (identifikátor cíle v I2P), takže ji nevidí výstupní endpoint odchozího tunnel. Floodfill odpoví DeliveryStatusMessage, která se vrací přes příchozí tunnel.\n8.6 Proces zaplavování Floodfill uzly (uzly udržující netdb) ověřují RouterInfo (metadata o routeru)/LeaseSet (informace pro směrování k destinaci) před lokálním uložením pomocí adaptivních kritérií závislých na zátěži, velikosti netdb (síťová databáze I2P) a dalších faktorech.\nPo obdržení platnějších novějších dat je floodfill routery „floodují“ tak, že vyhledají 3 nejbližší floodfill routery ke směrovacímu klíči. Přímá spojení posílají I2NP DatabaseStoreMessage s nulovým Reply Token (odpovědním tokenem). Ostatní routery neodpovídají ani znovu „floodují“.\nDůležitá omezení: - Floodfills nesmí šířit přes tunnels; pouze přímá spojení - Floodfills nikdy nešíří expirovaný LeaseSet ani RouterInfo zveřejněné před více než hodinou\n8.7 Vyhledávání RouterInfo (informace o routeru) a LeaseSet I2NP DatabaseLookupMessage požaduje záznamy z netdb (síťová databáze I2P) od floodfill routers (speciální routery replikující netdb). Vyhledávání se odesílají přes odchozí průzkumný tunnel; odpovědi uvádějí návratovou cestu přes příchozí průzkumný tunnel.\nVyhledávací dotazy se obvykle posílají dvěma „dobrým“ floodfill routerům, které jsou nejblíže požadovanému klíči, paralelně.\nLokální shoda: obdrží odpověď I2NP DatabaseStoreMessage Žádná lokální shoda: obdrží I2NP DatabaseSearchReplyMessage s odkazy na jiné floodfill routery blízké hledanému klíči Vyhledávání LeaseSet používají end-to-end garlic encryption (od verze 0.9.5). Vyhledávání RouterInfo nejsou šifrovaná kvůli výpočetní náročnosti ElGamal, což je činí zranitelnými vůči odposlechu na odchozím koncovém bodu.\nOd verze 0.9.7 odpovědi na vyhledávací dotazy obsahují klíč relace a značku (tag), čímž je skrývají před vstupní bránou.\n8.8 Iterativní vyhledávání Před verzí 0.8.9: Dvě paralelní redundantní vyhledávání bez rekurzivního ani iterativního směrování.\nOd verze 0.8.9: Iterativní vyhledávání je implementováno bez redundance—efektivnější, spolehlivější a vhodné pro neúplnou znalost floodfill. Jak sítě rostou a routers znají méně floodfill, vyhledávání se blíží složitosti O(log n).\nIterativní vyhledávání pokračuje i bez odkazů na bližší uzly, čímž se zabrání škodlivému black-holingu (záměrnému pohlcování provozu bez odezvy). Platí aktuální maximální počet dotazů i časový limit.\n8.9 Ověření Ověřování RouterInfo (informace o routeru): Od verze 0.9.7.1 je deaktivováno, aby se zabránilo útokům popsaným ve studii \u0026ldquo;Practical Attacks Against the I2P Network\u0026rdquo;.\nOvěření LeaseSet: Routery čekají ~10 sekund, poté provedou vyhledání u jiného floodfill přes odchozí klientský tunnel. End-to-end garlic encryption to skrývá před odchozím koncovým bodem. Odpovědi se vracejí přes příchozí tunnels.\nOd verze 0.9.7 se odpovědi šifrují pomocí session key/tag hiding (skrývání klíče/značky relace), takže jsou skryté před vstupní bránou.\n8.10 Průzkum Průzkum zahrnuje vyhledávání v netdb s náhodnými klíči pro nalezení nových routerů. Uzly floodfill odpovídají zprávou DatabaseSearchReplyMessage, která obsahuje hashe routerů, jež nejsou floodfill, blízké požadovanému klíči. Průzkumné dotazy nastavují speciální příznak v DatabaseLookupMessage.\n9. MultiHoming (připojení k více sítím) Destinations (cílový identifikátor v I2P) používající stejné soukromé/veřejné klíče (tradiční eepPriv.dat) lze provozovat na více routerech současně. Každá instance periodicky publikuje podepsané LeaseSets; nejnovější zveřejněný LeaseSet se vrací žadatelům o vyhledání. Při maximální době platnosti 10 minut pro LeaseSet trvají výpadky nanejvýš ~10 minut.\nOd verze 0.9.38 Meta LeaseSets podporují rozsáhlé multihomed služby (služby s vícenásobným připojením k síti) využívající samostatné Destinace poskytující společné služby. Záznamy Meta LeaseSet jsou Destinace nebo jiné Meta LeaseSets s platností až 18,2 hodiny, což umožňuje, aby společné služby hostovaly stovky až tisíce Destinací.\n10. Analýza hrozeb Přibližně 1700 floodfill routerů je v současnosti v provozu. Růst sítě ztěžuje většinu útoků nebo snižuje jejich dopad.\n10.1 Obecná zmírňující opatření Růst: Více floodfills ztěžuje útoky nebo snižuje jejich dopad Redundance: Všechny záznamy v netdb se ukládají prostřednictvím flooding (zaplavování) na 3 floodfill routers nejblíže ke klíči Podpisy: Všechny záznamy jsou podepsány tvůrcem; falšování je nemožné 10.2 Pomalé nebo nereagující Routers Routers udržují rozšířené statistiky profilů uzlů pro floodfills:\nPrůměrná doba odezvy Procento zodpovězených dotazů Procento úspěšnosti ověření uložení Poslední úspěšné uložení Poslední úspěšné vyhledání Poslední odpověď Routers používají tyto metriky při určování \u0026ldquo;vhodnosti\u0026rdquo; pro výběr nejbližší floodfill. Zcela nereagující routers jsou rychle identifikovány a je jim vyhýbáno; částečně zlovolné routers představují větší výzvu.\n10.3 Sybil útok (celý klíčový prostor) Útočníci mohou za účelem účinného DOS útoku vytvořit početné routery typu floodfill rozmístěné napříč prostorem klíčů.\nPokud se chování nejeví natolik závadné, aby si zasloužilo označení \u0026ldquo;bad\u0026rdquo;, možné reakce zahrnují: - Sestavování seznamů \u0026ldquo;bad\u0026rdquo; hashů/IP adres routerů a jejich oznamování prostřednictvím novinek v konzoli, webu a fóra - Celosíťové povolení floodfill (\u0026ldquo;bojovat proti Sybil (útok Sybil) ještě více Sybil\u0026rdquo;) - Nové verze softwaru s natvrdo zakódovanými seznamy \u0026ldquo;bad\u0026rdquo; - Vylepšené metriky profilů peerů a prahové hodnoty pro automatickou identifikaci - Kvalifikace IP bloků vylučující více floodfillů v jediném IP bloku - Automatický blacklist založený na odběru (podobně jako konsenzus Toru)\nVětší sítě to ztěžují.\n10.4 Sybil útok (částečný klíčový prostor) Útočníci mohou vytvořit 8–15 floodfill routers těsně seskupených v klíčovém prostoru. Všechny operace vyhledávání/ukládání pro tento klíčový prostor jsou směrovány na routery útočníka, což umožňuje útok DoS na konkrétní I2P stránky.\nJelikož klíčový prostor indexuje kryptografické hashe SHA256, útočníci musí použít hrubou sílu k vytvoření routerů s dostatečnou blízkostí.\nObrana: Algoritmus blízkosti Kademlia se v čase mění pomocí SHA256(key + YYYYMMDD), každý den o půlnoci UTC. Tato keyspace rotation (rotace prostoru klíčů) vynucuje denní obnovu útoku.\nPoznámka: Nedávný výzkum ukazuje, že rotace prostoru klíčů není obzvlášť účinná—útočníci mohou předpočítat hashe routerů, takže k zastínění částí prostoru klíčů jim stačí jen několik routerů během půl hodiny po rotaci.\nDůsledek denní rotace: distribuovaná netdb se po rotaci na několik minut stává nespolehlivou—dotazy selhávají, než nový nejbližší router obdrží stores (zprávy pro uložení).\n10.5 Útoky při bootstrapu (počáteční inicializaci) Útočníci by mohli převzít kontrolu nad reseed webovými stránkami (weby/servery poskytujícími bootstrap novým routerům) nebo přimět vývojáře k přidání nepřátelských reseed webových stránek, čímž by uváděli nové routery do izolovaných/většinově kontrolovaných sítí.\nImplementovaná obranná opatření: - Načítat podmnožiny RouterInfo (informace o routeru) z více reseed sites (bootstrap serverů), nikoli z jediného serveru - Mimo-síťové monitorování reseed, které periodicky dotazuje servery - Od verze 0.9.14 jsou balíčky reseed dat poskytovány jako podepsané soubory ZIP s ověřením staženého podpisu (viz specifikace su3 )\n10.6 Zachycení dotazů Floodfill routery mohou \u0026ldquo;nasměrovat\u0026rdquo; protějšky na routery kontrolované útočníkem prostřednictvím vrácených referencí.\nNepravděpodobné prostřednictvím průzkumu kvůli nízké frekvenci; reference na peery se získávají hlavně běžným vytvářením tunnel.\nOd verze 0.8.9 jsou implementována iterativní vyhledávání. Reference floodfill uvedené v DatabaseSearchReplyMessage se následují, pokud jsou blíže vyhledávacímu klíči. Požadující router nedůvěřuje blízkosti referencí. Vyhledávání pokračuje i když nejsou k dispozici bližší klíče, a to až do vypršení časového limitu/maximálního počtu dotazů, což brání škodlivému black-holingu (pohlcování provozu).\n10.7 Úniky informací Únik informací v DHT (distribuovaná hašovací tabulka) v I2P vyžaduje další prošetření. Floodfill routers pozorují dotazy a shromažďují informace. Při podílu škodlivých uzlů 20 % se dříve popsané hrozby Sybil (útok založený na mnohonásobné identitě) stávají problematickými z více důvodů.\n11. Budoucí práce End-to-end šifrování (šifrování mezi koncovými body) dalších dotazů do netDb a jejich odpovědí Lepší metody sledování odpovědí na dotazy Metody zmírnění problémů se spolehlivostí při rotaci klíčového prostoru 12. Reference Specifikace obecných struktur – struktury RouterInfo a LeaseSet Specifikace I2NP – typy databázových zpráv Návrh 123: Nové záznamy v netDb – specifikace LeaseSet2 Historická diskuse o netDb – historie vývoje a archivované diskuse ","description":"Porozumění distribuované síťové databázi I2P (netDb) - specializovaná distribuovaná hashovací tabulka (DHT) pro kontaktní informace routerů a vyhledávání destinací","id":"ef0a5e8bee4372a50a7f4562af717b0c","section":"docs","title":"Síťová databáze","url":"/cs/docs/overview/network-database/"},{"categories":null,"content":"Přehled Síťový protokol I2P (I2NP) definuje, jak routers vyměňují zprávy, volí transportní protokoly a mísí provoz při zachování anonymity. Funguje mezi I2CP (klientské API) a transportními protokoly (NTCP2 a SSU2).\nI2NP je vrstva nad transportními protokoly I2P. Je to protokol router-to-router (komunikace přímo mezi routery) používaný pro: - Vyhledávání v síťové databázi a odpovědi - Vytváření tunnelů - Šifrované datové zprávy routeru a klienta\nZprávy I2NP lze posílat bod-bod na jiný router nebo anonymně přes tunnels na tentýž router.\nRouters řadí odchozí úlohy do fronty podle lokálních priorit. Vyšší čísla priority se zpracovávají dříve. Cokoli nad standardní prioritu dat pro tunnel (400) se považuje za naléhavé.\nSoučasné transportní protokoly I2P nyní používá NTCP2 (TCP) a SSU2 (UDP) pro IPv4 i IPv6. Oba transporty používají: - X25519 pro výměnu klíčů (rámec protokolu Noise) - ChaCha20/Poly1305 pro autentizované šifrování s přidruženými daty (AEAD) - SHA-256 pro hashování\nZastaralé transporty odstraněny: - NTCP (původní TCP) byl odstraněn z Java routeru ve verzi 0.9.50 (květen 2021) - SSU v1 (původní UDP) byl odstraněn z Java routeru ve verzi 2.4.0 (prosinec 2023) - SSU v1 byl odstraněn z i2pd ve verzi 2.44.0 (listopad 2022)\nOd roku 2025 síť zcela přešla na transportní protokoly založené na Noise (sada kryptografických handshake protokolů) bez jakékoli podpory starších transportů.\nSystém číslování verzí DŮLEŽITÉ: I2P používá dvojí systém verzování, kterému je nutné jasně rozumět:\nVerze vydání (určené pro uživatele) Toto jsou verze, které uživatelé vidí a stahují: - 0.9.50 (květen 2021) - Poslední vydání řady 0.9.x - 1.5.0 (srpen 2021) - První vydání řady 1.x - 1.6.0, 1.7.0, 1.8.0, 1.9.0 (v letech 2021-2022) - 2.0.0 (listopad 2022) - První vydání řady 2.x - 2.1.0 až 2.9.0 (v letech 2023-2025) - 2.10.0 (8. září 2025) - Aktuální vydání\nVerze API (kompatibilita protokolů) Toto jsou interní čísla verzí zveřejněná v poli \u0026ldquo;router.version\u0026rdquo; ve vlastnostech RouterInfo: - 0.9.50 (květen 2021) - 0.9.51 (srpen 2021) - Verze API pro vydání 1.5.0 - 0.9.52 až 0.9.66 (pokračuje napříč vydáními 2.x) - 0.9.67 (září 2025) - Verze API pro vydání 2.10.0\nKlíčový bod: Nevyšla ŽÁDNÁ vydání s označením 0.9.51 až 0.9.67. Tato čísla existují pouze jako identifikátory verzí API. I2P přeskočilo z vydání 0.9.50 přímo na 1.5.0.\nTabulka mapování verzí Release Version API Version Date Key Features 0.9.50 0.9.50 May 2021 Last 0.9.x release, removed NTCP1 1.5.0 0.9.51 August 2021 Short tunnel build messages (218 bytes) 1.6.0 0.9.52 November 2021 Various improvements 1.7.0 0.9.53 January 2022 Performance enhancements 1.8.0 0.9.54 May 2022 SSU2 introduced 1.9.0 0.9.55 August 2022 SSU2 improvements 2.0.0 0.9.56 November 2022 SSU2 enabled by default 2.1.0 0.9.57 January 2023 Stability improvements 2.2.0 0.9.58 March 2023 ElGamal routers deprecated 2.3.0 0.9.59 May 2023 Various improvements 2.4.0 0.9.61 December 2023 Removed SSU1 support 2.5.0 0.9.62 February 2024 Performance improvements 2.6.0 0.9.63 May 2024 Network optimizations 2.7.0 0.9.64 October 2024 Post-quantum preparation work 2.8.0 0.9.65 February 2025 Tunnel bandwidth parameters 2.9.0 0.9.66 June 2025 LeaseSet service records 2.10.0 0.9.67 September 2025 Post-quantum hybrid cryptography (beta) **Nadcházející:** Verze 2.11.0 (plánováno na prosinec 2025) bude vyžadovat Javu 17+ a ve výchozím nastavení povolí postkvantovou kryptografii. Verze protokolů Všechny routery musí uvádět svou verzi protokolu I2NP v poli \u0026ldquo;router.version\u0026rdquo; ve vlastnostech RouterInfo (informační záznam o routeru). Tato verze je verzí API, která udává úroveň podpory různých funkcí protokolu I2NP, a nemusí nutně odpovídat skutečné verzi routeru.\nPokud alternativní (non-Java) routers chtějí zveřejnit jakékoli informace o verzi samotné implementace routeru, musejí tak učinit v jiné vlastnosti. Jsou povoleny i jiné verze než ty uvedené níže. Podpora bude určena číselným porovnáním; například 0.9.13 implikuje podporu funkcí verze 0.9.12.\nPoznámka: Vlastnost \u0026ldquo;coreVersion\u0026rdquo; se již v informacích o routeru nezveřejňuje a nikdy se nepoužívala k určení verze protokolu I2NP.\nPřehled funkcí podle verze API API Version Required I2NP Features 0.9.67Post-quantum hybrid cryptography (MLKEM ratchet) support (beta), UDP tracker support 0.9.66LeaseSet2 service record options (see proposal 167) 0.9.65Tunnel build bandwidth parameters (see proposal 168) 0.9.59Minimum peers will build tunnels through (as of 0.9.63), minimum floodfill peers will send DSM to (as of 0.9.63) 0.9.58Minimum peers will build tunnels through (as of 0.9.62), ElGamal routers deprecated 0.9.55SSU2 transport support (if published in router info) 0.9.51Short tunnel build messages for ECIES-X25519 routers, minimum peers will build tunnels through (as of 0.9.58), minimum floodfill peers will send DSM to (as of 0.9.58) 0.9.49Garlic messages to ECIES-X25519 routers 0.9.48ECIES-X25519 routers, ECIES-X25519 build request/response records 0.9.46DatabaseLookup flag bit 4 for AEAD reply 0.9.44ECIES-X25519 keys in LeaseSet2 0.9.40MetaLeaseSet may be sent in a DSM 0.9.39EncryptedLeaseSet may be sent in a DSM, RedDSA_SHA512_Ed25519 signature type supported 0.9.38DSM type bits 3-0 now contain the type; LeaseSet2 may be sent in a DSM 0.9.36NTCP2 transport support (if published in router info), minimum peers will build tunnels through (as of 0.9.46) 0.9.28RSA signature types disallowed, minimum floodfill peers will send DSM to (as of 0.9.34) 0.9.18DSM type bits 7-1 ignored 0.9.16RI key certs / ECDSA and EdDSA signature types, DLM lookup types (flag bits 3-2), minimum version compatible with the current network 0.9.15Destination/LeaseSet key certificates with EdDSA Ed25519 signature type (if floodfill) 0.9.12Destination/LeaseSet key certificates with ECDSA P-256, P-384, and P-521 signature types (if floodfill); non-zero expiration allowed in RouterAddress 0.9.7Encrypted DSM/DSRM replies supported (DLM flag bit 1) for floodfill routers 0.9.6Non-zero DLM flag bits 7-1 allowed 0.9.3Requires zero expiration in RouterAddress 0.9Supports up to 16 leases in a DSM LeaseSet store (previously 6) 0.7.12VTBM and VTBRM message support 0.7.10Floodfill supports encrypted DSM stores 0.6.1.10TBM and TBRM messages introduced; minimum version compatible with the current network **Poznámka:** Existují také funkce související s transportem a problémy s kompatibilitou. Podrobnosti viz dokumentaci k transportům NTCP2 a SSU2. Hlavička zprávy I2NP používá logickou strukturu hlavičky o velikosti 16 bajtů, zatímco moderní transporty (NTCP2 a SSU2) používají zkrácenou 9bajtovou hlavičku, která vynechává redundantní pole velikosti a kontrolního součtu. Pole zůstávají koncepčně shodná.\nSrovnání formátu hlavičky Standardní formát (16 bajtů):\nPoužívá se v zastaralém transportu NTCP a když jsou zprávy I2NP vnořeny do jiných zpráv (TunnelData, TunnelGateway, GarlicClove).\nBytes 0-15: +----+----+----+----+----+----+----+----+ |type| msg_id | expiration +----+----+----+----+----+----+----+----+ | size |chks| +----+----+----+----+----+----+----+----+ type :: Integer (1 byte) Identifies the message type (see message type table) msg_id :: Integer (4 bytes) Uniquely identifies this message (for some time at least) Usually a locally-generated random number, but for outgoing tunnel build messages may be derived from the incoming message expiration :: Date (8 bytes) Unix timestamp in milliseconds when this message expires size :: Integer (2 bytes) Length of the payload (0 to ~61.2 KB for tunnel messages) chks :: Integer (1 byte) SHA256 hash of payload truncated to first byte Deprecated - NTCP2/SSU2 use ChaCha20/Poly1305 AEAD for integrity Krátký formát pro SSU (zastaralý, 5 bajtů):\n+----+----+----+----+----+ |type| short_expiration | +----+----+----+----+----+ type :: Integer (1 byte) short_expiration :: Integer (4 bytes, seconds since epoch) Krátký formát pro NTCP2, SSU2 a ECIES-Ratchet (postupný klíčový mechanismus ECIES) Garlic Cloves (podsložky zprávy v garlic encryption) (9 bajtů):\nPoužívá se v moderních transportech a v garlic messages (garlicových zprávách) šifrovaných pomocí ECIES.\n+----+----+----+----+----+----+----+----+ |type| msg_id | short_expira- +----+----+----+----+----+----+----+----+ tion| +----+ type :: Integer (1 byte) msg_id :: Integer (4 bytes) short_expiration :: Integer (4 bytes, seconds since epoch, unsigned) Podrobnosti o polích hlavičky Field Bytes Description Type 1 Identifies the message class (0\u0026ndash;255, see message types below) Unique ID 4 Locally unique identifier for matching replies Expiration 8 (standard) / 4 (short) Timestamp when the message expires. Routers discard expired messages. Short format uses seconds since epoch (unsigned, wraps February 7, 2106) Payload Length 2 Size in bytes (0 to ~61.2 KB for tunnel messages). NTCP2 and SSU2 encode this in their frame headers Checksum 1 Deprecated. First byte of SHA-256 hash of the payload. NTCP2/SSU2 use ChaCha20/Poly1305 AEAD for integrity ### Poznámky k implementaci Při přenosu přes SSU (zastaralé) byly zahrnuty pouze typ a 4bajtová doba platnosti Při přenosu přes NTCP2 nebo SSU2 se používá 9bajtový krátký formát Pro zprávy I2NP obsažené v jiných zprávách (Data, TunnelData, TunnelGateway, GarlicClove) je vyžadována standardní 16bajtová hlavička Od verze 0.8.12 je na některých místech v zásobníku protokolů z důvodu efektivity ověřování kontrolního součtu vypnuto, ale generování kontrolního součtu je kvůli kompatibilitě stále vyžadováno Krátká doba platnosti je bez znaménka a 7. února 2106 dojde k přetočení. Po tomto datu je nutné přičíst offset (posun), aby se získal správný čas Pro kompatibilitu se staršími verzemi vždy generujte kontrolní součty, i když nemusí být ověřovány Omezení velikosti Zprávy tunnel fragmentují užitečná data I2NP na části pevné velikosti:\nPrvní fragment: přibližně 956 bajtů Následující fragmenty: přibližně 996 bajtů každý Maximální počet fragmentů: 64 (očíslované 0–63) Maximální velikost užitečných dat: přibližně 61 200 bajtů (61,2 KB) Výpočet: 956 + (63 × 996) = 63,704 bajtů jako teoretické maximum, s praktickým limitem kolem 61,200 bajtů kvůli režii.\nHistorický kontext Starší transporty měly přísnější limity velikosti rámců: - NTCP: rámce o velikosti 16 KB - SSU: rámce o velikosti přibližně 32 KB\nNTCP2 podporuje rámce o velikosti přibližně 65 KB, ale limit fragmentace pro tunnel stále platí.\nÚvahy týkající se dat aplikací Garlic messages (typ zpráv používaný v rámci garlic encryption) mohou zahrnovat LeaseSets, značky relace, nebo šifrované varianty LeaseSet2, čímž se snižuje prostor pro užitečná data.\nDoporučení: Datagramy by měly zůstat ≤ 10 KB pro zajištění spolehlivého doručení. Zprávy blížící se limitu 61 KB mohou zaznamenat: - Zvýšenou latenci kvůli opětovnému sestavení fragmentů - Vyšší pravděpodobnost selhání doručení - Větší vystavení analýze provozu\nTechnické podrobnosti fragmentace Každá zpráva tunnelu má přesně 1,024 bajtů (1 KB) a obsahuje: - 4bajtové tunnel ID - 16bajtový inicializační vektor (IV) - 1,004 bajtů šifrovaných dat\nV rámci šifrovaných dat zprávy tunnelu přenášejí fragmentované zprávy I2NP s hlavičkami fragmentů, které uvádějí:\nČíslo fragmentu (0-63) Zda se jedná o první, nebo navazující fragment ID celé zprávy pro opětovné sestavení První fragment obsahuje úplnou hlavičku zprávy I2NP (16 bajtů), takže pro užitečná data zbývá přibližně 956 bajtů. Následující fragmenty hlavičku zprávy neobsahují, což umožňuje přibližně 996 bajtů užitečných dat na fragment.\nBěžné typy zpráv Routers používají typ zprávy a prioritu k plánování odchozí práce. Vyšší hodnoty priority jsou zpracovány jako první. Hodnoty níže odpovídají aktuálním výchozím hodnotám Java I2P (k verzi API 0.9.67).\nPoznámka: Priority závisejí na implementaci. Pro závazné hodnoty priorit nahlédněte do dokumentace třídy OutNetMessage ve zdrojovém kódu Java I2P.\nMessage Type Priority Typical Size Purpose DatabaseStore 1 460 Varies (LeaseSet ≈ 898\u0026nbsp;B, RouterInfo ≈ 2\u0026ndash;4\u0026nbsp;KB compressed) Publishes RouterInfo or LeaseSet objects. Supports LeaseSet2, EncryptedLeaseSet, and MetaLeaseSet DatabaseLookup 2 500 Varies Queries the network database for RouterInfo or LeaseSet entries DatabaseSearchReply 3 300 ≈161\u0026nbsp;B (5 hashes) Returns candidate floodfill router hashes (typically 3\u0026ndash;16 hashes, recommended maximum 16) DeliveryStatus 10 Varies 12\u0026nbsp;B Receipts for tunnel tests or acknowledgements inside GarlicMessages GarlicMessage 11 100 (local) Varies Bundles multiple message cloves (e.g., DataMessage, LeaseSets). Supports ElGamal/AES (deprecated) and ECIES-X25519-AEAD-Ratchet encryption TunnelData 18 400 1,028\u0026nbsp;B (fixed) Encrypted tunnel message exchanged between hops. Contains a 4-byte tunnel ID, 16-byte IV, and 1,004 bytes of encrypted data TunnelGateway 19 300\u0026ndash;400 Varies Encapsulates messages at the tunnel gateway before fragmentation DataMessage 20 425 4\u0026ndash;62\u0026nbsp;KB Carries end-to-end garlic payloads (application traffic) TunnelBuild (deprecated) 21 500 4,224\u0026nbsp;B Requests tunnel participation from routers (8 × 528-byte records). Replaced by VariableTunnelBuild for ECIES TunnelBuildReply (deprecated) 22 300 4,224\u0026nbsp;B Replies to TunnelBuild with accept/reject status per hop VariableTunnelBuild 23 500 1,057\u0026ndash;4,225\u0026nbsp;B Variable-length tunnel build for ElGamal or ECIES-X25519 routers (1\u0026ndash;8 records, API 0.9.12+) VariableTunnelBuildReply 24 300 1,057\u0026ndash;4,225\u0026nbsp;B Replies to VariableTunnelBuild ShortTunnelBuild 25 500 873\u0026ndash;1,745\u0026nbsp;B Short tunnel build messages for ECIES-X25519 routers only (1\u0026ndash;8 × 218-byte records, API 0.9.51+) OutboundTunnelBuildReply 26 300 873\u0026ndash;1,745\u0026nbsp;B Sent from outbound endpoint to originator for ECIES-X25519 routers (API 0.9.51+) **Vyhrazené typy zpráv:** - Typ 0: Vyhrazeno - Typy 4-9: Vyhrazeno pro budoucí použití - Typy 12-17: Vyhrazeno pro budoucí použití - Typy 224-254: Vyhrazeno pro experimentální zprávy - Typ 255: Vyhrazeno pro budoucí rozšíření Poznámky k typům zpráv Zprávy řídicí roviny (DatabaseLookup, TunnelBuild apod.) obvykle putují přes průzkumné tunnels (virtuální okruhy v I2P), nikoli klientské tunnels, což umožňuje nezávislé určování priority Hodnoty priorit jsou přibližné a mohou se lišit podle implementace TunnelBuild (21) a TunnelBuildReply (22) jsou zastaralé, ale stále implementované kvůli kompatibilitě s velmi dlouhými tunnels (\u0026gt;8 skoků) Standardní priorita dat pro tunnel je 400; cokoli nad tímto je považováno za naléhavé Typická délka tunnel v dnešní síti je 3–4 skoky, takže většina sestavení tunnel používá ShortTunnelBuild (záznamy o velikosti 218 bajtů) nebo VariableTunnelBuild (záznamy o velikosti 528 bajtů) Šifrování a zapouzdřování zpráv Routers často zapouzdřují zprávy I2NP před přenosem, čímž vytvářejí více vrstev šifrování. Zpráva DeliveryStatus může být: 1. Vložená do GarlicMessage (zašifrovaná) 2. Uvnitř DataMessage 3. Uvnitř zprávy TunnelData (znovu zašifrovaná)\nKaždý skok dešifruje pouze svou vrstvu; koncový cíl odhalí nejvnitřnější užitečná data.\nŠifrovací algoritmy Zastaralé (postupně vyřazováno): - ElGamal/AES + SessionTags (značky relace) - ElGamal-2048 pro asymetrické šifrování - AES-256 pro symetrické šifrování - 32bajtové session tags\nAktuální (standard od API 0.9.48): - ECIES-X25519 + ChaCha20/Poly1305 AEAD s ratcheting forward secrecy (průběžně obnovované dopředné utajení) - rámec protokolu Noise (Noise_IK_25519_ChaChaPoly_SHA256 pro destinace) - 8bajtové značky relace (zmenšeno z 32 bajtů) - algoritmus Signal Double Ratchet pro dopředné utajení - Zavedeno ve verzi API 0.9.46 (2020) - Povinné pro všechny routers od verze API 0.9.58 (2023)\nBudoucnost (Beta od verze 2.10.0): - Postkvantová hybridní kryptografie používající MLKEM (ML-KEM-768) v kombinaci s X25519 - Hybridní ratchet (kryptografický krokovací mechanismus) kombinující klasické i postkvantové vyjednávání klíče - Zpětně kompatibilní s ECIES-X25519 - Stane se výchozí ve vydání 2.11.0 (prosinec 2025)\nOznačení ElGamal routeru za zastaralý KRITICKÉ: ElGamal routery byly označeny jako zastaralé od verze API 0.9.58 (vydání 2.2.0, březen 2023). Jelikož doporučená minimální verze floodfill pro dotazování je nyní 0.9.58, implementace nemusejí implementovat šifrování pro ElGamal floodfill routery.\nNicméně: Cíle ElGamal jsou stále podporovány kvůli zpětné kompatibilitě. Klienti používající šifrování ElGamal mohou nadále komunikovat prostřednictvím ECIES routers.\nPodrobnosti o ECIES-X25519-AEAD-Ratchet (kryptografický mechanismus) Toto je crypto type 4 (typ kryptografie číslo 4) v kryptografické specifikaci I2P. Poskytuje:\nKlíčové vlastnosti: - Dopředné utajení pomocí ratcheting (nové klíče pro každou zprávu) - Snížené nároky na ukládání značek relací (8 bajtů vs. 32 bajtů) - Více typů relací (New Session, Existing Session, One-Time) - Založeno na protokolu Noise Noise_IK_25519_ChaChaPoly_SHA256 - Integrované s algoritmem Double Ratchet od Signalu\nKryptografická primitiva: - X25519 pro dohodu o klíči Diffie-Hellman - ChaCha20 pro proudové šifrování - Poly1305 pro autentizaci zpráv (AEAD, autentizované šifrování s přidruženými daty) - SHA-256 pro hašování - HKDF pro odvozování klíčů\nSpráva relací: - Nová relace: Počáteční spojení s použitím statického klíče cíle - Stávající relace: Následné zprávy s využitím značek relace - Jednorázová relace: Relace s jedinou zprávou pro nižší režii\nViz Specifikace ECIES a Návrh 144 pro úplné technické podrobnosti.\nSpolečné struktury Následující struktury jsou součástí více zpráv I2NP. Nejedná se o úplné zprávy.\nBuildRequestRecord (záznam požadavku na sestavení) (ElGamal) ZASTARALÉ. Používá se v současné síti pouze tehdy, když tunnel obsahuje ElGamal router. Viz ECIES Tunnel Creation pro moderní formát.\nÚčel: Jeden záznam v sadě více záznamů k vyžádání vytvoření jednoho skoku v rámci tunnel.\nFormát:\nZašifrováno pomocí ElGamal a AES (celkem 528 bajtů):\n+----+----+----+----+----+----+----+----+ | encrypted data (528 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ ElGamalem šifrovaná struktura (528 bajtů):\n+----+----+----+----+----+----+----+----+ | toPeer (16 bytes) | +----+----+----+----+----+----+----+----+ | ElGamal encrypted data (512 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ toPeer :: First 16 bytes of SHA-256 hash of peer\u0026#39;s RouterIdentity encrypted_data :: ElGamal-2048 encrypted (bytes 1-256 and 258-513 of the 514-byte ElGamal block, with padding bytes at positions 0 and 257 removed) Struktura otevřeného textu (222 bajtů před šifrováním):\n+----+----+----+----+----+----+----+----+ | receive_tunnel (4) | our_ident (32) | +----+----+----+----+ + | | + +----+----+----+----+ | | next_tunnel (4) | +----+----+----+----+----+----+----+----+ | next_ident (32 bytes) | + + | | +----+----+----+----+----+----+----+----+ | layer_key (32 bytes) | + + | | +----+----+----+----+----+----+----+----+ | iv_key (32 bytes) | + + | | +----+----+----+----+----+----+----+----+ | reply_key (32 bytes) | + + | | +----+----+----+----+----+----+----+----+ | reply_iv (16 bytes) | + + | | +----+----+----+----+----+----+----+----+ |flag| request_time (4) | send_msg_id | +----+----+----+----+----+----+----+----+ (4) | padding (29) | +----+----+----+----+----+ + | | + +----+----+ | | +----+----+----+----+----+----+ receive_tunnel :: TunnelId (4 bytes, nonzero) our_ident :: Hash (32 bytes) next_tunnel :: TunnelId (4 bytes, nonzero) next_ident :: Hash (32 bytes) layer_key :: SessionKey (32 bytes) iv_key :: SessionKey (32 bytes) reply_key :: SessionKey (32 bytes) reply_iv :: 16 bytes flag :: Integer (1 byte) request_time :: Integer (4 bytes, hours since epoch = time / 3600) send_message_id :: Integer (4 bytes) padding :: 29 bytes random data Poznámky: - Šifrování ElGamal-2048 vytváří 514bajtový blok, ale dva vycpávkové bajty (na pozicích 0 a 257) jsou odstraněny, takže výsledkem je 512 bajtů - Viz Specifikace vytváření Tunnelu pro podrobnosti o polích - Zdrojový kód: net.i2p.data.i2np.BuildRequestRecord - Konstanta: EncryptedBuildRecord.RECORD_SIZE = 528\nBuildRequestRecord (ECIES-X25519 dlouhý) Pro ECIES-X25519 routers, uvedené ve verzi API 0.9.48. Používá 528 bajtů pro zpětnou kompatibilitu se smíšenými tunnels.\nFormát:\n+----+----+----+----+----+----+----+----+ | toPeer (16 bytes) | +----+----+----+----+----+----+----+----+ | ephemeral_key (32 bytes) | + + | | +----+----+----+----+----+----+----+----+ | ChaCha20 encrypted data (464 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ | Poly1305 MAC (16 bytes) | + + | | +----+----+----+----+----+----+----+----+ toPeer :: First 16 bytes of SHA-256 hash of peer\u0026#39;s RouterIdentity ephemeral_key :: X25519 ephemeral public key (32 bytes) encrypted_data :: ChaCha20 encrypted (464 bytes) mac :: Poly1305 message authentication code (16 bytes) Celková velikost: 528 bajtů (stejná jako u ElGamalu kvůli kompatibilitě)\nViz ECIES Tunnel Creation pro podrobnosti o struktuře nešifrovaných dat a šifrování.\nBuildRequestRecord (ECIES-X25519 Short) (záznam požadavku na sestavení) Pouze pro ECIES-X25519 routers, od verze API 0.9.51 (vydání 1.5.0). Toto je aktuální standardní formát.\nFormát:\n+----+----+----+----+----+----+----+----+ | toPeer (16 bytes) | +----+----+----+----+----+----+----+----+ | ephemeral_key (32 bytes) | + + | | +----+----+----+----+----+----+----+----+ | ChaCha20 encrypted data (154 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ | Poly1305 MAC (16 bytes) | + + | | +----+----+----+----+----+----+----+----+ toPeer :: First 16 bytes of SHA-256 hash of peer\u0026#39;s RouterIdentity ephemeral_key :: X25519 ephemeral public key (32 bytes) encrypted_data :: ChaCha20 encrypted (154 bytes) mac :: Poly1305 message authentication code (16 bytes) Celková velikost: 218 bajtů (snížení o 59 % oproti 528 bajtům)\nKlíčový rozdíl: Krátké záznamy odvozují VŠECHNY klíče pomocí HKDF (funkce pro odvozování klíčů), místo aby je do záznamu explicitně zahrnovaly. To zahrnuje: - Klíče vrstvy (pro šifrování tunnelu) - IV klíče (pro šifrování tunnelu) - Reply klíče (pro build reply) - Reply IVs (pro build reply)\nVšechny klíče jsou odvozeny pomocí mechanismu HKDF protokolu Noise na základě sdíleného tajemství z výměny klíčů X25519.\nVýhody: - 4 krátké záznamy se vejdou do jedné zprávy pro tunnel (873 bajtů) - 3 zprávové tunnel builds (sestavení tunnelu) místo samostatných zpráv pro každý záznam - Snížené nároky na šířku pásma a latenci - Stejné bezpečnostní vlastnosti jako dlouhý formát\nViz Návrh 157 pro odůvodnění a ECIES Tunnel Creation pro úplnou specifikaci.\nZdrojový kód: - net.i2p.data.i2np.ShortEncryptedBuildRecord - Konstanta: ShortEncryptedBuildRecord.RECORD_SIZE = 218\nBuildResponseRecord (ElGamal) (záznam odpovědi pro sestavení) ZASTARALÉ. Používá se pouze, pokud tunnel obsahuje ElGamal router.\nÚčel: Jeden záznam v sadě více záznamů obsahujících odpovědi na požadavek na sestavení.\nFormát:\nŠifrované (528 bajtů, stejná velikost jako BuildRequestRecord (záznam požadavku na sestavení tunnelu)):\nbytes 0-527 :: AES-encrypted record Nešifrovaná struktura:\n+----+----+----+----+----+----+----+----+ | SHA-256 hash (32 bytes) | + + | (hash of bytes 32-527) | + + | | +----+----+----+----+----+----+----+----+ | random data (495 bytes) | ~ ~ | |ret | +----+----+----+----+----+----+----+----+ bytes 0-31 :: SHA-256 hash of bytes 32-527 bytes 32-526 :: Random data (could be used for congestion info) byte 527 :: Reply code (0 = accept, 30 = reject) Kódy odpovědí: - 0 - Přijmout - 30 - Odmítnout (kvůli překročení šířky pásma)\nViz Tunnel Creation Specification pro podrobnosti o poli odpovědi.\nBuildResponseRecord (záznam odpovědi na sestavení) (ECIES-X25519) Pro ECIES-X25519 routers, verze API 0.9.48+. Stejná velikost jako u odpovídajícího požadavku (528 pro dlouhý, 218 pro krátký).\nFormát:\nDlouhý formát (528 bajtů):\n+----+----+----+----+----+----+----+----+ | ChaCha20 encrypted data (512 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ | Poly1305 MAC (16 bytes) | + + | | +----+----+----+----+----+----+----+----+ Krátký formát (218 bajtů):\n+----+----+----+----+----+----+----+----+ | ChaCha20 encrypted data (202 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ | Poly1305 MAC (16 bytes) | + + | | +----+----+----+----+----+----+----+----+ Struktura otevřeného textu (pro oba formáty):\nObsahuje mapovací strukturu (formát klíč–hodnota I2P) s: - Kód stavu odpovědi (povinný) - Parametr dostupné šířky pásma (\u0026ldquo;b\u0026rdquo;) (volitelný, přidán v API 0.9.65) - Další volitelné parametry pro budoucí rozšíření\nStavové kódy odpovědi: - 0 - Úspěch - 30 - Odmítnuto: překročen limit šířky pásma\nViz ECIES Tunnel Creation pro úplnou specifikaci.\nGarlicClove (vnitřní část zprávy v rámci garlic encryption, ElGamal/AES) UPOZORNĚNÍ: Toto je formát používaný pro garlic cloves (části garlic zpráv) uvnitř ElGamalem šifrovaných garlic messages. Formát pro ECIES-AEAD-X25519-Ratchet garlic messages a garlic cloves je výrazně odlišný. Moderní formát viz Specifikace ECIES .\nZastaralé pro routers (API 0.9.58+), stále podporováno pro cíle.\nFormát:\nNešifrované:\n+----+----+----+----+----+----+----+----+ | Delivery Instructions (variable) | ~ ~ +----+----+----+----+----+----+----+----+ | I2NP Message (variable) | ~ ~ +----+----+----+----+----+----+----+----+ | Clove ID (4) | Expiration (8) |Cert| +----+----+----+----+----+----+----+----+ (3) | +----+----+----+----+----+----+----+----+ Delivery Instructions :: Variable length (typically 1, 33, or 37 bytes) I2NP Message :: Any I2NP message Clove ID :: 4-byte Integer (random, checked for duplicates) Expiration :: Date (8 bytes) Certificate :: Always NULL (3 bytes total, all zeroes) Poznámky: - Cloves (podzpráva v garlic routingu) se nikdy nefragmentují - Když je první bit bajtu příznaků Delivery Instructions 0, clove není šifrován - Když je první bit 1, clove je šifrován (neimplementovaná funkce) - Maximální délka je funkcí součtu délek všech clove a maximální délky GarlicMessage - Certifikát by bylo možné použít s HashCash k \u0026ldquo;placení\u0026rdquo; za směrování (možná budoucí funkcionalita) - V praxi používané zprávy: DataMessage, DeliveryStatusMessage, DatabaseStoreMessage - GarlicMessage může obsahovat GarlicMessage (vnořený garlic), ale to se v praxi nepoužívá\nPro koncepční přehled viz Garlic Routing (způsob směrování v I2P).\nGarlicClove (ECIES-X25519-AEAD-Ratchet) Pro ECIES-X25519 routers a destinace, verze API 0.9.46+. Toto je aktuální standardní formát.\nZÁSADNÍ ROZDÍL: ECIES garlic používá zcela odlišnou strukturu založenou na blocích protokolu Noise, nikoli na explicitních strukturách clove (podzprávy v rámci garlic v I2P).\nFormát:\nECIES garlic messages (zprávy typu garlic) obsahují sérii bloků:\nBlock structure: +----+----+----+----+----+----+----+----+ |type| length | data ... +----+----+----+----+----+-//- type :: 1 byte block type length :: 2 bytes block length data :: variable length data Typy bloků: - 0 - Garlic Clove Block (blok „stroužku“ v rámci garlic encryption; obsahuje zprávu I2NP) - 1 - Blok data a času (časové razítko) - 2 - Blok možností (parametry doručení) - 3 - Vycpávkový blok - 254 - Ukončovací blok (neimplementováno)\nGarlic Clove Block (blok stroužku v garlic encryption) (typ 0):\n+----+----+----+----+----+----+----+----+ | 0 | length | Delivery Instructions | +----+----+----+----+ + ~ ~ +----+----+----+----+----+----+----+----+ | I2NP Message | ~ ~ +----+----+----+----+----+----+----+----+ | Clove ID (4) | Expiration (4) | +----+----+----+----+----+----+----+----+ Klíčové rozdíly oproti formátu ElGamal: - Používá 4bajtové vypršení platnosti (sekundy od epochy) místo 8bajtového Date - Bez pole certificate - Zabalené do blokové struktury s typem a délkou - Celá zpráva šifrovaná pomocí ChaCha20/Poly1305 AEAD - Správa relace pomocí ratcheting (postupné posouvání klíčů)\nPro úplné podrobnosti o rámci protokolu Noise a strukturách bloků viz specifikaci ECIES .\nInstrukce pro doručení Garlic Clove (podzpráva v rámci garlic encryption) Tento formát se používá pro garlic cloves (stroužky) u ElGamal i ECIES. Určuje, jak doručit obsaženou zprávu.\nKRITICKÉ VAROVÁNÍ: Tato specifikace je určena POUZE pro Pokyny k doručení uvnitř Garlic Cloves (v I2P: jednotlivé vnořené části tzv. garlicové zprávy). \u0026ldquo;Pokyny k doručení\u0026rdquo; se používají také uvnitř zpráv Tunnel, kde je formát výrazně odlišný. Viz Specifikace zprávy Tunnel pro pokyny k doručení týkající se Tunnel. NEZAMĚŇUJTE tyto dva formáty.\nFormát:\nKlíč relace a zpoždění se nepoužívají a nikdy nejsou přítomny, takže tři možné délky jsou: - 1 bajt (LOCAL) - 33 bajtů (ROUTER a DESTINATION) - 37 bajtů (TUNNEL)\n+----+----+----+----+----+----+----+----+ |flag| | +----+ + | Session Key (optional, 32) | + + | | + +----+----+----+----+--------------+ | | | +----+ + | To Hash (optional, 32) | + + | | + +----+----+----+----+--------------+ | | Tunnel ID (4, opt)| Delay (4, opt)| +----+----+----+----+----+----+----+----+ flag :: 1 byte Bit order: 76543210 bit 7: encrypted? (Unimplemented, always 0) If 1, a 32-byte encryption session key follows bits 6-5: delivery type 0x0 = LOCAL (0) 0x1 = DESTINATION (1) 0x2 = ROUTER (2) 0x3 = TUNNEL (3) bit 4: delay included? (Not fully implemented, always 0) If 1, four delay bytes are included bits 3-0: reserved, set to 0 for compatibility Session Key :: 32 bytes (Optional, unimplemented) Present if encrypt flag bit is set To Hash :: 32 bytes (Optional) Present if delivery type is DESTINATION, ROUTER, or TUNNEL - DESTINATION: SHA256 hash of the destination - ROUTER: SHA256 hash of the router identity - TUNNEL: SHA256 hash of the gateway router identity Tunnel ID :: 4 bytes (Optional) Present if delivery type is TUNNEL The destination tunnel ID (nonzero) Delay :: 4 bytes (Optional, unimplemented) Present if delay included flag is set Specifies delay in seconds Typické délky: - LOKÁLNÍ doručení: 1 bajt (pouze příznak) - ROUTER / DESTINATION doručení: 33 bajtů (příznak + hash) - TUNNEL doručení: 37 bajtů (příznak + hash + tunnel ID)\nPopisy typů doručení:\nType Value Description LOCAL 0 Deliver to the local router (this router) DESTINATION 1 Deliver to a destination (client) identified by hash ROUTER 2 Deliver to another router identified by hash TUNNEL 3 Deliver to a tunnel gateway router **Poznámky k implementaci:** - Šifrování klíče relace není implementováno a příznakový bit je vždy 0 - Zpoždění není plně implementováno a příznakový bit je vždy 0 - U doručení TUNNEL hash identifikuje vstupní router a tunnel ID určuje, který příchozí tunnel - U doručení DESTINATION je hash SHA-256 veřejného klíče cíle - U doručení ROUTER je hash SHA-256 identity routeru Zprávy I2NP Úplné specifikace zpráv pro všechny typy zpráv I2NP.\nPřehled typů zpráv Message Type Since Status DatabaseStore10.6.1.10Active DatabaseLookup20.6.1.10Active DatabaseSearchReply30.6.1.10Active DeliveryStatus100.6.1.10Active Garlic110.6.1.10Active TunnelData180.6.1.10Active TunnelGateway190.6.1.10Active Data200.6.1.10Active TunnelBuild210.6.1.10Deprecated TunnelBuildReply220.6.1.10Deprecated VariableTunnelBuild230.7.12Active VariableTunnelBuildReply240.7.12Active ShortTunnelBuild250.9.51Active OutboundTunnelBuildReply260.9.51Active **Vyhrazeno:** - Typ 0: Vyhrazeno - Typy 4-9: Vyhrazeno pro budoucí použití - Typy 12-17: Vyhrazeno pro budoucí použití - Typy 224-254: Vyhrazeno pro experimentální zprávy - Typ 255: Vyhrazeno pro budoucí rozšíření DatabaseStore (uložení do databáze; Typ 1) Účel: Nevyžádané uložení do databáze nebo odpověď na úspěšnou zprávu DatabaseLookup.\nObsah: Nekomprimovaný LeaseSet, LeaseSet2, MetaLeaseSet nebo EncryptedLeaseSet, případně komprimovaný RouterInfo.\nFormát s reply token (token pro odpověď):\n+----+----+----+----+----+----+----+----+ | SHA256 Hash as key (32 bytes) | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ |type| reply token (4) | reply_tunnelId +----+----+----+----+----+----+----+----+ (4) | reply gateway | +----+----+----+----+----+ + | SHA256 hash (32 bytes) | + + | | + +----+ | | +----+----+----+----+----+----+----+ | data ... +----+-// key :: 32 bytes SHA256 hash (the \u0026#34;real\u0026#34; hash, not routing key) type :: 1 byte Type identifier bit 0: 0 = RouterInfo 1 = LeaseSet or variants bits 3-1: (as of 0.9.38) 0: RouterInfo or LeaseSet (types 0 or 1) 1: LeaseSet2 (type 3) 2: EncryptedLeaseSet (type 5) 3: MetaLeaseSet (type 7) 4-7: Unsupported, invalid bits 7-4: Reserved, set to 0 reply token :: 4 bytes If greater than zero, a DeliveryStatusMessage is requested with the Message ID set to the reply token A floodfill router is also expected to flood the data to the closest floodfill peers reply_tunnelId :: 4 bytes (only if reply token \u0026gt; 0) TunnelId of the inbound gateway of the tunnel for the response If 0, reply is sent directly to reply gateway reply gateway :: 32 bytes (only if reply token \u0026gt; 0) SHA256 hash of the RouterInfo If reply_tunnelId is nonzero: inbound gateway router If reply_tunnelId is zero: router to send reply to data :: Variable length If type == 0: 2-byte Integer length + gzip-compressed RouterInfo If type == 1: Uncompressed LeaseSet If type == 3: Uncompressed LeaseSet2 If type == 5: Uncompressed EncryptedLeaseSet If type == 7: Uncompressed MetaLeaseSet Formát s tokenem odpovědi == 0:\n+----+----+----+----+----+----+----+----+ | SHA256 Hash as key (32 bytes) | + + | | +----+----+----+----+----+----+----+----+ |type| 0 | data ... +----+----+----+----+----+-// Poznámky: - Z bezpečnostních důvodů se pole pro odpověď ignorují, pokud je zpráva přijata přes tunnel - Klíč je „skutečný“ hash RouterIdentity nebo Destination, NE směrovací klíč - Typy 3, 5 a 7 (varianty LeaseSet2) byly přidány ve verzi 0.9.38 (API 0.9.38). Podrobnosti viz Návrh 123 - Tyto typy by se měly posílat pouze routerům s verzí API 0.9.38 nebo vyšší - Jako optimalizaci ke snížení počtu spojení, pokud je typ LeaseSet, je přiložen odpovědní token, reply tunnel ID je nenulové a dvojice reply gateway/tunnelID je v LeaseSetu nalezena jako lease (záznam v LeaseSetu), může příjemce přesměrovat odpověď na libovolný jiný lease v daném LeaseSetu - Formát RouterInfo gzip: Aby se skryl OS routeru a implementace, slaďte se s implementací Java routeru nastavením času změny na 0 a bajtu OS na 0xFF a nastavte XFL na 0x02 (maximální komprese, nejpomalejší algoritmus) dle RFC 1952. Prvních 10 bajtů: 1F 8B 08 00 00 00 00 00 02 FF\nZdrojový kód: - net.i2p.data.i2np.DatabaseStoreMessage - net.i2p.data.RouterInfo (pro strukturu RouterInfo) - net.i2p.data.LeaseSet (pro strukturu LeaseSet)\nDatabaseLookup (vyhledávání v databázi) (Typ 2) Účel: Požadavek na vyhledání položky v síťové databázi (netDb). Odpovědí je buď DatabaseStore, nebo DatabaseSearchReply.\nFormát:\n+----+----+----+----+----+----+----+----+ | SHA256 hash as the key (32 bytes) | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ | SHA256 hash of the from router (32) | + or reply tunnel gateway + | | + + | | + + | | +----+----+----+----+----+----+----+----+ |flag| reply_tunnelId (4)| size (2)| | +----+----+----+----+----+----+----+ + | SHA256 of key1 to exclude (32 bytes) | + + | | + +----+ | | | +----+----+----+----+----+----+----+ + | SHA256 of key2 to exclude (32) | + + ~ ~ | | + +----+ | | | +----+----+----+----+----+----+----+ + | Session key if reply encryption | + requested (32 bytes) + | | + +----+ | |tags| +----+----+----+----+----+----+----+----+ | Session tags if reply encryption | + requested (variable) + ~ ~ | | +----+----+----+----+----+----+----+----+ key :: 32 bytes SHA256 hash of the object to lookup from :: 32 bytes If deliveryFlag == 0: SHA256 hash of RouterInfo (sender) If deliveryFlag == 1: SHA256 hash of reply tunnel gateway flags :: 1 byte Bit order: 76543210 bit 0: deliveryFlag 0 = send reply directly 1 = send reply to some tunnel bit 1: encryptionFlag Through 0.9.5: must be 0 As of 0.9.6: ignored As of 0.9.7: 0 = send unencrypted reply 1 = send AES encrypted reply using key and tag bits 3-2: lookup type flags Through 0.9.5: must be 00 As of 0.9.6: ignored As of 0.9.16: 00 = ANY (deprecated, use LS or RI as of 0.9.16) 01 = LS lookup (LeaseSet or variants) 10 = RI lookup (RouterInfo) 11 = exploration lookup (RouterInfo, non-floodfill) bit 4: ECIESFlag Before 0.9.46: ignored As of 0.9.46: 0 = send unencrypted or ElGamal reply 1 = send ChaCha/Poly encrypted reply using key bits 7-5: Reserved, set to 0 reply_tunnelId :: 4 bytes (only if deliveryFlag == 1) TunnelId of the tunnel to send reply to (nonzero) size :: 2 bytes Integer (valid range: 0-512) Number of peers to exclude from DatabaseSearchReply excludedPeers :: $size SHA256 hashes of 32 bytes each If lookup fails, exclude these peers from the reply If includes a hash of all zeroes, the request is exploratory (return non-floodfill routers only) reply_key :: 32 bytes (conditional, see encryption modes below) reply_tags :: 1 byte count + variable length tags (conditional) Režimy šifrování odpovědí:\nPOZNÁMKA: ElGamal routery jsou od API 0.9.58 označeny jako zastaralé. Jelikož je nyní doporučená minimální verze floodfill pro dotazování 0.9.58, implementace nemusejí implementovat šifrování pro ElGamal floodfill routery. ElGamal destinace jsou stále podporovány.\nPříznakový bit 4 (ECIESFlag) se používá v kombinaci s bitem 1 (encryptionFlag) k určení režimu šifrování odpovědi:\nFlag bits 4,1 From To Router Reply DH? Notes 0 0 Any Any No encryption n/a No encryption 0 1 ElG ElG AES No As of 0.9.7, deprecated 0.9.58 1 0 ECIES ElG AEAD No As of 0.9.46, deprecated 0.9.58 1 0 ECIES ECIES AEAD No As of 0.9.49, current standard 1 1 ElG ECIES AES Yes TBD, future 1 1 ECIES ECIES AEAD Yes TBD, future **Bez šifrování (příznaky 0,0):** reply_key, tags a reply_tags nejsou k dispozici.\nElG na ElG (příznaky 0,1) - ZASTARALÉ:\nPodporováno od verze 0.9.7, zastaralé od verze 0.9.58.\nreply_key :: 32 byte SessionKey (big-endian) CSRNG(32) random data tags :: 1 byte Integer (1-32, typically 1) Number of reply tags that follow reply_tags :: One or more 32-byte SessionTags Each is CSRNG(32) random data ECIES na ElG (příznaky 1,0) - ZASTARALÉ:\nPodporováno od verze 0.9.46, zastaralé od verze 0.9.58.\nreply_key :: 32 byte ECIES SessionKey (big-endian) CSRNG(32) random data tags :: 1 byte Integer (required value: 1) Number of reply tags that follow reply_tags :: One 8-byte ECIES SessionTag CSRNG(8) random data Odpověď je zpráva ECIES Existing Session (zpráva pro existující relaci), jak je definována ve Specifikaci ECIES :\n+----+----+----+----+----+----+----+----+ | Session Tag (8 bytes) | +----+----+----+----+----+----+----+----+ | ChaCha20 encrypted payload | ~ ~ | | +----+----+----+----+----+----+----+----+ | Poly1305 MAC (16 bytes) | + + | | +----+----+----+----+----+----+----+----+ tag :: 8 byte reply_tag k :: 32 byte session key (the reply_key) n :: 0 (nonce) ad :: The 8 byte reply_tag payload :: Plaintext data (DSM or DSRM) ciphertext = ENCRYPT(k, n, payload, ad) ECIES (šifrovací schéma založené na eliptických křivkách) na ECIES (příznaky 1,0) - AKTUÁLNÍ STANDARD:\nECIES destinace nebo router odešle požadavek na vyhledání k ECIES routeru. Podporováno od verze 0.9.49.\nStejný formát jako \u0026ldquo;ECIES to ElG\u0026rdquo; výše. Šifrování vyhledávací zprávy je specifikováno v ECIES Routers . Žadatel je anonymní.\nECIES (integrované šifrování na eliptických křivkách) na ECIES s DH (výměna klíčů Diffie–Hellman) (příznaky 1,1) - BUDOUCNOST:\nZatím není plně definováno. Viz Návrh 156 .\nPoznámky: - Před verzí 0.9.16 mohl klíč patřit k RouterInfo nebo LeaseSet (stejný prostor klíčů, bez příznaku k rozlišení) - Šifrované odpovědi jsou užitečné pouze tehdy, když odpověď jde přes tunnel - Počet zahrnutých tagů může být více než jeden, pokud jsou implementovány alternativní strategie vyhledávání v DHT (distribuovaná hašovací tabulka) - Vyhledávací klíč a vylučovací klíče jsou \u0026ldquo;skutečné\u0026rdquo; hashe, NIKOLI směrovací klíče - Typy 3, 5 a 7 (varianty LeaseSet2) mohou být od verze 0.9.38 vráceny. Viz Návrh 123 - Poznámky k průzkumnému vyhledávání: Průzkumné vyhledávání je definováno tak, že vrací seznam ne-floodfill hashů blízkých danému klíči. Implementace se však liší: Java skutečně vyhledá hledaný klíč pro RI (RouterInfo) a vrátí DatabaseStore (záznam v netDb), pokud existuje; i2pd nikoli. Proto se nedoporučuje používat průzkumné vyhledávání pro dříve přijaté hashe\nZdrojový kód: - net.i2p.data.i2np.DatabaseLookupMessage - Šifrování: net.i2p.crypto.SessionKeyManager\nDatabaseSearchReply (Typ 3) Účel: Odpověď na neúspěšnou zprávu DatabaseLookup (dotaz do databáze).\nObsah: Seznam router hashů nejbližších k požadovanému klíči.\nFormát:\n+----+----+----+----+----+----+----+----+ | SHA256 hash as query key (32 bytes) | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ | num| peer_hashes (variable) | +----+ + | | ~ ~ | | + +----+----+----+----+----+----+----+ | | from (32 bytes) | +----+ + | | + + | | + + | | + +----+----+----+----+----+----+----+ | | +----+ key :: 32 bytes SHA256 of the object being searched num :: 1 byte Integer Number of peer hashes that follow (0-255) peer_hashes :: $num SHA256 hashes of 32 bytes each (total $num*32 bytes) SHA256 of the RouterIdentity that the sender thinks is close to the key from :: 32 bytes SHA256 of the RouterInfo of the router this reply was sent from Zdrojový kód: - net.i2p.data.i2np.DatabaseSearchReplyMessage\nDeliveryStatus (stav doručení, typ 10) Účel: Jednoduché potvrzení přijetí zprávy. Toto potvrzení obvykle vytváří odesílatel zprávy a spolu se samotnou zprávou je zabaleno do Garlic Message (speciální typ zprávy v I2P), aby je příjemce vrátil.\nObsah: ID doručené zprávy a čas vytvoření nebo přijetí.\nFormát:\n+----+----+----+----+----+----+----+----+----+----+----+----+ | msg_id (4) | time_stamp (8) | +----+----+----+----+----+----+----+----+----+----+----+----+ msg_id :: Integer (4 bytes) Unique ID of the message we deliver the DeliveryStatus for (see I2NP Message Header for details) time_stamp :: Date (8 bytes) Time the message was successfully created or delivered Poznámky: - Časové razítko je vždy nastaveno tvůrcem na aktuální čas. V kódu však existuje několik použití a v budoucnu mohou přibýt další - Tato zpráva se také používá jako potvrzení o navázání relace v SSU. V tomto případě je ID zprávy nastaveno na náhodné číslo a \u0026ldquo;arrival time\u0026rdquo; je nastaven na aktuální síťové ID platné pro celou síť, které je 2 (tj., 0x0000000000000002) - DeliveryStatus (zpráva potvrzení doručení) se obvykle zapouzdřuje do GarlicMessage a posílá se přes tunnel, aby poskytla potvrzení bez odhalení odesílatele - Používá se pro testování tunnel k měření latence a spolehlivosti\nZdrojový kód: - net.i2p.data.i2np.DeliveryStatusMessage - Použito v: net.i2p.router.tunnel.InboundEndpointProcessor pro testování tunnelu\nGarlicMessage (Typ 11) UPOZORNĚNÍ: Toto je formát používaný pro garlic messages (zprávy typu garlic) šifrované pomocí ElGamalu. Formát pro ECIES-AEAD-X25519-Ratchet garlic messages je výrazně odlišný. Podívejte se na ECIES Specification pro moderní formát.\nÚčel: Slouží k zapouzdření více šifrovaných zpráv I2NP.\nObsah: Po dešifrování se jedná o sérii Garlic Cloves (jednotlivé části garlic zprávy) a doplňkových dat, která se také nazývá Clove Set (sada těchto částí).\nŠifrovaný formát:\n+----+----+----+----+----+----+----+----+ | length (4) | data | +----+----+----+----+----+ + | | ~ ~ | | +----+----+----+----+----+----+----+----+ length :: 4 byte Integer Number of bytes that follow (0 to 64 KB) data :: $length bytes ElGamal encrypted data Dešifrovaná data (Clove Set – sada dílčích zpráv):\n+----+----+----+----+----+----+----+----+ | num| clove 1 (variable) | +----+ + | | ~ ~ | | +----+----+----+----+----+----+----+----+ | clove 2 (variable) | ~ ~ | | +----+----+----+----+----+----+----+----+ | Certificate (3) | Message_ID (4) | +----+----+----+----+----+----+----+----+ Expiration (8) | +----+----+----+----+----+----+----+----+ num :: 1 byte Integer Number of GarlicCloves to follow clove :: GarlicClove (see GarlicClove structure above) Certificate :: Always NULL (3 bytes total, all zeroes) Message_ID :: 4 byte Integer Expiration :: Date (8 bytes) Pro formát ECIES-X25519-AEAD-Ratchet (aktuální standard pro routers):\nViz Specifikaci ECIES a Návrh 144 .\nZdrojový kód: - net.i2p.data.i2np.GarlicMessage - Šifrování: net.i2p.crypto.elgamal.ElGamalAESEngine (zastaralé) - Moderní šifrování: net.i2p.crypto.ECIES balíčky\nTunnelData (Typ 18) Účel: Zpráva odeslaná ze vstupní brány nebo účastníka tunnelu k dalšímu účastníkovi nebo koncovému bodu. Data mají pevnou délku a obsahují zprávy I2NP, které jsou fragmentované, sdružované do dávek, doplněné vycpávkou a šifrované.\nFormát:\n+----+----+----+----+----+----+----+----+ | tunnelID (4) | data (1024) | +----+----+----+----+----+ + | | ~ ~ | | + +----+----+----+----+ | | +----+----+----+----+ tunnelId :: 4 bytes TunnelId identifying the tunnel this message is directed at Nonzero data :: 1024 bytes Payload data, fixed to 1024 bytes Struktura užitečných dat (1024 bajtů):\nBytes 0-15: Initialization Vector (IV) for AES encryption Bytes 16-1023: Encrypted tunnel message data (1008 bytes) Poznámky: - ID zprávy I2NP pro TunnelData je na každém skoku nastaveno na nové náhodné číslo - Formát zprávy tunnel (uvnitř šifrovaných dat) je specifikován v Specifikaci zprávy tunnel - Každý skok dešifruje jednu vrstvu pomocí AES-256 v režimu CBC - IV se na každém skoku aktualizuje pomocí dešifrovaných dat - Celková velikost je přesně 1,028 bajtů (4 tunnelId + 1024 data) - Toto je základní jednotka provozu v tunnel - Zprávy TunnelData přenášejí fragmentované zprávy I2NP (GarlicMessage, DatabaseStore atd.)\nZdrojový kód: - net.i2p.data.i2np.TunnelDataMessage - Konstanta: TunnelDataMessage.DATA_LENGTH = 1024 - Zpracování: net.i2p.router.tunnel.InboundGatewayProcessor\nTunnelGateway (Typ 19) Účel: Zapouzdřuje další zprávu I2NP, která má být odeslána do tunnelu na jeho vstupní bráně.\nFormát:\n+----+----+----+----+----+----+----+-// | tunnelId (4) | length (2)| data... +----+----+----+----+----+----+----+-// tunnelId :: 4 bytes TunnelId identifying the tunnel this message is directed at Nonzero length :: 2 byte Integer Length of the payload data :: $length bytes Actual payload of this message Poznámky: - Užitečná data jsou zpráva I2NP se standardní 16bajtovou hlavičkou - Používá se k vkládání zpráv do tunnels z místního routeru - Brána podle potřeby fragmentuje vloženou zprávu - Po fragmentaci jsou fragmenty zapouzdřeny do zpráv TunnelData - TunnelGateway se nikdy neposílá po síti; jde o interní typ zprávy používaný před zpracováním tunnelu\nZdrojový kód: - net.i2p.data.i2np.TunnelGatewayMessage - Zpracování: net.i2p.router.tunnel.OutboundGatewayProcessor\nDataMessage (typ 20) Účel: Používá se v Garlic Messages (struktura zpráv v I2P) a Garlic Cloves (vložené podzprávy v rámci Garlic Messages) k zapouzdření libovolných dat (typicky end-to-end šifrovaných aplikačních dat).\nFormát:\n+----+----+----+----+----+----+-//-+ | length (4) | data... | +----+----+----+----+----+----+-//-+ length :: 4 bytes Length of the payload data :: $length bytes Actual payload of this message Poznámky: - Tato zpráva neobsahuje žádné směrovací informace a nikdy nebude odeslána \u0026ldquo;neobalená\u0026rdquo; - Používá se pouze uvnitř Garlic messages (garlic zprávy) - Typicky obsahuje end-to-end šifrovaná aplikační data (HTTP, IRC, email atd.) - Data jsou obvykle šifrována pomocí ElGamal/AES nebo ECIES - Maximální praktická délka je přibližně 61,2 KB kvůli omezením fragmentace zpráv v tunnelu\nZdrojový kód: - net.i2p.data.i2np.DataMessage\nTunnelBuild (typ 21) ZASTARALÉ. Použijte VariableTunnelBuild (typ 23) nebo ShortTunnelBuild (typ 25).\nÚčel: Požadavek na sestavení tunnelu pevné délky pro 8 skoků.\nFormát:\n+----+----+----+----+----+----+----+----+ | Record 0 (528 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ | Record 1 (528 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ | Record 7 (528 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ Just 8 BuildRequestRecords attached together Record size: 528 bytes Total size: 8 × 528 = 4,224 bytes Zdrojový kód: - net.i2p.data.i2np.TunnelBuildMessage - Konstanta: TunnelBuildMessageBase.MAX_RECORD_COUNT = 8\nTunnelBuildReply (Typ 22) ZASTARALÉ. Použijte VariableTunnelBuildReply (typ 24) nebo OutboundTunnelBuildReply (typ 26).\nÚčel: Odpověď pro sestavení tunnelu s pevnou délkou pro 8 skoků.\nFormát:\nStejný formát jako u TunnelBuildMessage, s BuildResponseRecords namísto BuildRequestRecords.\nTotal size: 8 × 528 = 4,224 bytes Poznámky: - Od verze 0.9.48 může obsahovat ECIES-X25519 BuildResponseRecords (záznamy odpovědí pro sestavení pomocí ECIES-X25519). Viz Vytváření ECIES tunnelu - Podrobnosti viz Specifikace vytváření tunnelu - ID zprávy I2NP pro tuto zprávu musí být nastaveno podle specifikace vytváření tunnelu - Ačkoli se v dnešní síti vyskytuje zřídka (nahrazeno VariableTunnelBuildReply), může být stále použito pro velmi dlouhé tunnely a nebylo formálně označeno jako zastaralé - Routers to stále musí implementovat kvůli kompatibilitě\nZdrojový kód: - net.i2p.data.i2np.TunnelBuildReplyMessage\nVariableTunnelBuild (Typ 23) Účel: Sestavení tunnelu s proměnnou délkou pro 1-8 skoků. Podporuje jak routery ElGamal, tak ECIES-X25519.\nFormát:\n+----+----+----+----+----+----+----+----+ | num| BuildRequestRecords (variable) | +----+----+----+----+----+----+----+----+ num :: 1 byte Integer Valid values: 1-8 BuildRequestRecords :: $num records of 528 bytes each Record size: 528 bytes Total size: 1 + ($num × 528) bytes Poznámky: - Od verze 0.9.48 může obsahovat ECIES-X25519 (schéma ECIES s křivkou X25519) BuildRequestRecords (záznamy požadavku na sestavení). Viz Vytváření ECIES tunnelů - Zavedeno ve verzi routeru 0.7.12 (2009) - Nemá být posíláno účastníkům tunnelu s verzí starší než 0.7.12 - Podrobnosti viz Specifikace vytváření tunnelů - ID zprávy I2NP musí být nastaveno podle specifikace vytváření tunnelu - Obvyklý počet záznamů: 4 (pro 4-hopový tunnel) - Obvyklá celková velikost: 1 + (4 × 528) = 2,113 bajtů - Toto je standardní zpráva pro sestavení tunnelu pro ElGamal routery - ECIES routery obvykle místo toho používají ShortTunnelBuild (zpráva pro krátkou výstavbu tunnelu; typ 25)\nZdrojový kód: - net.i2p.data.i2np.VariableTunnelBuildMessage\nVariableTunnelBuildReply (Typ 24) Účel: Odpověď na sestavení tunnel s proměnnou délkou pro 1-8 skoků. Podporuje jak ElGamal, tak ECIES-X25519 routers.\nFormát:\nStejný formát jako VariableTunnelBuildMessage, s BuildResponseRecords namísto BuildRequestRecords.\n+----+----+----+----+----+----+----+----+ | num| BuildResponseRecords (variable) | +----+----+----+----+----+----+----+----+ num :: 1 byte Integer Valid values: 1-8 BuildResponseRecords :: $num records of 528 bytes each Record size: 528 bytes Total size: 1 + ($num × 528) bytes Poznámky: - Od verze 0.9.48 může obsahovat ECIES-X25519 BuildResponseRecords. Viz Vytváření tunnelu ECIES - Zavedeno ve verzi routeru 0.7.12 (2009) - Nesmí být odesíláno účastníkům tunnelu s verzí starší než 0.7.12 - Podrobnosti viz Specifikace vytváření tunnelu - ID zprávy I2NP musí být nastaveno podle specifikace vytváření tunnelu - Typický počet záznamů: 4 - Typická celková velikost: 2,113 bajtů\nZdrojový kód: - net.i2p.data.i2np.VariableTunnelBuildReplyMessage\nShortTunnelBuild (Typ 25) Účel: Krátké zprávy pro sestavení tunnelů pouze pro ECIES-X25519 routers. Zavedeno ve verzi API 0.9.51 (vydání 1.5.0, srpen 2021). Toto je aktuální standard pro ECIES sestavování tunnelů.\nFormát:\n+----+----+----+----+----+----+----+----+ | num| ShortBuildRequestRecords (var) | +----+----+----+----+----+----+----+----+ num :: 1 byte Integer Valid values: 1-8 ShortBuildRequestRecords :: $num records of 218 bytes each Record size: 218 bytes Total size: 1 + ($num × 218) bytes Poznámky: - Zavedeno ve verzi routeru 0.9.51 (vydání 1.5.0, srpen 2021) - Nesmí být odesíláno účastníkům tunnelu dříve než od verze API 0.9.51 - Viz Vytváření ECIES Tunnel pro úplnou specifikaci - Viz Návrh 157 pro zdůvodnění - Typický počet záznamů: 4 - Typická celková velikost: 1 + (4 × 218) = 873 bajtů - Úspora šířky pásma: o 59% menší než VariableTunnelBuild (873 vs 2,113 bajtů) - Výkonnostní přínos: 4 krátké záznamy se vejdou do jedné tunnel zprávy; VariableTunnelBuild vyžaduje 3 tunnel zprávy - Toto je nyní standardní formát sestavení tunnelu pro čisté ECIES-X25519 tunnely - Záznamy odvozují klíče pomocí HKDF místo jejich explicitního zahrnutí\nZdrojový kód: - net.i2p.data.i2np.ShortTunnelBuildMessage - Konstanta: ShortEncryptedBuildRecord.RECORD_SIZE = 218\nOutboundTunnelBuildReply (Typ 26) Účel: Odesláno z výstupního koncového bodu nového tunnel iniciátorovi. Pouze pro ECIES-X25519 routers. Zavedeno v API verzi 0.9.51 (vydání 1.5.0, srpen 2021).\nFormát:\nStejný formát jako ShortTunnelBuildMessage, s ShortBuildResponseRecords namísto ShortBuildRequestRecords.\n+----+----+----+----+----+----+----+----+ | num| ShortBuildResponseRecords (var) | +----+----+----+----+----+----+----+----+ num :: 1 byte Integer Valid values: 1-8 ShortBuildResponseRecords :: $num records of 218 bytes each Record size: 218 bytes Total size: 1 + ($num × 218) bytes Poznámky: - Zavedeno ve verzi router 0.9.51 (vydání 1.5.0, srpen 2021) - Viz ECIES Tunnel Creation pro úplnou specifikaci - Typický počet záznamů: 4 - Typická celková velikost: 873 bajtů - Tato odpověď je odeslána z odchozího koncového bodu (OBEP) zpět k tvůrci tunnel přes nově vytvořený odchozí tunnel - Poskytuje potvrzení, že všechny skoky přijaly sestavení tunnel\nZdrojový kód: - net.i2p.data.i2np.OutboundTunnelBuildReplyMessage\nReference Oficiální specifikace Specifikace I2NP - Kompletní specifikace formátu zpráv I2NP Společné struktury - Datové typy a struktury používané napříč I2P Vytváření tunnel - Vytváření tunnel pomocí ElGamal (zastaralé) Vytváření tunnel ECIES - Vytváření tunnel s ECIES-X25519 (aktuální) Zpráva pro tunnel - Formát zprávy pro tunnel a pokyny k doručení Specifikace NTCP2 - Transportní protokol TCP Specifikace SSU2 - Transportní protokol UDP Specifikace ECIES - Šifrování ECIES-X25519-AEAD-Ratchet (krokovací mechanismus) Specifikace kryptografie - Nízkoúrovňová kryptografická primitiva Specifikace I2CP - Specifikace klientského protokolu Specifikace datagramů - Formáty Datagram2 a Datagram3 Návrhy Návrh 123 - Nové záznamy netDB (LeaseSet2, EncryptedLeaseSet, MetaLeaseSet) Návrh 144 - Šifrování ECIES-X25519-AEAD-Ratchet Návrh 154 - Šifrované vyhledávání v databázi Návrh 156 - ECIES routery Návrh 157 - Menší zprávy pro sestavení tunnel (krátký formát) Návrh 159 - Transport SSU2 Návrh 161 - Komprimovatelná výplň Návrh 163 - Datagram2 a Datagram3 Návrh 167 - Parametry záznamu služby LeaseSet Návrh 168 - Parametry šířky pásma pro sestavení tunnel Návrh 169 - Postkvantová hybridní kryptografie Dokumentace Garlic Routing - Vrstvené seskupování zpráv ElGamal/AES - Zastaralé šifrovací schéma Implementace tunnelu - Fragmentace a zpracování Síťová databáze - Distribuovaná hašovací tabulka Transport NTCP2 - Specifikace transportu TCP Transport SSU2 - Specifikace transportu UDP Technický úvod - Přehled architektury I2P Zdrojový kód Repozitář Java I2P - Oficiální implementace v jazyce Java Zrcadlo na GitHubu - GitHubové zrcadlo Java I2P Repozitář i2pd - Implementace v C++ Klíčová umístění zdrojového kódu Java I2P (i2pgit.org/I2P_Developers/i2p.i2p): - core/java/src/net/i2p/data/i2np/ - implementace zpráv I2NP - core/java/src/net/i2p/crypto/ - kryptografické implementace - router/java/src/net/i2p/router/tunnel/ - zpracování tunnelu - router/java/src/net/i2p/router/transport/ - implementace transportu\nKonstanty a hodnoty: - I2NPMessage.MAX_SIZE = 65536 - Maximální velikost zprávy I2NP - I2NPMessageImpl.HEADER_LENGTH = 16 - Standardní velikost hlavičky - TunnelDataMessage.DATA_LENGTH = 1024 - Užitečná data zprávy Tunnel - EncryptedBuildRecord.RECORD_SIZE = 528 - Dlouhý záznam sestavení - ShortEncryptedBuildRecord.RECORD_SIZE = 218 - Krátký záznam sestavení - TunnelBuildMessageBase.MAX_RECORD_COUNT = 8 - Max. počet záznamů na jedno sestavení\nPříloha A: Statistiky sítě a aktuální stav Složení sítě (stav k říjnu 2025) Celkový počet routers: Přibližně 60,000-70,000 (liší se) Floodfill routers: Přibližně 500-700 aktivních Typy šifrování: ECIES-X25519: \u0026gt;95% routerů ElGamal: \u0026lt;5% routerů (zastaralé, pouze pro zpětnou kompatibilitu) Rozšíření transportů: SSU2: \u0026gt;60% jako primární transport NTCP2: ~40% jako primární transport Zastaralé transporty (SSU1, NTCP): 0% (odstraněno) Typy podpisů: EdDSA (Ed25519): drtivá většina ECDSA: malé procento RSA: nepovoleno (odstraněno) Minimální požadavky na router Verze API: 0.9.16+ (pro kompatibilitu EdDSA se sítí) Doporučené minimum: API 0.9.51+ (sestavení krátkých tunnelů ECIES) Aktuální minimum pro floodfills (uzly udržující netDb): API 0.9.58+ (zastarání routerů ElGamal) Nadcházející požadavek: Java 17+ (od vydání 2.11.0, prosinec 2025) Požadavky na šířku pásma Minimální: 128 KBytes/sec (příznak N nebo vyšší) pro floodfill Doporučeno: 256 KBytes/sec (příznak O) nebo vyšší Požadavky floodfill: Minimálně 128 KB/sec šířky pásma Stabilní doba běhu (\u0026gt;95% doporučeno) Nízká latence (\u0026lt;500ms k peerům) Splnit testy kondice (doba ve frontě, zpoždění úloh) Statistiky tunnelů Typická délka tunnelu: 3-4 skoky Maximální délka tunnelu: 8 skoků (teoretická, zřídka používaná) Typická životnost tunnelu: 10 minut Úspěšnost sestavení tunnelu: \u0026gt;85% u dobře propojených routerů Formát zprávy pro sestavení tunnelu: ECIES routery: ShortTunnelBuild (záznamy o velikosti 218 bajtů) Smíšené tunnely: VariableTunnelBuild (záznamy o velikosti 528 bajtů) Metriky výkonu Doba sestavení tunnelu: 1-3 sekundy (typicky) End-to-end latence: 0.5-2 sekundy (typicky, celkem 6-8 skoků) Propustnost: Omezená šířkou pásma tunnelu (typicky 10-50 KB/sec na tunnel) Maximální velikost datagramu: 10 KB doporučeno (teoretické maximum 61.2 KB) Příloha B: Zastaralé a odstraněné funkce Zcela odstraněno (již není podporováno) NTCP transport - Odstraněno ve verzi 0.9.50 (květen 2021) SSU v1 transport - Odstraněno z Java I2P ve verzi 2.4.0 (prosinec 2023) SSU v1 transport - Odstraněno z i2pd ve verzi 2.44.0 (listopad 2022) Typy podpisů RSA - Nepovoleno od API 0.9.28 Zastaralé (podporováno, ale nedoporučuje se) ElGamal routers - Zastaralé od API 0.9.58 (březen 2023) ElGamal destinace jsou nadále podporovány kvůli zpětné kompatibilitě Nové routers by měly používat výhradně ECIES-X25519 TunnelBuild (typ 21) - Zastaralé ve prospěch VariableTunnelBuild a ShortTunnelBuild Stále implementováno pro velmi dlouhé tunnels (\u0026gt;8 skoků) TunnelBuildReply (typ 22) - Zastaralé ve prospěch VariableTunnelBuildReply a OutboundTunnelBuildReply Šifrování ElGamal/AES - Zastaralé ve prospěch ECIES-X25519-AEAD-Ratchet Stále používáno pro starší destinace Dlouhé ECIES BuildRequestRecords (528 bajtů) - Zastaralé ve prospěch krátkého formátu (218 bajtů) Stále používáno pro smíšené tunnels s ElGamal skoky Časová osa podpory starších verzí Feature Introduced Deprecated Removed Notes NTCP 2003 2018 (0.9.36) 2021 (0.9.50) Replaced by NTCP2 SSU v1 2004 2022 (0.9.54) 2023 (Java) / 2022 (i2pd) Replaced by SSU2 ElGamal routers 2003 2023 (0.9.58) TBD Destinations still supported RSA signatures 2015 2017 2017 (0.9.28) Never widely used TunnelBuild 2004 2009 (0.7.12) Not removed Still supported for long tunnels --- Příloha C: Budoucí vývoj Postkvantová kryptografie Stav: Beta od vydání 2.10.0 (září 2025), stane se výchozí ve vydání 2.11.0 (prosinec 2025)\nImplementace: - Hybridní přístup kombinující klasické X25519 a postkvantové MLKEM (ML-KEM-768) - Zpětně kompatibilní se stávající infrastrukturou ECIES-X25519 - Používá Signal Double Ratchet (mechanismus postupné výměny klíčů) s klasickým i postkvantovým klíčovým materiálem - Podrobnosti viz Návrh 169 Migrační postup: 1. Verze 2.10.0 (září 2025): K dispozici jako volitelná beta 2. Verze 2.11.0 (prosinec 2025): Povoleno ve výchozím nastavení 3. Budoucí verze: Nakonec povinné\nPlánované funkce Vylepšení pro IPv6 - Lepší podpora IPv6 a přechodové mechanismy Omezování na úrovni tunnel - Jemně odstupňované řízení šířky pásma pro každý tunnel Vylepšené metriky - Lepší monitoring výkonu a diagnostika Optimalizace protokolů - Snížená režie a vyšší efektivita Vylepšený výběr floodfill - Lepší distribuce síťové databáze Výzkumné oblasti Optimalizace délky tunnelu - Dynamická délka tunnelu na základě modelu hrozeb Pokročilý padding (výplň dat) - Vylepšení odolnosti proti analýze provozu Nová šifrovací schémata - Příprava na hrozby kvantového výpočetnictví Řízení zahlcení - Lepší zvládání zátěže sítě Podpora mobilních zařízení - Optimalizace pro mobilní zařízení a sítě Příloha D: Pokyny k implementaci Pro nové implementace Minimální požadavky: 1. Podporovat funkce API ve verzi 0.9.51+ 2. Implementovat šifrování ECIES-X25519-AEAD-Ratchet 3. Podporovat transporty NTCP2 a SSU2 4. Implementovat zprávy ShortTunnelBuild (záznamy o velikosti 218 bajtů) 5. Podporovat varianty LeaseSet2 (typy 3, 5, 7) 6. Používat podpisy EdDSA (Ed25519)\nDoporučeno: 1. Podporovat postkvantovou hybridní kryptografii (od verze 2.11.0) 2. Implementovat parametry šířky pásma pro každý tunnel 3. Podporovat formáty Datagram2 a Datagram3 4. Implementovat možnosti záznamu služby v LeaseSets 5. Dodržovat oficiální specifikace na /docs/specs/\nNení vyžadováno: 1. Podpora routeru ElGamal (zastaralé) 2. Podpora staršího transportu (SSU1, NTCP) 3. Dlouhé ECIES BuildRequestRecords (528 bajtů pro čisté ECIES tunnels) 4. Zprávy TunnelBuild/TunnelBuildReply (použijte varianty Variable nebo Short)\nTestování a validace Soulad s protokolem: 1. Otestujte interoperabilitu s oficiální Java I2P router 2. Otestujte interoperabilitu s i2pd C++ router 3. Ověřte formáty zpráv podle specifikací 4. Otestujte cykly sestavení/zrušení tunnel 5. Ověřte šifrování/dešifrování pomocí testovacích vektorů\nTestování výkonu: 1. Změřte míru úspěšnosti sestavování tunnel (měla by být \u0026gt;85%) 2. Testujte s různými délkami tunnel (2-8 hopů) 3. Ověřte správnou fragmentaci a znovusestavení 4. Testujte pod zátěží (více současných tunnel) 5. Změřte end-to-end latenci\nTestování zabezpečení: 1. Ověřit implementaci šifrování (použít testovací vektory) 2. Otestovat prevenci útoků typu replay 3. Ověřit zpracování vypršení platnosti zpráv 4. Testovat proti nesprávně formátovaným zprávám 5. Ověřit správnou generaci náhodných čísel\nČastá úskalí implementace Matoucí formáty pokynů k doručení - garlic clove (jednotlivá část v garlic zprávě) vs tunnel message Nesprávné odvozování klíčů - použití HKDF pro krátké záznamy sestavení Zpracování ID zprávy - Není správně nastavováno pro tunnel builds Problémy s fragmentací - Nerespektování praktického limitu 61,2 KB Chyby endianness (pořadí bajtů) - Java používá big-endian pro všechna celá čísla Zpracování expirace - Krátký formát se přetočí 7. února 2106 Generování kontrolního součtu - Pořád vyžadováno, i když se neověřuje ","description":"Formáty zpráv mezi routery, priority a limity velikosti v rámci I2P.","id":"917124900b0896942323b4effccf9b55","section":"docs","title":"Síťový protokol I2P (I2NP)","url":"/cs/docs/specs/i2np/"},{"categories":null,"content":"Tento glosář definuje běžné termíny používané v dokumentaci a diskuzích o I2P.\nB Blockchain Distribuovaná účetní kniha, která dokáže zaznamenávat transakce mezi více stranami efektivně, ověřitelným a trvalým způsobem.\nD Decentralizace Síťová architektura, která se vyhýbá závislosti na jediné straně. Zahrnuje peer-to-peer, blockchain, federované a distribuované technologie.\nDestination Kryptografická identita tunelu. Jedná se o identity klientů a serverů v rámci sítě I2P.\nDHT (Distributed Hash Table) Používá se v některých projektech pro propojování peerů mezi sebou ukládáním informací ve formě dvojic klíč-hodnota distribuovaným způsobem.\nDistribuované systémy Akademické téma v rámci informatiky zabývající se návrhem počítačových systémů, které se skládají z mnoha jednotlivých počítačů propojených přes síť.\nF Federovaný Federace umožňuje samostatným nasazením služby komunikovat mezi sebou prostřednictvím společného protokolu.\nH Hash Číslo, obvykle zobrazované jako řetězec písmen a čísel. Může sloužit jako „otisk prstu\u0026quot; jednoznačně identifikující data.\nI I2P Invisible Internet Project: projekt určený k poskytnutí vrstvy anonymity, aby uživatelé mohli anonymně komunikovat pomocí řady aplikací.\nIP adresa Číslo počítače nebo sítě, které je jedinečné, a lze ho tedy použít k jeho adresování.\nL LeaseSet Soubor informací potřebných pro komunikaci s klientem nebo serverem na konkrétní destinaci (Destination).\nP Peer-to-Peer (P2P) Uzly (peers) poskytují část svých zdrojů přímo ostatním účastníkům sítě, bez potřeby centrální koordinace pomocí serverů nebo stabilních hostitelů.\nR Router Základní software I2P, který směruje šifrované pakety v síti I2P.\nRouterIdentity Kolekce informací potřebných pro přímou komunikaci s routerem.\nT TCP/UDP Dva základní transportní protokoly používané na internetu.\nTunnel Anonymní komunikační cesta mezi klientem nebo serverem a sítí I2P.\nU UX Uživatelská zkušenost, celkový zážitek osoby používající produkt nebo službu.\nW WebRTC Protokolový standard pro navazování spojení ve webovém prohlížeči, kde data procházejí přímo mezi uživateli.\n","description":"Běžné termíny a definice používané v dokumentaci I2P","id":"2235ec8f316773700ef08dd43b19a1c0","section":"docs","title":"Slovník","url":"/cs/docs/overview/slovn%C3%ADk/"},{"categories":null,"content":"Přehled I2P vytváří dočasné, jednosměrné tunnely — uspořádané sekvence routerů, které přeposílají šifrovaný provoz. Tunnely jsou klasifikovány jako inbound (zprávy směřují k tvůrci) nebo outbound (zprávy směřují pryč od tvůrce).\nTypická výměna směruje Alicinu zprávu ven přes jeden z jejích odchozích tunnelů, instruuje odchozí koncový bod, aby ji přeposlal na bránu jednoho z Bobových příchozích tunnelů, a poté ji Bob přijme na svém příchozím koncovém bodě.\nA: Outbound Gateway (Alice) B: Outbound Participant C: Outbound Endpoint D: Inbound Gateway E: Inbound Participant F: Inbound Endpoint (Bob) Tunnely mají pevnou životnost 10 minut a přenášejí zprávy s pevnou velikostí 1024 bajtů (1028 bajtů včetně hlavičky tunelu), aby se zabránilo analýze provozu na základě velikosti zpráv nebo časových vzorů.\nSlovník tunelů Tunnel gateway: První router v tunelu. U příchozích tunelů se identita tohoto routeru objevuje v publikovaném LeaseSet . U odchozích tunelů je gateway výchozí router (A a D výše). Tunnel endpoint: Poslední router v tunelu (C a F výše). Tunnel participant: Zprostředkující router v tunelu (B a E výše). Účastníci nemohou určit svou pozici ani směr tunelu. n-hop tunnel: Počet přeskoků mezi routery. 0-hop: Gateway a endpoint jsou stejný router – minimální anonymita. 1-hop: Gateway se připojuje přímo k endpointu – nízká latence, nízká anonymita. 2-hop: Výchozí nastavení pro průzkumné tunely; vyvážené zabezpečení/výkon. 3-hop: Doporučeno pro aplikace vyžadující silnou anonymitu. Tunnel ID: 4-bajtové celé číslo unikátní pro každý router a každý přeskok, náhodně vybrané tvůrcem. Každý přeskok přijímá a přeposílá na různých ID. Informace o vytváření tunelů Routery plnící role gateway, participant a endpoint obdrží různé záznamy v rámci Tunnel Build Message. Moderní I2P podporuje dvě metody:\nElGamal (starší verze, 528-bajtové záznamy) ECIES-X25519 (aktuální, 218-bajtové záznamy prostřednictvím Short Tunnel Build Message – STBM) Information Distributed to Participants Gateway obdrží: - Klíč vrstvy tunelu (klíč AES-256 nebo ChaCha20 v závislosti na typu tunelu) - Klíč IV tunelu (pro šifrování inicializačních vektorů) - Klíč odpovědi a IV odpovědi (pro šifrování odpovědi při vytváření) - ID tunelu (pouze pro příchozí gateway) - Hash identity dalšího uzlu a ID tunelu (pokud není koncový)\nZprostředkující účastníci obdrží: - Klíč vrstvy tunnel a IV klíč pro jejich skok - ID tunnel a informace o dalším skoku - Klíč odpovědi a IV pro šifrování odpovědi na vytvoření\nKoncové body přijímají: - Klíče vrstvy tunelu a IV - Router odpovědi a ID tunelu (pouze odchozí koncové body) - Klíč odpovědi a IV (pouze odchozí koncové body)\nPro úplné podrobnosti viz Specifikace vytváření tunnelů a Specifikace vytváření ECIES tunnelů .\nTunnel Pooling Routery seskupují tunely do fondů tunelů (tunnel pools) pro redundanci a distribuci zátěže. Každý fond udržuje více paralelních tunelů, což umožňuje převzetí funkcí při selhání jednoho tunelu. Fondy používané interně jsou exploratory tunnels, zatímco fondy specifické pro aplikace jsou client tunnels.\nKaždá destinace udržuje oddělené příchozí a odchozí skupiny konfigurované pomocí I2CP voleb (počet tunelů, počet záloh, délka a QoS parametry). Routery monitorují stav tunelů, provádějí periodické testy a automaticky obnovují selhané tunely pro udržení velikosti skupiny.\nSdružování tunelů 0-hop tunely: Nabízejí pouze věrohodné popření. Provoz vždy pochází a končí na stejném routeru — nedoporučuje se pro jakékoli anonymní použití.\n1-hop Tunnely: Poskytují základní anonymitu proti pasivním pozorovatelům, ale jsou zranitelné, pokud protivník ovládá tento jediný hop.\n2-hop Tunnels: Zahrnují dva vzdálené routery a výrazně zvyšují náklady na útok. Výchozí nastavení pro průzkumné fondy.\n3-hop Tunnely: Doporučeno pro aplikace vyžadující robustní ochranu anonymity. Další přeskoky přidávají latenci bez smysluplného zvýšení bezpečnosti.\nVýchozí nastavení: Routery používají 2-hop průzkumné tunely a aplikačně specifické 2 nebo 3 hop klientské tunely, což vyvažuje výkon a anonymitu.\nDélka tunelu Routery pravidelně testují tunely odesláním DeliveryStatusMessage přes odchozí tunel do příchozího tunelu. Pokud test selže, oba tunely obdrží zápornou váhu v profilu. Po po sobě jdoucích selháních je tunel označen jako nepoužitelný; router poté sestaví náhradu a zveřejní nový LeaseSet. Výsledky vstupují do metrik kapacity uzlů používaných systémem výběru uzlů .\nTestování tunelů Routery konstruují tunnely pomocí neinteraktivní teleskopické metody: jedna Tunnel Build Message se šíří po jednotlivých hopech. Každý hop dešifruje svůj záznam, přidá svou odpověď a přepošle zprávu dál. Konečný hop vrací agregovanou odpověď o výstavbě tunnelu jinou cestou, čímž zabraňuje korelaci. Moderní implementace používají Short Tunnel Build Messages (STBM) pro ECIES a Variable Tunnel Build Messages (VTBM) pro starší cesty. Každý záznam je šifrován per-hop pomocí ElGamal nebo ECIES-X25519.\nVytvoření tunelu Provoz v tunelu používá vícevrstvé šifrování. Každý přeskok přidává nebo odstraňuje vrstvu šifrování, jak zprávy procházejí tunelem.\nElGamal tunnels: AES-256/CBC pro datové části s PKCS#5 paddingem. ECIES tunnels: ChaCha20 nebo ChaCha20-Poly1305 pro autentizované šifrování. Každý skok má dva klíče: layer key a IV key. Routery dešifrují IV, použijí jej ke zpracování datové části, poté IV znovu zašifrují před předáním. Toto dvojité schéma IV zabraňuje značkování zpráv.\nOdchozí brány předem dešifrují všechny vrstvy, takže koncové body obdrží otevřený text poté, co všichni účastníci přidali šifrování. Příchozí tunely šifrují v opačném směru. Účastníci nemohou určit směr ani délku tunelu.\nŠifrování tunelů Dynamické životnosti tunelů a adaptivní velikost poolů pro vyvážení síťové zátěže Alternativní strategie testování tunelů a diagnostika jednotlivých hopů Volitelná validace proof-of-work nebo certifikátů šířky pásma (implementováno v API 0.9.65+) Výzkum tvarování provozu a vkládání chaff pro míchání koncových bodů Pokračující vyřazování ElGamal a migrace na ECIES-X25519 Průběžný vývoj Specifikace implementace tunelů Specifikace vytváření tunelů (ElGamal) Specifikace vytváření tunelů (ECIES-X25519) Specifikace zpráv tunelů Garlic Routing I2P Network Database Profilování a výběr peerů Model hrozeb I2P ElGamal/AES + SessionTag šifrování I2CP možnosti ","description":"Přehled terminologie I2P tunelů, jejich konstrukce a životního cyklu","id":"d2bb4d16ccaaecd4bfaae8d5b1356800","section":"docs","title":"Směrování tunelu","url":"/cs/docs/overview/tunnel-routing/"},{"categories":null,"content":" Upozornění: SOCKS tunel přeposílá datové části aplikací bez jejich sanitizace. Mnoho protokolů prozrazuje IP adresy, názvy hostitelů nebo jiné identifikátory. SOCKS používejte pouze se softwarem, který jste prověřili z hlediska anonymity.\n1. Přehled I2P poskytuje podporu proxy SOCKS 4, 4a a 5 pro odchozí spojení prostřednictvím I2PTunnel klienta. Umožňuje standardním aplikacím přístup k I2P destinacím, ale nemůže přistupovat na clearnet. Neexistuje žádný SOCKS outproxy a veškerý provoz zůstává v rámci sítě I2P.\nShrnutí implementace Parameter Java I2P i2pd Default Port User-defined 127.0.0.1:4447 Supported SOCKS Versions 4, 4a, 5 4, 4a, 5 UDP Mode Stubbed (non-functional) Stubbed (non-functional) Persistent Keys ✅ Since 0.9.9 ✅ Shared Client Tunnels Supported Supported Outproxy Support ❌ None ❌ None **Podporované typy adres:** - `.i2p` hostitelská jména (záznamy v adresáři) - Base32 hashe (`.b32.i2p`) - Bez podpory Base64 nebo běžného internetu 2. Bezpečnostní rizika a omezení Únik na aplikační vrstvě SOCKS pracuje pod aplikační vrstvou a nemůže sanitizovat protokoly. Mnoho klientů (např. prohlížeče, IRC, e-mail) zahrnuje metadata, která odhalují vaši IP adresu, název hostitele nebo podrobnosti o systému.\nBěžné úniky zahrnují: - IP adresy v hlavičkách e-mailů nebo IRC CTCP odpovědích - Skutečná jména/uživatelská jména v protokolových datech - Řetězce user-agent s otisky OS - Externí DNS dotazy - WebRTC a telemetrii prohlížeče\nI2P nemůže zabránit těmto únikům—dochází k nim nad vrstvou tunelů. SOCKS používejte pouze pro auditované klienty navržené pro anonymitu.\nSdílená identita tunelu Pokud několik aplikací sdílí SOCKS tunel, sdílejí stejnou identitu I2P destinace. To umožňuje korelaci nebo otisk prstu napříč různými službami.\nZmírnění: Použijte nesdílené tunnely pro každou aplikaci a povolte trvalé klíče pro udržení konzistentních kryptografických identit napříč restarty.\nRežim UDP není implementován Podpora UDP v SOCKS5 není implementována. Protokol inzeruje schopnost UDP, ale volání jsou ignorována. Používejte pouze klienty podporující TCP.\nBez Outproxy záměrně Na rozdíl od Toru, I2P nenabízí SOCKS outproxy pro přístup k běžnému internetu. Pokusy o připojení k externím IP adresám selžou nebo prozradí identitu. Pokud je potřeba outproxy, použijte HTTP nebo HTTPS proxy.\n3. Historický kontext Vývojáři již dlouho nedoporučují SOCKS pro anonymní použití. Z interních vývojářských diskusí a z roku 2004 Meeting 81 a Meeting 82 :\n\u0026ldquo;Přeposílání libovolného provozu je nebezpečné a jako vývojářům softwaru pro anonymitu nám přísluší mít bezpečnost našich koncových uživatelů na prvním místě.\u0026rdquo;\nPodpora SOCKS byla zahrnuta kvůli kompatibilitě, ale nedoporučuje se pro produkční prostředí. Téměř každá internetová aplikace prozrazuje citlivá metadata nevhodná pro anonymní směrování.\n4. Konfigurace Java I2P Otevřete I2PTunnel Manager Vytvořte nový klientský tunnel typu \u0026ldquo;SOCKS 4/4a/5\u0026rdquo; Nakonfigurujte možnosti: Lokální port (jakýkoliv dostupný) Sdílený klient: vypnout pro samostatnou identitu pro každou aplikaci Trvalý klíč: zapnout pro snížení korelace klíčů Spusťte tunnel i2pd i2pd obsahuje podporu SOCKS5, která je ve výchozím nastavení povolena na 127.0.0.1:4447. Konfigurace v i2pd.conf pod sekcí [SOCKSProxy] vám umožňuje upravit port, hostitele a parametry tunelu.\n5. Harmonogram vývoje Version Change Date 0.7.1 Initial SOCKS 4/4a/5 support 2010 0.9.9 Added persistent keying 2013 1.7.0 BOB API deprecated and removed 2022 2.6.0 I2P-over-Tor blocked to improve network health 2024 2.10.0 Post-quantum hybrid encryption introduced 2025 Samotný modul SOCKS nezaznamenal od roku 2013 žádné zásadní aktualizace protokolu, ale okolní tunnel stack získal vylepšení výkonu a kryptografie. 6. Doporučené alternativy Pro jakoukoliv produkční, veřejně přístupnou nebo bezpečnostně kritickou aplikaci používejte místo SOCKS jedno z oficiálních I2P API:\nAPI Description Recommended For SAM v3 (3.3) Simple Anonymous Messaging API Cross-language apps needing socket-like I/O Streaming Library TCP-like sockets for Java Native Java integrations I2CP Low-level router communication Custom protocols, router-level integration BOB Deprecated (removed 2022) Legacy only; migrate to SAM Tato API poskytují řádnou izolaci cílů, kontrolu kryptografické identity a lepší výkon směrování. 7. OnionCat / GarliCat OnionCat podporuje I2P prostřednictvím svého režimu GarliCat (rozsah IPv6 fd60:db4d:ddb5::/48). Stále funkční, ale s omezeným vývojem od roku 2019.\nUpozornění k použití: - Vyžaduje ruční konfiguraci .oc.b32.i2p v SusiDNS - Potřebuje statické přiřazení IPv6 - Oficiálně není podporováno projektem I2P\nDoporučeno pouze pro pokročilá nastavení VPN-over-I2P.\n8. Osvědčené postupy Pokud musíte použít SOCKS: 1. Vytvořte samostatné tunnely pro každou aplikaci. 2. Vypněte režim sdíleného klienta. 3. Povolte trvalé klíče. 4. Vynuťte SOCKS5 DNS rozlišení. 5. Auditujte chování protokolu kvůli únikům. 6. Vyhněte se clearnet připojením. 7. Monitorujte síťový provoz kvůli únikům.\n9. Technické shrnutí Parameter Value Supported SOCKS Versions 4, 4a, 5 Transport TCP only UDP Support Stubbed (non-functional) Clearnet Access Not supported Default Ports Java I2P: user-set; i2pd: 127.0.0.1:4447 Persistent Keying Supported since 0.9.9 Shared Tunnels Supported (discouraged) --- 10. Závěr SOCKS proxy v I2P poskytuje základní kompatibilitu s existujícími TCP aplikacemi, ale není navržen pro silné záruky anonymity. Měl by být používán pouze v kontrolovaných, auditovaných testovacích prostředích.\nPro závažná nasazení přejděte na SAM v3 nebo Streaming API. Tato API izolují identity aplikací, používají moderní kryptografii a jsou nadále vyvíjena.\nDalší zdroje Oficiální dokumentace SOCKS Specifikace SAM v3 Dokumentace Streaming Library Reference I2PTunnel Dokumentace pro vývojáře I2P Komunitní fórum ","description":"Bezpečné používání SOCKS tunelu I2P (aktualizováno pro verzi 2.10.0)","id":"e71093f25f593f15b6820398338abc89","section":"docs","title":"SOCKS Proxy","url":"/cs/docs/api/socks/"},{"categories":null,"content":"Přehled Router automaticky kontroluje aktualizace průběžným dotazováním podepsaného kanálu novinek distribuovaného prostřednictvím sítě I2P. Když je oznámena novější verze, router stáhne kryptograficky podepsaný aktualizační archiv (.su3) a připraví jej k instalaci. Tento systém zajišťuje ověřenou, vůči manipulaci odolnou a vícekanálovou distribuci oficiálních vydání.\nOd verze I2P 2.10.0 používá systém aktualizací: - RSA-4096 / SHA-512 podpisy - kontejnerový formát SU3 (nahrazující zastaralé SUD/SU2) - Redundantní zrcadla: HTTP v síti, clearnet HTTPS (veřejný internet) a BitTorrent\n1. Kanál novinek Routery každých několik hodin pravidelně načítají podepsaný kanál Atom, aby zjistily nové verze a bezpečnostní upozornění. Kanál je podepsaný a distribuován jako soubor .su3, který může obsahovat:\n\u0026lt;i2p:version\u0026gt; — nové číslo verze \u0026lt;i2p:minVersion\u0026gt; — minimální podporovaná verze routeru \u0026lt;i2p:minJavaVersion\u0026gt; — požadované minimální běhové prostředí Java \u0026lt;i2p:update\u0026gt; — uvádí více zrcadel ke stažení (I2P, HTTPS, torrent) \u0026lt;i2p:revocations\u0026gt; — data o revokaci certifikátů \u0026lt;i2p:blocklist\u0026gt; — blokovací seznamy na úrovni sítě pro kompromitované uzly Distribuce kanálu Channel Description Usage I2P HTTP (eepsite) Primary update source Private, resilient Clearnet HTTPS Fallback mirror Public fallback BitTorrent magnet Distributed channel Reduces mirror load Routers dávají přednost I2P kanálu, ale v případě potřeby se mohou uchýlit k distribuci přes clearnet (veřejný internet) nebo k torrentové distribuci. 2. Formáty souborů SU3 (aktuální standard) Zavedeno ve verzi 0.9.9, SU3 nahradilo starší formáty SUD a SU2. Každý soubor obsahuje hlavičku, užitečná data a koncový podpis.\nStruktura hlavičky \u0026lt;tr\u0026gt; \u0026lt;th style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem; text-align:left; background:var(--color-bg-secondary);\u0026quot;\u0026gt;Field\u0026lt;/th\u0026gt; \u0026lt;th style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem; text-align:left; background:var(--color-bg-secondary);\u0026quot;\u0026gt;Description\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Magic\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;\u0026lt;code\u0026gt;\u0026quot;I2Psu3\u0026quot;\u0026lt;/code\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Format Version\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;\u0026lt;code\u0026gt;0\u0026lt;/code\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Signature Type\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;e.g., \u0026lt;code\u0026gt;0x000B\u0026lt;/code\u0026gt; (RSA-SHA512-4096)\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Signature Length\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;\u0026lt;code\u0026gt;512 bytes\u0026lt;/code\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Version String\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Router version\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Signer ID\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Certificate name\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Content Type\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;1 = router update, 3 = reseed, 4 = news feed\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; Kroky ověření podpisu 1. Parsujte hlavičku a identifikujte algoritmus podpisu. 2. Ověřte hash a podpis pomocí uloženého certifikátu podepisujícího. 3. Potvrďte, že certifikát podepisujícího není revokován. 4. Porovnejte vložený řetězec verze s metadaty užitečných dat.\nRouters jsou dodávány s důvěryhodnými certifikáty podepisovatelů (aktuálně zzz a str4d) a odmítají jakékoli nepodepsané nebo odvolané zdroje.\nSU2 (Zastaralé) Používala se přípona .su2 u JAR souborů komprimovaných pomocí Pack200. Odstraněno poté, co Java 14 označila Pack200 za zastaralý (JEP 367). Deaktivováno v I2P 0.9.48+; nyní plně nahrazeno kompresí ZIP. SUD (zastaralé) Raný formát ZIP podepsaný DSA-SHA1 (pre-0.9.9). Chybí ID podepisujícího i hlavička, omezená integrita. Nahrazen kvůli slabé kryptografii a chybějícímu vynucování verzí. 3. Pracovní postup aktualizace 3.1 Ověření hlavičky Routers načítají pouze hlavičku SU3, aby ověřily řetězec verze před stažením celých souborů. To zabraňuje plýtvání šířkou pásma na neaktuálních zrcadlech nebo zastaralých verzích.\n3.2 Úplné stažení Po ověření hlavičky router stáhne celý soubor .su3 z: - Zrcadel eepsite uvnitř sítě (preferováno) - Zrcadel na clearnetu (veřejný internet) přes HTTPS (záložní) - BitTorrentu (volitelná distribuce s asistencí peerů)\nStahování používají standardní HTTP klienty I2PTunnel, s opakováním pokusů, obsluhou časových limitů a přepínáním na zrcadla.\n3.3 Ověření podpisu Každý stažený soubor prochází: - Kontrola podpisu: ověření RSA-4096/SHA512 - Shoda verzí: kontrola shody verze hlavičky a datové části - Zabránění snížení verze: zajišťuje, že aktualizace je novější než nainstalovaná verze\nNeplatné nebo neodpovídající soubory jsou okamžitě zahazovány.\n3.4 Příprava instalace Po ověření: 1. Rozbalte obsah ZIPu do dočasného adresáře 2. Odstraňte soubory uvedené v deletelist.txt 3. Nahraďte nativní knihovny, pokud je součástí lib/jbigi.jar 4. Zkopírujte certifikáty podepisovatele do ~/.i2p/certificates/ 5. Uložte aktualizaci jako i2pupdate.zip, aby se použila při příštím restartu\nAktualizace se nainstaluje automaticky při příštím spuštění nebo když je ručně vyvolána možnost „Nainstalovat aktualizaci nyní“.\n4. Správa souborů deletelist.txt Seznam v prostém textu zastaralých souborů, které je třeba odstranit před rozbalením nového obsahu.\nPravidla: - Jedna cesta na řádek (pouze relativní cesty) - Řádky začínající znakem # se ignorují - .. a absolutní cesty jsou odmítnuty\nNativní knihovny Aby se předešlo zastaralým nebo neodpovídajícím nativním binárním souborům: - Pokud existuje lib/jbigi.jar, staré soubory .so nebo .dll jsou odstraněny - Zajišťuje, že knihovny specifické pro danou platformu jsou znovu rozbaleny\n5. Správa certifikátů Routers mohou přijímat nové certifikáty podepisovatele prostřednictvím aktualizací nebo revokací v kanálu novinek.\nNové soubory .crt jsou zkopírovány do adresáře s certifikáty. Odvolané certifikáty jsou před dalšími ověřeními smazány. Podporuje rotaci klíčů bez nutnosti ručního zásahu uživatele. Všechny aktualizace jsou podepisovány offline pomocí air-gapped signing systems (systémy pro podepisování fyzicky izolované od sítě). Soukromé klíče nejsou nikdy ukládány na sestavovacích serverech.\n6. Pokyny pro vývojáře Topic Details Signing Use RSA-4096 (SHA-512) via apps/jetty/news SU3 tooling. Mirror Policy I2P eepsite preferred, clearnet HTTPS fallback, torrent optional. Testing Validate updates from prior releases, across all OS platforms. Version Enforcement minVersion prevents incompatible upgrades. Certificate Rotation Distribute new certs in updates and revocation lists. Budoucí vydání se zaměří na integraci postkvantových podpisů (viz Proposal 169) a na reprodukovatelná sestavení. 7. Přehled zabezpečení Threat Mitigation Tampering Cryptographic signature (RSA-4096/SHA512) Key Compromise Feed-based certificate revocation Downgrade Attack Version comparison enforcement Mirror Hijack Signature verification, multiple mirrors DoS Fallback to alternate mirrors/torrents MITM HTTPS transport + signature-level integrity --- 8. Verzování Router: 2.10.0 (API 0.9.67) Sémantické verzování s Major.Minor.Patch. Vynucování minimální verze brání nebezpečným aktualizacím. Podporované verze Javy: Java 8–17. Budoucí verze 2.11.0+ bude vyžadovat Javu 17+. ","description":"Bezpečný mechanismus podepsaných aktualizací a struktura kanálu pro I2P routers","id":"aea843f73d809c9546b3d675324af161","section":"docs","title":"Specifikace aktualizace softwaru","url":"/cs/docs/specs/updates/"},{"categories":null,"content":"Přehled Tento dokument specifikuje formát souboru blockfile v I2P a tabulky v hostsdb.blockfile používané Blockfile Naming Service (pojmenovací služba Blockfile). Pro souvislosti viz Pojmenování v I2P a adresář .\nBlockfile umožňuje rychlé vyhledávání destinací v kompaktním binárním formátu. Ve srovnání se zastaralým systémem hosts.txt:\nDestinace jsou uloženy v binární podobě, nikoli v Base64. Lze připojit libovolná metadata (např. datum přidání, zdroj, poznámky). Doby vyhledávání jsou zhruba 10× rychlejší. Spotřeba místa na disku se mírně zvyšuje. Blockfile (blokový soubor) je na disku uložená kolekce seřazených map (párů klíč–hodnota) implementovaná jako skiplists (skákací seznamy). Vychází z Metanotion Blockfile Database . Tato specifikace nejprve definuje strukturu souboru, poté popisuje, jak jej používá BlockfileNamingService.\nBlockfile Naming Service (služba pojmenování využívající blokové soubory) nahradila starou implementaci hosts.txt v I2P 0.8.8. \u0026gt; Při inicializaci importuje záznamy z privatehosts.txt, userhosts.txt a hosts.txt.\nFormát Blockfile (blokový soubor) Formát se skládá ze stránek o velikosti 1024 bajtů, přičemž každá z nich má na začátku magické číslo pro zajištění integrity. Stránky jsou číslovány od 1:\nPage Description 1 Superblock (starts at byte 0) 2 Metaindex skiplist (starts at byte 1024) Všechna celá čísla používají **síťové pořadí bajtů (big-endian)**. 2-bajtové hodnoty jsou bez znaménka; 4-bajtové hodnoty (čísla stránek) jsou se znaménkem a musí být kladné. Vláknování: Databáze je navržena pro jednovláknový přístup; BlockfileNamingService zajišťuje synchronizaci.\nFormát superbloku Byte Contents 0-5 Magic number 0x3141de493250 (\"1A\" 0xde \"I2P\") 6 Major version 0x01 7 Minor version 0x02 8-15 File length (in bytes) 16-19 First free list page 20-21 Mounted flag (0x01 = yes) 22-23 Span size (max key/value pairs per span, 16 for hostsdb) 24-27 Page size (as of v1.2; 1024 before that) 28-1023 Unused --- Formát stránky bloku skokového seznamu Byte Contents 0-7 Magic 0x536b69704c697374 (\"SkipList\") 8-11 First span page 12-15 First level page 16-19 Size (total keys, valid at startup) 20-23 Spans (total spans, valid at startup) 24-27 Levels (total levels, valid at startup) 28-29 Span size (as of v1.2; used for new spans) 30-1023 Unused --- Formát blokovací stránky pro přeskočení úrovně Každá úroveň má rozpětí, ale ne každé rozpětí má úroveň.\nByte Contents 0-7 Magic 0x42534c6576656c73 (\"BSLevels\") 8-9 Max height 10-11 Current height 12-15 Span page 16-… Next level pages (current height × 4 bytes, lowest first) \u0026mdash; Remaining bytes unused --- Vynechání Rozpětí Blok Formát Stránky Páry klíč–hodnota jsou napříč spans (úseky) seřazeny podle klíče. Všechny spans kromě prvního nesmí být prázdné.\nByte Contents 0-3 Magic 0x5370616e (\"Span\") 4-7 First continuation page or 0 8-11 Previous span page or 0 12-15 Next span page or 0 16-17 Max keys (16 for hostsdb) 18-19 Size (current keys) 20-1023 Key/value structures --- Formát stránky bloku pokračování rozsahu Byte Contents 0-3 Magic 0x434f4e54 (\"CONT\") 4-7 Next continuation page or 0 8-1023 Key/value structures --- Formát struktury klíč–hodnota U klíče a hodnoty délková pole nesmějí přesahovat stránky (všechny 4 bajty se musí vejít). Pokud nezbývá dost místa, přidejte padding až o 3 bajty (doplnění vycpávkou) a pokračujte na offsetu 8 následující stránky.\nByte Contents 0-1 Key length (bytes) 2-3 Value length (bytes) 4-… Key data → Value data \u0026mdash; Max length = 65535 bytes each --- Formát stránky seznamu volných bloků Byte Contents 0-7 Magic 0x2366724c69737423 (\"#frList#\") 8-11 Next free list block or 0 12-15 Number of valid free pages (0 – 252) 16-1023 Free page numbers (4 bytes each) --- Formát bloku volné stránky Byte Contents 0-7 Magic 0x7e2146524545217e (\"~!FREE!~\") 8-1023 Unused --- Metaindex Nachází se na stránce 2. Mapuje US-ASCII řetězce → 4bajtová celá čísla. Klíčem je název skiplistu; hodnotou je index stránky.\nTabulky služby Blockfile Naming Service (služba pojmenování založená na blockfile) Služba definuje několik struktur typu skiplist (datová struktura s přeskakováním). Každý span (úsek/segment) umožňuje až 16 záznamů.\nSkiplist vlastností (skokový seznam) %%__INFO__%% obsahuje jednu položku:\nKey Value info A Properties object (UTF-8 String / String map) serialized as a Mapping Typická pole: Property Description version \"4\" created Java long (ms since epoch) upgraded Java long (ms since epoch, since DB v2) lists Comma-separated host DBs (e.g. privatehosts.txt,userhosts.txt,hosts.txt) listversion_* Version of each DB (used to detect partial upgrades, since v4) --- Skiplist (skokový seznam) pro reverzní vyhledávání %%__REVERSE__%% obsahuje záznamy Integer → Properties (od DB v2).\nKlíč: První 4 bajty hashu SHA-256 Destination (cílová adresa v I2P). Hodnota: objekt Properties (serializované mapování). Více záznamů řeší kolize a Destinations s více názvy hostitele. Každý klíč vlastnosti = název hostitele; hodnota = prázdný řetězec. Skiplists (skokové seznamy) databáze hostitelů Každý ze souborů hosts.txt, userhosts.txt a privatehosts.txt mapuje jména hostitelů → Destinations (I2P cíle).\nVerze 4 podporuje více Destinations (identifikátorů cílových služeb v I2P) na jeden název hostitele (zavedeno v I2P 0.9.26). Databáze verze 3 se migrují automaticky.\nKlíč Řetězec UTF-8 (název hostitele, malými písmeny, končící na .i2p)\nHodnota Verze 4: 1 bajt s počtem dvojic vlastnost/Destination Pro každou dvojici: Vlastnosti → Destination (binárně) Verze 3: Vlastnosti → Destination (binárně) Vlastnosti DestEntry (záznamu cíle) Key Meaning a Time added (Java long ms) m Last modified (Java long ms) notes User comments s Source (file or subscription URL) v Signature verified (true/false) --- Poznámky k implementaci Třída BlockfileNamingService v jazyce Java implementuje tuto specifikaci.\nMimo kontext routeru se databáze otevírá pouze pro čtení, pokud není nastaveno i2p.naming.blockfile.writeInAppContext=true. Není určen pro přístup z více instancí ani z více JVM. Udržuje tři hlavní mapy (privatehosts, userhosts, hosts) a reverzní mapu pro rychlé vyhledávání. Odkazy Dokumentace k pojmenování a adresáři v I2P Specifikace společných struktur Databáze Blockfile od Metanotion JavaDoc pro BlockfileNamingService ","description":"Formát úložiště typu blockfile (blokový soubor) na disku, který I2P používá pro překlad názvů hostitelů","id":"5cbdbb030530ec5e0200cc202d4bff7f","section":"docs","title":"Specifikace Blockfile","url":"/cs/docs/specs/blockfile/"},{"categories":null,"content":"1. Přehled SSU2 je protokol transportní vrstvy založený na UDP, používaný pro zabezpečenou, částečně spolehlivou komunikaci mezi routery v I2P. Nejde o obecný transport, ale je specializovaný na výměnu zpráv I2NP.\nZákladní funkce Ověřená výměna klíčů prostřednictvím vzoru Noise XK Šifrované hlavičky pro odolnost vůči DPI Průchod NATem s využitím relayů a hole‑punchingu (technika navázání přímého spojení přes NAT) Migrace spojení a ověřování adresy Volitelné ověřování cesty Dopředné utajení a ochrana proti replay útokům Starší verze a kompatibilita Implementation SSU2 Default SSU1 Removed i2pd2.44.02.44.0 Java I2P0.9.560.9.61 SSU1 se již v celé veřejné síti I2P nepoužívá. 2. Kryptografie SSU2 používá Noise_XK_25519_ChaChaPoly_SHA256 s rozšířeními specifickými pro I2P.\nFunction Algorithm Notes Diffie-HellmanX25519 (RFC 7748)32-byte keys CipherChaCha20/Poly1305 (RFC 7539)AEAD encryption HashSHA-256Used for key derivation and message integrity KDFHKDF-SHA256 (RFC 5869)For session and header keys Hlavičky a užitečná data jsou kryptograficky provázány pomocí `mixHash()`. Všechny kryptografické primitivy jsou sdíleny s NTCP2 a ECIES kvůli efektivitě implementace. 3. Přehled zpráv 3.1 Pravidla datagramů UDP Každý datagram UDP nese přesně jednu zprávu SSU2. Zprávy Session Confirmed (potvrzení relace) mohou být fragmentovány do více datagramů. Minimální velikost: 40 bajtů Maximální velikost: 1472 bajtů (IPv4) / 1452 bajtů (IPv6)\n3.2 Typy zpráv Type Message Header Description 0Session Request32BHandshake initiation 1Session Created32BHandshake response 2Session Confirmed16BFinal handshake, may be fragmented 6Data16BEncrypted I2NP message blocks 7Peer Test32BNAT reachability testing 9Retry32BToken or rejection notice 10Token Request32BRequest for validation token 11Hole Punch32BNAT traversal signaling --- 4. Navázání relace 4.1 Standardní tok (platný token) Alice Bob SessionRequest ─────────────\u0026gt; \u0026lt;────────────── SessionCreated SessionConfirmed ────────────\u0026gt; 4.2 Získání tokenu Alice Bob TokenRequest ───────────────\u0026gt; \u0026lt;────────────── Retry (Token) SessionRequest ─────────────\u0026gt; \u0026lt;────────────── SessionCreated SessionConfirmed ────────────\u0026gt; 4.3 Neplatný token Alice Bob SessionRequest ─────────────\u0026gt; \u0026lt;────────────── Retry (Termination) 5. Struktury hlaviček 5.1 Dlouhá hlavička (32 bajtů) Používá se před navázáním relace (SessionRequest, Created, Retry, PeerTest, TokenRequest, HolePunch).\nField Size Description Destination Connection ID8Random unique ID Packet Number4Random (ignored during handshake) Type1Message type Version1Always 2 NetID12 = main I2P network Flags1Reserved (0) Source Connection ID8Random ID distinct from destination Token8Token for address validation ### 5.2 Krátká hlavička (16 bajtů) Používá se během navázaných relací (SessionConfirmed, Data).\nField Size Description Destination Connection ID8Stable throughout session Packet Number4Incrementing per message Type1Message type (2 or 6) Flags3ACK/fragment flags --- 6. Šifrování 6.1 AEAD Veškerá užitečná data jsou šifrována pomocí ChaCha20/Poly1305 AEAD (ověřené šifrování s přidruženými daty):\nciphertext = ChaCha20_Poly1305_Encrypt(key, nonce, plaintext, associated_data) Nonce (jednorázová hodnota): 12 bajtů (4 nulové bajty + 8 bajtů čítače) Tag (autentizační značka): 16 bajtů Přidružená data: zahrnuje hlavičku pro vazbu integrity 6.2 Ochrana záhlaví Hlavičky jsou maskovány pomocí klíčového proudu ChaCha20 odvozeného z klíčů hlavičky relace. To zajišťuje, že všechna ID spojení a pole paketů vypadají náhodně, což poskytuje odolnost vůči DPI (hloubková inspekce paketů).\n6.3 Odvozování klíčů Phase Input Output InitialintroKey + salthandshake header key HandshakeDH(X25519)chainKey + AEAD key Data phasechainKeyTX/RX keys Key rotationoldKeynewKey --- 7. Zabezpečení a prevence replay útoků Tokeny jsou vázané na IP adresu, vyprší za ~60 sekund. Replay útokům se předchází pomocí Bloomových filtrů pro každou relaci. Duplicitní efemérní klíče jsou odmítány. Hlavičky a užitečná data jsou kryptograficky provázány. Routers musí zahodit každý paket, který neprojde autentizací AEAD, nebo má neplatnou verzi či NetID.\n8. Číslování paketů a životnost relace Každý směr si udržuje svůj vlastní 32bitový čítač. - Začíná na 0, zvyšuje se s každým paketem. - Nesmí se přetéct; je třeba provést rekey relace (znovu vygenerovat klíče) nebo ji ukončit před dosažením 2³².\nIdentifikátory připojení zůstávají po celou relaci neměnné, a to i během migrace.\n9. Datová fáze Typ = 6 (Data) Krátká hlavička (16 bajtů) Užitečná data obsahují jeden nebo více šifrovaných bloků: seznamy ACK/NACK fragmenty zpráv I2NP Výplň (0–31 náhodných bajtů) Ukončovací bloky (volitelné) Selektivní retransmise a doručování mimo pořadí jsou podporovány. Spolehlivost zůstává „částečně spolehlivá“ — chybějící pakety mohou být po vyčerpání limitů opakování tiše zahozeny.\n10. Přeposílání a průchod NAT Message Type Purpose Peer Test7Determines inbound reachability Retry9Issues new token or rejection Token Request10Requests new address token Hole Punch11Coordinates NAT hole punching Přeposílací routery pomáhají uzlům za restriktivními NATy pomocí těchto řídicích zpráv. 11. Ukončení relace Kterákoli strana může relaci ukončit pomocí Termination block (blok pro ukončení) v rámci Data message (datová zpráva). Prostředky musí být okamžitě po přijetí uvolněny. Opakované pakety pro ukončení lze po potvrzení ignorovat.\n12. Pokyny k implementaci Routers MUSÍ: - Ověřovat version = 2 a NetID = 2. - Zahazovat pakety \u0026lt;40 bajtů nebo s neplatným AEAD. - Vynucovat 120s replay cache (mezipaměť proti přehrání). - Odmítat opětovně použité tokeny nebo efemérní klíče.\nRouters SHOULD: - Náhodně volit výplň 0–31 bajtů. - Používat adaptivní retransmisi (RFC 6298). - Implementovat ověřování cesty pro každého protějška před migrací.\n13. Shrnutí zabezpečení Property Achieved By Forward secrecyX25519 ephemeral keys Replay protectionTokens + Bloom filter Authenticated encryptionChaCha20/Poly1305 KCI resistanceNoise XK pattern DPI resistanceEncrypted headers NAT traversalRelay + Hole Punch MigrationStatic connection IDs --- 14. Reference Návrh 159 – SSU2 Rámec protokolu Noise RFC 9000 – Transport QUIC RFC 9001 – QUIC TLS RFC 7539 – ChaCha20/Poly1305 AEAD RFC 7748 – X25519 ECDH RFC 5869 – HKDF-SHA256 ","description":"Zabezpečený částečně spolehlivý transportní protokol UDP verze 2","id":"b45756033b706b68daaee09f536f3c91","section":"docs","title":"Specifikace SSU2","url":"/cs/docs/specs/ssu2/"},{"categories":null,"content":"Přehled Účel ECIES-X25519-AEAD-Ratchet je moderní protokol pro end-to-end šifrování v I2P, který nahrazuje starší systém ElGamal/AES+SessionTags. Poskytuje dopředné utajení, autentizované šifrování a významná zlepšení výkonu i bezpečnosti.\nHlavní vylepšení oproti ElGamal/AES+SessionTags Menší klíče: 32bajtové klíče vs 256bajtové veřejné klíče ElGamal (snížení o 87,5 %) Dopředné utajení: Dosahováno pomocí DH ratcheting (postupné obnovování klíčů) (není dostupné ve starším protokolu) Moderní kryptografie: X25519 DH, ChaCha20-Poly1305 AEAD (autentizované šifrování s přidruženými daty), SHA-256 Autentizované šifrování: Vestavěná autentizace díky konstrukci AEAD Obousměrný protokol: Spárované příchozí/odchozí relace vs jednosměrný starší protokol Efektivní značky: 8bajtové značky relace vs 32bajtové značky (snížení o 75 %) Zakrývání provozu: Elligator2 kódování (technika maskování) činí handshaky (navazování spojení) nerozeznatelnými od náhodných dat Stav nasazení První vydání: Verze 0.9.46 (25. května 2020) Nasazení v síti: Dokončeno k roku 2020 Aktuální stav: Vyzrálý, široce nasazený (v provozu 5+ let) Podpora routeru: Vyžadována verze 0.9.46 nebo vyšší Požadavky na Floodfill: Téměř 100% přijetí pro šifrované dotazy Stav implementace Plně implementováno: - Zprávy typu New Session (NS) s vazbou - Zprávy typu New Session Reply (NSR) - Zprávy typu Existing Session (ES) - DH ratchet mechanism (ráčnový mechanismus DH) - Značka relace a ráčny symetrických klíčů - bloky DateTime, NextKey, ACK, ACK Request, Garlic Clove a Padding\nNení implementováno (k verzi 0.9.50): - blok MessageNumbers (typ 6) - blok Options (typ 5) - blok Termination (typ 4) - automatické odpovědi na úrovni protokolu - režim Zero static key (režim bez statického klíče) - multicastové relace\nPoznámka: Stav implementace pro verze 1.5.0 až 2.10.0 (2021–2025) vyžaduje ověření, protože některé funkce mohly být přidány.\nZáklady protokolu Rámec protokolu Noise ECIES-X25519-AEAD-Ratchet je založen na Noise Protocol Framework (rámec protokolu Noise; revize 34, 2018-07-11), konkrétně na vzoru handshaku IK (interaktivní, se známým vzdáleným statickým klíčem) s rozšířeními specifickými pro I2P.\nIdentifikátor protokolu Noise Noise_IKelg2+hs2_25519_ChaChaPoly_SHA256 Komponenty identifikátoru: - Noise - Základní rámec - IK - Interaktivní vzor handshake se známým statickým klíčem protistrany - elg2 - Kódování Elligator2 pro efemérní klíče (rozšíření I2P) - +hs2 - MixHash volaný před druhou zprávou pro smíchání tagu (rozšíření I2P) - 25519 - Diffie–Hellmanova funkce X25519 - ChaChaPoly - AEAD (ověřené šifrování s přidruženými daty) šifra ChaCha20-Poly1305 - SHA256 - Hashovací funkce SHA-256\nVzor handshaku Noise Notace vzoru IK:\n\u0026lt;- s (Bob\u0026#39;s static key known to Alice) ... -\u0026gt; e, es, s, ss (Alice sends ephemeral, DH es, static key, DH ss) \u0026lt;- e, ee, se (Bob sends ephemeral, DH ee, DH se) Význam tokenů: - e - Přenos efemérního klíče - s - Přenos statického klíče - es - DH (Diffie-Hellman) mezi efemérním klíčem Alice a statickým klíčem Boba - ss - DH mezi statickým klíčem Alice a statickým klíčem Boba - ee - DH mezi efemérním klíčem Alice a efemérním klíčem Boba - se - DH mezi statickým klíčem Boba a efemérním klíčem Alice\nBezpečnostní vlastnosti protokolu Noise V terminologii Noise poskytuje vzor IK:\nMessage Authentication Level Confidentiality Level Message\u0026nbsp;1 (NS) Level\u0026nbsp;1 (sender auth, KCI vulnerable) Level\u0026nbsp;2 (weak forward secrecy) Message\u0026nbsp;2 (NSR) Level\u0026nbsp;2 (mutual auth) Level\u0026nbsp;4 (weak forward secrecy) Transport (ES) Level\u0026nbsp;2 (mutual auth) Level\u0026nbsp;5 (strong forward secrecy) **Úrovně autentizace:** - **Úroveň 1**: Uživatelská data jsou ověřena jako náležející vlastníkovi statického klíče odesílatele, ale jsou zranitelná vůči Key Compromise Impersonation (KCI, vydávání se za jinou stranu po kompromitaci klíče) - **Úroveň 2**: Odolné vůči útokům KCI po NSR Úrovně důvěrnosti: - Úroveň 2: Dopředná bezpečnost pokud je později kompromitován statický klíč odesílatele - Úroveň 4: Dopředná bezpečnost pokud je později kompromitován efemérní klíč odesílatele - Úroveň 5: Plná dopředná bezpečnost po smazání obou efemérních klíčů\nRozdíly mezi IK a XK Vzor IK se liší od vzoru XK používaného v NTCP2 a SSU2:\nČtyři DH operace: IK používá 4 DH operace (es, ss, ee, se) oproti 3 u XK Okamžitá autentizace: Alice je autentizována v první zprávě (úroveň autentizace 1) Rychlejší dopředné utajení: Plné dopředné utajení (úroveň 5) dosaženo po druhé zprávě (1-RTT) Kompromis: Užitečná data první zprávy nejsou chráněna dopředným utajením (oproti XK, kde jsou všechna užitečná data chráněna dopředným utajením) Shrnutí: IK umožňuje doručení Bobovy odpovědi v 1-RTT s plným dopředným utajením, za cenu toho, že počáteční požadavek není chráněn dopředným utajením.\nKoncepty Signal Double Ratchet (dvojitý západkový mechanismus) ECIES (schéma integrovaného šifrování na eliptických křivkách) přebírá koncepty z Signal Double Ratchet Algorithm :\nDH Ratchet (ráčnový mechanismus založený na DH): Zajišťuje dopředné utajení pravidelnou výměnou nových DH klíčů Symmetric Key Ratchet (ráčnový mechanismus pro symetrické klíče): Odvozuje nové klíče relace pro každou zprávu Session Tag Ratchet (ráčnový mechanismus pro značky relace): Deterministicky generuje session tags pro jednorázové použití Klíčové rozdíly oproti Signal: - Méně časté ratcheting (postupné obnovování klíčů): I2P provádí ratcheting pouze když je to potřeba (při blížícím se vyčerpání tagů nebo podle zásad) - Session tags (značky relace) místo šifrování hlavičky: Používá deterministické session tags namísto šifrovaných hlaviček - Explicitní ACK (potvrzení přijetí): Používá in-band ACK bloky místo toho, aby se spoléhal výhradně na reverzní provoz - Oddělené ratchety tagů a klíčů: Efektivnější pro příjemce (může odložit výpočet klíče)\nRozšíření I2P pro Noise Kódování Elligator2: Efemérní klíče kódované tak, aby byly nerozeznatelné od náhodných dat Tag předřazený před NSR: Session tag (identifikátor relace) přidán před zprávu NSR (Noise Session Request) pro korelaci Definovaný formát užitečných dat: Bloková struktura užitečných dat pro všechny typy zpráv Zapouzdření I2NP: Všechny zprávy jsou zapouzdřeny do záhlaví I2NP Garlic Message Oddělená datová fáze: Transportní zprávy (ES) se odchylují od standardní datové fáze protokolu Noise Kryptografické primitivy Diffie-Hellman na křivce X25519 Specifikace: RFC 7748 Vlastnosti klíče: - Velikost soukromého klíče: 32 bajtů - Velikost veřejného klíče: 32 bajtů - Velikost sdíleného tajemství: 32 bajtů - Pořadí bajtů: Little-endian - Křivka: Curve25519\nProvoz:\nX25519 GENERATE_PRIVATE() Vygeneruje náhodný soukromý klíč o délce 32 bajtů:\nprivkey = CSRNG(32) X25519 DERIVE_PUBLIC(privkey) Odvodí odpovídající veřejný klíč:\npubkey = curve25519_scalarmult_base(privkey) Vrací 32bajtový veřejný klíč v little-endian (pořadí bajtů s nejméně významným bajtem jako prvním).\nX25519 DH(privkey, pubkey) Provádí Diffie-Hellmanovu dohodu o klíči:\nsharedSecret = curve25519_scalarmult(privkey, pubkey) Vrací 32bajtové sdílené tajemství.\nBezpečnostní poznámka: Implementátoři musí ověřit, že sdílené tajemství není tvořeno samými nulami (slabý klíč). V takovém případě odmítněte a ukončete handshake (navázání spojení).\nChaCha20-Poly1305 AEAD (autentizované šifrování s přidruženými daty) Specifikace: RFC 7539 sekce 2.8\nParametry: - Velikost klíče: 32 bajtů (256 bitů) - Velikost nonce (jednorázová hodnota): 12 bajtů (96 bitů) - Velikost MAC (ověřovací kód zprávy): 16 bajtů (128 bitů) - Velikost bloku: 64 bajtů (interní)\nFormát nonce (jednorázové číslo):\nByte 0-3: 0x00 0x00 0x00 0x00 (always zero) Byte 4-11: Little-endian counter (message number N) Konstrukce AEAD:\nAEAD kombinuje proudovou šifru ChaCha20 s MAC Poly1305:\nVygenerujte klíčový proud ChaCha20 z klíče a nonce (jednorázového čísla) Zašifrujte otevřený text operací XOR s klíčovým proudem Spočítejte Poly1305 MAC nad (asociovaná data || šifrotext) Připojte 16bajtový MAC k šifrotextu ChaCha20-Poly1305 ENCRYPT(k, n, plaintext, ad) Šifruje otevřený text s autentizací:\n# Inputs k = 32-byte cipher key n = 12-byte nonce (first 4 bytes zero, last 8 bytes = message number) plaintext = data to encrypt (0 to 65519 bytes) ad = associated data (optional, used in MAC calculation) # Output ciphertext = chacha20_encrypt(k, n, plaintext) mac = poly1305(ad || ciphertext, poly1305_key_gen(k, n)) return ciphertext || mac # Total length = len(plaintext) + 16 Vlastnosti: - Šifrovaný text má stejnou délku jako otevřený text (proudová šifra) - Výstup je plaintext_length + 16 bajtů (zahrnuje MAC) - Celý výstup je nerozeznatelný od náhodných dat, pokud je klíč tajný - MAC autentizuje jak přidružená data, tak šifrovaný text\nChaCha20-Poly1305 DECRYPT(k, n, ciphertext, ad) Dešifruje a ověřuje autentizaci:\n# Split ciphertext and MAC ct_without_mac = ciphertext[0:-16] received_mac = ciphertext[-16:] # Verify MAC expected_mac = poly1305(ad || ct_without_mac, poly1305_key_gen(k, n)) if not constant_time_compare(received_mac, expected_mac): raise AuthenticationError(\u0026#34;MAC verification failed\u0026#34;) # Decrypt plaintext = chacha20_decrypt(k, n, ct_without_mac) return plaintext Kritické bezpečnostní požadavky: - Nonces (jednorázové hodnoty) MUSÍ být jedinečné pro každou zprávu se stejným klíčem - Nonces NESMÍ být znovu použity (katastrofální selhání v případě opětovného použití) - Ověření MAC MUSÍ používat porovnání v konstantním čase k zamezení časových útoků - Neúspěšné ověření MAC MUSÍ vést k úplnému odmítnutí zprávy (žádné částečné dešifrování)\nHashovací funkce SHA-256 Specifikace: NIST FIPS 180-4\nVlastnosti: - Velikost výstupu: 32 bajtů (256 bitů) - Velikost bloku: 64 bajtů (512 bitů) - Úroveň zabezpečení: 128 bitů (odolnost proti kolizím)\nProvoz:\nSHA-256 H(p, d) Hash SHA-256 s personalizačním řetězcem:\nH(p, d) := SHA256(p || d) Kde || značí zřetězení, p je personalizační řetězec, d jsou data.\nSHA-256 MixHash(d) Aktualizuje průběžně počítaný hash novými daty:\nh = SHA256(h || d) Používá se během Noise handshake (navázání spojení v Noise) k udržování hashe transkriptu.\nDerivace klíče pomocí HKDF Specifikace: RFC 5869 Popis: Funkce odvozování klíče založená na HMAC s použitím SHA-256\nParametry: - Hašovací funkce: HMAC-SHA256 - Délka soli: až 32 bajtů (velikost výstupu SHA-256) - Délka výstupu: proměnlivá (až 255 * 32 bajtů)\nFunkce HKDF (funkce pro odvozování klíčů na bázi HMAC):\ndef HKDF(salt, ikm, info, length): \u0026#34;\u0026#34;\u0026#34; Args: salt: Salt value (32 bytes max for SHA-256) ikm: Input key material (any length) info: Context-specific info string length: Desired output length in bytes Returns: output: Derived key material (length bytes) \u0026#34;\u0026#34;\u0026#34; # Extract phase prk = HMAC-SHA256(salt, ikm) # Expand phase n = ceil(length / 32) t = b\u0026#39;\u0026#39; okm = b\u0026#39;\u0026#39; for i in range(1, n + 1): t = HMAC-SHA256(prk, t || info || byte(i)) okm = okm || t return okm[0:length] Běžné vzorce používání:\n# Generate two keys (64 bytes total) keydata = HKDF(chainKey, sharedSecret, \u0026#34;KDFDHRatchetStep\u0026#34;, 64) nextRootKey = keydata[0:31] chainKey = keydata[32:63] # Generate session tag (8 bytes) tagdata = HKDF(chainKey, CONSTANT, \u0026#34;SessionTagKeyGen\u0026#34;, 64) nextChainKey = tagdata[0:31] sessionTag = tagdata[32:39] # Generate symmetric key (32 bytes) keydata = HKDF(chainKey, ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) nextChainKey = keydata[0:31] sessionKey = keydata[32:63] Informační řetězce používané v ECIES: - \u0026quot;KDFDHRatchetStep\u0026quot; - Odvozování klíče v DH ratchet (ráčnový mechanismus) - \u0026quot;TagAndKeyGenKeys\u0026quot; - Inicializace klíčů pro řetězce tagů a klíčů - \u0026quot;STInitialization\u0026quot; - Inicializace ratchetu relačního tagu - \u0026quot;SessionTagKeyGen\u0026quot; - Generování relačního tagu - \u0026quot;SymmetricRatchet\u0026quot; - Generování symetrického klíče - \u0026quot;XDHRatchetTagSet\u0026quot; - Klíč sady tagů pro DH ratchet - \u0026quot;SessionReplyTags\u0026quot; - Generování sady tagů pro NSR - \u0026quot;AttachPayloadKDF\u0026quot; - Odvozování klíče pro užitečná data NSR\nKódování Elligator2 (algoritmus pro mapování bodů na eliptické křivce na náhodně vypadající data) Účel: Zakódovat veřejné klíče X25519 tak, aby byly nerozeznatelné od rovnoměrně náhodných 32bajtových řetězců.\nSpecifikace: Článek Elligator2 Problém: Standardní veřejné klíče X25519 mají rozpoznatelnou strukturu. Pozorovatel může identifikovat zprávy handshake (navázání spojení) detekcí těchto klíčů, i když je obsah šifrován.\nŘešení: Elligator2 poskytuje bijektivní zobrazení mezi ~50 % platných veřejných klíčů X25519 a náhodně vypadajícími 254bitovými řetězci.\nGenerování klíčů pomocí Elligator2 (kryptografická technika pro maskování veřejných klíčů):\nElligator2 GENERATE_PRIVATE_ELG2() Vygeneruje soukromý klíč, který se mapuje na veřejný klíč, jenž lze zakódovat pomocí Elligator2 (algoritmus pro zakódování do uniformní podoby):\nwhile True: privkey = CSRNG(32) pubkey = DERIVE_PUBLIC(privkey) # Test if public key is Elligator2-encodable try: encoded = ENCODE_ELG2(pubkey) # Success - this key pair is suitable return privkey except NotEncodableError: # Try again with new random key continue Důležité: Přibližně 50 % náhodně generovaných soukromých klíčů vytvoří veřejné klíče, které nelze zakódovat. Tyto je třeba zahodit a pokusit se o novou generaci.\nOptimalizace výkonu: Generujte klíče předem ve vlákně na pozadí, abyste udržovali zásobu vhodných párů klíčů a předešli prodlevám při navazování spojení.\nElligator2 ENCODE_ELG2(pubkey) Zakóduje veřejný klíč do 32 náhodně vypadajících bajtů:\ndef ENCODE_ELG2(pubkey): \u0026#34;\u0026#34;\u0026#34; Encodes X25519 public key using Elligator2. Args: pubkey: 32-byte X25519 public key (little-endian) Returns: encoded: 32-byte encoded key indistinguishable from random Raises: NotEncodableError: If pubkey cannot be encoded \u0026#34;\u0026#34;\u0026#34; # Perform Elligator2 representative calculation # Returns 254-bit value (31.75 bytes) encodedKey = elligator2_encode(pubkey) # Add 2 random bits to MSB to make full 32 bytes randomByte = CSRNG(1) encodedKey[31] |= (randomByte \u0026amp; 0xc0) return encodedKey Podrobnosti kódování: - Elligator2 (metoda pro uniformní kódování veřejných klíčů) vytváří 254 bitů (ne plných 256) - Nejvyšší 2 bity bajtu 31 jsou náhodná výplň - Výsledek je rovnoměrně rozložen v 32bajtovém prostoru - Úspěšně kóduje přibližně 50 % platných veřejných klíčů X25519\nElligator2 DECODE_ELG2(encodedKey) Dekóduje se zpět na původní veřejný klíč:\ndef DECODE_ELG2(encodedKey): \u0026#34;\u0026#34;\u0026#34; Decodes Elligator2-encoded key back to X25519 public key. Args: encodedKey: 32-byte encoded key Returns: pubkey: 32-byte X25519 public key (little-endian) \u0026#34;\u0026#34;\u0026#34; # Mask out 2 random padding bits from MSB encodedKey[31] \u0026amp;= 0x3f # Perform Elligator2 representative inversion pubkey = elligator2_decode(encodedKey) return pubkey Bezpečnostní vlastnosti: - Kódované klíče jsou výpočetně nerozlišitelné od náhodných bajtů - Žádné statistické testy nedokážou spolehlivě detekovat klíče kódované metodou Elligator2 - Dekódování je deterministické (stejný kódovaný klíč vždy vede ke stejnému veřejnému klíči) - Kódování je bijektivní pro ~50 % klíčů v kódovatelné podmnožině\nPoznámky k implementaci: - Uložte zakódované klíče už ve fázi generování, abyste se vyhnuli opětovnému kódování během navazování spojení - Nevhodné klíče z generování Elligator2 lze použít pro NTCP2 (který Elligator2 nevyžaduje) - Generování klíčů na pozadí je zásadní pro výkon - Průměrná doba generování se kvůli 50% míře vyřazení zdvojnásobuje\nFormáty zpráv Přehled ECIES definuje tři typy zpráv:\nNew Session (NS): Počáteční zpráva handshake (navázání spojení) od Alice Bobovi New Session Reply (NSR): Bobova odpověď v rámci handshake Alici Existing Session (ES): Všechny následující zprávy v obou směrech Všechny zprávy jsou zapouzdřeny ve formátu I2NP Garlic Message (specifický formát zprávy v rámci I2NP) s dalšími vrstvami šifrování.\nI2NP kontejner zpráv typu Garlic Všechny zprávy ECIES (schéma šifrování s eliptickými křivkami) jsou zapouzdřeny do standardních hlaviček I2NP Garlic Message:\n+----+----+----+----+----+----+----+----+ |type| msg_id | expiration | +----+----+----+----+----+----+----+----+ | size |chks| +----+----+----+----+----+----+----+----+ | length | | +----+----+----+----+ + | encrypted data | ~ ~ Pole: - type: 0x26 (Garlic Message – zpráva Garlic) - msg_id: 4bajtové ID zprávy I2NP - expiration: 8bajtové unixové časové razítko (milisekundy) - size: 2bajtová velikost užitečných dat - chks: 1bajtový kontrolní součet - length: 4bajtová délka šifrovaných dat - encrypted data: užitečná data šifrovaná pomocí ECIES\nÚčel: Poskytuje identifikaci zpráv a směrování na vrstvě I2NP. Pole length umožňuje příjemcům zjistit celkovou velikost šifrovaných užitečných dat.\nZpráva nové relace (NS) Zpráva New Session zahajuje novou relaci od Alice k Bobovi. Má tři varianty:\nS vazbou (1b): Zahrnuje Aličin statický klíč pro obousměrnou komunikaci Bez vazby (1c): Vynechává statický klíč pro jednosměrnou komunikaci Jednorázové (1d): Režim jediné zprávy bez navazování relace Zpráva NS s vazbou (typ 1b) Případ použití: streamování, datagramy umožňující odpověď, jakýkoli protokol, který vyžaduje odpověď\nCelková délka: 96 + payload_length bajtů\nFormát:\n+----+----+----+----+----+----+----+----+ | | + + | New Session Ephemeral Public Key | + 32 bytes + | Encoded with Elligator2 | + + | | +----+----+----+----+----+----+----+----+ | | + Static Key Section + | ChaCha20 encrypted data | + 32 bytes + | | + + | | +----+----+----+----+----+----+----+----+ | Poly1305 Message Authentication Code | + (MAC) for Static Key Section + | 16 bytes | +----+----+----+----+----+----+----+----+ | | + Payload Section + | ChaCha20 encrypted data | ~ Variable length ~ | | + + | | +----+----+----+----+----+----+----+----+ | Poly1305 Message Authentication Code | + (MAC) for Payload Section + | 16 bytes | +----+----+----+----+----+----+----+----+ Podrobnosti pole:\nEfemérní veřejný klíč (32 bajtů, v otevřeném textu): - Jednorázový veřejný klíč X25519 Alice - Kódován pomocí Elligator2 (nerozlišitelný od náhodných dat) - Pro každou NS zprávu generován nově (nikdy se nepoužije znovu) - Formát little-endian\nSekce statického klíče (32 bajtů šifrovaných, 48 bajtů včetně MAC): - Obsahuje statický veřejný klíč X25519 Alice (32 bajtů) - Šifrováno pomocí ChaCha20 - Autentizováno pomocí Poly1305 MAC (16 bajtů) - Použito Bobem ke svázání relace s destinací Alice\nSekce datové části (šifrovaná s proměnnou délkou, +16 bajtů MAC): - Obsahuje garlic cloves (části zprávy v rámci garlic encryption) a další bloky - Musí obsahovat blok DateTime jako první blok - Obvykle obsahuje bloky Garlic Clove s aplikačními daty - Může obsahovat blok NextKey pro okamžitý ratchet (krok posunu klíčů) - Šifrováno pomocí ChaCha20 - Autentizováno pomocí Poly1305 MAC (16 bajtů)\nBezpečnostní vlastnosti: - Efemérní klíč zajišťuje dopředné utajení - Statický klíč autentizuje Alici (svazuje s cílem) - Obě části mají samostatné MAC pro oddělení domén - Celé navázání spojení provádí 2 operace DH (es, ss)\nZpráva NS bez vazby (typ 1c) Případ použití: Surové datagramy, kde se odpověď neočekává ani není žádoucí\nCelková délka: 96 + payload_length bajtů\nFormát:\n+----+----+----+----+----+----+----+----+ | | + + | New Session Ephemeral Public Key | + 32 bytes + | Encoded with Elligator2 | + + | | +----+----+----+----+----+----+----+----+ | | + Flags Section + | ChaCha20 encrypted data | + 32 bytes + | All zeros | + + | | +----+----+----+----+----+----+----+----+ | Poly1305 Message Authentication Code | + (MAC) for above section + | 16 bytes | +----+----+----+----+----+----+----+----+ | | + Payload Section + | ChaCha20 encrypted data | ~ Variable length ~ | | + + | | +----+----+----+----+----+----+----+----+ | Poly1305 Message Authentication Code | + (MAC) for Payload Section + | 16 bytes | +----+----+----+----+----+----+----+----+ Klíčový rozdíl: sekce Flags obsahuje 32 nulových bajtů místo statického klíče.\nDetekce: Bob určí typ zprávy dešifrováním 32bajtové sekce a ověřením, zda jsou všechny bajty nulové: - Všechny nuly → nevázaná relace (typ 1c) - Nenulové → vázaná relace se statickým klíčem (typ 1b)\nVlastnosti: - Žádný statický klíč znamená, že není vazba na Aličin cíl - Bob nemůže posílat odpovědi (není znám žádný cíl) - Provádí pouze 1 DH operaci - Řídí se vzorem Noise \u0026ldquo;N\u0026rdquo; spíše než \u0026ldquo;IK\u0026rdquo; - Efektivnější, když odpovědi nejsou nikdy potřeba\nFlags Section (vyhrazeno pro budoucí použití): Aktuálně samé nuly. V budoucích verzích může sloužit k vyjednávání funkcí.\nNS Jednorázová zpráva (Typ 1d) Případ použití: Jediná anonymní zpráva bez relace a bez očekávané odpovědi\nCelková délka: 96 + payload_length bajtů\nFormát: Shodný s NS bez vazby (typ 1c)\nRozdíl: - Typ 1c může v rámci stejné relace odeslat více zpráv (následují ES messages) - Typ 1d odešle přesně jednu zprávu bez navázání relace - V praxi s nimi mohou implementace zpočátku zacházet totožně\nVlastnosti: - Maximální anonymita (žádný statický klíč, žádná relace) - Žádná ze stran neuchovává stav relace - Řídí se vzorcem Noise \u0026ldquo;N\u0026rdquo; - Jediná operace DH (es)\nZpráva New Session Reply (NSR) Bob odešle jednu nebo více zpráv NSR (typ protokolové zprávy) v reakci na zprávu NS (typ protokolové zprávy) od Alice. NSR dokončuje Noise IK handshake (navázání spojení pomocí schématu Noise IK) a zřizuje obousměrnou relaci.\nCelková délka: 72 + payload_length bajtů\nFormát:\n+----+----+----+----+----+----+----+----+ | Session Tag 8 bytes | +----+----+----+----+----+----+----+----+ | | + Ephemeral Public Key + | | + 32 bytes + | Encoded with Elligator2 | + + | | +----+----+----+----+----+----+----+----+ | Poly1305 Message Authentication Code | + (MAC) for Key Section (empty) + | 16 bytes | +----+----+----+----+----+----+----+----+ | | + Payload Section + | ChaCha20 encrypted data | ~ Variable length ~ | | + + | | +----+----+----+----+----+----+----+----+ | Poly1305 Message Authentication Code | + (MAC) for Payload Section + | 16 bytes | +----+----+----+----+----+----+----+----+ Podrobnosti pole:\nZnačka relace (8 bajtů, v otevřeném textu): - Generováno z NSR tagsetu (množina značek) (viz sekce KDF) - Propojuje tuto odpověď se zprávou NS od Alice - Umožňuje Alici identifikovat, na které NS tato NSR odpovídá - Jednorázové použití (nikdy se znovu nepoužije)\nEfemérní veřejný klíč (32 bajtů, v otevřené podobě): - Bobův jednorázový veřejný klíč X25519 - Zakódovaný pomocí Elligator2 - Generován znovu pro každou zprávu NSR - Musí být odlišný pro každý odeslaný NSR\nMAC sekce klíče (16 bajtů): - Autentizuje prázdná data (ZEROLEN) - Součást protokolu Noise IK (vzor se) - Používá hash přepisu jako přidružená data - Zásadní pro svázání NSR s NS\nSekce užitečných dat (proměnlivé délky): - Obsahuje garlic cloves (stroužky v rámci garlic encryption) a bloky - Obvykle zahrnuje odpovědi aplikační vrstvy - Může být prázdná (ACK-only NSR, tj. pouze potvrzení v NSR) - Maximální velikost: 65519 bajtů (65535 - 16bajtový MAC)\nVíce zpráv NSR:\nBob může v odpovědi na jeden NS odeslat více zpráv NSR: - Každá zpráva NSR má jedinečný efemérní klíč - Každá zpráva NSR má jedinečnou značku relace - Alice použije první přijatou zprávu NSR k dokončení navázání spojení (handshake) - Ostatní zprávy NSR slouží jako redundance (pro případ ztráty paketů)\nKritické načasování: - Alice musí obdržet jeden NSR před odesláním ES zpráv - Bob musí obdržet jednu ES zprávu před odesláním ES zpráv - NSR odvozuje obousměrné klíče relace pomocí operace split()\nBezpečnostní vlastnosti: - Dokončuje Noise IK handshake (schéma navázání spojení IK v rámci frameworku Noise) - Provádí 2 další operace DH (ee, se) - Celkem 4 operace DH napříč NS+NSR - Dosahuje vzájemného ověření (úroveň 2) - Poskytuje slabé dopředné utajení (úroveň 4) pro payload NSR\nZpráva pro existující relaci (ES) Všechny zprávy po handshake NS/NSR používají formát Existing Session (formát existující relace). Zprávy ES se používají obousměrně jak Alicí, tak Bobem.\nCelková délka: 8 + payload_length + 16 bajtů (minimálně 24 bajtů)\nFormát:\n+----+----+----+----+----+----+----+----+ | Session Tag 8 bytes | +----+----+----+----+----+----+----+----+ | | + Payload Section + | ChaCha20 encrypted data | ~ Variable length ~ | | + + | | +----+----+----+----+----+----+----+----+ | Poly1305 Message Authentication Code | + (MAC) + | 16 bytes | +----+----+----+----+----+----+----+----+ Podrobnosti pole:\nZnačka relace (8 bajtů, v otevřené podobě): - Vygenerována z aktuální odchozí sady značek - Identifikuje relaci a číslo zprávy - Příjemce vyhledá značku, aby našel klíč relace a nonce (jednorázové číslo) - Jednorázové použití (každá značka je použita právě jednou) - Formát: Prvních 8 bajtů výstupu HKDF\nSekce užitečných dat (proměnlivé délky): - Obsahuje garlic cloves (části zprávy v rámci garlic encryption) a bloky - Nejsou žádné povinné bloky (může být prázdná) - Běžné bloky: Garlic Clove, NextKey, ACK, ACK Request, Padding - Maximální velikost: 65519 bajtů (65535 - 16 bajtů MAC)\nMAC (16 bajtů): - Autentizační tag Poly1305 - Spočítán nad celou užitečnou zátěží - Asociovaná data: 8bajtový session tag (značka relace) - Musí být ověřen správně, jinak je zpráva odmítnuta\nProces vyhledávání tagů:\nPříjemce extrahuje 8bajtový tag Vyhledá tag ve všech aktuálních příchozích tagsetech (množinách tagů) Načte přiřazený session key (relační klíč) a číslo zprávy N Sestaví nonce: [0x00, 0x00, 0x00, 0x00, N (8 bytes little-endian)] Dešifruje payload pomocí AEAD s tagem jako přidruženými daty Odstraní tag z tagsetu (jednorázové použití) Zpracuje dešifrované bloky Značka relace nenalezena:\nPokud se tag (kryptografický identifikátor) nenajde v žádném tagsetu (množině tagů): - Může jít o zprávu NS → zkuste dešifrování NS - Může jít o zprávu NSR → zkuste dešifrování NSR - Může jít o ES doručené mimo pořadí → krátce vyčkejte na aktualizaci tagsetu - Může jít o útok opakovaným přehráním → odmítněte - Může jít o poškozená data → odmítněte\nPrázdná užitečná data:\nZprávy ES mohou mít prázdná užitečná data (0 bajtů): - Slouží jako explicitní ACK, když byl přijat ACK Request - Poskytuje odpověď na úrovni protokolu bez aplikačních dat - Přesto spotřebuje session tag (značka relace) - Užitečné, když vyšší vrstva nemá okamžitě co odeslat\nBezpečnostní vlastnosti: - Plné dopředné utajení (úroveň 5) po přijetí NSR - Autentizované šifrování pomocí AEAD - Tag (značka) slouží jako dodatečná asociovaná data - Maximálně 65535 zpráv na jeden tagset (sadu značek) než je vyžadován ratchet (mechanismus postupné výměny klíčů)\nFunkce pro odvozování klíčů Tato část dokumentuje všechny operace KDF (funkce odvození klíče) používané v ECIES (integrované šifrovací schéma na eliptických křivkách) a ukazuje úplná kryptografická odvození.\nNotace a konstanty Konstanty: - ZEROLEN - Bajtové pole nulové délky (prázdný řetězec) - || - Operátor konkatenace\nProměnné: - h - Průběžný hash přepisu (32 bajtů) - chainKey - Řetězící klíč pro HKDF (32 bajtů) - k - Klíč symetrické šifry (32 bajtů) - n - Nonce (jednorázová hodnota) / číslo zprávy\nKlíče: - ask / apk - statický soukromý/veřejný klíč Alice - aesk / aepk - efemérní soukromý/veřejný klíč Alice - bsk / bpk - statický soukromý/veřejný klíč Boba - besk / bepk - efemérní soukromý/veřejný klíč Boba\nFunkce odvození klíče (KDF) pro zprávy NS KDF 1: Počáteční řetězový klíč Provedeno jednou při inicializaci protokolu (lze předpočítat):\n# Protocol name (40 bytes, ASCII, no null termination) protocol_name = \u0026#34;Noise_IKelg2+hs2_25519_ChaChaPoly_SHA256\u0026#34; # Initialize hash h = SHA256(protocol_name) # Initialize chaining key chainKey = h # MixHash with empty prologue h = SHA256(h) # State: chainKey and h initialized # Can be precalculated for all outbound sessions Výsledek: - chainKey = Počáteční řetězící klíč pro všechny následující KDF (funkce odvození klíče) - h = Počáteční hash transkriptu\nKDF 2: Směšování Bobova statického klíče Bob to provede jednou (lze předpočítat pro všechny příchozí relace):\n# Bob\u0026#39;s static keys (published in LeaseSet) bsk = GENERATE_PRIVATE() bpk = DERIVE_PUBLIC(bsk) # Mix Bob\u0026#39;s public key into hash h = SHA256(h || bpk) # State: h updated with Bob\u0026#39;s identity # Can be precalculated by Bob for all inbound sessions KDF 3: Generování Aličina efemérního klíče Alice generuje nové klíče pro každou zprávu NS:\n# Generate ephemeral key pair suitable for Elligator2 aesk = GENERATE_PRIVATE_ELG2() aepk = DERIVE_PUBLIC(aesk) # Mix ephemeral public key into hash h = SHA256(h || aepk) # Elligator2 encode for transmission elg2_aepk = ENCODE_ELG2(aepk) # State: h updated with Alice\u0026#39;s ephemeral key # Send elg2_aepk as first 32 bytes of NS message KDF (funkce pro odvozování klíčů) 4: NS sekce statického klíče (es DH) Odvozuje klíče pro šifrování Aličina statického klíče:\n# Perform first DH (ephemeral-static) sharedSecret = DH(aesk, bpk) # Alice computes # Equivalent: sharedSecret = DH(bsk, aepk) # Bob computes # Derive cipher key from shared secret keydata = HKDF(chainKey, sharedSecret, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k = keydata[32:63] # AEAD encryption parameters nonce = 0 associated_data = h # Current hash transcript # Encrypt static key section if binding_requested: plaintext = apk # Alice\u0026#39;s static public key (32 bytes) else: plaintext = bytes(32) # All zeros for unbound ciphertext = ENCRYPT(k, nonce, plaintext, associated_data) # ciphertext = 32 bytes encrypted + 16 bytes MAC = 48 bytes # Mix ciphertext into hash h = SHA256(h || ciphertext) # State: Static key section encrypted, h updated # Send ciphertext (48 bytes) as next part of NS message KDF 5: Sekce užitečných dat NS (ss DH, pouze vázané) Pro vázané relace proveďte druhou výměnu DH (Diffie‑Hellmanova výměna klíčů) pro šifrování užitečných dat:\nif binding_requested: # Alice\u0026#39;s static keys ask = GENERATE_PRIVATE() # Alice\u0026#39;s long-term key apk = DERIVE_PUBLIC(ask) # Perform second DH (static-static) sharedSecret = DH(ask, bpk) # Alice computes # Equivalent: sharedSecret = DH(bsk, apk) # Bob computes # Derive cipher key keydata = HKDF(chainKey, sharedSecret, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k = keydata[32:63] nonce = 0 associated_data = h else: # Unbound: reuse keys from static key section # chainKey and k unchanged nonce = 1 # Increment nonce (reusing same key) associated_data = h # Encrypt payload payload = build_payload() # DateTime + Garlic Cloves + etc. ciphertext = ENCRYPT(k, nonce, payload, associated_data) # Mix ciphertext into hash h = SHA256(h || ciphertext) # State: Payload encrypted, h contains complete NS transcript # Save chainKey and h for NSR processing # Send ciphertext as final part of NS message Důležité poznámky:\nVázané vs Nevázané:\nVázané provádí 2 operace DH (es + ss) Nevázané provádí 1 operaci DH (jen es) Nevázané inkrementuje nonce (jednorázová hodnota) místo odvození nového klíče Bezpečnost proti znovupoužití klíče:\nRůzné nonces (jednorázové hodnoty) (0 vs 1) zabraňují znovupoužití klíče/nonce Odlišná přidružená data (h se liší) zajišťují oddělení domén Hash transkript:\nh nyní obsahuje: protocol_name, prázdný prolog, bpk, aepk, static_key_ciphertext, payload_ciphertext Tento transkript provazuje všechny části zprávy NS dohromady KDF sady odpovědních tagů NSR Bob generuje tagy pro zprávy NSR:\n# Chain key from NS payload section # chainKey = final chainKey from NS KDF # Generate tagset key tagsetKey = HKDF(chainKey, ZEROLEN, \u0026#34;SessionReplyTags\u0026#34;, 32) # Initialize NSR tagset (see DH_INITIALIZE below) tagset_nsr = DH_INITIALIZE(chainKey, tagsetKey) # Get tag for this NSR tagsetEntry = tagset_nsr.GET_NEXT_ENTRY() tag = tagsetEntry.SESSION_TAG # 8 bytes # State: tag available for NSR message # Send tag as first 8 bytes of NSR Funkce odvození klíčů pro zprávy NSR KDF 6: Generování efemérního klíče NSR Bob generuje nový efemérní klíč pro každý NSR:\n# Mix tag into hash (I2P extension to Noise) h = SHA256(h || tag) # Generate ephemeral key pair besk = GENERATE_PRIVATE_ELG2() bepk = DERIVE_PUBLIC(besk) # Mix ephemeral public key into hash h = SHA256(h || bepk) # Elligator2 encode for transmission elg2_bepk = ENCODE_ELG2(bepk) # State: h updated with tag and Bob\u0026#39;s ephemeral key # Send elg2_bepk as bytes 9-40 of NSR message KDF 7: Sekce klíče NSR (ee a se DH) Odvozuje klíče pro sekci klíčů NSR:\n# Perform third DH (ephemeral-ephemeral) sharedSecret_ee = DH(aesk, bepk) # Alice computes # Equivalent: sharedSecret_ee = DH(besk, aepk) # Bob computes # Mix ee into chain keydata = HKDF(chainKey, sharedSecret_ee, \u0026#34;\u0026#34;, 32) chainKey = keydata[0:31] # Perform fourth DH (static-ephemeral) sharedSecret_se = DH(ask, bepk) # Alice computes # Equivalent: sharedSecret_se = DH(besk, apk) # Bob computes # Derive cipher key from se keydata = HKDF(chainKey, sharedSecret_se, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k = keydata[32:63] # AEAD encryption of empty data (key section has no payload) nonce = 0 associated_data = h ciphertext = ENCRYPT(k, nonce, ZEROLEN, associated_data) # ciphertext = 16 bytes (MAC only, no plaintext) # Mix ciphertext into hash h = SHA256(h || ciphertext) # State: Key section encrypted, chainKey contains all 4 DH results # Send ciphertext (16 bytes MAC) as bytes 41-56 of NSR Kritické: Tím je dokončen handshake protokolu Noise IK. chainKey nyní obsahuje příspěvky ze všech čtyř operací DH (Diffie–Hellman) (es, ss, ee, se).\nKDF (funkce odvození klíče) 8: Sekce užitečných dat NSR Odvozuje klíče pro šifrování datové části NSR:\n# Split chainKey into bidirectional keys keydata = HKDF(chainKey, ZEROLEN, \u0026#34;\u0026#34;, 64) k_ab = keydata[0:31] # Alice → Bob key k_ba = keydata[32:63] # Bob → Alice key # Initialize ES tagsets for both directions tagset_ab = DH_INITIALIZE(chainKey, k_ab) # Alice → Bob tagset_ba = DH_INITIALIZE(chainKey, k_ba) # Bob → Alice # Derive NSR payload key (Bob → Alice) k_nsr = HKDF(k_ba, ZEROLEN, \u0026#34;AttachPayloadKDF\u0026#34;, 32) # Encrypt NSR payload nonce = 0 associated_data = h # Binds payload to entire NSR payload = build_payload() # Usually application reply ciphertext = ENCRYPT(k_nsr, nonce, payload, associated_data) # State: Bidirectional ES sessions established # tagset_ab and tagset_ba ready for ES messages # Send ciphertext as bytes 57+ of NSR message Důležité poznámky:\nSplit Operation (operace rozdělení):\nVytváří nezávislé klíče pro každý směr Zabraňuje znovupoužití klíčů mezi Alice→Bob a Bob→Alice Vazba payloadu NSR:\nPoužívá h jako přidružená data k svázání payloadu s handshake Samostatná KDF (funkce pro odvozování klíčů) (\u0026ldquo;AttachPayloadKDF\u0026rdquo;) zajišťuje oddělení domén Připravenost ES:\nPo NSR mohou obě strany posílat zprávy ES Alice musí před odesláním ES obdržet NSR Bob musí před odesláním ES obdržet ES KDF (funkce odvození klíče) pro zprávy ES Zprávy ES používají předem vygenerované relační klíče z tagsetů:\n# Sender gets next tag and key tagsetEntry = outbound_tagset.GET_NEXT_ENTRY() tag = tagsetEntry.SESSION_TAG # 8 bytes k = tagsetEntry.SESSION_KEY # 32 bytes N = tagsetEntry.INDEX # Message number # Construct nonce (12 bytes) nonce = [0x00, 0x00, 0x00, 0x00] + little_endian_8_bytes(N) # AEAD encryption associated_data = tag # Tag is associated data payload = build_payload() ciphertext = ENCRYPT(k, nonce, payload, associated_data) # Send: tag || ciphertext (8 + len(ciphertext) bytes) Proces příjemce:\n# Extract tag tag = message[0:8] # Look up tag in inbound tagsets tagsetEntry = inbound_tagset.GET_SESSION_KEY(tag) if tagsetEntry is None: # Not an ES message, try NS/NSR decryption return try_handshake_decryption(message) k = tagsetEntry.SESSION_KEY N = tagsetEntry.INDEX # Construct nonce nonce = [0x00, 0x00, 0x00, 0x00] + little_endian_8_bytes(N) # AEAD decryption associated_data = tag ciphertext = message[8:] try: payload = DECRYPT(k, nonce, ciphertext, associated_data) except AuthenticationError: # MAC verification failed, reject message return reject_message() # Process payload blocks process_payload(payload) # Remove tag from tagset (one-time use) inbound_tagset.remove(tag) Funkce DH_INITIALIZE Vytvoří sadu tagů pro jeden směr:\ndef DH_INITIALIZE(rootKey, k): \u0026#34;\u0026#34;\u0026#34; Initializes a tagset with session tag and symmetric key ratchets. Args: rootKey: Chain key from previous DH ratchet (32 bytes) k: Key material from split() or DH ratchet (32 bytes) Returns: tagset: Initialized tagset object \u0026#34;\u0026#34;\u0026#34; # Derive next root key and chain key keydata = HKDF(rootKey, k, \u0026#34;KDFDHRatchetStep\u0026#34;, 64) nextRootKey = keydata[0:31] chainKey_tagset = keydata[32:63] # Derive separate chain keys for tags and keys keydata = HKDF(chainKey_tagset, ZEROLEN, \u0026#34;TagAndKeyGenKeys\u0026#34;, 64) sessTag_ck = keydata[0:31] # Session tag chain key symmKey_ck = keydata[32:63] # Symmetric key chain key # Create tagset object tagset = Tagset() tagset.nextRootKey = nextRootKey tagset.sessTag_chainKey = sessTag_ck tagset.symmKey_chainKey = symmKey_ck tagset.lastIndex = -1 return tagset Kontexty použití:\nNSR Tagset (množina tagů): DH_INITIALIZE(chainKey_from_NS, tagsetKey_NSR) ES Tagsets: DH_INITIALIZE(chainKey_from_NSR, k_ab or k_ba) Ratchetované Tagsets: DH_INITIALIZE(nextRootKey_from_previous, tagsetKey_from_DH) Ráčnové mechanismy ECIES používá tři synchronizované ratchet mechanisms (ráčnové mechanismy) k zajištění dopředného utajení a efektivní správy relací.\nPřehled ratchetu Tři typy ratchet (kryptografický ráčnový mechanismus):\nDH Ratchet (ráčnový mechanismus): Provádí výměny klíčů Diffie–Hellman za účelem generování nových kořenových klíčů Session Tag Ratchet: Deterministicky odvozuje jednorázové značky relace Symmetric Key Ratchet: Odvozuje relační klíče pro šifrování zpráv Vztah:\nDH Ratchet (periodic) ↓ Creates new tagset ↓ Session Tag Ratchet (per message) ← synchronized → Symmetric Key Ratchet (per message) ↓ ↓ Session Tags (8 bytes each) Session Keys (32 bytes each) Klíčové vlastnosti:\nOdesílatel: Generuje tagy a klíče podle potřeby (není potřeba nic ukládat) Příjemce: Předgeneruje tagy pro look-ahead window (okno dopředu) (vyžaduje ukládání) Synchronizace: Index tagu určuje index klíče (N_tag = N_key) Dopředné utajení: Dosahuje se prostřednictvím periodického DH ratchet (postupné periodické překlápění klíčů Diffie-Hellman) Efektivita: Příjemce může odložit výpočet klíče, dokud neobdrží tag DH Ratchet (mechanismus průběžné obnovy klíčů pomocí Diffie–Hellman) DH ratchet (mechanismus postupné obnovy klíčů Diffie‑Hellman) poskytuje dopředné utajení pravidelnou výměnou nových efemérních klíčů.\nFrekvence DH Ratchet (krokového mechanismu DH) Požadované podmínky pro ratchet (kryptografický krokovací mechanismus): - Sada tagů se blíží vyčerpání (maximum je tag 65535) - Zásady specifické pro implementaci: - Prahová hodnota počtu zpráv (např. každých 4096 zpráv) - Časová prahová hodnota (např. každých 10 minut) - Prahová hodnota objemu dat (např. každých 100 MB)\nDoporučený First Ratchet (počáteční krok kryptografického mechanismu ratchet): Kolem čísla tagu 4096, aby se zabránilo dosažení limitu\nMaximální hodnoty: - Maximální ID sady tagů: 65535 - Maximální ID klíče: 32767 - Maximální počet zpráv na sadu tagů: 65535 - Teoretické maximální množství dat na relaci: ~6,9 TB (64K sad tagů × 64K zpráv × 1730 bajtů průměrně)\nID tagů a klíčů pro DH Ratchet (ráčnový mechanismus DH) Počáteční sada tagů (po handshake (navázání spojení)): - ID sady tagů: 0 - Zatím nebyly odeslány žádné bloky NextKey - Nebyla přiřazena žádná ID klíčů\nPo prvním ratchetu (kryptografický mechanismus pro postupnou výměnu klíčů): - ID sady tagů: 1 = (1 + ID klíče Alice + ID klíče Boba) = (1 + 0 + 0) - Alice posílá zprávu NextKey s ID klíče 0 - Bob odpovídá zprávou NextKey s ID klíče 0\nNásledující sady tagů: - ID sady tagů = 1 + ID klíče odesílatele + ID klíče příjemce - Příklad: sada tagů 5 = (1 + sender_key_2 + receiver_key_2)\nTabulka vývoje sady tagů:\nTag Set ID Sender Key ID Receiver Key ID Notes 0 n/a n/a Initial tag set (post-NSR) 1 0 * 0 * First ratchet (both generate new keys) 2 1 * 0 Sender generates new key 3 1 1 * Receiver generates new key 4 2 * 1 Sender generates new key 5 2 2 * Receiver generates new key ... ... ... Pattern repeats 65534 32767 * 32766 Second-to-last tag set 65535 32767 32767 * Final tag set \\* = Nový klíč vygenerovaný v tomto ratchetu (mechanismus postupné výměny klíčů) Pravidla pro ID klíče: - ID jsou sekvenční a začínají od 0 - ID se zvyšují pouze při vytvoření nového klíče - Maximální ID klíče je 32767 (15 bitů) - Po ID klíče 32767 je vyžadována nová relace\nTok zpráv DH Ratchet (mechanismus postupného odvozování klíčů) Role: - Odesílatel tagů: Vlastní odchozí sadu tagů, odesílá zprávy - Příjemce tagů: Vlastní příchozí sadu tagů, přijímá zprávy\nVzor: Odesílatel tagů zahájí ratchet (mechanismus postupné obnovy klíčů), když je sada tagů téměř vyčerpána.\nDiagram toku zpráv:\nTag Sender Tag Receiver ... using tag set #0 ... (Tag set #0 approaching exhaustion) (Generate new key #0) NextKey forward, request reverse, with key #0 --------\u0026gt; (Repeat until NextKey ACK received) (Generate new key #0) (Perform DH: sender_key_0 × receiver_key_0) (Create inbound tag set #1) \u0026lt;--------------- NextKey reverse, with key #0 (Repeat until tag from tag set #1 received) (Receive NextKey with key #0) (Perform DH: sender_key_0 × receiver_key_0) (Create outbound tag set #1) ... using tag set #1 ... (Tag set #1 approaching exhaustion) (Generate new key #1) NextKey forward, with key #1 --------\u0026gt; (Repeat until NextKey ACK received) (Reuse existing key #0) (Perform DH: sender_key_1 × receiver_key_0) (Create inbound tag set #2) \u0026lt;-------------- NextKey reverse, id 0 (ACK) (Repeat until tag from tag set #2 received) (Receive NextKey with id 0) (Perform DH: sender_key_1 × receiver_key_0) (Create outbound tag set #2) ... using tag set #2 ... (Tag set #2 approaching exhaustion) (Reuse existing key #1) NextKey forward, request reverse, id 1 --------\u0026gt; (Repeat until NextKey received) (Generate new key #1) (Perform DH: sender_key_1 × receiver_key_1) (Create inbound tag set #3) \u0026lt;-------------- NextKey reverse, with key #1 (Receive NextKey with key #1) (Perform DH: sender_key_1 × receiver_key_1) (Create outbound tag set #3) ... using tag set #3 ... (Pattern repeats: even-numbered tag sets use forward key, odd-numbered use reverse key) Vzory pro Ratchet (ráčnový mechanismus):\nVytváření sudě číslovaných sad tagů (2, 4, 6, \u0026hellip;): 1. Odesílatel vygeneruje nový klíč 2. Odesílatel pošle NextKey block s novým klíčem 3. Příjemce pošle NextKey block s ID starého klíče (ACK) 4. Oba provedou DH s (novým klíčem odesílatele × starým klíčem příjemce)\nVytváření lichě číslovaných sad tagů (3, 5, 7, \u0026hellip;): 1. Odesílatel požádá o reverzní klíč (pošle NextKey s příznakem žádosti) 2. Příjemce vygeneruje nový klíč 3. Příjemce pošle blok NextKey s novým klíčem 4. Oba provedou DH (Diffie–Hellman) s (starý klíč odesílatele × nový klíč příjemce)\nFormát bloku NextKey Viz sekci Payload Format pro podrobnou specifikaci bloku NextKey.\nKlíčové prvky: - Bajt příznaků: - Bit 0: Klíč přítomen (1) nebo pouze ID (0) - Bit 1: Reverzní klíč (1) nebo dopředný klíč (0) - Bit 2: Požadavek na reverzní klíč (1) nebo bez požadavku (0) - ID klíče: 2 bajty, big-endian (0-32767) - Veřejný klíč: 32 bajtů X25519 (pokud bit 0 = 1)\nUkázkové NextKey Blocks (bloky NextKey):\n# Sender initiates ratchet with new key (key ID 0, tag set 1) NextKey(flags=0x01, key_id=0, pubkey=sender_key_0) # Receiver replies with new key (key ID 0, tag set 1) NextKey(flags=0x03, key_id=0, pubkey=receiver_key_0) # Sender ratchets again with new key (key ID 1, tag set 2) NextKey(flags=0x01, key_id=1, pubkey=sender_key_1) # Receiver ACKs with old key ID (tag set 2) NextKey(flags=0x02, key_id=0) # Sender requests reverse key (tag set 3) NextKey(flags=0x04, key_id=1) # Receiver sends new reverse key (key ID 1, tag set 3) NextKey(flags=0x03, key_id=1, pubkey=receiver_key_1) KDF pro DH ratchet (funkce odvozování klíče pro ráčnový mechanizmus Diffie–Hellmana) Když dojde k výměně nových klíčů:\n# Tag sender generates or reuses key if generating_new: sender_sk = GENERATE_PRIVATE() sender_pk = DERIVE_PUBLIC(sender_sk) else: # Reuse existing key pair sender_pk = existing_sender_pk # Tag receiver generates or reuses key if generating_new: receiver_sk = GENERATE_PRIVATE() receiver_pk = DERIVE_PUBLIC(receiver_sk) else: # Reuse existing key pair receiver_pk = existing_receiver_pk # Both parties perform DH sharedSecret = DH(sender_sk, receiver_pk) # Derive tagset key tagsetKey = HKDF(sharedSecret, ZEROLEN, \u0026#34;XDHRatchetTagSet\u0026#34;, 32) # Get next root key from previous tagset rootKey = previous_tagset.nextRootKey # Initialize new tagset new_tagset = DH_INITIALIZE(rootKey, tagsetKey) # Tag sender: outbound tagset # Tag receiver: inbound tagset Kritické načasování:\nOdesílatel tagů: - Okamžitě vytvoří novou odchozí sadu tagů - Okamžitě začne používat nové tagy - Odstraní starou odchozí sadu tagů\nPříjemce tagů: - Vytváří novou příchozí sadu tagů - Ponechá starou příchozí sadu tagů po dobu přechodné lhůty (3 minuty) - Během přechodné lhůty přijímá tagy z obou sad, staré i nové - Po uplynutí přechodné lhůty smaže starou příchozí sadu tagů\nSpráva stavu DH Ratchet (mechanismus postupné obnovy klíčů pomocí Diffie‑Hellman) Stav odesílatele: - Aktuální odchozí sada tagů - ID sady tagů a ID klíčů - Další kořenový klíč (pro další ratchet, ráčnový mechanismus) - Počet zpráv v aktuální sadě tagů\nStav příjemce: - Aktuální množiny příchozích tagů (během ochranné lhůty mohou být dvě) - Čísla předchozích zpráv (PN) pro detekci mezer - Dopředné okno předem vygenerovaných tagů - Další kořenový klíč (pro další ratchet, mechanismus postupného odvozování klíčů)\nPravidla přechodů stavů:\nPřed prvním Ratchet (mechanismus postupného obnovování klíčů):\nPoužití sady tagů 0 (z NSR) Nejsou přiřazena žádná ID klíčů Zahájení Ratchet (kryptografického ráčnového mechanismu):\nVygenerujte nový klíč (pokud v tomto kole generuje odesílatel) Odešlete blok NextKey v ES message Před vytvořením novou sadu odchozích tagů vyčkejte na odpověď NextKey Přijetí požadavku Ratchet (mechanismus postupné obnovy klíčů):\nVygenerujte nový klíč (pokud v tomto kole generuje klíč příjemce) Proveďte DH s přijatým klíčem Vytvořte novou sadu příchozích značek Odešlete odpověď NextKey Ponechte starou sadu příchozích značek po dobu odkladu Dokončení ratchetu (ráčnového mechanismu):\nPřijmout odpověď NextKey Provést DH Vytvořit novou sadu odchozích tagů Začít používat nové tagy Rohatkový mechanismus značek relace Mechanismus session tag ratchet (kryptografický mechanismus pro štítky relace) deterministicky generuje jednorázové 8bajtové session tags.\nÚčel Session Tag Ratchet (mechanismus postupné změny tagů relace) Nahrazuje explicitní přenos tagů (ElGamal posílal 32bajtové tagy) Umožňuje příjemci předgenerovat tagy pro okno dopředného náhledu Odesílatel je generuje na vyžádání (není třeba je ukládat) Synchronizuje se se symmetric key ratchet (schéma postupného odvozování klíčů se symetrickým klíčem) prostřednictvím indexu Vzorec ráčnového mechanismu značky relace Inicializace:\n# From DH_INITIALIZE sessTag_ck = initial_chain_key # 32 bytes # Initialize session tag ratchet keydata = HKDF(sessTag_ck, ZEROLEN, \u0026#34;STInitialization\u0026#34;, 64) sessTag_chainKey = keydata[0:31] # First chain key SESSTAG_CONSTANT = keydata[32:63] # Constant for all tags in this tagset Generování značky (pro značku N):\n# Generate tag N keydata = HKDF(sessTag_chainKey_(N-1), SESSTAG_CONSTANT, \u0026#34;SessionTagKeyGen\u0026#34;, 64) sessTag_chainKey_N = keydata[0:31] # Chain key for next tag tag_N = keydata[32:39] # Session tag (8 bytes) # Chain continues for each tag # tag_0, tag_1, tag_2, ..., tag_65535 Kompletní sekvence:\n# Tag 0 keydata_0 = HKDF(sessTag_chainKey, SESSTAG_CONSTANT, \u0026#34;SessionTagKeyGen\u0026#34;, 64) sessTag_chainKey_0 = keydata_0[0:31] tag_0 = keydata_0[32:39] # Tag 1 keydata_1 = HKDF(sessTag_chainKey_0, SESSTAG_CONSTANT, \u0026#34;SessionTagKeyGen\u0026#34;, 64) sessTag_chainKey_1 = keydata_1[0:31] tag_1 = keydata_1[32:39] # Tag N keydata_N = HKDF(sessTag_chainKey_(N-1), SESSTAG_CONSTANT, \u0026#34;SessionTagKeyGen\u0026#34;, 64) sessTag_chainKey_N = keydata_N[0:31] tag_N = keydata_N[32:39] Implementace odesílatele pro ráčnový mechanismus Session Tag class OutboundTagset: def __init__(self, sessTag_ck): # Initialize keydata = HKDF(sessTag_ck, ZEROLEN, \u0026#34;STInitialization\u0026#34;, 64) self.chainKey = keydata[0:31] self.constant = keydata[32:63] self.index = -1 def get_next_tag(self): # Increment index self.index += 1 if self.index \u0026gt; 65535: raise TagsetExhausted(\u0026#34;Ratchet required\u0026#34;) # Generate tag keydata = HKDF(self.chainKey, self.constant, \u0026#34;SessionTagKeyGen\u0026#34;, 64) self.chainKey = keydata[0:31] tag = keydata[32:39] return (tag, self.index) Proces odesílatele: 1. Zavolejte get_next_tag() pro každou zprávu 2. Použijte vrácený tag (značka) v ES message (zpráva ES) 3. Uložte index N pro případné sledování ACK (potvrzení přijetí) 4. Není vyžadováno ukládání tagů (generují se podle potřeby)\nImplementace příjemce Session Tag Ratchet (ráčnový mechanismus pro značky relace) class InboundTagset: def __init__(self, sessTag_ck, look_ahead=32): # Initialize keydata = HKDF(sessTag_ck, ZEROLEN, \u0026#34;STInitialization\u0026#34;, 64) self.chainKey = keydata[0:31] self.constant = keydata[32:63] self.index = -1 self.look_ahead = look_ahead self.tags = {} # Dictionary: tag -\u0026gt; index # Pre-generate initial tags self.extend(look_ahead) def extend(self, count): \u0026#34;\u0026#34;\u0026#34;Generate \u0026#39;count\u0026#39; more tags\u0026#34;\u0026#34;\u0026#34; for _ in range(count): self.index += 1 if self.index \u0026gt; 65535: return # Cannot exceed maximum # Generate tag keydata = HKDF(self.chainKey, self.constant, \u0026#34;SessionTagKeyGen\u0026#34;, 64) self.chainKey = keydata[0:31] tag = keydata[32:39] # Store tag self.tags[tag] = self.index def lookup_tag(self, tag): \u0026#34;\u0026#34;\u0026#34;Look up tag and return index\u0026#34;\u0026#34;\u0026#34; if tag in self.tags: index = self.tags[tag] # Remove tag (one-time use) del self.tags[tag] return index return None def check_and_extend(self): \u0026#34;\u0026#34;\u0026#34;Extend if tag count is low\u0026#34;\u0026#34;\u0026#34; current_count = len(self.tags) if current_count \u0026lt; self.look_ahead // 2: # Extend to restore window self.extend(self.look_ahead - current_count) Proces příjemce: 1. Předem vygenerujte tagy pro look-ahead window (dopředné okno) (např. 32 tagů) 2. Uložte tagy do hashovací tabulky nebo slovníku 3. Když dorazí zpráva, vyhledejte tag a získejte index N 4. Odstraňte tag z úložiště (jednorázové použití) 5. Rozšiřte okno, pokud počet tagů klesne pod prahovou hodnotu\nStrategie předzásobení Session Tag (značka relace) Účel: Najít rovnováhu mezi využitím paměti a zpracováním zpráv mimo pořadí\nDoporučené velikosti Look-Ahead (dopředný náhled):\nTagset Type Initial Size Maximum Size Notes NSR tagset 12 12 Short-lived ES tagset 0 24 160 Initial ES tagset ES tagset 1+ 160 160 Ratcheted tagsets **Adaptivní Look-Ahead (dopředný náhled):** # Dynamic look-ahead based on highest tag received look_ahead = min(tsmax, tsmin + N // 4) # Example: # tsmin = 24, tsmax = 160 # N = 0: look_ahead = min(160, 24 + 0/4) = 24 # N = 100: look_ahead = min(160, 24 + 100/4) = 49 # N = 500: look_ahead = min(160, 24 + 500/4) = 149 # N = 544: look_ahead = min(160, 24 + 544/4) = 160 Ořezat vzadu:\n# Trim tags far behind highest received trim_behind = look_ahead // 2 # If highest received tag is N=100, trim tags below N=50 Výpočet paměti:\n# Per tag: 8 bytes (tag) + 2 bytes (index) + overhead ≈ 16 bytes # Look-ahead of 160 tags ≈ 2.5 KB per inbound tagset # With multiple sessions: # 100 inbound sessions × 2.5 KB = 250 KB total Zpracování Session Tag (značky relace) mimo pořadí Scénář: Zprávy přicházejí mimo pořadí\nExpected: tag_5, tag_6, tag_7, tag_8 Received: tag_5, tag_7, tag_6, tag_8 Chování příjemce:\nPřijmout tag_5:\nVyhledat: nalezeno na indexu 5 Zpracovat zprávu Odstranit tag_5 Nejvyšší přijaté: 5 Přijmout tag_7 (mimo pořadí):\nVyhledat: nalezeno na indexu 7 Zpracovat zprávu Odstranit tag_7 Nejvyšší dosud přijaté: 7 Poznámka: tag_6 je stále v úložišti (dosud nepřijatý) Přijmout tag_6 (zpožděno):\nVyhledat: nalezeno na indexu 6 Zpracovat zprávu Odstranit tag_6 Nejvyšší přijaté: 7 (beze změny) Přijmout tag_8:\nVyhledat: nalezen na indexu 8 Zpracovat zprávu Odstranit tag_8 Nejvyšší přijaté: 8 Správa okna: - Sledovat nejvyšší přijatý index - Udržovat seznam chybějících indexů (mezery) - Rozšiřovat okno podle nejvyššího indexu - Volitelné: Po vypršení časového limitu odstranit staré mezery\nSymmetric Key Ratchet (symetrická ráčna) Symmetric key ratchet (mechanismus postupné obnovy klíčů) generuje 32bajtové šifrovací klíče synchronizované s tagy relace.\nÚčel Symmetric Key Ratchet (mechanismus postupné obměny symetrických klíčů) Poskytuje jedinečný šifrovací klíč pro každou zprávu Synchronizováno se session tag ratchet (krokovací mechanismus; stejný index) Odesílatel může generovat podle potřeby Příjemce může odložit generování, dokud neobdrží tag Vzorec pro Symmetric Key Ratchet (ráčnový mechanismus pro postupné odvozování symetrických klíčů) Inicializace:\n# From DH_INITIALIZE symmKey_ck = initial_chain_key # 32 bytes # No additional initialization needed # Unlike session tag ratchet, no constant is derived Generování klíče (pro klíč N):\n# Generate key N SYMMKEY_CONSTANT = ZEROLEN # Empty string keydata = HKDF(symmKey_chainKey_(N-1), SYMMKEY_CONSTANT, \u0026#34;SymmetricRatchet\u0026#34;, 64) symmKey_chainKey_N = keydata[0:31] # Chain key for next key key_N = keydata[32:63] # Session key (32 bytes) Kompletní sekvence:\n# Key 0 keydata_0 = HKDF(symmKey_ck, ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) symmKey_chainKey_0 = keydata_0[0:31] key_0 = keydata_0[32:63] # Key 1 keydata_1 = HKDF(symmKey_chainKey_0, ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) symmKey_chainKey_1 = keydata_1[0:31] key_1 = keydata_1[32:63] # Key N keydata_N = HKDF(symmKey_chainKey_(N-1), ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) symmKey_chainKey_N = keydata_N[0:31] key_N = keydata_N[32:63] Implementace odesílatele pro Symmetric Key Ratchet (symetrický ráčnový mechanismus) class OutboundKeyRatchet: def __init__(self, symmKey_ck): self.chainKey = symmKey_ck self.index = -1 def get_key(self, index): \u0026#34;\u0026#34;\u0026#34;Generate key for specific index\u0026#34;\u0026#34;\u0026#34; # Fast-forward to desired index if needed while self.index \u0026lt; index: self.index += 1 keydata = HKDF(self.chainKey, ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) self.chainKey = keydata[0:31] if self.index == index: return keydata[32:63] # Should not reach here if called correctly raise ValueError(\u0026#34;Key already generated\u0026#34;) Proces odesílatele: 1. Získat další značku a její index N 2. Vygenerovat klíč pro index N 3. Použít klíč k zašifrování zprávy 4. Není vyžadováno žádné ukládání klíče\nImplementace příjemce pro Symmetric Key Ratchet (ráčna se symetrickým klíčem) Strategie 1: Odložené generování (doporučeno)\nclass InboundKeyRatchet: def __init__(self, symmKey_ck): self.chainKey = symmKey_ck self.index = -1 self.cache = {} # Optional: cache recently used keys def get_key(self, index): \u0026#34;\u0026#34;\u0026#34;Generate key for specific index\u0026#34;\u0026#34;\u0026#34; # Check cache first (optional optimization) if index in self.cache: key = self.cache[index] del self.cache[index] return key # Fast-forward to desired index while self.index \u0026lt; index: self.index += 1 keydata = HKDF(self.chainKey, ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) self.chainKey = keydata[0:31] if self.index == index: return keydata[32:63] raise ValueError(\u0026#34;Index already passed\u0026#34;) Proces odložené generace: 1. Přijmout ES zprávu se značkou 2. Vyhledat značku a získat index N 3. Vygenerovat klíče 0 až N (pokud již nebyly vygenerovány) 4. Použít klíč N k dešifrování zprávy 5. Řetězový klíč je nyní umístěn na indexu N\nVýhody: - Minimální využití paměti - Klíče se generují pouze když jsou potřeba - Jednoduchá implementace\nNevýhody: - Při prvním použití je nutné vygenerovat všechny klíče od 0 do N - Nemůže zpracovat zprávy mimo pořadí bez ukládání do mezipaměti\nStrategie 2: Předgenerování s Tag Window (okno značek) (Alternativa)\nclass InboundKeyRatchet: def __init__(self, symmKey_ck): self.chainKey = symmKey_ck self.index = -1 self.keys = {} # Dictionary: index -\u0026gt; key def extend(self, count): \u0026#34;\u0026#34;\u0026#34;Pre-generate \u0026#39;count\u0026#39; more keys\u0026#34;\u0026#34;\u0026#34; for _ in range(count): self.index += 1 keydata = HKDF(self.chainKey, ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) self.chainKey = keydata[0:31] key = keydata[32:63] self.keys[self.index] = key def get_key(self, index): \u0026#34;\u0026#34;\u0026#34;Retrieve pre-generated key\u0026#34;\u0026#34;\u0026#34; if index in self.keys: key = self.keys[index] del self.keys[index] return key return None Proces předgenerování: 1. Předgenerujte klíče odpovídající oknu značek (např. 32 klíčů) 2. Uložte klíče indexované podle čísla zprávy 3. Po přijetí značky vyhledejte odpovídající klíč 4. Rozšiřujte okno, jak se značky používají\nVýhody: - Přirozeně zvládá zprávy doručené mimo pořadí - Rychlé získání klíče (bez zpoždění způsobeného generováním)\nNevýhody: - Vyšší spotřeba paměti (32 bajtů na klíč vs 8 bajtů na tag) - Je nutné udržovat klíče synchronizované s tagy\nPorovnání paměti:\n# Look-ahead of 160: # Tags only: 160 × 16 bytes = 2.5 KB # Tags+Keys: 160 × (16 + 32) bytes = 7.5 KB # # For 100 sessions: # Tags only: 250 KB # Tags+Keys: 750 KB Synchronizace Symmetric Ratchet (symetrické ráčnování) pomocí Session Tags (značky relace) Kritický požadavek: Index značky relace MUSÍ být roven indexu symetrického klíče\n# Sender tag, index = outbound_tagset.get_next_tag() key = outbound_keyratchet.get_key(index) # Same index nonce = construct_nonce(index) ciphertext = ENCRYPT(key, nonce, payload, tag) # Receiver index = inbound_tagset.lookup_tag(tag) key = inbound_keyratchet.get_key(index) # Same index nonce = construct_nonce(index) plaintext = DECRYPT(key, nonce, ciphertext, tag) Režimy selhání:\nPokud se synchronizace přeruší: - Pro dešifrování použit nesprávný klíč - Ověření MAC selže - Zpráva odmítnuta\nPrevence: - Vždy používejte stejný index pro značku a klíč - Nikdy nevynechávejte indexy v žádném ratchet (kryptografický mechanismus postupného posunu) - Zpracovávejte zprávy doručené mimo pořadí opatrně\nKonstrukce nonce pro symetrický ratchet (mechanismus postupného odvozování klíčů) Nonce (jednorázová hodnota) je odvozena z pořadového čísla zprávy:\ndef construct_nonce(index): \u0026#34;\u0026#34;\u0026#34; Construct 12-byte nonce for ChaCha20-Poly1305 Args: index: Message number (0-65535) Returns: nonce: 12-byte nonce \u0026#34;\u0026#34;\u0026#34; # First 4 bytes are always zero nonce = bytearray(12) nonce[0:4] = b\u0026#39;\\x00\\x00\\x00\\x00\u0026#39; # Last 8 bytes are little-endian message number nonce[4:12] = index.to_bytes(8, byteorder=\u0026#39;little\u0026#39;) return bytes(nonce) Příklady:\nindex = 0: nonce = 0x00000000 0000000000000000 index = 1: nonce = 0x00000000 0100000000000000 index = 255: nonce = 0x00000000 FF00000000000000 index = 256: nonce = 0x00000000 0001000000000000 index = 65535: nonce = 0x00000000 FFFF000000000000 Důležité vlastnosti: - Nonce (jednorázová náhodná hodnota) jsou jedinečné pro každou zprávu v tagsetu (množina tagů) - Nonce se nikdy neopakují (one-time-use tagy to zajišťují) - 8bajtový čítač umožňuje 2^64 zpráv (my používáme jen 2^16) - Formát nonce odpovídá konstrukci založené na čítači podle RFC 7539\nSpráva relací Kontext relace Všechny příchozí a odchozí relace musí patřit do konkrétního kontextu:\nKontext routeru: Relace pro samotný router Kontext destinace: Relace pro konkrétní místní destinaci (klientská aplikace) Kritické pravidlo: Relace se NESMÍ sdílet napříč kontexty, aby se zabránilo korelačním útokům.\nImplementace:\nclass SessionKeyManager: \u0026#34;\u0026#34;\u0026#34;Context for managing sessions (router or destination)\u0026#34;\u0026#34;\u0026#34; def __init__(self, context_id): self.context_id = context_id self.inbound_sessions = {} # far_end_dest -\u0026gt; [sessions] self.outbound_sessions = {} # far_end_dest -\u0026gt; session self.static_keypair = generate_keypair() # Context\u0026#39;s identity def get_outbound_session(self, destination): \u0026#34;\u0026#34;\u0026#34;Get or create outbound session to destination\u0026#34;\u0026#34;\u0026#34; if destination not in self.outbound_sessions: self.outbound_sessions[destination] = create_outbound_session(destination) return self.outbound_sessions[destination] def add_inbound_session(self, session, destination=None): \u0026#34;\u0026#34;\u0026#34;Add inbound session, optionally bound to destination\u0026#34;\u0026#34;\u0026#34; if destination: if destination not in self.inbound_sessions: self.inbound_sessions[destination] = [] self.inbound_sessions[destination].append(session) else: # Unbound session self.inbound_sessions[None].append(session) Implementace I2P v Javě:\nV Java I2P třída SessionKeyManager poskytuje tuto funkcionalitu: - Jeden SessionKeyManager pro každý router - Jeden SessionKeyManager pro každou lokální destinaci - Oddělená správa relací ECIES a ElGamal v rámci každého kontextu\nVazba relace Vazba spojuje relaci s konkrétním cílem na vzdálené straně.\nVázané relace Vlastnosti: - Zahrnuje statický klíč odesílatele ve zprávě NS - Příjemce může identifikovat destinaci odesílatele - Umožňuje obousměrnou komunikaci - Jedna odchozí relace pro každou destinaci - Může mít více příchozích relací (během přechodů)\nPřípady použití: - Streamová spojení (podobná TCP) - Datagramy s možností odpovědi - Jakýkoli protokol vyžadující režim požadavek/odpověď\nProces vázání:\n# Alice creates bound outbound session outbound_session = OutboundSession( destination=bob_destination, static_key=alice_static_key, bound=True ) # Alice sends NS with static key ns_message = build_ns_message( ephemeral_key=alice_ephemeral_key, static_key=alice_static_key, # Included for binding payload=data ) # Bob receives NS bob_receives_ns(ns_message) # Bob extracts Alice\u0026#39;s static key alice_static_key = decrypt_static_key_section(ns_message) # Bob looks up Alice\u0026#39;s destination (from bundled LeaseSet) alice_destination = lookup_destination_by_static_key(alice_static_key) # Bob creates bound inbound session inbound_session = InboundSession( destination=alice_destination, bound=True ) # Bob pairs with outbound session outbound_session = OutboundSession( destination=alice_destination, bound=True ) Výhody: 1. Ephemeral-Ephemeral DH (dočasný-dočasný Diffie-Hellman): Odpověď používá ee DH (plná dopředná důvěrnost) 2. Kontinuita relace: Ratchets (mechanismus postupného klíčování) udržují vazbu na stejnou destination (cílová identita v I2P) 3. Zabezpečení: Zabraňuje únosu relace (autentizace statickým klíčem) 4. Efektivita: Jedna relace na destination (bez duplikace)\nNevázané relace Vlastnosti: - V NS message (zpráva typu NS) není žádný statický klíč (sekce příznaků obsahuje samé nuly) - Příjemce nemůže identifikovat odesílatele - Pouze jednosměrná komunikace - Je povoleno více relací ke stejnému cíli\nPřípady použití: - Surové datagramy (odešli a zapomeň) - Anonymní publikování - Zasílání zpráv ve stylu broadcastu\nVlastnosti: - Anonymnější (bez identifikace odesílatele) - Efektivnější (1 DH vs 2 DH při navázání spojení) - Odpovědi nejsou možné (příjemce neví, kam odpovědět) - Žádné session ratcheting (postupné obměňování klíčů) (jednorázové nebo omezené použití)\nPárování relací Spárování propojuje příchozí relaci s odchozí relací pro obousměrnou komunikaci.\nVytváření spárovaných relací Pohled Alice (iniciátor):\n# Create outbound session to Bob outbound_session = create_outbound_session(bob_destination) # Create paired inbound session inbound_session = create_inbound_session( paired_with=outbound_session, bound_to=bob_destination ) # Link them outbound_session.paired_inbound = inbound_session inbound_session.paired_outbound = outbound_session # Send NS message send_ns_message(outbound_session, payload) Bobova perspektiva (respondent):\n# Receive NS message ns_message = receive_ns_message() # Create inbound session inbound_session = create_inbound_session_from_ns(ns_message) # If NS contains static key (bound): if ns_message.has_static_key(): alice_destination = extract_destination(ns_message) inbound_session.bind_to(alice_destination) # Create paired outbound session outbound_session = create_outbound_session(alice_destination) # Link them outbound_session.paired_inbound = inbound_session inbound_session.paired_outbound = outbound_session # Send NSR send_nsr_message(inbound_session, outbound_session, payload) Výhody párování relací In-band ACKs: Mohou potvrzovat zprávy bez samostatného clove (části zprávy v garlic encryption) Efektivní ratcheting (kryptografický mechanismus postupného posunu klíčů): Oba směry se posouvají společně Řízení toku: Lze implementovat zpětný tlak napříč párovanými relacemi Konzistence stavu: Snazší udržovat synchronizovaný stav Pravidla spárování relací Odchozí relace může být nespárovaná (unbound NS) Příchozí relace pro bound NS by měla být spárovaná Párování probíhá při vytváření relace, ne až poté Spárované relace mají stejnou vazbu na destinaci Ratchets (kryptografický ráčnový mechanismus) probíhají nezávisle, ale jsou koordinované Životní cyklus relace Životní cyklus relace: fáze vytvoření Navázání odchozí relace (Alice):\ndef create_outbound_session(destination, bound=True): session = OutboundSession() session.destination = destination session.bound = bound session.state = SessionState.NEW session.created_time = now() # Generate keys for NS message session.ephemeral_keypair = generate_elg2_keypair() if bound: session.static_key = context.static_keypair.public_key # Will be populated after NSR received session.outbound_tagset = None session.inbound_tagset = None return session Vytváření příchozí relace (Bob):\ndef create_inbound_session_from_ns(ns_message): session = InboundSession() session.state = SessionState.ESTABLISHED session.created_time = now() # Extract from NS session.remote_ephemeral_key = ns_message.ephemeral_key session.remote_static_key = ns_message.static_key if session.remote_static_key: session.bound = True session.destination = lookup_destination(session.remote_static_key) else: session.bound = False session.destination = None # Generate keys for NSR session.ephemeral_keypair = generate_elg2_keypair() # Create tagsets from KDF session.inbound_tagset = create_tagset_from_nsr() session.outbound_tagset = create_tagset_from_nsr() return session Životní cyklus relace: Aktivní fáze Přechody stavů:\nNEW (outbound only) ↓ NS sent ↓ PENDING_REPLY (outbound only) ↓ NSR received ↓ ESTABLISHED ↓ ES messages exchanged ↓ ESTABLISHED (ongoing) ↓ (optional) RATCHETING ↓ ESTABLISHED Údržba aktivní relace:\ndef maintain_active_session(session): # Update last activity time session.last_activity = now() # Check for ratchet needed if session.outbound_tagset.needs_ratchet(): initiate_ratchet(session) # Check for incoming ratchet if received_nextkey_block(): process_ratchet(session) # Trim old tags from inbound tagset session.inbound_tagset.expire_old_tags() # Check session health if session.idle_time() \u0026gt; SESSION_TIMEOUT: mark_session_idle(session) Životní cyklus relace: fáze vypršení platnosti Hodnoty časového limitu relace:\nSession Type Sender Timeout Receiver Timeout Notes NSR tagset N/A 3 minutes Short-lived ES tagset 0 8 minutes 10 minutes Initial ES tagset 1+ 8 minutes 10 minutes Ratcheted Old tagset N/A 3 minutes After ratchet **Logika vypršení platnosti:** def check_session_expiration(): for session in active_sessions: # Outbound session expiration (sender) if session.is_outbound(): if session.idle_time() \u0026gt; 8 * 60: # 8 minutes expire_outbound_session(session) # Inbound session expiration (receiver) else: if session.idle_time() \u0026gt; 10 * 60: # 10 minutes expire_inbound_session(session) # Old tagsets (after ratchet) for tagset in old_tagsets: if tagset.age() \u0026gt; 3 * 60: # 3 minutes delete_tagset(tagset) Kritické pravidlo: Odchozí relace MUSÍ vypršet dříve než příchozí relace, aby se zabránilo desynchronizaci.\nKorektní ukončení:\ndef terminate_session(session, reason=0): # Send Termination block (if implemented) send_termination_block(session, reason) # Mark session for deletion session.state = SessionState.TERMINATED # Keep session briefly for final messages schedule_deletion(session, delay=30) # 30 seconds # Notify paired session if session.paired_session: session.paired_session.mark_remote_terminated() Více NS zpráv Scénář: Ztratí se zpráva NS od Alice nebo se ztratí odpověď NSR.\nChování Alice:\nclass OutboundSession: def __init__(self): self.ns_messages_sent = [] self.ns_timer = None self.max_ns_attempts = 5 def send_ns_message(self, payload): # Generate new ephemeral key for each NS ephemeral_key = generate_elg2_keypair() ns_message = build_ns_message( ephemeral_key=ephemeral_key, static_key=self.static_key, payload=payload ) # Store state for this NS ns_state = { \u0026#39;ephemeral_key\u0026#39;: ephemeral_key, \u0026#39;chainkey\u0026#39;: compute_chainkey(ns_message), \u0026#39;hash\u0026#39;: compute_hash(ns_message), \u0026#39;tagset\u0026#39;: derive_nsr_tagset(ns_message), \u0026#39;sent_time\u0026#39;: now() } self.ns_messages_sent.append(ns_state) # Send message send_message(ns_message) # Set timer for retry if not self.ns_timer: self.ns_timer = set_timer(1.0, self.on_ns_timeout) def on_ns_timeout(self): if len(self.ns_messages_sent) \u0026gt;= self.max_ns_attempts: # Give up fail_session(\u0026#34;No NSR received after {self.max_ns_attempts} attempts\u0026#34;) return # Retry with new NS message send_ns_message(self.payload) def on_nsr_received(self, nsr_message): # Cancel timer cancel_timer(self.ns_timer) # Find which NS this NSR responds to tag = nsr_message.tag for ns_state in self.ns_messages_sent: if tag in ns_state[\u0026#39;tagset\u0026#39;]: # This NSR corresponds to this NS self.active_ns_state = ns_state break # Process NSR and complete handshake complete_handshake(nsr_message, self.active_ns_state) # Discard other NS states self.ns_messages_sent = [] Důležité vlastnosti:\nJedinečné efemérní klíče: Každý NS používá odlišný efemérní klíč Nezávislé handshake (navázání spojení): Každý NS vytváří samostatný stav handshake Korelace NSR: Tag NSR identifikuje, na které NS odpovídá Vyčištění stavů: Nepoužité stavy NS jsou po úspěšném NSR zahozeny Prevence útoků:\nAby se předešlo vyčerpání prostředků:\n# Limit NS sending rate max_ns_rate = 5 per 10 seconds per destination # Limit total NS attempts max_ns_attempts = 5 # Limit total pending NS states max_pending_ns = 10 per context Více zpráv NSR Scénář: Bob posílá více NSR (např. data odpovědi rozdělená do více zpráv).\nBobovo chování:\nclass InboundSession: def send_nsr_replies(self, payload_chunks): # One NS received, multiple NSRs to send for chunk in payload_chunks: # Generate new ephemeral key for each NSR ephemeral_key = generate_elg2_keypair() # Get next tag from NSR tagset tag = self.nsr_tagset.get_next_tag() nsr_message = build_nsr_message( tag=tag, ephemeral_key=ephemeral_key, payload=chunk ) send_message(nsr_message) # Wait for ES message from Alice self.state = SessionState.AWAITING_ES Chování Alice:\nclass OutboundSession: def on_nsr_received(self, nsr_message): if self.state == SessionState.PENDING_REPLY: # First NSR received complete_handshake(nsr_message) self.state = SessionState.ESTABLISHED # Create ES sessions self.es_outbound_tagset = derive_es_outbound_tagset() self.es_inbound_tagset = derive_es_inbound_tagset() # Send ES message (ACK) send_es_message(empty_payload) elif self.state == SessionState.ESTABLISHED: # Additional NSR received # Decrypt and process payload payload = decrypt_nsr_payload(nsr_message) process_payload(payload) # These NSRs are from other NS attempts, ignore handshake Bobovo vyčištění:\nclass InboundSession: def on_es_received(self, es_message): # First ES received from Alice # This confirms which NSR Alice used # Clean up other handshake states for other_ns_state in self.pending_ns_states: if other_ns_state != self.active_ns_state: delete_ns_state(other_ns_state) # Delete unused NSR tagsets for tagset in self.nsr_tagsets: if tagset != self.active_nsr_tagset: delete_tagset(tagset) self.state = SessionState.ESTABLISHED Důležité vlastnosti:\nVíce NSR je povoleno: Bob může poslat více NSR pro jeden NS Odlišné efemérní klíče: Každá NSR by měla použít jedinečný efemérní klíč Stejný tagset pro NSR: Všechny NSR pro jeden NS používají stejný tagset (sada tagů) První ES rozhoduje: První ES od Alice určuje, která NSR byla úspěšná Úklid po ES: Bob po obdržení ES zahodí nepoužité stavy Stavový automat relace Úplný stavový diagram:\nOutbound Session Inbound Session NEW | send NS | PENDING_REPLY -------------------- receive NS ---\u0026gt; ESTABLISHED | | receive NSR send NSR | | ESTABLISHED \u0026lt;---------- receive ES ------------- AWAITING_ES | | | ┌─────┴─────┐ | receive ES | | | | send ES receive ES | ESTABLISHED | | | | └─────┬─────┘ | ┌─────────┴─────────┐ | | | | | | send ES receive ES | | | | | | └─────────┬─────────┘ | | | └─────────────────────┴──────────────────────────┘ ACTIVE | idle timeout | EXPIRED Popisy stavů:\nNEW: Vytvořena odchozí relace, zatím nebyl odeslán žádný NS PENDING_REPLY: NS odeslán, čeká se na NSR AWAITING_ES: NSR odeslán, čeká se na první ES od Alice ESTABLISHED: Navázání spojení dokončeno, lze odesílat/přijímat ES ACTIVE: Aktivně probíhá výměna zpráv ES RATCHETING: Probíhá DH ratchet – postupné obnovování klíčů Diffie–Hellman (podmnožina stavu ACTIVE) EXPIRED: Relaci vypršel časový limit, čeká na smazání TERMINATED: Relace výslovně ukončena Formát užitečných dat Sekce užitečných dat všech zpráv ECIES (NS, NSR, ES) používá blokový formát podobný NTCP2.\nBloková struktura Obecný formát:\n+----+----+----+----+----+----+----+----+ |blk | size | data | +----+----+----+ + | | ~ ... ~ | | +----+----+----+----+----+----+----+----+ |blk | size | data | +----+----+----+ + | | ~ ... ~ | | +----+----+----+----+----+----+----+----+ Pole:\nblk: 1 bajt - Číslo typu bloku size: 2 bajty - Big-endianová velikost datového pole (0-65516) data: Proměnná délka - Data specifická pro blok Omezení:\nMaximální rámec ChaChaPoly: 65535 bajtů Poly1305 MAC: 16 bajtů Maximální celková velikost bloků: 65519 bajtů (65535 - 16) Maximální velikost jednoho bloku: 65519 bajtů (včetně 3bajtové hlavičky) Maximální velikost dat v jednom bloku: 65516 bajtů Typy bloků Definované typy bloků:\nType Name Size Status Usage 0 DateTime 7 bytes Implemented Required in NS 1-3 Reserved - - Future use 4 Termination 9+ bytes Unimplemented Session termination 5 Options 21+ bytes Unimplemented Session options 6 MessageNumbers 5 bytes Unimplemented PN value 7 NextKey 3 or 35 bytes Implemented DH ratchet 8 ACK 4+ bytes Implemented Message acknowledgment 9 ACK Request 3 bytes Implemented Request ACK 10 Reserved - - Future use 11 Garlic Clove Variable Implemented Application data 12-223 Reserved - - Future use 224-253 Experimental Variable - Testing features 254 Padding Variable Implemented Traffic shaping 255 Reserved - - Future extension **Zpracování neznámých bloků:** Implementace MUSÍ ignorovat bloky s neznámými typovými čísly a považovat je za výplň. To zajišťuje dopřednou kompatibilitu.\nPravidla řazení bloků Pořadí zpráv NS Povinné: - blok DateTime MUSÍ být první\nPovoleno: - Garlic Clove (část zprávy Garlic; \u0026lsquo;stroužek\u0026rsquo;) (typ 11) - Možnosti (typ 5) - pokud je implementováno - Výplň (typ 254)\nZakázáno: - NextKey, ACK, ACK Request, Termination, MessageNumbers\nPříklad platného NS payloadu:\nDateTime (0) | Garlic Clove (11) | Garlic Clove (11) | Padding (254) Pořadí zpráv v NSR Povinné: - Žádné (užitečná data mohou být prázdná)\nPovoleno: - Garlic Clove (jedna zapouzdřená zpráva v garlic encryption) (type 11) - Možnosti (type 5) - pokud je implementováno - Výplň (type 254)\nZakázáno: - DateTime, NextKey, ACK, ACK Request, Termination, MessageNumbers\nPříklad platného NSR payloadu:\nGarlic Clove (11) | Garlic Clove (11) | Padding (254) nebo\n(empty - ACK only) Pořadí zpráv ES Povinné: - Žádné (užitečná data mohou být prázdná)\nPovoleno (v libovolném pořadí): - Garlic Clove (type 11) - NextKey (type 7) - ACK (type 8) - ACK Request (type 9) - Termination (type 4) - je-li implementováno - MessageNumbers (type 6) - je-li implementováno - Options (type 5) - je-li implementováno - Padding (type 254)\nSpeciální pravidla: - Termination (ukončovací blok) MUSÍ být poslední blok (kromě bloku Padding (vycpávka)) - Padding MUSÍ být poslední blok - Více Garlic Cloves (částí \u0026lsquo;garlic\u0026rsquo; zprávy) je povoleno - Až 2 NextKey blocks (bloky s dalším klíčem) jsou povoleny (dopředný a zpětný) - Více bloků Padding NENÍ povoleno\nPříklady platných ES payloadů:\nGarlic Clove (11) | ACK (8) | Padding (254) NextKey (7) | Garlic Clove (11) | Garlic Clove (11) NextKey (7) forward | NextKey (7) reverse | Garlic Clove (11) ACK Request (9) | Garlic Clove (11) | Termination (4) | Padding (254) Blok DateTime (Typ 0) Účel: Časové razítko pro prevenci replay útoků (opakování zachycených zpráv) a ověření odchylky hodin\nVelikost: 7 bajtů (3bajtová hlavička + 4 bajty dat)\nFormát:\n+----+----+----+----+----+----+----+ | 0 | 4 | timestamp | +----+----+----+----+----+----+----+ Pole:\nblk: 0 size: 4 (big-endian; nejvýznamnější bajt první) timestamp: 4 bajty - Unixové časové razítko v sekundách (bez znaménka, big-endian) Formát časového razítka:\ntimestamp = int(time.time()) # Seconds since 1970-01-01 00:00:00 UTC # Wraps around in year 2106 (4-byte unsigned maximum) Pravidla validace:\nMAX_CLOCK_SKEW_PAST = 5 * 60 # 5 minutes MAX_CLOCK_SKEW_FUTURE = 2 * 60 # 2 minutes def validate_datetime(timestamp): now = int(time.time()) age = now - timestamp if age \u0026lt; -MAX_CLOCK_SKEW_FUTURE: return False # Too far in future if age \u0026gt; MAX_CLOCK_SKEW_PAST: return False # Too old return True Prevence replay útoků:\nclass ReplayFilter: def __init__(self, duration=5*60): self.duration = duration # 5 minutes self.seen_messages = BloomFilter(size=100000, false_positive_rate=0.001) self.cleanup_timer = RepeatTimer(60, self.cleanup) def check_replay(self, ephemeral_key, timestamp): # Check timestamp validity if not validate_datetime(timestamp): return False # Check if ephemeral key seen recently if ephemeral_key in self.seen_messages: return False # Replay attack # Add to seen messages self.seen_messages.add(ephemeral_key) return True def cleanup(self): # Expire old entries (Bloom filter automatically ages out) pass Poznámky k implementaci:\nNS Messages: DateTime MUSÍ být prvním blokem NSR/ES Messages: DateTime se obvykle neuvádí Replay Window (okno pro opakování útoku): minimálně doporučená hodnota je 5 minut Bloomův filtr: doporučen pro efektivní detekci replay útoků Odchylka hodin: povolte 5 minut do minulosti, 2 minuty do budoucnosti Garlic Clove Block (blok dílčí zprávy v rámci garlic zprávy) (Typ 11) Účel: Zapouzdřuje zprávy I2NP pro doručení\nFormát:\n+----+----+----+----+----+----+----+----+ | 11 | size | | +----+----+----+ + | Delivery Instructions | ~ ~ | | +----+----+----+----+----+----+----+----+ |type| Message_ID | Expiration | +----+----+----+----+----+----+----+----+ | I2NP Message body | +----+ + ~ ~ | | +----+----+----+----+----+----+----+----+ Pole:\nblk: 11 size: Celková velikost clove (dílčí zpráva v rámci zprávy typu garlic; proměnlivá) Delivery Instructions: Jak je uvedeno ve specifikaci I2NP type: Typ zprávy I2NP (1 bajt) Message_ID: Identifikátor zprávy I2NP (4 bajty) Expiration: Unixové časové razítko v sekundách (4 bajty) I2NP Message body: Data zprávy s proměnlivou délkou Formáty pokynů pro doručení:\nLokální doručení (1 bajt):\n+----+ |0x00| +----+ Doručení pro Destination (Destination = identita/koncová adresa v I2P) (33 bajtů):\n+----+----+----+----+----+----+----+----+ |0x01| | +----+ Destination Hash + | 32 bytes | + + | | +----+----+----+----+----+----+----+----+ Router Delivery (33 bajtů):\n+----+----+----+----+----+----+----+----+ |0x02| | +----+ Router Hash + | 32 bytes | + + | | +----+----+----+----+----+----+----+----+ Tunnel Delivery (37 bajtů):\n+----+----+----+----+----+----+----+----+ |0x03| Tunnel ID | +----+----+----+----+----+ + | Router Hash | + 32 bytes + | | + + | | +----+----+----+----+----+----+----+----+ Hlavička zprávy I2NP (celkem 9 bajtů):\n+----+----+----+----+----+----+----+----+ |type| msg_id | expiration | +----+----+----+----+----+----+----+----+ | | type: typ zprávy I2NP (Database Store, Database Lookup, Data, atd.) msg_id: 4bajtový identifikátor zprávy expiration: 4bajtové Unixové časové razítko (sekundy) Důležité rozdíly oproti ElGamal Clove Format (formát \u0026lsquo;clove\u0026rsquo; v rámci šifrovacího schématu ElGamal):\nŽádný certifikát: Pole certifikátu vynecháno (v ElGamalu se nepoužívá) Žádné Clove ID: Clove ID vynecháno (bylo vždy 0; Clove = podzpráva v rámci I2P \u0026lsquo;garlic\u0026rsquo; zprávy) Žádná expirace Clove: Místo toho se používá expirace zprávy I2NP Kompaktní hlavička: 9bajtová hlavička I2NP oproti většímu formátu ElGamalu Každý Clove je samostatný blok: Žádná struktura CloveSet Více stroužků:\n# Multiple Garlic Cloves in one message payload = [ build_datetime_block(), build_garlic_clove(i2np_message_1), build_garlic_clove(i2np_message_2), build_garlic_clove(i2np_message_3), build_padding_block() ] Běžné typy I2NP zpráv v Cloves (stroužcích, termín v rámci garlic encryption):\nType Name Usage 1 DatabaseStore Publishing LeaseSet 2 DatabaseLookup Requesting LeaseSet 5 DeliveryStatus ACK (legacy, avoid in ECIES) 20 Data Streaming data 21 Garlic Nested garlic messages **Zpracování clove (podzpráva v rámci garlic encryption):** def process_garlic_clove(clove_data): # Parse delivery instructions delivery_type = clove_data[0] if delivery_type == 0x00: # Local delivery offset = 1 elif delivery_type == 0x01: # Destination delivery dest_hash = clove_data[1:33] offset = 33 elif delivery_type == 0x02: # Router delivery router_hash = clove_data[1:33] offset = 33 elif delivery_type == 0x03: # Tunnel delivery tunnel_id = struct.unpack(\u0026#39;\u0026gt;I\u0026#39;, clove_data[1:5])[0] router_hash = clove_data[5:37] offset = 37 # Parse I2NP header i2np_type = clove_data[offset] msg_id = struct.unpack(\u0026#39;\u0026gt;I\u0026#39;, clove_data[offset+1:offset+5])[0] expiration = struct.unpack(\u0026#39;\u0026gt;I\u0026#39;, clove_data[offset+5:offset+9])[0] # Extract I2NP body i2np_body = clove_data[offset+9:] # Process message process_i2np_message(i2np_type, msg_id, expiration, i2np_body) Blok NextKey (Typ 7) Účel: výměna klíčů pomocí DH ratchet (ráčnový mechanismus Diffie–Hellman)\nFormát (klíč přítomen - 38 bajtů):\n+----+----+----+----+----+----+----+----+ | 7 | 35 |flag| key ID | | +----+----+----+----+----+----+ + | | + Next DH Ratchet Public Key + | 32 bytes | + + | | + +----+----+ | | +----+----+----+----+----+----+ Formát (Pouze ID klíče - 6 bajtů):\n+----+----+----+----+----+----+ | 7 | 3 |flag| key ID | +----+----+----+----+----+----+ Pole:\nblk: 7 size: 3 (pouze ID) nebo 35 (s klíčem) flag: 1 bajt - bity příznaku key ID: 2 bajty - Big-endian identifikátor klíče (0-32767) Public Key: 32 bajtů - veřejný klíč X25519 (little-endian), pokud je bit 0 příznaku = 1 Příznakové bity:\nBit 7 6 5 4 3 2 1 0 | | | | | | | | | | | | | | | +-- Bit 0: Key present (1) or ID only (0) | | | | | | +---- Bit 1: Reverse key (1) or forward key (0) | | | | | +------ Bit 2: Request reverse key (1) or no request (0) | | | | | +-+-+-+-+-------- Bits 3-7: Reserved (set to 0) Příklady příznaků:\n# Forward key present flags = 0x01 # Binary: 00000001 # Reverse key present flags = 0x03 # Binary: 00000011 # Forward key ID only (ACK) flags = 0x00 # Binary: 00000000 # Reverse key ID only (ACK) flags = 0x02 # Binary: 00000010 # Forward key ID with reverse request flags = 0x04 # Binary: 00000100 Pravidla pro ID klíčů:\nID jsou sekvenční: 0, 1, 2, \u0026hellip;, 32767 ID se zvyšuje pouze při vygenerování nového klíče Stejné ID se používá pro více zpráv, dokud neproběhne další ratchet (kryptografický krok) Maximální ID je 32767 (poté je nutné zahájit novou relaci) Příklady použití:\n# Initiating ratchet (sender generates new key) nextkey = NextKeyBlock( flags=0x01, # Key present, forward key_id=0, public_key=sender_new_pk ) # Replying to ratchet (receiver generates new key) nextkey = NextKeyBlock( flags=0x03, # Key present, reverse key_id=0, public_key=receiver_new_pk ) # Acknowledging ratchet (no new key from sender) nextkey = NextKeyBlock( flags=0x02, # ID only, reverse key_id=0 ) # Requesting reverse ratchet nextkey = NextKeyBlock( flags=0x04, # Request reverse, forward ID key_id=1 ) Logika zpracování:\ndef process_nextkey_block(block): flags = block.flags key_id = block.key_id key_present = (flags \u0026amp; 0x01) != 0 is_reverse = (flags \u0026amp; 0x02) != 0 request_reverse = (flags \u0026amp; 0x04) != 0 if key_present: public_key = block.public_key if is_reverse: # Reverse key received perform_dh_ratchet(receiver_key=public_key, key_id=key_id) # Sender should ACK with own key ID else: # Forward key received perform_dh_ratchet(sender_key=public_key, key_id=key_id) # Receiver should reply with reverse key send_reverse_key(generate_new_key()) else: # Key ID only (ACK) if is_reverse: # Reverse key ACK confirm_reverse_ratchet(key_id) else: # Forward key ACK confirm_forward_ratchet(key_id) if request_reverse: # Sender requests receiver to generate new key send_reverse_key(generate_new_key()) Více bloků NextKey:\nJedna zpráva ES může obsahovat až 2 bloky NextKey, pokud v obou směrech současně probíhá ratcheting (průběžné obnovování klíčů):\n# Both directions ratcheting payload = [ NextKeyBlock(flags=0x01, key_id=2, public_key=forward_key), # Forward NextKeyBlock(flags=0x03, key_id=1, public_key=reverse_key), # Reverse build_garlic_clove(data) ] Blok ACK (Typ 8) Účel: Potvrzovat přijaté zprávy v rámci stejného kanálu\nFormát (jediný ACK - 7 bajtů):\n+----+----+----+----+----+----+----+ | 8 | 4 |tagsetid | N | +----+----+----+----+----+----+----+ Formát (více ACKs (potvrzení)):\n+----+----+----+----+----+----+----+----+ | 8 | size |tagsetid | N | | +----+----+----+----+----+----+----+ + | more ACKs | ~ ... ~ | | +----+----+----+----+----+----+----+----+ Pole:\nblk: 8 size: 4 * počet ACKů (minimálně 4) Pro každý ACK: tagsetid: 2 bajty - Big-endian ID sady tagů (0-65535) N: 2 bajty - Big-endian číslo zprávy (0-65535) Určení ID sady značek:\n# Tag set 0 (initial, after NSR) tagset_id = 0 # After first ratchet (tag set 1) # Both Alice and Bob sent key ID 0 tagset_id = 1 + 0 + 0 = 1 # After second ratchet (tag set 2) # Alice sent key ID 1, Bob still using key ID 0 tagset_id = 1 + 1 + 0 = 2 # After third ratchet (tag set 3) # Alice still using key ID 1, Bob sent key ID 1 tagset_id = 1 + 1 + 1 = 3 Příklad s jediným ACK:\n# ACK message from tag set 5, message number 127 ack_block = ACKBlock( tagset_id=5, message_number=127 ) # Wire format (7 bytes): # 08 00 04 00 05 00 7F # | | | | | | | # | | | | | | +-- N (127) # | | | | +--------- N high byte # | | | +------------ tagset_id (5) # | | +--------------- tagset_id high byte # | +------------------ size (4) # +--------------------- type (8) Příklad více ACKů:\n# ACK three messages ack_block = ACKBlock([ (tagset_id=3, N=42), (tagset_id=3, N=43), (tagset_id=4, N=0) ]) # Wire format (15 bytes): # 08 00 0C 00 03 00 2A 00 03 00 2B 00 04 00 00 # (ts=3, N=42) (ts=3, N=43) (ts=4, N=0) Zpracování:\ndef process_ack_block(block): num_acks = block.size // 4 for i in range(num_acks): offset = i * 4 tagset_id = struct.unpack(\u0026#39;\u0026gt;H\u0026#39;, block.data[offset:offset+2])[0] message_num = struct.unpack(\u0026#39;\u0026gt;H\u0026#39;, block.data[offset+2:offset+4])[0] # Mark message as acknowledged mark_acked(tagset_id, message_num) # May trigger retransmission timeout cancellation cancel_retransmit_timer(tagset_id, message_num) Kdy odesílat ACKs (potvrzení):\nExplicitní ACK Request: Vždy odpovězte na blok ACK Request Doručení LeaseSet: Pokud odesílatel zahrne LeaseSet do zprávy Navázání relace: Může potvrdit (ACK) NS/NSR (ačkoli protokol preferuje implicitní ACK prostřednictvím ES) Potvrzení ratchetu (ratchet = mechanismus průběžné rotace klíčů): Může potvrdit (ACK) přijetí NextKey Aplikační vrstva: Podle požadavků protokolu vyšší vrstvy (např. Streaming) Načasování ACK:\nclass ACKManager: def __init__(self): self.pending_acks = [] self.ack_timer = None def request_ack(self, tagset_id, message_num): self.pending_acks.append((tagset_id, message_num)) if not self.ack_timer: # Delay ACK briefly to allow higher layer to respond self.ack_timer = set_timer(0.1, self.send_acks) # 100ms def send_acks(self): if self.pending_acks and not has_outbound_data(): # No higher layer data, send explicit ACK send_es_message(build_ack_block(self.pending_acks)) # Otherwise, ACK will piggyback on next ES message self.pending_acks = [] self.ack_timer = None Blok požadavku na ACK (Typ 9) Účel: Vyžádat in-band (v rámci stejného kanálu) potvrzení přijetí aktuální zprávy\nFormát:\n+----+----+----+----+ | 9 | 1 |flg | +----+----+----+----+ Pole:\nblk: 9 size: 1 flg: 1 bajt - Příznaky (všechny bity jsou aktuálně nepoužité, nastaveny na 0) Použití:\n# Request ACK for this message payload = [ build_ack_request_block(), build_garlic_clove(important_data) ] Odpověď přijímače:\nKdyž je přijata ACK Request (požadavek na potvrzení):\nWith Immediate Data: Zahrňte blok ACK do okamžité odpovědi Without Immediate Data: Spusťte časovač (např. 100ms) a pokud časovač vyprší, odešlete prázdný ES s ACK Tag Set ID: Použijte aktuální ID příchozího tagsetu (sada tagů) Message Number: Použijte číslo zprávy spojené s přijatým session tagem (značka relace) Zpracování:\ndef process_ack_request(message): # Extract message identification tagset_id = message.tagset_id message_num = message.message_num # Schedule ACK schedule_ack(tagset_id, message_num) # If no data to send immediately, start timer if not has_pending_data(): set_timer(0.1, lambda: send_ack_only(tagset_id, message_num)) Kdy použít ACK Request (požadavek na potvrzení):\nKritické zprávy: Zprávy, které musí být potvrzeny Doručení LeaseSet: Při přibalení LeaseSet Session Ratchet: (mechanismus postupné obměny klíčů) Po odeslání NextKey block Konec přenosu: Když odesílatel už nemá další data k odeslání, ale chce potvrzení Kdy NE používat:\nProtokol pro streamování: Vrstva streamování zpracovává ACK (potvrzení přijetí) Zprávy s vysokou četností: Vyhněte se požadavku na ACK u každé zprávy (režie) Nedůležité datagramy: Surové datagramy obvykle nepotřebují ACK Ukončovací blok (typ 4) Stav: NEIMPLEMENTOVÁNO\nÚčel: Korektně ukončit relaci\nFormát:\n+----+----+----+----+----+----+----+----+ | 4 | size | rsn| addl data | +----+----+----+----+ + ~ ... ~ +----+----+----+----+----+----+----+----+ Pole:\nblk: 4 size: 1 nebo více bajtů rsn: 1 bajt - kód důvodu addl data: Volitelná dodatečná data (formát závisí na důvodu) Důvodové kódy:\nCode Meaning Additional Data 0 Normal close / unspecified None 1 Termination received None 2 Idle timeout None (implementation-specific) 3 Resource exhaustion None (implementation-specific) 4+ Reserved Implementation-specific **Použití (až bude implementováno):** # Normal session close termination = TerminationBlock( reason=0, additional_data=b\u0026#39;\u0026#39; ) # Session termination due to received termination termination = TerminationBlock( reason=1, additional_data=b\u0026#39;\u0026#39; ) Pravidla:\nMUSÍ být posledním blokem, s výjimkou Padding (výplň) Je-li přítomen Termination (ukončení), Padding jej MUSÍ následovat Není povoleno ve zprávách NS ani NSR Povoleno pouze ve zprávách ES Blok voleb (Typ 5) Stav: NEIMPLEMENTOVÁNO\nÚčel: Vyjednat parametry relace\nFormát:\n+----+----+----+----+----+----+----+----+ | 5 | size |ver |flg |STL |STimeout | +----+----+----+----+----+----+----+----+ | SOTW | RITW |tmin|tmax|rmin|rmax| +----+----+----+----+----+----+----+----+ | tdmy | rdmy | tdelay | rdelay | +----+----+----+----+----+----+----+----+ | more_options | ~ ... ~ | | +----+----+----+----+----+----+----+----+ Pole:\nblk: 5 size: 21 nebo více bajtů ver: 1 bajt - Verze protokolu (musí být 0) flg: 1 bajt - Příznaky (všechny bity jsou aktuálně nevyužité) STL: 1 bajt - Délka session tagu (značky relace) (musí být 8) STimeout: 2 bajty - Časový limit nečinnosti relace v sekundách (big-endian) SOTW: 2 bajty - Okno odchozích značek odesílatele (big-endian) RITW: 2 bajty - Okno příchozích značek příjemce (big-endian) tmin, tmax, rmin, rmax: každý po 1 bajtu - Parametry vyplňování (4.4 s pevnou desetinnou čárkou) tdmy: 2 bajty - Max. falešný provoz (dummy traffic), který je ochoten posílat (bajtů/s, big-endian) rdmy: 2 bajty - Požadovaný falešný provoz (bajtů/s, big-endian) tdelay: 2 bajty - Max. vnitrozprávové zpoždění, které je ochoten vložit (msec, big-endian) rdelay: 2 bajty - Požadované vnitrozprávové zpoždění (msec, big-endian) more_options: Proměnná délka - budoucí rozšíření Parametry výplně (4.4 s pevnou řádovou čárkou):\ndef encode_padding_ratio(ratio): \u0026#34;\u0026#34;\u0026#34; Encode padding ratio as 4.4 fixed-point ratio: 0.0 to 15.9375 returns: 0x00 to 0xFF \u0026#34;\u0026#34;\u0026#34; return int(ratio * 16) def decode_padding_ratio(encoded): \u0026#34;\u0026#34;\u0026#34; Decode 4.4 fixed-point to ratio encoded: 0x00 to 0xFF returns: 0.0 to 15.9375 \u0026#34;\u0026#34;\u0026#34; return encoded / 16.0 # Examples: # 0x00 = 0.0 (no padding) # 0x01 = 0.0625 (6.25% padding) # 0x10 = 1.0 (100% padding - double traffic) # 0x80 = 8.0 (800% padding - 9x traffic) # 0xFF = 15.9375 (1593.75% padding) Vyjednávání okna tagů:\n# SOTW: Sender\u0026#39;s recommendation for receiver\u0026#39;s inbound window # RITW: Sender\u0026#39;s declaration of own inbound window # Receiver calculates actual inbound window: inbound_window = calculate_window( sender_suggestion=SOTW, own_constraints=MAX_INBOUND_TAGS, own_resources=available_memory() ) # Sender uses: # - RITW to know how far ahead receiver will accept # - Own SOTW to hint optimal window size Výchozí hodnoty (pokud nejsou vyjednány možnosti):\nDEFAULT_OPTIONS = { \u0026#39;version\u0026#39;: 0, \u0026#39;session_tag_length\u0026#39;: 8, \u0026#39;session_timeout\u0026#39;: 600, # 10 minutes \u0026#39;sender_outbound_tag_window\u0026#39;: 160, \u0026#39;receiver_inbound_tag_window\u0026#39;: 160, \u0026#39;tmin\u0026#39;: 0x00, # No minimum padding \u0026#39;tmax\u0026#39;: 0x10, # Up to 100% padding \u0026#39;rmin\u0026#39;: 0x00, # No minimum requested \u0026#39;rmax\u0026#39;: 0x10, # Up to 100% requested \u0026#39;tdmy\u0026#39;: 0, # No dummy traffic \u0026#39;rdmy\u0026#39;: 0, # No dummy traffic requested \u0026#39;tdelay\u0026#39;: 0, # No delay \u0026#39;rdelay\u0026#39;: 0 # No delay requested } Blok čísel zpráv (Typ 6) Stav: NEIMPLEMENTOVÁNO\nÚčel: Označuje poslední zprávu odeslanou v předchozí sadě tagů (umožňuje detekci mezer)\nFormát:\n+----+----+----+----+----+ | 6 | 2 | PN | +----+----+----+----+----+ Pole:\nblk: 6 size: 2 PN: 2 bajty - číslo poslední zprávy předchozí sady značek (big-endian (pořadí bajtů od nejvýznamnějšího), 0-65535) Definice PN (předchozí číslo):\nPN je index poslední značky odeslané v předchozí sadě značek.\nPoužití (až bude implementováno):\n# After ratcheting to new tag set # Old tag set: sent messages 0-4095 # New tag set: sending first message payload = [ MessageNumbersBlock(PN=4095), build_garlic_clove(data) ] Výhody pro příjemce:\ndef process_message_numbers(pn_value): # Receiver can now: # 1. Determine if any messages were skipped highest_received_in_old_tagset = 4090 if pn_value \u0026gt; highest_received_in_old_tagset: missing_count = pn_value - highest_received_in_old_tagset # 5 messages were never received # 2. Delete tags higher than PN from old tagset for tag_index in range(pn_value + 1, MAX_TAG_INDEX): delete_tag(old_tagset, tag_index) # 3. Expire tags ≤ PN after grace period (e.g., 2 minutes) schedule_deletion(old_tagset, delay=120) Pravidla:\nNESMÍ být odesláno v tag set 0 (žádný předchozí tag set; \u0026ldquo;tag set\u0026rdquo; = sada tagů) Odesílá se pouze v ES messages (ES zprávách) Odesílá se pouze v první zprávě (zprávách) nového tag set PN value (hodnota PN) je z pohledu odesílatele (poslední tag, který odesílatel poslal) Vztah k aplikaci Signal:\nV Signal Double Ratchet je PN v hlavičce zprávy. V ECIES je v šifrované části zprávy a je volitelný.\nVýplňový blok (typ 254) Účel: Odolnost vůči analýze provozu a zamlžování velikosti zpráv\nFormát:\n+----+----+----+----+----+----+----+----+ |254 | size | padding | +----+----+----+ + | | ~ ... ~ | | +----+----+----+----+----+----+----+----+ Pole:\nblk: 254 size: 0-65516 bajtů (big-endian, pořadí bajtů od nejvýznamnějšího) padding: Náhodná nebo nulová data Pravidla:\nMUSÍ být posledním blokem ve zprávě Více bloků Padding (výplň) NENÍ povoleno Může mít nulovou délku (pouze 3bajtová hlavička) Data bloku Padding mohou být samé nuly nebo náhodné bajty Výchozí padding (výplň):\nDEFAULT_PADDING_MIN = 0 DEFAULT_PADDING_MAX = 15 def generate_default_padding(): size = random.randint(DEFAULT_PADDING_MIN, DEFAULT_PADDING_MAX) data = random.bytes(size) # or zeros return PaddingBlock(size, data) Strategie odolnosti vůči analýze provozu:\nStrategie 1: Náhodná velikost (výchozí)\n# Add 0-15 bytes random padding to each message padding_size = random.randint(0, 15) padding_block = PaddingBlock(padding_size, random.bytes(padding_size)) Strategie 2: Zaokrouhlení na násobek\n# Round total message size to next multiple of 64 target_size = ((message_size + 63) // 64) * 64 padding_size = target_size - message_size - 3 # -3 for block header padding_block = PaddingBlock(padding_size, random.bytes(padding_size)) Strategie 3: Pevné velikosti zpráv\n# Always send 1KB messages TARGET_MESSAGE_SIZE = 1024 padding_size = TARGET_MESSAGE_SIZE - message_size - 3 padding_block = PaddingBlock(padding_size, random.bytes(padding_size)) Strategie 4: Vyjednané vycpávání (blok Options)\n# Calculate padding based on negotiated parameters # tmin, tmax from Options block min_padding = int(payload_size * tmin_ratio) max_padding = int(payload_size * tmax_ratio) padding_size = random.randint(min_padding, max_padding) padding_block = PaddingBlock(padding_size, random.bytes(padding_size)) Zprávy obsahující pouze výplň:\nZprávy mohou sestávat výhradně z výplně (bez aplikačních dat):\n# Dummy traffic message payload = [ PaddingBlock(random.randint(100, 500), random.bytes(...)) ] Poznámky k implementaci:\nVýplň samými nulami: Přijatelná (bude zašifrována algoritmem ChaCha20) Náhodná výplň: Po šifrování neposkytuje žádné dodatečné zabezpečení, ale spotřebovává více entropie Výkon: Generování náhodné výplně může být výpočetně náročné; zvažte použití samých nul Paměť: Velké bloky výplně spotřebovávají šířku pásma; buďte opatrní s maximální velikostí Implementační příručka Předpoklady Kryptografické knihovny:\nX25519: libsodium, NaCl nebo Bouncy Castle ChaCha20-Poly1305: libsodium, OpenSSL 1.1.0+ nebo Bouncy Castle SHA-256: OpenSSL, Bouncy Castle nebo vestavěná podpora v jazyce Elligator2 (technika mapování veřejných klíčů na náhodně vypadající reprezentace): Omezená podpora v knihovnách; může vyžadovat vlastní implementaci Implementace Elligator2 (technika pro mapování bodů eliptické křivky na rovnoměrně rozdělená data):\nElligator2 (kryptografická technika pro zakódování bodů eliptické křivky do náhodně vypadajících bajtů) není široce implementován. Možnosti:\nOBFS4: Zásuvný transport obfs4 pro Tor obsahuje implementaci Elligator2 (kryptografická metoda pro mapování náhodných dat na body eliptické křivky) Vlastní implementace: Založena na článku Elligator2 kleshni/Elligator: Referenční implementace na GitHubu Poznámka k Java I2P: Java I2P používá knihovnu net.i2p.crypto.eddsa s vlastními rozšířeními Elligator2.\nDoporučené pořadí implementace Fáze 1: Základní kryptografie 1. X25519 DH generování a výměna klíčů 2. ChaCha20-Poly1305 AEAD (autentizované šifrování s přidruženými daty) šifrování/dešifrování 3. SHA-256 hašování a MixHash 4. HKDF (odvozování klíčů na bázi HMAC) odvozování klíčů 5. Elligator2 (metoda maskování bodů eliptické křivky) kódování/dekódování (zpočátku lze použít testovací vektory)\nFáze 2: Formáty zpráv 1. Zpráva NS (nevázaná) - nejjednodušší formát 2. Zpráva NS (vázaná) - přidává statický klíč 3. Zpráva NSR 4. Zpráva ES 5. Parsování a generování bloků\nFáze 3: Správa relací 1. Vytváření a ukládání relací 2. Správa sady tagů (značek) (odesílatel a příjemce) 3. Ratchet (krokovací mechanismus) pro session tagy 4. Ratchet symetrického klíče 5. Vyhledávání tagů a správa okna\nFáze 4: DH Ratcheting (ráčnový mechanismus Diffie–Hellman) 1. Zpracování bloku NextKey 2. DH ratchet KDF (funkce odvození klíče) 3. Vytvoření sady tagů po provedení ratchet 4. Správa více sad tagů\nFáze 5: Logika protokolu 1. Stavový automat NS/NSR/ES 2. Prevence replay (útoku opakovaným přehráním) (DateTime, Bloomův filtr) 3. Logika retransmise (více NS/NSR) 4. Zpracování ACK (potvrzení přijetí)\nFáze 6: Integrace 1. zpracování I2NP Garlic Clove (jednotlivý segment zprávy) 2. sdružování LeaseSet 3. integrace streamingového protokolu 4. integrace datagramového protokolu\nImplementace odesílatele Životní cyklus odchozí relace:\nclass OutboundSession: def __init__(self, destination, bound=True): self.destination = destination self.bound = bound self.state = SessionState.NEW # Keys for NS message self.ephemeral_keypair = generate_elg2_keypair() if bound: self.static_key = context.static_keypair # Will be populated after NSR self.outbound_tagset = None self.outbound_keyratchet = None self.inbound_tagset = None self.inbound_keyratchet = None # Timing self.created_time = now() self.last_activity = now() # Retransmission self.ns_attempts = [] self.ns_timer = None def send_initial_message(self, payload): \u0026#34;\u0026#34;\u0026#34;Send NS message\u0026#34;\u0026#34;\u0026#34; # Build NS message ns_message = self.build_ns_message(payload) # Send send_to_network(self.destination, ns_message) # Track for retransmission self.ns_attempts.append({ \u0026#39;message\u0026#39;: ns_message, \u0026#39;time\u0026#39;: now(), \u0026#39;ephemeral_key\u0026#39;: self.ephemeral_keypair, \u0026#39;kdf_state\u0026#39;: self.save_kdf_state() }) # Start timer self.ns_timer = set_timer(1.0, self.on_ns_timeout) self.state = SessionState.PENDING_REPLY def build_ns_message(self, payload): \u0026#34;\u0026#34;\u0026#34;Construct NS message\u0026#34;\u0026#34;\u0026#34; # KDF initialization chainKey, h = self.initialize_kdf() # Ephemeral key section elg2_ephemeral = ENCODE_ELG2(self.ephemeral_keypair.public_key) h = SHA256(h || self.destination.static_key) h = SHA256(h || self.ephemeral_keypair.public_key) # es DH es_shared = DH(self.ephemeral_keypair.private_key, self.destination.static_key) keydata = HKDF(chainKey, es_shared, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k_static = keydata[32:63] # Encrypt static key section if self.bound: static_section = self.static_key.public_key else: static_section = bytes(32) static_ciphertext = ENCRYPT(k_static, 0, static_section, h) h = SHA256(h || static_ciphertext) # ss DH (if bound) if self.bound: ss_shared = DH(self.static_key.private_key, self.destination.static_key) keydata = HKDF(chainKey, ss_shared, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k_payload = keydata[32:63] nonce = 0 else: k_payload = k_static nonce = 1 # Build payload blocks payload_data = self.build_ns_payload(payload) # Encrypt payload payload_ciphertext = ENCRYPT(k_payload, nonce, payload_data, h) h = SHA256(h || payload_ciphertext) # Save KDF state for NSR processing self.ns_chainkey = chainKey self.ns_hash = h # Assemble message return elg2_ephemeral + static_ciphertext + payload_ciphertext def build_ns_payload(self, application_data): \u0026#34;\u0026#34;\u0026#34;Build NS payload blocks\u0026#34;\u0026#34;\u0026#34; blocks = [] # DateTime block (required, first) blocks.append(build_datetime_block()) # Garlic Clove(s) with application data blocks.append(build_garlic_clove(application_data)) # Optionally bundle LeaseSet if should_send_leaseset(): blocks.append(build_garlic_clove(build_leaseset_store())) # Padding blocks.append(build_padding_block(random.randint(0, 15))) return encode_blocks(blocks) def on_nsr_received(self, nsr_message): \u0026#34;\u0026#34;\u0026#34;Process NSR and establish ES session\u0026#34;\u0026#34;\u0026#34; # Cancel retransmission timer cancel_timer(self.ns_timer) # Parse NSR tag = nsr_message[0:8] elg2_bob_ephemeral = nsr_message[8:40] key_section_mac = nsr_message[40:56] payload_ciphertext = nsr_message[56:] # Find corresponding NS attempt ns_state = self.find_ns_by_tag(tag) if not ns_state: raise ValueError(\u0026#34;NSR tag doesn\u0026#39;t match any NS\u0026#34;) # Restore KDF state chainKey = ns_state[\u0026#39;chainkey\u0026#39;] h = ns_state[\u0026#39;hash\u0026#39;] # Decode Bob\u0026#39;s ephemeral key bob_ephemeral = DECODE_ELG2(elg2_bob_ephemeral) # Mix tag and Bob\u0026#39;s ephemeral into hash h = SHA256(h || tag) h = SHA256(h || bob_ephemeral) # ee DH ee_shared = DH(self.ephemeral_keypair.private_key, bob_ephemeral) keydata = HKDF(chainKey, ee_shared, \u0026#34;\u0026#34;, 32) chainKey = keydata[0:31] # se DH se_shared = DH(self.static_key.private_key, bob_ephemeral) keydata = HKDF(chainKey, se_shared, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k_key_section = keydata[32:63] # Verify key section MAC try: DECRYPT(k_key_section, 0, key_section_mac, h) except AuthenticationError: raise ValueError(\u0026#34;NSR key section MAC verification failed\u0026#34;) h = SHA256(h || key_section_mac) # Split for bidirectional ES keydata = HKDF(chainKey, ZEROLEN, \u0026#34;\u0026#34;, 64) k_ab = keydata[0:31] # Alice → Bob k_ba = keydata[32:63] # Bob → Alice # Initialize ES tagsets self.outbound_tagset = DH_INITIALIZE(chainKey, k_ab) self.inbound_tagset = DH_INITIALIZE(chainKey, k_ba) # Decrypt NSR payload k_nsr = HKDF(k_ba, ZEROLEN, \u0026#34;AttachPayloadKDF\u0026#34;, 32) try: payload = DECRYPT(k_nsr, 0, payload_ciphertext, h) except AuthenticationError: raise ValueError(\u0026#34;NSR payload MAC verification failed\u0026#34;) # Process NSR payload blocks self.process_payload_blocks(payload) # Session established self.state = SessionState.ESTABLISHED self.last_activity = now() # Send ES message (implicit ACK) self.send_es_ack() def send_es_message(self, payload): \u0026#34;\u0026#34;\u0026#34;Send ES message\u0026#34;\u0026#34;\u0026#34; if self.state != SessionState.ESTABLISHED: raise ValueError(\u0026#34;Session not established\u0026#34;) # Get next tag and key tag, index = self.outbound_tagset.get_next_tag() key = self.outbound_keyratchet.get_key(index) # Construct nonce nonce = construct_nonce(index) # Build payload blocks payload_data = self.build_es_payload(payload) # AEAD encryption ciphertext = ENCRYPT(key, nonce, payload_data, tag) # Assemble message es_message = tag + ciphertext # Send send_to_network(self.destination, es_message) # Update activity self.last_activity = now() # Check if ratchet needed if self.outbound_tagset.should_ratchet(): self.initiate_ratchet() Implementace přijímače Životní cyklus příchozí relace:\nclass InboundSession: def __init__(self): self.state = None self.bound = False self.destination = None # Keys self.remote_ephemeral_key = None self.remote_static_key = None self.ephemeral_keypair = None # Tagsets self.inbound_tagset = None self.outbound_tagset = None # Timing self.created_time = None self.last_activity = None # Paired session self.paired_outbound = None @staticmethod def try_decrypt_ns(message): \u0026#34;\u0026#34;\u0026#34;Attempt to decrypt as NS message\u0026#34;\u0026#34;\u0026#34; # Parse NS structure elg2_ephemeral = message[0:32] static_ciphertext = message[32:80] # 32 + 16 payload_ciphertext = message[80:] # Decode ephemeral key try: alice_ephemeral = DECODE_ELG2(elg2_ephemeral) except: return None # Not a valid Elligator2 encoding # Check replay if is_replay(alice_ephemeral): return None # KDF initialization chainKey, h = initialize_kdf() # Mix keys h = SHA256(h || context.static_keypair.public_key) h = SHA256(h || alice_ephemeral) # es DH es_shared = DH(context.static_keypair.private_key, alice_ephemeral) keydata = HKDF(chainKey, es_shared, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k_static = keydata[32:63] # Decrypt static key section try: static_data = DECRYPT(k_static, 0, static_ciphertext, h) except AuthenticationError: return None # Not a valid NS message h = SHA256(h || static_ciphertext) # Check if bound or unbound if static_data == bytes(32): # Unbound alice_static_key = None k_payload = k_static nonce = 1 else: # Bound - perform ss DH alice_static_key = static_data ss_shared = DH(context.static_keypair.private_key, alice_static_key) keydata = HKDF(chainKey, ss_shared, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k_payload = keydata[32:63] nonce = 0 # Decrypt payload try: payload = DECRYPT(k_payload, nonce, payload_ciphertext, h) except AuthenticationError: return None h = SHA256(h || payload_ciphertext) # Create session session = InboundSession() session.state = SessionState.ESTABLISHED session.created_time = now() session.last_activity = now() session.remote_ephemeral_key = alice_ephemeral session.remote_static_key = alice_static_key session.bound = (alice_static_key is not None) session.ns_chainkey = chainKey session.ns_hash = h # Extract destination if bound if session.bound: session.destination = extract_destination_from_payload(payload) # Process payload session.process_payload_blocks(payload) return session def send_nsr_reply(self, reply_payload): \u0026#34;\u0026#34;\u0026#34;Send NSR message\u0026#34;\u0026#34;\u0026#34; # Generate NSR tagset tagsetKey = HKDF(self.ns_chainkey, ZEROLEN, \u0026#34;SessionReplyTags\u0026#34;, 32) nsr_tagset = DH_INITIALIZE(self.ns_chainkey, tagsetKey) # Get tag tag, _ = nsr_tagset.get_next_tag() # Mix tag into hash h = SHA256(self.ns_hash || tag) # Generate ephemeral key self.ephemeral_keypair = generate_elg2_keypair() bob_ephemeral = self.ephemeral_keypair.public_key elg2_bob_ephemeral = ENCODE_ELG2(bob_ephemeral) # Mix ephemeral key h = SHA256(h || bob_ephemeral) chainKey = self.ns_chainkey # ee DH ee_shared = DH(self.ephemeral_keypair.private_key, self.remote_ephemeral_key) keydata = HKDF(chainKey, ee_shared, \u0026#34;\u0026#34;, 32) chainKey = keydata[0:31] # se DH se_shared = DH(context.static_keypair.private_key, self.remote_ephemeral_key) keydata = HKDF(chainKey, se_shared, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k_key_section = keydata[32:63] # Encrypt key section (empty) key_section_ciphertext = ENCRYPT(k_key_section, 0, ZEROLEN, h) h = SHA256(h || key_section_ciphertext) # Split for bidirectional ES keydata = HKDF(chainKey, ZEROLEN, \u0026#34;\u0026#34;, 64) k_ab = keydata[0:31] # Alice → Bob k_ba = keydata[32:63] # Bob → Alice # Initialize ES tagsets self.inbound_tagset = DH_INITIALIZE(chainKey, k_ab) self.outbound_tagset = DH_INITIALIZE(chainKey, k_ba) # Build reply payload payload_data = build_payload_blocks(reply_payload) # Encrypt payload k_nsr = HKDF(k_ba, ZEROLEN, \u0026#34;AttachPayloadKDF\u0026#34;, 32) payload_ciphertext = ENCRYPT(k_nsr, 0, payload_data, h) # Assemble NSR nsr_message = tag + elg2_bob_ephemeral + key_section_ciphertext + payload_ciphertext # Send send_to_network(self.destination, nsr_message) # Wait for ES self.state = SessionState.AWAITING_ES self.last_activity = now() def on_es_received(self, es_message): \u0026#34;\u0026#34;\u0026#34;Process first ES message\u0026#34;\u0026#34;\u0026#34; if self.state == SessionState.AWAITING_ES: # First ES received, confirms session self.state = SessionState.ESTABLISHED # Process ES message self.process_es_message(es_message) def process_es_message(self, es_message): \u0026#34;\u0026#34;\u0026#34;Decrypt and process ES message\u0026#34;\u0026#34;\u0026#34; # Extract tag tag = es_message[0:8] ciphertext = es_message[8:] # Look up tag index = self.inbound_tagset.lookup_tag(tag) if index is None: raise ValueError(\u0026#34;Tag not found\u0026#34;) # Get key key = self.inbound_keyratchet.get_key(index) # Construct nonce nonce = construct_nonce(index) # Decrypt try: payload = DECRYPT(key, nonce, ciphertext, tag) except AuthenticationError: raise ValueError(\u0026#34;ES MAC verification failed\u0026#34;) # Process blocks self.process_payload_blocks(payload) # Update activity self.last_activity = now() Klasifikace zpráv Rozlišování typů zpráv:\ndef classify_message(message): \u0026#34;\u0026#34;\u0026#34;Determine message type\u0026#34;\u0026#34;\u0026#34; # Minimum lengths if len(message) \u0026lt; 24: return None # Too short # Check for session tag (8 bytes) tag = message[0:8] # Try ES decryption first (most common) session = lookup_session_by_tag(tag) if session: return (\u0026#39;ES\u0026#39;, session) # Try NSR decryption (tag + Elligator2 key) if len(message) \u0026gt;= 72: # Check if bytes 8-40 are valid Elligator2 try: nsr_ephemeral = DECODE_ELG2(message[8:40]) nsr_session = find_pending_nsr_by_tag(tag) if nsr_session: return (\u0026#39;NSR\u0026#39;, nsr_session) except: pass # Try NS decryption (starts with Elligator2 key) if len(message) \u0026gt;= 96: try: ns_ephemeral = DECODE_ELG2(message[0:32]) ns_session = InboundSession.try_decrypt_ns(message) if ns_session: return (\u0026#39;NS\u0026#39;, ns_session) except: pass # Check ElGamal/AES (for dual-key compatibility) if len(message) \u0026gt;= 514: if (len(message) - 2) % 16 == 0: # Might be ElGamal NS return (\u0026#39;ELGAMAL_NS\u0026#39;, None) elif len(message) % 16 == 0: # Might be ElGamal ES return (\u0026#39;ELGAMAL_ES\u0026#39;, None) return None # Unknown message type Osvědčené postupy pro správu relací Úložiště relace:\nclass SessionKeyManager: def __init__(self): # Outbound sessions (one per destination) self.outbound_sessions = {} # destination -\u0026gt; OutboundSession # Inbound sessions (multiple per destination during transition) self.inbound_sessions = [] # [InboundSession] # Session tag lookup (fast path for ES messages) self.tag_to_session = {} # tag -\u0026gt; InboundSession # Limits self.max_inbound_sessions = 1000 self.max_tags_per_session = 160 def get_outbound_session(self, destination): \u0026#34;\u0026#34;\u0026#34;Get or create outbound session\u0026#34;\u0026#34;\u0026#34; if destination not in self.outbound_sessions: session = OutboundSession(destination) self.outbound_sessions[destination] = session return self.outbound_sessions[destination] def add_inbound_session(self, session): \u0026#34;\u0026#34;\u0026#34;Add new inbound session\u0026#34;\u0026#34;\u0026#34; # Check limits if len(self.inbound_sessions) \u0026gt;= self.max_inbound_sessions: self.expire_oldest_session() self.inbound_sessions.append(session) # Add tags to lookup table self.register_session_tags(session) def register_session_tags(self, session): \u0026#34;\u0026#34;\u0026#34;Register session\u0026#39;s tags in lookup table\u0026#34;\u0026#34;\u0026#34; for tag in session.inbound_tagset.get_all_tags(): self.tag_to_session[tag] = session def lookup_tag(self, tag): \u0026#34;\u0026#34;\u0026#34;Fast tag lookup\u0026#34;\u0026#34;\u0026#34; return self.tag_to_session.get(tag) def expire_sessions(self): \u0026#34;\u0026#34;\u0026#34;Periodic session expiration\u0026#34;\u0026#34;\u0026#34; now_time = now() # Expire outbound sessions for dest, session in list(self.outbound_sessions.items()): if session.idle_time(now_time) \u0026gt; 8 * 60: del self.outbound_sessions[dest] # Expire inbound sessions expired = [] for session in self.inbound_sessions: if session.idle_time(now_time) \u0026gt; 10 * 60: expired.append(session) for session in expired: self.remove_inbound_session(session) def remove_inbound_session(self, session): \u0026#34;\u0026#34;\u0026#34;Remove inbound session and clean up tags\u0026#34;\u0026#34;\u0026#34; self.inbound_sessions.remove(session) # Remove tags from lookup for tag in session.inbound_tagset.get_all_tags(): if tag in self.tag_to_session: del self.tag_to_session[tag] Správa paměti:\nclass TagMemoryManager: def __init__(self, max_memory_kb=10240): # 10 MB default self.max_memory = max_memory_kb * 1024 self.current_memory = 0 self.max_tags_per_session = 160 self.min_tags_per_session = 32 def calculate_tag_memory(self, session): \u0026#34;\u0026#34;\u0026#34;Calculate memory used by session tags\u0026#34;\u0026#34;\u0026#34; tag_count = len(session.inbound_tagset.tags) # Each tag: 8 bytes (tag) + 2 bytes (index) + 32 bytes (key, optional) # + overhead bytes_per_tag = 16 if session.defer_keys else 48 return tag_count * bytes_per_tag def check_pressure(self): \u0026#34;\u0026#34;\u0026#34;Check if under memory pressure\u0026#34;\u0026#34;\u0026#34; return self.current_memory \u0026gt; (self.max_memory * 0.9) def handle_pressure(self): \u0026#34;\u0026#34;\u0026#34;Reduce memory usage when under pressure\u0026#34;\u0026#34;\u0026#34; if not self.check_pressure(): return # Strategy 1: Reduce look-ahead windows for session in all_sessions: if session.look_ahead \u0026gt; self.min_tags_per_session: session.reduce_look_ahead(self.min_tags_per_session) # Strategy 2: Trim old tags aggressively for session in all_sessions: session.inbound_tagset.trim_behind(aggressive=True) # Strategy 3: Refuse new ratchets for session in all_sessions: if session.outbound_tagset.should_ratchet(): session.defer_ratchet = True # Strategy 4: Expire idle sessions early expire_idle_sessions(threshold=5*60) # 5 min instead of 10 Testovací strategie Jednotkové testy:\ndef test_x25519_dh(): \u0026#34;\u0026#34;\u0026#34;Test X25519 key exchange\u0026#34;\u0026#34;\u0026#34; alice_sk = GENERATE_PRIVATE() alice_pk = DERIVE_PUBLIC(alice_sk) bob_sk = GENERATE_PRIVATE() bob_pk = DERIVE_PUBLIC(bob_sk) # Both sides compute same shared secret alice_shared = DH(alice_sk, bob_pk) bob_shared = DH(bob_sk, alice_pk) assert alice_shared == bob_shared def test_elligator2_encode_decode(): \u0026#34;\u0026#34;\u0026#34;Test Elligator2 roundtrip\u0026#34;\u0026#34;\u0026#34; sk = GENERATE_PRIVATE_ELG2() pk = DERIVE_PUBLIC(sk) encoded = ENCODE_ELG2(pk) decoded = DECODE_ELG2(encoded) assert decoded == pk def test_chacha_poly_encrypt_decrypt(): \u0026#34;\u0026#34;\u0026#34;Test ChaCha20-Poly1305 AEAD\u0026#34;\u0026#34;\u0026#34; key = CSRNG(32) nonce = construct_nonce(42) plaintext = b\u0026#34;Hello, I2P!\u0026#34; ad = b\u0026#34;associated_data\u0026#34; ciphertext = ENCRYPT(key, nonce, plaintext, ad) decrypted = DECRYPT(key, nonce, ciphertext, ad) assert decrypted == plaintext def test_session_tag_ratchet(): \u0026#34;\u0026#34;\u0026#34;Test session tag generation\u0026#34;\u0026#34;\u0026#34; sessTag_ck = CSRNG(32) tagset = SessionTagRatchet(sessTag_ck) # Generate 100 tags tags = [tagset.get_next_tag() for _ in range(100)] # All tags should be unique assert len(set(tags)) == 100 # Each tag should be 8 bytes for tag in tags: assert len(tag) == 8 Integrační testy:\ndef test_ns_nsr_handshake(): \u0026#34;\u0026#34;\u0026#34;Test NS/NSR handshake\u0026#34;\u0026#34;\u0026#34; # Alice creates outbound session alice_session = OutboundSession(bob_destination, bound=True) # Alice sends NS ns_message = alice_session.build_ns_message(b\u0026#34;Hello Bob\u0026#34;) # Bob receives NS bob_session = InboundSession.try_decrypt_ns(ns_message) assert bob_session is not None assert bob_session.bound == True # Bob sends NSR nsr_message = bob_session.build_nsr_message(b\u0026#34;Hello Alice\u0026#34;) # Alice receives NSR alice_session.on_nsr_received(nsr_message) assert alice_session.state == SessionState.ESTABLISHED # Both should have matching ES tagsets # (Cannot directly compare, but can test by sending ES messages) def test_es_bidirectional(): \u0026#34;\u0026#34;\u0026#34;Test ES messages in both directions\u0026#34;\u0026#34;\u0026#34; # (After NS/NSR handshake) # Alice sends ES to Bob es_alice_to_bob = alice_session.send_es_message(b\u0026#34;Data from Alice\u0026#34;) # Bob receives ES bob_session.process_es_message(es_alice_to_bob) # Bob sends ES to Alice es_bob_to_alice = bob_session.send_es_message(b\u0026#34;Data from Bob\u0026#34;) # Alice receives ES alice_session.process_es_message(es_bob_to_alice) def test_dh_ratchet(): \u0026#34;\u0026#34;\u0026#34;Test DH ratchet\u0026#34;\u0026#34;\u0026#34; # (After established session) # Alice initiates ratchet alice_session.initiate_ratchet() nextkey_alice = build_nextkey_block( flags=0x01, key_id=0, public_key=alice_new_key ) # Send to Bob bob_session.process_nextkey_block(nextkey_alice) # Bob replies nextkey_bob = build_nextkey_block( flags=0x03, key_id=0, public_key=bob_new_key ) # Send to Alice alice_session.process_nextkey_block(nextkey_bob) # Both should now be using new tagsets assert alice_session.outbound_tagset.id == 1 assert bob_session.inbound_tagset.id == 1 Testovací vektory:\nImplementujte testovací vektory ze specifikace:\nNoise IK Handshake: Použijte standardní testovací vektory pro Noise HKDF: Použijte testovací vektory z RFC 5869 ChaCha20-Poly1305: Použijte testovací vektory z RFC 7539 Elligator2: Použijte testovací vektory z článku Elligator2 nebo z OBFS4 Testování interoperability:\nJava I2P: Otestujte vůči referenční implementaci Java I2P i2pd: Otestujte vůči C++ implementaci i2pd Zachycení paketů: Použijte disektor Wiresharku (pokud je k dispozici) k ověření formátů zpráv Napříč implementacemi: Vytvořte test harness (testovací rámec), který dokáže odesílat/přijímat mezi implementacemi Hlediska výkonu Generování klíčů:\nGenerování klíčů Elligator2 (kryptografická technika pro maskování veřejných klíčů) je výpočetně náročné (50% míra odmítnutí):\nclass KeyPool: \u0026#34;\u0026#34;\u0026#34;Pre-generate keys in background thread\u0026#34;\u0026#34;\u0026#34; def __init__(self, pool_size=10): self.pool = Queue(maxsize=pool_size) self.generator_thread = Thread(target=self.generate_keys, daemon=True) self.generator_thread.start() def generate_keys(self): while True: if not self.pool.full(): keypair = generate_elg2_keypair() # Also compute encoded form encoded = ENCODE_ELG2(keypair.public_key) self.pool.put((keypair, encoded)) else: sleep(0.1) def get_keypair(self): try: return self.pool.get(timeout=1.0) except Empty: # Pool exhausted, generate inline return generate_elg2_keypair() Vyhledání tagu (štítku):\nPoužijte hashovací tabulky pro O(1) vyhledávání tagů:\nclass FastTagLookup: def __init__(self): self.tag_to_session = {} # Python dict is hash table def add_tag(self, tag, session, index): # 8-byte tag as bytes is hashable self.tag_to_session[tag] = (session, index) def lookup_tag(self, tag): return self.tag_to_session.get(tag) Optimalizace paměti:\nOdložit generování symetrického klíče:\nclass DeferredKeyRatchet: \u0026#34;\u0026#34;\u0026#34;Only generate keys when needed\u0026#34;\u0026#34;\u0026#34; def __init__(self, symmKey_ck): self.chainKey = symmKey_ck self.index = -1 self.cache = LRUCache(maxsize=32) # Cache recent keys def get_key(self, index): # Check cache first if index in self.cache: return self.cache[index] # Generate keys up to index while self.index \u0026lt; index: self.index += 1 keydata = HKDF(self.chainKey, ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) self.chainKey = keydata[0:31] if self.index == index: key = keydata[32:63] self.cache[index] = key return key Dávkové zpracování:\nZpracujte více zpráv dávkově:\ndef process_message_batch(messages): \u0026#34;\u0026#34;\u0026#34;Process multiple messages efficiently\u0026#34;\u0026#34;\u0026#34; results = [] # Group by type ns_messages = [] nsr_messages = [] es_messages = [] for msg in messages: msg_type = classify_message(msg) if msg_type[0] == \u0026#39;NS\u0026#39;: ns_messages.append(msg) elif msg_type[0] == \u0026#39;NSR\u0026#39;: nsr_messages.append(msg) elif msg_type[0] == \u0026#39;ES\u0026#39;: es_messages.append(msg) # Process in batches # ES messages are most common, process first for msg in es_messages: results.append(process_es_message(msg)) for msg in nsr_messages: results.append(process_nsr_message(msg)) for msg in ns_messages: results.append(process_ns_message(msg)) return results Bezpečnostní hlediska Model hrozeb Schopnosti útočníka:\nPasivní pozorovatel: Může sledovat veškerý síťový provoz Aktivní útočník: Může vkládat, upravovat, zahazovat a opakovat (replay) zprávy Kompromitovaný uzel: Může kompromitovat router nebo destination (cílový identifikátor v I2P) Analýza provozu: Může provádět statistickou analýzu vzorců provozu Bezpečnostní cíle:\nDůvěrnost: Obsah zpráv skrytý před pozorovatelem Autentizace: Identita odesílatele ověřena (u vázaných relací) Dopředné utajení: Minulé zprávy zůstávají tajné i při kompromitaci klíčů Prevence replay útoků: Nelze zopakovat staré zprávy Obfuskace provozu: Navazování spojení nerozlišitelné od náhodných dat Kryptografické předpoklady Předpoklady o výpočetní obtížnosti:\nX25519 CDH: Výpočetní problém Diffie-Hellman je na křivce Curve25519 výpočetně těžký ChaCha20 PRF: ChaCha20 je pseudonáhodná funkce Poly1305 MAC: Poly1305 je nepodvrzitelný při útoku s volenou zprávou SHA-256 CR: SHA-256 je odolná vůči kolizím HKDF Security: HKDF extrahuje a rozšiřuje rovnoměrně rozdělené klíče Úrovně zabezpečení:\nX25519: ~128bitová bezpečnost (řád křivky 2^252) ChaCha20: 256bitové klíče, 256bitová bezpečnost Poly1305: 128bitová bezpečnost (pravděpodobnost kolize) SHA-256: 128bitová odolnost vůči kolizím, 256bitová odolnost vůči předobrazu Správa klíčů Generování klíčů:\n# CRITICAL: Use cryptographically secure RNG def CSRNG(length): # GOOD: os.urandom, secrets.token_bytes (Python) # GOOD: /dev/urandom (Linux) # GOOD: BCryptGenRandom (Windows) # BAD: random.random(), Math.random() (NOT cryptographically secure) return os.urandom(length) # CRITICAL: Validate keys def validate_x25519_key(pubkey): # Check for weak keys (all zeros, small order points) if pubkey == bytes(32): raise WeakKeyError(\u0026#34;All-zero public key\u0026#34;) # Perform DH to check for weak shared secrets test_shared = DH(test_private_key, pubkey) if test_shared == bytes(32): raise WeakKeyError(\u0026#34;Results in zero shared secret\u0026#34;) Úložiště klíčů:\n# CRITICAL: Protect private keys class SecureKeyStorage: def __init__(self): # Store in memory with protection self.keys = {} # Option 1: Memory locking (prevent swapping to disk) # mlock(self.keys) # Option 2: Encrypted storage # self.encryption_key = derive_from_password() def store_key(self, key_id, private_key): # Option: Encrypt before storage # encrypted = encrypt(private_key, self.encryption_key) # self.keys[key_id] = encrypted self.keys[key_id] = private_key def delete_key(self, key_id): # Securely wipe memory if key_id in self.keys: key = self.keys[key_id] # Overwrite with zeros before deletion for i in range(len(key)): key[i] = 0 del self.keys[key_id] Rotace klíčů:\n# CRITICAL: Rotate keys regularly class KeyRotationPolicy: def __init__(self): self.max_messages_per_tagset = 4096 # Ratchet before 65535 self.max_tagset_age = 10 * 60 # 10 minutes self.max_session_age = 60 * 60 # 1 hour def should_ratchet(self, tagset): return (tagset.messages_sent \u0026gt;= self.max_messages_per_tagset or tagset.age() \u0026gt;= self.max_tagset_age) def should_replace_session(self, session): return session.age() \u0026gt;= self.max_session_age Opatření ke zmírnění útoků Opatření proti replay útokům Ověření data a času:\nMAX_CLOCK_SKEW_PAST = 5 * 60 MAX_CLOCK_SKEW_FUTURE = 2 * 60 def validate_datetime(timestamp): now = int(time.time()) age = now - timestamp if age \u0026lt; -MAX_CLOCK_SKEW_FUTURE: raise ReplayError(\u0026#34;Timestamp too far in future\u0026#34;) if age \u0026gt; MAX_CLOCK_SKEW_PAST: raise ReplayError(\u0026#34;Timestamp too old\u0026#34;) return True Bloomův filtr pro zprávy NS:\nclass ReplayFilter: def __init__(self, capacity=100000, error_rate=0.001, duration=5*60): self.bloom = BloomFilter(capacity=capacity, error_rate=error_rate) self.duration = duration self.entries = [] # (timestamp, ephemeral_key) def check_replay(self, ephemeral_key, timestamp): # Validate timestamp if not validate_datetime(timestamp): return False # Check Bloom filter if ephemeral_key in self.bloom: # Potential replay (or false positive) # Check exact match in entries for ts, key in self.entries: if key == ephemeral_key: return False # Definite replay # Add to filter self.bloom.add(ephemeral_key) self.entries.append((timestamp, ephemeral_key)) # Expire old entries self.expire_old_entries() return True def expire_old_entries(self): now = int(time.time()) self.entries = [(ts, key) for ts, key in self.entries if now - ts \u0026lt; self.duration] Jednorázové použití Session Tag (značka relace):\ndef process_session_tag(tag): # Look up tag entry = tagset.lookup_tag(tag) if entry is None: raise ValueError(\u0026#34;Invalid session tag\u0026#34;) # CRITICAL: Remove tag immediately (one-time use) tagset.remove_tag(tag) # Use associated key return entry.key, entry.index Opatření proti Key Compromise Impersonation (KCI; vydávání se za protějšek po kompromitaci klíče) Problém: Autentizace zpráv NS je zranitelná vůči KCI (napodobení po kompromitaci klíče) (Úroveň autentizace 1)\nZmírnění:\nPřejděte na NSR (úroveň autentizace 2) co nejrychleji Nevěřte NS payloadu při bezpečnostně kritických operacích Před provedením nevratných akcí vyčkejte na potvrzení NSR def process_ns_message(ns_message): # NS authenticated at Level 1 (KCI vulnerable) # Do NOT perform security-critical operations yet # Extract sender\u0026#39;s static key sender_key = ns_message.static_key # Mark session as pending Level 2 authentication session.auth_level = 1 session.sender_key = sender_key # Send NSR send_nsr_reply(session) def process_first_es_message(es_message): # Now we have Level 2 authentication (KCI resistant) session.auth_level = 2 # Safe to perform security-critical operations process_security_critical_operation(es_message) Opatření proti útokům typu odmítnutí služby (DoS) Ochrana proti zahlcení NS (systém názvů):\nclass NSFloodProtection: def __init__(self): self.ns_count = defaultdict(int) # source -\u0026gt; count self.ns_timestamps = defaultdict(list) # source -\u0026gt; [timestamps] self.max_ns_per_source = 5 self.rate_window = 10 # seconds self.max_concurrent_ns = 100 def check_ns_allowed(self, source): # Global limit total_pending = sum(self.ns_count.values()) if total_pending \u0026gt;= self.max_concurrent_ns: return False # Per-source rate limit now = time.time() timestamps = self.ns_timestamps[source] # Remove old timestamps timestamps = [ts for ts in timestamps if now - ts \u0026lt; self.rate_window] self.ns_timestamps[source] = timestamps # Check rate if len(timestamps) \u0026gt;= self.max_ns_per_source: return False # Allow NS timestamps.append(now) self.ns_count[source] += 1 return True def on_session_established(self, source): # Decrease pending count if self.ns_count[source] \u0026gt; 0: self.ns_count[source] -= 1 Limity ukládání značek:\nclass TagStorageLimit: def __init__(self, max_tags=1000000): self.max_tags = max_tags self.current_tags = 0 def can_create_session(self, look_ahead): if self.current_tags + look_ahead \u0026gt; self.max_tags: return False return True def add_tags(self, count): self.current_tags += count def remove_tags(self, count): self.current_tags -= count Adaptivní správa zdrojů:\nclass AdaptiveResourceManager: def __init__(self): self.load_level = 0 # 0 = low, 1 = medium, 2 = high, 3 = critical def adjust_parameters(self): if self.load_level == 0: # Normal operation return { \u0026#39;max_look_ahead\u0026#39;: 160, \u0026#39;max_sessions\u0026#39;: 1000, \u0026#39;session_timeout\u0026#39;: 10 * 60 } elif self.load_level == 1: # Moderate load return { \u0026#39;max_look_ahead\u0026#39;: 80, \u0026#39;max_sessions\u0026#39;: 800, \u0026#39;session_timeout\u0026#39;: 8 * 60 } elif self.load_level == 2: # High load return { \u0026#39;max_look_ahead\u0026#39;: 32, \u0026#39;max_sessions\u0026#39;: 500, \u0026#39;session_timeout\u0026#39;: 5 * 60 } else: # load_level == 3 # Critical load return { \u0026#39;max_look_ahead\u0026#39;: 16, \u0026#39;max_sessions\u0026#39;: 200, \u0026#39;session_timeout\u0026#39;: 3 * 60 } Odolnost vůči analýze provozu Kódování Elligator2:\nZajišťuje, že zprávy handshake (navázání spojení) jsou nerozlišitelné od náhodných dat:\n# NS and NSR start with Elligator2-encoded ephemeral keys # Observer cannot distinguish from random 32-byte string Strategie výplně:\n# Resist message size fingerprinting def add_padding(payload, strategy=\u0026#39;random\u0026#39;): if strategy == \u0026#39;random\u0026#39;: # Random padding 0-15 bytes size = random.randint(0, 15) elif strategy == \u0026#39;round\u0026#39;: # Round to next 64-byte boundary target = ((len(payload) + 63) // 64) * 64 size = target - len(payload) - 3 # -3 for block header elif strategy == \u0026#39;fixed\u0026#39;: # Always 1KB messages size = 1024 - len(payload) - 3 return build_padding_block(size) Časové útoky:\n# CRITICAL: Use constant-time operations def constant_time_compare(a, b): \u0026#34;\u0026#34;\u0026#34;Constant-time byte string comparison\u0026#34;\u0026#34;\u0026#34; if len(a) != len(b): return False result = 0 for x, y in zip(a, b): result |= x ^ y return result == 0 # CRITICAL: Constant-time MAC verification def verify_mac(computed_mac, received_mac): if not constant_time_compare(computed_mac, received_mac): # Always take same time regardless of where comparison fails raise AuthenticationError(\u0026#34;MAC verification failed\u0026#34;) Úskalí implementace Časté chyby:\nZnovupoužití nonce (jednorázové hodnoty): NIKDY znovu nepoužívejte dvojice (key, nonce) # BAD: Reusing nonce with same key ciphertext1 = ENCRYPT(key, nonce, plaintext1, ad1) ciphertext2 = ENCRYPT(key, nonce, plaintext2, ad2) # CATASTROPHIC DOBRÉ: Jedinečná nonce (jednorázová hodnota) pro každou zprávu ciphertext1 = ENCRYPT(key, nonce1, plaintext1, ad1) ciphertext2 = ENCRYPT(key, nonce2, plaintext2, ad2) 2. **Ephemeral Key Reuse**: Generate fresh ephemeral key for each NS/NSR ```python # ŠPATNĚ: Opětovné použití efemérního klíče ephemeral_key = generate_elg2_keypair() send_ns_message(ephemeral_key) send_ns_message(ephemeral_key) # ŠPATNĚ # SPRÁVNĚ: Nový klíč pro každou zprávu send_ns_message(generate_elg2_keypair()) send_ns_message(generate_elg2_keypair()) Weak RNG: Use cryptographically secure random number generator ŠPATNĚ: Nekryptografický generátor náhodných čísel (RNG) import random key = bytes([random.randint(0, 255) for _ in range(32)]) # NEZABEZPEČENÉ SPRÁVNĚ: Kryptograficky bezpečný generátor náhodných čísel import os key = os.urandom(32) 4. **Timing Attacks**: Use constant-time comparisons ```python # ŠPATNĚ: Porovnání s předčasným ukončením if computed_mac == received_mac: # Časovací únik pass # SPRÁVNĚ: Porovnání v konstantním čase if constant_time_compare(computed_mac, received_mac): pass Incomplete MAC Verification: Always verify before using data ŠPATNĚ: Dešifrování před ověřením plaintext = chacha20_decrypt(key, nonce, ciphertext) mac_ok = verify_mac(mac, plaintext) # PŘÍLIŠ POZDĚ if not mac_ok: return error SPRÁVNĚ: AEAD ověřuje před dešifrováním try: plaintext = DECRYPT(key, nonce, ciphertext, ad) # Verifies MAC first except AuthenticationError:\nreturn error 6. **Key Deletion**: Securely wipe keys from memory ```python # ŠPATNĚ: Jednoduché smazání del private_key # Stále v paměti # SPRÁVNĚ: Přepsat před smazáním for i in range(len(private_key)): private_key[i] = 0 del private_key Security Audits Recommended Audits:\nCryptographic Review: Expert review of KDF chains and DH operations Implementation Audit: Code review for timing attacks, key management, RNG usage Protocol Analysis: Formal verification of handshake security properties Side-Channel Analysis: Timing, power, and cache attacks Fuzzing: Random input testing for parser robustness Test Cases:\n# Bezpečnostně kritické testovací případy def test_nonce_uniqueness(): \u0026#34;\u0026#34;\u0026#34;Ensure nonces are never reused\u0026#34;\u0026#34;\u0026#34; nonces = set() for i in range(10000): nonce = construct_nonce(i) assert nonce not in nonces nonces.add(nonce) def test_key_isolation(): \u0026#34;\u0026#34;\u0026#34;Ensure sessions don\u0026#39;t share keys\u0026#34;\u0026#34;\u0026#34; session1 = create_session(destination1) session2 = create_session(destination2) assert session1.key != session2.key def test_replay_prevention(): \u0026#34;\u0026#34;\u0026#34;Ensure replay attacks are detected\u0026#34;\u0026#34;\u0026#34; ns_message = create_ns_message() # First delivery succeeds assert process_ns_message(ns_message) == True # Replay fails assert process_ns_message(ns_message) == False def test_mac_verification(): \u0026#34;\u0026#34;\u0026#34;Ensure MAC verification is enforced\u0026#34;\u0026#34;\u0026#34; key = CSRNG(32) nonce = construct_nonce(0) plaintext = b\u0026#34;test\u0026#34; ad = b\u0026#34;test_ad\u0026#34; ciphertext = ENCRYPT(key, nonce, plaintext, ad) # Correct MAC verifies assert DECRYPT(key, nonce, ciphertext, ad) == plaintext # Corrupted MAC fails corrupted = ciphertext[:-1] + bytes([ciphertext[-1] ^ 0xFF]) with pytest.raises(AuthenticationError): DECRYPT(key, nonce, corrupted, ad) Configuration and Deployment I2CP Configuration Enable ECIES Encryption:\n# Pouze ECIES (Elliptic Curve Integrated Encryption Scheme – integrované šifrovací schéma na eliptických křivkách; doporučeno pro nová nasazení) i2cp.leaseSetEncType=4 # Dvouklíčový (ECIES + ElGamal pro kompatibilitu) i2cp.leaseSetEncType=4,0 # Pouze ElGamal (zastaralé, nedoporučuje se) i2cp.leaseSetEncType=0 LeaseSet Type:\n# Standardní LS2 (nejběžnější) i2cp.leaseSetType=3 # Šifrované LS2 (zaslepené destinace) i2cp.leaseSetType=5 # Meta LS2 (více destinací) i2cp.leaseSetType=7 Additional Options:\n# Statický klíč pro ECIES (schéma integrovaného šifrování na eliptických křivkách) (volitelný, automaticky se vygeneruje, pokud není uveden) # 32bajtový veřejný klíč X25519, zakódovaný v Base64 i2cp.leaseSetPrivateKey=\u0026lt;base64-encoded-key\u0026gt; # Typ podpisu (pro LeaseSet) i2cp.leaseSetSigningPrivateKey=\u0026lt;base64-encoded-key\u0026gt; i2cp.leaseSetSigningType=7 # Ed25519 Java I2P Configuration router.config:\n# ECIES mezi routery i2p.router.useECIES=true Build Properties:\n// Pro klienty I2CP (Java) Properties props = new Properties(); props.setProperty(\u0026#34;i2cp.leaseSetEncType\u0026#34;, \u0026#34;4\u0026#34;); props.setProperty(\u0026#34;i2cp.leaseSetType\u0026#34;, \u0026#34;3\u0026#34;); I2PSession session = i2pClient.createSession(props); i2pd Configuration i2pd.conf:\n[limity] # Paměťový limit pro relace ECIES (Elliptic Curve Integrated Encryption Scheme – šifrovací schéma využívající eliptické křivky) ecies.memory = 128M [ecies] # Povolit ECIES (integrované šifrování eliptických křivek) enabled = true # Pouze ECIES (Elliptic Curve Integrated Encryption Scheme) nebo dvouklíčové compatibility = true # true = dual-key (režim se dvěma klíči), false = pouze ECIES Tunnels Configuration:\n[my-service] type = http host = 127.0.0.1 port = 8080 keys = my-service-keys.dat # Pouze ECIES (schéma integrovaného šifrování s eliptickými křivkami) ecies = true Compatibility Matrix Router Version Support:\nVersion ECIES Support LS2 Support Dual-Key Notes \u0026lt; 0.9.38 ❌ No ❌ No N/A Legacy only 0.9.38-0.9.45 ❌ No ✅ Yes N/A LS2 only 0.9.46-0.9.50 ✅ Yes ✅ Yes ✅ Yes Initial ECIES 1.5.0+ ✅ Yes ✅ Yes ✅ Yes Current 2.0.0+ ✅ Yes ✅ Yes ✅ Yes Current Destination Compatibility:\nDestination Type Can Connect To Notes ECIES-only ECIES-only, Dual-key Requires 0.9.46+ routers Dual-key Any Maximum compatibility ElGamal-only ElGamal-only, Dual-key Legacy FloodFill Requirements:\nECIES-only destinations: Require majority of floodfills on 0.9.46+ for encrypted lookups Dual-key destinations: Work with any floodfill version Current status: Near 100% floodfill adoption as of 2025 Migration Guide Migrating from ElGamal to ECIES:\nStep 1: Enable Dual-Key Mode\n# Přidat ECIES při zachování ElGamalu i2cp.leaseSetEncType=4,0 Step 2: Monitor Connections\n# Zkontrolujte typy připojení i2prouter.exe status # nebo http://127.0.0.1:7657/peers Step 3: Switch to ECIES-Only (after testing)\n# Odstranit ElGamal i2cp.leaseSetEncType=4 Step 4: Restart Application\n# Restartujte I2P router nebo aplikaci systemctl restart i2p # nebo i2prouter.exe restart Rollback Plan:\n# V případě problémů se vraťte k režimu pouze ElGamal i2cp.leaseSetEncType=0 Performance Tuning Session Limits:\n# Maximální počet příchozích relací i2p.router.maxInboundSessions=1000 # Maximální počet odchozích relací i2p.router.maxOutboundSessions=1000 # Časový limit relace (sekundy) i2p.router.sessionTimeout=600 Memory Limits:\n# Limit pro ukládání značek (KB) i2p.ecies.maxTagMemory=10240 # 10 MB # Okno dopředného náhledu i2p.ecies.tagLookAhead=160 i2p.ecies.tagLookAheadMin=32 Ratchet Policy:\n# Zprávy před ratchet (kryptografický mechanismus průběžné obměny klíčů) i2p.ecies.ratchetThreshold=4096 # Čas do ratchet (mechanismus postupné obměny klíčů) (sekundy) i2p.ecies.ratchetTimeout=600 # 10 minut Monitoring and Debugging Logging:\n# Povolit ladicí protokolování pro ECIES (integrované šifrovací schéma založené na eliptických křivkách) logger.i2p.router.transport.ecies=DEBUG Metrics:\nMonitor these metrics:\nNS Success Rate: Percentage of NS messages receiving NSR Session Establishment Time: Time from NS to first ES Tag Storage Usage: Current memory usage for tags Ratchet Frequency: How often sessions ratchet Session Lifetime: Average session duration Common Issues:\nNS Timeout: No NSR received\nCheck destination is online Check floodfill availability Verify LeaseSet published correctly High Memory Usage: Too many tags stored\nReduce look-ahead window Decrease session timeout Implement aggressive expiration Frequent Ratchets: Sessions ratcheting too often\nIncrease ratchet threshold Check for retransmissions Session Failures: ES messages failing to decrypt\nVerify tag synchronization Check for replay attacks Validate nonce construction References Specifications ECIES Proposal: Proposal 144 I2NP: I2NP Specification Common Structures: Common Structures Specification NTCP2: NTCP2 Specification SSU2: SSU2 Specification I2CP: I2CP Specification ElGamal/AES+SessionTags: ElGamal/AES Specification Cryptographic Standards Noise Protocol Framework: Noise Specification (Revision 34, 2018-07-11) Signal Double Ratchet: Signal Specification RFC 7748: Elliptic Curves for Security (X25519) RFC 7539: ChaCha20 and Poly1305 for IETF Protocols RFC 5869: HKDF (HMAC-based Key Derivation Function) RFC 2104: HMAC: Keyed-Hashing for Message Authentication Elligator2: Elligator Paper Implementation Resources Java I2P: i2p.i2p Repository i2pd (C++): i2pd Repository OBFS4 (Elligator2): obfs4proxy Repository Additional Information I2P Website: / I2P Forum: https://i2pforum.net I2P Wiki: https://wiki.i2p-projekt.de Appendix A: KDF Summary All KDF Operations in ECIES:\nOperation Input Info String Output NS Initial ChainKey protocol_name (none - SHA256) h, chainKey NS Static Key Section chainKey, es_shared \"\" chainKey, k NS Payload Section (bound) chainKey, ss_shared \"\" chainKey, k NSR Tagset chainKey \"SessionReplyTags\" tagsetKey NSR ee DH chainKey, ee_shared \"\" chainKey NSR se DH chainKey, se_shared \"\" chainKey, k NSR Split chainKey \"\" k_ab, k_ba NSR Payload k_ba \"AttachPayloadKDF\" k_nsr DH Initialize rootKey, k \"KDFDHRatchetStep\" nextRootKey, chainKey Tag and Key Chain Keys chainKey \"TagAndKeyGenKeys\" sessTag_ck, symmKey_ck Session Tag Init sessTag_ck \"STInitialization\" chainKey, CONSTANT Session Tag Gen chainKey, CONSTANT \"SessionTagKeyGen\" chainKey, tag Symmetric Key Gen chainKey \"SymmetricRatchet\" chainKey, key DH Ratchet sharedSecret \"XDHRatchetTagSet\" tagsetKey Appendix B: Message Size Calculator Calculate message sizes for capacity planning:\ndef calculate_ns_size(payload_size, bound=True): \u0026#34;\u0026#34;\u0026#34;Calculate New Session message size\u0026#34;\u0026#34;\u0026#34; ephemeral_key = 32 static_section = 32 + 16 # encrypted + MAC payload_encrypted = payload_size + 16 # + MAC return ephemeral_key + static_section + payload_encrypted def calculate_nsr_size(payload_size): \u0026#34;\u0026#34;\u0026#34;Calculate New Session Reply message size\u0026#34;\u0026#34;\u0026#34; tag = 8 ephemeral_key = 32 key_section_mac = 16 payload_encrypted = payload_size + 16 # + MAC return tag + ephemeral_key + key_section_mac + payload_encrypted def calculate_es_size(payload_size): \u0026#34;\u0026#34;\u0026#34;Calculate Existing Session message size\u0026#34;\u0026#34;\u0026#34; tag = 8 payload_encrypted = payload_size + 16 # + MAC return tag + payload_encrypted # Příklady print(\u0026#34;NS (bound, 1KB payload):\u0026#34;, calculate_ns_size(1024, bound=True), \u0026#34;bytes\u0026#34;) # Výstup: 1120 bajtů print(\u0026#34;NSR (1KB užitečných dat):\u0026#34;, calculate_nsr_size(1024), \u0026#34;bajtů\u0026#34;) # Výstup: 1096 bajtů print(\u0026#34;ES (1 kB užitečných dat):\u0026#34;, calculate_es_size(1024), \u0026#34;bajtů\u0026#34;) # Výstup: 1048 bajtů Appendix C: Glossary AEAD: Authenticated Encryption with Associated Data - encryption mode that provides both confidentiality and authenticity\nAuthentication Level: Noise protocol security property indicating strength of sender identity verification\nBinding: Association of a session with a specific far-end destination\nChaCha20: Stream cipher designed by Daniel J. Bernstein\nChainKey: Cryptographic key used in HKDF chains to derive subsequent keys\nConfidentiality Level: Noise protocol security property indicating strength of forward secrecy\nDH: Diffie-Hellman key agreement protocol\nElligator2: Encoding technique to make elliptic curve points indistinguishable from random\nEphemeral Key: Short-lived key used only for a single handshake\nES: Existing Session message (used after handshake completion)\nForward Secrecy: Property ensuring past communications remain secure if keys are compromised\nGarlic Clove: I2NP message container for end-to-end delivery\nHKDF: HMAC-based Key Derivation Function\nIK Pattern: Noise handshake pattern where initiator sends static key immediately\nKCI: Key Compromise Impersonation attack\nKDF: Key Derivation Function - cryptographic function for generating keys from other keys\nLeaseSet: I2P structure containing a destination\u0026rsquo;s public keys and tunnel information\nLS2: LeaseSet version 2 with encryption type support\nMAC: Message Authentication Code - cryptographic checksum proving authenticity\nMixHash: Noise protocol function for maintaining running hash transcript\nNS: New Session message (initiates new session)\nNSR: New Session Reply message (response to NS)\nNonce: Number used once - ensures unique encryption even with same key\nPairing: Linking an inbound session with an outbound session for bidirectional communication\nPoly1305: Message authentication code designed by Daniel J. Bernstein\nRatchet: Cryptographic mechanism for deriving sequential keys\nSession Tag: 8-byte one-time identifier for existing session messages\nStatic Key: Long-term key associated with a destination\u0026rsquo;s identity\nTag Set: Collection of session tags derived from a common root\nX25519: Elliptic curve Diffie-Hellman key agreement using Curve25519\n","description":"Integrované šifrovací schéma na eliptických křivkách pro I2P (X25519 + AEAD)","id":"82b727dd29ed7e2e04873dac8c2acf51","section":"docs","title":"Specifikace šifrování ECIES-X25519-AEAD-Ratchet (ráčnování)","url":"/cs/docs/specs/ecies/"},{"categories":null,"content":"Přehled Tento dokument specifikuje základní datové struktury používané napříč všemi protokoly I2P, včetně I2NP , I2CP , SSU2 , NTCP2 a dalších. Tyto společné struktury zajišťují interoperabilitu mezi různými implementacemi I2P a vrstvami protokolu.\nHlavní změny od verze 0.9.58 ElGamal a DSA-SHA1 jsou pro Router Identities zastaralé (použijte X25519 + EdDSA) Podpora postkvantového ML-KEM je v beta testování (opt-in (volitelné zapnutí) od verze 2.10.0) Možnosti záznamu služby byly standardizovány (Proposal 167 , implementováno ve verzi 0.9.66) Specifikace komprimovatelné výplně byly finalizovány (Proposal 161 , implementováno ve verzi 0.9.57) Obecné specifikace typů Celé číslo Popis: Představuje nezáporné celé číslo v síťovém pořadí bajtů (big-endian).\nObsah: 1 až 8 bajtů představujících neznaménkové celé číslo.\nPoužití: Délky polí, počty, identifikátory typů a číselné hodnoty napříč protokoly I2P.\nDatum Popis: Časové razítko udávající počet milisekund od unixové epochy (1. ledna 1970 00:00:00 GMT).\nObsah: 8bajtové celé číslo (neznaménkový long)\nSpeciální hodnoty: - 0 = nedefinované nebo nulové datum - Maximální hodnota: 0xFFFFFFFFFFFFFFFF (rok 584,942,417,355)\nPoznámky k implementaci: - Vždy časové pásmo UTC/GMT - Je vyžadována milisekundová přesnost - Používá se pro vypršení platnosti lease (I2P: záznam s dobou platnosti), publikaci RouterInfo (metadata o routeru) a ověření časových razítek\nŘetězec Popis: Řetězec kódovaný v UTF‑8 s délkovým prefixem.\nFormát:\n+----+----+----+----+----+----+ |len | UTF-8 encoded data... | +----+----+----+----+----+----+ len :: Integer (1 byte) Value: 0-255 (string length in bytes, NOT characters) data :: UTF-8 encoded bytes Length: 0-255 bytes Omezení: - Maximální délka: 255 bajtů (nikoli znaky - vícebajtové sekvence UTF-8 se počítají jako více bajtů) - Délka může být nula (prázdný řetězec) - Nulový terminátor NENÍ zahrnut - Řetězec NENÍ ukončen nulou\nDůležité: Sekvence UTF-8 mohou používat více bajtů na jeden znak. Řetězec se 100 znaky může překročit limit 255 bajtů, pokud používá vícebajtové znaky.\nStruktury kryptografických klíčů Veřejný klíč Popis: Veřejný klíč pro asymetrické šifrování. Typ a délka klíče jsou závislé na kontextu nebo jsou uvedeny v Key Certificate (certifikátu klíče).\nVýchozí typ: ElGamal (zastaralé pro Router Identities (identit routeru) od verze 0.9.58)\nPodporované typy:\nType Code Length (bytes) Since Endianness Usage Status ElGamal0256-BigDestinations only (unused field)Deprecated for RIs P256164TBDBigReservedSee Proposal 145 P384296TBDBigReservedSee Proposal 145 P5213132TBDBigReservedSee Proposal 145 X255194320.9.38LittleCurrent standardRecommended MLKEM512_X255195320.9.67MixedHybrid PQ, LeaseSets onlyBeta MLKEM768_X255196320.9.67MixedHybrid PQ, LeaseSets onlyBeta MLKEM1024_X255197320.9.67MixedHybrid PQ, LeaseSets onlyBeta MLKEM512-8000.9.67TBDHandshakes onlyBeta MLKEM768-11840.9.67TBDHandshakes onlyBeta MLKEM1024-15680.9.67TBDHandshakes onlyBeta MLKEM512_CT-7680.9.67TBDHandshakes onlyBeta MLKEM768_CT-10880.9.67TBDHandshakes onlyBeta MLKEM1024_CT-15680.9.67TBDHandshakes onlyBeta **Požadavky na implementaci:** X25519 (Type 4) - aktuální standard:\nPoužívá se pro šifrování ECIES-X25519-AEAD-Ratchet Povinné pro identity routeru od verze 0.9.48 Kódování little-endian (na rozdíl od ostatních typů) Viz ECIES a ECIES-ROUTERS ElGamal (Type 0) - zastaralé:\nOznačeno jako zastaralé pro Router Identities od verze 0.9.58 Stále platné pro destinace (pole se nepoužívá od 0.6/2005) Používá konstantní prvočísla definovaná ve specifikaci ElGamal Podpora je udržována kvůli zpětné kompatibilitě MLKEM (postkvantové) - Beta:\nHybridní přístup kombinuje ML-KEM s X25519 NENÍ ve výchozím nastavení povoleno ve verzi 2.10.0 Vyžaduje ruční aktivaci prostřednictvím Hidden Service Manager (správce skrytých služeb) Viz ECIES-HYBRID a Návrh 169 Kódy typů a specifikace podléhají změnám JavaDoc: PublicKey Soukromý klíč Popis: Soukromý klíč pro asymetrické dešifrování, odpovídající typům PublicKey.\nÚložiště: Typ a délka jsou odvozeny z kontextu nebo uloženy odděleně v datových strukturách/souborech s klíči.\nPodporované typy:\nType Code Length (bytes) Since Endianness Usage Status ElGamal0256-BigDestinations onlyDeprecated for RIs P256132TBDBigReservedSee Proposal 145 P384248TBDBigReservedSee Proposal 145 P521366TBDBigReservedSee Proposal 145 X255194320.9.38LittleCurrent standardRecommended MLKEM512_X255195320.9.67MixedHybrid PQ, LeaseSets onlyBeta MLKEM768_X255196320.9.67MixedHybrid PQ, LeaseSets onlyBeta MLKEM1024_X255197320.9.67MixedHybrid PQ, LeaseSets onlyBeta MLKEM512-16320.9.67TBDHandshakes onlyBeta MLKEM768-24000.9.67TBDHandshakes onlyBeta MLKEM1024-31680.9.67TBDHandshakes onlyBeta **Bezpečnostní poznámky:** - Soukromé klíče MUSÍ být generovány pomocí kryptograficky bezpečných generátorů náhodných čísel - Soukromé klíče X25519 používají scalar clamping (úprava bitů skaláru) podle definice v RFC 7748 - Klíčový materiál MUSÍ být bezpečně vymazán z paměti, když již není potřeba JavaDoc: PrivateKey SessionKey (klíč relace) Popis: Symetrický klíč pro šifrování a dešifrování AES-256 v I2P v rámci tunnel a garlic encryption.\nObsah: 32 bajtů (256 bitů)\nPoužití: - Šifrování vrstvy tunnel (AES-256/CBC s IV) - Garlic message encryption (šifrování zpráv metodou garlic) - End-to-end šifrování relace\nGenerování: MUSÍ použít kryptograficky bezpečný generátor náhodných čísel.\nJavaDoc: SessionKey SigningPublicKey Popis: Veřejný klíč pro ověření podpisu. Typ a délka jsou specifikovány v Key Certificate of Destination (certifikátu klíče objektu Destination) nebo odvozeny z kontextu.\nVýchozí typ: DSA_SHA1 (zastaralé od verze 0.9.58)\nPodporované typy:\nType Code Length (bytes) Since Endianness Usage Status DSA_SHA10128-BigLegacy onlyDeprecated ECDSA_SHA256_P2561640.9.12BigOlder DestinationsDeprecated ECDSA_SHA384_P3842960.9.12BigRareDeprecated ECDSA_SHA512_P52131320.9.12BigRareDeprecated RSA_SHA256_204842560.9.12BigOffline signing onlyDeprecated RSA_SHA384_307253840.9.12BigOffline signing onlyDeprecated RSA_SHA512_409665120.9.12BigOffline signing onlyRecommended for SU3 EdDSA_SHA512_Ed255197320.9.15LittleCurrent standardRecommended EdDSA_SHA512_Ed25519ph8320.9.25LittleOffline signing onlyRare RedDSA_SHA512_Ed2551911320.9.39LittleEncrypted leasesets onlySpecialized Reserved (GOST)964-BigReservedProposal 134 Reserved (GOST)10128-BigReservedProposal 134 Reserved (MLDSA)12-20TBD-TBDReservedProposal 169 Experimental65280-65534Varies-VariesTesting onlyNever production Reserved65535---Future expansion- **Požadavky na implementaci:** EdDSA_SHA512_Ed25519 (Typ 7) - Aktuální standard:\nVýchozí pro všechny nové identity routeru a destinace od konce roku 2015 Používá křivku Ed25519 s hashovací funkcí SHA-512 32bajtové veřejné klíče, 64bajtové podpisy Kódování little-endian (na rozdíl od většiny ostatních typů) Vysoký výkon a bezpečnost RedDSA_SHA512_Ed25519 (Type 11) - Specializované:\nPoužíváno POUZE pro šifrované leasesets a zaslepení (blinding) Nikdy se nepoužívá pro identity routeru ani pro standardní destinace Hlavní rozdíly oproti EdDSA: Odvozování soukromých klíčů prováděno modulární redukcí (nikoli clamping [bitové upnutí]) Podpisy zahrnují 80 bajtů náhodných dat Používá veřejné klíče přímo (nikoli hashů soukromých klíčů) Viz [Specifikace Red25519](//docs/specs/red25519-signature-scheme/ DSA_SHA1 (Typ 0) - Historické:\nZastaralé pro identity routeru od verze 0.9.58 Nedoporučeno pro nové Destinace 1024bitové DSA se SHA-1 (známé slabiny) Podpora je zachována pouze kvůli kompatibilitě Víceprvkové klíče:\nPokud se skládají ze dvou prvků (např. souřadnice bodu ECDSA X,Y) Každý prvek je doplněn na délku/2 počátečními nulami Příklad: 64bajtový klíč ECDSA = 32 bajtů X + 32 bajtů Y JavaDoc: SigningPublicKey SigningPrivateKey Popis: Soukromý klíč pro vytváření podpisů, odpovídající typům SigningPublicKey.\nÚložiště: Typ a délka jsou určeny při vytvoření.\nPodporované typy:\nType Code Length (bytes) Since Endianness Usage Status DSA_SHA1020-BigLegacy onlyDeprecated ECDSA_SHA256_P2561320.9.12BigOlder DestinationsDeprecated ECDSA_SHA384_P3842480.9.12BigRareDeprecated ECDSA_SHA512_P5213660.9.12BigRareDeprecated RSA_SHA256_204845120.9.12BigOffline signing onlyDeprecated RSA_SHA384_307257680.9.12BigOffline signing onlyDeprecated RSA_SHA512_4096610240.9.12BigOffline signing onlyRecommended for SU3 EdDSA_SHA512_Ed255197320.9.15LittleCurrent standardRecommended EdDSA_SHA512_Ed25519ph8320.9.25LittleOffline signing onlyRare RedDSA_SHA512_Ed2551911320.9.39LittleEncrypted leasesets onlySpecialized **Požadavky na zabezpečení:** - Generovat s použitím kryptograficky bezpečného zdroje náhodnosti - Chránit pomocí vhodného řízení přístupu - Po dokončení bezpečně vymazat z paměti - Pro EdDSA: 32bajtový seed zahashovaný pomocí SHA-512, prvních 32 bajtů tvoří skalár (clamped – bitově upraveno dle specifikace) - Pro RedDSA: Odlišný způsob generování klíče (modulární redukce místo clamping) JavaDoc: SigningPrivateKey Podpis Popis: Kryptografický podpis nad daty, s využitím podpisového algoritmu, který odpovídá typu SigningPrivateKey.\nTyp a délka: Určeno podle typu klíče použitého pro podepisování.\nPodporované typy:\nType Code Length (bytes) Since Endianness Usage Status DSA_SHA1040-BigLegacy onlyDeprecated ECDSA_SHA256_P2561640.9.12BigOlder DestinationsDeprecated ECDSA_SHA384_P3842960.9.12BigRareDeprecated ECDSA_SHA512_P52131320.9.12BigRareDeprecated RSA_SHA256_204842560.9.12BigOffline signing onlyDeprecated RSA_SHA384_307253840.9.12BigOffline signing onlyDeprecated RSA_SHA512_409665120.9.12BigOffline signing onlyCurrent for SU3 EdDSA_SHA512_Ed255197640.9.15LittleCurrent standardRecommended EdDSA_SHA512_Ed25519ph8640.9.25LittleOffline signing onlyRare RedDSA_SHA512_Ed2551911640.9.39LittleEncrypted leasesets onlySpecialized **Poznámky k formátu:** - Víceprvkové podpisy (např. hodnoty R,S u ECDSA) se pro každý prvek doplňují úvodními nulami na délku length/2 - EdDSA a RedDSA používají kódování little-endian (pořadí bajtů s nejméně významným bajtem první) - Všechny ostatní typy používají kódování big-endian (pořadí bajtů s nejvíce významným bajtem první) Ověření: - Použijte odpovídající SigningPublicKey - Postupujte podle specifikací algoritmu podpisu pro daný typ klíče - Zkontrolujte, že délka podpisu odpovídá očekávané délce pro daný typ klíče\nJavaDoc: Signature Otisk Description: SHA-256 hash dat, používaný v celém I2P k ověřování integrity a identifikaci.\nObsah: 32 bajtů (256 bitů)\nAlgoritmus: SHA-256 podle FIPS 180-4\nJavaDoc: Hash Session Tag (značka relace) Popis: Náhodné číslo používané pro identifikaci relace a šifrování založené na značkách.\nDůležité: Velikost Session Tagu (značka relace) se liší podle typu šifrování: - ElGamal/AES+SessionTag: 32 bajtů (starší) - ECIES-X25519: 8 bajtů (současný standard)\nAktuální standard (ECIES – integrované šifrovací schéma eliptických křivek):\nContents: 8 bytes Usage: Ratchet-based encryption for Destinations and Routers Viz ECIES a ECIES-ROUTERS pro podrobné specifikace.\nZastaralé (ElGamal/AES):\nContents: 32 bytes Usage: Deprecated encryption scheme Generování: MUSÍ používat kryptograficky bezpečný generátor náhodných čísel.\nJavaDoc: SessionTag TunnelId Popis: Jedinečný identifikátor pozice routeru v tunnelu. Každý hop v tunnelu má svůj vlastní TunnelId (identifikátor hopu v tunnelu).\nFormát:\nContents: 4-byte Integer (unsigned 32-bit) Range: Generally \u0026gt; 0 (zero reserved for special cases) Použití: - Identifikuje příchozí/odchozí spojení v rámci tunnel pro každý router - Odlišné TunnelId na každém skoku v řetězci tunnel - Používá se ve strukturách Lease (I2P záznam o přístupu do tunnel) k identifikaci vstupních tunnel\nSpeciální hodnoty: - 0 = Vyhrazeno pro speciální účely protokolu (nepoužívat při běžném provozu) - TunnelIds mají lokální platnost pro každý router\nJavaDoc: TunnelId Specifikace certifikátů Certifikát Popis: Kontejner pro potvrzení, proof-of-work (důkaz práce) nebo kryptografická metadata používaný v celém I2P.\nFormát:\n+----+----+----+----+----+----+-// |type| length | payload +----+----+----+----+----+----+-// type :: Integer (1 byte) Values: 0-5 (see types below) length :: Integer (2 bytes, big-endian) Size of payload in bytes payload :: data length -\u0026gt; $length bytes Celková velikost: minimálně 3 bajty (NULL certificate – certifikát typu NULL), maximálně 65538 bajtů\nTypy certifikátů Type Code Payload Length Total Size Status Usage NULL003CurrentDefault/empty certificate HASHCASH1VariesVariesDeprecatedUnused (was for proof-of-work) HIDDEN203DeprecatedUnused (hidden routers don't advertise) SIGNED340 or 7243 or 75DeprecatedUnused (DSA signature ± destination hash) MULTIPLE4VariesVariesDeprecatedUnused (multiple certificates) KEY54+7+CurrentSpecifies key types (see below) ### Certifikát klíče (typ 5) Úvod: Verze 0.9.12 (prosinec 2013)\nÚčel: Určuje nevýchozí typy klíčů a ukládá dodatečná data klíče nad rámec standardní 384bajtové struktury KeysAndCert.\nStruktura užitečných dat:\n+----+----+----+----+----+----+----+----+-// |SPKtype|CPKtype| Excess SPK data | +----+----+----+----+----+----+----+----+-// | Excess CPK data... | +----+----+----+----+----+----+----+----+ SPKtype :: Signing Public Key Type (2 bytes) See SigningPublicKey table above CPKtype :: Crypto Public Key Type (2 bytes) See PublicKey table above Excess SPK data :: Signing key bytes beyond 128 bytes Length: 0 to 65531 bytes Excess CPK data :: Crypto key bytes beyond 256 bytes Length: 0 to remaining space Zásadní implementační poznámky:\nPořadí typů klíčů:\nUPOZORNĚNÍ: Typ podpisového klíče je PŘED typem kryptografického klíče Je to neintuitivní, ale je to zachováno kvůli kompatibilitě Pořadí: SPKtype, CPKtype (ne CPKtype, SPKtype) Uspořádání dat klíčů v KeysAndCert:\n[Crypto Public Key (partial/complete)] [Padding (if total key lengths \u0026lt; 384)] [Signing Public Key (partial/complete)] [Certificate Header (3 bytes)] [Key Certificate (4+ bytes)] [Excess Signing Key Data] [Excess Crypto Key Data] Výpočet přebytečných dat klíče:\nPokud Crypto Key \u0026gt; 256 bajtů: Excess = (Crypto Length - 256) Pokud Signing Key \u0026gt; 128 bajtů: Excess = (Signing Length - 128) Padding = max(0, 384 - Crypto Length - Signing Length) Příklady (kryptografický klíč ElGamal):\nSigning Key Type Total SPK Length Padding Excess in Cert Total Structure Size DSA_SHA112800387 + 7 = 394 ECDSA_P25664640387 + 7 = 394 ECDSA_P38496320387 + 7 = 394 ECDSA_P52113204387 + 11 = 398 RSA_20482560128387 + 135 = 522 RSA_40965120384387 + 391 = 778 EdDSA32960387 + 7 = 394 **Požadavky na identitu pro router:** - NULL certificate (prázdný certifikát) používán do verze 0.9.15 - Key Certificate (certifikát klíče) vyžadován pro nevýchozí typy klíčů od verze 0.9.16 - Šifrovací klíče X25519 podporovány od verze 0.9.48 Požadavky na Destination (identifikátor cíle v I2P): - NULL certifikát NEBO Key Certificate (dle potřeby) - Key Certificate (certifikát s klíčem) vyžadován pro nevýchozí typy podpisových klíčů od verze 0.9.12 - Pole veřejného kryptografického klíče se od verze 0.6 (2005) nepoužívá, ale stále musí být přítomno\nDůležitá varování:\nNULL vs. KEY certifikát:\nCertifikát KEY s typy (0,0) určujícími ElGamal+DSA_SHA1 je povolen, ale nedoporučuje se Pro ElGamal+DSA_SHA1 vždy používejte certifikát NULL (kanonická reprezentace) Certifikát KEY s (0,0) je o 4 bajty delší a může způsobit problémy s kompatibilitou Některé implementace nemusí certifikáty KEY s (0,0) zpracovávat správně Validace nadbytečných dat:\nImplementace MUSÍ ověřovat, že délka certifikátu odpovídá očekávané délce pro dané typy klíčů Odmítat certifikáty s nadbytečnými daty, která neodpovídají typům klíčů Zakázat koncová odpadní data po platné struktuře certifikátu JavaDoc: Certificate Mapování Popis: Soubor dvojic klíč–hodnota používaný pro konfiguraci a metadata.\nFormát:\n+----+----+----+----+----+----+----+----+ | size | key_string (len + data)| = | +----+----+----+----+----+----+----+----+ | val_string (len + data) | ; | ... +----+----+----+----+----+----+----+ size :: Integer (2 bytes, big-endian) Total number of bytes that follow (not including size field) Range: 0 to 65535 key_string :: String Format: 1-byte length + UTF-8 data Length: 0-255 bytes = :: Single byte (0x3D, \u0026#39;=\u0026#39; character) val_string :: String Format: 1-byte length + UTF-8 data Length: 0-255 bytes ; :: Single byte (0x3B, \u0026#39;;\u0026#39; character) [Repeat key_string = val_string ; for additional entries] Limity velikosti: - Délka klíče: 0-255 bajtů (+ 1 bajt pro délku) - Délka hodnoty: 0-255 bajtů (+ 1 bajt pro délku) - Celková velikost mapování: 0-65535 bajtů (+ 2 bajty pole velikosti) - Maximální velikost struktury: 65537 bajtů\nZásadní požadavek na řazení:\nKdyž se mapování vyskytují v podepsaných strukturách (RouterInfo, RouterAddress, Destination properties, I2CP SessionConfig), položky MUSÍ být seřazeny podle klíče, aby byla zajištěna invariance podpisu:\nMetoda řazení: Lexikografické pořadí podle hodnot kódových bodů Unicode (ekvivalentní k Java String.compareTo()) Rozlišování velikosti písmen: Klíče a hodnoty obecně rozlišují velikost písmen (závisí na aplikaci) Duplicitní klíče: NEJSOU povoleny v podepsaných strukturách (způsobí selhání ověření podpisu) Kódování znaků: Porovnávání na úrovni bajtů v UTF-8 Proč na řazení záleží: - Podpisy se počítají na základě bajtové reprezentace - Různá pořadí klíčů vedou k různým podpisům - Nepodepsaná mapování nevyžadují řazení, ale měla by se řídit stejnou konvencí\nPoznámky k implementaci:\nRedundance v kódování:\nJsou přítomny jak oddělovače = a ;, tak i bajty délky řetězce Je to neefektivní, ale kvůli kompatibilitě je to zachováno Bajty délky jsou směrodatné; oddělovače jsou vyžadovány, ale jsou nadbytečné Podpora znaků:\nNavzdory dokumentaci jsou = a ; UVNITŘ ŘETĚZCŮ PODPOROVÁNY (o to se starají délkové bajty) Kódování UTF-8 podporuje celý Unicode Upozornění: I2CP používá UTF-8, ale I2NP historicky nezpracovával UTF-8 správně Pro maximální kompatibilitu používejte pro I2NP mapování pokud možno ASCII Zvláštní kontexty:\nRouterInfo/RouterAddress: (informace a adresa routeru) MUSÍ být seřazeny, bez duplicit I2CP SessionConfig: (konfigurace relace I2CP) MUSÍ být seřazeno, bez duplicit Mapování aplikací: Řazení je doporučeno, ale ne vždy vyžadováno Příklad (možnosti RouterInfo):\nMapping size: 45 bytes Sorted entries: caps=L (capabilities) netId=2 (network ID) router.version=0.9.67 JavaDoc: DataHelper Specifikace společné struktury Klíče a certifikát Popis: Základní struktura kombinující šifrovací klíč, podpisový klíč a certifikát. Používá se jako RouterIdentity i jako Destination.\nStruktura:\n+----+----+----+----+----+----+----+----+ | public_key | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | padding (optional) | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | signing_key | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | certificate | +----+----+----+-// public_key :: PublicKey (partial or full) Default: 256 bytes (ElGamal) Other sizes: As specified in Key Certificate padding :: Random data Length: 0 bytes or as needed CONSTRAINT: public_key + padding + signing_key = 384 bytes signing_key :: SigningPublicKey (partial or full) Default: 128 bytes (DSA_SHA1) Other sizes: As specified in Key Certificate certificate :: Certificate Minimum: 3 bytes (NULL certificate) Common: 7 bytes (Key Certificate with default keys) TOTAL LENGTH: 387+ bytes (never assume exactly 387!) Zarovnání klíčů: - Veřejný kryptografický klíč: Zarovnaný na začátku (bajt 0) - Vycpávka: Uprostřed (pokud je potřeba) - Veřejný klíč pro podpis: Zarovnaný na konci (bajt 256 až bajt 383) - Certifikát: Začíná na bajtu 384\nVýpočet velikosti:\nTotal size = 384 + 3 + key_certificate_length For NULL certificate (ElGamal + DSA_SHA1): Total = 384 + 3 = 387 bytes For Key Certificate (EdDSA + X25519): Total = 384 + 3 + 4 = 391 bytes For larger keys (e.g., RSA_4096): Total = 384 + 3 + 4 + excess_key_data_length Pokyny pro generování vycpávky (Návrh 161 ) Verze implementace: 0.9.57 (leden 2023, vydání 2.1.0)\nPozadí: - U klíčů jiných než ElGamal+DSA je výplň přítomna v pevné struktuře o velikosti 384 bajtů - U Destinations (cílové identifikátory v I2P) je pole veřejného klíče o velikosti 256 bajtů nevyužité od verze 0.6 (2005) - Výplň by měla být generována tak, aby byla komprimovatelná a přitom zůstala bezpečná\nPožadavky:\nMinimální množství náhodných dat:\nPoužijte alespoň 32 bajtů kryptograficky bezpečných náhodných dat To poskytuje dostatečnou entropii pro zajištění bezpečnosti Strategie komprese:\nOpakujte těch 32 bajtů napříč polem výplně/veřejného klíče Protokoly jako I2NP Database Store, Streaming SYN, SSU2 handshake používají kompresi Výrazná úspora šířky pásma bez ohrožení bezpečnosti Příklady:\nRouter identita (X25519 + EdDSA):\nStructure: - 32 bytes X25519 public key - 320 bytes padding (10 copies of 32-byte random data) - 32 bytes EdDSA public key - 7 bytes Key Certificate Compression savings: ~288 bytes when compressed Cíl (ElGamal-unused + EdDSA):\nStructure: - 256 bytes unused ElGamal field (11 copies of 32-byte random data, truncated to 256) - 96 bytes padding (3 copies of 32-byte random data) - 32 bytes EdDSA public key - 7 bytes Key Certificate Compression savings: ~320 bytes when compressed Proč to funguje:\nHash SHA-256 celé struktury stále zahrnuje veškerou entropii Distribuce DHT síťové databáze závisí pouze na hashi Podepisovací klíč (32 bajtů EdDSA/X25519) poskytuje 256 bitů entropie Dalších 32 bajtů opakovaných náhodných dat = celkem 512 bitů entropie Více než dostačující pro kryptografickou odolnost Poznámky k implementaci:\nMUSÍ ukládat a přenášet celou strukturu o velikosti 387+ bajtů Hash SHA-256 se počítá nad kompletní nekomprimovanou strukturou Komprese se aplikuje na úrovni protokolu (I2NP, Streaming, SSU2) Zpětně kompatibilní se všemi verzemi od 0.6 (2005) JavaDoc: KeysAndCert RouterIdentity (identita routeru) Popis: Jednoznačně identifikuje router (směrovač) v síti I2P. Stejná struktura jako KeysAndCert.\nFormát: Viz strukturu KeysAndCert výše\nAktuální požadavky (k verzi 0.9.58):\nPovinné typy klíčů:\nŠifrování: X25519 (typ 4, 32 bajtů) Podepisování: EdDSA_SHA512_Ed25519 (typ 7, 32 bajtů) Certifikát: Certifikát klíče (typ 5) Zastaralé typy klíčů:\nElGamal (typ 0) označen jako zastaralý pro identity routerů od verze 0.9.58 DSA_SHA1 (typ 0) označen jako zastaralý pro identity routerů od verze 0.9.58 Tyto by NEMĚLY být používány pro nové routery Typická velikost:\nX25519 + EdDSA s certifikátem klíče = 391 bajtů 32 bajtů veřejného klíče X25519 320 bajtů výplně (komprimovatelná podle Proposal 161 ) 32 bajtů veřejného klíče EdDSA 7 bajtů certifikátu (3bajtová hlavička + 4 bajty typů klíčů) Historický vývoj: - Před 0.9.16: Vždy nulový certifikát (ElGamal + DSA_SHA1) - 0.9.16-0.9.47: Přidána podpora pro Key Certificate (typ certifikátu určující typ klíče) - 0.9.48+: Podpora šifrovacích klíčů X25519 - 0.9.58+: ElGamal a DSA_SHA1 zastaralé\nKlíč síťové databáze: - RouterInfo (záznam s informacemi o routeru v I2P) je indexován pomocí SHA-256 hashe úplného RouterIdentity - Hash je vypočten nad celou strukturou o 391+ bajtech (včetně výplně)\nViz také: - Pokyny pro generování paddingu (vycpávky) (Proposal 161 ) - Specifikace Key Certificate výše\nJavaDoc: RouterIdentity Cíl Popis: Identifikátor koncového bodu pro bezpečné doručování zpráv. Strukturálně totožný s KeysAndCert, ale s odlišnou sémantikou použití.\nFormát: Viz strukturu KeysAndCert výše\nZásadní rozdíl oproti RouterIdentity: - Pole veřejného klíče se NEPOUŽÍVÁ a může obsahovat náhodná data - Toto pole se nepoužívá od verze 0.6 (2005) - Původně bylo určeno pro staré šifrování I2CP-to-I2CP (zakázáno) - Aktuálně slouží pouze jako IV (inicializační vektor) pro zastaralé šifrování LeaseSet\nAktuální doporučení:\nPodpisový klíč:\nDoporučeno: EdDSA_SHA512_Ed25519 (typ 7, 32 bajtů) Alternativy: typy ECDSA pro zachování kompatibility se staršími verzemi Vyhněte se: DSA_SHA1 (zastaralé, nedoporučuje se) Šifrovací klíč:\nPole se nepoužívá, ale musí být přítomné Doporučeno: Vyplňte náhodnými daty dle Proposal 161 (komprimovatelná) Velikost: vždy 256 bajtů (slot pro ElGamal, i když se ElGamal nepoužívá) Certifikát:\nNULL certificate pro ElGamal + DSA_SHA1 (jen pro starší verze) Key Certificate pro všechny ostatní typy podpisových klíčů Typický moderní cíl:\nStructure: - 256 bytes unused field (random data, compressible) - 96 bytes padding (random data, compressible) - 32 bytes EdDSA signing public key - 7 bytes Key Certificate Total: 391 bytes Compression savings: ~320 bytes Skutečný šifrovací klíč: - Šifrovací klíč pro Destination (cílový identifikátor) je v LeaseSet, nikoli v Destination - LeaseSet obsahuje aktuální veřejné šifrovací klíče - Viz specifikaci LeaseSet2 pro nakládání se šifrovacími klíči\nKlíč síťové databáze: - LeaseSet je indexován podle hashe SHA-256 celého Destination (cílového identifikátoru) - Hash je vypočítán nad celou strukturou o velikosti 387+ bajtů\nJavaDoc: Destination Struktury síťové databáze Pronájem Popis: Oprávňuje konkrétní tunnel přijímat zprávy pro Destination (cílový identifikátor). Součást původního formátu LeaseSet (typ 1).\nFormát:\n+----+----+----+----+----+----+----+----+ | tunnel_gw | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ | tunnel_id | end_date +----+----+----+----+----+----+----+----+ | +----+----+----+----+ tunnel_gw :: Hash (32 bytes) SHA-256 hash of the gateway RouterIdentity tunnel_id :: TunnelId (4 bytes) Tunnel identifier at the gateway router end_date :: Date (8 bytes) Expiration timestamp in milliseconds since epoch Celková velikost: 44 bajtů\nPoužití: - Používá se pouze v původním LeaseSet (typ 1, zastaralý) - Pro LeaseSet2 a pozdější varianty použijte místo toho Lease2\nJavaDoc: Lease LeaseSet (Typ 1) Popis: Původní formát LeaseSet. Obsahuje autorizované tunnels a klíče pro Destination (identifikátor cíle v I2P). Uloženo v síťové databázi. Stav: Zastaralé (místo toho použijte LeaseSet2).\nStruktura:\n+----+----+----+----+----+----+----+----+ | destination | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | encryption_key | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | signing_key | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | num| Lease 0 | +----+ + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | Lease 1 | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | Lease ($num-1) | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | signature | + + | | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ destination :: Destination Length: 387+ bytes encryption_key :: PublicKey (256 bytes, ElGamal) Used for end-to-end ElGamal/AES+SessionTag encryption Generated anew at each router startup (not persistent) signing_key :: SigningPublicKey (128+ bytes) Same type as Destination signing key Used for LeaseSet revocation (unimplemented) Generated anew at each router startup (not persistent) num :: Integer (1 byte) Number of Leases to follow Range: 0-16 leases :: Array of Lease structures Length: $num × 44 bytes Each Lease is 44 bytes signature :: Signature (40+ bytes) Length determined by Destination signing key type Signed by Destination\u0026#39;s SigningPrivateKey Uložení v databázi: - Typ databáze: 1 - Klíč: SHA-256 hash destinace - Hodnota: Úplná struktura LeaseSet\nDůležité poznámky:\nVeřejný klíč Destination (cílový identifikátor v I2P) se nepoužívá:\nPole veřejného klíče pro šifrování v Destination se nepoužívá Šifrovací klíč v LeaseSet je skutečný šifrovací klíč Dočasné klíče:\nencryption_key je dočasný (znovu vygenerován při startu routeru) signing_key je dočasný (znovu vygenerován při startu routeru) Ani jeden z klíčů se neuchovává napříč restarty Revokace (neimplementováno):\nsigning_key byl zamýšlen pro revokaci LeaseSetu Mechanismus revokace nebyl nikdy implementován LeaseSet s nulovým počtem lease (časově omezených záznamů) byl zamýšlen pro revokaci, ale není používán Verzování/časové razítko:\nLeaseSet nemá žádné explicitní pole časového razítka published Verze je nejbližší okamžik vypršení platnosti ze všech leases (technické záznamy o tunelech v I2P) Nový LeaseSet musí mít dřívější dobu vypršení platnosti lease, aby byl přijat Zveřejňování expirace lease (dočasného záznamu pro tunnel):\nPřed 0.9.7: Všechny lease byly zveřejněny se stejnou expirací (nejdřívější) 0.9.7+: Zveřejňují se skutečné expirace jednotlivých lease Toto je detail implementace, nikoli součást specifikace Nulový počet leases:\nLeaseSet s nulovým počtem leases (Lease – časově omezený záznam) je technicky povoleno Určeno pro revokaci (neimplementováno) V praxi se nepoužívá Varianty LeaseSet2 vyžadují alespoň jeden Lease Zastarání: LeaseSet typu 1 je zastaralý. Nové implementace by měly používat LeaseSet2 (typ 3) který poskytuje: - Pole s časovým razítkem publikace (lepší verzování) - Podpora více šifrovacích klíčů - Možnost offline podpisu - 4bajtové expirace lease (oproti 8bajtovým) - Flexibilnější možnosti\nJavaDoc: LeaseSet Varianty LeaseSet Lease2 (druhá generace záznamu Lease v I2P) Popis: Vylepšený formát lease (záznamu o tunelu) se 4bajtovou expirací. Používá se v LeaseSet2 (typ 3) a MetaLeaseSet (typ 7).\nÚvod: Verze 0.9.38 (viz Návrh 123 )\nFormát:\n+----+----+----+----+----+----+----+----+ | tunnel_gw | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ | tunnel_id | end_date | +----+----+----+----+----+----+----+----+ tunnel_gw :: Hash (32 bytes) SHA-256 hash of gateway RouterIdentity tunnel_id :: TunnelId (4 bytes) Tunnel identifier at gateway end_date :: 4-byte timestamp (seconds since epoch) Rolls over in year 2106 Celková velikost: 40 bajtů (o 4 bajty menší než původní Lease (záznam o pronájmu tunelu))\nSrovnání s původním Lease (záznamem v leaseSet):\nFeature Lease (Type\u0026nbsp;1) Lease2 (Type\u0026nbsp;3+) Size44 bytes40 bytes Expiration Size8 bytes (ms)4 bytes (seconds) PrecisionMillisecondSecond RolloverYear\u0026nbsp;292,277,026,596Year\u0026nbsp;2106 Used InLeaseSet (deprecated)LeaseSet2, MetaLeaseSet **JavaDoc:** [Lease2](http://docs.i2p-projekt.de/javadoc/net/i2p/data/Lease2.html) Offline podpis Popis: Volitelná struktura pro předem podepsané dočasné klíče, umožňující publikaci LeaseSetu bez online přístupu k soukromému podpisovému klíči Destination (identita cílové služby v I2P).\nÚvod: Verze 0.9.38 (viz Návrh 123 )\nFormát:\n+----+----+----+----+----+----+----+----+ | expires | sigtype | | +----+----+----+----+----+----+ + | transient_public_key | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | signature | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ expires :: 4-byte timestamp (seconds since epoch) Expiration of transient key validity Rolls over in year 2106 sigtype :: 2-byte signature type Type of transient_public_key (see SigningPublicKey types) transient_public_key :: SigningPublicKey Length determined by sigtype Temporary signing key for LeaseSet signature :: Signature Length determined by Destination\u0026#39;s signing key type Signature of (expires || sigtype || transient_public_key) Signed by Destination\u0026#39;s permanent SigningPrivateKey Účel: - Umožňuje offline generování LeaseSet - Chrání hlavní klíč Destination (identifikátor cíle v I2P) před online odhalením - Dočasný klíč lze zneplatnit zveřejněním nového LeaseSet bez offline podpisu\nScénáře použití:\nVysoce zabezpečené destinace:\nHlavní podpisový klíč uložen offline (HSM, studené úložiště) Dočasné klíče generované offline pro omezená časová období Kompromitovaný dočasný klíč neprozradí hlavní klíč Šifrované publikování LeaseSet:\nEncryptedLeaseSet může obsahovat offline podpis Zaslepený veřejný klíč + offline podpis poskytují dodatečné zabezpečení Bezpečnostní hlediska:\nSpráva doby platnosti:\nNastavte rozumnou dobu platnosti (dny až týdny, ne roky) Před vypršením generujte nové dočasné klíče Kratší doba platnosti = lepší zabezpečení, více údržby Generování klíčů:\nGenerujte dočasné klíče offline v zabezpečeném prostředí Podepište hlavním klíčem offline Přeneste pouze podepsaný dočasný klíč + podpis do online routeru Odvolání:\nZveřejněte nový LeaseSet bez offline podpisu k implicitnímu odvolání Nebo zveřejněte nový LeaseSet s jiným dočasným klíčem Ověření podpisu:\nData to sign: expires (4 bytes) || sigtype (2 bytes) || transient_public_key Verification: 1. Extract Destination from LeaseSet 2. Get Destination\u0026#39;s SigningPublicKey 3. Verify signature over (expires || sigtype || transient_public_key) 4. Check that current time \u0026lt; expires 5. If valid, use transient_public_key to verify LeaseSet signature Poznámky k implementaci: - Celková velikost se liší podle sigtype (typ podpisu) a typu podpisového klíče Destination - Minimální velikost: 4 + 2 + 32 (klíč EdDSA) + 64 (podpis EdDSA) = 102 bajtů - Maximální praktická velikost: ~600 bajtů (dočasný klíč RSA-4096 + podpis RSA-4096)\nKompatibilní s: - LeaseSet2 (typ 3) - EncryptedLeaseSet (typ 5) - MetaLeaseSet (typ 7)\nViz také: Proposal 123 pro podrobný offline podpisový protokol.\nLeaseSet2Header Popis: Společná struktura hlavičky pro LeaseSet2 (typ 3) a MetaLeaseSet (typ 7).\nÚvod: Verze 0.9.38 (viz Návrh 123 )\nFormát:\n+----+----+----+----+----+----+----+----+ | destination | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | published | expires | flags | +----+----+----+----+----+----+----+----+ | offline_signature (optional) | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ destination :: Destination Length: 387+ bytes published :: 4-byte timestamp (seconds since epoch) Publication time of this LeaseSet Rolls over in year 2106 expires :: 2-byte offset (seconds) Offset from published timestamp Maximum: 65535 seconds (18.2 hours) flags :: 2 bytes (bit flags) See flag definitions below offline_signature :: OfflineSignature (optional) Present only if flags bit 0 is set Variable length Minimální celková velikost: 395 bajtů (bez offline podpisu)\nDefinice příznaků (pořadí bitů: 15 14 \u0026hellip; 3 2 1 0):\nBit Name Description 0Offline Keys0 = No offline keys, 1 = Offline signature present 1Unpublished0 = Standard published, 1 = Unpublished (client-side only) 2Blinded0 = Standard, 1 = Will be blinded when published 3-15ReservedMust be 0 for compatibility **Podrobnosti příznaku:** Bit 0 - Offline klíče: - 0: Žádný offline podpis, použijte podpisový klíč Destination (kryptografický identifikátor cíle v I2P) k ověření podpisu LeaseSet - 1: Struktura OfflineSignature následuje za polem flags\nBit 1 - Nezveřejněno: - 0: Standardně publikovaný LeaseSet, měl by být rozšířen k floodfills - 1: Nezveřejněný LeaseSet (pouze na straně klienta) - Nesmí být rozšiřován, publikován ani posílán v odpovědi na dotazy - Pokud vyprší, NEdotazovat se netdb na náhradu (pokud není nastaven i bit 2) - Používá se pro lokální tunnels nebo testování\nBit 2 - Blinded (zaslepené) (od verze 0.9.42): - 0: Standardní LeaseSet - 1: Tento nešifrovaný LeaseSet bude při publikování blinded a zašifrován - Publikovaná verze bude EncryptedLeaseSet (typ 5) - Pokud vyprší, vyhledejte v netdb náhradu na blinded location - Je také nutné nastavit bit 1 na 1 (unpublished + blinded) - Používá se pro šifrované skryté služby\nLimity vypršení platnosti:\nLeaseSet Type Maximum Expires Value Maximum Actual Time LeaseSet2 (type 3)≈660 seconds≈11 minutes MetaLeaseSet (type 7)65,535 seconds≈18.2 hours **Požadavky na časové razítko zveřejnění:** LeaseSet (typ 1) neměl pole published, což vyžadovalo hledání nejdřívějšího vypršení platnosti lease (záznamu o pronájmu trasy v I2P) pro účely verzování. LeaseSet2 přidává explicitní časové razítko published s rozlišením na 1 sekundu.\nKritická poznámka k implementaci: - Routers MUSÍ omezovat rychlost publikování LeaseSet na výrazně pomalejší než jednou za sekundu pro každou Destination (identifikátor cíle) - Pokud publikujete rychleji, zajistěte, aby každý nový LeaseSet měl čas published alespoň o 1 sekundu později - Floodfills odmítnou LeaseSet, pokud čas published není novější než aktuální verze - Doporučený minimální interval: 10-60 sekund mezi publikacemi\nPříklady výpočtů:\nLeaseSet2 (maximálně 11 minut):\npublished = 1704067200 (2024-01-01 00:00:00 UTC) expires = 660 (seconds) Actual expiration = 1704067200 + 660 = 1704067860 (2024-01-01 00:11:00 UTC) MetaLeaseSet (max. 18,2 hodiny):\npublished = 1704067200 (2024-01-01 00:00:00 UTC) expires = 65535 (seconds) Actual expiration = 1704067200 + 65535 = 1704132735 (2024-01-01 18:12:15 UTC) Verzování: - LeaseSet je považován za „novější“, pokud je časové razítko published vyšší - Floodfills ukládají a rozesílají pouze nejnovější verzi - Dávejte pozor, když se nejstarší Lease (záznam o tunelu v I2P) shoduje s nejstarším Lease předchozího LeaseSetu\nLeaseSet2 (Typ 3) Popis: Moderní formát LeaseSet s více šifrovacími klíči, offline podpisy a záznamy o službách. Aktuální standard pro skryté služby I2P.\nÚvod: Verze 0.9.38 (viz Návrh 123 )\nStruktura:\n+----+----+----+----+----+----+----+----+ | ls2_header | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | options | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ |numk| keytype0| keylen0 | | +----+----+----+----+----+ + | encryption_key_0 | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | keytypen| keylenn | | +----+----+----+----+ + | encryption_key_n | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | num| Lease2 0 | +----+ + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | Lease2($num-1) | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | signature | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ ls2header :: LeaseSet2Header Length: 395+ bytes (varies with offline signature) options :: Mapping Key-value pairs for service records and metadata Length: 2+ bytes (size field + data) numk :: Integer (1 byte) Number of encryption keys Range: 1 to (implementation-defined maximum, typically 8) keytype :: 2-byte encryption type See PublicKey type table keylen :: 2-byte key length Must match keytype specification encryption_key :: PublicKey Length: keylen bytes Type: keytype [Repeat keytype/keylen/encryption_key for each key] num :: Integer (1 byte) Number of Lease2s Range: 1-16 (at least one required) leases :: Array of Lease2 structures Length: $num × 40 bytes signature :: Signature Length determined by signing key type Signed over entire structure including database type prefix Úložiště databáze: - Typ databáze: 3 - Klíč: SHA-256 hash Destination (I2P cílová adresa) - Hodnota: Úplná struktura LeaseSet2\nVýpočet podpisu:\nData to sign: database_type (1 byte, value=3) || complete LeaseSet2 data Verification: 1. Prepend database type byte (0x03) to LeaseSet2 data 2. If offline signature present: - Verify offline signature against Destination key - Verify LeaseSet2 signature against transient key 3. Else: - Verify LeaseSet2 signature against Destination key Preferenční pořadí šifrovacích klíčů Pro publikovaný (serverový) LeaseSet: - Klíče jsou uvedeny v pořadí preferencí serveru (nejpreferovanější první) - Klienti podporující více typů BY MĚLI respektovat preference serveru - Vyberte ze seznamu první podporovaný typ - Obecně jsou typy klíčů s vyšším číslem (novější) bezpečnější/efektivnější - Doporučené pořadí: Uvádějte klíče v obráceném pořadí podle kódu typu (nejnovější první)\nPříklad předvolby serveru:\nnumk = 2 Key 0: X25519 (type 4, 32 bytes) [Most preferred] Key 1: ElGamal (type 0, 256 bytes) [Legacy compatibility] Pro nepublikovaný (klientský) LeaseSet: - Pořadí klíčů prakticky nehraje roli (pokusy o připojení ke klientům jsou vzácné) - Pro zachování konzistence dodržujte stejnou konvenci\nVýběr klíče klienta: - Respektovat preferenci serveru (vybrat první podporovaný typ) - Nebo použít preferenci definovanou implementací - Nebo určit kombinovanou preferenci na základě schopností obou stran\nMapování možností Požadavky: - Možnosti MUSÍ být seřazeny podle klíče (lexikograficky, v pořadí bajtů UTF-8) - Řazení zajišťuje neměnnost podpisu - Duplicitní klíče NEJSOU povoleny\nStandardní formát (Návrh 167 ):\nOd API 0.9.66 (červen 2025, vydání 2.9.0) mají možnosti záznamu služby standardizovaný formát. Úplnou specifikaci viz Proposal 167 .\nFormát volby záznamu služby:\nKey: _service._proto Value: record_type ttl [priority weight] port target [appoptions] service :: Symbolic name of service (lowercase, [a-z0-9-]) Examples: smtp, http, irc, mumble Use standard identifiers from IANA Service Name Registry or Linux /etc/services when available proto :: Transport protocol (lowercase, [a-z0-9-]) \u0026#34;tcp\u0026#34; = streaming protocol \u0026#34;udp\u0026#34; = repliable datagrams Protocol indicators for raw datagrams may be defined later record_type :: \u0026#34;0\u0026#34; (self-reference) or \u0026#34;1\u0026#34; (SRV record) ttl :: Time to live in seconds (positive integer) Recommended minimum: 86400 (one day) Prevents frequent re-queries For record_type = 0 (self-reference): port :: I2CP port number (non-negative integer) appoptions :: Optional application-specific data (no spaces or commas) For record_type = 1 (SRV record): priority :: Lower value = more preferred (non-negative integer) weight :: Relative weight for same priority, higher = more likely (non-negative) port :: I2CP port number (non-negative integer) target :: Hostname or b32 of destination (lowercase) Format: \u0026#34;example.i2p\u0026#34; or \u0026#34;aaaaa...aaaa.b32.i2p\u0026#34; Recommend b32 unless hostname is \u0026#34;well known\u0026#34; appoptions :: Optional application-specific data (no spaces or commas) Ukázkové záznamy služby:\n1. Samoodkazující SMTP server:\nDestination: aaaa...aaaa.b32.i2p (this LeaseSet) Option: \u0026#34;_smtp._tcp\u0026#34; = \u0026#34;0 999999 25\u0026#34; Meaning: This destination provides SMTP service on I2CP port 25 2. Jeden externí SMTP server:\nDestination: aaaa...aaaa.b32.i2p (this LeaseSet) Option: \u0026#34;_smtp._tcp\u0026#34; = \u0026#34;1 86400 0 0 25 bbbb...bbbb.b32.i2p\u0026#34; Meaning: SMTP service provided by bbbb...bbbb on port 25 TTL = 1 day, single server (priority=0, weight=0) 3. Více SMTP serverů (vyvažování zátěže):\nDestination: aaaa...aaaa.b32.i2p (this LeaseSet) Option: \u0026#34;_smtp._tcp\u0026#34; = \u0026#34;1 86400 0 0 25 bbbb...bbbb.b32.i2p,1 86400 1 0 25 cccc...cccc.b32.i2p\u0026#34; Meaning: Two SMTP servers bbbb...bbbb (priority=0, preferred) cccc...cccc (priority=1, backup) 4. HTTP služba s možnostmi aplikace:\nOption: \u0026#34;_http._tcp\u0026#34; = \u0026#34;0 86400 80 tls=1.3;cert=ed25519\u0026#34; Meaning: HTTP on port 80 with TLS 1.3 and EdDSA certificates Doporučení pro TTL (čas života): - Minimum: 86400 sekund (1 den) - Delší TTL snižuje zátěž dotazů na netdb - Vyvážení mezi snížením počtu dotazů a propagací aktualizací služby - Pro stabilní služby: 604800 (7 dní) nebo déle\nPoznámky k implementaci:\nŠifrovací klíče (stav k verzi 0.9.44):\nElGamal (typ 0, 256 bajtů): Zpětná kompatibilita X25519 (typ 4, 32 bajtů): Současný standard Varianty MLKEM: Postkvantové (beta, dosud nefinalizované) Ověření délky klíče:\nFloodfills a klienti MUSÍ být schopni parsovat neznámé typy klíčů Použijte pole keylen k přeskočení neznámých klíčů Neukončujte parsování s chybou, pokud je typ klíče neznámý Časová značka zveřejnění:\nViz poznámky k LeaseSet2Header ohledně omezování četnosti Minimální rozestup mezi zveřejněními: 1 sekunda Doporučeno: 10–60 sekund mezi zveřejněními Migrace typu šifrování:\nPoužití více klíčů umožňuje postupnou migraci Během přechodného období uveďte jak staré, tak nové klíče Starý klíč odstraňte po uplynutí dostatečné doby pro aktualizaci klientů JavaDoc: LeaseSet2 MetaLease (speciální typ Lease s metadaty v I2P) Popis: Struktura Lease (záznam v LeaseSet) pro MetaLeaseSet (metasada LeaseSet), která může odkazovat na jiné LeaseSets místo na tunnels. Používá se pro vyvažování zátěže a redundanci.\nÚvod: Verze 0.9.38, naplánováno na 0.9.40 (viz Návrh 123 )\nFormát:\n+----+----+----+----+----+----+----+----+ | tunnel_gw | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ | flags |cost| end_date | +----+----+----+----+----+----+----+----+ tunnel_gw :: Hash (32 bytes) SHA-256 hash of: - Gateway RouterIdentity (for type 1), OR - Another MetaLeaseSet destination (for type 3/5/7) flags :: 3 bytes Bit order: 23 22 ... 3 2 1 0 Bits 3-0: Entry type (see table below) Bits 23-4: Reserved (must be 0) cost :: 1 byte (0-255) Lower value = higher priority Used for load balancing end_date :: 4-byte timestamp (seconds since epoch) Expiration time Rolls over in year 2106 Celková velikost: 40 bajtů\nTyp položky (bity příznaků 3–0):\nType Code Description Unknown0Unknown/invalid entry LeaseSet1Points to LeaseSet (type 1, deprecated) LeaseSet23Points to LeaseSet2 (type 3) EncryptedLeaseSet5Points to EncryptedLeaseSet (type 5) MetaLeaseSet7Points to another MetaLeaseSet (type 7) **Scénáře použití:** Vyvažování zátěže:\nMetaLeaseSet (metasada pro agregaci více LeaseSet) s více záznamy MetaLease (metazáznamy) Každý záznam odkazuje na jiný LeaseSet2 (novější formát LeaseSet) Klienti vybírají na základě pole cost Redundance:\nVíce záznamů odkazujících na záložní LeaseSets Záložní řešení, pokud je primární LeaseSet nedostupný Migrace služby:\nMetaLeaseSet (meta-sada LeaseSet) odkazuje na nový LeaseSet Umožňuje plynulý přechod mezi Destinations (cílovými adresami v I2P) Použití pole Cost: - Nižší hodnota Cost = vyšší priorita - Cost 0 = nejvyšší priorita - Cost 255 = nejnižší priorita - Klienti BY MĚLI preferovat záznamy s nižší hodnotou Cost - Záznamy se stejnou hodnotou Cost mohou být náhodně vyvažovány\nSrovnání s Lease2:\nFeature Lease2 MetaLease Size40 bytes40 bytes Tunnel ID4 bytesReplaced by flags (3 bytes) + cost (1 byte) Points ToSpecific tunnelLeaseSet or MetaLeaseSet UsageDirect tunnel referenceIndirection/load balancing **JavaDoc:** [MetaLease](http://docs.i2p-projekt.de/javadoc/net/i2p/data/MetaLease.html) MetaLeaseSet (Typ 7; speciální varianta leaseSet) Popis: Varianta LeaseSetu, která obsahuje položky MetaLease a poskytuje zprostředkované odkazování na jiné LeaseSety. Používá se pro vyvažování zátěže, redundanci a migraci služeb.\nÚvod: Definováno ve verzi 0.9.38, naplánováno jako funkční v 0.9.40 (viz Návrh 123 )\nStav: Specifikace je dokončena. Stav produkčního nasazení by měl být ověřen podle aktuálních vydání I2P.\nStruktura:\n+----+----+----+----+----+----+----+----+ | ls2_header | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | options | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | num| MetaLease 0 | +----+ + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | MetaLease($num-1) | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ |numr| | +----+ + | revocation_0 | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | revocation_n | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | signature | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ ls2header :: LeaseSet2Header Length: 395+ bytes options :: Mapping Length: 2+ bytes (size + data) MUST be sorted by key num :: Integer (1 byte) Number of MetaLease entries Range: 1 to (implementation-defined, recommend 1-16) metaleases :: Array of MetaLease structures Length: $num × 40 bytes numr :: Integer (1 byte) Number of revocation hashes Range: 0 to (implementation-defined, recommend 0-16) revocations :: Array of Hash structures Length: $numr × 32 bytes SHA-256 hashes of revoked LeaseSet Destinations Úložiště databáze: - Typ databáze: 7 - Klíč: SHA-256 hash z Destination (cíl v I2P) - Hodnota: Kompletní struktura MetaLeaseSet (typ rozšířeného leaseSetu)\nVýpočet podpisu:\nData to sign: database_type (1 byte, value=7) || complete MetaLeaseSet data Verification: 1. Prepend database type byte (0x07) to MetaLeaseSet data 2. If offline signature present in header: - Verify offline signature against Destination key - Verify MetaLeaseSet signature against transient key 3. Else: - Verify MetaLeaseSet signature against Destination key Scénáře použití:\n1. Vyvažování zátěže:\nMetaLeaseSet for primary.i2p: MetaLease 0: cost=0, points to server1.i2p LeaseSet2 MetaLease 1: cost=0, points to server2.i2p LeaseSet2 MetaLease 2: cost=0, points to server3.i2p LeaseSet2 Clients randomly select among equal-cost entries 2. Převzetí služeb při selhání:\nMetaLeaseSet for service.i2p: MetaLease 0: cost=0, points to primary.i2p LeaseSet2 MetaLease 1: cost=100, points to backup.i2p LeaseSet2 Clients prefer cost=0 (primary), fall back to cost=100 (backup) 3. Migrace služby:\nMetaLeaseSet for old-domain.i2p: MetaLease 0: cost=0, points to new-domain.i2p LeaseSet2 Transparently redirects clients from old to new destination 4. Vícevrstvá architektura:\nMetaLeaseSet for service.i2p: MetaLease 0: cost=0, points to region1-meta.i2p (another MetaLeaseSet) MetaLease 1: cost=0, points to region2-meta.i2p (another MetaLeaseSet) Each region MetaLeaseSet points to regional servers Allows hierarchical load balancing Seznam zneplatnění:\nRevokační seznam umožňuje, aby MetaLeaseSet (rozšířená forma typu LeaseSet v I2P) výslovně odvolal dříve zveřejněné LeaseSets:\nÚčel: Označit konkrétní Destinations (identifikátory cílů v I2P) jako již neplatné Obsah: Hashů SHA-256 odvolaných struktur Destination Použití: Klienti NESMÍ používat LeaseSets, jejichž hash Destination se nachází v revokačním seznamu Typická hodnota: Prázdné (numr=0) ve většině nasazení Příklad revokace:\nService migrates from dest-v1.i2p to dest-v2.i2p: MetaLease 0: points to dest-v2.i2p Revocations: [hash(dest-v1.i2p)] Clients will use v2 and ignore v1 even if cached Zpracování expirace:\nMetaLeaseSet (anglický termín pro speciální typ LeaseSet) používá LeaseSet2Header (anglický název hlavičky struktury LeaseSet2) s maximální hodnotou expires=65535 sekund (~18,2 hodin):\nMnohem delší než LeaseSet2 (max ~11 minut) Vhodné pro relativně statickou indirekci Odkazované LeaseSets mohou mít kratší dobu platnosti Klienti musí kontrolovat platnost jak MetaLeaseSet, tak i odkazovaných LeaseSets Mapování možností:\nPoužijte stejný formát jako volby LeaseSet2 Může obsahovat záznamy služby (Proposal 167 ) MUSÍ být seřazeny podle klíče Záznamy služby zpravidla popisují koncovou službu, nikoli zprostředkovací strukturu Poznámky k implementaci klienta:\nPostup resoluce:\n1. Query netdb for MetaLeaseSet using SHA-256(Destination) 2. Parse MetaLeaseSet, extract MetaLease entries 3. Sort entries by cost (lower = better) 4. For each entry in cost order: a. Extract LeaseSet hash from tunnel_gw field b. Determine entry type from flags c. Query netdb for referenced LeaseSet (may be another MetaLeaseSet) d. Check revocation list e. Check expiration f. If valid, use the LeaseSet; else try next entry Kešování:\nKešujte jak MetaLeaseSet, tak odkazované LeaseSets Kontrolujte vypršení platnosti na obou úrovních Sledujte publikaci aktualizovaného MetaLeaseSet Failover (přepnutí při selhání):\nPokud preferovaná položka selže, zkuste položku s dalším nejnižším nákladem Zvažte označení selhaných položek jako dočasně nedostupných Pravidelně znovu kontrolujte, zda se neobnovily Stav implementace:\nNávrh 123 uvádí, že některé části jsou stále „ve vývoji“. Implementátoři by měli: - Ověřit připravenost pro produkční nasazení v cílové verzi I2P - Otestovat podporu MetaLeaseSet (rozšířený typ leaseSet) před nasazením - Zkontrolovat aktualizované specifikace v novějších vydáních I2P\nJavaDoc: MetaLeaseSet EncryptedLeaseSet (šifrovaný LeaseSet; typ 5) Popis: Šifrovaný a zaslepený LeaseSet pro zvýšenou ochranu soukromí. Pouze zaslepený veřejný klíč a metadata jsou viditelné; samotné leases (záznamy) a šifrovací klíče jsou šifrované.\nÚvod: Definováno v 0.9.38, funkční od 0.9.39 (viz Proposal 123 )\nStruktura:\n+----+----+----+----+----+----+----+----+ | sigtype | | +----+----+ + | blinded_public_key | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | published | expires | flags | +----+----+----+----+----+----+----+----+ | offline_signature (optional) | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | len | | +----+----+ + | encrypted_data | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | signature | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ sigtype :: 2-byte signature type Type of blinded_public_key MUST be RedDSA_SHA512_Ed25519 (type 11) blinded_public_key :: SigningPublicKey (32 bytes for RedDSA) Blinded version of Destination signing key Used to verify signature on EncryptedLeaseSet published :: 4-byte timestamp (seconds since epoch) Publication time Rolls over in year 2106 expires :: 2-byte offset (seconds) Offset from published Maximum: 65535 seconds (18.2 hours) Practical maximum for LeaseSet data: ~660 seconds (~11 min) flags :: 2 bytes Bit 0: Offline signature present (0=no, 1=yes) Bit 1: Unpublished (0=published, 1=client-side only) Bits 15-2: Reserved (must be 0) offline_signature :: OfflineSignature (optional) Present only if flags bit 0 = 1 Variable length len :: 2-byte integer Length of encrypted_data Range: 1 to 65535 encrypted_data :: Encrypted payload Length: len bytes Contains encrypted LeaseSet2 or MetaLeaseSet signature :: Signature (64 bytes for RedDSA) Length determined by sigtype Signed by blinded_public_key or transient key Uložení v databázi: - Typ databáze: 5 - Klíč: SHA-256 hash z blinded Destination (Destination: cílový identifikátor v I2P; nikoli původní Destination) - Hodnota: Úplná struktura EncryptedLeaseSet\nZásadní rozdíly oproti LeaseSet2:\nNEpoužívá strukturu LeaseSet2Header (hlavička LeaseSet verze 2) (má podobná pole, ale jiné uspořádání) Zaslepený veřejný klíč namísto plného Destination (I2P identifikátor cíle) Šifrovaná užitečná data namísto leases a klíčů v otevřeném textu Databázový klíč je hash zaslepeného Destination, ne původního Destination Výpočet podpisu:\nData to sign: database_type (1 byte, value=5) || complete EncryptedLeaseSet data Verification: 1. Prepend database type byte (0x05) to EncryptedLeaseSet data 2. If offline signature present (flags bit 0 = 1): - Verify offline signature against blinded public key - Verify EncryptedLeaseSet signature against transient key 3. Else: - Verify EncryptedLeaseSet signature against blinded public key Požadavek na typ podpisu:\nMUSÍ se použít RedDSA_SHA512_Ed25519 (typ 11): - 32bajtové zaslepené veřejné klíče - 64bajtové podpisy - Vyžadováno kvůli bezpečnostním vlastnostem zaslepení - Viz [specifikace Red25519](//docs/specs/red25519-signature-scheme/\nKlíčové rozdíly oproti EdDSA: - Soukromé klíče odvozované pomocí modulární redukce (nikoli clamping, tj. ořezání bitů) - Podpisy obsahují 80 bajtů náhodných dat - Veřejné klíče používá přímo (nikoli hashe) - Umožňuje bezpečnou operaci zaslepení\nZaslepení a šifrování:\nPro veškeré podrobnosti viz specifikaci EncryptedLeaseSet :\n1. Oslepování klíče:\nBlinding process (daily rotation): secret = HKDF(original_signing_private_key, date_string, \u0026#34;i2pblinding1\u0026#34;) alpha = SHA-256(secret) mod L (where L is Ed25519 group order) blinded_private_key = alpha * original_private_key blinded_public_key = alpha * original_public_key 2. Umístění databáze:\nClient publishes to: Key = SHA-256(blinded_destination) Where blinded_destination uses: - Blinded public key (signing key) - Same unused public key field (random) - Same certificate structure 3. Šifrovací vrstvy (třívrstvé):\nVrstva 1 - Autentizační vrstva (přístup klienta): - Šifrování: proudová šifra ChaCha20 - Odvozování klíčů: HKDF s tajemstvími pro jednotlivé klienty - Autentizovaní klienti mohou dešifrovat vnější vrstvu\nVrstva 2 - šifrovací vrstva: - Šifrování: ChaCha20 - Klíč: odvozen z Diffie–Hellmanovy výměny klíčů mezi klientem a serverem - Obsahuje skutečný LeaseSet2 nebo MetaLeaseSet\nVrstva 3 - Vnitřní LeaseSet: - Kompletní LeaseSet2 nebo MetaLeaseSet - Obsahuje všechny tunnels, šifrovací klíče, volby - Přístupné pouze po úspěšném dešifrování\nOdvozování šifrovacího klíče:\nClient has: ephemeral_client_private_key Server has: ephemeral_server_public_key (in encrypted_data) Shared secret = X25519(client_private, server_public) Encryption key = HKDF(shared_secret, context_info, \u0026#34;i2pblinding2\u0026#34;) Proces zjišťování:\nPro autorizované klienty:\n1. Client knows original Destination 2. Client computes current blinded Destination (based on current date) 3. Client computes database key: SHA-256(blinded_destination) 4. Client queries netdb for EncryptedLeaseSet using blinded key 5. Client decrypts layer 1 using authorization credentials 6. Client decrypts layer 2 using DH shared secret 7. Client extracts inner LeaseSet2/MetaLeaseSet 8. Client uses tunnels from inner LeaseSet for communication Pro neoprávněné klienty: - Nelze dešifrovat ani v případě, že najdou EncryptedLeaseSet - Nelze určit původní Destination (cílový identifikátor v I2P) z oslepené verze - Nelze propojit EncryptedLeaseSets napříč různými obdobími oslepování (denní rotace)\nČasy vypršení platnosti:\nContent Type Maximum Expires Notes EncryptedLeaseSet (outer)65,535 sec (≈18.2 hr)Full 2-byte expires field Inner LeaseSet2≈660 sec (≈11 min)Actual lease data practical maximum Inner MetaLeaseSet65,535 sec (≈18.2 hr)Indirection can be longer-lived **Časové razítko zveřejnění:** Stejné požadavky jako u LeaseSet2Header (hlavička datové struktury LeaseSet2):\nMusí se mezi publikacemi zvýšit alespoň o 1 sekundu Floodfills (speciální uzly I2P pro netDb) odmítnou, pokud není novější než aktuální verze Doporučeno: 10-60 sekund mezi publikacemi Offline podpisy se šifrovanými LeaseSets:\nZvláštní aspekty při používání offline podpisů: - Blinded public key (zaslepený veřejný klíč) se mění denně - Offline podpis je nutné denně znovu vytvořit s novým blinded key - NEBO použijte offline podpis na vnitřním LeaseSet, nikoli na vnějším EncryptedLeaseSet - Viz poznámky k Proposal 123 Poznámky k implementaci:\nAutorizace klientů:\nVíce klientů lze autorizovat pomocí různých klíčů Každý autorizovaný klient má jedinečné údaje pro dešifrování Klientovi lze odebrat přístup změnou autorizačních klíčů Denní rotace klíčů:\nOslepené klíče se mění o půlnoci UTC Klienti musí denně znovu vypočítat oslepenou Destination (cílová identita) Staré EncryptedLeaseSets se po rotaci stanou nedohledatelnými Vlastnosti ochrany soukromí:\nFloodfills nemohou určit původní Destination (identifikátor cíle v I2P) Neoprávnění klienti nemohou přistupovat ke službě Různá období zaslepení nelze vzájemně propojit Žádná nešifrovaná metadata kromě časů expirace Výkon:\nKlienti musí provádět denní výpočet zaslepení Třívrstvé šifrování přidává výpočetní režii Zvažte ukládání do mezipaměti dešifrovaného vnitřního LeaseSet Bezpečnostní hlediska:\nSpráva autorizačních klíčů:\nZabezpečeně distribuujte autorizační pověření klientů Používejte jedinečná pověření pro každého klienta pro možnost cíleného odvolání Pravidelně obměňujte autorizační klíče Synchronizace hodin:\nDenní blinding (kryptografické zaslepení) závisí na synchronizovaných datech UTC Odchylka hodin může způsobovat selhání vyhledávání Zvažte podporu blindingu pro předchozí/následující den pro zvýšení tolerance Únik metadat:\nPole Published a expires jsou v nešifrovaném textu Analýza vzorců může odhalit charakteristiky služby Znáhodněte intervaly publikace, pokud máte obavy JavaDoc: EncryptedLeaseSet Struktury routeru RouterAddress (adresa routeru) Popis: Definuje informace o připojení k routeru prostřednictvím konkrétního transportního protokolu.\nFormát:\n+----+----+----+----+----+----+----+----+ |cost| expiration +----+----+----+----+----+----+----+----+ | transport_style | +----+----+----+----+-//-+----+----+----+ | | + + | options | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ cost :: Integer (1 byte) Relative cost, 0=free, 255=expensive Typical values: 5-6: SSU2 10-11: NTCP2 expiration :: Date (8 bytes) MUST BE ALL ZEROS (see critical note below) transport_style :: String (1-256 bytes) Transport protocol name Current values: \u0026#34;SSU2\u0026#34;, \u0026#34;NTCP2\u0026#34; Legacy: \u0026#34;SSU\u0026#34;, \u0026#34;NTCP\u0026#34; (removed) options :: Mapping Transport-specific configuration Common options: \u0026#34;host\u0026#34;, \u0026#34;port\u0026#34; Transport-specific options vary KRITICKÉ - Pole expirace:\n⚠️ Pole expiration MUSÍ být nastaveno na samé nuly (8 nulových bajtů).\nDůvod: Od verze 0.9.3 způsobuje nenulová expirace selhání ověření podpisu Historie: Expirace se původně nepoužívala, vždy byla null Aktuální stav: Pole bylo od verze 0.9.12 opět rozpoznáno, ale je nutné počkat na upgrade sítě Implementace: Vždy nastaveno na 0x0000000000000000 Jakákoli nenulová expirace způsobí, že podpis RouterInfo neprojde ověřením.\nTransportní protokoly Aktuální protokoly (stav k verzi 2.10.0):\nProtocol Status Introduced Removed Notes SSU2Current0.9.54 (May 2022)-Default since 0.9.56 NTCP2Current0.9.36 (Aug 2018)-Active NTCPRemoved-0.9.50 (May 2021)Use NTCP2 SSURemoved-2.4.0 (Dec 2023)Use SSU2 **Hodnoty stylu transportu:** - `\"SSU2\"`: Aktuální transport založený na UDP - `\"NTCP2\"`: Aktuální transport založený na TCP - `\"NTCP\"`: Zastaralý, odstraněn (nepoužívat) - `\"SSU\"`: Zastaralý, odstraněn (nepoužívat) Obecné volby Všechny transporty obvykle zahrnují:\n\u0026#34;host\u0026#34; = IPv4 or IPv6 address or hostname \u0026#34;port\u0026#34; = Port number (1-65535) Možnosti specifické pro SSU2 Viz specifikaci SSU2 pro úplné podrobnosti.\nPovinné volby:\n\u0026#34;host\u0026#34; = IP address (IPv4 or IPv6) \u0026#34;port\u0026#34; = UDP port number \u0026#34;s\u0026#34; = Static X25519 public key (Base64, 44 characters = 32 bytes) \u0026#34;i\u0026#34; = Introduction key X25519 (Base64, 44 characters = 32 bytes) \u0026#34;v\u0026#34; = \u0026#34;2\u0026#34; (protocol version) Volitelné možnosti:\n\u0026#34;caps\u0026#34; = Capability string (e.g., \u0026#34;B\u0026#34; for bandwidth tier) \u0026#34;ihost0\u0026#34;, \u0026#34;ihost1\u0026#34;, ... = Introducer IP addresses \u0026#34;iport0\u0026#34;, \u0026#34;iport1\u0026#34;, ... = Introducer ports \u0026#34;ikey0\u0026#34;, \u0026#34;ikey1\u0026#34;, ... = Introducer static keys (Base64, 44 chars) \u0026#34;itag0\u0026#34;, \u0026#34;itag1\u0026#34;, ... = Introducer relay tags \u0026#34;iexp0\u0026#34;, \u0026#34;iexp1\u0026#34;, ... = Introducer expiration timestamps \u0026#34;mtu\u0026#34; = Maximum transmission unit (default 1500, min 1280) \u0026#34;mtu6\u0026#34; = IPv6 MTU (if different from IPv4) Příklad SSU2 RouterAddress:\ncost: 5 expiration: 0x0000000000000000 transport_style: \u0026#34;SSU2\u0026#34; options: host=198.51.100.42 port=12345 s=SGVsbG8gV29ybGQhIFRoaXMgaXMgYSBzYW1wbGUga2V5IQ== i=QW5vdGhlciBTYW1wbGUgS2V5IGZvciBJbnRyb2R1Y3Rpb24= v=2 caps=BC mtu=1472 Specifické volby pro NTCP2 Pro úplné podrobnosti viz specifikaci NTCP2 .\nPovinné volby:\n\u0026#34;host\u0026#34; = IP address (IPv4 or IPv6) \u0026#34;port\u0026#34; = TCP port number \u0026#34;s\u0026#34; = Static X25519 public key (Base64, 44 characters = 32 bytes) \u0026#34;i\u0026#34; = Initialization vector (Base64, 24 characters = 16 bytes) \u0026#34;v\u0026#34; = \u0026#34;2\u0026#34; (protocol version) Volitelné možnosti (od 0.9.50):\n\u0026#34;caps\u0026#34; = Capability string Příklad NTCP2 RouterAddress:\ncost: 10 expiration: 0x0000000000000000 transport_style: \u0026#34;NTCP2\u0026#34; options: host=198.51.100.42 port=23456 s=SGVsbG8gV29ybGQhIFRoaXMgaXMgYSBzYW1wbGUga2V5IQ== i=U2FtcGxlIElWIGhlcmU= v=2 Poznámky k implementaci Hodnoty nákladů:\nUDP (SSU2) má obvykle nižší náklady (5-6) díky efektivitě TCP (NTCP2) má obvykle vyšší náklady (10-11) kvůli režii Nižší náklady = preferovaný transport Více adres:\nRouters mohou zveřejňovat více záznamů RouterAddress Různé transporty (SSU2 a NTCP2) Různé verze IP (IPv4 a IPv6) Klienti vybírají na základě cost (metrika nákladů) a schopností Název hostitele vs. IP:\nPro výkon jsou preferovány IP adresy Názvy hostitelů jsou podporovány, ale přidávají režii vyhledávání v DNS Zvažte použití IP pro publikované RouterInfos Kódování Base64:\nVšechny klíče a binární data jsou kódovány v Base64 Standardní Base64 (RFC 4648) Bez paddingu (vyplňování) ani nestandardních znaků JavaDoc: RouterAddress RouterInfo (informace o routeru) Popis: Kompletní zveřejněné informace o routeru, uložené v síťové databázi. Obsahuje identitu, adresy a schopnosti.\nFormát:\n+----+----+----+----+----+----+----+----+ | router_ident | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | published | +----+----+----+----+----+----+----+----+ |size| RouterAddress 0 | +----+ + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | RouterAddress 1 | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | RouterAddress ($size-1) | + + | | ~ ~ ~ ~ | | +----+----+----+----+-//-+----+----+----+ |psiz| options | +----+----+----+----+-//-+----+----+----+ | signature | + + | | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ router_ident :: RouterIdentity Length: 387+ bytes (typically 391 for X25519+EdDSA) published :: Date (8 bytes) Publication timestamp (milliseconds since epoch) size :: Integer (1 byte) Number of RouterAddress entries Range: 0-255 addresses :: Array of RouterAddress Variable length Each RouterAddress has variable size peer_size :: Integer (1 byte) Number of peer hashes (ALWAYS 0) Historical, unused feature options :: Mapping Router capabilities and metadata MUST be sorted by key signature :: Signature Length determined by router_ident signing key type Typically 64 bytes (EdDSA) Signed by router_ident\u0026#39;s SigningPrivateKey Databázové úložiště: - Typ databáze: 0 - Klíč: hash SHA-256 z RouterIdentity (identita routeru) - Hodnota: kompletní struktura RouterInfo (informace o routeru)\nPublikované časové razítko: - 8bajtové datum (milisekundy od epochy) - Používá se pro verzování RouterInfo - Routery periodicky publikují nové RouterInfo - Floodfills uchovávají nejnovější verzi na základě publikovaného časového razítka\nŘazení adres: - Historické: Velmi staré routers vyžadovaly, aby adresy byly seřazeny podle SHA-256 jejich dat - Současné: Řazení NENÍ vyžadováno, nestojí za implementaci kvůli kompatibilitě - Adresy mohou být v libovolném pořadí\nPole velikosti peerů (historické): - Vždy 0 v moderním I2P - Bylo zamýšleno pro omezené trasy (neimplementováno) - Pokud by bylo implementováno, následovalo by ho právě tolik hashů routerů - Některé staré implementace mohly vyžadovat seřazený seznam peerů\nMapování možností:\nVolby MUSÍ být seřazeny podle klíče. Mezi standardní volby patří:\nNastavení schopností:\n\u0026#34;caps\u0026#34; = Capability string Common values: f = Floodfill (network database) L or M or N or O = Bandwidth tier (L=lowest, O=highest) R = Reachable U = Unreachable/firewalled Example: \u0026#34;fLRU\u0026#34; = Floodfill, Low bandwidth, Reachable, Unreachable Možnosti sítě:\n\u0026#34;netId\u0026#34; = Network ID (default \u0026#34;2\u0026#34; for main I2P network) Different values for test networks \u0026#34;router.version\u0026#34; = I2P version string Example: \u0026#34;0.9.67\u0026#34; or \u0026#34;2.10.0\u0026#34; Statistické možnosti:\n\u0026#34;stat_uptime\u0026#34; = Uptime in milliseconds \u0026#34;coreVersion\u0026#34; = Core I2P version \u0026#34;router.version\u0026#34; = Full router version string Viz dokumentaci k RouterInfo v síťové databázi pro úplný seznam standardních možností.\nVýpočet podpisu:\nData to sign: Complete RouterInfo structure from router_ident through options Verification: 1. Extract RouterIdentity from RouterInfo 2. Get SigningPublicKey from RouterIdentity (type determines algorithm) 3. Verify signature over all data preceding signature field 4. Signature must match signing key type and length Typický moderní RouterInfo:\nRouterIdentity: 391 bytes (X25519+EdDSA with Key Certificate) Published: 8 bytes Size: 1 byte (typically 1-4 addresses) RouterAddress × N: Variable (typically 200-500 bytes each) Peer Size: 1 byte (value=0) Options: Variable (typically 50-200 bytes) Signature: 64 bytes (EdDSA) Total: ~1000-2500 bytes typical Poznámky k implementaci:\nVíce adres:\nRouters obvykle zveřejňují 1-4 adresy Varianty IPv4 a IPv6 Transporty SSU2 a/nebo NTCP2 Každá adresa je nezávislá Verzování:\nNovější RouterInfo (záznam s informacemi o routeru v I2P) má pozdější časové razítko published Každý router znovu publikuje každé ~2 hodiny nebo když se změní adresy Floodfill uzly ukládají a šíří pouze nejnovější verzi Validace:\nOvěřte podpis před přijetím RouterInfo Zkontrolujte, že pole expiration má samé nuly v každém RouterAddress Ověřte, že mapování options je seřazeno podle klíče Zkontrolujte, že typy certifikátu a klíče jsou známé a podporované Síťová databáze:\nFloodfills (speciální router v I2P pro netDb) ukládají RouterInfo indexované podle Hash(RouterIdentity) Uloženo po dobu ~2 dnů od poslední publikace Routers posílají dotazy na floodfills, aby našly další routers JavaDoc: RouterInfo Poznámky k implementaci Pořadí bajtů (Endianness) Výchozí: Big-Endian (síťové pořadí bajtů)\nVětšina struktur I2P používá pořadí bajtů big-endian: - Všechny celočíselné typy (1-8 bajtů) - Časová razítka Date - TunnelId - Prefix délky řetězce - Typy a délky certifikátů - Kódy typů klíčů - Pole velikosti mapování\nVýjimka: Little-Endian\nNásledující typy klíčů používají kódování little-endian (nejméně významný bajt je první): - X25519 šifrovací klíče (typ 4) - EdDSA_SHA512_Ed25519 podpisové klíče (typ 7) - EdDSA_SHA512_Ed25519ph podpisové klíče (typ 8) - RedDSA_SHA512_Ed25519 podpisové klíče (typ 11)\nImplementace:\n// Big-endian (most structures) int value = ((bytes[0] \u0026amp; 0xFF) \u0026lt;\u0026lt; 24) | ((bytes[1] \u0026amp; 0xFF) \u0026lt;\u0026lt; 16) | ((bytes[2] \u0026amp; 0xFF) \u0026lt;\u0026lt; 8) | (bytes[3] \u0026amp; 0xFF); // Little-endian (X25519, EdDSA, RedDSA) int value = (bytes[0] \u0026amp; 0xFF) | ((bytes[1] \u0026amp; 0xFF) \u0026lt;\u0026lt; 8) | ((bytes[2] \u0026amp; 0xFF) \u0026lt;\u0026lt; 16) | ((bytes[3] \u0026amp; 0xFF) \u0026lt;\u0026lt; 24); Verzování datových struktur Nikdy nepředpokládejte pevné velikosti:\nŘada struktur má proměnnou délku: - RouterIdentity (identita uzlu): 387+ bajtů (ne vždy 387) - Destination (cílová identita): 387+ bajtů (ne vždy 387) - LeaseSet2 (struktura LeaseSet verze 2): Výrazně se liší - Certifikát: 3+ bajtů\nVždy čtěte velikostní pole: - Délka certifikátu na bajtech 1-2 - Velikost mapování na začátku - KeysAndCert se vždy počítá jako 384 + 3 + certificate_length\nZkontrolujte nadbytečná data: - Zakázat nadbytečná koncová data za platnými strukturami - Ověřit, že délky certifikátů odpovídají typům klíčů - Vynutit přesně očekávané délky u typů s pevnou velikostí\nAktuální doporučení (říjen 2025) Pro nové identity routeru:\nEncryption: X25519 (type 4, 32 bytes) Signing: EdDSA_SHA512_Ed25519 (type 7, 32 bytes) Certificate: Key Certificate (type 5) Total Size: 391 bytes Padding: Compressible per [Proposal 161](/cs/proposals/161-ri-dest-padding/) Pro nové destinace:\nUnused Public Key Field: 256 bytes random (compressible) Signing: EdDSA_SHA512_Ed25519 (type 7, 32 bytes) Certificate: Key Certificate (type 5) Total Size: 391 bytes Padding: Compressible per [Proposal 161](/cs/proposals/161-ri-dest-padding/) Pro nové LeaseSets:\nType: LeaseSet2 (type 3) Encryption Keys: X25519 (type 4, 32 bytes) Leases: At least 1, typically 3-5 Options: Include service records per [Proposal 167](/proposals/167-service-records/) Signature: EdDSA (64 bytes) Pro šifrované služby:\nType: EncryptedLeaseSet (type 5) Blinding: RedDSA_SHA512_Ed25519 (type 11) Inner LeaseSet: LeaseSet2 (type 3) Rotation: Daily blinding key rotation Authorization: Per-client encryption keys Zastaralé funkce - nepoužívat Zastaralé šifrování: - ElGamal (typ 0) pro identity Routeru (zastaralé od 0.9.58) - Šifrování ElGamal/AES+SessionTag (použijte ECIES-X25519)\nZastaralé podepisování: - DSA_SHA1 (typ 0) pro identity routeru (zastaralé od verze 0.9.58) - varianty ECDSA (typy 1-3) pro nové implementace - varianty RSA (typy 4-6) kromě souborů SU3\nZastaralé síťové formáty: - LeaseSet typ 1 (použijte LeaseSet2) - Lease (44 bytů, použijte Lease2) - Původní formát vypršení platnosti Lease\nZastaralé transporty: - NTCP (odstraněno ve verzi 0.9.50) - SSU (odstraněno ve verzi 2.4.0)\nZastaralé certifikáty: - HASHCASH (typ 1) - HIDDEN (typ 2) - SIGNED (typ 3) - MULTIPLE (typ 4)\nBezpečnostní aspekty Generování klíčů: - Vždy používejte kryptograficky bezpečné generátory náhodných čísel - Nikdy znovu nepoužívejte klíče napříč různými kontexty - Chraňte soukromé klíče pomocí vhodných mechanismů řízení přístupu - Po dokončení bezpečně vymažte klíčový materiál z paměti\nOvěření podpisu: - Vždy ověřujte podpisy, než budete datům důvěřovat - Zkontrolujte, že délka podpisu odpovídá typu klíče - Ověřte, že podepsaná data obsahují očekávaná pole - U seřazených map ověřte řazení před podepsáním/ověřením\nOvěření časových razítek: - Zkontrolujte, že publikované časy jsou rozumné (ne v příliš vzdálené budoucnosti) - Ověřte, že platnost lease (záznam v leaseSet) nevypršela - Zohledněte toleranci odchylky hodin (typicky ±30 sekund)\nSíťová databáze (netDb): - Ověřte všechny struktury před uložením - Prosazujte limity velikosti, abyste zabránili DoS - Omezujte rychlost dotazů a publikací - Ověřte, že klíče databáze odpovídají hashům struktur\nPoznámky ke kompatibilitě Zpětná kompatibilita: - ElGamal a DSA_SHA1 jsou stále podporovány pro starší routers - Zastaralé typy klíčů zůstávají funkční, ale jejich používání se nedoporučuje - Komprimovatelný padding (komprimovatelná vycpávka) (Proposal 161 ) zpětně kompatibilní až k verzi 0.6\nDopředná kompatibilita: - Neznámé typy klíčů lze parsovat pomocí délkových polí - Neznámé typy certifikátů lze přeskočit pomocí délky - Neznámé typy podpisů by měly být zpracovány korektně - Implementace by neměly selhávat kvůli neznámým volitelným funkcím\nMigrační strategie: - Během přechodu podporovat jak staré, tak nové typy klíčů - LeaseSet2 (nová verze formátu LeaseSet) může uvádět více šifrovacích klíčů - Offline podpisy umožňují bezpečnou rotaci klíčů - MetaLeaseSet (metazáznam LeaseSet pro migraci služeb) umožňuje transparentní migraci služby\nTestování a validace Validace struktury: - Ověřte, že všechna délková pole jsou v očekávaných rozsazích - Zkontrolujte, že struktury s proměnnou délkou se správně parsují - Ověřte, že ověření podpisů proběhne úspěšně - Testujte se strukturami minimální i maximální velikosti\nOkrajové případy: - Řetězce nulové délky - Prázdná mapování - Minimální a maximální počty lease (záznamů v leaseSetu) - Certifikát s nulovou délkou užitečných dat - Velmi velké struktury (blízko maximální velikosti)\nInteroperabilita: - Testovat proti oficiální implementaci I2P v Javě - Ověřit kompatibilitu s i2pd - Testovat s různým obsahem síťové databáze - Validovat vůči ověřeným referenčním testovacím vektorům\nReference Specifikace Protokol I2NP Protokol I2CP Transport SSU2 Transport NTCP2 Protokol Tunnel Datagramový protokol Kryptografie Přehled kryptografie Šifrování ElGamal/AES Šifrování ECIES-X25519 ECIES pro Routers Hybridní ECIES (postkvantový) Podpisy Red25519 Šifrovaný LeaseSet Návrhy Návrh 123: Nové záznamy v netDB Návrh 134: Typy podpisů GOST Návrh 136: Experimentální typy podpisů Návrh 145: ECIES-P256 Návrh 156: ECIES routery Návrh 161: Generování vycpávky Návrh 167: Záznamy služeb Návrh 169: Postkvantová kryptografie Rejstřík všech návrhů Síťová databáze Přehled síťové databáze Standardní možnosti RouterInfo Referenční dokumentace API JavaDoc Balíček základních dat PublicKey PrivateKey SessionKey SigningPublicKey SigningPrivateKey Signature Hash SessionTag TunnelId Certificate DataHelper KeysAndCert RouterIdentity Destination Lease LeaseSet Lease2 LeaseSet2 MetaLease MetaLeaseSet EncryptedLeaseSet RouterAddress RouterInfo Externí standardy RFC 7748 (X25519): Eliptické křivky pro zabezpečení RFC 7539 (ChaCha20): ChaCha20 a Poly1305 pro protokoly IETF RFC 4648 (Base64): Kódování dat Base16, Base32 a Base64 FIPS 180-4 (SHA-256): Bezpečnostní hašovací standard FIPS 204 (ML-DSA): Module-Lattice-Based Digital Signature Standard (standard digitálních podpisů založený na mřížkové kryptografii s moduly) Registr služeb IANA Zdroje komunity Webové stránky I2P Fórum I2P I2P GitLab Zrcadlo I2P na GitHubu Index technické dokumentace Informace o vydání Vydání I2P 2.10.0 Historie vydání Seznam změn Příloha: Stručné referenční tabulky Rychlý přehled typů klíčů Aktuální standard (doporučený pro všechny nové implementace): - Šifrování: X25519 (typ 4, 32 bajtů, little-endian) - Podepisování: EdDSA_SHA512_Ed25519 (typ 7, 32 bajtů, little-endian)\nStarší (podporováno, ale zastaralé): - Šifrování: ElGamal (typ 0, 256 bajtů, big-endian (nejvýznamnější bajt první)) - Podepisování: DSA_SHA1 (typ 0, 20bajtový soukromý / 128bajtový veřejný, big-endian)\nSpecializované: - Podpis (šifrovaný LeaseSet): RedDSA_SHA512_Ed25519 (typ 11, 32 bajtů, little-endian)\nPostkvantové (beta, zatím nefinalizované): - Hybridní šifrování: varianty MLKEM_X25519 (typy 5-7) - Čistě postkvantové šifrování: varianty MLKEM (zatím nemají přiřazené kódy typů)\nRychlý přehled velikostí struktur Structure Minimum Size Typical Size Maximum Size Integer1 byteVaries8 bytes Date8 bytes8 bytes8 bytes String1 byteVaries256 bytes SessionKey32 bytes32 bytes32 bytes Hash32 bytes32 bytes32 bytes TunnelId4 bytes4 bytes4 bytes Certificate3 bytes7 bytes65,538 bytes KeysAndCert387 bytes391 bytes≈1000+ bytes RouterIdentity387 bytes391 bytes≈1000+ bytes Destination387 bytes391 bytes≈1000+ bytes Lease44 bytes44 bytes44 bytes Lease240 bytes40 bytes40 bytes LeaseSet≈1000 bytes≈1200 bytes≈2000+ bytes LeaseSet2≈500 bytes≈800 bytes≈2000+ bytes EncryptedLeaseSet≈600 bytes≈1000 bytes≈3000+ bytes RouterAddress≈150 bytes≈300 bytes≈600 bytes RouterInfo≈1000 bytes≈1500 bytes≈3000+ bytes ### Rychlý přehled typů databází Type Structure Status Notes 0RouterInfoCurrentStored under Hash(RouterIdentity) 1LeaseSetDeprecatedUse LeaseSet2 instead 3LeaseSet2CurrentStored under Hash(Destination) 5EncryptedLeaseSetCurrentStored under Hash(Blinded Destination) 7MetaLeaseSetDefinedVerify production status ### Rychlá referenční příručka k transportním protokolům Protocol Status Port Type Since Notes SSU2CurrentUDP0.9.54Default since 0.9.56 NTCP2CurrentTCP0.9.36Active SSURemovedUDP-Removed in 2.4.0 NTCPRemovedTCP-Removed in 0.9.50 ### Rychlý přehled verzí a milníků Version API Date Key Changes 0.60.6.x2005Destination encryption disabled 0.9.120.9.12Dec 2013Key Certificates introduced 0.9.150.9.15Sep 2015EdDSA support added 0.9.160.9.16Nov 2015Router Key Certificates 0.9.360.9.36Aug 2018NTCP2 introduced 0.9.380.9.38Nov 2018LeaseSet2, X25519 for Destinations 0.9.390.9.39Dec 2018EncryptedLeaseSet working 0.9.480.9.48Jul 2020X25519 for Router Identities 0.9.500.9.50May 2021NTCP removed 0.9.540.9.54May 2022SSU2 testing 0.9.570.9.57Jan 2023[Proposal 161](/cs/proposals/161-ri-dest-padding/) padding (release 2.1.0) 0.9.580.9.58Mar 2023ElGamal/DSA deprecated for RIs (2.2.0) 0.9.660.9.66Jun 2025[Proposal 167](/proposals/167-service-records/) service records (2.9.0) 0.9.670.9.67Sep 2025ML-KEM beta support (2.10.0) --- ","description":"Sdílené datové typy a serializační formáty používané napříč specifikacemi I2P","id":"178a1cfe9e5d2970a6e9f8d07c374b78","section":"docs","title":"Společné struktury","url":"/cs/docs/specs/common-structures/"},{"categories":null,"content":"1. Přehled Záznamy v clients.config říkají routeru, které aplikace spustit při startu. Každý záznam může běžet jako managed klient (preferováno) nebo jako unmanaged klient. Managed klienti spolupracují s ClientAppManager, který:\nVytváří instanci aplikace a sleduje stav životního cyklu pro router console Zpřístupňuje uživateli ovládací prvky start/stop a vynucuje čisté ukončení při vypnutí routeru Hostuje odlehčený client registry a port mapper, aby aplikace mohly objevovat vzájemné služby Nespravované klienty jednoduše vyvolávají metodu main(); používejte je pouze pro starší kód, který nelze modernizovat.\n2. Implementace Managed Client Managed klienti musí implementovat buď net.i2p.app.ClientApp (pro aplikace určené uživatelům) nebo net.i2p.router.app.RouterApp (pro rozšíření routeru). Poskytněte jeden z níže uvedených konstruktorů, aby mohl manager dodat kontext a konfigurační argumenty:\npublic MyClientApp(I2PAppContext context, ClientAppManager manager, String[] args) public MyRouterApp(RouterContext context, ClientAppManager manager, String[] args) Pole args obsahuje hodnoty nakonfigurované v clients.config nebo v jednotlivých souborech v clients.config.d/. Pokud je to možné, rozšiřte pomocné třídy ClientApp / RouterApp, abyste zdědili výchozí propojení životního cyklu.\n2.1 Lifecycle Methods Očekává se, že spravovaní klienti implementují:\nstartup() - provede inicializaci a okamžitě se vrátí. Musí alespoň jednou zavolat manager.notify() pro přechod ze stavu INITIALIZED. shutdown(String[] args) - uvolní zdroje a zastaví vlákna na pozadí. Musí alespoň jednou zavolat manager.notify() pro změnu stavu na STOPPING nebo STOPPED. getState() - informuje konzoli, zda aplikace běží, spouští se, zastavuje se nebo selhala Manažer volá tyto metody, když uživatelé interagují s konzolí.\n2.2 Advantages Přesné hlášení stavu v konzoli routeru Čisté restarty bez úniku vláken nebo statických odkazů Nižší paměťová náročnost po zastavení aplikace Centralizované logování a hlášení chyb prostřednictvím injektovaného kontextu 3. Unmanaged Clients (Fallback Mode) Pokud nakonfigurovaná třída neimplementuje managed interface, router ji spustí vyvoláním main(String[] args) a nemůže sledovat výsledný proces. Konzole zobrazuje omezené informace a shutdown hooks se nemusí spustit. Tento režim vyhraďte pro skripty nebo jednorázové utility, které nemohou přijmout managed API.\n4. Client Registry Managed i unmanaged klienti se mohou registrovat u manageru, aby ostatní komponenty mohly získat referenci podle jména:\nmanager.register(this); Registrace používá návratovou hodnotu getName() klienta jako klíč registru. Známé registrace zahrnují console, i2ptunnel, Jetty, outproxy a update. K získání klienta použijte ClientAppManager.getRegisteredApp(String name) pro koordinaci funkcí (například konzole dotazující se Jetty na detaily stavu).\nPoznámka: registr klientů a mapovač portů jsou oddělené systémy. Registr klientů umožňuje meziapolikační komunikaci pomocí vyhledávání podle jména, zatímco mapovač portů mapuje názvy služeb na kombinace host:port pro objevování služeb.\n3. Nespravovaní klienti (režim návratu) Mapovač portů nabízí jednoduchý adresář pro interní TCP služby. Registrujte loopback porty, aby spolupracovníci nemuseli používat natvrdo zakódované adresy:\ncontext.portMapper().register(PortMapper.SVC_HTTPS_PROXY, 4445); Nebo s explicitním zadáním hostitele:\ncontext.portMapper().register(PortMapper.SVC_HTTP_PROXY, \u0026#34;127.0.0.1\u0026#34;, 4444); Vyhledávejte služby pomocí PortMapper.getPort(String name) (vrací -1, pokud není nalezena) nebo getPort(String name, int defaultPort) (vrací výchozí hodnotu, pokud není nalezena). Zkontrolujte stav registrace pomocí isRegistered(String name) a získejte registrovaný host pomocí getActualHost(String name).\nBěžné konstanty služby mapování portů z net.i2p.util.PortMapper:\nSVC_CONSOLE - Konzole routeru (výchozí port 7657) SVC_HTTP_PROXY - HTTP proxy (výchozí port 4444) SVC_HTTPS_PROXY - HTTPS proxy (výchozí port 4445) SVC_I2PTUNNEL - Správce I2PTunnel SVC_SAM - SAM bridge (výchozí port 7656) SVC_SAM_SSL - SAM bridge SSL SVC_SAM_UDP - SAM UDP SVC_BOB - BOB bridge (výchozí port 2827) SVC_EEPSITE - Standardní eepsite (výchozí port 7658) SVC_HTTPS_EEPSITE - HTTPS eepsite SVC_IRC - IRC tunnel (výchozí port 6668) SVC_SUSIDNS - SusiDNS Poznámka: httpclient, httpsclient a httpbidirclient jsou typy tunelů i2ptunnel (používané v konfiguraci tunnel.N.type), nikoli konstanty služby pro mapování portů.\n4. Registr klientů 2.1 Metody životního cyklu Od verze 0.9.42 router podporuje rozdělení konfigurace do samostatných souborů v adresáři clients.config.d/. Každý soubor obsahuje vlastnosti pro jednoho klienta, přičemž všechny vlastnosti mají předponu clientApp.0.:\nclientApp.0.main=net.i2p.router.web.RouterConsoleRunner clientApp.0.name=Router Console clientApp.0.args=7657 ::1,127.0.0.1 ./webapps/ clientApp.0.delay=0 clientApp.0.onBoot=true Toto je doporučený přístup pro nové instalace a pluginy.\n2.2 Výhody Z důvodu zpětné kompatibility používá tradiční formát sekvenční číslování:\nclientApp.0.main=net.i2p.router.web.RouterConsoleRunner clientApp.0.name=Router Console clientApp.0.args=7657 ::1,127.0.0.1 ./webapps/ clientApp.1.main=net.i2p.apps.systray.UrlLauncher clientApp.1.name=URL Launcher clientApp.1.delay=5 6.3 Configuration Properties Povinné: - main - Úplný název třídy implementující ClientApp nebo RouterApp, nebo obsahující statickou metodu main(String[] args)\nVolitelné: - name - Zobrazované jméno pro router console (výchozí je název třídy) - args - Argumenty oddělené mezerami nebo tabulátory (podporuje řetězce v uvozovkách) - delay - Sekundy před spuštěním (výchozí 120) - onBoot - Vynutí delay=0, pokud je true - startOnLoad - Povoluje/zakazuje klienta (výchozí true)\nSpecifické pro plugin: - stopargs - Argumenty předané během vypnutí - uninstallargs - Argumenty předané během odinstalace pluginu - classpath - Čárkou oddělené dodatečné položky classpath\nSubstituce proměnných pro pluginy: - $I2P - Základní adresář I2P - $CONFIG - Adresář s konfigurací uživatele (např. ~/.i2p) - $PLUGIN - Adresář pluginu - $OS - Název operačního systému - $ARCH - Název architektury\n5. Port Mapper Preferujte spravované klienty; vraťte se k nespravovaným pouze v případě absolutní nutnosti. Udržujte inicializaci a vypínání nenáročné, aby operace konzole zůstaly responzivní. Používejte popisné názvy registrů a portů, aby diagnostické nástroje (a koncoví uživatelé) pochopili, co služba dělá. Vyhýbejte se statickým singletonům - spoléhejte na vložený kontext a manager pro sdílení zdrojů. Volajte manager.notify() při všech změnách stavu pro udržení přesného stavu konzole. Pokud musíte běžet v samostatném JVM, zdokumentujte, jak se logy a diagnostika zobrazují v hlavní konzoli. Pro externí programy zvažte použití ShellService (přidáno ve verzi 1.7.0) pro získání výhod spravovaného klienta. 6. Formát konfigurace Managed clients byly představeny ve verzi 0.9.4 (17. prosince 2012) a zůstávají doporučenou architekturou k verzi 2.10.0 (9. září 2025). Základní API zůstala stabilní s nulou breaking changes během tohoto období:\nSignatury konstruktorů nezměněny Metody životního cyklu (startup, shutdown, getState) nezměněny Registrační metody ClientAppManager nezměněny Registrační a vyhledávací metody PortMapper nezměněny Významná vylepšení: - 0.9.42 (2019) - adresářová struktura clients.config.d/ pro jednotlivé konfigurační soubory - 1.7.0 (2021) - přidána ShellService pro sledování stavu externích programů - 2.10.0 (2025) - aktuální vydání bez změn v API spravovaných klientů\nDalší hlavní vydání bude vyžadovat minimálně Java 17+ (požadavek na infrastrukturu, nikoli změna API).\nReferences Specifikace clients.config Specifikace konfiguračního souboru Index technické dokumentace I2P ClientAppManager Javadoc (API 0.9.66) PortMapper Javadoc (API 0.9.66) Rozhraní ClientApp (API 0.9.66) Rozhraní RouterApp (API 0.9.66) Alternativní Javadoc (stabilní) Alternativní Javadoc (clearnet mirror) Poznámka: Síť I2P hostuje komplexní dokumentaci na adrese http://idk.i 2p/javadoc-i2p/, která vyžaduje pro přístup I2P router. Pro přístup z běžného internetu použijte výše uvedené zrcadlo na GitHub Pages.\n","description":"Jak aplikace spravované routerem integrují s ClientAppManager a mapovačem portů","id":"f9e2324a49e9ed9bf413b4c636d5d1b6","section":"docs","title":"Spravovaní klienti","url":"/cs/docs/applications/managed-clients/"},{"categories":null,"content":" Zastaralé: SSU bylo nahrazeno SSU2. Podpora byla odstraněna ve verzi i2pd 2.44.0 (API 0.9.56, listopad 2022) a ve verzi Java I2P 2.4.0 (API 0.9.61, prosinec 2023).\nSSU poskytoval na UDP založené, částečně spolehlivé doručování s řízením přetížení, průchodem NATem a podporou introducerů (prostředníků pro navázání spojení). Doplňoval NTCP tím, že obsluhoval routers za NATem/firewally a koordinoval zjišťování IP adres.\nPrvky adresy transport: SSU caps: příznaky schopností (B, C, 4, 6, atd.) host / port: naslouchající pro IPv4 nebo IPv6 (volitelné, pokud je za firewallem) key: úvodní klíč v Base64 mtu: Volitelné; výchozí 1484 (IPv4) / 1488 (IPv6) ihost/ikey/iport/itag/iexp: záznamy introduceru (prostředník pro navázání spojení), když je router za firewallem Funkce Kooperativní traverzování NAT pomocí introducers (zprostředkovatelů) Zjišťování lokální IP pomocí testů peerů a inspekce příchozích paketů Automatické předávání stavu firewallu ostatním transportům a konzoli routeru Polospolehlivé doručování: zprávy jsou znovu odesílány až do určitého limitu, poté jsou zahazovány Řízení zahlcení s aditivním zvyšováním / multiplikativním snižováním a bitovými poli ACK fragmentů SSU také zajišťoval metadatové úlohy, jako jsou časovací majáky a vyjednávání MTU. Veškerá funkcionalita je nyní poskytována (s moderní kryptografií) protokolem SSU2 .\n","description":"Původní zabezpečený polospolehlivý transport přes UDP","id":"15d4d0ea2bfc8074b5a7981b8673c420","section":"docs","title":"SSU (starší)","url":"/cs/docs/legacy/ssu/"},{"categories":null,"content":" Zastaralé: SSU (Secure Semi-Reliable UDP, zabezpečený částečně spolehlivý UDP) byl nahrazen SSU2 . Java I2P odstranil SSU ve verzi 2.4.0 (API 0.9.61) a i2pd jej odstranil ve verzi 2.44.0 (API 0.9.56). Tento dokument je ponechán pouze pro historické účely.\nHlavní body UDP transport poskytující šifrované, autentizované doručování zpráv I2NP v režimu bod‑bod. Spoléhal na 2048bitový Diffie–Hellmanův handshake (stejné prvočíslo jako u ElGamalu). Každý datagram nesl 16bajtový HMAC-MD5 (nestandardní zkrácená varianta) + 16bajtový IV, po nichž následovala užitečná data šifrovaná pomocí AES-256-CBC. Ochrana proti opakování (replay) a stav relace byly sledovány v rámci šifrovaných užitečných dat. Hlavička zprávy [16-byte MAC][16-byte IV][encrypted payload] Použitý výpočet MAC: HMAC-MD5(ciphertext || IV || (len ^ version ^ ((netid-2)\u0026lt;\u0026lt;8))) s 32bajtovým MAC klíčem. Délka užitečných dat byla 16bitová v pořadí bajtů big-endian a byla připojena do vstupu pro výpočet MAC. Verze protokolu měla výchozí hodnotu 0; netId mělo výchozí hodnotu 2 (hlavní síť).\nRelační klíče a klíče MAC (kód autentizace zprávy) Odvozeno ze sdíleného tajemství DH (Diffie-Hellman):\nPřeveďte sdílenou hodnotu na bajtové pole ve formátu big-endian (přidejte 0x00 na začátek, pokud je nastaven nejvyšší bit). Klíč relace: prvních 32 bajtů (doplňte nulami, je-li kratší). Klíč MAC: bajty 33–64; pokud jich není dost, použijte místo toho hash SHA-256 sdílené hodnoty. Stav Routers již neoznamují SSU adresy. Klienti by měli přejít na transporty SSU2 nebo NTCP2. Historické implementace lze najít ve starších vydáních:\nZdrojové kódy v jazyce Java starší než 2.4.0 v adresáři router/transport/udp Zdrojové kódy i2pd starší než 2.44.0 Aktuální chování UDP transportu naleznete v specifikaci SSU2 .\n","description":"Původní transport přes UDP používaný před SSU2","id":"1eefecf66e3adc6ea013d5a5e58326da","section":"docs","title":"SSU transport (zastaralý)","url":"/cs/docs/legacy/ssu/"},{"categories":null,"content":" Stav zastaralosti: Tento obsah je zachován pouze pro historické referenční účely. Popisuje tunnel system, který byl distribuován před I2P 0.6.1.10 a neměl by se používat pro moderní vývoj. Pro pokyny k produkčnímu nasazení viz aktuální implementaci .\nPůvodní tunnel subsystém také používal jednosměrné tunnels, ale lišil se uspořádáním zpráv, detekcí duplicit a strategií vytváření. Mnoho sekcí níže zrcadlí strukturu zastaralého dokumentu, aby usnadnilo srovnání.\n1. Přehled Tunnel Tunnels byly vytvářeny jako uspořádané sekvence peerů vybraných tvůrcem. Tunnel lengths se pohybovaly v rozmezí 0–7 hopů, s několika možnostmi nastavení pro padding (doplnění dat), throttling (regulaci rychlosti) a chaff generation (generování šumu). Příchozí tunnels doručovaly zprávy z nedůvěryhodné brány k tvůrci (koncový bod); odchozí tunnels odesílaly data od tvůrce směrem ven. Životnost tunnels byla 10 minut, po uplynutí této doby se konstruovaly nové tunnels (často se stejnými peery, ale s odlišnými tunnel IDs). 2. Provoz v původním návrhu 2.1 Předzpracování zprávy Brány shromáždily ≤32 KB užitečných dat I2NP, zvolily výplň a vytvořily užitečná data obsahující:\nDvoubytové pole délky výplně (padding length) a právě tolik náhodných bajtů Sekvence dvojic {instructions, I2NP message} popisujících cíle doručení, fragmentaci a volitelná zpoždění Celé zprávy I2NP zarovnané (výplní) na hranici 16 bajtů Pokyny pro doručení zapouzdřovaly směrovací informace do bitových polí (typ doručení, příznaky zpoždění, příznaky fragmentace a volitelná rozšíření). Fragmentované zprávy obsahovaly 4bajtové ID zprávy a příznak indexu/posledního fragmentu.\n2.2 Šifrování na bráně Starší návrh stanovil délku tunnelu pro šifrovací fázi na osm skoků. Brány skládaly vrstvy AES-256/CBC spolu s bloky s kontrolním součtem, aby každý skok mohl ověřit integritu, aniž by se zmenšila užitečná data. Samotný kontrolní součet byl blok odvozený ze SHA-256, vložený do zprávy.\n2.3 Chování účastníků Účastníci sledovali ID příchozích tunnelů, včas ověřovali integritu a před přeposláním zahazovali duplikáty. Protože vycpávky a ověřovací bloky byly zabudovány, velikost zprávy zůstávala konstantní bez ohledu na počet skoků.\n2.4 Zpracování koncového bodu Koncové body postupně dešifrovaly vrstvené bloky, ověřily kontrolní součty a rozdělily užitečná data zpět na zakódované instrukce a zprávy I2NP pro další doručení.\n3. Sestavování tunnelů (zastaralý proces) Výběr peerů: Peerové byli vybíráni z lokálně spravovaných profilů (průzkumné (exploratory) vs. klientské (client)). Původní dokument už zdůrazňoval zmírnění útoku předchůdce opětovným používáním seřazených seznamů peerů pro každý tunnel pool. Doručování požadavků: Zprávy pro sestavení byly předávány postupně (hop-by-hop) se šifrovanými částmi pro každý peer. Alternativní nápady, jako teleskopické rozšiřování (telescopic extension), přesměrování uprostřed cesty (midstream rerouting) nebo odstranění bloků kontrolních součtů, byly diskutovány jako experimenty, ale nikdy nebyly přijaty. Poolování: Každá místní destinace měla samostatné příchozí a odchozí pooly. Nastavení zahrnovala požadované množství, záložní tunnels, variabilitu délky, omezování rychlosti a zásady výplně (padding). 4. Koncepty škrcení a mixování Starší dokument navrhl několik strategií, které ovlivnily pozdější vydání:\nVážené náhodné předčasné zahazování (WRED) pro řízení zahlcení Limity pro každý tunnel založené na klouzavých průměrech nedávného využití Volitelné chaff (výplňová data) a řízení dávkování (není plně implementováno) 5. Archivované alternativy Části původního dokumentu se zabývaly myšlenkami, které nikdy nebyly nasazeny:\nOdstranění bloků kontrolního součtu ke snížení zpracování na každém hopu Teleskopické rozšiřování tunnels za běhu za účelem změny složení uzlů Přechod na obousměrné tunnels (nakonec zamítnuto) Použití kratších hashů nebo odlišných schémat doplňování Tyto myšlenky mají i nadále hodnotu jako historický kontext, ale neodrážejí moderní kódovou základnu.\nReference Původní archiv zastaralých dokumentů (před verzí 0.6.1.10) Přehled Tunnel pro aktuální terminologii Profilování a výběr protějšků pro moderní heuristiky ","description":"Archivní popis návrhu pro tunnel, který se používal před I2P 0.6.1.10.","id":"0970f5387a965fe6857e4afbb03bdc8f","section":"docs","title":"Starší implementace Tunnelu (zastaralé)","url":"/cs/docs/legacy/old-implementation/"},{"categories":null,"content":"Přehled I2P Streaming Library poskytuje spolehlivý, uspořádaný a autentizovaný přenos přes zprávy I2P, podobně jako TCP over IP. Nachází se nad protokolem I2CP a používají jej téměř všechny interaktivní aplikace I2P, včetně HTTP proxy, IRC, BitTorrentu a emailu.\nZákladní charakteristiky Jednofázové navázání spojení pomocí příznaků SYN, ACK a FIN, které mohou být sdruženy s užitečnými daty pro snížení počtu přenosových cyklů. Řízení zahltění pomocí posuvného okna s pomalým startem a vyhýbáním se zahlcení optimalizovaným pro prostředí I2P s vysokou latencí. Komprese paketů (výchozí 4KB komprimované segmenty) vyvažující náklady na opětovný přenos a latenci fragmentace. Plně autentizovaná, šifrovaná a spolehlivá abstrakce kanálu mezi I2P destinacemi. Tento design umožňuje dokončit malé HTTP požadavky a odpovědi v jediném cyklu. SYN paket může nést payload požadavku, zatímco SYN/ACK/FIN respondenta může obsahovat celé tělo odpovědi.\nZáklady API Java streaming API kopíruje standardní programování soketů v Javě:\nI2PSocketManager mgr = I2PSocketManagerFactory.createManager(host, port, options); I2PSocket socket = mgr.connect(destination); I2PServerSocket server = mgr.getServerSocket(); I2PSocketManagerFactory vyjednává nebo znovu používá session routeru přes I2CP. Pokud není poskytnut klíč, je automaticky vygenerována nová destinace. Vývojáři mohou předat I2CP volby (např. délky tunelů, typy šifrování nebo nastavení připojení) pomocí mapy options. I2PSocket a I2PServerSocket zrcadlí standardní Java rozhraní Socket, což usnadňuje migraci. Kompletní Javadocs jsou dostupné z I2P router console nebo zde .\nKonfigurace a ladění Konfigurační vlastnosti můžete předat při vytváření správce socketů pomocí:\nI2PSocketManagerFactory.createManager(host, port, properties); Klíčové možnosti Option Description Default i2p.streaming.maxWindowSize Maximum send window (bytes) 128 KB i2p.streaming.initialRTO Initial retransmission timeout 9s i2p.streaming.inactivityTimeout Timeout before connection close 90s i2p.streaming.enforceProtocol Enforce protocol ID (prevents confusion) true i2p.streaming.congestionAlgorithm Congestion control method Default (AIMD TCP-like) i2p.streaming.disableRejectLogging Disable logging rejected packets false ### Chování podle zátěže Workload Recommended Settings HTTP-like Default parameters are ideal. Bulk Transfer Increase window size to 256 KB or 512 KB; lengthen timeouts. Real-time Streaming Lower tunnel length to 1-2 hops; adjust RTO downwards. Novější funkce od verze 0.9.4 zahrnují potlačení záznamů o odmítnutí, podporu DSA seznamů (0.9.21) a vynucené dodržování protokolu (0.9.36). Routery od verze 2.10.0 zahrnují post-kvantové hybridní šifrování (ML-KEM + X25519) na transportní vrstvě. Detaily protokolu Každý stream je identifikován pomocí Stream ID. Pakety nesou kontrolní příznaky podobné TCP: SYNCHRONIZE, ACK, FIN a RESET. Pakety mohou současně obsahovat jak data, tak kontrolní příznaky, což zlepšuje efektivitu krátkodobých spojení.\nŽivotní cyklus spojení SYN odeslán — iniciátor zahrnuje volitelná data. SYN/ACK odpověď — respondent zahrnuje volitelná data. ACK finalizace — navazuje spolehlivost a stav relace. FIN/RESET — používá se pro řádné uzavření nebo náhlé ukončení. Fragmentace a přeuspořádání Protože I2P tunnely zavádějí latenci a změnu pořadí zpráv, knihovna ukládá pakety z neznámých nebo předčasně přicházejících streamů do vyrovnávací paměti. Uložené zprávy jsou uchovávány až do dokončení synchronizace, což zajišťuje úplné doručení ve správném pořadí.\nVynucení protokolu Volba i2p.streaming.enforceProtocol=true (výchozí od verze 0.9.36) zajišťuje, že připojení používají správné číslo I2CP protokolu, čímž zabraňuje konfliktům mezi více subsystémy sdílejícími jednu destinaci.\nInteroperabilita a osvědčené postupy Protokol streaming koexistuje s Datagram API, což vývojářům poskytuje možnost volby mezi spojově orientovanou a nespojovou přenosovou vrstvou.\nUse Case Recommended Transport Reliable, ordered data (HTTP, IRC, FTP) Streaming Connectionless or lossy data (DNS, telemetry) Datagram ### Sdílení klienti Aplikace mohou opětovně využívat existující tunnely tím, že běží jako sdílení klienti, což umožňuje více službám sdílet stejnou destinaci. I když to snižuje režii, zvyšuje to riziko korelace mezi službami—používejte opatrně.\nŘízení zahlcení Vrstva streamování se průběžně přizpůsobuje latenci a propustnosti sítě prostřednictvím zpětné vazby založené na RTT. Aplikace fungují nejlépe, když routery jsou přispívajícími uzly (zapnuté účastnické tunnely). Mechanismy kontroly zahlcení podobné TCP zabraňují přetížení pomalých uzlů a pomáhají vyvážit využití šířky pásma napříč tunnely. Úvahy o latenci Protože I2P přidává několik stovek milisekund základní latence, aplikace by měly minimalizovat počet přenosů tam a zpět. Pokud je to možné, seskupte data s navázáním spojení (např. HTTP požadavky v SYN). Vyhněte se návrhům spoléhajícím na mnoho malých sekvenčních výměn dat.\nTestování a Kompatibilita Vždy testujte proti Java I2P i i2pd, abyste zajistili plnou kompatibilitu. Ačkoli je protokol standardizovaný, mohou existovat drobné rozdíly v implementaci. Zacházejte s staršími routery ohleduplně—mnoho protějšků stále používá verze před 2.0. Sledujte statistiky připojení pomocí I2PSocket.getOptions() a getSession() pro čtení RTT a metrik retransmise. Výkon značně závisí na konfiguraci tunnelu: - Krátké tunnely (1–2 hopy) → nižší latence, snížená anonymita. - Dlouhé tunnely (3+ hopy) → vyšší anonymita, zvýšené RTT.\nKlíčová vylepšení (2.0.0–2.10.0) Feature Introduced Description Persistent ACK Bundling 2.0.0 Optimized round-trip reduction for HTTP workloads. Adaptive Window Scaling 2.3.0 Improved large file transfer stability. Thread Pooling and Socket Reuse 2.5.0 Reduced per-connection overhead. Protocol Enforcement Default 0.9.36 Ensures correct stream usage. Hybrid ML-KEM Ratchet 2.10.0 Adds post-quantum hybrid encryption layer. i2pd Streaming API Compatibility Fixes 2.9.0 Full parity with Java I2P library behavior. --- Shrnutí I2P Streaming Library je páteří veškeré spolehlivé komunikace v rámci I2P. Zajišťuje doručování zpráv ve správném pořadí, autentizované a šifrované, a poskytuje téměř přímou náhradu za TCP v anonymních prostředích.\nPro dosažení optimálního výkonu: - Minimalizujte počet přenosů pomocí sdružování SYN+payload. - Upravte parametry okna a timeoutu podle vašeho zatížení. - U aplikací citlivých na latenci upřednostněte kratší tunnely. - Používejte návrhy šetrné ke kongesti, abyste nepřetěžovali ostatní uzly.\n","description":"Transportní protokol podobný TCP, používaný většinou I2P aplikací","id":"d5eaf45dea26928a910e0f2b8a0e1037","section":"docs","title":"Streamovací protokol","url":"/cs/docs/api/streaming/"},{"categories":null,"content":"Přehled I2P Streaming Library (knihovna pro streamování v I2P) poskytuje spolehlivé, se zachováním pořadí a autentizované doručování dat nad nespolehlivou vrstvou zpráv I2P — analogicky k TCP nad IP. Používají ji téměř všechny interaktivní aplikace I2P, jako je prohlížení webu, IRC, e‑mail a sdílení souborů.\nZajišťuje spolehlivý přenos, řízení zahlcení, retransmise a řízení toku napříč anonymními I2P tunnels s vysokou latencí. Každý datový proud je mezi destinacemi plně šifrován end-to-end.\nZákladní principy návrhu Streamovací knihovna implementuje jednofázové navázání spojení, kde příznaky SYN, ACK a FIN mohou nést užitečná data ve stejné zprávě. To minimalizuje počet kol cesty v prostředích s vysokou latencí — malá HTTP transakce se může dokončit během jediného kola cesty.\nŘízení zahlcení a opětovné odesílání jsou inspirovány TCP, ale přizpůsobeny prostředí I2P. Velikost okna je založená na zprávách, nikoli na bajtech, a je vyladěna s ohledem na latenci tunnelu a režii. Protokol podporuje pomalý start, vyhýbání se zahlcení a exponenciální backoff (exponenciální zpožďování), podobně jako AIMD algoritmus TCP.\nArchitektura Streamovací knihovna funguje mezi aplikacemi a rozhraním I2CP.\nLayer Responsibility Application Standard I2PSocket and I2PServerSocket usage Streaming Library Connection setup, sequencing, retransmission, and flow control I2CP Tunnel creation, routing, and message handling I2NP / Router Layer Transport through tunnels Většina uživatelů k němu přistupuje přes I2PSocketManager, I2PTunnel nebo SAMv3. Knihovna transparentně zajišťuje správu destinací, práci s tunnel a retransmise. Formát paketu +-----------------------------------------------+ | Send Stream ID (4B) | Receive Stream ID (4B) | +-----------------------------------------------+ | Sequence Number (4B) | Ack Through (4B) | +-----------------------------------------------+ | NACK Count (1B) | optional NACK list (4B each) +-----------------------------------------------+ | Flags (1B) | Option Size (1B) | Options ... | +-----------------------------------------------+ | Payload ... | Podrobnosti hlavičky Identifikátory streamů: 32bitové hodnoty, které jednoznačně identifikují lokální a vzdálené streamy. Sekvenční číslo: Začíná na 0 pro SYN, inkrementuje se pro každou zprávu. Potvrzení až do: Potvrzuje všechny zprávy až do N, s výjimkou těch v seznamu NACK. Příznaky: Bitová maska řídicí stav a chování. Volby: Seznam proměnné délky pro RTT, MTU a vyjednávání protokolu. Příznaky klíče Flag Purpose SYN Connection initiation ACK Acknowledge received packets FIN Graceful close RST Reset connection FROM_INCLUDED Sender’s destination included SIGNATURE_INCLUDED Message signed by sender ECHO / ECHO_REPLY Ping/Pong keepalive --- Řízení toku a spolehlivost Streaming používá okenní řízení založené na zprávách, na rozdíl od bajtově orientovaného přístupu TCP. Počet nepotvrzených paketů povolených v letu se rovná aktuální velikosti okna (výchozí 128).\nMechanismy Řízení zahlcení: Pomalý start a vyhýbání založené na AIMD (aditivní zvýšení/multiplikativní snížení). Choke/Unchoke (škrcení/uvolnění): Signalizace řízení toku založená na zaplnění vyrovnávací paměti. Retransmise: Výpočet RTO podle RFC 6298 s exponenciálním backoffem (exponenciální prodlužování čekací doby). Filtrování duplicit: Zajišťuje spolehlivost nad potenciálně přeuspořádanými zprávami. Typické hodnoty konfigurace:\nParameter Default Description maxWindowSize 128 Max unacknowledged messages maxMessageSize 1730 Maximum payload bytes per message initialRTO 9000 ms Initial retransmission timeout inactivityTimeout 90000 ms Idle connection timeout connectTimeout 300000 ms Connection establishment timeout --- Navázání spojení Iniciátor odešle SYN (volitelně s užitečnými daty a FROM_INCLUDED). Odpovídající strana odpoví SYN+ACK (může obsahovat užitečná data). Iniciátor odešle závěrečný ACK potvrzující navázání spojení. Volitelná počáteční užitečná data umožňují přenos dat ještě před úplným dokončením handshake.\nPodrobnosti implementace Retransmise a časový limit Algoritmus retransmise se řídí RFC 6298. - Počáteční RTO: 9s - Minimální RTO: 100ms - Maximální RTO: 45s - Alfa: 0.125 - Beta: 0.25\nSdílení řídicího bloku Nedávná spojení se stejným peerem znovu využívají předchozí data RTT a okna pro rychlejší náběh, čímž se vyhnou latenci „studeného startu“. Řídicí bloky vyprší po několika minutách.\nMTU a fragmentace Výchozí MTU: 1730 bajtů (pojme dvě I2NP zprávy). ECIES destinace: 1812 bajtů (snížená režie). Minimální podporované MTU: 512 bajtů. Velikost užitečných dat nezahrnuje minimální streamingovou hlavičku o velikosti 22 bajtů.\nHistorie verzí Router Version Feature 0.7.1 Protocol numbers defined in I2CP 0.9.11 Variable-length signatures 0.9.12 ECDSA signature support 0.9.15 Ed25519 signature support 0.9.18 Ping/Pong payloads 0.9.20 FROM_INCLUDED not required in RESET 0.9.36 Protocol enforcement enabled by default 0.9.39 OFFLINE_SIGNATURE support 0.9.58 Bob’s hash added to NACK field in SYN 2.10.0 Post-Quantum hybrid encryption (experimental) --- Použití na aplikační úrovni Příklad v Javě Properties props = new Properties(); props.setProperty(\u0026#34;i2p.streaming.maxWindowSize\u0026#34;, \u0026#34;512\u0026#34;); I2PSocketManager mgr = I2PSocketManagerFactory.createManager(props); I2PSocket socket = mgr.connect(destination); InputStream in = socket.getInputStream(); OutputStream out = socket.getOutputStream(); Podpora SAMv3 a i2pd SAMv3: Poskytuje režimy STREAM a DATAGRAM pro klienty nepsané v jazyce Java. i2pd: Zpřístupňuje totožné parametry streamování prostřednictvím voleb v konfiguračním souboru (např. i2p.streaming.maxWindowSize, profile, atd.). Volba mezi streamováním a datagramy Use Case Recommended Transport Reason HTTP, IRC, Email Streaming Requires reliability DNS Repliable Datagram Single request/response Telemetry, Logging Raw Datagram Best-effort acceptable P2P DHT Datagram High connection churn --- Bezpečnost a postkvantová budoucnost Streamingové relace jsou na vrstvě I2CP šifrovány end-to-end. Postkvantové hybridní šifrování (ML-KEM + X25519) je v 2.10.0 experimentálně podporováno, ale ve výchozím nastavení je vypnuto.\nReference Přehled API pro streamování Specifikace protokolu pro streamování Specifikace I2CP Návrh 144: Výpočty MTU pro streamování Poznámky k vydání I2P 2.10.0 ","description":"Spolehlivý transport podobný TCP, používaný většinou I2P aplikací","id":"100837c91cc0808ee048c86902b36251","section":"docs","title":"Streamovací protokol","url":"/cs/docs/specs/streaming/"},{"categories":null,"content":"Tato implementace I2P (Java implementace distribuovaná na tomto webu) obsahuje „Seznam přísných zemí\u0026quot;, který slouží k úpravě chování routeru v regionech, kde může být účast na směrování pro ostatní omezena zákonem. Přestože nejsme si vědomi jurisdikcí, které by zakazovaly používání I2P, několik z nich má široké zákazy přeposílání provozu. Routery, které se zdají být v „přísných\u0026quot; zemích, jsou automaticky přepnuty do skrytého režimu.\nProjekt odkazuje na výzkum organizací pro občanská a digitální práva při těchto rozhodnutích. Zejména průběžný výzkum Freedom House ovlivňuje naše volby. Obecné vodítko je zahrnout země s hodnocením občanských svobod (CL) 16 nebo méně, nebo s hodnocením svobody internetu 39 nebo méně (není svobodný).\nShrnutí skrytého režimu Když je router přepnut do režimu Hidden, změní se tři klíčové věci v jeho chování:\nNepublikuje RouterInfo do netDb. Nepřijímá participující tunely. Odmítá přímá připojení k routerům ve stejné zemi. Tyto obranné mechanismy ztěžují spolehlivé mapování routerů a snižují riziko porušení místních zákazů týkajících se přeposílání provozu pro ostatní.\nSeznam zemí s přísnými omezeními (k roku 2024) /* Afghanistan */ \u0026#34;AF\u0026#34;, /* Azerbaijan */ \u0026#34;AZ\u0026#34;, /* Bahrain */ \u0026#34;BH\u0026#34;, /* Belarus */ \u0026#34;BY\u0026#34;, /* Brunei */ \u0026#34;BN\u0026#34;, /* Burundi */ \u0026#34;BI\u0026#34;, /* Cameroon */ \u0026#34;CM\u0026#34;, /* Central African Republic */ \u0026#34;CF\u0026#34;, /* Chad */ \u0026#34;TD\u0026#34;, /* China */ \u0026#34;CN\u0026#34;, /* Cuba */ \u0026#34;CU\u0026#34;, /* Democratic Republic of the Congo */ \u0026#34;CD\u0026#34;, /* Egypt */ \u0026#34;EG\u0026#34;, /* Equatorial Guinea */ \u0026#34;GQ\u0026#34;, /* Eritrea */ \u0026#34;ER\u0026#34;, /* Ethiopia */ \u0026#34;ET\u0026#34;, /* Iran */ \u0026#34;IR\u0026#34;, /* Iraq */ \u0026#34;IQ\u0026#34;, /* Kazakhstan */ \u0026#34;KZ\u0026#34;, /* Laos */ \u0026#34;LA\u0026#34;, /* Libya */ \u0026#34;LY\u0026#34;, /* Myanmar */ \u0026#34;MM\u0026#34;, /* North Korea */ \u0026#34;KP\u0026#34;, /* Palestinian Territories */ \u0026#34;PS\u0026#34;, /* Pakistan */ \u0026#34;PK\u0026#34;, /* Rwanda */ \u0026#34;RW\u0026#34;, /* Saudi Arabia */ \u0026#34;SA\u0026#34;, /* Somalia */ \u0026#34;SO\u0026#34;, /* South Sudan */ \u0026#34;SS\u0026#34;, /* Sudan */ \u0026#34;SD\u0026#34;, /* Eswatini (Swaziland) */ \u0026#34;SZ\u0026#34;, /* Syria */ \u0026#34;SY\u0026#34;, /* Tajikistan */ \u0026#34;TJ\u0026#34;, /* Thailand */ \u0026#34;TH\u0026#34;, /* Turkey */ \u0026#34;TR\u0026#34;, /* Turkmenistan */ \u0026#34;TM\u0026#34;, /* Venezuela */ \u0026#34;VE\u0026#34;, /* United Arab Emirates */ \u0026#34;AE\u0026#34;, /* Uzbekistan */ \u0026#34;UZ\u0026#34;, /* Vietnam */ \u0026#34;VN\u0026#34;, /* Western Sahara */ \u0026#34;EH\u0026#34;, /* Yemen */ \u0026#34;YE\u0026#34; Pokud si myslíte, že by měla být země přidána nebo odebrána ze striktního seznamu, otevřete prosím issue: https://i2pgit.org/i2p/i2p.i2p/ Reference: Freedom House – https://freedomhouse.org/ ","description":"Jak se I2P chová v jurisdikcích s omezeními na směrování nebo nástroje pro anonymitu (Hidden Mode a striktní seznam)","id":"483dc8380c381981cff8df178412f086","section":"docs","title":"Striktní/restriktivní země","url":"/cs/docs/overview/restrictive-countries/"},{"categories":null,"content":" Stav: Tento dokument popisuje starší šifrovací protokol ElGamal/AES+SessionTag. Je nadále podporován pouze z důvodu zpětné kompatibility, protože moderní verze I2P (2.10.0+) používají ECIES-X25519-AEAD-Ratchet . Protokol ElGamal je zastaralý a je ponechán výhradně z historických a interoperabilních důvodů.\nPřehled ElGamal/AES+SessionTag poskytoval původní mechanismus end-to-end šifrování v I2P pro garlic messages (tzv. garlic zprávy v I2P). Kombinoval:\nElGamal (2048bitový) — pro výměnu klíčů AES-256/CBC — pro šifrování užitečných dat SHA-256 — pro hashování a odvození IV Značky relace (32 bajtů) — pro jednorázové identifikátory zpráv Protokol umožňoval bezpečnou komunikaci mezi routers a destinacemi bez nutnosti udržovat trvalá spojení. V každé relaci se nejprve provedla asymetrická výměna ElGamal pro vytvoření symetrického klíče AES a poté následovaly odlehčené \u0026ldquo;tagged\u0026rdquo; (označkované) zprávy odkazující na tuto relaci.\nFungování protokolu Navázání relace (nová relace) Nová relace začala zprávou obsahující dvě části:\nSection Size Contents Purpose ElGamal-encrypted block 514 bytes 222 bytes of plaintext encrypted using the recipient's ElGamal public key Establishes the AES session key and IV seed AES-encrypted block Variable (≥128 bytes typical) Payload data, integrity hash, and session tags Carries the actual message and new tags Otevřený text uvnitř bloku ElGamal se skládal z: Field Size Description Session Key 32 bytes AES-256 key for the session Pre-IV 32 bytes Material for deriving the AES initialization vector (IV = first 16 bytes of SHA-256(Pre-IV)) Random Padding 158 bytes Filler to reach required ElGamal plaintext length ### Zprávy pro existující relaci Jakmile byla relace navázána, odesílatel mohl odesílat zprávy typu existing-session pomocí uložených značek relace:\nField Size Description Session Tag 32 bytes Single-use identifier tied to the existing session key AES-Encrypted Block Variable Encrypted payload and metadata using the established AES key Routers kešovaly doručené tagy přibližně **15 minut**, poté nepoužité tagy vypršely. Každý tag byl platný přesně pro **jednu zprávu**, aby se zabránilo korelačním útokům. Formát bloku šifrovaný AES Field Size Description Tag Count 2 bytes Number (0–200) of new session tags included Session Tags 32 × N bytes Newly generated single-use tags Payload Size 4 bytes Length of the payload in bytes Payload Hash 32 bytes SHA-256 digest of the payload Flag 1 byte 0x00 normal, 0x01 = new session key follows (unused) New Session Key 32 bytes (optional) Replacement AES key (rarely used) Payload Variable Encrypted message data Padding Variable (16-byte aligned) Random padding to block boundary Router dešifrují pomocí klíče relace a IV (inicializační vektor) odvozených buď z Pre-IV (předběžný IV) pro nové relace, nebo ze značky relace pro existující relace. Po dešifrování ověří integritu znovuvýpočtem hashe SHA-256 nad prostým textem užitečných dat. Správa značek relace Tagy jsou jednosměrné: tagy Alice → Bob nelze znovu použít pro Bob → Alice. Tagy vyprší přibližně po 15 minutách. Routers udržují pro každou destinaci správce klíčů relací, kteří sledují tagy, klíče a časy vypršení. Aplikace mohou řídit chování tagů prostřednictvím voleb I2CP : i2cp.tagThreshold — minimální počet tagů v mezipaměti před doplněním i2cp.tagCount — počet nových tagů na zprávu Tento mechanismus omezil potřebu výpočetně náročných ElGamal handshake (úvodní navázání spojení) při zachování nepropojitelnosti mezi zprávami.\nKonfigurace a efektivita Session tags (značky relace) byly zavedeny ke zvýšení efektivity napříč transportem I2P s vysokou latencí a bez zaručeného pořadí. Typické nastavení doručovalo 40 tagů na zprávu, což přidávalo přibližně 1,2 KB režie. Aplikace mohly upravit chování doručování podle očekávaného provozu:\nUse Case Recommended Tags Notes Short-lived requests (HTTP, datagrams) 0 – 5 Low overhead, may trigger ElGamal fallback Persistent streams or bulk transfer 20 – 50 Higher bandwidth use, avoids session re-establishment Long-term services 50+ Ensures steady tag supply despite loss or delay Routers pravidelně odstraňují expirované tagy a pročišťují nepoužívaný stav relace, aby snížily využití paměti a zmírnily útoky zaplavováním tagy. Omezení Category Limitation Performance 514-byte ElGamal block adds heavy overhead for new sessions; session tags consume 32 bytes each. Security No forward secrecy – compromise of ElGamal private key exposes past sessions. Integrity AES-CBC requires manual hash verification; no AEAD. Quantum Resistance Vulnerable to Shor's algorithm – will not survive quantum attacks. Complexity Requires stateful tag management and careful timeout tuning. Tyto nedostatky přímo motivovaly návrh protokolu [ECIES-X25519-AEAD-Ratchet](/docs/specs/ecies/), který poskytuje dokonalé dopředné utajení, autentizované šifrování a efektivní výměnu klíčů. Zastarání a stav migrace Zavedeno: Rané verze I2P (před 0.6) Zastaralé: S uvedením ECIES-X25519 (0.9.46 → 0.9.48) Odstraněno: Už není výchozí od verze 2.4.0 (prosinec 2023) Podporováno: Pouze pro zpětnou kompatibilitu Moderní routery a destinace nyní uvádějí typ šifrování 4 (ECIES-X25519) namísto typu 0 (ElGamal/AES). Zastaralý protokol zůstává podporován kvůli interoperabilitě se zastaralými protějšky, ale neměl by se používat pro nová nasazení.\nHistorické souvislosti ElGamal/AES+SessionTag byl zásadním pilířem rané kryptografické architektury I2P. Jeho hybridní návrh přinesl inovace, jako jednorázové session tagy a jednosměrné relace, které ovlivnily následné protokoly. Mnohé z těchto myšlenek se vyvinuly v moderní schémata, jako jsou deterministic ratchets (deterministické ráčnové mechanismy) a hybrid post-quantum key exchanges (hybridní postkvantové výměny klíčů).\n","description":"Zastaralé end-to-end šifrování kombinující ElGamal, AES, SHA-256 a jednorázové značky relace","id":"092d77bf065d0f13bb2b2a470f57a902","section":"docs","title":"Šifrování ElGamal/AES + SessionTag (značka relace)","url":"/cs/docs/legacy/elgamal-aes/"},{"categories":null,"content":"Přehled Tento dokument specifikuje zaslepení, šifrování a dešifrování šifrovaného LeaseSet2 (LS2). Šifrované LeaseSets umožňují publikování informací o skrytých službách v síťové databázi I2P s řízeným přístupem.\nKlíčové vlastnosti: - Denní rotace klíčů pro dopředné utajení - Dvoustupňová autorizace klientů (na bázi DH a na bázi PSK) - Šifrování ChaCha20 pro vyšší výkon na zařízeních bez hardwarové podpory AES - Podpisy Red25519 se zaslepením klíče - Členství klientů s ochranou soukromí\nSouvisející dokumentace: - Specifikace společných struktur - Struktura šifrovaného LeaseSet - Návrh 123: Nové položky v netDB - Pozadí k šifrovaným LeaseSet - Dokumentace k databázi sítě - Použití NetDB\nHistorie verzí a stav implementace Časová osa vývoje protokolu Důležitá poznámka k číslování verzí: I2P používá dvě oddělená schémata číslování verzí: - Verze API/Router: řada 0.9.x (používaná v technických specifikacích) - Verze produktového vydání: řada 2.x.x (používaná pro veřejná vydání)\nTechnické specifikace odkazují na verze API (např. 0.9.41), zatímco koncoví uživatelé vidí produktové verze (např. 2.10.0).\nMilníky implementace Version Release Date Features 0.9.38January 2019Floodfill support for standard LS2, offline keys 0.9.39March 2019Full encrypted LS2 support, Red25519 (sig type\u0026nbsp;11) 0.9.40May 2019Per-client authorization, encrypted LS2 with offline keys, B32 support 0.9.41June 2019Protocol finalized as stable 2.10.0September 2025Latest Java implementation (API version 0.9.61) i2pd 2.58.0September 2025Full C++ implementation compatibility ### Aktuální stav ✅ Stav protokolu: Stabilní a beze změny od června 2019 ✅ Java I2P: Plně implementováno ve verzi 0.9.40+ ✅ i2pd (C++): Plně implementováno ve verzi 2.58.0+ ✅ Interoperabilita: Plná napříč implementacemi ✅ Síťové nasazení: Připraveno pro produkční nasazení s více než 6 lety provozních zkušeností Kryptografické definice Notace a konvence || označuje zřetězení mod L označuje modulární redukci podle řádu Ed25519 Všechna pole bajtů jsou v síťovém pořadí bajtů (big-endian, nejvýznamnější bajt první), není-li uvedeno jinak Hodnoty v little-endian (nejméně významný bajt první) jsou výslovně označeny CSRNG(n) Kryptograficky bezpečný generátor náhodných čísel\nVytvoří n bajtů kryptograficky bezpečných náhodných dat vhodných pro generování klíčového materiálu.\nPožadavky na zabezpečení: - Musí být kryptograficky bezpečné (vhodné pro generování klíčů) - Musí být bezpečné i v případě, že jsou na síti vystaveny sousední bajtové sekvence - Implementace by měly hashovat výstup z potenciálně nedůvěryhodných zdrojů\nOdkazy: - Bezpečnostní úvahy ohledně PRNG - Diskuse vývojářů projektu Tor H(p, d) SHA-256 hash s personalizací\nDoménově oddělená hashovací funkce, která přijímá: - p: Personalizační řetězec (zajišťuje oddělení domén) - d: Data k hashování\nImplementace:\nH(p, d) := SHA-256(p || d) Použití: Poskytuje kryptografické oddělení domén, aby se zabránilo kolizním útokům mezi různými protokolovými použitími SHA-256.\nPROUDOVÁ ŠIFRA: ChaCha20 Proudová šifra: ChaCha20 podle RFC 7539, sekce 2.4\nParametry: - S_KEY_LEN = 32 (256bitový klíč) - S_IV_LEN = 12 (96bitová nonce — jednorázová hodnota) - Počáteční čítač: 1 (RFC 7539 povoluje 0 nebo 1; 1 se doporučuje v kontextech AEAD)\nENCRYPT(k, iv, plaintext)\nŠifruje otevřený text pomocí: - k: 32bajtový šifrovací klíč - iv: 12bajtová nonce (jednorázová hodnota; MUSÍ být jedinečná pro každý klíč) - Vrací šifrotext stejné délky jako otevřený text\nBezpečnostní vlastnost: Celý šifrotext musí být nerozlišitelný od náhodných dat, pokud je klíč tajný.\nDECRYPT(k, iv, ciphertext)\nDešifruje šifrotext pomocí: - k: 32bajtový šifrovací klíč - iv: 12bajtový nonce (jednorázová hodnota) - Vrací prostý text\nOdůvodnění návrhu: ChaCha20 byl upřednostněn před AES, protože: - 2,5–3× rychlejší než AES na zařízeních bez hardwarové akcelerace - Implementaci s konstantním časem je snazší dosáhnout - Srovnatelná bezpečnost a rychlost, když je k dispozici AES-NI\nOdkazy: - RFC 7539 - ChaCha20 a Poly1305 pro protokoly IETF\nPodpis: Red25519 Schéma podpisu: Red25519 (SigType 11) se zaslepením klíče\nRed25519 je založena na podpisech Ed25519 nad křivkou Ed25519, při hašování používá SHA-512 a podporuje key blinding (zaslepení klíče), jak je specifikováno v ZCash RedDSA.\nFunkce:\nDERIVE_PUBLIC(privkey) Vrátí veřejný klíč odpovídající zadanému soukromému klíči. - Používá standardní skalární násobení Ed25519 podle základního bodu (generátoru)\nSIGN(privkey, m) Vrátí podpis zprávy m soukromým klíčem privkey.\nRozdíly Red25519 při podepisování oproti Ed25519: 1. Náhodná Nonce (jednorázová hodnota): Používá 80 bajtů dodatečných náhodných dat\nT = CSRNG(80) // 80 random bytes r = H*(T || publickey || message) Díky tomu je každý podpis Red25519 jedinečný, i pro stejnou zprávu a stejný klíč.\nGenerování soukromého klíče: Soukromé klíče Red25519 se generují z náhodných čísel a redukují se mod L, nikoli pomocí přístupu Ed25519 zvaného bit-clamping (ořezání bitů). VERIFY(pubkey, m, sig) Ověří podpis sig vůči veřejnému klíči pubkey a zprávě m. - Vrátí true, pokud je podpis platný, jinak false - Ověření je totožné s Ed25519\nOperace zaslepení klíče:\nGENERATE_ALPHA(data, secret) Generuje hodnotu alfa pro zaslepení klíče. - data: Obvykle obsahuje veřejný klíč pro podepisování a typy podpisů - secret: Volitelný dodatečný tajný údaj (pokud se nepoužije, má nulovou délku) - Výsledek má totožné rozdělení jako soukromé klíče Ed25519 (po redukci mod L)\nBLIND_PRIVKEY(privkey, alpha) Zaslepuje soukromý klíč pomocí tajné hodnoty alpha. - Implementace: blinded_privkey = (privkey + alpha) mod L - Používá skalární aritmetiku v tělese\nBLIND_PUBKEY(pubkey, alpha) Zaslepí veřejný klíč pomocí tajné hodnoty alpha. - Implementace: blinded_pubkey = pubkey + DERIVE_PUBLIC(alpha) - Používá sčítání prvků skupiny (bodů) na křivce\nKritická vlastnost:\nBLIND_PUBKEY(pubkey, alpha) == DERIVE_PUBLIC(BLIND_PRIVKEY(privkey, alpha)) Bezpečnostní hlediska:\nZe specifikace protokolu ZCash, oddíl 5.4.6.1: Z hlediska bezpečnosti musí mít alpha stejnou distribuci jako unblinded (odzaslepené) soukromé klíče. To zajišťuje, že \u0026ldquo;kombinace re-randomized (znovunáhodněného) veřejného klíče a podpisu/podpisů pod tímto klíčem neodhaluje klíč, z něhož byl re-randomizován.\u0026rdquo;\nPodporované typy podpisů: - Typ 7 (Ed25519): Podporován pro existující destinace (zpětná kompatibilita) - Typ 11 (Red25519): Doporučen pro nové destinace využívající šifrování - Zaslepené klíče: Vždy používejte typ 11 (Red25519)\nReference: - Specifikace protokolu Zcash - Sekce 5.4.6 RedDSA - Specifikace I2P Red25519 DH: X25519 Diffie–Hellman nad eliptickými křivkami: X25519\nVeřejnoklíčový systém pro dohodu klíče založený na Curve25519 (eliptická křivka 25519).\nParametry: - Soukromé klíče: 32 bajtů - Veřejné klíče: 32 bajtů - Výstup sdíleného tajemství: 32 bajtů\nFunkce:\nGENERATE_PRIVATE() Vygeneruje nový 32bajtový soukromý klíč pomocí CSRNG (kryptograficky bezpečného generátoru náhodných čísel).\nDERIVE_PUBLIC(privkey) Odvodí 32bajtový veřejný klíč ze zadaného soukromého klíče. - Používá skalární násobení na eliptické křivce Curve25519\nDH(privkey, pubkey) Provádí Diffie-Hellmanovu dohodu o klíči. - privkey: Místní soukromý klíč o délce 32 bajtů - pubkey: Vzdálený veřejný klíč o délce 32 bajtů - Vrací: sdílené tajemství o délce 32 bajtů\nBezpečnostní vlastnosti: - Výpočetní předpoklad Diffie–Hellman na křivce Curve25519 - Dopředné utajení při použití efemérních klíčů - Implementace s konstantním časem je nezbytná k zabránění časovým útokům\nReference: - RFC 7748 - Eliptické křivky pro zabezpečení\nHKDF (funkce pro odvozování klíčů založená na HMAC) Funkce pro odvozování klíčů založená na HMAC\nExtrahuje a rozšiřuje klíčový materiál ze vstupního klíčového materiálu.\nParametry: - salt: maximálně 32 bajtů (typicky 32 bajtů pro SHA-256) - ikm: vstupní klíčový materiál (libovolná délka, měl by mít vysokou entropii) - info: kontextově specifické informace (separace domén) - n: délka výstupu v bajtech\nImplementace:\nPoužívá HKDF (funkce derivace klíčů založená na HMAC) podle RFC 5869 s: - Hašovací funkce: SHA-256 - HMAC: Jak je uvedeno v RFC 2104 - Délka saltu: Maximálně 32 bajtů (HashLen pro SHA-256)\nVzor použití:\nkeys = HKDF(salt, ikm, info, n) Oddělení domén: Parametr info zajišťuje kryptografické oddělení domén mezi různými použitími HKDF v protokolu.\nOvěřené hodnoty Info: - \u0026quot;ELS2_L1K\u0026quot; - Šifrování 1. vrstvy (vnější) - \u0026quot;ELS2_L2K\u0026quot; - Šifrování 2. vrstvy (vnitřní) - \u0026quot;ELS2_XCA\u0026quot; - Autorizace klienta DH - \u0026quot;ELS2PSKA\u0026quot; - Autorizace klienta PSK - \u0026quot;i2pblinding1\u0026quot; - Generování alfy\nOdkazy: - RFC 5869 - Specifikace HKDF - RFC 2104 - Specifikace HMAC\nSpecifikace formátu Šifrovaný LS2 (druhá generace leaseSet) se skládá ze tří vnořených vrstev:\nVrstva 0 (vnější): Informace v prostém textu pro ukládání a načítání Vrstva 1 (střední): Data pro ověření klienta (šifrovaná) Vrstva 2 (vnitřní): Vlastní data LeaseSet2 (I2P struktura s informacemi o dosažitelnosti služby) (šifrovaná) Celková struktura:\nLayer 0 data + Enc(layer 1 data + Enc(layer 2 data)) + Signature Důležité: Šifrovaný LS2 (LeaseSet verze 2) používá zaslepené klíče. Destination (cílová identita v I2P) není v hlavičce. Místo uložení v DHT je SHA-256(sig type || blinded public key), mění se každý den.\nVrstva 0 (vnější) - prostý text Vrstva 0 NEPOUŽÍVÁ standardní hlavičku LS2. Má vlastní formát optimalizovaný pro blinded keys (zaslepené klíče).\nStruktura:\nField Size Description Type1 byteNot in header, from DatabaseStore message field Blinded Public Key Sig Type2 bytesBig endian, always 0x000b (Red25519 type 11) Blinded Public Key32 bytesRed25519 blinded public key Published Timestamp4 bytesBig endian, seconds since epoch (rolls over in 2106) Expires2 bytesBig endian, offset from published in seconds (max 65,535 \u0026asymp; 18.2 hours) Flags2 bytesBit flags (see below) [Optional] Transient Key DataVariablePresent if flag bit\u0026nbsp;0 is set lenOuterCiphertext2 bytesBig endian, length of outer ciphertext outerCiphertextlenOuterCiphertextEncrypted Layer\u0026nbsp;1 data Signature64 bytesRed25519 signature over all preceding data **Pole příznaků (2 bajty, bity 15-0):** - **Bit 0:** Indikátor offline klíčů - `0` = Žádné offline klíče - `1` = Offline klíče jsou přítomny (následují dočasná data klíče) - **Bity 1-15:** Rezervováno, musí být 0 pro budoucí kompatibilitu Dočasná klíčová data (přítomná, pokud je bit příznaku 0 = 1):\nField Size Description Expires Timestamp4 bytesBig endian, seconds since epoch Transient Sig Type2 bytesBig endian, signature type Transient Signing Public KeyVariableLength implied by signature type Signature64 bytesSigned by blinded public key; covers expires timestamp, transient sig type, and transient public key **Ověření podpisu:** - **Bez offline klíčů:** Ověřte pomocí zaslepeného veřejného klíče - **S offline klíči:** Ověřte pomocí dočasného veřejného klíče Podpis se vztahuje na veškerá data od Type až po outerCiphertext (včetně).\nVrstva 1 (střední) - Autorizace klienta Dešifrování: Viz sekci Layer 1 Encryption .\nStruktura:\nField Size Description Flags1 byteAuthorization flags (see below) [Optional] Auth DataVariablePresent based on flags innerCiphertextVariableEncrypted Layer\u0026nbsp;2 data (remainder) **Pole příznaků (1 bajt, bity 7-0):** - **Bit 0:** Režim autorizace - `0` = Žádná autorizace pro jednotlivé klienty (kdokoli) - `1` = Autorizace pro jednotlivé klienty (následuje sekce autorizace) - **Bity 3-1:** Schéma autentizace (pouze pokud bit 0 = 1) - `000` = Autentizace klienta DH - `001` = Autentizace klienta PSK - Ostatní hodnoty jsou vyhrazeny - **Bity 7-4:** Nepoužito, musí být 0 DH autorizační data klienta (příznaky = 0x01, bity 3-1 = 000):\nField Size Description ephemeralPublicKey32 bytesServer's ephemeral X25519 public key clients2 bytesBig endian, number of client entries authClient[]40 bytes eachArray of client authorization entries **Záznam authClient (40 bajtů):** - `clientID_i`: 8 bajtů - `clientCookie_i`: 32 bajtů (šifrovaný authCookie) Autorizační údaje klienta PSK (příznaky = 0x03, bity 3-1 = 001):\nField Size Description authSalt32 bytesSalt for PSK key derivation clients2 bytesBig endian, number of client entries authClient[]40 bytes eachArray of client authorization entries **Záznam authClient (40 bajtů):** - `clientID_i`: 8 bajtů - `clientCookie_i`: 32 bajtů (šifrovaný authCookie) Vrstva 2 (vnitřní) - LeaseSet Data Dešifrování: Viz část Šifrování vrstvy 2 .\nStruktura:\nField Size Description Type1 byte3 (LS2) or 7 (Meta LS2) DataVariableComplete LeaseSet2 or MetaLeaseSet2 Vnitřní vrstva obsahuje úplnou strukturu LeaseSet2 včetně: - záhlaví LS2 - informace o Lease (záznam o příchozím tunnelu s dobou platnosti) - podpis LS2 Požadavky na ověření: Po dešifrování musí implementace ověřit: 1. Vnitřní časové razítko se shoduje s vnějším publikovaným časovým razítkem 2. Vnitřní doba platnosti se shoduje s vnější dobou platnosti 3. Podpis LS2 (LeaseSet2, novější formát leaseSet) je platný 4. Data lease jsou syntakticky správná\nOdkazy: - Specifikace obecných struktur - Podrobnosti formátu LeaseSet2\nOdvození zaslepujícího klíče Přehled I2P používá aditivní schéma zaslepování klíčů založené na Ed25519 a ZCash RedDSA. Zaslepené klíče se kvůli dopřednému utajení denně obměňují (o půlnoci UTC).\nOdůvodnění návrhu:\nI2P se výslovně rozhodl nepoužít přístup popsaný v dokumentu projektu Tor rend-spec-v3.txt, příloha A.2. Podle specifikace:\n\u0026ldquo;Nepoužíváme přílohu A.2 dokumentu projektu Tor rend-spec-v3.txt, která má podobné cíle návrhu, protože její zaslepené veřejné klíče mohou být mimo podskupinu s prvočíselným řádem, což má neznámé bezpečnostní důsledky.\u0026rdquo;\nAditivní zaslepení v I2P zaručuje, že zaslepené klíče zůstávají v podskupině o prvočíselném řádu křivky Ed25519.\nMatematické definice Parametry Ed25519: - B: základní bod Ed25519 (generátor) = 2^255 - 19 - L: řád Ed25519 = 2^252 + 27742317777372353535851937790883648493\nKlíčové proměnné: - A: Nezaslepený 32bajtový veřejný podpisový klíč (v Destination — identifikátoru cíle v I2P) - a: Nezaslepený 32bajtový soukromý podpisový klíč - A': Zaslepený 32bajtový veřejný podpisový klíč (použit v šifrovaném LeaseSet) - a': Zaslepený 32bajtový soukromý podpisový klíč - alpha: 32bajtový faktor zaslepení (tajný)\nPomocné funkce:\nLEOS2IP(x) \u0026ldquo;Převod řetězce oktetů v Little-Endian (pořadí bajtů, kde nejméně významný bajt je první) na celé číslo\u0026rdquo;\nPřevede pole bajtů v pořadí little-endian na celočíselnou reprezentaci.\nH*(x) \u0026ldquo;Hašování a redukce\u0026rdquo;\nH*(x) = (LEOS2IP(SHA512(x))) mod L Stejná operace jako při generování klíče Ed25519 (algoritmus eliptické křivky).\nGenerace Alfa Denní rotace: Každý den o půlnoci UTC (00:00:00 UTC) MUSÍ být vygenerovány nové alpha (parametr „alpha“) a blinded keys (zaslepené klíče).\nGENERATE_ALPHA(destination, date, secret) Algoritmus:\n# Input parameters A = destination\u0026#39;s signing public key (32 bytes) stA = signature type of A (2 bytes, big endian) # 0x0007 for Ed25519 or 0x000b for Red25519 stA\u0026#39; = signature type of blinded key A\u0026#39; (2 bytes, big endian) # Always 0x000b (Red25519) datestring = \u0026#34;YYYYMMDD\u0026#34; (8 bytes ASCII from current UTC date) secret = optional UTF-8 encoded string (zero-length if not used) # Computation keydata = A || stA || stA\u0026#39; # 36 bytes total seed = HKDF( salt=H(\u0026#34;I2PGenerateAlpha\u0026#34;, keydata), ikm=datestring || secret, info=\u0026#34;i2pblinding1\u0026#34;, n=64 ) # Treat seed as 64-byte little-endian integer and reduce alpha = seed mod L Ověřené parametry: - Personalizace soli: \u0026quot;I2PGenerateAlpha\u0026quot; - HKDF info: \u0026quot;i2pblinding1\u0026quot; - Výstup: 64 bajtů před redukcí - Rozdělení Alpha: má stejné rozdělení jako soukromé klíče Ed25519 po mod L\nZaslepení soukromého klíče Algoritmus BLIND_PRIVKEY(a, alpha):\nPro vlastníka Destination (cílová adresa), který publikuje šifrovaný LeaseSet:\n# For Ed25519 private key (type 7) if sigtype == 7: seed = destination\u0026#39;s signing private key (32 bytes) a = left_half(SHA512(seed)) # 32 bytes a = clamp(a) # Ed25519 clamping # For Red25519 private key (type 11) elif sigtype == 11: a = destination\u0026#39;s signing private key (32 bytes) # No clamping for Red25519 # Additive blinding using scalar arithmetic blinded_privkey = a\u0026#39; = (a + alpha) mod L # Derive blinded public key blinded_pubkey = A\u0026#39; = DERIVE_PUBLIC(a\u0026#39;) Kritické: Redukce mod L je nezbytná pro zachování správného algebraického vztahu mezi soukromými a veřejnými klíči.\nZaslepení veřejného klíče Algoritmus BLIND_PUBKEY(A, alpha):\nPro klienty, kteří načítají a ověřují šifrovaný LeaseSet:\nalpha = GENERATE_ALPHA(destination, date, secret) A = destination\u0026#39;s signing public key (32 bytes) # Additive blinding using group elements (curve points) blinded_pubkey = A\u0026#39; = A + DERIVE_PUBLIC(alpha) Matematická ekvivalence:\nObě metody vedou ke shodným výsledkům:\nBLIND_PUBKEY(A, alpha) == DERIVE_PUBLIC(BLIND_PRIVKEY(a, alpha)) Je to proto, že:\nA\u0026#39; = A + [alpha]B = [a]B + [alpha]B = [a + alpha]B (group operation) = DERIVE_PUBLIC(a + alpha mod L) Podepisování pomocí zaslepených klíčů Podepisování nezaslepeného LeaseSet:\nNezaslepený LeaseSet (odesílán přímo ověřeným klientům) je podepsán pomocí: - standardního podpisu Ed25519 (type 7) nebo Red25519 (type 11) - nezaslepeného soukromého klíče pro podepisování - ověřován nezaslepeným veřejným klíčem\nS offline klíči: - Podepsáno nezaslepeným dočasným soukromým klíčem - Ověřeno pomocí nezaslepeného dočasného veřejného klíče - Oba musí být typu 7 nebo 11\nPodepisování šifrovaného LeaseSetu:\nVnější část šifrovaného LeaseSetu používá podpisy Red25519 se zaslepenými klíči.\nPodpisový algoritmus Red25519:\n# Generate per-signature random nonce T = CSRNG(80) # 80 random bytes # Calculate r (differs from Ed25519) r = H*(T || blinded_pubkey || message) # Rest is same as Ed25519 R = [r]B S = (r + H(R || A\u0026#39; || message) * a\u0026#39;) mod L signature = R || S # 64 bytes total Klíčové rozdíly oproti Ed25519: 1. Používá 80 bajtů náhodných dat T (nikoli hash soukromého klíče) 2. Používá přímo hodnotu veřejného klíče (nikoli hash soukromého klíče) 3. Každý podpis je jedinečný i pro stejnou zprávu a klíč\nOvěření:\nStejné jako u Ed25519 (schéma digitálního podpisu):\n# Parse signature R = signature[0:32] S = signature[32:64] # Verify equation: [S]B = R + [H(R || A\u0026#39; || message)]A\u0026#39; return [S]B == R + [H(R || A\u0026#39; || message)]A\u0026#39; Bezpečnostní hlediska Alfa distribuce:\nZ bezpečnostních důvodů musí mít alpha shodné rozdělení jako nezaslepené soukromé klíče. Při zaslepení Ed25519 (typ 7) (schéma digitálního podpisu) na Red25519 (typ 11) (varianta schématu založená na Ed25519) se rozdělení mírně liší.\nDoporučení: Použijte Red25519 (type 11) pro nezaslepené i zaslepené klíče pro splnění požadavků ZCash: \u0026ldquo;kombinace re-randomized (znovu náhodně změněného) veřejného klíče a podpisů vytvořených tímto klíčem neodhaluje klíč, ze kterého byl re-randomized.\u0026rdquo;\nPodpora typu 7: Ed25519 je podporován pro zachování zpětné kompatibility se stávajícími destinacemi, ale pro nové šifrované destinace je doporučen typ 11.\nVýhody denní rotace: - Dopředná bezpečnost: Kompromitace dnešního zaslepeného klíče neodhalí včerejšího - Nepropojitelnost: Denní rotace zabraňuje dlouhodobému sledování přes DHT - Oddělení klíčů: Různé klíče pro různá časová období\nReference: - Specifikace protokolu Zcash - Sekce 5.4.6.1 - Diskuse o zaslepení klíče v Toru - Tor ticket č. 8106 Šifrování a zpracování Odvození Subcredential (podpověření) Před šifrováním odvodíme pověření a podpověření, aby byly šifrované vrstvy vázány na znalost veřejného podpisového klíče Destination (adresa/identita služby v I2P).\nCíl: Zajistit, aby pouze ti, kteří znají veřejný podpisový klíč Destination (identita cíle v I2P), mohli dešifrovat šifrovaný LeaseSet. Není nutné znát celou Destination.\nVýpočet pověření A = destination\u0026#39;s signing public key (32 bytes) stA = signature type of A (2 bytes big endian) # 0x0007 for Ed25519 or 0x000b for Red25519 stA\u0026#39; = signature type of blinded key A\u0026#39; (2 bytes big endian) # Always 0x000b (Red25519) keydata = A || stA || stA\u0026#39; # 36 bytes credential = H(\u0026#34;credential\u0026#34;, keydata) # 32 bytes Oddělení domén: Personalizační řetězec \u0026quot;credential\u0026quot; zajišťuje, že tento hash nekoliduje s žádnými klíči pro vyhledávání v distribuované hašovací tabulce (DHT) ani s jinými způsoby použití protokolu.\nVýpočet Subcredentialu (odvozeného pověření) blindedPublicKey = A\u0026#39; (32 bytes, from blinding process) subcredential = H(\u0026#34;subcredential\u0026#34;, credential || blindedPublicKey) # 32 bytes Účel: Subcredential (podpověření) váže šifrovaný LeaseSet na: 1. konkrétní Destination (identifikátor cíle v I2P) (prostřednictvím credential) 2. konkrétní zaslepený klíč (prostřednictvím blindedPublicKey) 3. konkrétní den (prostřednictvím denní rotace blindedPublicKey)\nTím se zabraňuje replay attacks (útokům opakováním) a propojování napříč dny.\nŠifrování vrstvy 1 Kontext: Vrstva 1 obsahuje autorizační data klienta a je šifrována klíčem odvozeným od subcredential (dílčí pověřovací údaj).\nŠifrovací algoritmus # Prepare input outerInput = subcredential || publishedTimestamp # publishedTimestamp: 4 bytes from Layer 0 # Generate random salt outerSalt = CSRNG(32) # 32 bytes # Derive encryption key and IV keys = HKDF( salt=outerSalt, ikm=outerInput, info=\u0026#34;ELS2_L1K\u0026#34;, # Domain separation n=44 # 32 bytes key + 12 bytes IV ) outerKey = keys[0:31] # 32 bytes (indices 0-31 inclusive) outerIV = keys[32:43] # 12 bytes (indices 32-43 inclusive) # Encrypt and prepend salt outerPlaintext = [Layer 1 data] outerCiphertext = outerSalt || ENCRYPT(outerKey, outerIV, outerPlaintext) Výstup: outerCiphertext má 32 + len(outerPlaintext) bajtů.\nBezpečnostní vlastnosti: - Salt zajišťuje jedinečné dvojice klíč/IV i při stejném subcredential (podpověření) - Kontextový řetězec \u0026quot;ELS2_L1K\u0026quot; zajišťuje oddělení domén - ChaCha20 poskytuje sémantické zabezpečení (šifrotext nerozlišitelný od náhodných dat)\nDešifrovací algoritmus # Parse salt from ciphertext outerSalt = outerCiphertext[0:31] # First 32 bytes # Derive decryption key and IV (same process as encryption) outerInput = subcredential || publishedTimestamp keys = HKDF( salt=outerSalt, ikm=outerInput, info=\u0026#34;ELS2_L1K\u0026#34;, n=44 ) outerKey = keys[0:31] # 32 bytes outerIV = keys[32:43] # 12 bytes # Decrypt (skip salt bytes) outerPlaintext = DECRYPT(outerKey, outerIV, outerCiphertext[32:end]) Ověření: Po dešifrování ověřte, že struktura vrstvy 1 je správně formovaná, než přejdete na vrstvu 2.\nŠifrování na 2. vrstvě Kontext: Vrstva 2 obsahuje samotná data LeaseSet2 a je šifrována klíčem odvozeným z authCookie (pokud je povolena autentizace pro jednotlivé klienty) nebo klíčem odvozeným z prázdného řetězce (pokud není).\nŠifrovací algoritmus # Determine authCookie based on authorization mode if per_client_auth_enabled: authCookie = [32-byte cookie from client authorization process] else: authCookie = b\u0026#39;\u0026#39; # Zero-length byte array # Prepare input innerInput = authCookie || subcredential || publishedTimestamp # Generate random salt innerSalt = CSRNG(32) # 32 bytes # Derive encryption key and IV keys = HKDF( salt=innerSalt, ikm=innerInput, info=\u0026#34;ELS2_L2K\u0026#34;, # Domain separation n=44 # 32 bytes key + 12 bytes IV ) innerKey = keys[0:31] # 32 bytes innerIV = keys[32:43] # 12 bytes # Encrypt and prepend salt innerPlaintext = [Layer 2 data: LS2 type byte + LeaseSet2 data] innerCiphertext = innerSalt || ENCRYPT(innerKey, innerIV, innerPlaintext) Výstup: innerCiphertext má velikost 32 + len(innerPlaintext) bajtů.\nVazba klíče: - Pokud není použita autentizace klienta: Vázáno pouze na subcredential (podřazené pověření) a časové razítko - Pokud je zapnuta autentizace klienta: Navíc vázáno na authCookie (různé pro každého autorizovaného klienta)\nDešifrovací algoritmus # Determine authCookie (same as encryption) if per_client_auth_enabled: authCookie = [32-byte cookie from client authorization process] else: authCookie = b\u0026#39;\u0026#39; # Zero-length byte array # Parse salt from ciphertext innerSalt = innerCiphertext[0:31] # First 32 bytes # Derive decryption key and IV innerInput = authCookie || subcredential || publishedTimestamp keys = HKDF( salt=innerSalt, ikm=innerInput, info=\u0026#34;ELS2_L2K\u0026#34;, n=44 ) innerKey = keys[0:31] # 32 bytes innerIV = keys[32:43] # 12 bytes # Decrypt (skip salt bytes) innerPlaintext = DECRYPT(innerKey, innerIV, innerCiphertext[32:end]) Ověření: Po dešifrování: 1. Ověřte, že bajt typu LS2 je platný (3 nebo 7) 2. Rozparsujte strukturu LeaseSet2 3. Ověřte, že vnitřní časové razítko odpovídá vnějšímu publikovanému časovému razítku 4. Ověřte, že vnitřní expirace odpovídá vnější expiraci 5. Ověřte podpis LeaseSet2\nSouhrn šifrovací vrstvy ┌─────────────────────────────────────────────────┐ │ Layer 0 (Plaintext) │ │ - Blinded public key │ │ - Timestamps │ │ - Signature │ │ │ │ ┌─────────────────────────────────────────┐ │ │ │ Layer 1 (Encrypted with subcredential) │ │ │ │ - Authorization flags │ │ │ │ - Client auth data (if enabled) │ │ │ │ │ │ │ │ ┌────────────────────────────────┐ │ │ │ │ │ Layer 2 (Encrypted with │ │ │ │ │ │ authCookie + subcred) │ │ │ │ │ │ - LeaseSet2 type │ │ │ │ │ │ - LeaseSet2 data │ │ │ │ │ │ - Leases │ │ │ │ │ │ - LS2 signature │ │ │ │ │ └────────────────────────────────┘ │ │ │ └─────────────────────────────────────────┘ │ └─────────────────────────────────────────────────┘ Postup dešifrování: 1. Ověřte podpis Vrstvy 0 pomocí zaslepeného veřejného klíče 2. Dešifrujte Vrstvu 1 pomocí subcredential (podpověření) 3. Zpracujte autorizační data (pokud jsou k dispozici) pro získání authCookie 4. Dešifrujte Vrstvu 2 pomocí authCookie a subcredential 5. Ověřte a rozparsujte LeaseSet2\nAutorizace pro jednotlivé klienty Přehled Je-li povolena autorizace pro jednotlivé klienty, server udržuje seznam autorizovaných klientů. Každý klient má klíčový materiál, který je nutné bezpečně předat mimo hlavní komunikační kanál.\nDva mechanismy autorizace: 1. Autorizace klienta DH (Diffie-Hellman): Bezpečnější, používá dohodu klíče X25519 2. Autorizace PSK (Pre-Shared Key): Jednodušší, používá symetrické klíče\nObecné bezpečnostní vlastnosti: - Soukromí členství klientů: Pozorovatelé vidí počet klientů, ale nemohou identifikovat konkrétní klienty - Anonymní přidávání/odebírání klientů: Nelze sledovat, kdy jsou konkrétní klienti přidáni nebo odebráni - Pravděpodobnost kolize 8bajtového identifikátoru klienta: ~1 z 18 kvintilionů (zanedbatelné)\nAutorizace klienta DH (Diffie–Hellmanova výměna klíčů) Přehled: Každý klient generuje klíčový pár X25519 a prostřednictvím zabezpečeného mimopásmového kanálu odešle svůj veřejný klíč serveru. Server používá efemérní DH k zašifrování jedinečného authCookie pro každého klienta.\nGenerování klientských klíčů # Client generates keypair csk_i = GENERATE_PRIVATE() # 32-byte X25519 private key cpk_i = DERIVE_PUBLIC(csk_i) # 32-byte X25519 public key # Client sends cpk_i to server via secure out-of-band channel # Client KEEPS csk_i secret (never transmitted) Bezpečnostní výhoda: Soukromý klíč klienta nikdy neopustí zařízení klienta. Útočník, který zachytí out-of-band (mimo hlavní kanál) přenos, nedokáže dešifrovat budoucí šifrované LeaseSets, aniž by prolomil X25519 DH.\nZpracování na serveru # Server generates new auth cookie and ephemeral keypair authCookie = CSRNG(32) # 32-byte cookie esk = GENERATE_PRIVATE() # 32-byte ephemeral private key epk = DERIVE_PUBLIC(esk) # 32-byte ephemeral public key # For each authorized client i for cpk_i in authorized_clients: # Perform DH key agreement sharedSecret = DH(esk, cpk_i) # 32 bytes # Derive client-specific encryption key authInput = sharedSecret || cpk_i || subcredential || publishedTimestamp okm = HKDF( salt=epk, # Ephemeral public key as salt ikm=authInput, info=\u0026#34;ELS2_XCA\u0026#34;, # Domain separation n=52 # 32 key + 12 IV + 8 ID ) # Extract components clientKey_i = okm[0:31] # 32 bytes clientIV_i = okm[32:43] # 12 bytes clientID_i = okm[44:51] # 8 bytes # Encrypt authCookie for this client clientCookie_i = ENCRYPT(clientKey_i, clientIV_i, authCookie) # Store [clientID_i, clientCookie_i] entry in Layer 1 Datová struktura vrstvy 1:\nephemeralPublicKey (32 bytes) clients (2 bytes) = N [clientID_1 (8 bytes) || clientCookie_1 (32 bytes)] [clientID_2 (8 bytes) || clientCookie_2 (32 bytes)] ... [clientID_N (8 bytes) || clientCookie_N (32 bytes)] Doporučení pro server: - Vygenerujte nový efemérní pár klíčů pro každý zveřejněný šifrovaný LeaseSet - Náhodně měňte pořadí klientů, abyste zabránili sledování podle pozice - Zvažte přidání zástupných záznamů, abyste skryli skutečný počet klientů\nZpracování na straně klienta # Client has: csk_i (their private key), destination, date, secret # Client receives: encrypted LeaseSet with epk in Layer 1 # Perform DH key agreement with server\u0026#39;s ephemeral public key sharedSecret = DH(csk_i, epk) # 32 bytes # Derive expected client identifier and decryption key cpk_i = DERIVE_PUBLIC(csk_i) # Client\u0026#39;s own public key authInput = sharedSecret || cpk_i || subcredential || publishedTimestamp okm = HKDF( salt=epk, ikm=authInput, info=\u0026#34;ELS2_XCA\u0026#34;, n=52 ) clientKey_i = okm[0:31] # 32 bytes clientIV_i = okm[32:43] # 12 bytes clientID_i = okm[44:51] # 8 bytes # Search Layer 1 authorization data for clientID_i for (clientID, clientCookie) in layer1_auth_entries: if clientID == clientID_i: # Found matching entry, decrypt authCookie authCookie = DECRYPT(clientKey_i, clientIV_i, clientCookie) # Use authCookie to decrypt Layer 2 break else: # No matching entry - client not authorized or revoked raise AuthorizationError(\u0026#34;Client not authorized\u0026#34;) Zpracování chyb na straně klienta: - Pokud clientID_i nenalezen: Klientovi byl přístup odebrán nebo nikdy nebyl autorizován - Pokud dešifrování selže: Poškozená data nebo nesprávné klíče (velmi vzácné) - Klienti by měli pravidelně znovu načítat, aby detekovali odebrání oprávnění\nAutorizace klienta pomocí předem sdíleného klíče (PSK) Přehled: Každý klient má předem sdílený symetrický klíč o velikosti 32 bajtů. Server šifruje stejný authCookie pomocí PSK (předem sdílený klíč) každého klienta.\nGenerování klíčů # Option 1: Client generates key psk_i = CSRNG(32) # 32-byte pre-shared key # Client sends psk_i to server via secure out-of-band channel # Option 2: Server generates key psk_i = CSRNG(32) # 32-byte pre-shared key # Server sends psk_i to one or more clients via secure out-of-band channel Bezpečnostní poznámka: Stejný PSK (předem sdílený klíč) lze podle potřeby sdílet mezi více klienty (vytváří \u0026ldquo;skupinovou\u0026rdquo; autorizaci).\nZpracování na straně serveru # Server generates new auth cookie and salt authCookie = CSRNG(32) # 32-byte cookie authSalt = CSRNG(32) # 32-byte salt # For each authorized client i for psk_i in authorized_clients: # Derive client-specific encryption key authInput = psk_i || subcredential || publishedTimestamp okm = HKDF( salt=authSalt, ikm=authInput, info=\u0026#34;ELS2PSKA\u0026#34;, # Domain separation n=52 # 32 key + 12 IV + 8 ID ) # Extract components clientKey_i = okm[0:31] # 32 bytes clientIV_i = okm[32:43] # 12 bytes clientID_i = okm[44:51] # 8 bytes # Encrypt authCookie for this client clientCookie_i = ENCRYPT(clientKey_i, clientIV_i, authCookie) # Store [clientID_i, clientCookie_i] entry in Layer 1 Datová struktura vrstvy 1:\nauthSalt (32 bytes) clients (2 bytes) = N [clientID_1 (8 bytes) || clientCookie_1 (32 bytes)] [clientID_2 (8 bytes) || clientCookie_2 (32 bytes)] ... [clientID_N (8 bytes) || clientCookie_N (32 bytes)] Zpracování klienta # Client has: psk_i (their pre-shared key), destination, date, secret # Client receives: encrypted LeaseSet with authSalt in Layer 1 # Derive expected client identifier and decryption key authInput = psk_i || subcredential || publishedTimestamp okm = HKDF( salt=authSalt, ikm=authInput, info=\u0026#34;ELS2PSKA\u0026#34;, n=52 ) clientKey_i = okm[0:31] # 32 bytes clientIV_i = okm[32:43] # 12 bytes clientID_i = okm[44:51] # 8 bytes # Search Layer 1 authorization data for clientID_i for (clientID, clientCookie) in layer1_auth_entries: if clientID == clientID_i: # Found matching entry, decrypt authCookie authCookie = DECRYPT(clientKey_i, clientIV_i, clientCookie) # Use authCookie to decrypt Layer 2 break else: # No matching entry - client not authorized or revoked raise AuthorizationError(\u0026#34;Client not authorized\u0026#34;) Srovnání a doporučení Feature DH Authorization PSK Authorization Key ExchangeAsymmetric (X25519)Symmetric (shared secret) SecurityHigher (forward secrecy)Lower (depends on PSK secrecy) Client PrivacyPrivate key never transmittedPSK must be transmitted securely PerformanceN+1 DH operationsNo DH operations Key SharingOne key per clientCan share key among multiple clients Revocation DetectionAdversary cannot tell when revokedAdversary can track revocation if PSK intercepted Use CaseHigh security requirementsPerformance-critical or group access **Doporučení:** - **Používejte autorizaci DH** pro vysoce zabezpečené aplikace, kde je důležité dopředné utajení - **Používejte autorizaci pomocí PSK (předem sdíleného klíče)** pokud je výkon kritický nebo při správě skupin klientů - **Nikdy znovu nepoužívejte PSK** napříč různými službami ani v různých časových obdobích - **Vždy používejte zabezpečené kanály** pro distribuci klíčů (např. Signal, OTR, PGP) Bezpečnostní hlediska Ochrana soukromí členství klienta:\nOba mechanismy poskytují soukromí ohledně členství klientů prostřednictvím:\nŠifrované identifikátory klientů: 8bajtové hodnoty clientID odvozené z výstupu HKDF (funkce pro odvozování klíčů na bázi HMAC) Nerozlišitelné soubory cookie: Všechny hodnoty clientCookie o délce 32 bajtů se jeví jako náhodné Žádná metadata specifická pro klienta: Neexistuje způsob, jak zjistit, která položka patří kterému klientovi Pozorovatel může vidět: - Počet autorizovaných klientů (z pole clients) - Změny počtu klientů v čase\nPozorovatel NEMŮŽE vidět: - Kteří konkrétní klienti jsou autorizováni - Kdy jsou konkrétní klienti přidáni nebo odebráni (pokud počet zůstává stejný) - Jakékoli informace umožňující identifikaci klienta\nDoporučení pro randomizaci:\nServery BY MĚLY pokaždé, když generují šifrovaný LeaseSet, náhodně změnit pořadí klientů:\nimport random # Before serializing auth_entries = [(clientID_i, clientCookie_i) for each client] random.shuffle(auth_entries) # Now serialize in randomized order Výhody: - Zabraňuje klientům zjistit svou pozici v seznamu - Zabraňuje inferenčním útokům založeným na změnách pozice v seznamu - Učiní přidání/odebrání klienta nerozlišitelným\nSkrytí počtu klientů:\nServery MOHOU vkládat náhodné výplňové záznamy:\n# Add dummy entries num_dummies = random.randint(0, max_dummies) for _ in range(num_dummies): dummy_id = CSRNG(8) dummy_cookie = CSRNG(32) auth_entries.append((dummy_id, dummy_cookie)) # Randomize all entries (real + dummy) random.shuffle(auth_entries) Náklady: Zástupné položky zvětšují velikost šifrovaného LeaseSetu (každá o 40 bajtů).\nRotace AuthCookie:\nServery by měly vygenerovat nový authCookie: - Pokaždé, když je publikován šifrovaný LeaseSet (obvykle každých několik hodin) - Ihned po odebrání přístupu klientovi - V pravidelných intervalech (např. denně), i když nedojde k žádným změnám u klientů\nVýhody: - Omezuje dopad, pokud dojde ke kompromitaci authCookie - Zajišťuje, že klientům s odvolaným oprávněním je přístup rychle zablokován - Poskytuje dopředné utajení pro vrstvu 2\nAdresování Base32 pro šifrované LeaseSets Přehled Tradiční base32 adresy I2P obsahují pouze hash Destination (32 bajtů → 52 znaků). To je nedostatečné pro šifrované LeaseSets, protože:\nKlienti potřebují neoslepený veřejný klíč k derivaci oslepeného veřejného klíče Klienti potřebují typy podpisů (neoslepené a oslepené) pro správnou derivaci klíče Samotný hash tyto informace neposkytuje Řešení: Nový formát base32 (kódování Base32), který obsahuje veřejný klíč a typy podpisů.\nSpecifikace formátu adresy Dekódovaná struktura (35 bajtů):\n┌─────────────────────────────────────────────────────┐ │ Byte 0 │ Byte 1 │ Byte 2 │ Bytes 3-34 │ │ Flags │ Unblind │ Blinded │ Public Key │ │ (XOR) │ SigType │ SigType │ (32 bytes) │ │ │ (XOR) │ (XOR) │ │ └─────────────────────────────────────────────────────┘ První 3 bajty (XOR s kontrolním součtem):\nPrvní 3 bajty obsahují metadata XORovaná s částmi kontrolního součtu CRC-32:\n# Data structure before XOR flags = 0x00 # 1 byte (reserved for future use) unblinded_sigtype = 0x07 or 0x0b # 1 byte (7 or 11) blinded_sigtype = 0x0b # 1 byte (always 11) # Compute CRC-32 checksum of public key checksum = crc32(pubkey) # 4-byte CRC-32 of bytes 3-34 # XOR first 3 bytes with parts of checksum data[0] = flags XOR (checksum \u0026gt;\u0026gt; 24) \u0026amp; 0xFF data[1] = unblinded_sigtype XOR (checksum \u0026gt;\u0026gt; 16) \u0026amp; 0xFF data[2] = blinded_sigtype XOR (checksum \u0026gt;\u0026gt; 8) \u0026amp; 0xFF # Bytes 3-34 contain the unmodified 32-byte public key data[3:34] = pubkey Vlastnosti kontrolního součtu: - Používá standardní polynom CRC-32 - Míra falešně negativních výsledků: ~1 z 16 milionů - Detekuje překlepy v adrese - Nelze použít k autentizaci (není kryptograficky bezpečný)\nKódovaný formát:\nBase32Encode(35 bytes) || \u0026#34;.b32.i2p\u0026#34; Vlastnosti: - Celkový počet znaků: 56 (35 bajtů × 8 bitů ÷ 5 bitů na znak) - Koncovka: \u0026ldquo;.b32.i2p\u0026rdquo; (stejná jako tradiční base32) - Celková délka: 56 + 8 = 64 znaků (bez nulového terminátoru)\nKódování Base32: - Abeceda: abcdefghijklmnopqrstuvwxyz234567 (standardu RFC 4648) - 5 nevyužitých bitů na konci MUSÍ být 0 - Nerozlišuje velikost písmen (dle konvence malá písmena)\nGenerování adres import struct from zlib import crc32 import base64 def generate_encrypted_b32_address(pubkey, unblinded_sigtype, blinded_sigtype): \u0026#34;\u0026#34;\u0026#34; Generate base32 address for encrypted LeaseSet. Args: pubkey: 32-byte public key (bytes) unblinded_sigtype: Unblinded signature type (7 or 11) blinded_sigtype: Blinded signature type (always 11) Returns: String address ending in .b32.i2p \u0026#34;\u0026#34;\u0026#34; # Verify inputs assert len(pubkey) == 32, \u0026#34;Public key must be 32 bytes\u0026#34; assert unblinded_sigtype in [7, 11], \u0026#34;Unblinded sigtype must be 7 or 11\u0026#34; assert blinded_sigtype == 11, \u0026#34;Blinded sigtype must be 11\u0026#34; # Compute CRC-32 of public key checksum = crc32(pubkey) \u0026amp; 0xFFFFFFFF # Ensure 32-bit unsigned # Prepare metadata bytes flags = 0x00 # XOR metadata with checksum parts byte0 = flags ^ ((checksum \u0026gt;\u0026gt; 24) \u0026amp; 0xFF) byte1 = unblinded_sigtype ^ ((checksum \u0026gt;\u0026gt; 16) \u0026amp; 0xFF) byte2 = blinded_sigtype ^ ((checksum \u0026gt;\u0026gt; 8) \u0026amp; 0xFF) # Construct 35-byte data data = bytes([byte0, byte1, byte2]) + pubkey # Base32 encode (standard alphabet) # Python\u0026#39;s base64 module uses uppercase by default b32 = base64.b32encode(data).decode(\u0026#39;ascii\u0026#39;).lower().rstrip(\u0026#39;=\u0026#39;) # Construct full address address = b32 + \u0026#34;.b32.i2p\u0026#34; return address Parsování adres import struct from zlib import crc32 import base64 def parse_encrypted_b32_address(address): \u0026#34;\u0026#34;\u0026#34; Parse base32 address for encrypted LeaseSet. Args: address: String address ending in .b32.i2p Returns: Tuple of (pubkey, unblinded_sigtype, blinded_sigtype) Raises: ValueError: If address is invalid or checksum fails \u0026#34;\u0026#34;\u0026#34; # Remove suffix if not address.endswith(\u0026#39;.b32.i2p\u0026#39;): raise ValueError(\u0026#34;Invalid address suffix\u0026#34;) b32 = address[:-8] # Remove \u0026#34;.b32.i2p\u0026#34; # Verify length (56 characters for 35 bytes) if len(b32) != 56: raise ValueError(f\u0026#34;Invalid length: {len(b32)} (expected 56)\u0026#34;) # Base32 decode # Add padding if needed padding_needed = (8 - (len(b32) % 8)) % 8 b32_padded = b32.upper() + \u0026#39;=\u0026#39; * padding_needed try: data = base64.b32decode(b32_padded) except Exception as e: raise ValueError(f\u0026#34;Invalid base32 encoding: {e}\u0026#34;) # Verify decoded length if len(data) != 35: raise ValueError(f\u0026#34;Invalid decoded length: {len(data)} (expected 35)\u0026#34;) # Extract public key pubkey = data[3:35] # Compute CRC-32 for verification checksum = crc32(pubkey) \u0026amp; 0xFFFFFFFF # Un-XOR metadata bytes flags = data[0] ^ ((checksum \u0026gt;\u0026gt; 24) \u0026amp; 0xFF) unblinded_sigtype = data[1] ^ ((checksum \u0026gt;\u0026gt; 16) \u0026amp; 0xFF) blinded_sigtype = data[2] ^ ((checksum \u0026gt;\u0026gt; 8) \u0026amp; 0xFF) # Verify expected values if flags != 0x00: raise ValueError(f\u0026#34;Invalid flags: {flags:#x} (expected 0x00)\u0026#34;) if unblinded_sigtype not in [7, 11]: raise ValueError(f\u0026#34;Invalid unblinded sigtype: {unblinded_sigtype} (expected 7 or 11)\u0026#34;) if blinded_sigtype != 11: raise ValueError(f\u0026#34;Invalid blinded sigtype: {blinded_sigtype} (expected 11)\u0026#34;) return pubkey, unblinded_sigtype, blinded_sigtype Srovnání s tradičním Base32 Feature Traditional B32 Encrypted LS2 B32 ContentSHA-256 hash of DestinationPublic key + signature types Decoded Size32 bytes35 bytes Encoded Length52 characters56 characters Suffix.b32.i2p.b32.i2p Total Length60 chars64 chars ChecksumNoneCRC-32 (XOR'd into first 3 bytes) Use CaseRegular destinationsEncrypted LeaseSet destinations ### Omezení použití Nekompatibilita BitTorrentu:\nŠifrované adresy LS2 NELZE používat s compact announce replies (kompaktními odpověďmi announce) BitTorrentu:\nCompact announce reply format: ┌────────────────────────────┐ │ 32-byte destination hash │ ← Only hash, no signature types │ 2-byte port │ └────────────────────────────┘ Problém: Kompaktní formát obsahuje pouze hash (32 bajtů), bez prostoru pro typy podpisů nebo informace o veřejném klíči.\nŘešení: Použijte plné odpovědi announce (oznámení) nebo trackery založené na HTTP, které podporují plné adresy.\nIntegrace adresáře Pokud má klient v adresáři plnou Destination (cílová identita v I2P):\nUložit plnou Destination (cílový identifikátor; obsahuje veřejný klíč) Podporovat reverzní vyhledávání podle hashe Při nalezení šifrované LS2 získat veřejný klíč z adresáře Není třeba nového formátu base32, pokud je plná Destination již známa Formáty adresáře, které podporují šifrované LS2: - hosts.txt s úplnými řetězci destinací - databáze SQLite se sloupcem destination - formáty JSON/XML s úplnými daty destinace\nPříklady implementace Příklad 1: Vygenerování adresy\n# Ed25519 destination example pubkey = bytes.fromhex(\u0026#39;a\u0026#39; * 64) # 32-byte public key unblinded_type = 7 # Ed25519 blinded_type = 11 # Red25519 (always) address = generate_encrypted_b32_address(pubkey, unblinded_type, blinded_type) print(f\u0026#34;Address: {address}\u0026#34;) # Output: 56 base32 characters + .b32.i2p Příklad 2: Parsování a validace\naddress = \u0026#34;abc...xyz.b32.i2p\u0026#34; # 56 chars + suffix try: pubkey, unblinded, blinded = parse_encrypted_b32_address(address) print(f\u0026#34;Public Key: {pubkey.hex()}\u0026#34;) print(f\u0026#34;Unblinded SigType: {unblinded}\u0026#34;) print(f\u0026#34;Blinded SigType: {blinded}\u0026#34;) except ValueError as e: print(f\u0026#34;Invalid address: {e}\u0026#34;) Příklad 3: Převod z Destination (cíl v I2P)\ndef destination_to_encrypted_b32(destination): \u0026#34;\u0026#34;\u0026#34; Convert full Destination to encrypted LS2 base32 address. Args: destination: I2P Destination object Returns: Base32 address string \u0026#34;\u0026#34;\u0026#34; # Extract public key and signature type from destination pubkey = destination.signing_public_key # 32 bytes sigtype = destination.sig_type # 7 or 11 # Blinded type is always 11 (Red25519) blinded_type = 11 # Generate address return generate_encrypted_b32_address(pubkey, sigtype, blinded_type) Bezpečnostní aspekty Soukromí: - Adresa Base32 odhaluje veřejný klíč - Je to záměrné a vyžadované protokolem - Neprozrazuje soukromý klíč ani neohrožuje bezpečnost - Veřejné klíče jsou záměrně veřejnou informací\nOdolnost vůči kolizím: - CRC-32 poskytuje pouze 32 bitů odolnosti vůči kolizím - Není kryptograficky bezpečný (používejte pouze pro detekci chyb) - V žádném případě nespoléhejte na kontrolní součet pro autentizaci - Úplné ověření cíle je stále vyžadováno\nOvěření adresy: - Před použitím vždy ověřte kontrolní součet - Odmítejte adresy s neplatnými typy podpisů - Ověřte, že veřejný klíč leží na křivce (v závislosti na implementaci)\nOdkazy: - Návrh 149: B32 pro šifrovaný LS2 - Specifikace adresování B32 - Specifikace pojmenování I2P Podpora offline klíčů Přehled Offline klíče umožňují, aby hlavní podepisovací klíč zůstal offline (v režimu studeného úložiště), zatímco dočasný podepisovací klíč se používá pro každodenní provoz. To je zásadní pro služby s vysokými nároky na bezpečnost.\nSpecifické požadavky pro šifrované LS2: - Dočasné klíče musí být generovány offline - Zaslepené soukromé klíče musí být předgenerovány (jeden denně) - Oba typy klíčů, dočasné i zaslepené, se dodávají v dávkách - Standardizovaný formát souboru zatím není definován (TODO ve specifikaci)\nStruktura offline klíče Data dočasného klíče vrstvy 0 (když je příznakový bit 0 = 1):\n┌───────────────────────────────────────────────────┐ │ Expires Timestamp │ 4 bytes (seconds) │ │ Transient Sig Type │ 2 bytes (big endian) │ │ Transient Signing Pubkey│ Variable (sigtype len) │ │ Signature (by blinded) │ 64 bytes (Red25519) │ └───────────────────────────────────────────────────┘ Rozsah podpisu: Podpis v offline bloku klíče zahrnuje: - Časové razítko vypršení platnosti (4 bajty) - Dočasný typ podpisu (2 bajty) - Dočasný veřejný klíč pro podepisování (proměnné délky)\nTento podpis je ověřen pomocí zaslepeného veřejného klíče, což dokazuje, že entita se zaslepeným soukromým klíčem autorizovala tento dočasný klíč.\nProces generování klíčů Pro šifrovaný LeaseSet s offline klíči:\nVygenerujte dočasné klíčové páry (offline, ve studeném úložišti):\n# For each day in future for date in future_dates: # Generate daily transient keypair transient_privkey = generate_red25519_privkey() # Type 11 transient_pubkey = derive_public(transient_privkey) # Store for later delivery keys[date] = (transient_privkey, transient_pubkey) Generate daily blinded keypairs (offline, in cold storage):\nPro každý den for date in future_dates: # Derive alpha for this date datestring = date.strftime(\u0026quot;%Y%m%d\u0026quot;) # \u0026quot;YYYYMMDD\u0026quot; alpha = GENERATE_ALPHA(destination, datestring, secret) # Blind the signing private key a = destination_signing_privkey # Type 7 or 11 blinded_privkey = BLIND_PRIVKEY(a, alpha) # Result is type 11 blinded_pubkey = DERIVE_PUBLIC(blinded_privkey) # Store for later delivery blinded_keys[date] = (blinded_privkey, blinded_pubkey) 3. **Sign transient keys with blinded keys** (offline): ```python for date in future_dates: transient_pubkey = keys[date][1] blinded_privkey = blinded_keys[date][0] # Create signature data expires = int((date + timedelta(days=1)).timestamp()) sig_data = struct.pack(\u0026#39;\u0026gt;I\u0026#39;, expires) # 4 bytes sig_data += struct.pack(\u0026#39;\u0026gt;H\u0026#39;, 11) # Transient type (Red25519) sig_data += transient_pubkey # 32 bytes # Sign with blinded private key signature = RED25519_SIGN(blinded_privkey, sig_data) # Package for delivery offline_sig_blocks[date] = { \u0026#39;expires\u0026#39;: expires, \u0026#39;transient_type\u0026#39;: 11, \u0026#39;transient_pubkey\u0026#39;: transient_pubkey, \u0026#39;signature\u0026#39;: signature } Package for delivery to router: Pro každé datum delivery_package[date] = { 'transient_privkey': keys[date][0], 'transient_pubkey': keys[date][1], 'blinded_privkey': blinded_keys[date][0], 'blinded_pubkey': blinded_keys[date][1], 'offline_sig_block': offline_sig_blocks[date] }\n### Router Usage **Daily Key Loading:** ```python # O půlnoci UTC (nebo před zveřejněním) date = datetime.utcnow().date() # Načíst dnešní klíče today_keys = load_delivery_package(date) transient_privkey = today_keys[\u0026#39;transient_privkey\u0026#39;] transient_pubkey = today_keys[\u0026#39;transient_pubkey\u0026#39;] blinded_privkey = today_keys[\u0026#39;blinded_privkey\u0026#39;] blinded_pubkey = today_keys[\u0026#39;blinded_pubkey\u0026#39;] offline_sig_block = today_keys[\u0026#39;offline_sig_block\u0026#39;] # Použijte tyto klíče pro dnešní šifrovaný LeaseSet Publishing Process:\n# 1. Vytvořte vnitřní LeaseSet2 inner_ls2 = create_leaseset2( destinations, leases, expires, signing_key=transient_privkey # Use transient key ) # 2. Zašifrujte vrstvu 2 layer2_ciphertext = encrypt_layer2(inner_ls2, authCookie, subcredential, timestamp) # 3. Vytvořte vrstvu 1 s autorizačními údaji layer1_plaintext = create_layer1(authorization_data, layer2_ciphertext) # 4. Zašifrujte vrstvu 1 layer1_ciphertext = encrypt_layer1(layer1_plaintext, subcredential, timestamp) # 5. Vytvořte vrstvu 0 s blokem offline podpisu layer0 = create_layer0( blinded_pubkey, timestamp, expires, flags=0x0001, # Bit 0 set (offline keys present) offline_sig_block=offline_sig_block, layer1_ciphertext=layer1_ciphertext ) # 6. Podepište vrstvu 0 dočasným soukromým klíčem signature = RED25519_SIGN(transient_privkey, layer0) # 7. Připojte podpis a zveřejněte encrypted_leaseset = layer0 + signature publish_to_netdb(encrypted_leaseset) Security Considerations Tracking via Offline Signature Block:\nThe offline signature block is in plaintext (Layer 0). An adversary scraping floodfills could:\nTrack the same encrypted LeaseSet across multiple days Correlate encrypted LeaseSets even though blinded keys change daily Mitigation: Generate new transient keys daily (in addition to blinded keys):\n# Každý den generovat jak nové dočasné, tak i nové oslepené klíče for date in future_dates: # New transient keypair for this day transient_privkey = generate_red25519_privkey() transient_pubkey = derive_public(transient_privkey) # New blinded keypair for this day alpha = GENERATE_ALPHA(destination, datestring, secret) blinded_privkey = BLIND_PRIVKEY(signing_privkey, alpha) blinded_pubkey = DERIVE_PUBLIC(blinded_privkey) # Sign new transient key with new blinded key sig = RED25519_SIGN(blinded_privkey, transient_pubkey || metadata) # Now offline sig block changes daily Benefits:\nPrevents tracking across days via offline signature block Provides same security as encrypted LS2 without offline keys Each day appears completely independent Cost:\nMore keys to generate and store More complex key management File Format (TODO) Current Status: No standardized file format defined for batch key delivery.\nRequirements for Future Format:\nMust support multiple dates:\nBatch delivery of 30+ days worth of keys Clear date association for each key set Must include all necessary data:\nTransient private key Transient public key Blinded private key Blinded public key Pre-computed offline signature block Expiration timestamps Should be tamper-evident:\nChecksums or signatures over entire file Integrity verification before loading Should be encrypted:\nKeys are sensitive material Encrypt file with router\u0026rsquo;s key or passphrase Proposed Format Example (JSON, encrypted):\n{ \u0026#34;version\u0026#34;: 1, \u0026#34;destination_hash\u0026#34;: \u0026#34;base64...\u0026#34;, \u0026#34;keys\u0026#34;: [ { \u0026#34;date\u0026#34;: \u0026#34;2025-10-15\u0026#34;, \u0026#34;transient\u0026#34;: { \u0026#34;type\u0026#34;: 11, \u0026#34;privkey\u0026#34;: \u0026#34;base64...\u0026#34;, \u0026#34;pubkey\u0026#34;: \u0026#34;base64...\u0026#34; }, \u0026#34;blinded\u0026#34;: { \u0026#34;privkey\u0026#34;: \u0026#34;base64...\u0026#34;, \u0026#34;pubkey\u0026#34;: \u0026#34;base64...\u0026#34; }, \u0026#34;offline_sig_block\u0026#34;: { \u0026#34;expires\u0026#34;: 1729123200, \u0026#34;signature\u0026#34;: \u0026#34;base64...\u0026#34; } } ], \u0026#34;signature\u0026#34;: \u0026#34;base64...\u0026#34; // Signature over entire structure } I2CP Protocol Enhancement (TODO) Current Status: No I2CP protocol enhancement defined for offline keys with encrypted LeaseSet.\nRequirements:\nKey delivery mechanism:\nUpload batch of keys from client to router Acknowledgment of successful key loading Key expiration notification:\nRouter notifies client when keys running low Client can generate and upload new batch Key revocation:\nEmergency revocation of future keys if compromise suspected Proposed I2CP Messages:\nUPLOAD_OFFLINE_KEYS - Dávka šifrovaného klíčového materiálu - Pokryté časové období OFFLINE_KEY_STATUS - Počet zbývajících dnů - Datum příštího vypršení platnosti klíče REVOKE_OFFLINE_KEYS - Časové rozmezí k odvolání - Nové klíče k nahrazení (volitelné) Implementation Status Java I2P:\n✅ Offline keys for standard LS2: Fully supported (since 0.9.38) ⚠️ Offline keys for encrypted LS2: Implemented (since 0.9.40) ❌ File format: Not standardized ❌ I2CP protocol: Not enhanced i2pd (C++):\n✅ Offline keys for standard LS2: Fully supported ✅ Offline keys for encrypted LS2: Fully supported (since 2.58.0) ❌ File format: Not standardized ❌ I2CP protocol: Not enhanced References:\nOffline Signatures Proposal I2CP Specification Security Considerations Cryptographic Security Algorithm Selection:\nAll cryptographic primitives are based on well-studied algorithms:\nChaCha20: Modern stream cipher, constant-time, no timing attacks SHA-256: NIST-approved hash, 128-bit security level HKDF: RFC 5869 standard, proven security bounds Ed25519/Red25519: Curve25519-based, ~128-bit security level X25519: Diffie-Hellman over Curve25519, ~128-bit security level Key Sizes:\nAll symmetric keys: 256 bits (32 bytes) All public/private keys: 256 bits (32 bytes) All nonces/IVs: 96 bits (12 bytes) All signatures: 512 bits (64 bytes) These sizes provide adequate security margins against current and near-future attacks.\nForward Secrecy Daily Key Rotation:\nEncrypted LeaseSets rotate keys daily (UTC midnight):\nNew blinded public/private key pair New storage location in DHT New encryption keys for both layers Benefits:\nCompromising today\u0026rsquo;s blinded key doesn\u0026rsquo;t reveal yesterday\u0026rsquo;s Limits exposure window to 24 hours Prevents long-term tracking via DHT Enhanced with Ephemeral Keys:\nDH client authorization uses ephemeral keys:\nServer generates new ephemeral DH keypair for each publication Compromising ephemeral key only affects that publication True forward secrecy even if long-term keys compromised Privacy Properties Destination Blinding:\nThe blinded public key:\nIs unlinkable to the original destination (without knowing the secret) Changes daily, preventing long-term correlation Cannot be reversed to find the original public key Client Membership Privacy:\nPer-client authorization provides:\nAnonymity: No way to identify which clients are authorized Untraceability: Cannot track when specific clients added/revoked Size obfuscation: Can add dummy entries to hide true count DHT Privacy:\nStorage location rotates daily:\nlocation = SHA-256(sig_type || blinded_public_key) This prevents:\nCorrelation across days via DHT lookups Long-term monitoring of service availability Traffic analysis of DHT queries Threat Model Adversary Capabilities:\nNetwork Adversary:\nCan monitor all DHT traffic Can observe encrypted LeaseSet publications Cannot decrypt without proper keys Floodfill Adversary:\nCan store and analyze all encrypted LeaseSets Can track publication patterns over time Cannot decrypt Layer 1 or Layer 2 Can see client count (but not identities) Authorized Client Adversary:\nCan decrypt specific encrypted LeaseSets Can access inner LeaseSet2 data Cannot determine other clients\u0026rsquo; identities Cannot decrypt past LeaseSets (with ephemeral keys) Out of Scope:\nMalicious router implementations Compromised router host systems Side-channel attacks (timing, power analysis) Physical access to keys Social engineering attacks Attack Scenarios 1. Offline Keys Tracking Attack:\nAttack: Adversary tracks encrypted LeaseSets via unchanging offline signature block.\nMitigation: Generate new transient keys daily (in addition to blinded keys).\nStatus: Documented recommendation, implementation-specific.\n2. Client Position Inference Attack:\nAttack: If client order is static, clients can infer their position and detect when other clients added/removed.\nMitigation: Randomize client order in authorization list for each publication.\nStatus: Documented recommendation in specification.\n3. Client Count Analysis Attack:\nAttack: Adversary monitors client count changes over time to infer service popularity or client churn.\nMitigation: Add random dummy entries to authorization list.\nStatus: Optional feature, deployment-specific trade-off (size vs. privacy).\n4. PSK Interception Attack:\nAttack: Adversary intercepts PSK during out-of-band exchange and can decrypt all future encrypted LeaseSets.\nMitigation: Use DH client authorization instead, or ensure secure key exchange (Signal, OTR, PGP).\nStatus: Known limitation of PSK approach, documented in specification.\n5. Timing Correlation Attack:\nAttack: Adversary correlates publication times across days to link encrypted LeaseSets.\nMitigation: Randomize publication times, use delayed publishing.\nStatus: Implementation-specific, not addressed in core specification.\n6. Long-term Secret Compromise:\nAttack: Adversary compromises the blinding secret and can compute all past and future blinded keys.\nMitigation:\nUse optional secret parameter (not empty) Rotate secret periodically Use different secrets for different services Status: Secret parameter is optional; using it is highly recommended.\nOperational Security Key Management:\nSigning Private Key:\nStore offline in cold storage Use only for generating blinded keys (batch process) Never expose to online router Blinded Private Keys:\nGenerate offline, deliver in batches Rotate daily automatically Delete after use (forward secrecy) Transient Private Keys (with offline keys):\nGenerate offline, deliver in batches Can be longer-lived (days/weeks) Rotate regularly for enhanced privacy Client Authorization Keys:\nDH: Client private keys never leave client device PSK: Use unique keys per client, secure exchange Revoke immediately upon client removal Secret Management:\nThe optional secret parameter in GENERATE_ALPHA:\nSHOULD be used for high-security services MUST be transmitted securely to authorized clients SHOULD be rotated periodically (e.g., monthly) CAN be different for different client groups Monitoring and Auditing:\nPublication Monitoring:\nVerify encrypted LeaseSets published successfully Monitor floodfill acceptance rates Alert on publication failures Client Access Monitoring:\nLog client authorization attempts (without identifying clients) Monitor for unusual patterns Detect potential attacks early Key Rotation Auditing:\nVerify daily key rotation occurs Check blinded key changes daily Ensure old keys are deleted Implementation Security Constant-Time Operations:\nImplementations MUST use constant-time operations for:\nAll scalar arithmetic (mod L operations) Private key comparisons Signature verification DH key agreement Memory Security:\nZero sensitive key material after use Use secure memory allocation for keys Prevent keys from being paged to disk Clear stack variables containing key material Random Number Generation:\nUse cryptographically secure RNG (CSRNG) Properly seed RNG from OS entropy source Do not use predictable RNGs for key material Verify RNG output quality periodically Input Validation:\nValidate all public keys are on the curve Check all signature types are supported Verify all lengths before parsing Reject malformed encrypted LeaseSets early Error Handling:\nDo not leak information via error messages Use constant-time comparison for authentication Do not expose timing differences in decryption Log security-relevant events properly Recommendations For Service Operators:\n✅ Use Red25519 (type 11) for new destinations ✅ Use DH client authorization for high-security services ✅ Generate new transient keys daily when using offline keys ✅ Use the optional secret parameter in GENERATE_ALPHA ✅ Randomize client order in authorization lists ✅ Monitor publication success and investigate failures ⚠️ Consider dummy entries to hide client count (size trade-off) For Client Implementers:\n✅ Validate blinded public keys are on prime-order subgroup ✅ Verify all signatures before trusting data ✅ Use constant-time operations for cryptographic primitives ✅ Zero key material immediately after use ✅ Implement proper error handling without information leaks ✅ Support both Ed25519 and Red25519 destination types For Network Operators:\n✅ Accept encrypted LeaseSets in floodfill routers ✅ Enforce reasonable size limits to prevent abuse ✅ Monitor for anomalous patterns (extremely large, frequent updates) ⚠️ Consider rate limiting encrypted LeaseSet publications Implementation Notes Java I2P Implementation Repository: https://github.com/i2p/i2p.i2p Key Classes:\nnet.i2p.data.LeaseSet2 - LeaseSet2 structure net.i2p.data.EncryptedLeaseSet - Encrypted LS2 implementation net.i2p.crypto.eddsa.EdDSAEngine - Ed25519/Red25519 signatures net.i2p.crypto.HKDF - HKDF implementation net.i2p.crypto.ChaCha20 - ChaCha20 cipher Configuration:\nEnable encrypted LeaseSet in clients.config:\n# Povolit šifrovaný LeaseSet i2cp.encryptLeaseSet=true # Volitelné: Povolit autorizaci klienta i2cp.enableAccessList=true # Volitelné: Použít autorizaci DH (výchozí je PSK) i2cp.accessListType=0 # Volitelné: Blinding secret (tajný údaj pro zaslepení) (důrazně doporučeno) i2cp.blindingSecret=your-secret-here API Usage Example:\n// Vytvořte šifrovaný LeaseSet EncryptedLeaseSet els = new EncryptedLeaseSet(); // Nastavit cílovou adresu els.setDestination(destination); // Povolte autorizaci pro jednotlivé klienty els.setAuthorizationEnabled(true); els.setAuthType(EncryptedLeaseSet.AUTH_DH); // Přidejte autorizované klienty (veřejné klíče DH) for (byte[] clientPubKey : authorizedClients) { els.addClient(clientPubKey); } // Nastavte parametry blinding (zaslepení) els.setBlindingSecret(\u0026#34;your-secret\u0026#34;); // Podepište a publikujte els.sign(signingPrivateKey); netDb.publish(els); i2pd (C++) Implementation Repository: https://github.com/PurpleI2P/i2pd Key Files:\nlibi2pd/LeaseSet.h/cpp - LeaseSet implementations libi2pd/Crypto.h/cpp - Cryptographic primitives libi2pd/Ed25519.h/cpp - Ed25519/Red25519 signatures libi2pd/ChaCha20.h/cpp - ChaCha20 cipher Configuration:\nEnable in tunnel configuration (tunnels.conf):\n[my-hidden-service] type = http host = 127.0.0.1 port = 8080 keys = my-service-keys.dat # Povolit šifrovaný LeaseSet encryptleaseset = true # Volitelné: Typ autorizace klienta (0=DH, 1=PSK) authtype = 0 # Volitelné: Tajemství zaslepení secret = váš-tajný-klíč-zde # Volitelné: Autorizovaní klienti (po jednom na řádek, veřejné klíče zakódované v Base64) client.1 = base64-encoded-client-pubkey-1 client.2 = base64-encoded-client-pubkey-2 API Usage Example:\n// Vytvořte šifrovaný LeaseSet (sada údajů o příchozích tunnel destinace v I2P) auto encryptedLS = std::make_shared\u0026lt;i2p::data::EncryptedLeaseSet\u0026gt;( destination, blindingSecret ); // Povolit autorizaci pro jednotlivé klienty encryptedLS-\u0026gt;SetAuthType(i2p::data::AUTH_TYPE_DH); // Přidejte autorizované klienty for (const auto\u0026amp; clientPubKey : authorizedClients) { encryptedLS-\u0026gt;AddClient(clientPubKey); } // Podepište a publikujte encryptedLS-\u0026gt;Sign(signingPrivKey); netdb.Publish(encryptedLS); Testing and Debugging Test Vectors:\nGenerate test vectors for implementation verification:\n# Testovací vektor 1: zaslepení klíče destination_pubkey = bytes.fromhex(\u0026#39;a\u0026#39; * 64) sigtype = 7 blinded_sigtype = 11 date = \u0026#34;20251015\u0026#34; secret = \u0026#34;\u0026#34; alpha = generate_alpha(destination_pubkey, sigtype, blinded_sigtype, date, secret) print(f\u0026#34;Alpha: {alpha.hex()}\u0026#34;) # Očekávané: (ověřte podle referenční implementace) Unit Tests:\nKey areas to test:\nHKDF derivation with various inputs ChaCha20 encryption/decryption Red25519 signature generation and verification Key blinding (private and public) Layer 1/2 encryption/decryption Client authorization (DH and PSK) Base32 address generation and parsing Integration Tests:\nPublish encrypted LeaseSet to test network Retrieve and decrypt from client Verify daily key rotation Test client authorization (add/remove clients) Test offline keys (if supported) Common Implementation Errors:\nIncorrect mod L reduction: Must use proper modular arithmetic Endianness errors: Most fields are big-endian, but some crypto uses little-endian Off-by-one in array slicing: Verify indices are inclusive/exclusive as needed Missing constant-time comparisons: Use constant-time for all sensitive comparisons Not zeroing key material: Always zero keys after use Performance Considerations Computational Costs:\nOperation Cost Notes Key blinding (server)1 scalar multPer publication Key blinding (client)1 point add + 1 scalar multPer retrieval Layer 1 encryption1 HKDF + 1 ChaCha20Fast Layer 2 encryption1 HKDF + 1 ChaCha20Fast DH client auth (server)N+1 X25519 opsN = number of clients DH client auth (client)1 X25519 opPer retrieval PSK client auth0 DH opsOnly HKDF + ChaCha20 Signature (Red25519)1 signature opSimilar cost to Ed25519 Size Overhead:\nComponent Size Frequency Blinded public key32 bytesPer LeaseSet Layer 1 encryption overhead32 bytes (salt)Per LeaseSet Layer 2 encryption overhead32 bytes (salt)Per LeaseSet DH auth per client40 bytesPer client per LeaseSet DH ephemeral pubkey32 bytesPer LeaseSet (if DH auth) PSK auth per client40 bytesPer client per LeaseSet PSK salt32 bytesPer LeaseSet (if PSK auth) Signature64 bytesPer LeaseSet Offline sig block≈100 bytesPer LeaseSet (if offline keys) Typical Sizes:\nNo client auth: ~200 bytes overhead With 10 DH clients: ~600 bytes overhead With 100 DH clients: ~4200 bytes overhead Optimization Tips:\nBatch key generation: Generate blinded keys for multiple days in advance Cache subcredentials: Compute once per day, reuse for all publications Reuse ephemeral keys: Can reuse ephemeral DH key for short period (minutes) Parallel client encryption: Encrypt client cookies in parallel Fast path for no auth: Skip authorization layer entirely when disabled Compatibility Backward Compatibility:\nEd25519 (type 7) destinations supported for unblinded keys Red25519 (type 11) required for blinded keys Traditional LeaseSets still fully supported Encrypted LeaseSets do not break existing network Forward Compatibility:\nReserved flag bits for future features Extensible authorization scheme (3 bits allow 8 types) Version field in various structures Interoperability:\nJava I2P and i2pd fully interoperable since: Java I2P 0.9.40 (May 2019) i2pd 2.58.0 (September 2025) Encrypted LeaseSets work across implementations Client authorization works across implementations References IETF RFCs RFC 2104 - HMAC: Keyed-Hashing for Message Authentication (February 1997) RFC 5869 - HMAC-based Extract-and-Expand Key Derivation Function (HKDF) (May 2010) RFC 7539 - ChaCha20 and Poly1305 for IETF Protocols (May 2015) RFC 7748 - Elliptic Curves for Security (January 2016) I2P Specifications Common Structures Specification - LeaseSet2 and EncryptedLeaseSet structures Proposal 123: New netDB Entries - Background and design of LeaseSet2 Proposal 146: Red25519 - Red25519 signature scheme specification Proposal 149: B32 for Encrypted LS2 - Base32 addressing for encrypted LeaseSets Red25519 Specification - Detailed Red25519 implementation B32 Addressing Specification - Base32 address format Network Database Documentation - NetDB usage and operations I2CP Specification - I2P Client Protocol Cryptographic References Ed25519 Paper - \u0026ldquo;High-speed high-security signatures\u0026rdquo; by Bernstein et al. ZCash Protocol Specification - Section 5.4.6: RedDSA signature scheme Tor Rendezvous Specification v3 - Tor\u0026rsquo;s onion service specification (for comparison) Security References Key Blinding Security Discussion - Tor Project mailing list discussion Tor Ticket #8106 - Key blinding implementation discussion PRNG Security - Random number generator security considerations Tor PRNG Discussion - Discussion of PRNG usage in Tor Implementation References Java I2P Repository - Official Java implementation i2pd Repository - C++ implementation I2P Website - Official I2P project website I2P Specifications - Complete specification index Version History I2P Release Notes - Official release announcements Java I2P Releases - GitHub release history i2pd Releases - GitHub release history Appendix A: Cryptographic Constants Ed25519 / Red25519 Constants # Ed25519 základní bod (generátor) B = 2**255 - 19 # Řád Ed25519 (velikost skalárního pole) L = 2**252 + 27742317777372353535851937790883648493 # Hodnoty typu podpisu SIGTYPE_ED25519 = 7 # 0x0007 SIGTYPE_RED25519 = 11 # 0x000b # Délky klíčů PRIVKEY_SIZE = 32 # bajtů PUBKEY_SIZE = 32 # bajtů SIGNATURE_SIZE = 64 # bajtů ChaCha20 Constants # Parametry ChaCha20 CHACHA20_KEY_SIZE = 32 # bajtů (256 bitů) CHACHA20_NONCE_SIZE = 12 # bajtů (96 bitů) CHACHA20_INITIAL_COUNTER = 1 # RFC 7539 povoluje 0 nebo 1 HKDF Constants # Parametry HKDF (funkce odvozování klíčů založená na HMAC) HKDF_HASH = \u0026#34;SHA-256\u0026#34; HKDF_SALT_MAX = 32 # bytes (HashLen) # Řetězce info pro HKDF (funkce odvozování klíčů založená na HMAC) (oddělení domén) HKDF_INFO_ALPHA = b\u0026#34;i2pblinding1\u0026#34; HKDF_INFO_LAYER1 = b\u0026#34;ELS2_L1K\u0026#34; HKDF_INFO_LAYER2 = b\u0026#34;ELS2_L2K\u0026#34; HKDF_INFO_DH_AUTH = b\u0026#34;ELS2_XCA\u0026#34; HKDF_INFO_PSK_AUTH = b\u0026#34;ELS2PSKA\u0026#34; Hash Personalization Strings # Personalizační řetězce pro SHA-256 HASH_PERS_ALPHA = b\u0026#34;I2PGenerateAlpha\u0026#34; HASH_PERS_RED25519 = b\u0026#34;I2P_Red25519H(x)\u0026#34; HASH_PERS_CREDENTIAL = b\u0026#34;credential\u0026#34; HASH_PERS_SUBCREDENTIAL = b\u0026#34;subcredential\u0026#34; Structure Sizes # Velikosti vrstvy 0 (vnější) BLINDED_SIGTYPE_SIZE = 2 # bajty BLINDED_PUBKEY_SIZE = 32 # bajtů (pro Red25519) PUBLISHED_TS_SIZE = 4 # bajty EXPIRES_SIZE = 2 # bajty FLAGS_SIZE = 2 # bajty LEN_OUTER_CIPHER_SIZE = 2 # bajty SIGNATURE_SIZE = 64 # bajtů (Red25519) # Velikosti bloků offline klíče OFFLINE_EXPIRES_SIZE = 4 # bajty OFFLINE_SIGTYPE_SIZE = 2 # bajty OFFLINE_SIGNATURE_SIZE = 64 # bajtů # Velikosti vrstvy 1 (střední) AUTH_FLAGS_SIZE = 1 # bajt EPHEMERAL_PUBKEY_SIZE = 32 # bajtů (DH autentizace) AUTH_SALT_SIZE = 32 # bajtů (PSK autentizace) NUM_CLIENTS_SIZE = 2 # bajtů CLIENT_ID_SIZE = 8 # bajtů CLIENT_COOKIE_SIZE = 32 # bajtů AUTH_CLIENT_ENTRY_SIZE = 40 # bajtů (CLIENT_ID + CLIENT_COOKIE) # Režie šifrování SALT_SIZE = 32 # bajtů (přidáno před každou šifrovanou vrstvu) # Adresa Base32 B32_ENCRYPTED_DECODED_SIZE = 35 # bajtů B32_ENCRYPTED_ENCODED_LEN = 56 # znaků B32_SUFFIX = \u0026#34;.b32.i2p\u0026#34; Appendix B: Test Vectors Test Vector 1: Alpha Generation Input:\n# Veřejný klíč cíle (Ed25519) A = bytes.fromhex(\u0026#39;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\u0026#39;) stA = 0x0007 # Ed25519 stA_prime = 0x000b # Red25519 date = \u0026#34;20251015\u0026#34; secret = \u0026#34;\u0026#34; # Prázdné tajemství Computation:\nkeydata = A || bytes([0x00, 0x07]) || bytes([0x00, 0x0b]) # keydata = 36 bajtů salt = SHA256(b\u0026#34;I2PGenerateAlpha\u0026#34; + keydata) ikm = b\u0026#34;20251015\u0026#34; info = b\u0026#34;i2pblinding1\u0026#34; seed = HKDF(salt, ikm, info, 64) alpha = LEOS2IP(seed) mod L Expected Output:\n(Ověřte podle referenční implementace) alpha = [64bajtová hexadecimální hodnota] Test Vector 2: ChaCha20 Encryption Input:\nkey = bytes([i for i in range(32)]) # 0x00..0x1f nonce = bytes([i for i in range(12)]) # 0x00..0x0b plaintext = b\u0026#34;Hello, I2P!\u0026#34; Computation:\nciphertext = ChaCha20_Encrypt(key, nonce, plaintext, counter=1) Expected Output:\nciphertext = [ověřte podle testovacích vektorů RFC 7539] Test Vector 3: HKDF Input:\nsalt = bytes(32) # Samé nuly ikm = b\u0026#34;test input keying material\u0026#34; info = b\u0026#34;ELS2_L1K\u0026#34; n = 44 Computation:\nkeys = HKDF(salt, ikm, info, n) Expected Output:\nkeys = [44bajtová hexadecimální hodnota] Test Vector 4: Base32 Address Input:\npubkey = bytes.fromhex(\u0026#39;bbbb\u0026#39; + \u0026#39;bb\u0026#39; * 30) # 32 bytes unblinded_sigtype = 11 # Red25519 blinded_sigtype = 11 # Red25519 Computation:\naddress = generate_encrypted_b32_address(pubkey, unblinded_sigtype, blinded_sigtype) Expected Output:\naddress = [56 znaků v base32].b32.i2p # Ověřte, že se kontrolní součet ověřuje správně Appendix C: Glossary Alpha (α): The secret blinding factor used to blind public and private keys. Generated from the destination, date, and optional secret.\nAuthCookie: A 32-byte random value encrypted for each authorized client, used as input to Layer 2 encryption.\nB (Base Point): The generator point for the Ed25519 elliptic curve.\nBlinded Key: A public or private key that has been transformed using the alpha blinding factor. Blinded keys cannot be linked to the original keys without knowing alpha.\nChaCha20: A stream cipher providing fast, secure encryption without requiring AES hardware support.\nClientID: An 8-byte identifier derived from HKDF output, used to identify authorization entries for clients.\nClientCookie: A 32-byte encrypted value containing the authCookie for a specific client.\nCredential: A 32-byte value derived from the destination\u0026rsquo;s public key and signature types, binding encryption to knowledge of the destination.\nCSRNG: Cryptographically Secure Random Number Generator. Must provide unpredictable output suitable for key generation.\nDH (Diffie-Hellman): A cryptographic protocol for securely establishing shared secrets. I2P uses X25519.\nEd25519: An elliptic curve signature scheme providing fast signatures with 128-bit security level.\nEphemeral Key: A short-lived cryptographic key, typically used once and then discarded.\nFloodfill: I2P routers that store and serve network database entries, including encrypted LeaseSets.\nHKDF: HMAC-based Key Derivation Function, used to derive multiple cryptographic keys from a single source.\nL (Order): The order of the Ed25519 scalar field (approximately 2^252).\nLayer 0 (Outer): The plaintext portion of an encrypted LeaseSet, containing blinded key and metadata.\nLayer 1 (Middle): The first encrypted layer, containing client authorization data.\nLayer 2 (Inner): The innermost encrypted layer, containing the actual LeaseSet2 data.\nLeaseSet2 (LS2): Second version of I2P\u0026rsquo;s network database entry format, introducing encrypted variants.\nNetDB: The I2P network database, a distributed hash table storing router and destination information.\nOffline Keys: A feature allowing the main signing key to remain in cold storage while a transient key handles daily operations.\nPSK (Pre-Shared Key): A symmetric key shared in advance between two parties, used for PSK client authorization.\nRed25519: An Ed25519-based signature scheme with key blinding support, based on ZCash RedDSA.\nSalt: Random data used as input to key derivation functions to ensure unique outputs.\nSigType: A numeric identifier for signature algorithms (e.g., 7 = Ed25519, 11 = Red25519).\nSubcredential: A 32-byte value derived from the credential and blinded public key, binding encryption to a specific encrypted LeaseSet.\nTransient Key: A temporary signing key used with offline keys, with a limited validity period.\nX25519: An elliptic curve Diffie-Hellman protocol over Curve25519, providing key agreement.\nDocument Information Status: This document represents the current stable encrypted LeaseSet specification as implemented in I2P since June 2019. The protocol is mature and widely deployed.\nContributing: For corrections or improvements to this documentation, please submit issues or pull requests to the I2P specifications repository.\nSupport: For questions about implementing encrypted LeaseSets:\nI2P Forum: https://i2pforum.net/ IRC: #i2p-dev on OFTC Matrix: #i2p-dev:matrix.org Acknowledgments: This specification builds on work by the I2P development team, ZCash cryptography research, and Tor Project\u0026rsquo;s key blinding research.\n","description":"Formát LeaseSet s řízeným přístupem pro soukromé Destinations (cíle)","id":"14f2a4c0bb3f459df8db8dbce45508ff","section":"docs","title":"Šifrovaný LeaseSet","url":"/cs/docs/specs/encryptedleaseset/"},{"categories":null,"content":"Přehled NTCP2 nahrazuje původní transport NTCP handshakem založeným na Noise (kryptografickém rámci pro handshake), který odolává rozpoznávání provozu podle otisků, šifruje délková pole a podporuje moderní sady šifer. Routery mohou provozovat NTCP2 vedle SSU2 jako dva povinné transportní protokoly v síti I2P. NTCP (verze 1) byl v 0.9.40 (květen 2019) označen jako zastaralý a v 0.9.50 (květen 2021) zcela odstraněn.\nRámec protokolu Noise NTCP2 používá Noise Protocol Framework (rámec protokolu Noise) Revize 33, 2017-10-04 s rozšířeními specifickými pro I2P:\nVzor: Noise_XK_25519_ChaChaPoly_SHA256 Rozšířený identifikátor: Noise_XKaesobfse+hs2+hs3_25519_ChaChaPoly_SHA256 (pro inicializaci KDF) Funkce DH: X25519 (RFC 7748) - 32bajtové klíče, kódování little-endian Šifra: AEAD_CHACHA20_POLY1305 (RFC 7539/RFC 8439) 12bajtový nonce (jednorázová hodnota): první 4 bajty jsou nula, posledních 8 bajtů je čítač (little-endian) Maximální hodnota nonce: 2^64 - 2 (spojení se musí ukončit před dosažením 2^64 - 1) Hašovací funkce: SHA-256 (32bajtový výstup) MAC: Poly1305 (16bajtový autentizační tag) Rozšíření specifická pro I2P Obfuskace AES: Efemerní klíče šifrované pomocí AES-256-CBC s využitím hashe routeru Boba a publikovaného IV (inicializačního vektoru) Náhodný padding: Padding v otevřeném textu ve zprávách 1-2 (autentizovaný), padding AEAD (ověřené šifrování s připojenými daty) ve zprávách 3+ (šifrovaný) Zakrytí délky pomocí SipHash-2-4: Dvoubajtové délky rámců jsou XORovány s výstupem SipHash Struktura rámců: Rámce s délkovým prefixem pro datovou fázi (kompatibilita se streamováním přes TCP) Blokově strukturovaná uživatelská data: Strukturovaný datový formát s typovanými bloky Postup navázání spojení Alice (Initiator) Bob (Responder) SessionRequest ──────────────────────► ◄────────────────────── SessionCreated SessionConfirmed ──────────────────────► Třízprávový handshake SessionRequest - Aličin zamaskovaný efemérní klíč, volby, nápovědy k paddingu (vycpávce) SessionCreated - Bobův zamaskovaný efemérní klíč, šifrované volby, padding SessionConfirmed - Aličin šifrovaný statický klíč a RouterInfo (dva AEAD rámce; ověřené šifrování s přidruženými daty) Vzory zpráv Noise (kryptografický rámec) XK(s, rs): Authentication Confidentiality \u0026lt;- s (Bob\u0026#39;s static key known in advance) -\u0026gt; e, es 0 2 \u0026lt;- e, ee 2 1 -\u0026gt; s, se 2 5 \u0026lt;- 2 5 Úrovně autentizace: - 0: Bez autentizace (mohl to poslat kdokoli) - 2: Autentizace odesílatele odolná vůči útoku typu key-compromise impersonation (KCI, podvržení po kompromitaci klíče)\nÚrovně důvěrnosti: - 1: Efemérní příjemce (dopředné utajení, bez autentizace příjemce) - 2: Známý příjemce, dopředné utajení pouze při kompromitaci odesílatele - 5: Silné dopředné utajení (efemérní-efemérní + efemérní-statický DH)\nSpecifikace zpráv Notace klíčů RH_A = Router Hash pro Alici (32 bajtů, SHA-256) RH_B = Router Hash pro Boba (32 bajtů, SHA-256) || = operátor zřetězení byte(n) = jeden bajt s hodnotou n Všechny vícebajtové celočíselné hodnoty jsou big-endian (pořadí bajtů od nejvýznamnějšího), není-li uvedeno jinak Klíče X25519 jsou little-endian (pořadí bajtů od nejméně významného) (32 bajtů) Autentizované šifrování (ChaCha20-Poly1305) Šifrovací funkce:\nAEAD_ChaCha20_Poly1305(key, nonce, associatedData, plaintext) → (ciphertext || MAC) Parametry: - key: 32bajtový šifrovací klíč z KDF - nonce: 12 bajtů (4 nulové bajty + 8bajtový čítač, little-endian (nejméně významný bajt první)) - associatedData: 32bajtový hash ve fázi handshake; ve fázi dat nulové délky - plaintext: Data k zašifrování (0+ bajtů)\nVýstup: - Šifrotext: Stejná délka jako otevřený text - MAC: 16 bajtů (autentizační tag Poly1305)\nSpráva nonce: - Čítač začíná na 0 u každé instance šifry - Zvyšuje se pro každou operaci AEAD v daném směru - Samostatné čítače pro Alice→Bob a Bob→Alice v datové fázi - Spojení se musí ukončit dříve, než čítač dosáhne 2^64 - 1\nZpráva 1: SessionRequest (žádost o relaci) Alice navazuje spojení s Bobem.\nOperace Noise: e, es (generování a výměna efemérních klíčů)\nSurový formát +----+----+----+----+----+----+----+----+ | | + AES-256-CBC Encrypted X (32B) + | Key: RH_B, IV: Bob\u0026#39;s published IV | + + | | +----+----+----+----+----+----+----+----+ | | + ChaChaPoly Frame (48 bytes) + | Plaintext: 32B (X + options) | + k from KDF-1, n=0, ad=h + | | +----+----+----+----+----+----+----+----+ | Cleartext Padding (optional) | + Length specified in options + | 0 to 65535 - 80 bytes | ~ . . . ~ +----+----+----+----+----+----+----+----+ Omezení velikosti: - Minimum: 80 bajtů (32 AES + 48 AEAD) - Maximum: celkem 65535 bajtů - Zvláštní případ: Max 287 bajtů při připojení k adresám \u0026ldquo;NTCP\u0026rdquo; (detekce verze)\nDešifrovaný obsah +----+----+----+----+----+----+----+----+ | | + X (Alice ephemeral public key) + | 32 bytes, X25519, little-endian | + + | | +----+----+----+----+----+----+----+----+ | Options Block | + (16 bytes) + | | +----+----+----+----+----+----+----+----+ | Cleartext Padding (optional) | ~ . . . ~ +----+----+----+----+----+----+----+----+ Blok voleb (16 bajtů, big-endian (uspořádání s nejvýznamnějším bajtem jako prvním)) +----+----+----+----+----+----+----+----+ | id | ver| padLen | m3p2len | Rsvd(0) | +----+----+----+----+----+----+----+----+ | tsA | Reserved (0) | +----+----+----+----+----+----+----+----+ id : 1 byte - Network ID (2 for mainnet, 16-254 for testnets) ver : 1 byte - Protocol version (currently 2) padLen : 2 bytes - Padding length in this message (0-65455) m3p2len : 2 bytes - Length of SessionConfirmed part 2 frame Rsvd : 2 bytes - Reserved, set to 0 tsA : 4 bytes - Unix timestamp (seconds since epoch) Reserved: 4 bytes - Reserved, set to 0 Kritická pole: - Network ID (od verze 0.9.42): Rychlé odmítnutí spojení napříč sítěmi - m3p2len: Přesná velikost části 2 zprávy 3 (musí odpovídat při odeslání)\nFunkce pro odvozování klíčů (KDF-1) Inicializace protokolu:\nprotocol_name = \u0026#34;Noise_XKaesobfse+hs2+hs3_25519_ChaChaPoly_SHA256\u0026#34; h = SHA256(protocol_name) ck = h // Chaining key initialized to hash Operace MixHash:\nh = SHA256(h) // Null prologue h = SHA256(h || rs) // Bob\u0026#39;s static key (known) h = SHA256(h || e.pubkey) // Alice\u0026#39;s ephemeral key X // h is now the associated data for message 1 AEAD Operace MixKey (es pattern – vzor ephemeral-static):\ndh_result = X25519(Alice.ephemeral_private, Bob.static_public) temp_key = HMAC-SHA256(ck, dh_result) ck = HMAC-SHA256(temp_key, byte(0x01)) k = HMAC-SHA256(temp_key, ck || byte(0x02)) // k is the cipher key for message 1 // ck is retained for message 2 KDF Poznámky k implementaci AES obfuskace: Používá se pouze pro odolnost vůči DPI (hloubková inspekce paketů); kdokoli s Bobovým hash routeru a IV může dešifrovat X Prevence replay útoků: Bob musí ukládat do cache hodnoty X (nebo jejich šifrované ekvivalenty) po dobu alespoň 2*D sekund (D = maximální odchylka hodin) Validace časového razítka: Bob musí odmítnout spojení s |tsA - current_time| \u0026gt; D (typicky D = 60 sekund) Validace křivky: Bob musí ověřit, že X je platný bod X25519 Rychlé odmítnutí: Bob může zkontrolovat X[31] \u0026amp; 0x80 == 0 před dešifrováním (platné klíče X25519 mají nejvyšší bit (MSB) nulový) Zpracování chyb: Při jakémkoli selhání Bob ukončí spojení s TCP RST po náhodném timeoutu a náhodném přečtení bajtů Bufferování: Alice musí odeslat celou zprávu (včetně vycpávky) najednou kvůli efektivitě Zpráva 2: SessionCreated Bob odpovídá Alici.\nOperace Noise: e, ee (efemérní-efemérní DH)\nSurový formát +----+----+----+----+----+----+----+----+ | | + AES-256-CBC Encrypted Y (32B) + | Key: RH_B, IV: AES state from msg1 | + + | | +----+----+----+----+----+----+----+----+ | | + ChaChaPoly Frame (48 bytes) + | Plaintext: 32B (Y + options) | + k from KDF-2, n=0, ad=h + | | +----+----+----+----+----+----+----+----+ | Cleartext Padding (optional) | + Length specified in options + | 0 to 65535 - 80 bytes | ~ . . . ~ +----+----+----+----+----+----+----+----+ Dešifrovaný obsah +----+----+----+----+----+----+----+----+ | | + Y (Bob ephemeral public key) + | 32 bytes, X25519, little-endian | + + | | +----+----+----+----+----+----+----+----+ | Options Block | + (16 bytes) + | | +----+----+----+----+----+----+----+----+ | Cleartext Padding (optional) | ~ . . . ~ +----+----+----+----+----+----+----+----+ Blok možností (16 bajtů, big-endian (nejvýznamnější bajt první)) +----+----+----+----+----+----+----+----+ | Rsvd(0) | padLen | Reserved (0) | +----+----+----+----+----+----+----+----+ | tsB | Reserved (0) | +----+----+----+----+----+----+----+----+ Rsvd : 2 bytes - Reserved, set to 0 padLen : 2 bytes - Padding length in this message Reserved: 10 bytes - Reserved, set to 0 tsB : 4 bytes - Unix timestamp (seconds since epoch) Funkce pro odvození klíče (KDF-2) Operace MixHash (mixovací hash):\nh = SHA256(h || encrypted_payload_msg1) // 32-byte ciphertext if (msg1_padding_length \u0026gt; 0): h = SHA256(h || padding_from_msg1) h = SHA256(h || e.pubkey) // Bob\u0026#39;s ephemeral key Y // h is now the associated data for message 2 AEAD Operace MixKey (vzor ee):\ndh_result = X25519(Bob.ephemeral_private, Alice.ephemeral_public) temp_key = HMAC-SHA256(ck, dh_result) ck = HMAC-SHA256(temp_key, byte(0x01)) k = HMAC-SHA256(temp_key, ck || byte(0x02)) // k is the cipher key for message 2 // ck is retained for message 3 KDF Vyčištění paměti:\n// Overwrite ephemeral keys after ee DH Alice.ephemeral_public = zeros(32) Alice.ephemeral_private = zeros(32) // Bob side Bob.received_ephemeral = zeros(32) // Bob side Poznámky k implementaci Řetězení AES: Šifrování Y používá stav AES-CBC ze zprávy 1 (neresetuje se) Prevence replay (opakovaného přehrání): Alice musí uchovávat hodnoty Y v mezipaměti alespoň po dobu 2*D sekund Ověření časového razítka: Alice musí odmítnout, pokud |tsB - current_time| \u0026gt; D Ověření křivky: Alice musí ověřit, že Y je platný bod X25519 Zpracování chyb: Při jakémkoli selhání Alice ukončí spojení pomocí TCP RST Bufferování: Bob musí vyprázdnit celou zprávu najednou Zpráva 3: SessionConfirmed Alice potvrdí relaci a odešle RouterInfo (metadata o routeru).\nOperace Noise: s, se (zveřejnění statického klíče a staticko-efemérní DH)\nDvoudílná struktura Zpráva 3 se skládá ze dvou samostatných rámců AEAD (ověřené šifrování s přidruženými daty):\nČást 1: Pevný 48bajtový rámec s Aliciným zašifrovaným statickým klíčem Část 2: Rámec proměnné délky obsahující RouterInfo, volby a vycpávku Surový formát +----+----+----+----+----+----+----+----+ | ChaChaPoly Frame 1 (48 bytes) | + Plaintext: Alice static key (32B) + | k from KDF-2, n=1, ad=h | + + | | +----+----+----+----+----+----+----+----+ | | + ChaChaPoly Frame 2 (variable) + | Length specified in msg1.m3p2len | + k from KDF-3, n=0, ad=h + | Plaintext: RouterInfo + padding | + + | | ~ . . . ~ +----+----+----+----+----+----+----+----+ Omezení velikosti: - Část 1: Přesně 48 bajtů (32 prostého textu + 16 MAC (Message Authentication Code, autentizační kód zprávy)) - Část 2: Délka uvedená ve zprávě 1 (pole m3p2len) - Celkové maximum: 65535 bajtů (část 1 max 48, takže část 2 max 65487)\nDešifrovaný obsah Část 1:\n+----+----+----+----+----+----+----+----+ | | + S (Alice static public key) + | 32 bytes, X25519, little-endian | + + | | +----+----+----+----+----+----+----+----+ Část 2:\n+----+----+----+----+----+----+----+----+ | Block: RouterInfo (required) | + Type=2, contains Alice\u0026#39;s RI + | | ~ . . . ~ +----+----+----+----+----+----+----+----+ | Block: Options (optional) | + Type=1, padding parameters + | | +----+----+----+----+----+----+----+----+ | Block: Padding (optional) | + Type=254, random data + | MUST be last block if present | ~ . . . ~ +----+----+----+----+----+----+----+----+ Funkce pro odvozování klíčů (KDF-3) Část 1 (vzorec s):\nh = SHA256(h || encrypted_payload_msg2) // 32-byte ciphertext if (msg2_padding_length \u0026gt; 0): h = SHA256(h || padding_from_msg2) // Encrypt static key with message 2 cipher key ciphertext = AEAD_ChaCha20_Poly1305(k_msg2, n=1, h, Alice.static_public) h = SHA256(h || ciphertext) // 48 bytes (32 + 16) // h is now the associated data for message 3 part 2 Část 2 (se pattern):\ndh_result = X25519(Alice.static_private, Bob.ephemeral_public) temp_key = HMAC-SHA256(ck, dh_result) ck = HMAC-SHA256(temp_key, byte(0x01)) k = HMAC-SHA256(temp_key, ck || byte(0x02)) // k is the cipher key for message 3 part 2 // ck is retained for data phase KDF ciphertext = AEAD_ChaCha20_Poly1305(k, n=0, h, payload) h = SHA256(h || ciphertext) // h is retained for SipHash KDF Vyčištění paměti:\n// Overwrite Bob\u0026#39;s ephemeral key after se DH Alice.received_ephemeral = zeros(32) // Alice side Bob.ephemeral_public = zeros(32) // Bob side Bob.ephemeral_private = zeros(32) // Bob side Poznámky k implementaci Ověření RouterInfo: Bob musí ověřit podpis, časové razítko a konzistenci klíče Shoda klíčů: Bob musí ověřit, že statický klíč Alice v části 1 se shoduje s klíčem v RouterInfo Umístění statického klíče: Hledejte odpovídající parametr \u0026ldquo;s\u0026rdquo; v NTCP nebo NTCP2 RouterAddress Pořadí bloků: RouterInfo musí být první, Options jako druhý (pokud je přítomen), Padding jako poslední (pokud je přítomen) Plánování délky: Alice musí zajistit, aby m3p2len ve zprávě 1 přesně odpovídal délce části 2 Bufferování: Alice musí odeslat obě části společně jako jedno odeslání TCP Volitelné řetězení: Alice může pro vyšší efektivitu okamžitě připojit rámec datové fáze Datová fáze Po dokončení handshake všechny zprávy používají rámce AEAD (ověřené šifrování s přidruženými daty) s proměnnou délkou a s obfuskovanými poli délky.\nFunkce odvození klíče (datová fáze) Funkce Split (Noise):\n// Generate transmit and receive keys zerolen = \u0026#34;\u0026#34; // Zero-length byte array temp_key = HMAC-SHA256(ck, zerolen) // Alice transmits to Bob k_ab = HMAC-SHA256(temp_key, byte(0x01)) // Bob transmits to Alice k_ba = HMAC-SHA256(temp_key, k_ab || byte(0x02)) // Cleanup ck = zeros(32) temp_key = zeros(32) Odvození klíče SipHash:\n// Generate additional symmetric key for SipHash ask_master = HMAC-SHA256(temp_key, \u0026#34;ask\u0026#34; || byte(0x01)) // \u0026#34;siphash\u0026#34; is 7 bytes US-ASCII temp_key2 = HMAC-SHA256(ask_master, h || \u0026#34;siphash\u0026#34;) sip_master = HMAC-SHA256(temp_key2, byte(0x01)) // Alice to Bob SipHash keys temp_key3 = HMAC-SHA256(sip_master, zerolen) sipkeys_ab = HMAC-SHA256(temp_key3, byte(0x01)) sipk1_ab = sipkeys_ab[0:7] // 8 bytes, little-endian sipk2_ab = sipkeys_ab[8:15] // 8 bytes, little-endian sipiv_ab = sipkeys_ab[16:23] // 8 bytes, IV // Bob to Alice SipHash keys sipkeys_ba = HMAC-SHA256(temp_key3, sipkeys_ab || byte(0x02)) sipk1_ba = sipkeys_ba[0:7] // 8 bytes, little-endian sipk2_ba = sipkeys_ba[8:15] // 8 bytes, little-endian sipiv_ba = sipkeys_ba[16:23] // 8 bytes, IV Struktura rámce +----+----+----+----+----+----+----+----+ |Obfs Len | | +----+----+ ChaChaPoly Frame + | Encrypted Block Data | + k_ab (Alice→Bob) or k_ba (Bob→Alice)| | Nonce starts at 0, increments | + No associated data (empty string) + | | ~ . . . ~ | | +----+----+----+----+----+----+----+----+ | Poly1305 MAC (16 bytes) | +----+----+----+----+----+----+----+----+ Omezení rámce: - Minimum: 18 bajtů (2 bajty zamaskované délky + 0 bajtů prostého textu + 16 bajtů MAC) - Maximum: 65537 bajtů (2 bajty zamaskované délky + rámec 65535 bajtů) - Doporučeno: pár KB na rámec (minimalizovat latenci přijímače)\nMaskování délky pomocí SipHash Účel: Zabránit identifikaci hranic rámců pomocí DPI\nAlgoritmus:\n// Initialization (per direction) IV[0] = sipiv // From KDF // For each frame: IV[n] = SipHash-2-4(sipk1, sipk2, IV[n-1]) Mask[n] = IV[n][0:1] // First 2 bytes of IV ObfuscatedLength = ActualLength XOR Mask[n] // Send 2-byte ObfuscatedLength, then ActualLength bytes Dekódování:\n// Receiver maintains identical IV chain IV[n] = SipHash-2-4(sipk1, sipk2, IV[n-1]) Mask[n] = IV[n][0:1] ActualLength = ObfuscatedLength XOR Mask[n] // Read ActualLength bytes (includes 16-byte MAC) Poznámky: - Oddělené řetězce IV (inicializační vektor) pro každý směr (Alice→Bob a Bob→Alice) - Pokud SipHash vrací uint64, použijte nejméně významné 2 bajty jako masku - Převeďte uint64 na další IV jako bajty v pořadí little-endian\nFormát bloku Každý rámec obsahuje nula nebo více bloků:\n+----+----+----+----+----+----+----+----+ |Type| Length | Data | +----+----+----+ + | | ~ . . . ~ +----+----+----+----+----+----+----+----+ Type : 1 byte - Block type identifier Length: 2 bytes - Big-endian, data size (0-65516) Data : Variable length payload Limity velikosti: - Maximální rámec: 65535 bajtů (včetně MAC) - Maximální prostor pro blok: 65519 bajtů (rámec - 16bajtové MAC) - Maximální jednotlivý blok: 65519 bajtů (3bajtová hlavička + 65516 dat)\nTypy bloků Type Name Description 0DateTimeTime synchronization (4-byte timestamp) 1OptionsPadding parameters, dummy traffic 2RouterInfoRouterInfo delivery/flooding 3I2NPI2NP message with shortened header 4TerminationExplicit connection close 224-253ReservedExperimental features 254PaddingRandom padding (must be last) 255ReservedFuture extensions **Pravidla řazení bloků:** - **Zpráva 3, část 2**: RouterInfo, Možnosti (volitelné), Padding (vycpávka; volitelný) - ŽÁDNÉ jiné typy - **Datová fáze**: Libovolné pořadí s výjimkou: - Padding MUSÍ být poslední blok, pokud je přítomen - Ukončení MUSÍ být poslední blok (kromě Padding), pokud je přítomen - Více bloků I2NP je povoleno v jednom rámci - Více bloků Padding NENÍ povoleno v jednom rámci Typ bloku 0: Datum a čas Synchronizace času pro detekci odchylky hodin.\n+----+----+----+----+----+----+----+ | 0 | 4 | timestamp | +----+----+----+----+----+----+----+ Type : 0 Length : 4 (big-endian) Timestamp: 4 bytes, Unix seconds (big-endian) Implementace: Zaokrouhlit na nejbližší sekundu, aby se zabránilo hromadění časové odchylky hodin.\nTyp bloku 1: Možnosti Parametry paddingu (vycpávání/výplň dat) a tvarování provozu.\n+----+----+----+----+----+----+----+----+ | 1 | size |tmin|tmax|rmin|rmax|tdmy| +----+----+----+----+----+----+----+----+ |tdmy| rdmy | tdelay | rdelay | | +----+----+----+----+----+----+----+ + | more_options (TBD) | ~ . . . ~ +----+----+----+----+----+----+----+----+ Type : 1 Length: 12+ bytes (big-endian) Poměry výplně (4.4 číslo s pevnou řádovou čárkou, hodnota/16.0): - tmin: Minimální poměr výplně pro odesílání (0.0 - 15.9375) - tmax: Maximální poměr výplně pro odesílání (0.0 - 15.9375) - rmin: Minimální poměr výplně pro příjem (0.0 - 15.9375) - rmax: Maximální poměr výplně pro příjem (0.0 - 15.9375)\nPříklady: - 0x00 = 0% výplně - 0x01 = 6.25% výplně - 0x10 = 100% výplně (poměr 1:1) - 0x80 = 800% výplně (poměr 8:1)\nFalešný provoz: - tdmy: Maximální objem, který je ochoten odesílat (2 bajty, průměr v bajtech/s) - rdmy: Požadovaný příjem (2 bajty, průměr v bajtech/s)\nVkládání zpoždění: - tdelay: Max. zpoždění ochotné k vložení (2 bajty, průměr v milisekundách) - rdelay: Požadované zpoždění (2 bajty, průměr v milisekundách)\nPokyny: - Minimální hodnoty označují požadovanou odolnost vůči analýze provozu - Maximální hodnoty označují omezení šířky pásma - Odesílatel by měl respektovat maximální hodnotu příjemce - Odesílatel může respektovat minimální hodnotu příjemce v rámci omezení - Žádný mechanismus vynucování; implementace se mohou lišit\nTyp bloku 2: RouterInfo Doručování RouterInfo pro naplnění a zaplavování netdb.\n+----+----+----+----+----+----+----+----+ | 2 | size |flg | RouterInfo | +----+----+----+----+ + | | ~ . . . ~ +----+----+----+----+----+----+----+----+ Type : 2 Length: Flag (1 byte) + RouterInfo size Flag : Bit 0 = flood request (1) or local store (0) Bits 1-7 = Reserved, set to 0 Použití:\nV Message 3 Part 2 (handshake): - Alice pošle svůj RouterInfo Bobovi - Flood bit obvykle 0 (lokální uložení) - RouterInfo NENÍ komprimován pomocí gzipu\nVe fázi dat: - Každá ze stran může odeslat svůj aktualizovaný RouterInfo - Bit Flood = 1: Vyžádat distribuci přes floodfill (pokud je příjemce floodfill) - Bit Flood = 0: Pouze místní uložení do netdb\nPožadavky na ověřování: 1. Ověřte, že typ podpisu je podporován 2. Ověřte podpis RouterInfo 3. Ověřte, že časové razítko je v přijatelných mezích 4. Pro handshake: Ověřte, že statický klíč odpovídá parametru \u0026ldquo;s\u0026rdquo; v adrese NTCP2 5. Pro datovou fázi: Ověřte, že router hash odpovídá protějšku relace 6. Floodujte (zaplavujte) pouze RouterInfos s publikovanými adresami\nPoznámky: - Žádný mechanismus ACK (v případě potřeby použijte I2NP DatabaseStore s reply tokenem) - Může obsahovat RouterInfos třetích stran (při použití floodfill) - NENÍ komprimováno pomocí gzip (na rozdíl od I2NP DatabaseStore)\nTyp bloku 3: zpráva I2NP Zpráva I2NP se zkrácenou hlavičkou o délce 9 bajtů.\n+----+----+----+----+----+----+----+----+ | 3 | size |type| msg_id | +----+----+----+----+----+----+----+----+ | expiration | I2NP payload | +----+----+----+ + | | ~ . . . ~ +----+----+----+----+----+----+----+----+ Type : 3 Length : 9 + payload_size (big-endian) Type : 1 byte, I2NP message type Msg_ID : 4 bytes, big-endian, I2NP message ID Expiration: 4 bytes, big-endian, Unix timestamp (seconds) Payload : I2NP message body (length = size - 9) Rozdíly oproti NTCP1: - Expirace: 4 bajty (sekundy) vs 8 bajtů (milisekundy) - Délka: vynecháno (odvoditelné z délky bloku) - Kontrolní součet: vynecháno (AEAD zajišťuje integritu) - Hlavička: 9 bajtů vs 16 bajtů (snížení o 44 %)\nFragmentace: - Zprávy I2NP NESMÍ být fragmentovány napříč bloky - Zprávy I2NP NESMÍ být fragmentovány napříč rámci - Více bloků I2NP je povoleno v jednom rámci\nTyp bloku 4: Ukončení Explicitní ukončení spojení s kódem důvodu.\n+----+----+----+----+----+----+----+----+ | 4 | size | valid_frames_recv | +----+----+----+----+----+----+----+----+ | (continued) |rsn | additional_data | +----+----+----+----+ + | | ~ . . . ~ +----+----+----+----+----+----+----+----+ Type : 4 Length : 9+ bytes (big-endian) Valid_Frames_Recv: 8 bytes, big-endian (receive nonce value) 0 if error in handshake phase Reason : 1 byte (see table below) Additional_Data : Optional (format unspecified, for debugging) Kódy důvodů:\nCode Reason Phase 0Normal close / unspecifiedAny 1Termination receivedData 2Idle timeoutData 3Router shutdownData 4Data phase AEAD failureData 5Incompatible optionsHandshake 6Incompatible signature typeHandshake 7Clock skewHandshake 8Padding violationAny 9AEAD framing errorData 10Payload format errorData 11Message 1 errorHandshake 12Message 2 errorHandshake 13Message 3 errorHandshake 14Intra-frame read timeoutData 15RouterInfo signature verification failHandshake 16Static key parameter mismatchHandshake 17BannedAny **Pravidla:** - Ukončení MUSÍ být v rámci posledním nevyplňovacím blokem - Maximálně jeden ukončovací blok na rámec - Odesílatel by měl po odeslání uzavřít spojení - Příjemce by měl po přijetí uzavřít spojení Zpracování chyb: - Chyby handshake: Typicky uzavřít pomocí TCP RST (bez ukončovacího bloku) - Chyby AEAD (autentizované šifrování s připojenými daty) ve fázi dat: Náhodný timeout + náhodné čtení, poté odeslat ukončení - Viz sekci \u0026ldquo;AEAD Error Handling\u0026rdquo; pro bezpečnostní postupy\nTyp bloku 254: Vycpávka Náhodná výplň pro odolnost vůči analýze síťového provozu.\n+----+----+----+----+----+----+----+----+ |254 | size | random_data | +----+----+----+ + | | ~ . . . ~ +----+----+----+----+----+----+----+----+ Type: 254 Length: 0-65516 bytes (big-endian) Data: Cryptographically random bytes Pravidla: - Výplň MUSÍ být posledním blokem v rámci, pokud je přítomna - Výplň nulové délky je povolena - Pouze jeden blok výplně na rámec - Rámce pouze s výplní jsou povoleny - Měly by být dodrženy vyjednané parametry z Options block (blok s volbami)\nVýplň ve zprávách 1-2: - Mimo rámec AEAD (v otevřeném textu) - Zahrnuto do hashového řetězce následující zprávy (autentizováno) - Manipulace je zjištěna, když AEAD následující zprávy selže\nVýplň ve zprávě 3+ a v datové fázi: - Uvnitř rámce AEAD (šifrovaného a autentizovaného) - Používá se pro tvarování provozu a zastírání velikosti\nOšetření chyb AEAD Kritické bezpečnostní požadavky:\nFáze navázání spojení (zprávy 1–3) Známá velikost zprávy: - Velikosti zpráv jsou předem stanovené nebo určené - Selhání autentizace AEAD je jednoznačné\nBobova reakce na selhání zprávy 1: 1. Nastavit náhodný timeout (rozsah závislý na implementaci, doporučeno 100-500ms) 2. Přečíst náhodný počet bajtů (rozsah závislý na implementaci, doporučeno 1KB-64KB) 3. Ukončit spojení pomocí TCP RST (bez odpovědi) 4. Dočasně zablokovat zdrojovou IP 5. Sledovat opakovaná selhání pro dlouhodobé blokace\nReakce Alice na selhání Message 2: 1. Okamžitě ukončit spojení pomocí TCP RST 2. Neodpovídat Bobovi\nBobova reakce na selhání zprávy 3: 1. Okamžitě ukončit spojení pomocí TCP RST 2. Neodpovídat Alici\nDatová fáze Zamaskovaná velikost zprávy: - Pole délky je zamaskované pomocí SipHash - Neplatná délka nebo selhání AEAD (autentizované šifrování s přidruženými daty) může naznačovat: - Sondování útočníkem - Poškození sítě - Desynchronizovaný SipHash IV (inicializační vektor) - Škodlivý uzel\nReakce na chybu AEAD nebo délky: 1. Nastavte náhodný časový limit (doporučeno 100-500ms) 2. Přečtěte náhodný počet bajtů (doporučeno 1KB-64KB) 3. Odešlete ukončovací blok s kódem důvodu 4 (selhání AEAD) nebo 9 (chyba rámce) 4. Ukončete spojení\nPrevence dešifrovacího orákula: - Nikdy neprozrazujte protistraně typ chyby před uplynutím náhodného časového limitu - Nikdy nevynechávejte ověření délky před kontrolou AEAD - S neplatnou délkou zacházejte stejně jako se selháním AEAD - Pro obě chyby používejte stejný postup obsluhy chyb\nÚvahy k implementaci: - Některé implementace mohou po chybách AEAD (autentizované šifrování s přidruženými daty) pokračovat v provozu, pokud se vyskytují jen zřídka - Ukončit po opakovaných chybách (doporučený práh: 3-5 chyb za hodinu) - Vyvážit obnovu po chybách a bezpečnost\nPublikované RouterInfo Formát adresy pro Router Podpora NTCP2 je oznamována prostřednictvím publikovaných záznamů RouterAddress (typ záznamu adresy routeru) se specifickými volbami.\nStyl přenosu: - \u0026quot;NTCP2\u0026quot; - NTCP2 pouze na tomto portu - \u0026quot;NTCP\u0026quot; - NTCP i NTCP2 na tomto portu (automatická detekce) - Poznámka: podpora NTCP (v1) byla odstraněna ve verzi 0.9.50 (květen 2021) - styl \u0026ldquo;NTCP\u0026rdquo; je nyní zastaralý; použijte \u0026ldquo;NTCP2\u0026rdquo;\nPovinné volby Všechny zveřejněné adresy NTCP2:\nhost - IP adresa (IPv4 nebo IPv6) nebo název hostitele\nFormát: Standardní IP zápis nebo doménové jméno Může být vynecháno u routerů pouze pro odchozí provoz nebo u skrytých routerů port - číslo TCP portu\nFormát: celé číslo, 1-65535 Může být vynechán u pouze odchozích nebo skrytých routerů s - Statický veřejný klíč (X25519)\nFormát: kódováno v Base64, 44 znaků Kódování: abeceda I2P Base64 Zdroj: veřejný klíč X25519 o délce 32 bajtů, little-endian i - Inicializační vektor pro AES\nFormát: zakódováno v Base64, 24 znaků Kódování: abeceda I2P Base64 Zdroj: IV o délce 16 bajtů, big-endian v - Verze protokolu\nFormát: celé číslo nebo čárkou oddělená celá čísla Aktuální: \u0026quot;2\u0026quot; Budoucí: \u0026quot;2,3\u0026quot; (musí být v číselném pořadí) Volitelné možnosti:\ncaps - Schopnosti (od 0.9.50)\nFormát: řetězec znaků schopností Hodnoty: \u0026quot;4\u0026quot; - schopnost odchozího IPv4 \u0026quot;6\u0026quot; - schopnost odchozího IPv6 \u0026quot;46\u0026quot; - obojí, IPv4 i IPv6 (doporučené pořadí) Není potřeba, pokud je host publikován Užitečné pro skryté/za firewallem routers cost - Priorita adresy\nFormát: celé číslo, 0-255 Nižší hodnoty = vyšší priorita Doporučeno: 5-10 pro běžné adresy Doporučeno: 14 pro nepublikované adresy Příklady záznamů RouterAddress Zveřejněná IPv4 adresa:\n\u0026lt;Address cost=\u0026#34;5\u0026#34;\u0026gt; \u0026lt;transport_style\u0026gt;NTCP2\u0026lt;/transport_style\u0026gt; \u0026lt;options\u0026gt; \u0026lt;host\u0026gt;192.0.2.1\u0026lt;/host\u0026gt; \u0026lt;port\u0026gt;8887\u0026lt;/port\u0026gt; \u0026lt;s\u0026gt;9EjeG7BZeznKbL9a2fXx8JBDPgLZbLmKbqY3QrNGJCo=\u0026lt;/s\u0026gt; \u0026lt;i\u0026gt;MDEyMzQ1Njc4OUFCQ0RFRg==\u0026lt;/i\u0026gt; \u0026lt;v\u0026gt;2\u0026lt;/v\u0026gt; \u0026lt;/options\u0026gt; \u0026lt;/Address\u0026gt; Skrytý Router (pouze odchozí):\n\u0026lt;Address cost=\u0026#34;14\u0026#34;\u0026gt; \u0026lt;transport_style\u0026gt;NTCP2\u0026lt;/transport_style\u0026gt; \u0026lt;options\u0026gt; \u0026lt;s\u0026gt;9EjeG7BZeznKbL9a2fXx8JBDPgLZbLmKbqY3QrNGJCo=\u0026lt;/s\u0026gt; \u0026lt;v\u0026gt;2\u0026lt;/v\u0026gt; \u0026lt;caps\u0026gt;4\u0026lt;/caps\u0026gt; \u0026lt;/options\u0026gt; \u0026lt;/Address\u0026gt; Router s duálním stackem:\n\u0026lt;!-- IPv4 Address --\u0026gt; \u0026lt;Address cost=\u0026#34;5\u0026#34;\u0026gt; \u0026lt;transport_style\u0026gt;NTCP2\u0026lt;/transport_style\u0026gt; \u0026lt;options\u0026gt; \u0026lt;host\u0026gt;192.0.2.1\u0026lt;/host\u0026gt; \u0026lt;port\u0026gt;8887\u0026lt;/port\u0026gt; \u0026lt;s\u0026gt;9EjeG7BZeznKbL9a2fXx8JBDPgLZbLmKbqY3QrNGJCo=\u0026lt;/s\u0026gt; \u0026lt;i\u0026gt;MDEyMzQ1Njc4OUFCQ0RFRg==\u0026lt;/i\u0026gt; \u0026lt;v\u0026gt;2\u0026lt;/v\u0026gt; \u0026lt;/options\u0026gt; \u0026lt;/Address\u0026gt; \u0026lt;!-- IPv6 Address (same keys, same port) --\u0026gt; \u0026lt;Address cost=\u0026#34;5\u0026#34;\u0026gt; \u0026lt;transport_style\u0026gt;NTCP2\u0026lt;/transport_style\u0026gt; \u0026lt;options\u0026gt; \u0026lt;host\u0026gt;2001:db8::1\u0026lt;/host\u0026gt; \u0026lt;port\u0026gt;8887\u0026lt;/port\u0026gt; \u0026lt;s\u0026gt;9EjeG7BZeznKbL9a2fXx8JBDPgLZbLmKbqY3QrNGJCo=\u0026lt;/s\u0026gt; \u0026lt;i\u0026gt;MDEyMzQ1Njc4OUFCQ0RFRg==\u0026lt;/i\u0026gt; \u0026lt;v\u0026gt;2\u0026lt;/v\u0026gt; \u0026lt;/options\u0026gt; \u0026lt;/Address\u0026gt; Důležitá pravidla: - Více adres NTCP2 se stejným portem MUSÍ používat shodné hodnoty s, i a v - Různé porty mohou používat různé klíče - Dual-stack (současná podpora IPv4 i IPv6) routers by měly zveřejňovat oddělené adresy IPv4 a IPv6\nNezveřejněná adresa NTCP2 Pro pouze odchozí Routers:\nPokud router nepřijímá příchozí spojení NTCP2, ale zahajuje odchozí spojení, MUSÍ i tak zveřejnit RouterAddress (záznam adresy routeru) s:\n\u0026lt;Address cost=\u0026#34;14\u0026#34;\u0026gt; \u0026lt;transport_style\u0026gt;NTCP2\u0026lt;/transport_style\u0026gt; \u0026lt;options\u0026gt; \u0026lt;s\u0026gt;9EjeG7BZeznKbL9a2fXx8JBDPgLZbLmKbqY3QrNGJCo=\u0026lt;/s\u0026gt; \u0026lt;v\u0026gt;2\u0026lt;/v\u0026gt; \u0026lt;/options\u0026gt; \u0026lt;/Address\u0026gt; Účel: - Umožňuje Bobovi ověřit Aličin statický klíč během handshake (navázání spojení) - Vyžadováno pro ověření RouterInfo ve 2. části zprávy 3 - Není potřeba i, host ani port (pouze odchozí)\nAlternativa: - Přidejte s a v k již zveřejněné adrese \u0026ldquo;NTCP\u0026rdquo; nebo SSU\nRotace veřejného klíče a IV (inicializačního vektoru) Kritická bezpečnostní politika:\nObecná pravidla: 1. Nikdy neprovádějte rotaci, když je router spuštěný 2. Trvale ukládejte klíč a IV i mezi restarty 3. Sledujte předchozí dobu výpadku pro určení, zda je rotace vhodná\nMinimální doba nedostupnosti před rotací:\nRouter Type Min Downtime Reason Published NTCP2 address1 monthMany routers cache RouterInfo Published SSU only (no NTCP2)1 dayModerate caching No published addresses (hidden)2 hoursMinimal impact **Další spouštěče:** - Změna lokální IP adresy: Může dojít k rotaci bez ohledu na výpadek - Router \"rekey\" (změna klíčů) (nový Router Hash): Vygeneruje nové klíče Odůvodnění: - Zabraňuje odhalení časů restartu prostřednictvím změn klíčů - Umožňuje, aby RouterInfos uložené v mezipaměti přirozeně vypršely - Udržuje stabilitu sítě - Snižuje počet neúspěšných pokusů o připojení\nImplementace: 1. Uložit klíč, IV a časové razítko posledního vypnutí trvale 2. Při startu vypočítat downtime = current_time - last_shutdown 3. Pokud downtime \u0026gt; minimum pro typ routeru, lze provést rotaci 4. Pokud se IP změnila nebo probíhá výměna klíče, lze provést rotaci 5. Jinak znovu použít předchozí klíč a IV\nRotace IV (inicializačního vektoru): - Řídí se totožnými pravidly jako rotace klíče - Vyskytuje se pouze u zveřejněných adres (nikoli u skrytých routerů) - Doporučuje se měnit IV vždy, když se změní klíč\nDetekce verze Kontext: Když je transportStyle=\u0026quot;NTCP\u0026quot; (zastaralé), Bob podporuje NTCP v1 i v2 na stejném portu a musí automaticky detekovat verzi protokolu.\nAlgoritmus detekce:\n1. Wait for at least 64 bytes (minimum NTCP2 message 1 size) 2. If received ≥ 288 bytes: → Connection is NTCP version 1 (NTCP1 message 1 is 288 bytes) 3. If received \u0026lt; 288 bytes: Option A (conservative, pre-NTCP2 majority): a. Wait additional short time (e.g., 100-500ms) b. If total received ≥ 288 bytes → NTCP1 c. Otherwise → Attempt NTCP2 decode Option B (aggressive, post-NTCP2 majority): a. Attempt NTCP2 decode immediately: - Decrypt first 32 bytes (X key) with AES-256-CBC - Verify valid X25519 point (X[31] \u0026amp; 0x80 == 0) - Verify AEAD frame b. If decode succeeds → NTCP2 c. If decode fails → Wait for more data or NTCP1 Rychlá kontrola nejvýznamnějšího bitu (MSB): - Před dešifrováním AES ověřte: encrypted_X[31] \u0026amp; 0x80 == 0 - Platné klíče X25519 mají nejvyšší bit vynulovaný - Selhání pravděpodobně naznačuje NTCP1 (nebo útok) - Při selhání implementujte odolnost proti sondování (náhodný časový limit + čtení)\nPožadavky na implementaci:\nOdpovědnost Alice:\nPři připojení k adrese \u0026ldquo;NTCP\u0026rdquo; omezte zprávu 1 na maximálně 287 bajtů Uložte do bufferu a vyprázdněte celou zprávu 1 najednou Zvyšuje pravděpodobnost doručení v jediném TCP paketu Bobova odpovědnost:\nPřed určením verze bufferovat přijatá data Implementovat správnou obsluhu časových limitů Použít TCP_NODELAY pro rychlou detekci verze Po detekci verze nabufferovat celou zprávu 2 a odeslat ji najednou Bezpečnostní aspekty: - Útoky segmentací: Bob by měl být odolný vůči segmentaci TCP - Sondovací útoky: Při selháních implementovat náhodná zpoždění a čtení bajtů - Prevence DoS: Omezit počet souběžně čekajících spojení - Časové limity pro čtení: Jak pro každé čtení, tak celkové (ochrana proti útoku \u0026ldquo;slowloris\u0026rdquo;)\nPokyny pro časovou odchylku Pole časových razítek: - Zpráva 1: tsA (časové razítko Alice) - Zpráva 2: tsB (časové razítko Boba) - Zpráva 3+: volitelné bloky DateTime (datum a čas)\nMaximální odchylka (D): - Typicky: ±60 sekund - Konfigurovatelné podle implementace - Odchylka \u0026gt; D je obecně fatální\nZpracování na straně Boba (Zpráva 1) 1. Receive tsA from Alice 2. skew = tsA - current_time 3. If |skew| \u0026gt; D: a. Still send message 2 (allows Alice to calculate skew) b. Include tsB in message 2 c. Do NOT initiate handshake completion d. Optionally: Temporary ban Alice\u0026#39;s IP e. After message 2 sent, close connection 4. If |skew| ≤ D: a. Continue handshake normally Odůvodnění: Odeslání zprávy 2 i při časové odchylce umožní Alici diagnostikovat problémy s časem.\nZpracování u Alice (Zpráva 2) 1. Receive tsB from Bob 2. RTT = (current_time_now - tsA_sent) 3. adjusted_skew = (tsB - current_time_now) - (RTT / 2) 4. If |adjusted_skew| \u0026gt; D: a. Close connection immediately b. If local clock suspect: Adjust clock or use external time source c. If Bob\u0026#39;s clock suspect: Temporary ban Bob d. Log for operator review 5. If |adjusted_skew| ≤ D: a. Continue handshake normally b. Optionally: Track skew for time synchronization Úprava RTT: - Odečtěte polovinu RTT od vypočtené odchylky - Zohledňuje zpoždění šíření v síti - Přesnější odhad odchylky\nBobovo zpracování (Zpráva 3) 1. If message 3 received (unlikely if skew exceeded in message 1) 2. Recalculate skew = tsA_received - current_time 3. If |adjusted_skew| \u0026gt; D: a. Send termination block (reason code 7: clock skew) b. Close connection c. Ban Alice for period (e.g., 1-24 hours) Synchronizace času Bloky DateTime (datová fáze): - Pravidelně odesílat blok DateTime (typ 0) - Příjemce jej může použít k seřízení hodin - Zaokrouhlit časové razítko na nejbližší sekundu (předejít zkreslení)\nExterní zdroje času: - NTP (síťový časový protokol) - Synchronizace systémových hodin - Konsenzuální čas sítě I2P\nStrategie úpravy hodin: - Pokud jsou místní hodiny nesprávné: Upravte systémový čas nebo použijte posun - Pokud jsou hodiny peerů trvale nesprávné: Označte problém u peera - Sledujte statistiky časové odchylky (skew) pro monitorování zdraví sítě\nBezpečnostní vlastnosti Dopředné utajení Dosaženo pomocí: - Efemérní výměna klíčů Diffie-Hellman (X25519) - Tři operace DH: es, ee, se (vzor Noise XK) - Efemérní klíče jsou po dokončení handshake (navázání spojení) zničeny\nProgrese důvěrnosti: - Zpráva 1: Úroveň 2 (dopředné utajení v případě kompromitace odesílatele) - Zpráva 2: Úroveň 1 (ephemeral recipient; dočasný příjemce) - Zpráva 3+: Úroveň 5 (silné dopředné utajení)\nPerfect Forward Secrecy (dopředné utajení): - Kompromitace dlouhodobých statických klíčů NEodhalí minulé klíče sezení - Každé sezení používá jedinečné efemérní klíče - Efemérní soukromé klíče se nikdy znovu nepoužijí - Vyčištění paměti po dohodě o klíči\nOmezení: - Zpráva 1 je zranitelná, pokud je kompromitován Bobův statický klíč (ale zachová se forward secrecy (dopředné utajení) i při kompromitaci Alice) - Opakované útoky (replay) jsou možné pro zprávu 1 (zmírněno pomocí časového razítka a replay cache (mezipaměť proti opakování))\nAutentizace Vzájemná autentizace: - Alice ověřena pomocí statického klíče ve zprávě 3 - Bob ověřen na základě vlastnictví statického soukromého klíče (implicitně z úspěšného navázání spojení)\nOdolnost vůči Key Compromise Impersonation (KCI; zneužití identity po kompromitaci klíče): - Úroveň autentizace 2 (odolné vůči KCI) - Útočník se nemůže vydávat za Alici ani se statickým soukromým klíčem Alice (bez efemérního klíče Alice) - Útočník se nemůže vydávat za Boba ani se statickým soukromým klíčem Boba (bez efemérního klíče Boba)\nOvěření statického klíče: - Alice zná Bobův statický klíč předem (z RouterInfo) - Bob ověří, že Aličin statický klíč odpovídá RouterInfo ve zprávě 3 - Zabraňuje útokům typu man-in-the-middle\nOdolnost vůči analýze provozu Opatření proti DPI: 1. Obfuskace AES: Dočasné klíče jsou šifrovány, jeví se náhodně 2. Obfuskace délky pomocí SipHash: Délky rámců nejsou v prostém textu 3. Náhodná výplň (padding): Proměnlivé velikosti zpráv, žádné pevné vzory 4. Šifrované rámce: Veškerá užitečná data jsou šifrována pomocí ChaCha20\nPrevence replay útoků (útoků přehráním): - Ověření časového razítka (±60 sekund) - Replay cache efemérních klíčů (životnost 2*D) - Inkrementace nonce (jednorázové hodnoty) brání přehrání paketů v rámci relace\nOdolnost proti sondování: - Náhodné vypršení časového limitu při selháních AEAD (ověřené šifrování s přidruženými daty) - Náhodné čtení bajtů před uzavřením spojení - Žádné odpovědi při selhání navázání spojení - Zařazení IP adres na černou listinu při opakovaných selháních\nPokyny pro padding (vycpávání): - Zprávy 1-2: nešifrovaný padding (ověřený) - Zpráva 3+: šifrovaný padding uvnitř rámců AEAD - Dohodnuté parametry paddingu (blok Options) - Rámce obsahující pouze padding jsou povoleny\nZmírnění útoků typu DoS Limity připojení: - Maximální počet aktivních spojení (v závislosti na implementaci) - Maximální počet čekajících handshaků (např. 100-1000) - Limity připojení na IP adresu (např. 3-10 současných)\nOchrana prostředků: - Operace DH s omezením rychlosti (výpočetně náročné) - Časové limity pro čtení pro každý socket i celkové - Ochrana proti \u0026ldquo;Slowloris\u0026rdquo; (celkové časové limity) - Zařazování IP adres na černou listinu při zneužívání\nRychlé odmítnutí: - Neshoda ID sítě → okamžité uzavření - Neplatný bod X25519 → rychlá kontrola nejvýznamnějšího bitu (MSB) před dešifrováním - Časové razítko mimo povolený rozsah → uzavření bez výpočtu - Selhání AEAD (autentizované šifrování s přidruženými daty) → bez odezvy, náhodné zpoždění\nOdolnost vůči sondování: - Náhodný časový limit: 100-500ms (závislé na implementaci) - Náhodné čtení: 1KB-64KB (závislé na implementaci) - Žádné informace o chybě pro útočníka - Ukončit pomocí TCP RST (bez FIN handshake)\nKryptografické zabezpečení Algoritmy: - X25519: 128bitová bezpečnost, Diffie–Hellman nad eliptickou křivkou (Curve25519) - ChaCha20: proudová šifra s 256bitovým klíčem - Poly1305: informačně-teoreticky bezpečný MAC - SHA-256: 128bitová odolnost proti kolizím, 256bitová odolnost vůči předobrazu - HMAC-SHA256: PRF (pseudonáhodná funkce) pro odvozování klíčů\nVelikosti klíčů: - Statické klíče: 32 bajtů (256 bitů) - Efemérní klíče: 32 bajtů (256 bitů) - Šifrovací klíče: 32 bajtů (256 bitů) - MAC: 16 bajtů (128 bitů)\nZnámé problémy: - Znovupoužití nonce (jednorázové číslo) u ChaCha20 je katastrofální (zabráněno inkrementací čítače) - X25519 má problémy s malými podgrupami (zmírněno ověřením bodu na křivce) - SHA-256 je teoreticky zranitelná vůči útoku rozšíření délky (v HMAC ji nelze zneužít)\nŽádné známé zranitelnosti (k říjnu 2025): - Noise Protocol Framework rozsáhle analyzován - ChaCha20-Poly1305 nasazen v TLS 1.3 - X25519 standard v moderních protokolech - Žádné praktické útoky na konstrukci\nReference Hlavní specifikace Specifikace NTCP2 - Oficiální specifikace I2P Návrh 111 - Původní návrhový dokument se zdůvodněním Rámec protokolu Noise - Revize 33 (2017-10-04) Kryptografické standardy RFC 7748 - Eliptické křivky pro bezpečnost (X25519) RFC 7539 - ChaCha20 a Poly1305 pro protokoly IETF RFC 8439 - ChaCha20-Poly1305 (nahrazuje RFC 7539) RFC 2104 - HMAC: klíčované hašování pro autentizaci zpráv SipHash - SipHash-2-4 pro použití jako hašovací funkce Související specifikace I2P Specifikace I2NP - formát zpráv I2NP Společné struktury - formáty RouterInfo a RouterAddress Transport SSU - transport přes UDP (původní, nyní SSU2) Návrh 147 - kontrola ID transportní sítě (0.9.42) Implementační odkazy I2P Java - Referenční implementace (Java) i2pd - Implementace v C++ Poznámky k vydání I2P - Historie verzí a aktualizace Historické souvislosti Station-To-Station Protocol (STS) - Inspirace pro Noise framework (kryptografický rámec Noise) obfs4 - Zásuvný transport (precedens zastírání délky pomocí SipHash) Pokyny k implementaci Povinné požadavky Pro dodržování předpisů:\nImplementujte kompletní handshake (navázání kryptografické relace):\nPodporujte všechny tři zprávy se správnými řetězci KDF (funkce odvození klíče) Ověřujte všechny AEAD tagy (ověřovací značky AEAD) Ověřte, že body X25519 (body eliptické křivky X25519) jsou platné Implementovat datovou fázi:\nObfuskace délky pomocí SipHash (v obou směrech) Všechny typy bloků: 0 (DateTime), 1 (Options), 2 (RouterInfo), 3 (I2NP), 4 (Termination), 254 (Padding) Správná správa nonce (jednorázová hodnota; oddělené čítače) Bezpečnostní funkce:\nPrevence replay útoků (ukládání efemérních klíčů do mezipaměti po dobu 2*D) Ověření časového razítka (výchozí ±60 sekund) Náhodná výplň ve zprávách 1-2 Zpracování chyb AEAD s náhodnými časovými limity Publikování RouterInfo:\nPublikovat statický klíč (\u0026ldquo;s\u0026rdquo;), IV (\u0026ldquo;i\u0026rdquo;) a verzi (\u0026ldquo;v\u0026rdquo;) Rotovat klíče podle zásad Podporovat pole schopností (\u0026ldquo;caps\u0026rdquo;) pro skryté routery Kompatibilita sítě:\nPodporovat pole ID sítě (aktuálně 2 pro hlavní síť) Interoperovat se stávajícími implementacemi v jazyce Java a i2pd Podporovat IPv4 i IPv6 Doporučené postupy Optimalizace výkonu:\nStrategie bufferování:\nOdeslat celé zprávy najednou (zprávy 1, 2, 3) Použít TCP_NODELAY pro zprávy během navázání spojení Slučovat více datových bloků do jednoho rámce Omezit velikost rámce na několik KB (minimalizovat latenci na straně příjemce) Správa připojení:\nOpakovaně používat připojení, pokud je to možné Implementovat sdružování připojení Sledovat stav připojení (DateTime blocks) Správa paměti:\nPo použití vynulujte citlivá data (efemérní klíče, výsledky DH) Omezte souběžně probíhající handshake (úvodní fáze navázání spojení; prevence DoS) Pro časté alokace používejte paměťové pooly Zpřísnění zabezpečení:\nOdolnost vůči sondování:\nNáhodné časové limity: 100-500ms Náhodné čtení bajtů: 1KB-64KB IP blacklisting (zařazení IP adres na černou listinu) při opakovaných selháních Žádné podrobnosti o chybách pro protějšky Limity prostředků:\nMaximální počet připojení na jednu IP adresu: 3-10 Maximální počet čekajících handshake (navázání spojení): 100-1000 Časové limity pro čtení: 30-60 sekund na operaci Celkový časový limit spojení: 5 minut pro handshake Správa klíčů:\nTrvalé uložení statického klíče a IV (inicializačního vektoru) Bezpečné generování náhodných hodnot (kryptografický generátor náhodných čísel, RNG) Striktně dodržujte zásady rotace klíčů Nikdy znovu nepoužívejte efemérní klíče Monitoring a diagnostika:\nMetriky:\nMíry úspěchu/selhání handshaku Míry chyb AEAD Distribuce časové odchylky (clock skew) Statistiky délky trvání spojení Logování:\nZaznamenávejte selhání handshake (úvodní navázání spojení) s kódy důvodů Zaznamenávejte události odchylky systémových hodin Zaznamenávejte zakázané IP adresy Nikdy nezaznamenávejte citlivý klíčový materiál Testování:\nJednotkové testy pro řetězce KDF Integrační testy s jinými implementacemi Fuzzing pro zpracování paketů Zátěžové testování odolnosti vůči DoS útokům Častá úskalí Kritické chyby, kterým je třeba se vyhnout:\nZnovupoužití nonce (jednorázové hodnoty):\nNikdy během relace neresetujte čítač nonce Používejte samostatné čítače pro každý směr Ukončete dříve, než dosáhnete 2^64 - 1 Rotace klíčů:\nNikdy nerotujte klíče, když je router spuštěn Nikdy znovu nepoužívejte efemérní klíče napříč relacemi Dodržujte pravidla pro minimální odstávku Zpracování časových razítek:\nNikdy nepřijímejte expirovaná časová razítka Vždy při výpočtu odchylky zohledněte RTT (doba obousměrné cesty) Zaokrouhlujte časová razítka DateTime na sekundy Chyby AEAD:\nNikdy neprozrazujte útočníkovi typ chyby Vždy použijte náhodný časový limit před uzavřením Zacházejte s neplatnou délkou stejně jako se selháním AEAD Výplň:\nNikdy neodesílejte výplň mimo dohodnuté meze Vždy umístěte blok výplně na konec Nikdy nepoužívejte více než jeden blok výplně v rámci jednoho rámce RouterInfo (záznam s informacemi o I2P router):\nVždy ověřujte, že se statický klíč shoduje s RouterInfo Nikdy nešiřte RouterInfos bez zveřejněných adres Vždy ověřujte podpisy Metodika testování Jednotkové testy:\nKryptografická primitiva:\nTestovací vektory pro X25519, ChaCha20, Poly1305, SHA-256 Testovací vektory pro HMAC-SHA256 Testovací vektory pro SipHash-2-4 Řetězce KDF:\nTesty s předem známým výsledkem pro všechny tři zprávy Ověřit propagaci řetězového klíče Otestovat generování IV pro SipHash Parsování zpráv:\nDekódování platných zpráv Odmítnutí neplatných zpráv Hraniční podmínky (prázdná zpráva, maximální velikost) Integrační testy:\nHandshake (navázání spojení):\nÚspěšná výměna tří zpráv Odmítnutí kvůli časové odchylce Detekce replay útoku Odmítnutí neplatného klíče Datová fáze:\npřenos zpráv I2NP výměna RouterInfo zpracování výplně ukončovací zprávy Interoperabilita:\nTestovat s Java I2P Testovat s i2pd Testovat IPv4 a IPv6 Testovat zveřejněné a skryté routers Bezpečnostní testy:\nNegativní testy:\nNeplatné značky AEAD Zopakované zprávy (replay) Útoky využívající odchylku systémových hodin Chybně formátované rámce Testy DoS:\nZaplavování spojení Útoky typu Slowloris Vyčerpání CPU (nadměrné DH) Vyčerpání paměti Fuzzing (testování náhodnými vstupy):\nNáhodné zprávy pro handshake Náhodné rámce datové fáze Náhodné typy a velikosti bloků Neplatné kryptografické hodnoty Přechod z NTCP Pro podporu zastaralého NTCP (nyní odstraněno):\nPodpora NTCP (verze 1) byla odstraněna v I2P 0.9.50 (květen 2021). Všechny současné implementace musí podporovat NTCP2. Historické poznámky:\nPřechodné období (2018-2021):\n0.9.36: NTCP2 zaveden (ve výchozím nastavení zakázán) 0.9.37: NTCP2 ve výchozím nastavení povolen 0.9.40: NTCP označen jako zastaralý 0.9.50: NTCP odstraněn Detekce verze:\n\u0026ldquo;NTCP\u0026rdquo; transportStyle (typ přenosu) znamenal, že jsou podporovány obě verze \u0026ldquo;NTCP2\u0026rdquo; transportStyle znamenal pouze NTCP2 Automatická detekce na základě velikosti zprávy (287 vs 288 bajtů) Aktuální stav:\nVšechny routers musí podporovat NTCP2 \u0026ldquo;NTCP\u0026rdquo; transportStyle (styl přenosu) je zastaralý Používejte výhradně transportStyle \u0026ldquo;NTCP2\u0026rdquo; Příloha A: Noise XK Pattern (vzor XK protokolu Noise) Standardní vzor Noise XK:\nXK(s, rs): \u0026lt;- s ... -\u0026gt; e, es \u0026lt;- e, ee -\u0026gt; s, se Interpretace:\n\u0026lt;- : Zpráva od odpovídající strany (Bob) k iniciátorovi (Alice) -\u0026gt; : Zpráva od iniciátora (Alice) k odpovídající straně (Bob) s : Statický klíč (dlouhodobý identitní klíč) rs : Vzdálený statický klíč (statický klíč protějšku, známý předem) e : Efemérní klíč (specifický pro relaci, generovaný podle potřeby) es : Efemérní-statický DH (Alice efemérní × Bob statický) ee : Efemérní-efemérní DH (Alice efemérní × Bob efemérní) se : Statický-efemérní DH (Alice statický × Bob efemérní) Postup dohodnutí klíče:\nPředběžná zpráva: Alice zná Bobův statický veřejný klíč (z RouterInfo) Zpráva 1: Alice posílá efemérní klíč, provede es DH Zpráva 2: Bob posílá efemérní klíč, provede ee DH Zpráva 3: Alice odhalí statický klíč, provede se DH Bezpečnostní vlastnosti:\nAlice ověřena: Ano (pomocí zprávy 3) Bob ověřen: Ano (držením statického soukromého klíče) Dopředné utajení: Ano (efemerní klíče zničeny) Odolnost vůči KCI (útoku s kompromitací klíče): Ano (úroveň ověření 2) Příloha B: Kódování Base64 Abeceda I2P Base64:\nABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-~ Rozdíly oproti standardnímu Base64: - Znaky 62–63: -~ místo +/ - Výplň: Stejná (=) nebo vynechána v závislosti na kontextu\nPoužití v NTCP2: - Statický klíč (\u0026ldquo;s\u0026rdquo;): 32 bajtů → 44 znaků (bez paddingu) - IV (inicializační vektor) (\u0026ldquo;i\u0026rdquo;): 16 bajtů → 24 znaků (bez paddingu)\nPříklad kódování:\n# 32-byte static key (hex): # f4489e1bb0597b39ca6cbf5ad9f5f1f09043e02d96cb9aa6a63742b3462429aa # I2P Base64 encoded: # 9EjeG7BZeznKbL9a2fXx8JBDPgLZbLmKbqY3QrNGJCo= Příloha C: Analýza zachycených paketů Identifikace provozu NTCP2:\nNavázání TCP spojení:\nStandardní TCP SYN, SYN-ACK, ACK Cílový port typicky 8887 nebo podobný Zpráva 1 (SessionRequest – žádost o relaci):\nPrvní aplikační data od Alice 80-65535 bajtů (obvykle několik stovek) Vypadá náhodně (dočasný klíč šifrovaný AES) 287 bajtů max, pokud se připojuje k adrese \u0026ldquo;NTCP\u0026rdquo; Zpráva 2 (SessionCreated – vytvoření relace):\nOdpověď od Boba 80-65535 bajtů (typicky několik stovek) Také působí náhodně Zpráva 3 (SessionConfirmed – potvrzení relace):\nOd Alice 48 bajtů + proměnná část (velikost RouterInfo + výplň) Obvykle 1-4 KB Datová fáze:\nRámce s proměnnou délkou Pole délky je zatemněné (vypadá náhodně) Šifrovaná užitečná data Výplň způsobuje, že velikost je nepředvídatelná Obcházení DPI: - Žádné hlavičky v prostém textu - Žádné pevné vzory - Pole délky jsou obfuskovaná - Náhodná výplň narušuje heuristiky založené na velikosti\nSrovnání s NTCP: - NTCP zpráva 1 má vždy 288 bajtů (identifikovatelná) - Zpráva 1 v NTCP2 má proměnlivou velikost (neidentifikovatelná) - NTCP měl rozpoznatelné vzorce - NTCP2 je navržen tak, aby odolal DPI (hluboké inspekci paketů)\nPříloha D: Historie verzí Hlavní milníky:\n0.9.36 (23. srpna 2018): NTCP2 zavedeno, ve výchozím nastavení zakázáno 0.9.37 (4. října 2018): NTCP2 ve výchozím nastavení povoleno 0.9.40 (20. května 2019): NTCP označen jako zastaralý 0.9.42 (27. srpna 2019): Přidáno pole Network ID (Návrh 147) 0.9.50 (17. května 2021): NTCP odstraněn, přidána podpora capabilities (schopností) 2.10.0 (9. září 2025): Nejnovější stabilní vydání Stabilita protokolu: - Žádné zpětně nekompatibilní změny od 0.9.50 - Průběžná vylepšení odolnosti vůči sondování - Důraz na výkon a spolehlivost - Postkvantová kryptografie ve vývoji (není ve výchozím nastavení povolena)\nAktuální stav transportních protokolů: - NTCP2: Povinný TCP transport - SSU2: Povinný UDP transport - NTCP (v1): Odstraněno - SSU (v1): Odstraněno\n","description":"TCP transport založený na Noise (kryptografickém protokolu Noise) pro spojení router-to-router","id":"4882afdd530d8c7e8da14bb97487aecc","section":"docs","title":"Transport NTCP2","url":"/cs/docs/specs/ntcp2/"},{"categories":null,"content":" 1. Přehled V I2P je transport metodou přímé, bod‑na‑bod komunikace mezi routery. Tyto mechanismy zajišťují důvěrnost a integritu a zároveň ověřují identitu routerů.\nKaždý transport pracuje jako spojovaný protokol s podporou autentizace, řízení toku, potvrzování a opakovaného přenosu.\n2. Aktuální transporty I2P v současnosti podporuje dva hlavní přenosové protokoly:\nTransport Protocol Description NTCP2 TCP Noise-based TCP transport with modern encryption (as of 0.9.36) SSU2 UDP Secure Semireliable UDP with modern encryption (as of 0.9.56) ### 2.1 Starší transportní protokoly (zastaralé) Transport Protocol Status NTCP TCP Replaced by NTCP2; removed in 0.9.62 SSU UDP Replaced by SSU2; removed in 0.9.62 --- 3. Transportní služby Transportní podsystém poskytuje následující služby:\n3.1 Doručování zpráv Spolehlivé doručování zpráv I2NP (transporty obsluhují výhradně I2NP komunikaci) Doručování ve správném pořadí NENÍ univerzálně zaručeno Řazení zpráv do front podle priority 3.2 Správa připojení Navazování a ukončování spojení Správa limitů spojení s vynucováním prahových hodnot Sledování stavu na úrovni jednotlivých peerů Automatické i manuální vynucování seznamu blokovaných peerů 3.3 Konfigurace sítě Více adres routeru pro každý transport (podpora IPv4 a IPv6 od verze v0.9.8) Otevírání portů firewallu přes UPnP Podpora průchodu přes NAT/firewall Detekce místní IP adresy více metodami 3.4 Zabezpečení Šifrování pro komunikaci bod–bod Ověření IP adresy podle místních pravidel Určování konsenzu času (záložní NTP) 3.5 Správa šířky pásma Limity příchozí a odchozí šířky pásma Optimální výběr transportního protokolu pro odchozí zprávy 4. Transportní adresy Subsystém udržuje seznam kontaktních bodů pro router:\nTransportní metoda (NTCP2, SSU2) IP adresa Číslo portu Volitelné parametry Pro každou přenosovou metodu může existovat více adres.\n4.1 Běžné konfigurace adres Configuration Description Hidden Routers with no published addresses Firewalled Routers publishing SSU2 addresses with \"introducer\" peer lists for NAT traversal Unrestricted Routers advertising both NTCP2 and SSU2 addresses on IPv4 and/or IPv6 --- 5. Výběr transportu Systém vybírá transportní protokoly pro I2NP messages nezávisle na protokolech vyšších vrstev. Výběr používá systém nabídek, v němž každý transportní protokol podává nabídku a vyhrává nejnižší nabídka.\n5.1 Faktory pro stanovení nabídky Nastavení preferencí transportu Stávající spojení s protějšky Aktuální vs. prahové počty spojení Historie nedávných pokusů o připojení Omezení velikosti zpráv Transportní schopnosti v RouterInfo protějšku Přímost spojení (přímé vs. závislé na introduceru (zprostředkovatel v SSU)) Protějškem inzerované preference transportu Obecně si dva routery udržují současně spojení s jedním transportem, ačkoli jsou možná i současná spojení s více transporty.\n6. NTCP2 NTCP2 (Nový transportní protokol 2) je moderní transport založený na TCP pro I2P, představený ve verzi 0.9.36.\n6.1 Klíčové vlastnosti Na základě Noise Protocol Framework (rámec pro návrh šifrovaných handshake) (Noise_XK pattern) Používá X25519 pro výměnu klíčů (elipticko-křivkový algoritmus) Používá ChaCha20/Poly1305 pro autentizované šifrování (AEAD – autentizované šifrování s přidruženými daty) Používá BLAKE2s pro hashování (moderní kryptografická hashovací funkce) Obfuskace protokolu pro odolnost vůči DPI (Deep Packet Inspection – hloubková inspekce paketů) Volitelné padding (výplň) pro odolnost vůči analýze provozu 6.2 Navázání spojení Požadavek na relaci (Alice → Bob): efemérní klíč X25519 + šifrovaná užitečná data Relace vytvořena (Bob → Alice): efemérní klíč + šifrované potvrzení Relace potvrzena (Alice → Bob): závěrečný handshake (navázání spojení) s RouterInfo Veškerá následná data jsou šifrována pomocí klíčů sezení odvozených z handshake (navázání spojení).\nPodrobné informace najdete v specifikaci NTCP2 .\n7. SSU2 SSU2 (Zabezpečený částečně spolehlivý UDP 2) je moderní transportní protokol založený na UDP pro I2P, představený ve verzi 0.9.56.\n7.1 Klíčové vlastnosti Založeno na Noise Protocol Framework (rámec protokolu Noise) (Noise_XK pattern) Používá X25519 pro výměnu klíčů Používá ChaCha20/Poly1305 pro autentizované šifrování Částečně spolehlivé doručování se selektivními potvrzeními Průchod NATem pomocí hole punchingu (technika navazování přímého spojení přes NAT) a relay/introduction Podpora migrace spojení Zjišťování MTU na trase 7.2 Výhody oproti SSU (starší) Feature SSU (Legacy) SSU2 Encryption ElGamal + AES X25519 + ChaCha20/Poly1305 Header encryption Partial Full (ChaCha20) Connection ID Fixed Encrypted, rotatable NAT traversal Basic introduction Enhanced hole punching + relay Obfuscation Minimal Improved (variable padding) Pro úplné podrobnosti viz [Specifikace SSU2](/docs/specs/ssu2/). 8. Průchod NAT Oba transportní protokoly podporují průchod přes NAT, aby se routers za firewallem mohly zapojit do sítě.\n8.1 Úvod do SSU2 Pokud router nemůže přímo přijímat příchozí spojení:\nRouter zveřejňuje adresy introducer (zprostředkovatel spojení) ve svém RouterInfo (informace o routeru) Připojující se uzel odešle požadavek na zprostředkování introduceru Introducer předá routeru za firewallem informace o připojení Router za firewallem iniciuje odchozí spojení (hole punch, prorážení NATu) Je navázána přímá komunikace 8.2 NTCP2 a firewally NTCP2 vyžaduje příchozí TCP konektivitu. Routers za NATem mohou:\nPoužít UPnP k automatickému otevření portů Ručně nakonfigurovat přesměrování portů Spoléhat se na SSU2 pro příchozí připojení, zatímco pro odchozí používat NTCP2 9. Obfuskace protokolu Oba moderní přenosové protokoly obsahují prvky pro zastírání:\nNáhodná výplň ve zprávách handshake (navazovací procedury) Šifrované hlavičky, které neprozrazují signatury protokolu Zprávy proměnlivé délky, aby odolaly analýze provozu Žádné pevné vzorce při navazování spojení Poznámka: Obfuskace na transportní vrstvě doplňuje, ale nenahrazuje anonymitu poskytovanou tunnel architekturou I2P.\n10. Budoucí vývoj Plánovaný výzkum a vylepšení zahrnují:\nZásuvné transporty – zásuvné moduly pro zastírání kompatibilní s Tor Transport založený na QUIC – zkoumání přínosů protokolu QUIC Optimalizace limitů připojení – výzkum optimálních limitů připojení k peerům Vylepšené strategie paddingu – zlepšená odolnost vůči analýze provozu 11. Odkazy Specifikace NTCP2 – Transport přes TCP založený na Noise (kryptografický rámec) Specifikace SSU2 – Bezpečné částečně spolehlivé UDP 2 Specifikace I2NP – Zprávy síťového protokolu I2P Společné struktury – RouterInfo a struktury adres Historická diskuse o NTCP – Historie vývoje staršího transportu Dokumentace ke staršímu SSU – Původní specifikace SSU (zastaralá) ","description":"Porozumění transportní vrstvě I2P - metody komunikace point-to-point mezi routers včetně NTCP2 a SSU2","id":"5fbac972dc212081634c49c5e6ac0004","section":"docs","title":"Transportní vrstva","url":"/cs/docs/overview/transport/"},{"categories":null,"content":"Přehled Tato specifikace popisuje protokol pro UDP oznamování BitTorrentu v I2P. Celkovou specifikaci BitTorrentu v I2P najdete v dokumentaci k BitTorrentu přes I2P . Pro pozadí a další informace o vývoji této specifikace viz Návrh 160 .\nTento protokol byl formálně schválen 24. června 2025 a implementován v I2P verzi 2.10.0 (API 0.9.67), vydané 8. září 2025. Podpora UDP trackeru je v síti I2P aktuálně v provozu s několika produkčními trackery a plnou podporou klienta i2psnark.\nNávrh Tato specifikace používá repliable datagram2, repliable datagram3 a surové datagramy, jak jsou definovány v I2P Datagram Specification . Datagram2 a Datagram3 jsou variantami repliable datagrams (datagramů s možností odpovědi), definované v Proposal 163 . Datagram2 přidává odolnost vůči replay útokům a podporu offline podpisů. Datagram3 je menší než starý formát datagramu, ale bez autentizace.\nBEP 15 Pro informaci je tok zpráv definovaný v BEP 15 následující:\nClient Tracker Connect Req. -------------\u0026gt; \u0026lt;-------------- Connect Resp. Announce Req. -------------\u0026gt; \u0026lt;-------------- Announce Resp. Announce Req. -------------\u0026gt; \u0026lt;-------------- Announce Resp. Fáze připojení je nutná k zabránění podvržení IP adresy. Tracker vrátí identifikátor spojení, který klient používá v následujících announces (oznámeních). Tento identifikátor spojení ve výchozím nastavení vyprší za jednu minutu u klienta a za dvě minuty u trackeru.\nI2P používá stejný tok zpráv jako BEP 15, pro usnadnění integrace do stávajících kódových základen klientů podporujících UDP, kvůli efektivitě a také z bezpečnostních důvodů rozebraných níže:\nClient Tracker Connect Req. -------------\u0026gt; (Repliable Datagram2) \u0026lt;-------------- Connect Resp. (Raw) Announce Req. -------------\u0026gt; (Repliable Datagram3) \u0026lt;-------------- Announce Resp. (Raw) Announce Req. -------------\u0026gt; (Repliable Datagram3) \u0026lt;-------------- Announce Resp. (Raw) ... To potenciálně poskytuje výraznou úsporu šířky pásma oproti oznámením přes streaming (TCP). Zatímco Datagram2 má zhruba stejnou velikost jako streaming SYN, odpověď raw (surová) je mnohem menší než streaming SYN ACK. Následné požadavky používají Datagram3 a následné odpovědi jsou raw.\nPožadavky announce jsou typu Datagram3, takže tracker (sledovací server) nemusí udržovat velkou mapovací tabulku, která by přiřazovala ID připojení k cíli announce nebo k hashi. Místo toho může tracker kryptograficky generovat ID připojení z hashe odesílatele, aktuálního časového razítka (na základě určitého intervalu) a tajné hodnoty. Když je přijat požadavek announce, tracker ověří ID připojení a poté použije hash odesílatele z Datagram3 jako cíl odeslání.\nDoba trvání spojení BEP 15 specifikuje, že identifikátor spojení vyprší za jednu minutu u klienta a za dvě minuty u trackeru. Není konfigurovatelný. To omezuje potenciální přínosy z hlediska efektivity, ledaže by klienti dávkovali announces (požadavky na tracker) tak, aby je všechny odeslali v rámci jednominutového okna. i2psnark v současnosti announces nedávkuje; rozprostírá je v čase, aby se předešlo špičkám provozu. Uvádí se, že pokročilí uživatelé provozují naráz tisíce torrentů a poslat tolik announces během jedné minuty není realistické.\nZde navrhujeme rozšířit connect response (odpověď na požadavek connect) o volitelné pole s dobou trvání spojení. Výchozí hodnota, pokud není uvedeno, je jedna minuta. V opačném případě klient použije zadanou dobu trvání v sekundách a tracker bude udržovat ID spojení ještě o jednu minutu déle.\nKompatibilita s BEP 15 Tento návrh zachovává kompatibilitu s BEP 15 v co největší možné míře, aby se omezily změny nutné v existujících klientech a trackerech.\nJedinou povinnou změnou je formát informací o peerech v announce response (odpovědi announce). Přidání pole lifetime v connect response (odpovědi connect) není povinné, ale je důrazně doporučeno kvůli efektivitě, jak je vysvětleno výše.\nAnalýza zabezpečení Důležitým cílem oznamovacího protokolu UDP je zabránit podvržení adresy. Klient musí skutečně existovat a zahrnout skutečný leaseSet. Musí mít příchozí tunnels, aby mohl přijmout Connect Response. Tyto tunnels mohou být zero-hop (bez prostředníků) a sestavené okamžitě, ale to by odhalilo tvůrce. Tento protokol tohoto cíle dosahuje.\nProblémy Tento protokol nepodporuje blinded destinations (oslepené destinace v I2P), ale může být rozšířen tak, aby je podporoval. Viz níže.\nSpecifikace Protokoly a porty Datagram s možností odpovědi Datagram2 používá protokol I2CP 19; datagram s možností odpovědi Datagram3 používá protokol I2CP 20; surové datagramy používají protokol I2CP 18. Požadavky mohou být Datagram2 nebo Datagram3. Odpovědi jsou vždy surové. Starší formát datagramu s možností odpovědi (\u0026ldquo;Datagram1\u0026rdquo;) používající protokol I2CP 17 se NESMÍ používat pro požadavky ani odpovědi; pokud jsou přijaty na portech pro požadavky/odpovědi, musí být zahazovány. Všimněte si, že Datagram1 (protokol I2CP 17) se stále používá pro protokol DHT (distribuovaná hashovací tabulka).\nPožadavky používají I2CP „to port“ z oznamovací URL; viz níže. „From port“ u požadavku volí klient, ale měl by být nenulový a odlišný od portů používaných DHT, aby bylo možné odpovědi snadno klasifikovat. Trackery by měly odmítat požadavky přijaté na nesprávném portu.\nOdpovědi používají I2CP \u0026ldquo;to port\u0026rdquo; z požadavku. \u0026ldquo;From port\u0026rdquo; v odpovědi je \u0026ldquo;to port\u0026rdquo; z požadavku.\nOznamovací URL Formát announce URL (oznamovací URL) není specifikován v BEP 15 , ale stejně jako na clearnet (veřejný internet), mají UDP announce URL tvar \u0026ldquo;udp://host:port/path\u0026rdquo;. Cesta se ignoruje a může být prázdná, ale na clearnet je obvykle \u0026ldquo;/announce\u0026rdquo;. Část :port by měla být vždy přítomna; pokud je však část \u0026ldquo;:port\u0026rdquo; vynechána, použijte výchozí port I2CP 6969, jelikož to je běžný port na clearnet. Mohou být také připojeny parametry CGI \u0026amp;a=b\u0026amp;c=d; ty lze zpracovat a předat v požadavku announce, viz BEP 41 . Pokud nejsou žádné parametry ani cesta, koncové / může být také vynecháno, jak je naznačeno v BEP 41 .\nFormáty datagramů Všechny hodnoty jsou odesílány v síťovém pořadí bajtů (big endian). Neočekávejte, že pakety budou mít přesně určitou velikost. Budoucí rozšíření mohou velikost paketů zvětšit.\nŽádost o připojení Od klienta k trackeru. 16 bajtů. Musí jít o Datagram2 (druh datagramu v I2P) umožňující odpověď. Stejné jako v BEP 15 . Žádné změny.\nOffset Size Name Value 0 64-bit integer protocol_id 0x41727101980 // magic constant 8 32-bit integer action 0 // connect 12 32-bit integer transaction_id Odpověď na připojení Od trackeru ke klientovi. 16 nebo 18 bajtů. Musí být v surové podobě. Stejné jako v BEP 15 , s výjimkou toho, co je uvedeno níže.\nOffset Size Name Value 0 32-bit integer action 0 // connect 4 32-bit integer transaction_id 8 64-bit integer connection_id 16 16-bit integer lifetime optional // Change from BEP 15 Odpověď MUSÍ být odeslána na I2CP \u0026ldquo;to port\u0026rdquo;, který byl v požadavku přijat jako \u0026ldquo;from port\u0026rdquo;.\nPole lifetime je nepovinné a udává dobu životnosti connection_id klienta v sekundách. Výchozí hodnota je 60 a minimální hodnota, pokud je zadána, je 60. Maximální hodnota je 65535, tedy přibližně 18 hodin. Tracker by měl udržovat connection_id o 60 sekund déle, než je doba životnosti klienta.\nPožadavek na oznámení Od klienta k trackeru. Minimálně 98 bajtů. Musí být datagram Datagram3 s možností odpovědi. Stejné jako v BEP 15 , pokud není uvedeno jinak níže.\nconnection_id je stejné, jako bylo přijato v odpovědi na připojení.\nOffset Size Name Value 0 64-bit integer connection_id 8 32-bit integer action 1 // announce 12 32-bit integer transaction_id 16 20-byte string info_hash 36 20-byte string peer_id 56 64-bit integer downloaded 64 64-bit integer left 72 64-bit integer uploaded 80 32-bit integer event 0 // 0: none; 1: completed; 2: started; 3: stopped 84 32-bit integer IP address 0 // default, unused in I2P 88 32-bit integer key 92 32-bit integer num_want -1 // default 96 16-bit integer port // must be same as I2CP from port 98 varies options optional // As specified in BEP 41 Změny oproti BEP 15 :\nklíč je ignorován IP adresa se nepoužívá port se pravděpodobně ignoruje, ale musí být stejný jako I2CP from port sekce options, pokud je přítomna, je definována v BEP 41 Odpověď MUSÍ být odeslána na I2CP \u0026ldquo;to port\u0026rdquo;, který byl přijat jako \u0026ldquo;from port\u0026rdquo; v požadavku. Nepoužívejte port z announce request (oznamovacího požadavku).\nOdpověď na oznámení Z trackeru ke klientovi. Minimálně 20 bajtů. Musí být raw (surová binární data). Stejné jako v BEP 15 s výjimkami uvedenými níže.\nOffset Size Name Value 0 32-bit integer action 1 // announce 4 32-bit integer transaction_id 8 32-bit integer interval 12 32-bit integer leechers 16 32-bit integer seeders 20 32 * n 32-byte hash binary hashes // Change from BEP 15 ... // Change from BEP 15 Změny oproti BEP 15 :\nNamísto 6bajtového IPv4+portu nebo 18bajtového IPv6+portu vracíme data v podobě násobku 32bajtových \u0026ldquo;compact responses\u0026rdquo; obsahujících binární hashe peerů (SHA-256). Stejně jako u TCP compact responses port neuvádíme. Odpověď MUSÍ být odeslána na I2CP „to port“, který byl v požadavku přijat jako „from port“. Nepoužívejte port z oznamovacího požadavku.\nI2P datagramy mají velmi velkou maximální velikost kolem 64 KB; pro spolehlivé doručení by se však mělo vyhnout datagramům větším než 4 KB. Pro efektivní využití šířky pásma by trackery měly pravděpodobně omezit maximální počet peerů na asi 50, což odpovídá přibližně paketu o velikosti 1600 bajtů před režií na různých vrstvách, a po fragmentaci by se měl vejít do limitu užitečných dat dvou zpráv přenášených přes tunnel.\nStejně jako v BEP 15 zde není zahrnut počet následujících adres peerů (u BEP 15 IP/port, zde hashe). Ačkoli s tím BEP 15 nepočítá, bylo by možné definovat značku konce seznamu peerů složenou ze samých nul, která by signalizovala, že informace o peerech jsou úplné a že dále následují nějaká data rozšíření.\nAby bylo možné případné rozšíření v budoucnu, klienti by měli ignorovat 32bajtový hash složený samými nulami a veškerá následující data. Trackery by měly odmítat ohlášení pocházející z hashe složeného samými nulami, ačkoli tento hash už Java routers zakazují.\nSběr dat Požadavek a odpověď scrape (operace trackeru pro získání souhrnných statistik o torrentu) podle BEP 15 nejsou v této specifikaci povinné, ale lze je případně implementovat bez jakýchkoli změn. Klient musí nejprve získat ID připojení. Požadavek scrape je vždy repliable (na který lze odpovědět) Datagram3. Odpověď scrape je vždy raw (bez návratové adresy).\nChybová odpověď Z trackeru ke klientovi. Minimálně 8 bajtů (pokud je zpráva prázdná). Musí být v surové podobě. Stejné jako v BEP 15 . Žádné změny.\nOffset Size Name Value 0 32-bit integer action 3 // error 4 32-bit integer transaction_id 8 string message Rozšíření Rozšiřující bity ani pole verze nejsou zahrnuty. Klienti a trackery by neměli předpokládat, že pakety mají určitou velikost. Tímto způsobem lze přidávat další pole, aniž by došlo k narušení kompatibility. V případě potřeby se doporučuje formát rozšíření definovaný v BEP 41 .\nOdpověď na connect je upravena tak, aby obsahovala volitelnou dobu platnosti Connection ID (identifikátoru spojení).\nPokud je vyžadována podpora blinded destination (kryptograficky „zaslepeného“ cíle), můžeme buď přidat zaslepenou 35bajtovou adresu na konec požadavku announce, nebo v odpovědích požadovat zaslepené hashe, a to ve formátu BEP 41 (parametry budou upřesněny). Množinu zaslepených 35bajtových adres peerů lze přidat na konec odpovědi announce, za 32bajtovým hashem samých nul.\nPokyny k implementaci Viz výše uvedenou sekci Design pro diskusi o výzvách pro neintegrované, ne-I2CP klienty a trackery.\nKlienti Pro daný název hostitele trackeru by měl klient upřednostnit UDP před HTTP URL a neměl by se ohlašovat oběma současně.\nKlienti se stávající podporou BEP 15 by měli vyžadovat jen drobné úpravy.\nPokud klient podporuje DHT (distribuovaná hašovací tabulka) nebo jiné datagramové protokoly, měl by pravděpodobně zvolit jiný port jako „from port“ v požadavku, aby se odpovědi vracely na tento port a nemísily se se zprávami DHT. Klient jako odpovědi přijímá pouze surové datagramy. Trackery nikdy nepošlou klientovi repliable datagram2 (datagram verze 2, na který lze přímo odpovědět).\nKlienti s výchozím seznamem opentrackers (veřejné trackery) by měli aktualizovat seznam a přidat UDP URL, jakmile je u známých opentrackers potvrzena podpora UDP.\nKlienti mohou, ale nemusí implementovat retransmisi požadavků. Retransmise, jsou-li implementovány, by měly používat počáteční časový limit alespoň 15 sekund a pro každou retransmisi časový limit zdvojnásobit (exponenciální backoff).\nKlienti musí po obdržení chybové odpovědi provést backoff (tj. dočasně vyčkat a snížit frekvenci opakování požadavků).\nTrackery Trackery se stávající podporou BEP 15 by měly vyžadovat pouze drobné úpravy. Tato specifikace se liší od návrhu z roku 2014 tím, že tracker musí podporovat příjem repliable (s možností přímé odpovědi) datagram2 a datagram3 na stejném portu.\nAby se minimalizovaly nároky trackeru (sledovací server) na prostředky, je tento protokol navržen tak, aby odstranil jakoukoli potřebu, aby tracker ukládal mapování hashů klientů na ID připojení pro pozdější ověření. To je možné, protože paket požadavku announce je paket Datagram3 s možností odpovědi, takže obsahuje hash odesílatele.\nDoporučená implementace je:\nDefinujte aktuální epochu jako aktuální čas s rozlišením daným životností připojení, epoch = now / lifetime. Definujte kryptografickou hashovací funkci H(secret, clienthash, epoch), která generuje 8bajtový výstup. Vygenerujte náhodnou konstantní tajnou hodnotu používanou pro všechna připojení. Pro odpovědi na připojení vygenerujte connection_id = H(secret, clienthash, epoch) Pro požadavky announce validujte obdržené ID připojení v aktuální epoše tak, že ověříte, zda connection_id == H(secret, clienthash, epoch) || connection_id == H(secret, clienthash, epoch - 1) Stav nasazení Tento protokol byl schválen 24. června 2025 a od září 2025 je v síti I2P plně provozuschopný.\nAktuální implementace i2psnark: Plná podpora pro UDP tracker (server pro sledování peerů přes UDP) je zahrnuta ve verzi I2P 2.10.0 (API 0.9.67), vydané 8. září 2025. Všechny instalace I2P počínaje touto verzí zahrnují podporu UDP trackeru ve výchozím nastavení.\nzzzot tracker: Verze 0.20.0-beta2 a novější podporují oznamování přes UDP. K říjnu 2025 jsou v provozu následující produkční trackery: - opentracker.dg2.i2p - opentracker.simp.i2p - opentracker.skank.i2p\nPoznámky ke kompatibilitě klientů Omezení SAM v3.3: Externí klienti BitTorrentu používající SAM (Simple Anonymous Messaging) vyžadují podporu SAM v3.3 pro Datagram2/3. Tato podpora je k dispozici v Java I2P, ale aktuálně není podporována v i2pd (implementace I2P v C++), což může omezit přijetí u klientů založených na libtorrentu, jako je qBittorrent.\nKlienti I2CP: Klienti používající přímo I2CP (např. BiglyBT) mohou implementovat podporu UDP trackeru bez omezení SAM.\nReference [BEP15]: Protokol UDP trackeru BitTorrentu [BEP41]: Rozšíření protokolu UDP trackeru [DATAGRAMS]: Specifikace datagramů I2P [Prop160]: Návrh UDP trackerů [Prop163]: Návrh Datagram2 [SPEC]: BitTorrent přes I2P ","description":"Specifikace protokolu pro oznámení trackeru BitTorrentu na bázi UDP v I2P","id":"2413d642663e185a8a31352c9a9e8f28","section":"docs","title":"UDP oznámení BitTorrentu","url":"/cs/docs/specs/udp-bittorrent-announces/"},{"categories":null,"content":"Co je I2P? Invisible Internet Project (I2P) je anonymní síťová vrstva, která umožňuje komunikaci peer-to-peer odolnou vůči cenzuře. Anonymní spojení je dosaženo šifrováním provozu uživatele a jeho odesíláním prostřednictvím distribuované sítě provozované dobrovolníky po celém světě.\nKlíčové vlastnosti Anonymity I2P skrývá jak odesílatele, tak příjemce zpráv. Na rozdíl od tradičních internetových připojení, kde je vaše IP adresa viditelná pro webové stránky a služby, I2P používá několik vrstev šifrování a směrování k ochraně vašeho soukromí.\nDecentralization V I2P neexistuje žádná centrální autorita. Síť je udržována dobrovolníky, kteří darují šířku pásma a výpočetní zdroje. Díky tomu je odolná vůči cenzuře a jednotlivým bodům selhání.\nAnonymita Veškerý provoz v rámci I2P je šifrován end-to-end. Zprávy jsou šifrovány vícekrát při průchodu sítí, podobně jako funguje Tor, ale s důležitými rozdíly v implementaci.\nHow It Works Decentralizace I2P používá „tunnely\u0026quot; k směrování provozu. Když odesíláte nebo přijímáte data:\nVáš router vytvoří odchozí tunnel (pro odesílání) Váš router vytvoří příchozí tunnel (pro příjem) Zprávy jsou šifrovány a odesílány přes více routerů Každý router zná pouze předchozí a následující hop, ne celou cestu Šifrování typu End-to-End I2P vylepšuje tradiční onion routing pomocí „garlic routing\u0026quot;:\nVíce zpráv může být sdruženo dohromady (jako stroužky v hlavičce česneku) To poskytuje lepší výkon a dodatečnou anonymitu Ztěžuje analýzu síťového provozu Network Database I2P udržuje distribuovanou síťovou databázi obsahující:\nInformace o routeru Cílové adresy (podobné webovým stránkám .i2p) Šifrovaná směrovací data Common Use Cases Tunnely Hostujte nebo navštivte webové stránky s koncovkou .i2p - ty jsou dostupné pouze v rámci sítě I2P a poskytují silné záruky anonymity jak pro hostitele, tak pro návštěvníky.\nGarlic Routing Sdílejte soubory anonymně pomocí BitTorrentu přes I2P. Mnoho torrentových aplikací má vestavěnou podporu I2P.\nSíťová databáze Posílejte a přijímejte anonymní e-maily pomocí I2P-Bote nebo jiných e-mailových aplikací navržených pro I2P.\nMessaging Používejte IRC, instant messaging nebo další komunikační nástroje soukromě přes síť I2P.\nGetting Started Jste připraveni vyzkoušet I2P? Podívejte se na naši stránku se soubory ke stažení a nainstalujte si I2P do svého systému.\nPro více technických podrobností se podívejte na Technický úvod nebo prozkoumejte kompletní dokumentaci .\nJak to funguje Technický úvod - Hlubší technické koncepty Model hrozeb - Pochopení bezpečnostního modelu I2P Srovnání s Tor - Jak se I2P liší od Tor Kryptografie - Podrobnosti o kryptografických algoritmech I2P ","description":"Méně technický úvod do anonymní sítě I2P","id":"b4dafae75d4a04b2eac73ebf531f1d1b","section":"docs","title":"Úvod do I2P","url":"/cs/docs/overview/intro/"},{"categories":null,"content":" Stav: Toto je stručná reference pro nástroj v3dgsend. Doplňuje dokumentaci k Datagram API a SAM v3 .\nPřehled v3dgsend je nástroj příkazového řádku pro odesílání I2P datagramů pomocí rozhraní SAMv3. Je užitečný pro testování doručování datagramů, prototypování služeb a ověřování chování mezi koncovými body bez nutnosti psát plnohodnotného klienta.\nTypická použití zahrnují:\nKouřový test dostupnosti datagramu k Destinaci Ověření konfigurace firewallu a adresáře Experimentování se surovými vs. podepsanými (odpověditelnými) datagramy Použití Základní spuštění se liší podle platformy a balíčku. Mezi běžné možnosti patří:\nDestination: base64 Destination nebo .i2p název Protocol: raw (PROTOCOL 18) nebo signed (PROTOCOL 17) Payload: inline řetězec nebo vstup ze souboru Přesné příznaky naleznete v dokumentaci vaší distribuce nebo ve výstupu --help.\nViz také Datagram API SAM v3 Streaming Library (alternativa k datagramům) ","description":"CLI nástroj pro odesílání I2P datagramů přes SAM v3","id":"3fe6f64806c4c692f530bf7fa6eb9c45","section":"docs","title":"v3dgsend","url":"/cs/docs/api/v3dgsend/"},{"categories":null,"content":"Začlenění I2P do vaší aplikace je účinný způsob, jak přilákat uživatele—ale pouze pokud je router nakonfigurován odpovědně.\n1. Koordinace s týmy routerů Kontaktujte správce Java I2P a i2pd před začleněním do balíčku. Mohou zkontrolovat vaše výchozí nastavení a upozornit na problémy s kompatibilitou. Vyberte implementaci routeru, která odpovídá vašemu zásobníku: Java/Scala → Java I2P C/C++ → i2pd Ostatní jazyky → začleňte router do balíčku a integrujte pomocí SAM v3 nebo I2CP Ověřte podmínky redistribuce pro binární soubory routeru a závislosti (Java runtime, ICU, atd.). 2. Doporučená výchozí konfigurace Snažte se „přispívat více, než spotřebováváte.\u0026quot; Moderní výchozí nastavení upřednostňuje zdraví a stabilitu sítě.\nSetting Recommended Default (2025) Bandwidth share 80% for participating tunnels Tunnel quantities i2pd: 3 inbound / 3 outbound; Java I2P: 2 inbound / 2 outbound. Signature \u0026amp; encryption Use Ed25519 (SIGNATURE_TYPE=7) and advertise ECIES-X25519 + ElGamal (i2cp.leaseSetEncType=4,0). Client protocols Use SAM v3 or I2CP. API listeners Bind SAM/I2CP to 127.0.0.1 only. Disable if not needed. UI toggles Expose bandwidth controls, logs, and an opt-in checkbox for participating tunnels. ### Zúčastněné tunely zůstávají nezbytné Nedeaktivujte tunely pro účast.\nRoutery, které nepřenášejí provoz, fungují sami hůře. Síť závisí na dobrovolném sdílení kapacity. Krycí provoz (přenášený provoz) zlepšuje anonymitu. Oficiální minima: - Sdílená šířka pásma: ≥ 12 KB/s - Automatické zapojení jako floodfill: ≥ 128 KB/s - Doporučeno: 2 příchozí / 2 odchozí tunnely (výchozí nastavení Java I2P)\n3. Perzistence a Reseeding Adresáře s trvalým stavem (netDb/, profily, certifikáty) musí být zachovány mezi spuštěními.\nBez perzistence budou vaši uživatelé spouštět reseedy při každém startu—což zhoršuje výkon a zvyšuje zátěž na reseed servery.\nPokud není perzistence možná (např. kontejnery nebo dočasné instalace):\nZahrňte 1 000–2 000 router infos do instalátoru. Provozujte jeden nebo více vlastních reseed serverů pro odlehčení veřejným serverům. Konfigurační proměnné: - Základní adresář: i2p.dir.base - Konfigurační adresář: i2p.dir.config - Zahrnuje certificates/ pro reseed (obnovení dat sítě).\n4. Bezpečnost a odhalení Ponechte konzoli routeru (127.0.0.1:7657) pouze pro lokální přístup. Pokud zpřístupňujete UI externě, použijte HTTPS. Zakažte externí SAM/I2CP, pokud není vyžadováno. Zkontrolujte zahrnuté pluginy—dodávejte pouze ty, které vaše aplikace podporuje. Vždy zahrňte autentizaci pro vzdálený přístup ke konzoli. Bezpečnostní funkce zavedené od verze 2.5.0: - Izolace NetDB mezi aplikacemi (2.4.0+) - Zmírnění DoS a Tor bloklisty (2.5.1) - Odolnost NTCP2 proti skenování (2.9.0) - Vylepšení výběru floodfill routerů (2.6.0+)\n5. Podporovaná API (2025) API Status Notes SAM v3 (3.3) ✅ Active Recommended bridge for non-Java apps. I2CP ✅ Active Stable protocol core, used internally by Java I2P. I2PControl ✅ Active JSON-RPC API; plugin maintained. BOB ⚠️ Deprecated Removed from Java I2P since 1.7.0; use SAM v3 instead. Veškerá oficiální dokumentace se nachází v `/docs/api/` — stará cesta `/spec/samv3/` **neexistuje**. 6. Síťové připojení a porty Typické výchozí porty: - 4444 – HTTP proxy - 4445 – HTTPS proxy - 7654 – I2CP - 7656 – SAM Bridge - 7657 – Konzole routeru - 7658 – Lokální I2P stránka - 6668 – IRC proxy - 9000–31000 – Náhodný port routeru (UDP/TCP příchozí)\nRoutery si při prvním spuštění vyberou náhodný příchozí port. Přesměrování portů zlepšuje výkon, ale UPnP to může zvládnout automaticky.\n7. Moderní změny (2024–2025) Change Status Details SSU1 Transport Removed SSU2 is now the exclusive UDP transport. I2P-over-Tor Blocked Since 2.6.0 (July 2024). Datagram2/3 Added Authenticated, repliable datagram formats (2.9.0). LeaseSet service records Added Enables service discovery (Proposal 167). Tunnel build parameters Improved Adaptive congestion handling (2.9.0+). Post-quantum crypto Introduced (beta) ML-KEM hybrid ratchet, opt-in from 2.10.0. Java 17 requirement Announced Becomes mandatory in 2.11.0 (early 2026). ## 8. Uživatelská zkušenost a testování Komunikovat, co I2P dělá a proč je šířka pásma sdílena. Poskytnout diagnostiku routeru (šířka pásma, tunnely, stav reseedu). Testovat balíčky na Windows, macOS a Linuxu (včetně verzí pro nízkou RAM). Ověřit interoperabilitu s peery Java I2P i i2pd. Testovat obnovu po výpadcích sítě a nekorektních ukončeních. 9. Komunitní zdroje Fórum: i2pforum.net nebo http://i2pforum.i2p uvnitř I2P. Kód: i2pgit.org/I2P_Developers/i2p.i2p . IRC (síť Irc2P): #i2p-dev, #i2pd. #i2papps neověřeno; možná neexistuje. Upřesněte, která síť (Irc2P vs ilita.i2p) hostuje váš kanál. Zodpovědné začlenění znamená vyvážení uživatelského komfortu, výkonu a přínosu pro síť. Používejte tato výchozí nastavení, zůstaňte synchronizováni s vývojáři routeru a testujte pod reálným zatížením před vydáním.\n","description":"Aktualizované praktické pokyny pro odpovědné začlenění I2P routeru do vaší aplikace","id":"f67f27efbc9bb7bff8d34001c14105ff","section":"docs","title":"Vkládání I2P do vaší aplikace","url":"/cs/docs/applications/embedding/"},{"categories":null,"content":"Výkon sítě I2P: Rychlost, připojení a správa zdrojů Síť I2P je plně dynamická. Každý klient je znám ostatním uzlům a testuje lokálně známé uzly z hlediska dosažitelnosti a kapacity. Do lokální NetDB jsou ukládány pouze dosažitelné a výkonné uzly. Během procesu budování tunelů jsou z tohoto fondu vybírány nejlepší zdroje pro vytvoření tunelů. Protože testování probíhá nepřetržitě, fond uzlů se mění. Každý I2P uzel zná jinou část NetDB, což znamená, že každý router má k dispozici jinou sadu I2P uzlů pro použití v tunelech. I když dva routery mají stejnou podmnožinu známých uzlů, testy dosažitelnosti a kapacity pravděpodobně ukáží odlišné výsledky, protože ostatní routery mohou být právě pod zátěží ve chvíli, kdy jeden router testuje, ale mohou být volné, když testuje druhý router.\nToto popisuje, proč každý I2P uzel má různé uzly pro budování tunelů. Protože každý I2P uzel má odlišnou latenci a šířku pásma, tunely (které jsou postaveny přes tyto uzly) mají odlišné hodnoty latence a šířky pásma. A protože každý I2P uzel má vybudovány různé tunely, žádné dva I2P uzly nemají stejné sady tunelů.\nServer/klient je označován jako „destination\u0026quot; (destinace) a každá destinace má alespoň jeden příchozí a jeden odchozí tunnel. Výchozí nastavení je 3 skoky na tunnel. To dává dohromady 12 skoků (12 různých I2P uzlů) pro úplnou cestu tam a zpět klient → server → klient.\nKaždý datový balíček je odeslán přes 6 dalších I2P uzlů, než dorazí na server:\nclient - hop1 - hop2 - hop3 - hopa1 - hopa2 - hopa3 - server\na na zpáteční cestě 6 různých I2P uzlů:\nserver - hopb1 - hopb2 - hopb3 - hopc1 - hopc2 - hopc3 - client\nProvoz v síti vyžaduje ACK před odesláním nových dat; je nutné počkat, až se ACK vrátí ze serveru: odeslat data, počkat na ACK, odeslat další data, počkat na ACK. Protože se RTT (Round Trip Time) skládá z latence každého jednotlivého I2P uzlu a každého připojení na této cestě tam a zpět, obvykle trvá 1–3 sekundy, než se ACK vrátí ke klientovi. Kvůli návrhu TCP a I2P transportu má datový paket omezenou velikost. Tyto podmínky společně stanovují limit maximální šířky pásma na tunel přibližně 20–50 kB/s. Pokud však má pouze jeden hop v tunelu k dispozici pouze 5 kB/s šířky pásma, celý tunel je omezen na 5 kB/s, nezávisle na latenci a dalších omezeních.\nŠifrování, latence a způsob, jakým je tunel vybudován, činí jeho vytvoření poměrně náročným z hlediska využití CPU. To je důvod, proč destinace může mít maximálně 6 příchozích a 6 odchozích tunelů pro přenos dat. S maximem 50 kB/s na tunel může destinace využívat zhruba 300 kB/s celkového provozu (ve skutečnosti to může být více, pokud se používají kratší tunely s nízkou nebo žádnou anonymitou). Použité tunely jsou zahozeny každých 10 minut a jsou vybudovány nové. Tato změna tunelů a někdy i klienti, kteří se vypnou nebo ztratí připojení k síti, občas způsobí přerušení tunelů a spojení. Příklad toho lze vidět na IRC2P Network při ztrátě spojení (ping timeout) nebo při použití eepget.\nS omezenou sadou cílových destinací a omezenou sadou tunelů na destinaci používá jeden I2P uzel pouze omezenou sadu tunelů napříč jinými I2P uzly. Pokud je například I2P uzel „hop1\u0026quot; v malém příkladu výše, vidí pouze jeden participating tunel vycházející z klienta. Pokud sečteme celou I2P síť, může být vybudován pouze poměrně omezený počet participating tunelů s omezeným množstvím šířky pásma celkem. Pokud tato omezená čísla rozdělíme na počet I2P uzlů, je k dispozici pouze zlomek dostupné šířky pásma/kapacity.\nAby zůstala zachována anonymita, jeden router by neměl být využíván celou sítí pro budování tunelů. Pokud by jeden router fungoval jako router tunelu pro všechny I2P uzly, stal by se velmi reálným centrálním bodem selhání a zároveň centrálním místem pro sbírání IP adres a dat od klientů. To je důvod, proč síť distribuuje provoz napříč uzly v procesu budování tunelů.\nDalším faktorem ovlivňujícím výkon je způsob, jakým I2P zpracovává mesh networking. Každý spojovací přeskok (hop-to-hop) využívá jedno TCP nebo UDP spojení na I2P uzlech. Při 1000 spojeních vidíme 1000 TCP spojení. To je docela hodně a některé domácí routery a routery pro malé kanceláře umožňují pouze malý počet spojení. I2P se snaží omezit tato spojení na méně než 1500 pro UDP a pro TCP typ. Tím se také omezuje množství provozu směrovaného přes I2P uzel.\nPokud je uzel dosažitelný a má nastavení šířky pásma \u0026gt;128 kB/s sdílené a je dosažitelný 24/7, měl by být po určité době použit pro účastnický provoz. Pokud je mezitím nedostupný, testování I2P uzlu prováděné jinými uzly jim sdělí, že není dosažitelný. To zablokuje uzel na ostatních uzlech nejméně na 24 hodin. Takže ostatní uzly, které otestovaly daný uzel jako nedostupný, nebudou tento uzel používat po dobu 24 hodin pro budování tunnelů. To je důvod, proč je váš provoz nižší po restartu/vypnutí vašeho I2P routeru minimálně po dobu 24 hodin.\nNavíc další I2P uzly potřebují znát I2P router, aby ho mohly testovat z hlediska dostupnosti a kapacity. Tento proces lze urychlit, když interagujete se sítí, například používáním aplikací nebo návštěvou I2P stránek, což povede k budování více tunnelů a tím pádem k větší aktivitě a dostupnosti pro testování uzly v síti.\nHistorie výkonu (vybrané) V průběhu let došlo v I2P k řadě významných vylepšení výkonu:\nNative math Implementováno prostřednictvím JNI vazeb na knihovnu GNU MP (GMP) pro zrychlení modPow třídy BigInteger, které dříve dominovalo spotřebě procesorového času. Časné výsledky ukázaly dramatické zrychlení v kryptografii s veřejným klíčem. Viz: /misc/jbigi/\nGarlic wrapping a \u0026ldquo;reply\u0026rdquo; LeaseSet (tuned) Dříve odpovědi často vyžadovaly vyhledání odesílatelova LeaseSet v síťové databázi. Zabalení odesílatelova LeaseSet do počátečního garlic zlepšuje latenci odpovědi. Nyní se to provádí selektivně (na začátku spojení nebo když se LeaseSet změní), aby se snížila režie.\nNativní matematika Některé validační kroky byly přesunuty dříve do transport handshake, aby byly špatné uzly odmítnuty dříve (špatné hodiny, špatný NAT/firewall, nekompatibilní verze), což šetří CPU a šířku pásma.\nGarlic wrapping \u0026ldquo;odpověď\u0026rdquo; LeaseSet (vyladěný) Používejte kontextově orientované testování tunelů: vyhýbejte se testování tunelů, u kterých je známo, že procházejí data; upřednostňujte testování v nečinnosti. To snižuje režii a zrychluje detekci selhávajících tunelů.\nEfektivnější odmítání TCP Zachování výběrů pro dané spojení snižuje doručování mimo pořadí a umožňuje knihovně streamingu zvětšovat velikosti oken, čímž zlepšuje propustnost.\nÚpravy testování tunelů GZip nebo podobné pro rozsáhlé struktury (např. RouterInfo options) snižuje šířku pásma tam, kde je to vhodné.\nTrvalý výběr tunelu/leaseSetu Náhrada za zjednodušený protokol \u0026ldquo;ministreaming\u0026rdquo;. Moderní streaming zahrnuje selektivní ACK a řízení zahlcení přizpůsobené anonymnímu, zprávy orientovanému substrátu I2P. Viz: /docs/api/streaming/\nFuture Performance Improvements (historical ideas) Níže jsou uvedeny historicky zdokumentované nápady na potenciální vylepšení. Mnoho z nich je zastaralých, implementovaných nebo nahrazených architektonickými změnami.\nKomprimovat vybrané datové struktury Zlepšit způsob, jakým routery vybírají uzly pro budování tunelů, aby se vyhnuly pomalým nebo přetíženým uzlům, přičemž zůstanou odolné vůči Sybil útokům ze strany silných protivníků.\nProtokol pro úplné streamování Snižte zbytečné zkoumání, když je keyspace stabilní; upravte, kolik peerů je vráceno při vyhledávání a kolik souběžných prohledávání je prováděno.\nSession Tag tuning and improvements (legacy) Pro starší schéma ElGamal/AES+SessionTag snižují chytřejší strategie expirace a doplňování návratů k ElGamal a plýtvání tagy.\nLepší profilování a výběr peerů Generovat tagy ze synchronizovaného PRNG osívaného během navázání nové relace, což snižuje per‑message režii oproti předem dodaným tagům.\nLadění síťové databáze Delší životnost tunelů ve spojení s opravami může snížit režii obnovy; vyvažte s anonymitou a spolehlivostí.\nLadění a vylepšení Session Tag (legacy) Odmítněte neplatné peery dříve a učiňte testování tunelů více kontextově orientované, aby se snížila kontence a latence.\nMigrace SessionTag na synchronizovaný PRNG (legacy) Selektivní sdružování LeaseSet, komprimované možnosti RouterInfo a adopce plného streamovacího protokolu, to vše přispívá k lepšímu vnímanému výkonu.\nDůležité poznámky pro vývojáře Prosím přečtěte si tuto stránku pečlivě před vývojem aplikací pro I2P.\nArchitektura aplikací Používejte SAM nebo I2CP Pro většinu aplikací doporučujeme používat SAM (Simple Anonymous Messaging) nebo I2CP (I2P Client Protocol) . SAM je jednodušší protokol podobný SOCKS a je dostupný v mnoha programovacích jazycích. I2CP poskytuje více možností konfigurace a kontroly, ale je složitější na použití.\nNepoužívejte HTTP proxy pro non-HTTP provoz HTTP proxy je určena pouze pro HTTP provoz. Nepoužívejte ji pro jiné protokoly. Použijte SAM, I2CP nebo SOCKS proxy místo toho.\nNepoužívejte SOCKS proxy pro kritické aplikace SOCKS proxy v I2P má určitá omezení a nemusí být vhodná pro všechny aplikace. Pro produkční nasazení doporučujeme používat SAM nebo I2CP.\nBezpečnost a anonymita Mějte na paměti charakteristiky latence I2P má vyšší latenci než běžný internet. Vaše aplikace by měla být navržena s ohledem na tuto latenci. Používejte vhodné timeouty a opakování.\nNeprozrazujte informace o uživateli Vaše aplikace by neměla prozrazovat informace jako IP adresu uživatele, časové pásmo nebo jiné identifikující údaje. Buďte opatrní s metadaty.\nPoužívejte end-to-end šifrování I2P poskytuje garlic encryption pro ochranu síťové vrstvy, ale pro citlivá data doporučujeme přidat další vrstvu end-to-end šifrování na aplikační úrovni.\nVýkon a škálovatelnost Optimalizujte pro I2P síť I2P má jiné výkonnostní charakteristiky než běžný internet. Minimalizujte počet připojení, používejte connection pooling a implementujte vhodné strategie cachování.\nTestujte s realistickou zátěží Testujte vaši aplikaci s realistickým množstvím provozu. I2P síť může mít odlišné chování pod zátěží.\nKompatibilita Podporujte různé verze I2P Různí uživatelé mohou používat různé verze I2P routeru. Navrhněte vaši aplikaci tak, aby byla kompatibilní s více verzemi.\nDokumentujte závislosti Jasně dokumentujte všechny závislosti a požadavky na verze pro vaši aplikaci.\nViz také:\nSměrování tunelů Výběr peerů Transporty Specifikace SSU2 a Specifikace NTCP2 ","description":"Výkon sítě I2P: jak se chová dnes, historická vylepšení a nápady pro budoucí optimalizaci","id":"eb296d22dd7b2414170601d7c73a1613","section":"docs","title":"Výkon","url":"/cs/docs/overview/performance/"},{"categories":null,"content":"Reseed hosty jsou klíčovou infrastrukturou pro síť I2P, poskytují novým routerům počáteční skupinu uzlů během procesu bootstrapu. Tento průvodce vás provede nastavením a provozem vlastního reseed serveru.\nCo je I2P Reseed Server? Server pro reseed I2P pomáhá integrovat nové routery do sítě I2P tím, že:\nPoskytování počátečního zjišťování protějšků: Nové routery získají výchozí sadu síťových uzlů, ke kterým se připojí Obnova bootstrapu: Pomoc routerům, které mají potíže s udržením připojení Bezpečná distribuce: Proces reseedingu je šifrovaný a digitálně podepsaný pro zajištění síťové bezpečnosti Když se nový I2P router spustí poprvé (nebo ztratil všechna svá peer připojení), kontaktuje reseed servery, aby stáhl počáteční sadu informací o routerech. To umožňuje novému routeru začít budovat vlastní síťovou databázi a navazovat tunnely.\nPředpoklady Než začnete, budete potřebovat:\nLinuxový server (doporučuje se Debian/Ubuntu) s root přístupem Doménové jméno odkazující na váš server Minimálně 1GB RAM a 10GB diskového prostoru Běžící I2P router na serveru pro naplnění network database Základní znalost správy Linuxových systémů Příprava serveru Step 1: Update System and Install Dependencies Nejprve aktualizujte systém a nainstalujte požadované balíčky:\nsudo apt update \u0026amp;\u0026amp; sudo apt upgrade -y \u0026amp;\u0026amp; sudo apt-get install golang-go git make docker.io docker-compose -y Toto nainstaluje: - golang-go: Runtime programovacího jazyka Go - git: Systém pro správu verzí - make: Nástroj pro automatizaci buildů - docker.io \u0026amp; docker-compose: Kontejnerová platforma pro provoz Nginx Proxy Manager\nStep 2: Clone and Build Reseed Tools Naklonujte repozitář reseed-tools a sestavte aplikaci:\ncd /home/i2p git clone https://i2pgit.org/idk/reseed-tools cd reseed-tools make build sudo make install Balíček reseed-tools poskytuje základní funkcionalitu pro provoz reseed serveru. Zajišťuje: - Sběr informací o routerech z vaší lokální síťové databáze - Balení informací o routerech do podepsaných SU3 souborů - Poskytování těchto souborů přes HTTPS\nStep 3: Generate SSL Certificate Vygenerujte SSL certifikát a soukromý klíč vašeho reseed serveru:\nsu - i2p -c \u0026#39;reseed-tools reseed --signer=admin@stormycloud.org --netdb=/home/i2p/.i2p/netDb --port=8443 --ip=127.0.0.1 --trustProxy\u0026#39; Důležité parametry: - --signer: Vaše e-mailová adresa (nahraďte admin@stormycloud.org svou vlastní) - --netdb: Cesta k síťové databázi vašeho I2P routeru - --port: Interní port (doporučuje se 8443) - --ip: Navázat na localhost (pro veřejný přístup použijeme reverzní proxy) - --trustProxy: Důvěřovat hlavičkám X-Forwarded-For z reverzní proxy\nPříkaz vygeneruje: - Privátní klíč pro podepisování SU3 souborů - SSL certifikát pro zabezpečená HTTPS spojení\nKrok 1: Aktualizace systému a instalace závislostí Kritické: Bezpečně zálohujte vygenerované klíče umístěné v /home/i2p/.reseed/:\nsudo tar -czf reseed-keys-backup.tar.gz /home/i2p/.reseed/ Uložte tuto zálohu na bezpečné, šifrované místo s omezeným přístupem. Tyto klíče jsou nezbytné pro provoz vašeho reseed serveru a měly by být pečlivě chráněny.\nConfiguring the Service Krok 2: Klonování a sestavení Reseed nástrojů Vytvořte systemd službu pro automatické spuštění reseed serveru:\nsudo tee /etc/systemd/system/reseed.service \u0026lt;\u0026lt;EOF [Unit] Description=Reseed Service After=network.target [Service] User=i2p WorkingDirectory=/home/i2p ExecStart=/bin/bash -c \u0026#39;reseed-tools reseed --signer=admin@stormycloud.org --netdb=/home/i2p/.i2p/netDb --port=8443 --ip=127.0.0.1 --trustProxy\u0026#39; Restart=always RestartSec=10 [Install] WantedBy=multi-user.target EOF Nezapomeňte nahradit admin@stormycloud.org vlastní e-mailovou adresou.\nNyní službu povolte a spusťte:\nsudo systemctl daemon-reload sudo systemctl enable reseed sudo systemctl start reseed Zkontrolujte, že služba běží:\nsudo systemctl status reseed Krok 3: Vygenerování SSL certifikátu Pro optimální výkon můžete chtít pravidelně restartovat službu reseed pro obnovení informací o routerech:\nsudo crontab -e Přidejte tento řádek pro restartování služby každé 3 hodiny:\n0 */3 * * * systemctl restart reseed Setting Up Reverse Proxy Reseed server běží na localhost:8443 a potřebuje reverzní proxy pro zpracování veřejného HTTPS provozu. Doporučujeme Nginx Proxy Manager pro jeho snadné použití.\nKrok 4: Zálohujte své klíče Nasazení Nginx Proxy Manager pomocí Dockeru:\ndocker run -d \\ --name nginx-proxy-manager \\ -p 80:80 \\ -p 81:81 \\ -p 443:443 \\ -v $(pwd)/data:/data \\ -v $(pwd)/letsencrypt:/etc/letsencrypt \\ --restart unless-stopped \\ jc21/nginx-proxy-manager:latest Toto vystavuje: - Port 80: HTTP provoz - Port 81: Rozhraní pro správu - Port 443: HTTPS provoz\nConfigure Proxy Manager Přístup k administračnímu rozhraní na adrese http://your-server-ip:81\nPřihlaste se pomocí výchozích přihlašovacích údajů:\nEmail: admin@example.com Heslo: changeme Důležité: Tyto přihlašovací údaje změňte okamžitě po prvním přihlášení!\nPřejděte na Proxy Hosts a klikněte na Add Proxy Host Nakonfigurujte proxy hostitele: Doménové jméno: Vaše reseed doména (např. reseed.example.com) Schéma: https Forward Hostname / IP: 127.0.0.1 Forward Port: 8443 Povolte Cache Assets Povolte Block Common Exploits Povolte Websockets Support V záložce SSL: Vyberte Request a new SSL Certificate (Let\u0026rsquo;s Encrypt) Povolte Force SSL Povolte HTTP/2 Support Odsouhlaste podmínky služby Let\u0026rsquo;s Encrypt Klikněte na Uložit Váš reseed server by nyní měl být přístupný na https://reseed.example.com\nRegistering Your Reseed Server Jakmile váš reseed server funguje, kontaktujte vývojáře I2P, aby byl přidán do oficiálního seznamu reseed serverů.\nKrok 5: Vytvoření Systemd služby Napište e-mail zzz (vedoucímu vývojáři I2P) s následujícími informacemi:\nI2P Email: zzz@mail.i2p Clearnet Email: zzz@i2pmail.org Krok 6: Volitelné - Konfigurace periodických restartů Uveďte ve svém e-mailu:\nURL reseed serveru: Úplná HTTPS URL adresa (např. https://reseed.example.com) Veřejný reseed certifikát: Umístěný v /home/i2p/.reseed/ (přiložte soubor .crt) Kontaktní e-mail: Váš preferovaný způsob kontaktu pro upozornění na údržbu serveru Umístění serveru: Volitelné, ale užitečné (země/region) Předpokládaná dostupnost: Váš závazek k udržování serveru Verification Vývojáři I2P ověří, že váš reseed server: - Je správně nakonfigurován a poskytuje informace o routerech - Používá platné SSL certifikáty - Poskytuje správně podepsané SU3 soubory - Je dostupný a responzivní\nPo schválení bude váš reseed server přidán do seznamu distribuovaného s I2P routery, což pomůže novým uživatelům připojit se k síti!\nMonitoring and Maintenance Instalace Nginx Proxy Manager Monitorujte svou reseed službu:\nsudo systemctl status reseed sudo journalctl -u reseed -f Konfigurace správce proxy Sledujte systémové prostředky:\nhtop df -h Update Reseed Tools Pravidelně aktualizujte reseed-tools, abyste získali nejnovější vylepšení:\ncd /home/i2p/reseed-tools git pull make build sudo make install sudo systemctl restart reseed Kontaktní informace Pokud používáte Let\u0026rsquo;s Encrypt prostřednictvím Nginx Proxy Manager, certifikáty se automaticky obnoví. Ověřte, že obnova funguje:\ndocker logs nginx-proxy-manager | grep -i certificate Konfigurace služby Požadované informace Zkontrolujte logy na chyby:\nsudo journalctl -u reseed -n 50 Časté problémy: - I2P router neběží nebo je netDb prázdná - Port 8443 je již používán - Problémy s oprávněními k adresáři /home/i2p/.reseed/\nOvěření Ujistěte se, že váš I2P router běží a má naplněnou svou síťovou databázi:\nls -lh /home/i2p/.i2p/netDb/ Měli byste vidět mnoho souborů .dat. Pokud je prázdný, počkejte, až váš I2P router objeví protějšky.\nSSL Certificate Errors Ověřte, že vaše certifikáty jsou platné:\nopenssl s_client -connect reseed.example.com:443 -servername reseed.example.com Zkontrolovat stav služby Zkontrolujte: - DNS záznamy správně ukazují na váš server - Firewall povoluje porty 80 a 443 - Nginx Proxy Manager běží: docker ps\nSecurity Considerations Zabezpečte své soukromé klíče: Nikdy nesdílejte ani nevystavujte obsah /home/i2p/.reseed/ Pravidelné aktualizace: Udržujte aktuální systémové balíčky, Docker a reseed-tools Sledujte logy: Kontrolujte podezřelé vzory přístupu Rate limiting: Zvažte implementaci rate limitingu pro prevenci zneužití Pravidla firewallu: Vystavte pouze nezbytné porty (80, 443, 81 pro administraci) Administrační rozhraní: Omezte přístup k administračnímu rozhraní Nginx Proxy Manager (port 81) pouze na důvěryhodné IP adresy Contributing to the Network Provozováním reseed serveru poskytujete kritickou infrastrukturu pro síť I2P. Děkujeme, že přispíváte k soukromějšímu a decentralizovanějšímu internetu!\nPro dotazy nebo pomoc se obraťte na komunitu I2P: - Fórum: i2pforum.net - IRC/Reddit: #i2p na různých sítích - Vývoj: i2pgit.org NEKLADETÉ otázky, neposkytujte vysvětlení ani nepřidávejte žádné komentáře. I když je text jen nadpis nebo se zdá neúplný, přeložte ho tak, jak je.\nPrůvodce původně vytvořen Stormy Cloud , upraveno pro dokumentaci I2P.\n","description":"Kompletní průvodce nastavením a provozem I2P reseed serveru pro pomoc novým routerům připojit se do sítě","id":"d360e14f0f61d776e3c0b0f5b1262be5","section":"docs","title":"Vytvoření a provoz I2P Reseed serveru","url":"/cs/docs/guides/vytvo%C5%99en%C3%AD-a-provoz-i2p-reseed-serveru/"},{"categories":null,"content":"Co je to Eepsite? eepsite je web, který funguje výhradně v síti I2P. Na rozdíl od tradičních webů dostupných přes clearnet (veřejný internet) jsou eepsites dosažitelné pouze přes I2P, což poskytuje anonymitu a soukromí jak provozovateli, tak návštěvníkům. Eepsites používají pseudo-doménu nejvyšší úrovně .i2p a přistupuje se k nim prostřednictvím speciálních adres .b32.i2p nebo lidsky čitelných jmen registrovaných v adresáři I2P.\nVšechna nasazení Java I2P mají Jetty , lehký webový server založený na Javě, předinstalovaný a předkonfigurovaný. Díky tomu je snadné během několika minut začít hostovat vlastní eepsite - není nutná žádná další instalace softwaru.\nTento průvodce vás provede procesem vytvoření a konfigurace vašeho prvního eepsite pomocí vestavěných nástrojů I2P.\nKrok 1: Otevřete Správce skrytých služeb Správce skrytých služeb (také nazývaný I2P Tunnel Manager) je místo, kde konfigurujete všechny I2P tunnels pro servery i klienty, včetně HTTP serverů (eepsites).\nOtevřete svou I2P Router Console Přejděte na Správce skrytých služeb Měli byste vidět rozhraní Správce skrytých služeb, které zobrazuje: - Stavové zprávy - Aktuální stav tunnel a klienta - Globální ovládání tunnel - Tlačítka pro správu všech tunnels najednou - I2P Skryté služby - Seznam nakonfigurovaných serverových tunnels\nVe výchozím nastavení uvidíte existující položku I2P webový server nakonfigurovanou, ale nespuštěnou. Jedná se o předem nakonfigurovaný webový server Jetty, připravený k použití.\nKrok 2: Nakonfigurujte nastavení vašeho serveru Eepsite Klikněte na položku I2P webserver v seznamu Skrytých služeb a otevřete stránku s konfigurací serveru. Zde si upravíte nastavení svého eepsite.\nVysvětlení možností konfigurace Název - Toto je interní identifikátor pro váš tunnel - Hodí se, pokud provozujete více eepsites, abyste měli přehled, která je která - Výchozí: \u0026ldquo;I2P webserver\u0026rdquo;\nPopis - Stručný popis vašeho eepsite pro vaši vlastní potřebu - Viditelné pouze vám ve Správci skrytých služeb - Příklad: \u0026ldquo;Můj eepsite\u0026rdquo; nebo \u0026ldquo;Osobní blog\u0026rdquo;\nAutomatické spuštění tunnel - Důležité: Zaškrtněte toto políčko, aby se váš eepsite automaticky spustil, když se spustí váš I2P router - Zajistí, že váš eepsite zůstane dostupný bez ručního zásahu, i když se router znovu spustí - Doporučeno: Povoleno\nCíl (hostitel a port) - Hostitel: Místní adresa, na které běží váš webový server (výchozí: 127.0.0.1) - Port: Port, na kterém váš webový server naslouchá (výchozí: 7658 pro Jetty) - Pokud používáte předinstalovaný webový server Jetty, ponechte je na výchozích hodnotách - Měňte je pouze v případě, že provozujete vlastní webový server na jiném portu\nNázev hostitele webu - Toto je čitelný název domény .i2p vašeho eepsite - Výchozí: mysite.i2p (zástupný název) - Můžete si zaregistrovat vlastní doménu jako stormycloud.i2p nebo myblog.i2p - Nechte prázdné, pokud chcete používat pouze automaticky generovanou adresu .b32.i2p (pro outproxies (výstupní proxy)) - Viz níže Registrace vaší I2P domény , kde se dozvíte, jak získat vlastní název hostitele\nMístní destinace - Toto je jedinečný kryptografický identifikátor (adresa destinace) vašeho eepsite - Automaticky generován při prvním vytvoření tunnel - Představte si to jako trvalou \u0026ldquo;IP adresu\u0026rdquo; vašeho webu na I2P - Dlouhý alfanumerický řetězec je kódovaná podoba .b32.i2p adresy vašeho webu\nSoubor soukromého klíče - Umístění, kde jsou uloženy soukromé klíče vašeho eepsite - Výchozí: eepsite/eepPriv.dat - Tento soubor udržujte v bezpečí - kdokoli s přístupem k tomuto souboru se může vydávat za váš eepsite - Nikdy tento soubor nesdílejte ani nemažte\nDůležitá poznámka Žlutý varovný rámeček vám připomíná, že pro povolení generování QR kódů nebo funkcí ověřování při registraci musíte nakonfigurovat Název hostitele webu s příponou .i2p (např. mynewsite.i2p).\nKrok 3: Pokročilé síťové možnosti (volitelné) Pokud na stránce s nastavením posunete dolů, najdete pokročilá síťová nastavení. Tato nastavení jsou volitelná - výchozí nastavení fungují dobře pro většinu uživatelů. Nicméně je můžete upravit podle svých požadavků na zabezpečení a výkon.\nMožnosti délky pro Tunnel Délka tunnelu - Výchozí: tunnel o 3 skocích (vysoká anonymita) - Určuje, kolika skoky mezi routery požadavek prochází, než dorazí k vašemu eepsite - Více skoků = vyšší anonymita, ale pomalejší výkon - Méně skoků = rychlejší výkon, ale nižší anonymita - Možnosti sahají od 0-3 skoků s nastavením odchylky - Doporučení: ponechte 3 skoky, pokud nemáte specifické požadavky na výkon\nVariabilita tunnelu - Výchozí: variabilita 0 hopů (bez náhodnosti, konzistentní výkon) - Přidává náhodnost do délky tunnelu pro vyšší bezpečnost - Příklad: \u0026ldquo;0-1 hop variance\u0026rdquo; znamená, že délka tunnelu bude náhodně 3 nebo 4 hopy - Zvyšuje nepředvídatelnost, ale může způsobit nekonzistentní časy načítání\nMožnosti počtu Tunnel Počet (Inbound/Outbound Tunnels) - Výchozí: 2 inbound, 2 outbound tunnels (standardní šířka pásma a spolehlivost) - Určuje, kolik paralelních tunnels je vyhrazeno pro vaši eepsite - Více tunnels = Lepší dostupnost a zvládání zátěže, ale vyšší využití prostředků - Méně tunnels = Nižší využití prostředků, ale snížená redundance - Doporučeno pro většinu uživatelů: 2/2 (výchozí) - Weby s vysokým provozem mohou těžit z 3/3 nebo vyšší hodnoty\nPočet záložních tunnels - Výchozí: 0 záložních tunnels (žádná redundance, žádné další využití prostředků) - Pohotovostní tunnels, které se aktivují, pokud primární tunnels selžou - Zvyšuje spolehlivost, ale spotřebovává více šířky pásma a CPU - Většina osobních eepsites nepotřebuje záložní tunnels\nLimity POST Pokud váš eepsite obsahuje formuláře (kontaktní formuláře, sekce komentářů, nahrávání souborů apod.), můžete nakonfigurovat limity požadavků POST, abyste zabránili zneužívání:\nLimity na klienta - Za období: Maximální počet požadavků od jednoho klienta (výchozí: 6 za 5 minut) - Doba blokování: Jak dlouho blokovat zneužívající klienty (výchozí: 20 minut)\nCelkové limity - Celkem: Maximální počet požadavků POST ze všech klientů dohromady (výchozí: 20 během 5 minut) - Doba blokace: Jak dlouho odmítat všechny požadavky POST, pokud je limit překročen (výchozí: 10 minut)\nInterval omezení POST - Časové okno pro měření míry požadavků (výchozí: 5 minut)\nTato omezení pomáhají chránit před spamem, útoky typu odepření služby (denial-of-service) a zneužíváním automatizovaného odesílání formulářů.\nKdy upravit pokročilá nastavení Komunitní web s vysokým provozem: Zvyšte počet tunnelů (3-4 příchozí/odchozí) Výkonově kritická aplikace: Snižte délku tunnelu na 2 skoky (kompromis v oblasti soukromí) Vyžadována maximální anonymita: Zachovejte 3 skoky, přidejte 0-1 odchylku Formuláře s legitimně vysokým využitím: Podle toho zvyšte limity pro POST Osobní blog/portfolio: Použijte všechny výchozí hodnoty Krok 4: Přidání obsahu do vaší eepsite Nyní, když je vaše eepsite nakonfigurována, musíte přidat soubory svého webu (HTML, CSS, obrázky apod.) do kořenového adresáře dokumentů webového serveru. Umístění se liší podle vašeho operačního systému, typu instalace a implementace I2P.\nZjištění vašeho kořenového adresáře webu Kořenový adresář (často nazývaný docroot) je složka, do níž umisťujete všechny soubory svého webu. Váš soubor index.html by měl být umístěn přímo v této složce.\nJava I2P (Standardní distribuce) Linux - Standardní instalace: ~/.i2p/eepsite/docroot/ - Instalace z balíčku (běžící jako služba): /var/lib/i2p/i2p-config/eepsite/docroot/\nWindows - Standardní instalace: %LOCALAPPDATA%\\I2P\\eepsite\\docroot\\ - Typická cesta: C:\\Users\\YourUsername\\AppData\\Local\\I2P\\eepsite\\docroot\\ - Instalace jako služba Windows: %PROGRAMDATA%\\I2P\\eepsite\\docroot\\ - Typická cesta: C:\\ProgramData\\I2P\\eepsite\\docroot\\\nmacOS - Standardní instalace: /Users/YourUsername/Library/Application Support/i2p/eepsite/docroot/\nI2P+ (vylepšená distribuce I2P) I2P+ používá stejnou adresářovou strukturu jako Java I2P. Řiďte se výše uvedenými cestami podle svého operačního systému.\ni2pd (Implementace v C++) Linux/Unix - Výchozí: /var/lib/i2pd/eepsite/ nebo ~/.i2pd/eepsite/ - Zkontrolujte svůj konfigurační soubor i2pd.conf a ověřte aktuální nastavení root v oddílu pro váš HTTP server tunnel\nWindows - Zkontrolujte i2pd.conf ve vašem instalačním adresáři i2pd\nmacOS - Obvykle: ~/Library/Application Support/i2pd/eepsite/\nPřidání souborů vašeho webu Přejděte do svého kořenového adresáře dokumentů pomocí správce souborů nebo terminálu Vytvořte nebo zkopírujte soubory svého webu do složky docroot Alespoň vytvořte soubor index.html (to je vaše domovská stránka) Podle potřeby přidejte CSS, JavaScript, obrázky a další statické soubory Uspořádejte podadresáře tak, jak byste to udělali u libovolného webu: docroot/ ├── index.html ├── about.html ├── css/ │ └── style.css ├── images/ │ └── logo.png └── js/ └── script.js Rychlý start: Jednoduchý příklad HTML Pokud právě začínáte, vytvořte základní soubor index.html ve své složce docroot:\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;My I2P Eepsite\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Welcome to My Eepsite!\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;This is my first website on the I2P network.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Privacy-focused and decentralized!\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Oprávnění (Linux/Unix/macOS) Pokud spouštíte I2P jako službu nebo pod jiným uživatelem, ujistěte se, že proces I2P má k vašim souborům oprávnění ke čtení:\n# Set appropriate ownership (if running as i2p user) sudo chown -R i2p:i2p /var/lib/i2p/i2p-config/eepsite/docroot/ # Or set readable permissions for all users chmod -R 755 ~/.i2p/eepsite/docroot/ Tipy Výchozí obsah: Když si poprvé nainstalujete I2P, ve složce docroot už je ukázkový obsah - klidně ho nahraďte Statické weby fungují nejlépe: Ačkoli Jetty podporuje servlety a JSP, jednoduché weby v HTML/CSS/JavaScriptu se nejlépe udržují Externí webové servery: Pokročilí uživatelé mohou provozovat vlastní webové servery (Apache, Nginx, Node.js, atd.) na různých portech a nasměrovat na ně I2P tunnel Krok 5: Spuštění vašeho Eepsite Nyní, když je váš eepsite nakonfigurován a má obsah, je čas jej spustit a zpřístupnit v síti I2P.\nSpustit Tunnel Vraťte se do Správce skrytých služeb Najděte v seznamu položku svého I2P webového serveru Klikněte na tlačítko Start ve sloupci Ovládání Počkejte, až se tunnel naváže Po kliknutí na Start se váš eepsite tunnel začne sestavovat. Tento proces obvykle trvá 30–60 sekund. Sledujte indikátor stavu:\nČervené světlo = Tunnel se spouští/buduje Žluté světlo = Tunnel je částečně navázán Zelené světlo = Tunnel je plně funkční a připraven Jakmile uvidíte zelené světlo, váš eepsite je dostupný v síti I2P!\nPřístup k vašemu eepsite Klikněte na tlačítko Preview vedle vašeho spuštěného eepsite (I2P webová stránka). Tím se otevře nová karta prohlížeče s adresou vašeho eepsite.\nVaše eepsite má dva typy adres:\nBase32 adresa (.b32.i2p): Dlouhá kryptografická adresa, která vypadá takto:\nhttp://fcyianvr325tdgiiueyg4rsq4r5iuibzovl26msox5ryoselykpq.b32.i2p Toto je trvalá, kryptograficky odvozená adresa vaší eepsite (web na I2P) Nelze ji změnit a je svázána s vaším soukromým klíčem Funguje vždy, i bez registrace domény Lidsky čitelná doména (.i2p): Pokud nastavíte název hostitele webu (např. testwebsite.i2p)\nFunguje až po registraci domény (viz následující část) Snadněji se pamatuje a sdílí Mapuje se na vaši adresu .b32.i2p Tlačítko Copy Hostname vám umožní rychle zkopírovat celou vaši adresu .b32.i2p ke sdílení.\n⚠️ Kritické: Zálohujte svůj privátní klíč Než budete pokračovat dál, musíte zálohovat soubor s privátním klíčem vašeho eepsite. Je to z několika důvodů kriticky důležité:\nProč zálohovat svůj klíč? Váš soukromý klíč (eepPriv.dat) je identitou vašeho eepsite (webu na síti I2P). Určuje vaši adresu .b32.i2p a prokazuje vlastnictví vašeho eepsite.\nKlíč = .b32 adresa: Váš soukromý klíč matematicky generuje vaši jedinečnou adresu .b32.i2p Nelze obnovit: Pokud ztratíte svůj klíč, trvale přijdete o adresu svého eepsite Nelze změnit: Pokud jste zaregistrovali doménu směřující na .b32 adresu, neexistuje způsob, jak ji aktualizovat - registrace je trvalá Nutné pro migraci: Přesun na nový počítač nebo přeinstalace I2P vyžaduje tento klíč k zachování stejné adresy Multihoming support (podpora hostování z více umístění): Provozování vašeho eepsite z více umístění vyžaduje stejný klíč na každém serveru Kde je soukromý klíč? Ve výchozím nastavení je váš soukromý klíč uložen zde: - Linux: ~/.i2p/eepsite/eepPriv.dat (nebo /var/lib/i2p/i2p-config/eepsite/eepPriv.dat v případě instalace jako služby) - Windows: %LOCALAPPDATA%\\I2P\\eepsite\\eepPriv.dat nebo %PROGRAMDATA%\\I2P\\eepsite\\eepPriv.dat - macOS: /Users/YourUsername/Library/Application Support/i2p/eepsite/eepPriv.dat\nTuto cestu můžete také zkontrolovat/změnit ve své konfiguraci tunnelu v položce \u0026ldquo;Private Key File\u0026rdquo;.\nJak zálohovat Zastavte svůj tunnel (volitelné, ale bezpečnější) Zkopírujte eepPriv.dat na bezpečné místo: Externí USB disk Šifrovaný záložní disk Archiv chráněný heslem Bezpečné cloudové úložiště (šifrované) Mějte více záloh na různých fyzických místech Tento soubor nikdy nesdílejte - kdokoli, kdo ho má, se může vydávat za váš eepsite Obnovit ze zálohy Chcete-li obnovit svůj eepsite na novém systému nebo po reinstalaci:\nNainstalujte I2P a vytvořte/nakonfigurujte nastavení svého tunnelu Zastavte tunnel před zkopírováním klíče Zkopírujte svůj zálohovaný eepPriv.dat do správného umístění Spusťte tunnel - použije vaši původní adresu .b32 Pokud neregistrujete doménu Gratulujeme! Pokud neplánujete registrovat vlastní doménové jméno .i2p, váš eepsite (webová stránka v síti I2P) je nyní hotový a v provozu.\nMůžete: - Sdílet svou adresu .b32.i2p s ostatními - Přistupovat ke svému webu přes síť I2P pomocí libovolného prohlížeče s podporou I2P - Kdykoli aktualizovat soubory svého webu ve složce docroot - Sledovat tunnel status v Hidden Services Manager (Správce skrytých služeb)\nPokud chcete lidsky čitelnou doménu (například mysite.i2p místo dlouhé .b32 adresy), přejděte do další sekce.\nRegistrace vaší I2P domény Lidsky čitelná doména .i2p (například testwebsite.i2p) se mnohem snáze pamatuje a sdílí než dlouhá adresa .b32.i2p. Registrace domény je zdarma a propojí vámi zvolené jméno s kryptografickou adresou vašeho eepsite.\nPředpoklady Váš eepsite musí běžet se zelenou kontrolkou Musíte mít nastavený Název hostitele webu v konfiguraci pro tunnel (Krok 2) Příklad: testwebsite.i2p nebo myblog.i2p Krok 1: Vygenerujte autentizační řetězec Vraťte se ke své konfiguraci pro tunnel ve Správci skrytých služeb Klikněte na položku I2P webserver pro otevření nastavení Posuňte se dolů a najděte tlačítko Ověření registrace Klikněte na Ověření registrace Zkopírujte celý ověřovací řetězec zobrazený pro \u0026ldquo;Ověření pro přidání hostitele [yourdomainhere]\u0026rdquo; Ověřovací řetězec bude vypadat takto:\ntestwebsite.i2p=I8WiuSx1TcYAutCrhLveZ6gghdqsIJ1v9noSGPb7ItYjxaK5LHVNxgC60KuEu95nqCCF2qwgnW~2ehIY9vsi1iPForksdU3GALrQq4S73meoIIXarCCdb~Z6Ehj2-yLWI8WiuSx1TcYAutCrhLveZ6gghdqsIJ1v9noSGPb7ItYjxaK5LHVNxgC60KuEu95nqCCF2qwgnW~2ehIY9vsi1iPForksdU3GALrQq4S73meoIIXarCCdb~Z6Ehj2-yLWI8WiuSx1TcYAutCrhLveZ6gghdqsIJ1v9noSGPb7ItYjxaK5LHVNxgC60KuEu95nqCCF2qwgnW~2ehIY9vsi1iPForksdU3GALrQq4S73meoIIXarCCdb~Z6Ehj2-yLWI8WiuSx1TcYAutCrhLveZ6gghdqsIJ1v9noSGPb7ItYjxaK5LHVNxgC60KuEu95nqCCF2qwgnW~2ehIY9vsi1uNxFZ0HN7tQbbVj1pmbahepQZNxEW0ufwnMYAoFo8opBQAEAAcAAA==#!date=1762104890#sig=9DjEfrcNRxsoSxiE0Mp0-7rH~ktYWtgwU8c4J0eSo0VHbGxDxdiO9D1Cvwcx8hkherMO07UWOC9BWf-1wRyUAw== Tento řetězec obsahuje: - Vaše doménové jméno (testwebsite.i2p) - Vaše cílová adresa (dlouhý kryptografický identifikátor) - Časové razítko - Kryptografický podpis prokazující, že vlastníte soukromý klíč\nUschovejte si tento ověřovací řetězec - budete ho potřebovat pro obě registrační služby.\nKrok 2: Zaregistrujte se na stats.i2p Přejděte na stats.i2p Přidat klíč (v rámci I2P) Vložte ověřovací řetězec do pole \u0026ldquo;Authentication String\u0026rdquo; Přidejte své jméno (volitelné) – výchozí je \u0026ldquo;Anonymous\u0026rdquo; Přidejte popis (doporučeno) – stručně popište, o čem je váš eepsite Příklad: \u0026ldquo;Nový I2P Eepsite\u0026rdquo;, \u0026ldquo;Osobní blog\u0026rdquo;, \u0026ldquo;Služba pro sdílení souborů\u0026rdquo; Zaškrtněte \u0026ldquo;HTTP Service?\u0026rdquo;, pokud jde o web (u většiny eepsites ponechte zaškrtnuto) Zrušte zaškrtnutí pro IRC, NNTP, proxy, XMPP, git atd. Klikněte na Submit V případě úspěchu uvidíte potvrzení, že vaše doména byla přidána do adresáře na stats.i2p.\nKrok 3: Zaregistrujte se na reg.i2p Abyste zajistili maximální dostupnost, měli byste se také zaregistrovat u služby reg.i2p:\nPřejděte na reg.i2p Add Domain (v rámci I2P) Vložte stejný autentizační řetězec do pole \u0026ldquo;Auth string\u0026rdquo; Přidejte popis (volitelné, ale doporučeno) To pomáhá ostatním uživatelům I2P pochopit, co váš web nabízí Klikněte na Submit Měli byste obdržet potvrzení, že vaše doména byla zaregistrována.\nKrok 4: Počkejte na propagaci Po odeslání do obou služeb se registrace vaší domény rozšíří napříč adresářovým systémem sítě I2P.\nČasová osa propagace: - Počáteční registrace: Okamžitě na registračních službách - Propagace napříč sítí: Několik hodin až 24+ hodin - Plná dostupnost: Může trvat až 48 hodin, než se všechny routers aktualizují\nTo je normální! Systém adresáře I2P se aktualizuje pravidelně, ne okamžitě. Váš eepsite funguje - ostatní uživatelé jen potřebují získat aktualizovaný adresář.\nOvěřte svou doménu Po několika hodinách můžete otestovat svou doménu:\nOtevřete novou kartu prohlížeče ve svém I2P prohlížeči Zkuste přejít přímo na svou doménu: http://yourdomainname.i2p Pokud se stránka načte, vaše doména je registrována a propaguje se! Pokud to zatím nefunguje: - Počkejte déle (adresáře se aktualizují podle vlastního harmonogramu) - Adresář vašeho routeru může potřebovat čas na synchronizaci - Zkuste restartovat svůj I2P router, abyste vynutili aktualizaci adresáře\nDůležité poznámky Registrace je trvalá: Jakmile je jednou zaregistrována a rozšířena, vaše doména trvale směřuje na vaši adresu .b32.i2p Cíl nelze změnit: Nelze aktualizovat, na kterou adresu .b32.i2p vaše doména směřuje - proto je zásadní zálohovat eepPriv.dat Vlastnictví domény: Doménu může zaregistrovat nebo aktualizovat pouze držitel soukromého klíče Služba zdarma: Registrace domén na I2P je zdarma, spravovaná komunitou a decentralizovaná Více registrátorů: Registrace u stats.i2p i reg.i2p zvyšuje spolehlivost a rychlost propagace Gratulujeme! Vaše I2P eepsite je nyní plně funkční s registrovanou doménou!\nDalší kroky: - Přidejte další obsah do své složky docroot - Sdílejte svou doménu s komunitou I2P - Uchovejte svou zálohu eepPriv.dat v bezpečí - Pravidelně sledujte stav svého tunnelu - Zvažte zapojení do fór I2P nebo IRC, abyste propagovali svůj web\nVítejte v síti I2P! 🎉\n","description":"Naučte se, jak vytvořit a hostovat svůj vlastní web v síti I2P pomocí vestavěného webového serveru Jetty","id":"cdd089b486cced0cc2a37529ae0ace6b","section":"docs","title":"Vytvoření I2P Eepsite","url":"/cs/docs/guides/vytvo%C5%99en%C3%AD-i2p-eepsite/"},{"categories":null,"content":"SSH tunel poskytuje bezpečné, šifrované spojení pro přístup ke konzoli vašeho vzdáleného I2P routeru nebo k dalším službám. Tato příručka vám ukáže, jak vytvořit SSH tunely na systémech Windows, Linux a Mac.\nCo je SSH tunel? SSH tunel je metoda směrování dat a informací bezpečně přes šifrované SSH spojení. Představte si to jako vytvoření chráněného \u0026ldquo;potrubí\u0026rdquo; přes internet - vaše data cestují tímto šifrovaným tunelem, což zabraňuje komukoli je cestou zachytit nebo přečíst.\nSSH tunelování je zvláště užitečné pro:\nPřístup ke vzdáleným I2P routerům: Připojte se ke konzoli I2P běžící na vzdáleném serveru Zabezpečená spojení: Veškerý provoz je šifrován end-to-end Obcházení omezení: Přistupujte ke službám na vzdálených systémech, jako by byly lokální Přesměrování portů: Namapujte lokální port na vzdálenou službu V kontextu I2P můžete použít SSH tunel pro přístup ke konzoli vašeho I2P routeru (typicky na portu 7657) na vzdáleném serveru tak, že ji přesměrujete na lokální port na vašem počítači.\nPředpoklady Před vytvořením SSH tunelu budete potřebovat:\nSSH klient: Windows: PuTTY (ke stažení zdarma) Linux/Mac: Vestavěný SSH klient (přes Terminál) Přístup ke vzdálenému serveru: Uživatelské jméno pro vzdálený server IP adresa nebo hostname vzdáleného serveru SSH heslo nebo autentizace pomocí klíče Dostupný lokální port: Zvolte nepoužívaný port v rozsahu 1-65535 (pro I2P se běžně používá 7657) Pochopení příkazu Tunnel Příkaz pro SSH tunel se řídí tímto vzorem:\nssh -L [local_port]:[destination_ip]:[destination_port] [username]@[remote_server] Vysvětlení parametrů: - local_port: Port na vašem lokálním počítači (např. 7657) - destination_ip: Obvykle 127.0.0.1 (localhost na vzdáleném serveru) - destination_port: Port služby na vzdáleném serveru (např. 7657 pro I2P) - username: Vaše uživatelské jméno na vzdáleném serveru - remote_server: IP adresa nebo hostname vzdáleného serveru\nPříklad: ssh -L 7657:127.0.0.1:7657 i2p@20.228.143.58\nToto vytvoří tunel, kde: - Lokální port 7657 na vašem počítači přeposílá na\u0026hellip; - Port 7657 na localhost vzdáleného serveru (kde běží I2P) - Připojení jako uživatel i2p na server 20.228.143.58\nVytvoření SSH tunelů ve Windows Uživatelé Windows mohou vytvářet SSH tunely pomocí PuTTY, bezplatného SSH klienta.\nStep 1: Download and Install PuTTY Stáhněte si PuTTY z putty.org a nainstalujte ho do vašeho systému Windows.\nStep 2: Configure the SSH Connection Otevřete PuTTY a nakonfigurujte své připojení:\nV kategorii Session: Zadejte IP adresu nebo hostname vašeho vzdáleného serveru do pole Host Name Ujistěte se, že Port je nastaven na 22 (výchozí SSH port) Typ připojení by měl být SSH Step 3: Configure the Tunnel Přejděte na Connection → SSH → Tunnels v levém postranním panelu:\nZdrojový port: Zadejte lokální port, který chcete použít (např. 7657) Cíl: Zadejte 127.0.0.1:7657 (localhost:port na vzdáleném serveru) Klikněte na Přidat pro přidání tunelu Tunel by se měl objevit v seznamu \u0026ldquo;Přesměrované porty\u0026rdquo; Step 4: Connect Klikněte na Open pro zahájení připojení Pokud se připojujete poprvé, zobrazí se bezpečnostní upozornění - klikněte na Yes pro důvěru serveru Zadejte své uživatelské jméno, když budete vyzváni Zadejte své heslo, když budete vyzváni Po připojení můžete přistupovat ke své vzdálené konzoli I2P otevřením prohlížeče a navigací na adresu http://127.0.0.1:7657\nKrok 1: Stažení a instalace PuTTY Abyste se vyhnuli opětovné konfiguraci pokaždé:\nVraťte se do kategorie Session Zadejte název do pole Saved Sessions (např. \u0026ldquo;I2P Tunnel\u0026rdquo;) Klikněte na Save Příště stačí načíst tuto relaci a kliknout na Open Creating SSH Tunnels on Linux Linuxové systémy mají SSH zabudované v terminálu, což činí vytváření tunelů rychlým a přímočarým.\nKrok 2: Konfigurace SSH připojení Otevřete terminál a spusťte příkaz SSH tunelu:\nssh -L 7657:127.0.0.1:7657 i2p@20.228.143.58 Nahraďte: - 7657 (první výskyt): Požadovaný místní port - 127.0.0.1:7657: Cílová adresa a port na vzdáleném serveru - i2p: Vaše uživatelské jméno na vzdáleném serveru - 20.228.143.58: IP adresa vašeho vzdáleného serveru\nKdyž budete vyzváni, zadejte své heslo. Po připojení je tunel aktivní.\nPřístup ke vzdálené I2P konzoli získáte v prohlížeči na adrese http://127.0.0.1:7657.\nKrok 3: Konfigurace tunelu Tunel zůstává aktivní po celou dobu běhu SSH relace. Pro udržení běhu na pozadí:\nssh -f -N -L 7657:127.0.0.1:7657 i2p@20.228.143.58 Dodatečné příznaky: - -f: Spustí SSH na pozadí - -N: Nespouštět vzdálené příkazy (pouze tunel)\nPro uzavření tunelu na pozadí najděte a ukončete SSH proces:\nps aux | grep ssh kill [process_id] Krok 4: Připojení Pro lepší zabezpečení a pohodlí použijte autentizaci pomocí SSH klíčů:\nVygenerujte pár SSH klíčů (pokud ho ještě nemáte):\nssh-keygen -t ed25519 -C \u0026#34;your_email@example.com\u0026#34; Zkopírujte svůj veřejný klíč na vzdálený server:\nssh-copy-id i2p@20.228.143.58 Nyní se můžete připojit bez hesla:\nssh -L 7657:127.0.0.1:7657 i2p@20.228.143.58 Creating SSH Tunnels on Mac Systémy Mac používají stejného SSH klienta jako Linux, takže proces je identický.\nVolitelné: Uložte si svou relaci Otevřete Terminál (Aplikace → Utility → Terminál) a spusťte:\nssh -L 7657:127.0.0.1:7657 i2p@20.228.143.58 Nahraďte: - 7657 (první výskyt): Váš požadovaný lokální port - 127.0.0.1:7657: Cílová adresa a port na vzdáleném serveru - i2p: Vaše uživatelské jméno na vzdáleném serveru - 20.228.143.58: IP adresa vašeho vzdáleného serveru\nZadejte heslo, když budete vyzváni. Po připojení přistupujte ke své vzdálené konzoli I2P na adrese http://127.0.0.1:7657\nBackground Tunnels on Mac Stejně jako na Linuxu můžete tunel spustit na pozadí:\nssh -f -N -L 7657:127.0.0.1:7657 i2p@20.228.143.58 Používání terminálu Nastavení SSH klíče na Macu je identické s Linuxem:\n# Generate key (if needed) ssh-keygen -t ed25519 -C \u0026#34;your_email@example.com\u0026#34; # Copy to remote server ssh-copy-id i2p@20.228.143.58 Common Use Cases Udržování tunelu aktivního Nejčastější případ použití - přístup ke konzoli vašeho vzdáleného I2P routeru:\nssh -L 7657:127.0.0.1:7657 user@remote-server Poté otevřete http://127.0.0.1:7657 ve vašem prohlížeči.\nPoužití SSH klíčů (doporučeno) Přeposílání více portů najednou:\nssh -L 7657:127.0.0.1:7657 -L 7658:127.0.0.1:7658 user@remote-server Toto přeposílá jak port 7657 (I2P konzole), tak 7658 (další službu).\nCustom Local Port Použijte jiný lokální port, pokud je 7657 již používán:\nssh -L 8080:127.0.0.1:7657 user@remote-server Místo toho přistupujte ke konzoli I2P na http://127.0.0.1:8080.\nTroubleshooting Používání terminálu Chyba: \u0026ldquo;bind: Address already in use\u0026rdquo;\nŘešení: Zvolte jiný lokální port nebo ukončete proces, který tento port používá:\n# Linux/Mac - find process on port 7657 lsof -i :7657 # Kill the process kill [process_id] Tunely na pozadí na Macu Chyba: \u0026ldquo;Connection refused\u0026rdquo; nebo \u0026ldquo;channel 2: open failed\u0026rdquo;\nMožné příčiny: - Vzdálená služba není spuštěna (zkontrolujte, zda běží I2P router na vzdáleném serveru) - Firewall blokuje připojení - Nesprávný cílový port\nŘešení: Ověřte, že I2P router běží na vzdáleném serveru:\nssh user@remote-server \u0026#34;systemctl status i2p\u0026#34; Nastavení SSH klíčů na Macu Chyba: \u0026ldquo;Permission denied\u0026rdquo; nebo \u0026ldquo;Authentication failed\u0026rdquo;\nMožné příčiny: - Nesprávné uživatelské jméno nebo heslo - SSH klíč není správně nakonfigurován - SSH přístup je na vzdáleném serveru zakázán\nŘešení: Ověřte přihlašovací údaje a ujistěte se, že je na vzdáleném serveru povolen SSH přístup.\nTunnel Drops Connection Chyba: Připojení se odpojí po období nečinnosti\nŘešení: Přidejte nastavení keep-alive do vaší SSH konfigurace (~/.ssh/config):\nHost remote-server ServerAliveInterval 60 ServerAliveCountMax 3 Security Best Practices Používejte SSH klíče: Bezpečnější než hesla, obtížněji kompromitovatelné Zakažte autentizaci heslem: Jakmile jsou SSH klíče nastaveny, zakažte přihlašování heslem na serveru Používejte silná hesla: Pokud používáte autentizaci heslem, použijte silné, jedinečné heslo Omezte SSH přístup: Nakonfigurujte pravidla firewallu pro omezení SSH přístupu na důvěryhodné IP adresy Udržujte SSH aktualizované: Pravidelně aktualizujte svůj SSH klient a serverový software Monitorujte logy: Kontrolujte SSH logy na serveru kvůli podezřelé aktivitě Používejte nestandardní SSH porty: Změňte výchozí SSH port (22) pro snížení automatizovaných útoků Vytváření SSH tunelů v Linuxu Přístup k I2P konzoli Vytvořte skript pro automatické vytvoření tunelů:\n#!/bin/bash # i2p-tunnel.sh ssh -f -N -L 7657:127.0.0.1:7657 i2p@20.228.143.58 echo \u0026#34;I2P tunnel established\u0026#34; Udělejte jej spustitelným:\nchmod +x i2p-tunnel.sh ./i2p-tunnel.sh Více Tunelů Vytvořte systemd službu pro automatické vytváření tunelů:\nsudo nano /etc/systemd/system/i2p-tunnel.service Přidat:\n[Unit] Description=I2P SSH Tunnel After=network.target [Service] ExecStart=/usr/bin/ssh -NT -o ServerAliveInterval=60 -o ExitOnForwardFailure=yes -L 7657:127.0.0.1:7657 i2p@20.228.143.58 Restart=always RestartSec=10 User=your-username [Install] WantedBy=multi-user.target Povolit a spustit:\nsudo systemctl enable i2p-tunnel sudo systemctl start i2p-tunnel Advanced Tunneling Vlastní lokální port Vytvořte SOCKS proxy pro dynamické přesměrování:\nssh -D 8080 user@remote-server Nakonfigurujte svůj prohlížeč tak, aby používal 127.0.0.1:8080 jako SOCKS5 proxy.\nReverse Tunneling Povolit vzdálenému serveru přístup ke službám na vašem lokálním počítači:\nssh -R 7657:127.0.0.1:7657 user@remote-server Port je již používán Tunelování přes mezilehlý server:\nssh -J jumphost.example.com -L 7657:127.0.0.1:7657 user@final-server Conclusion SSH tunelování je mocný nástroj pro bezpečný přístup ke vzdáleným I2P routerům a dalším službám. Ať už používáte Windows, Linux nebo Mac, proces je přímočarý a poskytuje silné šifrování pro vaše připojení.\nPro další pomoc nebo dotazy navštivte komunitu I2P: - Fórum: i2pforum.net - IRC: #i2p na různých sítích - Dokumentace: I2P Docs NEKLASTE otázky, neposkytujte vysvětlení ani nepřidávejte žádné komentáře. I když je text pouze nadpis nebo se zdá neúplný, přeložte jej tak, jak je.\nPrůvodce původně vytvořený Stormy Cloud , upravený pro dokumentaci I2P.\n","description":"Naučte se, jak vytvořit zabezpečené SSH tunely na Windows, Linux a Mac pro přístup ke vzdálenému I2P routeru","id":"7d461aaa86788adfcb07bfb98f6e4965","section":"docs","title":"Vytvoření SSH tunelu pro vzdálený přístup k I2P","url":"/cs/docs/guides/vytvo%C5%99en%C3%AD-ssh-tunelu-pro-vzd%C3%A1len%C3%BD-p%C5%99%C3%ADstup-k-i2p/"},{"categories":null,"content":"Proč psát kód specifický pro I2P? Existuje několik způsobů, jak používat aplikace v I2P. Pomocí I2PTunnel můžete používat běžné aplikace, aniž byste museli programovat explicitní podporu I2P. To je velmi efektivní pro scénáře klient-server, kde potřebujete se připojit k jediné webové stránce. Můžete jednoduše vytvořit tunnel pomocí I2PTunnel pro připojení k této webové stránce, jak je znázorněno na obrázku 1.\nPokud je vaše aplikace distribuovaná, bude vyžadovat připojení k velkému množství uzlů. Při použití I2PTunnel budete muset vytvořit nový tunel pro každý uzel, se kterým se chcete spojit, jak je znázorněno na obrázku 2. Tento proces lze samozřejmě automatizovat, ale provozování mnoha instancí I2PTunnel vytváří velkou režii. Kromě toho u mnoha protokolů budete muset donutit všechny používat stejnou sadu portů pro všechny uzly — např. pokud chcete spolehlivě provozovat DCC chat, každý se musí dohodnout, že port 10001 je Alice, port 10002 je Bob, port 10003 je Charlie a tak dále, protože protokol obsahuje informace specifické pro TCP/IP (host a port).\nObecné síťové aplikace často odesílají množství dodatečných dat, která mohou být použita k identifikaci uživatelů. Názvy hostitelů, čísla portů, časová pásma, znakové sady atd. jsou často odesílány bez informování uživatele. Proto navržení síťového protokolu specificky s ohledem na anonymitu může zabránit kompromitaci identit uživatelů.\nPři určování způsobu interakce nad I2P je třeba zvážit také aspekty efektivity. Streamovací knihovna a nástroje na ní postavené pracují s handshaky podobnými TCP, zatímco základní I2P protokoly (I2NP a I2CP) jsou striktně založené na zprávách (jako UDP nebo v některých případech čisté IP). Důležitým rozlišením je, že u I2P probíhá komunikace přes dlouhou silně zaplněnou síť — každá end-to-end zpráva bude mít nezanedbatelné latence, ale může obsahovat datové části o velikosti až několika KB. Aplikace, která potřebuje jednoduché požadavky a odpovědi, se může zbavit jakéhokoli stavu a snížit latenci způsobenou inicializačními a ukončovacími handshaky použitím datagramů (best effort) bez nutnosti řešit detekci MTU nebo fragmentaci zpráv.\nFigure 1: Creating a server-client connection using I2PTunnel only requires creating a single tunnel. Figure 2: Setting up connections for a peer-to-peer applications requires a very large amount of tunnels. Shrnutí, několik důvodů pro psaní kódu specifického pro I2P: Vytvoření velkého množství I2PTunnel instancí spotřebovává nezanedbatelné množství zdrojů, což je problematické pro distribuované aplikace (pro každého peer je vyžadován nový tunnel). Obecné síťové protokoly často odesílají velké množství dodatečných dat, která mohou být použita k identifikaci uživatelů. Programování přímo pro I2P umožňuje vytvoření síťového protokolu, který takové informace neprozrazuje, a udržuje tak uživatele anonymní a v bezpečí. Síťové protokoly navržené pro použití na běžném internetu mohou být na I2P neefektivní, což je síť s mnohem vyšší latencí. I2P podporuje standardní rozhraní pro pluginy pro vývojáře, aby mohly být aplikace snadno integrovány a distribuovány.\nAplikace napsané v Javě a přístupné/spustitelné pomocí HTML rozhraní přes standardní webapps/app.war mohou být zváženy k zařazení do distribuce I2P.\nDůležité koncepty Při používání I2P je třeba se přizpůsobit několika změnám:\nDestinace Aplikace běžící na I2P posílá zprávy z jedinečného kryptograficky zabezpečeného koncového bodu — „destination\u0026quot; (cíle) — a přijímá do něj zprávy. Ve smyslu TCP nebo UDP by destination mohl být (z velké části) považován za ekvivalent dvojice název hostitele plus číslo portu, i když existuje několik rozdílů.\nI2P destination sama o sobě je kryptografický konstrukt — všechna data na ni odeslaná jsou šifrována, jako by byl universálně nasazen IPsec s (anonymizovanou) lokací koncového bodu podepsanou, jako by byl universálně nasazen DNSSEC. I2P destinace jsou mobilní identifikátory — mohou být přesunuty z jednoho I2P routeru na jiný (nebo mohou dokonce operovat v režimu „multihome\u0026quot; — pracovat na více routerech současně). To se výrazně liší od světa TCP nebo UDP, kde jeden koncový bod (port) musí zůstat na jediném hostu. I2P destinace jsou nepřehledné a velké — na pozadí obsahují 2048bitový ElGamal veřejný klíč pro šifrování, 1024bitový DSA veřejný klíč pro podepisování a certifikát proměnné velikosti, který může obsahovat proof of work nebo zaslepená data. Existují způsoby, jak odkazovat na tyto velké a nepohodlné destinace pomocí krátkých a přehledných názvů (např. \u0026ldquo;irc.duck.i2p\u0026rdquo;), ale tyto techniky nezaručují globální unikátnost (protože jsou uloženy lokálně v databázi na počítači každého uživatele) a současný mechanismus není příliš škálovatelný ani bezpečný (aktualizace seznamu hostitelů jsou spravovány pomocí \u0026ldquo;odběrů\u0026rdquo; jmenných služeb). Možná jednou vznikne bezpečný, lidsky čitelný, škálovatelný a globálně unikátní systém pojmenování, ale aplikace by na něm neměly být závislé. Další informace o systému pojmenování jsou k dispozici.\nZatímco většina aplikací nepotřebuje rozlišovat protokoly a porty, I2P je podporuje. Komplexní aplikace mohou specifikovat protokol, zdrojový port a cílový port na základě jednotlivých zpráv, aby multiplexovaly provoz na jedné destinaci. Podrobnosti naleznete na stránce o datagramech . Jednoduché aplikace fungují tak, že naslouchají \u0026ldquo;všem protokolům\u0026rdquo; na \u0026ldquo;všech portech\u0026rdquo; destinace.\nAnonymita a důvěrnost I2P má transparentní end-to-end šifrování a autentizaci pro všechna data přenášená přes síť — pokud Bob posílá na Alicinu destinaci, může ji přijmout pouze Alicina destinace, a pokud Bob používá datagramovou nebo streamovací knihovnu, Alice má jistotu, že data poslala Bobova destinace.\nSamozřejmě, I2P transparentně anonymizuje data odesílaná mezi Alicí a Bobem, ale nedělá nic pro anonymizaci obsahu toho, co si posílají. Například pokud Alice pošle Bobovi formulář se svým celým jménem, občanskými průkazy a čísly platebních karet, I2P s tím nemůže nic udělat. Protokoly a aplikace by proto měly mít na paměti, jaké informace se snaží chránit a jaké informace jsou ochotny odhalit.\nI2P datagramy mohou mít až několik KB Aplikace využívající I2P datagramy (ať už základní nebo s možností odpovědi) lze v podstatě chápat z hlediska UDP — datagramy jsou neuspořádané, s best effort doručením a bezstavové — ale na rozdíl od UDP se aplikace nemusí starat o detekci MTU a mohou jednoduše odesílat velké datagramy. Zatímco horní limit je nominálně 32 KB, zpráva je fragmentována pro přenos, což snižuje spolehlivost celku. Datagramy nad přibližně 10 KB se v současnosti nedoporučují. Podrobnosti naleznete na stránce o datagramech . Pro mnoho aplikací je 10 KB dat dostačujících pro celý požadavek nebo odpověď, což jim umožňuje transparentně fungovat v I2P jako UDP-like aplikace bez nutnosti implementovat fragmentaci, opětovné odesílání atd.\nMožnosti vývoje Existuje několik způsobů přenosu dat přes I2P, každý s vlastními výhodami a nevýhodami. Streaming lib je doporučené rozhraní, které používá většina I2P aplikací.\nStreaming Lib Kompletní streaming knihovna je nyní standardním rozhraním. Umožňuje programování pomocí socketů podobných TCP, jak je vysvětleno v průvodci vývojem pro Streaming .\nBOB BOB je Basic Open Bridge , umožňující aplikaci v jakémkoliv jazyce vytvářet streamovací spojení do a z I2P. V současné době postrádá podporu UDP, ale podpora UDP je plánována v blízké budoucnosti. BOB také obsahuje několik nástrojů, jako je generování klíčů destinací a ověřování, zda adresa odpovídá specifikacím I2P. Aktuální informace a aplikace využívající BOB naleznete na této I2P Stránce .\nSAM, SAM V2, SAM V3 SAM se nedoporučuje. SAM V2 je v pořádku, SAM V3 se doporučuje.\nSAM je protokol Simple Anonymous Messaging , který umožňuje aplikaci napsané v jakémkoli jazyce komunikovat s SAM bridge přes obyčejný TCP socket a nechat tento bridge multiplexovat veškerý její I2P provoz, transparentně koordinovat šifrování/dešifrování a zpracování založené na událostech. SAM podporuje tři styly provozu:\nstreamy, pro případy kdy Alice a Bob chtějí posílat data spolehlivě a ve správném pořadí odpověditelné datagramy, pro případy kdy Alice chce poslat Bobovi zprávu, na kterou může Bob odpovědět čisté datagramy, pro případy kdy Alice chce vyždímat co nejvíce šířky pásma a výkonu, a Bobovi nezáleží na tom, zda je odesílatel dat ověřený či ne (např. přenášená data jsou sama o sobě autentizovaná) SAMv3 sleduje stejný cíl jako SAM a SAM V2, ale nevyžaduje multiplexování/demultiplexování. Každý I2P stream je obsluhován vlastním socketem mezi aplikací a SAM mostem. Kromě toho mohou být datagramy odesílány a přijímány aplikací prostřednictvím datagramové komunikace s SAM mostem.\nSAM V2 je nová verze používaná aplikací imule, která opravuje některé problémy v SAM .\nSAM V3 je používán aplikací imule od verze 1.4.0.\nI2PTunnel Aplikace I2PTunnel umožňuje aplikacím vytvářet specifické TCP-podobné tunely k protějškům vytvořením buď I2PTunnel \u0026lsquo;klientských\u0026rsquo; aplikací (které naslouchají na konkrétním portu a připojují se ke konkrétní I2P destinaci, kdykoli je otevřen socket na tento port) nebo I2PTunnel \u0026lsquo;serverových\u0026rsquo; aplikací (které naslouchají na konkrétní I2P destinaci a kdykoli obdrží nové I2P připojení, předávají ho na konkrétního TCP hosta/port). Tyto streamy jsou 8-bitově čisté a jsou autentizovány a zabezpečeny pomocí stejné streaming knihovny, kterou používá SAM, ale vytváření více unikátních instancí I2PTunnel s sebou nese nezanedbatelnou režii, protože každá má svou vlastní unikátní I2P destinaci a svou vlastní sadu tunelů, klíčů atd.\nSOCKS I2P podporuje SOCKS V4 a V5 proxy. Odchozí spojení fungují dobře. Příchozí (server) a UDP funkčnost může být neúplná a neotestovaná.\nMinistreaming Odstraněno\nDříve existovala jednoduchá knihovna „ministreaming\u0026quot;, ale nyní ministreaming.jar obsahuje pouze rozhraní pro plnou streaming knihovnu.\nDatagramy Doporučeno pro aplikace podobné UDP\nKnihovna Datagram umožňuje odesílání paketů podobných UDP. Je možné použít:\nOdpověditelné datagramy Surové datagramy I2CP Nedoporučuje se\nI2CP je sám o sobě protokol nezávislý na programovacím jazyce, ale pro implementaci I2CP knihovny v jiném jazyce než Java je potřeba napsat značné množství kódu (šifrovací rutiny, marshalling objektů, asynchronní zpracování zpráv atd.). I když by někdo mohl napsat I2CP knihovnu v C nebo jiném jazyce, bylo by pravděpodobně užitečnější použít místo toho SAM knihovnu v C.\nWebové aplikace I2P je dodáván s webovým serverem Jetty a konfigurace pro použití serveru Apache je jednoduchá. Měla by fungovat jakákoli standardní technologie webových aplikací.\nZačněte s vývojem — Jednoduchý průvodce Vývoj s I2P vyžaduje funkční instalaci I2P a vývojové prostředí dle vašeho výběru. Pokud používáte Javu, můžete začít vývoj se streaming library nebo datagram library. Při použití jiného programovacího jazyka lze využít SAM nebo BOB.\nVývoj se Streaming knihovnou Níže je zkrácená a modernizovaná verze příkladu z původní stránky. Pro kompletní příklad viz starší stránku nebo naše Java příklady v kódové základně.\n// Server example (excerpt) I2PSocketManager manager = I2PSocketManagerFactory.createManager(); I2PServerSocket server = manager.getServerSocket(); I2PSocket socket = server.accept(); BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream())); String s; while ((s = br.readLine()) != null) { System.out.println(\u0026#34;Received: \u0026#34; + s); } Příklad kódu: základní server přijímající data.\n// Client example (excerpt) I2PSocketManager manager = I2PSocketManagerFactory.createManager(); Destination dest = new Destination(serverDestBase64); I2PSocket socket = manager.connect(dest); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream())); bw.write(\u0026#34;Hello I2P!\\n\u0026#34;); bw.flush(); Příklad kódu: klient se připojuje a odesílá řádek.\n","description":"Proč psát aplikace specifické pro I2P, klíčové koncepty, možnosti vývoje a jednoduchý průvodce pro začátečníky","id":"d137fc4f3bedf693b877aa1ba9bde3eb","section":"docs","title":"Vývoj aplikací","url":"/cs/docs/develop/applications/"}]
[{"categories":null,"content":"개요 이 문서는 I2P blockfile 파일 형식과 Blockfile Naming Service(블록파일 네이밍 서비스)에서 사용하는 hostsdb.blockfile 내 테이블을 명세합니다. 배경 정보는 I2P 네이밍과 주소록 을 참고하십시오.\nblockfile(블록파일)은 간결한 이진 형식으로 빠른 목적지 조회를 가능하게 합니다. 레거시 hosts.txt 시스템과 비교하면:\nDestination(목적지)은 Base64가 아닌 바이너리로 저장됩니다. 임의의 메타데이터(예: 추가 일자, 출처, 주석)를 첨부할 수 있습니다. 조회 시간은 대략 10× 더 빠름. 디스크 사용량이 소폭 증가합니다. blockfile(블록 파일)은 디스크에 저장된 정렬된 맵(키-값 쌍) 모음으로, **skip list(스킵 리스트)**로 구현됩니다. 이는 Metanotion Blockfile Database 에서 파생되었습니다. 이 명세서는 먼저 파일 구조를 정의한 다음, BlockfileNamingService에서 이를 어떻게 사용하는지 설명합니다.\nBlockfile Naming Service(블록파일 네이밍 서비스)는 I2P 0.8.8에서 이전 hosts.txt 구현을 대체했다. \u0026gt; 초기화 시 privatehosts.txt, userhosts.txt, hosts.txt의 항목을 가져온다.\nBlockfile(블록파일) 형식 형식은 1024바이트 페이지로 구성되며, 각 페이지의 무결성을 위해 앞부분에 매직 넘버가 붙습니다. 페이지는 1부터 번호가 매겨집니다:\nPage Description 1 Superblock (starts at byte 0) 2 Metaindex skiplist (starts at byte 1024) 모든 정수는 **네트워크 바이트 순서 (big-endian)**를 사용합니다. 2바이트 값은 부호 없고; 4바이트 값(페이지 번호)은 부호가 있으며 양수여야 합니다. 스레딩: 데이터베이스는 단일 스레드 접근을 위해 설계되었습니다; BlockfileNamingService가 동기화를 제공합니다.\n슈퍼블록 형식 Byte Contents 0-5 Magic number 0x3141de493250 (\"1A\" 0xde \"I2P\") 6 Major version 0x01 7 Minor version 0x02 8-15 File length (in bytes) 16-19 First free list page 20-21 Mounted flag (0x01 = yes) 22-23 Span size (max key/value pairs per span, 16 for hostsdb) 24-27 Page size (as of v1.2; 1024 before that) 28-1023 Unused --- 스킵 리스트 블록 페이지 형식 Byte Contents 0-7 Magic 0x536b69704c697374 (\"SkipList\") 8-11 First span page 12-15 First level page 16-19 Size (total keys, valid at startup) 20-23 Spans (total spans, valid at startup) 24-27 Levels (total levels, valid at startup) 28-29 Span size (as of v1.2; used for new spans) 30-1023 Unused --- 건너뛰기 레벨 차단 페이지 형식 모든 수준에는 범위가 있지만, 모든 범위에 수준이 있는 것은 아니다.\nByte Contents 0-7 Magic 0x42534c6576656c73 (\"BSLevels\") 8-9 Max height 10-11 Current height 12-15 Span page 16-… Next level pages (current height × 4 bytes, lowest first) \u0026mdash; Remaining bytes unused --- Skip Span 블록 페이지 형식 키/값 쌍은 스팬 전체에서 키 기준으로 정렬됩니다. 첫 번째가 아닌 스팬은 비어 있어서는 안 됩니다.\nByte Contents 0-3 Magic 0x5370616e (\"Span\") 4-7 First continuation page or 0 8-11 Previous span page or 0 12-15 Next span page or 0 16-17 Max keys (16 for hostsdb) 18-19 Size (current keys) 20-1023 Key/value structures --- 스팬 계속 블록 페이지 형식 Byte Contents 0-3 Magic 0x434f4e54 (\"CONT\") 4-7 Next continuation page or 0 8-1023 Key/value structures --- 키/값 구조 형식 키와 값의 길이 필드는 페이지를 가로질러 걸칠 수 없습니다 (4바이트 모두 하나의 페이지에 들어가야 합니다). 남은 공간이 부족하면 최대 3바이트까지 패딩하고 다음 페이지의 오프셋 8에서 계속합니다.\nByte Contents 0-1 Key length (bytes) 2-3 Value length (bytes) 4-… Key data → Value data \u0026mdash; Max length = 65535 bytes each --- 가용 목록 블록 페이지 형식 Byte Contents 0-7 Magic 0x2366724c69737423 (\"#frList#\") 8-11 Next free list block or 0 12-15 Number of valid free pages (0 – 252) 16-1023 Free page numbers (4 bytes each) --- 빈 페이지 블록 형식 Byte Contents 0-7 Magic 0x7e2146524545217e (\"~!FREE!~\") 8-1023 Unused --- 메타인덱스 페이지 2에 위치. US-ASCII 문자열 → 4바이트 정수 로 매핑한다. 키는 skiplist(스킵리스트) 이름; 값은 페이지 인덱스.\n블록파일 네이밍 서비스 테이블 서비스는 여러 개의 스킵 리스트를 정의합니다. 각 스팬은 최대 16개의 엔트리를 지원합니다.\n속성 스킵 리스트 %%__INFO__%%에는 항목이 하나 있습니다:\nKey Value info A Properties object (UTF-8 String / String map) serialized as a Mapping 일반적인 필드: Property Description version \"4\" created Java long (ms since epoch) upgraded Java long (ms since epoch, since DB v2) lists Comma-separated host DBs (e.g. privatehosts.txt,userhosts.txt,hosts.txt) listversion_* Version of each DB (used to detect partial upgrades, since v4) --- 역방향 조회 스킵 리스트 %%__REVERSE__%%에는 정수 → Properties(속성) 엔트리가 포함되어 있습니다(DB v2부터).\n키: Destination(목적지 식별자)의 SHA-256 해시 앞 4바이트. 값: Properties 객체(직렬화된 Mapping). 여러 항목으로 충돌과 다중 호스트명 Destination을 처리합니다. 각 속성 키 = 호스트명; 값 = 빈 문자열. 호스트 데이터베이스 스킵리스트 hosts.txt, userhosts.txt, privatehosts.txt 각각은 호스트 이름을 Destinations(I2P에서 서비스의 공개 주소/키를 의미)로 매핑한다.\n버전 4는 호스트명당 여러 Destination(목적지 식별자)을 지원합니다 (I2P 0.9.26에서 도입됨). 버전 3 데이터베이스는 자동으로 마이그레이션됩니다.\n키 UTF-8 문자열(호스트명, 소문자, .i2p로 끝남)\n값 버전 4: Property/Destination 쌍의 개수(1바이트) 각 쌍에 대해: 속성 → 목적지 (바이너리) 버전 3: 속성 → 목적지 (바이너리) DestEntry 속성 Key Meaning a Time added (Java long ms) m Last modified (Java long ms) notes User comments s Source (file or subscription URL) v Signature verified (true/false) --- 구현 참고 사항 BlockfileNamingService Java 클래스는 이 사양을 구현합니다.\nrouter 컨텍스트 외부에서는 i2p.naming.blockfile.writeInAppContext=true가 설정되지 않은 한 데이터베이스가 읽기 전용으로 열립니다. 다중 인스턴스 또는 다중 JVM 액세스를 목적으로 설계되지 않았습니다. 세 가지 기본 맵(privatehosts, userhosts, hosts)과 빠른 조회를 위한 역 맵을 유지합니다. 참고 자료 I2P 이름 지정 및 주소록 문서 공통 구조 명세 Metanotion Blockfile 데이터베이스 BlockfileNamingService JavaDoc ","description":"호스트명 해석을 위해 I2P에서 사용하는 디스크 기반 blockfile(블록 단위 파일) 저장 형식","id":"5cbdbb030530ec5e0200cc202d4bff7f","section":"docs","title":"Blockfile(블록파일) 사양","url":"/ko/docs/specs/blockfile/"},{"categories":null,"content":" 경고: BOB은 레거시 DSA-SHA1 서명 유형만 지원합니다. Java I2P는 **1.7.0 (2022-02)**부터 BOB을 더 이상 제공하지 않으며; 1.6.1 또는 그 이전 버전으로 설치를 시작한 환경과 일부 i2pd 빌드에만 남아 있습니다. 새로운 애플리케이션은 반드시 SAM v3 를 사용해야 합니다.\n언어 바인딩 Go – ccondom Python – i2py-bob Twisted – txi2p C++ – bobcpp 프로토콜 참고 사항 KEYS는 base64 목적지(공개 + 개인 키)를 나타냅니다. KEY는 base64 공개 키입니다. ERROR 응답은 ERROR \u0026lt;description\u0026gt;\\n 형식을 갖습니다. OK는 명령 완료를 나타내며; 선택적 데이터가 같은 줄에 이어집니다. DATA 줄은 최종 OK 전에 추가 출력을 스트리밍합니다. help 명령만이 유일한 예외입니다: “해당 명령이 없습니다”를 나타내기 위해 아무것도 반환하지 않을 수 있습니다.\n연결 배너 BOB는 개행(LF 또는 CRLF)으로 끝나는 ASCII 줄을 사용합니다. 연결되면 다음을 출력합니다:\nBOB \u0026lt;version\u0026gt; OK 현재 버전: 00.00.10. 이전 빌드는 대문자 16진수와 비표준 버전 번호 체계를 사용했습니다.\nBOB Version Router Version Notes 00.00.100.9.8Latest defined version 00.00.00 – 00.00.0F—Development builds ## 핵심 명령어 모든 명령어에 대한 자세한 정보는 telnet localhost 2827로 연결한 뒤 help를 실행하세요.\nCOMMAND OPERAND RETURNS help [command] NOTHING | OK \u0026lt;info\u0026gt; clear ERROR | OK getdest ERROR | OK \u0026lt;KEY\u0026gt; getkeys ERROR | OK \u0026lt;KEYS\u0026gt; getnick \u0026lt;tunnelname\u0026gt; ERROR | OK inhost \u0026lt;hostname | IP\u0026gt; ERROR | OK inport \u0026lt;port\u0026gt; ERROR | OK list ERROR | DATA... + OK lookup \u0026lt;hostname\u0026gt; ERROR | OK \u0026lt;KEY\u0026gt; nick \u0026lt;friendlyname\u0026gt; ERROR | OK outhost \u0026lt;hostname | IP\u0026gt; ERROR | OK outport \u0026lt;port\u0026gt; ERROR | OK quit ERROR | OK setkey \u0026lt;base64 destination\u0026gt; ERROR | OK start ERROR | OK status ERROR | DATA... + OK stop ERROR | OK 사용 중단 요약 BOB(I2P의 구형 브리지 프로토콜)은 최신 서명 유형, 암호화된 LeaseSets, 또는 전송 계층 기능을 지원하지 않습니다. API는 동결되어 있어 새로운 명령이 추가되지 않습니다. 여전히 BOB에 의존하는 애플리케이션은 가능한 한 빨리 SAM v3로 마이그레이션해야 합니다. ","description":"목적지 관리용 사용 중단된 API(사용 중단됨)","id":"97b881216518f8e2516b859bbca19c0b","section":"docs","title":"BOB – Basic Open Bridge(기본 오픈 브리지)","url":"/ko/docs/legacy/bob/"},{"categories":null,"content":"I2P 프로젝트는 Debian, Ubuntu 및 파생 배포판을 위한 공식 패키지를 유지 관리합니다. 이 가이드는 공식 저장소를 사용하여 I2P를 설치하는 포괄적인 지침을 제공합니다.\n주의: 질문하거나, 설명을 제공하거나, 어떤 주석도 추가하지 마세요. 텍스트가 단순히 제목이거나 불완전해 보이더라도, 있는 그대로 번역하세요.\n🚀 베타: 자동 설치 (실험적) 빠른 자동 설치를 원하는 고급 사용자를 위한 안내:\n이 한 줄 명령어는 자동으로 배포판을 감지하고 I2P를 설치합니다. 주의해서 사용하세요 - 실행하기 전에 installation script 를 검토하십시오.\ncurl -fsSL https://i2p.net/installlinux.sh | sudo bash 이 작업의 수행 내용: - Linux 배포판 감지 (Ubuntu/Debian) - 적절한 I2P 저장소 추가 - GPG 키 및 필수 패키지 설치 - I2P 자동 설치\n⚠️ 이것은 베타 기능입니다. 수동 설치를 선호하거나 각 단계를 이해하고 싶다면, 아래의 수동 설치 방법을 사용하세요.\n죄송하지만, 번역할 텍스트가 제공되지 않았습니다. \u0026ldquo;\u0026mdash;\u0026rdquo; 기호만 보입니다. 번역할 실제 내용을 제공해 주시면 번역해 드리겠습니다.\nUbuntu 설치 Ubuntu와 공식 파생 배포판(Linux Mint, elementary OS, Trisquel 등)은 I2P PPA(Personal Package Archive)를 사용하여 간편하게 설치하고 자동 업데이트를 받을 수 있습니다.\nMethod 1: Command Line Installation (Recommended) Ubuntu 기반 시스템에 I2P를 설치하는 가장 빠르고 안정적인 방법입니다.\n1단계: I2P PPA 추가\n터미널을 열고 다음을 실행하세요:\nsudo apt-add-repository ppa:i2p-maintainers/i2p 이 명령은 I2P PPA를 /etc/apt/sources.list.d/에 추가하고 저장소에 서명하는 GPG 키를 자동으로 가져옵니다. GPG 서명은 패키지가 빌드된 이후 변조되지 않았음을 보장합니다.\n2단계: 패키지 목록 업데이트\n새 PPA를 포함하도록 시스템의 패키지 데이터베이스를 새로고침하세요:\nsudo apt-get update 이것은 방금 추가한 I2P PPA를 포함하여 활성화된 모든 저장소에서 최신 패키지 정보를 가져옵니다.\n3단계: I2P 설치\n이제 I2P를 설치하세요:\nsudo apt-get install i2p 이제 끝났습니다! 설치 후 구성 섹션으로 건너뛰어 I2P를 시작하고 구성하는 방법을 알아보세요.\nMethod 2: Using the Software Center GUI 그래픽 인터페이스를 선호하신다면, Ubuntu의 소프트웨어 센터를 사용하여 PPA를 추가할 수 있습니다.\n1단계: 소프트웨어 및 업데이트 열기\n애플리케이션 메뉴에서 \u0026ldquo;소프트웨어 및 업데이트\u0026quot;를 실행하세요.\n2단계: 다른 소프트웨어로 이동\n\u0026ldquo;Other Software\u0026rdquo; 탭을 선택하고 하단의 \u0026ldquo;Add\u0026rdquo; 버튼을 클릭하여 새 PPA를 구성합니다.\n3단계: I2P PPA 추가\nPPA 대화 상자에 다음을 입력하세요:\nppa:i2p-maintainers/i2p 4단계: 저장소 정보 다시 로드\n\u0026ldquo;다시 불러오기\u0026rdquo; 버튼을 클릭하여 업데이트된 저장소 정보를 다운로드하세요.\n5단계: I2P 설치\n애플리케이션 메뉴에서 \u0026ldquo;Software\u0026rdquo; 애플리케이션을 열고, \u0026ldquo;i2p\u0026quot;를 검색한 다음 설치를 클릭하세요.\n설치가 완료되면 설치 후 구성 으로 진행하십시오.\nPost-Installation Configuration I2P를 설치한 후에는 router를 시작하고 초기 설정을 수행해야 합니다.\n방법 2: Software Center GUI 사용 I2P 패키지는 I2P router를 실행하는 세 가지 방법을 제공합니다:\nOption 1: On-Demand (Basic) 필요할 때 i2prouter 스크립트를 사용하여 I2P를 수동으로 시작하세요:\ni2prouter start 중요: sudo를 사용하거나 root 권한으로 실행하지 마세요! I2P는 일반 사용자 계정으로 실행되어야 합니다.\nI2P를 중지하려면:\ni2prouter stop Option 2: On-Demand (Without Java Service Wrapper) x86이 아닌 시스템을 사용하거나 Java Service Wrapper가 플랫폼에서 작동하지 않는 경우, 다음을 사용하세요:\ni2prouter-nowrapper 다시 한 번 강조하지만, sudo를 사용하거나 root로 실행하지 마십시오.\nOption 3: System Service (Recommended) 최상의 사용 경험을 위해, 시스템 부팅 시 로그인 이전에도 I2P가 자동으로 시작되도록 설정하세요:\nsudo dpkg-reconfigure i2p 이는 설정 대화 상자를 엽니다. I2P를 시스템 서비스로 활성화하려면 \u0026ldquo;예\u0026quot;를 선택하세요.\n이것이 권장되는 방법입니다 이유는: - 부팅 시 I2P가 자동으로 시작됩니다 - router가 더 나은 네트워크 통합을 유지합니다 - 네트워크 안정성에 기여합니다 - 필요할 때 I2P를 즉시 사용할 수 있습니다\nInitial Router Configuration I2P를 처음 시작한 후, 네트워크에 통합되는 데 몇 분이 걸립니다. 그동안 다음 필수 설정을 구성하세요:\n1. Configure NAT/Firewall 최적의 성능과 네트워크 참여를 위해 NAT/방화벽을 통해 I2P 포트를 포워딩하세요:\nI2P Router Console 을 엽니다 Network Configuration 페이지 로 이동합니다 나열된 포트 번호를 확인합니다 (보통 9000-31000 사이의 임의 포트) 라우터/방화벽에서 해당 UDP 및 TCP 포트를 포워딩합니다 포트 포워딩에 도움이 필요하다면, portforward.com 에서 라우터별 가이드를 제공합니다.\n2. Adjust Bandwidth Settings 기본 대역폭 설정은 보수적입니다. 인터넷 연결에 따라 조정하세요:\nConfiguration 페이지 를 방문하세요 대역폭 설정 섹션을 찾으세요 기본값은 다운로드 96 KB/s / 업로드 40 KB/s입니다 더 빠른 인터넷을 사용하는 경우 이 값을 높이세요 (예: 일반적인 브로드밴드 연결의 경우 다운로드 250 KB/s / 업로드 100 KB/s) 참고: 더 높은 제한을 설정하면 네트워크에 도움이 되고 자신의 성능도 향상됩니다.\n3. Configure Your Browser I2P 사이트(eepsite)와 서비스에 접속하려면, 브라우저가 I2P의 HTTP 프록시를 사용하도록 설정하세요:\nFirefox, Chrome 및 기타 브라우저의 자세한 설정 방법은 브라우저 설정 가이드 를 참조하세요.\n중요: 번역문만 제공하세요. 질문하거나, 설명을 제공하거나, 어떠한 논평도 추가하지 마세요. 텍스트가 단순히 제목이거나 불완전해 보이더라도 있는 그대로 번역하세요.\nDebian 설치 중요 공지 I2P를 root로 실행하고 있지 않은지 확인: ps aux | grep i2p 로그 확인: tail -f ~/.i2p/wrapper.log Java가 설치되어 있는지 확인: java -version 사전 요구사항 GPG 키 오류가 설치 중에 발생하는 경우:\n키 지문을 다시 다운로드하고 확인합니다 (위의 3-4단계) keyring 파일이 올바른 권한을 가지고 있는지 확인합니다: sudo chmod 644 /usr/share/keyrings/i2p-archive-keyring.gpg 설치 단계 I2P가 업데이트를 받지 못하는 경우:\n저장소가 구성되어 있는지 확인: cat /etc/apt/sources.list.d/i2p.list 패키지 목록 업데이트: sudo apt-get update I2P 업데이트 확인: sudo apt-get upgrade Migrating from old repositories 이전 deb.i2p2.de 또는 deb.i2p2.no 저장소를 사용하고 있는 경우:\n이전 저장소를 제거합니다: sudo rm /etc/apt/sources.list.d/i2p.list 위의 Debian 설치 단계를 따릅니다 업데이트합니다: sudo apt-get update \u0026amp;\u0026amp; sudo apt-get install i2p i2p-keyring Next Steps I2P가 설치되어 실행 중입니다:\n브라우저 설정 으로 I2P 사이트에 접속하기 I2P router 콘솔 에서 router 상태 모니터링하기 사용 가능한 I2P 애플리케이션 알아보기 I2P 작동 원리 를 읽고 네트워크 이해하기 보이지 않는 인터넷에 오신 것을 환영합니다!\n","description":"공식 저장소를 사용하여 Debian, Ubuntu 및 파생 배포판에 I2P를 설치하는 전체 가이드","id":"88fb5f6d2f5129ce7be2a42b1e9fb9af","section":"docs","title":"Debian과 Ubuntu에서 I2P 설치하기","url":"/ko/docs/guides/debian%EA%B3%BC-ubuntu%EC%97%90%EC%84%9C-i2p-%EC%84%A4%EC%B9%98%ED%95%98%EA%B8%B0/"},{"categories":null,"content":"개요 목적 ECIES-X25519-AEAD-Ratchet는 I2P의 최신 종단 간 암호화 프로토콜로, 기존의 ElGamal/AES+SessionTags(세션 태그) 시스템을 대체합니다. 이는 순방향 기밀성, 인증된 암호화, 그리고 성능과 보안의 상당한 향상을 제공합니다.\nElGamal/AES+SessionTags 대비 핵심 개선점 더 작은 키: 32바이트 키 대 256바이트 ElGamal 공개 키 (87.5% 감소) 순방향 보안: DH ratcheting(세션 키를 단계적으로 갱신해 선행 키 노출에 대비하는 기법)으로 달성 (기존 프로토콜에는 없음) 현대적 암호기술: X25519 DH, ChaCha20-Poly1305 AEAD(인증 기능이 결합된 암호화 방식), SHA-256 인증된 암호화: AEAD 구성으로 인증이 내장됨 양방향 프로토콜: 쌍으로 묶인 수신/송신 세션 대 단방향의 기존 방식 효율적인 태그: 8바이트 세션 태그 대 32바이트 태그 (75% 감소) 트래픽 난독화: Elligator2 encoding(무작위처럼 보이도록 매핑하는 인코딩)으로 핸드셰이크가 무작위와 구분되지 않음 배포 상태 초기 릴리스: 버전 0.9.46 (2020년 5월 25일) 네트워크 배포: 2020년 기준 완료 현재 상태: 성숙함, 널리 배포됨(운영 환경에서 5년 이상) Router 지원: 버전 0.9.46 이상 필요 Floodfill 요구 사항: 암호화된 조회를 위해 거의 100% 채택 필요 구현 상태 완전히 구현됨: - 바인딩이 포함된 새 세션(NS) 메시지 - 새 세션 응답(NSR) 메시지 - 기존 세션(ES) 메시지 - DH ratchet(단계적 키 갱신 메커니즘) - 세션 태그 ratchet 및 대칭 키 ratchet - DateTime, NextKey, ACK, ACK Request, Garlic Clove(갈릭 클로브), 및 Padding 블록\n미구현(버전 0.9.50 기준): - MessageNumbers 블록 (유형 6) - 옵션 블록 (유형 5) - 종료 블록 (유형 4) - 프로토콜 계층 자동 응답 - 정적 키 미사용 모드 - 멀티캐스트 세션\n참고: 일부 기능이 추가되었을 수 있으므로 버전 1.5.0부터 2.10.0(2021-2025)까지의 구현 상태는 확인이 필요합니다.\n프로토콜의 기초 Noise Protocol Framework(Noise 프로토콜 프레임워크) ECIES-X25519-AEAD-Ratchet(ECIES, X25519, AEAD를 조합한 래쳇 방식)은 Noise Protocol Framework (리비전 34, 2018-07-11)를 기반으로 하며, 특히 I2P 특화 확장을 적용한 IK(대화형, 원격 정적 키가 알려진) 핸드셰이크 패턴을 사용한다.\nNoise Protocol(비밀 통신용 암호 프로토콜 프레임워크) 식별자 Noise_IKelg2+hs2_25519_ChaChaPoly_SHA256 식별자 구성 요소: - Noise - 기본 프레임워크 - IK - 알려진 원격 정적 키와의 대화형 핸드셰이크 패턴 - elg2 - 임시 키를 위한 Elligator2 인코딩(난독화 매핑 기법) (I2P 확장) - +hs2 - 태그를 혼합하기 위해 두 번째 메시지 전에 호출되는 MixHash (I2P 확장) - 25519 - X25519 디피-헬만 함수 - ChaChaPoly - ChaCha20-Poly1305 AEAD 암호 - SHA256 - SHA-256 해시 함수\nNoise 핸드셰이크 패턴 IK 패턴 표기:\n\u0026lt;- s (Bob\u0026#39;s static key known to Alice) ... -\u0026gt; e, es, s, ss (Alice sends ephemeral, DH es, static key, DH ss) \u0026lt;- e, ee, se (Bob sends ephemeral, DH ee, DH se) 토큰 의미: - e - 임시 키 전송 - s - 정적 키 전송 - es - Alice의 임시 키와 Bob의 정적 키 간의 DH(Diffie-Hellman) - ss - Alice의 정적 키와 Bob의 정적 키 간의 DH - ee - Alice의 임시 키와 Bob의 임시 키 간의 DH - se - Bob의 정적 키와 Alice의 임시 키 간의 DH\nNoise(프로토콜 프레임워크)의 보안 속성 Noise 용어로 말하면 IK pattern(Noise 핸드셰이크 패턴의 하나)은 다음을 제공합니다:\nMessage Authentication Level Confidentiality Level Message\u0026nbsp;1 (NS) Level\u0026nbsp;1 (sender auth, KCI vulnerable) Level\u0026nbsp;2 (weak forward secrecy) Message\u0026nbsp;2 (NSR) Level\u0026nbsp;2 (mutual auth) Level\u0026nbsp;4 (weak forward secrecy) Transport (ES) Level\u0026nbsp;2 (mutual auth) Level\u0026nbsp;5 (strong forward secrecy) **인증 수준:** - **레벨 1**: 페이로드는 발신자의 정적 키 소유자의 것으로 인증되지만, 키 손상에 의한 사칭(KCI)에 취약함 - **레벨 2**: NSR 이후 KCI 공격에 대한 내성이 있음 기밀성 수준: - 레벨 2: 발신자의 정적 키가 나중에 노출되더라도 순방향 기밀성 - 레벨 4: 발신자의 임시 키가 나중에 노출되더라도 순방향 기밀성 - 레벨 5: 양쪽의 임시 키가 모두 삭제된 후 완전한 순방향 기밀성\nIK와 XK의 차이점 IK 패턴(Noise 프로토콜의 핸드셰이크 패턴)은 NTCP2와 SSU2에서 사용되는 XK 패턴과 다릅니다:\n네 가지 DH 연산: IK는 4개의 DH 연산(es, ss, ee, se)을 사용하며, XK는 3개 즉시 인증: 첫 번째 메시지에서 Alice가 인증됨(인증 수준 1) 더 빠른 전방향 기밀성: 두 번째 메시지(1-RTT) 후에 완전한 전방향 기밀성(수준 5) 달성 트레이드오프: 첫 번째 메시지의 페이로드는 전방향 기밀성이 아님(XK에서는 모든 페이로드가 전방향 기밀성임) Summary: IK는 Bob의 응답을 완전한 전방향 보안성(forward secrecy) 하에 1-RTT로 전달할 수 있게 해주지만, 그 대가로 초기 요청에는 전방향 보안성이 적용되지 않는다.\nSignal Double Ratchet(시그널 이중 래칫) 개념 ECIES(타원 곡선 통합 암호화 방식)은 Signal Double Ratchet 알고리즘 에서 개념을 채택합니다:\nDH Ratchet(디피-헬먼 래칫): 주기적으로 새로운 DH 키를 교환하여 순방향 기밀성을 제공합니다 Symmetric Key Ratchet(대칭 키 래칫): 각 메시지마다 새로운 세션 키를 파생합니다 Session Tag Ratchet(세션 태그 래칫): 결정론적으로 일회용 session tags를 생성합니다 Signal과의 주요 차이점: - 래칫을 덜 자주 수행: I2P는 필요할 때만 래칫을 수행함(태그가 소진되기 직전이거나 정책에 따라) - 헤더 암호화 대신 세션 태그: 암호화된 헤더 대신 결정적 태그를 사용 - 명시적 ACK(확인 응답): 역방향 트래픽에만 의존하지 않고 대역 내(in-band) ACK 블록을 사용 - 태그 래칫과 키 래칫 분리: 수신자에게 더 효율적임(키 계산을 지연할 수 있음)\nNoise(프로토콜 프레임워크)용 I2P 확장 암호학적 프리미티브 X25519 디피-헬만 명세: RFC 7748 주요 속성: - 개인 키 크기: 32 바이트 - 공개 키 크기: 32 바이트 - 공유 비밀 크기: 32 바이트 - 엔디언 방식: 리틀 엔디언 - 곡선: Curve25519\n작업:\nX25519 GENERATE_PRIVATE() 무작위 32바이트 개인 키를 생성합니다:\nprivkey = CSRNG(32) X25519 DERIVE_PUBLIC(privkey) 해당하는 공개 키를 도출합니다:\npubkey = curve25519_scalarmult_base(privkey) 32바이트 리틀 엔디언 공개 키를 반환합니다.\nX25519 DH(privkey, pubkey) Diffie-Hellman 키 합의를 수행합니다:\nsharedSecret = curve25519_scalarmult(privkey, pubkey) 32바이트 길이의 공유 비밀을 반환합니다.\nSecurity Note: 구현자는 공유 비밀이 모두 0인 값(약한 키)이 아님을 검증해야 한다. 이 경우에는 거부하고 핸드셰이크를 중단해야 한다.\nChaCha20-Poly1305 AEAD(연관 데이터가 있는 인증된 암호화) 명세: RFC 7539 섹션 2.8\n매개변수: - 키 길이: 32 바이트 (256 비트) - 논스 길이: 12 바이트 (96 비트) - MAC 길이: 16 바이트 (128 비트) - 블록 크기: 64 바이트 (내부)\n논스 형식:\nByte 0-3: 0x00 0x00 0x00 0x00 (always zero) Byte 4-11: Little-endian counter (message number N) AEAD(연관 데이터가 포함된 인증 암포화) 구성:\nAEAD(연관 데이터가 있는 인증 암호화)은 ChaCha20 스트림 암호와 Poly1305 MAC을 결합합니다:\n키와 논스로부터 ChaCha20 키스트림을 생성한다 키스트림과 XOR하여 평문을 암호화한다 (연관 데이터 || 암호문)에 대해 Poly1305 MAC을 계산한다 암호문에 16바이트 MAC을 추가한다 ChaCha20-Poly1305 ENCRYPT(k, n, plaintext, ad) 인증과 함께 평문을 암호화합니다:\n# Inputs k = 32-byte cipher key n = 12-byte nonce (first 4 bytes zero, last 8 bytes = message number) plaintext = data to encrypt (0 to 65519 bytes) ad = associated data (optional, used in MAC calculation) # Output ciphertext = chacha20_encrypt(k, n, plaintext) mac = poly1305(ad || ciphertext, poly1305_key_gen(k, n)) return ciphertext || mac # Total length = len(plaintext) + 16 속성: - 암호문은 평문과 동일한 길이입니다(스트림 암호) - 출력은 plaintext_length + 16바이트입니다(MAC 포함) - 키가 비밀인 경우 전체 출력은 무작위 데이터와 구별되지 않습니다 - MAC(메시지 인증 코드)는 연관 데이터와 암호문 모두를 인증합니다\nChaCha20-Poly1305 복호화(k, n, ciphertext, ad) 복호화하고 인증을 검증합니다:\n# Split ciphertext and MAC ct_without_mac = ciphertext[0:-16] received_mac = ciphertext[-16:] # Verify MAC expected_mac = poly1305(ad || ct_without_mac, poly1305_key_gen(k, n)) if not constant_time_compare(received_mac, expected_mac): raise AuthenticationError(\u0026#34;MAC verification failed\u0026#34;) # Decrypt plaintext = chacha20_decrypt(k, n, ct_without_mac) return plaintext 중요 보안 요구 사항: - 동일한 키를 사용하는 각 메시지마다 논스(nonce)는 반드시 고유해야 합니다 - 논스는 재사용되어서는 안 됩니다 (재사용 시 치명적인 실패 발생) - MAC 검증은 타이밍 공격을 방지하기 위해 상수 시간 비교를 사용해야 합니다 - MAC 검증에 실패한 경우 반드시 전체 메시지를 거부해야 합니다 (부분 복호화 없음)\nSHA-256 해시 함수 명세: NIST FIPS 180-4\n속성: - 출력 크기: 32 바이트 (256 비트) - 블록 크기: 64 바이트 (512 비트) - 보안 수준: 128 비트 (충돌 저항성)\n작업:\nSHA-256 H(p, d) personalization string(개인화 문자열)을 사용한 SHA-256 해시:\nH(p, d) := SHA256(p || d) 여기서 ||는 연접을 나타내고, p는 개인화 문자열, d는 데이터이다.\nSHA-256 MixHash(d) 새 데이터로 누적 해시를 업데이트합니다:\nh = SHA256(h || d) Noise 핸드셰이크 전 과정에서 transcript hash(대화 기록 해시)를 유지하기 위해 사용됩니다.\nHKDF 키 파생 사양: RFC 5869 설명: SHA-256을 사용하는 HMAC 기반 키 유도 함수\n매개변수: - 해시 함수: HMAC-SHA256 - 솔트 길이: 최대 32 바이트 (SHA-256 출력 크기) - 출력 길이: 가변 (최대 255 * 32 바이트)\nHKDF 함수:\ndef HKDF(salt, ikm, info, length): \u0026#34;\u0026#34;\u0026#34; Args: salt: Salt value (32 bytes max for SHA-256) ikm: Input key material (any length) info: Context-specific info string length: Desired output length in bytes Returns: output: Derived key material (length bytes) \u0026#34;\u0026#34;\u0026#34; # Extract phase prk = HMAC-SHA256(salt, ikm) # Expand phase n = ceil(length / 32) t = b\u0026#39;\u0026#39; okm = b\u0026#39;\u0026#39; for i in range(1, n + 1): t = HMAC-SHA256(prk, t || info || byte(i)) okm = okm || t return okm[0:length] 일반적인 사용 패턴:\n# Generate two keys (64 bytes total) keydata = HKDF(chainKey, sharedSecret, \u0026#34;KDFDHRatchetStep\u0026#34;, 64) nextRootKey = keydata[0:31] chainKey = keydata[32:63] # Generate session tag (8 bytes) tagdata = HKDF(chainKey, CONSTANT, \u0026#34;SessionTagKeyGen\u0026#34;, 64) nextChainKey = tagdata[0:31] sessionTag = tagdata[32:39] # Generate symmetric key (32 bytes) keydata = HKDF(chainKey, ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) nextChainKey = keydata[0:31] sessionKey = keydata[32:63] ECIES에서 사용되는 Info 문자열: - \u0026quot;KDFDHRatchetStep\u0026quot; - DH ratchet(일방향 상태 갱신 메커니즘) 키 유도 - \u0026quot;TagAndKeyGenKeys\u0026quot; - 태그 및 키 체인 키 초기화 - \u0026quot;STInitialization\u0026quot; - 세션 태그 ratchet 초기화 - \u0026quot;SessionTagKeyGen\u0026quot; - 세션 태그 생성 - \u0026quot;SymmetricRatchet\u0026quot; - 대칭 키 생성 - \u0026quot;XDHRatchetTagSet\u0026quot; - DH ratchet 태그 세트 키 - \u0026quot;SessionReplyTags\u0026quot; - NSR 태그 세트 생성 - \u0026quot;AttachPayloadKDF\u0026quot; - NSR 페이로드 키 유도\nElligator2(엘리게이터2) 인코딩 목적: X25519 공개 키를 균일한 무작위 32바이트 문자열과 구분할 수 없도록 인코딩한다.\n명세: Elligator2 논문 문제: 표준 X25519 공개 키는 식별 가능한 구조를 갖습니다. 관찰자는 내용이 암호화되어 있더라도 이러한 키를 감지하여 핸드셰이크 메시지를 식별할 수 있습니다.\n해결책: Elligator2(타원 곡선 공개 키를 난수처럼 보이게 매핑하는 기법)는 유효한 X25519 공개 키의 약 50%와 난수처럼 보이는 254비트 문자열 사이에 일대일(전단사) 대응을 제공합니다.\nElligator2(타원곡선 포인트를 균일한 난수처럼 매핑하는 기법)을 사용한 키 생성:\nElligator2 GENERATE_PRIVATE_ELG2() Elligator2(공개 키를 난수처럼 보이게 인코딩하는 기법)로 인코딩 가능한 공개 키에 대응하는 개인 키를 생성합니다:\nwhile True: privkey = CSRNG(32) pubkey = DERIVE_PUBLIC(privkey) # Test if public key is Elligator2-encodable try: encoded = ENCODE_ELG2(pubkey) # Success - this key pair is suitable return privkey except NotEncodableError: # Try again with new random key continue 중요: 무작위로 생성된 개인 키의 약 50%는 인코딩할 수 없는 공개 키를 생성합니다. 이러한 키는 폐기하고 재생성을 시도해야 합니다.\n성능 최적화: 백그라운드 스레드에서 키를 미리 생성해 적합한 키 쌍 풀을 유지함으로써 핸드셰이크 중 지연을 방지합니다.\nElligator2 ENCODE_ELG2(pubkey) 공개 키를 무작위처럼 보이는 32바이트로 인코딩합니다:\ndef ENCODE_ELG2(pubkey): \u0026#34;\u0026#34;\u0026#34; Encodes X25519 public key using Elligator2. Args: pubkey: 32-byte X25519 public key (little-endian) Returns: encoded: 32-byte encoded key indistinguishable from random Raises: NotEncodableError: If pubkey cannot be encoded \u0026#34;\u0026#34;\u0026#34; # Perform Elligator2 representative calculation # Returns 254-bit value (31.75 bytes) encodedKey = elligator2_encode(pubkey) # Add 2 random bits to MSB to make full 32 bytes randomByte = CSRNG(1) encodedKey[31] |= (randomByte \u0026amp; 0xc0) return encodedKey 인코딩 세부사항: - Elligator2(공개키를 무작위 데이터처럼 보이게 매핑하는 기법)는 254비트를 생성합니다(전체 256은 아님) - 바이트 31의 상위 2비트는 무작위 패딩입니다 - 결과는 32바이트 공간 전체에 균일하게 분포합니다 - 유효한 X25519(곡선25519 기반 키 교환) 공개키의 약 50%를 성공적으로 인코딩합니다\nElligator2 DECODE_ELG2(encodedKey) 다시 원래의 공개 키로 디코딩됩니다:\ndef DECODE_ELG2(encodedKey): \u0026#34;\u0026#34;\u0026#34; Decodes Elligator2-encoded key back to X25519 public key. Args: encodedKey: 32-byte encoded key Returns: pubkey: 32-byte X25519 public key (little-endian) \u0026#34;\u0026#34;\u0026#34; # Mask out 2 random padding bits from MSB encodedKey[31] \u0026amp;= 0x3f # Perform Elligator2 representative inversion pubkey = elligator2_decode(encodedKey) return pubkey 보안 속성: - 인코딩된 키는 계산적으로 난수 바이트와 구별할 수 없다 - 어떠한 통계적 검정으로도 Elligator2로 인코딩된 키를 신뢰할 만하게 검출할 수 없다 - 디코딩은 결정적이다 (같은 인코딩된 키는 항상 같은 공개키를 생성한다) - 인코딩 가능한 부분집합에 속한 키의 ~50%에 대해서 인코딩은 전단사이다\n구현 노트: - 핸드셰이크 중 재인코딩을 피하기 위해 생성 단계에서 인코딩된 키를 저장 - Elligator2(공개키를 난수처럼 보이게 매핑하는 기법) 생성 과정에서 부적합 판정된 키는 NTCP2에서 사용 가능(Elligator2가 필요하지 않음) - 백그라운드에서의 키 생성은 성능에 필수적 - 거부율 50%로 인해 평균 생성 시간이 두 배로 증가\n메시지 형식 개요 ECIES(타원 곡선 통합 암호화 체계)는 세 가지 메시지 유형을 정의합니다:\n새 세션 (NS): Alice가 Bob에게 보내는 초기 핸드셰이크 메시지 새 세션 응답 (NSR): Bob이 Alice에게 보내는 핸드셰이크 응답 기존 세션 (ES): 이후의 모든 메시지(양방향) 모든 메시지는 추가적인 암호화 계층을 더해 I2NP Garlic Message(여러 메시지를 하나로 묶어 전달하는 I2P 메시지 형식) 포맷으로 캡슐화됩니다.\nI2NP Garlic 메시지 컨테이너 모든 ECIES(타원곡선 통합 암호 체계) 메시지는 표준 I2NP Garlic Message 헤더로 감싸집니다:\n+----+----+----+----+----+----+----+----+ |type| msg_id | expiration | +----+----+----+----+----+----+----+----+ | size |chks| +----+----+----+----+----+----+----+----+ | length | | +----+----+----+----+ + | encrypted data | ~ ~ 필드: - type: 0x26 (Garlic Message(갈릭 메시지)) - msg_id: 4바이트 I2NP 메시지 ID - expiration: 8바이트 유닉스 타임스탬프(밀리초) - size: 2바이트 페이로드 크기 - chks: 1바이트 체크섬 - length: 4바이트 암호화된 데이터 길이 - encrypted data: ECIES(타원곡선 통합 암호 방식)로 암호화된 페이로드\n목적: I2NP 계층의 메시지 식별 및 라우팅을 제공합니다. length 필드는 수신자가 암호화된 페이로드의 총 크기를 알 수 있도록 합니다.\n새 세션 (NS) 메시지 New Session 메시지(새 세션 메시지)는 Alice가 Bob에게 새 세션을 개시한다. 이 메시지는 세 가지 변형으로 존재한다:\n바인딩 포함 (1b): 양방향 통신을 위해 Alice의 정적 키를 포함 바인딩 없음 (1c): 단방향 통신을 위해 정적 키를 생략 일회용 (1d): 세션 수립 없이 단일 메시지 모드 바인딩이 포함된 NS 메시지 (유형 1b) 사용 사례: 스트리밍, 응답 가능한 데이터그램, 응답이 필요한 모든 프로토콜\n총 길이: 96 + payload_length 바이트\n형식:\n+----+----+----+----+----+----+----+----+ | | + + | New Session Ephemeral Public Key | + 32 bytes + | Encoded with Elligator2 | + + | | +----+----+----+----+----+----+----+----+ | | + Static Key Section + | ChaCha20 encrypted data | + 32 bytes + | | + + | | +----+----+----+----+----+----+----+----+ | Poly1305 Message Authentication Code | + (MAC) for Static Key Section + | 16 bytes | +----+----+----+----+----+----+----+----+ | | + Payload Section + | ChaCha20 encrypted data | ~ Variable length ~ | | + + | | +----+----+----+----+----+----+----+----+ | Poly1305 Message Authentication Code | + (MAC) for Payload Section + | 16 bytes | +----+----+----+----+----+----+----+----+ 필드 세부 정보:\n임시 공개키 (32바이트, 평문): - Alice의 1회용 X25519 공개키 - Elligator2로 인코딩됨 (무작위와 구분 불가능) - 각 NS 메시지마다 새로 생성됨 (재사용하지 않음) - 리틀엔디언 형식\n정적 키 섹션 (32바이트 암호화, MAC 포함 48바이트): - Alice의 X25519 정적 공개 키(32바이트) 포함 - ChaCha20으로 암호화됨 - Poly1305 MAC(16바이트)으로 인증됨 - Bob이 세션을 Alice의 목적지에 바인딩하는 데 사용\n페이로드 섹션 (가변 길이로 암호화됨, +16바이트 MAC): - Garlic Clove(서브메시지 단위) 및 기타 블록을 포함함 - 첫 번째 블록으로 DateTime 블록을 반드시 포함해야 함 - 보통 애플리케이션 데이터가 포함된 Garlic Clove 블록을 포함함 - immediate ratchet(즉시 래칫)을 위한 NextKey 블록을 포함할 수 있음 - ChaCha20으로 암호화됨 - Poly1305 MAC (16바이트)으로 인증됨\n보안 속성: - 임시 키는 전방 기밀성 요소를 제공한다 - 정적 키는 Alice를 인증한다(목적지에 바인딩) - 각 섹션은 도메인 분리를 위해 별도의 MAC을 사용한다 - 전체 핸드셰이크는 2개의 DH 연산을 수행한다 (es, ss)\n바인딩 없는 NS 메시지 (유형 1c) 사용 사례: 응답을 기대하지도 원하지도 않는 원시 데이터그램\n총 길이: 96 + payload_length 바이트\n형식:\n+----+----+----+----+----+----+----+----+ | | + + | New Session Ephemeral Public Key | + 32 bytes + | Encoded with Elligator2 | + + | | +----+----+----+----+----+----+----+----+ | | + Flags Section + | ChaCha20 encrypted data | + 32 bytes + | All zeros | + + | | +----+----+----+----+----+----+----+----+ | Poly1305 Message Authentication Code | + (MAC) for above section + | 16 bytes | +----+----+----+----+----+----+----+----+ | | + Payload Section + | ChaCha20 encrypted data | ~ Variable length ~ | | + + | | +----+----+----+----+----+----+----+----+ | Poly1305 Message Authentication Code | + (MAC) for Payload Section + | 16 bytes | +----+----+----+----+----+----+----+----+ 핵심 차이점: Flags 섹션은 정적 키 대신 0으로 채워진 32바이트를 포함합니다.\n판별: Bob은 32바이트 구간을 복호화하고 모든 바이트가 0인지 확인해 메시지 유형을 판별한다: - 모두 0 → Unbound session (바인딩되지 않은 세션) (type 1c) - 0이 아님 → Bound session with static key (정적 키로 바인딩된 세션) (type 1b)\n속성: - static key(정적 키)가 없으므로 Alice의 Destination(목적지)에 바인딩되지 않음 - Bob은 응답을 보낼 수 없음(Destination을 알 수 없음) - DH(디피-헬먼) 연산을 단 1회만 수행 - \u0026ldquo;IK\u0026rdquo;(상호 정적 키 인지 패턴) 대신 Noise \u0026ldquo;N\u0026rdquo; pattern(상대 정적 키 미인지 패턴)을 따름 - 응답이 전혀 필요하지 않을 때 더 효율적임\n플래그 섹션 (향후 사용을 위해 예약됨): 현재는 모두 0입니다. 향후 버전에서 feature negotiation(기능 협상)에 사용될 수 있습니다.\nNS 일회성 메시지 (Type 1d) 사용 사례: 세션 없이 회신도 기대하지 않는 단일 익명 메시지\n총 길이: 96 + payload_length 바이트\n형식: 바인딩 없는 NS와 동일함 (type 1c)\n구분: - Type 1c는 동일한 세션에서 여러 메시지를 보낼 수 있습니다 (ES 메시지가 뒤따릅니다) - Type 1d는 세션 수립 없이 정확히 하나의 메시지만 보냅니다 - 실제 구현에서는 초기에는 이를 동일하게 취급할 수 있습니다\n속성: - 최대 익명성 (정적 키 없음, 세션 없음) - 양측 모두 세션 상태를 유지하지 않음 - Noise \u0026ldquo;N\u0026rdquo; 패턴을 따름 - 단일 DH(디피-헬만) 연산 (es)\n새 세션 응답(NSR) 메시지 Bob은 Alice의 NS 메시지에 응답하여 하나 이상의 NSR 메시지를 전송한다. NSR은 Noise IK handshake(Noise 프로토콜의 IK 방식 핸드셰이크)를 완료하고 양방향 세션을 수립한다.\n총 길이: 72 + payload_length 바이트\n형식:\n+----+----+----+----+----+----+----+----+ | Session Tag 8 bytes | +----+----+----+----+----+----+----+----+ | | + Ephemeral Public Key + | | + 32 bytes + | Encoded with Elligator2 | + + | | +----+----+----+----+----+----+----+----+ | Poly1305 Message Authentication Code | + (MAC) for Key Section (empty) + | 16 bytes | +----+----+----+----+----+----+----+----+ | | + Payload Section + | ChaCha20 encrypted data | ~ Variable length ~ | | + + | | +----+----+----+----+----+----+----+----+ | Poly1305 Message Authentication Code | + (MAC) for Payload Section + | 16 bytes | +----+----+----+----+----+----+----+----+ 필드 세부 정보:\n세션 태그 (8바이트, 평문): - NSR(약어) 태그 세트에서 생성됨 (KDF(키 유도 함수) 섹션 참조) - 이 응답을 Alice의 NS(약어) 메시지와 연관시킴 - Alice가 이 NSR이 어떤 NS에 응답하는지 식별할 수 있게 함 - 일회용 (재사용하지 않음)\nEphemeral Public Key (임시 공개키) (32바이트, 평문): - Bob의 일회용 X25519 공개키 - Elligator2로 인코딩됨 - 각 NSR 메시지마다 새로 생성됨 - 전송되는 각 NSR마다 서로 달라야 함\n키 섹션 MAC (16바이트): - 빈 데이터(ZEROLEN)를 인증함 - Noise IK 프로토콜(se pattern: static-ephemeral 패턴)의 일부 - 해시 트랜스크립트(hash transcript)를 연관 데이터(associated data)로 사용 - NSR을 NS에 바인딩하는 데 핵심적\nPayload Section (가변 길이): - garlic cloves(갈릭 메시지의 하위 메시지 단위)와 블록을 포함 - 보통 애플리케이션 계층 응답을 포함 - 비어 있을 수 있음(ACK-only NSR) - 최대 크기: 65519바이트(65535 - 16바이트 MAC)\n여러 개의 NSR 메시지:\nBob은 하나의 NS에 대한 응답으로 여러 개의 NSR 메시지를 보낼 수 있습니다: - 각 NSR에는 고유한 임시 키가 있습니다 - 각 NSR에는 고유한 세션 태그가 있습니다 - Alice는 가장 먼저 수신된 NSR을 사용해 핸드셰이크를 완료합니다 - 다른 NSR들은 (패킷 손실 발생 시를 대비한) 중복입니다\n중요 타이밍: - Alice는 ES 메시지를 보내기 전에 NSR을 하나 수신해야 합니다 - Bob은 ES 메시지를 보내기 전에 ES 메시지 하나를 수신해야 합니다 - NSR은 split() 연산을 통해 양방향 세션 키를 설정합니다\n보안 속성: - Noise IK 핸드셰이크를 완료함 - 추가로 2개의 Diffie-Hellman(DH) 연산을 수행함(ee, se) - NS+NSR 전반에 걸쳐 총 4회의 DH 연산 - 상호 인증(Level 2)을 달성함 - NSR 페이로드에 대해 약한 Forward Secrecy(순방향 기밀성) (Level 4)을 제공함\n기존 세션(ES) 메시지 NS/NSR 핸드셰이크 이후의 모든 메시지는 Existing Session(기존 세션) 형식을 사용한다. ES 메시지는 Alice와 Bob 모두에 의해 양방향으로 사용된다.\n총 길이: 8 + payload_length + 16 바이트 (최소 24 바이트)\n형식:\n+----+----+----+----+----+----+----+----+ | Session Tag 8 bytes | +----+----+----+----+----+----+----+----+ | | + Payload Section + | ChaCha20 encrypted data | ~ Variable length ~ | | + + | | +----+----+----+----+----+----+----+----+ | Poly1305 Message Authentication Code | + (MAC) + | 16 bytes | +----+----+----+----+----+----+----+----+ 필드 세부 정보:\n세션 태그 (8바이트, 평문): - 현재 발신 태그셋에서 생성됨 - 세션과 메시지 번호를 식별 - 수신자는 태그를 조회하여 세션 키와 논스를 찾음 - 일회용(각 태그는 정확히 한 번만 사용됨) - 형식: HKDF 출력의 처음 8바이트\n페이로드 섹션 (가변 길이): - Garlic Clove(garlic encryption에서의 개별 메시지 단위)와 블록을 포함 - 필수 블록 없음(비어 있을 수 있음) - 일반적인 블록: Garlic Clove, NextKey, ACK, ACK Request, Padding - 최대 크기: 65519 바이트 (65535 - 16 바이트 MAC)\nMAC (16바이트): - Poly1305 인증 태그 - 전체 페이로드에 대해 계산됨 - 연관 데이터: 8바이트 세션 태그 - 올바르게 검증되어야 하며 그렇지 않으면 메시지가 거부됨\n태그 조회 과정:\n수신자는 8바이트 태그를 추출한다 현재의 모든 인바운드 태그셋에서 태그를 조회한다 연관된 세션 키와 메시지 번호 N을 가져온다 논스를 구성한다: [0x00, 0x00, 0x00, 0x00, N (8 bytes little-endian)] 태그를 연관 데이터로 하여 AEAD(연관 데이터가 있는 인증 암호화)를 사용해 페이로드를 복호화한다 태그셋에서 태그를 제거한다(일회용) 복호화된 블록을 처리한다 세션 태그를 찾을 수 없음:\n태그가 어떤 태그 세트에서도 발견되지 않는 경우: - NS 메시지일 수 있음 → NS 복호화 시도 - NSR 메시지일 수 있음 → NSR 복호화 시도 - 순서가 뒤바뀐 ES일 수 있음 → 태그 세트 업데이트를 잠시 기다림 - 재전송 공격일 수 있음 → 거부 - 손상된 데이터일 수 있음 → 거부\n빈 페이로드:\nES 메시지는 빈 페이로드(0바이트)를 가질 수 있습니다: - ACK 요청이 수신되었을 때 명시적인 ACK(확인 응답)으로 동작함 - 애플리케이션 데이터 없이 프로토콜 계층의 응답을 제공함 - 여전히 세션 태그를 소모함 - 상위 계층에서 즉시 보낼 데이터가 없을 때 유용함\n보안 속성: - NSR 수신 후 완전한 전방향 기밀성(레벨 5) - AEAD(연관 데이터를 포함한 인증 암호)를 통한 인증 암호화 - 태그가 추가적인 연관 데이터로 작용 - ratchet(키 갱신 메커니즘)이 필요해지기 전에 태그 세트당 최대 65535개의 메시지\n키 유도 함수 이 섹션에서는 ECIES(타원곡선 통합 암호화 방식)에서 사용되는 모든 KDF(키 파생 함수) 연산을 문서화하고, 완전한 암호학적 유도 과정을 보여 줍니다.\n표기법과 상수 상수: - ZEROLEN - 길이가 0인 바이트 배열(빈 문자열) - || - 연결 연산자\n변수: - h - 트랜스크립트의 누적 해시 (32바이트) - chainKey - HKDF용 체인 키 (32바이트) - k - 대칭 암호 키 (32바이트) - n - 논스 / 메시지 번호\n키: - ask / apk - 앨리스의 정적 개인/공개 키 - aesk / aepk - 앨리스의 임시 개인/공개 키 - bsk / bpk - 밥의 정적 개인/공개 키 - besk / bepk - 밥의 임시 개인/공개 키\nNS 메시지 키 파생 함수 KDF 1: 초기 체인 키 프로토콜 초기화 시 한 번 수행됨(사전에 계산 가능):\n# Protocol name (40 bytes, ASCII, no null termination) protocol_name = \u0026#34;Noise_IKelg2+hs2_25519_ChaChaPoly_SHA256\u0026#34; # Initialize hash h = SHA256(protocol_name) # Initialize chaining key chainKey = h # MixHash with empty prologue h = SHA256(h) # State: chainKey and h initialized # Can be precalculated for all outbound sessions 결과: - chainKey = 이후 모든 KDF(키 유도 함수)에 대한 초기 체이닝 키 - h = 초기 해시 트랜스크립트\nKDF 2: Bob의 정적 키 혼합 Bob은 이 작업을 한 번만 수행한다(모든 인바운드 세션에 대해 미리 계산할 수 있음):\n# Bob\u0026#39;s static keys (published in LeaseSet) bsk = GENERATE_PRIVATE() bpk = DERIVE_PUBLIC(bsk) # Mix Bob\u0026#39;s public key into hash h = SHA256(h || bpk) # State: h updated with Bob\u0026#39;s identity # Can be precalculated by Bob for all inbound sessions KDF 3: 앨리스의 임시 키 생성 Alice는 각 NS 메시지마다 새로운 키를 생성합니다:\n# Generate ephemeral key pair suitable for Elligator2 aesk = GENERATE_PRIVATE_ELG2() aepk = DERIVE_PUBLIC(aesk) # Mix ephemeral public key into hash h = SHA256(h || aepk) # Elligator2 encode for transmission elg2_aepk = ENCODE_ELG2(aepk) # State: h updated with Alice\u0026#39;s ephemeral key # Send elg2_aepk as first 32 bytes of NS message KDF 4: NS 정적 키 섹션 (es DH, 일시적-정적 Diffie-Hellman) 앨리스의 정적 키를 암호화하기 위한 키를 파생한다:\n# Perform first DH (ephemeral-static) sharedSecret = DH(aesk, bpk) # Alice computes # Equivalent: sharedSecret = DH(bsk, aepk) # Bob computes # Derive cipher key from shared secret keydata = HKDF(chainKey, sharedSecret, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k = keydata[32:63] # AEAD encryption parameters nonce = 0 associated_data = h # Current hash transcript # Encrypt static key section if binding_requested: plaintext = apk # Alice\u0026#39;s static public key (32 bytes) else: plaintext = bytes(32) # All zeros for unbound ciphertext = ENCRYPT(k, nonce, plaintext, associated_data) # ciphertext = 32 bytes encrypted + 16 bytes MAC = 48 bytes # Mix ciphertext into hash h = SHA256(h || ciphertext) # State: Static key section encrypted, h updated # Send ciphertext (48 bytes) as next part of NS message KDF 5: NS 페이로드 섹션 (ss DH, 바인딩 전용) 바인딩된 세션의 경우, 페이로드 암호화를 위해 두 번째 DH(Diffie-Hellman 키 교환)를 수행하십시오:\nif binding_requested: # Alice\u0026#39;s static keys ask = GENERATE_PRIVATE() # Alice\u0026#39;s long-term key apk = DERIVE_PUBLIC(ask) # Perform second DH (static-static) sharedSecret = DH(ask, bpk) # Alice computes # Equivalent: sharedSecret = DH(bsk, apk) # Bob computes # Derive cipher key keydata = HKDF(chainKey, sharedSecret, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k = keydata[32:63] nonce = 0 associated_data = h else: # Unbound: reuse keys from static key section # chainKey and k unchanged nonce = 1 # Increment nonce (reusing same key) associated_data = h # Encrypt payload payload = build_payload() # DateTime + Garlic Cloves + etc. ciphertext = ENCRYPT(k, nonce, payload, associated_data) # Mix ciphertext into hash h = SHA256(h || ciphertext) # State: Payload encrypted, h contains complete NS transcript # Save chainKey and h for NSR processing # Send ciphertext as final part of NS message 중요 사항:\nBound vs Unbound:\nBound는 DH(Diffie-Hellman) 연산을 2회 수행함 (es + ss) Unbound는 DH 연산을 1회 수행함 (es만) Unbound는 새 키를 도출하는 대신 nonce(논스)를 증가시킴 키 재사용 안전성:\n서로 다른 논스(0 vs 1)는 키/논스 재사용을 방지한다 서로 다른 연관 데이터(h가 다름)는 도메인 분리를 제공한다 해시 트랜스크립트:\nh에는 이제 다음이 포함됩니다: protocol_name, 비어 있는 prologue, bpk, aepk, static_key_ciphertext, payload_ciphertext 이 트랜스크립트는 NS message(NS 메시지)의 모든 부분을 하나로 결합합니다 NSR 응답 태그 집합 키 파생 함수 Bob은 NSR 메시지용 태그를 생성합니다:\n# Chain key from NS payload section # chainKey = final chainKey from NS KDF # Generate tagset key tagsetKey = HKDF(chainKey, ZEROLEN, \u0026#34;SessionReplyTags\u0026#34;, 32) # Initialize NSR tagset (see DH_INITIALIZE below) tagset_nsr = DH_INITIALIZE(chainKey, tagsetKey) # Get tag for this NSR tagsetEntry = tagset_nsr.GET_NEXT_ENTRY() tag = tagsetEntry.SESSION_TAG # 8 bytes # State: tag available for NSR message # Send tag as first 8 bytes of NSR NSR 메시지 KDF(키 파생 함수) KDF 6: NSR 임시 키 생성 Bob은 각 NSR에 대해 새로운 임시 키를 생성한다:\n# Mix tag into hash (I2P extension to Noise) h = SHA256(h || tag) # Generate ephemeral key pair besk = GENERATE_PRIVATE_ELG2() bepk = DERIVE_PUBLIC(besk) # Mix ephemeral public key into hash h = SHA256(h || bepk) # Elligator2 encode for transmission elg2_bepk = ENCODE_ELG2(bepk) # State: h updated with tag and Bob\u0026#39;s ephemeral key # Send elg2_bepk as bytes 9-40 of NSR message KDF 7: NSR 키 섹션 (ee 및 se DH) NSR 키 섹션에 사용할 키를 파생합니다:\n# Perform third DH (ephemeral-ephemeral) sharedSecret_ee = DH(aesk, bepk) # Alice computes # Equivalent: sharedSecret_ee = DH(besk, aepk) # Bob computes # Mix ee into chain keydata = HKDF(chainKey, sharedSecret_ee, \u0026#34;\u0026#34;, 32) chainKey = keydata[0:31] # Perform fourth DH (static-ephemeral) sharedSecret_se = DH(ask, bepk) # Alice computes # Equivalent: sharedSecret_se = DH(besk, apk) # Bob computes # Derive cipher key from se keydata = HKDF(chainKey, sharedSecret_se, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k = keydata[32:63] # AEAD encryption of empty data (key section has no payload) nonce = 0 associated_data = h ciphertext = ENCRYPT(k, nonce, ZEROLEN, associated_data) # ciphertext = 16 bytes (MAC only, no plaintext) # Mix ciphertext into hash h = SHA256(h || ciphertext) # State: Key section encrypted, chainKey contains all 4 DH results # Send ciphertext (16 bytes MAC) as bytes 41-56 of NSR 중요: 이것으로 Noise IK 핸드셰이크가 완료됩니다. chainKey에는 이제 4가지 DH(디피-헬만) 연산(es, ss, ee, se)에서 나온 모든 값이 반영되어 있습니다.\nKDF 8: NSR 페이로드 섹션 NSR(특정 프로토콜/메시지 형식의 약어) 페이로드 암호화를 위한 키를 파생합니다:\n# Split chainKey into bidirectional keys keydata = HKDF(chainKey, ZEROLEN, \u0026#34;\u0026#34;, 64) k_ab = keydata[0:31] # Alice → Bob key k_ba = keydata[32:63] # Bob → Alice key # Initialize ES tagsets for both directions tagset_ab = DH_INITIALIZE(chainKey, k_ab) # Alice → Bob tagset_ba = DH_INITIALIZE(chainKey, k_ba) # Bob → Alice # Derive NSR payload key (Bob → Alice) k_nsr = HKDF(k_ba, ZEROLEN, \u0026#34;AttachPayloadKDF\u0026#34;, 32) # Encrypt NSR payload nonce = 0 associated_data = h # Binds payload to entire NSR payload = build_payload() # Usually application reply ciphertext = ENCRYPT(k_nsr, nonce, payload, associated_data) # State: Bidirectional ES sessions established # tagset_ab and tagset_ba ready for ES messages # Send ciphertext as bytes 57+ of NSR message 중요 사항:\nSplit Operation(분할 연산):\n각 방향마다 독립적인 키를 생성 Alice→Bob 및 Bob→Alice 간의 키 재사용을 방지 NSR 페이로드 바인딩:\nh를 연관 데이터(associated data)로 사용하여 페이로드를 핸드셰이크에 바인딩 별도의 KDF (\u0026ldquo;AttachPayloadKDF\u0026rdquo;)가 도메인 분리를 제공 ES(메시지) 준비 상태:\nNSR(메시지) 이후, 양측은 ES 메시지를 보낼 수 있다 Alice는 ES를 보내기 전에 NSR을 수신해야 한다 Bob은 ES를 보내기 전에 ES를 수신해야 한다 ES 메시지 키 파생 함수 ES 메시지는 tagsets(태그셋)에서 미리 생성된 세션 키를 사용합니다:\n# Sender gets next tag and key tagsetEntry = outbound_tagset.GET_NEXT_ENTRY() tag = tagsetEntry.SESSION_TAG # 8 bytes k = tagsetEntry.SESSION_KEY # 32 bytes N = tagsetEntry.INDEX # Message number # Construct nonce (12 bytes) nonce = [0x00, 0x00, 0x00, 0x00] + little_endian_8_bytes(N) # AEAD encryption associated_data = tag # Tag is associated data payload = build_payload() ciphertext = ENCRYPT(k, nonce, payload, associated_data) # Send: tag || ciphertext (8 + len(ciphertext) bytes) 수신 프로세스:\n# Extract tag tag = message[0:8] # Look up tag in inbound tagsets tagsetEntry = inbound_tagset.GET_SESSION_KEY(tag) if tagsetEntry is None: # Not an ES message, try NS/NSR decryption return try_handshake_decryption(message) k = tagsetEntry.SESSION_KEY N = tagsetEntry.INDEX # Construct nonce nonce = [0x00, 0x00, 0x00, 0x00] + little_endian_8_bytes(N) # AEAD decryption associated_data = tag ciphertext = message[8:] try: payload = DECRYPT(k, nonce, ciphertext, associated_data) except AuthenticationError: # MAC verification failed, reject message return reject_message() # Process payload blocks process_payload(payload) # Remove tag from tagset (one-time use) inbound_tagset.remove(tag) DH_INITIALIZE 함수 한 방향용 태그 집합을 생성합니다:\ndef DH_INITIALIZE(rootKey, k): \u0026#34;\u0026#34;\u0026#34; Initializes a tagset with session tag and symmetric key ratchets. Args: rootKey: Chain key from previous DH ratchet (32 bytes) k: Key material from split() or DH ratchet (32 bytes) Returns: tagset: Initialized tagset object \u0026#34;\u0026#34;\u0026#34; # Derive next root key and chain key keydata = HKDF(rootKey, k, \u0026#34;KDFDHRatchetStep\u0026#34;, 64) nextRootKey = keydata[0:31] chainKey_tagset = keydata[32:63] # Derive separate chain keys for tags and keys keydata = HKDF(chainKey_tagset, ZEROLEN, \u0026#34;TagAndKeyGenKeys\u0026#34;, 64) sessTag_ck = keydata[0:31] # Session tag chain key symmKey_ck = keydata[32:63] # Symmetric key chain key # Create tagset object tagset = Tagset() tagset.nextRootKey = nextRootKey tagset.sessTag_chainKey = sessTag_ck tagset.symmKey_chainKey = symmKey_ck tagset.lastIndex = -1 return tagset 사용 맥락:\nNSR Tagset(태그셋): DH_INITIALIZE(chainKey_from_NS, tagsetKey_NSR) ES Tagsets: DH_INITIALIZE(chainKey_from_NSR, k_ab or k_ba) Ratcheted(래칫) Tagsets: DH_INITIALIZE(nextRootKey_from_previous, tagsetKey_from_DH) 래칫 메커니즘 ECIES(타원곡선 통합 암호 체계)는 서로 동기화된 세 가지 ratchet(래칫) 메커니즘을 사용하여 전방향 기밀성과 효율적인 세션 관리를 제공합니다.\nRatchet(래칫) 개요 세 가지 Ratchet(단계적 키 갱신 메커니즘) 유형:\nDH 래칫: 새로운 루트 키를 생성하기 위해 디피-헬만 키 교환을 수행한다 세션 태그 래칫: 일회용 세션 태그를 결정적으로 파생한다 대칭 키 래칫: 메시지 암호화를 위한 세션 키를 파생한다 관계:\nDH Ratchet (periodic) ↓ Creates new tagset ↓ Session Tag Ratchet (per message) ← synchronized → Symmetric Key Ratchet (per message) ↓ ↓ Session Tags (8 bytes each) Session Keys (32 bytes each) 주요 속성:\n송신자: 필요할 때 태그와 키를 생성(저장 필요 없음) 수신자: look-ahead window(선행 윈도우)를 위해 태그를 미리 생성(저장 필요) 동기화: 태그 인덱스가 키 인덱스를 결정 (N_tag = N_key) 전방향 기밀성: 주기적 DH ratchet(DH 래칫)으로 달성 효율성: 수신자는 태그를 받을 때까지 키 계산을 지연할 수 있음 DH Ratchet(디피-헬만 기반의 단계적 키 갱신 기법) DH ratchet(디피-헬먼 기반 키 래칫 메커니즘)은 주기적으로 새로운 임시 키를 교환하여 전방향 기밀성을 제공합니다.\nDH Ratchet(디피-헬만 기반 키 래칫) 빈도 필수 Ratchet(암호 프로토콜의 단계적 키 갱신 메커니즘) 조건: - 태그 집합이 소진에 임박함 (태그 65535가 최대치) - 구현별 정책: - 메시지 수 임계값 (예: 매 4096개 메시지마다) - 시간 임계값 (예: 매 10분마다) - 데이터 용량 임계값 (예: 매 100 MB마다)\n권장되는 첫 번째 Ratchet(세션 키를 순차적으로 갱신하는 메커니즘): 제한에 도달하지 않도록 태그 번호를 4096 전후로\n최대값: - 최대 태그 세트 ID: 65535 - 최대 키 ID: 32767 - 태그 세트당 최대 메시지 수: 65535 - 세션당 이론상 최대 데이터: ~6.9 TB (64K 태그 세트 × 64K 메시지 × 평균 1730바이트)\nDH Ratchet(디피-헬만 래칫) 태그 및 키 ID 초기 태그 세트 (핸드셰이크 이후): - 태그 세트 ID: 0 - NextKey(다음 키) 블록이 아직 전송되지 않았음 - 키 ID가 할당되지 않음\n첫 번째 래칫 이후: - 태그 세트 ID: 1 = (1 + Alice의 키 ID + Bob의 키 ID) = (1 + 0 + 0) - Alice는 키 ID 0을 사용한 NextKey(다음 키)를 보냄 - Bob은 키 ID 0을 사용한 NextKey로 응답함\n후속 태그 세트: - 태그 세트 ID = 1 + 송신자의 키 ID + 수신자의 키 ID - 예: 태그 세트 5 = (1 + sender_key_2 + receiver_key_2)\n태그 세트 진행 표:\nTag Set ID Sender Key ID Receiver Key ID Notes 0 n/a n/a Initial tag set (post-NSR) 1 0 * 0 * First ratchet (both generate new keys) 2 1 * 0 Sender generates new key 3 1 1 * Receiver generates new key 4 2 * 1 Sender generates new key 5 2 2 * Receiver generates new key ... ... ... Pattern repeats 65534 32767 * 32766 Second-to-last tag set 65535 32767 32767 * Final tag set \\* = 이번 ratchet(래칫)에서 새 키가 생성됨 키 ID 규칙: - ID는 0부터 순차적으로 부여됩니다 - 새 키가 생성될 때에만 ID가 증가합니다 - 최대 키 ID는 32767(15비트)입니다 - 키 ID 32767 이후에는 새 세션이 필요합니다\nDH 래칫 메시지 흐름 역할: - 태그 송신자: 아웃바운드 태그 집합을 소유하고, 메시지를 보냄 - 태그 수신자: 인바운드 태그 집합을 소유하고, 메시지를 받음\n패턴: 태그 발신자는 태그 세트가 거의 소진되었을 때 ratchet(키를 단계적으로 갱신하는 메커니즘)을 개시한다.\n메시지 흐름 다이어그램:\nTag Sender Tag Receiver ... using tag set #0 ... (Tag set #0 approaching exhaustion) (Generate new key #0) NextKey forward, request reverse, with key #0 --------\u0026gt; (Repeat until NextKey ACK received) (Generate new key #0) (Perform DH: sender_key_0 × receiver_key_0) (Create inbound tag set #1) \u0026lt;--------------- NextKey reverse, with key #0 (Repeat until tag from tag set #1 received) (Receive NextKey with key #0) (Perform DH: sender_key_0 × receiver_key_0) (Create outbound tag set #1) ... using tag set #1 ... (Tag set #1 approaching exhaustion) (Generate new key #1) NextKey forward, with key #1 --------\u0026gt; (Repeat until NextKey ACK received) (Reuse existing key #0) (Perform DH: sender_key_1 × receiver_key_0) (Create inbound tag set #2) \u0026lt;-------------- NextKey reverse, id 0 (ACK) (Repeat until tag from tag set #2 received) (Receive NextKey with id 0) (Perform DH: sender_key_1 × receiver_key_0) (Create outbound tag set #2) ... using tag set #2 ... (Tag set #2 approaching exhaustion) (Reuse existing key #1) NextKey forward, request reverse, id 1 --------\u0026gt; (Repeat until NextKey received) (Generate new key #1) (Perform DH: sender_key_1 × receiver_key_1) (Create inbound tag set #3) \u0026lt;-------------- NextKey reverse, with key #1 (Receive NextKey with key #1) (Perform DH: sender_key_1 × receiver_key_1) (Create outbound tag set #3) ... using tag set #3 ... (Pattern repeats: even-numbered tag sets use forward key, odd-numbered use reverse key) Ratchet(래칫) 패턴:\n짝수 번호 태그 세트 생성 (2, 4, 6, \u0026hellip;): 1. 송신자는 새 키를 생성한다 2. 송신자는 새 키와 함께 NextKey block을 전송한다 3. 수신자는 이전 키 ID와 함께 NextKey block을 전송한다 (ACK, 확인 응답) 4. 양측은 (새 송신자 키 × 이전 수신자 키)로 DH(디피-헬만 키 교환)를 수행한다\n홀수 번호 태그 세트 생성 (3, 5, 7, \u0026hellip;): 1. 송신자는 역방향 키를 요청함(요청 플래그가 설정된 NextKey 전송) 2. 수신자는 새 키를 생성 3. 수신자는 새 키가 포함된 NextKey 블록을 전송 4. 양측은 (이전 송신자 키 × 새 수신자 키)로 DH(디피-헬만)를 수행\nNextKey(다음 키) 블록 형식 자세한 NextKey(다음 키) 블록 사양은 Payload Format 섹션을 참조하십시오.\n핵심 요소: - 플래그 바이트: - 비트 0: 키 존재(1) 또는 ID만(0) - 비트 1: 역방향 키(1) 또는 정방향 키(0) - 비트 2: 역방향 키 요청(1) 또는 요청 없음(0) - 키 ID: 2바이트, 빅엔디언(0-32767) - 공개 키: 32바이트 X25519 (비트 0 = 1인 경우)\nNextKey 블록 예시:\n# Sender initiates ratchet with new key (key ID 0, tag set 1) NextKey(flags=0x01, key_id=0, pubkey=sender_key_0) # Receiver replies with new key (key ID 0, tag set 1) NextKey(flags=0x03, key_id=0, pubkey=receiver_key_0) # Sender ratchets again with new key (key ID 1, tag set 2) NextKey(flags=0x01, key_id=1, pubkey=sender_key_1) # Receiver ACKs with old key ID (tag set 2) NextKey(flags=0x02, key_id=0) # Sender requests reverse key (tag set 3) NextKey(flags=0x04, key_id=1) # Receiver sends new reverse key (key ID 1, tag set 3) NextKey(flags=0x03, key_id=1, pubkey=receiver_key_1) DH 래칫 키 파생 함수 새 키가 교환될 때:\n# Tag sender generates or reuses key if generating_new: sender_sk = GENERATE_PRIVATE() sender_pk = DERIVE_PUBLIC(sender_sk) else: # Reuse existing key pair sender_pk = existing_sender_pk # Tag receiver generates or reuses key if generating_new: receiver_sk = GENERATE_PRIVATE() receiver_pk = DERIVE_PUBLIC(receiver_sk) else: # Reuse existing key pair receiver_pk = existing_receiver_pk # Both parties perform DH sharedSecret = DH(sender_sk, receiver_pk) # Derive tagset key tagsetKey = HKDF(sharedSecret, ZEROLEN, \u0026#34;XDHRatchetTagSet\u0026#34;, 32) # Get next root key from previous tagset rootKey = previous_tagset.nextRootKey # Initialize new tagset new_tagset = DH_INITIALIZE(rootKey, tagsetKey) # Tag sender: outbound tagset # Tag receiver: inbound tagset 중요한 타이밍:\n태그 송신자: - 새 아웃바운드 태그 세트를 즉시 생성합니다 - 새 태그를 즉시 사용하기 시작합니다 - 기존 아웃바운드 태그 세트를 삭제합니다\n태그 수신자: - 새로운 인바운드 태그 세트를 생성 - 유예 기간(3분) 동안 기존 인바운드 태그 세트를 유지 - 유예 기간 동안 기존 및 새 태그 세트의 태그를 모두 수락 - 유예 기간 후 기존 인바운드 태그 세트를 삭제\nDH 래칫 상태 관리 송신자 상태: - 현재 발신 태그 세트 - 태그 세트 ID 및 키 ID - 다음 루트 키(다음 ratchet(단계적 키 갱신 메커니즘)용) - 현재 태그 세트의 메시지 수\n수신자 상태: - 현재 인바운드 태그 세트(유예 기간 동안에는 2개일 수 있음) - 누락 감지를 위한 이전 메시지 번호(PN) - 사전 생성된 태그의 look-ahead window(선행 창) - 다음 루트 키(다음 ratchet(암호 키를 단계적으로 갱신하는 메커니즘)용)\n상태 전이 규칙:\n첫 번째 Ratchet(암호 키 갱신 메커니즘) 이전:\n태그 세트 0 사용(NSR에서) 키 ID가 할당되지 않음 Ratchet(래칫) 초기화:\n새 키 생성(이번 라운드에서 발신자가 생성하는 경우) ES message에 NextKey block 전송 새 아웃바운드 tag set 생성 전에 NextKey reply 대기 Ratchet(래칫, 연속적 키 갱신 메커니즘) 요청 수신:\n새 키 생성(이번 라운드에서 수신자가 생성자일 경우) 수신한 키로 Diffie-Hellman(DH) 수행 새 인바운드 태그 세트 생성 NextKey(다음 키) 응답 전송 유예 기간 동안 기존 인바운드 태그 세트 유지 Ratchet(래칫, 단계적 키 갱신) 완료:\nNextKey 응답 수신 디피-헬만 키 교환 수행 새 아웃바운드 태그 세트 생성 새 태그 사용 시작 세션 태그 래칫 session tag ratchet(세션 태그를 위한 암호화 래칫 메커니즘)은 일회용 8바이트 세션 태그를 결정적으로 생성한다.\nSession Tag Ratchet(Session Tag를 전진 갱신하는 암호학적 메커니즘)의 목적 명시적 태그 전송을 대체함 (ElGamal은 32바이트 태그를 전송했음) 수신자가 look-ahead window(선행 윈도우)를 위해 태그를 사전 생성할 수 있게 함 송신자는 요청 시 생성함 (저장 필요 없음) 인덱스를 통해 symmetric key ratchet(대칭키 래칫, 단계적으로 대칭키를 갱신하는 메커니즘)과 동기화됨 세션 태그 래칫 공식 초기화:\n# From DH_INITIALIZE sessTag_ck = initial_chain_key # 32 bytes # Initialize session tag ratchet keydata = HKDF(sessTag_ck, ZEROLEN, \u0026#34;STInitialization\u0026#34;, 64) sessTag_chainKey = keydata[0:31] # First chain key SESSTAG_CONSTANT = keydata[32:63] # Constant for all tags in this tagset 태그 생성(태그 N에 대해):\n# Generate tag N keydata = HKDF(sessTag_chainKey_(N-1), SESSTAG_CONSTANT, \u0026#34;SessionTagKeyGen\u0026#34;, 64) sessTag_chainKey_N = keydata[0:31] # Chain key for next tag tag_N = keydata[32:39] # Session tag (8 bytes) # Chain continues for each tag # tag_0, tag_1, tag_2, ..., tag_65535 전체 시퀀스:\n# Tag 0 keydata_0 = HKDF(sessTag_chainKey, SESSTAG_CONSTANT, \u0026#34;SessionTagKeyGen\u0026#34;, 64) sessTag_chainKey_0 = keydata_0[0:31] tag_0 = keydata_0[32:39] # Tag 1 keydata_1 = HKDF(sessTag_chainKey_0, SESSTAG_CONSTANT, \u0026#34;SessionTagKeyGen\u0026#34;, 64) sessTag_chainKey_1 = keydata_1[0:31] tag_1 = keydata_1[32:39] # Tag N keydata_N = HKDF(sessTag_chainKey_(N-1), SESSTAG_CONSTANT, \u0026#34;SessionTagKeyGen\u0026#34;, 64) sessTag_chainKey_N = keydata_N[0:31] tag_N = keydata_N[32:39] Session Tag Ratchet(세션 태그를 단계적으로 교체하는 메커니즘) 송신자 구현 class OutboundTagset: def __init__(self, sessTag_ck): # Initialize keydata = HKDF(sessTag_ck, ZEROLEN, \u0026#34;STInitialization\u0026#34;, 64) self.chainKey = keydata[0:31] self.constant = keydata[32:63] self.index = -1 def get_next_tag(self): # Increment index self.index += 1 if self.index \u0026gt; 65535: raise TagsetExhausted(\u0026#34;Ratchet required\u0026#34;) # Generate tag keydata = HKDF(self.chainKey, self.constant, \u0026#34;SessionTagKeyGen\u0026#34;, 64) self.chainKey = keydata[0:31] tag = keydata[32:39] return (tag, self.index) 송신 프로세스: 1. 각 메시지마다 get_next_tag()를 호출 2. 반환된 태그를 ES 메시지에 사용 3. 잠재적인 ACK(확인 응답) 추적을 위해 인덱스 N을 저장 4. 태그 저장이 필요 없음(필요 시 생성됨)\n세션 태그 Ratchet(키 갱신 메커니즘) 수신자 구현 class InboundTagset: def __init__(self, sessTag_ck, look_ahead=32): # Initialize keydata = HKDF(sessTag_ck, ZEROLEN, \u0026#34;STInitialization\u0026#34;, 64) self.chainKey = keydata[0:31] self.constant = keydata[32:63] self.index = -1 self.look_ahead = look_ahead self.tags = {} # Dictionary: tag -\u0026gt; index # Pre-generate initial tags self.extend(look_ahead) def extend(self, count): \u0026#34;\u0026#34;\u0026#34;Generate \u0026#39;count\u0026#39; more tags\u0026#34;\u0026#34;\u0026#34; for _ in range(count): self.index += 1 if self.index \u0026gt; 65535: return # Cannot exceed maximum # Generate tag keydata = HKDF(self.chainKey, self.constant, \u0026#34;SessionTagKeyGen\u0026#34;, 64) self.chainKey = keydata[0:31] tag = keydata[32:39] # Store tag self.tags[tag] = self.index def lookup_tag(self, tag): \u0026#34;\u0026#34;\u0026#34;Look up tag and return index\u0026#34;\u0026#34;\u0026#34; if tag in self.tags: index = self.tags[tag] # Remove tag (one-time use) del self.tags[tag] return index return None def check_and_extend(self): \u0026#34;\u0026#34;\u0026#34;Extend if tag count is low\u0026#34;\u0026#34;\u0026#34; current_count = len(self.tags) if current_count \u0026lt; self.look_ahead // 2: # Extend to restore window self.extend(self.look_ahead - current_count) 수신 프로세스: 1. look-ahead window(선행 윈도우)용 태그를 미리 생성한다(예: 태그 32개) 2. 태그를 해시 테이블 또는 사전에 저장한다 3. 메시지가 도착하면 태그를 조회하여 인덱스 N을 얻는다 4. 저장소에서 태그를 제거한다(1회용) 5. 태그 수가 임계값 아래로 떨어지면 윈도우를 확장한다\n세션 태그 사전 준비 전략 목적: 메모리 사용량과 순서가 어긋난 메시지 처리 간의 균형 조정\n권장 룩어헤드 크기:\nTagset Type Initial Size Maximum Size Notes NSR tagset 12 12 Short-lived ES tagset 0 24 160 Initial ES tagset ES tagset 1+ 160 160 Ratcheted tagsets **적응형 전방 탐색:** # Dynamic look-ahead based on highest tag received look_ahead = min(tsmax, tsmin + N // 4) # Example: # tsmin = 24, tsmax = 160 # N = 0: look_ahead = min(160, 24 + 0/4) = 24 # N = 100: look_ahead = min(160, 24 + 100/4) = 49 # N = 500: look_ahead = min(160, 24 + 500/4) = 149 # N = 544: look_ahead = min(160, 24 + 544/4) = 160 뒤쪽 자르기:\n# Trim tags far behind highest received trim_behind = look_ahead // 2 # If highest received tag is N=100, trim tags below N=50 메모리 계산:\n# Per tag: 8 bytes (tag) + 2 bytes (index) + overhead ≈ 16 bytes # Look-ahead of 160 tags ≈ 2.5 KB per inbound tagset # With multiple sessions: # 100 inbound sessions × 2.5 KB = 250 KB total Session Tag(세션 태그) 순서 뒤바뀜 처리 시나리오: 메시지가 순서대로 도착하지 않음\nExpected: tag_5, tag_6, tag_7, tag_8 Received: tag_5, tag_7, tag_6, tag_8 수신자 동작:\ntag_5 수신:\n조회: 인덱스 5에서 찾음 메시지 처리 tag_5 제거 최대 수신값: 5 tag_7 수신 (순서 어긋남):\n조회: 인덱스 7에서 발견 메시지 처리 tag_7 제거 최고 수신 번호: 7 참고: tag_6은 여전히 저장소에 있음 (아직 수신되지 않음) tag_6 수신(지연됨):\n조회: 인덱스 6에서 찾음 메시지 처리 tag_6 제거 최대 수신값: 7 (변경 없음) tag_8 수신:\n조회: 인덱스 8에서 찾음 메시지 처리 tag_8 제거 가장 높은 수신 번호: 8 윈도우 관리: - 수신된 인덱스의 최댓값을 추적 - 누락된 인덱스(갭) 목록 유지 - 최댓값 인덱스를 기준으로 윈도우 확장 - 선택 사항: 타임아웃 후 오래된 갭 만료\n대칭 키 래칫 symmetric key ratchet(대칭키 래칫)은 session tags(세션 태그)와 동기화된 32바이트 암호화 키를 생성합니다.\nSymmetric Key Ratchet(대칭 키 래칫)의 목적 각 메시지마다 고유한 암호화 키 제공 session tag ratchet(세션 태그 래칫, 단계적 키 갱신 메커니즘)과 동기화됨(같은 인덱스) 송신자는 필요 시 생성 가능 수신자는 태그를 받을 때까지 생성을 지연할 수 있음 대칭 키 래칫 공식 초기화:\n# From DH_INITIALIZE symmKey_ck = initial_chain_key # 32 bytes # No additional initialization needed # Unlike session tag ratchet, no constant is derived 키 생성(키 N용):\n# Generate key N SYMMKEY_CONSTANT = ZEROLEN # Empty string keydata = HKDF(symmKey_chainKey_(N-1), SYMMKEY_CONSTANT, \u0026#34;SymmetricRatchet\u0026#34;, 64) symmKey_chainKey_N = keydata[0:31] # Chain key for next key key_N = keydata[32:63] # Session key (32 bytes) 전체 시퀀스:\n# Key 0 keydata_0 = HKDF(symmKey_ck, ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) symmKey_chainKey_0 = keydata_0[0:31] key_0 = keydata_0[32:63] # Key 1 keydata_1 = HKDF(symmKey_chainKey_0, ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) symmKey_chainKey_1 = keydata_1[0:31] key_1 = keydata_1[32:63] # Key N keydata_N = HKDF(symmKey_chainKey_(N-1), ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) symmKey_chainKey_N = keydata_N[0:31] key_N = keydata_N[32:63] Symmetric Key Ratchet(대칭키 래칫) 송신자 구현 class OutboundKeyRatchet: def __init__(self, symmKey_ck): self.chainKey = symmKey_ck self.index = -1 def get_key(self, index): \u0026#34;\u0026#34;\u0026#34;Generate key for specific index\u0026#34;\u0026#34;\u0026#34; # Fast-forward to desired index if needed while self.index \u0026lt; index: self.index += 1 keydata = HKDF(self.chainKey, ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) self.chainKey = keydata[0:31] if self.index == index: return keydata[32:63] # Should not reach here if called correctly raise ValueError(\u0026#34;Key already generated\u0026#34;) 송신자 프로세스: 1. 다음 태그와 해당 인덱스 N을 가져온다 2. 인덱스 N에 대한 키를 생성한다 3. 키를 사용하여 메시지를 암호화한다 4. 키 저장이 필요하지 않다\n대칭 키 래칫 수신자 구현 전략 1: 지연 생성 (권장)\nclass InboundKeyRatchet: def __init__(self, symmKey_ck): self.chainKey = symmKey_ck self.index = -1 self.cache = {} # Optional: cache recently used keys def get_key(self, index): \u0026#34;\u0026#34;\u0026#34;Generate key for specific index\u0026#34;\u0026#34;\u0026#34; # Check cache first (optional optimization) if index in self.cache: key = self.cache[index] del self.cache[index] return key # Fast-forward to desired index while self.index \u0026lt; index: self.index += 1 keydata = HKDF(self.chainKey, ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) self.chainKey = keydata[0:31] if self.index == index: return keydata[32:63] raise ValueError(\u0026#34;Index already passed\u0026#34;) 지연 생성 프로세스: 1. 태그가 포함된 ES message(ES 메시지)를 수신 2. 태그를 조회해 인덱스 N을 얻음 3. (아직 생성되지 않았다면) 키 0부터 N까지 생성 4. 키 N으로 메시지를 복호화 5. Chain key(체인 키)는 이제 인덱스 N에 위치함\n장점: - 메모리 사용량 최소화 - 필요할 때에만 키 생성 - 구현이 단순함\n단점: - 최초 사용 시 0부터 N까지 모든 키를 생성해야 함 - 캐싱 없이는 순서가 뒤바뀐 메시지를 처리할 수 없음\n전략 2: 태그 윈도우 기반 사전 생성 (대안)\nclass InboundKeyRatchet: def __init__(self, symmKey_ck): self.chainKey = symmKey_ck self.index = -1 self.keys = {} # Dictionary: index -\u0026gt; key def extend(self, count): \u0026#34;\u0026#34;\u0026#34;Pre-generate \u0026#39;count\u0026#39; more keys\u0026#34;\u0026#34;\u0026#34; for _ in range(count): self.index += 1 keydata = HKDF(self.chainKey, ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) self.chainKey = keydata[0:31] key = keydata[32:63] self.keys[self.index] = key def get_key(self, index): \u0026#34;\u0026#34;\u0026#34;Retrieve pre-generated key\u0026#34;\u0026#34;\u0026#34; if index in self.keys: key = self.keys[index] del self.keys[index] return key return None 사전 생성 프로세스: 1. tag window(태그 윈도우)에 맞춰 키를 미리 생성 (예: 키 32개) 2. 메시지 번호로 인덱싱하여 키를 저장 3. 태그를 수신하면 해당 키를 조회 4. 태그가 사용됨에 따라 윈도우를 확장\n장점: - 순서가 뒤바뀐 메시지도 자연스럽게 처리 - 빠른 키 조회(생성 지연 없음)\n단점: - 메모리 사용량 증가 (키당 32바이트 대 태그당 8바이트) - 키를 태그와 동기화된 상태로 유지해야 함\n메모리 비교:\n# Look-ahead of 160: # Tags only: 160 × 16 bytes = 2.5 KB # Tags+Keys: 160 × (16 + 32) bytes = 7.5 KB # # For 100 sessions: # Tags only: 250 KB # Tags+Keys: 750 KB Session Tags(세션 태그)를 이용한 대칭 래칫 동기화 중대한 요구 사항: 세션 태그 인덱스는 대칭 키 인덱스와 반드시 동일해야 한다\n# Sender tag, index = outbound_tagset.get_next_tag() key = outbound_keyratchet.get_key(index) # Same index nonce = construct_nonce(index) ciphertext = ENCRYPT(key, nonce, payload, tag) # Receiver index = inbound_tagset.lookup_tag(tag) key = inbound_keyratchet.get_key(index) # Same index nonce = construct_nonce(index) plaintext = DECRYPT(key, nonce, ciphertext, tag) 실패 모드:\n동기화가 깨지면: - 복호화에 잘못된 키가 사용됨 - MAC(메시지 인증 코드) 검증 실패 - 메시지가 거부됨\n예방: - 태그와 키에 동일한 인덱스를 항상 사용하십시오 - 어느 쪽의 ratchet(암호 키 발전 메커니즘)에서도 인덱스를 건너뛰지 마십시오 - 순서가 어긋난 메시지는 신중하게 처리하십시오\n대칭 래칫 논스 구성 Nonce(논스)는 메시지 번호에서 파생됩니다:\ndef construct_nonce(index): \u0026#34;\u0026#34;\u0026#34; Construct 12-byte nonce for ChaCha20-Poly1305 Args: index: Message number (0-65535) Returns: nonce: 12-byte nonce \u0026#34;\u0026#34;\u0026#34; # First 4 bytes are always zero nonce = bytearray(12) nonce[0:4] = b\u0026#39;\\x00\\x00\\x00\\x00\u0026#39; # Last 8 bytes are little-endian message number nonce[4:12] = index.to_bytes(8, byteorder=\u0026#39;little\u0026#39;) return bytes(nonce) 예시:\nindex = 0: nonce = 0x00000000 0000000000000000 index = 1: nonce = 0x00000000 0100000000000000 index = 255: nonce = 0x00000000 FF00000000000000 index = 256: nonce = 0x00000000 0001000000000000 index = 65535: nonce = 0x00000000 FFFF000000000000 중요한 속성: - nonce(논스)는 tagset(태그 집합) 내 각 메시지마다 고유합니다 - nonce는 절대 반복되지 않습니다(일회용 태그가 이를 보장합니다) - 8바이트 카운터는 2^64개의 메시지를 허용합니다(우리는 2^16만 사용합니다) - nonce 형식은 RFC 7539의 카운터 기반 구성과 일치합니다\n세션 관리 세션 컨텍스트 모든 인바운드 및 아웃바운드 세션은 특정 컨텍스트에 속해야 합니다:\nRouter 컨텍스트: router 자체용 세션 Destination 컨텍스트: 특정 로컬 destination(I2P 목적지) (클라이언트 애플리케이션)을 위한 세션 중요 규칙: 상관관계 공격을 방지하기 위해 세션은 컨텍스트 간에 절대 공유되어서는 안 됩니다.\n구현:\nclass SessionKeyManager: \u0026#34;\u0026#34;\u0026#34;Context for managing sessions (router or destination)\u0026#34;\u0026#34;\u0026#34; def __init__(self, context_id): self.context_id = context_id self.inbound_sessions = {} # far_end_dest -\u0026gt; [sessions] self.outbound_sessions = {} # far_end_dest -\u0026gt; session self.static_keypair = generate_keypair() # Context\u0026#39;s identity def get_outbound_session(self, destination): \u0026#34;\u0026#34;\u0026#34;Get or create outbound session to destination\u0026#34;\u0026#34;\u0026#34; if destination not in self.outbound_sessions: self.outbound_sessions[destination] = create_outbound_session(destination) return self.outbound_sessions[destination] def add_inbound_session(self, session, destination=None): \u0026#34;\u0026#34;\u0026#34;Add inbound session, optionally bound to destination\u0026#34;\u0026#34;\u0026#34; if destination: if destination not in self.inbound_sessions: self.inbound_sessions[destination] = [] self.inbound_sessions[destination].append(session) else: # Unbound session self.inbound_sessions[None].append(session) Java I2P 구현:\nJava I2P에서, SessionKeyManager 클래스는 다음 기능을 제공합니다: - router마다 하나의 SessionKeyManager - 로컬 destination(목적지)마다 하나의 SessionKeyManager - 각 컨텍스트 내에서 ECIES(타원 곡선 기반 공개키 암호 방식)와 ElGamal(공개키 암호 체계) 세션을 분리하여 관리\n세션 바인딩 Binding(바인딩)은 세션을 특정 원격단 목적지와 연관합니다.\n바인딩된 세션 특징: - NS 메시지에 송신자의 정적 키 포함 - 수신자는 송신자의 목적지를 식별할 수 있음 - 양방향 통신을 가능하게 함 - 목적지당 단일 발신 세션 - 여러 수신 세션이 있을 수 있음(전환 중)\n사용 사례: - 스트리밍 연결(TCP 유사) - 회신 가능한 데이터그램 - 요청/응답이 필요한 모든 프로토콜\n바인딩 프로세스:\n# Alice creates bound outbound session outbound_session = OutboundSession( destination=bob_destination, static_key=alice_static_key, bound=True ) # Alice sends NS with static key ns_message = build_ns_message( ephemeral_key=alice_ephemeral_key, static_key=alice_static_key, # Included for binding payload=data ) # Bob receives NS bob_receives_ns(ns_message) # Bob extracts Alice\u0026#39;s static key alice_static_key = decrypt_static_key_section(ns_message) # Bob looks up Alice\u0026#39;s destination (from bundled LeaseSet) alice_destination = lookup_destination_by_static_key(alice_static_key) # Bob creates bound inbound session inbound_session = InboundSession( destination=alice_destination, bound=True ) # Bob pairs with outbound session outbound_session = OutboundSession( destination=alice_destination, bound=True ) 이점: 1. Ephemeral-Ephemeral DH(일시적-일시적 디피-헬먼 키 교환): 응답은 ee DH를 사용함(완전한 순방향 기밀성) 2. 세션 연속성: Ratchets(래칫 기반 키 갱신 메커니즘)가 동일한 목적지에 대한 바인딩을 유지 3. 보안: 세션 하이재킹을 방지(정적 키로 인증됨) 4. 효율성: 목적지당 단일 세션(중복 없음)\n바인딩되지 않은 세션 특징: - NS 메시지에 고정 키가 없음(플래그 섹션은 모두 0) - 수신자는 발신자를 식별할 수 없음 - 단방향 통신만 가능 - 동일한 destination(목적지)에 여러 세션 허용\n사용 사례: - 원시 데이터그램 (fire-and-forget(보낸 뒤 확인하지 않음)) - 익명 게시 - 방송형 메시징\n특성: - 더 높은 익명성 (발신자 식별 없음) - 더 높은 효율 (핸드셰이크에서 1 DH 대 2 DH) - 응답 불가 (수신자가 어디로 응답해야 할지 모름) - session ratcheting(세션 키를 점진적으로 갱신하는 메커니즘) 없음 (일회성 또는 제한적 사용)\n세션 페어링 Pairing(페어링) 은 양방향 통신을 위해 인바운드 세션과 아웃바운드 세션을 연결합니다.\n페어링된 세션 생성 Alice의 관점 (개시자):\n# Create outbound session to Bob outbound_session = create_outbound_session(bob_destination) # Create paired inbound session inbound_session = create_inbound_session( paired_with=outbound_session, bound_to=bob_destination ) # Link them outbound_session.paired_inbound = inbound_session inbound_session.paired_outbound = outbound_session # Send NS message send_ns_message(outbound_session, payload) Bob의 관점(응답자):\n# Receive NS message ns_message = receive_ns_message() # Create inbound session inbound_session = create_inbound_session_from_ns(ns_message) # If NS contains static key (bound): if ns_message.has_static_key(): alice_destination = extract_destination(ns_message) inbound_session.bind_to(alice_destination) # Create paired outbound session outbound_session = create_outbound_session(alice_destination) # Link them outbound_session.paired_inbound = inbound_session inbound_session.paired_outbound = outbound_session # Send NSR send_nsr_message(inbound_session, outbound_session, payload) 세션 페어링의 이점 인밴드 ACK: 별도의 clove(garlic encryption에서 개별 메시지 단위) 없이 메시지를 수신 확인할 수 있음 효율적인 Ratcheting(세션 키를 단계적으로 갱신하는 래칫 기법): 양 방향이 함께 래칫을 진행함 흐름 제어: 쌍으로 연결된 세션 전반에 걸쳐 back-pressure(소비 속도에 맞춰 전송을 억제하는 메커니즘)를 구현할 수 있음 상태 일관성: 동기화된 상태를 더 쉽게 유지할 수 있음 세션 페어링 규칙 아웃바운드 세션은 페어링되지 않았을 수 있음 (바인딩되지 않은 NS) 바인딩된 NS의 인바운드 세션은 페어링되어야 함 페어링은 세션 생성 시에 이루어지며, 그 이후에는 이루어지지 않음 페어링된 세션은 동일한 목적지 바인딩을 가짐 래칫은 독립적으로 발생하지만 조율됨 세션 수명주기 세션 수명 주기: 생성 단계 아웃바운드 세션 생성 (Alice):\ndef create_outbound_session(destination, bound=True): session = OutboundSession() session.destination = destination session.bound = bound session.state = SessionState.NEW session.created_time = now() # Generate keys for NS message session.ephemeral_keypair = generate_elg2_keypair() if bound: session.static_key = context.static_keypair.public_key # Will be populated after NSR received session.outbound_tagset = None session.inbound_tagset = None return session 인바운드 세션 생성 (Bob):\ndef create_inbound_session_from_ns(ns_message): session = InboundSession() session.state = SessionState.ESTABLISHED session.created_time = now() # Extract from NS session.remote_ephemeral_key = ns_message.ephemeral_key session.remote_static_key = ns_message.static_key if session.remote_static_key: session.bound = True session.destination = lookup_destination(session.remote_static_key) else: session.bound = False session.destination = None # Generate keys for NSR session.ephemeral_keypair = generate_elg2_keypair() # Create tagsets from KDF session.inbound_tagset = create_tagset_from_nsr() session.outbound_tagset = create_tagset_from_nsr() return session 세션 수명 주기: 활성 단계 상태 전이:\nNEW (outbound only) ↓ NS sent ↓ PENDING_REPLY (outbound only) ↓ NSR received ↓ ESTABLISHED ↓ ES messages exchanged ↓ ESTABLISHED (ongoing) ↓ (optional) RATCHETING ↓ ESTABLISHED 활성 세션 유지 관리:\ndef maintain_active_session(session): # Update last activity time session.last_activity = now() # Check for ratchet needed if session.outbound_tagset.needs_ratchet(): initiate_ratchet(session) # Check for incoming ratchet if received_nextkey_block(): process_ratchet(session) # Trim old tags from inbound tagset session.inbound_tagset.expire_old_tags() # Check session health if session.idle_time() \u0026gt; SESSION_TIMEOUT: mark_session_idle(session) 세션 수명주기: 만료 단계 세션 타임아웃 값:\nSession Type Sender Timeout Receiver Timeout Notes NSR tagset N/A 3 minutes Short-lived ES tagset 0 8 minutes 10 minutes Initial ES tagset 1+ 8 minutes 10 minutes Ratcheted Old tagset N/A 3 minutes After ratchet **만료 로직:** def check_session_expiration(): for session in active_sessions: # Outbound session expiration (sender) if session.is_outbound(): if session.idle_time() \u0026gt; 8 * 60: # 8 minutes expire_outbound_session(session) # Inbound session expiration (receiver) else: if session.idle_time() \u0026gt; 10 * 60: # 10 minutes expire_inbound_session(session) # Old tagsets (after ratchet) for tagset in old_tagsets: if tagset.age() \u0026gt; 3 * 60: # 3 minutes delete_tagset(tagset) 중요 규칙: 동기화가 어긋나는 것을 방지하기 위해 아웃바운드 세션은 인바운드 세션보다 반드시 먼저 만료되어야 합니다.\n정상 종료:\ndef terminate_session(session, reason=0): # Send Termination block (if implemented) send_termination_block(session, reason) # Mark session for deletion session.state = SessionState.TERMINATED # Keep session briefly for final messages schedule_deletion(session, delay=30) # 30 seconds # Notify paired session if session.paired_session: session.paired_session.mark_remote_terminated() 복수의 NS 메시지 시나리오: Alice의 NS 메시지가 손실되었거나 NSR 응답이 손실된 경우.\nAlice의 동작:\nclass OutboundSession: def __init__(self): self.ns_messages_sent = [] self.ns_timer = None self.max_ns_attempts = 5 def send_ns_message(self, payload): # Generate new ephemeral key for each NS ephemeral_key = generate_elg2_keypair() ns_message = build_ns_message( ephemeral_key=ephemeral_key, static_key=self.static_key, payload=payload ) # Store state for this NS ns_state = { \u0026#39;ephemeral_key\u0026#39;: ephemeral_key, \u0026#39;chainkey\u0026#39;: compute_chainkey(ns_message), \u0026#39;hash\u0026#39;: compute_hash(ns_message), \u0026#39;tagset\u0026#39;: derive_nsr_tagset(ns_message), \u0026#39;sent_time\u0026#39;: now() } self.ns_messages_sent.append(ns_state) # Send message send_message(ns_message) # Set timer for retry if not self.ns_timer: self.ns_timer = set_timer(1.0, self.on_ns_timeout) def on_ns_timeout(self): if len(self.ns_messages_sent) \u0026gt;= self.max_ns_attempts: # Give up fail_session(\u0026#34;No NSR received after {self.max_ns_attempts} attempts\u0026#34;) return # Retry with new NS message send_ns_message(self.payload) def on_nsr_received(self, nsr_message): # Cancel timer cancel_timer(self.ns_timer) # Find which NS this NSR responds to tag = nsr_message.tag for ns_state in self.ns_messages_sent: if tag in ns_state[\u0026#39;tagset\u0026#39;]: # This NSR corresponds to this NS self.active_ns_state = ns_state break # Process NSR and complete handshake complete_handshake(nsr_message, self.active_ns_state) # Discard other NS states self.ns_messages_sent = [] 중요한 속성:\n고유한 임시 키: 각 NS(핸드셰이크 시작 메시지)는 서로 다른 임시 키를 사용함 독립적인 핸드셰이크: 각 NS는 별도의 핸드셰이크 상태를 생성함 NSR 연관: NSR(해당 NS에 대한 응답 메시지) 태그는 어떤 NS에 대한 응답인지 식별함 상태 정리: NSR이 성공하면 사용되지 않은 NS 상태는 폐기됨 공격 방지:\n리소스 고갈을 방지하기 위해:\n# Limit NS sending rate max_ns_rate = 5 per 10 seconds per destination # Limit total NS attempts max_ns_attempts = 5 # Limit total pending NS states max_pending_ns = 10 per context 여러 NSR(NTCP2의 세션 요청 메시지) 메시지 시나리오: Bob이 여러 개의 NSR(응답 메시지)을 전송한다(예: 응답 데이터가 여러 메시지로 분할된 경우).\nBob의 동작:\nclass InboundSession: def send_nsr_replies(self, payload_chunks): # One NS received, multiple NSRs to send for chunk in payload_chunks: # Generate new ephemeral key for each NSR ephemeral_key = generate_elg2_keypair() # Get next tag from NSR tagset tag = self.nsr_tagset.get_next_tag() nsr_message = build_nsr_message( tag=tag, ephemeral_key=ephemeral_key, payload=chunk ) send_message(nsr_message) # Wait for ES message from Alice self.state = SessionState.AWAITING_ES 앨리스의 동작:\nclass OutboundSession: def on_nsr_received(self, nsr_message): if self.state == SessionState.PENDING_REPLY: # First NSR received complete_handshake(nsr_message) self.state = SessionState.ESTABLISHED # Create ES sessions self.es_outbound_tagset = derive_es_outbound_tagset() self.es_inbound_tagset = derive_es_inbound_tagset() # Send ES message (ACK) send_es_message(empty_payload) elif self.state == SessionState.ESTABLISHED: # Additional NSR received # Decrypt and process payload payload = decrypt_nsr_payload(nsr_message) process_payload(payload) # These NSRs are from other NS attempts, ignore handshake Bob의 정리:\nclass InboundSession: def on_es_received(self, es_message): # First ES received from Alice # This confirms which NSR Alice used # Clean up other handshake states for other_ns_state in self.pending_ns_states: if other_ns_state != self.active_ns_state: delete_ns_state(other_ns_state) # Delete unused NSR tagsets for tagset in self.nsr_tagsets: if tagset != self.active_nsr_tagset: delete_tagset(tagset) self.state = SessionState.ESTABLISHED 중요한 속성:\n여러 개의 NSR 허용: Bob은 NS당 여러 개의 NSR을 보낼 수 있다 서로 다른 임시 키: 각 NSR은 고유한 임시 키를 사용해야 한다 동일한 NSR Tagset: 하나의 NS에 대한 모든 NSR은 동일한 tagset(태그 집합)을 사용한다 먼저 도착한 ES가 승리: Alice의 첫 ES가 어떤 NSR이 성공했는지 결정한다 ES 이후 정리: Bob은 ES를 받은 후 사용되지 않은 상태를 폐기한다 세션 상태 머신 전체 상태 다이어그램:\nOutbound Session Inbound Session NEW | send NS | PENDING_REPLY -------------------- receive NS ---\u0026gt; ESTABLISHED | | receive NSR send NSR | | ESTABLISHED \u0026lt;---------- receive ES ------------- AWAITING_ES | | | ┌─────┴─────┐ | receive ES | | | | send ES receive ES | ESTABLISHED | | | | └─────┬─────┘ | ┌─────────┴─────────┐ | | | | | | send ES receive ES | | | | | | └─────────┬─────────┘ | | | └─────────────────────┴──────────────────────────┘ ACTIVE | idle timeout | EXPIRED 상태 설명:\nNEW: 아웃바운드 세션이 생성되었으며, 아직 NS를 보내지 않음 PENDING_REPLY: NS를 전송했으며, NSR을 대기 중 AWAITING_ES: NSR을 전송했으며, Alice로부터 첫 번째 ES를 대기 중 ESTABLISHED: 핸드셰이크가 완료되어 ES를 송수신할 수 있음 ACTIVE: ES 메시지를 활발히 교환 중 RATCHETING: DH ratchet(디피-헬만 기반 키 갱신 래칫) 진행 중 (ACTIVE의 하위 상태) EXPIRED: 세션이 타임아웃되어 삭제 대기 중 TERMINATED: 세션이 명시적으로 종료됨 페이로드 형식 모든 ECIES(타원곡선 통합 암호화 방식) 메시지(NS, NSR, ES)의 페이로드 섹션은 NTCP2와 유사한 블록 기반 형식을 사용합니다.\n블록 구조 일반 형식:\n+----+----+----+----+----+----+----+----+ |blk | size | data | +----+----+----+ + | | ~ ... ~ | | +----+----+----+----+----+----+----+----+ |blk | size | data | +----+----+----+ + | | ~ ... ~ | | +----+----+----+----+----+----+----+----+ 필드:\nblk: 1바이트 - 블록 유형 번호 size: 2바이트 - 빅엔디언 형태의 데이터 필드 크기 (0-65516) data: 가변 길이 - 블록별 데이터 제약 사항:\n최대 ChaChaPoly(ChaCha20-Poly1305 조합) 프레임: 65535 바이트 Poly1305 MAC(메시지 인증 코드): 16 바이트 블록 총합의 최대 크기: 65519 바이트 (65535 - 16) 단일 블록의 최대 크기: 65519 바이트 (3바이트 헤더 포함) 단일 블록 데이터의 최대 크기: 65516 바이트 블록 유형 정의된 블록 유형:\nType Name Size Status Usage 0 DateTime 7 bytes Implemented Required in NS 1-3 Reserved - - Future use 4 Termination 9+ bytes Unimplemented Session termination 5 Options 21+ bytes Unimplemented Session options 6 MessageNumbers 5 bytes Unimplemented PN value 7 NextKey 3 or 35 bytes Implemented DH ratchet 8 ACK 4+ bytes Implemented Message acknowledgment 9 ACK Request 3 bytes Implemented Request ACK 10 Reserved - - Future use 11 Garlic Clove Variable Implemented Application data 12-223 Reserved - - Future use 224-253 Experimental Variable - Testing features 254 Padding Variable Implemented Traffic shaping 255 Reserved - - Future extension **알 수 없는 블록 처리:** 구현체는 알 수 없는 타입 번호의 블록을 반드시 무시하고 패딩으로 취급해야 한다. 이는 전방 호환성을 보장한다.\n블록 순서 규칙 NS 메시지 순서 필수: - DateTime 블록은 반드시 맨 앞에 와야 합니다\n허용됨: - Garlic Clove (garlic 메시지를 구성하는 단위) (유형 11) - 옵션 (유형 5) - 구현된 경우 - 패딩 (유형 254)\n금지: - NextKey, ACK, ACK Request, Termination, MessageNumbers\n유효한 NS 페이로드 예시:\nDateTime (0) | Garlic Clove (11) | Garlic Clove (11) | Padding (254) NSR 메시지 순서 필수: - 없음 (페이로드는 비어 있을 수 있음)\n허용: - Garlic Clove(garlic 메시지 내부의 개별 메시지 단위) (유형 11) - 옵션 (유형 5) - 구현된 경우 - 패딩 (유형 254)\n금지: - DateTime, NextKey, ACK, ACK Request, Termination, MessageNumbers\n유효한 NSR 페이로드 예시:\nGarlic Clove (11) | Garlic Clove (11) | Padding (254) 또는\n(empty - ACK only) ES 메시지 순서 필수: - 없음 (페이로드가 비어 있을 수 있음)\n허용됨(순서는 무관): - Garlic Clove (type 11) - NextKey (type 7) - ACK (type 8) - ACK Request (type 9) - Termination (type 4) - 구현된 경우 - MessageNumbers (type 6) - 구현된 경우 - Options (type 5) - 구현된 경우 - Padding (type 254)\n특별 규칙: - Termination(종료) 블록은 반드시 마지막 블록이어야 함(단, Padding(패딩)이 있을 경우 Padding이 마지막) - Padding 블록은 반드시 마지막 블록이어야 함 - Garlic Cloves(Garlic 메시지의 하위 메시지) 다수 허용 - NextKey(다음 키) 블록은 최대 2개까지 허용(순방향 및 역방향) - Padding 블록 다수는 허용되지 않음\n유효한 ES 페이로드 예시:\nGarlic Clove (11) | ACK (8) | Padding (254) NextKey (7) | Garlic Clove (11) | Garlic Clove (11) NextKey (7) forward | NextKey (7) reverse | Garlic Clove (11) ACK Request (9) | Garlic Clove (11) | Termination (4) | Padding (254) DateTime 블록 (유형 0) 목적: replay(재전송 공격) 방지 및 clock skew(시계 오차) 검증을 위한 타임스탬프\n크기: 7바이트 (3바이트 헤더 + 4바이트 데이터)\n형식:\n+----+----+----+----+----+----+----+ | 0 | 4 | timestamp | +----+----+----+----+----+----+----+ 필드:\nblk: 0 size: 4 (big-endian(빅엔디언)) timestamp: 4바이트 - 초 단위의 유닉스 타임스탬프(부호 없는, big-endian) 타임스탬프 형식:\ntimestamp = int(time.time()) # Seconds since 1970-01-01 00:00:00 UTC # Wraps around in year 2106 (4-byte unsigned maximum) 유효성 검사 규칙:\nMAX_CLOCK_SKEW_PAST = 5 * 60 # 5 minutes MAX_CLOCK_SKEW_FUTURE = 2 * 60 # 2 minutes def validate_datetime(timestamp): now = int(time.time()) age = now - timestamp if age \u0026lt; -MAX_CLOCK_SKEW_FUTURE: return False # Too far in future if age \u0026gt; MAX_CLOCK_SKEW_PAST: return False # Too old return True 재전송 공격 방지:\nclass ReplayFilter: def __init__(self, duration=5*60): self.duration = duration # 5 minutes self.seen_messages = BloomFilter(size=100000, false_positive_rate=0.001) self.cleanup_timer = RepeatTimer(60, self.cleanup) def check_replay(self, ephemeral_key, timestamp): # Check timestamp validity if not validate_datetime(timestamp): return False # Check if ephemeral key seen recently if ephemeral_key in self.seen_messages: return False # Replay attack # Add to seen messages self.seen_messages.add(ephemeral_key) return True def cleanup(self): # Expire old entries (Bloom filter automatically ages out) pass 구현 참고 사항:\nNS Messages(NS 메시지): DateTime은 반드시 첫 번째 블록이어야 함 NSR/ES Messages(NSR/ES 메시지): DateTime은 일반적으로 포함되지 않음 Replay Window(리플레이 윈도우): 최소 권장값은 5분 Bloom Filter(블룸 필터): 효율적인 리플레이 탐지를 위해 권장됨 Clock Skew(시계 오차): 과거 5분, 미래 2분 허용 Garlic Clove Block (garlic encryption에서 개별 클로브를 담는 블록) (유형 11) 목적: 전달을 위해 I2NP 메시지를 캡슐화합니다\n형식:\n+----+----+----+----+----+----+----+----+ | 11 | size | | +----+----+----+ + | Delivery Instructions | ~ ~ | | +----+----+----+----+----+----+----+----+ |type| Message_ID | Expiration | +----+----+----+----+----+----+----+----+ | I2NP Message body | +----+ + ~ ~ | | +----+----+----+----+----+----+----+----+ 필드:\nblk: 11 size: clove(garlic encryption에서의 개별 메시지 단위)의 총 크기(가변) Delivery Instructions: I2NP 사양에 명시된 대로 type: I2NP 메시지 유형(1바이트) Message_ID: I2NP 메시지 ID(4바이트) Expiration: 초 단위 Unix 타임스탬프(4바이트) I2NP Message body: 가변 길이의 메시지 데이터 전달 지시 형식:\nLocal Delivery(로컬 전달) (1바이트):\n+----+ |0x00| +----+ 목적지 전달 (33 바이트):\n+----+----+----+----+----+----+----+----+ |0x01| | +----+ Destination Hash + | 32 bytes | + + | | +----+----+----+----+----+----+----+----+ Router 전달 (33 바이트):\n+----+----+----+----+----+----+----+----+ |0x02| | +----+ Router Hash + | 32 bytes | + + | | +----+----+----+----+----+----+----+----+ Tunnel 전달 (37 바이트):\n+----+----+----+----+----+----+----+----+ |0x03| Tunnel ID | +----+----+----+----+----+ + | Router Hash | + 32 bytes + | | + + | | +----+----+----+----+----+----+----+----+ I2NP 메시지 헤더 (총 9바이트):\n+----+----+----+----+----+----+----+----+ |type| msg_id | expiration | +----+----+----+----+----+----+----+----+ | | type: I2NP 메시지 유형 (Database Store, Database Lookup, Data 등) msg_id: 4바이트 메시지 식별자 expiration: 4바이트 유닉스 타임스탬프 (초) ElGamal Clove 형식과의 중요한 차이점:\n인증서 없음: 인증서 필드를 생략함 (ElGamal(엘가말, 공개키 암호 방식)에서는 사용되지 않음) Clove ID 없음: Clove(I2P 메시지 내부의 서브메시지 단위) ID를 생략함 (항상 0이었음) Clove 만료 시간 없음: 대신 I2NP 메시지 만료 시간을 사용함 간결한 헤더: 9바이트 I2NP 헤더 vs 더 큰 ElGamal 형식 각 Clove는 별도의 블록: CloveSet(여러 Clove를 묶는 구조) 구조 없음 여러 개의 Clove(클로브: 하나의 garlic 메시지 안에 포장되는 개별 하위 메시지 단위):\n# Multiple Garlic Cloves in one message payload = [ build_datetime_block(), build_garlic_clove(i2np_message_1), build_garlic_clove(i2np_message_2), build_garlic_clove(i2np_message_3), build_padding_block() ] Cloves(garlic encryption 메시지의 하위 메시지 단위)에서 일반적인 I2NP 메시지 유형:\nType Name Usage 1 DatabaseStore Publishing LeaseSet 2 DatabaseLookup Requesting LeaseSet 5 DeliveryStatus ACK (legacy, avoid in ECIES) 20 Data Streaming data 21 Garlic Nested garlic messages **Clove(클로브, garlic 메시지의 하위 메시지) 처리:** def process_garlic_clove(clove_data): # Parse delivery instructions delivery_type = clove_data[0] if delivery_type == 0x00: # Local delivery offset = 1 elif delivery_type == 0x01: # Destination delivery dest_hash = clove_data[1:33] offset = 33 elif delivery_type == 0x02: # Router delivery router_hash = clove_data[1:33] offset = 33 elif delivery_type == 0x03: # Tunnel delivery tunnel_id = struct.unpack(\u0026#39;\u0026gt;I\u0026#39;, clove_data[1:5])[0] router_hash = clove_data[5:37] offset = 37 # Parse I2NP header i2np_type = clove_data[offset] msg_id = struct.unpack(\u0026#39;\u0026gt;I\u0026#39;, clove_data[offset+1:offset+5])[0] expiration = struct.unpack(\u0026#39;\u0026gt;I\u0026#39;, clove_data[offset+5:offset+9])[0] # Extract I2NP body i2np_body = clove_data[offset+9:] # Process message process_i2np_message(i2np_type, msg_id, expiration, i2np_body) NextKey 블록 (유형 7) 목적: DH ratchet(디피-헬만 기반 래칫) 키 교환\n형식 (키 존재 - 38바이트):\n+----+----+----+----+----+----+----+----+ | 7 | 35 |flag| key ID | | +----+----+----+----+----+----+ + | | + Next DH Ratchet Public Key + | 32 bytes | + + | | + +----+----+ | | +----+----+----+----+----+----+ 형식 (Key ID만 - 6바이트):\n+----+----+----+----+----+----+ | 7 | 3 |flag| key ID | +----+----+----+----+----+----+ 필드:\nblk: 7 size: 3 (ID만) 또는 35 (키 포함) flag: 1 바이트 - 플래그 비트 key ID: 2 바이트 - 빅 엔디안 키 식별자(0-32767) Public Key: 32 바이트 - X25519 공개 키(리틀 엔디안), 플래그 비트 0 = 1인 경우 플래그 비트:\nBit 7 6 5 4 3 2 1 0 | | | | | | | | | | | | | | | +-- Bit 0: Key present (1) or ID only (0) | | | | | | +---- Bit 1: Reverse key (1) or forward key (0) | | | | | +------ Bit 2: Request reverse key (1) or no request (0) | | | | | +-+-+-+-+-------- Bits 3-7: Reserved (set to 0) 플래그 예시:\n# Forward key present flags = 0x01 # Binary: 00000001 # Reverse key present flags = 0x03 # Binary: 00000011 # Forward key ID only (ACK) flags = 0x00 # Binary: 00000000 # Reverse key ID only (ACK) flags = 0x02 # Binary: 00000010 # Forward key ID with reverse request flags = 0x04 # Binary: 00000100 키 ID 규칙:\nID는 순차적임: 0, 1, 2, \u0026hellip;, 32767 ID는 새 키가 생성될 때에만 증가함 다음 ratchet(래칫, 단계적 키 갱신 메커니즘) 전까지는 여러 메시지에 동일한 ID가 사용됨 최대 ID는 32767 (그 이후에는 새 세션을 시작해야 함) 사용 예시:\n# Initiating ratchet (sender generates new key) nextkey = NextKeyBlock( flags=0x01, # Key present, forward key_id=0, public_key=sender_new_pk ) # Replying to ratchet (receiver generates new key) nextkey = NextKeyBlock( flags=0x03, # Key present, reverse key_id=0, public_key=receiver_new_pk ) # Acknowledging ratchet (no new key from sender) nextkey = NextKeyBlock( flags=0x02, # ID only, reverse key_id=0 ) # Requesting reverse ratchet nextkey = NextKeyBlock( flags=0x04, # Request reverse, forward ID key_id=1 ) 처리 로직:\ndef process_nextkey_block(block): flags = block.flags key_id = block.key_id key_present = (flags \u0026amp; 0x01) != 0 is_reverse = (flags \u0026amp; 0x02) != 0 request_reverse = (flags \u0026amp; 0x04) != 0 if key_present: public_key = block.public_key if is_reverse: # Reverse key received perform_dh_ratchet(receiver_key=public_key, key_id=key_id) # Sender should ACK with own key ID else: # Forward key received perform_dh_ratchet(sender_key=public_key, key_id=key_id) # Receiver should reply with reverse key send_reverse_key(generate_new_key()) else: # Key ID only (ACK) if is_reverse: # Reverse key ACK confirm_reverse_ratchet(key_id) else: # Forward key ACK confirm_forward_ratchet(key_id) if request_reverse: # Sender requests receiver to generate new key send_reverse_key(generate_new_key()) 여러 개의 NextKey Blocks(다음 키 블록):\n양방향에서 동시에 ratcheting(키를 단계적으로 갱신하는 절차)을 수행할 때, 단일 ES message는 최대 2개의 NextKey blocks를 포함할 수 있습니다:\n# Both directions ratcheting payload = [ NextKeyBlock(flags=0x01, key_id=2, public_key=forward_key), # Forward NextKeyBlock(flags=0x03, key_id=1, public_key=reverse_key), # Reverse build_garlic_clove(data) ] ACK(확인 응답) 블록 (유형 8) 목적: 수신된 메시지에 대한 수신 확인을 in-band(동일 채널 내에서)으로 수행\n형식 (단일 ACK - 7바이트):\n+----+----+----+----+----+----+----+ | 8 | 4 |tagsetid | N | +----+----+----+----+----+----+----+ 형식 (여러 개의 ACK(확인 응답)):\n+----+----+----+----+----+----+----+----+ | 8 | size |tagsetid | N | | +----+----+----+----+----+----+----+ + | more ACKs | ~ ... ~ | | +----+----+----+----+----+----+----+----+ 필드:\nblk: 8 size: 4 * ACK의 개수(최소 4) 각 ACK에 대해: tagsetid: 2바이트 - 빅엔디언 태그 세트 ID (0-65535) N: 2바이트 - 빅엔디언 메시지 번호 (0-65535) 태그 세트 ID 결정:\n# Tag set 0 (initial, after NSR) tagset_id = 0 # After first ratchet (tag set 1) # Both Alice and Bob sent key ID 0 tagset_id = 1 + 0 + 0 = 1 # After second ratchet (tag set 2) # Alice sent key ID 1, Bob still using key ID 0 tagset_id = 1 + 1 + 0 = 2 # After third ratchet (tag set 3) # Alice still using key ID 1, Bob sent key ID 1 tagset_id = 1 + 1 + 1 = 3 단일 ACK(확인 응답) 예시:\n# ACK message from tag set 5, message number 127 ack_block = ACKBlock( tagset_id=5, message_number=127 ) # Wire format (7 bytes): # 08 00 04 00 05 00 7F # | | | | | | | # | | | | | | +-- N (127) # | | | | +--------- N high byte # | | | +------------ tagset_id (5) # | | +--------------- tagset_id high byte # | +------------------ size (4) # +--------------------- type (8) 여러 ACK(승인) 예시:\n# ACK three messages ack_block = ACKBlock([ (tagset_id=3, N=42), (tagset_id=3, N=43), (tagset_id=4, N=0) ]) # Wire format (15 bytes): # 08 00 0C 00 03 00 2A 00 03 00 2B 00 04 00 00 # (ts=3, N=42) (ts=3, N=43) (ts=4, N=0) 처리:\ndef process_ack_block(block): num_acks = block.size // 4 for i in range(num_acks): offset = i * 4 tagset_id = struct.unpack(\u0026#39;\u0026gt;H\u0026#39;, block.data[offset:offset+2])[0] message_num = struct.unpack(\u0026#39;\u0026gt;H\u0026#39;, block.data[offset+2:offset+4])[0] # Mark message as acknowledged mark_acked(tagset_id, message_num) # May trigger retransmission timeout cancellation cancel_retransmit_timer(tagset_id, message_num) ACK(승인 응답)을 언제 보낼지:\n명시적 ACK Request: ACK Request 블록에는 항상 응답 LeaseSet 전달: 발신자가 메시지에 LeaseSet을 포함할 때 세션 설정: NS/NSR을 ACK할 수 있음(프로토콜은 ES를 통한 암시적 ACK를 선호함) Ratchet(단계적 키 갱신 메커니즘) 확인: NextKey 수신을 ACK할 수 있음 애플리케이션 계층: 상위 계층 프로토콜의 요구에 따라(예: Streaming) ACK(승인) 타이밍:\nclass ACKManager: def __init__(self): self.pending_acks = [] self.ack_timer = None def request_ack(self, tagset_id, message_num): self.pending_acks.append((tagset_id, message_num)) if not self.ack_timer: # Delay ACK briefly to allow higher layer to respond self.ack_timer = set_timer(0.1, self.send_acks) # 100ms def send_acks(self): if self.pending_acks and not has_outbound_data(): # No higher layer data, send explicit ACK send_es_message(build_ack_block(self.pending_acks)) # Otherwise, ACK will piggyback on next ES message self.pending_acks = [] self.ack_timer = None ACK 요청 블록 (타입 9) 목적: 현재 메시지에 대한 인밴드 수신 확인을 요청\n형식:\n+----+----+----+----+ | 9 | 1 |flg | +----+----+----+----+ 필드:\nblk: 9 size: 1 flg: 1바이트 - 플래그(현재 모든 비트는 미사용이며 0으로 설정됨) 사용법:\n# Request ACK for this message payload = [ build_ack_request_block(), build_garlic_clove(important_data) ] 수신자 응답:\nACK 요청을 수신했을 때:\n즉시 데이터가 있는 경우: 즉시 응답에 ACK(확인 응답) 블록을 포함 즉시 데이터가 없는 경우: 타이머를 시작하고(예: 100ms), 타이머가 만료되면 ACK와 함께 빈 ES를 전송 태그 세트 ID: 현재 인바운드 태그세트 ID를 사용 메시지 번호: 수신된 세션 태그에 연관된 메시지 번호를 사용 처리:\ndef process_ack_request(message): # Extract message identification tagset_id = message.tagset_id message_num = message.message_num # Schedule ACK schedule_ack(tagset_id, message_num) # If no data to send immediately, start timer if not has_pending_data(): set_timer(0.1, lambda: send_ack_only(tagset_id, message_num)) ACK 요청을 언제 사용해야 하나요:\n중요한 메시지: 반드시 확인되어야 하는 메시지 LeaseSet 전달: LeaseSet을 함께 묶어 보낼 때 세션 래칫: NextKey block(다음 키 블록)을 전송한 뒤 전송 종료: 송신자가 더 보낼 데이터는 없지만 확인을 원할 때 사용하지 말아야 할 때:\nStreaming Protocol: 스트리밍 계층이 ACK를 처리합니다 High Frequency Messages: 모든 메시지마다 ACK 요청을 피하세요(오버헤드) Unimportant Datagrams: 원시 데이터그램은 일반적으로 ACK가 필요하지 않습니다 종료 블록 (유형 4) 상태: 미구현\n목적: 세션을 정상적으로 종료\n형식:\n+----+----+----+----+----+----+----+----+ | 4 | size | rsn| addl data | +----+----+----+----+ + ~ ... ~ +----+----+----+----+----+----+----+----+ 필드:\nblk: 4 size: 1바이트 이상 rsn: 1바이트 - 이유 코드 addl data: 선택적 추가 데이터 (형식은 이유에 따라 다름) 사유 코드:\nCode Meaning Additional Data 0 Normal close / unspecified None 1 Termination received None 2 Idle timeout None (implementation-specific) 3 Resource exhaustion None (implementation-specific) 4+ Reserved Implementation-specific **사용 방법(구현되면):** # Normal session close termination = TerminationBlock( reason=0, additional_data=b\u0026#39;\u0026#39; ) # Session termination due to received termination termination = TerminationBlock( reason=1, additional_data=b\u0026#39;\u0026#39; ) 규칙:\nPadding(패딩)을 제외하면 반드시 마지막 블록이어야 함 존재하는 경우 Padding은 Termination(종료) 뒤에 반드시 와야 함 NS 또는 NSR 메시지에서는 허용되지 않음 ES 메시지에서만 허용됨 옵션 블록 (타입 5) 상태: 미구현\n목적: 세션 매개변수 협상\n형식:\n+----+----+----+----+----+----+----+----+ | 5 | size |ver |flg |STL |STimeout | +----+----+----+----+----+----+----+----+ | SOTW | RITW |tmin|tmax|rmin|rmax| +----+----+----+----+----+----+----+----+ | tdmy | rdmy | tdelay | rdelay | +----+----+----+----+----+----+----+----+ | more_options | ~ ... ~ | | +----+----+----+----+----+----+----+----+ 필드:\nblk: 5 size: 21바이트 이상 ver: 1바이트 - 프로토콜 버전(0이어야 함) flg: 1바이트 - 플래그(현재 모든 비트 미사용) STL: 1바이트 - 세션 태그 길이(8이어야 함) STimeout: 2바이트 - 세션 유휴 타임아웃(초, 빅 엔디언) SOTW: 2바이트 - 송신자 아웃바운드 태그 윈도우(빅 엔디언) RITW: 2바이트 - 수신자 인바운드 태그 윈도우(빅 엔디언) tmin, tmax, rmin, rmax: 각 1바이트 - 패딩 파라미터(4.4 고정소수점) tdmy: 2바이트 - 보내려는 최대 더미 트래픽(바이트/초, 빅 엔디언) rdmy: 2바이트 - 요청된 더미 트래픽(바이트/초, 빅 엔디언) tdelay: 2바이트 - 삽입하려는 최대 메시지 내부 지연(밀리초, 빅 엔디언) rdelay: 2바이트 - 요청된 메시지 내부 지연(밀리초, 빅 엔디언) more_options: 가변 길이 - 향후 확장 패딩 매개변수 (4.4 고정소수점):\ndef encode_padding_ratio(ratio): \u0026#34;\u0026#34;\u0026#34; Encode padding ratio as 4.4 fixed-point ratio: 0.0 to 15.9375 returns: 0x00 to 0xFF \u0026#34;\u0026#34;\u0026#34; return int(ratio * 16) def decode_padding_ratio(encoded): \u0026#34;\u0026#34;\u0026#34; Decode 4.4 fixed-point to ratio encoded: 0x00 to 0xFF returns: 0.0 to 15.9375 \u0026#34;\u0026#34;\u0026#34; return encoded / 16.0 # Examples: # 0x00 = 0.0 (no padding) # 0x01 = 0.0625 (6.25% padding) # 0x10 = 1.0 (100% padding - double traffic) # 0x80 = 8.0 (800% padding - 9x traffic) # 0xFF = 15.9375 (1593.75% padding) Tag Window Negotiation(태그 윈도우 협상):\n# SOTW: Sender\u0026#39;s recommendation for receiver\u0026#39;s inbound window # RITW: Sender\u0026#39;s declaration of own inbound window # Receiver calculates actual inbound window: inbound_window = calculate_window( sender_suggestion=SOTW, own_constraints=MAX_INBOUND_TAGS, own_resources=available_memory() ) # Sender uses: # - RITW to know how far ahead receiver will accept # - Own SOTW to hint optimal window size 기본값(옵션이 협상되지 않은 경우):\nDEFAULT_OPTIONS = { \u0026#39;version\u0026#39;: 0, \u0026#39;session_tag_length\u0026#39;: 8, \u0026#39;session_timeout\u0026#39;: 600, # 10 minutes \u0026#39;sender_outbound_tag_window\u0026#39;: 160, \u0026#39;receiver_inbound_tag_window\u0026#39;: 160, \u0026#39;tmin\u0026#39;: 0x00, # No minimum padding \u0026#39;tmax\u0026#39;: 0x10, # Up to 100% padding \u0026#39;rmin\u0026#39;: 0x00, # No minimum requested \u0026#39;rmax\u0026#39;: 0x10, # Up to 100% requested \u0026#39;tdmy\u0026#39;: 0, # No dummy traffic \u0026#39;rdmy\u0026#39;: 0, # No dummy traffic requested \u0026#39;tdelay\u0026#39;: 0, # No delay \u0026#39;rdelay\u0026#39;: 0 # No delay requested } MessageNumbers(메시지 번호) 블록 (유형 6) 상태: 미구현\n목적: 이전 태그 세트에서 전송된 마지막 메시지를 표시하여 누락 감지를 가능하게 함\n형식:\n+----+----+----+----+----+ | 6 | 2 | PN | +----+----+----+----+----+ 필드:\nblk: 6 size: 2 PN: 2바이트 - 이전 태그 세트의 마지막 메시지 번호(빅엔디언, 0-65535) PN (이전 번호) 정의:\nPN은 이전 태그 세트에서 보낸 마지막 태그의 인덱스입니다.\n사용법(구현되면):\n# After ratcheting to new tag set # Old tag set: sent messages 0-4095 # New tag set: sending first message payload = [ MessageNumbersBlock(PN=4095), build_garlic_clove(data) ] 수신자 이점:\ndef process_message_numbers(pn_value): # Receiver can now: # 1. Determine if any messages were skipped highest_received_in_old_tagset = 4090 if pn_value \u0026gt; highest_received_in_old_tagset: missing_count = pn_value - highest_received_in_old_tagset # 5 messages were never received # 2. Delete tags higher than PN from old tagset for tag_index in range(pn_value + 1, MAX_TAG_INDEX): delete_tag(old_tagset, tag_index) # 3. Expire tags ≤ PN after grace period (e.g., 2 minutes) schedule_deletion(old_tagset, delay=120) 규칙:\ntag set(태그 세트) 0(이전 tag set 없음)에서는 절대 전송하면 안 됨 ES 메시지에서만 전송됨 새로운 tag set의 최초 메시지(들)에서만 전송됨 PN 값은 발신자 관점 기준임(발신자가 마지막으로 보낸 tag(태그)) Signal과의 관계:\nSignal Double Ratchet(시그널 프로토콜의 더블 래칫 알고리즘)에서는 PN(이전 체인 길이)이 메시지 헤더에 포함된다. ECIES(타원곡선 통합 암호화 체계)에서는 암호화된 페이로드에 포함되며 선택 사항이다.\n패딩 블록 (유형 254) 목적: 트래픽 분석 저항성과 메시지 크기 난독화\n형식:\n+----+----+----+----+----+----+----+----+ |254 | size | padding | +----+----+----+ + | | ~ ... ~ | | +----+----+----+----+----+----+----+----+ 필드:\nblk: 254 size: 0-65516 바이트 (빅엔디언) padding: 무작위 데이터 또는 0으로 채운 데이터 규칙:\n반드시 메시지에서 마지막 블록이어야 함 여러 개의 패딩 블록은 허용되지 않음 길이가 0일 수 있음(3바이트 헤더만) 패딩 데이터는 0으로 채우거나 임의의 바이트일 수 있음 기본 패딩:\nDEFAULT_PADDING_MIN = 0 DEFAULT_PADDING_MAX = 15 def generate_default_padding(): size = random.randint(DEFAULT_PADDING_MIN, DEFAULT_PADDING_MAX) data = random.bytes(size) # or zeros return PaddingBlock(size, data) 트래픽 분석 저항 전략:\n전략 1: 무작위 크기(기본값)\n# Add 0-15 bytes random padding to each message padding_size = random.randint(0, 15) padding_block = PaddingBlock(padding_size, random.bytes(padding_size)) 전략 2: 배수로 반올림\n# Round total message size to next multiple of 64 target_size = ((message_size + 63) // 64) * 64 padding_size = target_size - message_size - 3 # -3 for block header padding_block = PaddingBlock(padding_size, random.bytes(padding_size)) 전략 3: 고정 메시지 크기\n# Always send 1KB messages TARGET_MESSAGE_SIZE = 1024 padding_size = TARGET_MESSAGE_SIZE - message_size - 3 padding_block = PaddingBlock(padding_size, random.bytes(padding_size)) 전략 4: 협상된 패딩 (Options block(옵션 블록))\n# Calculate padding based on negotiated parameters # tmin, tmax from Options block min_padding = int(payload_size * tmin_ratio) max_padding = int(payload_size * tmax_ratio) padding_size = random.randint(min_padding, max_padding) padding_block = PaddingBlock(padding_size, random.bytes(padding_size)) 패딩 전용 메시지:\n메시지는 전적으로 패딩으로만 구성될 수 있습니다(애플리케이션 데이터 없음):\n# Dummy traffic message payload = [ PaddingBlock(random.randint(100, 500), random.bytes(...)) ] 구현 참고 사항:\n올-제로 패딩: 허용됨(ChaCha20(스트림 암호 알고리즘)에 의해 암호화됨) 무작위 패딩: 암호화 후에는 추가적인 보안을 제공하지 않지만 더 많은 엔트로피를 사용함 성능: 무작위 패딩 생성은 비용이 많이 들 수 있으므로 0 사용을 고려 메모리: 큰 패딩 블록은 대역폭을 소모하므로 최대 크기에 주의 구현 가이드 사전 준비 사항 암호화 라이브러리:\nX25519: libsodium, NaCl, 또는 Bouncy Castle ChaCha20-Poly1305: libsodium, OpenSSL 1.1.0+, 또는 Bouncy Castle SHA-256: OpenSSL, Bouncy Castle, 또는 언어의 내장 지원 Elligator2: 라이브러리 지원이 제한적임; 사용자 정의 구현이 필요할 수 있음 Elligator2(타원곡선 점을 무작위 데이터처럼 보이게 하는 매핑 기법) 구현:\nElligator2(암호학적 매핑 기법)은 널리 구현되어 있지 않습니다. 옵션:\nOBFS4: Tor의 obfs4 pluggable transport(플러그형 전송)는 Elligator2 구현을 포함합니다 Custom Implementation: Elligator2 paper 를 기반으로 합니다 kleshni/Elligator: GitHub의 참조 구현 Java I2P 참고: Java I2P는 사용자 지정 Elligator2(암호학적 매핑 기법) 추가 기능이 포함된 net.i2p.crypto.eddsa 라이브러리를 사용합니다.\n권장 구현 순서 1단계: 핵심 암호 기술 1. X25519 DH 키 생성 및 교환 2. ChaCha20-Poly1305 AEAD 암호화/복호화 3. SHA-256 해싱 및 MixHash 4. HKDF 키 파생 5. Elligator2 인코딩/디코딩(초기에는 테스트 벡터를 사용할 수 있음)\n2단계: 메시지 형식 1. NS 메시지 (바인딩되지 않음) - 가장 단순한 형식 2. NS 메시지 (바인딩됨) - 정적 키 추가 3. NSR 메시지 4. ES 메시지 5. 블록 파싱 및 생성\n3단계: 세션 관리 1. 세션 생성 및 저장 2. 태그 집합 관리(송신자와 수신자) 3. 세션 태그 ratchet(래칫: 단계적으로 키를 갱신하는 암호 메커니즘) 4. 대칭키 ratchet 5. 태그 조회 및 윈도우 관리\n4단계: DH 래칫팅 1. NextKey 블록 처리 2. DH 래칫 KDF(키 유도 함수) 3. 래칫 이후 태그 세트 생성 4. 다중 태그 세트 관리\n5단계: 프로토콜 로직 1. NS/NSR/ES 상태 머신 2. 재생 공격 방지 (DateTime(날짜/시간), Bloom filter(블룸 필터)) 3. 재전송 로직 (복수의 NS/NSR) 4. ACK(확인 응답) 처리\n6단계: 통합 1. I2NP Garlic Clove(서브메시지 단위) 처리 2. LeaseSet 번들링 3. 스트리밍 프로토콜 통합 4. 데이터그램 프로토콜 통합\n송신자 구현 아웃바운드 세션 수명주기:\nclass OutboundSession: def __init__(self, destination, bound=True): self.destination = destination self.bound = bound self.state = SessionState.NEW # Keys for NS message self.ephemeral_keypair = generate_elg2_keypair() if bound: self.static_key = context.static_keypair # Will be populated after NSR self.outbound_tagset = None self.outbound_keyratchet = None self.inbound_tagset = None self.inbound_keyratchet = None # Timing self.created_time = now() self.last_activity = now() # Retransmission self.ns_attempts = [] self.ns_timer = None def send_initial_message(self, payload): \u0026#34;\u0026#34;\u0026#34;Send NS message\u0026#34;\u0026#34;\u0026#34; # Build NS message ns_message = self.build_ns_message(payload) # Send send_to_network(self.destination, ns_message) # Track for retransmission self.ns_attempts.append({ \u0026#39;message\u0026#39;: ns_message, \u0026#39;time\u0026#39;: now(), \u0026#39;ephemeral_key\u0026#39;: self.ephemeral_keypair, \u0026#39;kdf_state\u0026#39;: self.save_kdf_state() }) # Start timer self.ns_timer = set_timer(1.0, self.on_ns_timeout) self.state = SessionState.PENDING_REPLY def build_ns_message(self, payload): \u0026#34;\u0026#34;\u0026#34;Construct NS message\u0026#34;\u0026#34;\u0026#34; # KDF initialization chainKey, h = self.initialize_kdf() # Ephemeral key section elg2_ephemeral = ENCODE_ELG2(self.ephemeral_keypair.public_key) h = SHA256(h || self.destination.static_key) h = SHA256(h || self.ephemeral_keypair.public_key) # es DH es_shared = DH(self.ephemeral_keypair.private_key, self.destination.static_key) keydata = HKDF(chainKey, es_shared, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k_static = keydata[32:63] # Encrypt static key section if self.bound: static_section = self.static_key.public_key else: static_section = bytes(32) static_ciphertext = ENCRYPT(k_static, 0, static_section, h) h = SHA256(h || static_ciphertext) # ss DH (if bound) if self.bound: ss_shared = DH(self.static_key.private_key, self.destination.static_key) keydata = HKDF(chainKey, ss_shared, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k_payload = keydata[32:63] nonce = 0 else: k_payload = k_static nonce = 1 # Build payload blocks payload_data = self.build_ns_payload(payload) # Encrypt payload payload_ciphertext = ENCRYPT(k_payload, nonce, payload_data, h) h = SHA256(h || payload_ciphertext) # Save KDF state for NSR processing self.ns_chainkey = chainKey self.ns_hash = h # Assemble message return elg2_ephemeral + static_ciphertext + payload_ciphertext def build_ns_payload(self, application_data): \u0026#34;\u0026#34;\u0026#34;Build NS payload blocks\u0026#34;\u0026#34;\u0026#34; blocks = [] # DateTime block (required, first) blocks.append(build_datetime_block()) # Garlic Clove(s) with application data blocks.append(build_garlic_clove(application_data)) # Optionally bundle LeaseSet if should_send_leaseset(): blocks.append(build_garlic_clove(build_leaseset_store())) # Padding blocks.append(build_padding_block(random.randint(0, 15))) return encode_blocks(blocks) def on_nsr_received(self, nsr_message): \u0026#34;\u0026#34;\u0026#34;Process NSR and establish ES session\u0026#34;\u0026#34;\u0026#34; # Cancel retransmission timer cancel_timer(self.ns_timer) # Parse NSR tag = nsr_message[0:8] elg2_bob_ephemeral = nsr_message[8:40] key_section_mac = nsr_message[40:56] payload_ciphertext = nsr_message[56:] # Find corresponding NS attempt ns_state = self.find_ns_by_tag(tag) if not ns_state: raise ValueError(\u0026#34;NSR tag doesn\u0026#39;t match any NS\u0026#34;) # Restore KDF state chainKey = ns_state[\u0026#39;chainkey\u0026#39;] h = ns_state[\u0026#39;hash\u0026#39;] # Decode Bob\u0026#39;s ephemeral key bob_ephemeral = DECODE_ELG2(elg2_bob_ephemeral) # Mix tag and Bob\u0026#39;s ephemeral into hash h = SHA256(h || tag) h = SHA256(h || bob_ephemeral) # ee DH ee_shared = DH(self.ephemeral_keypair.private_key, bob_ephemeral) keydata = HKDF(chainKey, ee_shared, \u0026#34;\u0026#34;, 32) chainKey = keydata[0:31] # se DH se_shared = DH(self.static_key.private_key, bob_ephemeral) keydata = HKDF(chainKey, se_shared, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k_key_section = keydata[32:63] # Verify key section MAC try: DECRYPT(k_key_section, 0, key_section_mac, h) except AuthenticationError: raise ValueError(\u0026#34;NSR key section MAC verification failed\u0026#34;) h = SHA256(h || key_section_mac) # Split for bidirectional ES keydata = HKDF(chainKey, ZEROLEN, \u0026#34;\u0026#34;, 64) k_ab = keydata[0:31] # Alice → Bob k_ba = keydata[32:63] # Bob → Alice # Initialize ES tagsets self.outbound_tagset = DH_INITIALIZE(chainKey, k_ab) self.inbound_tagset = DH_INITIALIZE(chainKey, k_ba) # Decrypt NSR payload k_nsr = HKDF(k_ba, ZEROLEN, \u0026#34;AttachPayloadKDF\u0026#34;, 32) try: payload = DECRYPT(k_nsr, 0, payload_ciphertext, h) except AuthenticationError: raise ValueError(\u0026#34;NSR payload MAC verification failed\u0026#34;) # Process NSR payload blocks self.process_payload_blocks(payload) # Session established self.state = SessionState.ESTABLISHED self.last_activity = now() # Send ES message (implicit ACK) self.send_es_ack() def send_es_message(self, payload): \u0026#34;\u0026#34;\u0026#34;Send ES message\u0026#34;\u0026#34;\u0026#34; if self.state != SessionState.ESTABLISHED: raise ValueError(\u0026#34;Session not established\u0026#34;) # Get next tag and key tag, index = self.outbound_tagset.get_next_tag() key = self.outbound_keyratchet.get_key(index) # Construct nonce nonce = construct_nonce(index) # Build payload blocks payload_data = self.build_es_payload(payload) # AEAD encryption ciphertext = ENCRYPT(key, nonce, payload_data, tag) # Assemble message es_message = tag + ciphertext # Send send_to_network(self.destination, es_message) # Update activity self.last_activity = now() # Check if ratchet needed if self.outbound_tagset.should_ratchet(): self.initiate_ratchet() 수신기 구현 인바운드 세션 라이프사이클:\nclass InboundSession: def __init__(self): self.state = None self.bound = False self.destination = None # Keys self.remote_ephemeral_key = None self.remote_static_key = None self.ephemeral_keypair = None # Tagsets self.inbound_tagset = None self.outbound_tagset = None # Timing self.created_time = None self.last_activity = None # Paired session self.paired_outbound = None @staticmethod def try_decrypt_ns(message): \u0026#34;\u0026#34;\u0026#34;Attempt to decrypt as NS message\u0026#34;\u0026#34;\u0026#34; # Parse NS structure elg2_ephemeral = message[0:32] static_ciphertext = message[32:80] # 32 + 16 payload_ciphertext = message[80:] # Decode ephemeral key try: alice_ephemeral = DECODE_ELG2(elg2_ephemeral) except: return None # Not a valid Elligator2 encoding # Check replay if is_replay(alice_ephemeral): return None # KDF initialization chainKey, h = initialize_kdf() # Mix keys h = SHA256(h || context.static_keypair.public_key) h = SHA256(h || alice_ephemeral) # es DH es_shared = DH(context.static_keypair.private_key, alice_ephemeral) keydata = HKDF(chainKey, es_shared, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k_static = keydata[32:63] # Decrypt static key section try: static_data = DECRYPT(k_static, 0, static_ciphertext, h) except AuthenticationError: return None # Not a valid NS message h = SHA256(h || static_ciphertext) # Check if bound or unbound if static_data == bytes(32): # Unbound alice_static_key = None k_payload = k_static nonce = 1 else: # Bound - perform ss DH alice_static_key = static_data ss_shared = DH(context.static_keypair.private_key, alice_static_key) keydata = HKDF(chainKey, ss_shared, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k_payload = keydata[32:63] nonce = 0 # Decrypt payload try: payload = DECRYPT(k_payload, nonce, payload_ciphertext, h) except AuthenticationError: return None h = SHA256(h || payload_ciphertext) # Create session session = InboundSession() session.state = SessionState.ESTABLISHED session.created_time = now() session.last_activity = now() session.remote_ephemeral_key = alice_ephemeral session.remote_static_key = alice_static_key session.bound = (alice_static_key is not None) session.ns_chainkey = chainKey session.ns_hash = h # Extract destination if bound if session.bound: session.destination = extract_destination_from_payload(payload) # Process payload session.process_payload_blocks(payload) return session def send_nsr_reply(self, reply_payload): \u0026#34;\u0026#34;\u0026#34;Send NSR message\u0026#34;\u0026#34;\u0026#34; # Generate NSR tagset tagsetKey = HKDF(self.ns_chainkey, ZEROLEN, \u0026#34;SessionReplyTags\u0026#34;, 32) nsr_tagset = DH_INITIALIZE(self.ns_chainkey, tagsetKey) # Get tag tag, _ = nsr_tagset.get_next_tag() # Mix tag into hash h = SHA256(self.ns_hash || tag) # Generate ephemeral key self.ephemeral_keypair = generate_elg2_keypair() bob_ephemeral = self.ephemeral_keypair.public_key elg2_bob_ephemeral = ENCODE_ELG2(bob_ephemeral) # Mix ephemeral key h = SHA256(h || bob_ephemeral) chainKey = self.ns_chainkey # ee DH ee_shared = DH(self.ephemeral_keypair.private_key, self.remote_ephemeral_key) keydata = HKDF(chainKey, ee_shared, \u0026#34;\u0026#34;, 32) chainKey = keydata[0:31] # se DH se_shared = DH(context.static_keypair.private_key, self.remote_ephemeral_key) keydata = HKDF(chainKey, se_shared, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k_key_section = keydata[32:63] # Encrypt key section (empty) key_section_ciphertext = ENCRYPT(k_key_section, 0, ZEROLEN, h) h = SHA256(h || key_section_ciphertext) # Split for bidirectional ES keydata = HKDF(chainKey, ZEROLEN, \u0026#34;\u0026#34;, 64) k_ab = keydata[0:31] # Alice → Bob k_ba = keydata[32:63] # Bob → Alice # Initialize ES tagsets self.inbound_tagset = DH_INITIALIZE(chainKey, k_ab) self.outbound_tagset = DH_INITIALIZE(chainKey, k_ba) # Build reply payload payload_data = build_payload_blocks(reply_payload) # Encrypt payload k_nsr = HKDF(k_ba, ZEROLEN, \u0026#34;AttachPayloadKDF\u0026#34;, 32) payload_ciphertext = ENCRYPT(k_nsr, 0, payload_data, h) # Assemble NSR nsr_message = tag + elg2_bob_ephemeral + key_section_ciphertext + payload_ciphertext # Send send_to_network(self.destination, nsr_message) # Wait for ES self.state = SessionState.AWAITING_ES self.last_activity = now() def on_es_received(self, es_message): \u0026#34;\u0026#34;\u0026#34;Process first ES message\u0026#34;\u0026#34;\u0026#34; if self.state == SessionState.AWAITING_ES: # First ES received, confirms session self.state = SessionState.ESTABLISHED # Process ES message self.process_es_message(es_message) def process_es_message(self, es_message): \u0026#34;\u0026#34;\u0026#34;Decrypt and process ES message\u0026#34;\u0026#34;\u0026#34; # Extract tag tag = es_message[0:8] ciphertext = es_message[8:] # Look up tag index = self.inbound_tagset.lookup_tag(tag) if index is None: raise ValueError(\u0026#34;Tag not found\u0026#34;) # Get key key = self.inbound_keyratchet.get_key(index) # Construct nonce nonce = construct_nonce(index) # Decrypt try: payload = DECRYPT(key, nonce, ciphertext, tag) except AuthenticationError: raise ValueError(\u0026#34;ES MAC verification failed\u0026#34;) # Process blocks self.process_payload_blocks(payload) # Update activity self.last_activity = now() 메시지 분류 메시지 유형 구분:\ndef classify_message(message): \u0026#34;\u0026#34;\u0026#34;Determine message type\u0026#34;\u0026#34;\u0026#34; # Minimum lengths if len(message) \u0026lt; 24: return None # Too short # Check for session tag (8 bytes) tag = message[0:8] # Try ES decryption first (most common) session = lookup_session_by_tag(tag) if session: return (\u0026#39;ES\u0026#39;, session) # Try NSR decryption (tag + Elligator2 key) if len(message) \u0026gt;= 72: # Check if bytes 8-40 are valid Elligator2 try: nsr_ephemeral = DECODE_ELG2(message[8:40]) nsr_session = find_pending_nsr_by_tag(tag) if nsr_session: return (\u0026#39;NSR\u0026#39;, nsr_session) except: pass # Try NS decryption (starts with Elligator2 key) if len(message) \u0026gt;= 96: try: ns_ephemeral = DECODE_ELG2(message[0:32]) ns_session = InboundSession.try_decrypt_ns(message) if ns_session: return (\u0026#39;NS\u0026#39;, ns_session) except: pass # Check ElGamal/AES (for dual-key compatibility) if len(message) \u0026gt;= 514: if (len(message) - 2) % 16 == 0: # Might be ElGamal NS return (\u0026#39;ELGAMAL_NS\u0026#39;, None) elif len(message) % 16 == 0: # Might be ElGamal ES return (\u0026#39;ELGAMAL_ES\u0026#39;, None) return None # Unknown message type 세션 관리 모범 사례 세션 저장소:\nclass SessionKeyManager: def __init__(self): # Outbound sessions (one per destination) self.outbound_sessions = {} # destination -\u0026gt; OutboundSession # Inbound sessions (multiple per destination during transition) self.inbound_sessions = [] # [InboundSession] # Session tag lookup (fast path for ES messages) self.tag_to_session = {} # tag -\u0026gt; InboundSession # Limits self.max_inbound_sessions = 1000 self.max_tags_per_session = 160 def get_outbound_session(self, destination): \u0026#34;\u0026#34;\u0026#34;Get or create outbound session\u0026#34;\u0026#34;\u0026#34; if destination not in self.outbound_sessions: session = OutboundSession(destination) self.outbound_sessions[destination] = session return self.outbound_sessions[destination] def add_inbound_session(self, session): \u0026#34;\u0026#34;\u0026#34;Add new inbound session\u0026#34;\u0026#34;\u0026#34; # Check limits if len(self.inbound_sessions) \u0026gt;= self.max_inbound_sessions: self.expire_oldest_session() self.inbound_sessions.append(session) # Add tags to lookup table self.register_session_tags(session) def register_session_tags(self, session): \u0026#34;\u0026#34;\u0026#34;Register session\u0026#39;s tags in lookup table\u0026#34;\u0026#34;\u0026#34; for tag in session.inbound_tagset.get_all_tags(): self.tag_to_session[tag] = session def lookup_tag(self, tag): \u0026#34;\u0026#34;\u0026#34;Fast tag lookup\u0026#34;\u0026#34;\u0026#34; return self.tag_to_session.get(tag) def expire_sessions(self): \u0026#34;\u0026#34;\u0026#34;Periodic session expiration\u0026#34;\u0026#34;\u0026#34; now_time = now() # Expire outbound sessions for dest, session in list(self.outbound_sessions.items()): if session.idle_time(now_time) \u0026gt; 8 * 60: del self.outbound_sessions[dest] # Expire inbound sessions expired = [] for session in self.inbound_sessions: if session.idle_time(now_time) \u0026gt; 10 * 60: expired.append(session) for session in expired: self.remove_inbound_session(session) def remove_inbound_session(self, session): \u0026#34;\u0026#34;\u0026#34;Remove inbound session and clean up tags\u0026#34;\u0026#34;\u0026#34; self.inbound_sessions.remove(session) # Remove tags from lookup for tag in session.inbound_tagset.get_all_tags(): if tag in self.tag_to_session: del self.tag_to_session[tag] 메모리 관리:\nclass TagMemoryManager: def __init__(self, max_memory_kb=10240): # 10 MB default self.max_memory = max_memory_kb * 1024 self.current_memory = 0 self.max_tags_per_session = 160 self.min_tags_per_session = 32 def calculate_tag_memory(self, session): \u0026#34;\u0026#34;\u0026#34;Calculate memory used by session tags\u0026#34;\u0026#34;\u0026#34; tag_count = len(session.inbound_tagset.tags) # Each tag: 8 bytes (tag) + 2 bytes (index) + 32 bytes (key, optional) # + overhead bytes_per_tag = 16 if session.defer_keys else 48 return tag_count * bytes_per_tag def check_pressure(self): \u0026#34;\u0026#34;\u0026#34;Check if under memory pressure\u0026#34;\u0026#34;\u0026#34; return self.current_memory \u0026gt; (self.max_memory * 0.9) def handle_pressure(self): \u0026#34;\u0026#34;\u0026#34;Reduce memory usage when under pressure\u0026#34;\u0026#34;\u0026#34; if not self.check_pressure(): return # Strategy 1: Reduce look-ahead windows for session in all_sessions: if session.look_ahead \u0026gt; self.min_tags_per_session: session.reduce_look_ahead(self.min_tags_per_session) # Strategy 2: Trim old tags aggressively for session in all_sessions: session.inbound_tagset.trim_behind(aggressive=True) # Strategy 3: Refuse new ratchets for session in all_sessions: if session.outbound_tagset.should_ratchet(): session.defer_ratchet = True # Strategy 4: Expire idle sessions early expire_idle_sessions(threshold=5*60) # 5 min instead of 10 테스트 전략 단위 테스트:\ndef test_x25519_dh(): \u0026#34;\u0026#34;\u0026#34;Test X25519 key exchange\u0026#34;\u0026#34;\u0026#34; alice_sk = GENERATE_PRIVATE() alice_pk = DERIVE_PUBLIC(alice_sk) bob_sk = GENERATE_PRIVATE() bob_pk = DERIVE_PUBLIC(bob_sk) # Both sides compute same shared secret alice_shared = DH(alice_sk, bob_pk) bob_shared = DH(bob_sk, alice_pk) assert alice_shared == bob_shared def test_elligator2_encode_decode(): \u0026#34;\u0026#34;\u0026#34;Test Elligator2 roundtrip\u0026#34;\u0026#34;\u0026#34; sk = GENERATE_PRIVATE_ELG2() pk = DERIVE_PUBLIC(sk) encoded = ENCODE_ELG2(pk) decoded = DECODE_ELG2(encoded) assert decoded == pk def test_chacha_poly_encrypt_decrypt(): \u0026#34;\u0026#34;\u0026#34;Test ChaCha20-Poly1305 AEAD\u0026#34;\u0026#34;\u0026#34; key = CSRNG(32) nonce = construct_nonce(42) plaintext = b\u0026#34;Hello, I2P!\u0026#34; ad = b\u0026#34;associated_data\u0026#34; ciphertext = ENCRYPT(key, nonce, plaintext, ad) decrypted = DECRYPT(key, nonce, ciphertext, ad) assert decrypted == plaintext def test_session_tag_ratchet(): \u0026#34;\u0026#34;\u0026#34;Test session tag generation\u0026#34;\u0026#34;\u0026#34; sessTag_ck = CSRNG(32) tagset = SessionTagRatchet(sessTag_ck) # Generate 100 tags tags = [tagset.get_next_tag() for _ in range(100)] # All tags should be unique assert len(set(tags)) == 100 # Each tag should be 8 bytes for tag in tags: assert len(tag) == 8 통합 테스트:\ndef test_ns_nsr_handshake(): \u0026#34;\u0026#34;\u0026#34;Test NS/NSR handshake\u0026#34;\u0026#34;\u0026#34; # Alice creates outbound session alice_session = OutboundSession(bob_destination, bound=True) # Alice sends NS ns_message = alice_session.build_ns_message(b\u0026#34;Hello Bob\u0026#34;) # Bob receives NS bob_session = InboundSession.try_decrypt_ns(ns_message) assert bob_session is not None assert bob_session.bound == True # Bob sends NSR nsr_message = bob_session.build_nsr_message(b\u0026#34;Hello Alice\u0026#34;) # Alice receives NSR alice_session.on_nsr_received(nsr_message) assert alice_session.state == SessionState.ESTABLISHED # Both should have matching ES tagsets # (Cannot directly compare, but can test by sending ES messages) def test_es_bidirectional(): \u0026#34;\u0026#34;\u0026#34;Test ES messages in both directions\u0026#34;\u0026#34;\u0026#34; # (After NS/NSR handshake) # Alice sends ES to Bob es_alice_to_bob = alice_session.send_es_message(b\u0026#34;Data from Alice\u0026#34;) # Bob receives ES bob_session.process_es_message(es_alice_to_bob) # Bob sends ES to Alice es_bob_to_alice = bob_session.send_es_message(b\u0026#34;Data from Bob\u0026#34;) # Alice receives ES alice_session.process_es_message(es_bob_to_alice) def test_dh_ratchet(): \u0026#34;\u0026#34;\u0026#34;Test DH ratchet\u0026#34;\u0026#34;\u0026#34; # (After established session) # Alice initiates ratchet alice_session.initiate_ratchet() nextkey_alice = build_nextkey_block( flags=0x01, key_id=0, public_key=alice_new_key ) # Send to Bob bob_session.process_nextkey_block(nextkey_alice) # Bob replies nextkey_bob = build_nextkey_block( flags=0x03, key_id=0, public_key=bob_new_key ) # Send to Alice alice_session.process_nextkey_block(nextkey_bob) # Both should now be using new tagsets assert alice_session.outbound_tagset.id == 1 assert bob_session.inbound_tagset.id == 1 테스트 벡터:\n명세에 따른 테스트 벡터 구현:\nNoise IK Handshake (Noise 프로토콜의 IK 핸드셰이크): 표준 Noise 테스트 벡터를 사용 HKDF (HMAC 기반 키 유도 함수): RFC 5869 테스트 벡터를 사용 ChaCha20-Poly1305 (ChaCha20 스트림 암호와 Poly1305 인증을 결합한 AEAD 알고리즘): RFC 7539 테스트 벡터를 사용 Elligator2 (타원곡선 공개키를 균일 분포처럼 위장하는 매핑): Elligator2 논문 또는 OBFS4의 테스트 벡터를 사용 상호운용성 테스트:\nJava I2P: Java I2P 참조 구현을 대상으로 테스트 i2pd: C++ i2pd 구현을 대상으로 테스트 패킷 캡처: Wireshark dissector(프로토콜 해석기)를 사용해 메시지 형식을 검증(가능한 경우) 교차 구현: 서로 다른 구현 간 송수신이 가능한 테스트 하네스를 구축 성능 고려 사항 키 생성:\nElligator2(키를 무작위 바이트처럼 보이게 인코딩하는 기법) 키 생성은 연산 비용이 큽니다(거부율 50%):\nclass KeyPool: \u0026#34;\u0026#34;\u0026#34;Pre-generate keys in background thread\u0026#34;\u0026#34;\u0026#34; def __init__(self, pool_size=10): self.pool = Queue(maxsize=pool_size) self.generator_thread = Thread(target=self.generate_keys, daemon=True) self.generator_thread.start() def generate_keys(self): while True: if not self.pool.full(): keypair = generate_elg2_keypair() # Also compute encoded form encoded = ENCODE_ELG2(keypair.public_key) self.pool.put((keypair, encoded)) else: sleep(0.1) def get_keypair(self): try: return self.pool.get(timeout=1.0) except Empty: # Pool exhausted, generate inline return generate_elg2_keypair() 태그 조회:\nO(1) 태그 조회를 위해 해시 테이블을 사용하십시오:\nclass FastTagLookup: def __init__(self): self.tag_to_session = {} # Python dict is hash table def add_tag(self, tag, session, index): # 8-byte tag as bytes is hashable self.tag_to_session[tag] = (session, index) def lookup_tag(self, tag): return self.tag_to_session.get(tag) 메모리 최적화:\n대칭 키 생성 연기:\nclass DeferredKeyRatchet: \u0026#34;\u0026#34;\u0026#34;Only generate keys when needed\u0026#34;\u0026#34;\u0026#34; def __init__(self, symmKey_ck): self.chainKey = symmKey_ck self.index = -1 self.cache = LRUCache(maxsize=32) # Cache recent keys def get_key(self, index): # Check cache first if index in self.cache: return self.cache[index] # Generate keys up to index while self.index \u0026lt; index: self.index += 1 keydata = HKDF(self.chainKey, ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) self.chainKey = keydata[0:31] if self.index == index: key = keydata[32:63] self.cache[index] = key return key 배치 처리:\n여러 메시지를 일괄 처리:\ndef process_message_batch(messages): \u0026#34;\u0026#34;\u0026#34;Process multiple messages efficiently\u0026#34;\u0026#34;\u0026#34; results = [] # Group by type ns_messages = [] nsr_messages = [] es_messages = [] for msg in messages: msg_type = classify_message(msg) if msg_type[0] == \u0026#39;NS\u0026#39;: ns_messages.append(msg) elif msg_type[0] == \u0026#39;NSR\u0026#39;: nsr_messages.append(msg) elif msg_type[0] == \u0026#39;ES\u0026#39;: es_messages.append(msg) # Process in batches # ES messages are most common, process first for msg in es_messages: results.append(process_es_message(msg)) for msg in nsr_messages: results.append(process_nsr_message(msg)) for msg in ns_messages: results.append(process_ns_message(msg)) return results 보안 고려사항 위협 모델 공격자의 능력:\n수동 관찰자: 모든 네트워크 트래픽을 관찰할 수 있음 능동 공격자: 메시지를 삽입, 수정, 드롭(폐기), 재전송(리플레이)할 수 있음 침해된 노드: router 또는 목적지를 침해할 수 있음 트래픽 분석: 트래픽 패턴에 대한 통계적 분석을 수행할 수 있음 보안 목표:\n기밀성: 관찰자가 메시지 내용을 볼 수 없음 인증: 발신자 신원 검증 (바운드 세션의 경우) 전방향 기밀성: 키가 유출되더라도 과거 메시지는 비밀로 유지됨 재생 공격 방지: 이전 메시지를 재전송할 수 없음 트래픽 난독화: 핸드셰이크가 무작위 데이터와 구분되지 않음 암호학적 가정 계산적 난이도 가정:\nX25519 CDH: Curve25519에서 계산적 디피-헬만 문제는 풀기 어렵다 ChaCha20 PRF: ChaCha20은 의사난수 함수(PRF)이다 Poly1305 MAC: Poly1305는 선택 메시지 공격에 대해 위조가 불가능하다 SHA-256 CR: SHA-256은 충돌 저항성을 가진다 HKDF Security: HKDF는 키를 추출하고 균일한 분포의 키로 확장한다 보안 수준:\nX25519: ~128비트 보안 강도 (곡선의 차수 2^252) ChaCha20: 256비트 키, 256비트 보안 강도 Poly1305: 128비트 보안 강도 (충돌 확률 기준) SHA-256: 128비트 충돌 저항성, 256비트 전이미지 저항성 키 관리 키 생성:\n# CRITICAL: Use cryptographically secure RNG def CSRNG(length): # GOOD: os.urandom, secrets.token_bytes (Python) # GOOD: /dev/urandom (Linux) # GOOD: BCryptGenRandom (Windows) # BAD: random.random(), Math.random() (NOT cryptographically secure) return os.urandom(length) # CRITICAL: Validate keys def validate_x25519_key(pubkey): # Check for weak keys (all zeros, small order points) if pubkey == bytes(32): raise WeakKeyError(\u0026#34;All-zero public key\u0026#34;) # Perform DH to check for weak shared secrets test_shared = DH(test_private_key, pubkey) if test_shared == bytes(32): raise WeakKeyError(\u0026#34;Results in zero shared secret\u0026#34;) 키 저장소:\n# CRITICAL: Protect private keys class SecureKeyStorage: def __init__(self): # Store in memory with protection self.keys = {} # Option 1: Memory locking (prevent swapping to disk) # mlock(self.keys) # Option 2: Encrypted storage # self.encryption_key = derive_from_password() def store_key(self, key_id, private_key): # Option: Encrypt before storage # encrypted = encrypt(private_key, self.encryption_key) # self.keys[key_id] = encrypted self.keys[key_id] = private_key def delete_key(self, key_id): # Securely wipe memory if key_id in self.keys: key = self.keys[key_id] # Overwrite with zeros before deletion for i in range(len(key)): key[i] = 0 del self.keys[key_id] 키 로테이션:\n# CRITICAL: Rotate keys regularly class KeyRotationPolicy: def __init__(self): self.max_messages_per_tagset = 4096 # Ratchet before 65535 self.max_tagset_age = 10 * 60 # 10 minutes self.max_session_age = 60 * 60 # 1 hour def should_ratchet(self, tagset): return (tagset.messages_sent \u0026gt;= self.max_messages_per_tagset or tagset.age() \u0026gt;= self.max_tagset_age) def should_replace_session(self, session): return session.age() \u0026gt;= self.max_session_age 공격 완화 대책 재전송 공격 완화 기법 DateTime(날짜/시간) 유효성 검사:\nMAX_CLOCK_SKEW_PAST = 5 * 60 MAX_CLOCK_SKEW_FUTURE = 2 * 60 def validate_datetime(timestamp): now = int(time.time()) age = now - timestamp if age \u0026lt; -MAX_CLOCK_SKEW_FUTURE: raise ReplayError(\u0026#34;Timestamp too far in future\u0026#34;) if age \u0026gt; MAX_CLOCK_SKEW_PAST: raise ReplayError(\u0026#34;Timestamp too old\u0026#34;) return True NS 메시지용 블룸 필터:\nclass ReplayFilter: def __init__(self, capacity=100000, error_rate=0.001, duration=5*60): self.bloom = BloomFilter(capacity=capacity, error_rate=error_rate) self.duration = duration self.entries = [] # (timestamp, ephemeral_key) def check_replay(self, ephemeral_key, timestamp): # Validate timestamp if not validate_datetime(timestamp): return False # Check Bloom filter if ephemeral_key in self.bloom: # Potential replay (or false positive) # Check exact match in entries for ts, key in self.entries: if key == ephemeral_key: return False # Definite replay # Add to filter self.bloom.add(ephemeral_key) self.entries.append((timestamp, ephemeral_key)) # Expire old entries self.expire_old_entries() return True def expire_old_entries(self): now = int(time.time()) self.entries = [(ts, key) for ts, key in self.entries if now - ts \u0026lt; self.duration] Session Tag(세션 태그) 일회성 사용:\ndef process_session_tag(tag): # Look up tag entry = tagset.lookup_tag(tag) if entry is None: raise ValueError(\u0026#34;Invalid session tag\u0026#34;) # CRITICAL: Remove tag immediately (one-time use) tagset.remove_tag(tag) # Use associated key return entry.key, entry.index Key Compromise Impersonation (KCI, 키 손상 가장 공격) 완화 방안 문제: NS 메시지 인증은 KCI(키 손상 사칭 공격)에 취약함 (인증 수준 1)\n완화 조치:\n가능한 한 빨리 NSR(인증 레벨 2)로 전환하세요 보안에 민감한 작업에서는 NS 페이로드를 신뢰하지 마세요 되돌릴 수 없는 작업을 수행하기 전에 NSR 확인을 기다리세요 def process_ns_message(ns_message): # NS authenticated at Level 1 (KCI vulnerable) # Do NOT perform security-critical operations yet # Extract sender\u0026#39;s static key sender_key = ns_message.static_key # Mark session as pending Level 2 authentication session.auth_level = 1 session.sender_key = sender_key # Send NSR send_nsr_reply(session) def process_first_es_message(es_message): # Now we have Level 2 authentication (KCI resistant) session.auth_level = 2 # Safe to perform security-critical operations process_security_critical_operation(es_message) 서비스 거부(DoS) 완화 대책 NS 플러딩 방지:\nclass NSFloodProtection: def __init__(self): self.ns_count = defaultdict(int) # source -\u0026gt; count self.ns_timestamps = defaultdict(list) # source -\u0026gt; [timestamps] self.max_ns_per_source = 5 self.rate_window = 10 # seconds self.max_concurrent_ns = 100 def check_ns_allowed(self, source): # Global limit total_pending = sum(self.ns_count.values()) if total_pending \u0026gt;= self.max_concurrent_ns: return False # Per-source rate limit now = time.time() timestamps = self.ns_timestamps[source] # Remove old timestamps timestamps = [ts for ts in timestamps if now - ts \u0026lt; self.rate_window] self.ns_timestamps[source] = timestamps # Check rate if len(timestamps) \u0026gt;= self.max_ns_per_source: return False # Allow NS timestamps.append(now) self.ns_count[source] += 1 return True def on_session_established(self, source): # Decrease pending count if self.ns_count[source] \u0026gt; 0: self.ns_count[source] -= 1 태그 저장 제한:\nclass TagStorageLimit: def __init__(self, max_tags=1000000): self.max_tags = max_tags self.current_tags = 0 def can_create_session(self, look_ahead): if self.current_tags + look_ahead \u0026gt; self.max_tags: return False return True def add_tags(self, count): self.current_tags += count def remove_tags(self, count): self.current_tags -= count 적응형 자원 관리:\nclass AdaptiveResourceManager: def __init__(self): self.load_level = 0 # 0 = low, 1 = medium, 2 = high, 3 = critical def adjust_parameters(self): if self.load_level == 0: # Normal operation return { \u0026#39;max_look_ahead\u0026#39;: 160, \u0026#39;max_sessions\u0026#39;: 1000, \u0026#39;session_timeout\u0026#39;: 10 * 60 } elif self.load_level == 1: # Moderate load return { \u0026#39;max_look_ahead\u0026#39;: 80, \u0026#39;max_sessions\u0026#39;: 800, \u0026#39;session_timeout\u0026#39;: 8 * 60 } elif self.load_level == 2: # High load return { \u0026#39;max_look_ahead\u0026#39;: 32, \u0026#39;max_sessions\u0026#39;: 500, \u0026#39;session_timeout\u0026#39;: 5 * 60 } else: # load_level == 3 # Critical load return { \u0026#39;max_look_ahead\u0026#39;: 16, \u0026#39;max_sessions\u0026#39;: 200, \u0026#39;session_timeout\u0026#39;: 3 * 60 } 트래픽 분석 저항성 Elligator2 Encoding(엘리게이터2 인코딩):\n핸드셰이크 메시지가 무작위 데이터와 구분되지 않도록 보장합니다:\n# NS and NSR start with Elligator2-encoded ephemeral keys # Observer cannot distinguish from random 32-byte string 패딩 전략:\n# Resist message size fingerprinting def add_padding(payload, strategy=\u0026#39;random\u0026#39;): if strategy == \u0026#39;random\u0026#39;: # Random padding 0-15 bytes size = random.randint(0, 15) elif strategy == \u0026#39;round\u0026#39;: # Round to next 64-byte boundary target = ((len(payload) + 63) // 64) * 64 size = target - len(payload) - 3 # -3 for block header elif strategy == \u0026#39;fixed\u0026#39;: # Always 1KB messages size = 1024 - len(payload) - 3 return build_padding_block(size) 타이밍 공격:\n# CRITICAL: Use constant-time operations def constant_time_compare(a, b): \u0026#34;\u0026#34;\u0026#34;Constant-time byte string comparison\u0026#34;\u0026#34;\u0026#34; if len(a) != len(b): return False result = 0 for x, y in zip(a, b): result |= x ^ y return result == 0 # CRITICAL: Constant-time MAC verification def verify_mac(computed_mac, received_mac): if not constant_time_compare(computed_mac, received_mac): # Always take same time regardless of where comparison fails raise AuthenticationError(\u0026#34;MAC verification failed\u0026#34;) 구현상의 함정 일반적인 실수:\nNonce(논스) 재사용: (key, nonce) 쌍을 절대 재사용하지 마십시오 # BAD: Reusing nonce with same key ciphertext1 = ENCRYPT(key, nonce, plaintext1, ad1) ciphertext2 = ENCRYPT(key, nonce, plaintext2, ad2) # CATASTROPHIC 좋음: 각 메시지마다 고유한 nonce(논스: 한 번만 사용하는 임의값) ciphertext1 = ENCRYPT(key, nonce1, plaintext1, ad1) ciphertext2 = ENCRYPT(key, nonce2, plaintext2, ad2) 2. **Ephemeral Key Reuse**: Generate fresh ephemeral key for each NS/NSR ```python # 나쁨: 임시 키 재사용 ephemeral_key = generate_elg2_keypair() send_ns_message(ephemeral_key) send_ns_message(ephemeral_key) # 나쁨 # 좋음: 각 메시지마다 새 키 send_ns_message(generate_elg2_keypair()) send_ns_message(generate_elg2_keypair()) Weak RNG: Use cryptographically secure random number generator 나쁨: 비암호학적 난수 생성기 import random key = bytes([random.randint(0, 255) for _ in range(32)]) # 안전하지 않음 좋음: 암호학적으로 안전한 RNG(난수 생성기) import os key = os.urandom(32) 4. **Timing Attacks**: Use constant-time comparisons ```python # 나쁨: Early-exit(조기 종료) 비교 if computed_mac == received_mac: # 타이밍 누출 pass # 좋음: 상수 시간 비교 if constant_time_compare(computed_mac, received_mac): pass Incomplete MAC Verification: Always verify before using data 나쁜 예: 검증 전에 복호화 plaintext = chacha20_decrypt(key, nonce, ciphertext) mac_ok = verify_mac(mac, plaintext) # 너무 늦음 if not mac_ok: return error 좋음: AEAD(부가 데이터가 있는 인증 암호화)는 복호화하기 전에 검증한다 try: plaintext = DECRYPT(key, nonce, ciphertext, ad) # Verifies MAC first except AuthenticationError:\nreturn error 6. **Key Deletion**: Securely wipe keys from memory ```python # 나쁨: 단순 삭제 del private_key # 아직 메모리에 남아 있음 # 권장: 삭제 전에 덮어쓰기 for i in range(len(private_key)): private_key[i] = 0 del private_key Security Audits Recommended Audits:\nCryptographic Review: Expert review of KDF chains and DH operations Implementation Audit: Code review for timing attacks, key management, RNG usage Protocol Analysis: Formal verification of handshake security properties Side-Channel Analysis: Timing, power, and cache attacks Fuzzing: Random input testing for parser robustness Test Cases:\n# 보안상 중요한 테스트 케이스 def test_nonce_uniqueness(): \u0026#34;\u0026#34;\u0026#34;Ensure nonces are never reused\u0026#34;\u0026#34;\u0026#34; nonces = set() for i in range(10000): nonce = construct_nonce(i) assert nonce not in nonces nonces.add(nonce) def test_key_isolation(): \u0026#34;\u0026#34;\u0026#34;Ensure sessions don\u0026#39;t share keys\u0026#34;\u0026#34;\u0026#34; session1 = create_session(destination1) session2 = create_session(destination2) assert session1.key != session2.key def test_replay_prevention(): \u0026#34;\u0026#34;\u0026#34;Ensure replay attacks are detected\u0026#34;\u0026#34;\u0026#34; ns_message = create_ns_message() # First delivery succeeds assert process_ns_message(ns_message) == True # Replay fails assert process_ns_message(ns_message) == False def test_mac_verification(): \u0026#34;\u0026#34;\u0026#34;Ensure MAC verification is enforced\u0026#34;\u0026#34;\u0026#34; key = CSRNG(32) nonce = construct_nonce(0) plaintext = b\u0026#34;test\u0026#34; ad = b\u0026#34;test_ad\u0026#34; ciphertext = ENCRYPT(key, nonce, plaintext, ad) # Correct MAC verifies assert DECRYPT(key, nonce, ciphertext, ad) == plaintext # Corrupted MAC fails corrupted = ciphertext[:-1] + bytes([ciphertext[-1] ^ 0xFF]) with pytest.raises(AuthenticationError): DECRYPT(key, nonce, corrupted, ad) Configuration and Deployment I2CP Configuration Enable ECIES Encryption:\n# ECIES(타원곡선 통합 암호화 방식) 전용(신규 배포에 권장) i2cp.leaseSetEncType=4 # 이중 키 (ECIES + ElGamal 호환성용) i2cp.leaseSetEncType=4,0 # ElGamal 전용 (레거시, 권장되지 않음) i2cp.leaseSetEncType=0 LeaseSet Type:\n# 표준 LS2(LeaseSet2, 가장 일반적) i2cp.leaseSetType=3 # 암호화된 LS2 (blinded destinations, 블라인드된 목적지) i2cp.leaseSetType=5 # 메타 LS2 (여러 Destination(목적지)) i2cp.leaseSetType=7 Additional Options:\n# ECIES(타원곡선 통합 암호화 방식)용 정적 키(선택 사항, 지정하지 않으면 자동 생성) # Base64로 인코딩된 32바이트 X25519(타원 곡선 기반 키 교환 알고리즘) 공개 키 i2cp.leaseSetPrivateKey=\u0026lt;base64-encoded-key\u0026gt; # 서명 유형(LeaseSet용) i2cp.leaseSetSigningPrivateKey=\u0026lt;base64-encoded-key\u0026gt; i2cp.leaseSetSigningType=7 # Ed25519 Java I2P Configuration router.config:\n# router 간 ECIES i2p.router.useECIES=true Build Properties:\n// I2CP 클라이언트(Java)용 Properties props = new Properties(); props.setProperty(\u0026#34;i2cp.leaseSetEncType\u0026#34;, \u0026#34;4\u0026#34;); props.setProperty(\u0026#34;i2cp.leaseSetType\u0026#34;, \u0026#34;3\u0026#34;); I2PSession session = i2pClient.createSession(props); i2pd Configuration i2pd.conf:\n[제한] # ECIES(타원곡선 통합 암호화 방식) 세션 메모리 제한 ecies.memory = 128M [ecies] # ECIES(타원 곡선 통합 암호화 체계) 활성화 enabled = true # ECIES(타원곡선 통합 암호화 체계) 전용 또는 이중 키 compatibility = true # true = dual-key(이중 키), false = ECIES-only(ECIES 전용) Tunnels Configuration:\n[my-service] type = http host = 127.0.0.1 port = 8080 keys = my-service-keys.dat # ECIES(타원곡선 통합 암호 방식) 전용 ecies = true Compatibility Matrix Router Version Support:\nVersion ECIES Support LS2 Support Dual-Key Notes \u0026lt; 0.9.38 ❌ No ❌ No N/A Legacy only 0.9.38-0.9.45 ❌ No ✅ Yes N/A LS2 only 0.9.46-0.9.50 ✅ Yes ✅ Yes ✅ Yes Initial ECIES 1.5.0+ ✅ Yes ✅ Yes ✅ Yes Current 2.0.0+ ✅ Yes ✅ Yes ✅ Yes Current Destination Compatibility:\nDestination Type Can Connect To Notes ECIES-only ECIES-only, Dual-key Requires 0.9.46+ routers Dual-key Any Maximum compatibility ElGamal-only ElGamal-only, Dual-key Legacy FloodFill Requirements:\nECIES-only destinations: Require majority of floodfills on 0.9.46+ for encrypted lookups Dual-key destinations: Work with any floodfill version Current status: Near 100% floodfill adoption as of 2025 Migration Guide Migrating from ElGamal to ECIES:\nStep 1: Enable Dual-Key Mode\n# ElGamal은 유지하면서 ECIES를 추가 i2cp.leaseSetEncType=4,0 Step 2: Monitor Connections\n# 연결 유형 확인 i2prouter.exe status # 또는 http://127.0.0.1:7657/peers Step 3: Switch to ECIES-Only (after testing)\n# ElGamal 제거 i2cp.leaseSetEncType=4 Step 4: Restart Application\n# I2P router 또는 애플리케이션을 재시작 systemctl restart i2p # 또는 i2prouter.exe restart Rollback Plan:\n# 문제가 발생하면 ElGamal(엘가말)만 사용하도록 되돌리기 i2cp.leaseSetEncType=0 Performance Tuning Session Limits:\n# 최대 인바운드 세션 수 i2p.router.maxInboundSessions=1000 # 최대 아웃바운드 세션 수 i2p.router.maxOutboundSessions=1000 # 세션 타임아웃 (초) i2p.router.sessionTimeout=600 Memory Limits:\n# 태그 저장 용량 제한 (KB) i2p.ecies.maxTagMemory=10240 # 10 MB # 룩어헤드 윈도우 i2p.ecies.tagLookAhead=160 i2p.ecies.tagLookAheadMin=32 Ratchet Policy:\n# ratchet(키를 단계적으로 갱신하는 암호화 메커니즘) 이전의 메시지 i2p.ecies.ratchetThreshold=4096 # 래칫까지 남은 시간(초) i2p.ecies.ratchetTimeout=600 # 10분 Monitoring and Debugging Logging:\n# ECIES(타원곡선 통합 암호 방식) 디버그 로깅 활성화 logger.i2p.router.transport.ecies=DEBUG Metrics:\nMonitor these metrics:\nNS Success Rate: Percentage of NS messages receiving NSR Session Establishment Time: Time from NS to first ES Tag Storage Usage: Current memory usage for tags Ratchet Frequency: How often sessions ratchet Session Lifetime: Average session duration Common Issues:\nNS Timeout: No NSR received\nCheck destination is online Check floodfill availability Verify LeaseSet published correctly High Memory Usage: Too many tags stored\nReduce look-ahead window Decrease session timeout Implement aggressive expiration Frequent Ratchets: Sessions ratcheting too often\nIncrease ratchet threshold Check for retransmissions Session Failures: ES messages failing to decrypt\nVerify tag synchronization Check for replay attacks Validate nonce construction References Specifications ECIES Proposal: Proposal 144 I2NP: I2NP Specification Common Structures: Common Structures Specification NTCP2: NTCP2 Specification SSU2: SSU2 Specification I2CP: I2CP Specification ElGamal/AES+SessionTags: ElGamal/AES Specification Cryptographic Standards Noise Protocol Framework: Noise Specification (Revision 34, 2018-07-11) Signal Double Ratchet: Signal Specification RFC 7748: Elliptic Curves for Security (X25519) RFC 7539: ChaCha20 and Poly1305 for IETF Protocols RFC 5869: HKDF (HMAC-based Key Derivation Function) RFC 2104: HMAC: Keyed-Hashing for Message Authentication Elligator2: Elligator Paper Implementation Resources Java I2P: i2p.i2p Repository i2pd (C++): i2pd Repository OBFS4 (Elligator2): obfs4proxy Repository Additional Information I2P Website: / I2P Forum: https://i2pforum.net I2P Wiki: https://wiki.i2p-projekt.de Appendix A: KDF Summary All KDF Operations in ECIES:\nOperation Input Info String Output NS Initial ChainKey protocol_name (none - SHA256) h, chainKey NS Static Key Section chainKey, es_shared \"\" chainKey, k NS Payload Section (bound) chainKey, ss_shared \"\" chainKey, k NSR Tagset chainKey \"SessionReplyTags\" tagsetKey NSR ee DH chainKey, ee_shared \"\" chainKey NSR se DH chainKey, se_shared \"\" chainKey, k NSR Split chainKey \"\" k_ab, k_ba NSR Payload k_ba \"AttachPayloadKDF\" k_nsr DH Initialize rootKey, k \"KDFDHRatchetStep\" nextRootKey, chainKey Tag and Key Chain Keys chainKey \"TagAndKeyGenKeys\" sessTag_ck, symmKey_ck Session Tag Init sessTag_ck \"STInitialization\" chainKey, CONSTANT Session Tag Gen chainKey, CONSTANT \"SessionTagKeyGen\" chainKey, tag Symmetric Key Gen chainKey \"SymmetricRatchet\" chainKey, key DH Ratchet sharedSecret \"XDHRatchetTagSet\" tagsetKey Appendix B: Message Size Calculator Calculate message sizes for capacity planning:\ndef calculate_ns_size(payload_size, bound=True): \u0026#34;\u0026#34;\u0026#34;Calculate New Session message size\u0026#34;\u0026#34;\u0026#34; ephemeral_key = 32 static_section = 32 + 16 # encrypted + MAC payload_encrypted = payload_size + 16 # + MAC return ephemeral_key + static_section + payload_encrypted def calculate_nsr_size(payload_size): \u0026#34;\u0026#34;\u0026#34;Calculate New Session Reply message size\u0026#34;\u0026#34;\u0026#34; tag = 8 ephemeral_key = 32 key_section_mac = 16 payload_encrypted = payload_size + 16 # + MAC return tag + ephemeral_key + key_section_mac + payload_encrypted def calculate_es_size(payload_size): \u0026#34;\u0026#34;\u0026#34;Calculate Existing Session message size\u0026#34;\u0026#34;\u0026#34; tag = 8 payload_encrypted = payload_size + 16 # + MAC return tag + payload_encrypted # 예제 print(\u0026#34;NS (bound, 1KB payload):\u0026#34;, calculate_ns_size(1024, bound=True), \u0026#34;바이트\u0026#34;) # 출력: 1120 바이트 print(\u0026#34;NSR (1KB payload):\u0026#34;, calculate_nsr_size(1024), \u0026#34;bytes\u0026#34;) # 출력: 1096 바이트 print(\u0026#34;ES (1KB 페이로드):\u0026#34;, calculate_es_size(1024), \u0026#34;바이트\u0026#34;) # 출력: 1048 바이트 Appendix C: Glossary AEAD: Authenticated Encryption with Associated Data - encryption mode that provides both confidentiality and authenticity\nAuthentication Level: Noise protocol security property indicating strength of sender identity verification\nBinding: Association of a session with a specific far-end destination\nChaCha20: Stream cipher designed by Daniel J. Bernstein\nChainKey: Cryptographic key used in HKDF chains to derive subsequent keys\nConfidentiality Level: Noise protocol security property indicating strength of forward secrecy\nDH: Diffie-Hellman key agreement protocol\nElligator2: Encoding technique to make elliptic curve points indistinguishable from random\nEphemeral Key: Short-lived key used only for a single handshake\nES: Existing Session message (used after handshake completion)\nForward Secrecy: Property ensuring past communications remain secure if keys are compromised\nGarlic Clove: I2NP message container for end-to-end delivery\nHKDF: HMAC-based Key Derivation Function\nIK Pattern: Noise handshake pattern where initiator sends static key immediately\nKCI: Key Compromise Impersonation attack\nKDF: Key Derivation Function - cryptographic function for generating keys from other keys\nLeaseSet: I2P structure containing a destination\u0026rsquo;s public keys and tunnel information\nLS2: LeaseSet version 2 with encryption type support\nMAC: Message Authentication Code - cryptographic checksum proving authenticity\nMixHash: Noise protocol function for maintaining running hash transcript\nNS: New Session message (initiates new session)\nNSR: New Session Reply message (response to NS)\nNonce: Number used once - ensures unique encryption even with same key\nPairing: Linking an inbound session with an outbound session for bidirectional communication\nPoly1305: Message authentication code designed by Daniel J. Bernstein\nRatchet: Cryptographic mechanism for deriving sequential keys\nSession Tag: 8-byte one-time identifier for existing session messages\nStatic Key: Long-term key associated with a destination\u0026rsquo;s identity\nTag Set: Collection of session tags derived from a common root\nX25519: Elliptic curve Diffie-Hellman key agreement using Curve25519\n","description":"I2P용 타원곡선 통합 암호화 스킴 (X25519 + AEAD)","id":"82b727dd29ed7e2e04873dac8c2acf51","section":"docs","title":"ECIES-X25519-AEAD-Ratchet 암호화 명세","url":"/ko/docs/specs/ecies/"},{"categories":null,"content":"구현 현황 현재 배포 현황: - i2pd (C++ 구현): ML-KEM-512, ML-KEM-768, ML-KEM-1024 지원과 함께 버전 2.58.0(2025년 9월)에 완전 구현되었습니다. OpenSSL 3.5.0 이상이 사용 가능한 경우 post-quantum(양자내성) 종단간 암호화가 기본적으로 활성화됩니다. - Java I2P: 버전 0.9.67 / 2.10.0(2025년 9월) 기준으로 아직 구현되지 않았습니다. 규격은 승인되었으며, 구현은 향후 릴리스에 포함될 예정입니다.\n이 명세서는 현재 i2pd에 배포되어 있으며 Java I2P 구현에 도입이 예정된 승인된 기능을 설명합니다.\n개요 이는 ECIES-X25519-AEAD-Ratchet 프로토콜 ECIES 의 포스트-양자 하이브리드 변형이다. 이는 승인될 Proposal 169 Prop169 의 첫 번째 단계를 나타낸다. 전체 목표, 위협 모델, 분석, 대안, 추가 정보는 해당 제안을 참조하라.\nProposal 169 상태: Open (하이브리드 ECIES(타원 곡선 통합 암호 체계) 구현을 위한 1단계가 승인됨).\n이 명세서는 표준 ECIES 와의 차이점만을 포함하며, 해당 명세서와 함께 읽어야 합니다.\n설계 우리는 NIST FIPS 203 표준 FIPS203 을 사용하며, 이는 CRYSTALS-Kyber(포스트-양자 공개키 암호)를 기반으로 하지만, CRYSTALS-Kyber의 버전 3.1, 3 및 그 이전과는 호환되지 않습니다.\n하이브리드 핸드셰이크는 기존의 X25519 Diffie-Hellman과 양자내성 ML-KEM 키 캡슐화 메커니즘을 결합한다. 이러한 접근법은 PQNoise 연구에 문서화된 하이브리드 전방 비밀성 개념과 TLS 1.3, IKEv2, WireGuard의 유사한 구현을 기반으로 한다.\n키 교환 우리는 Ratchet(래칫)용 하이브리드 키 교환을 정의한다. Post-quantum KEM(포스트-양자 키 캡슐화 메커니즘)은 임시 키만 제공하며 Noise IK(Noise 프로토콜의 IK 패턴)와 같은 정적 키 기반 핸드셰이크를 직접적으로 지원하지 않는다.\n본 사양에서는 FIPS203 에 명시된 대로 세 가지 ML-KEM(모듈 격자 기반 키 캡슐화 메커니즘) 변형을 정의하며, 이에 따라 총 3개의 새로운 암호화 유형이 됩니다. 하이브리드 유형은 X25519와의 조합에서만 정의됩니다.\n새로운 암호화 유형은 다음과 같습니다:\nType Code Security Level ML-KEM Variant MLKEM512_X25519 5 NIST Category 1 (AES-128 equivalent) ML-KEM-512 MLKEM768_X25519 6 NIST Category 3 (AES-192 equivalent) ML-KEM-768 (Recommended) MLKEM1024_X25519 7 NIST Category 5 (AES-256 equivalent) ML-KEM-1024 **참고:** MLKEM768_X25519 (Type 6)은 합리적인 오버헤드로 강력한 포스트-양자 보안을 제공하는 권장 기본 변형입니다. X25519 전용 암호화와 비교하면 오버헤드가 상당합니다. 일반적인 메시지 1과 2의 크기(IK pattern(Noise 핸드셰이크 패턴 중 하나) 기준)는 현재 약 96103바이트(추가 페이로드 이전)입니다. 메시지 유형에 따라 MLKEM512의 경우 약 912배, MLKEM768의 경우 1316배, MLKEM1024의 경우 1723배로 증가합니다.\n새로운 암호화 필요 ML-KEM (이전 명칭: CRYSTALS-Kyber) FIPS203 - 모듈 격자 기반 키 캡슐화 메커니즘 표준 SHA3-256 (이전 명칭: Keccak-512) FIPS202 - SHA-3 표준의 일부 SHAKE128 and SHAKE256 (SHA3에 대한 XOF 확장) FIPS202 - 확장 가능한 출력 함수 SHA3-256, SHAKE128, SHAKE256에 대한 테스트 벡터는 NIST Cryptographic Algorithm Validation Program(미국표준기술연구원(NIST) 암호 알고리즘 검증 프로그램) 에서 제공됩니다.\n라이브러리 지원: - Java: Bouncycastle 라이브러리 버전 1.79 이상은 모든 ML-KEM(모듈-격자 기반 키 캡슐화 메커니즘) 변형과 SHA3/SHAKE 함수를 지원 - C++: OpenSSL 3.5 이상에는 ML-KEM 전체 지원 포함(2025년 4월 릴리스) - Go: ML-KEM 및 SHA3 구현을 위한 여러 라이브러리 사용 가능\n명세서 공통 구조 키 길이와 식별자에 대해서는 Common Structures Specification 을 참조하세요.\n핸드셰이크 패턴 핸드셰이크는 하이브리드 포스트양자 보안을 위해 I2P에 특화된 변형을 적용한 Noise Protocol Framework 핸드셰이크 패턴을 사용합니다.\n다음 문자 매핑을 사용합니다:\ne = 일회용 임시 키 (X25519) s = 정적 키 p = 메시지 페이로드 e1 = 일회용 임시 PQ(후양자) 키, Alice가 Bob에게 전송됨 (I2P 전용 토큰) ekem1 = KEM(키 캡슐화 메커니즘) 암호문, Bob이 Alice에게 전송됨 (I2P 전용 토큰) 중요 참고: 패턴 이름 \u0026ldquo;IKhfs\u0026quot;와 \u0026ldquo;IKhfselg2\u0026rdquo;, 그리고 토큰 \u0026ldquo;e1\u0026quot;과 \u0026ldquo;ekem1\u0026quot;은 공식 Noise Protocol Framework(노이즈 프로토콜 프레임워크) 명세에 문서화되어 있지 않은 I2P 고유한 변형입니다. 이는 ML-KEM(양자내성 키 캡슐화 방식)을 Noise IK 패턴에 통합하기 위한 맞춤 정의를 나타냅니다. X25519 + ML-KEM 하이브리드 방식은 양자내성 암호 연구와 다른 프로토콜에서 널리 인정되고 있지만, 여기서 사용되는 구체적 명명법은 I2P에 특화되어 있습니다.\n하이브리드 순방향 기밀성을 위해 IK에 다음과 같은 변경 사항이 적용됩니다:\nStandard IK: I2P IKhfs (Hybrid): \u0026lt;- s \u0026lt;- s ... ... -\u0026gt; e, es, s, ss, p -\u0026gt; e, es, e1, s, ss, p \u0026lt;- e, ee, se, p \u0026lt;- e, ee, ekem1, se, p \u0026lt;- p \u0026lt;- p p -\u0026gt; p -\u0026gt; Note: e1 and ekem1 are encrypted within ChaCha20-Poly1305 AEAD blocks. Note: e1 (ML-KEM public key) and ekem1 (ML-KEM ciphertext) have different sizes. e1 패턴은 다음과 같이 정의됩니다:\nFor Alice (sender): (encap_key, decap_key) = PQ_KEYGEN() // EncryptAndHash(encap_key) ciphertext = ENCRYPT(k, n, encap_key, ad) n++ MixHash(ciphertext) For Bob (receiver): // DecryptAndHash(ciphertext) encap_key = DECRYPT(k, n, ciphertext, ad) n++ MixHash(ciphertext) ekem1 패턴은 다음과 같이 정의됩니다:\nFor Bob (receiver of encap_key): (kem_ciphertext, kem_shared_key) = ENCAPS(encap_key) // EncryptAndHash(kem_ciphertext) ciphertext = ENCRYPT(k, n, kem_ciphertext, ad) MixHash(ciphertext) // MixKey MixKey(kem_shared_key) For Alice (sender of encap_key): // DecryptAndHash(ciphertext) kem_ciphertext = DECRYPT(k, n, ciphertext, ad) MixHash(ciphertext) // MixKey kem_shared_key = DECAPS(kem_ciphertext, decap_key) MixKey(kem_shared_key) 정의된 ML-KEM 연산 우리는 FIPS203 에 규정된 암호학적 구성 요소에 대응하는 다음 함수들을 정의한다.\n(encap_key, decap_key) = PQ_KEYGEN() : Alice는 캡슐화 키와 디캡슐화 키를 생성한다. 캡슐화 키는 NS 메시지로 전송된다. 키 크기: - ML-KEM-512: encap_key = 800 바이트, decap_key = 1632 바이트 - ML-KEM-768: encap_key = 1184 바이트, decap_key = 2400 바이트 - ML-KEM-1024: encap_key = 1568 바이트, decap_key = 3168 바이트\n(ciphertext, kem_shared_key) = ENCAPS(encap_key) : Bob은 NS 메시지에서 수신한 캡슐화 키를 사용해 암호문과 공유 키를 계산한다. 암호문은 NSR 메시지로 전송된다. 암호문 크기: - ML-KEM-512: 768 바이트 - ML-KEM-768: 1088 바이트 - ML-KEM-1024: 1568 바이트\nkem_shared_key는 세 가지 변형 모두에서 항상 32바이트입니다.\nkem_shared_key = DECAPS(ciphertext, decap_key) : Alice는 NSR 메시지로 받은 ciphertext를 사용하여 공유 키를 계산한다. kem_shared_key는 항상 32바이트이다.\n중요: encap_key와 암호문은 모두 Noise(암호 프로토콜 프레임워크) 핸드셰이크 메시지 1과 2의 ChaCha20-Poly1305 블록 내부에서 암호화되며, 핸드셰이크 과정의 일부로 복호화된다.\nkem_shared_key는 MixKey()를 사용하여 chaining key(체이닝 키)에 혼합됩니다. 자세한 내용은 아래를 참조하세요.\nNoise 핸드셰이크 KDF(키 파생 함수) 개요 하이브리드 핸드셰이크는 기존의 X25519 ECDH와 포스트-양자 ML-KEM(키 캡슐화 메커니즘)을 결합합니다. 첫 번째 메시지는 앨리스가 밥에게 보내는 것으로, 메시지 페이로드 앞에 e1(ML-KEM 캡슐화 키)을 포함합니다. 이는 추가 키 자료로 취급되며, 이에 대해 EncryptAndHash()(앨리스인 경우) 또는 DecryptAndHash()(밥인 경우)를 호출합니다. 그런 다음 평소와 같이 메시지 페이로드를 처리합니다.\n두 번째 메시지(보낸 이: Bob, 받는 이: Alice)는 메시지 페이로드 앞에 ekem1(ML-KEM 암호문)을 포함합니다. 이는 추가적인 키 자료로 취급하며, 이에 대해 Bob은 EncryptAndHash()를, Alice는 DecryptAndHash()를 호출합니다. 그런 다음 kem_shared_key를 계산하고 MixKey(kem_shared_key)를 호출합니다. 그 후 메시지 페이로드를 평소대로 처리합니다.\nNoise(프로토콜 프레임워크) 식별자 다음은 Noise 초기화 문자열입니다(I2P 전용):\nNoise_IKhfselg2_25519+MLKEM512_ChaChaPoly_SHA256 Noise_IKhfselg2_25519+MLKEM768_ChaChaPoly_SHA256 Noise_IKhfselg2_25519+MLKEM1024_ChaChaPoly_SHA256 Alice 측 NS 메시지용 KDF(키 유도 함수) \u0026rsquo;es\u0026rsquo; 메시지 패턴 다음, \u0026rsquo;s\u0026rsquo; 메시지 패턴 이전에 다음을 추가하세요:\nThis is the \u0026#34;e1\u0026#34; message pattern: (encap_key, decap_key) = PQ_KEYGEN() // EncryptAndHash(encap_key) // AEAD parameters k = keydata[32:63] n = 0 ad = h ciphertext = ENCRYPT(k, n, encap_key, ad) n++ // MixHash(ciphertext) h = SHA256(h || ciphertext) End of \u0026#34;e1\u0026#34; message pattern. NOTE: For the next section (payload for XK or static key for IK), the keydata and chain key remain the same, and n now equals 1 (instead of 0 for non-hybrid). NS 메시지용 Bob 키 유도 함수 \u0026rsquo;es\u0026rsquo; 메시지 패턴 뒤, \u0026rsquo;s\u0026rsquo; 메시지 패턴 앞에 다음을 추가하십시오:\nThis is the \u0026#34;e1\u0026#34; message pattern: // DecryptAndHash(encap_key_section) // AEAD parameters k = keydata[32:63] n = 0 ad = h encap_key = DECRYPT(k, n, encap_key_section, ad) n++ // MixHash(encap_key_section) h = SHA256(h || encap_key_section) End of \u0026#34;e1\u0026#34; message pattern. NOTE: For the next section (payload for XK or static key for IK), the keydata and chain key remain the same, and n now equals 1 (instead of 0 for non-hybrid). NSR 메시지를 위한 Bob KDF \u0026rsquo;ee\u0026rsquo; 메시지 패턴 뒤에, \u0026lsquo;se\u0026rsquo; 메시지 패턴 앞에 다음을 추가하십시오:\nThis is the \u0026#34;ekem1\u0026#34; message pattern: (kem_ciphertext, kem_shared_key) = ENCAPS(encap_key) // EncryptAndHash(kem_ciphertext) // AEAD parameters k = keydata[32:63] n = 0 ad = h ciphertext = ENCRYPT(k, n, kem_ciphertext, ad) // MixHash(ciphertext) h = SHA256(h || ciphertext) // MixKey(kem_shared_key) keydata = HKDF(chainKey, kem_shared_key, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] End of \u0026#34;ekem1\u0026#34; message pattern. NSR 메시지를 위한 Alice 키 유도 함수 \u0026rsquo;ee\u0026rsquo; 메시지 패턴 이후, \u0026lsquo;ss\u0026rsquo; 메시지 패턴 이전에 다음을 추가하세요:\nThis is the \u0026#34;ekem1\u0026#34; message pattern: // DecryptAndHash(kem_ciphertext_section) // AEAD parameters k = keydata[32:63] n = 0 ad = h kem_ciphertext = DECRYPT(k, n, kem_ciphertext_section, ad) // MixHash(kem_ciphertext_section) h = SHA256(h || kem_ciphertext_section) // MixKey(kem_shared_key) kem_shared_key = DECAPS(kem_ciphertext, decap_key) keydata = HKDF(chainKey, kem_shared_key, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] End of \u0026#34;ekem1\u0026#34; message pattern. split()를 위한 KDF(키 파생 함수) split() 함수는 표준 ECIES(타원 곡선 통합 암호화 체계) 명세와 동일하게 유지됩니다. 핸드셰이크가 완료된 후:\nkeydata = HKDF(chainKey, ZEROLEN, \u0026#34;\u0026#34;, 64) k_ab = keydata[0:31] k_ba = keydata[32:63] 이는 지속적인 통신을 위한 양방향 세션 키입니다.\n메시지 형식 NS (New Session, 새 세션) 형식 변경 사항: 현재 ratchet(순차적 키 갱신 메커니즘)은 첫 번째 ChaCha20-Poly1305(인증 암호화(AEAD) 알고리즘) 섹션에 정적 키를, 두 번째 섹션에 페이로드를 포함합니다. ML-KEM(양자 내성 키 캡슐화 메커니즘)을 사용하면 이제 세 개의 섹션으로 구성됩니다. 첫 번째 섹션에는 암호화된 ML-KEM 공개 키(encap_key)가 포함됩니다. 두 번째 섹션에는 정적 키가 포함됩니다. 세 번째 섹션에는 페이로드가 포함됩니다.\n메시지 크기:\nType Type Code X25519 len NS len NS Enc len NS Dec len PQ key len pl len X25519 4 32 96+pl 64+pl pl -- pl MLKEM512_X25519 5 32 912+pl 880+pl 800+pl 800 pl MLKEM768_X25519 6 32 1296+pl 1264+pl 1184+pl 1184 pl MLKEM1024_X25519 7 32 1680+pl 1648+pl 1568+pl 1568 pl **참고:** 페이로드에는 DateTime 블록(최소 7바이트: 1바이트 타입, 2바이트 크기, 4바이트 타임스탬프)이 포함되어야 합니다. 최소 NS 크기는 이에 따라 산출할 수 있습니다. 따라서 X25519의 실용적인 최소 NS 크기는 103바이트이고, 하이브리드 변형의 경우 919바이트에서 1687바이트까지입니다. 세 가지 ML-KEM(모듈 격자 기반 키 캡슐화 메커니즘) 변형에서 816, 1200, 1584바이트의 크기 증가는 ML-KEM 공개키와 인증된 암호화를 위한 16바이트 Poly1305 MAC(메시지 인증 코드) 때문입니다.\nNSR (New Session Reply, 새 세션 응답) 형식 변경 사항: 현재 ratchet(키 갱신 메커니즘)은 첫 번째 ChaCha20-Poly1305(대칭 인증 암호 알고리즘) 섹션의 페이로드가 비어 있고, 두 번째 섹션에 페이로드가 있습니다. ML-KEM(양자내성 공개키 캡슐화 방식)을 사용하면 이제 섹션이 세 개입니다. 첫 번째 섹션에는 암호화된 ML-KEM 암호문이 들어 있습니다. 두 번째 섹션은 페이로드가 비어 있습니다. 세 번째 섹션에는 페이로드가 들어 있습니다.\n메시지 크기:\nType Type Code X25519 len NSR len NSR Enc len NSR Dec len PQ ct len pl len X25519 4 32 72+pl 40+pl pl -- pl MLKEM512_X25519 5 32 856+pl 824+pl 784+pl 768 pl MLKEM768_X25519 6 32 1176+pl 1144+pl 1104+pl 1088 pl MLKEM1024_X25519 7 32 1656+pl 1624+pl 1584+pl 1568 pl 세 가지 ML-KEM 변형의 크기 증가분 784, 1104, 1584바이트는 인증된 암호화를 위해 ML-KEM 암호문에 16바이트 Poly1305 MAC이 더해진 크기에 해당한다. 오버헤드 분석 키 교환 하이브리드 암호화의 오버헤드는 X25519-only와 비교하면 상당히 큽니다:\nMLKEM512_X25519: 핸드셰이크 메시지 크기가 약 9~12배 증가 (NS: 9.5배, NSR: 11.9배) MLKEM768_X25519: 핸드셰이크 메시지 크기가 약 13~16배 증가 (NS: 13.5배, NSR: 16.3배) MLKEM1024_X25519: 핸드셰이크 메시지 크기가 약 17~23배 증가 (NS: 17.5배, NSR: 23배) 추가된 포스트-양자 보안 이점을 고려하면 이 오버헤드는 수용할 만합니다. 배수는 메시지 유형마다 다른데, 기본 메시지 크기가 서로 다르기 때문입니다 (NS 최소 96바이트, NSR 최소 72바이트).\n대역폭 고려사항 최소 페이로드로 일반적인 세션 수립 시: - X25519만: 총 ~200바이트 (NS + NSR) - MLKEM512_X25519: 총 ~1,800바이트 (9배 증가) - MLKEM768_X25519: 총 ~2,500바이트 (12.5배 증가) - MLKEM1024_X25519: 총 ~3,400바이트 (17배 증가)\n세션 수립 후, 이후 전송되는 메시지의 암호화는 X25519 전용 세션과 동일한 데이터 전송 형식을 사용하므로 후속 메시지에 추가 오버헤드가 없습니다.\n보안 분석 핸드셰이크 하이브리드 핸드셰이크는 전통적(X25519)과 양자 이후(ML-KEM(모듈-격자 기반 키 캡슐화 메커니즘)) 보안을 모두 제공합니다. 공격자가 세션 키를 노출시키려면 전통적 ECDH(타원 곡선 디피-헬만)와 양자 이후 KEM을 둘 다 깨뜨려야 합니다.\n이는 다음을 제공합니다: - 현재 보안: X25519 ECDH는 고전적(비양자) 공격자에 대해 보안을 제공합니다(128비트 보안 수준) - 미래 보안: ML-KEM은 양자 공격자에 대한 보안을 제공합니다(매개변수 집합에 따라 달라짐) - 하이브리드 보안: 세션을 손상시키려면 둘 모두가 깨져야 합니다(보안 수준 = 두 구성요소 중 최대값)\n보안 수준 Variant NIST Category Classical Security PQ Security Hybrid Security MLKEM512_X25519 Category 1 128-bit (X25519) AES-128 equivalent 128-bit MLKEM768_X25519 Category 3 128-bit (X25519) AES-192 equivalent 128-bit MLKEM1024_X25519 Category 5 128-bit (X25519) AES-256 equivalent 128-bit **참고:** 하이브리드 보안 수준은 두 구성요소 중 더 약한 쪽의 수준을 넘지 못합니다. 모든 경우에 X25519는 고전 컴퓨팅 기준으로 128비트 보안 수준을 제공합니다. 암호학적으로 의미 있는 양자 컴퓨터가 사용 가능해질 경우, 보안 수준은 선택한 ML-KEM(모듈 격자 기반 키 캡슐화 메커니즘) 매개변수 세트에 따라 달라집니다. 순방향 기밀성 하이브리드 방식은 전방 비밀성 특성을 유지한다. 세션 키는 임시 X25519와 임시 ML-KEM 키 교환 모두로부터 파생된다. 핸드셰이크 이후 X25519 또는 ML-KEM의 임시 개인 키가 파기되면, 장기 정적 키가 유출되더라도 과거 세션은 복호화할 수 없다.\nIK pattern(Noise 프로토콜의 핸드셰이크 패턴)은 두 번째 메시지(NSR)가 전송된 후 완전한 전방향 보안성(Noise Confidentiality level 5, Noise 프로토콜에서 정의된 기밀성 등급 5)을 제공한다.\n유형 기본 설정 구현체는 여러 하이브리드 유형을 지원하고, 서로 지원하는 변형 중 가장 강력한 것을 협상해야 합니다. 선호 순서는 다음과 같아야 합니다:\nMLKEM768_X25519 (유형 6) - 권장 기본값으로, 보안과 성능의 균형이 가장 우수함 MLKEM1024_X25519 (유형 7) - 민감한 애플리케이션을 위한 최고 수준의 보안 MLKEM512_X25519 (유형 5) - 자원 제약 환경을 위한 기본 수준의 포스트-양자 보안 X25519 (유형 4) - 기존(고전) 암호 전용, 호환성 유지를 위한 대체 옵션 근거: MLKEM768_X25519는 NIST 보안 수준 3(AES-192에 상응)을 제공하여 양자컴퓨터에 대해 충분한 보호를 제공하면서도 합리적인 메시지 크기를 유지하므로 기본값으로 권장됩니다. MLKEM1024_X25519는 더 높은 보안을 제공하지만 오버헤드가 상당히 증가합니다.\n구현 참고 사항 라이브러리 지원 Java: Bouncycastle 라이브러리 버전 1.79(2024년 8월) 이상은 필요한 모든 ML-KEM(양자내성 키 캡슐화 메커니즘 표준) 변형과 SHA3/SHAKE(해시/확장 가능 출력 함수)를 지원합니다. FIPS 203(미국 연방 정보 처리 표준 203) 준수를 위해 org.bouncycastle.pqc.crypto.mlkem.MLKEMEngine을 사용하십시오. C++: OpenSSL 3.5(2025년 4월) 이상은 EVP_KEM 인터페이스를 통해 ML-KEM 지원을 포함합니다. 이는 2030년 4월까지 유지 관리되는 장기 지원(Long Term Support) 릴리스입니다. Go: ML-KEM 및 SHA3용 타사 라이브러리가 여러 개 제공되며, 그중에는 Cloudflare의 CIRCL 라이브러리도 포함됩니다. 마이그레이션 전략 구현체는 다음을 따르는 것이 바람직하다: 1. 전환 기간 동안 X25519-only와 하이브리드 ML-KEM 변형을 모두 지원할 것 2. 두 피어 모두가 하이브리드 변형을 지원하는 경우 하이브리드 변형을 우선시할 것 3. 하위 호환성을 위해 X25519-only로의 fallback(대체 수단)을 유지할 것 4. 기본 변형을 선택할 때 네트워크 대역폭 제약을 고려할 것\n공유된 Tunnels 증가한 메시지 크기가 공유 tunnel 사용에 영향을 줄 수 있습니다. 구현체는 다음을 고려해야 합니다: - 가능한 경우 핸드셰이크를 배치 처리하여 오버헤드 비용을 상쇄하기 - 저장된 상태를 줄이기 위해 하이브리드 세션의 만료 시간을 더 짧게 설정하기 - 대역폭 사용량을 모니터링하고 그에 따라 파라미터를 조정하기 - 세션 수립 트래픽에 대한 혼잡 제어를 구현하기\n새 세션 크기 고려사항 더 큰 핸드셰이크 메시지로 인해, 구현체에서는 다음이 필요할 수 있습니다: - 세션 협상용 버퍼 크기 증가(최소 4KB 권장) - 느린 연결을 위한 타임아웃 값 조정(메시지가 약 3~17배 더 커짐을 감안) - NS/NSR 메시지의 페이로드 데이터에 대한 압축 고려 - 전송 계층에서 요구되는 경우 단편화 처리 구현\n테스트 및 검증 구현체는 다음을 검증해야 합니다: - ML-KEM(모듈 격자 기반 키 캡슐화 메커니즘) 키 생성, 캡슐화, 디캡슐화의 정확성 - kem_shared_key가 Noise KDF(키 도출 함수)에 올바르게 통합되는지 - 메시지 크기 계산이 명세와 일치하는지 - 다른 I2P router 구현과의 상호 운용성 - ML-KEM을 사용할 수 없을 때의 폴백 동작\nML-KEM 연산에 대한 테스트 벡터는 NIST Cryptographic Algorithm Validation Program(암호 알고리즘 검증 프로그램) 에서 제공됩니다.\n버전 호환성 I2P 버전 번호 체계: I2P는 두 가지 버전 번호 체계를 병행하여 유지합니다: - Router 릴리스 버전: 2.x.x 형식 (예: 2025년 9월에 릴리스된 2.10.0) - API/프로토콜 버전: 0.9.x 형식 (예: 0.9.67은 router 2.10.0에 해당)\n이 명세서는 프로토콜 버전 0.9.67을 참조하며, 이는 router 2.10.0 릴리스 및 그 이후 버전에 해당합니다.\n호환성 매트릭스:\nImplementation Version ML-KEM Support Status i2pd 2.58.0+ Full (512/768/1024) Deployed September 2025 Java I2P 0.9.67 / 2.10.0 Not yet Planned for future release ## 참고자료 [ECIES]: ECIES-X25519-AEAD-Ratchet 명세서 [Prop169]: 제안 169: 포스트-양자 암호 [FIPS203]: NIST FIPS 203 - ML-KEM 표준 [FIPS202]: NIST FIPS 202 - SHA-3 표준 [Noise]: Noise 프로토콜 프레임워크 [COMMON]: 공통 구조 명세서 [RFC7539]: RFC 7539 - ChaCha20 및 Poly1305 [RFC5869]: RFC 5869 - HKDF [OpenSSL]: OpenSSL 3.5 ML-KEM 문서 [Bouncycastle]: Bouncycastle 자바 암호화 라이브러리 ","description":"ML-KEM(모듈 격자 기반 키 캡슐화 메커니즘)을 사용하는 ECIES 암호화 프로토콜의 양자 내성 하이브리드 변형","id":"f6a66a37875c5b108bc5a8ea027dc0e2","section":"docs","title":"ECIES-X25519-AEAD-Ratchet 하이브리드 암호화","url":"/ko/docs/specs/ecies-hybrid/"},{"categories":null,"content":" 상태: 이 문서는 레거시 ElGamal/AES+SessionTag 암호화 프로토콜을 설명합니다. 최신 I2P 버전(2.10.0+)이 ECIES-X25519-AEAD-Ratchet (라쳇 기반 암호화 방식)을 사용하므로, 하위 호환성 유지를 위해서만 계속 지원됩니다. ElGamal 프로토콜은 사용 중단(deprecated)되었으며, 역사적 및 상호운용성 목적을 위해서만 보존됩니다.\n개요 ElGamal/AES+SessionTag는 garlic messages(I2P에서 여러 하위 메시지를 하나의 캡슐로 묶어 전송하는 메시지 형식)에 대한 I2P의 원래 종단 간 암호화 메커니즘을 제공했다. 이는 다음을 결합했다:\nElGamal (2048비트) — 키 교환용 AES-256/CBC — 페이로드 암호화용 SHA-256 — 해싱 및 IV(초기화 벡터) 도출용 Session Tags (세션 태그, 32 bytes) — 일회용 메시지 식별자용 이 프로토콜은 지속적인 연결을 유지하지 않고도 router와 Destination(목적지)이 안전하게 통신할 수 있도록 했다. 각 세션은 대칭 AES 키를 설정하기 위해 비대칭 ElGamal 키 교환을 사용했고, 이어서 해당 세션을 참조하는 경량의 \u0026ldquo;tagged\u0026rdquo; 메시지를 주고받았다.\n프로토콜 동작 세션 수립(새 세션) 새로운 세션은 두 개의 섹션이 포함된 메시지로 시작되었습니다:\nSection Size Contents Purpose ElGamal-encrypted block 514 bytes 222 bytes of plaintext encrypted using the recipient's ElGamal public key Establishes the AES session key and IV seed AES-encrypted block Variable (≥128 bytes typical) Payload data, integrity hash, and session tags Carries the actual message and new tags ElGamal(엘가말) 블록 내부의 평문은 다음과 같이 구성되어 있었다: Field Size Description Session Key 32 bytes AES-256 key for the session Pre-IV 32 bytes Material for deriving the AES initialization vector (IV = first 16 bytes of SHA-256(Pre-IV)) Random Padding 158 bytes Filler to reach required ElGamal plaintext length ### 기존 세션 메시지 세션이 수립되면, 발신자는 캐시된 세션 태그를 사용하여 existing-session 메시지를 보낼 수 있었다:\nField Size Description Session Tag 32 bytes Single-use identifier tied to the existing session key AES-Encrypted Block Variable Encrypted payload and metadata using the established AES key Routers는 전달된 태그를 약 **15분** 동안 캐시했으며, 그 시간이 지나면 사용되지 않은 태그는 만료되었다. 상관관계 공격을 방지하기 위해 각 태그는 정확히 **한 메시지**에만 유효했다. AES로 암호화된 블록 형식 Field Size Description Tag Count 2 bytes Number (0–200) of new session tags included Session Tags 32 × N bytes Newly generated single-use tags Payload Size 4 bytes Length of the payload in bytes Payload Hash 32 bytes SHA-256 digest of the payload Flag 1 byte 0x00 normal, 0x01 = new session key follows (unused) New Session Key 32 bytes (optional) Replacement AES key (rarely used) Payload Variable Encrypted message data Padding Variable (16-byte aligned) Random padding to block boundary Routers는 새 세션의 경우 Pre-IV(사전 초기화 벡터), 기존 세션의 경우 세션 태그로부터 유도된 세션 키와 IV(초기화 벡터)를 사용하여 복호화한다. 복호화 후에는 평문 페이로드의 SHA-256 해시를 다시 계산하여 무결성을 검증한다. 세션 태그 관리 태그는 단방향입니다: Alice → Bob 태그는 Bob → Alice에서 재사용할 수 없습니다. 태그는 약 15분 후 만료됩니다. Routers는 대상별 세션 키 관리자를 유지하여 태그, 키, 만료 시간을 추적합니다. 애플리케이션은 I2CP 옵션 을 통해 태그 동작을 제어할 수 있습니다: i2cp.tagThreshold — 보충하기 전에 캐시된 태그의 최소 개수 i2cp.tagCount — 메시지당 새 태그 수 이 메커니즘은 메시지 간 비연결성을 유지하면서 고비용의 ElGamal 핸드셰이크를 최소화했다.\n구성 및 효율성 Session tags(암호화 세션을 식별하기 위한 일시적 태그)은 I2P의 지연이 크고 순서가 보장되지 않는 전송 전반에서 효율성을 개선하기 위해 도입되었습니다. 일반적인 구성에서는 메시지당 태그 40개를 전달하여 약 1.2 KB의 오버헤드가 추가되었습니다. 애플리케이션은 예상되는 트래픽에 따라 전달 동작을 조정할 수 있었습니다:\nUse Case Recommended Tags Notes Short-lived requests (HTTP, datagrams) 0 – 5 Low overhead, may trigger ElGamal fallback Persistent streams or bulk transfer 20 – 50 Higher bandwidth use, avoids session re-establishment Long-term services 50+ Ensures steady tag supply despite loss or delay router는 주기적으로 만료된 태그를 제거하고 사용되지 않는 세션 상태를 정리하여 메모리 사용량을 줄이고 태그 플러딩 공격을 완화합니다. 제한 사항 Category Limitation Performance 514-byte ElGamal block adds heavy overhead for new sessions; session tags consume 32 bytes each. Security No forward secrecy – compromise of ElGamal private key exposes past sessions. Integrity AES-CBC requires manual hash verification; no AEAD. Quantum Resistance Vulnerable to Shor's algorithm – will not survive quantum attacks. Complexity Requires stateful tag management and careful timeout tuning. 이러한 단점들은 [ECIES-X25519-AEAD-Ratchet](/docs/specs/ecies/) 프로토콜 설계의 직접적인 동기가 되었으며, 이 프로토콜은 완전 순방향 기밀성, 인증된 암호화, 그리고 효율적인 키 교환을 제공합니다. 사용 중단 및 마이그레이션 상태 도입: 초기 I2P 릴리스 (0.6 이전) 사용 중단: ECIES-X25519(타원곡선 기반 암호화 방식) 도입과 함께 (0.9.46 → 0.9.48) 제거: 2.4.0부터 더 이상 기본값이 아님 (2023년 12월) 지원: 레거시 호환성 전용 최신 router와 destination(목적지)는 이제 **암호 타입 4 (ECIES-X25519)**를 타입 0 (ElGamal/AES) 대신 광고한다. 레거시 프로토콜은 구버전 피어와의 상호 운용성을 위해 여전히 지원되지만, 새로운 배포에는 사용해서는 안 된다.\n역사적 맥락 ElGamal/AES+SessionTag는 I2P 초기 암호 아키텍처의 토대였다. 그 하이브리드 설계는 일회용 session tag(세션 태그)와 단방향 세션 같은 혁신을 도입했고, 이는 이후 프로토콜에 영향을 미쳤다. 이러한 아이디어의 상당수는 결정적 래칫과 하이브리드 포스트-양자 키 교환 같은 현대적 구성으로 발전했다.\n","description":"ElGamal, AES, SHA-256, 일회용 세션 태그를 결합한 레거시 종단 간 암호화","id":"092d77bf065d0f13bb2b2a470f57a902","section":"docs","title":"ElGamal/AES + SessionTag(세션 태그) 암호화","url":"/ko/docs/legacy/elgamal-aes/"},{"categories":null,"content":" 1. 개요 Garlic routing은 I2P의 핵심 혁신 기술 중 하나로, 계층화된 암호화, 메시지 번들링, 그리고 단방향 터널을 결합합니다. 개념적으로 onion routing과 유사하지만, 여러 개의 암호화된 메시지(\u0026ldquo;cloves\u0026rdquo;)를 단일 봉투(\u0026ldquo;garlic\u0026rdquo;)로 묶는 방식으로 모델을 확장하여 효율성과 익명성을 향상시킵니다.\ngarlic routing이라는 용어는 Roger Dingledine의 Free Haven 석사 논문 (2000년 6월, §8.1.1)에서 Michael J. Freedman 이 만들었습니다. I2P 개발자들은 2000년대 초반에 이 용어를 채택하여 메시지 번들링 강화와 단방향 전송 모델을 반영했으며, 이는 Tor의 회선 교환 방식 설계와 구별됩니다.\n요약: Garlic routing = 계층화된 암호화 + 메시지 번들링 + 단방향 터널을 통한 익명 전달.\n2. \u0026ldquo;Garlic\u0026rdquo; 용어 역사적으로, garlic이라는 용어는 I2P 내에서 세 가지 다른 맥락으로 사용되어 왔습니다:\n계층화된 암호화 – tunnel 수준의 onion 방식 보호 여러 메시지 번들링 – \u0026ldquo;garlic message\u0026rdquo; 내부의 여러 \u0026ldquo;clove\u0026quot;들 종단간 암호화 – 이전에는 ElGamal/AES+SessionTags, 현재는 ECIES‑X25519‑AEAD‑Ratchet 아키텍처는 그대로 유지되지만, 암호화 방식은 완전히 현대화되었습니다.\n3. 계층적 암호화 Garlic routing은 onion routing과 근본적인 원리를 공유합니다: 각 router는 암호화 계층 중 하나만 복호화하여 다음 hop만 알 뿐 전체 경로는 알지 못합니다.\n그러나 I2P는 양방향 회로가 아닌 단방향 터널을 구현합니다:\nOutbound tunnel: 생성자로부터 메시지를 전송합니다 Inbound tunnel: 생성자에게 메시지를 다시 전달합니다 완전한 왕복 통신(Alice ↔ Bob)은 네 개의 tunnel을 사용합니다: Alice의 outbound → Bob의 inbound, 그 다음 Bob의 outbound → Alice의 inbound. 이 설계는 양방향 회로에 비해 상관관계 데이터 노출을 절반으로 줄입니다.\n터널 구현 세부사항은 Tunnel Specification 과 Tunnel Creation (ECIES) 명세를 참조하세요.\n4. 여러 메시지 묶기 (\u0026ldquo;Cloves\u0026rdquo;) Freedman의 원래 garlic routing은 하나의 메시지 내에 여러 개의 암호화된 \u0026ldquo;bulbs\u0026quot;를 묶는 것을 구상했습니다. I2P는 이를 garlic message 내부의 cloves로 구현합니다 — 각 clove는 자체적인 암호화된 전달 지침과 대상(router, destination 또는 tunnel)을 가집니다.\nGarlic 번들링은 I2P가 다음을 수행할 수 있게 합니다:\n확인 응답과 메타데이터를 데이터 메시지와 결합 관찰 가능한 트래픽 패턴 감소 추가 연결 없이 복잡한 메시지 구조 지원 그림 1: 여러 개의 clove를 포함하는 Garlic Message, 각 clove는 자체 전달 지시사항을 가지고 있음.\n일반적인 정향(clove)에는 다음이 포함됩니다:\n전송 상태 메시지 — 전송 성공 또는 실패를 확인하는 승인 메시지.\n기밀성을 유지하기 위해 자체 garlic 레이어로 감싸집니다. 데이터베이스 저장 메시지 — 피어가 netDb를 다시 조회하지 않고 응답할 수 있도록 자동으로 번들된 LeaseSet. Clove는 다음과 같은 경우에 번들로 묶입니다:\n새로운 LeaseSet이 게시되어야 함 새로운 세션 태그가 전달됨 최근에 번들이 발생하지 않음 (기본값으로 약 1분) Garlic 메시지는 여러 암호화된 구성 요소를 단일 패킷으로 효율적인 종단 간 전달을 달성합니다.\n5. 암호화 발전 5.1 Historical Context 초기 문서(≤ v0.9.12)는 ElGamal/AES+SessionTags 암호화를 설명했습니다: - ElGamal 2048비트로 래핑된 AES 세션 키 - 페이로드 암호화를 위한 AES‑256/CBC - 메시지당 한 번 사용되는 32바이트 세션 태그\n해당 암호화 시스템은 더 이상 사용되지 않습니다.\n5.2 ECIES‑X25519‑AEAD‑Ratchet (Current Standard) 2019년부터 2023년 사이에 I2P는 ECIES‑X25519‑AEAD‑Ratchet으로 완전히 마이그레이션되었습니다. 최신 스택은 다음 구성 요소를 표준화합니다:\nLayer ECIES Primitive or Concept Transport Layer (NTCP2, SSU2) Noise_NX → X25519, ChaCha20/Poly1305, BLAKE2s I2NP Delivery ECIES‑X25519‑AEAD (ChaCha20/Poly1305) Session Management Ratchet with rekey records, per-clove key material Offline Authentication EdDSA (Ed25519) with LeaseSet2/MetaLeaseSet chains ECIES 마이그레이션의 이점: 메시지별 래칫 키를 통한 전방향 비밀성(Forward secrecy) ElGamal 대비 축소된 페이로드 크기 암호 해독 기술 발전에 대한 회복력 미래의 양자 내성 하이브리드와의 호환성 (제안 169 참조) 추가 세부 사항: ECIES 사양 및 EncryptedLeaseSet 사양 을 참조하세요.\n6. LeaseSets and Garlic Bundling Garlic 엔벨로프는 목적지 도달 가능성을 게시하거나 업데이트하기 위해 leaseSet을 자주 포함합니다.\nVersion Type Key Capabilities Distribution Notes 1 LeaseSet (legacy) Single encryption/signature pair Accepted for backward compatibility 3 LeaseSet2 Multiple crypto suites, offline signing keys Default for modern routers 5 EncryptedLeaseSet Access-controlled, destination hidden from floodfill Requires shared decryption key 7 MetaLeaseSet Aggregates multiple destinations or multi-homed services Extends LeaseSet2 fields recursively 모든 LeaseSet은 특수 라우터가 유지하는 *floodfill DHT*를 통해 배포됩니다. 게시는 메타데이터 상관관계를 줄이기 위해 검증되고, 타임스탬프가 찍히며, 속도 제한이 적용됩니다. 자세한 내용은 Network Database 문서 를 참조하십시오.\n7. Modern “Garlic” Applications within I2P Garlic 암호화와 메시지 번들링은 I2P 프로토콜 스택 전반에 걸쳐 사용됩니다:\n터널 생성 및 사용 — 홉(hop)별 계층화된 암호화 종단 간 메시지 전달 — 복제 확인응답(cloned-acknowledgment)과 LeaseSet clove가 포함된 번들 garlic 메시지 Network Database 게시 — 프라이버시를 위해 garlic 봉투로 래핑된 LeaseSet SSU2 및 NTCP2 전송 — Noise 프레임워크와 X25519/ChaCha20 기본 요소를 사용한 하위 계층 암호화 따라서 Garlic routing은 암호화 계층화 방법이자 네트워크 메시징 모델입니다.\n6. LeaseSets과 Garlic Bundling I2P의 문서 허브는 여기에서 확인할 수 있으며 , 지속적으로 유지 관리됩니다. 관련된 최신 명세서는 다음과 같습니다:\nECIES 명세서 — ECIES‑X25519‑AEAD‑Ratchet Tunnel 생성 (ECIES) — 현대적인 tunnel 구축 프로토콜 I2NP 명세서 — I2NP 메시지 형식 SSU2 명세서 — SSU2 UDP 전송 공통 구조 — netDb 및 floodfill 동작 학술적 검증: Hoang et al. (IMC 2018, USENIX FOCI 2019)과 Muntaka et al. (2025)은 I2P 설계의 아키텍처 안정성과 운영 복원력을 확인했습니다.\n7. I2P 내의 현대적인 \u0026ldquo;Garlic\u0026rdquo; 애플리케이션 진행 중인 제안:\n제안 169: 하이브리드 양자 내성 암호화 (ML-KEM 512/768/1024 + X25519) 제안 168: Transport 대역폭 최적화 데이터그램 및 스트리밍 업데이트: 향상된 혼잡 제어 향후 적응 방식에는 Freedman이 원래 설명한 사용되지 않은 전달 옵션을 기반으로 추가적인 메시지 지연 전략이나 garlic 메시지 수준에서의 다중 터널 중복성이 포함될 수 있습니다.\n8. 현재 문서 및 참고 자료 Freedman, M. J. \u0026amp; Dingledine, R. (2000). Free Haven Master\u0026rsquo;s Thesis, § 8.1.1. Free Haven Papers Onion Router Publications Garlic Routing (Wikipedia) Tor Project Free Haven Anonbib Goldschlag, D. M., Reed, M. G., Syverson, P. F. (1996). Hiding Routing Information. NRL Publication. ","description":"I2P에서 garlic routing 용어, 아키텍처 및 최신 구현 이해하기","id":"ba07d93d883918641f4a69832e497bb8","section":"docs","title":"Garlic Routing","url":"/ko/docs/overview/garlic-routing/"},{"categories":null,"content":"개요 참고: 더 이상 사용되지 않음 - 이제 선호 순서로 세 가지 형식을 지원합니다:\nMaxmind geoip2 (GeoLite2-Country.mmdb)는 Debian 패키지와 Android를 제외한 모든 설치에 번들됩니다. Debian geoip-database 패키지에 있는 Maxmind geoip1 (GeoIP.dat) 아래에 문서화된 IPv4 Tor 형식(geoip.txt)과 맞춤형 IPv6 형식(geoipv6.dat.gz)은 여전히 지원되지만 사용되지는 않습니다. 이 페이지는 router가 IP에 해당하는 국가를 조회하는 데 사용하는 여러 GeoIP 파일의 형식을 규정합니다.\n국가 이름 (countries.txt) 형식 이 형식은 다양한 공개 출처에서 제공되는 데이터 파일로부터 쉽게 생성할 수 있습니다. 예를 들어:\n$ wget http://geolite.maxmind.com/download/geoip/database/GeoIPCountryCSV.zip $ unzip GeoIPCountryCSV.zip $ cut -d, -f5,6 \u0026lt; GeoIPCountryWhois.csv | sed \u0026#39;s/\u0026#34;//g\u0026#39; | sort | uniq \u0026gt; countries.txt 형식 사양:\n인코딩은 UTF-8입니다 첫 번째 열의 \u0026lsquo;#\u0026lsquo;은 주석 행을 나타냅니다 항목 행은 CountryCode,CountryName 형식입니다 CountryCode는 ISO 두 글자 코드이며 대문자입니다 CountryName은 영어로 표기합니다 IPv4 (geoip.txt) 형식 이 형식은 Tor에서 차용되었으며, 여러 공개 출처에서 제공되는 데이터 파일로부터 쉽게 생성할 수 있습니다. 예를 들어:\n$ wget http://geolite.maxmind.com/download/geoip/database/GeoIPCountryCSV.zip $ unzip GeoIPCountryCSV.zip $ cut -d, -f3-5 \u0026lt; GeoIPCountryWhois.csv | sed \u0026#39;s/\u0026#34;//g\u0026#39; \u0026gt; geoip.txt $ cut -d, -f5,6 \u0026lt; GeoIPCountryWhois.csv | sed \u0026#39;s/\u0026#34;//g\u0026#39; | sort | uniq \u0026gt; countries.txt 형식 사양:\n인코딩은 ASCII입니다 1열의 \u0026lsquo;#\u0026lsquo;는 주석 행을 지정합니다 항목 행은 FromIP,ToIP,CountryCode 형식입니다 FromIP 및 ToIP는 4바이트 IP의 부호 없는 정수 표현입니다 CountryCode는 ISO 두 글자 코드이며 대문자입니다 항목 행은 FromIP의 숫자값 기준으로 정렬되어야 합니다 IPv6 (geoipv6.dat.gz) 형식 이는 I2P용으로 설계된 압축된 이진 형식입니다. 파일은 gzip으로 압축되어 있습니다. 압축 해제된 형식:\nBytes 0-9: Magic number \u0026#34;I2PGeoIPv6\u0026#34; Bytes 10-11: Version (0x0001) Bytes 12-15 Options (0x00000000) (future use) Bytes 16-23: Creation date (ms since 1970-01-01) Bytes 24-xx: Optional comment (UTF-8) terminated by zero byte Bytes xx-255: null padding Bytes 256-: 18 byte records: 8 byte from (/64) 8 byte to (/64) 2 byte ISO country code LOWER case (ASCII) 참고 사항:\n데이터는 정렬되어 있어야 하며(부호 있는 long 2의 보수 표현), 중복이 없어야 합니다. 따라서 순서는 80000000 \u0026hellip; FFFFFFFF 00000000 \u0026hellip; 7FFFFFFF 입니다. GeoIPv6.java 클래스에는 Maxmind GeoLite data와 같은 공개 소스에서 이 형식을 생성하는 프로그램이 포함되어 있습니다. IPv6 GeoIP 조회는 릴리스 0.9.8부터 지원됩니다. ","description":"IP→국가 조회를 위한 레거시 GeoIP 파일 형식 사양","id":"b5f34a4f13210a8caf4c4d0b5e62a828","section":"docs","title":"GeoIP 파일 형식","url":"/ko/docs/legacy/geoip-%ED%8C%8C%EC%9D%BC-%ED%98%95%EC%8B%9D/"},{"categories":null,"content":"네트워크 상황으로 인해 git clone이 불안정할 때, BitTorrent나 다른 파일 전송 방식을 통해 저장소를 git bundle로 배포할 수 있습니다. bundle은 전체 저장소 히스토리를 포함하는 단일 파일입니다. 다운로드 후에는 로컬에서 fetch하고 나서 다시 업스트림 리모트로 전환하면 됩니다.\n1. 시작하기 전에 번들을 생성하려면 완전한 Git 클론이 필요합니다. --depth 1로 생성된 얕은 클론은 정상적으로 작동하는 것처럼 보이지만 다른 사람이 사용하려고 할 때 실패하는 손상된 번들을 조용히 생성합니다. 항상 신뢰할 수 있는 소스(GitHub의 github.com/i2p/i2p.i2p , I2P Gitea 인스턴스인 i2pgit.org , 또는 I2P를 통한 git.idk.i2p)에서 가져오고, 필요한 경우 git fetch --unshallow를 실행하여 번들을 생성하기 전에 얕은 클론을 전체 클론으로 변환하세요.\n기존 번들을 사용하기만 하는 경우, 그냥 다운로드하면 됩니다. 특별한 준비는 필요하지 않습니다.\n2. 번들 다운로드 Obtaining the Bundle File I2PSnark(I2P에 내장된 토렌트 클라이언트) 또는 I2P 플러그인이 설치된 BiglyBT와 같은 다른 I2P 호환 클라이언트를 사용하여 BitTorrent를 통해 번들 파일을 다운로드하세요.\n중요: I2PSnark는 I2P 네트워크 전용으로 생성된 토렌트에서만 작동합니다. 일반 클리어넷 토렌트는 호환되지 않는데, I2P는 IP 주소와 포트 대신 Destination(387바이트 이상의 주소)을 사용하기 때문입니다.\n번들 파일 위치는 I2P 설치 유형에 따라 다릅니다:\n사용자/수동 설치 (Java 설치 프로그램으로 설치): ~/.i2p/i2psnark/ 시스템/데몬 설치 (apt-get 또는 패키지 관리자로 설치): /var/lib/i2p/i2p-config/i2psnark/ BiglyBT 사용자는 구성된 다운로드 디렉토리에서 다운로드한 파일을 찾을 수 있습니다.\nCloning from the Bundle 표준 방법 (대부분의 경우 작동함):\ngit clone ~/.i2p/i2psnark/i2p.i2p.bundle fatal: multiple updates for ref 오류가 발생하는 경우 (Git 2.21.0 이상 버전에서 전역 Git 설정에 충돌하는 fetch refspec이 포함되어 있을 때 발생하는 알려진 문제), 수동 초기화 방법을 사용하세요:\nmkdir i2p.i2p \u0026amp;\u0026amp; cd i2p.i2p git init git fetch ~/.i2p/i2psnark/i2p.i2p.bundle 또는 --update-head-ok 플래그를 사용할 수 있습니다:\ngit fetch --update-head-ok ~/.i2p/i2psnark/i2p.i2p.bundle \u0026#39;*:*\u0026#39; 번들 파일 획득하기 번들에서 클론한 후, 향후 fetch가 I2P 또는 clearnet을 통해 이루어지도록 클론이 실제 원격 저장소를 가리키도록 설정하세요:\ngit remote set-url origin git@127.0.0.1:I2P_Developers/i2p.i2p 또는 일반 인터넷(clearnet) 접속의 경우:\ngit remote set-url origin https://github.com/i2p/i2p.i2p I2P SSH 접속을 위해서는 I2P 라우터 콘솔에서 SSH 클라이언트 tunnel을 설정해야 합니다(일반적으로 포트 7670). 이 tunnel은 g6u4vqiuy6bdc3dbu6a7gmi3ip45sqwgtbgrr6uupqaaqfyztrka.b32.i2p를 가리켜야 합니다. 비표준 포트를 사용하는 경우:\nGIT_SSH_COMMAND=\u0026#34;ssh -p 7670\u0026#34; git clone git@127.0.0.1:I2P_Developers/i2p.i2p 3. Creating a Bundle 번들에서 복제하기 저장소가 완전한 복제본(shallow가 아닌)으로 완전히 최신 상태인지 확인하세요:\ngit fetch --all shallow clone이 있는 경우, 먼저 변환하세요:\ngit fetch --unshallow 라이브 리모트로 전환하기 Ant 빌드 타겟 사용 (I2P 소스 트리에 권장):\nant git-bundle 이는 i2p.i2p.bundle (번들 파일)과 i2p.i2p.bundle.torrent (BitTorrent 메타데이터)를 모두 생성합니다.\ngit bundle을 직접 사용하기:\ngit bundle create i2p.i2p.bundle --all 더 선택적인 번들의 경우:\ngit bundle create i2p.i2p.bundle --branches --tags Verifying Your Bundle 배포하기 전에 항상 번들을 검증하세요:\ngit bundle verify i2p.i2p.bundle 이는 번들이 유효함을 확인하고 필요한 선행 커밋을 표시합니다.\n사전 요구사항 번들과 토렌트 메타데이터를 I2PSnark 디렉토리에 복사하세요:\n사용자 설치의 경우:\ncp i2p.i2p.bundle* ~/.i2p/i2psnark/ 시스템 설치의 경우:\ncp i2p.i2p.bundle* /var/lib/i2p/i2p-config/i2psnark/ I2PSnark는 .torrent 파일을 수 초 내에 자동으로 감지하고 로드합니다. http://127.0.0.1:7657/i2psnark 에서 웹 인터페이스에 접속하여 시딩을 시작하세요.\n4. Creating Incremental Bundles 주기적인 업데이트를 위해서는 마지막 번들 이후의 새로운 커밋만 포함하는 증분 번들을 생성하세요:\ngit tag lastBundleTag git bundle create update.bundle lastBundleTag..master 사용자가 이미 base 저장소를 가지고 있다면 incremental 번들에서 가져올 수 있습니다:\ngit fetch /path/to/update.bundle 증분 번들이 예상되는 사전 요구 커밋을 표시하는지 항상 확인하십시오:\ngit bundle verify update.bundle 5. Updating After the Initial Clone 번들에서 작동하는 저장소를 확보했다면, 다른 Git 클론처럼 다루면 됩니다:\ngit remote add upstream git@127.0.0.1:I2P_Developers/i2p.i2p git fetch upstream git merge upstream/master 또는 더 간단한 워크플로우의 경우:\ngit fetch origin git pull origin master 3. 번들 생성하기 탄력적인 배포: 대규모 저장소는 BitTorrent를 통해 공유될 수 있으며, 재시도, 조각 검증, 재개가 자동으로 처리됩니다. Peer-to-peer 부트스트랩: 새로운 기여자는 I2P 네트워크의 인근 peer로부터 클론을 부트스트랩한 다음, Git 호스트에서 직접 증분 변경사항을 가져올 수 있습니다. 서버 부하 감소: Mirror는 주기적인 번들을 게시하여 활성 Git 호스트의 부담을 줄일 수 있으며, 이는 대규모 저장소나 느린 네트워크 환경에서 특히 유용합니다. 오프라인 전송: 번들은 BitTorrent뿐만 아니라 모든 파일 전송 수단(USB 드라이브, 직접 전송, sneakernet)에서 작동합니다. 번들은 라이브 원격 저장소를 대체하지 않습니다. 단지 초기 클론이나 주요 업데이트를 위한 더 탄력적인 부트스트래핑 방법을 제공할 뿐입니다.\n7. Troubleshooting 번들 생성하기 문제: 번들 생성은 성공하지만 다른 사용자가 번들에서 클론할 수 없습니다.\n원인: 소스 클론이 shallow(얕은 클론)입니다(--depth 옵션으로 생성됨).\n해결 방법: 번들을 생성하기 전에 전체 복제본으로 변환하세요:\ngit fetch --unshallow 번들 검증하기 문제: 번들에서 클론할 때 fatal: multiple updates for ref 오류 발생.\n원인: Git 2.21.0 이상 버전이 ~/.gitconfig의 전역 fetch refspec과 충돌합니다.\n해결 방법: 1. 수동 초기화 사용: mkdir repo \u0026amp;\u0026amp; cd repo \u0026amp;\u0026amp; git init \u0026amp;\u0026amp; git fetch /path/to/bundle 2. --update-head-ok 플래그 사용: git fetch --update-head-ok /path/to/bundle '*:*' 3. 충돌하는 설정 제거: git config --global --unset remote.origin.fetch\nI2PSnark를 통한 배포 문제: git bundle verify가 누락된 전제 조건을 보고합니다.\n원인: 증분 번들 또는 불완전한 소스 복제.\n해결 방법: 필수 커밋을 먼저 가져오거나, 기본 번들을 먼저 사용한 다음 증분 업데이트를 적용하세요.\n","description":"``` git bundle과 BitTorrent를 사용하여 대용량 저장소 가져오기 및 배포하기 ```","id":"555586cb7b43c73ad912bbb01f20326b","section":"docs","title":"Git 번들 (I2P용)","url":"/ko/docs/applications/git-bundle/"},{"categories":null,"content":"Eepsite(I2P 내부 익명 웹사이트)란 무엇인가요? eepsite(I2P 네트워크 전용 웹사이트)는 I2P 네트워크에서만 존재하는 웹사이트입니다. clearnet(일반 인터넷)을 통해 접속할 수 있는 전통적인 웹사이트와 달리, eepsites는 오직 I2P를 통해서만 접속할 수 있어 사이트 운영자와 방문자 모두의 익명성과 프라이버시를 보호합니다. Eepsites는 .i2p 의사 최상위 도메인을 사용하며, 특수한 .b32.i2p 주소 또는 I2P address book(I2P 주소록)에 등록된 사람이 읽을 수 있는 이름을 통해 접속할 수 있습니다.\n모든 Java I2P 배포판에는 경량의 Java 기반 웹서버인 Jetty 가 사전 설치되고 사전 구성된 상태로 포함되어 있습니다. 덕분에 몇 분 안에 자신의 eepsite(I2P 내부 웹사이트)를 호스팅하기 시작할 수 있으며 - 추가 소프트웨어 설치가 필요 없습니다.\n이 가이드는 I2P의 내장 도구를 사용하여 첫 번째 eepsite를 생성하고 설정하는 과정을 단계별로 안내합니다.\n1단계: 숨은 서비스 관리자 열기 Hidden Services Manager(I2P Tunnel Manager라고도 함)은 HTTP 서버(eepsites)를 포함하여 모든 I2P 서버 및 클라이언트 tunnels을 설정하는 곳입니다.\nI2P Router Console 을 엽니다 Hidden Services Manager 로 이동합니다 Hidden Services Manager 인터페이스에 다음이 표시되어야 합니다: - 상태 메시지 - 현재 tunnel 및 클라이언트 상태 - 전역 tunnel 제어 - 모든 tunnel을 한 번에 관리하는 버튼 - I2P Hidden Services - 구성된 서버 tunnel 목록\n기본적으로, 설정되어 있지만 아직 시작되지 않은 기존의 I2P 웹서버 항목이 보일 것입니다. 이는 바로 사용하실 수 있도록 사전 구성된 Jetty 웹서버입니다.\n2단계: Eepsite 서버 설정 구성 Hidden Services 목록에서 I2P webserver 항목을 클릭하여 서버 설정 페이지를 엽니다. 여기에서 eepsite의 설정을 맞춤설정할 수 있습니다.\n구성 옵션 설명 이름 - 귀하의 tunnel에 대한 내부 식별자입니다 - 여러 eepsites를 운영하는 경우 어느 것이 어느 것인지 추적하는 데 유용합니다 - 기본값: \u0026ldquo;I2P webserver\u0026rdquo;\n설명 - 참고용으로 자신의 eepsite에 대한 간단한 설명 - Hidden Services Manager(숨은 서비스 관리자)에서 본인에게만 표시됨 - 예: \u0026ldquo;내 eepsite\u0026rdquo; 또는 \u0026ldquo;개인 블로그\u0026rdquo;\n자동 시작 Tunnel - 중요: I2P router가 시작될 때 eepsite를 자동으로 시작하려면 이 확인란을 선택하세요 - router가 다시 시작된 후에도 수동 개입 없이 사이트가 계속 접속 가능하도록 보장합니다 - 권장: 활성화\n대상(호스트와 포트) - 호스트: 웹 서버가 실행 중인 로컬 주소(기본값: 127.0.0.1) - 포트: 웹 서버가 수신 대기하는 포트(기본값: Jetty의 경우 7658) - 사전 설치된 Jetty 웹 서버를 사용 중이라면, 이 값들을 기본값으로 그대로 두세요 - 다른 포트에서 사용자 정의 웹 서버를 실행 중인 경우에만 변경하세요\n웹사이트 호스트 이름 - 이는 eepsite의 사람이 읽기 쉬운 .i2p 도메인 이름입니다 - 기본값: mysite.i2p (자리표시자) - stormycloud.i2p 또는 myblog.i2p 같은 사용자 지정 도메인을 등록할 수 있습니다 - 자동 생성되는 .b32.i2p 주소만 사용하려면 비워 두세요 (outproxy(아웃프록시)용) - 사용자 지정 호스트 이름을 등록하는 방법은 아래의 I2P 도메인 등록 을 참조하세요\nLocal Destination - 이는 귀하의 eepsite의 고유한 암호학적 식별자(destination address, 목적지 주소)입니다 - tunnel이 처음 생성될 때 자동으로 생성됩니다 - I2P에서 귀하의 사이트의 영구적인 \u0026ldquo;IP address\u0026quot;라고 생각하면 됩니다 - 긴 영숫자 문자열은 귀하의 사이트 .b32.i2p 주소를 인코딩한 형태입니다\n개인 키 파일 - 귀하의 eepsite의 개인 키가 저장되는 위치 - 기본값: eepsite/eepPriv.dat - 이 파일을 안전하게 보호하십시오 - 이 파일에 접근할 수 있는 사람은 누구나 귀하의 eepsite를 사칭할 수 있습니다 - 이 파일을 절대 공유하거나 삭제하지 마십시오\n중요 참고 사항 QR 코드 생성 또는 등록 인증 기능을 사용하려면 .i2p 접미사가 붙은 웹사이트 호스트 이름을 구성해야 한다는 점을 노란색 경고 상자가 상기시켜 줍니다(예: mynewsite.i2p).\n3단계: 고급 네트워킹 옵션(선택 사항) 설정 페이지에서 아래로 스크롤하면 고급 네트워크 옵션을 찾을 수 있습니다. 이 설정은 선택 사항입니다 - 기본 설정은 대부분의 사용자에게 잘 동작합니다. 그러나 보안 요구 사항과 성능 요구 사항에 따라 조정할 수 있습니다.\nTunnel 길이 옵션 Tunnel 길이 - 기본값: 3홉 tunnel (높은 익명성) - 요청이 eepsite에 도달하기 전에 몇 개의 router 홉을 경유할지 제어합니다 - 홉이 많을수록 = 익명성은 높지만 성능은 느려집니다 - 홉이 적을수록 = 성능은 빨라지지만 익명성은 낮아집니다 - 옵션은 variance 설정(변동 설정)과 함께 0-3 홉 범위로 제공됩니다 - 권장 사항: 특별한 성능 요구가 없다면 3홉으로 유지하세요\nTunnel 변동폭 - 기본값: 0 홉 변동폭 (무작위화 없음, 일관된 성능) - 보안을 강화하기 위해 tunnel 길이에 무작위성을 추가 - 예: \u0026ldquo;0-1 홉 변동폭\u0026quot;은 tunnel이 무작위로 3 또는 4 홉이 됨을 의미 - 예측 불가능성이 증가하지만 로드 시간이 일관되지 않을 수 있음\nTunnel 수량 옵션 개수 (인바운드/아웃바운드 tunnel) - 기본값: 인바운드 tunnel 2개, 아웃바운드 tunnel 2개 (표준 대역폭 및 안정성) - eepsite에 할당되는 병렬 tunnel 수를 제어합니다 - 더 많은 tunnel = 더 나은 가용성과 부하 처리 능력, 하지만 더 높은 자원 사용량 - 더 적은 tunnel = 더 낮은 자원 사용량, 하지만 중복성 감소 - 대부분의 사용자에게 권장: 2/2 (기본값) - 트래픽이 많은 eepsite는 3/3 이상이 도움이 될 수 있습니다\n백업 개수 - 기본값: 백업 tunnels 0개 (중복 없음, 추가 리소스 사용량 없음) - 주요 tunnels가 실패하면 활성화되는 대기용 tunnels - 신뢰성을 높이지만 더 많은 대역폭과 CPU를 소모 - 대부분의 개인용 eepsites에는 백업 tunnels가 필요하지 않음\nPOST 제한 eepsite에 양식(문의 양식, 댓글 섹션, 파일 업로드 등)이 포함되어 있다면, 남용을 방지하기 위해 POST 요청 제한을 설정할 수 있습니다:\n클라이언트별 제한 - 기간당: 단일 클라이언트로부터의 최대 요청 수 (기본값: 5분당 6회) - 차단 기간: 남용하는 클라이언트를 얼마나 오래 차단할지 (기본값: 20분)\nTotal Limits - Total: 모든 클라이언트 합산 기준 최대 POST 요청 수(기본값: 5분당 20회) - Ban Duration: 제한 초과 시 모든 POST 요청을 거부하는 기간(기본값: 10분)\nPOST 제한 기간 - 요청 빈도를 측정하는 시간 창(기본값: 5분)\n이러한 제한은 스팸, 서비스 거부(DoS) 공격, 그리고 자동화된 폼 제출의 악용으로부터 보호하는 데 도움이 됩니다.\n고급 설정을 조정해야 할 때 트래픽이 많은 커뮤니티 사이트: tunnel 개수를 늘리세요(인바운드/아웃바운드 각각 3-4) 성능이 중요한 애플리케이션: tunnel 길이를 2홉으로 줄이세요(익명성 감소라는 트레이드오프가 있음) 최대 수준의 익명성이 필요한 경우: 3홉을 유지하고, 길이 변동(variance) 0-1을 추가하세요 정상적으로 사용량이 많은 양식: POST 제한을 그에 맞게 늘리세요 개인 블로그/포트폴리오: 모든 기본값을 사용하세요 4단계: 귀하의 Eepsite에 콘텐츠 추가 이제 eepsite 설정을 마쳤으므로 웹서버의 문서 루트 디렉터리에 웹사이트 파일(HTML, CSS, 이미지 등)을 추가해야 합니다. 해당 위치는 사용하는 운영 체제, 설치 유형, 그리고 I2P 구현에 따라 달라집니다.\n문서 루트 찾기 문서 루트(일반적으로 docroot라고도 합니다)는 웹사이트의 모든 파일을 두는 디렉터리입니다. index.html 파일은 직접 이 디렉터리에 놓아야 합니다.\nJava I2P (표준 배포판) 리눅스 - 표준 설치: ~/.i2p/eepsite/docroot/ - 패키지 설치 (서비스로 실행): /var/lib/i2p/i2p-config/eepsite/docroot/\nWindows - 표준 설치: %LOCALAPPDATA%\\I2P\\eepsite\\docroot\\ - 일반적인 경로: C:\\Users\\YourUsername\\AppData\\Local\\I2P\\eepsite\\docroot\\ - Windows 서비스 설치: %PROGRAMDATA%\\I2P\\eepsite\\docroot\\ - 일반적인 경로: C:\\ProgramData\\I2P\\eepsite\\docroot\\\nmacOS - 표준 설치: /Users/YourUsername/Library/Application Support/i2p/eepsite/docroot/\nI2P+ (향상된 I2P 배포판) I2P+는 Java I2P와 동일한 디렉터리 구조를 사용합니다. 운영 체제에 따라 위에 제시된 경로를 따르십시오.\ni2pd (C++ 구현체) Linux/Unix - 기본값: /var/lib/i2pd/eepsite/ 또는 ~/.i2pd/eepsite/ - HTTP 서버 tunnel 아래의 실제 root 설정은 i2pd.conf 구성 파일에서 확인하세요\nWindows - i2pd 설치 디렉터리의 i2pd.conf를 확인하세요\nmacOS - 일반적으로: ~/Library/Application Support/i2pd/eepsite/\n웹사이트 파일 추가하기 문서 루트로 이동 파일 관리자 또는 터미널을 사용하여 웹사이트 파일을 생성하거나 복사 docroot 폴더에 최소한 index.html 파일을 만듭니다(홈페이지입니다) 필요에 따라 CSS, JavaScript, 이미지 및 기타 리소스를 추가합니다 하위 디렉터리를 구성 일반적인 웹사이트와 마찬가지로: docroot/ ├── index.html ├── about.html ├── css/ │ └── style.css ├── images/ │ └── logo.png └── js/ └── script.js 빠른 시작: 간단한 HTML 예제 이제 막 시작하는 경우, docroot 폴더에 기본 index.html 파일을 만드세요:\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;My I2P Eepsite\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Welcome to My Eepsite!\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;This is my first website on the I2P network.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Privacy-focused and decentralized!\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 권한 (Linux/Unix/macOS) I2P를 서비스로 실행하거나 다른 사용자 계정으로 실행 중이라면, I2P 프로세스가 귀하의 파일에 대한 읽기 권한을 가지고 있는지 확인하세요:\n# Set appropriate ownership (if running as i2p user) sudo chown -R i2p:i2p /var/lib/i2p/i2p-config/eepsite/docroot/ # Or set readable permissions for all users chmod -R 755 ~/.i2p/eepsite/docroot/ 팁 기본 콘텐츠: I2P를 처음 설치하면 docroot 폴더에 이미 샘플 콘텐츠가 들어 있습니다 - 원하시면 자유롭게 교체하세요 정적 사이트가 가장 적합합니다: Jetty는 서블릿과 JSP를 지원하지만, 단순한 HTML/CSS/JavaScript 사이트가 유지 관리하기 가장 쉽습니다 외부 웹 서버: 고급 사용자는 다른 포트에서 사용자 지정 웹 서버(Apache, Nginx, Node.js 등)를 실행하고 I2P tunnel을 해당 서버로 가리키도록 설정할 수 있습니다 5단계: Eepsite 시작하기 이제 eepsite가 구성되었고 콘텐츠도 준비되었으니, 이를 시작해 I2P 네트워크에서 접근 가능하도록 만들 차례입니다.\nTunnel 시작 Hidden Services Manager 로 돌아가세요 목록에서 I2P webserver 항목을 찾으세요 Control 열에서 Start 버튼을 클릭하세요 Tunnel 수립 대기 Start를 클릭하면, 사용자의 eepsite tunnel이 구축되기 시작합니다. 이 과정은 보통 30-60초 정도 걸립니다. 상태 표시기를 확인하세요:\n빨간 표시등 = Tunnel 시작/구축 중 노란 표시등 = Tunnel이 부분적으로 설정됨 초록 표시등 = Tunnel이 완전히 정상 작동하며 준비됨 녹색 표시등이 보이면, 귀하의 eepsite가 I2P 네트워크에서 온라인 상태입니다!\n내 Eepsite에 접속하기 실행 중인 eepsite 옆에 있는 Preview 버튼을 클릭하세요. 그러면 eepsite의 주소가 표시된 새 브라우저 탭이 열립니다.\n사용자의 eepsite에는 두 가지 유형의 주소가 있습니다:\nBase32 주소 (.b32.i2p): 다음과 같은 긴 암호학적 주소:\nhttp://fcyianvr325tdgiiueyg4rsq4r5iuibzovl26msox5ryoselykpq.b32.i2p 이는 eepsite(익명 웹사이트)의 영구적이며 암호학적으로 파생된 주소입니다 변경할 수 없으며 개인 키와 연계되어 있습니다 도메인 등록이 없어도 항상 유효합니다 사람이 읽기 쉬운 도메인(.i2p): 웹사이트 호스트명을 설정하면 (예: testwebsite.i2p)\n도메인 등록 후에만 작동함 (다음 섹션 참조) 기억하고 공유하기 쉬움 귀하의 .b32.i2p 주소로 매핑됨 호스트명 복사 버튼을 사용하면 공유를 위해 전체 .b32.i2p 주소를 빠르게 복사할 수 있습니다.\n⚠️ 중요: 개인 키를 백업하세요 더 진행하기 전에, eepsite(I2P 내 웹사이트)의 개인 키 파일을 반드시 백업해야 합니다. 이는 여러 가지 이유로 매우 중요합니다:\n왜 키를 백업해야 하나요? 귀하의 개인 키(eepPriv.dat)는 귀하의 eepsite(I2P 네트워크 전용 웹사이트)의 정체성입니다. 이는 귀하의 .b32.i2p 주소를 결정하고 eepsite에 대한 소유권을 증명합니다.\n키 = .b32 주소: 개인 키는 수학적으로 고유한 .b32.i2p 주소를 생성합니다 복구할 수 없음: 키를 잃으면 eepsite 주소를 영구적으로 잃게 됩니다 변경할 수 없음: .b32 주소를 가리키는 도메인을 등록했다면, 이를 업데이트할 방법이 없습니다 - 등록은 영구적입니다 마이그레이션에 필요: 새 컴퓨터로 이동하거나 I2P를 재설치할 때 동일한 주소를 유지하려면 이 키가 필요합니다 멀티호밍 지원: 여러 위치에서 eepsite를 운영하려면 각 서버에 동일한 키가 필요합니다 개인 키는 어디에 있나요? 기본적으로 개인 키는 다음 위치에 저장됩니다: - Linux: ~/.i2p/eepsite/eepPriv.dat (서비스로 설치한 경우 또는 /var/lib/i2p/i2p-config/eepsite/eepPriv.dat) - Windows: %LOCALAPPDATA%\\I2P\\eepsite\\eepPriv.dat 또는 %PROGRAMDATA%\\I2P\\eepsite\\eepPriv.dat - macOS: /Users/YourUsername/Library/Application Support/i2p/eepsite/eepPriv.dat\n또한 tunnel 설정의 \u0026ldquo;Private Key File\u0026quot;에서 이 경로를 확인하거나 변경할 수 있습니다.\n백업하는 방법 tunnel을 중지하세요 (선택 사항이지만 더 안전합니다) eepPriv.dat을 복사하세요 안전한 위치로: 외장 USB 드라이브 암호화된 백업 드라이브 비밀번호로 보호된 아카이브 보안 클라우드 스토리지(암호화됨) 여러 개의 백업을 보관하세요 서로 다른 물리적 위치에 이 파일을 절대 공유하지 마세요 - 이 파일을 가진 사람은 누구나 귀하의 eepsite를 사칭할 수 있습니다 백업에서 복원 새 시스템에서 또는 재설치한 후 eepsite를 복원하려면:\nI2P를 설치하고 tunnel 설정을 생성/구성하세요 키를 복사하기 전에 tunnel을 중지하세요 백업해 둔 eepPriv.dat를 올바른 위치로 복사하세요 tunnel을 시작하세요 - 기존 .b32 주소를 사용합니다 도메인을 등록하지 않을 경우 축하합니다! 사용자 지정 .i2p 도메인 이름을 등록할 계획이 없다면, 이제 귀하의 eepsite(I2P 내 웹사이트)는 완성되어 정상적으로 운영됩니다.\n다음을 수행할 수 있습니다: - 자신의 .b32.i2p 주소를 다른 사람들과 공유 - 어떤 I2P 지원 브라우저를 사용해 I2P 네트워크를 통해 사이트에 접속 - 언제든지 docroot 폴더의 웹사이트 파일을 업데이트 - Hidden Services Manager(숨겨진 서비스 관리자)에서 tunnel 상태를 모니터링\n사람이 읽기 쉬운 도메인을 원한다면 (mysite.i2p처럼 긴 .b32 주소가 아닌), 다음 섹션으로 이동하세요.\n자신의 I2P 도메인 등록하기 사람이 읽기 쉬운 .i2p 도메인(예: testwebsite.i2p)은 긴 .b32.i2p 주소보다 기억하고 공유하기가 훨씬 쉽습니다. 도메인 등록은 무료이며 선택한 이름을 eepsite의 암호학적 주소에 연결합니다.\n사전 요구 사항 사용자의 eepsite가 녹색 표시로 실행 중이어야 합니다 tunnel 구성에서 Website Hostname을 설정했어야 합니다(2단계) 예: testwebsite.i2p 또는 myblog.i2p 1단계: 인증 문자열 생성 tunnel 구성으로 돌아가세요 Hidden Services Manager(숨김 서비스 관리자)에서 설정을 열려면 자신의 I2P 웹서버 항목을 클릭하세요 아래로 스크롤하여 Registration Authentication 버튼(등록 인증)을 찾으세요 Registration Authentication을 클릭합니다 \u0026ldquo;Authentication for adding host [yourdomainhere]\u0026ldquo;에 표시된 전체 인증 문자열을 복사합니다 인증 문자열은 다음과 같습니다:\ntestwebsite.i2p=I8WiuSx1TcYAutCrhLveZ6gghdqsIJ1v9noSGPb7ItYjxaK5LHVNxgC60KuEu95nqCCF2qwgnW~2ehIY9vsi1iPForksdU3GALrQq4S73meoIIXarCCdb~Z6Ehj2-yLWI8WiuSx1TcYAutCrhLveZ6gghdqsIJ1v9noSGPb7ItYjxaK5LHVNxgC60KuEu95nqCCF2qwgnW~2ehIY9vsi1iPForksdU3GALrQq4S73meoIIXarCCdb~Z6Ehj2-yLWI8WiuSx1TcYAutCrhLveZ6gghdqsIJ1v9noSGPb7ItYjxaK5LHVNxgC60KuEu95nqCCF2qwgnW~2ehIY9vsi1iPForksdU3GALrQq4S73meoIIXarCCdb~Z6Ehj2-yLWI8WiuSx1TcYAutCrhLveZ6gghdqsIJ1v9noSGPb7ItYjxaK5LHVNxgC60KuEu95nqCCF2qwgnW~2ehIY9vsi1uNxFZ0HN7tQbbVj1pmbahepQZNxEW0ufwnMYAoFo8opBQAEAAcAAA==#!date=1762104890#sig=9DjEfrcNRxsoSxiE0Mp0-7rH~ktYWtgwU8c4J0eSo0VHbGxDxdiO9D1Cvwcx8hkherMO07UWOC9BWf-1wRyUAw== 이 문자열에는 다음이 포함됩니다: - 귀하의 도메인 이름 (testwebsite.i2p) - 귀하의 Destination(목적지) 주소 (길이가 긴 암호학적 식별자) - 타임스탬프 - 개인 키를 소유하고 있음을 증명하는 암호학적 서명\n이 인증 문자열을 보관해 두세요 - 두 등록 서비스 모두에 필요합니다.\n2단계: stats.i2p에 등록하기 다음 위치로 이동 stats.i2p Add Key (I2P 내에서) 인증 문자열을 붙여넣으세요 \u0026ldquo;Authentication String\u0026rdquo; 필드에 이름을 추가하세요 (선택 사항) - 기본값은 \u0026ldquo;Anonymous\u0026rdquo; 설명을 추가하세요 (권장) - eepsite가 무엇에 관한 것인지 간단히 설명하세요 예: \u0026ldquo;새 I2P Eepsite\u0026rdquo;, \u0026ldquo;개인 블로그\u0026rdquo;, \u0026ldquo;파일 공유 서비스\u0026rdquo; \u0026ldquo;HTTP Service?\u0026ldquo;을 선택하세요 웹사이트인 경우 (대부분의 eepsite는 선택 상태로 두세요) IRC, NNTP, 프록시, XMPP, git 등에는 선택을 해제하세요 Submit을 클릭하세요 성공하면 도메인이 stats.i2p 주소록에 추가되었다는 확인 메시지가 표시됩니다.\n3단계: reg.i2p에서 등록하기 최대 가용성을 확보하려면 reg.i2p 서비스에도 등록하는 것이 좋습니다:\n다음으로 이동하세요 reg.i2p Add Domain (I2P 내에서) 동일한 인증 문자열을 붙여넣으세요 \u0026ldquo;Auth string\u0026rdquo; 필드에 설명을 추가하세요 (선택 사항이지만 권장됩니다) 이는 다른 I2P 사용자가 사이트에서 제공하는 내용을 이해하는 데 도움이 됩니다 Submit을 클릭하세요 도메인이 등록되었다는 확인을 받게 됩니다.\n4단계: 전파 대기 두 서비스 모두에 제출한 후, 도메인 등록이 I2P 네트워크의 주소록 시스템을 통해 전파됩니다.\n전파 타임라인: - 초기 등록: 등록 서비스에서 즉시 - 네트워크 전체 전파: 수 시간에서 24시간 이상 - 완전한 이용 가능: 모든 routers가 업데이트되기까지 최대 48시간이 걸릴 수 있습니다\n정상입니다! I2P 주소록 시스템은 즉시가 아니라 주기적으로 업데이트됩니다. 귀하의 eepsite(익명 웹사이트)는 정상적으로 작동하고 있습니다 - 다른 사용자들이 업데이트된 주소록을 받기만 하면 됩니다.\n도메인 확인 몇 시간이 지나면 도메인을 테스트할 수 있습니다:\nI2P 브라우저에서 새 브라우저 탭을 여세요 도메인에 직접 접속해 보세요: http://yourdomainname.i2p 열리면, 도메인이 등록되어 전파 중입니다! 아직 작동하지 않으면: - 좀 더 기다리세요(주소록은 자체 일정에 따라 업데이트됩니다) - router의 주소록이 동기화되는 데 시간이 필요할 수 있습니다 - 주소록 업데이트를 강제로 수행하려면 I2P router를 다시 시작해 보세요\n중요 참고 사항 등록은 영구적입니다: 등록되어 전파되면, 도메인은 영구적으로 자신의 .b32.i2p 주소를 가리키게 됩니다 목적지는 변경할 수 없습니다: 도메인이 가리키는 .b32.i2p 주소는 업데이트할 수 없습니다 - 따라서 eepPriv.dat를 백업하는 것이 매우 중요합니다 도메인 소유권: 개인 키 보유자만 도메인을 등록하거나 업데이트할 수 있습니다 무료 서비스: I2P에서의 도메인 등록은 무료이며, 커뮤니티가 운영하고, 탈중앙화되어 있습니다 여러 등록기관: stats.i2p와 reg.i2p 모두에 등록하면 신뢰성과 전파 속도가 향상됩니다 축하합니다! 귀하의 I2P eepsite(I2P 전용 웹사이트)가 이제 등록된 도메인과 함께 완전히 운영 중입니다!\n다음 단계: - docroot 폴더에 더 많은 콘텐츠를 추가하세요 - I2P 커뮤니티와 도메인을 공유하세요 - eepPriv.dat 백업을 안전하게 보관하세요 - tunnel 상태를 정기적으로 모니터링하세요 - 사이트를 홍보하기 위해 I2P 포럼이나 IRC(인터넷 릴레이 채팅)에 참여하는 것을 고려하세요\nI2P 네트워크에 오신 것을 환영합니다! 🎉\n","description":"내장된 Jetty 웹 서버를 사용하여 I2P 네트워크에서 나만의 웹사이트를 만들고 호스팅하는 방법을 알아보세요","id":"cdd089b486cced0cc2a37529ae0ace6b","section":"docs","title":"I2P Eepsite(I2P 전용 익명 웹사이트) 만들기","url":"/ko/docs/guides/i2p-eepsitei2p-%EC%A0%84%EC%9A%A9-%EC%9D%B5%EB%AA%85-%EC%9B%B9%EC%82%AC%EC%9D%B4%ED%8A%B8-%EB%A7%8C%EB%93%A4%EA%B8%B0/"},{"categories":null,"content":"소개 I2P는 내장된 웹메일 클라이언트인 SusiMail과 결합된 Postman\u0026rsquo;s Mail.i2p 서비스를 통해 이메일 방식의 프라이빗 메시징을 제공합니다. 이 시스템을 통해 사용자는 I2P 네트워크 내부뿐만 아니라 게이트웨이 브리지를 통해 일반 인터넷(clearnet)과의 사이에서도 이메일을 주고받을 수 있습니다.\nTechnical Details SMTP 서비스: localhost:7659 (Postman 제공) POP3 서비스: localhost:7660 웹메일 접근: 라우터 콘솔에 내장 http://127.0.0.1:7657/susimail/\n중요: SusiMail은 이메일을 읽고 보내는 용도로만 사용됩니다. 계정 생성 및 관리는 hq.postman.i2p에서 수행해야 합니다.\n","description":"I2P 네트워크 내 이메일 시스템 개요 — 역사, 옵션 및 현재 상태","id":"31217ea91c11f98bd1997466684f9fb3","section":"docs","title":"I2P Mail (I2P를 통한 익명 이메일)","url":"/ko/docs/applications/i2p-mail/"},{"categories":null,"content":"I2P router가 실패하는 가장 흔한 원인은 포트 포워딩 문제, 불충분한 대역폭 할당, 부적절한 부트스트랩(초기 네트워크 동기화) 시간입니다. 이 세 가지 요인이 보고된 문제의 70% 이상을 차지합니다. router는 시작 후 네트워크에 완전히 통합되려면 최소 10-15분이 필요하며, 128 KB/sec 최소 대역폭(256 KB/sec 권장)과 적절한 UDP/TCP 포트 포워딩이 있어야 방화벽에 막히지 않은 상태를 달성할 수 있습니다. 새 사용자는 즉각적인 연결을 기대하고 너무 일찍 재시작하는 경우가 흔한데, 이로 인해 통합 진행 상황이 초기화되어 좌절스러운 악순환이 생깁니다. 이 가이드는 2.10.0 이상 버전에 영향을 미치는 주요 I2P 문제 전반에 대한 자세한 해결책을 제공합니다.\nI2P의 익명성 아키텍처는 암호화된 다중 홉 tunnel을 사용하기 때문에 본질적으로 프라이버시를 위해 속도를 대가로 치릅니다. 이러한 근본적인 설계를 이해하면 사용자는 정상적인 동작을 문제로 오해하지 않고 현실적인 기대치를 설정하고 효과적으로 문제를 해결할 수 있습니다.\nRouter가 시작되지 않거나 즉시 충돌합니다 가장 흔한 시작 실패는 포트 충돌, Java 버전 비호환성, 또는 손상된 구성 파일에서 비롯됩니다. 더 깊은 문제를 조사하기 전에 다른 I2P 인스턴스가 이미 실행 중인지 확인하세요.\n충돌하는 프로세스가 없는지 확인:\n리눅스: ps aux | grep i2p 또는 netstat -tulpn | grep 7657\nWindows: 작업 관리자 → 세부 정보 → 명령줄에 i2p가 포함된 java.exe를 찾으세요\nmacOS: 활동 모니터 → \u0026ldquo;i2p\u0026rdquo; 검색\n좀비 프로세스가 있다면 강제 종료하세요: pkill -9 -f i2p (Linux/Mac) 또는 taskkill /F /IM javaw.exe (Windows)\nJava 버전 호환성 확인:\nI2P 2.10.0+는 최소 Java 8이 필요하며, Java 11 이상을 권장합니다. 설치가 \u0026ldquo;mixed mode\u0026rdquo;(\u0026ldquo;interpreted mode\u0026quot;가 아님)로 표시되는지 확인하세요:\njava -version 다음이 표시되어야 합니다: OpenJDK 또는 Oracle Java, 버전 8+, \u0026ldquo;mixed mode\u0026rdquo;\n피하십시오: GNU GCJ, 구식 Java 구현체, 인터프리터 전용 모드\n일반적인 포트 충돌은 여러 서비스가 I2P의 기본 포트를 두고 경쟁할 때 발생합니다. router console (7657), I2CP (7654), SAM (7656), 그리고 HTTP 프록시 (4444)는 사용 가능해야 합니다. 충돌 여부 확인: netstat -ano | findstr \u0026quot;7657 4444 7654\u0026quot; (Windows) 또는 lsof -i :7657,4444,7654 (Linux/Mac).\n구성 파일 손상은 로그에 구문 분석 오류가 기록되며 즉시 충돌이 발생하는 형태로 나타납니다. Router.config는 BOM 없는 UTF-8 인코딩을 요구하고, 구분자로 =를 사용합니다 ( : 아님), 또한 특정 특수 문자는 금지됩니다. 백업한 뒤 다음을 확인하세요: ~/.i2p/router.config (Linux), %LOCALAPPDATA%\\I2P\\router.config (Windows), ~/Library/Application Support/i2p/router.config (macOS).\n식별 정보를 유지하면서 구성을 초기화하려면: I2P를 중지하고, router.keys와 keyData 디렉터리를 백업한 뒤, router.config를 삭제하고 재시작하십시오. router가 기본 구성을 다시 생성합니다.\nJava 힙 할당량이 너무 낮으면 OutOfMemoryError(메모리 부족 오류) 충돌이 발생합니다. wrapper.config를 편집하고 wrapper.java.maxmemory를 기본값 128 또는 256에서 최소 512(고대역폭 routers의 경우 1024)로 늘리세요. 이 변경을 적용하려면 완전히 종료하고 11분을 기다렸다가 다시 시작해야 합니다 - 콘솔에서 \u0026ldquo;Restart\u0026quot;를 클릭해도 변경 사항은 적용되지 않습니다.\n\u0026ldquo;Network: Firewalled\u0026rdquo; 상태 해결 방화벽 상태란 router가 직접적인 인바운드 연결을 수신할 수 없어 introducers(소개자 노드)에 의존해야 함을 의미합니다. router는 이 상태에서도 동작하지만, 성능이 크게 저하됩니다 그리고 네트워크에 대한 기여도는 최소 수준에 머뭅니다. 방화벽에 의해 차단되지 않은 상태를 달성하려면 올바른 포트 포워딩이 필요합니다.\nrouter는 포트를 무작위로 선택합니다(통신용 범위: 9000-31000). http://127.0.0.1:7657/confignet 에서 자신의 포트를 확인하세요 - \u0026ldquo;UDP Port\u0026quot;와 \u0026ldquo;TCP Port\u0026quot;를 찾으면 됩니다(일반적으로 같은 번호입니다). 최적의 성능을 위해서는 UDP와 TCP 둘 다 포트 포워딩을 해야 하지만, UDP만으로도 기본 기능은 동작합니다.\nUPnP 자동 포트 포워딩 활성화 (가장 간단한 방법):\nhttp://127.0.0.1:7657/confignet에 접속하세요 \u0026ldquo;Enable UPnP\u0026quot;를 선택하세요 변경 사항을 저장하고 router를 다시 시작하세요 5~10분 기다린 후 상태가 \u0026ldquo;Network: Firewalled\u0026quot;에서 \u0026ldquo;Network: OK\u0026quot;로 변경되었는지 확인하세요 UPnP는 router 지원(2010년 이후 제조된 대부분의 소비자용 router에서는 기본적으로 활성화됨)과 적절한 네트워크 구성을 필요로 합니다.\n수동 포트 포워딩 (UPnP가 실패할 때 필요):\nhttp://127.0.0.1:7657/confignet 에서 자신의 I2P 포트를 확인해 메모해 두세요 (예: 22648) 로컬 IP 주소를 확인하세요: ipconfig (Windows), ip addr (Linux), 시스템 환경설정 → 네트워크 (macOS) router의 관리자 인터페이스에 접속하세요 (일반적으로 192.168.1.1 또는 192.168.0.1) Port Forwarding으로 이동하세요 (Advanced, NAT, 또는 Virtual Servers 아래에 있을 수 있음) 다음 두 가지 규칙을 생성하세요: 외부 포트: [당신의 I2P 포트] → 내부 IP: [당신의 컴퓨터] → 내부 포트: [동일] → 프로토콜: UDP 외부 포트: [당신의 I2P 포트] → 내부 IP: [당신의 컴퓨터] → 내부 포트: [동일] → 프로토콜: TCP 구성을 저장하고 필요한 경우 router를 재시작하세요 포트 포워딩 검증은 설정을 마친 뒤 온라인 점검 도구로 수행하세요. 감지되지 않으면 방화벽 설정을 확인하세요 - 시스템 방화벽과 백신 방화벽 모두에서 I2P 포트를 허용해야 합니다.\nHidden mode 대안 포트 포워딩이 불가능한 제한적인 네트워크 환경에서 사용: http://127.0.0.1:7657/confignet에서 활성화 → \u0026ldquo;Hidden mode\u0026quot;를 체크하세요. router는 방화벽 뒤 상태를 유지하지만, SSU introducers(SSU에서 NAT 우회를 위한 소개자)를 전용으로 사용해 이 상태에 최적화합니다. 성능은 느려지지만 정상적으로 동작합니다.\nrouter가 \u0026ldquo;Starting\u0026rdquo; 또는 \u0026ldquo;Testing\u0026rdquo; 상태에서 멈춰 있음 초기 부트스트랩 과정에서 나타나는 이러한 일시적 상태들은 신규 설치의 경우 10-15분 또는 기존 routers의 경우 3-5분 내에 대개 해소됩니다. 너무 일찍 개입하면 오히려 문제를 악화시키는 경우가 많습니다.\n**\u0026ldquo;Network: Testing\u0026rdquo;**는 router가 다양한 연결 방식(직접, introducers(소개자 노드), 여러 프로토콜 버전)을 통해 도달 가능성을 점검하고 있음을 의미합니다. 이는 시작 후 처음 5-10분 동안 정상입니다. router는 최적 구성을 결정하기 위해 여러 시나리오를 테스트합니다.\n**\u0026ldquo;Rejecting tunnels: starting up\u0026rdquo;**은 router에 충분한 피어 정보가 없을 때 bootstrap(초기 설정) 중에 나타납니다. router는 네트워크에 충분히 통합될 때까지 중계 트래픽에 참여하지 않습니다. netDb에 50개 이상의 router가 채워지면 보통 10~20분 후 이 메시지는 사라집니다.\n클록 스큐는 도달성 테스트를 무력화합니다. I2P는 시스템 시간이 네트워크 시간과 ±60초 이내여야 합니다. 90초를 초과하는 차이가 있으면 연결이 자동으로 거부됩니다. 시스템 시계를 동기화하십시오:\n리눅스: sudo timedatectl set-ntp true \u0026amp;\u0026amp; sudo systemctl restart systemd-timesyncd\nWindows: 제어판 → 날짜 및 시간 → 인터넷 시간 → 지금 업데이트 → 자동 동기화 사용\nmacOS: 시스템 환경설정 → 날짜 및 시간 → \u0026ldquo;날짜와 시간을 자동으로 설정\u0026rdquo; 활성화\nclock skew(시스템 시간 오차)를 수정한 후, 제대로 통합되도록 I2P를 완전히 재시작하세요.\n대역폭 할당 부족은 성공적인 테스트를 막습니다. router가 테스트 tunnel을 구축하기 위해서는 충분한 용량이 필요합니다. http://127.0.0.1:7657/config에서 설정하세요:\n최소 동작 가능: 수신 96 KB/sec, 송신 64 KB/sec 권장 표준: 수신 256 KB/sec, 송신 128 KB/sec 최적 성능: 수신 512+ KB/sec, 송신 256+ KB/sec 공유 비율: 80% (router가 네트워크에 대역폭을 기여하도록 허용) 대역폭이 낮아도 작동할 수 있지만, 통합 시간은 분 단위에서 시간 단위로 늘어납니다.\n부적절한 종료 또는 디스크 오류로 인해 손상된 netDb가 발생하면 무한 테스트 루프가 발생합니다. 유효한 피어 데이터가 없으면 router는 테스트를 완료할 수 없습니다:\n# Stop I2P completely i2prouter stop # or systemctl stop i2p # Delete corrupted database (safe - will reseed automatically) rm -rf ~/.i2p/netDb/* # Restart and allow 10-15 minutes for reseed i2prouter start Windows: %APPDATA%\\I2P\\netDb\\ 또는 %LOCALAPPDATA%\\I2P\\netDb\\의 내용을 삭제하세요\nreseed(초기 피어 확보 절차)을 차단하는 방화벽은 초기 피어 획득을 방해합니다. bootstrap(초기화 단계) 중, I2P는 HTTPS reseed 서버에서 router 정보를 가져옵니다. 기업/ISP 방화벽이 이러한 연결을 차단할 수 있습니다. 제한적인 네트워크 환경 뒤에서 운영 중이라면 http://127.0.0.1:7657/configreseed 에서 reseed 프록시를 구성하십시오.\n느린 속도, 시간 초과, 및 tunnel 구축 실패 I2P의 설계는 다중 홉 암호화, 패킷 오버헤드, 경로의 예측 불가능성 때문에 본질적으로 클리어넷(일반 인터넷) 대비 3-10배 더 느린 속도를 초래합니다. tunnel 구축은 여러 router를 거치며, 각 router가 지연시간을 더합니다. 이를 이해하면 정상 동작을 문제로 잘못 진단하는 일을 막을 수 있습니다.\n일반적인 성능 기대치:\n.i2p 사이트 브라우징: 처음에는 페이지 로드에 10-30초, tunnel(익명 통신 경로) 설정 후 더 빨라짐 I2PSnark를 통한 토렌트: 시더 수와 네트워크 상태에 따라 토렌트당 10-100 KB/sec 대용량 파일 다운로드: 인내 필요 - 메가바이트 크기 파일은 몇 분, 기가바이트 크기는 몇 시간 걸릴 수 있음 첫 연결이 가장 느림: tunnel 구축에 30-90초 소요; 이후 연결은 기존 tunnel을 사용 Tunnel build success rate는 네트워크 건전성을 나타냅니다. http://127.0.0.1:7657/tunnels에서 확인하세요:\n60% 초과: 정상적이고 안정적인 동작 40-60%: 경계 상태, 대역폭 증가 또는 부하 감소를 고려 40% 미만: 문제가 있는 상태 - 대역폭 부족, 네트워크 문제, 또는 부적절한 피어 선택을 의미 대역폭 할당을 늘리는 것을 첫 번째 최적화로 삼으세요. 느린 성능의 대부분은 대역폭 부족에서 비롯됩니다. http://127.0.0.1:7657/config에서 한도를 점진적으로 높이고, http://127.0.0.1:7657/graphs에서 그래프를 모니터링하세요.\nDSL/케이블용 (1-10 Mbps 연결): - 수신: 400 KB/초 - 송신: 200 KB/초 - 공유: 80% - 메모리: 384 MB (wrapper.config 편집)\n고속(10-100+ Mbps 연결)용: - 수신: 1500 KB/sec - 송신: 1000 KB/sec - 공유 비율: 80-100% - 메모리: 512-1024 MB - 고려: http://127.0.0.1:7657/configadvanced 에서 참여용 tunnels(트래픽을 중계하는 경로)을 2000-5000으로 늘리기\ntunnel 구성을 최적화하여 성능을 향상하세요. http://127.0.0.1:7657/i2ptunnel에서 개별 tunnel 설정에 접속하여 각 tunnel을 편집하세요:\nTunnel 수량: 2에서 3-4로 늘리기(더 많은 경로 사용 가능) 백업 수량: 1-2로 설정(tunnel 실패 시 신속한 페일오버) Tunnel 길이: 기본 3홉은 좋은 균형을 제공함; 2로 줄이면 속도는 향상되지만 익명성은 낮아짐 **네이티브 암호화 라이브러리 (jbigi)**는 순수 Java 암호화보다 5~10배 더 나은 성능을 제공합니다. http://127.0.0.1:7657/logs 에서 로드되었는지 확인하세요 - \u0026ldquo;jbigi loaded successfully\u0026rdquo; 또는 \u0026ldquo;Using native CPUID implementation\u0026quot;을 찾으세요. 없다면:\nLinux: 일반적으로 자동으로 감지되어 ~/.i2p/jbigi-*.so에서 로드됩니다 Windows: I2P 설치 디렉터리에 jbigi.dll이 있는지 확인하세요 없으면: 빌드 도구를 설치하고 소스에서 컴파일하거나, 공식 저장소에서 미리 컴파일된 바이너리를 다운로드하세요\nrouter를 지속적으로 실행 상태로 유지하십시오. 재시작할 때마다 통합 상태가 초기화되어, tunnel 네트워크와 피어 관계를 다시 구축하는 데 30~60분이 필요합니다. 가동 시간이 길고 안정적인 router는 tunnel 구축 시 우선적으로 선택되어 성능에 긍정적인 피드백 루프가 형성됩니다.\n높은 CPU 및 메모리 사용량 과도한 리소스 사용은 일반적으로 불충분한 메모리 할당, 네이티브 암호 라이브러리 누락, 또는 **네트워크 참여에 대한 overcommitment(오버커밋)**을 나타냅니다. 적절히 구성된 routers는 활성 사용 중 CPU 10-30%를 사용하고, 할당된 힙의 80% 미만에서 메모리 사용량을 안정적으로 유지해야 합니다.\n메모리 문제는 다음과 같이 나타납니다: - 상단이 평평한 메모리 그래프(최대치에 고정됨) - 잦은 가비지 컬렉션(급격한 하강이 있는 톱니형 패턴) - 로그에 OutOfMemoryError 발생 - 부하 시 Router가 응답하지 않음 - 리소스 고갈로 인한 자동 종료\nJava 힙 메모리 할당량 늘리기 wrapper.config에서 (완전 종료가 필요함):\n# Linux: ~/.i2p/wrapper.config # Windows: %APPDATA%\\I2P\\wrapper.config # Find and modify: wrapper.java.maxmemory=512 # Recommendations by usage: # Light browsing only: 256 # Standard use (browsing + light torrenting): 512 # Heavy use (multiple applications, active torrenting): 768-1024 # Floodfill or very high bandwidth: 1024-2048 중요: wrapper.config을 수정한 후, 반드시 완전히 종료해야 합니다 (재시작이 아님), 정상 종료를 위해 11분 동안 기다린 다음, 새로 시작하십시오. Router 콘솔의 \u0026ldquo;Restart\u0026rdquo; 버튼은 wrapper 설정을 다시 로드하지 않습니다.\nCPU 최적화에는 네이티브 암호화 라이브러리가 필요합니다. 순수 Java BigInteger(임의 정밀도 정수) 연산은 네이티브 구현 대비 CPU를 1020배 더 사용합니다. 시작 시 http://127.0.0.1:7657/logs 에서 jbigi 상태를 확인하세요. jbigi가 없으면 tunnel 구축 및 암호화 작업 동안 CPU 사용률이 50100%까지 급등합니다.\n참여 tunnel 부하 줄이기 router가 과부하된 경우:\nhttp://127.0.0.1:7657/configadvanced 에 접속하세요 router.maxParticipatingTunnels=1000으로 설정하세요 (기본값 8000) http://127.0.0.1:7657/config 에서 공유 비율을 80%에서 50%로 낮추세요 floodfill 모드가 활성화되어 있다면 비활성화하세요: router.floodfillParticipant=false I2PSnark의 대역폭과 동시 토렌트 수를 제한하세요. 토렌트는 상당한 시스템 자원을 소모합니다. http://127.0.0.1:7657/i2psnark에서:\n동시에 활성화된 토렌트를 최대 3~5개로 제한하세요 \u0026ldquo;Up BW Limit\u0026rdquo; 및 \u0026ldquo;Down BW Limit\u0026quot;을 합리적인 값(각각 50-100 KB/초)으로 설정하세요 현재 필요하지 않을 때는 토렌트를 중지하세요 수십 개의 토렌트를 동시에 시딩하는 것을 피하세요 리소스 사용량을 모니터링하세요: http://127.0.0.1:7657/graphs 에 있는 내장 그래프를 사용하세요. 메모리 그래프는 headroom(여유 공간)이 보여야 하며, flat-top(상단이 평평한 모양)이면 안 됩니다. tunnel 구축 중 발생하는 CPU 급등은 정상이며; 지속적으로 높은 CPU는 구성 문제를 나타냅니다.\n자원이 매우 제한된 시스템 (Raspberry Pi, 구형 하드웨어)에서는 i2pd (C++ 구현체)를 대안으로 고려하세요. i2pd는 Java I2P의 350+ MB에 비해 ~130 MB RAM만 필요하고, 유사한 부하에서 CPU 사용률도 Java I2P의 70%에 비해 ~7% 수준입니다. 참고로 i2pd에는 내장 애플리케이션이 없어 외부 도구가 필요합니다.\nI2PSnark 토렌트 문제 I2PSnark가 I2P router 아키텍처와 통합되어 동작하려면, 토렌팅은 전적으로 router tunnel의 상태에 좌우된다는 점을 이해해야 한다. router가 10개 이상의 활성 피어와 정상 동작하는 tunnel을 확보해 네트워크에 충분히 연동될 때까지 토렌트는 시작되지 않는다.\n0%에서 멈춰 있는 토렌트는 일반적으로 다음을 의미합니다:\nRouter가 네트워크에 완전히 통합되지 않음: I2P 시작 후 토렌트 활동을 기대하기 전에 10~15분 기다리세요 DHT 비활성화됨: http://127.0.0.1:7657/i2psnark → Configuration → \u0026ldquo;Enable DHT\u0026quot;에 체크하여 활성화 (버전 0.9.2부터 기본적으로 활성화됨) 유효하지 않거나 죽은 트래커: I2P 토렌트는 I2P 전용 트래커가 필요합니다 - 클리어넷 트래커는 작동하지 않습니다 불충분한 tunnel 구성: I2PSnark Configuration → Tunnels 섹션에서 tunnels를 늘리세요 더 나은 성능을 위해 I2PSnark tunnels 구성하기:\n인바운드 tunnels: 3-5 (Java I2P의 기본값은 2, i2pd는 5) 아웃바운드 tunnels: 3-5 Tunnel 길이: 3홉 (속도를 위해 2로 줄이면 익명성은 낮아짐) Tunnel 개수: 3 (일관된 성능 제공) 필수 I2P 토렌트 트래커 포함: - tracker2.postman.i2p (기본, 가장 신뢰할 수 있음) - w7tpbzncbcocrqtwwm3nezhnnsw4ozadvi2hmvzdhrqzfxfum7wa.b32.i2p/a\n모든 clearnet(일반 인터넷, non-.i2p) 트래커를 제거하세요 - 이들은 아무런 가치도 제공하지 않고 시간 초과로 끝나는 연결 시도만 만들어냅니다.\n트래커와의 통신이 실패할 때 \u0026ldquo;Torrent not registered\u0026rdquo; 오류가 발생합니다. 토렌트를 마우스 오른쪽 버튼으로 클릭 → \u0026ldquo;Start\u0026quot;를 선택하면 announce(트래커에 상태를 알리는 요청)를 다시 수행하도록 강제합니다. 문제가 계속되면, I2P로 구성된 브라우저에서 http://tracker2.postman.i 2p 로 접속해 트래커에 접근 가능한지 확인하십시오. 죽은 트래커는 동작하는 대체 트래커로 교체해야 합니다.\n피어가 연결되지 않음 트래커가 정상이어도 다음을 시사합니다: - Router가 방화벽에 막혀 있음 (포트 포워딩을 하면 개선되지만 필수는 아님) - 대역폭이 부족함 (256+ KB/sec 이상으로 늘리기) - 스웜이 너무 작음 (일부 토렌트는 시더가 1-2명뿐; 인내 필요) - DHT(분산 해시 테이블) 비활성화됨 (트래커 없이 피어를 찾으려면 활성화)\nDHT(분산 해시 테이블)와 PEX(Peer Exchange, 피어 교환)를 활성화 I2PSnark 설정에서. DHT는 트래커에 의존하지 않고 피어를 찾을 수 있게 해줍니다. PEX는 연결된 피어로부터 피어를 발견하여 스웜 탐색을 가속합니다.\n다운로드된 파일 손상은 I2PSnark의 내장 무결성 검사 덕분에 드물게 발생합니다. 감지된 경우:\n토렌트를 마우스 오른쪽 클릭 → \u0026ldquo;Check\u0026quot;를 선택하면 모든 조각을 강제로 리해시합니다 손상된 토렌트 데이터 삭제(.torrent 파일은 유지) 마우스 오른쪽 클릭 → \u0026ldquo;Start\u0026quot;로 조각 검증과 함께 다시 다운로드 손상이 계속되면 디스크 오류를 검사: chkdsk (Windows), fsck (Linux) 감시 디렉터리가 작동하지 않음 문제는 올바른 구성이 필요합니다:\nI2PSnark 설정 → \u0026ldquo;Watch directory(감시 디렉터리)\u0026rdquo;: 절대 경로를 지정합니다 (예: /home/user/torrents/watch) I2P 프로세스에 읽기 권한이 있는지 확인합니다: chmod 755 /path/to/watch .torrent 파일을 watch directory에 놓으면 - I2PSnark가 자동으로 추가합니다 \u0026ldquo;Auto start(자동 시작)\u0026rdquo; 설정: 토렌트가 추가되면 즉시 시작할지 여부를 선택합니다 토렌트 사용을 위한 성능 최적화:\n동시에 활성 상태인 토렌트 수를 제한하세요: 일반 연결에서는 최대 3~5개 중요한 다운로드를 우선시하세요: 우선순위가 낮은 토렌트는 일시적으로 중지하세요 router 대역폭 할당을 늘리세요: 대역폭이 많을수록 토렌트 성능이 좋아집니다 인내심을 가지세요: I2P 토렌트는 clearnet(공개 인터넷) BitTorrent보다 본질적으로 더 느립니다 다운로드 후 시딩하세요: 네트워크는 상호성에 기반해 성장합니다 I2P를 통한 Git 구성 및 문제 해결 I2P를 통한 Git 작업은 SSH/HTTP 액세스를 위해 SOCKS 프록시 구성 또는 전용 I2P tunnels이 필요하다. Git의 설계는 저지연 연결을 전제로 하므로 I2P의 고지연 아키텍처에서는 어려움이 있다.\nGit에서 I2P SOCKS 프록시를 사용하도록 설정:\n~/.ssh/config를 편집하세요(없다면 생성하세요):\nHost *.i2p ProxyCommand nc -X 5 -x 127.0.0.1:4447 %h %p ServerAliveInterval 60 ServerAliveCountMax 3 Compression yes 이는 .i2p 호스트로의 모든 SSH 연결을 I2P의 SOCKS 프록시(포트 4447)를 통해 라우팅합니다. ServerAlive 설정(SSH의 서버 생존 확인 옵션)은 I2P의 지연 시간 동안 연결을 유지합니다.\nHTTP/HTTPS git 작업의 경우, git을 전역으로 설정하세요:\ngit config --global http.proxy socks5h://127.0.0.1:4447 git config --global https.proxy socks5h://127.0.0.1:4447 참고: socks5h 는 DNS 해석을 프록시를 통해 수행합니다 - .i2p 도메인에 필수적입니다.\nGit SSH용 전용 I2P tunnel 만들기 (SOCKS보다 더 신뢰할 수 있음):\nhttp://127.0.0.1:7657/i2ptunnel에 접속 \u0026ldquo;New client tunnel\u0026rdquo;(터널) → \u0026ldquo;Standard\u0026rdquo; 구성: Name: Git-SSH Type: Client Port: 2222 (Git 액세스를 위한 로컬 포트) Destination: [your-git-server].i2p:22 Auto start: Enabled Tunnel count: 3-4 (신뢰성을 위해 더 높게 설정) tunnel을 저장하고 시작 SSH가 tunnel을 사용하도록 설정: ssh -p 2222 git@127.0.0.1 I2P를 통해 발생하는 SSH 인증 오류는 일반적으로 다음과 같은 원인에서 비롯됩니다:\n키가 ssh-agent에 추가되지 않음: ssh-add ~/.ssh/id_rsa 잘못된 키 파일 권한: chmod 600 ~/.ssh/id_rsa Tunnel이 실행 중이 아님: http://127.0.0.1:7657/i2ptunnel 에서 초록색 상태로 표시되는지 확인 Git 서버에서 특정 키 유형을 요구함: RSA가 실패하면 ed25519 키를 생성 Git 작업 시간 초과는 I2P의 지연 특성과 관련이 있습니다:\nGit 타임아웃 늘리기: git config --global http.postBuffer 524288000 (500MB 버퍼) 저속 임계값 늘리기: git config --global http.lowSpeedLimit 1000 및 git config --global http.lowSpeedTime 600 (10분 동안 대기) 초기 체크아웃에 shallow clone(최신 커밋만 가져오는 얕은 복제) 사용: git clone --depth 1 [url] (최신 커밋만 가져와 더 빠름) 활동이 적은 시간대에 복제 수행: 네트워크 혼잡은 I2P 성능에 영향을 줍니다 느린 git clone/fetch 작업은 I2P의 아키텍처에 내재된 특성입니다. 100MB 리포지토리는 I2P에서는 30-60분이 걸릴 수 있는 반면, clearnet(일반 인터넷)에서는 몇 초에 불과합니다. 전략:\n얕은 클론을 사용하세요: --depth 1은 초기 데이터 전송량을 크게 줄입니다 점진적으로 가져오세요: 전체 클론 대신 특정 브랜치만 가져오세요: git fetch origin branch:branch I2P 위에서 rsync 사용을 고려하세요: 매우 큰 저장소의 경우 rsync가 더 나은 성능을 보일 수 있습니다 tunnel 수량을 늘리세요: tunnels의 수가 많을수록 지속적인 대용량 전송에서 더 나은 처리량을 제공합니다 \u0026ldquo;Connection refused\u0026rdquo; 오류는 tunnel의 잘못된 구성을 나타냅니다:\nI2P router가 실행 중인지 확인: http://127.0.0.1:7657에서 확인 http://127.0.0.1:7657/i2ptunnel에서 tunnel이 활성 상태이며 녹색인지 확인 tunnel 테스트: nc -zv 127.0.0.1 2222 (tunnel이 작동 중이면 연결되어야 함) 대상에 도달 가능한지 확인: 가능하다면 대상의 HTTP 인터페이스에 접속 특정 오류 확인을 위해 http://127.0.0.1:7657/logs에서 tunnel 로그 검토 I2P를 통한 Git 모범 사례:\n안정적인 Git 접속을 위해 I2P router(I2P 노드)를 지속적으로 실행하세요 비밀번호 인증 대신 SSH 키를 사용하세요(대화형 프롬프트가 줄어듭니다) 일시적인 SOCKS 연결보다 지속적인 tunnels(익명 통신 경로)를 구성하세요 더 나은 제어를 위해 직접 I2P git 서버를 운영하는 것을 고려하세요 협업자들을 위해 .i2p git 엔드포인트를 문서화해 두세요 eepsites에 접속하고 .i2p 도메인 이름을 해석하기 사용자가 .i2p 사이트에 접속하지 못하는 가장 흔한 이유는 잘못된 브라우저 프록시 설정입니다. I2P 사이트는 I2P 네트워크 내부에서만 존재하며 I2P의 HTTP 프록시를 통해 라우팅되어야 합니다.\n브라우저 프록시 설정을 정확히 구성하세요:\nFirefox (I2P에 권장됨):\n메뉴 → 설정 → 네트워크 설정 → 설정 버튼 \u0026ldquo;수동 프록시 구성\u0026rdquo; 선택 HTTP 프록시: 127.0.0.1 포트: 4444 SSL 프록시: 127.0.0.1 포트: 4444 SOCKS 프록시: 127.0.0.1 포트: 4447 (선택 사항, SOCKS 앱용) \u0026ldquo;SOCKS v5 사용 시 DNS 프록시\u0026rdquo; 체크 확인을 눌러 저장 중요한 Firefox about:config 설정:\nabout:config로 이동하여 다음을 변경하세요:\nmedia.peerconnection.ice.proxy_only = true (WebRTC IP 유출을 방지합니다) keyword.enabled = false (.i2p 주소가 검색 엔진으로 리디렉션되는 것을 방지합니다) network.proxy.socks_remote_dns = true (프록시를 통한 DNS) Chrome/Chromium 제한 사항:\nChrome은 애플리케이션별 설정이 아닌 시스템 전체 프록시 설정을 사용합니다. Windows에서: 설정 → \u0026ldquo;프록시\u0026rdquo; 검색 → \u0026ldquo;컴퓨터의 프록시 설정 열기\u0026rdquo; → HTTP: 127.0.0.1:4444 및 HTTPS: 127.0.0.1:4445를 구성합니다.\n더 나은 접근법: 선택적 .i2p 라우팅을 위해 FoxyProxy 또는 Proxy SwitchyOmega 확장 프로그램을 사용하세요.\n\u0026ldquo;Website Not Found In Address Book\u0026rdquo; 오류는 router에 .i2p 도메인의 암호화된 주소가 없음을 의미합니다. I2P는 중앙집중식 DNS 대신 로컬 주소록을 사용합니다. 해결 방법:\n방법 1: jump services(주소록에 사이트 주소를 자동으로 추가해 주는 서비스) 사용 (신규 사이트에 가장 쉬움):\nhttp://stats.i 2p 로 이동해 사이트를 검색하세요. addresshelper(주소 도우미) 링크를 클릭하세요: http://example.i2p/?i2paddresshelper=base64destination. 브라우저에 \u0026ldquo;주소록에 저장하시겠습니까?\u0026ldquo;가 표시되면 확인하여 추가하세요.\n방법 2: 주소록 구독 업데이트:\nhttp://127.0.0.1:7657/dns로 이동하세요 (SusiDNS) \u0026ldquo;Subscriptions\u0026rdquo; 탭을 클릭하세요 활성 구독을 확인하세요 (기본값: http://i2p-projekt.i 2p/hosts.txt) 권장 구독을 추가하세요: http://stats.i 2p/cgi-bin/newhosts.txt http://notbob.i 2p/hosts.txt http://reg.i 2p/export/hosts.txt \u0026ldquo;Update Now\u0026quot;를 클릭하여 구독을 즉시 강제로 업데이트하세요 처리를 위해 5-10분 기다리세요 방법 3: base32 주소 사용 (사이트가 온라인이면 항상 작동함):\n모든 .i2p 사이트에는 Base32 주소가 있습니다: 52개의 무작위 문자 뒤에 .b32.i2p가 붙습니다(예: ukeu3k5oycgaauneqgtnvselmt4yemvoilkln7jpvamvfx7dnkdq.b32.i2p). Base32 주소는 addressbook(주소록)을 우회하며, router가 직접 암호학적 조회를 수행합니다.\n일반적인 브라우저 설정 실수:\nHTTP 전용 사이트에서 HTTPS 시도: 대부분의 .i2p 사이트는 HTTP만 사용 - https://example.i2p를 시도하면 실패함 http:// 접두사 누락: 브라우저가 연결 대신 검색할 수 있음 - 항상 http://example.i2p를 사용 WebRTC(웹 실시간 통신) 활성화됨: 실제 IP 주소가 유출될 수 있음 - Firefox 설정 또는 확장 기능에서 비활성화 프록시되지 않은 DNS: 클리어넷(일반 공개 인터넷) DNS는 .i2p를 해석할 수 없음 - DNS 쿼리를 반드시 프록시해야 함 잘못된 프록시 포트: HTTP는 4444 (4445가 아님. 이는 클리어넷으로 나가는 HTTPS outproxy(아웃프록시: I2P에서 외부 인터넷으로 나가는 프록시)임) Router가 완전히 통합되지 않음 상태에서는 어떤 사이트에도 접속할 수 없습니다. 충분히 통합되었는지 확인하세요:\nhttp://127.0.0.1:7657 에서 \u0026ldquo;Network: OK\u0026rdquo; 또는 \u0026ldquo;Network: Firewalled\u0026quot;로 표시되는지 확인하세요(단, \u0026ldquo;Network: Testing\u0026quot;은 아님) 활성 피어는 최소 10개 이상(권장 50개 이상)이어야 합니다 \u0026ldquo;Rejecting tunnels: starting up\u0026rdquo; 메시지가 없어야 합니다 router 시작 후 .i2p에 접속을 기대하기 전에 10~15분을 충분히 기다리세요 IRC 및 이메일 클라이언트 구성은 유사한 프록시 패턴을 따릅니다:\nIRC: 클라이언트는 127.0.0.1:6668 (I2P의 IRC 프록시 tunnel)에 연결합니다. IRC 클라이언트의 프록시 설정을 비활성화하세요 - localhost:6668로의 연결은 이미 I2P를 통해 프록시됩니다.\n이메일(Postman): - SMTP: 127.0.0.1:7659 - POP3: 127.0.0.1:7660 - SSL/TLS 없음 (I2P tunnel이 암호화를 처리함) - postman.i2p 계정 등록 시 발급된 자격 증명\n이러한 모든 tunnels가 http://127.0.0.1:7657/i2ptunnel에서 \u0026ldquo;running\u0026rdquo;(녹색) 상태로 표시되어야 합니다.\n설치 실패 및 패키지 문제 패키지 기반 설치(Debian, Ubuntu, Arch)는 저장소 변경, GPG 키 만료, 또는 의존성 충돌 때문에 때때로 실패할 수 있습니다. 최근 버전에서는 공식 저장소가 deb.i2p2.de/deb.i2p2.no(지원 종료)에서 deb.i2p.net으로 변경되었습니다.\nDebian/Ubuntu 저장소를 최신 상태로 업데이트:\n# Remove old repository entries sudo rm /etc/apt/sources.list.d/i2p.list # Add current repository echo \u0026#34;deb [signed-by=/usr/share/keyrings/i2p-archive-keyring.gpg] https://deb.i2p.net/ $(lsb_release -sc) main\u0026#34; | sudo tee /etc/apt/sources.list.d/i2p.list # Download and install current signing key curl -o i2p-archive-keyring.gpg https://geti2p.net/_static/i2p-archive-keyring.gpg sudo cp i2p-archive-keyring.gpg /usr/share/keyrings/ # Update and install sudo apt update sudo apt install i2p i2p-keyring GPG 서명 검증 실패는 저장소 키가 만료되거나 변경될 때 발생합니다:\n# Error: \u0026#34;The following signatures were invalid\u0026#34; # Solution: Install current keyring package sudo apt install i2p-keyring # Manual key import if package unavailable wget https://geti2p.net/_static/i2p-debian-repo.key.asc sudo apt-key add i2p-debian-repo.key.asc 패키지 설치 후 서비스가 시작되지 않음의 가장 흔한 원인은 Debian/Ubuntu의 AppArmor 프로필 문제입니다:\n# Check service status sudo systemctl status i2p.service # Common error: \u0026#34;Failed at step APPARMOR spawning\u0026#34; # Solution: Reconfigure without AppArmor sudo dpkg-reconfigure -plow i2p # Select \u0026#34;No\u0026#34; for AppArmor when prompted # Alternative: Set profile to complain mode sudo aa-complain /usr/sbin/wrapper # Check logs for specific errors sudo journalctl -xe -u i2p.service 권한 문제 패키지로 설치된 I2P에서:\n# Fix ownership (package install uses \u0026#39;i2psvc\u0026#39; user) sudo chown -R i2psvc:i2psvc /var/lib/i2p /var/log/i2p /run/i2p sudo chmod 750 /var/log/i2p /var/lib/i2p # Set file descriptor limits (add to /etc/security/limits.conf) i2psvc soft nofile 4096 i2psvc hard nofile 8192 Java 호환성 문제:\nI2P 2.10.0은 최소 Java 8을 요구합니다. 구형 시스템에는 Java 7 또는 그 이전 버전이 설치되어 있을 수 있습니다:\n# Check Java version java -version # Install appropriate Java (Debian/Ubuntu) sudo apt install openjdk-11-jre-headless # Set default Java if multiple versions installed sudo update-alternatives --config java Wrapper 구성 오류로 인해 서비스가 시작되지 않습니다:\nWrapper.config 위치는 설치 방법에 따라 다릅니다:\n사용자 설치: ~/.i2p/wrapper.config 패키지 설치: /etc/i2p/wrapper.config 또는 /var/lib/i2p/wrapper.config 일반적인 wrapper.config 문제:\n경로가 잘못됨: wrapper.java.command는 유효한 Java 설치를 가리켜야 합니다 메모리 부족: wrapper.java.maxmemory가 너무 낮게 설정됨(512 이상으로 늘리세요) 잘못된 pidfile(프로세스 ID를 저장하는 파일) 위치: wrapper.pidfile은 쓰기 가능한 위치여야 합니다 wrapper 바이너리 누락: 일부 플랫폼에는 미리 컴파일된 wrapper가 없음(대신 runplain.sh 사용) 업데이트 실패 및 손상된 업데이트:\n네트워크 중단으로 인해 다운로드 도중 router 콘솔 업데이트가 간헐적으로 실패할 수 있습니다. 수동 업데이트 절차:\nhttps://geti2p.net/en/download 에서 i2pupdate_X.X.X.zip을 다운로드합니다 SHA256 체크섬이 공개된 해시와 일치하는지 확인합니다 I2P 설치 디렉터리에 i2pupdate.zip으로 복사합니다 router를 다시 시작합니다 - 업데이트를 자동으로 감지하고 압축을 해제합니다 업데이트 설치가 완료될 때까지 5-10분 기다립니다 http://127.0.0.1:7657에서 새 버전을 확인합니다 매우 오래된 버전에서의 마이그레이션 (pre-0.9.47)을 현재 버전으로 수행할 때는, 호환되지 않는 서명 키나 제거된 기능 때문에 실패할 수 있습니다. 단계적 업데이트가 필요합니다:\n0.9.9보다 오래된 버전: 현재 서명을 검증할 수 없음 - 수동 업데이트 필요 Java 6/7 사용 버전: I2P를 2.x로 업데이트하기 전에 Java를 업그레이드해야 함 주요 버전 차이가 큰 경우: 먼저 중간 버전으로 업데이트 (권장 경유점: 0.9.47) 인스톨러와 패키지 중 언제 사용할지:\n패키지(apt/yum): 서버, 자동 보안 업데이트, 시스템 통합, systemd 관리에 가장 적합 설치 프로그램(.jar): 사용자 수준 설치, Windows, macOS, 맞춤형 설치, 최신 버전 사용에 가장 적합 설정 파일 손상 및 복구 I2P의 설정 지속성은 여러 핵심 파일에 의존합니다. 손상은 보통 부적절한 종료, 디스크 오류, 또는 수동 편집 실수로 인해 발생합니다. 파일의 용도를 이해하면 전체 재설치 대신 정밀 복구가 가능합니다.\n중요 파일과 그 용도:\nrouter.keys (516+ 바이트): router의 암호학적 ID - 이 파일을 잃으면 새 ID가 생성됨 router.info (자동 생성): 공개된 router 정보 - 삭제해도 안전하며, 다시 생성됨 router.config (텍스트): 주요 구성 - 대역폭, 네트워크 설정, 기본 설정 i2ptunnel.config (텍스트): tunnel 정의 - 클라이언트/서버 tunnel, 키, 목적지 netDb/ (디렉터리): 피어 데이터베이스 - 네트워크 참여자를 위한 router 정보 peerProfiles/ (디렉터리): 피어의 성능 통계 - tunnel 선택에 영향을 줌 keyData/ (디렉터리): Destination(목적지) 키(eepsites(익명 웹사이트) 및 서비스용) - 분실하면 주소가 변경됨 addressbook/ (디렉터리): 로컬 .i2p 호스트명 매핑 전체 백업 절차 변경 전에:\n# Stop I2P first i2prouter stop # or: systemctl stop i2p # Backup directory BACKUP_DIR=~/i2p-backup-$(date +%Y%m%d-%H%M) mkdir -p $BACKUP_DIR # Copy critical files cp -r ~/.i2p/router.keys $BACKUP_DIR/ cp -r ~/.i2p/*.config $BACKUP_DIR/ cp -r ~/.i2p/keyData $BACKUP_DIR/ cp -r ~/.i2p/addressbook $BACKUP_DIR/ cp -r ~/.i2p/eepsite $BACKUP_DIR/ # if hosting sites # Optional but recommended tar -czf $BACKUP_DIR.tar.gz $BACKUP_DIR Router.config 손상 징후:\n로그에 구문 분석 오류가 있어 router가 시작되지 않음 재시작 후 설정이 유지되지 않음 예기치 않은 기본값이 나타남 파일을 볼 때 글자가 깨져 보임 손상된 router.config 복구:\n기존 파일 백업: cp router.config router.config.broken 파일 인코딩 확인: BOM 없는 UTF-8이어야 함 구문 확인: 키는 구분자로 =를 사용함(: 아님), 키 끝에 공백 없어야 함, #는 주석에만 사용 흔한 손상: 값에 ASCII가 아닌 문자가 포함, 줄바꿈 방식 문제(CRLF vs LF) 수정 불가한 경우: router.config를 삭제 - router가 기본 router.config를 생성하며 식별자는 유지됨 보존해야 하는 필수 router.config 설정:\ni2np.bandwidth.inboundKBytesPerSecond=512 i2np.bandwidth.outboundKBytesPerSecond=256 router.updatePolicy=notify routerconsole.lang=en router.hiddenMode=false 손실되었거나 유효하지 않은 router.keys 는 새로운 router identity(라우터 신원)를 생성합니다. 다음의 경우를 제외하면 허용됩니다:\nfloodfill 운영 중 (floodfill 상태 상실) 공개된 주소로 eepsites 호스팅 (연속성 상실) 네트워크 내에서 확립된 평판 백업이 없으면 복구할 수 없습니다 - 새로 생성: router.keys 삭제, I2P 재시작, 새 식별자 생성.\n중요한 구분: router.keys (신원) vs keyData/* (서비스). router.keys를 잃으면 router 신원이 변경됩니다. keyData/mysite-keys.dat을 잃으면 eepsite의 .i2p 주소가 변경됩니다 - 주소가 공개되어 있다면 치명적입니다.\neepsite/서비스 키를 별도로 백업하세요:\n# Identify your service keys ls -la ~/.i2p/keyData/ # Backup with descriptive names cp ~/.i2p/keyData/myservice-keys.dat ~/backups/myservice-keys-$(date +%Y%m%d).dat # Store securely (encrypted if sensitive) gpg -c ~/backups/myservice-keys-*.dat NetDb 및 peerProfiles(피어 프로파일) 손상:\n증상: 활성 피어 0개, tunnel(익명 트래픽 경로)을 구축할 수 없음, 로그에 \u0026ldquo;Database corruption detected\u0026quot;가 표시됨\n안전한 수정(모두 자동으로 reseed(재시드)/rebuild(재구성)됩니다):\ni2prouter stop rm -rf ~/.i2p/netDb/* rm -rf ~/.i2p/peerProfiles/* i2prouter start # Wait 10-15 minutes for reseed and integration 이 디렉터리에는 캐시된 네트워크 정보만 들어 있습니다 - 삭제하면 새로 부트스트랩을 강제하지만 중요한 데이터는 손실되지 않습니다.\n예방 전략:\n항상 정상 종료: i2prouter stop을 사용하거나 router 콘솔의 \u0026ldquo;Shutdown\u0026rdquo; 버튼 사용 - 절대 강제 종료하지 말 것 자동 백업: cron 작업으로 ~/.i2p를 매주 별도 디스크에 백업 디스크 상태 모니터링: 주기적으로 SMART 상태 확인 - 고장 나는 디스크는 데이터를 손상시킴 충분한 디스크 공간: 1GB 이상의 여유 공간을 유지 - 디스크가 가득 차면 손상 발생 UPS(무정전 전원장치) 권장: 쓰기 중 전원 장애는 파일을 손상시킴 중요 구성 파일 버전 관리: router.config, i2ptunnel.config를 Git 저장소로 관리하면 롤백 가능 파일 권한은 중요합니다:\n# Correct permissions (user install) chmod 600 ~/.i2p/router.keys chmod 600 ~/.i2p/*.config chmod 700 ~/.i2p/keyData chmod 755 ~/.i2p # Never run as root - creates permission problems 일반적인 오류 메시지 해설 I2P의 로그 기능은 문제를 정확히 특정할 수 있는 구체적인 오류 메시지를 제공합니다. 이러한 메시지를 이해하면 문제 해결 속도가 빨라집니다.\n**\u0026ldquo;No tunnels available\u0026rdquo;**는 router가 동작에 필요한 충분한 tunnels을 아직 구축하지 못했을 때 표시됩니다. 이는 시작 후 처음 5-10분 동안에는 정상입니다. 15분을 넘어도 지속된다면:\nhttp://127.0.0.1:7657에서 활성 피어가 10개 초과인지 확인 대역폭 할당이 충분한지 확인 (최소 128 KB/sec 이상) http://127.0.0.1:7657/tunnels에서 tunnel 성공률을 확인 (40%를 초과해야 함) 로그에서 tunnel 구축 거부 사유를 확인 \u0026ldquo;Clock skew detected\u0026rdquo; 또는 **\u0026ldquo;NTCP2 disconnect code 7\u0026rdquo;**는 시스템 시간이 네트워크 합의 시간과 90초 이상 차이가 있음을 나타냅니다. I2P는 ±60초 정확도를 요구합니다. 시간 동기화가 어긋난 routers와의 연결은 자동으로 거부됩니다.\n즉시 수정:\n# Linux sudo timedatectl set-ntp true sudo systemctl restart systemd-timesyncd date # Verify correct time # Windows # Control Panel → Date and Time → Internet Time → Update now # Verify after sync http://127.0.0.1:7657/logs # Should no longer show clock skew warnings \u0026ldquo;Build timeout\u0026rdquo; 또는 **\u0026ldquo;Tunnel build timeout exceeded\u0026rdquo;**는 peer chain(피어 체인)을 통한 tunnel 구축이 타임아웃 시간 제한(일반적으로 60초) 내에 완료되지 않았음을 의미합니다. 원인:\n느린 피어: Router가 tunnel에 대해 응답하지 않는 참여자를 선택함 네트워크 혼잡: I2P 네트워크에 높은 부하가 걸림 대역폭 부족: 사용자의 대역폭 제한 때문에 제때 tunnel을 구축하지 못함 과부하된 router: 참여하는 tunnel이 너무 많아 리소스를 소모함 해결 방법: 대역폭을 늘리고, 참여 중인 tunnels 수를 줄이며 (router.maxParticipatingTunnels는 http://127.0.0.1:7657/configadvanced에서), 더 나은 피어 선택을 위해 포트 포워딩을 활성화하세요.\n\u0026ldquo;Router is shutting down\u0026rdquo; 또는 **\u0026ldquo;Graceful shutdown in progress\u0026rdquo;**는 정상 종료 또는 충돌 복구 중에 표시됩니다. 정상 종료 절차는 router가 tunnel을 닫고 피어들에게 알리며 상태를 영구적으로 저장하기 때문에 최대 10분까지 걸릴 수 있습니다.\n종료 상태에서 11분을 넘겨 멈춰 있으면 강제로 종료하십시오:\n# Linux kill -9 $(pgrep -f i2p) # Windows taskkill /F /IM javaw.exe \u0026ldquo;java.lang.OutOfMemoryError: Java heap space\u0026rdquo; 는 힙 메모리 고갈을 나타냅니다. 즉각적인 해결책:\nwrapper.config을 편집하세요: wrapper.java.maxmemory=512 (또는 더 크게) 완전 종료가 필요합니다 - 재시작만으로는 변경 사항이 적용되지 않습니다 완전 종료될 때까지 11분 기다리세요 router를 새로 시작하세요 http://127.0.0.1:7657/graphs 에서 메모리 할당을 확인하세요 - 여유 공간이 보여야 합니다 관련 메모리 오류:\n\u0026ldquo;GC overhead limit exceeded\u0026rdquo;: 가비지 컬렉션에 너무 많은 시간이 소모됨 - 힙 크기를 늘리세요 \u0026ldquo;Metaspace(Java 클래스 메타데이터 공간)\u0026rdquo;: Java 클래스 메타데이터 공간이 고갈됨 - wrapper.java.additional.X=-XX:MaxMetaspaceSize=256M를 추가하세요 Windows 전용: Kaspersky Antivirus는 wrapper.config 설정과 관계없이 Java 힙을 512MB로 제한합니다 - Kaspersky Antivirus를 제거하거나 I2P를 검사 제외 목록에 추가하세요.\n애플리케이션이 router에 연결을 시도할 때 \u0026ldquo;Connection timeout\u0026rdquo; 또는 \u0026ldquo;I2CP Error - port 7654\u0026rdquo;:\nrouter가 실행 중인지 확인: http://127.0.0.1:7657 에 접속 시 응답해야 합니다 I2CP 포트 확인: netstat -an | grep 7654 에서 LISTENING이 표시되어야 합니다 localhost 방화벽이 허용하도록 설정: sudo ufw allow from 127.0.0.1 애플리케이션이 올바른 포트를 사용하는지 확인 (I2CP=7654, SAM=7656) reseed(네트워크 부트스트랩 과정) 중 \u0026ldquo;Certificate validation failed\u0026rdquo; 또는 \u0026ldquo;RouterInfo corrupt\u0026rdquo;:\n근본 원인: 시계 오차 (먼저 수정), 손상된 netDb, 유효하지 않은 reseed certificates(리시드 인증서)\n# After fixing clock: i2prouter stop rm -rf ~/.i2p/netDb/* # Delete corrupted database i2prouter start # Auto-reseeds with fresh data **\u0026ldquo;Database corruption detected\u0026rdquo;**는 netDb 또는 peerProfiles에서 디스크 수준의 데이터 손상이 발생했음을 나타냅니다:\n# Safe fix - all will rebuild i2prouter stop rm -rf ~/.i2p/netDb/* ~/.i2p/peerProfiles/* i2prouter start SMART(S.M.A.R.T., 자가 모니터링/분석/보고 기술) 도구로 디스크 상태를 점검하세요 - 반복적인 손상은 저장장치의 고장 징후일 수 있습니다.\n플랫폼별 도전 과제 운영 체제가 다르면 권한, 보안 정책, 시스템 통합과 관련해 I2P 배포에서 고유한 과제가 발생한다.\n리눅스 권한 및 서비스 문제 패키지로 설치된 I2P는 시스템 사용자 i2psvc (Debian/Ubuntu) 또는 i2p (기타 배포판)로 실행되며, 특정 권한이 필요합니다:\n# Fix package install permissions sudo chown -R i2psvc:i2psvc /var/lib/i2p /var/log/i2p /run/i2p sudo chmod 750 /var/log/i2p /var/lib/i2p sudo chmod 644 /var/lib/i2p/*.config # User install permissions (should be your user) chown -R $USER:$USER ~/.i2p chmod 700 ~/.i2p chmod 600 ~/.i2p/router.keys ~/.i2p/*.config 파일 디스크립터 제한은 router가 처리할 수 있는 연결 수용 능력에 영향을 줍니다. 기본 제한(1024)은 고대역폭 router에는 불충분합니다:\n# Check current limits ulimit -n # Temporary increase ulimit -n 4096 # Permanent fix: Edit /etc/security/limits.conf i2psvc soft nofile 4096 i2psvc hard nofile 8192 # Systemd override sudo mkdir -p /etc/systemd/system/i2p.service.d/ sudo nano /etc/systemd/system/i2p.service.d/override.conf # Add: [Service] LimitNOFILE=8192 sudo systemctl daemon-reload sudo systemctl restart i2p Debian/Ubuntu에서 흔한 AppArmor 충돌로 인해 서비스가 시작되지 않습니다:\n# Error: \u0026#34;Failed at step APPARMOR spawning /usr/sbin/wrapper\u0026#34; # Cause: AppArmor profile missing or misconfigured # Solution 1: Disable AppArmor for I2P sudo aa-complain /usr/sbin/wrapper # Solution 2: Reconfigure package without AppArmor sudo dpkg-reconfigure -plow i2p # Select \u0026#34;No\u0026#34; when asked about AppArmor # Solution 3: LXC/Proxmox containers - disable AppArmor in container config lxc.apparmor.profile: unconfined SELinux 관련 문제 RHEL/CentOS/Fedora에서:\n# Temporary: Set permissive mode sudo setenforce 0 # Permanent: Generate custom policy sudo ausearch -c \u0026#39;java\u0026#39; --raw | audit2allow -M i2p_policy sudo semodule -i i2p_policy.pp # Or disable SELinux for I2P process (less secure) sudo semanage permissive -a i2p_t SystemD(리눅스 초기화 시스템) 서비스 문제 해결:\n# Detailed service status sudo systemctl status i2p.service -l # Full logs sudo journalctl -xe -u i2p.service # Follow logs live sudo journalctl -f -u i2p.service # Restart with logging sudo systemctl restart i2p.service \u0026amp;\u0026amp; sudo journalctl -f -u i2p.service Windows 방화벽 및 안티바이러스의 간섭 Windows Defender와 타사 백신 제품은 네트워크 동작 패턴 때문에 I2P를 자주 의심 대상으로 표시합니다. 적절한 설정을 통해 보안을 유지하면서 불필요한 차단을 예방할 수 있습니다.\nWindows Defender 방화벽 구성:\n# Run PowerShell as Administrator # Find Java path (adjust for your Java installation) $javaPath = \u0026#34;C:\\Program Files\\Eclipse Adoptium\\jdk-11.0.16.101-hotspot\\bin\\javaw.exe\u0026#34; # Create inbound rules New-NetFirewallRule -DisplayName \u0026#34;I2P Java\u0026#34; -Direction Inbound -Program $javaPath -Action Allow New-NetFirewallRule -DisplayName \u0026#34;I2P UDP\u0026#34; -Direction Inbound -Protocol UDP -LocalPort 22648 -Action Allow New-NetFirewallRule -DisplayName \u0026#34;I2P TCP\u0026#34; -Direction Inbound -Protocol TCP -LocalPort 22648 -Action Allow # Add exclusions to Windows Defender Add-MpPreference -ExclusionPath \u0026#34;C:\\Program Files\\i2p\u0026#34; Add-MpPreference -ExclusionPath \u0026#34;$env:APPDATA\\I2P\u0026#34; Add-MpPreference -ExclusionPath \u0026#34;$env:LOCALAPPDATA\\I2P\u0026#34; Add-MpPreference -ExclusionProcess \u0026#34;javaw.exe\u0026#34; 포트 22648을 http://127.0.0.1:7657/confignet에서 확인한 실제 I2P 포트로 바꾸세요.\nKaspersky Antivirus 특정 문제: Kaspersky의 \u0026ldquo;Application Control\u0026quot;은 wrapper.config 설정과 무관하게 Java 힙을 512MB로 제한합니다. 이는 대역폭이 높은 routers에서 OutOfMemoryError(메모리 부족 오류)를 유발합니다.\n해결 방법: 1. Kaspersky의 제외 목록에 I2P를 추가: 설정 → 추가 → 위협 및 제외 → 제외 관리 2. 또는 Kaspersky를 제거(I2P 사용을 위해 권장됨)\n타사 안티바이러스 일반 지침:\nI2P 설치 디렉터리를 예외 목록에 추가 %APPDATA%\\I2P 및 %LOCALAPPDATA%\\I2P를 예외 목록에 추가 행위 기반 분석에서 javaw.exe를 제외 I2P 프로토콜을 방해할 수 있는 \u0026ldquo;Network Attack Protection\u0026rdquo;(네트워크 공격 방지) 기능을 비활성화 macOS Gatekeeper가 설치를 차단함 macOS Gatekeeper(보안 기능)는 서명되지 않은 애플리케이션의 실행을 차단합니다. I2P 설치 프로그램은 Apple Developer ID(애플의 개발자 인증 체계)로 서명되어 있지 않아 보안 경고가 표시됩니다.\nI2P 설치 프로그램용 Gatekeeper(macOS 보안 기능) 우회:\n# Method 1: Remove quarantine attribute xattr -d com.apple.quarantine ~/Downloads/i2pinstall_*.jar java -jar ~/Downloads/i2pinstall_*.jar # Method 2: Use System Settings (macOS 13+) # Try to open installer → macOS blocks it # System Settings → Privacy \u0026amp; Security → scroll down # Click \u0026#34;Open Anyway\u0026#34; next to I2P warning # Confirm in dialog # Method 3: Control-click installer # Control-click (right-click) i2pinstall_*.jar # Select \u0026#34;Open\u0026#34; from menu → \u0026#34;Open\u0026#34; again in dialog # Bypasses Gatekeeper for this specific file 설치 후 실행 시에도 여전히 경고가 표시될 수 있습니다:\n# If I2P won\u0026#39;t start due to Gatekeeper: xattr -dr com.apple.quarantine ~/i2p/ Gatekeeper를 절대 영구적으로 비활성화하지 마세요 - 다른 애플리케이션에 보안 위험이 됩니다. 파일별 우회만 사용하세요.\nmacOS 방화벽 설정:\n시스템 환경설정 → 보안 및 개인 정보 보호 → 방화벽 → 방화벽 옵션 \u0026ldquo;+\u0026rdquo; 버튼을 클릭하여 앱을 추가합니다 Java 설치 위치로 이동합니다 (예: /Library/Java/JavaVirtualMachines/jdk-11.jdk/Contents/Home/bin/java) 추가한 뒤 \u0026ldquo;들어오는 연결 허용\u0026quot;으로 설정합니다 Android I2P 애플리케이션 문제 Android 버전 제약과 리소스 제한으로 인해 고유한 도전 과제가 발생합니다.\n최소 요구 사항: - 현재 버전에는 Android 5.0+ (API level 21+) 필요 - 최소 512MB RAM, 1GB+ 권장 - 앱 및 router 데이터용 100MB 저장 공간 - I2P에 대해 백그라운드 앱 제한 비활성화\n앱이 실행 즉시 강제 종료됩니다:\nAndroid 버전 확인: 설정 → 휴대전화 정보 → Android 버전 (5.0 이상이어야 함) 모든 I2P 버전 제거: 한 종류만 설치하세요: net.i2p.android (Google Play) net.i2p.android.router (F-Droid)\n여러 개를 동시에 설치하면 충돌합니다 앱 데이터 삭제: 설정 → 앱 → I2P → 저장공간 → 데이터 삭제 깨끗한 상태에서 재설치 배터리 최적화로 인해 router가 종료됨:\nAndroid는 배터리를 절약하기 위해 백그라운드 앱을 공격적으로 종료합니다. I2P는 배터리 최적화에서 제외해야 합니다:\n설정 → 배터리 → 배터리 최적화 (또는 앱 배터리 사용량) I2P 찾기 → 최적화 안 함 (또는 백그라운드 활동 허용) 설정 → 앱 → I2P → 배터리 → 백그라운드 활동 허용 + 제한 해제 모바일에서의 연결 문제:\nBootstrap(초기 설정 단계)에는 WiFi가 필요합니다: 초기 reseed(초기 피어 목록 동기화)에서는 상당한 데이터를 다운로드합니다 - 셀룰러가 아니라 WiFi를 사용하세요 네트워크 변경: I2P는 네트워크 전환을 매끄럽게 처리하지 못합니다 - WiFi/셀룰러 전환 후 앱을 재시작하세요 모바일용 대역폭: 셀룰러 데이터 소진을 피하려면 64-128 KB/sec로 보수적으로 설정하세요 모바일 성능 최적화:\nI2P 앱 → 메뉴 → 설정 → 대역폭 적절한 제한값 설정: 셀룰러 사용 시 수신 64 KB/sec, 송신 32 KB/sec participating tunnels 수 줄이기: 설정 → 고급 → Max participating tunnels: 100-200 배터리 절약을 위해 \u0026ldquo;Stop I2P when screen off\u0026rdquo; 활성화 안드로이드에서 토렌트 사용:\n동시에 진행되는 토렌트를 최대 2~3개로 제한 DHT(분산 해시 테이블) 동작을 덜 공격적으로 설정 토렌트에만 WiFi 사용 모바일 하드웨어에서는 더 느린 속도를 감수 Reseed(재시드) 및 bootstrap(부트스트랩) 문제 새로 I2P를 설치하면 네트워크에 참여하기 위해 공개 HTTPS 서버에서 초기 피어 정보를 가져오는 reseeding(초기 피어 정보 가져오기)이 필요합니다. reseeding 문제가 발생하면 사용자들은 피어가 0개이고 네트워크에 접속할 수 없는 상태에 갇히게 됩니다.\n**신규 설치 직후 \u0026ldquo;No active peers\u0026rdquo;**는 일반적으로 reseed(초기 피어 부트스트랩) 실패를 나타냅니다. 증상:\n알려진 피어: 0이거나 5 미만으로 유지됨 \u0026ldquo;Network: Testing\u0026rdquo; 상태가 15분을 넘어 지속됨 로그에 \u0026ldquo;Reseed failed\u0026rdquo; 또는 리시드 서버에 대한 연결 오류가 표시됨 reseed(리시드: 초기 피어 정보 다시 받기)가 실패하는 이유:\nHTTPS 차단 방화벽: 기업/ISP 방화벽이 reseed server(초기 부트스트랩 서버) 연결을 차단함(포트 443) SSL 인증서 오류: 시스템에 최신 루트 인증서가 없음 프록시 필요: 네트워크가 외부 연결에 HTTP/SOCKS 프록시를 요구함 시계 오차: 시스템 시간이 잘못되면 SSL 인증서 검증이 실패함 지리적 검열: 일부 국가/ISP가 알려진 reseed server를 차단함 수동 reseed(네트워크 초기 피어 목록 다시 가져오기) 강제 실행:\nhttp://127.0.0.1:7657/configreseed 에 접속하세요 \u0026ldquo;Save changes and reseed now\u0026quot;를 클릭하세요 (Reseed: 초기 연결을 위해 피어 정보를 받아오는 과정) http://127.0.0.1:7657/logs 에서 \u0026ldquo;Reseed got XX router infos\u0026quot;가 표시되는지 모니터링하세요 처리가 완료될 때까지 5~10분 기다리세요 http://127.0.0.1:7657 를 확인하세요 - Known peers가 50+로 증가해야 합니다 reseed proxy(네트워크 초기 부트스트랩용 프록시) 구성 제한된 네트워크 환경용:\nhttp://127.0.0.1:7657/configreseed → 프록시 구성:\nHTTP 프록시: [proxy-server]:[port] 또는 SOCKS5: [socks-server]:[port] \u0026ldquo;Use proxy for reseed only\u0026rdquo; 사용하도록 설정 필요한 경우 인증 정보 저장하고 reseed(초기 부트스트랩용 피어 정보 다운로드)를 강제로 실행 대안: reseed(초기 부트스트랩)용 Tor 프록시:\nTor Browser 또는 Tor 데몬이 실행 중인 경우:\n프록시 유형: SOCKS5 호스트: 127.0.0.1 포트: 9050 (기본 Tor SOCKS 포트) 활성화 및 reseed(네트워크 부트스트랩) su3 파일을 통한 수동 reseed(네트워크 초기 부트스트랩) (최후의 수단):\n자동화된 reseed(리시드: 네트워크 부트스트랩을 위한 초기 피어 정보 획득)가 모두 실패하면, reseed 파일을 별도 경로로 확보하십시오:\n제한 없는 연결 상태에서 신뢰할 수 있는 출처로부터 i2pseeds.su3를 다운로드 (https://reseed.i2p.rocks/i2pseeds.su3 , https://reseed-fr.i2pd.xyz/i2pseeds.su3 ) I2P를 완전히 중지 i2pseeds.su3를 ~/.i2p/ 디렉터리로 복사 I2P를 시작 - 파일을 자동으로 추출하고 처리함 처리 후 i2pseeds.su3 삭제 http://127.0.0.1:7657에서 피어 수가 증가했는지 확인 reseed(리시드) 중 SSL 인증서 오류:\nError: \u0026#34;Reseed: Certificate verification failed\u0026#34; Cause: System root certificates outdated or missing 해결책:\n# Linux - update certificates sudo apt install ca-certificates sudo update-ca-certificates # Windows - install KB updates for root certificate trust # Or install .NET Framework (includes certificate updates) # macOS - update system # Software Update includes certificate trust updates 알려진 피어가 0인 상태로 30분 넘게 멈춰 있음:\nreseed(초기 부트스트랩을 위한 netDb 시드 다운로드 과정)이 완전히 실패했음을 나타냅니다. 문제 해결 순서:\n시스템 시간이 정확한지 확인 (가장 흔한 문제 - 가장 먼저 해결) HTTPS 연결 테스트: 브라우저에서 https://reseed.i2p.rocks 에 접속해 보세요 - 실패하면 네트워크 문제 I2P 로그 확인 http://127.0.0.1:7657/logs 에서 reseed(네트워크 초기 부트스트랩) 관련 구체적인 오류를 확인 다른 reseed URL 시도: http://127.0.0.1:7657/configreseed → 사용자 지정 reseed URL 추가: https://reseed-fr.i2pd.xyz/ 수동 su3 파일 방법 사용 자동화된 시도가 모두 소진되었다면 Reseed servers(리시드 서버) 가끔 오프라인 상태일 수 있음: I2P에는 여러 개의 하드코딩된 reseed servers가 포함되어 있습니다. 하나가 실패하면 router가 자동으로 다른 reseed servers를 시도합니다. 모든 reseed servers가 전부 실패하는 경우는 극히 드물지만 가능할 수 있습니다.\n현재 활성화된 reseed servers(네트워크 초기 부트스트랩용 서버) (2025년 10월 기준):\nhttps://reseed.i2p.rocks/ https://reseed-fr.i2pd.xyz/ https://i2p.novg.net/ https://i2p-projekt.de/ 기본값에 문제가 있는 경우 사용자 지정 URL로 추가하세요.\n검열이 심한 지역의 사용자용:\n초기 reseed(네트워크 부트스트랩)에는 Tor를 통한 Snowflake/Meek bridges 사용을 고려하고, 네트워크에 연결되면 직접 I2P 연결로 전환하세요. 또는 i2pseeds.su3를 스테가노그래피(디지털 은닉 기법), 이메일, 아니면 검열 환경 밖에서 가져온 USB를 통해 확보하세요.\n추가 도움을 구해야 할 때 이 가이드는 I2P 관련 문제의 대다수를 포괄하지만, 일부 문제는 개발자 검토나 커뮤니티의 전문 지식이 필요합니다.\n다음과 같은 경우 I2P 커뮤니티에 도움을 요청하세요:\n모든 문제 해결 단계를 따른 뒤에도 Router가 지속적으로 충돌함 메모리 누수로 인해 할당된 힙을 넘어 사용량이 꾸준히 증가함 적절한 구성에도 불구하고 tunnel 성공률이 20% 미만으로 유지됨 이 가이드에서 다루지 않은 새로운 오류가 로그에 나타남 보안 취약점이 발견됨 기능 요청 또는 개선 제안 도움을 요청하기 전에 진단 정보를 수집하세요:\nI2P 버전: http://127.0.0.1:7657 (예: \u0026ldquo;2.10.0\u0026rdquo;) Java 버전: java -version 출력 운영 체제와 버전 router 상태: 네트워크 상태, 활성 피어 수, 참여 중인 tunnels 대역폭 구성: 수신/송신 한도 포트 포워딩 상태: 방화벽으로 차단됨(Firewalled) 또는 OK 관련 로그 발췌: http://127.0.0.1:7657/logs 에서 오류가 표시된 마지막 50줄 공식 지원 채널:\n포럼: https://i2pforum.net (clearnet, 일반 인터넷) 또는 http://i2pforum.i 2p (I2P 내에서) IRC: Irc2P의 #i2p (irc.postman.i2p, I2P를 통해) 또는 irc.freenode.net (clearnet) Reddit: https://reddit.com/r/i2p 커뮤니티 토론용 버그 트래커: https://i2pgit.org/i2p-hackers/i2p.i2p/-/issues 확인된 버그 보고용 메일링 리스트: i2p-dev@lists.i2p-projekt.de 개발 관련 질문용 현실적인 기대치가 중요합니다. I2P는 근본적인 설계상 clearnet(일반 인터넷)보다 느립니다 - 다중 홉로 암호화된 tunnel(터널)을 이용하는 구조가 고유한 지연을 만들어냅니다. 페이지 로딩에 30초가 걸리고 초당 50 KB의 토렌트 속도가 나오는 I2P router(라우터)는 고장난 것이 아니라 정상 동작 중입니다. clearnet 속도를 기대하는 사용자는 설정 최적화와 무관하게 실망하게 될 것입니다.\n결론 대부분의 I2P 문제는 세 가지 범주에서 비롯됩니다: 부트스트랩 동안의 인내심 부족(10-15분 필요), 불충분한 리소스 할당(512 MB RAM 및 최소 256 KB/sec 대역폭), 또는 잘못 구성된 포트 포워딩. I2P의 분산 아키텍처와 익명성 중심 설계를 이해하면 사용자가 정상적인 동작과 실제 문제를 구분하는 데 도움이 됩니다.\nrouter의 \u0026ldquo;Firewalled\u0026rdquo;(방화벽 뒤) 상태는 최적은 아니지만 I2P 사용을 막지는 않습니다 - 네트워크 기여를 제한하고 성능을 약간 저하시킬 뿐입니다. 신규 사용자는 최적화보다 안정성을 우선시해야 합니다: 고급 설정을 조정하기 전에 router를 며칠 동안 연속 실행하세요. 가동 시간이 늘어날수록 네트워크 통합이 자연스럽게 개선됩니다.\n문제 해결 시에는 항상 기본부터 확인하십시오: 올바른 시스템 시간, 충분한 대역폭, router가 연속으로 실행 중인지, 그리고 10개 이상의 활성 피어. 대부분의 문제는 난해한 구성 매개변수를 조정하기보다 이러한 기본 사항을 점검하면 해결됩니다. 가동 시간이 수일에서 수주에 걸쳐 누적될수록 router가 평판을 쌓고 피어 선택을 최적화하므로, I2P는 인내와 연속 가동에 대해 성능 향상으로 보상합니다.\n","description":"연결성, 성능 및 구성 문제를 포함한 일반적인 I2P router 문제에 대한 종합적인 문제 해결 가이드","id":"2ff67fee0173608876ccc012bf3ff6ce","section":"docs","title":"I2P Router 문제 해결 가이드","url":"/ko/docs/troubleshooting/"},{"categories":null,"content":"개요 I2P 네트워크 프로토콜(I2NP)은 routers가 메시지를 교환하고, 전송 프로토콜을 선택하며, 익명성을 보존하면서 트래픽을 혼합하는 방법을 정의합니다. 이는 I2CP (클라이언트 API)와 전송 프로토콜(NTCP2 및 SSU2) 사이에서 동작합니다.\nI2NP는 I2P 전송 프로토콜 위에 있는 계층이다. 이는 다음을 위한 router 간 프로토콜이다: - 네트워크 데이터베이스 조회 및 응답 - tunnel 생성 - 암호화된 router 및 클라이언트 데이터 메시지\nI2NP 메시지는 다른 router로 점대점으로 전송되거나, tunnel을 통해 해당 router로 익명으로 전송될 수 있다.\nRouters는 로컬 우선순위를 사용하여 발신 작업을 대기열에 넣습니다. 우선순위 번호가 높을수록 먼저 처리됩니다. 표준 tunnel 데이터 우선순위(400)를 초과하는 것은 긴급으로 취급됩니다.\n현재 전송 프로토콜 I2P는 이제 IPv4와 IPv6 모두에서 NTCP2 (TCP)와 SSU2 (UDP)를 사용합니다. 두 전송 프로토콜 모두 다음을 사용합니다: - X25519 키 교환 (Noise 프로토콜 프레임워크) - ChaCha20/Poly1305 인증된 암호화 (AEAD) - SHA-256 해싱\n레거시 전송 프로토콜(transport) 제거됨: - NTCP (원래의 TCP)는 Java router 0.9.50 릴리스(2021년 5월)에서 제거되었습니다 - SSU v1 (원래의 UDP)는 Java router 2.4.0 릴리스(2023년 12월)에서 제거되었습니다 - SSU v1은 i2pd 2.44.0 릴리스(2022년 11월)에서 제거되었습니다\n2025년 기준, 네트워크는 레거시 전송을 전혀 지원하지 않고, 전부 Noise(프로토콜 프레임워크) 기반 전송으로 완전히 전환되었습니다.\n버전 번호 체계 중요: I2P는 이중 버전 관리 시스템을 사용하며, 이를 명확히 이해해야 합니다:\n릴리스 버전 (사용자 대상) 사용자가 보고 다운로드하는 버전은 다음과 같습니다: - 0.9.50 (2021년 5월) - 마지막 0.9.x 릴리스 - 1.5.0 (2021년 8월) - 첫 1.x 릴리스 - 1.6.0, 1.7.0, 1.8.0, 1.9.0 (2021-2022에 걸쳐) - 2.0.0 (2022년 11월) - 첫 2.x 릴리스 - 2.1.0부터 2.9.0까지 (2023-2025에 걸쳐) - 2.10.0 (2025년 9월 8일) - 현재 릴리스\nAPI 버전(프로토콜 호환성) 다음은 RouterInfo 속성의 \u0026ldquo;router.version\u0026rdquo; 필드에 게시되는 내부 버전 번호입니다: - 0.9.50 (2021년 5월) - 0.9.51 (2021년 8월) - 릴리스 1.5.0용 API 버전 - 0.9.52부터 0.9.66까지 (2.x 릴리스를 통해 계속됨) - 0.9.67 (2025년 9월) - 릴리스 2.10.0용 API 버전\n핵심 사항: 0.9.51부터 0.9.67까지 번호가 매겨진 릴리스는 전혀 없었습니다. 이 번호들은 API 버전 식별자용으로만 존재합니다. I2P는 0.9.50 릴리스에서 곧바로 1.5.0으로 건너뛰었습니다.\n버전 매핑 표 Release Version API Version Date Key Features 0.9.50 0.9.50 May 2021 Last 0.9.x release, removed NTCP1 1.5.0 0.9.51 August 2021 Short tunnel build messages (218 bytes) 1.6.0 0.9.52 November 2021 Various improvements 1.7.0 0.9.53 January 2022 Performance enhancements 1.8.0 0.9.54 May 2022 SSU2 introduced 1.9.0 0.9.55 August 2022 SSU2 improvements 2.0.0 0.9.56 November 2022 SSU2 enabled by default 2.1.0 0.9.57 January 2023 Stability improvements 2.2.0 0.9.58 March 2023 ElGamal routers deprecated 2.3.0 0.9.59 May 2023 Various improvements 2.4.0 0.9.61 December 2023 Removed SSU1 support 2.5.0 0.9.62 February 2024 Performance improvements 2.6.0 0.9.63 May 2024 Network optimizations 2.7.0 0.9.64 October 2024 Post-quantum preparation work 2.8.0 0.9.65 February 2025 Tunnel bandwidth parameters 2.9.0 0.9.66 June 2025 LeaseSet service records 2.10.0 0.9.67 September 2025 Post-quantum hybrid cryptography (beta) **예정:** 릴리스 2.11.0 (2025년 12월 예정)은 Java 17+를 요구하며 기본적으로 양자내성 암호를 활성화합니다. 프로토콜 버전 모든 router는 RouterInfo 속성의 \u0026ldquo;router.version\u0026rdquo; 필드에 자신들의 I2NP 프로토콜 버전을 게시해야 합니다. 이 버전 필드는 API 버전으로, 다양한 I2NP 프로토콜 기능에 대한 지원 수준을 나타내며, 반드시 실제 router 버전을 의미하는 것은 아닙니다.\n대체(비-Java) router가 실제 router 구현에 대한 버전 정보를 공개하고자 하는 경우, 해당 정보는 다른 속성에 기재해야 한다. 아래에 나열된 것 외의 버전도 허용된다. 지원 여부는 숫자 비교를 통해 결정되며, 예를 들어 0.9.13은 0.9.12 기능 지원을 의미한다.\n참고: \u0026ldquo;coreVersion\u0026rdquo; 속성은 더 이상 router 정보에 포함되지 않으며, I2NP 프로토콜 버전을 결정하는 데 사용된 적이 없습니다.\nAPI 버전별 기능 요약 API Version Required I2NP Features 0.9.67Post-quantum hybrid cryptography (MLKEM ratchet) support (beta), UDP tracker support 0.9.66LeaseSet2 service record options (see proposal 167) 0.9.65Tunnel build bandwidth parameters (see proposal 168) 0.9.59Minimum peers will build tunnels through (as of 0.9.63), minimum floodfill peers will send DSM to (as of 0.9.63) 0.9.58Minimum peers will build tunnels through (as of 0.9.62), ElGamal routers deprecated 0.9.55SSU2 transport support (if published in router info) 0.9.51Short tunnel build messages for ECIES-X25519 routers, minimum peers will build tunnels through (as of 0.9.58), minimum floodfill peers will send DSM to (as of 0.9.58) 0.9.49Garlic messages to ECIES-X25519 routers 0.9.48ECIES-X25519 routers, ECIES-X25519 build request/response records 0.9.46DatabaseLookup flag bit 4 for AEAD reply 0.9.44ECIES-X25519 keys in LeaseSet2 0.9.40MetaLeaseSet may be sent in a DSM 0.9.39EncryptedLeaseSet may be sent in a DSM, RedDSA_SHA512_Ed25519 signature type supported 0.9.38DSM type bits 3-0 now contain the type; LeaseSet2 may be sent in a DSM 0.9.36NTCP2 transport support (if published in router info), minimum peers will build tunnels through (as of 0.9.46) 0.9.28RSA signature types disallowed, minimum floodfill peers will send DSM to (as of 0.9.34) 0.9.18DSM type bits 7-1 ignored 0.9.16RI key certs / ECDSA and EdDSA signature types, DLM lookup types (flag bits 3-2), minimum version compatible with the current network 0.9.15Destination/LeaseSet key certificates with EdDSA Ed25519 signature type (if floodfill) 0.9.12Destination/LeaseSet key certificates with ECDSA P-256, P-384, and P-521 signature types (if floodfill); non-zero expiration allowed in RouterAddress 0.9.7Encrypted DSM/DSRM replies supported (DLM flag bit 1) for floodfill routers 0.9.6Non-zero DLM flag bits 7-1 allowed 0.9.3Requires zero expiration in RouterAddress 0.9Supports up to 16 leases in a DSM LeaseSet store (previously 6) 0.7.12VTBM and VTBRM message support 0.7.10Floodfill supports encrypted DSM stores 0.6.1.10TBM and TBRM messages introduced; minimum version compatible with the current network **참고:** 전송과 관련된 기능 및 호환성 문제도 있습니다. 자세한 내용은 NTCP2 및 SSU2 전송 문서를 참조하십시오. 메시지 헤더 I2NP는 논리적인 16바이트 헤더 구조를 사용하고, 현대식 전송 프로토콜(NTCP2 및 SSU2)은 중복되는 크기와 체크섬 필드를 생략한 축약된 9바이트 헤더를 사용합니다. 필드는 개념적으로 동일하게 유지됩니다.\n헤더 형식 비교 표준 형식 (16바이트):\n레거시 NTCP 전송과 I2NP 메시지가 다른 메시지(TunnelData, TunnelGateway, GarlicClove) 내에 포함될 때 사용됩니다.\nBytes 0-15: +----+----+----+----+----+----+----+----+ |type| msg_id | expiration +----+----+----+----+----+----+----+----+ | size |chks| +----+----+----+----+----+----+----+----+ type :: Integer (1 byte) Identifies the message type (see message type table) msg_id :: Integer (4 bytes) Uniquely identifies this message (for some time at least) Usually a locally-generated random number, but for outgoing tunnel build messages may be derived from the incoming message expiration :: Date (8 bytes) Unix timestamp in milliseconds when this message expires size :: Integer (2 bytes) Length of the payload (0 to ~61.2 KB for tunnel messages) chks :: Integer (1 byte) SHA256 hash of payload truncated to first byte Deprecated - NTCP2/SSU2 use ChaCha20/Poly1305 AEAD for integrity SSU용 단축 형식(사용 중단됨, 5바이트):\n+----+----+----+----+----+ |type| short_expiration | +----+----+----+----+----+ type :: Integer (1 byte) short_expiration :: Integer (4 bytes, seconds since epoch) NTCP2, SSU2, 및 ECIES-Ratchet(키 래칫 메커니즘) garlic 클로브의 단축 형식 (9바이트):\n최신 트랜스포트와 ECIES로 암호화된 garlic 메시지(여러 메시지를 한 덩어리로 묶는 I2P 메시지)에 사용됩니다.\n+----+----+----+----+----+----+----+----+ |type| msg_id | short_expira- +----+----+----+----+----+----+----+----+ tion| +----+ type :: Integer (1 byte) msg_id :: Integer (4 bytes) short_expiration :: Integer (4 bytes, seconds since epoch, unsigned) 헤더 필드 세부 정보 Field Bytes Description Type 1 Identifies the message class (0\u0026ndash;255, see message types below) Unique ID 4 Locally unique identifier for matching replies Expiration 8 (standard) / 4 (short) Timestamp when the message expires. Routers discard expired messages. Short format uses seconds since epoch (unsigned, wraps February 7, 2106) Payload Length 2 Size in bytes (0 to ~61.2 KB for tunnel messages). NTCP2 and SSU2 encode this in their frame headers Checksum 1 Deprecated. First byte of SHA-256 hash of the payload. NTCP2/SSU2 use ChaCha20/Poly1305 AEAD for integrity ### 구현 참고 사항 SSU(사용 중단됨)로 전송될 때는 유형과 4바이트 만료 시간만 포함되었습니다 NTCP2 또는 SSU2로 전송될 때는 9바이트 짧은 형식이 사용됩니다 다른 메시지(Data, TunnelData, TunnelGateway, GarlicClove)에 포함된 I2NP 메시지에는 표준 16바이트 헤더가 필요합니다 릴리스 0.8.12부터 효율성을 위해 프로토콜 스택의 일부 지점에서 체크섬 검증이 비활성화되었지만, 호환성을 위해 체크섬 생성은 여전히 필요합니다 짧은 만료 값은 부호 없는 값이며 2106년 2월 7일에 순환됩니다. 그 이후에는 올바른 시간을 얻기 위해 오프셋을 추가해야 합니다 이전 버전과의 호환성을 위해 검증되지 않을 수 있더라도 항상 체크섬을 생성해야 합니다 크기 제약 조건 Tunnel 메시지는 I2NP 페이로드를 고정 크기의 조각으로 분할합니다: - 첫 번째 조각: 약 956바이트 - 이후 조각들: 각 약 996바이트 - 최대 조각 수: 64개 (번호 0-63) - 최대 페이로드: 약 61,200바이트 (61.2 KB)\n계산: 956 + (63 × 996) = 63,704 바이트의 이론적 최대치이며, 오버헤드로 인해 실제 한계는 약 61,200 바이트입니다.\n역사적 맥락 이전 전송 방식들은 프레임 크기 제한이 더 엄격했습니다: - NTCP: 16 KB 프레임 - SSU: 약 32 KB 프레임\nNTCP2는 약 65 KB 크기의 프레임을 지원하지만, tunnel 단편화 제한은 여전히 적용됩니다.\n애플리케이션 데이터 고려 사항 Garlic 메시지는 LeaseSets, Session Tags(세션 태그), 또는 암호화된 LeaseSet2 변형을 함께 묶어 포함할 수 있어 페이로드 데이터에 사용할 수 있는 공간이 줄어듭니다.\n권장 사항: 데이터그램은 신뢰할 수 있는 전달을 보장하기 위해 ≤ 10 KB로 유지하는 것이 좋습니다. 61 KB 제한에 가까운 메시지는 다음과 같은 현상이 발생할 수 있습니다: - 조각화 재조립으로 인한 지연 증가 - 전달 실패 가능성 증가 - 트래픽 분석에 대한 노출 증가\n단편화 기술적 세부사항 각 tunnel 메시지는 정확히 1,024바이트 (1 KB)이며 다음을 포함합니다: - 4바이트 tunnel ID - 16바이트 초기화 벡터 (IV) - 1,004바이트의 암호화된 데이터\n암호화된 데이터 내부에서, tunnel 메시지는 조각 헤더를 통해 다음 정보를 나타내는 단편화된 I2NP 메시지를 포함한다: - 조각 번호 (0-63) - 이것이 첫 번째 조각인지 후속 조각인지 - 재조립을 위한 전체 메시지 ID\n첫 번째 프래그먼트에는 전체 I2NP 메시지 헤더(16바이트)가 포함되어 페이로드에 대략 956바이트가 남습니다. 후속 프래그먼트에는 메시지 헤더가 포함되지 않으므로 프래그먼트당 페이로드는 대략 996바이트입니다.\n일반적인 메시지 유형 router는 메시지 유형과 우선순위를 사용해 발신 작업을 스케줄링합니다. 우선순위 값이 높을수록 먼저 처리됩니다. 아래 값은 현재 Java I2P 기본값과 일치합니다(API 버전 0.9.67 기준).\n참고: 우선순위는 구현에 따라 달라집니다. 공식 우선순위 값은 Java I2P 소스 코드의 OutNetMessage 클래스 문서를 참조하십시오.\nMessage Type Priority Typical Size Purpose DatabaseStore 1 460 Varies (LeaseSet ≈ 898\u0026nbsp;B, RouterInfo ≈ 2\u0026ndash;4\u0026nbsp;KB compressed) Publishes RouterInfo or LeaseSet objects. Supports LeaseSet2, EncryptedLeaseSet, and MetaLeaseSet DatabaseLookup 2 500 Varies Queries the network database for RouterInfo or LeaseSet entries DatabaseSearchReply 3 300 ≈161\u0026nbsp;B (5 hashes) Returns candidate floodfill router hashes (typically 3\u0026ndash;16 hashes, recommended maximum 16) DeliveryStatus 10 Varies 12\u0026nbsp;B Receipts for tunnel tests or acknowledgements inside GarlicMessages GarlicMessage 11 100 (local) Varies Bundles multiple message cloves (e.g., DataMessage, LeaseSets). Supports ElGamal/AES (deprecated) and ECIES-X25519-AEAD-Ratchet encryption TunnelData 18 400 1,028\u0026nbsp;B (fixed) Encrypted tunnel message exchanged between hops. Contains a 4-byte tunnel ID, 16-byte IV, and 1,004 bytes of encrypted data TunnelGateway 19 300\u0026ndash;400 Varies Encapsulates messages at the tunnel gateway before fragmentation DataMessage 20 425 4\u0026ndash;62\u0026nbsp;KB Carries end-to-end garlic payloads (application traffic) TunnelBuild (deprecated) 21 500 4,224\u0026nbsp;B Requests tunnel participation from routers (8 × 528-byte records). Replaced by VariableTunnelBuild for ECIES TunnelBuildReply (deprecated) 22 300 4,224\u0026nbsp;B Replies to TunnelBuild with accept/reject status per hop VariableTunnelBuild 23 500 1,057\u0026ndash;4,225\u0026nbsp;B Variable-length tunnel build for ElGamal or ECIES-X25519 routers (1\u0026ndash;8 records, API 0.9.12+) VariableTunnelBuildReply 24 300 1,057\u0026ndash;4,225\u0026nbsp;B Replies to VariableTunnelBuild ShortTunnelBuild 25 500 873\u0026ndash;1,745\u0026nbsp;B Short tunnel build messages for ECIES-X25519 routers only (1\u0026ndash;8 × 218-byte records, API 0.9.51+) OutboundTunnelBuildReply 26 300 873\u0026ndash;1,745\u0026nbsp;B Sent from outbound endpoint to originator for ECIES-X25519 routers (API 0.9.51+) **예약된 메시지 유형:** - 유형 0: 예약됨 - 유형 4-9: 향후 사용을 위해 예약됨 - 유형 12-17: 향후 사용을 위해 예약됨 - 유형 224-254: 실험적 메시지용으로 예약됨 - 유형 255: 향후 확장을 위해 예약됨 메시지 유형 참고 사항 제어 평면 메시지(DatabaseLookup, TunnelBuild 등)는 보통 클라이언트 tunnels가 아닌 탐색용 tunnels을 통해 전달되어, 우선순위를 독립적으로 지정할 수 있다 우선순위 값은 대략적이며 구현에 따라 달라질 수 있다 TunnelBuild (21)와 TunnelBuildReply (22)는 더 이상 권장되지 않지만, 8 hops를 초과하는 매우 긴 tunnels와의 호환성을 위해 여전히 구현되어 있다 표준 tunnel 데이터 우선순위는 400이며, 이보다 높은 값은 긴급으로 취급된다 현재 네트워크에서 일반적인 tunnel 길이는 3-4 hops이므로, 대부분의 tunnel 빌드는 ShortTunnelBuild (218-byte records) 또는 VariableTunnelBuild (528-byte records)를 사용한다 암호화 및 메시지 래핑 Routers는 전송 전에 I2NP 메시지를 자주 캡슐화하여 여러 겹의 암호화 계층을 만듭니다. DeliveryStatus 메시지(전달 상태 확인 메시지)는 다음과 같을 수 있습니다: 1. GarlicMessage로 캡슐화됨(암호화됨) 2. DataMessage 내부 3. TunnelData 메시지 내부(다시 암호화됨)\n각 hop(네트워크 경유 단계)은 자신의 계층만 복호화한다; 최종 목적지는 가장 내부의 페이로드를 드러낸다.\n암호화 알고리즘 레거시(단계적으로 폐지 중): - ElGamal/AES + 세션 태그 - 비대칭 암호화를 위한 ElGamal-2048 - 대칭 암호화를 위한 AES-256 - 32바이트 세션 태그\n현재(API 0.9.48 기준 표준): - ECIES-X25519 + ChaCha20/Poly1305 AEAD, 래칫 기반 전방 기밀성 지원 - Noise 프로토콜 프레임워크 (Noise_IK_25519_ChaChaPoly_SHA256 목적지용) - 8바이트 세션 태그 (32바이트에서 축소) - 전방 기밀성을 위한 Signal Double Ratchet algorithm(시그널 더블 래칫 알고리즘) - API 버전 0.9.46 (2020)에 도입 - API 버전 0.9.58 (2023)부터 모든 routers에 의무화\n향후(2.10.0 기준 베타): - MLKEM (ML-KEM-768)과 X25519를 결합한 양자 내성 하이브리드 암호화 - 고전(클래식) 및 양자 내성 키 합의를 결합한 하이브리드 ratchet(세션 키를 단계적으로 갱신하는 메커니즘) - ECIES-X25519와 하위 호환 - 2.11.0 릴리스(2025년 12월)에서 기본값이 됨\nElGamal Router 사용 중단 예정 CRITICAL: ElGamal routers는 API 버전 0.9.58(릴리스 2.2.0, 2023년 3월)부터 사용 중단되었습니다. 이제 조회할 권장 최소 floodfill 버전이 0.9.58이므로, 구현체는 ElGamal floodfill routers에 대한 암호화를 구현할 필요가 없습니다.\n그러나: 하위 호환성을 위해 ElGamal 목적지는 여전히 지원됩니다. ElGamal 암호화를 사용하는 클라이언트는 ECIES(타원곡선 통합 암호체계) router를 통해서도 여전히 통신할 수 있습니다.\nECIES-X25519-AEAD-Ratchet 세부 사항 이는 I2P의 암호화 명세에서의 암호 유형 4입니다. 다음을 제공합니다:\n핵심 기능: - ratcheting(연쇄적 키 갱신 기법)을 통한 순방향 비밀성(각 메시지마다 새 키) - 세션 태그 저장 공간 축소(8바이트 대 32바이트) - 여러 세션 유형(New Session, Existing Session, One-Time) - Noise protocol(경량 암호 핸드셰이크 프레임워크) Noise_IK_25519_ChaChaPoly_SHA256 기반 - Signal의 Double Ratchet 알고리즘(메시지별 키 갱신 알고리즘)과 통합\n암호학 기본 구성 요소: - 디피-헬먼 키 합의를 위한 X25519 - 스트림 암호화를 위한 ChaCha20 - 메시지 인증 (AEAD, 연관 데이터가 포함된 인증된 암호화)을 위한 Poly1305 - 해시를 위한 SHA-256 - 키 파생을 위한 HKDF\n세션 관리: - 신규 세션: 정적 destination key(목적지 키)를 사용하는 초기 연결 - 기존 세션: session tags(세션 태그)를 사용하는 후속 메시지 - 일회성 세션: 오버헤드를 줄이기 위한 단일 메시지 세션\n자세한 기술 세부사항은 ECIES 사양 및 제안 144 를 참고하세요.\n공통 구조 다음 구조체들은 여러 I2NP 메시지의 구성 요소입니다. 완전한 메시지는 아닙니다.\nBuildRequestRecord (빌드 요청 레코드) (ElGamal) 사용 중단됨. 현재 네트워크에서는 tunnel에 ElGamal router가 포함된 경우에만 사용됩니다. 최신 형식은 ECIES Tunnel 생성 을 참조하세요.\n목적: tunnel에서 하나의 홉 생성을 요청하기 위해 사용되는, 여러 개의 레코드로 이루어진 집합 중 하나의 레코드.\n형식:\nElGamal과 AES로 암호화됨 (총 528바이트):\n+----+----+----+----+----+----+----+----+ | encrypted data (528 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ ElGamal(엘가말)로 암호화된 구조 (528바이트):\n+----+----+----+----+----+----+----+----+ | toPeer (16 bytes) | +----+----+----+----+----+----+----+----+ | ElGamal encrypted data (512 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ toPeer :: First 16 bytes of SHA-256 hash of peer\u0026#39;s RouterIdentity encrypted_data :: ElGamal-2048 encrypted (bytes 1-256 and 258-513 of the 514-byte ElGamal block, with padding bytes at positions 0 and 257 removed) 평문 구조 (암호화 전에 222바이트):\n+----+----+----+----+----+----+----+----+ | receive_tunnel (4) | our_ident (32) | +----+----+----+----+ + | | + +----+----+----+----+ | | next_tunnel (4) | +----+----+----+----+----+----+----+----+ | next_ident (32 bytes) | + + | | +----+----+----+----+----+----+----+----+ | layer_key (32 bytes) | + + | | +----+----+----+----+----+----+----+----+ | iv_key (32 bytes) | + + | | +----+----+----+----+----+----+----+----+ | reply_key (32 bytes) | + + | | +----+----+----+----+----+----+----+----+ | reply_iv (16 bytes) | + + | | +----+----+----+----+----+----+----+----+ |flag| request_time (4) | send_msg_id | +----+----+----+----+----+----+----+----+ (4) | padding (29) | +----+----+----+----+----+ + | | + +----+----+ | | +----+----+----+----+----+----+ receive_tunnel :: TunnelId (4 bytes, nonzero) our_ident :: Hash (32 bytes) next_tunnel :: TunnelId (4 bytes, nonzero) next_ident :: Hash (32 bytes) layer_key :: SessionKey (32 bytes) iv_key :: SessionKey (32 bytes) reply_key :: SessionKey (32 bytes) reply_iv :: 16 bytes flag :: Integer (1 byte) request_time :: Integer (4 bytes, hours since epoch = time / 3600) send_message_id :: Integer (4 bytes) padding :: 29 bytes random data 참고: - ElGamal-2048 암호화는 514바이트 블록을 생성하지만, 패딩 바이트 두 개(위치 0과 257)는 제거되어 최종 크기는 512바이트가 됩니다 - 필드 상세 내용은 Tunnel 생성 사양 을 참조하세요 - 소스 코드: net.i2p.data.i2np.BuildRequestRecord - 상수: EncryptedBuildRecord.RECORD_SIZE = 528\nBuildRequestRecord(빌드 요청 레코드) (ECIES-X25519 Long) ECIES-X25519(타원곡선 통합 암호 방식) routers용이며, API 버전 0.9.48에서 도입되었습니다. 혼합 tunnels과의 하위 호환성을 위해 528바이트를 사용합니다.\n형식:\n+----+----+----+----+----+----+----+----+ | toPeer (16 bytes) | +----+----+----+----+----+----+----+----+ | ephemeral_key (32 bytes) | + + | | +----+----+----+----+----+----+----+----+ | ChaCha20 encrypted data (464 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ | Poly1305 MAC (16 bytes) | + + | | +----+----+----+----+----+----+----+----+ toPeer :: First 16 bytes of SHA-256 hash of peer\u0026#39;s RouterIdentity ephemeral_key :: X25519 ephemeral public key (32 bytes) encrypted_data :: ChaCha20 encrypted (464 bytes) mac :: Poly1305 message authentication code (16 bytes) 총 크기: 528바이트 (호환성을 위해 ElGamal과 동일)\n평문 구조와 암호화 세부 정보는 ECIES Tunnel Creation 을 참조하세요.\nBuildRequestRecord (빌드 요청 레코드) (ECIES-X25519 단축형) ECIES-X25519(X25519 기반 ECIES 암호 방식) router에만 해당하며, API 버전 0.9.51(릴리스 1.5.0) 기준입니다. 이는 현재 표준 형식입니다.\n형식:\n+----+----+----+----+----+----+----+----+ | toPeer (16 bytes) | +----+----+----+----+----+----+----+----+ | ephemeral_key (32 bytes) | + + | | +----+----+----+----+----+----+----+----+ | ChaCha20 encrypted data (154 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ | Poly1305 MAC (16 bytes) | + + | | +----+----+----+----+----+----+----+----+ toPeer :: First 16 bytes of SHA-256 hash of peer\u0026#39;s RouterIdentity ephemeral_key :: X25519 ephemeral public key (32 bytes) encrypted_data :: ChaCha20 encrypted (154 bytes) mac :: Poly1305 message authentication code (16 bytes) 총 크기: 218바이트 (528바이트 대비 59% 감소)\n핵심 차이점: Short records(짧은 레코드 형식)는 레코드에 키를 명시적으로 포함하는 대신 HKDF (키 유도 함수)를 통해 모든 키를 유도한다. 이에는 다음이 포함된다: - 레이어 키 (tunnel 암호화용) - IV 키 (tunnel 암호화용) - 응답 키 (빌드 응답용) - 응답 IV (빌드 응답용)\n모든 키는 X25519 키 교환으로부터 얻은 공유 비밀을 기반으로 Noise 프로토콜의 HKDF(해시 기반 키 유도 함수) 메커니즘을 사용해 파생됩니다.\n장점: - 짧은 레코드 4개가 하나의 tunnel 메시지(873바이트)에 들어감 - 각 레코드마다 별도의 메시지를 보내는 대신 tunnel 빌드 메시지 3개 - 대역폭과 지연시간 감소 - 긴 형식과 동일한 보안 특성\n설계 근거는 Proposal 157 을 참조하고, 완전한 명세는 ECIES Tunnel Creation 을 참조하세요.\n소스 코드: - net.i2p.data.i2np.ShortEncryptedBuildRecord - 상수: ShortEncryptedBuildRecord.RECORD_SIZE = 218\nBuildResponseRecord (ElGamal 공개키 암호) 사용 중단됨. tunnel에 ElGamal router가 포함된 경우에만 사용됩니다.\n목적: 빌드 요청에 대한 응답을 담은 여러 레코드로 구성된 집합 중 하나의 레코드.\n형식:\n암호화됨 (528바이트, BuildRequestRecord(빌드 요청 레코드)와 동일한 크기):\nbytes 0-527 :: AES-encrypted record 암호화되지 않은 구조:\n+----+----+----+----+----+----+----+----+ | SHA-256 hash (32 bytes) | + + | (hash of bytes 32-527) | + + | | +----+----+----+----+----+----+----+----+ | random data (495 bytes) | ~ ~ | |ret | +----+----+----+----+----+----+----+----+ bytes 0-31 :: SHA-256 hash of bytes 32-527 bytes 32-526 :: Random data (could be used for congestion info) byte 527 :: Reply code (0 = accept, 30 = reject) 응답 코드: - 0 - 수락 - 30 - 거부 (대역폭 초과)\n응답 필드에 대한 자세한 내용은 Tunnel Creation Specification 을 참조하십시오.\nBuildResponseRecord (빌드 응답 레코드) (ECIES-X25519) ECIES-X25519 router의 경우, API 버전은 0.9.48+입니다. 해당 요청과 동일한 크기입니다(긴 형식은 528, 짧은 형식은 218).\n형식:\n긴 형식(528바이트):\n+----+----+----+----+----+----+----+----+ | ChaCha20 encrypted data (512 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ | Poly1305 MAC (16 bytes) | + + | | +----+----+----+----+----+----+----+----+ 짧은 형식(218바이트):\n+----+----+----+----+----+----+----+----+ | ChaCha20 encrypted data (202 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ | Poly1305 MAC (16 bytes) | + + | | +----+----+----+----+----+----+----+----+ 평문 구조(두 형식 모두):\n매핑 구조(I2P의 키-값 형식)에는 다음이 포함됩니다: - 응답 상태 코드(필수) - 사용 가능한 대역폭 매개변수(\u0026ldquo;b\u0026rdquo;)(선택적, API 0.9.65에서 추가됨) - 향후 확장을 위한 기타 선택적 매개변수\n응답 상태 코드: - 0 - 성공 - 30 - 거부: 대역폭 초과\n전체 명세는 ECIES Tunnel 생성 을 참조하십시오.\nGarlicClove(I2P garlic encryption의 하위 메시지) (ElGamal/AES) 경고: 이는 ElGamal로 암호화된 garlic messages(갈릭 메시지: 여러 cloves를 한 번에 묶어 전달하는 메시지 형식) 내부의 garlic cloves(갈릭 클로브: garlic message를 구성하는 개별 하위 메시지)에 사용되는 형식입니다. ECIES-AEAD-X25519-Ratchet garlic messages 및 garlic cloves의 형식은 이와 크게 다릅니다. 최신 형식은 ECIES Specification 을 참고하십시오.\nrouter에서는 더 이상 권장되지 않음 (API 0.9.58+), 목적지에서는 여전히 지원됩니다.\n형식:\n암호화되지 않음:\n+----+----+----+----+----+----+----+----+ | Delivery Instructions (variable) | ~ ~ +----+----+----+----+----+----+----+----+ | I2NP Message (variable) | ~ ~ +----+----+----+----+----+----+----+----+ | Clove ID (4) | Expiration (8) |Cert| +----+----+----+----+----+----+----+----+ (3) | +----+----+----+----+----+----+----+----+ Delivery Instructions :: Variable length (typically 1, 33, or 37 bytes) I2NP Message :: Any I2NP message Clove ID :: 4-byte Integer (random, checked for duplicates) Expiration :: Date (8 bytes) Certificate :: Always NULL (3 bytes total, all zeroes) 참고: - clove(garlic에서 묶이는 개별 하위 메시지 단위)는 절대 단편화되지 않는다 - Delivery Instructions 플래그 바이트의 첫 번째 비트가 0이면, clove는 암호화되지 않는다 - 첫 번째 비트가 1이면, clove는 암호화된다(미구현 기능) - 최대 길이는 전체 clove 길이들의 합과 최대 GarlicMessage 길이의 함수다 - 인증서는 라우팅에 대한 \u0026ldquo;지불\u0026quot;을 위해 HashCash에 사용될 수도 있다(향후 가능성) - 실제로 사용되는 메시지: DataMessage, DeliveryStatusMessage, DatabaseStoreMessage - GarlicMessage는 GarlicMessage를 포함할 수 있다(중첩된 garlic), 그러나 실제로는 사용되지 않는다\n개념적 개요는 Garlic Routing(갈릭 라우팅) 을 참조하세요.\nGarlicClove (ECIES-X25519-AEAD-Ratchet) ECIES-X25519 router와 목적지의 경우, API 버전은 0.9.46+입니다. 이는 현재 표준 형식입니다.\n중요한 차이점: ECIES garlic은 명시적인 clove(메시지 묶음 내 개별 서브메시지) 구조가 아니라 Noise 프로토콜 블록을 기반으로 한 완전히 다른 구조를 사용합니다.\n형식:\nECIES(타원곡선 통합 암호화 방식) garlic 메시지(여러 메시지를 묶어 전송하는 I2P 방식의 메시지)에는 일련의 블록이 포함됩니다:\nBlock structure: +----+----+----+----+----+----+----+----+ |type| length | data ... +----+----+----+----+----+-//- type :: 1 byte block type length :: 2 bytes block length data :: variable length data 블록 유형: - 0 - Garlic Clove Block (갈릭 클로브 블록; I2NP 메시지를 포함) - 1 - DateTime Block (날짜/시간 블록; 타임스탬프) - 2 - Options Block (옵션 블록; 전달 옵션) - 3 - Padding Block (패딩 블록) - 254 - Termination Block (종료 블록; 구현되지 않음)\nGarlic Clove Block(garlic 메시지에서 각 clove를 담는 블록) (type 0):\n+----+----+----+----+----+----+----+----+ | 0 | length | Delivery Instructions | +----+----+----+----+ + ~ ~ +----+----+----+----+----+----+----+----+ | I2NP Message | ~ ~ +----+----+----+----+----+----+----+----+ | Clove ID (4) | Expiration (4) | +----+----+----+----+----+----+----+----+ ElGamal(엘가말) 형식과의 주요 차이점: - 8바이트 Date 대신 4바이트 만료 시간(epoch 기준 초 단위)을 사용 - certificate 필드 없음 - type과 length를 포함하는 블록 구조로 감싸짐 - 전체 메시지는 ChaCha20/Poly1305 AEAD로 암호화됨 - ratcheting(래칫 방식)을 통한 세션 관리\nNoise Protocol Framework(Noise 프로토콜 프레임워크)와 블록 구조에 대한 자세한 내용은 ECIES Specification 을 참조하세요.\nGarlic Clove(개별 메시지 단위) 전달 지침 이 형식은 ElGamal 및 ECIES garlic cloves(마늘 메시지의 개별 구성 요소) 모두에 사용됩니다. 이는 포함된 메시지를 전달하는 방법을 지정합니다.\n중대한 경고: 이 명세는 Garlic Cloves(garlic 메시지의 clove 단위) 내부의 Delivery Instructions(전송 지시사항)에만 해당합니다. \u0026ldquo;Delivery Instructions\u0026quot;는 Tunnel 메시지 내부에서도 사용되며, 그 형식은 상당히 다릅니다. Tunnel delivery instructions에 대해서는 Tunnel Message Specification 을 참조하십시오. 이 두 형식을 혼동하지 마십시오.\n형식:\n세션 키와 지연은 사용되지 않으며 존재하지 않으므로, 가능한 길이는 다음 세 가지입니다:\n1 바이트 (LOCAL) 33 바이트 (ROUTER 및 DESTINATION) 37 바이트 (TUNNEL) +----+----+----+----+----+----+----+----+ |flag| | +----+ + | Session Key (optional, 32) | + + | | + +----+----+----+----+--------------+ | | | +----+ + | To Hash (optional, 32) | + + | | + +----+----+----+----+--------------+ | | Tunnel ID (4, opt)| Delay (4, opt)| +----+----+----+----+----+----+----+----+ flag :: 1 byte Bit order: 76543210 bit 7: encrypted? (Unimplemented, always 0) If 1, a 32-byte encryption session key follows bits 6-5: delivery type 0x0 = LOCAL (0) 0x1 = DESTINATION (1) 0x2 = ROUTER (2) 0x3 = TUNNEL (3) bit 4: delay included? (Not fully implemented, always 0) If 1, four delay bytes are included bits 3-0: reserved, set to 0 for compatibility Session Key :: 32 bytes (Optional, unimplemented) Present if encrypt flag bit is set To Hash :: 32 bytes (Optional) Present if delivery type is DESTINATION, ROUTER, or TUNNEL - DESTINATION: SHA256 hash of the destination - ROUTER: SHA256 hash of the router identity - TUNNEL: SHA256 hash of the gateway router identity Tunnel ID :: 4 bytes (Optional) Present if delivery type is TUNNEL The destination tunnel ID (nonzero) Delay :: 4 bytes (Optional, unimplemented) Present if delay included flag is set Specifies delay in seconds 일반적인 길이: - 로컬 전달: 1바이트 (플래그만) - ROUTER / 목적지 전달: 33바이트 (플래그 + 해시) - TUNNEL 전달: 37바이트 (플래그 + 해시 + tunnel ID)\n전송 유형 설명:\nType Value Description LOCAL 0 Deliver to the local router (this router) DESTINATION 1 Deliver to a destination (client) identified by hash ROUTER 2 Deliver to another router identified by hash TUNNEL 3 Deliver to a tunnel gateway router **구현 참고 사항:** - 세션 키 암호화는 미구현이며 플래그 비트는 항상 0이다 - 지연은 완전히 구현되지 않았으며 플래그 비트는 항상 0이다 - TUNNEL 전달의 경우, 해시는 게이트웨이 router를 식별하며 tunnel ID는 어느 인바운드 tunnel인지를 지정한다 - DESTINATION 전달의 경우, 해시는 대상의 공개 키의 SHA-256이다 - ROUTER 전달의 경우, 해시는 router의 식별자의 SHA-256이다 I2NP 메시지 모든 I2NP 메시지 유형에 대한 포괄적인 메시지 사양.\n메시지 유형 요약 Message Type Since Status DatabaseStore10.6.1.10Active DatabaseLookup20.6.1.10Active DatabaseSearchReply30.6.1.10Active DeliveryStatus100.6.1.10Active Garlic110.6.1.10Active TunnelData180.6.1.10Active TunnelGateway190.6.1.10Active Data200.6.1.10Active TunnelBuild210.6.1.10Deprecated TunnelBuildReply220.6.1.10Deprecated VariableTunnelBuild230.7.12Active VariableTunnelBuildReply240.7.12Active ShortTunnelBuild250.9.51Active OutboundTunnelBuildReply260.9.51Active **예약됨:** - 유형 0: 예약됨 - 유형 4-9: 향후 사용을 위해 예약됨 - 유형 12-17: 향후 사용을 위해 예약됨 - 유형 224-254: 실험적 메시지용으로 예약됨 - 유형 255: 향후 확장을 위해 예약됨 DatabaseStore (유형 1) Purpose: 요청되지 않은 데이터베이스 저장, 또는 성공한 DatabaseLookup message(데이터베이스 조회 메시지)에 대한 응답.\n내용: 압축되지 않은 LeaseSet(목적지 접속 경로 정보 집합), LeaseSet2(2세대 LeaseSet 형식), MetaLeaseSet(여러 LeaseSet을 참조하는 메타 형식), 또는 EncryptedLeaseSet(암호화된 LeaseSet), 또는 압축된 RouterInfo(router 정보).\n응답 토큰으로 포맷:\n+----+----+----+----+----+----+----+----+ | SHA256 Hash as key (32 bytes) | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ |type| reply token (4) | reply_tunnelId +----+----+----+----+----+----+----+----+ (4) | reply gateway | +----+----+----+----+----+ + | SHA256 hash (32 bytes) | + + | | + +----+ | | +----+----+----+----+----+----+----+ | data ... +----+-// key :: 32 bytes SHA256 hash (the \u0026#34;real\u0026#34; hash, not routing key) type :: 1 byte Type identifier bit 0: 0 = RouterInfo 1 = LeaseSet or variants bits 3-1: (as of 0.9.38) 0: RouterInfo or LeaseSet (types 0 or 1) 1: LeaseSet2 (type 3) 2: EncryptedLeaseSet (type 5) 3: MetaLeaseSet (type 7) 4-7: Unsupported, invalid bits 7-4: Reserved, set to 0 reply token :: 4 bytes If greater than zero, a DeliveryStatusMessage is requested with the Message ID set to the reply token A floodfill router is also expected to flood the data to the closest floodfill peers reply_tunnelId :: 4 bytes (only if reply token \u0026gt; 0) TunnelId of the inbound gateway of the tunnel for the response If 0, reply is sent directly to reply gateway reply gateway :: 32 bytes (only if reply token \u0026gt; 0) SHA256 hash of the RouterInfo If reply_tunnelId is nonzero: inbound gateway router If reply_tunnelId is zero: router to send reply to data :: Variable length If type == 0: 2-byte Integer length + gzip-compressed RouterInfo If type == 1: Uncompressed LeaseSet If type == 3: Uncompressed LeaseSet2 If type == 5: Uncompressed EncryptedLeaseSet If type == 7: Uncompressed MetaLeaseSet 응답 토큰 == 0인 형식:\n+----+----+----+----+----+----+----+----+ | SHA256 Hash as key (32 bytes) | + + | | +----+----+----+----+----+----+----+----+ |type| 0 | data ... +----+----+----+----+----+-// 소스 코드: - net.i2p.data.i2np.DatabaseStoreMessage - net.i2p.data.RouterInfo (RouterInfo(router에 대한 정보) 구조체용) - net.i2p.data.LeaseSet (LeaseSet(임대 정보 집합) 구조체용)\nDatabaseLookup(데이터베이스 조회) (유형 2) 목적: 네트워크 데이터베이스에서 항목을 조회하기 위한 요청입니다. 응답은 DatabaseStore 또는 DatabaseSearchReply 중 하나입니다.\n형식:\n+----+----+----+----+----+----+----+----+ | SHA256 hash as the key (32 bytes) | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ | SHA256 hash of the from router (32) | + or reply tunnel gateway + | | + + | | + + | | +----+----+----+----+----+----+----+----+ |flag| reply_tunnelId (4)| size (2)| | +----+----+----+----+----+----+----+ + | SHA256 of key1 to exclude (32 bytes) | + + | | + +----+ | | | +----+----+----+----+----+----+----+ + | SHA256 of key2 to exclude (32) | + + ~ ~ | | + +----+ | | | +----+----+----+----+----+----+----+ + | Session key if reply encryption | + requested (32 bytes) + | | + +----+ | |tags| +----+----+----+----+----+----+----+----+ | Session tags if reply encryption | + requested (variable) + ~ ~ | | +----+----+----+----+----+----+----+----+ key :: 32 bytes SHA256 hash of the object to lookup from :: 32 bytes If deliveryFlag == 0: SHA256 hash of RouterInfo (sender) If deliveryFlag == 1: SHA256 hash of reply tunnel gateway flags :: 1 byte Bit order: 76543210 bit 0: deliveryFlag 0 = send reply directly 1 = send reply to some tunnel bit 1: encryptionFlag Through 0.9.5: must be 0 As of 0.9.6: ignored As of 0.9.7: 0 = send unencrypted reply 1 = send AES encrypted reply using key and tag bits 3-2: lookup type flags Through 0.9.5: must be 00 As of 0.9.6: ignored As of 0.9.16: 00 = ANY (deprecated, use LS or RI as of 0.9.16) 01 = LS lookup (LeaseSet or variants) 10 = RI lookup (RouterInfo) 11 = exploration lookup (RouterInfo, non-floodfill) bit 4: ECIESFlag Before 0.9.46: ignored As of 0.9.46: 0 = send unencrypted or ElGamal reply 1 = send ChaCha/Poly encrypted reply using key bits 7-5: Reserved, set to 0 reply_tunnelId :: 4 bytes (only if deliveryFlag == 1) TunnelId of the tunnel to send reply to (nonzero) size :: 2 bytes Integer (valid range: 0-512) Number of peers to exclude from DatabaseSearchReply excludedPeers :: $size SHA256 hashes of 32 bytes each If lookup fails, exclude these peers from the reply If includes a hash of all zeroes, the request is exploratory (return non-floodfill routers only) reply_key :: 32 bytes (conditional, see encryption modes below) reply_tags :: 1 byte count + variable length tags (conditional) 응답 암호화 모드:\nNOTE: ElGamal router는 API 0.9.58부터 사용 중단되었습니다. 조회 시 권장되는 최소 floodfill 버전이 이제 0.9.58이므로, 구현체는 ElGamal floodfill router에 대한 암호화를 구현할 필요가 없습니다. ElGamal 목적지는 여전히 지원됩니다.\n플래그 비트 4(ECIESFlag)는 비트 1(encryptionFlag)과 조합되어 응답 암호화 모드를 결정하는 데 사용된다:\nFlag bits 4,1 From To Router Reply DH? Notes 0 0 Any Any No encryption n/a No encryption 0 1 ElG ElG AES No As of 0.9.7, deprecated 0.9.58 1 0 ECIES ElG AEAD No As of 0.9.46, deprecated 0.9.58 1 0 ECIES ECIES AEAD No As of 0.9.49, current standard 1 1 ElG ECIES AES Yes TBD, future 1 1 ECIES ECIES AEAD Yes TBD, future **암호화 없음 (플래그 0,0):** reply_key, tags, 그리고 reply_tags는 존재하지 않습니다.\nElG에서 ElG로 (플래그 0,1) - 사용 중단됨:\n0.9.7부터 지원되며, 0.9.58부터 더 이상 권장되지 않습니다.\nreply_key :: 32 byte SessionKey (big-endian) CSRNG(32) random data tags :: 1 byte Integer (1-32, typically 1) Number of reply tags that follow reply_tags :: One or more 32-byte SessionTags Each is CSRNG(32) random data ECIES에서 ElG로 (플래그 1,0) - 사용 중단됨:\n버전 0.9.46부터 지원됨, 버전 0.9.58부터 더 이상 권장되지 않음.\nreply_key :: 32 byte ECIES SessionKey (big-endian) CSRNG(32) random data tags :: 1 byte Integer (required value: 1) Number of reply tags that follow reply_tags :: One 8-byte ECIES SessionTag CSRNG(8) random data 응답은 ECIES 사양 에 정의된 ECIES 기존 세션 메시지입니다:\n+----+----+----+----+----+----+----+----+ | Session Tag (8 bytes) | +----+----+----+----+----+----+----+----+ | ChaCha20 encrypted payload | ~ ~ | | +----+----+----+----+----+----+----+----+ | Poly1305 MAC (16 bytes) | + + | | +----+----+----+----+----+----+----+----+ tag :: 8 byte reply_tag k :: 32 byte session key (the reply_key) n :: 0 (nonce) ad :: The 8 byte reply_tag payload :: Plaintext data (DSM or DSRM) ciphertext = ENCRYPT(k, n, payload, ad) ECIES(타원곡선 통합 암호체계)에서 ECIES로 (플래그 1,0) - 현재 표준:\nECIES(타원 곡선 통합 암호화 체계) 목적지 또는 router가 ECIES router로 조회 요청을 보냅니다. 0.9.49부터 지원됩니다.\n위의 \u0026ldquo;ECIES to ElG\u0026quot;와 동일한 형식입니다. 조회 메시지 암호화는 ECIES Routers 에 명시되어 있습니다. 요청자는 익명입니다.\nECIES(타원곡선 통합 암호 체계)에서 ECIES로, DH(디피-헬먼 키 교환) 사용 (플래그 1,1) - 향후:\n아직 완전히 정의되지 않았습니다. Proposal 156 를 참조하십시오.\n참고: - 0.9.16 이전에는 키가 RouterInfo 또는 LeaseSet용일 수 있었습니다(동일한 키 공간, 구분할 플래그 없음) - 암호화된 응답은 응답이 tunnel을 통해 이뤄질 때만 유용합니다 - 대체 DHT 조회 전략이 구현된 경우 포함된 태그 수는 하나보다 클 수 있습니다 - 조회 키와 제외 키는 \u0026ldquo;실제\u0026rdquo; 해시이며, 라우팅 키가 아닙니다 - 유형 3, 5, 7(LeaseSet2 variants)은 0.9.38부터 반환될 수 있습니다. Proposal 123 를 참조하세요 - 탐색적 조회 참고: 탐색적 조회는 키와 가까운 non-floodfill 해시 목록을 반환하도록 정의됩니다. 그러나 구현은 다양합니다: Java는 RI(RouterInfo)에 대해 검색 키를 조회하고 존재하면 DatabaseStore를 반환하지만; i2pd는 그렇지 않습니다. 따라서 이전에 수신한 해시에 대해 탐색적 조회를 사용하는 것은 권장되지 않습니다\n소스 코드: - net.i2p.data.i2np.DatabaseLookupMessage - 암호화: net.i2p.crypto.SessionKeyManager\nDatabaseSearchReply (데이터베이스 검색 응답) (유형 3) 목적: 실패한 DatabaseLookup 메시지에 대한 응답.\n내용: 요청된 키에 가장 가까운 router 해시 목록.\n형식:\n+----+----+----+----+----+----+----+----+ | SHA256 hash as query key (32 bytes) | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ | num| peer_hashes (variable) | +----+ + | | ~ ~ | | + +----+----+----+----+----+----+----+ | | from (32 bytes) | +----+ + | | + + | | + + | | + +----+----+----+----+----+----+----+ | | +----+ key :: 32 bytes SHA256 of the object being searched num :: 1 byte Integer Number of peer hashes that follow (0-255) peer_hashes :: $num SHA256 hashes of 32 bytes each (total $num*32 bytes) SHA256 of the RouterIdentity that the sender thinks is close to the key from :: 32 bytes SHA256 of the RouterInfo of the router this reply was sent from 참고: - \u0026lsquo;from\u0026rsquo; 해시는 인증되지 않았으며 신뢰할 수 없다 - 반환된 피어 해시는 쿼리 중인 router보다 키에 더 가까울 필요는 없다. 일반 조회에 대한 응답의 경우, 새로운 floodfills(특수 역할의 router)를 발견하고 견고성을 위해 \u0026ldquo;역방향\u0026rdquo; 검색(키에서 더 먼 방향)을 수행하는 데 도움이 된다 - 탐색 조회의 경우, 키는 보통 무작위로 생성된다. 응답의 floodfill이 아닌 peer_hashes는 로컬 전체 데이터베이스의 비효율적인 정렬을 피하기 위해 최적화된 알고리즘(예: 가깝지만 반드시 가장 가까운 피어일 필요는 없는 피어들)을 사용해 선택될 수 있다. 캐싱 전략을 사용할 수도 있다. 이는 구현에 따라 달라진다 - 반환되는 해시의 일반적인 개수: 3 - 반환할 해시의 권장 최대 개수: 16 - 조회 키, 피어 해시, 그리고 from 해시는 \u0026ldquo;실제\u0026rdquo; 해시이며, 라우팅 키가 아니다 - num이 0이면, 더 가까운 피어를 찾지 못했음을 의미한다(막다른 지점)\n소스 코드: - net.i2p.data.i2np.DatabaseSearchReplyMessage\nDeliveryStatus(전달 상태) (유형 10) Purpose: 간단한 메시지 수신 확인. 일반적으로 메시지 발신자가 생성하며, 메시지 자체와 함께 Garlic Message(여러 메시지를 묶어 전달하는 I2P 메시지 형식)로 감싸 목적지에서 회신되도록 한다.\n내용: 전달된 메시지의 ID와 생성 시간 또는 도착 시간.\n형식:\n+----+----+----+----+----+----+----+----+----+----+----+----+ | msg_id (4) | time_stamp (8) | +----+----+----+----+----+----+----+----+----+----+----+----+ msg_id :: Integer (4 bytes) Unique ID of the message we deliver the DeliveryStatus for (see I2NP Message Header for details) time_stamp :: Date (8 bytes) Time the message was successfully created or delivered 참고: - 타임스탬프는 작성자가 항상 현재 시간으로 설정합니다. 하지만 코드에서 이 타임스탬프가 여러 용도로 사용되고 있으며, 앞으로 더 추가될 수 있습니다 - 이 메시지는 SSU에서 세션 수립 확인 용도로도 사용됩니다. 이 경우 메시지 ID는 무작위 값으로 설정되고, \u0026ldquo;도착 시간\u0026quot;은 현재 네트워크 전역 ID인 2로 설정됩니다(즉, 0x0000000000000002) - DeliveryStatus(전달 상태 메시지)는 일반적으로 GarlicMessage(갈릭 메시지)에 래핑되어 tunnel을 통해 전송되며, 발신자를 드러내지 않고 수신 확인을 제공합니다 - tunnel 테스트에 사용되어 지연 시간과 신뢰성을 측정합니다\n소스 코드: - net.i2p.data.i2np.DeliveryStatusMessage - 사용 위치: net.i2p.router.tunnel.InboundEndpointProcessor tunnel 테스트를 위해\nGarlicMessage(갈릭 메시지) (Type 11) 경고: 이것은 ElGamal로 암호화된 garlic messages(여러 메시지를 하나로 묶어 전달하는 I2P 방식)에 사용되는 형식입니다. ECIES-AEAD-X25519-Ratchet garlic messages의 형식은 현저히 다릅니다. 최신 형식은 ECIES Specification 을 참조하세요.\n목적: 여러 개의 암호화된 I2NP 메시지를 감싸는 데 사용됩니다.\n내용: 복호화되면 일련의 Garlic Cloves(개별 메시지 단위)와 추가 데이터로 구성되며, Clove Set(클로브 집합)이라고도 한다.\n암호화된 형식:\n+----+----+----+----+----+----+----+----+ | length (4) | data | +----+----+----+----+----+ + | | ~ ~ | | +----+----+----+----+----+----+----+----+ length :: 4 byte Integer Number of bytes that follow (0 to 64 KB) data :: $length bytes ElGamal encrypted data 복호화된 데이터 (Clove Set, 클로브 집합):\n+----+----+----+----+----+----+----+----+ | num| clove 1 (variable) | +----+ + | | ~ ~ | | +----+----+----+----+----+----+----+----+ | clove 2 (variable) | ~ ~ | | +----+----+----+----+----+----+----+----+ | Certificate (3) | Message_ID (4) | +----+----+----+----+----+----+----+----+ Expiration (8) | +----+----+----+----+----+----+----+----+ num :: 1 byte Integer Number of GarlicCloves to follow clove :: GarlicClove (see GarlicClove structure above) Certificate :: Always NULL (3 bytes total, all zeroes) Message_ID :: 4 byte Integer Expiration :: Date (8 bytes) ECIES-X25519-AEAD-Ratchet 형식 (routers용 현재 표준)의 경우:\nECIES 명세 및 제안 144 를 참조하십시오.\n소스 코드: - net.i2p.data.i2np.GarlicMessage - 암호화: net.i2p.crypto.elgamal.ElGamalAESEngine (사용 중단됨) - 최신 암호화: net.i2p.crypto.ECIES 패키지\nTunnelData (유형 18) 목적: tunnel의 게이트웨이 또는 참가자가 다음 참가자 또는 엔드포인트로 보내는 메시지. 데이터는 고정 길이이며, 분할·배치·패딩 처리되어 암호화된 I2NP 메시지를 포함한다.\n형식:\n+----+----+----+----+----+----+----+----+ | tunnelID (4) | data (1024) | +----+----+----+----+----+ + | | ~ ~ | | + +----+----+----+----+ | | +----+----+----+----+ tunnelId :: 4 bytes TunnelId identifying the tunnel this message is directed at Nonzero data :: 1024 bytes Payload data, fixed to 1024 bytes 페이로드 구조 (1024바이트):\nBytes 0-15: Initialization Vector (IV) for AES encryption Bytes 16-1023: Encrypted tunnel message data (1008 bytes) 참고: - TunnelData에 대한 I2NP 메시지 ID는 각 홉마다 새로운 난수로 설정됩니다 - 암호화된 데이터 내부의 tunnel 메시지 형식은 Tunnel Message Specification 에 정의되어 있습니다 - 각 홉은 CBC 모드의 AES-256을 사용해 한 겹을 복호화합니다 - 복호화된 데이터를 사용하여 각 홉에서 IV(초기화 벡터)가 갱신됩니다 - 전체 크기는 정확히 1,028 바이트입니다(4 tunnelId + 1024 data) - 이는 tunnel 트래픽의 기본 단위입니다 - TunnelData 메시지는 분할된 I2NP 메시지(GarlicMessage, DatabaseStore 등)를 운반합니다\n소스 코드: - net.i2p.data.i2np.TunnelDataMessage - 상수: TunnelDataMessage.DATA_LENGTH = 1024 - 처리: net.i2p.router.tunnel.InboundGatewayProcessor\nTunnelGateway (유형 19) 목적: 다른 I2NP 메시지를 감싸, 해당 tunnel의 인바운드 게이트웨이에서 tunnel로 전송되도록 한다.\n형식:\n+----+----+----+----+----+----+----+-// | tunnelId (4) | length (2)| data... +----+----+----+----+----+----+----+-// tunnelId :: 4 bytes TunnelId identifying the tunnel this message is directed at Nonzero length :: 2 byte Integer Length of the payload data :: $length bytes Actual payload of this message 참고: - 페이로드는 표준 16바이트 헤더를 가진 I2NP 메시지입니다 - 로컬 router에서 여러 tunnel로 메시지를 주입하는 데 사용됩니다 - 필요한 경우 게이트웨이가 포함된 메시지를 조각화합니다 - 조각화 후, 조각들은 TunnelData 메시지로 래핑됩니다 - TunnelGateway는 네트워크를 통해 전송되지 않습니다; 이는 tunnel 처리 이전에 사용되는 내부 메시지 유형입니다\n소스 코드: - net.i2p.data.i2np.TunnelGatewayMessage - 처리: net.i2p.router.tunnel.OutboundGatewayProcessor\nDataMessage(데이터 메시지) (유형 20) 목적: Garlic Messages(갈릭 메시지)와 Garlic Cloves(갈릭 클로브)에서 임의의 데이터(보통 종단 간 암호화된 애플리케이션 데이터)를 캡슐화하는 데 사용됩니다.\n형식:\n+----+----+----+----+----+----+-//-+ | length (4) | data... | +----+----+----+----+----+----+-//-+ length :: 4 bytes Length of the payload data :: $length bytes Actual payload of this message 참고: - 이 메시지에는 라우팅 정보가 없으며 결코 \u0026ldquo;unwrapped\u0026rdquo; 상태로 전송되지 않습니다 - Garlic messages(갈릭 메시지, garlic encryption에서 사용되는 메시지 단위) 내부에서만 사용됩니다 - 일반적으로 종단 간 암호화된 애플리케이션 데이터(HTTP, IRC, email 등)를 포함합니다 - 데이터는 보통 ElGamal/AES 또는 ECIES로 암호화된 페이로드입니다 - tunnel 메시지 단편화 한계로 인해 실사용 가능한 최대 길이는 약 61.2 KB입니다\n소스 코드: - net.i2p.data.i2np.DataMessage\nTunnelBuild (유형 21) 사용 중단됨. VariableTunnelBuild (type 23) 또는 ShortTunnelBuild (type 25)를 사용하세요.\n목적: 8홉을 위한 고정 길이 tunnel 빌드 요청.\n형식:\n+----+----+----+----+----+----+----+----+ | Record 0 (528 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ | Record 1 (528 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ | Record 7 (528 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ Just 8 BuildRequestRecords attached together Record size: 528 bytes Total size: 8 × 528 = 4,224 bytes 참고: - 0.9.48 기준으로 ECIES-X25519 BuildRequestRecords(tunnel 빌드 요청 레코드)를 포함할 수 있습니다. ECIES Tunnel 생성 - 자세한 내용은 Tunnel 생성 사양 을 참조하세요 - 이 메시지의 I2NP 메시지 ID는 tunnel 생성 사양에 따라 설정되어야 합니다 - 오늘날의 네트워크에서는 드물게 보이지만(VariableTunnelBuild(가변 길이 tunnel 빌드 메시지 유형)로 대체됨), 매우 긴 tunnel에서는 여전히 사용될 수 있으며 공식적으로 사용 중단(deprecated)되지는 않았습니다 - Routers는 호환성을 위해 여전히 이를 구현해야 합니다 - 고정 8-레코드 형식은 유연성이 떨어지며 더 짧은 tunnel에서는 대역폭을 낭비합니다\n소스 코드: - net.i2p.data.i2np.TunnelBuildMessage - 상수: TunnelBuildMessageBase.MAX_RECORD_COUNT = 8\nTunnelBuildReply (유형 22) 사용 중단됨. VariableTunnelBuildReply (type 24) 또는 OutboundTunnelBuildReply (type 26)를 사용하세요.\n목적: 8 홉용 고정 길이 tunnel 구축 응답.\n형식:\nTunnelBuildMessage와 동일한 형식이며, BuildRequestRecords 대신 BuildResponseRecords를 사용합니다.\nTotal size: 8 × 528 = 4,224 bytes 참고: - 0.9.48 기준, ECIES-X25519 BuildResponseRecords(빌드 응답 레코드)를 포함할 수 있습니다. ECIES Tunnel 생성 을 참조하세요 - 자세한 내용은 Tunnel 생성 명세 를 참조하세요 - 이 메시지의 I2NP 메시지 ID는 tunnel 생성 명세에 따라 설정되어야 합니다 - 오늘날의 네트워크에서는 드물게 보이지만(VariableTunnelBuildReply(가변 Tunnel 빌드 응답)로 대체됨), 매우 긴 tunnel에서는 여전히 사용될 수 있으며 공식적으로 사용 중단으로 지정되지는 않았습니다 - 호환성을 위해 Routers는 여전히 이를 구현해야 합니다\n소스 코드: - net.i2p.data.i2np.TunnelBuildReplyMessage\nVariableTunnelBuild (유형 23) 목적: 1~8 홉에 대한 가변 길이 tunnel 구축. ElGamal 및 ECIES-X25519 routers 모두를 지원합니다.\n형식:\n+----+----+----+----+----+----+----+----+ | num| BuildRequestRecords (variable) | +----+----+----+----+----+----+----+----+ num :: 1 byte Integer Valid values: 1-8 BuildRequestRecords :: $num records of 528 bytes each Record size: 528 bytes Total size: 1 + ($num × 528) bytes 참고: - 0.9.48 기준, ECIES-X25519 BuildRequestRecords(ECIES-X25519 기반 빌드 요청 레코드)을 포함할 수 있습니다. ECIES Tunnel 생성 - router 버전 0.7.12(2009)에서 도입 - 0.7.12 이전 버전의 tunnel 참가자에게는 전송되지 않을 수 있습니다 - 자세한 내용은 Tunnel Creation 명세 를 참조하십시오 - I2NP 메시지 ID는 tunnel 생성 명세에 따라 설정되어야 합니다 - 일반적인 레코드 수: 4 (4-hop tunnel의 경우) - 일반적인 총 크기: 1 + (4 × 528) = 2,113 바이트 - 이것은 ElGamal router용 표준 tunnel 빌드 메시지입니다 - ECIES router는 일반적으로 ShortTunnelBuild(type 25)(짧은 tunnel 빌드)를 대신 사용합니다\n소스 코드: - net.i2p.data.i2np.VariableTunnelBuildMessage\nVariableTunnelBuildReply (유형 24) 목적: 1~8홉용 가변 길이 tunnel 빌드 응답. ElGamal 및 ECIES-X25519 routers를 모두 지원합니다.\n형식:\nBuildRequestRecords 대신 BuildResponseRecords를 사용하는 점을 제외하면 VariableTunnelBuildMessage와 동일한 형식입니다.\n+----+----+----+----+----+----+----+----+ | num| BuildResponseRecords (variable) | +----+----+----+----+----+----+----+----+ num :: 1 byte Integer Valid values: 1-8 BuildResponseRecords :: $num records of 528 bytes each Record size: 528 bytes Total size: 1 + ($num × 528) bytes 참고: - 0.9.48 기준, ECIES-X25519 BuildResponseRecords(빌드 응답 레코드) 를 포함할 수 있습니다. ECIES Tunnel Creation 을 참조하세요 - router 버전 0.7.12(2009)에서 도입됨 - 버전 0.7.12 이전의 tunnel 참가자에게는 전송되지 않을 수 있습니다 - 자세한 내용은 Tunnel Creation Specification 을 참조하세요 - I2NP 메시지 ID는 tunnel 생성 사양에 따라 설정해야 합니다 - 일반적인 레코드 수: 4 - 일반적인 총 크기: 2,113 바이트\n소스 코드: - net.i2p.data.i2np.VariableTunnelBuildReplyMessage\nShortTunnelBuild (유형 25) 목적: ECIES-X25519 routers 전용의 짧은 tunnel 구축 메시지. API 버전 0.9.51(릴리스 1.5.0, 2021년 8월)에 도입됨. 이는 ECIES tunnel 구축의 현재 표준입니다.\n형식:\n+----+----+----+----+----+----+----+----+ | num| ShortBuildRequestRecords (var) | +----+----+----+----+----+----+----+----+ num :: 1 byte Integer Valid values: 1-8 ShortBuildRequestRecords :: $num records of 218 bytes each Record size: 218 bytes Total size: 1 + ($num × 218) bytes 참고: - router 버전 0.9.51(릴리스 1.5.0, 2021년 8월)에 도입 - API 버전 0.9.51 미만의 tunnel 참가자에게는 전송되지 않을 수 있음 - 전체 사양은 ECIES Tunnel Creation 참조 - 설계 근거는 Proposal 157 참조 - 일반적인 레코드 수: 4 - 일반적인 총 크기: 1 + (4 × 218) = 873 바이트 - 대역폭 절감: VariableTunnelBuild 대비 59% 작음(873 대 2,113 바이트) - 성능 이점: 짧은 레코드 4개가 하나의 tunnel 메시지에 들어감; VariableTunnelBuild는 3개의 tunnel 메시지가 필요함 - 이는 현재 순수 ECIES-X25519 tunnel에 대한 표준 tunnel 빌드 형식임 - 레코드는 키를 명시적으로 포함하는 대신 HKDF(키 파생 함수)를 통해 파생함\n소스 코드: - net.i2p.data.i2np.ShortTunnelBuildMessage - 상수: ShortEncryptedBuildRecord.RECORD_SIZE = 218\nOutboundTunnelBuildReply (유형 26) Purpose: 새로 생성된 tunnel의 아웃바운드 엔드포인트에서 생성자에게 전송됩니다. ECIES-X25519 routers 전용입니다. API 버전 0.9.51에서 도입되었습니다(릴리스 1.5.0, 2021년 8월).\n형식:\nShortTunnelBuildMessage와 동일한 형식이며, ShortBuildRequestRecords 대신 ShortBuildResponseRecords를 사용합니다.\n+----+----+----+----+----+----+----+----+ | num| ShortBuildResponseRecords (var) | +----+----+----+----+----+----+----+----+ num :: 1 byte Integer Valid values: 1-8 ShortBuildResponseRecords :: $num records of 218 bytes each Record size: 218 bytes Total size: 1 + ($num × 218) bytes 참고: - router 버전 0.9.51에 도입됨(릴리스 1.5.0, 2021년 8월) - 전체 사양은 ECIES Tunnel 생성 을 참조하십시오 - 일반적인 레코드 수: 4 - 일반적인 전체 크기: 873 바이트 - 이 응답은 새로 생성된 outbound tunnel을 통해 outbound endpoint(OBEP, 아웃바운드 엔드포인트)에서 tunnel 생성자로 되돌려 전송됩니다 - 모든 홉이 tunnel 구축을 수락했음을 확인합니다\n소스 코드: - net.i2p.data.i2np.OutboundTunnelBuildReplyMessage\n참고 자료 공식 명세 I2NP 사양 - I2NP 메시지 형식의 완전한 사양 공통 구조 - I2P 전반에서 사용되는 데이터 타입과 구조 tunnel 생성 - ElGamal tunnel 생성(사용 중단됨) ECIES tunnel 생성 - ECIES-X25519 tunnel 생성(현재) tunnel 메시지 - tunnel 메시지 형식 및 전달 지침 NTCP2 사양 - TCP 전송 프로토콜 SSU2 사양 - UDP 전송 프로토콜 ECIES 사양 - ECIES-X25519-AEAD-Ratchet 암호화 암호학 사양 - 저수준 암호 프리미티브 I2CP 사양 - 클라이언트 프로토콜 사양 데이터그램 사양 - Datagram2 및 Datagram3 형식 제안서 제안 123 - 새로운 netDB 항목 (LeaseSet2, EncryptedLeaseSet, MetaLeaseSet) 제안 144 - ECIES-X25519-AEAD-Ratchet 암호화 제안 154 - 암호화된 데이터베이스 조회 제안 156 - ECIES routers 제안 157 - 더 작은 tunnel 빌드 메시지 (짧은 형식) 제안 159 - SSU2 트랜스포트 제안 161 - 압축 가능한 패딩 제안 163 - Datagram2 및 Datagram3 제안 167 - LeaseSet 서비스 레코드 매개변수 제안 168 - tunnel 빌드 대역폭 매개변수 제안 169 - 포스트-양자 하이브리드 암호기술 문서 Garlic 라우팅 - 계층화된 메시지 번들링 ElGamal/AES - 사용 중단된 암호화 방식 Tunnel 구현 - 단편화 및 처리 네트워크 데이터베이스 - 분산 해시 테이블 NTCP2 전송 - TCP 전송 명세 SSU2 전송 - UDP 전송 명세 기술 소개 - I2P 아키텍처 개요 소스 코드 Java I2P 저장소 - 공식 Java 구현 GitHub 미러 - Java I2P의 GitHub 미러 i2pd 저장소 - C++ 구현 주요 소스 코드 위치 Java I2P (i2pgit.org/I2P_Developers/i2p.i2p): - core/java/src/net/i2p/data/i2np/ - I2NP 메시지 구현 - core/java/src/net/i2p/crypto/ - 암호화 구현 - router/java/src/net/i2p/router/tunnel/ - Tunnel 처리 - router/java/src/net/i2p/router/transport/ - 전송 구현\n상수와 값: - I2NPMessage.MAX_SIZE = 65536 - I2NP 메시지 최대 크기 - I2NPMessageImpl.HEADER_LENGTH = 16 - 표준 헤더 크기 - TunnelDataMessage.DATA_LENGTH = 1024 - tunnel 메시지 페이로드 - EncryptedBuildRecord.RECORD_SIZE = 528 - 긴 빌드 레코드 - ShortEncryptedBuildRecord.RECORD_SIZE = 218 - 짧은 빌드 레코드 - TunnelBuildMessageBase.MAX_RECORD_COUNT = 8 - 빌드당 최대 레코드 수\n부록 A: 네트워크 통계 및 현재 상태 네트워크 구성 (2025년 10월 기준) 총 routers: 약 60,000-70,000 (변동) Floodfill routers: 약 500-700개 활성 상태 암호화 유형: ECIES-X25519: routers 중 \u0026gt;95% ElGamal: routers 중 \u0026lt;5% (더 이상 사용되지 않음, 레거시 전용) 전송 채택 현황: SSU2: \u0026gt;60% 주요 전송 NTCP2: ~40% 주요 전송 레거시 전송(SSU1, NTCP): 0% (제거됨) 서명 유형: EdDSA (Ed25519): 대다수 ECDSA: 소수 RSA: 허용되지 않음 (제거됨) 최소 Router 요구 사항 API 버전: 0.9.16+ (네트워크와의 EdDSA 호환성 확보용) 권장 최소: API 0.9.51+ (ECIES 짧은 tunnel 빌드) floodfills(메타데이터를 전파하는 특수 노드)용 현재 최소: API 0.9.58+ (ElGamal router 사용 중단) 예정 요구사항: Java 17+ (릴리스 2.11.0 기준, 2025년 12월) 대역폭 요구 사항 최소: floodfill(네트워크 데이터베이스를 유포하는 특수 노드)용 128 KBytes/sec (N 플래그 이상) 권장: 256 KBytes/sec (O 플래그) 이상 Floodfill 요구 사항: 최소 128 KB/sec 대역폭 안정적인 가동 시간(\u0026gt;95% 권장) 낮은 지연 시간(피어까지 \u0026lt;500ms) 상태 검사 통과(대기열 시간, 작업 지연) Tunnel 통계 일반적인 tunnel 길이: 3-4 홉 최대 tunnel 길이: 8 홉 (이론상, 거의 사용되지 않음) 일반적인 tunnel 수명: 10분 tunnel 구축 성공률: 연결성이 좋은 router의 경우 \u0026gt;85% tunnel 구축 메시지 형식: ECIES(타원곡선 통합 암호화 방식) router: ShortTunnelBuild (218바이트 레코드) 혼합 tunnel: VariableTunnelBuild (528바이트 레코드) 성능 지표 Tunnel 구축 시간: 1-3초 (일반적) 엔드 투 엔드 지연: 0.5-2초 (일반적, 총 6-8 홉) 처리량: tunnel 대역폭에 의해 제한됨 (일반적으로 tunnel당 10-50 KB/sec) 최대 데이터그램 크기: 10 KB 권장 (이론상 최대 61.2 KB) 부록 B: 사용 중단 및 제거된 기능 완전히 제거됨 (더 이상 지원되지 않음) NTCP 전송 - 0.9.50 릴리스에서 제거됨 (2021년 5월) SSU v1 전송 - Java I2P의 2.4.0 릴리스에서 제거됨 (2023년 12월) SSU v1 전송 - i2pd의 2.44.0 릴리스에서 제거됨 (2022년 11월) RSA 서명 유형 - API 0.9.28부터 허용되지 않음 사용 중단됨(지원되지만 권장하지 않음) ElGamal routers - API 0.9.58 (2023년 3월)부터 사용 중단됨 ElGamal 목적지는 이전 버전과의 호환성을 위해 여전히 지원됨 새로운 routers는 ECIES-X25519만 사용해야 함 TunnelBuild (type 21) - VariableTunnelBuild 및 ShortTunnelBuild로 대체되어 사용 중단됨 매우 긴 tunnels (\u0026gt;8 홉)에는 여전히 구현되어 있음 TunnelBuildReply (type 22) - VariableTunnelBuildReply 및 OutboundTunnelBuildReply로 대체되어 사용 중단됨 ElGamal/AES encryption - ECIES-X25519-AEAD-Ratchet로 대체되어 사용 중단됨 레거시 목적지에서는 여전히 사용됨 Long ECIES BuildRequestRecords (528 bytes) - 짧은 형식 (218 바이트)으로 대체되어 사용 중단됨 ElGamal 홉이 포함된 혼합 tunnels에서는 여전히 사용됨 레거시 지원 일정 Feature Introduced Deprecated Removed Notes NTCP 2003 2018 (0.9.36) 2021 (0.9.50) Replaced by NTCP2 SSU v1 2004 2022 (0.9.54) 2023 (Java) / 2022 (i2pd) Replaced by SSU2 ElGamal routers 2003 2023 (0.9.58) TBD Destinations still supported RSA signatures 2015 2017 2017 (0.9.28) Never widely used TunnelBuild 2004 2009 (0.7.12) Not removed Still supported for long tunnels --- 부록 C: 향후 개발 양자내성 암호 상태: 2.10.0 릴리스(2025년 9월) 기준 베타이며, 2.11.0(2025년 12월)부터 기본 설정이 됩니다\n구현: - 전통적인 X25519와 포스트-양자 MLKEM (ML-KEM-768)을 결합한 하이브리드 접근 방식 - 기존 ECIES-X25519 인프라와 하위 호환 - 전통적인 및 포스트-양자(PQ) 키 자료를 모두 사용하는 Signal Double Ratchet(이중 래칫 프로토콜) 사용 - 자세한 내용은 Proposal 169 를 참조하세요\n마이그레이션 경로: 1. 릴리스 2.10.0 (2025년 9월): 베타 옵션으로 제공 2. 릴리스 2.11.0 (2025년 12월): 기본적으로 활성화 3. 향후 릴리스: 결국 필수\n계획된 기능 IPv6 개선 - 향상된 IPv6 지원과 전환 메커니즘 tunnel별 스로틀링 - 세밀한 tunnel별 대역폭 제어 향상된 메트릭 - 더 나은 성능 모니터링과 진단 프로토콜 최적화 - 오버헤드 감소와 효율성 향상 향상된 floodfill 선택 - 더 나은 네트워크 데이터베이스 분산 연구 분야 Tunnel 길이 최적화 - 위협 모델 기반의 동적 Tunnel 길이 고급 패딩 - 트래픽 분석 저항성 개선 새로운 암호화 방식 - 양자 컴퓨팅 위협 대비 혼잡 제어 - 네트워크 부하 처리 개선 모바일 지원 - 모바일 기기와 네트워크를 위한 최적화 부록 D: 구현 지침 새로운 구현을 위한 최소 요구 사항: 1. API 버전 0.9.51+ 기능 지원 2. ECIES-X25519-AEAD-Ratchet 암호화 구현 3. NTCP2 및 SSU2 transports(전송 프로토콜) 지원 4. ShortTunnelBuild 메시지 구현(218바이트 레코드) 5. LeaseSet2 변형 지원(유형 3, 5, 7) 6. EdDSA 서명 사용(Ed25519)\n권장: 1. 포스트-양자 하이브리드 암호 지원(2.11.0 기준) 2. tunnel별 대역폭 매개변수 구현 3. Datagram2 및 Datagram3 형식 지원(개선된 I2P 데이터그램 형식 버전 2/3) 4. LeaseSets에서 서비스 레코드 옵션 구현 5. /docs/specs/의 공식 사양 준수\n필수 아님: 1. ElGamal router 지원 (사용 중단됨) 2. 레거시 트랜스포트 지원 (SSU1, NTCP) 3. 긴 ECIES BuildRequestRecords(빌드 요청 레코드; 순수 ECIES tunnels의 경우 528바이트) 4. TunnelBuild/TunnelBuildReply 메시지 (Variable 또는 Short 변형 사용)\n테스트 및 검증 프로토콜 준수: 1. 공식 Java I2P router와 상호운용성 테스트 2. i2pd C++ router와 상호운용성 테스트 3. 명세에 따른 메시지 형식 검증 4. tunnel 구축/해제 사이클 테스트 5. 테스트 벡터로 암호화/복호화 검증\n성능 테스트: 1. tunnel 구축 성공률을 측정(85% 초과여야 함) 2. 다양한 tunnel 길이(2-8홉)로 테스트 3. 단편화와 재조립을 검증 4. 부하 상태에서 테스트(동시에 여러 개의 tunnel) 5. 종단 간 지연시간을 측정\n보안 테스트: 1. 암호화 구현을 검증 (테스트 벡터 사용) 2. 리플레이 공격 방지 기능을 테스트 3. 메시지 만료 처리의 유효성 검증 4. 잘못 형식화된 메시지에 대한 테스트 5. 난수 생성이 적절한지 검증\n구현 시 흔한 함정 혼란스러운 전달 지시 형식 - garlic clove(garlic encryption에서 단일 메시지 조각) vs tunnel 메시지 잘못된 키 도출 - 짧은 빌드 레코드를 위한 HKDF 사용 메시지 ID 처리 - tunnel 빌드에서 올바르게 설정하지 않음 분할 문제 - 61.2 KB의 실질적 한계를 준수하지 않음 엔디언 오류 - Java는 모든 정수에 big-endian을 사용함 만료 처리 - Short 형식은 2106년 2월 7일에 순환(wrap)됨 체크섬 생성 - 검증하지 않더라도 여전히 필요함 ","description":"I2P 내부의 router 간 메시지 형식, 우선순위 및 크기 제한","id":"917124900b0896942323b4effccf9b55","section":"docs","title":"I2P 네트워크 프로토콜 (I2NP)","url":"/ko/docs/specs/i2np/"},{"categories":null,"content":"Reseed 호스트는 I2P 네트워크의 핵심 인프라로, 부트스트랩 과정에서 새로운 router에게 초기 노드 그룹을 제공합니다. 이 가이드는 자체 reseed 서버를 설정하고 운영하는 방법을 안내합니다.\nI2P Reseed 서버란 무엇인가? I2P 리시드 서버는 다음과 같은 방식으로 새로운 router가 I2P 네트워크에 통합되도록 돕습니다:\n초기 피어 발견 제공: 새로운 라우터가 연결할 네트워크 노드의 초기 집합을 받습니다 부트스트랩 복구: 연결 유지에 어려움을 겪는 라우터를 지원합니다 안전한 배포: 리시딩 프로세스는 네트워크 보안을 보장하기 위해 암호화되고 디지털 서명됩니다 새로운 I2P router가 처음 시작될 때(또는 모든 피어 연결을 잃었을 때), 초기 router 정보 세트를 다운로드하기 위해 reseed 서버에 접속합니다. 이를 통해 새로운 router는 자체 netDb를 구축하고 tunnel을 설정할 수 있습니다.\n사전 요구 사항 시작하기 전에 필요한 사항:\nroot 액세스 권한이 있는 Linux 서버 (Debian/Ubuntu 권장) 서버를 가리키는 도메인 이름 최소 1GB RAM 및 10GB 디스크 공간 network database를 채우기 위해 서버에서 실행 중인 I2P router Linux 시스템 관리에 대한 기본 지식 서버 준비하기 Step 1: Update System and Install Dependencies 먼저 시스템을 업데이트하고 필요한 패키지를 설치하세요:\nsudo apt update \u0026amp;\u0026amp; sudo apt upgrade -y \u0026amp;\u0026amp; sudo apt-get install golang-go git make docker.io docker-compose -y 이것은 다음을 설치합니다: - golang-go: Go 프로그래밍 언어 런타임 - git: 버전 관리 시스템 - make: 빌드 자동화 도구 - docker.io \u0026amp; docker-compose: Nginx Proxy Manager 실행을 위한 컨테이너 플랫폼\nStep 2: Clone and Build Reseed Tools reseed-tools 저장소를 복제하고 애플리케이션을 빌드하세요:\ncd /home/i2p git clone https://i2pgit.org/idk/reseed-tools cd reseed-tools make build sudo make install reseed-tools 패키지는 reseed 서버 실행을 위한 핵심 기능을 제공합니다. 다음을 처리합니다: - 로컬 netDb에서 router 정보 수집 - router info를 서명된 SU3 파일로 패키징 - HTTPS를 통해 이러한 파일 제공\nStep 3: Generate SSL Certificate reseed 서버의 SSL 인증서와 개인 키를 생성하세요:\nsu - i2p -c \u0026#39;reseed-tools reseed --signer=admin@stormycloud.org --netdb=/home/i2p/.i2p/netDb --port=8443 --ip=127.0.0.1 --trustProxy\u0026#39; 중요한 매개변수: - --signer: 귀하의 이메일 주소 (admin@stormycloud.org를 자신의 이메일로 교체) - --netdb: I2P router의 네트워크 데이터베이스 경로 - --port: 내부 포트 (8443 권장) - --ip: localhost에 바인딩 (공개 접근을 위해 리버스 프록시 사용 예정) - --trustProxy: 리버스 프록시로부터의 X-Forwarded-For 헤더 신뢰\n이 명령은 다음을 생성합니다: - SU3 파일 서명을 위한 개인 키 - 안전한 HTTPS 연결을 위한 SSL 인증서\n1단계: 시스템 업데이트 및 의존성 설치 중요: /home/i2p/.reseed/에 있는 생성된 키를 안전하게 백업하세요:\nsudo tar -czf reseed-keys-backup.tar.gz /home/i2p/.reseed/ 이 백업을 제한된 접근 권한이 있는 안전하고 암호화된 위치에 저장하세요. 이 키들은 reseed 서버 운영에 필수적이며 신중하게 보호해야 합니다.\nConfiguring the Service 2단계: Reseed 도구 복제 및 빌드 systemd 서비스를 생성하여 reseed 서버를 자동으로 실행하세요:\nsudo tee /etc/systemd/system/reseed.service \u0026lt;\u0026lt;EOF [Unit] Description=Reseed Service After=network.target [Service] User=i2p WorkingDirectory=/home/i2p ExecStart=/bin/bash -c \u0026#39;reseed-tools reseed --signer=admin@stormycloud.org --netdb=/home/i2p/.i2p/netDb --port=8443 --ip=127.0.0.1 --trustProxy\u0026#39; Restart=always RestartSec=10 [Install] WantedBy=multi-user.target EOF 반드시 admin@stormycloud.org를 본인의 이메일 주소로 교체하세요.\n이제 서비스를 활성화하고 시작합니다:\nsudo systemctl daemon-reload sudo systemctl enable reseed sudo systemctl start reseed 서비스가 실행 중인지 확인하세요:\nsudo systemctl status reseed 단계 3: SSL 인증서 생성 최적의 성능을 위해 라우터 정보를 새로 고치기 위해 reseed 서비스를 주기적으로 재시작하는 것이 좋습니다:\nsudo crontab -e 서비스를 3시간마다 재시작하려면 다음 줄을 추가하세요:\n0 */3 * * * systemctl restart reseed Setting Up Reverse Proxy reseed 서버는 localhost:8443에서 실행되며 공개 HTTPS 트래픽을 처리하기 위해 리버스 프록시가 필요합니다. 사용 편의성을 위해 Nginx Proxy Manager를 권장합니다.\n4단계: 키 백업하기 Docker를 사용하여 Nginx Proxy Manager 배포:\ndocker run -d \\ --name nginx-proxy-manager \\ -p 80:80 \\ -p 81:81 \\ -p 443:443 \\ -v $(pwd)/data:/data \\ -v $(pwd)/letsencrypt:/etc/letsencrypt \\ --restart unless-stopped \\ jc21/nginx-proxy-manager:latest 이것은 다음을 노출합니다: - 포트 80: HTTP 트래픽 - 포트 81: 관리자 인터페이스 - 포트 443: HTTPS 트래픽\nConfigure Proxy Manager http://your-server-ip:81에서 관리자 인터페이스에 접속합니다\n기본 자격 증명으로 로그인:\n이메일: admin@example.com 비밀번호: changeme 중요: 최초 로그인 후 즉시 이 인증 정보를 변경하세요!\nProxy Hosts로 이동하여 Add Proxy Host를 클릭합니다 프록시 호스트 설정: Domain Name: 리시드 도메인 (예: reseed.example.com) Scheme: https Forward Hostname / IP: 127.0.0.1 Forward Port: 8443 Cache Assets 활성화 Block Common Exploits 활성화 Websockets Support 활성화 SSL 탭에서: Request a new SSL Certificate (Let\u0026rsquo;s Encrypt) 선택 Force SSL 활성화 HTTP/2 Support 활성화 Let\u0026rsquo;s Encrypt 서비스 약관 동의 저장 클릭 이제 리시드 서버가 https://reseed.example.com에서 접근 가능해야 합니다\nRegistering Your Reseed Server reseed 서버가 작동하면 I2P 개발자에게 연락하여 공식 reseed 서버 목록에 추가되도록 하세요.\n5단계: Systemd 서비스 생성 zzz (I2P 수석 개발자)에게 다음 정보를 이메일로 보내세요:\nI2P 이메일: zzz@mail.i2p 일반 인터넷 이메일: zzz@i2pmail.org 6단계: 선택 사항 - 주기적 재시작 구성 이메일에 다음을 포함하세요:\nReseed 서버 URL: 전체 HTTPS URL (예: https://reseed.example.com) 공개 reseed 인증서: /home/i2p/.reseed/에 위치 (.crt 파일 첨부) 연락처 이메일: 서버 유지보수 알림을 위한 선호하는 연락 방법 서버 위치: 선택 사항이지만 유용함 (국가/지역) 예상 가동 시간: 서버 유지에 대한 귀하의 약속 Verification I2P 개발자들은 귀하의 리시드 서버가 다음을 충족하는지 확인할 것입니다: - 적절히 구성되어 있고 router 정보를 제공하고 있는지 - 유효한 SSL 인증서를 사용하고 있는지 - 올바르게 서명된 SU3 파일을 제공하고 있는지 - 접근 가능하고 응답하는지\n승인되면, 귀하의 리시드 서버가 I2P router와 함께 배포되는 목록에 추가되어 새로운 사용자들이 네트워크에 참여하는 데 도움이 됩니다!\nMonitoring and Maintenance Nginx Proxy Manager 설치 reseed 서비스를 모니터링하세요:\nsudo systemctl status reseed sudo journalctl -u reseed -f 프록시 관리자 구성 시스템 리소스를 주시하세요:\nhtop df -h Update Reseed Tools 최신 개선 사항을 받기 위해 주기적으로 reseed-tools를 업데이트하세요:\ncd /home/i2p/reseed-tools git pull make build sudo make install sudo systemctl restart reseed 연락처 정보 Nginx Proxy Manager를 통해 Let\u0026rsquo;s Encrypt를 사용하는 경우, 인증서가 자동으로 갱신됩니다. 갱신이 정상적으로 작동하는지 확인하세요:\ndocker logs nginx-proxy-manager | grep -i certificate 서비스 구성 필수 정보 오류 확인을 위한 로그 검사:\nsudo journalctl -u reseed -n 50 일반적인 문제: - I2P router가 실행되지 않았거나 netDb가 비어있음 - 8443 포트가 이미 사용 중 - /home/i2p/.reseed/ 디렉토리에 대한 권한 문제\n검증 I2P router가 실행 중이고 네트워크 데이터베이스가 채워져 있는지 확인하세요:\nls -lh /home/i2p/.i2p/netDb/ 많은 .dat 파일들이 보일 것입니다. 비어있다면, I2P router가 피어를 발견할 때까지 기다리세요.\nSSL Certificate Errors 인증서가 유효한지 확인하세요:\nopenssl s_client -connect reseed.example.com:443 -servername reseed.example.com 서비스 상태 확인 확인: - DNS 레코드가 서버를 올바르게 가리키고 있는지 - 방화벽이 80번과 443번 포트를 허용하는지 - Nginx Proxy Manager가 실행 중인지: docker ps\nSecurity Considerations 개인 키 보안 유지: /home/i2p/.reseed/ 내용을 절대 공유하거나 노출하지 마세요 정기 업데이트: 시스템 패키지, Docker, reseed-tools를 최신 상태로 유지하세요 로그 모니터링: 의심스러운 접근 패턴을 주시하세요 속도 제한: 남용 방지를 위해 속도 제한 구현을 고려하세요 방화벽 규칙: 필요한 포트만 노출하세요 (80, 443, 81은 관리자용) 관리자 인터페이스: Nginx Proxy Manager 관리자 인터페이스(포트 81)를 신뢰할 수 있는 IP로만 제한하세요 Contributing to the Network reseed 서버를 운영함으로써, 당신은 I2P 네트워크를 위한 중요한 인프라를 제공하고 있습니다. 더 프라이빗하고 탈중앙화된 인터넷에 기여해 주셔서 감사합니다!\n질문이나 도움이 필요하시면 I2P 커뮤니티에 문의하세요: - 포럼: i2pforum.net - IRC/Reddit: 다양한 네트워크의 #i2p - 개발: i2pgit.org 가이드는 원래 Stormy Cloud 에 의해 작성되었으며, I2P 문서를 위해 수정되었습니다.\n","description":"I2P 리시드 서버를 설정하고 운영하여 새로운 라우터가 네트워크에 참여할 수 있도록 돕는 완전한 가이드","id":"d360e14f0f61d776e3c0b0f5b1262be5","section":"docs","title":"I2P 리시드 서버 생성 및 실행","url":"/ko/docs/guides/i2p-%EB%A6%AC%EC%8B%9C%EB%93%9C-%EC%84%9C%EB%B2%84-%EC%83%9D%EC%84%B1-%EB%B0%8F-%EC%8B%A4%ED%96%89/"},{"categories":null,"content":"목적: I2P 기술 문서 전반에 걸쳐 일관성, 정확성, 접근성을 유지합니다\n핵심 원칙 1. 모든 것을 검증하세요 절대 가정하거나 추측하지 마십시오. 모든 기술적 내용은 다음과 대조하여 검증해야 합니다: - 최신 I2P 소스 코드 (https://i2pgit.org/I2P_Developers/i2p.i2p/src/branch/master ) - 공식 API 문서 (https://i2p.github.io/i2p.i2p/ - 구성 사양 /docs/specs/ - 최근 릴리스 노트 /releases/ 올바른 검증의 예:\n❌ BAD: \u0026#34;The ClientApp interface probably requires three constructor parameters.\u0026#34; ✅ GOOD: \u0026#34;The ClientApp interface requires this constructor signature: public MyClientApp(I2PAppContext context, ClientAppManager manager, String[] args)\u0026#34; 2. 간결성보다 명확성 I2P(익명 네트워크 프로젝트인 The Invisible Internet Project)를 처음 접할 수도 있는 개발자를 대상으로 작성하세요. 독자의 사전 지식을 가정하지 말고 개념을 충분히 설명하세요.\n예시:\n❌ BAD: \u0026#34;Use the port mapper for service discovery.\u0026#34; ✅ GOOD: \u0026#34;The port mapper offers a simple directory for internal TCP services. Register loopback ports so other applications can discover your service without hardcoded addresses.\u0026#34; 3. 접근성 우선 I2P가 오버레이 네트워크임에도 불구하고, 문서는 clearnet(일반 인터넷)에서도 개발자가 접근할 수 있어야 합니다. I2P 내부 리소스에는 항상 clearnet에서 접근 가능한 대안을 제공해야 합니다.\n기술적 정확성 API 및 인터페이스 문서 항상 포함할 것: 1. 최초 언급 시 전체 패키지 이름: net.i2p.app.ClientApp 2. 반환 타입을 포함한 완전한 메서드 시그니처 3. 매개변수 이름과 타입 4. 필수 매개변수와 선택 매개변수 구분\n예시:\nThe `startup()` method has signature `void startup() throws IOException` and must execute without blocking. The method must call `ClientAppManager.notify()` at least once to transition from INITIALIZED state. 구성 속성 구성 파일을 문서화할 때: 1. 정확한 속성 이름을 그대로 명시한다 2. 파일 인코딩을 지정한다(I2P 구성 파일은 UTF-8) 3. 완전한 예제를 제공한다 4. 기본값을 문서화한다 5. 속성이 도입되었거나 변경된 버전을 명시한다\n예시:\n### clients.config Properties **Required:** - `clientApp.N.main` - Full class name (no default) **Optional:** - `clientApp.N.delay` - Seconds before starting (default: 120) - `clientApp.N.onBoot` - Forces delay=0 if true (default: false, added in 0.9.4) 상수와 열거형 상수를 문서화할 때는 실제 코드 이름을 사용하세요:\n❌ BAD: \u0026#34;Common registrations include console, i2ptunnel, Jetty, sam, and bob\u0026#34; ✅ GOOD: \u0026#34;Common port mapper service constants from `net.i2p.util.PortMapper`: - `SVC_CONSOLE` - Router console (default port 7657) - `SVC_HTTP_PROXY` - HTTP proxy (default port 4444) - `SVC_SAM` - SAM bridge (default port 7656)\u0026#34; 유사한 개념을 구별하기 I2P에는 서로 겹치는 시스템이 여럿 있습니다. 어떤 시스템을 문서화하는지 항상 분명히 하세요:\n예시:\nNote that client registry and port mapper are separate systems: - **ClientAppManager registry** enables inter-application communication by name lookup - **PortMapper** maps service names to host:port combinations for service discovery - **i2ptunnel tunnel types** are configuration values (tunnel.N.type), not service registrations 문서 URL 및 참고 자료 URL 접근성 규칙 주요 참고 자료는 clearnet(일반 인터넷)에서 접근 가능한 URL을 사용하는 것이 권장됩니다 I2P 내부 URL(.i2p 도메인)에는 접근성 안내를 반드시 포함해야 합니다 항상 대체 링크를 제공하세요 I2P 내부 리소스에 링크할 때에는 I2P 내부 URL용 템플릿:\n\u0026gt; **Note:** The I2P network hosts comprehensive documentation at http://idk.i2p/javadoc-i2p/ \u0026gt; which requires an I2P router for access. For clearnet access, use the GitHub Pages \u0026gt; mirror at https://eyedeekay.github.io/javadoc-i2p/ 권장 I2P 참고용 URL 공식 명세: - 구성 - 플러그인 - 문서 색인 API 문서 (가장 최신 문서를 선택): - 가장 최신: https://i2p.github.io/i2p.i2p/ (I2P 2.10.0 기준 API 0.9.66) - 클리어넷 미러: https://eyedeekay.github.io/javadoc-i2p/ 소스 코드: - GitLab (공식): https://i2pgit.org/I2P_Developers/i2p.i2p/src/branch/master - GitHub 미러: https://github.com/i2p/i2p.i2p 링크 형식 표준 ✅ GOOD: [ClientApp Javadoc](https://i2p.github.io/i2p.i2p/net/i2p/app/ClientApp.html) ✅ GOOD: [Configuration Specification](https://geti2p.net/spec/configuration) ❌ BAD: See the ClientApp docs at http://idk.i2p/... ❌ BAD: [link](url) with no descriptive text 버전 추적 문서 메타데이터 모든 기술 문서의 frontmatter(문서 상단의 메타데이터 블록)에는 버전 메타데이터가 포함되어야 합니다:\n--- title: \u0026#34;Document Title\u0026#34; description: \u0026#34;Brief description\u0026#34; slug: \u0026#34;url-slug\u0026#34; lastUpdated: \u0026#34;2025-10\u0026#34; accurateFor: \u0026#34;2.10.0\u0026#34; reviewStatus: \u0026#34;verified\u0026#34; --- 필드 정의: - lastUpdated: 문서가 마지막으로 검토/업데이트된 연-월 - accurateFor: 문서 검증 대상 I2P 버전 - reviewStatus: 다음 중 하나: \u0026ldquo;draft\u0026rdquo;, \u0026ldquo;needs-review\u0026rdquo;, \u0026ldquo;verified\u0026rdquo;, \u0026ldquo;outdated\u0026rdquo;\n콘텐츠의 버전 참조 버전을 언급할 때:\n현재 버전에는 굵게를 사용하세요: \u0026ldquo;버전 2.10.0 (2025년 9월)\u0026rdquo; 과거를 참조할 때는 버전 번호와 날짜를 모두 명시하세요 필요할 경우 API 버전은 I2P 버전과 구분하여 명시하세요 예시:\nManaged clients were introduced in **version 0.9.4** (December 17, 2012) and remain the recommended architecture as of **version 2.10.0** (September 9, 2025). The current API version is **0.9.66**. 시간에 따른 변경 사항 문서화 진화한 기능의 경우:\n**Version history:** - **0.9.4 (December 2012)** - Managed clients introduced - **0.9.42 (2019)** - clients.config.d/ directory structure added - **1.7.0 (2021)** - ShellService added for external program tracking - **2.10.0 (September 2025)** - Current release, no API changes to managed clients 사용 중단 공지 사용 중단된 기능을 문서화할 때:\n\u0026gt; **Deprecated:** This feature was deprecated in version X.Y.Z and will be removed \u0026gt; in version A.B.C. Use [alternative feature](link) instead. 용어 표준 I2P 공식 용어 다음의 정확한 용어를 일관되게 사용하세요:\nCorrect Term Avoid I2P router I2P node, I2P client (ambiguous) eepsite I2P website, hidden service (Tor term) tunnel connection, circuit (Tor term) netDb network database, DHT lease set destination info destination address, endpoint base64 destination I2P address, .i2p address ### 관리형 클라이언트 용어 관리형 클라이언트를 문서화할 때:\nUse This Not This managed client managed application unmanaged client legacy client, static client ClientAppManager application manager, client manager lifecycle methods state methods, control methods client registry application registry, name service port mapper port registry, service directory ### 구성 용어 Correct Incorrect clients.config clients.cfg, client.config clients.config.d/ clients.d/, config.d/ router.config router.cfg i2ptunnel.config tunnel.config ### 패키지 및 클래스 이름 처음 언급할 때는 항상 완전히 한정된 이름을 사용하고, 그 이후에는 약칭을 사용하십시오:\nThe `net.i2p.app.ClientApp` interface requires implementation of three lifecycle methods. When a ClientApp starts, the manager calls `startup()`... 코드 예제와 서식 Java 코드 예제 적절한 구문 하이라이팅과 완전한 예제를 사용하세요:\n### Example: Registering with Port Mapper \\`\\`\\`java // Register HTTP proxy service context.portMapper().register( PortMapper.SVC_HTTP_PROXY, \u0026#34;127.0.0.1\u0026#34;, 4444 ); // Later, retrieve the port int port = context.portMapper().getPort(PortMapper.SVC_HTTP_PROXY); if (port == -1) { // Service not registered } \\`\\`\\` 코드 예제 요구 사항: 1. 핵심 코드 줄을 설명하는 주석을 포함할 것 2. 관련된 곳에서는 오류 처리를 보여줄 것 3. 현실적인 변수 이름을 사용할 것 4. I2P 코딩 규약을 따를 것 (4칸 들여쓰기) 5. 문맥상 분명하지 않은 경우 import를 명시할 것\n구성 예제 완전하고 유효한 구성 예제를 보여 주세요:\n### Example: clients.config.d/ Entry File: `clients.config.d/00-console.config` \\`\\`\\`properties # Router console configuration clientApp.0.main=net.i2p.router.web.RouterConsoleRunner clientApp.0.name=Router Console clientApp.0.args=7657 ::1,127.0.0.1 ./webapps/ clientApp.0.delay=0 clientApp.0.onBoot=true \\`\\`\\` 명령줄 예제 사용자 명령에는 $를, root에는 #를 사용:\n\\`\\`\\`bash # Install I2P on Debian/Ubuntu $ sudo apt-get install i2p # Start the router $ i2prouter start \\`\\`\\` 인라인 코드 다음 항목에는 백틱을 사용하세요: - 메서드 이름: startup() - 클래스 이름: ClientApp - 프로퍼티 이름: clientApp.0.main - 파일 이름: clients.config - 상수: SVC_HTTP_PROXY - 패키지 이름: net.i2p.app\n톤과 보이스 전문적이면서도 이해하기 쉬운 기술 독자를 대상으로 하되, 가르치려 드는 어투는 피하십시오:\n❌ BAD: \u0026#34;Obviously, you should implement the startup() method.\u0026#34; ✅ GOOD: \u0026#34;Managed clients must implement the startup() method to initialize resources.\u0026#34; ❌ BAD: \u0026#34;Even a junior dev knows you need to call notify().\u0026#34; ✅ GOOD: \u0026#34;The manager requires at least one notify() call during startup to track state transitions.\u0026#34; 능동태 명확성을 위해 능동태로 작성하세요:\n❌ PASSIVE: \u0026#34;The ClientAppManager is notified by the client when state changes.\u0026#34; ✅ ACTIVE: \u0026#34;The client notifies ClientAppManager when state changes.\u0026#34; 지침 작성 시 명령형 사용 절차형 콘텐츠에서는 직접 명령형을 사용하라:\n✅ \u0026#34;Implement these three lifecycle methods:\u0026#34; ✅ \u0026#34;Call manager.notify() after changing state.\u0026#34; ✅ \u0026#34;Register services using context.portMapper().register()\u0026#34; 불필요한 전문 용어를 피하세요 용어는 처음 사용할 때 설명하세요:\n✅ GOOD: \u0026#34;The netDb (network database) stores information about I2P routers and destinations.\u0026#34; ❌ BAD: \u0026#34;Query the netDb for peer info.\u0026#34; (no explanation) 문장 부호 지침 em dash(긴 대시) 금지 - 대신 일반 대시, 쉼표, 또는 세미콜론을 사용하세요 목록에서는 옥스퍼드 쉼표를 사용하세요: \u0026ldquo;console, i2ptunnel, and Jetty\u0026rdquo; 코드 블록 내부의 마침표는 문법상 필요한 경우에만 사용하세요 열거 목록에서는 항목에 쉼표가 포함될 때 세미콜론을 사용하세요 문서 구조 표준 섹션 순서 API 문서는 다음을 참조하세요:\n개요 - 이 기능이 무엇을 하는지, 왜 존재하는지 구현 - 어떻게 구현하거나 사용하는지 구성 - 어떻게 설정하는지 API 참조 - 메서드/속성에 대한 상세 설명 예제 - 완전한 실행 가능한 예제 모범 사례 - 팁과 권장 사항 버전 이력 - 도입 시점과 시간에 따른 변경 사항 참고 자료 - 관련 문서 링크 제목 계층 구조 의미에 맞는 제목 수준을 사용하세요:\n# Document Title (h1 - only one per document) ## Major Section (h2) ### Subsection (h3) #### Detail Section (h4) **Bold text for emphasis within sections** 정보 상자 특별 공지에는 인용문을 사용하세요:\n\u0026gt; **Note:** Additional information that clarifies the main content. \u0026gt; **Warning:** Important information about potential issues or breaking changes. \u0026gt; **Deprecated:** This feature is deprecated and will be removed in version X.Y.Z. \u0026gt; **Status:** Current implementation status or version information. 목록 및 구성 순서 없는 목록 비순차적 항목용:\n- First item - Second item - Third item 순서 있는 목록은 순차적인 단계용:\n1. First step 2. Second step 3. Third step 정의 목록 용어 설명용:\n**Term One** : Explanation of term one **Term Two** : Explanation of term two 피해야 할 흔한 함정 1. 혼동되는 유사 시스템 혼동하지 마세요: - ClientAppManager 레지스트리 vs. PortMapper - i2ptunnel tunnel 유형 vs. 포트 매퍼 서비스 상수 - ClientApp vs. RouterApp (다른 컨텍스트) - 관리형 vs. 비관리형 클라이언트\n항상 어떤 시스템을 논의하는지:\n✅ \u0026#34;Register with ClientAppManager using manager.register(this) for name-based lookup.\u0026#34; ✅ \u0026#34;Register with PortMapper using context.portMapper().register() for port discovery.\u0026#34; 2. 구버전 참조 하지 마세요: - 구버전을 \u0026ldquo;최신\u0026quot;으로 표기 - 오래된 API 문서에 링크 - 예제에서 사용 중단된 메서드 시그니처 사용\n해야 할 일: - 게시하기 전에 릴리스 노트를 확인하세요 - API 문서가 현재 버전과 일치하는지 확인하세요 - 예제를 최신 모범 사례에 맞게 업데이트하세요\n3. 접속할 수 없는 URL 하지 말 것: - 클리어넷 대체 링크가 없는 .i2p 도메인에만 링크하지 말 것 - 작동하지 않거나 오래된 문서 URL을 사용하지 말 것 - 로컬 file:// 경로로 링크하지 말 것\n해야 할 일: - 모든 I2P 내부 링크에 대해 clearnet(일반 인터넷) 대안을 제공 - 게시하기 전에 URL이 접근 가능한지 확인 - 영속적인 URL을 사용(geti2p.net, 임시 호스팅이 아님)\n4. 불완전한 코드 예제 하지 말 것: - 맥락 없이 코드 조각만 보여주기 - 오류 처리를 생략하기 - 정의되지 않은 변수를 사용하기 - 명확하지 않을 때 import 문을 생략하기\n해야 할 일: - 완전하고 컴파일 가능한 예제를 제시하세요 - 필요한 오류 처리를 포함하세요 - 중요한 각 줄이 무엇을 하는지 설명하세요 - 게시하기 전에 예제를 테스트하세요\n5. 모호한 진술 ❌ \u0026#34;Some applications register services.\u0026#34; ✅ \u0026#34;Applications implementing ClientApp may register with ClientAppManager using manager.register(this) to enable name-based lookup.\u0026#34; ❌ \u0026#34;Configuration files go in the config directory.\u0026#34; ✅ \u0026#34;Modern I2P installations store client configurations in $I2P/clients.config.d/ as individual files.\u0026#34; Markdown 관례 파일 명명 파일 이름에는 kebab-case(단어를 소문자와 하이픈(-)으로 연결하는 표기)를 사용하세요: - managed-clients.md - port-mapper-guide.md - configuration-reference.md\n프론트매터 형식 항상 YAML frontmatter(문서 맨 위에 위치한 YAML 형식의 메타데이터 블록)을 포함하세요:\n--- title: \u0026#34;Document Title\u0026#34; description: \u0026#34;Brief description under 160 characters\u0026#34; slug: \u0026#34;url-slug\u0026#34; lastUpdated: \u0026#34;2025-10\u0026#34; accurateFor: \u0026#34;2.10.0\u0026#34; reviewStatus: \u0026#34;verified\u0026#34; --- 링크 서식 지정 내부 링크 (문서 내):\nSee [clients.config specification](https://geti2p.net/spec/configuration#clients-config) 외부 링크 (다른 리소스로 연결):\nFor more details, see [ClientApp Javadoc](https://i2p.github.io/i2p.i2p/net/i2p/app/ClientApp.html) 코드 저장소 링크:\nView source: [ClientApp.java](https://i2pgit.org/I2P_Developers/i2p.i2p/src/branch/master/core/java/src/net/i2p/app/ClientApp.java) 표 서식 GitHub-flavored Markdown(확장된 GitHub 마크다운) 표를 사용하세요:\n| Property | Type | Default | Description | |----------|------|---------|-------------| | `main` | String | (required) | Full class name | | `delay` | Integer | 120 | Seconds before start | | `onBoot` | Boolean | false | Force immediate start | 코드 블록 언어 태그 구문 강조를 위해 항상 언어를 명시하세요:\n\\`\\`\\`java // Java code \\`\\`\\` \\`\\`\\`bash # Shell commands \\`\\`\\` \\`\\`\\`properties # Configuration files \\`\\`\\` \\`\\`\\`xml \u0026lt;!-- XML files --\u0026gt; \\`\\`\\` 검토 체크리스트 문서를 게시하기 전에 다음을 확인하세요:\n모든 기술적 주장은 소스 코드 또는 공식 문서와 대조하여 검증됨 버전 번호와 날짜가 최신 상태임 모든 URL이 clearnet(일반 인터넷)에서 접근 가능함(또는 대안이 제공됨) 코드 예제가 완전하고 테스트됨 용어가 I2P 관례를 따름 em-dash(긴 대시) 사용 금지(일반 대시나 다른 문장부호 사용) Frontmatter(문서 머리말 메타데이터)가 완전하고 정확함 제목 계층이 의미론적임 (h1 → h2 → h3) 목록과 표가 올바르게 형식화됨 참고 문헌 섹션에 인용된 모든 출처가 포함됨 문서가 구조 지침을 따름 문체가 전문적이면서도 이해하기 쉬움 유사한 개념이 명확히 구분됨 끊어진 링크나 참조 없음 구성 예제가 유효하며 최신 상태임 피드백: 이 지침에 문제가 있거나 제안할 사항이 있다면, 공식 I2P 개발 채널을 통해 제출해 주세요.\n","description":"I2P 기술 문서 전반에 걸쳐 일관성, 정확성, 접근성을 유지합니다","id":"797e1cb5256ec022a3d99eefd7eda1f4","section":"docs","title":"I2P 문서 작성 지침","url":"/ko/docs/writing-guidelines/"},{"categories":null,"content":"I2P란 무엇인가? The Invisible Internet Project (I2P)는 검열 저항적이고 peer-to-peer 통신을 가능하게 하는 익명 네트워크 계층입니다. 익명 연결은 사용자의 트래픽을 암호화하고 전 세계 자원봉사자들이 운영하는 분산 네트워크를 통해 전송함으로써 달성됩니다.\n주요 기능 Anonymity I2P는 메시지의 발신자와 수신자를 모두 숨깁니다. 웹사이트와 서비스에 IP 주소가 노출되는 기존 인터넷 연결과 달리, I2P는 여러 계층의 암호화와 라우팅을 사용하여 사용자의 신원을 비공개로 유지합니다.\nDecentralization I2P에는 중앙 권한이 없습니다. 네트워크는 대역폭과 컴퓨팅 리소스를 기부하는 자원봉사자들에 의해 유지됩니다. 이는 검열과 단일 장애 지점에 저항성을 갖게 합니다.\n익명성 I2P 내의 모든 트래픽은 종단 간 암호화됩니다. 메시지는 네트워크를 통과하면서 여러 번 암호화되며, 이는 Tor의 작동 방식과 유사하지만 구현에 있어 중요한 차이점이 있습니다.\nHow It Works 탈중앙화 I2P는 트래픽을 라우팅하기 위해 \u0026ldquo;tunnel\u0026quot;을 사용합니다. 데이터를 전송하거나 수신할 때:\n라우터가 아웃바운드 tunnel을 생성합니다 (전송용) 라우터가 인바운드 tunnel을 생성합니다 (수신용) 메시지가 암호화되어 여러 router를 통해 전송됩니다 각 router는 이전 홉과 다음 홉만 알 뿐, 전체 경로는 알 수 없습니다 종단 간 암호화 I2P는 \u0026ldquo;garlic routing\u0026quot;을 통해 기존의 onion routing을 개선합니다:\n여러 메시지를 하나로 묶을 수 있습니다 (마늘 한 쪽에 여러 개의 마늘 알갱이가 있는 것처럼) 이를 통해 더 나은 성능과 추가적인 익명성을 제공합니다 트래픽 분석을 더 어렵게 만듭니다 Network Database I2P는 다음을 포함하는 분산 네트워크 데이터베이스를 유지합니다:\n라우터 정보 Destination 주소 (.i2p 웹사이트와 유사) 암호화된 라우팅 데이터 Common Use Cases 터널 .i2p로 끝나는 웹사이트를 호스팅하거나 방문하세요 - 이러한 사이트는 I2P 네트워크 내에서만 접근 가능하며 호스트와 방문자 모두에게 강력한 익명성을 보장합니다.\nGarlic Routing I2P를 통해 BitTorrent를 사용하여 익명으로 파일을 공유하세요. 많은 토렌트 애플리케이션에는 I2P 지원 기능이 내장되어 있습니다.\n네트워크 데이터베이스 I2P-Bote 또는 I2P용으로 설계된 다른 이메일 애플리케이션을 사용하여 익명 이메일을 보내고 받으세요.\nMessaging I2P 네트워크를 통해 IRC, 인스턴트 메시징 또는 기타 커뮤니케이션 도구를 비공개로 사용하세요.\nGetting Started I2P를 사용해 볼 준비가 되셨나요? 다운로드 페이지 를 확인하여 시스템에 I2P를 설치하세요.\n더 자세한 기술적 정보는 기술적 소개 를 참고하거나 전체 문서 를 살펴보세요.\n작동 원리 기술 소개 - 심화 기술 개념 위협 모델 - I2P 보안 모델 이해하기 Tor와의 비교 - I2P와 Tor의 차이점 암호화 - I2P 암호화 알고리즘 상세 정보 ","description":"I2P 익명 네트워크에 대한 비전문가를 위한 소개","id":"b4dafae75d4a04b2eac73ebf531f1d1b","section":"docs","title":"I2P 소개","url":"/ko/docs/overview/intro/"},{"categories":null,"content":"우리의 위협 모델 에서 요구하는 바와 같이 (그 외 다른 이유들도 있지만), I2P라고 부르는 익명 통신 네트워크를 지원하기 위해 개발된 소프트웨어는 자유롭게 이용 가능하고, 오픈 소스이며, 사용자가 수정할 수 있어야 합니다. 이러한 기준을 충족하기 위해, 우리는 I2P 프로젝트를 사용하거나 기여하려는 사람들의 진입 장벽을 최대한 제거하고자 다양한 법적 및 소프트웨어 엔지니어링 기법을 활용합니다.\n아래 정보는 단순히 \u0026ldquo;I2P는 BSD입니다\u0026rdquo;, \u0026ldquo;I2P는 GPL입니다\u0026rdquo; 또는 \u0026ldquo;I2P는 퍼블릭 도메인입니다\u0026quot;라고 말하는 것보다 더 혼란스러울 수 있지만, \u0026ldquo;I2P는 어떻게 라이선스되어 있나요?\u0026ldquo;라는 질문에 대한 간단한 답변은 다음과 같습니다:\nI2P 배포판에 포함된 모든 소프트웨어는 다음을 허용합니다: 무료 사용 어떻게, 언제, 어디서, 왜, 누구에 의해 실행되는지에 대한 제한 없이 사용 무료로 소스 코드에 접근 소스 수정 대부분의 소프트웨어는 훨씬 더 많은 것을 보장합니다 - 누구나 수정된 소스를 원하는 방식으로 배포할 수 있는 능력입니다. 그러나 번들로 제공되는 모든 소프트웨어가 이러한 자유를 제공하는 것은 아닙니다 - GPL은 I2P를 자체 오픈 소스가 아닌 애플리케이션과 통합하려는 개발자의 능력을 제한합니다. 우리는 공공재의 자원을 늘리려는 고귀한 목표를 지지하지만, I2P는 채택을 가로막는 장벽을 제거함으로써 가장 잘 발전할 수 있습니다 - I2P를 자신의 애플리케이션과 통합할 수 있는지 고려하는 개발자가 변호사와 상담하거나, 자신의 소스가 GPL 호환으로 릴리스될 수 있는지 확인하기 위해 코드 감사를 수행해야 한다면, 우리는 기회를 잃게 됩니다.\n컴포넌트 라이선스 I2P 배포판에는 소스 코드가 컴포넌트로 분할된 것을 반영하여 여러 리소스가 포함되어 있습니다. 각 컴포넌트는 고유한 라이선스를 가지고 있으며, 해당 컴포넌트에 기여하는 모든 개발자는 이에 동의합니다 - 컴포넌트와 호환되는 라이선스 하에 커밋된 코드의 릴리스를 명시적으로 선언하거나, 컴포넌트의 주 라이선스 하에 커밋된 코드를 암묵적으로 릴리스함으로써 동의합니다. 각 컴포넌트에는 어떤 라이선스가 해당 컴포넌트의 주 라이선스와 호환되는지에 대한 최종 결정권을 가진 리드 개발자가 있으며, I2P 프로젝트 매니저는 어떤 라이선스가 I2P 배포판에 포함되기 위한 위의 네 가지 보장 사항을 충족하는지에 대한 최종 결정권을 가집니다.\nComponent Source path Resource Primary license Alternate licenses Lead developer I2P SDK core i2p.jar Public domain BSD, Cryptix, MIT zzz I2P Router router router.jar Public domain BSD, Cryptix, MIT zzz Ministreaming apps/ministreaming mstreaming.jar BSD Public domain, Cryptix, MIT zzz Streaming apps/streaming streaming.jar Public domain BSD, Cryptix, MIT zzz I2PTunnel apps/i2ptunnel i2ptunnel.jar GPL + exception Public domain, BSD, Cryptix, MIT zzz Routerconsole apps/routerconsole routerconsole.war Public domain — zzz Address Book apps/addressbook addressbook.war MIT Public domain, Cryptix, BSD — Susidns apps/susidns susidns.war GPL + exception — — Susimail apps/susimail susimail.war GPL + exception — — I2PSnark apps/i2psnark i2psnark.jar GPL + exception — zzz [BOB](/docs/legacy/bob/) Bridge apps/BOB BOB.jar WTFPL — sponge [SAM](/docs/api/samv3/) Bridge apps/sam sam.jar Public domain Cryptix, BSD, MIT zzz [SAM v1](/docs/legacy/sam/) Perl library apps/sam/perl SAM.pm GPL Public domain, Cryptix, BSD, MIT BrianR [SAM v1](/docs/legacy/sam/) C library apps/sam/c libSAM BSD Public domain, Cryptix, MIT Nightblade [SAM v1](/docs/legacy/sam/) Python library apps/sam/python i2p.py Public domain BSD, Cryptix, MIT Connelly [SAM v1](/docs/legacy/sam/) C# library apps/sam/csharp/ n/a Public domain BSD, Cryptix, MIT smeghead Other apps not mentioned apps/ ... Probably Public domain but check the source — — Installer installer install.jar, guiinstall.jar Public domain GPL + exception, BSD, Cryptix, MIT — GPL 예외 중복될 수 있지만, 명확성을 위해 I2PTunnel 및 기타 앱에 포함된 GPL 코드는 Java의 표준 라이브러리 사용을 명시적으로 승인하는 추가 \u0026ldquo;예외\u0026rdquo; 조항과 함께 GPL 하에 공개되어야 합니다:\nIn addition, as a special exception, XXXX gives permission to link the code of this program with the proprietary Java implementation provided by Sun (or other vendors as well), and distribute linked combinations including the two. You must obey the GNU General Public License in all respects for all of the code used other than the proprietary Java implementation. If you modify this file, you may extend this exception to your version of the file, but you are not obligated to do so. If you do not wish to do so, delete this exception statement from your version. 각 구성 요소의 모든 소스 코드는 코드에 별도로 표시되지 않는 한 기본적으로 주 라이선스에 따라 라이선스가 부여됩니다. 위의 모든 내용은 라이선스 조건의 요약입니다 - 권위 있는 조건은 해당 구성 요소 또는 소스 코드의 구체적인 라이선스를 참조하시기 바랍니다. 저장소가 재구성되는 경우 구성 요소 소스 위치 및 리소스 패키징이 변경될 수 있습니다.\n웹사이트 라이선스 별도로 명시되지 않는 한, 이 사이트의 콘텐츠는 Creative Commons Attribution-ShareAlike 4.0 International License 에 따라 라이선스가 부여됩니다.\n커밋 권한 개발자는 해당 저장소를 운영하는 사람으로부터 권한을 받으면 분산 git 저장소에 변경 사항을 푸시할 수 있습니다. 자세한 내용은 새로운 개발자 가이드 를 참조하세요.\n그러나 릴리스에 변경 사항을 포함하려면 개발자는 릴리스 관리자(현재 zzz)의 신뢰를 받아야 합니다. 또한 신뢰를 받으려면 위의 조건에 명시적으로 동의해야 합니다. 즉, 릴리스 관리자 중 한 명에게 다음을 확인하는 서명된 메시지를 보내야 합니다:\n별도로 표시되지 않는 한, 내가 커밋하는 모든 코드는 해당 컴포넌트의 주요 라이선스에 따라 암묵적으로 라이선스가 부여됩니다 소스에 명시된 경우, 코드는 해당 컴포넌트의 대체 라이선스 중 하나에 따라 명시적으로 라이선스가 부여될 수 있습니다 나는 내가 커밋하는 조건에 따라 커밋하는 코드를 배포할 권리가 있습니다 위 조건이 충족되지 않는 사례를 알고 계신 분은 컴포넌트 책임자 및/또는 I2P 릴리스 관리자에게 추가 정보와 함께 연락해 주시기 바랍니다.\n","description":"I2P와 함께 번들로 제공되는 소프트웨어의 라이선스 정책 및 구성 요소 라이선스","id":"74bb6af167b1176b4058e46e5f8ca568","section":"docs","title":"I2P 소프트웨어 라이선스","url":"/ko/docs/develop/licenses/"},{"categories":null,"content":"1. \u0026ldquo;익명\u0026quot;의 의미 I2P는 실용적인 익명성을 제공하며, 투명성을 제공하는 것은 아닙니다. 익명성은 적대자가 당신이 비공개로 유지하고자 하는 정보—당신이 누구인지, 어디에 있는지, 누구와 대화하는지—를 알아내기 어려운 정도로 정의됩니다. 절대적인 익명성은 불가능합니다. 대신 I2P는 전역적 수동 및 능동 적대자에 대해 충분한 익명성을 목표로 합니다.\n귀하의 익명성은 I2P를 어떻게 구성하는지, 피어와 구독을 어떻게 선택하는지, 그리고 어떤 애플리케이션을 노출하는지에 따라 달라집니다.\n2. 암호화 및 전송 진화 (2003 → 2025) Era Primary Algorithms Notes 0.3 – 0.9 ElGamal + AES-256 + DSA-SHA1 Legacy stack (2003–2015) 0.9.15 Ed25519 signatures Replaced DSA 0.9.36 (2018) NTCP2 introduced Noise XK_25519_ChaChaPoly_SHA256 0.9.56 (2022) SSU2 enabled by default Noise-based UDP transport 2.4.0 (2023) NetDB Sub-DB isolation Prevents router↔client linkage 2.8.0+ (2025) Congestion-aware routing / observability reductions DoS hardening 2.10.0 (2025) Post-quantum hybrid ML-KEM support (optional) Experimental **현재 암호화 스위트 (Noise XK):** - **X25519** 키 교환용 - **ChaCha20/Poly1305 AEAD** 암호화용 - **Ed25519 (EdDSA-SHA512)** 서명용 - **SHA-256** 해싱 및 HKDF용 - 선택적 **ML-KEM 하이브리드** 포스트 양자 테스트용 모든 ElGamal 및 AES-CBC 사용은 폐기되었습니다. Transport는 전적으로 NTCP2 (TCP) 및 SSU2 (UDP)를 사용하며, 둘 다 IPv4/IPv6, forward secrecy (전방향 비밀성), DPI obfuscation (심층 패킷 검사 난독화)을 지원합니다.\n3. 네트워크 아키텍처 요약 자유 경로 mixnet: 송신자와 수신자가 각자 자신의 tunnel을 정의합니다. 중앙 권한 없음: 라우팅과 이름 지정이 탈중앙화되어 있으며, 각 router는 로컬 신뢰를 유지합니다. 단방향 tunnel: 인바운드와 아웃바운드가 분리되어 있습니다 (10분 수명). 탐색 tunnel: 기본적으로 2홉; 클라이언트 tunnel은 2–3홉입니다. Floodfill router: 약 55,000개 노드 중 약 1,700개(약 6%)가 분산된 NetDB를 유지합니다. NetDB 순환: 키스페이스는 UTC 자정에 매일 순환됩니다. Sub-DB 격리: 2.4.0 버전부터 각 클라이언트와 router는 연결을 방지하기 위해 별도의 데이터베이스를 사용합니다. 4. 공격 범주 및 현재 방어 메커니즘 Category Current Status (2025) Primary Defenses Brute Force / Cryptanalysis Impractical with modern primitives (X25519, ChaCha20). Strong crypto, key rotation, Noise handshakes. Timing Attacks Still unsolved for low-latency systems. Unidirectional tunnels, 1024\u0026nbsp;B cells, profile recalc (45\u0026nbsp;s). Research continues for non-trivial delays (3.0+). Intersection Attacks Inherent weakness of low latency mixnets. Tunnel rotation (10\u0026nbsp;min), leaseset expirations, multihoming. Predecessor Attacks Partially mitigated. Tiered peer selection, strict XOR ordering, variable length tunnels. Sybil Attacks No comprehensive defense. IP /16 limits, profiling, diversity rules; HashCash infra exists but not required. Floodfill / NetDB Attacks Improved but still a concern. One /16 per lookup, limit 500 active, daily rotation, randomized verification delay, Sub-DB isolation. DoS / Flooding Frequent (esp. 2023 incidents). Congestion-aware routing (2.4+), aggressive leaseset removal (2.8+). Traffic ID / Fingerprinting Greatly reduced. Noise obfuscation, random padding, no plaintext headers. Censorship / Partitioning Possible with state-level blocking. Hidden mode, IPv6, multiple reseeds, mirrors. Development / Supply Chain Mitigated. Open source, signed SU3 releases (RSA-4096), multi-signer trust model. --- 5. 현대적인 네트워크 데이터베이스 (NetDB) 핵심 사실 (여전히 정확함): - 수정된 Kademlia DHT가 RouterInfo와 LeaseSet을 저장합니다. - SHA-256 키 해싱; 10초 타임아웃으로 가장 가까운 2개의 floodfill에 병렬 쿼리를 수행합니다. - LeaseSet 수명 ≈ 10분 (LeaseSet2) 또는 18시간 (MetaLeaseSet).\n새로운 타입 (0.9.38 이후): - LeaseSet2 (타입 3) – 다중 암호화 타입, 타임스탬프 적용. - EncryptedLeaseSet2 (타입 5) – 비공개 서비스를 위한 블라인드 destination (DH 또는 PSK 인증). - MetaLeaseSet (타입 7) – 멀티호밍 및 연장된 만료 시간.\n주요 보안 업그레이드 – Sub-DB 격리 (2.4.0): - router↔client 연결 방지. - 각 client와 router가 별도의 netDb 세그먼트 사용. - 검증 및 감사 완료 (2.5.0).\n6. 숨김 모드 및 제한된 경로 Hidden Mode: 구현됨 (Freedom House 점수에 따라 엄격한 국가에서 자동 적용).\nRouter들은 RouterInfo를 공개하지 않으며 트래픽을 라우팅하지 않습니다. Restricted Routes: 부분 구현됨 (기본 신뢰 전용 tunnel).\n포괄적인 신뢰 피어 라우팅은 계획 중입니다 (3.0+). 절충안: 더 나은 프라이버시 ↔ 네트워크 용량 기여도 감소.\n7. DoS 및 Floodfill 공격 과거: 2013년 UCSB 연구에서 Eclipse 및 Floodfill 장악이 가능함을 보여줌. 현대적 방어 메커니즘: - 일일 키스페이스 순환. - Floodfill 제한 ≈ 500개, /16당 하나. - 무작위 저장소 검증 지연. - 최신 router 우선 (2.6.0). - 자동 등록 수정 (2.9.0). - 혼잡 인식 라우팅 및 lease 제한 (2.4.0+).\nFloodfill 공격은 이론적으로는 가능하지만 실제로는 더 어렵습니다.\n8. 트래픽 분석 및 검열 I2P 트래픽은 식별하기 어렵습니다: 고정 포트 없음, 평문 핸드셰이크 없음, 무작위 패딩 사용. NTCP2와 SSU2 패킷은 일반적인 프로토콜을 모방하고 ChaCha20 헤더 난독화를 사용합니다. 패딩 전략은 기본적이며(무작위 크기), 더미 트래픽은 구현되지 않았습니다(비용 문제). Tor exit 노드로부터의 연결은 2.6.0부터 차단됩니다(리소스 보호를 위해).\n9. 지속적인 제한사항 (인지됨) 저지연 애플리케이션에 대한 타이밍 상관관계는 여전히 근본적인 위험 요소입니다. 알려진 공개 목적지에 대한 교차 공격은 여전히 강력합니다. Sybil 공격에 대한 완전한 방어 수단이 부족합니다 (HashCash가 강제되지 않음). 일정 속도 트래픽과 중요한 지연은 아직 구현되지 않았습니다 (3.0 계획). 이러한 제한 사항에 대한 투명성은 의도적입니다 — 사용자가 익명성을 과대평가하는 것을 방지합니다.\n10. 네트워크 통계 (2025) 전 세계적으로 약 55,000개의 활성 router (2013년 7,000개에서 증가 ↑) 약 1,700개의 floodfill router (~6%) 기본적으로 95%가 tunnel 라우팅에 참여 대역폭 등급: K (\u0026lt;12 KB/s) → X (\u0026gt;2 MB/s) 최소 floodfill 속도: 128 KB/s Router 콘솔 Java 8+ (필수), 다음 사이클에 Java 17+ 계획 11. 개발 및 중앙 리소스 공식 사이트: geti2p.net 문서: Documentation Debian 저장소: https://deb.i2pgit.org ( 2023년 10월에 deb.i2p2.de를 대체 ) 소스 코드: https://i2pgit.org/I2P_Developers/i2p.i2p (Gitea) + GitHub 미러 모든 릴리스는 서명된 SU3 컨테이너 (RSA-4096, zzz/str4d 키) 활성 메일링 리스트 없음; 커뮤니티는 https://i2pforum.net 및 IRC2P를 통해 운영 업데이트 주기: 6–8주 안정 릴리스 12. 0.8.x 이후 보안 개선 사항 요약 Year Feature Effect 2015 Ed25519 signatures Removed SHA1/DSA weakness 2018 NTCP2 Noise-based TCP transport 2019 LeaseSet2 / EncryptedLeaseSet2 Hidden services privacy 2022 SSU2 Noise-based UDP transport 2023 Sub-DB Isolation + Congestion-Aware Routing Stopped NetDB linkage / improved resilience 2024 Floodfill selection improvements Reduced long-term node influence 2025 Observability reductions + PQ hybrid crypto Harder timing analysis / future-proofing --- 13. 알려진 미해결 또는 계획된 작업 포괄적인 제한된 경로 (신뢰할 수 있는 피어 라우팅) → 3.0 계획됨. 타이밍 저항을 위한 비자명한 지연/배치 → 3.0 계획됨. 고급 패딩 및 더미 트래픽 → 미구현. HashCash 신원 확인 → 인프라는 존재하지만 비활성화됨. R5N DHT 대체 → 제안만 존재. 14. 주요 참고 자료 Practical Attacks Against the I2P Network (Egger et al., RAID 2013) Privacy Implications of Performance-Based Peer Selection (Herrmann \u0026amp; Grothoff, PETS 2011) Resilience of the Invisible Internet Project (Muntaka et al., Wiley 2025) I2P 공식 문서 15. 결론 I2P의 핵심 익명성 모델은 20년 동안 유지되어 왔습니다: 전역 고유성을 희생하여 지역적 신뢰와 보안을 확보하는 것입니다. ElGamal에서 X25519로, NTCP에서 NTCP2로, 그리고 수동 reseed에서 Sub-DB 격리까지, 프로젝트는 심층 방어와 투명성이라는 철학을 유지하면서 진화해 왔습니다.\n많은 공격이 이론적으로는 모든 저지연 mixnet에 대해 여전히 가능하지만, I2P의 지속적인 강화는 이러한 공격을 점점 더 비실용적으로 만들고 있습니다. 네트워크는 그 어느 때보다 크고, 빠르며, 안전합니다. 하지만 여전히 자신의 한계에 대해 솔직합니다.\n","description":"I2P 설계에서 고려된 공격 목록 및 적용된 완화 조치","id":"8433fa179e266d091a906a9059db53f4","section":"docs","title":"I2P 위협 모델","url":"/ko/docs/overview/threat-model/"},{"categories":null,"content":"개요 I2CP는 I2P router와 임의의 클라이언트 프로세스 사이의 하위 수준 제어 프로토콜이다. 이는 책임의 엄격한 분리를 정의한다:\nRouter: 라우팅, 암호화, tunnel 수명 주기, 네트워크 데이터베이스 작업을 관리합니다 클라이언트: 익명성 속성을 선택하고, tunnel을 구성하며, 메시지를 전송/수신합니다 모든 통신은 단일 TCP 소켓(선택적으로 TLS로 래핑됨)을 통해 이루어지며, 비동기식, 풀 듀플렉스 동작을 가능하게 합니다.\nProtocol Version: I2CP는 초기 연결 수립 시 전송되는 프로토콜 버전 바이트 0x2A(10진수 42)를 사용합니다. 이 버전 바이트는 프로토콜 도입 이후로 변함없이 안정적으로 유지되고 있습니다.\n현재 상태: 본 사양은 2025-09에 릴리스된 router 버전 0.9.67(API 버전 0.9.67)에 대해 정확합니다.\n구현 컨텍스트 Java 구현체 레퍼런스 구현은 Java I2P에 포함되어 있습니다: - 클라이언트 SDK: i2p.jar 패키지 - Router 구현: router.jar 패키지 - Javadocs 클라이언트와 router가 동일한 JVM에서 실행될 때, I2CP 메시지는 직렬화 없이 Java 객체로 전달됩니다. 외부 클라이언트는 TCP를 통해 직렬화된 프로토콜을 사용합니다.\nC++ 구현 i2pd (C++ I2P router)는 클라이언트 연결을 위해 외부적으로 I2CP(클라이언트와 router 간 통신 프로토콜)도 구현합니다.\n비 Java 클라이언트 완전한 I2CP 클라이언트 라이브러리에 대해서는 알려진 비 Java 구현이 없습니다. Java가 아닌 애플리케이션은 대신 상위 수준 프로토콜을 사용해야 합니다:\nSAM (Simple Anonymous Messaging) v3: 여러 언어용 라이브러리가 있는 소켓 기반 인터페이스 BOB (Basic Open Bridge): SAM의 더 간단한 대안 이러한 상위 수준 프로토콜은 I2CP의 복잡성을 내부적으로 처리하고, TCP와 유사한 연결을 위한 스트리밍 라이브러리와 UDP와 유사한 연결을 위한 데이터그램 라이브러리도 제공합니다.\n연결 설정 1. TCP 연결 router의 I2CP 포트에 연결: - 기본값: 127.0.0.1:7654 - router 설정에서 구성 가능 - 선택적 TLS 래퍼(원격 연결의 경우 강력히 권장)\n2. 프로토콜 핸드셰이크 1단계: 프로토콜 버전 바이트 0x2A를 전송\n2단계: 시계 동기화\nClient → Router: GetDateMessage Router → Client: SetDateMessage router는 현재 타임스탬프와 I2CP API 버전 문자열을 반환합니다(0.8.7부터).\n3단계: 인증(활성화된 경우)\n0.9.11부터 인증은 다음을 포함하는 Mapping을 통해 GetDateMessage에 포함될 수 있습니다: - i2cp.username - i2cp.password\n0.9.16부터 인증이 활성화된 경우, 다른 어떤 메시지가 전송되기 전에 GetDateMessage(날짜 요청 메시지)를 통해 반드시 완료되어야 합니다.\n4단계: 세션 생성\nClient → Router: CreateSessionMessage (contains SessionConfig) Router → Client: SessionStatusMessage (status=Created) 5단계: Tunnel 준비 신호\nRouter → Client: RequestVariableLeaseSetMessage 이 메시지는 인바운드 tunnel이 구축되었음을 나타냅니다. router는 적어도 하나의 인바운드 tunnel과 하나의 아웃바운드 tunnel이 존재하기 전에는 이를 전송하지 않습니다.\n6단계: LeaseSet 게시\nClient → Router: CreateLeaseSet2Message 이 시점에서 세션은 메시지 송수신을 위해 완전히 동작합니다.\n메시지 흐름 패턴 발신 메시지 (클라이언트가 원격 목적지로 보냄) i2cp.messageReliability=none 설정 시:\nClient → Router: SendMessageMessage (nonce=0) [No acknowledgments] i2cp.messageReliability=BestEffort 설정 시:\nClient → Router: SendMessageMessage (nonce\u0026gt;0) Router → Client: MessageStatusMessage (status=Accepted) Router → Client: MessageStatusMessage (status=Success or Failure) 수신 메시지 (Router가 클라이언트로 전달) i2cp.fastReceive=true인 경우 (0.9.4부터 기본값):\nRouter → Client: MessagePayloadMessage [No acknowledgment required] i2cp.fastReceive=false로 설정 시 (사용 중단됨):\nRouter → Client: MessageStatusMessage (status=Available) Client → Router: ReceiveMessageBeginMessage Router → Client: MessagePayloadMessage Client → Router: ReceiveMessageEndMessage 최신 클라이언트는 항상 빠른 수신 모드를 사용해야 합니다.\n공통 자료 구조 I2CP 메시지 헤더 모든 I2CP 메시지는 이 공통 헤더를 사용합니다:\n+----+----+----+----+----+----+----+----+ | Body Length (4 bytes) | +----+----+----+----+----+----+----+----+ |Type| Message Body (variable) | +----+----+----+----+----+----+----+----+ 본문 길이: 4바이트 정수, 메시지 본문 길이만 (헤더 제외) 유형: 1바이트 정수, 메시지 유형 식별자 메시지 본문: 0바이트 이상, 형식은 메시지 유형에 따라 달라짐 메시지 크기 제한: 최대 약 64 KB.\n세션 ID router에서 세션을 고유하게 식별하는 2바이트 정수.\n특수 값: 0xFFFF는 \u0026ldquo;세션 없음\u0026quot;을 나타냅니다(설정된 세션 없이 호스트명 조회에 사용).\n메시지 ID 세션 내의 메시지를 고유하게 식별하기 위해 router가 생성하는 4바이트 정수.\n중요: 메시지 ID는 전역적으로 고유하지 않으며, 세션 내에서만 고유합니다. 또한 클라이언트가 생성한 nonce(임의 일회성 값)와도 구별됩니다.\n페이로드 형식 메시지 페이로드는 표준 10바이트 gzip 헤더를 사용해 gzip으로 압축됩니다:\n시작은 다음과 같습니다: 0x1F 0x8B 0x08 (RFC 1952) 0.7.1부터: gzip 헤더의 사용되지 않는 부분에는 프로토콜, from-port, to-port 정보가 포함됩니다 이는 동일한 목적지에서 스트리밍과 데이터그램을 모두 사용할 수 있게 합니다 압축 제어: 압축을 비활성화하려면 i2cp.gzip=false로 설정하세요(gzip effort(압축 노력 수준)을 0으로 설정). gzip 헤더는 여전히 포함되지만, 압축 오버헤드는 최소화됩니다.\nSessionConfig 구조체 클라이언트 세션에 대한 구성을 정의합니다:\n+----------------------------------+ | Destination | +----------------------------------+ | Mapping (configuration options) | +----------------------------------+ | Creation Date | +----------------------------------+ | Signature | +----------------------------------+ 중요 요구사항: 1. Mapping은 키 기준으로 정렬되어 있어야 합니다 서명 검증을 위해 2. Creation Date는 router의 현재 시간으로부터 ±30초 이내여야 합니다 3. Signature는 Destination(목적지)의 SigningPrivateKey로 생성됩니다\nOffline Signatures(오프라인 서명) (0.9.38 기준):\noffline signing(오프라인 서명)을 사용하는 경우, 매핑에는 다음이 포함되어야 합니다: - i2cp.leaseSetOfflineExpiration - i2cp.leaseSetTransientPublicKey - i2cp.leaseSetOfflineSignature\n그 후 임시 SigningPrivateKey(서명용 개인 키)에 의해 서명이 생성됩니다.\n코어 구성 옵션 Tunnel 구성 Option Default Description inbound.length 3 Number of hops for inbound tunnels outbound.length 3 Number of hops for outbound tunnels inbound.lengthVariance 0 Random variance in hop count (since 0.7.6) outbound.lengthVariance 0 Random variance in hop count (since 0.7.6) inbound.quantity 2 Number of concurrent inbound tunnels outbound.quantity 2 Number of concurrent outbound tunnels inbound.backupQuantity 0 Standby inbound tunnels (hot spares) outbound.backupQuantity 0 Standby outbound tunnels (hot spares) inbound.allowZeroHop true Allow 0-hop tunnels (disable for full anonymity) outbound.allowZeroHop true Allow 0-hop tunnels (disable for full anonymity) **참고**: - `quantity` 값이 6을 초과하면 0.9.0+를 실행 중인 피어가 필요하며 리소스 사용량이 크게 증가합니다 - 고가용성 서비스의 경우 `backupQuantity`를 1-2로 설정하십시오 - Zero-hop tunnels는 지연 시간을 줄이는 대신 익명성을 희생하지만 테스트에는 유용합니다 메시지 처리 Option Default Description clientMessageTimeout 60000\u0026nbsp;ms Legacy timeout for message delivery i2cp.messageReliability BestEffort None, BestEffort, or Guaranteed i2cp.fastReceive true Skip ReceiveMessageBegin/End handshake (default since 0.9.4) i2cp.gzip true Enable gzip compression of message payloads outbound.priority 0 Priority for outbound scheduling (-25 to +25) **메시지 신뢰성**: - `None`: router 확인 응답 없음 (스트리밍 라이브러리의 기본값, 0.8.1부터) - `BestEffort`: Router가 수락 + 성공/실패 알림을 보냄 - `Guaranteed`: 미구현됨 (현재는 BestEffort처럼 동작) 메시지별 재정의 (0.9.14부터): - messageReliability=none인 세션에서 0이 아닌 nonce(임의 일회성 값)를 설정하면 해당 특정 메시지에 대한 전달 확인 알림을 요청합니다 - BestEffort 세션에서 nonce=0으로 설정하면 해당 메시지에 대한 전달 확인 알림이 비활성화됩니다\nLeaseSet(목적지의 수신 터널 정보를 담은 레코드) 구성 Option Default Description i2cp.dontPublishLeaseSet false Disable automatic LeaseSet publication (for client-only destinations) i2cp.leaseSetType 1 LeaseSet variant: 1 = standard, 3 = LS2, 5 = encrypted, 7 = meta i2cp.leaseSetEncType 0 Comma-separated encryption type codes (see below) ### 레거시 ElGamal/AES 세션 태그 다음 옵션은 레거시 ElGamal 암호화에만 해당됩니다:\nOption Default Description crypto.lowTagThreshold 30 Minimum session tags before replenishing crypto.tagsToSend 40 Number of tags to send in a batch **참고**: ECIES-X25519 클라이언트는 다른 ratchet mechanism(래칫 메커니즘)을 사용하며 이 옵션들을 무시합니다. 암호화 유형 I2CP는 i2cp.leaseSetEncType 옵션을 통해 여러 종단 간 암호화 방식을 지원합니다. 최신 및 구형 피어 모두를 지원하기 위해 여러 타입을 쉼표로 구분하여 지정할 수 있습니다.\n지원되는 암호화 유형 Type Algorithm Key Size Since Status 0 ElGamal/AES+SessionTags 2048-bit ElGamal Original Legacy 1-3 Reserved - - Unused 4 ECIES-X25519-AEAD-Ratchet 32-byte X25519 0.9.46 Current Standard 5 ECIES-X25519-AEAD-Ratchet + ML-KEM-768 hybrid 32\u0026nbsp;+\u0026nbsp;PQ 0.9.67 Beta 6 ECIES-X25519-AEAD-Ratchet + ML-KEM-1024 hybrid 32\u0026nbsp;+\u0026nbsp;PQ 0.9.67 Beta 7 Reserved (likely ML-KEM-512 hybrid) 32\u0026nbsp;+\u0026nbsp;PQ Future Planned **권장 구성**: i2cp.leaseSetEncType=4,0 이는 X25519(곡선25519 기반 키 교환 방식, 권장)을 제공하며, 호환성을 위해 ElGamal(공개키 암호 방식)로 폴백합니다.\n암호화 유형 상세 정보 유형 0 - ElGamal/AES+SessionTags: - 2048비트 ElGamal 공개 키(256바이트) - AES-256 대칭 암호화 - 32바이트 session tags(세션 태그)를 묶음 단위로 전송 - 높은 CPU, 대역폭 및 메모리 오버헤드 - 네트워크 전반에서 단계적으로 폐지 중\n타입 4 - ECIES-X25519-AEAD-Ratchet: - X25519 키 교환(32바이트 키) - ChaCha20/Poly1305 AEAD - Signal 스타일의 double ratchet(이중 래칫) - 8바이트 세션 태그(ElGamal 대비 32바이트) - 태그는 동기화된 PRNG(의사난수 생성기)를 통해 생성됨(사전에 전송하지 않음) - ~92% 오버헤드 감소(ElGamal 대비) - 현행 I2P의 표준(대부분의 router가 이를 사용)\n유형 5-6 - 포스트-양자 하이브리드: - X25519와 ML-KEM (NIST FIPS 203, 모듈 격자 기반 키 캡슐화 메커니즘)을 결합 - 양자 내성 보안을 제공 - 균형 잡힌 보안/성능을 위한 ML-KEM-768 - 최대 보안을 위한 ML-KEM-1024 - 포스트-양자(PQ) 키 자료로 인해 메시지 크기가 더 큼 - 네트워크 지원은 아직 배포 진행 중\n마이그레이션 전략 I2P 네트워크는 ElGamal(유형 0)에서 X25519(유형 4)로 적극적으로 전환 중입니다: - NTCP → NTCP2 (완료) - SSU → SSU2 (완료) - ElGamal tunnels → X25519 tunnels (완료) - ElGamal 종단 간 → ECIES-X25519 (대부분 완료)\nLeaseSet2 및 고급 기능 LeaseSet2 옵션 (0.9.38부터) Option Since Purpose i2cp.leaseSetType 0.9.38 Specifies LeaseSet variant (1, 3, 5, 7) i2cp.leaseSetEncType 0.9.38 Encryption types supported (comma-separated) i2cp.leaseSetAuthType 0.9.41 Per-client authentication: 0 = none, 1 = DH, 2 = PSK i2cp.leaseSetPrivKey 0.9.41 X25519 private key for decrypting LS2 with auth i2cp.leaseSetSecret 0.9.39 Base64 secret for blinded addresses i2cp.leaseSetTransientPublicKey 0.9.38 Transient signing key for offline signatures i2cp.leaseSetPrivateKey 0.9.18 Persistent LeaseSet encryption keys (type:key pairs) i2cp.leaseSetOption.nnn 0.9.66 Service records (proposal 167) i2cp.leaseSetClient.dh.nnn 0.9.41 DH client auth material (indexed from 0) i2cp.leaseSetClient.psk.nnn 0.9.41 PSK client auth material (indexed from 0) ### Blinded Addresses(블라인딩 주소) 0.9.39부터 Destination(연결 대상 식별자)은 주기적으로 변경되는 \u0026ldquo;blinded\u0026rdquo;(블라인딩 처리된) 주소(b33 형식)를 사용할 수 있습니다: - 비밀번호 보호를 위해 i2cp.leaseSetSecret가 필요합니다 - 클라이언트별 인증은 선택 사항입니다 - 자세한 내용은 proposal 123 및 149를 참조하세요\n서비스 레코드(0.9.66부터) LeaseSet2는 서비스 레코드 옵션을 지원합니다(제안 167):\ni2cp.leaseSetOption.0=_smtp._tcp=1 86400 0 0 25 mail.example.b32.i2p 형식은 DNS SRV 레코드 스타일을 따르되 I2P에 맞게 조정되었습니다.\n여러 세션 (0.9.21 이후) 하나의 I2CP 연결로 여러 세션을 유지할 수 있습니다:\n기본 세션: 한 연결에서 처음 생성된 세션 하위 세션: 기본 세션의 tunnel 풀을 공유하는 추가 세션\nSubsession(하위 세션) 특성 공유된 tunnel: 기본과 동일한 인바운드/아웃바운드 tunnel 풀을 사용 공유된 암호화 키: 동일한 LeaseSet 암호화 키를 사용해야 함 서로 다른 서명 키: 서로 다른 Destination(목적지 식별자) 서명 키를 사용해야 함 익명성 보장 없음: 기본 세션과 명확히 연결됨 (동일한 router, 동일한 tunnel) 서브세션 사용 사례 다양한 서명 유형을 사용하는 목적지와의 통신을 활성화합니다: - 기본: EdDSA 서명(최신) - 하위 세션: DSA 서명(레거시 호환성)\nSubsession(하위 세션) 라이프사이클 생성:\nClient → Router: CreateSessionMessage Router → Client: SessionStatusMessage (unique Session ID) Router → Client: RequestVariableLeaseSetMessage (separate for each destination) Client → Router: CreateLeaseSet2Message (separate for each destination) 소멸: - 하위 세션 소멸: 기본 세션은 그대로 유지됨 - 기본 세션 소멸: 모든 하위 세션을 소멸하고 연결을 종료 - DisconnectMessage(연결 해제 메시지): 모든 세션을 소멸\n세션 ID 처리 대부분의 I2CP 메시지에는 세션 ID 필드가 포함됩니다. 예외: - DestLookup / DestReply (사용 중단됨, HostLookup / HostReply 사용) - GetBandwidthLimits / BandwidthLimits (응답이 세션에 종속되지 않음)\n중요: 응답을 요청과 확정적으로 매칭할 수 없으므로, 클라이언트는 CreateSession(세션 생성) 메시지를 동시에 여러 개 보류 중 상태로 두지 않아야 합니다.\n메시지 카탈로그 메시지 유형 요약 Type Name Direction Since Status 1 CreateSession C → R Original Current 2 ReconfigureSession C → R 0.7.1 Current 3 DestroySession C → R Original Current 4 CreateLeaseSet C → R Original Deprecated 5 SendMessage C → R Original Current 6 ReceiveMessageBegin C → R Original Deprecated 7 ReceiveMessageEnd C → R Original Deprecated 8 GetBandwidthLimits C → R 0.7.2 Current 20 SessionStatus R → C Original Current 21 RequestLeaseSet R → C Original Deprecated 22 MessageStatus R → C Original Current 23 BandwidthLimits R → C 0.7.2 Current 29 ReportAbuse Bidirectional Original Unused 30 Disconnect Bidirectional Original Current 31 MessagePayload R → C Original Current 32 GetDate C → R Original Current 33 SetDate R → C Original Current 34 DestLookup C → R 0.7 Deprecated 35 DestReply R → C 0.7 Deprecated 36 SendMessageExpires C → R 0.7.1 Current 37 RequestVariableLeaseSet R → C 0.9.7 Current 38 HostLookup C → R 0.9.11 Current 39 HostReply R → C 0.9.11 Current 41 CreateLeaseSet2 C → R 0.9.39 Current 42 BlindingInfo C → R 0.9.43 Current **범례**: C = 클라이언트, R = Router 핵심 메시지 세부 정보 CreateSessionMessage (유형 1) 목적: 새 I2CP 세션 개시\n내용: SessionConfig 구조체\n응답: SessionStatusMessage (세션 상태 메시지) (status=Created 또는 Invalid)\n요구 사항: - SessionConfig의 Date는 router 시간의 ±30초 이내여야 합니다 - 서명 검증을 위해 매핑은 키 기준으로 정렬되어야 합니다 - Destination(목적지)에 대해 이미 활성 세션이 존재해서는 안 됩니다\nRequestVariableLeaseSetMessage (유형 37) Purpose: Router가 인바운드 tunnels에 대한 클라이언트 권한 부여를 요청합니다\n내용: - 세션 ID - leases(I2P에서 목적지로 가는 터널과 만료 시간을 포함한 엔트리)의 개수 - Lease 구조체 배열(각각 개별 만료 시간 포함)\n응답: CreateLeaseSet2Message(LeaseSet2 생성 메시지)\n의미: 이는 세션이 정상적으로 동작 중임을 알리는 신호입니다. router는 다음 조건이 충족된 후에만 이를 전송합니다: 1. 인바운드 tunnel이 최소 1개 구축됨 2. 아웃바운드 tunnel이 최소 1개 구축됨\n타임아웃 권장사항: 세션 생성 후 5분 이상이 지나도 이 메시지를 수신하지 못한 경우, 클라이언트는 세션을 종료해야 합니다.\nCreateLeaseSet2Message (유형 41) 목적: 클라이언트가 LeaseSet(서비스 접속 정보 집합)을 네트워크 데이터베이스(netDb)에 게시한다\n내용: - 세션 ID - LeaseSet 타입 바이트 (1, 3, 5, 또는 7) - LeaseSet 또는 LeaseSet2 또는 EncryptedLeaseSet 또는 MetaLeaseSet - 개인 키 개수 - 개인 키 목록 (LeaseSet의 각 공개 키당 하나, 같은 순서)\n개인 키: 수신되는 garlic 메시지(여러 개의 메시지를 하나로 묶어 전달하는 I2P 메시지 형식)를 복호화하는 데 필요합니다. 형식:\nEncryption type (2 bytes) Key length (2 bytes) Private key data (variable) 참고: 다음을 처리하지 못하는 사용 중단된 CreateLeaseSetMessage(LeaseSet 생성 메시지) (type 4)을 대체합니다: - LeaseSet2(LeaseSet의 2세대 형식) 변형 - ElGamal이 아닌 암호화 - 여러 암호화 유형 - 암호화된 LeaseSets - 오프라인 서명 키\nSendMessageExpiresMessage (유형 36) 목적: 만료 시간 및 고급 옵션을 지정하여 메시지를 목적지로 전송\nContent: - 세션 ID - 목적지 - 페이로드 (gzip으로 압축됨) - 논스 (4바이트) - 플래그 (2바이트) - 아래 참조 - 만료 시각 (6바이트, 8바이트에서 잘림)\n플래그 필드 (2바이트, 비트 순서 15\u0026hellip;0):\n비트 15-11: 미사용, 반드시 0이어야 함\n비트 10-9: 메시지 신뢰성 오버라이드 (미사용, 대신 nonce(논스, 한 번만 사용하는 값)를 사용)\n비트 8: LeaseSet을 포함하지 않음 - 0: Router는 garlic(가릴릭, I2P의 다중 페이로드 메시지 방식) 안에 LeaseSet을 포함할 수 있음 - 1: LeaseSet을 포함하지 않음\n비트 7-4: 낮은 태그 임계값 (ElGamal(엘가말 암호)에만 해당, ECIES(타원곡선 통합 암호 방식)에서는 무시됨)\n0000 = Use session settings 0001 = 2 tags 0010 = 3 tags ... 1111 = 192 tags 비트 3-0: 필요한 경우 전송할 태그(ElGamal에서만 사용되며, ECIES에서는 무시됨)\n0000 = Use session settings 0001 = 2 tags 0010 = 4 tags ... 1111 = 160 tags MessageStatusMessage(메시지 상태 메시지) (유형 22) 목적: 클라이언트에게 메시지 전달 상태를 알림\n내용: - 세션 ID - 메시지 ID (router에서 생성됨) - 상태 코드 (1 바이트) - 크기 (4 바이트, status=0인 경우에만 해당) - 논스 (4 바이트, 클라이언트의 SendMessage 논스와 일치)\n상태 코드 (발신 메시지):\nCode Name Meaning Result 1 Accepted Router accepted message Success 2 Best Effort Success Probable delivery Success 4 Guaranteed Success Probable delivery Success 6 Local Success Delivered to local client Success 3 Best Effort Failure Probable failure Failure 5 Guaranteed Failure Generic failure Failure 7 Local Failure Local delivery failed Failure 8 Router Failure Router shutdown/error Failure 9 Network Failure No network connectivity Failure 10 Bad Session Invalid/closed session Failure 11 Bad Message Invalid payload Failure 12 Bad Options Invalid options/expiration Failure 13 Overflow Failure Queue/buffer full Failure 14 Message Expired Expired before send Failure 15 Bad Local LeaseSet Local LeaseSet problem Failure 16 No Local Tunnels No tunnels available Failure 17 Unsupported Encryption Incompatible encryption Failure 18 Bad Destination Invalid remote destination Failure 19 Bad Leaseset Invalid remote LeaseSet Failure 20 Expired Leaseset Remote LeaseSet expired Failure 21 No Leaseset Remote LeaseSet not found Failure 22 Meta Leaseset Cannot send to meta LS Failure 23 Loopback Denied Same source and destination Failure **성공 코드**: 1, 2, 4, 6 **실패 코드**: 그 외 모두 상태 코드 0 (사용 중단됨): 사용 가능한 메시지 (수신, 빠른 수신 기능 비활성화됨)\nHostLookupMessage (호스트 조회 메시지, 유형 38) 목적: 호스트명 또는 해시로 목적지 조회 (DestLookup을 대체)\nContent: - 세션 ID (세션이 없으면 0xFFFF) - 요청 ID (4바이트) - 밀리초 단위의 타임아웃 (4바이트, 권장 최소값: 10000) - 요청 유형 (1바이트) - 조회 키 (해시, 호스트명 문자열 또는 Destination(목적지))\n요청 유형:\nType Lookup Key Returns Since 0 Hash Destination Original 1 Hostname String Destination Original 2 Hash Destination + Options 0.9.66 3 Hostname String Destination + Options 0.9.66 4 Destination Destination + Options 0.9.66 유형 2-4는 가능한 경우 LeaseSet 옵션(제안 167)을 반환합니다. 응답: HostReplyMessage\nHostReplyMessage (호스트 응답 메시지) (유형 39) 목적: HostLookupMessage(호스트 조회 메시지)에 대한 응답\n내용: - 세션 ID - 요청 ID - 결과 코드(1바이트) - 목적지(성공 시 포함되며, 특정 실패 시에도 포함될 수 있음) - 매핑(조회 유형 2-4에만 해당하며, 비어 있을 수 있음)\n결과 코드:\nCode Name Meaning 0 Success Lookup succeeded 1 Failure Generic failure 2 Lookup Password Required Blinded address requires password 3 Private Key Required Blinded address requires private key 4 Password and Key Required Blinded address requires both 5 LeaseSet Decryption Failure Cannot decrypt LeaseSet 6 LeaseSet Lookup Failure LeaseSet not found in netdb 7 Lookup Type Unsupported Router doesn't support this type #### BlindingInfoMessage (블라인딩 정보 메시지) (유형 42) 목적: router에게 blinded destination(블라인드된 목적지)의 인증 요구사항을 알림 (0.9.43부터)\n내용: - 세션 ID - 플래그(1바이트) - 엔드포인트 유형(1바이트): 0=Hash, 1=호스트명, 2=Destination(목적지 식별자), 3=SigType+Key - 블라인드 서명 유형(2바이트) - 만료 시간(4바이트, epoch 이후 초 단위) - 엔드포인트 데이터(유형에 따라 다름) - 개인 키(32바이트, 플래그 비트 0이 설정된 경우에만) - 조회 비밀번호(String, 플래그 비트 4가 설정된 경우에만)\n플래그 (비트 순서 76543210):\n비트 0: 0=모두, 1=클라이언트별 비트 3-1: 인증 방식(비트 0=1인 경우): 000=DH(디피-헬만), 001=PSK(사전 공유 키) 비트 4: 1=비밀값 필요 비트 7-5: 사용되지 않음, 0으로 설정 응답 없음: Router는 조용히 처리합니다\nUse Case: 블라인드 목적지(b33 주소)로 전송하기 전에, 클라이언트는 다음 중 하나를 반드시 수행해야 합니다: 1. HostLookup을 통해 b33 주소를 조회하거나, 2. BlindingInfo 메시지를 전송\n목적지가 인증을 요구하는 경우, BlindingInfo는 필수입니다.\nReconfigureSessionMessage (유형 2) 목적: 생성 후 세션 설정 업데이트\n내용: - 세션 ID - SessionConfig (변경된 옵션만 필요)\n응답: SessionStatusMessage(세션 상태 메시지) (status=Updated or Invalid)\n참고: - router는 새 구성을 기존 구성과 병합합니다 - Tunnel 옵션 (inbound.*, outbound.*)은 항상 적용됩니다 - 일부 옵션은 세션 생성 후 변경할 수 없을 수 있습니다 - 날짜는 router 시간의 ±30초 이내여야 합니다 - 매핑은 키 기준으로 정렬되어야 합니다\nDestroySessionMessage (유형 3) 목적: 세션 종료\n내용: 세션 ID\n예상 응답: SessionStatusMessage (status=Destroyed)\n실제 동작 (Java I2P 0.9.66까지): - Router는 SessionStatus(Destroyed)를 절대 보내지 않음 - 세션이 남아 있지 않은 경우: DisconnectMessage 전송 - subsessions(하위 세션)이 남아 있는 경우: 응답 없음\n중요: Java I2P의 동작은 명세와 다릅니다. 구현체는 각 subsession(하위 세션)을 종료할 때 주의해야 합니다.\nDisconnectMessage(연결 해제 메시지) (유형 30) 목적: 연결이 곧 종료될 것임을 알림\n내용: 사유 문자열\n효과: 해당 연결의 모든 세션이 종료되고, 소켓이 닫힙니다\n구현: 주로 Java I2P에서 router → 클라이언트\n프로토콜 버전 연혁 버전 감지 I2CP 프로토콜 버전은 0.8.7부터 Get/SetDate 메시지에서 교환된다. 이전 버전의 router에서는 버전 정보를 확인할 수 없다.\n버전 문자열: \u0026ldquo;core\u0026rdquo; API 버전을 의미하며, 반드시 router 버전인 것은 아닙니다.\n기능 연대표 Version Key Features 0.9.67 PQ Hybrid ML-KEM (enc types 5-7) in LeaseSet 0.9.66 Host lookup/reply extensions (proposal 167), service records 0.9.62 MessageStatus loopback error code 0.9.46 X25519 (enc type 4) in LeaseSet, ECIES end-to-end 0.9.43 BlindingInfo message, extended HostReply failure codes 0.9.41 EncryptedLeaseSet options, Meta LS error code 0.9.39 CreateLeaseSet2 message, RedDSA Ed25519 support 0.9.38 Preliminary LS2 support (format changed in 0.9.39) 0.9.21 Multiple sessions on single connection 0.9.20 Additional SetDate messages for clock shifts 0.9.16 Authentication required before other messages (when enabled) 0.9.15 EdDSA Ed25519 signature type 0.9.14 Per-message reliability override with nonzero nonce 0.9.12 ECDSA P-256/384/521 signature types, RSA support 0.9.11 HostLookup/HostReply messages, auth in GetDate 0.9.7 RequestVariableLeaseSet message 0.9.5 Additional MessageStatus codes 0.9.4 Fast receive mode default, nonce=0 allowed 0.9.2 SendMessageExpires flag tag bits 0.9 16 leases per LeaseSet (up from 6) 0.8.7 Version strings in Get/SetDate 0.8.4 SendMessageExpires flag bits 0.8.3 DestLookup in standard session, concurrent lookups 0.8.1 messageReliability=none 0.7.2 GetBandwidthLimits, BandwidthLimits 0.7.1 SendMessageExpires, ReconfigureSession, ports in gzip header 0.7 DestLookup, DestReply 0.6.5- Original protocol features ## 보안 고려 사항 인증 기본값: 인증이 필요하지 않음 선택 사항: 사용자 이름/비밀번호 인증 (0.9.11부터) 필수: 활성화되면 다른 메시지 전에 인증이 완료되어야 함 (0.9.16부터)\n원격 연결: 자격 증명과 개인 키를 보호하기 위해 항상 TLS (i2cp.SSL=true)를 사용하세요.\n시계 오차 SessionConfig Date는 router 시간과 ±30초 이내여야 하며, 그렇지 않으면 세션이 거부됩니다. 동기화하려면 Get/SetDate를 사용하십시오.\n개인 키 관리 CreateLeaseSet2Message(LeaseSet2 생성 메시지)에는 수신 메시지를 복호화하기 위한 비밀 키가 포함되어 있습니다. 이 키들은 다음과 같아야 합니다: - 안전하게 전송(원격 연결에는 TLS 사용) - router에서 안전하게 저장 - 침해되었을 때 교체\n메시지 만료 명시적 만료 시간을 설정하려면 SendMessageExpires (SendMessage가 아님)을 항상 사용하세요. 이렇게 하면: - 메시지가 무기한으로 대기열에 쌓이는 것을 방지합니다 - 리소스 사용량을 줄입니다 - 신뢰성을 향상시킵니다\n세션 태그 관리 ElGamal (사용 중단됨): - 태그는 일괄로 전송되어야 함 - 태그 손실 시 복호화 실패 발생 - 높은 메모리 오버헤드\nECIES-X25519 (타원 곡선 통합 암호 방식의 하나, Curve25519 기반) (현재): - 동기화된 의사난수 생성기(PRNG)를 통해 태그 생성 - 사전 전송 불필요 - 메시지 손실에 강함 - 오버헤드가 크게 낮음\n모범 사례 클라이언트 개발자를 위한 빠른 수신 모드 사용: 항상 i2cp.fastReceive=true로 설정하세요 (또는 기본값을 사용)\nECIES-X25519(타원곡선 기반 키 교환/암호화 스위트)을 우선 사용: 호환성을 유지하면서 최상의 성능을 위해 i2cp.leaseSetEncType=4,0로 설정하세요\n만료를 명시적으로 설정: SendMessageExpires를 사용하고, SendMessage는 사용하지 마십시오\nSubsessions(하위 세션)을 신중하게 다루세요: subsessions은 목적지 간 익명성을 제공하지 않는다는 점에 유의하세요\n세션 생성 시간 초과: 5분 이내에 RequestVariableLeaseSet을 수신하지 못하면 세션을 파기한다\n구성 매핑 정렬: SessionConfig에 서명하기 전에 항상 Mapping 키를 정렬하세요\n적절한 Tunnel 개수 사용: 필요한 경우가 아니면 quantity \u0026gt; 6로 설정하지 마세요\nJava가 아닌 환경에서는 SAM/BOB(외부 애플리케이션을 I2P에 연결하는 프로토콜)를 고려하세요: I2CP를 직접 사용하는 대신 SAM을 구현하세요\nRouter 개발자를 위한 날짜 유효성 검사: SessionConfig 일시에 대해 ±30초 허용 오차 범위를 강제 적용\n메시지 크기 제한: 최대 메시지 크기를 ~64 KB로 강제합니다\n다중 세션 지원: 0.9.21 사양에 따라 subsession(하위 세션) 지원을 구현한다\nRequestVariableLeaseSet(가변 leaseSet 요청)을 신속히 전송: inbound 및 outbound tunnel이 모두 존재한 이후에만\n더 이상 권장되지 않는 메시지 처리: 허용하되 ReceiveMessageBegin/End 사용은 지양\nECIES-X25519 지원: (타원곡선 기반 하이브리드 암호 방식의 X25519 변형) 신규 배포에서는 type 4 암호화를 우선적으로 사용하십시오\n디버깅 및 문제 해결 일반적인 문제 세션 거부됨(유효하지 않음): - 시계 오차를 확인(±30초 이내여야 함) - 매핑이 키 기준으로 정렬되어 있는지 확인 - Destination(목적지)가 이미 사용 중이 아닌지 확인\nNo RequestVariableLeaseSet: - Router가 tunnel 구축 중일 수 있습니다 (최대 5분까지 기다리세요) - 네트워크 연결 문제를 확인하세요 - 충분한 피어 연결이 있는지 확인하세요\n메시지 전달 실패: - 구체적인 실패 원인을 파악하려면 MessageStatus 코드를 확인 - 원격 LeaseSet이 게시되어 있고 최신 상태인지 확인 - 호환되는 암호화 유형을 사용하고 있는지 확인\nSubsession(하위 세션) 문제: - 기본 세션이 먼저 생성되었는지 확인 - 암호화 키가 동일한지 확인 - 서명 키가 서로 다른지 확인\n진단 메시지 GetBandwidthLimits: router 용량을 조회 HostLookup: 이름 해석과 LeaseSet 가용성을 테스트 MessageStatus: 종단 간 메시지 전달을 추적\n관련 명세 공통 구조: /docs/specs/common-structures/ I2NP (네트워크 프로토콜): /docs/specs/i2np/ ECIES-X25519: /docs/specs/ecies/ tunnel 생성: /docs/specs/implementation/ 스트리밍 라이브러리: /docs/specs/streaming/ 데이터그램 라이브러리: /docs/api/datagrams/ SAM v3: /docs/api/samv3/ 참조된 제안서 제안 123 : 암호화된 LeaseSets 및 인증 제안 144 : ECIES-X25519-AEAD-Ratchet 제안 149 : 블라인드 주소 형식(b33) 제안 152 : X25519 tunnel 생성 제안 154 : ECIES 목적지에서의 데이터베이스 조회 제안 156 : Router의 ECIES-X25519로의 마이그레이션 제안 161 : Destination 패딩 압축 제안 167 : LeaseSet 서비스 레코드 제안 169 : 포스트-양자 하이브리드 암호(ML-KEM) Javadoc 레퍼런스 I2CP 패키지 MessageStatusMessage 클라이언트 API 사용 중단 요약 사용 중단된 메시지(사용하지 마십시오) CreateLeaseSetMessage (유형 4): CreateLeaseSet2Message를 사용하십시오 RequestLeaseSetMessage (유형 21): RequestVariableLeaseSetMessage를 사용하십시오 ReceiveMessageBeginMessage (유형 6): 빠른 수신 모드를 사용하십시오 ReceiveMessageEndMessage (유형 7): 빠른 수신 모드를 사용하십시오 DestLookupMessage (유형 34): HostLookupMessage를 사용하십시오 DestReplyMessage (유형 35): HostReplyMessage를 사용하십시오 ReportAbuseMessage (유형 29): 미구현 사용 중단된 옵션 ElGamal 암호화 (type 0): ECIES-X25519 (type 4)로 이전 DSA 서명: EdDSA 또는 ECDSA로 이전 i2cp.fastReceive=false: 항상 빠른 수신 모드를 사용 ","description":"애플리케이션이 I2P router와 세션, tunnels, LeaseSets를 협상하는 방법","id":"ed43fc9da2a03819fd3c8f71e9e9a5a3","section":"docs","title":"I2P 클라이언트 프로토콜 (I2CP)","url":"/ko/docs/specs/i2cp/"},{"categories":null,"content":"소개 I2P는 확장 가능하고 자가 조직화되며 복원력 있는 패킷 교환 익명 네트워크 계층으로, 그 위에서 익명성 또는 보안을 중요시하는 다양한 애플리케이션들이 작동할 수 있습니다. 이러한 각 애플리케이션은 자유 경로 mixnet(믹스넷)의 적절한 구현에 대해 걱정할 필요 없이 자체적인 익명성, 지연시간, 처리량 간의 균형을 조정할 수 있으며, 이를 통해 I2P 상에서 이미 실행 중인 더 큰 익명성 집합의 사용자들과 자신들의 활동을 자연스럽게 섞을 수 있습니다.\n이미 사용 가능한 애플리케이션들은 일반적인 인터넷 활동의 전체 범위를 제공합니다 — 익명 웹 브라우징, 웹 호스팅, 채팅, 파일 공유, 이메일, 블로깅, 콘텐츠 신디케이션은 물론 현재 개발 중인 여러 다른 애플리케이션들도 포함됩니다.\n웹 브라우징: 프록시를 지원하는 기존 브라우저 사용 채팅: IRC 및 기타 프로토콜 파일 공유: I2PSnark 및 기타 애플리케이션 이메일: Susimail 및 기타 애플리케이션 블로그: 로컬 웹 서버 또는 사용 가능한 플러그인 사용 Freenet 이나 GNUnet 과 같은 콘텐츠 배포 네트워크 내에서 호스팅되는 웹사이트와 달리, I2P에서 호스팅되는 서비스는 완전히 상호작용이 가능합니다 — 전통적인 웹 스타일의 검색 엔진, 게시판, 댓글을 달 수 있는 블로그, 데이터베이스 기반 사이트, 그리고 Freenet과 같은 정적 시스템을 로컬에 설치하지 않고도 쿼리할 수 있는 브리지가 있습니다.\n이러한 모든 익명성 지원 애플리케이션에서 I2P는 메시지 지향 미들웨어로 작동합니다 — 애플리케이션은 암호화 식별자(destination)로 전송할 데이터를 지정하고, I2P는 이를 안전하고 익명으로 도착하도록 보장합니다. I2P는 또한 I2P의 익명 최선 노력 메시지를 신뢰할 수 있는 순서대로 전송되는 스트림으로 변환할 수 있도록 간단한 스트리밍 라이브러리 를 포함하고 있으며, 네트워크의 높은 대역폭-지연 곱에 맞춰 조정된 TCP 기반 혼잡 제어를 제공합니다.\n기존 애플리케이션을 연결하기 위해 간단한 SOCKS 프록시가 개발되었지만, 대부분의 애플리케이션은 익명 환경에서 민감한 정보를 유출하기 때문에 그 가치가 제한적입니다. 가장 안전한 접근 방식은 애플리케이션을 감사하고 조정하여 I2P의 API를 직접 사용하도록 하는 것입니다.\nI2P는 학술, 상업 또는 정부 연구 프로젝트가 아니라, 실용적인 익명성 제공을 목표로 하는 엔지니어링 활동입니다. 2003년 초부터 전 세계에 분산된 기여자 그룹에 의해 지속적으로 개발되어 왔습니다. 모든 I2P 작업은 공식 웹사이트 에서 오픈 소스로 제공되며, 주로 퍼블릭 도메인으로 공개되고 일부 구성 요소는 허용적인 BSD 스타일 라이선스를 따릅니다. I2PTunnel , Susimail , I2PSnark 와 같은 여러 GPL 라이선스 클라이언트 애플리케이션을 사용할 수 있습니다. 자금은 전적으로 사용자 기부로만 충당됩니다.\n운영 Overview I2P는 router(네트워크에 참여하는 노드)와 destination(애플리케이션을 위한 익명 엔드포인트) 간에 명확한 구분을 둡니다. I2P 자체를 실행하는 것은 비밀이 아니며, 숨겨지는 것은 사용자가 무엇을 하고 있는지와 그들의 destination이 어떤 router를 사용하는지입니다. 최종 사용자는 일반적으로 여러 destination을 실행합니다(예: 웹 브라우징용 하나, 호스팅용 하나, IRC용 하나).\nI2P의 핵심 개념은 tunnel입니다. 이는 일련의 라우터들을 통과하는 단방향 암호화 경로입니다. 각 router는 한 계층만 복호화하며 다음 홉(hop)만 알게 됩니다. Tunnel은 10분마다 만료되며 재구축되어야 합니다.\n그림 1: 두 가지 유형의 tunnel이 존재합니다 — 인바운드와 아웃바운드.\nOutbound 터널은 생성자로부터 메시지를 보냅니다. Inbound 터널은 메시지를 생성자에게 다시 가져옵니다. 이 두 가지를 결합하면 양방향 통신이 가능합니다. 예를 들어, \u0026ldquo;Alice\u0026quot;는 아웃바운드 터널을 사용하여 \u0026ldquo;Bob\u0026quot;의 인바운드 터널로 전송합니다. Alice는 Bob의 인바운드 게이트웨이로의 라우팅 지침과 함께 메시지를 암호화합니다.\n또 다른 핵심 개념은 network database 또는 netDb로, 라우터와 목적지에 대한 메타데이터를 분산 저장합니다:\nRouterInfo: router 연락처 및 키 자료를 포함합니다. LeaseSet: destination에 연락하는 데 필요한 정보(tunnel 게이트웨이, 만료 시간, 암호화 키)를 포함합니다. 라우터는 자신의 RouterInfo를 netDb에 직접 게시합니다. LeaseSet은 익명성을 위해 아웃바운드 터널을 통해 전송됩니다.\n터널을 구축하기 위해 Alice는 netDb에서 RouterInfo 항목을 조회하여 피어를 선택하고, 터널이 완성될 때까지 암호화된 터널 구축 메시지를 홉별로 전송합니다.\n그림 2: Router 정보는 터널 구축에 사용됩니다.\nBob에게 데이터를 전송하기 위해, Alice는 Bob의 LeaseSet을 조회하고 자신의 아웃바운드 터널 중 하나를 사용하여 Bob의 인바운드 터널 게이트웨이로 데이터를 라우팅합니다.\n그림 3: LeaseSets는 아웃바운드 및 인바운드 터널을 연결합니다.\nI2P는 메시지 기반이기 때문에, 송신 종단점이나 수신 게이트웨이로부터도 메시지를 보호하기 위해 종단 간 garlic encryption을 추가합니다. garlic 메시지는 여러 개의 암호화된 \u0026ldquo;clove\u0026rdquo;(메시지)를 감싸서 메타데이터를 숨기고 익명성을 향상시킵니다.\n애플리케이션은 메시지 인터페이스를 직접 사용하거나 신뢰할 수 있는 연결을 위해 스트리밍 라이브러리 에 의존할 수 있습니다.\nTunnels 인바운드 및 아웃바운드 tunnel 모두 계층화된 암호화를 사용하지만 구성 방식이 다릅니다:\n인바운드 터널에서는 생성자(엔드포인트)가 모든 레이어를 복호화합니다. 아웃바운드 터널에서는 생성자(게이트웨이)가 엔드포인트에서의 명확성을 보장하기 위해 레이어를 사전에 복호화합니다. I2P는 직접적인 프로빙 없이 지연 시간과 신뢰성과 같은 간접적인 지표를 통해 피어를 프로파일링합니다. 이러한 프로파일을 기반으로 피어는 동적으로 네 가지 계층으로 그룹화됩니다:\n빠르고 높은 용량 높은 용량 실패하지 않음 실패 중 터널 피어 선택은 일반적으로 높은 용량의 피어를 선호하며, 익명성과 성능의 균형을 맞추기 위해 무작위로 선택되고, predecessor 공격과 netDb 수집을 완화하기 위해 추가적인 XOR 기반 순서 지정 전략을 사용합니다.\n더 자세한 내용은 Tunnel 사양 을 참조하세요.\n개요 floodfill 분산 해시 테이블(DHT)에 참여하는 router들은 LeaseSet 조회를 저장하고 응답합니다. DHT는 Kademlia 의 변형을 사용합니다. Floodfill router는 충분한 용량과 안정성이 있으면 자동으로 선택되거나 수동으로 구성할 수 있습니다.\nRouterInfo: router의 기능과 전송 방식을 설명합니다. LeaseSet: 목적지의 터널과 암호화 키를 설명합니다. netDb의 모든 데이터는 발행자에 의해 서명되고 타임스탬프가 기록되어 재전송 공격이나 오래된 항목 공격을 방지합니다. 시간 동기화는 SNTP와 전송 계층 스큐 감지를 통해 유지됩니다.\nAdditional concepts 미공개 및 암호화된 LeaseSet:\n목적지는 LeaseSet을 공개하지 않고 신뢰할 수 있는 피어하고만 공유함으로써 비공개 상태를 유지할 수 있습니다. 접근하려면 적절한 복호화 키가 필요합니다.\n부트스트래핑 (리시딩):\n네트워크에 참여하기 위해 새 router는 신뢰할 수 있는 HTTPS 리시드 서버로부터 서명된 RouterInfo 파일을 가져옵니다.\n조회 확장성:\nI2P는 DHT 확장성과 보안을 개선하기 위해 재귀적이 아닌 반복적 조회를 사용합니다.\n터널 현대 I2P 통신은 두 가지 완전히 암호화된 전송 방식을 사용합니다:\nNTCP2 : 암호화된 TCP 기반 프로토콜 SSU2 : 암호화된 UDP 기반 프로토콜 두 프로토콜 모두 현대적인 Noise Protocol Framework 를 기반으로 구축되어 강력한 인증과 트래픽 핑거프린팅(traffic fingerprinting, 트래픽 패턴 분석을 통한 식별 기법)에 대한 저항력을 제공합니다. 이들은 레거시 NTCP 및 SSU 프로토콜을 대체했으며(2023년부터 완전히 폐기됨),\nNTCP2는 TCP를 통한 암호화되고 효율적인 스트리밍을 제공합니다.\nSSU2는 UDP 기반의 신뢰성, NAT 통과, 그리고 선택적 홀 펀칭을 제공합니다. SSU2는 개념적으로 WireGuard 또는 QUIC와 유사하며, 신뢰성과 익명성의 균형을 맞춥니다.\n라우터는 IPv4와 IPv6을 모두 지원할 수 있으며, netDb에 전송 주소와 비용을 게시합니다. 연결의 전송 방식은 조건과 기존 링크에 최적화된 입찰 시스템에 의해 동적으로 선택됩니다.\n네트워크 데이터베이스 (netDb) I2P는 모든 구성 요소에 대해 계층화된 암호화를 사용합니다: 전송, tunnel, garlic 메시지 및 netDb.\n현재 프리미티브는 다음을 포함합니다:\n키 교환을 위한 X25519 서명을 위한 EdDSA (Ed25519) 인증된 암호화를 위한 ChaCha20-Poly1305 해싱을 위한 SHA-256 tunnel 계층 암호화를 위한 AES256 레거시 알고리즘(ElGamal, DSA-SHA1, ECDSA)은 하위 호환성을 위해 유지됩니다.\nI2P는 현재 \u0026ldquo;지금 수집하고 나중에 복호화\u0026rdquo; 공격에 대응하기 위해 X25519와 ML-KEM을 결합한 하이브리드 양자내성(PQ) 암호화 방식을 도입하고 있습니다.\nGarlic Messages Garlic 메시지는 독립적인 전달 지침을 가진 여러 암호화된 \u0026ldquo;clove\u0026quot;들을 그룹화하여 onion routing을 확장합니다. 이를 통해 메시지 수준의 라우팅 유연성과 균일한 트래픽 패딩이 가능합니다.\nSession Tags 엔드투엔드 암호화를 위해 두 가지 암호화 시스템이 지원됩니다:\nElGamal/AES+SessionTags (레거시):\n사전 전달된 세션 태그를 32바이트 nonce로 사용합니다. 비효율성으로 인해 현재는 더 이상 사용되지 않습니다.\nECIES-X25519-AEAD-Ratchet (현재):\nChaCha20-Poly1305와 동기화된 HKDF 기반 PRNG를 사용하여 임시 세션 키와 8바이트 태그를 동적으로 생성하며, 전방향 비밀성(forward secrecy)을 유지하면서 CPU, 메모리 및 대역폭 오버헤드를 줄입니다.\nFuture of the Protocol 주요 연구 분야는 국가 수준의 공격자에 대한 보안 유지와 양자 이후 암호화(post-quantum) 보호 도입에 집중하고 있습니다. 두 가지 초기 설계 개념인 제한된 경로와 가변 지연 시간은 현대적인 발전으로 대체되었습니다.\nRestricted Route Operation 원래 제한된 라우팅 개념은 IP 주소를 숨기는 것을 목표로 했습니다. 이러한 필요성은 다음에 의해 크게 완화되었습니다:\n자동 포트 포워딩을 위한 UPnP SSU2에서의 강력한 NAT 통과 IPv6 지원 협력적인 introducer 및 NAT hole-punching 선택적 오버레이(예: Yggdrasil) 연결성 따라서 현대의 I2P는 복잡한 제한된 라우팅 없이도 동일한 목표를 더 실용적으로 달성합니다.\nSimilar Systems I2P는 메시지 지향 미들웨어, DHT, 그리고 믹스넷의 개념을 통합합니다. 이 플랫폼의 혁신성은 이러한 요소들을 사용 가능하고 자율적으로 조직되는 익명성 플랫폼으로 결합한 데 있습니다.\n전송 프로토콜 웹사이트 Tor와 I2P는 목표를 공유하지만 아키텍처적으로 다릅니다:\nTor: 회선 교환 방식; 신뢰할 수 있는 디렉토리 권한에 의존. (~10k 릴레이) I2P: 패킷 교환 방식; 완전히 분산된 DHT 기반 네트워크. (~50k routers) I2P의 단방향 터널은 더 적은 메타데이터를 노출하고 유연한 라우팅 경로를 허용하는 반면, Tor는 익명 **인터넷 접속(outproxying)**에 초점을 맞춥니다. I2P는 대신 익명 네트워크 내 호스팅을 지원합니다.\n암호화 웹사이트 Freenet은 익명의 영구적인 파일 게시 및 검색에 중점을 둡니다. 반면 I2P는 대화형 사용(웹, 채팅, 토렌트)을 위한 실시간 통신 계층을 제공합니다. 두 시스템은 서로를 보완합니다 — Freenet은 검열 저항 저장소를 제공하고, I2P는 전송 익명성을 제공합니다.\nOther Networks Lokinet: 인센티브 기반 서비스 노드를 사용하는 IP 기반 오버레이. Nym: 더 높은 지연시간에서 커버 트래픽을 통해 메타데이터 보호를 강조하는 차세대 믹스넷. Appendix A: Application Layer I2P 자체는 메시지 전송만 처리합니다. 애플리케이션 계층 기능은 API와 라이브러리를 통해 외부적으로 구현됩니다.\nStreaming Library streaming library는 I2P의 TCP 유사 기능으로 작동하며, 고지연 익명 전송에 최적화된 슬라이딩 윈도우 프로토콜과 혼잡 제어를 제공합니다.\n일반적인 HTTP 요청/응답 패턴은 메시지 번들링 최적화로 인해 단일 왕복으로 완료될 수 있습니다.\nNaming Library and Address Book 개발자: mihi, Ragnarok 이름 지정 및 주소록 페이지를 참조하세요.\nI2P의 이름 시스템은 로컬 및 분산형이며, DNS 방식의 전역 이름을 사용하지 않습니다. 각 router는 사람이 읽을 수 있는 이름과 destination의 로컬 매핑을 유지합니다. 선택적으로 신뢰 네트워크 기반 주소록을 공유하거나 신뢰할 수 있는 피어로부터 가져올 수 있습니다.\n이 접근 방식은 중앙화된 권한을 피하고 글로벌 또는 투표 방식의 네이밍 시스템에 내재된 시빌(Sybil) 취약점을 우회합니다.\n제한된 라우트 운영 개발자: mihi\nI2PTunnel은 익명 TCP 프록시를 가능하게 하는 주요 클라이언트 계층 인터페이스입니다. 다음을 지원합니다:\nClient 터널 (I2P 목적지로의 아웃바운드) HTTP 클라이언트 (eepproxy) \u0026ldquo;.i2p\u0026rdquo; 도메인용 Server 터널 (I2P에서 로컬 서비스로의 인바운드) HTTP 서버 터널 (웹 서비스를 안전하게 프록시) 일반 인터넷으로의 Outproxy는 선택 사항이며, 자원봉사자가 운영하는 \u0026ldquo;서버\u0026rdquo; 터널을 통해 구현됩니다.\nI2PSnark 개발자: jrandom 외 — Snark 에서 포팅됨\nI2P에 번들로 포함된 I2PSnark는 DHT 및 UDP를 지원하는 익명 멀티-토렌트 BitTorrent 클라이언트로, 웹 인터페이스를 통해 접근할 수 있습니다.\nTor 개발자: postman, susi23, mastiejaner\nI2Pmail은 I2PTunnel 연결을 통해 익명 이메일을 제공합니다. Susimail은 기존 이메일 클라이언트에서 흔히 발생하는 정보 유출을 방지하도록 특별히 제작된 웹 기반 클라이언트입니다. mail.i2p 서비스는 바이러스 필터링, hashcash 할당량, 그리고 추가 보호를 위한 outproxy 분리 기능을 제공합니다.\n","description":"I2P 아키텍처 및 운영에 대한 기술적 소개","id":"75218044125880755dabbc53c9ce4b06","section":"docs","title":"I2P: 익명 통신을 위한 확장 가능한 프레임워크","url":"/ko/docs/overview/tech-intro/"},{"categories":null,"content":"I2PControl API 문서 I2PControl은 I2P router에 번들로 제공되는(버전 0.9.39부터) JSON-RPC 2.0 API입니다. 구조화된 JSON 요청을 통해 인증된 모니터링 및 router 제어를 가능하게 합니다.\n기본 비밀번호: itoopie — 이것은 공장 기본값이며 보안을 위해 즉시 변경해야 합니다.\n1. 개요 및 접근 Implementation Default Endpoint Protocol Enabled by Default Notes Java I2P (2.10.0+) http://127.0.0.1:7657/jsonrpc/ HTTP ❌ Must be enabled via WebApps (Router Console) Bundled webapp i2pd (C++ implementation) https://127.0.0.1:7650/ HTTPS ✅ Enabled by default Legacy plugin behavior Java I2P의 경우, **Router Console → WebApps → I2PControl**로 이동하여 활성화해야 합니다 (자동 시작으로 설정). 활성화되면 모든 메서드는 먼저 인증하고 세션 토큰을 받아야 합니다. 2. JSON-RPC 형식 모든 요청은 JSON-RPC 2.0 구조를 따릅니다:\n{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;MethodName\u0026#34;, \u0026#34;params\u0026#34;: { /* named parameters */ } } 성공적인 응답에는 result 필드가 포함되며, 실패 시에는 error 객체가 반환됩니다:\n{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;result\u0026#34;: { /* data */ } } 또는\n{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;error\u0026#34;: { \u0026#34;code\u0026#34;: -32001, \u0026#34;message\u0026#34;: \u0026#34;Invalid password\u0026#34; } } 3. 인증 흐름 요청 (인증) curl -s -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;Authenticate\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;API\u0026#34;: 1, \u0026#34;Password\u0026#34;: \u0026#34;itoopie\u0026#34; } }\u0026#39; \\ http://127.0.0.1:7657/jsonrpc/ 성공 응답 { \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;result\u0026#34;: { \u0026#34;Token\u0026#34;: \u0026#34;a1b2c3d4e5\u0026#34;, \u0026#34;API\u0026#34;: 1 } } 이후의 모든 요청에서 params에 해당 Token을 포함해야 합니다.\n4. 메서드 및 엔드포인트 4.1 RouterInfo router에 대한 주요 원격 측정 데이터를 가져옵니다.\n요청 예시\ncurl -s -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;2\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;RouterInfo\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;Token\u0026#34;: \u0026#34;a1b2c3d4e5\u0026#34;, \u0026#34;i2p.router.version\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;i2p.router.status\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;i2p.router.net.status\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;i2p.router.net.tunnels.participating\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;i2p.router.net.bw.inbound.1s\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;i2p.router.net.bw.outbound.1s\u0026#34;: \u0026#34;\u0026#34; } }\u0026#39; \\ http://127.0.0.1:7657/jsonrpc/ 응답 필드 (result) 공식 문서(GetI2P)에 따르면: - i2p.router.status (String) — 사람이 읽을 수 있는 상태 - i2p.router.uptime (long) — 밀리초 단위 (또는 구 버전 i2pd에서는 문자열) :contentReference[oaicite:0]{index=0} - i2p.router.version (String) — 버전 문자열 :contentReference[oaicite:1]{index=1} - i2p.router.net.bw.inbound.1s, i2p.router.net.bw.inbound.15s (double) — 인바운드 대역폭 (B/s 단위) :contentReference[oaicite:2]{index=2} - i2p.router.net.bw.outbound.1s, i2p.router.net.bw.outbound.15s (double) — 아웃바운드 대역폭 (B/s 단위) :contentReference[oaicite:3]{index=3} - i2p.router.net.status (long) — 숫자 상태 코드 (아래 열거형 참조) :contentReference[oaicite:4]{index=4} - i2p.router.net.tunnels.participating (long) — 참여 중인 tunnel 수 :contentReference[oaicite:5]{index=5} - i2p.router.netdb.activepeers, fastpeers, highcapacitypeers (long) — netDB 피어 통계 :contentReference[oaicite:6]{index=6} - i2p.router.netdb.isreseeding (boolean) — 리시드(reseed) 활성 여부 :contentReference[oaicite:7]{index=7} - i2p.router.netdb.knownpeers (long) — 알려진 총 피어 수 :contentReference[oaicite:8]{index=8}\n상태 코드 열거형 (i2p.router.net.status) Code Meaning 0 OK 1 TESTING 2 FIREWALLED 3 HIDDEN 4 WARN_FIREWALLED_AND_FAST 5 WARN_FIREWALLED_AND_FLOODFILL 6 WARN_FIREWALLED_WITH_INBOUND_TCP 7 WARN_FIREWALLED_WITH_UDP_DISABLED 8 ERROR_I2CP 9 ERROR_CLOCK_SKEW 10 ERROR_PRIVATE_TCP_ADDRESS 11 ERROR_SYMMETRIC_NAT 12 ERROR_UDP_PORT_IN_USE 13 ERROR_NO_ACTIVE_PEERS_CHECK_CONNECTION_AND_FIREWALL 14 ERROR_UDP_DISABLED_AND_TCP_UNSET --- 4.2 GetRate 주어진 시간 범위 동안 속도 메트릭(예: 대역폭, tunnel 성공률)을 가져오는 데 사용됩니다.\n요청 예시\ncurl -s -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;3\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;GetRate\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;Token\u0026#34;: \u0026#34;a1b2c3d4e5\u0026#34;, \u0026#34;Stat\u0026#34;: \u0026#34;bw.combined\u0026#34;, \u0026#34;Period\u0026#34;: 60000 } }\u0026#39; \\ http://127.0.0.1:7657/jsonrpc/ 샘플 응답\n{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;3\u0026#34;, \u0026#34;result\u0026#34;: { \u0026#34;Rate\u0026#34;: 12345.67 } } 4.3 RouterManager 관리 작업을 수행합니다.\n허용된 매개변수 / 메서드 - Restart, RestartGraceful - Shutdown, ShutdownGraceful - Reseed, FindUpdates, Update :contentReference[oaicite:10]{index=10}\n요청 예시\ncurl -s -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;4\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;RouterManager\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;Token\u0026#34;: \u0026#34;a1b2c3d4e5\u0026#34;, \u0026#34;Restart\u0026#34;: true } }\u0026#39; \\ http://127.0.0.1:7657/jsonrpc/ 성공 응답\n{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;4\u0026#34;, \u0026#34;result\u0026#34;: { \u0026#34;Restart\u0026#34;: null } } 4.4 NetworkSetting 네트워크 구성 매개변수 가져오기 또는 설정(포트, UPnP, 대역폭 공유 등)\n요청 예제 (현재 값 가져오기)\ncurl -s -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;5\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;NetworkSetting\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;Token\u0026#34;: \u0026#34;a1b2c3d4e5\u0026#34;, \u0026#34;i2p.router.net.ntcp.port\u0026#34;: null, \u0026#34;i2p.router.net.ssu.port\u0026#34;: null, \u0026#34;i2p.router.net.bw.share\u0026#34;: null, \u0026#34;i2p.router.net.upnp\u0026#34;: null } }\u0026#39; \\ http://127.0.0.1:7657/jsonrpc/ 샘플 응답\n{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;5\u0026#34;, \u0026#34;result\u0026#34;: { \u0026#34;i2p.router.net.ntcp.port\u0026#34;: \u0026#34;1234\u0026#34;, \u0026#34;i2p.router.net.ssu.port\u0026#34;: \u0026#34;5678\u0026#34;, \u0026#34;i2p.router.net.bw.share\u0026#34;: \u0026#34;50\u0026#34;, \u0026#34;i2p.router.net.upnp\u0026#34;: \u0026#34;true\u0026#34;, \u0026#34;SettingsSaved\u0026#34;: true, \u0026#34;RestartNeeded\u0026#34;: false } } 참고: 2.41 이전 버전의 i2pd는 문자열 대신 숫자 타입을 반환할 수 있습니다 — 클라이언트는 두 가지 모두를 처리해야 합니다. :contentReference[oaicite:11]{index=11}\n4.5 고급 설정 내부 라우터 매개변수를 조작할 수 있습니다.\n요청 예제\ncurl -s -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;6\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;AdvancedSettings\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;Token\u0026#34;: \u0026#34;a1b2c3d4e5\u0026#34;, \u0026#34;Set\u0026#34;: { \u0026#34;router.sharePercentage\u0026#34;: \u0026#34;75\u0026#34;, \u0026#34;i2np.flushInterval\u0026#34;: \u0026#34;6000\u0026#34; } } }\u0026#39; \\ http://127.0.0.1:7657/jsonrpc/ 응답 예시\n{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;6\u0026#34;, \u0026#34;result\u0026#34;: { \u0026#34;Set\u0026#34;: { \u0026#34;router.sharePercentage\u0026#34;: \u0026#34;75\u0026#34;, \u0026#34;i2np.flushInterval\u0026#34;: \u0026#34;6000\u0026#34; } } } 5. 오류 코드 표준 JSON-RPC 오류(-32700, -32600 등) 외에도 I2PControl은 다음을 정의합니다:\nCode Meaning -32001 Invalid password -32002 Missing token -32003 Token does not exist -32004 Token expired -32005 API version missing -32006 API version unsupported --- 6. 사용법 및 모범 사례 인증 시를 제외하고는 항상 Token 매개변수를 포함하세요. 첫 사용 시 기본 비밀번호(itoopie)를 변경하세요. Java I2P의 경우, WebApps를 통해 I2PControl webapp이 활성화되어 있는지 확인하세요. 약간의 차이에 대비하세요: 일부 필드는 I2P 버전에 따라 숫자 또는 문자열일 수 있습니다. 표시하기 좋은 출력을 위해 긴 상태 문자열을 줄 바꿈하세요. ","description":"I2PControl 웹앱을 통한 원격 라우터 관리 API","id":"f0e7aa57ce714931128f06f6bdb94db3","section":"docs","title":"I2PControl JSON-RPC","url":"/ko/docs/api/i2pcontrol/"},{"categories":null,"content":"개요 I2PTunnel은 I2P 네트워크에서 서비스를 제공하고 인터페이스하기 위한 핵심 I2P 구성 요소입니다. tunnel 추상화를 통해 TCP 기반 및 미디어 스트리밍 애플리케이션이 익명으로 작동할 수 있도록 합니다. tunnel의 목적지는 hostname , Base32 또는 전체 destination 키로 정의할 수 있습니다.\n설정된 각 tunnel은 로컬에서 수신 대기하며(예: localhost:port) I2P 목적지에 내부적으로 연결됩니다. 서비스를 호스팅하려면 원하는 IP와 포트를 가리키는 tunnel을 생성하세요. 해당 I2P destination 키가 생성되어 I2P 네트워크 내에서 서비스에 전역적으로 접근할 수 있게 됩니다. I2PTunnel 웹 인터페이스는 I2P Router Tunnel Manager 에서 이용할 수 있습니다.\n기본 서비스 서버 터널 I2P Webserver – I2P에서 쉽게 호스팅할 수 있도록 localhost:7658 의 Jetty 웹서버로 연결되는 tunnel입니다. Unix: $HOME/.i2p/eepsite/docroot Windows: %LOCALAPPDATA%\\I2P\\I2P Site\\docroot → C:\\Users\\\u0026lt;username\u0026gt;\\AppData\\Local\\I2P\\I2P Site\\docroot 클라이언트 터널 I2P HTTP Proxy – localhost:4444 – outproxy를 통해 I2P 및 인터넷을 탐색하는 데 사용됩니다. I2P HTTPS Proxy – localhost:4445 – HTTP proxy의 보안 버전입니다. Irc2P – localhost:6668 – 기본 익명 IRC 네트워크 tunnel입니다. Git SSH (gitssh.idk.i2p) – localhost:7670 – 저장소 SSH 접근을 위한 클라이언트 tunnel입니다. Postman SMTP – localhost:7659 – 발신 메일을 위한 클라이언트 tunnel입니다. Postman POP3 – localhost:7660 – 수신 메일을 위한 클라이언트 tunnel입니다. 참고: I2P 웹서버만이 기본 server tunnel이며, 나머지는 모두 외부 I2P 서비스에 연결하는 클라이언트 터널입니다.\n설정 I2PTunnel 구성 사양은 /spec/configuration 에 문서화되어 있습니다.\n클라이언트 모드 표준 I2P destination의 서비스에 연결하는 로컬 TCP 포트를 엽니다. 중복성을 위해 쉼표로 구분된 여러 destination 항목을 지원합니다.\nHTTP HTTP/HTTPS 요청을 위한 프록시 터널입니다. 로컬 및 원격 outproxy, 헤더 제거, 캐싱, 인증 및 투명한 압축을 지원합니다.\n개인정보 보호 기능: - 헤더 제거: Accept-*, Referer, Via, From - 호스트 헤더를 Base32 destination으로 교체 - RFC 준수 hop-by-hop 제거 강제 적용 - 투명한 압축 해제 지원 추가 - 내부 오류 페이지 및 현지화된 응답 제공\n압축 동작: - 요청은 커스텀 헤더 X-Accept-Encoding: x-i2p-gzip을 사용할 수 있습니다 - Content-Encoding: x-i2p-gzip이 포함된 응답은 투명하게 압축 해제됩니다 - 압축은 효율성을 위해 MIME 타입과 응답 길이로 평가됩니다\n지속성 (2.5.0부터 새로 추가): HTTP Keepalive와 지속 연결이 이제 Hidden Services Manager를 통해 I2P 호스팅 서비스에서 지원됩니다. 이는 지연 시간과 연결 오버헤드를 줄이지만 아직 모든 홉에서 RFC 2616 완전 준수 지속 소켓을 활성화하지는 않습니다.\n파이프라이닝: 지원되지 않으며 불필요합니다. 최신 브라우저에서는 이미 사용 중단되었습니다.\nUser-Agent 동작: - Outproxy: 최신 Firefox ESR User-Agent를 사용합니다. - Internal: 익명성 일관성을 위해 MYOB/6.66 (AN/ON)을 사용합니다.\nIRC 클라이언트 I2P 기반 IRC 서버에 연결합니다. 프라이버시 보호를 위해 식별자를 필터링하면서 안전한 명령어 하위 집합을 허용합니다.\nSOCKS 4/4a/5 TCP 연결을 위한 SOCKS 프록시 기능을 제공합니다. UDP는 Java I2P에서 구현되지 않았습니다 (i2pd에서만 구현됨).\n연결 SSL/TLS 연결을 위한 HTTP CONNECT 터널링을 구현합니다.\nStreamr TCP 기반 캡슐화를 통해 UDP 스타일 스트리밍을 활성화합니다. 해당하는 Streamr 서버 터널과 페어링되면 미디어 스트리밍을 지원합니다.\n서버 모드 표준 서버 로컬 IP:포트에 매핑된 TCP destination을 생성합니다.\nHTTP 서버 로컬 웹 서버와 인터페이스하는 destination을 생성합니다. 압축(x-i2p-gzip), 헤더 제거 및 DDoS 보호 기능을 지원합니다. 이제 지속 연결 지원(v2.5.0+) 및 스레드 풀링 최적화(v2.7.0–2.9.0)의 이점을 제공합니다.\nHTTP 양방향 더 이상 사용되지 않음 – 여전히 작동하지만 권장되지 않습니다. outproxy 없이 HTTP 서버와 클라이언트 역할을 모두 수행합니다. 주로 진단 루프백 테스트에 사용됩니다.\nIRC 서버 IRC 서비스를 위한 필터링된 destination을 생성하며, 클라이언트 destination 키를 호스트명으로 전달합니다.\nStreamr 서버 I2P를 통해 UDP 스타일 데이터 스트림을 처리하기 위해 Streamr 클라이언트 터널과 결합됩니다.\n새로운 기능 (2.4.0–2.10.0) Feature Introduced Summary Keepalive/Persistent Connections 2.5.0 HTTP tunnels now support persistent sockets for I2P-hosted services, improving performance. Thread Pooling Optimization 2.7.0-2.9.0 Reduced CPU overhead and latency by improving thread management. Post-Quantum Encryption (ML-KEM) 2.10.0 Optional hybrid X25519+ML-KEM encryption to resist future quantum attacks. NetDB Segmentation 2.4.0 Isolates I2PTunnel contexts for improved security and privacy. SSU1 Removal / SSU2 Adoption 2.4.0-2.6.0 Upgraded transport layer; transparent to users. I2P-over-Tor Blocking 2.6.0 Prevents inefficient and unstable I2P-over-Tor routing. Browser Proxy (Proposal 166) 2.7.0 Introduced identity-aware proxy mode; details pending confirmation. Java 17 Requirement (upcoming) 2.11.0 Future release will require Java 17+. --- 보안 기능 익명성을 위한 헤더 제거 (Accept, Referer, From, Via) in/outproxy에 따른 User-Agent 무작위화 POST 속도 제한 및 Slowloris 보호 스트리밍 하위 시스템의 연결 조절 tunnel 계층의 네트워크 혼잡 처리 애플리케이션 간 유출 방지를 위한 NetDB 격리 기술 세부사항 기본 destination 키 크기: 516바이트 (확장된 LS2 인증서의 경우 초과 가능) Base32 주소: {52–56+ chars}.b32.i2p Server tunnel은 Java I2P와 i2pd 모두와 호환성 유지 사용 중단된 기능: httpbidirserver만 해당; 0.9.59 이후 제거된 항목 없음 모든 플랫폼에서 기본 포트 및 document root가 올바른지 검증 완료 요약 I2PTunnel은 I2P와 애플리케이션 통합의 핵심으로 남아 있습니다. 0.9.59와 2.10.0 사이에서 지속적 연결 지원, 포스트 양자 암호화, 그리고 주요 스레딩 개선 사항이 추가되었습니다. 대부분의 구성은 호환성을 유지하지만, 개발자는 현대적인 전송 및 보안 기본값을 준수하는지 확인하기 위해 설정을 검증해야 합니다.\n","description":"I2P와 인터페이스하고 서비스를 제공하기 위한 도구","id":"7e5d426e3eead28c1767764107b1f3d1","section":"docs","title":"I2PTunnel","url":"/ko/docs/api/i2ptunnel/"},{"categories":null,"content":"개요 I2P 기반 BitTorrent는 I2P의 스트리밍 계층을 사용하여 암호화된 tunnel을 통해 익명 파일 공유를 가능하게 합니다. 모든 피어는 IP 주소 대신 암호화된 I2P destination으로 식별됩니다. 이 시스템은 HTTP 및 UDP 트래커, 하이브리드 마그넷 링크, 양자내성 하이브리드 암호화를 지원합니다.\n1. 프로토콜 스택 Layer Function Example Application BitTorrent i2psnark, BiglyBT Transport Streaming / SAM v3 I2CP, NTCP2 Network Garlic routing I2NP 모든 연결은 I2P의 암호화된 전송 계층(NTCP2 또는 SSU2)을 통해 실행됩니다. UDP 트래커 패킷도 I2P 스트리밍 내에 캡슐화됩니다. 2. 트래커 HTTP 트래커 표준 .i2p 트래커는 다음과 같은 HTTP GET 요청에 응답합니다:\nhttp://tracker2.postman.i2p/announce?info_hash=\u0026lt;20-byte\u0026gt;\u0026amp;peer_id=\u0026lt;20-byte\u0026gt;\u0026amp;port=6881\u0026amp;uploaded=0\u0026amp;downloaded=0\u0026amp;left=1234\u0026amp;compact=1 응답은 bencoded 형식이며 피어에 대해 I2P destination 해시를 사용합니다.\nUDP 트래커 UDP 트래커는 2025년에 표준화되었습니다 (제안 160).\n주요 UDP 트래커 - udp://tracker2.postman.i2p/announce - udp://opentracker.simp.i2p/a - http://opentracker.skank.i2p/a - http://opentracker.dg2.i2p/a \u0026mdash;\n3. 마그넷 링크 magnet:?xt=urn:btih:\u0026lt;infohash\u0026gt;\u0026amp;dn=\u0026lt;name\u0026gt;\u0026amp;tr=http://tracker2.postman.i2p/announce\u0026amp;tr=udp://denpa.i2p/announce\u0026amp;xs=i2p:\u0026lt;destination.b32.i2p\u0026gt; Parameter Meaning xs=i2p:\u0026lt;dest\u0026gt; Explicit I2P destination tr= Tracker URLs (HTTP or UDP) dn= Display name 마그넷 링크는 구성 시 I2P와 일반 인터넷(clearnet)에 걸친 하이브리드 스웜을 지원합니다. 4. DHT 구현 Implementation Type Status Java I2P Experimental overlay Stable i2pd UDP-based internal overlay Active BiglyBT SAM v3.3-based Fully supported --- 5. 클라이언트 구현 I2PSnark 모든 라우터에 번들로 포함됨 HTTP 전용 트래커 지원 http://127.0.0.1:7658/에 내장 트래커 제공 UDP 트래커 미지원 BiglyBT I2P 플러그인이 포함된 모든 기능 지원 HTTP + UDP tracker 지원 하이브리드 토렌트 지원 SAM v3.3 인터페이스 사용 Tixati / XD 경량 클라이언트 SAM 기반 터널링 실험적 ML-KEM 하이브리드 암호화 6. 설정 I2PSnark i2psnark.dir=/home/user/torrents i2psnark.autostart=true i2psnark.maxUpBW=128 i2psnark.maxDownBW=256 i2psnark.enableDHT=false BiglyBT SAMHost=127.0.0.1 SAMPort=7656 SAMNickname=BiglyBT-I2P SAMAutoStart=true DHTEnabled=true 7. 보안 모델 Component Description Encryption NTCP2 / SSU2 with X25519+ML-KEM hybrid Identity I2P destinations replace IP addresses Anonymity Peer info hidden; traffic multiplexed Leak Prevention Remove headers (X-Forwarded-For, Client-IP, Via) 하이브리드(일반 인터넷 + I2P) 토렌트는 익명성이 중요하지 않은 경우에만 사용해야 합니다. 8. 성능 Factor Impact Recommendation Tunnel length Adds latency 1-hop client, 2-hop server Peers Boosts speed 20+ active peers Compression Minimal gain Usually off Bandwidth Router-limited Default settings optimal 일반적인 속도는 피어 및 네트워크 상태에 따라 **30–80 KB/s** 범위입니다. 9. 알려진 문제 Java I2P와 i2pd 간 부분적인 DHT 상호 운용성 높은 부하 상태에서 마그넷 메타데이터 가져오기 지연 NTCP1은 더 이상 권장되지 않지만 여전히 오래된 피어에서 사용됨 스트리밍을 통한 UDP 시뮬레이션으로 지연 시간 증가 10. 향후 로드맵 QUIC와 유사한 멀티플렉싱 완전한 ML-KEM 통합 통합된 하이브리드 스웜 로직 개선된 재시드 미러 적응형 DHT 재시도 참고 자료 BEP 15 – UDP Tracker Protocol Proposal 160 – UDP Tracker over I2P I2PSnark 문서 Streaming Library 사양 ","description":"I2P 네트워크 내 BitTorrent에 대한 상세 사양 및 생태계 개요","id":"5d0ca50c8763996448d3099a14dc36b0","section":"docs","title":"I2P를 통한 BitTorrent","url":"/ko/docs/applications/bittorrent/"},{"categories":null,"content":"I2P 내에서 저장소를 복제하고 푸시하는 것은 이미 알고 있는 Git 명령어를 그대로 사용합니다. 클라이언트가 TCP/IP 대신 I2P tunnel을 통해 연결할 뿐입니다. 이 가이드는 계정 설정, tunnel 구성, 그리고 느린 연결 처리 방법을 안내합니다.\n빠른 시작: 읽기 전용 접근은 HTTP 프록시를 통해 작동합니다: http_proxy=http://127.0.0.1:4444 git clone http://example.i2p/project.git. SSH 읽기/쓰기 접근을 위해서는 아래 단계를 따르세요.\n1. 계정 만들기 I2P Git 서비스를 선택하고 등록하세요:\nI2P 내부: http://git.idk.i2p Clearnet 미러: https://i2pgit.org 등록에는 수동 승인이 필요할 수 있습니다. 안내 페이지에서 지침을 확인하세요. 승인되면 저장소를 포크하거나 생성하여 테스트할 수 있는 환경을 준비하세요.\n2. I2PTunnel 클라이언트 구성 (SSH) router console → I2PTunnel을 열고 새로운 Client 터널을 추가합니다. 서비스의 destination(Base32 또는 Base64)을 입력합니다. git.idk.i2p의 경우 프로젝트 홈페이지에서 HTTP와 SSH destination을 모두 찾을 수 있습니다. 로컬 포트를 선택합니다(예: localhost:7442). 터널을 자주 사용할 계획이라면 자동 시작을 활성화합니다. UI가 새 터널을 확인하고 상태를 표시합니다. 실행 중일 때, SSH 클라이언트는 선택한 포트의 127.0.0.1에 연결할 수 있습니다.\n3. SSH를 통한 클론 GIT_SSH_COMMAND 또는 SSH 설정 구문과 함께 터널 포트를 사용하세요:\nGIT_SSH_COMMAND=\u0026#34;ssh -p 7442\u0026#34; \\ git clone git@127.0.0.1:your-project/example.git 첫 번째 시도가 실패하면 (터널이 느릴 수 있음), shallow clone을 시도하세요:\nGIT_SSH_COMMAND=\u0026#34;ssh -p 7442\u0026#34; \\ git clone --depth 1 git@127.0.0.1:your-project/example.git cd example git fetch --unshallow 모든 브랜치를 가져오도록 Git 설정:\ngit config remote.origin.fetch \u0026#34;+refs/heads/*:refs/remotes/origin/*\u0026#34; git fetch origin 성능 최적화 팁 복원력을 향상시키기 위해 터널 편집기에서 백업 tunnel을 하나 또는 두 개 추가하세요. 테스트용이거나 위험도가 낮은 저장소의 경우 tunnel 길이를 1 hop으로 줄일 수 있지만, 익명성 트레이드오프를 유념하세요. 환경 변수에 GIT_SSH_COMMAND를 유지하거나 ~/.ssh/config에 항목을 추가하세요: Host git.i2p HostName 127.0.0.1 Port 7442 User git 그런 다음 git clone git@git.i2p:namespace/project.git를 사용하여 클론합니다.\n4. 워크플로우 제안 GitLab/GitHub에서 일반적으로 사용하는 fork-and-branch 워크플로우를 채택하세요:\nupstream 원격 저장소 설정: git remote add upstream git@git.i2p:I2P_Developers/i2p.i2p master 브랜치를 동기화 상태로 유지: git pull upstream master 변경사항을 위한 기능 브랜치 생성: git checkout -b feature/new-thing 브랜치를 본인의 포크로 푸시: git push origin feature/new-thing 병합 요청을 제출한 후, upstream에서 포크의 master를 fast-forward로 업데이트합니다. 5. 프라이버시 주의사항 Git은 커밋 타임스탬프를 로컬 시간대로 저장합니다. UTC 타임스탬프를 강제 적용하려면: git config --global alias.utccommit \u0026#39;!git commit --date=\u0026#34;$(date --utc +%Y-%m-%dT%H:%M:%S%z)\u0026#34;\u0026#39; 프라이버시가 중요할 때는 git commit 대신 git utccommit을 사용하세요.\n익명성이 우려 사항인 경우 커밋 메시지나 저장소 메타데이터에 clearnet URL이나 IP를 포함하지 마세요. 6. 문제 해결 Symptom Fix connection closed during clone Retry with --depth 1, add backup tunnels, or increase tunnel quantities. ssh: connect to host 127.0.0.1 port …: Connection refused Ensure the I2PTunnel client is running and SAM is enabled. Slow performance Lower tunnel length, increase bandwidth limits, or schedule large fetches during off-peak hours. 고급 시나리오(외부 저장소 미러링, 번들 시딩)에 대해서는 관련 가이드를 참조하세요: [Git 번들 워크플로우](/docs/applications/git-bundle/) 및 [I2P를 통한 GitLab 호스팅](/docs/guides/gitlab/). ","description":"i2pgit.org와 같은 I2P 호스팅 서비스에 Git 클라이언트 연결하기","id":"17704a86e8676ba273355af4fa703c15","section":"docs","title":"I2P를 통한 Git","url":"/ko/docs/applications/git/"},{"categories":null,"content":"I2P 내부에서 GitLab을 호스팅하는 것은 간단합니다: GitLab omnibus 컨테이너를 실행하고, 루프백에 노출시킨 다음, I2P tunnel을 통해 트래픽을 포워딩하면 됩니다. 아래 단계는 git.idk.i2p에 사용된 구성을 반영하지만 모든 자체 호스팅 인스턴스에서 작동합니다.\n1. 전제 조건 Docker Engine이 설치된 Debian 또는 다른 Linux 배포판 (sudo apt install docker.io 또는 Docker 저장소의 docker-ce). 사용자에게 서비스를 제공하기에 충분한 대역폭을 가진 I2P router (Java I2P 또는 i2pd). 선택사항: GitLab과 router를 데스크톱 환경에서 격리하기 위한 전용 VM. 2. GitLab 이미지 가져오기 docker pull gitlab/gitlab-ce:latest 공식 이미지는 Ubuntu 기본 레이어에서 빌드되며 정기적으로 업데이트됩니다. 추가적인 확신이 필요하다면 Dockerfile 을 검토하세요.\n3. 브리지 모드 vs. I2P 전용 모드 결정 I2P 전용 인스턴스는 클리어넷 호스트에 절대 접속하지 않습니다. 사용자는 다른 I2P 서비스에서 저장소를 미러링할 수 있지만 GitHub/GitLab.com에서는 할 수 없습니다. 이는 익명성을 최대화합니다. 브리지 인스턴스는 HTTP 프록시를 통해 클리어넷 Git 호스트에 접속합니다. 이는 공개 프로젝트를 I2P로 미러링하는 데 유용하지만 서버의 아웃바운드 요청을 비익명화합니다. 브리지 모드를 선택한 경우, Docker 호스트에 바인딩된 I2P HTTP 프록시(예: http://172.17.0.1:4446)를 사용하도록 GitLab을 구성하세요. 기본 라우터 프록시는 127.0.0.1에서만 수신 대기합니다. Docker 게이트웨이 주소에 바인딩된 새 프록시 tunnel을 추가하세요.\n4. 컨테이너 시작 docker run --detach \\ --env HTTP_PROXY=http://172.17.0.1:4446 \\ # omit for I2P-only --publish 127.0.0.1:8443:443 \\ --publish 127.0.0.1:8080:80 \\ --publish 127.0.0.1:8022:22 \\ --name gitlab \\ --restart always \\ --volume /srv/gitlab/config:/etc/gitlab:Z \\ --volume /srv/gitlab/logs:/var/log/gitlab:Z \\ --volume /srv/gitlab/data:/var/opt/gitlab:Z \\ gitlab/gitlab-ce:latest 게시된 포트를 루프백에 바인딩하세요. I2P tunnel이 필요에 따라 노출합니다. /srv/gitlab/...을 호스트에 맞는 저장소 경로로 교체하세요. 컨테이너가 실행되면 https://127.0.0.1:8443/를 방문하여 관리자 비밀번호를 설정하고 계정 제한을 구성하세요.\n5. I2P를 통한 GitLab 노출 세 개의 I2PTunnel 서버 터널을 생성하세요:\nPurpose Local target Suggested inbound port HTTPS web UI 127.0.0.1:8443 auto-generated HTTP web UI (optional) 127.0.0.1:8080 auto-generated SSH push/pull 127.0.0.1:8022 auto-generated 각 tunnel을 적절한 tunnel 길이와 대역폭으로 구성하십시오. 공개 인스턴스의 경우, 방향당 4–6개의 tunnel로 3홉을 설정하는 것이 좋은 출발점입니다. 사용자가 클라이언트 tunnel을 구성할 수 있도록 결과로 생성된 Base32/Base64 destination을 랜딩 페이지에 게시하십시오. Destination Enforcement HTTP(S) 터널을 사용하는 경우, destination enforcement를 활성화하여 의도된 호스트명만 서비스에 접근할 수 있도록 하십시오. 이는 터널이 일반 프록시로 악용되는 것을 방지합니다.\n6. Maintenance Tips GitLab 설정을 변경할 때마다 docker exec gitlab gitlab-ctl reconfigure를 실행하세요. 디스크 사용량(/srv/gitlab/data)을 모니터링하세요—Git 저장소는 빠르게 증가합니다. 설정 및 데이터 디렉토리를 정기적으로 백업하세요. GitLab의 백업 rake 작업 은 컨테이너 내부에서 작동합니다. 외부 모니터링 tunnel을 클라이언트 모드로 배치하여 더 넓은 네트워크에서 서비스에 접근할 수 있는지 확인하는 것을 고려하세요. 6. 유지보수 팁 애플리케이션에 I2P 임베딩하기 I2P를 통한 Git (클라이언트 가이드) 오프라인/느린 네트워크를 위한 Git 번들 잘 구성된 GitLab 인스턴스는 I2P 내부에서 완전히 작동하는 협업 개발 허브를 제공합니다. router를 건강하게 유지하고, GitLab 보안 업데이트를 최신 상태로 유지하며, 사용자 기반이 성장함에 따라 커뮤니티와 협력하세요.\n","description":"Docker와 I2P router를 사용하여 I2P 내부에 GitLab 배포하기","id":"0c6aba5984de265324df6360a00204c9","section":"docs","title":"I2P를 통한 GitLab 실행","url":"/ko/docs/guides/gitlab/"},{"categories":null,"content":"개요 핵심 사항\nI2P는 터널을 통해 IRC 트래픽에 대한 종단간 암호화를 제공합니다. clearnet으로 outproxy하는 경우가 아니라면 IRC 클라이언트에서 SSL/TLS를 비활성화하세요. 사전 구성된 Irc2P 클라이언트 터널은 기본적으로 127.0.0.1:6668에서 수신 대기합니다. IRC 클라이언트를 해당 주소와 포트로 연결하세요. \u0026ldquo;router‑provided TLS\u0026quot;라는 용어를 사용하지 마세요. \u0026ldquo;I2P\u0026rsquo;s native encryption\u0026rdquo; 또는 \u0026ldquo;end‑to‑end encryption\u0026quot;을 사용하세요. 빠른 시작 (Java I2P) http://127.0.0.1:7657/i2ptunnel/에서 Hidden Services Manager를 열고 Irc2P tunnel이 실행 중인지 확인하세요. IRC 클라이언트에서 server = 127.0.0.1, port = 6668, SSL/TLS = off로 설정하세요. 연결한 후 #i2p, #i2p-dev, #i2p-help와 같은 채널에 참여하세요. i2pd 사용자(C++ router)의 경우, tunnels.conf에 client tunnel을 생성하세요(아래 예시 참조).\n네트워크와 서버 IRC2P (main community network) 연합 서버: irc.postman.i2p:6667, irc.echelon.i2p:6667, irc.dg.i2p:6667. 127.0.0.1:6668의 Irc2P tunnel은 이들 중 하나에 자동으로 연결됩니다. 주요 채널: #i2p, #i2p-chat, #i2p-dev, #i2p-help. Ilita network 서버: irc.ilita.i2p:6667, irc.r4sas.i2p:6667, irc.acetone.i2p:6667, rusirc.ilita.i2p:6667. 주요 언어: 러시아어 및 영어. 일부 호스트에서 웹 프론트엔드를 제공합니다. Client setup Recommended, actively maintained WeeChat (터미널) — 강력한 SOCKS 지원; 스크립팅이 용이함. Pidgin (데스크톱) — 여전히 유지보수 중; Windows/Linux에서 잘 작동함. Thunderbird Chat (데스크톱) — ESR 128+ 버전부터 지원됨. The Lounge (자체 호스팅 웹) — 최신 웹 클라이언트. IRC2P (메인 커뮤니티 네트워크) LimeChat (무료, 오픈 소스). Textual (App Store에서 유료 판매, 직접 빌드 가능한 소스 제공). Ilita 네트워크 WeeChat via SOCKS5 /proxy add i2p socks5 127.0.0.1 4447 /set irc.server.i2p.addresses \u0026#34;127.0.0.1/6668\u0026#34; /set irc.server.i2p.proxy \u0026#34;i2p\u0026#34; /connect i2p Pidgin 프로토콜: IRC 서버: 127.0.0.1 포트: 6668 암호화: off 사용자명/닉네임: 아무거나 Thunderbird Chat 계정 유형: IRC 서버: 127.0.0.1 포트: 6668 SSL/TLS: off 선택사항: 연결 시 채널 자동 참가 Dispatch (SAM v3) config.toml 기본값 예시:\n[defaults] name = \u0026#34;Irc2P\u0026#34; host = \u0026#34;irc.postman.i2p\u0026#34; port = 6667 channels = [\u0026#34;#i2p\u0026#34;,\u0026#34;#i2p-dev\u0026#34;] ssl = false Tunnel configuration Java I2P defaults Irc2P 클라이언트 터널: 127.0.0.1:6668 → 포트 6667의 업스트림 서버. Hidden Services Manager: http://127.0.0.1:7657/i2ptunnel/. 권장됨, 활발히 유지 관리됨 ~/.i2pd/tunnels.conf:\n[IRC-IRC2P] type = client address = 127.0.0.1 port = 6668 destination = irc.postman.i2p destinationport = 6667 keys = irc-keys.dat Ilita용 별도 터널 (예시):\n[IRC-ILITA] type = client address = 127.0.0.1 port = 6669 destination = irc.ilita.i2p destinationport = 6667 keys = irc-ilita-keys.dat macOS 옵션 Java I2P에서 SAM 활성화 (기본적으로 비활성화됨) - /configclients 또는 clients.config에서 설정. 기본값: 127.0.0.1:7656/TCP 및 127.0.0.1:7655/UDP. 권장 암호화: SIGNATURE_TYPE=7 (Ed25519) 및 i2cp.leaseSetEncType=4,0 (ECIES‑X25519 + ElGamal 폴백) 또는 최신 버전 전용인 경우 4만 사용. 예제 구성 Java I2P 기본값: 인바운드 2개 / 아웃바운드 2개. i2pd 기본값: 인바운드 5개 / 아웃바운드 5개. IRC의 경우: 각각 2–3개면 충분하며, 라우터 간 일관된 동작을 위해 명시적으로 설정하세요. 클라이언트 설정 내부 I2P IRC 연결에는 SSL/TLS를 활성화하지 마세요. I2P는 이미 종단 간 암호화를 제공합니다. 추가 TLS는 익명성 향상 없이 오버헤드만 증가시킵니다. 안정적인 신원 유지를 위해 영구 키를 사용하세요. 테스트 중이 아니라면 재시작할 때마다 키를 재생성하지 마세요. 여러 앱에서 IRC를 사용하는 경우, 서비스 간 상관관계를 줄이기 위해 별도 tunnel(비공유)을 사용하는 것이 좋습니다. 원격 제어(SAM/I2CP)를 허용해야 하는 경우, localhost에 바인딩하고 SSH tunnel 또는 인증된 리버스 프록시로 접근을 보호하세요. Alternative connection method: SOCKS5 일부 클라이언트는 I2P의 SOCKS5 프록시를 통해 연결할 수 있습니다: 127.0.0.1:4447. 최상의 결과를 위해서는 6668 포트의 전용 IRC 클라이언트 tunnel을 사용하는 것이 좋습니다. SOCKS는 애플리케이션 계층 식별자를 제거할 수 없으며, 클라이언트가 익명성을 위해 설계되지 않은 경우 정보가 유출될 수 있습니다.\nTroubleshooting 연결할 수 없음 — Irc2P tunnel이 실행 중이고 router가 완전히 부트스트랩되었는지 확인하세요. resolve/join에서 멈춤 — SSL이 비활성화되어 있고 클라이언트가 127.0.0.1:6668을 가리키는지 다시 확인하세요. 높은 지연시간 — I2P는 설계상 지연시간이 높습니다. tunnel 수량을 적절하게 유지하고(2–3개) 빠른 재연결 루프를 피하세요. SAM 앱 사용 — SAM이 활성화되어 있는지(Java) 또는 방화벽에 차단되지 않았는지(i2pd) 확인하세요. 장시간 유지되는 세션을 권장합니다. Appendix: Ports and naming 일반적인 IRC 터널 포트: 6668 (Irc2P 기본값), 6667 및 6669 (대체 포트). .b32.i2p 호스트명: 52자 표준 형식; LS2/고급 인증서용 56자 이상 확장 형식도 존재. 명시적으로 b32 주소가 필요한 경우가 아니면 .i2p 호스트명을 사용하세요. ","description":"I2P IRC 네트워크, 클라이언트, tunnel, 서버 설정 완벽 가이드 (2025년 업데이트)","id":"f8c49a6509b36124b90dbaa1d0fbbc4b","section":"docs","title":"I2P를 통한 IRC","url":"/ko/docs/applications/irc/"},{"categories":null,"content":"SSH 터널은 원격 I2P router의 콘솔이나 다른 서비스에 접근하기 위한 안전하고 암호화된 연결을 제공합니다. 이 가이드는 Windows, Linux, Mac 시스템에서 SSH 터널을 생성하는 방법을 보여줍니다.\nSSH 터널이란 무엇인가? SSH 터널은 암호화된 SSH 연결을 통해 데이터와 정보를 안전하게 라우팅하는 방법입니다. 인터넷을 통과하는 보호된 \u0026ldquo;파이프라인\u0026quot;을 만드는 것으로 생각하면 됩니다 - 데이터가 이 암호화된 터널을 통해 이동하므로, 전송 과정에서 누구도 데이터를 가로채거나 읽을 수 없습니다.\nSSH 터널링은 특히 다음과 같은 경우에 유용합니다:\n원격 I2P router 접속: 원격 서버에서 실행 중인 I2P 콘솔에 연결 보안 연결: 모든 트래픽이 종단 간 암호화됨 제한 우회: 원격 시스템의 서비스를 로컬에 있는 것처럼 접근 포트 포워딩: 로컬 포트를 원격 서비스에 매핑 I2P 환경에서 SSH 터널을 사용하여 원격 서버의 I2P router console(일반적으로 7657 포트)에 접근할 수 있으며, 이를 컴퓨터의 로컬 포트로 포워딩할 수 있습니다.\n전제 조건 SSH 터널을 생성하기 전에 다음이 필요합니다:\nSSH 클라이언트: Windows: PuTTY (무료 다운로드) Linux/Mac: 내장 SSH 클라이언트 (터미널 사용) 원격 서버 접근: 원격 서버의 사용자 이름 원격 서버의 IP 주소 또는 호스트명 SSH 비밀번호 또는 키 기반 인증 사용 가능한 로컬 포트: 1-65535 범위에서 사용하지 않는 포트 선택 (I2P의 경우 일반적으로 7657 사용) 터널 명령어 이해하기 SSH 터널 명령은 다음과 같은 패턴을 따릅니다:\nssh -L [local_port]:[destination_ip]:[destination_port] [username]@[remote_server] 파라미터 설명: - local_port: 로컬 머신의 포트 (예: 7657) - destination_ip: 일반적으로 127.0.0.1 (원격 서버의 localhost) - destination_port: 원격 서버의 서비스 포트 (예: I2P의 경우 7657) - username: 원격 서버의 사용자 이름 - remote_server: 원격 서버의 IP 주소 또는 호스트명\n예제: ssh -L 7657:127.0.0.1:7657 i2p@20.228.143.58\n이는 다음과 같은 터널을 생성합니다: - 로컬 머신의 7657 포트가 전달됩니다\u0026hellip; - 원격 서버의 localhost(I2P가 실행 중인 곳)의 7657 포트로 - 서버 20.228.143.58에 사용자 i2p로 연결\nWindows에서 SSH 터널 생성하기 Windows 사용자는 무료 SSH 클라이언트인 PuTTY를 사용하여 SSH 터널을 생성할 수 있습니다.\nStep 1: Download and Install PuTTY putty.org 에서 PuTTY를 다운로드하여 Windows 시스템에 설치하십시오.\nStep 2: Configure the SSH Connection PuTTY를 열고 연결을 구성하십시오:\nSession 카테고리에서: Host Name 필드에 원격 서버의 IP 주소 또는 호스트명을 입력합니다 Port가 22(기본 SSH 포트)로 설정되어 있는지 확인합니다 Connection type은 SSH여야 합니다 Step 3: Configure the Tunnel 왼쪽 사이드바에서 Connection → SSH → Tunnels로 이동하세요:\nSource port: 사용할 로컬 포트를 입력합니다 (예: 7657) Destination: 127.0.0.1:7657을 입력합니다 (원격 서버의 localhost:port) Add를 클릭하여 터널을 추가합니다 \u0026ldquo;Forwarded ports\u0026rdquo; 목록에 터널이 표시되어야 합니다 Step 4: Connect Open을 클릭하여 연결을 시작합니다 처음 연결하는 경우 보안 경고가 표시됩니다 - Yes를 클릭하여 서버를 신뢰합니다 메시지가 표시되면 사용자 이름을 입력합니다 메시지가 표시되면 비밀번호를 입력합니다 연결되면 브라우저를 열고 http://127.0.0.1:7657로 이동하여 원격 I2P 콘솔에 액세스할 수 있습니다\n단계 1: PuTTY 다운로드 및 설치 매번 재구성하는 것을 피하려면:\nSession 카테고리로 돌아갑니다 Saved Sessions에 이름을 입력합니다 (예: \u0026ldquo;I2P Tunnel\u0026rdquo;) Save를 클릭합니다 다음번에는 이 세션을 불러오고 Open을 클릭하기만 하면 됩니다 Creating SSH Tunnels on Linux Linux 시스템은 터미널에 SSH가 내장되어 있어 tunnel 생성이 빠르고 간단합니다.\n2단계: SSH 연결 구성 터미널을 열고 SSH 터널 명령을 실행하세요:\nssh -L 7657:127.0.0.1:7657 i2p@20.228.143.58 교체: - 7657 (첫 번째 항목): 원하는 로컬 포트 - 127.0.0.1:7657: 원격 서버의 대상 주소 및 포트 - i2p: 원격 서버의 사용자 이름 - 20.228.143.58: 원격 서버의 IP 주소\n메시지가 표시되면 비밀번호를 입력하세요. 연결되면 터널이 활성화됩니다.\n브라우저에서 http://127.0.0.1:7657로 원격 I2P 콘솔에 접속하세요.\n3단계: 터널 구성 터널은 SSH 세션이 실행되는 동안 활성 상태를 유지합니다. 백그라운드에서 계속 실행하려면:\nssh -f -N -L 7657:127.0.0.1:7657 i2p@20.228.143.58 추가 플래그: - -f: SSH를 백그라운드에서 실행 - -N: 원격 명령을 실행하지 않음 (터널만)\n백그라운드 터널을 종료하려면 SSH 프로세스를 찾아서 종료하세요:\nps aux | grep ssh kill [process_id] 4단계: 연결 더 나은 보안과 편의성을 위해 SSH 키 인증을 사용하세요:\nSSH 키 페어 생성 (키 페어가 없는 경우):\nssh-keygen -t ed25519 -C \u0026#34;your_email@example.com\u0026#34; 공개 키를 원격 서버에 복사합니다:\nssh-copy-id i2p@20.228.143.58 이제 비밀번호 없이 연결할 수 있습니다:\nssh -L 7657:127.0.0.1:7657 i2p@20.228.143.58 Creating SSH Tunnels on Mac Mac 시스템은 Linux와 동일한 SSH 클라이언트를 사용하므로 프로세스가 동일합니다.\n선택사항: 세션 저장하기 터미널을 엽니다 (응용 프로그램 → 유틸리티 → 터미널). 그런 다음 다음을 실행합니다:\nssh -L 7657:127.0.0.1:7657 i2p@20.228.143.58 교체: - 7657 (첫 번째 항목): 원하는 로컬 포트 - 127.0.0.1:7657: 원격 서버의 대상 주소 및 포트 - i2p: 원격 서버의 사용자 이름 - 20.228.143.58: 원격 서버의 IP 주소\n메시지가 표시되면 비밀번호를 입력하세요. 연결되면 http://127.0.0.1:7657에서 원격 I2P 콘솔에 접속할 수 있습니다\nBackground Tunnels on Mac Linux와 동일하게, 터널을 백그라운드에서 실행할 수 있습니다:\nssh -f -N -L 7657:127.0.0.1:7657 i2p@20.228.143.58 터미널 사용하기 Mac SSH 키 설정은 Linux와 동일합니다:\n# Generate key (if needed) ssh-keygen -t ed25519 -C \u0026#34;your_email@example.com\u0026#34; # Copy to remote server ssh-copy-id i2p@20.228.143.58 Common Use Cases 터널 활성 상태 유지 가장 일반적인 사용 사례 - 원격 I2P router 콘솔에 접속:\nssh -L 7657:127.0.0.1:7657 user@remote-server 그런 다음 브라우저에서 http://127.0.0.1:7657을 엽니다.\nSSH 키 사용 (권장) 여러 포트를 한 번에 포워딩:\nssh -L 7657:127.0.0.1:7657 -L 7658:127.0.0.1:7658 user@remote-server 이것은 포트 7657 (I2P 콘솔)과 7658 (다른 서비스) 모두를 포워딩합니다.\nCustom Local Port 7657 포트가 이미 사용 중인 경우 다른 로컬 포트를 사용하세요:\nssh -L 8080:127.0.0.1:7657 user@remote-server 대신 http://127.0.0.1:8080에서 I2P 콘솔에 접속하세요.\nTroubleshooting 터미널 사용하기 오류: \u0026ldquo;bind: Address already in use\u0026rdquo;\n해결 방법: 다른 로컬 포트를 선택하거나 해당 포트를 사용하는 프로세스를 종료하세요:\n# Linux/Mac - find process on port 7657 lsof -i :7657 # Kill the process kill [process_id] Mac에서의 백그라운드 터널 오류: \u0026ldquo;Connection refused\u0026rdquo; 또는 \u0026ldquo;channel 2: open failed\u0026rdquo;\n가능한 원인: - 원격 서비스가 실행되지 않음 (원격 서버에서 I2P router가 실행 중인지 확인) - 방화벽이 연결을 차단함 - 잘못된 목적지 포트\n해결 방법: 원격 서버에서 I2P router가 실행 중인지 확인하세요:\nssh user@remote-server \u0026#34;systemctl status i2p\u0026#34; Mac에서 SSH 키 설정 오류: \u0026ldquo;Permission denied\u0026rdquo; 또는 \u0026ldquo;Authentication failed\u0026rdquo;\n가능한 원인: - 잘못된 사용자 이름 또는 비밀번호 - SSH 키가 올바르게 구성되지 않음 - 원격 서버에서 SSH 접근이 비활성화됨\n해결 방법: 자격 증명을 확인하고 원격 서버에서 SSH 액세스가 활성화되어 있는지 확인하세요.\nTunnel Drops Connection 오류: 일정 시간 비활성화 후 연결 끊김\n해결 방법: SSH 설정 파일(~/.ssh/config)에 keep-alive 설정을 추가하세요:\nHost remote-server ServerAliveInterval 60 ServerAliveCountMax 3 Security Best Practices SSH 키 사용: 비밀번호보다 안전하며 침해가 어려움 비밀번호 인증 비활성화: SSH 키 설정 후 서버에서 비밀번호 로그인 비활성화 강력한 비밀번호 사용: 비밀번호 인증을 사용하는 경우 강력하고 고유한 비밀번호 사용 SSH 접근 제한: 방화벽 규칙을 구성하여 신뢰할 수 있는 IP로 SSH 접근 제한 SSH 업데이트 유지: SSH 클라이언트 및 서버 소프트웨어를 정기적으로 업데이트 로그 모니터링: 서버의 SSH 로그에서 의심스러운 활동 확인 비표준 SSH 포트 사용: 자동화된 공격을 줄이기 위해 기본 SSH 포트(22)를 변경 Linux에서 SSH 터널 생성하기 I2P 콘솔 접속하기 터널을 자동으로 설정하는 스크립트를 작성하세요:\n#!/bin/bash # i2p-tunnel.sh ssh -f -N -L 7657:127.0.0.1:7657 i2p@20.228.143.58 echo \u0026#34;I2P tunnel established\u0026#34; 실행 가능하게 만들기:\nchmod +x i2p-tunnel.sh ./i2p-tunnel.sh 다중 터널 systemd 서비스를 생성하여 자동 터널 생성:\nsudo nano /etc/systemd/system/i2p-tunnel.service 추가:\n[Unit] Description=I2P SSH Tunnel After=network.target [Service] ExecStart=/usr/bin/ssh -NT -o ServerAliveInterval=60 -o ExitOnForwardFailure=yes -L 7657:127.0.0.1:7657 i2p@20.228.143.58 Restart=always RestartSec=10 User=your-username [Install] WantedBy=multi-user.target 활성화 및 시작:\nsudo systemctl enable i2p-tunnel sudo systemctl start i2p-tunnel Advanced Tunneling 커스텀 로컬 포트 동적 포워딩을 위한 SOCKS 프록시를 생성하세요:\nssh -D 8080 user@remote-server 브라우저를 127.0.0.1:8080을 SOCKS5 프록시로 사용하도록 설정하세요.\nReverse Tunneling 원격 서버가 로컬 머신의 서비스에 접근할 수 있도록 허용:\nssh -R 7657:127.0.0.1:7657 user@remote-server 포트가 이미 사용 중입니다 중간 서버를 통한 터널:\nssh -J jumphost.example.com -L 7657:127.0.0.1:7657 user@final-server Conclusion SSH 터널링은 원격 I2P router 및 기타 서비스에 안전하게 접근하기 위한 강력한 도구입니다. Windows, Linux, Mac 중 무엇을 사용하든 프로세스는 간단하며 연결에 강력한 암호화를 제공합니다.\n추가 도움이나 질문이 있으시면 I2P 커뮤니티를 방문하세요: - 포럼: i2pforum.net - IRC: 다양한 네트워크의 #i2p - 문서: I2P Docs 가이드는 원래 Stormy Cloud 에서 작성되었으며, I2P 문서에 맞게 수정되었습니다.\n","description":"Windows, Linux, Mac에서 안전한 SSH 터널을 생성하여 원격 I2P router에 접근하는 방법을 알아보세요","id":"7d461aaa86788adfcb07bfb98f6e4965","section":"docs","title":"I2P에 원격으로 접근하기 위한 SSH 터널 생성","url":"/ko/docs/guides/i2p%EC%97%90-%EC%9B%90%EA%B2%A9%EC%9C%BC%EB%A1%9C-%EC%A0%91%EA%B7%BC%ED%95%98%EA%B8%B0-%EC%9C%84%ED%95%9C-ssh-%ED%84%B0%EB%84%90-%EC%83%9D%EC%84%B1/"},{"categories":null,"content":"개요 오늘날 여러 주요 프라이버시 및 익명성 네트워크가 존재하며, 각각 다른 설계 목표와 위협 모델을 가지고 있습니다. Tor, Lokinet, GNUnet, Freenet 모두 프라이버시 보호 통신에 대한 가치 있는 접근 방식을 제공하지만, I2P는 네트워크 내 hidden services와 P2P 애플리케이션에 완전히 최적화된 유일한 프로덕션 수준의 패킷 교환 네트워크로 두드러집니다.\n아래 표는 2025년 기준 이러한 네트워크들의 주요 아키텍처 및 운영상의 차이점을 요약합니다.\n프라이버시 네트워크 비교 (2025) Feature / Network I2P Tor Lokinet Freenet (Hyphanet) GNUnet Primary Focus Hidden services, P2P applications Clearnet anonymity via exits Hybrid VPN + hidden services Distributed storage \u0026 publishing Research framework, F2F privacy Architecture Fully distributed, packet-switched Centralized directory, circuit-switched Packet-switched LLARP with blockchain coordination DHT-based content routing DHT \u0026 F2F topology (R5N) Routing Model Unidirectional tunnels (inbound/outbound) Bidirectional circuits (3 hops) Packet-switched over staked nodes Key-based routing Random walk + DHT hybrid Directory / Peer Discovery Distributed Kademlia netDB with floodfills 9 hardcoded directory authorities Blockchain + Oxen staking Heuristic routing Distributed hash routing (R5N) Encryption ECIES-X25519-AEAD-Ratchet (ChaCha20/Poly1305) AES + RSA/ECDH Curve25519/ChaCha20 Custom symmetric encryption Ed25519/Curve25519 Participation Model All routers route traffic (democratic) Small relay subset, majority are clients Only staked nodes User-selectable trust mesh Optional F2F restriction Traffic Handling Packet-switched, multi-path, load-balanced Circuit-switched, fixed path per circuit Packet-switched, incentivized File chunk propagation Message batching and proof-of-work Garlic Routing ✅ Yes (message bundling \u0026 tagging) ❌ No Partial (message batches) ❌ No ❌ No Exit to Clearnet Limited (discouraged) Core design goal Supported (VPN-style exits) Not applicable Not applicable Built-In Apps I2PSnark, I2PTunnel, SusiMail, I2PBote Tor Browser, OnionShare Lokinet GUI, SNApps Freenet UI GNUnet CLI tools Performance Optimized for internal services, 1–3s RTT Optimized for exits, ~200–500ms RTT Low latency, staked node QoS High latency (minutes) Experimental, inconsistent Anonymity Set Size ~55,000 active routers Millions of daily users \u0026lt;1,000 service nodes Thousands (small core) Hundreds (research only) Scalability Horizontal via floodfill rotation Centralized bottleneck (directory) Dependent on token economics Limited by routing heuristics Research-scale only Funding Model Volunteer-driven nonprofit Major institutional grants Crypto-incentivized (OXEN) Volunteer community Academic research License / Codebase Open source (Java/C++/Go) Open source (C) Open source (C++) Open source (Java) Open source (C) --- I2P가 프라이버시 우선 설계에서 선두를 달리는 이유 1. Packet Switching \u0026gt; Circuit Switching Tor의 회선 교환 모델은 트래픽을 고정된 3홉 경로에 바인딩합니다. 이는 브라우징에는 효율적이지만 장기 실행 내부 서비스에는 취약합니다. I2P의 packet-switched tunnel은 메시지를 여러 동시 경로로 전송하여 혼잡이나 장애를 자동으로 우회 라우팅함으로써 더 나은 가동 시간과 부하 분산을 제공합니다.\n2. Unidirectional Tunnels I2P는 인바운드와 아웃바운드 트래픽을 분리합니다. 이는 각 참여자가 통신 흐름의 절반만 볼 수 있음을 의미하며, 타이밍 상관관계 공격을 훨씬 어렵게 만듭니다. Tor, Lokinet 등은 요청과 응답이 동일한 경로를 공유하는 양방향 회로를 사용하는데, 더 단순하지만 추적이 더 쉽습니다.\n3. Fully Distributed netDB Tor의 9개 디렉토리 권한 서버는 네트워크 토폴로지를 정의합니다. I2P는 순환하는 floodfill router들이 유지하는 자가 조직화된 Kademlia DHT를 사용하여 중앙 제어 지점이나 조정 서버를 제거합니다.\n1. 패킷 스위칭 \u0026gt; 회선 스위칭 I2P는 garlic routing을 통해 onion routing을 확장하여 여러 암호화된 메시지를 하나의 컨테이너로 묶습니다. 이를 통해 메타데이터 유출과 대역폭 오버헤드를 줄이는 동시에 확인응답, 데이터 및 제어 메시지의 효율성을 향상시킵니다.\n2. 단방향 터널 모든 I2P router는 다른 사용자를 위해 라우팅을 수행합니다. 전담 릴레이 운영자나 특권 노드는 없으며, 대역폭과 신뢰성에 따라 각 노드가 얼마나 라우팅에 기여하는지 자동으로 결정됩니다. 이러한 민주적 접근 방식은 복원력을 구축하고 네트워크가 성장함에 따라 자연스럽게 확장됩니다.\n3. 완전 분산형 netDB I2P의 12-홉 왕복 경로(인바운드 6 + 아웃바운드 6)는 Tor의 6-홉 히든 서비스 회로보다 더 강력한 연결 불가 추적성을 제공합니다. 양측 당사자 모두 내부에 있기 때문에, 연결은 출구 병목 현상을 완전히 회피하여 더 빠른 내부 호스팅과 네이티브 애플리케이션 통합(I2PSnark, I2PTunnel, I2PBote)을 제공합니다.\nArchitectural Takeaways Design Principle I2P Advantage Decentralization No trusted authorities; netDB managed by floodfill peers Traffic Separation Unidirectional tunnels prevent request/response correlation Adaptability Packet-switching allows per-message load balancing Efficiency Garlic routing reduces metadata and increases throughput Inclusiveness All peers route traffic, strengthening anonymity set Focus Built specifically for hidden services and in-network communication --- When to Use Each Network Use Case Recommended Network Anonymous web browsing (clearnet access) I2P Anonymous hosting, P2P, or DApps I2P Anonymous file publishing and storage Freenet (Hyphanet) VPN-style private routing with staking Lokinet Academic experimentation and research GNUnet --- Summary I2P의 아키텍처는 독보적으로 프라이버시 우선입니다—디렉토리 서버 없음, 블록체인 의존성 없음, 중앙화된 신뢰 없음. 단방향 tunnel, 패킷 교환 라우팅, garlic 메시지 번들링, 분산 피어 발견의 조합은 오늘날 익명 호스팅 및 P2P 통신을 위한 가장 기술적으로 진보된 시스템입니다.\nI2P는 \u0026ldquo;Tor의 대안\u0026quot;이 아닙니다. 이는 프라이버시 네트워크 외부가 아닌 내부에서 일어나는 일을 위해 구축된 다른 종류의 네트워크입니다.\n","description":"I2P의 독특한 설계 장점을 강조하는 현대적인 기술 및 철학적 비교","id":"bc3abab13910824c59b1550aa1ce69df","section":"docs","title":"I2P와 다른 프라이버시 네트워크 비교","url":"/ko/docs/overview/comparison/"},{"categories":null,"content":" 메인 I2P 개발 브랜치(i2p.i2p)는 개발자들이 자바 개발에 일반적으로 사용되는 두 가지 IDE인 Eclipse와 NetBeans를 쉽게 설정할 수 있도록 구성되어 있습니다. Eclipse 주요 I2P 개발 브랜치(i2p.i2p 및 이로부터 파생된 브랜치)에는 Eclipse에서 브랜치를 쉽게 설정할 수 있도록 build.gradle이 포함되어 있습니다. 최신 버전의 Eclipse가 설치되어 있는지 확인하세요. 2017년 이후 버전이면 충분합니다. I2P 브랜치를 특정 디렉토리(예: $HOME/dev/i2p.i2p)에 체크아웃하세요. \"File → Import...\"를 선택한 다음 \"Gradle\" 아래에서 \"Existing Gradle Project\"를 선택하세요. \"Project root directory:\"에는 I2P 브랜치를 체크아웃한 디렉토리를 선택하세요. \"Import Options\" 대화상자에서 \"Gradle Wrapper\"를 선택하고 Continue를 누르세요. \"Import Preview\" 대화상자에서 프로젝트 구조를 검토할 수 있습니다. \"i2p.i2p\" 아래에 여러 프로젝트가 표시되어야 합니다. \"Finish\"를 누르세요. 완료! 이제 작업 공간에 I2P 브랜치 내의 모든 프로젝트가 포함되어 있으며, 빌드 종속성이 올바르게 설정되어 있어야 합니다. NetBeans 주요 I2P 개발 브랜치(i2p.i2p 및 여기서 파생된 브랜치)에는 NetBeans 프로젝트 파일이 포함되어 있습니다. ","description":"Gradle과 번들 프로젝트 파일을 사용하여 I2P 개발을 위한 Eclipse 및 NetBeans 설정","id":"59847e4ae7ce8d8ccadb441422ecc856","section":"docs","title":"IDE를 사용한 I2P 개발","url":"/ko/docs/guides/ides/"},{"categories":null,"content":"필요한 사항 macOS 10.14(Mojave) 이상을 실행하는 Mac 애플리케이션 설치를 위한 관리자 권한 약 15-20분의 시간 설치 프로그램 다운로드를 위한 인터넷 연결 개요 이 설치 과정은 네 가지 주요 단계로 구성됩니다:\nJava 설치 - Oracle Java Runtime Environment를 다운로드하고 설치합니다 I2P 설치 - I2P 설치 프로그램을 다운로드하고 실행합니다 I2P 앱 구성 - launcher를 설정하고 dock에 추가합니다 I2P 대역폭 구성 - 설정 마법사를 실행하여 연결을 최적화합니다 1부: Java 설치 I2P를 실행하려면 Java가 필요합니다. 이미 Java 8 이상이 설치되어 있다면 2부로 건너뛸 수 있습니다 .\nStep 1: Download Java Oracle Java 다운로드 페이지 를 방문하여 Java 8 이상의 macOS 설치 프로그램을 다운로드하세요.\nStep 2: Run the Installer Downloads 폴더에서 다운로드한 .dmg 파일을 찾아 더블클릭하여 엽니다.\nStep 3: Allow Installation macOS는 설치 프로그램이 확인된 개발자로부터 제공되었기 때문에 보안 알림을 표시할 수 있습니다. 계속 진행하려면 열기를 클릭하세요.\n1단계: Java 다운로드 Install을 클릭하여 Java 설치 프로세스를 시작합니다.\n2단계: 설치 프로그램 실행 설치 프로그램이 파일을 복사하고 시스템에 Java를 구성합니다. 일반적으로 1-2분이 소요됩니다.\n3단계: 설치 허용 성공 메시지가 표시되면 Java가 설치된 것입니다! Close를 클릭하여 완료하세요.\nPart Two: Download and Install I2P Java가 설치되었으므로 이제 I2P router를 설치할 수 있습니다.\n4단계: Java 설치 다운로드 페이지 를 방문하여 I2P for Unix/Linux/BSD/Solaris 설치 프로그램(.jar 파일)을 다운로드하세요.\n단계 5: 설치 대기 다운로드한 i2pinstall_X.X.X.jar 파일을 더블클릭하세요. 설치 프로그램이 실행되고 선호하는 언어를 선택하라는 메시지가 표시됩니다.\n6단계: 설치 완료 환영 메시지를 읽고 Next를 클릭하여 계속 진행하세요.\nStep 4: Important Notice 설치 프로그램은 업데이트에 대한 중요한 공지사항을 표시합니다. I2P 업데이트는 이 설치 프로그램 자체는 서명되지 않았지만 end-to-end 서명되고 검증됩니다. 다음을 클릭하세요.\n1단계: I2P 다운로드 I2P 라이선스 계약서(BSD 스타일 라이선스)를 읽으십시오. 다음을 클릭하여 동의합니다.\n2단계: 설치 프로그램 실행 I2P를 설치할 위치를 선택하세요. 기본 위치(/Applications/i2p)를 권장합니다. Next를 클릭하세요.\n3단계: 환영 화면 완전한 설치를 위해 모든 구성 요소를 선택한 상태로 두세요. 다음을 클릭하세요.\n4단계: 중요 공지 선택 사항을 검토하고 Next를 클릭하여 I2P 설치를 시작하세요.\n5단계: 라이선스 동의 설치 프로그램이 I2P 파일을 시스템에 복사합니다. 약 1-2분 정도 소요됩니다.\n단계 6: 설치 디렉토리 선택 설치 프로그램은 I2P를 시작하기 위한 실행 스크립트를 생성합니다.\n7단계: 구성 요소 선택 설치 프로그램은 바탕화면 바로가기와 메뉴 항목을 만들 것인지 묻습니다. 원하는 항목을 선택하고 다음을 클릭하세요.\n8단계: 설치 시작 성공! I2P가 설치되었습니다. 완료를 클릭하여 마치십시오.\nPart Three: Configure I2P App 이제 I2P를 응용 프로그램 폴더와 Dock에 추가하여 쉽게 실행할 수 있도록 만들어 봅시다.\n9단계: 파일 설치 Finder를 열고 Applications 폴더로 이동합니다.\n단계 10: 실행 스크립트 생성 /Applications/i2p/ 안에서 I2P 폴더 또는 Start I2P Router 애플리케이션을 찾으세요.\n단계 11: 설치 바로가기 Start I2P Router 애플리케이션을 Dock으로 드래그하여 쉽게 액세스할 수 있습니다. 데스크탑에 별칭을 생성할 수도 있습니다.\n팁: Dock에서 I2P 아이콘을 마우스 오른쪽 버튼으로 클릭하고 옵션 → Dock에 유지를 선택하면 영구적으로 고정할 수 있습니다.\nPart Four: Configure I2P Bandwidth I2P를 처음 실행하면 설정 마법사가 나타나 대역폭 설정을 구성하게 됩니다. 이는 사용자의 연결에 맞게 I2P의 성능을 최적화하는 데 도움이 됩니다.\n단계 12: 설치 완료 Dock에서 I2P 아이콘을 클릭하거나(또는 런처를 더블클릭) 하세요. 기본 웹 브라우저가 I2P Router Console로 열립니다.\nStep 2: Welcome Wizard 설정 마법사가 나타납니다. Next를 클릭하여 I2P 구성을 시작하세요.\n1단계: Applications 폴더 열기 선호하는 인터페이스 언어를 선택하고 라이트 또는 다크 테마 중에서 선택하세요. 다음을 클릭하세요.\n2단계: I2P Launcher 찾기 마법사는 대역폭 테스트를 설명합니다. 이 테스트는 M-Lab 서비스에 연결하여 인터넷 속도를 측정합니다. 계속하려면 다음을 클릭하세요.\n3단계: Dock에 추가 Run Test를 클릭하여 업로드 및 다운로드 속도를 측정하세요. 테스트는 약 30-60초가 소요됩니다.\nStep 6: Test Results 테스트 결과를 검토하세요. I2P는 연결 속도에 따라 대역폭 설정을 권장합니다.\n1단계: I2P 실행 I2P 네트워크와 공유할 대역폭을 선택하세요:\n자동 (권장): I2P가 사용량에 따라 대역폭을 관리합니다 제한: 특정 업로드/다운로드 제한을 설정합니다 무제한: 가능한 많이 공유합니다 (빠른 연결용) Next를 클릭하여 설정을 저장합니다.\n단계 2: 환영 마법사 I2P router가 이제 구성되어 실행 중입니다! router console에 연결 상태가 표시되며 I2P 사이트를 탐색할 수 있습니다.\nGetting Started with I2P I2P가 설치 및 구성되었으므로 다음을 수행할 수 있습니다:\nI2P 사이트 탐색: I2P 홈페이지 를 방문하여 인기 있는 I2P 서비스 링크를 확인하세요 브라우저 설정: .i2p 사이트에 접속하기 위해 브라우저 프로필 을 설정하세요 서비스 탐색: I2P 이메일, 포럼, 파일 공유 등을 확인해보세요 router 모니터링: 콘솔 에서 네트워크 상태와 통계를 확인할 수 있습니다 3단계: 언어 및 테마 Router Console: http://127.0.0.1:7657/ 설정: http://127.0.0.1:7657/config 주소록: http://127.0.0.1:7657/susidns/addressbook 대역폭 설정: http://127.0.0.1:7657/config Re-running the Setup Wizard 대역폭 설정을 변경하거나 나중에 I2P를 재구성하려면, Router Console에서 시작 마법사를 다시 실행할 수 있습니다:\nI2P 설정 마법사 로 이동합니다 마법사 단계를 다시 따라갑니다 Troubleshooting 4단계: 대역폭 테스트 정보 Java 확인: 터미널에서 java -version을 실행하여 Java가 설치되어 있는지 확인하세요 권한 확인: I2P 폴더에 올바른 권한이 있는지 확인하세요 로그 확인: 오류 메시지를 확인하려면 ~/.i2p/wrapper.log를 확인하세요 5단계: 대역폭 테스트 실행 I2P가 실행 중인지 확인하세요 (라우터 콘솔을 확인하세요) 브라우저의 프록시 설정을 HTTP 프록시 127.0.0.1:4444로 구성하세요 시작 후 I2P가 네트워크에 통합되는 데 5-10분 정도 기다리세요 6단계: 테스트 결과 대역폭 테스트를 다시 실행하고 설정을 조정하세요 네트워크와 일정량의 대역폭을 공유하고 있는지 확인하세요 Router Console에서 연결 상태를 확인하세요 Part Two: I2P 다운로드 및 설치 Mac에서 I2P를 제거하려면:\nI2P router가 실행 중이면 종료하세요 /Applications/i2p 폴더를 삭제하세요 ~/.i2p 폴더를 삭제하세요 (I2P 설정 및 데이터) Dock에서 I2P 아이콘을 제거하세요 Next Steps 커뮤니티 참여: i2pforum.net 을 방문하거나 Reddit의 I2P를 확인하세요 더 알아보기: 네트워크 작동 방식을 이해하기 위해 I2P 문서 를 읽어보세요 참여하기: I2P 개발에 기여 하거나 인프라 운영을 고려해보세요 축하합니다! 이제 여러분은 I2P 네트워크의 일원입니다. 보이지 않는 인터넷에 오신 것을 환영합니다!\n","description":"macOS에서 I2P와 의존성 패키지를 수동으로 설치하는 단계별 가이드","id":"f88100195c365b18735e1ea12826a97e","section":"docs","title":"macOS에 I2P 설치하기 (자세한 방법)","url":"/ko/docs/guides/macos%EC%97%90-i2p-%EC%84%A4%EC%B9%98%ED%95%98%EA%B8%B0-%EC%9E%90%EC%84%B8%ED%95%9C-%EB%B0%A9%EB%B2%95/"},{"categories":null,"content":"NTCP 대 SSU 논의 (2007년 3월) NTCP 질문 IRC에서 zzz와 cervantes가 나눈 대화를 바탕으로 재구성한 것입니다.\nNTCP가 오버헤드와 지연을 추가하는 것처럼 보이는데도 왜 SSU보다 우선시되나요?\nNTCP는 일반적으로 기존 SSU 구현보다 더 높은 신뢰성을 제공합니다. NTCP 위에서 스트리밍을 하면 고전적인 TCP-over-TCP collapse(TCP 위에 TCP를 중첩해 사용할 때 발생하는 성능 붕괴 현상)에 부딪히나요?\n그럴 수 있습니다. 다만 SSU는 경량 UDP 옵션으로 설계되었지만 실제로는 신뢰성이 너무 낮은 것으로 드러났습니다. “NTCP는 해롭다” (zzz, 2007년 3월 25일) 요약: NTCP의 더 높은 지연 시간과 오버헤드는 혼잡을 유발할 수 있지만, 라우팅은 SSU보다 낮은 bid 점수(입찰 점수)가 하드코딩되어 있기 때문에 NTCP를 선호한다. 해당 분석은 여러 가지 쟁점을 제기했다:\n현재 NTCP는 SSU보다 더 낮은 bid(전송 비용 지표)를 제시하므로, SSU 세션이 이미 설정되어 있지 않은 한 routers는 NTCP를 선호한다. SSU는 엄격히 제한된 타임아웃과 통계를 바탕으로 확인 응답(ACK)을 구현한다; NTCP는 훨씬 길 수 있는 RFC 스타일의 타임아웃을 사용하는 Java NIO TCP에 의존한다. 대부분의 트래픽(HTTP, IRC, BitTorrent)은 I2P의 스트리밍 라이브러리를 사용하며, 이는 사실상 NTCP 위에 TCP를 적층하는 것이다. 두 계층이 모두 재전송하면 혼잡 붕괴가 발생할 수 있다. 고전적 참고 자료로는 TCP over TCP is a bad idea 이 있다. 0.8 릴리스에서 스트리밍 라이브러리의 타임아웃은 10초에서 45초로 증가했다; SSU의 최대 타임아웃은 3초인 반면, NTCP의 타임아웃은 60초에 근접하는 것으로 추정된다(RFC 권고). NTCP 매개변수는 외부에서 관측하기 어렵다. 2007년 현장 관측에서는 i2psnark 업로드 처리량이 요동했으며, 주기적 혼잡 붕괴를 시사했다. 효율성 테스트(SSU 선호 강제)는 tunnel 오버헤드 비율을 대략 3.5:1에서 3:1로 낮추고, 스트리밍 지표들(윈도 크기, RTT, 송신/ACK 비율)을 개선했다. 2007년 스레드에서 나온 제안들 전송 우선순위를 전환하여 routers가 SSU를 선호하도록 (i2np.udp.alwaysPreferred 복원). 스트리밍 트래픽에 태그를 지정하여 익명성을 훼손하지 않으면서 SSU가 태그된 메시지에 대해서만 bid(선호도 점수)를 낮추도록. SSU 재전송 한계를 강화하여 붕괴 위험을 줄이기. semi-reliable underlays(부분 신뢰성 하부 계층)를 연구하여 스트리밍 라이브러리 아래에서의 재전송이 순이익인지 판단. 우선순위 큐와 타임아웃을 재검토—예를 들어, NTCP에 맞추기 위해 스트리밍 타임아웃을 45 s를 초과하도록 늘리기. jrandom의 답변 (2007년 3월 27일) 핵심 반론:\nNTCP는 초기 SSU 도입이 혼잡 붕괴(congestion collapse)를 겪었기 때문에 존재한다. 홉당 재전송률이 다소 낮더라도 다중 홉 tunnels 전반에서 폭증할 수 있다. tunnel 수준의 확인 응답이 없으면, 메시지의 일부만 종단 간(end-to-end) 전달 상태를 확인할 수 있으며, 실패는 감지되지 않은 채 발생할 수 있다. TCP 혼잡 제어는 수십 년에 걸쳐 최적화되어 왔으며, NTCP는 성숙한 TCP 스택을 통해 이를 활용한다. SSU를 선호할 때 관찰된 효율성 향상은 프로토콜 자체의 고유한 이점이라기보다 router의 큐잉 동작을 반영한 것일 수 있다. 더 긴 스트리밍 타임아웃은 이미 안정성을 개선하고 있었으며, 큰 변경 전에 추가적인 관찰과 데이터 수집이 권장되었다. 그 논쟁은 이후 전송 튜닝을 개선하는 데 도움이 되었지만 현대적인 NTCP2/SSU2 아키텍처를 반영하지는 않는다.\n","description":"NTCP 및 SSU 트랜스포트를 비교하는 역사적 노트와 제안된 튜닝 아이디어","id":"6fe94dc04faadfde27bcfeaaf9da5f71","section":"docs","title":"NTCP(TCP 기반 전송 프로토콜) 논의","url":"/ko/docs/ntcp/"},{"categories":null,"content":"개요 NTCP2는 트래픽 지문 식별에 대한 저항성을 갖고, 길이 필드를 암호화하며, 최신 암호군을 지원하는 Noise(보안 핸드셰이크 프레임워크) 기반 핸드셰이크로 기존 NTCP 전송을 대체합니다. Routers는 I2P 네트워크에서 필수인 두 가지 전송 프로토콜로서 SSU2와 함께 NTCP2를 실행할 수 있습니다. NTCP(버전 1)은 0.9.40(2019년 5월)에서 사용 중단되었으며 0.9.50(2021년 5월)에서 완전히 제거되었습니다.\nNoise Protocol Framework(노이즈 프로토콜 프레임워크) NTCP2는 I2P 전용 확장과 함께 Noise Protocol Framework Revision 33, 2017-10-04 (암호화 핸드셰이크 프로토콜 설계 프레임워크)를 사용합니다:\n패턴: Noise_XK_25519_ChaChaPoly_SHA256 확장 식별자: Noise_XKaesobfse+hs2+hs3_25519_ChaChaPoly_SHA256 (KDF 초기화를 위해) DH 함수: X25519 (RFC 7748) - 32바이트 키, 리틀 엔디언 인코딩 암호: AEAD_CHACHA20_POLY1305 (RFC 7539/RFC 8439) 12바이트 논스: 처음 4바이트는 0, 마지막 8바이트는 카운터(리틀 엔디언) 최대 논스 값: 2^64 - 2 (연결은 2^64 - 1에 도달하기 전에 종료되어야 함) 해시 함수: SHA-256 (32바이트 출력) MAC: Poly1305 (16바이트 인증 태그) I2P 전용 확장 기능 AES 난독화: 임시 키는 Bob의 router 해시와 공개된 IV를 사용하여 AES-256-CBC로 암호화됨 임의 패딩: 메시지 1-2에서는 평문 패딩(인증됨), 메시지 3+에서는 AEAD(연관 데이터 인증 암호) 패딩(암호화됨) SipHash-2-4 길이 난독화: 2바이트 프레임 길이는 SipHash 출력과 XOR 처리됨 프레임 구조: 데이터 단계에서 길이 접두사 프레임(TCP 스트리밍 호환성) 블록 기반 페이로드: 타입이 지정된 블록으로 구성된 구조화된 데이터 형식 핸드셰이크 흐름 Alice (Initiator) Bob (Responder) SessionRequest ──────────────────────► ◄────────────────────── SessionCreated SessionConfirmed ──────────────────────► 3-메시지 핸드셰이크 SessionRequest(세션 요청) - 앨리스의 난독화된 임시 키, 옵션, 패딩 힌트 SessionCreated(세션 생성) - 밥의 난독화된 임시 키, 암호화된 옵션, 패딩 SessionConfirmed(세션 확인) - 앨리스의 암호화된 정적 키와 RouterInfo(router 정보) (AEAD(연관 데이터가 있는 인증 암호) 프레임 두 개) Noise(프로토콜 프레임워크) 메시지 패턴 XK(s, rs): Authentication Confidentiality \u0026lt;- s (Bob\u0026#39;s static key known in advance) -\u0026gt; e, es 0 2 \u0026lt;- e, ee 2 1 -\u0026gt; s, se 2 5 \u0026lt;- 2 5 인증 수준: - 0: 인증 없음 (누구나 보냈을 수 있음) - 2: key-compromise impersonation (KCI, 키 손상 사칭)에 대한 저항성을 갖춘 발신자 인증\n기밀성 수준: - 1: 일시적 수신자(전방향 보안(forward secrecy), 수신자 인증 없음) - 2: 확인된 수신자, 발신자 침해에 대해서만 전방향 보안 - 5: 강한 전방향 보안(ephemeral-ephemeral + ephemeral-static DH(Diffie-Hellman, 디피-헬만))\n메시지 명세 키 표기법 RH_A = Alice에 대한 Router 해시(32바이트, SHA-256) RH_B = Bob에 대한 Router 해시(32바이트, SHA-256) || = 연결 연산자 byte(n) = 값이 n인 단일 바이트 모든 멀티바이트 정수는 별도 지정이 없는 한 빅엔디언 X25519 키는 리틀엔디언(32바이트) 인증된 암호화 (ChaCha20-Poly1305) 암호화 함수:\nAEAD_ChaCha20_Poly1305(key, nonce, associatedData, plaintext) → (ciphertext || MAC) 매개변수: - key: KDF(키 유도 함수)에서 파생된 32바이트 암호 키 - nonce: 12바이트(0 값 바이트 4개 + 8바이트 카운터, 리틀 엔디언) - associatedData: 핸드셰이크 단계에서는 32바이트 해시; 데이터 단계에서는 길이 0 - plaintext: 암호화할 데이터(0바이트 이상)\n출력: - 암호문: 평문과 동일한 길이 - MAC: 16바이트 (Poly1305 인증 태그)\n논스 관리: - 각 암호 인스턴스마다 카운터는 0에서 시작 - 해당 방향의 각 AEAD 연산마다 증가 - 데이터 단계에서 Alice→Bob 및 Bob→Alice에 대해 별도의 카운터 - 카운터가 2^64 - 1에 도달하기 전에 연결을 종료해야 함\n메시지 1: SessionRequest(세션 요청) 앨리스가 밥과의 연결을 시작한다.\nNoise 연산: e, es (임시 키 생성 및 교환)\n원시 형식 +----+----+----+----+----+----+----+----+ | | + AES-256-CBC Encrypted X (32B) + | Key: RH_B, IV: Bob\u0026#39;s published IV | + + | | +----+----+----+----+----+----+----+----+ | | + ChaChaPoly Frame (48 bytes) + | Plaintext: 32B (X + options) | + k from KDF-1, n=0, ad=h + | | +----+----+----+----+----+----+----+----+ | Cleartext Padding (optional) | + Length specified in options + | 0 to 65535 - 80 bytes | ~ . . . ~ +----+----+----+----+----+----+----+----+ 크기 제한: - 최소: 80바이트 (32 AES + 48 AEAD) - 최대: 총 65535바이트 - 특수한 경우: \u0026ldquo;NTCP\u0026rdquo; 주소에 연결할 때 최대 287바이트 (버전 감지)\n복호화된 콘텐츠 +----+----+----+----+----+----+----+----+ | | + X (Alice ephemeral public key) + | 32 bytes, X25519, little-endian | + + | | +----+----+----+----+----+----+----+----+ | Options Block | + (16 bytes) + | | +----+----+----+----+----+----+----+----+ | Cleartext Padding (optional) | ~ . . . ~ +----+----+----+----+----+----+----+----+ 옵션 블록 (16바이트, 빅 엔디언) +----+----+----+----+----+----+----+----+ | id | ver| padLen | m3p2len | Rsvd(0) | +----+----+----+----+----+----+----+----+ | tsA | Reserved (0) | +----+----+----+----+----+----+----+----+ id : 1 byte - Network ID (2 for mainnet, 16-254 for testnets) ver : 1 byte - Protocol version (currently 2) padLen : 2 bytes - Padding length in this message (0-65455) m3p2len : 2 bytes - Length of SessionConfirmed part 2 frame Rsvd : 2 bytes - Reserved, set to 0 tsA : 4 bytes - Unix timestamp (seconds since epoch) Reserved: 4 bytes - Reserved, set to 0 중요 필드: - 네트워크 ID (since 0.9.42): 네트워크 간 연결을 신속하게 거부 - m3p2len: 메시지 3 파트 2의 정확한 크기(전송 시 일치해야 함)\n키 유도 함수(KDF-1) 프로토콜 초기화:\nprotocol_name = \u0026#34;Noise_XKaesobfse+hs2+hs3_25519_ChaChaPoly_SHA256\u0026#34; h = SHA256(protocol_name) ck = h // Chaining key initialized to hash MixHash(혼합 해시) 연산:\nh = SHA256(h) // Null prologue h = SHA256(h || rs) // Bob\u0026#39;s static key (known) h = SHA256(h || e.pubkey) // Alice\u0026#39;s ephemeral key X // h is now the associated data for message 1 AEAD MixKey 동작 (es 패턴):\ndh_result = X25519(Alice.ephemeral_private, Bob.static_public) temp_key = HMAC-SHA256(ck, dh_result) ck = HMAC-SHA256(temp_key, byte(0x01)) k = HMAC-SHA256(temp_key, ck || byte(0x02)) // k is the cipher key for message 1 // ck is retained for message 2 KDF 구현 참고 사항 AES 난독화: DPI(딥 패킷 검사) 회피 목적에만 사용됨; Bob의 router 해시와 IV를 가진 누구나 X를 복호화할 수 있음 재생 공격 방지: Bob은 최소 2*D초 동안 X 값(또는 암호화된 동등값)을 캐시해야 함 (D = 최대 시계 스큐) 타임스탬프 검증: Bob은 |tsA - current_time| \u0026gt; D 인 연결을 거부해야 함 (일반적으로 D = 60초) 곡선 검증: Bob은 X가 유효한 X25519 점인지 검증해야 함 빠른 거부: 복호화 전에 Bob은 X[31] \u0026amp; 0x80 == 0 여부를 확인할 수 있음 (유효한 X25519 키는 MSB(최상위 비트)가 클리어되어 있음) 오류 처리: 어떤 실패가 발생해도, 임의의 타임아웃과 임의의 바이트를 읽은 뒤 TCP RST로 연결을 종료함 버퍼링: 효율을 위해 Alice는 전체 메시지(패딩 포함)를 한 번에 플러시해야 함 메시지 2: SessionCreated(세션 생성됨) Bob이 Alice에게 응답한다.\nNoise 연산: e, ee (ephemeral-ephemeral DH; 일회용-일회용 Diffie-Hellman)\n원시 형식 +----+----+----+----+----+----+----+----+ | | + AES-256-CBC Encrypted Y (32B) + | Key: RH_B, IV: AES state from msg1 | + + | | +----+----+----+----+----+----+----+----+ | | + ChaChaPoly Frame (48 bytes) + | Plaintext: 32B (Y + options) | + k from KDF-2, n=0, ad=h + | | +----+----+----+----+----+----+----+----+ | Cleartext Padding (optional) | + Length specified in options + | 0 to 65535 - 80 bytes | ~ . . . ~ +----+----+----+----+----+----+----+----+ 복호화된 콘텐츠 +----+----+----+----+----+----+----+----+ | | + Y (Bob ephemeral public key) + | 32 bytes, X25519, little-endian | + + | | +----+----+----+----+----+----+----+----+ | Options Block | + (16 bytes) + | | +----+----+----+----+----+----+----+----+ | Cleartext Padding (optional) | ~ . . . ~ +----+----+----+----+----+----+----+----+ 옵션 블록 (16바이트, 빅엔디언) +----+----+----+----+----+----+----+----+ | Rsvd(0) | padLen | Reserved (0) | +----+----+----+----+----+----+----+----+ | tsB | Reserved (0) | +----+----+----+----+----+----+----+----+ Rsvd : 2 bytes - Reserved, set to 0 padLen : 2 bytes - Padding length in this message Reserved: 10 bytes - Reserved, set to 0 tsB : 4 bytes - Unix timestamp (seconds since epoch) 키 유도 함수(KDF-2) MixHash 연산:\nh = SHA256(h || encrypted_payload_msg1) // 32-byte ciphertext if (msg1_padding_length \u0026gt; 0): h = SHA256(h || padding_from_msg1) h = SHA256(h || e.pubkey) // Bob\u0026#39;s ephemeral key Y // h is now the associated data for message 2 AEAD MixKey 연산 (ee pattern, ee 패턴):\ndh_result = X25519(Bob.ephemeral_private, Alice.ephemeral_public) temp_key = HMAC-SHA256(ck, dh_result) ck = HMAC-SHA256(temp_key, byte(0x01)) k = HMAC-SHA256(temp_key, ck || byte(0x02)) // k is the cipher key for message 2 // ck is retained for message 3 KDF 메모리 정리:\n// Overwrite ephemeral keys after ee DH Alice.ephemeral_public = zeros(32) Alice.ephemeral_private = zeros(32) // Bob side Bob.received_ephemeral = zeros(32) // Bob side 구현 참고사항 AES 체이닝: Y 암호화는 메시지 1의 AES-CBC(암호 블록 연쇄 모드) 상태를 사용한다(초기화하지 않음) 재생 공격 방지: Alice는 최소 2*D초 동안 Y 값을 캐시해야 한다 타임스탬프 검증: Alice는 |tsB - current_time| \u0026gt; D 인 경우 거부해야 한다 타원곡선 검증: Alice는 Y가 유효한 X25519(타원곡선 Diffie-Hellman(ECDH) 키 교환 방식) 점인지 확인해야 한다 오류 처리: 실패가 발생하면 Alice는 TCP RST(연결 재설정 플래그)로 연결을 닫는다 버퍼링: Bob은 전체 메시지를 한 번에 플러시해야 한다 메시지 3: SessionConfirmed(세션 확인) Alice는 세션을 확인하고 RouterInfo(router 정보)를 전송한다.\nNoise 연산: s, se (정적 키 공개 및 정적-에페메럴 DH)\n두 부분 구조 메시지 3은 별도의 AEAD(연관 데이터가 포함된 인증된 암호화) 프레임 두 개로 구성됩니다:\n부분 1: Alice의 암호화된 정적 키를 포함한 고정된 48바이트 프레임 부분 2: RouterInfo(라우터 정보), 옵션 및 패딩을 포함한 가변 길이 프레임 원시 형식 +----+----+----+----+----+----+----+----+ | ChaChaPoly Frame 1 (48 bytes) | + Plaintext: Alice static key (32B) + | k from KDF-2, n=1, ad=h | + + | | +----+----+----+----+----+----+----+----+ | | + ChaChaPoly Frame 2 (variable) + | Length specified in msg1.m3p2len | + k from KDF-3, n=0, ad=h + | Plaintext: RouterInfo + padding | + + | | ~ . . . ~ +----+----+----+----+----+----+----+----+ 크기 제한: - 파트 1: 정확히 48바이트 (32바이트 평문 + 16바이트 MAC) - 파트 2: 메시지 1에서 지정된 길이 (m3p2len 필드) - 총 최대: 65535바이트 (파트 1 최대 48, 따라서 파트 2 최대 65487)\n복호화된 콘텐츠 파트 1:\n+----+----+----+----+----+----+----+----+ | | + S (Alice static public key) + | 32 bytes, X25519, little-endian | + + | | +----+----+----+----+----+----+----+----+ 2부:\n+----+----+----+----+----+----+----+----+ | Block: RouterInfo (required) | + Type=2, contains Alice\u0026#39;s RI + | | ~ . . . ~ +----+----+----+----+----+----+----+----+ | Block: Options (optional) | + Type=1, padding parameters + | | +----+----+----+----+----+----+----+----+ | Block: Padding (optional) | + Type=254, random data + | MUST be last block if present | ~ . . . ~ +----+----+----+----+----+----+----+----+ 키 파생 함수(KDF-3) 파트 1 (s 패턴):\nh = SHA256(h || encrypted_payload_msg2) // 32-byte ciphertext if (msg2_padding_length \u0026gt; 0): h = SHA256(h || padding_from_msg2) // Encrypt static key with message 2 cipher key ciphertext = AEAD_ChaCha20_Poly1305(k_msg2, n=1, h, Alice.static_public) h = SHA256(h || ciphertext) // 48 bytes (32 + 16) // h is now the associated data for message 3 part 2 2부(se 패턴):\ndh_result = X25519(Alice.static_private, Bob.ephemeral_public) temp_key = HMAC-SHA256(ck, dh_result) ck = HMAC-SHA256(temp_key, byte(0x01)) k = HMAC-SHA256(temp_key, ck || byte(0x02)) // k is the cipher key for message 3 part 2 // ck is retained for data phase KDF ciphertext = AEAD_ChaCha20_Poly1305(k, n=0, h, payload) h = SHA256(h || ciphertext) // h is retained for SipHash KDF 메모리 정리:\n// Overwrite Bob\u0026#39;s ephemeral key after se DH Alice.received_ephemeral = zeros(32) // Alice side Bob.ephemeral_public = zeros(32) // Bob side Bob.ephemeral_private = zeros(32) // Bob side 구현 참고 사항 RouterInfo(라우터 정보) 검증: Bob은 서명, 타임스탬프, 키의 일관성을 검증해야 한다 키 일치: Bob은 파트 1에 있는 Alice의 정적 키가 RouterInfo의 키와 일치하는지 검증해야 한다 정적 키 위치: NTCP 또는 NTCP2 RouterAddress(라우터 주소)에서 일치하는 \u0026ldquo;s\u0026rdquo; 매개변수를 찾는다 블록 순서: RouterInfo는 첫 번째여야 하고, Options는 두 번째(있는 경우), Padding은 마지막(있는 경우)이어야 한다 길이 계획: Alice는 메시지 1의 m3p2len이 파트 2 길이와 정확히 일치하도록 해야 한다 버퍼링: Alice는 두 파트를 하나의 TCP 전송으로 함께 보내도록 플러시해야 한다 선택적 체이닝: 효율을 위해 Alice는 즉시 data phase frame(데이터 단계 프레임)을 이어붙일 수 있다 데이터 단계 핸드셰이크가 완료된 후에는 모든 메시지가 난독화된 길이 필드를 가진 가변 길이 AEAD(연관 데이터가 포함된 인증 암호화) 프레임을 사용합니다.\n키 파생 함수(데이터 단계) Split 함수(Noise 프로토콜):\n// Generate transmit and receive keys zerolen = \u0026#34;\u0026#34; // Zero-length byte array temp_key = HMAC-SHA256(ck, zerolen) // Alice transmits to Bob k_ab = HMAC-SHA256(temp_key, byte(0x01)) // Bob transmits to Alice k_ba = HMAC-SHA256(temp_key, k_ab || byte(0x02)) // Cleanup ck = zeros(32) temp_key = zeros(32) SipHash 키 파생:\n// Generate additional symmetric key for SipHash ask_master = HMAC-SHA256(temp_key, \u0026#34;ask\u0026#34; || byte(0x01)) // \u0026#34;siphash\u0026#34; is 7 bytes US-ASCII temp_key2 = HMAC-SHA256(ask_master, h || \u0026#34;siphash\u0026#34;) sip_master = HMAC-SHA256(temp_key2, byte(0x01)) // Alice to Bob SipHash keys temp_key3 = HMAC-SHA256(sip_master, zerolen) sipkeys_ab = HMAC-SHA256(temp_key3, byte(0x01)) sipk1_ab = sipkeys_ab[0:7] // 8 bytes, little-endian sipk2_ab = sipkeys_ab[8:15] // 8 bytes, little-endian sipiv_ab = sipkeys_ab[16:23] // 8 bytes, IV // Bob to Alice SipHash keys sipkeys_ba = HMAC-SHA256(temp_key3, sipkeys_ab || byte(0x02)) sipk1_ba = sipkeys_ba[0:7] // 8 bytes, little-endian sipk2_ba = sipkeys_ba[8:15] // 8 bytes, little-endian sipiv_ba = sipkeys_ba[16:23] // 8 bytes, IV 프레임 구조 +----+----+----+----+----+----+----+----+ |Obfs Len | | +----+----+ ChaChaPoly Frame + | Encrypted Block Data | + k_ab (Alice→Bob) or k_ba (Bob→Alice)| | Nonce starts at 0, increments | + No associated data (empty string) + | | ~ . . . ~ | | +----+----+----+----+----+----+----+----+ | Poly1305 MAC (16 bytes) | +----+----+----+----+----+----+----+----+ 프레임 제약 조건: - 최소: 18바이트 (2바이트 난독화된 길이 + 0바이트 평문 + 16바이트 MAC(메시지 인증 코드)) - 최대: 65537바이트 (2바이트 난독화된 길이 + 65535바이트 프레임) - 권장: 프레임당 수 KB (수신 지연을 최소화)\nSipHash 길이 난독화 목적: DPI(딥 패킷 검사)가 프레임 경계를 식별하는 것을 방지\n알고리즘:\n// Initialization (per direction) IV[0] = sipiv // From KDF // For each frame: IV[n] = SipHash-2-4(sipk1, sipk2, IV[n-1]) Mask[n] = IV[n][0:1] // First 2 bytes of IV ObfuscatedLength = ActualLength XOR Mask[n] // Send 2-byte ObfuscatedLength, then ActualLength bytes 디코딩:\n// Receiver maintains identical IV chain IV[n] = SipHash-2-4(sipk1, sipk2, IV[n-1]) Mask[n] = IV[n][0:1] ActualLength = ObfuscatedLength XOR Mask[n] // Read ActualLength bytes (includes 16-byte MAC) 참고: - 각 방향(Alice→Bob 및 Bob→Alice)에 대해 별도의 IV(초기화 벡터) 체인을 사용 - SipHash가 uint64를 반환하는 경우, 최하위 2바이트를 마스크로 사용 - uint64를 little-endian 바이트로 변환하여 다음 IV로 사용\n블록 형식 각 프레임에는 0개 이상의 블록이 포함됩니다:\n+----+----+----+----+----+----+----+----+ |Type| Length | Data | +----+----+----+ + | | ~ . . . ~ +----+----+----+----+----+----+----+----+ Type : 1 byte - Block type identifier Length: 2 bytes - Big-endian, data size (0-65516) Data : Variable length payload 크기 제한: - 최대 프레임: 65535 바이트 (MAC 포함) - 최대 블록 공간: 65519 바이트 (프레임 - 16바이트 MAC) - 최대 단일 블록: 65519 바이트 (3바이트 헤더 + 65516바이트 데이터)\n블록 유형 Type Name Description 0DateTimeTime synchronization (4-byte timestamp) 1OptionsPadding parameters, dummy traffic 2RouterInfoRouterInfo delivery/flooding 3I2NPI2NP message with shortened header 4TerminationExplicit connection close 224-253ReservedExperimental features 254PaddingRandom padding (must be last) 255ReservedFuture extensions **블록 순서 규칙:** - **메시지 3 파트 2**: RouterInfo(라우터 정보), 옵션 (선택 사항), 패딩 (선택 사항) - 다른 유형은 없음 - **데이터 단계**: 다음 예외를 제외하고 임의 순서: - 패딩은 존재하는 경우 반드시 마지막 블록이어야 함 - 종료는 존재하는 경우(패딩 제외) 반드시 마지막 블록이어야 함 - 프레임당 I2NP 블록 여러 개 허용 - 프레임당 패딩 블록 여러 개는 허용되지 않음 블록 유형 0: DateTime clock skew(클록 간 시간 불일치) 감지를 위한 시간 동기화.\n+----+----+----+----+----+----+----+ | 0 | 4 | timestamp | +----+----+----+----+----+----+----+ Type : 0 Length : 4 (big-endian) Timestamp: 4 bytes, Unix seconds (big-endian) 구현: 시계 오차 누적을 방지하기 위해 가장 가까운 초로 반올림합니다.\n블록 유형 1: 옵션 패딩 및 트래픽 셰이핑 매개변수.\n+----+----+----+----+----+----+----+----+ | 1 | size |tmin|tmax|rmin|rmax|tdmy| +----+----+----+----+----+----+----+----+ |tdmy| rdmy | tdelay | rdelay | | +----+----+----+----+----+----+----+ + | more_options (TBD) | ~ . . . ~ +----+----+----+----+----+----+----+----+ Type : 1 Length: 12+ bytes (big-endian) 패딩 비율 (4.4 고정소수점 값, value/16.0): - tmin: 송신 최소 패딩 비율 (0.0 - 15.9375) - tmax: 송신 최대 패딩 비율 (0.0 - 15.9375) - rmin: 수신 최소 패딩 비율 (0.0 - 15.9375) - rmax: 수신 최대 패딩 비율 (0.0 - 15.9375)\n예시: - 0x00 = 0% 패딩 - 0x01 = 6.25% 패딩 - 0x10 = 100% 패딩 (1:1 비율) - 0x80 = 800% 패딩 (8:1 비율)\n더미 트래픽: - tdmy: 보내기를 허용하는 최대치 (2바이트, 초당 바이트 평균) - rdmy: 수신 요청치 (2바이트, 초당 바이트 평균)\n지연 삽입: - tdelay: 삽입하려는 최대치 (2바이트, 밀리초 평균) - rdelay: 요청된 지연 (2바이트, 밀리초 평균)\n지침: - 최소값은 원하는 트래픽 분석 저항성을 나타낸다 - 최대값은 대역폭 제약을 나타낸다 - 송신자는 수신자의 최대값을 존중해야 한다 - 송신자는 제약 내에서 수신자의 최소값을 존중할 수 있다 - 강제 메커니즘은 없음; 구현은 달라질 수 있음\n블록 유형 2: RouterInfo netdb 구축 및 flooding(브로드캐스트식 전파)을 위한 RouterInfo 배포.\n+----+----+----+----+----+----+----+----+ | 2 | size |flg | RouterInfo | +----+----+----+----+ + | | ~ . . . ~ +----+----+----+----+----+----+----+----+ Type : 2 Length: Flag (1 byte) + RouterInfo size Flag : Bit 0 = flood request (1) or local store (0) Bits 1-7 = Reserved, set to 0 사용법:\n메시지 3 파트 2에서 (핸드셰이크): - Alice가 자신의 RouterInfo(라우터 정보)를 Bob에게 보냄 - Flood bit는 보통 0(로컬 저장) - RouterInfo는 gzip으로 압축되지 않음\n데이터 단계에서: - 양측 중 어느 한쪽은 업데이트된 RouterInfo를 보낼 수 있음 - Flood bit(플러드 비트) = 1: floodfill 배포를 요청(수신자가 floodfill인 경우) - Flood bit = 0: 로컬 netdb 저장만\n검증 요구 사항: 1. 서명 유형이 지원되는지 확인 2. RouterInfo 서명 확인 3. 타임스탬프가 허용 범위 내에 있는지 확인 4. 핸드셰이크의 경우: 정적 키가 NTCP2 주소의 \u0026ldquo;s\u0026rdquo; 매개변수와 일치하는지 확인 5. 데이터 단계의 경우: router 해시가 세션 피어와 일치하는지 확인 6. 공개된 주소가 있는 RouterInfos만 전파\n참고: - ACK 메커니즘 없음(필요한 경우 reply token(응답 토큰)과 함께 I2NP DatabaseStore 사용) - 제3자 RouterInfos(라우터 정보)를 포함할 수 있음(floodfill 사용) - gzip으로 압축되지 않음(I2NP DatabaseStore와 달리)\n블록 유형 3: I2NP 메시지 축약된 9바이트 헤더를 가진 I2NP 메시지.\n+----+----+----+----+----+----+----+----+ | 3 | size |type| msg_id | +----+----+----+----+----+----+----+----+ | expiration | I2NP payload | +----+----+----+ + | | ~ . . . ~ +----+----+----+----+----+----+----+----+ Type : 3 Length : 9 + payload_size (big-endian) Type : 1 byte, I2NP message type Msg_ID : 4 bytes, big-endian, I2NP message ID Expiration: 4 bytes, big-endian, Unix timestamp (seconds) Payload : I2NP message body (length = size - 9) NTCP1과의 차이점: - 만료 시각: 4바이트(초) vs 8바이트(밀리초) - 길이: 생략됨(블록 길이에서 도출 가능) - 체크섬: 생략됨(AEAD가 무결성을 제공) - 헤더: 9바이트 vs 16바이트(44% 감소)\n단편화: - I2NP 메시지는 블록 간 분할되어서는 안 됩니다 - I2NP 메시지는 프레임 간 분할되어서는 안 됩니다 - 프레임당 여러 I2NP 블록이 허용됩니다\n블록 유형 4: 종료 사유 코드를 포함한 명시적 연결 종료.\n+----+----+----+----+----+----+----+----+ | 4 | size | valid_frames_recv | +----+----+----+----+----+----+----+----+ | (continued) |rsn | additional_data | +----+----+----+----+ + | | ~ . . . ~ +----+----+----+----+----+----+----+----+ Type : 4 Length : 9+ bytes (big-endian) Valid_Frames_Recv: 8 bytes, big-endian (receive nonce value) 0 if error in handshake phase Reason : 1 byte (see table below) Additional_Data : Optional (format unspecified, for debugging) 사유 코드:\nCode Reason Phase 0Normal close / unspecifiedAny 1Termination receivedData 2Idle timeoutData 3Router shutdownData 4Data phase AEAD failureData 5Incompatible optionsHandshake 6Incompatible signature typeHandshake 7Clock skewHandshake 8Padding violationAny 9AEAD framing errorData 10Payload format errorData 11Message 1 errorHandshake 12Message 2 errorHandshake 13Message 3 errorHandshake 14Intra-frame read timeoutData 15RouterInfo signature verification failHandshake 16Static key parameter mismatchHandshake 17BannedAny **규칙:** - 종료 블록은 프레임 내에서 패딩이 아닌 마지막 블록이어야 함 - 프레임당 종료 블록은 최대 1개 - 송신자는 전송 후 연결을 닫는 것이 바람직함 - 수신자는 수신 후 연결을 닫는 것이 바람직함 오류 처리: - 핸드셰이크 오류: 일반적으로 TCP RST로 종료(종료 블록 없음) - 데이터 단계 AEAD 오류: 무작위 타임아웃 + 무작위 읽기, 그런 다음 종료 전송 - 보안 절차는 \u0026ldquo;AEAD Error Handling\u0026rdquo; 섹션을 참조하십시오\n블록 유형 254: 패딩 트래픽 분석 저항성을 위한 무작위 패딩.\n+----+----+----+----+----+----+----+----+ |254 | size | random_data | +----+----+----+ + | | ~ . . . ~ +----+----+----+----+----+----+----+----+ Type: 254 Length: 0-65516 bytes (big-endian) Data: Cryptographically random bytes 규칙: - 패딩이 존재하는 경우 프레임 내에서 마지막 블록이어야 함 - 길이가 0인 패딩은 허용됨 - 프레임당 패딩 블록은 하나만 허용됨 - 패딩만 있는 프레임은 허용됨 - Options 블록에서 협상된 매개변수를 준수해야 함\n메시지 1-2의 패딩: - AEAD(연관 데이터가 있는 인증된 암호화) 프레임 바깥(평문) - 다음 메시지의 해시 체인에 포함됨(인증됨) - 다음 메시지의 AEAD가 실패하면 변조가 탐지됨\n메시지 3+ 및 데이터 단계의 패딩: - AEAD 프레임 내부(암호화 및 인증됨) - 트래픽 셰이핑과 크기 은폐에 사용됨\nAEAD 오류 처리 핵심 보안 요구사항:\n핸드셰이크 단계 (메시지 1-3) 알려진 메시지 크기: - 메시지 크기는 미리 정해지거나 사전에 지정됨 - AEAD(연관 데이터가 있는 인증 암호화) 인증 실패는 모호하지 않음\nBob의 메시지 1 실패에 대한 대응: 1. 임의의 타임아웃 설정(범위는 구현에 따라 다름, 권장 100–500ms) 2. 임의의 바이트 수 읽기(범위는 구현에 따라 다름, 권장 1KB–64KB) 3. TCP RST로 연결 종료(응답 없이) 4. 소스 IP를 일시적으로 차단 목록에 추가 5. 장기 차단을 위해 반복된 실패를 추적\n메시지 2 실패에 대한 Alice의 대응: 1. TCP RST로 즉시 연결을 종료 2. Bob에게 응답하지 않음\n메시지 3 실패에 대한 Bob의 응답: 1. TCP RST(TCP 재설정)로 즉시 연결 종료 2. Alice에게 응답 없음\n데이터 단계 난독화된 메시지 크기: - 길이 필드는 SipHash(경량 MAC 함수)로 난독화됨 - 잘못된 길이이거나 AEAD(연관 데이터가 있는 인증된 암호화) 실패는 다음을 의미할 수 있음: - 공격자 프로빙(탐색) - 네트워크 손상 - 비동기화된 SipHash IV(초기화 벡터) - 악의적인 피어\nAEAD(연관 데이터가 있는 인증 암호화) 또는 길이 오류에 대한 응답: 1. 임의의 타임아웃을 설정한다 (권장 100-500ms) 2. 임의의 바이트 수를 읽는다 (권장 1KB-64KB) 3. 사유 코드 4(AEAD 실패) 또는 9(프레이밍 오류)가 포함된 종료 블록을 전송한다 4. 연결을 종료한다\n복호화 오라클 방지: - 임의의 타임아웃이 지나기 전에는 피어에게 오류 유형을 절대 공개하지 말 것 - AEAD(연관 데이터 인증 암호화) 검사를 수행하기 전에 길이 검증을 절대로 건너뛰지 말 것 - 유효하지 않은 길이는 AEAD 실패와 동일하게 취급할 것 - 두 오류 모두에 대해 동일한 오류 처리 경로를 사용할 것\n구현 시 고려사항: - AEAD(인증된 연관 데이터 암호화) 오류가 드물다면 일부 구현은 계속 진행할 수 있음 - 반복적으로 오류가 발생할 경우 종료 (권장 임계값: 시간당 3-5회 오류) - 오류 복구와 보안 간 균형 유지\n게시된 RouterInfo Router 주소 형식 NTCP2 지원 여부는 특정 옵션이 포함된 공개된 RouterAddress 항목을 통해 고지됩니다.\n전송 방식: - \u0026quot;NTCP2\u0026quot; - 이 포트에서 NTCP2만 사용 - \u0026quot;NTCP\u0026quot; - 이 포트에서 NTCP와 NTCP2 모두 사용(자동 감지) - 참고: NTCP (v1) 지원은 0.9.50(2021년 5월)에서 제거됨 - \u0026ldquo;NTCP\u0026rdquo; 스타일은 이제 사용 중단됨; \u0026ldquo;NTCP2\u0026quot;를 사용하세요\n필수 옵션 모든 공개된 NTCP2 주소:\nhost - IP 주소(IPv4 또는 IPv6) 또는 호스트 이름\n형식: 표준 IP 표기법 또는 도메인 이름 아웃바운드 전용 또는 숨겨진 router의 경우 생략할 수 있음 port - TCP 포트 번호\n형식: 정수, 1-65535 아웃바운드 전용 또는 숨겨진 router에서는 생략될 수 있음 s - 정적 공개 키 (X25519)\n형식: Base64 인코딩, 44자 인코딩: I2P Base64 알파벳 원본: 32바이트 X25519 공개 키, little-endian(리틀 엔디언) i - AES용 초기화 벡터(IV)\n형식: Base64로 인코딩된, 24자 인코딩: I2P Base64 알파벳 원본: 16바이트 IV, 빅엔디언 v - 프로토콜 버전\n형식: 정수 또는 쉼표로 구분된 정수들 현재: \u0026quot;2\u0026quot; 향후: \u0026quot;2,3\u0026quot; (숫자 순서여야 함) 선택적 옵션:\ncaps - Capabilities(기능) (0.9.50부터)\n형식: capability 문자로 이루어진 문자열 값: \u0026quot;4\u0026quot; - IPv4 아웃바운드 기능 \u0026quot;6\u0026quot; - IPv6 아웃바운드 기능 \u0026quot;46\u0026quot; - IPv4와 IPv6 모두 (권장 순서) host가 공개된 경우 필요 없음 숨겨진/방화벽 뒤에 있는 routers에 유용함 cost - 주소 우선순위\n형식: 정수, 0-255 값이 낮을수록 = 우선순위가 높음 권장: 일반 주소의 경우 5-10 권장: 미공개 주소의 경우 14 RouterAddress 엔트리 예시 공개된 IPv4 주소:\n\u0026lt;Address cost=\u0026#34;5\u0026#34;\u0026gt; \u0026lt;transport_style\u0026gt;NTCP2\u0026lt;/transport_style\u0026gt; \u0026lt;options\u0026gt; \u0026lt;host\u0026gt;192.0.2.1\u0026lt;/host\u0026gt; \u0026lt;port\u0026gt;8887\u0026lt;/port\u0026gt; \u0026lt;s\u0026gt;9EjeG7BZeznKbL9a2fXx8JBDPgLZbLmKbqY3QrNGJCo=\u0026lt;/s\u0026gt; \u0026lt;i\u0026gt;MDEyMzQ1Njc4OUFCQ0RFRg==\u0026lt;/i\u0026gt; \u0026lt;v\u0026gt;2\u0026lt;/v\u0026gt; \u0026lt;/options\u0026gt; \u0026lt;/Address\u0026gt; 숨겨진 Router (아웃바운드 전용):\n\u0026lt;Address cost=\u0026#34;14\u0026#34;\u0026gt; \u0026lt;transport_style\u0026gt;NTCP2\u0026lt;/transport_style\u0026gt; \u0026lt;options\u0026gt; \u0026lt;s\u0026gt;9EjeG7BZeznKbL9a2fXx8JBDPgLZbLmKbqY3QrNGJCo=\u0026lt;/s\u0026gt; \u0026lt;v\u0026gt;2\u0026lt;/v\u0026gt; \u0026lt;caps\u0026gt;4\u0026lt;/caps\u0026gt; \u0026lt;/options\u0026gt; \u0026lt;/Address\u0026gt; 듀얼 스택 Router:\n\u0026lt;!-- IPv4 Address --\u0026gt; \u0026lt;Address cost=\u0026#34;5\u0026#34;\u0026gt; \u0026lt;transport_style\u0026gt;NTCP2\u0026lt;/transport_style\u0026gt; \u0026lt;options\u0026gt; \u0026lt;host\u0026gt;192.0.2.1\u0026lt;/host\u0026gt; \u0026lt;port\u0026gt;8887\u0026lt;/port\u0026gt; \u0026lt;s\u0026gt;9EjeG7BZeznKbL9a2fXx8JBDPgLZbLmKbqY3QrNGJCo=\u0026lt;/s\u0026gt; \u0026lt;i\u0026gt;MDEyMzQ1Njc4OUFCQ0RFRg==\u0026lt;/i\u0026gt; \u0026lt;v\u0026gt;2\u0026lt;/v\u0026gt; \u0026lt;/options\u0026gt; \u0026lt;/Address\u0026gt; \u0026lt;!-- IPv6 Address (same keys, same port) --\u0026gt; \u0026lt;Address cost=\u0026#34;5\u0026#34;\u0026gt; \u0026lt;transport_style\u0026gt;NTCP2\u0026lt;/transport_style\u0026gt; \u0026lt;options\u0026gt; \u0026lt;host\u0026gt;2001:db8::1\u0026lt;/host\u0026gt; \u0026lt;port\u0026gt;8887\u0026lt;/port\u0026gt; \u0026lt;s\u0026gt;9EjeG7BZeznKbL9a2fXx8JBDPgLZbLmKbqY3QrNGJCo=\u0026lt;/s\u0026gt; \u0026lt;i\u0026gt;MDEyMzQ1Njc4OUFCQ0RFRg==\u0026lt;/i\u0026gt; \u0026lt;v\u0026gt;2\u0026lt;/v\u0026gt; \u0026lt;/options\u0026gt; \u0026lt;/Address\u0026gt; 중요 규칙: - 동일한 포트를 사용하는 여러 NTCP2 주소는 s, i, v 값이 반드시 동일해야 합니다 - 서로 다른 포트는 서로 다른 키를 사용할 수 있습니다 - 듀얼스택 router는 IPv4와 IPv6 주소를 별도로 게시해야 합니다\n공개되지 않은 NTCP2 주소 아웃바운드 전용 Routers의 경우:\nrouter가 수신 NTCP2 연결을 허용하지 않지만 송신 연결은 개시하는 경우에도, 여전히 다음을 포함하는 RouterAddress(라우터 주소 정보)를 발행해야 한다:\n\u0026lt;Address cost=\u0026#34;14\u0026#34;\u0026gt; \u0026lt;transport_style\u0026gt;NTCP2\u0026lt;/transport_style\u0026gt; \u0026lt;options\u0026gt; \u0026lt;s\u0026gt;9EjeG7BZeznKbL9a2fXx8JBDPgLZbLmKbqY3QrNGJCo=\u0026lt;/s\u0026gt; \u0026lt;v\u0026gt;2\u0026lt;/v\u0026gt; \u0026lt;/options\u0026gt; \u0026lt;/Address\u0026gt; 목적: - 핸드셰이크 중 Bob이 Alice의 정적 키를 검증할 수 있도록 함 - 메시지 3 파트 2의 RouterInfo 검증에 필요 - i, host, port가 필요 없음 (아웃바운드 전용)\n대안: - 기존에 공개된 \u0026ldquo;NTCP\u0026rdquo; 또는 SSU 주소에 s와 v를 추가합니다\n공개 키 및 IV(초기화 벡터) 로테이션 중요 보안 정책:\n일반 규칙: 1. router가 실행 중일 때는 절대 rotate(교체)하지 마십시오 2. 키와 IV(초기화 벡터)를 영구적으로 저장 재시작 간에도 3. 이전 다운타임을 추적 rotation 적용 가능 여부를 판단하기 위해\n로테이션 전에 필요한 최소 다운타임:\nRouter Type Min Downtime Reason Published NTCP2 address1 monthMany routers cache RouterInfo Published SSU only (no NTCP2)1 dayModerate caching No published addresses (hidden)2 hoursMinimal impact **추가 트리거:** - 로컬 IP 주소 변경: 다운타임 여부와 상관없이 변경될 수 있음 - Router \"rekey\" (새 Router Hash): 새 키 생성 근거: - 키 변경을 통해 재시작 시간을 노출하는 것을 방지 - 캐시된 RouterInfos(라우터 정보 객체)가 자연스럽게 만료되도록 허용 - 네트워크 안정성을 유지 - 실패한 연결 시도를 줄임\n구현: 1. 키, IV(초기화 벡터), 마지막 종료 타임스탬프를 영구적으로 저장한다 2. 시작 시, downtime 값을 current_time - last_shutdown으로 계산한다 3. downtime가 router 유형의 최소값을 초과하면 키를 교체할 수 있다 4. IP가 변경되었거나 rekeying(키를 다시 생성하는 작업)이면 키를 교체할 수 있다 5. 그렇지 않으면 이전 키와 IV를 재사용한다\nIV 회전: - 키 회전과 동일한 규칙이 적용됨 - 공개된 주소에만 존재함 (숨겨진 routers에는 해당 없음) - 키가 변경될 때마다 IV를 변경할 것을 권장\n버전 감지 맥락: transportStyle=\u0026quot;NTCP\u0026quot; (레거시)인 경우, Bob은 동일한 포트에서 NTCP v1과 v2를 모두 지원하며 프로토콜 버전을 자동으로 감지해야 합니다.\n탐지 알고리즘:\n1. Wait for at least 64 bytes (minimum NTCP2 message 1 size) 2. If received ≥ 288 bytes: → Connection is NTCP version 1 (NTCP1 message 1 is 288 bytes) 3. If received \u0026lt; 288 bytes: Option A (conservative, pre-NTCP2 majority): a. Wait additional short time (e.g., 100-500ms) b. If total received ≥ 288 bytes → NTCP1 c. Otherwise → Attempt NTCP2 decode Option B (aggressive, post-NTCP2 majority): a. Attempt NTCP2 decode immediately: - Decrypt first 32 bytes (X key) with AES-256-CBC - Verify valid X25519 point (X[31] \u0026amp; 0x80 == 0) - Verify AEAD frame b. If decode succeeds → NTCP2 c. If decode fails → Wait for more data or NTCP1 빠른 MSB 검사: - AES 복호화 전에 다음을 확인: encrypted_X[31] \u0026amp; 0x80 == 0 - 유효한 X25519 키는 최상위 비트가 클리어되어 있음 - 실패 시 NTCP1(또는 공격)일 가능성이 높음 - 실패 시 probing resistance(탐침 방어) 구현(무작위 타임아웃 + 읽기)\n구현 요구 사항:\nAlice의 책임:\n\u0026ldquo;NTCP\u0026rdquo; 주소에 연결할 때, 메시지 1의 크기를 최대 287바이트로 제한 메시지 1 전체를 버퍼링하고 한 번에 플러시 단일 TCP 패킷으로 전송될 가능성을 높임 Bob의 책임:\n버전을 판별하기 전에 수신된 데이터를 버퍼링할 것 적절한 타임아웃 처리를 구현할 것 빠른 버전 판별을 위해 TCP_NODELAY(Nagle algorithm 비활성화 옵션)을 사용할 것 버전 판별 후 메시지 2 전체를 버퍼에 모아 한 번에 플러시할 것 보안 고려사항: - 세그멘테이션 공격: Bob은 TCP 세그멘테이션에 내성이 있어야 함 - 프로빙 공격: 실패 시 무작위 지연과 바이트 읽기를 구현 - DoS 방지: 대기 중인 동시 연결 수를 제한 - 읽기 타임아웃: 개별 읽기와 전체 둘 다 (\u0026ldquo;slowloris\u0026rdquo;(연결을 길게 유지하며 요청을 지연시켜 자원을 고갈시키는 공격) 방어)\n시계 오차 지침 타임스탬프 필드: - 메시지 1: tsA (Alice의 타임스탬프) - 메시지 2: tsB (Bob의 타임스탬프) - 메시지 3+: 선택적 DateTime 블록\n최대 시간 오차(D): - 일반적: ±60초 - 구현별로 설정 가능 - 시간 오차 \u0026gt; D는 일반적으로 치명적임\nBob의 처리 (메시지 1) 1. Receive tsA from Alice 2. skew = tsA - current_time 3. If |skew| \u0026gt; D: a. Still send message 2 (allows Alice to calculate skew) b. Include tsB in message 2 c. Do NOT initiate handshake completion d. Optionally: Temporary ban Alice\u0026#39;s IP e. After message 2 sent, close connection 4. If |skew| ≤ D: a. Continue handshake normally 이유: skew(클록 오차) 상태에서도 메시지 2를 보내면 Alice가 클록 문제를 진단할 수 있다.\n앨리스의 처리 (메시지 2) 1. Receive tsB from Bob 2. RTT = (current_time_now - tsA_sent) 3. adjusted_skew = (tsB - current_time_now) - (RTT / 2) 4. If |adjusted_skew| \u0026gt; D: a. Close connection immediately b. If local clock suspect: Adjust clock or use external time source c. If Bob\u0026#39;s clock suspect: Temporary ban Bob d. Log for operator review 5. If |adjusted_skew| ≤ D: a. Continue handshake normally b. Optionally: Track skew for time synchronization RTT 조정: - 계산된 스큐(시간 편차)에서 RTT의 절반을 빼기 - 네트워크 전파 지연을 반영 - 더 정확한 스큐 추정\nBob의 처리 (메시지 3) 1. If message 3 received (unlikely if skew exceeded in message 1) 2. Recalculate skew = tsA_received - current_time 3. If |adjusted_skew| \u0026gt; D: a. Send termination block (reason code 7: clock skew) b. Close connection c. Ban Alice for period (e.g., 1-24 hours) 시간 동기화 DateTime 블록(데이터 단계): - 주기적으로 DateTime 블록 전송 (type 0) - 수신자는 시계 조정에 사용할 수 있음 - 타임스탬프를 가장 가까운 초로 반올림 (편향 방지)\n외부 시간 소스: - NTP(네트워크 시간 프로토콜) - 시스템 시계 동기화 - I2P 네트워크 합의 시간\n클록 조정 전략: - 로컬 클록이 잘못된 경우: 시스템 시간을 조정하거나 오프셋 사용 - 피어 클록이 지속적으로 잘못된 경우: 피어 문제로 플래그 지정 - 네트워크 건전성 모니터링을 위해 clock skew(시간 오차) 통계를 추적\n보안 속성 순방향 기밀성 다음 방식으로 달성: - 임시 Diffie-Hellman 키 교환 (X25519) - 세 가지 DH 연산: es, ee, se (Noise XK pattern: Noise 프로토콜의 XK 패턴) - 핸드셰이크 완료 후 임시 키 파기\n기밀성 진행: - 메시지 1: 레벨 2 (발신자 키 유출 시 forward secrecy(순방향 보안)) - 메시지 2: 레벨 1 (임시 수신자) - 메시지 3+: 레벨 5 (강력한 forward secrecy)\n완전 순방향 기밀성(Perfect Forward Secrecy, PFS): - 장기 정적 키가 유출되어도 과거 세션 키는 공개되지 않습니다 - 각 세션은 고유한 임시 키를 사용합니다 - 임시 개인 키는 절대 재사용하지 않습니다 - 키 합의 후 메모리 정리\n제한 사항: - Bob의 정적 키가 탈취되면 메시지 1은 취약해진다(단, Alice가 침해되더라도 Forward Secrecy(전방향 기밀성)은 유지됨) - 메시지 1에 대해 재전송 공격 가능(타임스탬프와 재전송 캐시로 완화됨)\n인증 상호 인증: - Alice는 메시지 3의 정적 키로 인증됨 - Bob은 정적 개인 키를 보유함으로써 인증됨 (성공적인 핸드셰이크에서 암시됨)\nKey Compromise Impersonation (KCI, 키 손상에 의한 사칭) 저항성: - 인증 레벨 2 (KCI에 내성) - 공격자는 Alice의 정적 개인 키만으로는 (Alice의 임시 키 없이) Alice를 사칭할 수 없음 - 공격자는 Bob의 정적 개인 키만으로는 (Bob의 임시 키 없이) Bob을 사칭할 수 없음\n정적 키 검증: - Alice는 Bob의 정적 키를 미리 알고 있음(RouterInfo(라우터 정보)에서) - Bob은 메시지 3에서 Alice의 정적 키가 RouterInfo와 일치하는지 검증함 - 중간자 공격을 방지함\n트래픽 분석에 대한 저항성 DPI(딥 패킷 검사) 대응책: 1. AES 난독화: 임시 키가 암호화되어 무작위처럼 보임 2. SipHash 길이 난독화: 프레임 길이는 평문이 아님 3. 무작위 패딩: 메시지 크기가 가변적이며, 고정된 패턴이 없음 4. 암호화된 프레임: 모든 페이로드는 ChaCha20으로 암호화됨\n리플레이(재전송) 공격 방지: - 타임스탬프 검증(±60초) - ephemeral 키에 대한 replay 캐시(수명 2*D) - Nonce(일회용 임의값) 증가로 세션 내 패킷 재전송을 방지\n프로빙 저항성: - AEAD(부가 데이터가 포함된 인증된 암호화) 실패 시 임의의 타임아웃 - 연결 종료 전에 임의의 바이트 읽기 - 핸드셰이크 실패 시 응답 없음 - 반복된 실패 시 IP 블랙리스트 등재\n패딩 지침: - 메시지 1-2: 평문 패딩(인증됨) - 메시지 3+: AEAD(연관 데이터가 포함된 인증 암호) 프레임 내부의 암호화된 패딩 - 협상된 패딩 매개변수(Options 블록) - 패딩 전용 프레임 허용됨\n서비스 거부(DoS) 완화 연결 제한: - 최대 활성 연결 수(구현에 따라 다름) - 대기 중인 핸드셰이크의 최대치(예: 100-1000) - IP당 연결 제한(예: 동시 3-10개)\n리소스 보호: - DH 연산 속도 제한 (비용이 큼) - 소켓별 및 전체 읽기 타임아웃 - \u0026ldquo;Slowloris\u0026rdquo; 보호 (총 시간 제한) - 남용 방지를 위한 IP 블랙리스트\n빠른 거부: - Network ID 불일치 → 즉시 종료 - 유효하지 않은 X25519 point(타원 곡선 X25519의 점) → 복호화 전에 빠른 최상위 비트(MSB) 검사 - 범위를 벗어난 타임스탬프 → 연산 없이 종료 - AEAD 실패 → 응답 없음, 무작위 지연\n프로빙 저항성: - 임의 타임아웃: 100-500ms (구현에 따라 다름) - 임의 읽기: 1KB-64KB (구현에 따라 다름) - 공격자에게 오류 정보를 제공하지 않음 - TCP RST로 종료 (FIN 핸드셰이크 없음)\n암호학적 보안 알고리즘: - X25519: 128비트 보안 강도, 타원곡선 DH (Curve25519) - ChaCha20: 256비트 키를 사용하는 스트림 암호 - Poly1305: 정보이론적으로 안전한 MAC - SHA-256: 128비트 충돌 저항성, 256비트 전이미지 저항성 - HMAC-SHA256: 키 파생용 PRF(의사난수 함수)\n키 크기: - 정적 키: 32 바이트 (256 비트) - 임시 키: 32 바이트 (256 비트) - 암호화 키: 32 바이트 (256 비트) - MAC: 16 바이트 (128 비트)\n알려진 문제: - ChaCha20 논스 재사용은 치명적입니다 (카운터 증가로 방지됨) - X25519에는 작은 부분군 문제가 있습니다 (곡선 검증으로 완화됨) - SHA-256은 이론적으로 길이 확장 공격에 취약합니다 (HMAC에서는 악용되지 않음)\n알려진 취약점 없음(2025년 10월 기준): - Noise Protocol Framework(노이즈 프로토콜 프레임워크) 광범위하게 분석됨 - ChaCha20-Poly1305 TLS 1.3에 채택됨 - X25519 최신 프로토콜에서 표준 - 구성에 대한 실질적인 공격 없음\n참고 자료 주요 명세 NTCP2 명세 - 공식 I2P 명세 문서 Proposal 111 - 설계 근거를 담은 원래 설계 문서 Noise Protocol Framework (노이즈 프로토콜 프레임워크) - 리비전 33 (2017-10-04) 암호화 표준 RFC 7748 - 보안용 타원 곡선 (X25519) RFC 7539 - IETF 프로토콜용 ChaCha20 및 Poly1305 RFC 8439 - ChaCha20-Poly1305 (RFC 7539를 대체함) RFC 2104 - HMAC: 메시지 인증을 위한 키 기반 해시 SipHash - 해시 함수 응용을 위한 SipHash-2-4 관련 I2P 명세 I2NP 사양 - I2P 네트워크 프로토콜 메시지 형식 공통 구조체 - RouterInfo, RouterAddress 형식 SSU 전송 - UDP 전송(원래 버전, 현재는 SSU2) 제안 147 - 전송 네트워크 ID 확인(0.9.42) 구현 참고 자료 I2P Java - 참조 구현(Java) i2pd - C++ 구현 I2P 릴리스 노트 - 버전 기록 및 업데이트 역사적 맥락 Station-To-Station Protocol (STS) - Noise 프레임워크의 영감이 된 obfs4 - 플러그형 트랜스포트 (SipHash 길이 난독화의 선례) 구현 지침 필수 요구 사항 규정 준수를 위해:\n완전한 핸드셰이크 구현:\n올바른 KDF(키 파생 함수) 체인을 사용해 세 가지 메시지 모두 지원 모든 AEAD(연관 데이터가 있는 인증된 암호화) 태그를 검증 X25519(ECDH 키 교환) 점이 유효한지 확인 데이터 단계 구현:\nSipHash 길이 난독화 (양방향) 모든 블록 타입: 0 (날짜/시간), 1 (옵션), 2 (RouterInfo), 3 (I2NP), 4 (종료), 254 (패딩) 적절한 nonce(일회용 값) 관리 (분리된 카운터) 보안 기능:\n재생 공격 방지(2*D 동안 임시 키 캐시) 타임스탬프 검증(기본값 ±60초) 메시지 1-2에 무작위 패딩 무작위 타임아웃을 사용하는 AEAD(부가 데이터가 포함된 인증된 암호화) 오류 처리 RouterInfo(라우터 정보를 담는 데이터 구조) 게시:\n정적 키 (\u0026ldquo;s\u0026rdquo;), IV (\u0026ldquo;i\u0026rdquo;, 초기화 벡터) 및 버전 (\u0026ldquo;v\u0026rdquo;)을 게시 정책에 따라 키를 순환 교체 숨겨진 router용 capabilities 필드 (\u0026ldquo;caps\u0026rdquo;) 지원 네트워크 호환성:\n네트워크 ID 필드 지원(현재 메인넷에서는 2) 기존 Java 및 i2pd 구현과 상호 운용 IPv4와 IPv6 모두 지원 권장 사항 성능 최적화:\n버퍼링 전략:\n전체 메시지를 한 번에 플러시 (메시지 1, 2, 3) 핸드셰이크 메시지에는 TCP_NODELAY 사용 여러 데이터 블록을 단일 프레임으로 버퍼링 프레임 크기를 몇 KB로 제한 (수신 측 지연시간 최소화) 연결 관리:\n가능한 경우 연결을 재사용하세요 연결 풀링을 구현하세요 연결 상태를 모니터링하세요 (DateTime blocks) 메모리 관리:\n사용 후 민감 데이터를 0으로 덮어쓰기(임시 키, DH 결과) 동시 핸드셰이크 제한(DoS(서비스 거부) 방지) 빈번한 할당에는 메모리 풀 사용 보안 강화:\n프로빙 저항성:\n무작위 타임아웃: 100-500ms 무작위 바이트 읽기: 1KB-64KB 반복적인 실패 시 IP 블랙리스트 추가 피어에게 오류 세부 정보를 제공하지 않음 리소스 제한:\nIP당 최대 연결 수: 3-10 대기 중인 핸드셰이크 최대 수: 100-1000 읽기 타임아웃: 작업당 30-60초 전체 연결 타임아웃: 핸드셰이크 완료까지 5분 키 관리:\n정적 키와 IV(초기화 벡터)의 영구 저장 보안 난수 생성(암호학적 난수 생성기) 키 로테이션 정책 엄수 임시 키 절대 재사용 금지 모니터링 및 진단:\n지표:\n핸드셰이크 성공/실패 비율 AEAD(Authenticated Encryption with Associated Data, 인증된 연계 데이터 암호화) 오류율 시계 오차 분포 연결 지속 시간 통계 로깅:\n이유 코드와 함께 핸드셰이크 실패를 로그에 기록 clock skew(시계 오차) 이벤트를 로그에 기록 차단된 IP 주소를 로그에 기록 민감한 키 재료는 절대로 로그에 기록하지 말 것 테스트:\nKDF(키 파생 함수) 체인에 대한 단위 테스트 다른 구현과의 통합 테스트 패킷 처리용 퍼징 DoS(서비스 거부) 내성에 대한 부하 테스트 자주 하는 실수 피해야 할 치명적인 오류:\nNonce(일회용 난수 값) 재사용:\n세션 중간에 nonce 카운터를 절대 초기화하지 말 것 송신/수신 각각에 대해 별도의 카운터를 사용할 것 2^64 - 1에 도달하기 전에 세션을 종료할 것 키 로테이션:\nrouter가 실행 중일 때는 키를 절대 교체(로테이션)하지 마십시오 세션 간에 임시 키를 절대 재사용하지 마십시오 최소 다운타임 규칙을 준수하십시오 타임스탬프 처리:\n만료된 타임스탬프는 절대 허용하지 않는다 편차를 계산할 때는 항상 RTT(왕복 지연 시간)를 보정한다 DateTime 타임스탬프는 초 단위로 반올림한다 AEAD(연관 데이터가 있는 인증된 암호화) 오류:\n공격자에게 오류 유형을 절대 공개하지 말 것 닫기 전에 항상 무작위 타임아웃을 사용할 것 잘못된 길이는 AEAD 실패와 동일하게 처리할 것 패딩:\n합의된 범위를 벗어난 패딩은 절대 전송하지 않는다 패딩 블록은 항상 마지막에 배치한다 프레임당 여러 개의 패딩 블록을 절대 포함하지 않는다 RouterInfo:\n항상 정적 키가 RouterInfo와 일치하는지 확인하세요 공개된 주소가 없는 RouterInfos는 절대 flood(대량 전파)하지 마세요 항상 서명을 검증하세요 테스트 방법론 단위 테스트:\n암호학 기본 구성 요소:\nX25519, ChaCha20, Poly1305, SHA-256용 테스트 벡터 HMAC-SHA256 테스트 벡터 SipHash-2-4 테스트 벡터 KDF 체인:\n세 가지 메시지 모두에 대한 정답(known-answer) 테스트 체이닝 키 전파 검증 SipHash IV 생성 테스트 메시지 파싱:\n유효한 메시지 디코딩 잘못된 메시지 거부 경계 조건(빈 입력, 최대 크기) 통합 테스트:\n핸드셰이크:\n3-메시지 교환 성공 시계 오차 거부 리플레이 공격 감지 유효하지 않은 키 거부 데이터 단계:\nI2NP 메시지 전송 RouterInfo(router 정보) 교환 패딩 처리 종료 메시지 상호운용성:\nJava I2P와의 상호운용성 테스트 i2pd와의 상호운용성 테스트 IPv4 및 IPv6 테스트 공개된 및 숨겨진 router 테스트 보안 테스트:\n네거티브 테스트:\n유효하지 않은 AEAD 태그 리플레이된 메시지 Clock skew(시계 오차) 공격 비정상 형식의 프레임 DoS 테스트:\n연결 플러딩 Slowloris 공격(느린 전송으로 연결을 붙잡아 두는 기법) CPU 고갈(과도한 DH(디피-헬만) 연산) 메모리 고갈 퍼징:\n무작위 핸드셰이크 메시지 무작위 데이터 단계 프레임 무작위 블록 유형과 크기 유효하지 않은 암호학적 값 NTCP에서의 마이그레이션 레거시 NTCP 지원(현재 제거됨):\nI2P 0.9.50 (2021년 5월)에서 NTCP (버전 1, I2P 전송 프로토콜)가 제거되었습니다. 현재 모든 구현체는 NTCP2를 지원해야 합니다. 역사적 참고 사항:\n전환 기간(2018-2021):\n0.9.36: NTCP2 도입(기본적으로 비활성화) 0.9.37: NTCP2 기본적으로 활성화 0.9.40: NTCP 사용 중단 0.9.50: NTCP 제거 버전 감지:\n\u0026ldquo;NTCP\u0026rdquo; transportStyle는 두 버전을 모두 지원함을 나타냄 \u0026ldquo;NTCP2\u0026rdquo; transportStyle는 NTCP2만 지원함을 나타냄 메시지 크기를 통해 자동 감지(287 대 288 바이트) 현재 상태:\n모든 routers는 NTCP2를 지원해야 합니다 \u0026ldquo;NTCP\u0026rdquo; transportStyle(전송 스타일)은 더 이상 사용되지 않습니다 \u0026ldquo;NTCP2\u0026rdquo; transportStyle만 사용하십시오 부록 A: Noise XK Pattern(Noise 프로토콜의 XK 패턴) 표준 Noise XK Pattern(Noise 프로토콜 프레임워크의 XK 패턴):\nXK(s, rs): \u0026lt;- s ... -\u0026gt; e, es \u0026lt;- e, ee -\u0026gt; s, se 해석:\n\u0026lt;- : 응답자(Bob)에서 개시자(Alice)로의 메시지 -\u0026gt; : 개시자(Alice)에서 응답자(Bob)로의 메시지 s : 정적 키(장기 식별 키) rs : 원격 정적 키(피어의 정적 키, 사전에 알고 있음) e : 임시 키(세션별, 필요 시 생성) es : 임시-정적 DH (Alice 임시 × Bob 정적) ee : 임시-임시 DH (Alice 임시 × Bob 임시) se : 정적-임시 DH (Alice 정적 × Bob 임시) 키 합의 절차:\n사전 메시지: Alice는 Bob의 정적 공개키를 알고 있음(RouterInfo에서) 메시지 1: Alice는 임시 키를 전송하고 es DH를 수행 메시지 2: Bob은 임시 키를 전송하고 ee DH를 수행 메시지 3: Alice는 정적 키를 공개하고 se DH를 수행 보안 속성:\nAlice 인증됨: 예 (메시지 3에 의해) Bob 인증됨: 예 (정적 개인 키를 보유함으로써) 전방향 기밀성: 예 (임시 키가 파기됨) KCI 저항성(키 손상 가장 공격에 대한 저항성): 예 (인증 수준 2) 부록 B: Base64 인코딩 I2P Base64 알파벳:\nABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-~ 표준 Base64와의 차이점: - 문자 62-63: +/ 대신 -~ - 패딩: 동일함 (=) 또는 문맥에 따라 생략\nNTCP2에서의 사용: - 정적 키 (\u0026ldquo;s\u0026rdquo;): 32바이트 → 44문자 (패딩 없음) - IV (\u0026ldquo;i\u0026rdquo;): 16바이트 → 24문자 (패딩 없음)\n인코딩 예시:\n# 32-byte static key (hex): # f4489e1bb0597b39ca6cbf5ad9f5f1f09043e02d96cb9aa6a63742b3462429aa # I2P Base64 encoded: # 9EjeG7BZeznKbL9a2fXx8JBDPgLZbLmKbqY3QrNGJCo= 부록 C: 패킷 캡처 분석 NTCP2 트래픽 식별:\nTCP 핸드셰이크:\n표준 TCP SYN, SYN-ACK, ACK 목적지 포트는 보통 8887 또는 비슷한 포트 메시지 1 (SessionRequest):\nAlice가 보낸 첫 애플리케이션 데이터 80-65535 바이트 (일반적으로 수백 바이트) 무작위처럼 보임 (AES로 암호화된 임시 키) \u0026ldquo;NTCP\u0026rdquo; 주소에 연결하는 경우 최대 287 바이트 메시지 2 (SessionCreated):\nBob의 응답 80-65535바이트(일반적으로 수백 바이트) 또한 무작위로 보입니다 메시지 3 (SessionConfirmed(세션 확인)):\nAlice로부터 48바이트 + 가변 길이(RouterInfo(router 정보 구조체) 크기 + 패딩) 보통 1~4 KB 데이터 단계:\n가변 길이 프레임 길이 필드 난독화(무작위처럼 보임) 암호화된 페이로드 패딩으로 인해 크기를 예측할 수 없음 DPI(딥 패킷 검사) 우회: - 평문 헤더 없음 - 고정된 패턴 없음 - 길이 필드 난독화 - 무작위 패딩으로 크기 기반 휴리스틱 무력화\nNTCP와의 비교: - NTCP 메시지 1은 항상 288바이트(식별 가능) - NTCP2 메시지 1의 크기는 가변적임(식별 불가) - NTCP에는 식별 가능한 패턴이 있었음 - NTCP2는 DPI(딥 패킷 검사)에 저항하도록 설계됨\n부록 D: 버전 이력 주요 이정표:\n0.9.36 (2018년 8월 23일): NTCP2 도입, 기본값으로 비활성화 0.9.37 (2018년 10월 4일): NTCP2 기본값으로 활성화 0.9.40 (2019년 5월 20일): NTCP 사용 중단 0.9.42 (2019년 8월 27일): 네트워크 ID 필드 추가(제안 147) 0.9.50 (2021년 5월 17일): NTCP 제거, capabilities 지원 추가 2.10.0 (2025년 9월 9일): 최신 안정 버전 프로토콜 안정성: - 0.9.50 이후 호환성 파괴 변경 없음 - 프로빙(probing, 서비스 탐지 시도)에 대한 저항성 지속 개선 - 성능과 신뢰성에 집중 - 양자 이후 암호(Post-quantum cryptography) 개발 중 (기본값으로는 비활성화)\n현재 전송 프로토콜 상태: - NTCP2: 필수 TCP 전송 프로토콜 - SSU2: 필수 UDP 전송 프로토콜 - NTCP (v1): 제거됨 - SSU (v1): 제거됨\n","description":"router 간 링크를 위한 Noise(프로토콜 프레임워크) 기반 TCP 전송","id":"4882afdd530d8c7e8da14bb97487aecc","section":"docs","title":"NTCP2 전송","url":"/ko/docs/specs/ntcp2/"},{"categories":null,"content":"개요 이 문서는 블라인드할 수 있는 Destination(목적지)을 생성하기에 적합한 re-randomizable signature scheme(재랜덤화 가능한 서명 스킴)을 명세한다. 또한 기존 Ed25519 Destination을 블라인드하는 데에도 사용할 수 있으나, 효율성이 소폭 저하된다.\nRed25519는 0.9.39 버전(2019년 3월 21일 출시)부터 I2P routers에서 완전 지원됩니다. 17개월간의 실운영 배포를 거친 뒤, 본 사양은 0.9.47 버전(2020년 8월)에서 최종 확정되었습니다. 이 서명 스킴은 I2P 네트워크에서 서명 유형 11(RedDSA_SHA512_Ed25519)로 동작합니다.\n동기 Proposal 123 (New netDB Entries)는 Principle of Least Authority(최소 권한 원칙)를 구현한 암호화된 LeaseSet2 형식을 정의한다: 각 네트워크 참여자는 자신의 역할에 필요한 정보만 제공받는다. 특히, floodfill에 게시된 암호화된 LeaseSet2는 대상 Destination을 드러내지 않으며, Leases는 해당 Destination에 대한 사전 지식을 가진 사람만 열람할 수 있다. 그러나 floodfill은 여전히 게시 시 암호화된 LeaseSet2를 인증할 수 있어야 하고, 클라이언트는 추가로 그 인증이 Destination 자체에 의해 강제되었음을 보장해야 한다.\n제안 123은 Destination(목적지 식별자)의 서명 키를 블라인딩함으로써 이를 달성한다. 블라인딩된 키는 floodfill에 의해 검증 가능한 서명을 생성하는 데 사용할 수 있으며, 클라이언트는 오직 해당 Destination만이 그 서명을 생성했음을 확신할 수 있다. 따라서 블라인딩에 사용할 수 있는 서명 스킴을 명시할 필요가 있다.\nProposal 123 상태 안내: Proposal 123의 일부는 0.9.38 버전부터 순차적으로 구현되어 배포되었으며, 0.9.39에서 Red25519 지원이 추가되었습니다. 암호화된 LeaseSet2 기능은 운영 환경에서 사용할 준비가 되어 있으며, 프라이버시가 강화된 히든 서비스용으로 I2P 네트워크에서 활발히 사용되고 있습니다.\n설계 핵심 서명 체계 여기에서 명시하는 서명 스킴 Red25519는 Zcash 프로토콜 명세서(Sapling 및 이후) 섹션 5.4.6에 정의된 RedDSA의 구현이다. RedDSA는 key re-randomization(키 재무작위화)을 지원하는 슈노르 기반 서명 스킴이다. 다음과 같은 함수가 있다:\nGENERATE_PRIVATE() : 균등한 분포를 따르는 무작위 개인 키를 반환합니다.\nDERIVE_PUBLIC(sk) : 주어진 개인 키에 해당하는 공개 키를 반환합니다.\nGENERATE_RANDOM() : 키 쌍을 재무작위화하는 데 적합한 무작위 스칼라를 반환합니다.\nRANDOMIZE_PRIVATE(sk, alpha) : 비밀 스칼라 alpha를 사용하여 개인 키를 재랜덤화합니다.\nRANDOMIZE_PUBLIC(vk, alpha) : 비밀 스칼라 alpha를 사용하여 공개 키를 재무작위화합니다.\nSIGN(sk, m) : 주어진 메시지 m에 대해 개인 키 sk로 생성한 서명을 반환합니다.\nVERIFY(vk, m, sig) : 공개키 vk와 메시지 m에 대해 서명 sig를 검증합니다. 서명이 유효하면 true를 반환하고, 그렇지 않으면 false를 반환합니다.\n주어진 키 쌍 (sk, vk)에 대해 다음과 같은 관계가 성립한다:\nRANDOMIZE_PUBLIC(vk, alpha) == DERIVE_PUBLIC(RANDOMIZE_PRIVATE(sk, alpha)) Ed25519(타원곡선 전자서명 방식) 키를 Red25519(RedDSA 전자서명 방식)로 변환하기 Ed25519 키는 기존 Ed25519 Destination(목적지)의 재무작위화를 지원하기 위해 일시적인 일방향 변환을 통해 Red25519 키로 변환될 수 있습니다. 다른 서명 유형은 호환되지 않습니다.\n다음과 같은 변환 함수를 정의합니다:\nCONVERT_ED25519_PRIVATE(privkey) : 주어진 Ed25519 개인 키에 해당하는 Red25519 개인 키를 반환합니다.\nCONVERT_ED25519_PUBLIC(pubkey) : 주어진 Ed25519 공개 키에 대응하는 Red25519 공개 키를 반환합니다.\n주어진 Ed25519 키 쌍 (privkey, pubkey)에 대해 다음 관계가 성립한다:\nCONVERT_ED25519_PUBLIC(pubkey) == DERIVE_PUBLIC(CONVERT_ED25519_PRIVATE(privkey)) 명세 정의 B : RFC 8032 에 정의된 Ed25519 기저점.\nL : RFC 8032 에 정의된 대로 Ed25519의 차수 2^252 + 27742317777372353535851937790883648493.\n[s] B : 고정된 기준점에 대해 s를 곱하는 스칼라 곱셈.\n[s] A : A에 s를 곱하는 가변 기준점 스칼라 곱셈.\nx || y : 바이트 배열 x에 y를 이어 붙입니다.\nRed25519(암호학 알고리즘 명칭) 스킴 Red25519는 RedDSA를 다음과 같이 특화한다:\nG := Curve25519의 에드워즈 형태 위의 점들로 이루어진 군. 특히, 이는 Red25519가 차수 L의 소수 부분군을 사용하며, 보수(cofactor) h_G는 8임을 의미한다. P_G := Ed25519 기저점 B. l_H := 512 H(x) := SHA-512(\u0026ldquo;I2P_Red25519H(x)\u0026rdquo; || x) 해시 함수 선택에 대한 참고: Red25519는 Zcash RedDSA에서 사용되는 BLAKE2b-512 대신 SHA-512를 사용합니다. 이러한 설계 선택은 아래에 설명된 length-prefixing(길이 접두어 부여) 보호로 보완됩니다. I2P Proposal 148은 중복 메시지 식별(DMI) 및 길이 확장 공격(LEA)에 대한 보호를 강화하고 성능을 향상하기 위해 향후 BLAKE2b-512로의 마이그레이션을 제안합니다.\nRedDSA는 H(x)가 길이 확장 공격에 대해 안전한 암호학적 해시 함수로 인스턴스화된다고 가정한다. SHA-512는 그 자체로는 이를 만족하지 않는다. 이를 보완하기 위해, 메시지의 길이를 prefix-free encoding(접두사-자유 인코딩)으로 표현한 접두사를 메시지 앞에 붙일 것을 요구한다:\nlen_u16(M) || M 여기서 len_u16(M)은 M의 길이를 2바이트로 표현한 값이며, 리틀 엔디언이다(스칼라와 포인트의 리틀 엔디언 인코딩과 일관성을 유지하기 위해).\n메시지는 65534 바이트를 초과할 수 없습니다. 65535 바이트 길이는 향후 확장을 위해 예약되어 있습니다.\nSecurity Note: 해시 함수에 공개키(vk)를 포함하고 서명 시 80바이트의 난수를 결합함으로써, 초기 RedDSA 설계에서 발견된 SURK-CMA (Strong Unforgeability with Re-randomized Keys under Chosen Message Attack, 선택 메시지 공격 하에서 재랜덤화된 키에 대한 강한 위조불가능성) 취약점으로부터의 보호를 보장합니다. 이 구현에는 NCC Group Zcash 감사(Finding NCC-Zcash2018-009)의 보안 수정 사항이 포함되어 있습니다.\n인코딩과 디코딩 Red25519 개인 키는 L을 법으로 하는 스칼라이며, 리틀 엔디언 표현으로 인코딩됩니다. 스칼라의 바이트 배열 형태와 정수 형태 사이를 상호 변환하기 위해 함수 DECODE_SCALAR와 ENCODE_SCALAR를 정의합니다.\nRed25519 공개키는 Curve25519(타원곡선 이름)의 에드워즈 형태 위의 점이다. 이들은 y좌표의 255비트 리틀 엔디언 표현 뒤에 x좌표의 부호를 나타내는 1비트를 이어붙인 방식으로 인코딩된다. 이는 Ed25519(서명 알고리즘 이름)와 동일한 인코딩이다. 점의 바이트 배열 형태와 좌표 형태 사이를 상호 변환하기 위해 DECODE_POINT와 ENCODE_POINT 함수를 정의한다.\nRedDSA(랜덤화된 Edwards-곡선 디지털 서명 알고리즘) 함수 구현을 용이하게 하기 위해, 이미 Red25519(레드25519)에 맞게 특화된 RedDSA(레드DSA) 함수들(그리고 몇 가지 보조 함수들)을 아래에 명시적으로 작성한다. 구현자들은 RedDSA 함수들의 일반적인 명세에 대해서는 Zcash Protocol Specification(지캐시 프로토콜 명세서) 섹션 5.4.6을 참조해야 한다.\nHStar(prefix1, prefix2, m) := h = SHA-512() h.input(\u0026#34;I2P_Red25519H(x)\u0026#34;) h.input(prefix1) h.input(prefix2) h.input(len(m) \u0026amp; 0xff) h.input((len(m) \u0026gt;\u0026gt; 8) \u0026amp; 0xff) h.input(m) s = h.digest() return s mod L GENERATE_PRIVATE := s = 64 random bytes return s mod L DERIVE_PUBLIC(sk) := [sk] B GENERATE_RANDOM := s = 64 random bytes return s mod L RANDOMIZE_PRIVATE(sk, alpha) := (sk + alpha) mod L RANDOMIZE_PUBLIC(vk, alpha) := vk + [alpha] B SIGN(sk, m) := T = 80 random bytes vkBytes = ENCODE_POINT(DERIVE_PUBLIC(sk)) r = HStar(T, vkBytes, m) R = [r] B Rbytes = ENCODE_POINT(R) c = HStar(Rbytes, vkBytes, m) S = (r + (c * sk)) mod L return Rbytes || ENCODE_SCALAR(S) VERIFY(vk, m, sig) := Rbytes = sig[0..32] Sbytes = sig[32..64] R = DECODE_POINT(Rbytes) if R is invalid: return false S = DECODE_SCALAR(Sbytes) if S \u0026gt;= L: return false vkBytes = ENCODE_POINT(vk) c = HStar(Rbytes, vkBytes, m) return ((-[S] B) + R + ([c] vk)).multiplyByCofactor().isIdentity() 변환 함수 CONVERT_ED25519_PRIVATE(privkey) := s = SHA-512(privkey)[0..32] s[0] = s[0] \u0026amp; 248 s[31] = (s[31] \u0026amp; 63) | 64 return s CONVERT_ED25519_PUBLIC(pubkey) := pubkey CONVERT_ED25519_PRIVATE의 구현은 Ed25519 개인 키에서 Ed25519 공개 키를 유도할 때 비밀 스칼라 s를 계산하는 것과 동등하며, 이는 RFC 8032 섹션 5.1.5의 1–3단계에 명시되어 있습니다.\n보안상의 영향 Red25519 Destination(I2P 목적지 식별자)를 다시 무작위화한 다음 그것으로 서명을 생성하더라도, 해당 Destination에 관한 어떤 정보도 누설되지 않는다. 이는 RANDOMIZE_PRIVATE를 통해 생성된 Red25519 개인 키의 분포가 GENERATE_PRIVATE를 통해 생성된 개인 키의 분포와 동일하고, DERIVE_PUBLIC이 결정적이기 때문이다.\nCONVERT_ED25519_PRIVATE를 통해 Ed25519(타원곡선 디지털 서명 방식) 개인 키를 Red25519(Ed25519에서 파생된 변환 키 형식)로 변환하면 동일한 분포가 생성되지 않습니다. 그러나 다음과 같은 이유로 보안성 감소는 수용 가능하다고 판단합니다:\nEd25519 스칼라의 공간은 Red25519 스칼라의 공간 크기의 대략 절반이다(가능한 Ed25519 스칼라는 2^251개이고, 가능한 Red25519 스칼라는 L ~= 2^252개이다). 따라서 보안 강도 손실은 많아야 대략 2배, 즉 약 1비트에 불과하다(우연히 Ed25519에도 유효한 Red25519 스칼라를 선택했을 수 있기 때문이다). 기존 Ed25519 목적지는 이미 과거에 네트워크에 노출되었으며, 악의적인 floodfills가 이미 이를 열거했을 것으로 가정해야 한다. 중요: 이 보안 약화가 우려되는 사용자는 Ed25519(서명 유형 7) 대신 자신의 Destinations(I2P의 공개 목적지 식별자)에 대한 sigtype으로 Red25519(서명 유형 11)를 사용해야 합니다.\n위의 논증은 재무작위화 스칼라 alpha에는 적용되지 않는다는 점에 유의하라. 편향된 alpha를 선택할 때마다 키에 관한 정보가 누출되는데, 이는 가법 재무작위화가 원타임 패드처럼 동작하기 때문이다.\n보안 감사 상태 중요한 고지: Red25519(서명 체계)를 포함한 I2P는 정식 제3자 보안 감사를 받은 적이 없습니다. 기반이 되는 RedDSA(서명 설계)는 2018년 Zcash Sapling 프로토콜 감사의 일환으로 NCC Group의 보안 검토를 받았으며, 그 과정에서 보안 문제가 식별되어 수정되었습니다. 그러나 SHA-512(BLAKE2b-512 대신)를 사용한 I2P의 구체적 구현과 I2P 도메인 분리(domain separation)는 독립적으로 분석된 바 없습니다.\nstr4d가 개발한 ed25519-java 참조 구현은 독립적인 제3자 감사를 한 차례 받았으나, 그 감사는 Red25519 구현 이전에 이루어졌고 Ed25519 기능만을 대상으로 했으며 Red25519 확장 기능은 포함하지 않았습니다.\nRed25519(암호학적 서명 방식)을 도입하는 사용자들은 이러한 한계를 이해하고 자신의 위협 모델에 따라 보안상의 절충관계를 평가해야 합니다.\n호환성 Red25519(서명 알고리즘)을 지원하는 I2P 버전(0.9.39 이상)은 그 방식으로 서명된 네트워크 데이터 구조를 검증할 수 있습니다. Red25519을 지원하지 않는 I2P 버전은 이를 알 수 없는 서명으로 간주하며, 데이터 구조를 폐기(MAY)할 수도 있습니다.\n배포 타임라인: - 0.9.39 (2019년 3월): floodfill에서 Encrypted LS2(암호화된 LS2) 지원을 포함한 최초 구현 - 0.9.40 (2019년 5월): Encrypted LS2에 대한 클라이언트별 인가 - 0.9.41 (2019년 8월): 오프라인 키와 함께 사용하는 Meta LS2(메타 LS2) 및 Encrypted LS2 - 0.9.43 (2020년 2월): Encrypted LS2에 대한 b32(base32 주소) 지원 - 0.9.47 (2020년 8월): 사양 최종화 - 2.10.0 (2025년 10월): 현재 네트워크 버전(0.9.67+와 동등)\n초기 구현 이후 네트워크가 6년이 넘는 기간 동안 업그레이드를 진행해 온 만큼, Encrypted LeaseSet2 사용 사례에서는 Red25519(서명 방식)로 서명된 데이터 구조의 신뢰성이 충분히 좋을 것으로 사용자는 기대할 수 있습니다. 그러나 일반적인 Destination(I2P 목적지) 사용에 대한 채택 지표는 공개되어 있지 않습니다.\n주요 사용 사례: Red25519는 key blinding(키 블라인딩: 공개키를 눈가림하여 연관성을 숨기는 기법)이 필요한 암호화된 LeaseSet2 기능에 주로 사용됩니다. 암호화된 leaseset 요구사항이 없는 표준 목적지의 경우, 더 넓은 호환성과 더 오래 검증된 이력 때문에 Ed25519(서명 유형 7)가 여전히 권장되는 선택입니다.\n구현 참고 사항 Red25519는 I2P Java router의 net.i2p.crypto.eddsa.RedDSAEngine에 구현되어 있으며, str4d(Jack Grigg)이 만든 ed25519-java 라이브러리를 Maven 의존성 net.i2p.crypto:eddsa(버전 0.1.0부터 0.3.0까지)로 사용합니다.\ni2pd C++ 구현은 암호화된 LeaseSet 게시를 위해 Red25519(서명 알고리즘의 한 종류) (signaturetype=11)도 지원합니다.\ni2pd용 구성 예제:\nsignaturetype=11 i2cp.leaseSetType=5 Encrypted LeaseSet2 호환성: Encrypted LeaseSet 명세에 따르면 블라인드가 해제된 destination(목적지 식별자)의 서명 공개키는 Ed25519(서명 유형 7) 또는 Red25519(서명 유형 11)여야 합니다. 암호화된 LeaseSet 기능에는 이외의 서명 유형은 지원되지 않습니다.\n테스트 벡터 다음 테스트 벡터는 구현 검증을 위해 제공됩니다. 각 벡터에는 다음이 포함됩니다:\nedsk: Ed25519 개인 키(무작위) edpk: edsk에 대응하는 Ed25519 공개 키 sk: CONVERT_ED25519_PRIVATE(edsk) vk: CONVERT_ED25519_PUBLIC(edpk) msg: 서명할 메시지 sig: SIGN(sk, msg) alpha: GENERATE_RANDOM() rsk: RANDOMIZE_PRIVATE(sk, alpha) rvk: RANDOMIZE_PUBLIC(vk, alpha) rsig: SIGN(rsk, msg) 구현 참고: 이 테스트 벡터는 지속적인 검증을 위해 자동화된 단위 테스트 스위트에 통합되어야 합니다. 구현자는 모든 변환, 서명, 그리고 re-randomization(재무작위화) 작업이 이러한 기대값과 일치하는지 확인해야 합니다.\n테스트 벡터 1 edsk: 0101010101010101010101010101010101010101010101010101010101010101 edpk: 8a88e3dd7409f195fd52db2d3cba5d72ca6709bf1d94121bf3748801b40f6f5c sk: 58e86efb75fa4e2c410f46e16de9f6acae1a1703528651b69bc176c088bef36e vk: 8a88e3dd7409f195fd52db2d3cba5d72ca6709bf1d94121bf3748801b40f6f5c msg: 0202020202020202020202020202020202020202020202020202020202020202 sig: 61f5527f4d3b46de4b2c234390370bf715ae9098907a0d191ba1b44b23a8ac1a 6a40437a5294e9503faaf9bd2b7f2fe7ba44dec487b3185aba7ff7d7a17cd40f alpha: ae9ba9cbbc047c442448fca7c9f4e288a202ed520bfad0c784b792b7773cee08 rsk: 8bb85f3c7a494a08890d7d142109c1a3501d04565d80227e2079097800fbe107 rvk: 6fe128737b8e76fa66698a748b0dc0a89168dd8a0601c2b1c0b26835d323e9b3 rsig: 533053074d3b44f08723aab988ede9880a001b7a684d4a98f2d1b88fabee07a5 b5c9430c69a690321e0cb8365d7aeb6688bcbad2c0780e0c69e8a1b4a45f3001 테스트 벡터 2 edsk: 0202020202020202020202020202020202020202020202020202020202020202 edpk: 8139770ea87d175f56a35466c34c7ecccb8d8a91b4ee37a25df60f5b8fc9b394 sk: a83c626bc9c38c8c201878ebb1d5b0b50ac40e8986c78793db1d4ef369fca14e vk: 8139770ea87d175f56a35466c34c7ecccb8d8a91b4ee37a25df60f5b8fc9b394 msg: 0303030303030303030303030303030303030303030303030303030303030303 sig: 0829e58eb5399870f009bd1f0270264e556424bda7a93fbcec99f6d9d75db46d 5c3cb546d9947ca7c1200876c8775a90c357a2aef3d2f16388242ee1914b1a0a alpha: 98b615d9027e996cc2796c019d9c8beb46aa7d2b6eea2e5d98eb29eb1584c203 rsk: 9fcfaa734852ca40b3810ebef590e138516e8cb4f4b1b6f0730978de7f806402 rvk: 527e121090158419609e4a0d8de6f7d3271b353a8cd0b8172fe41468ea1e9177 rsig: 9a6961f35ed264a946cd6214b2326a6e6caa426c2a61bc14367fd278e0b5fb51 3ac065a69210a457f17d12ba8a496cfd835002691affa8efcdecae48135c090f 참고: 추가 테스트 벡터 3-10은 동일한 형식을 따르며 레퍼런스 구현에서 확인할 수 있습니다.\n참고자료 제안 123: 새로운 netDB 항목 - 일부는 0.9.38, 0.9.39 및 이후 릴리스에 구현되어 배포됨 Zcash 프로토콜 명세, 5.4.6절: RedDSA(디지털 서명 체계), RedJubjub, 및 RedPallas - RedDSA는 Zcash 프로토콜 명세의 일부로 정의됨; NCC Group에서 보안 감사(2019년 1월) RFC 8032: 에드워즈 곡선 디지털 서명 알고리즘 (EdDSA) 제안 148: RedDSA-BLAKE2b-Ed25519 - 제안되었으나 아직 구현되지 않음; 향후 BLAKE2b-512로의 마이그레이션을 제안 암호화된 LeaseSet 명세 저수준 암호화 명세 ","description":"블라인딩된 Destination(목적지) 생성을 위한 재랜덤화 가능한 서명 스킴","id":"31b087e2977ad9f01f6b3b93e6af1f20","section":"docs","title":"Red25519 서명 스킴","url":"/ko/docs/specs/red25519-signature-scheme/"},{"categories":null,"content":"Reseed 호스트(초기 부트스트랩 서버) 소개 새로운 router가 I2P 네트워크에 참여하려면 소수의 피어가 필요합니다. reseed(초기 피어 확보) 호스트는 암호화된 HTTPS 다운로드를 통해 그 초기 부트스트랩 세트를 제공합니다. 각 reseed 번들은 호스트가 서명하여 인증되지 않은 주체의 변조를 방지합니다. 안정적으로 동작하는 router도 피어 집합이 오래되어 활성도가 떨어지면 가끔 reseed할 수 있습니다.\n네트워크 부트스트랩 절차 처음으로 I2P router를 시작하거나 오랜 기간 오프라인이었던 경우, 네트워크에 연결하려면 RouterInfo(라우터 정보) 데이터가 필요합니다. router에는 기존 피어가 없기 때문에, I2P 네트워크 내부만으로는 이 정보를 얻을 수 없습니다. reseed mechanism(재시드 메커니즘: 초기 부트스트랩 절차)은 신뢰할 수 있는 외부 HTTPS 서버에서 제공되는 RouterInfo 파일을 통해 이러한 부트스트랩 문제를 해결합니다.\nreseed(초기 부트스트랩) 과정은 암호학적으로 서명된 단일 번들로 75-100개의 RouterInfo 파일을 전달한다. 이는 새로운 routers가 별개의 신뢰할 수 없는 네트워크 파티션으로 고립시킬 수 있는 중간자 공격에 노출되지 않으면서 신속하게 연결을 설정할 수 있도록 보장한다.\n현재 네트워크 상태 2025년 10월 기준, I2P 네트워크는 router 버전 2.10.0(API 버전 0.9.67)으로 운영된다. 버전 0.9.14에서 도입된 reseed protocol(초기 부트스트랩 프로토콜)은 안정적이며 핵심 기능에는 변화가 없다. 네트워크는 가용성과 검열 저항성을 보장하기 위해 전 세계에 분산된 다수의 독립적인 reseed 서버를 유지한다.\n서비스 checki2p 는 모든 I2P reseed 서버(초기 부트스트랩을 위한 router 정보 배포 서버)를 4시간마다 모니터링하며, reseed 인프라의 실시간 상태 점검과 가용성 지표를 제공합니다.\nSU3 파일 형식 사양 SU3 파일 형식은 암호학적으로 서명된 콘텐츠 배포를 제공하는 I2P의 reseed(네트워크 부트스트랩) 프로토콜의 기반입니다. 이 형식을 이해하는 것은 reseed 서버와 클라이언트를 구현하는 데 필수적입니다.\n파일 구조 SU3 형식은 세 가지 주요 구성 요소로 이루어져 있습니다: 헤더(40바이트 이상), 콘텐츠(가변 길이), 서명(헤더에서 지정된 길이).\n헤더 형식(바이트 0-39 최소) Byte Range Field Description 0-5Magic NumberASCII string \"I2Psu3\" (0x493250737533) 6ReservedUnused, must be 0x00 7File Format VersionCurrent version: 0x00 8-9Signature TypeBig-endian 16-bit integer. Type 6 = RSA-4096-SHA512 (reseed standard) 10-11Signature LengthBig-endian 16-bit integer. 512 bytes (0x0200) for RSA-4096 12ReservedUnused, must be 0x00 13Version LengthMinimum 16 bytes (0x10) for compatibility 14ReservedUnused, must be 0x00 15Signer ID LengthLength of UTF-8 signer identifier string 16-23Content LengthBig-endian 64-bit integer, length of content in bytes 24ReservedUnused, must be 0x00 25File Type0x00 = ZIP, 0x01 = XML, 0x02 = HTML, 0x03 = XML.GZ, 0x04 = TXT.GZ, 0x05 = DMG, 0x06 = EXE 26ReservedUnused, must be 0x00 27Content Type0x00 = unknown, 0x01 = router update, 0x02 = plugin, 0x03 = reseed, 0x04 = news, 0x05 = blocklist 28-39PaddingUnused, must be all zeros 40-55Version StringASCII version string, padded with zeros (minimum 16 bytes) 56-...Signer IDUTF-8 encoded signer identifier (e.g., \"user@mail.i2p\") ### Reseed(리시드: I2P 네트워크 부트스트랩 서버) 전용 SU3 매개변수 reseed bundles(초기 부트스트랩용 피어 목록 묶음)의 경우, SU3 파일은 다음 요건을 충족해야 합니다:\n파일 이름: 반드시 정확히 i2pseeds.su3여야 합니다 콘텐츠 유형 (바이트 27): 0x03 (RESEED) 파일 유형 (바이트 25): 0x00 (ZIP) 서명 유형 (바이트 8-9): 0x0006 (RSA-4096-SHA512) 버전 문자열: ASCII의 Unix timestamp (epoch(에포크) 이후의 초, date +%s 형식) 서명자 ID: X.509 인증서의 CN(공통 이름)과 일치하는 이메일 형태의 식별자 네트워크 ID 쿼리 매개변수 버전 0.9.42부터 routers는 reseed 요청(초기 부트스트랩용 피어 목록을 받아오는 요청)에 ?netid=2를 덧붙입니다. 이는 테스트 네트워크가 서로 다른 네트워크 ID를 사용하므로 교차 네트워크 연결을 방지합니다. 현재 I2P 운영 네트워크는 네트워크 ID 2를 사용합니다.\n예시 요청: https://reseed.example.com/i2pseeds.su3?netid=2\nZIP 콘텐츠 구조 콘텐츠 섹션(헤더 이후, 서명 이전)은 다음 요구 사항을 충족하는 표준 ZIP 아카이브를 포함합니다:\n압축: 표준 ZIP 압축(DEFLATE) 파일 개수: 보통 RouterInfo 파일 75~100개 디렉터리 구조: 모든 파일은 최상위 경로에 있어야 합니다(하위 디렉터리 없음) 파일 이름: routerInfo-{44-character-base64-hash}.dat Base64 알파벳: I2P의 수정된 base64 알파벳을 사용해야 합니다 I2P base64 알파벳은 표준 base64와 달리 파일 시스템 및 URL 호환성을 보장하기 위해 +와 / 대신 -와 ~를 사용합니다.\n암호학적 서명 서명은 바이트 0부터 콘텐츠 섹션의 끝까지 파일 전체를 대상으로 합니다. 서명 자체는 콘텐츠 뒤에 덧붙여집니다.\n서명 알고리즘 (RSA-4096-SHA512) 바이트 0부터 콘텐츠 끝까지의 SHA-512 해시를 계산합니다 \u0026ldquo;raw\u0026rdquo; RSA를 사용하여 해시에 서명합니다(Java 용어로는 NONEwithRSA) 필요한 경우 선행 0으로 서명을 패딩하여 512바이트가 되도록 합니다 512바이트 서명을 파일 끝에 추가합니다 서명 검증 프로세스 클라이언트는 다음을 수행해야 합니다:\n서명 유형과 길이를 판별하기 위해 바이트 0–11을 읽는다 콘텐츠의 경계를 찾기 위해 전체 헤더를 읽는다 SHA-512 해시를 계산하는 동안 콘텐츠를 스트리밍한다 파일 끝에서 서명을 추출한다 서명자의 RSA-4096 공개 키를 사용하여 서명을 검증한다 서명 검증이 실패하면 파일을 거부한다 인증서 신뢰 모델 Reseed(초기 부트스트랩) 서명자 키는 RSA-4096 키를 사용하는 자체 서명된 X.509 인증서로 배포됩니다. 이러한 인증서는 I2P router 패키지의 certificates/reseed/ 디렉터리에 포함되어 있습니다.\n인증서 형식: - 키 유형: RSA-4096 - 서명: 자체 서명 - Subject CN (공통 이름): SU3 헤더의 Signer ID(서명자 ID)와 일치해야 합니다 - 유효 기간: 클라이언트는 인증서의 유효 기간을 강제해야 합니다\nReseed(네트워크 부트스트랩 서버) 호스트 운영 reseed 서비스(신규 참여 routers의 부트스트랩을 돕는 서비스)를 운영하려면 보안, 신뢰성, 그리고 네트워크 다양성 요구사항에 세심한 주의를 기울여야 합니다. 더 많은 독립적인 reseed 호스트는 복원력을 높이고, 공격자나 검열자가 새로운 routers의 참여를 차단하기 더 어렵게 만듭니다.\n기술 요구 사항 서버 사양 운영 체제: Unix/Linux (Ubuntu, Debian, FreeBSD는 테스트 완료 및 권장) 네트워크 연결: 정적 IPv4 주소 필수, IPv6 권장(선택 사항) CPU: 최소 2코어 RAM: 최소 2GB 대역폭: 월 약 15GB 트래픽 가동 시간: 24/7 운영 필수 I2P Router: 시스템에 잘 통합되어 상시 실행되는 I2P router 소프트웨어 요구 사항 Java: JDK 8 이상 (I2P 2.11.0부터는 Java 17+가 필요함) 웹 서버: 리버스 프록시 지원을 갖춘 nginx 또는 Apache (X-Forwarded-For 헤더의 제한으로 인해 Lighttpd는 더 이상 지원되지 않음) TLS/SSL: 유효한 TLS 인증서 (Let\u0026rsquo;s Encrypt, 자체 서명 인증서, 또는 상용 CA) DDoS 보호: fail2ban 또는 동등한 도구 (필수, 선택 사항 아님) Reseed Tools: https://i2pgit.org/idk/reseed-tools 의 공식 reseed-tools(네트워크 부트스트랩용 도구) 보안 요구사항 HTTPS/TLS 구성 프로토콜: HTTPS만, HTTP 폴백(fallback) 없음 TLS 버전: 최소 TLS 1.2 암호 스위트: Java 8+와 호환되는 강력한 암호 스위트를 지원해야 함 인증서 CN/SAN: 제공되는 URL 호스트명과 일치해야 함 (CN/SAN은 인증서의 Common Name과 Subject Alternative Name을 의미) 인증서 유형: 개발팀과 협의된 경우 self-signed(자체 서명) 가능, 또는 인정된 CA(인증 기관)가 발급한 인증서 인증서 관리 SU3 서명 인증서와 TLS 인증서는 서로 다른 목적을 수행한다:\nTLS 인증서 (certificates/ssl/): HTTPS 통신을 보호합니다 SU3 서명 인증서 (certificates/reseed/): reseed 번들(I2P 네트워크 초기화용 번들)에 서명합니다 두 인증서는 router 패키지에 포함되도록 reseed coordinator(리시드 담당자)(zzz@mail.i2p )에게 제출되어야 합니다.\nDDoS 및 스크레이핑 보호 Reseed servers(네트워크 초기 부트스트랩용 서버)는 버그가 있는 구현, 봇넷, 그리고 네트워크 데이터베이스를 스크래핑하려는 악의적 행위자들로부터 주기적인 공격에 직면합니다. 보호 조치는 다음과 같습니다:\nfail2ban: 요청 속도 제한과 공격 완화를 위해 필수 Bundle 다양성: 서로 다른 요청자에게 서로 다른 RouterInfo(라우터 정보) 집합을 제공 Bundle 일관성: 구성 가능한 시간 창 내에서 동일 IP의 반복 요청에는 동일한 번들을 제공 IP 로깅 제한: 로그나 IP 주소를 공개하지 말 것(개인정보 보호정책 요구사항) 구현 방법 방법 1: 공식 reseed-tools (권장) I2P 프로젝트에서 관리하는 공식 구현입니다. 저장소: https://i2pgit.org/idk/reseed-tools 설치:\n# Install dependencies sudo apt-get install golang git # Clone repository git clone https://i2pgit.org/idk/reseed-tools.git cd reseed-tools # Build make # Generate keys and start server (first run) ./reseed-tools reseed \\ --signer=your-email@mail.i2p \\ --netdb=/path/to/i2p/netDb \\ --tlsHost=your-domain.tld \\ --port=8443 첫 실행 시, 도구는 다음을 생성합니다: - your-email@mail.i2p.crt (SU3 서명용 인증서) - your-email@mail.i2p.pem (SU3 서명용 개인 키) - your-email@mail.i2p.crl (인증서 폐지 목록) - TLS 인증서 및 키 파일\n기능: - 자동 SU3 번들 생성(350가지 변형, 각 변형당 RouterInfos 77개) - 내장 HTTPS 서버 - cron을 통해 9시간마다 캐시 재빌드 - --trustProxy 플래그와 함께 X-Forwarded-For 헤더 지원 - 리버스 프록시 구성과 호환\n운영 환경 배포:\n# Create systemd service cat \u0026gt; /etc/systemd/system/i2p-reseed.service \u0026lt;\u0026lt; EOF [Unit] Description=I2P Reseed Server After=network.target [Service] Type=simple User=i2p-reseed WorkingDirectory=/opt/i2p-reseed ExecStart=/opt/i2p-reseed/reseed-tools reseed \\ --signer=your-email@mail.i2p \\ --netdb=/var/lib/i2p/netDb \\ --port=8443 \\ --ip=127.0.0.1 \\ --trustProxy Restart=always [Install] WantedBy=multi-user.target EOF systemctl enable i2p-reseed systemctl start i2p-reseed 방법 2: Python 구현 (pyseeder) PurpleI2P 프로젝트의 대체 구현: https://github.com/PurpleI2P/pyseeder pip install pyseeder # Generate SU3 file echo \u0026#34;your_password\u0026#34; | pyseeder reseed \\ --netdb /path/to/netDb \\ --private-key priv_key.pem \\ --outfile i2pseeds.su3 \\ --signer-id user@mail.i2p # Serve via built-in server pyseeder serve \\ --port 8443 \\ --host 0.0.0.0 \\ --private-key priv_key.pem \\ --cert user_at_mail.i2p.crt \\ --file i2pseeds.su3 방법 3: Docker 배포 컨테이너화된 환경에서는 Docker에 바로 사용할 수 있는 구현이 여러 가지 있습니다:\nDivaExchange i2p-reseed: https://github.com/diva-exchange/i2p-reseed RTradeLtd/i2p-tools-1: Tor 오니온 서비스 및 IPFS 지원을 추가 역방향 프록시 구성 nginx 설정 upstream i2p_reseed { server 127.0.0.1:8443; } server { listen 443 ssl http2; server_name reseed.example.com; ssl_certificate /path/to/tls-cert.crt; ssl_certificate_key /path/to/tls-key.key; ssl_protocols TLSv1.2 TLSv1.3; ssl_ciphers HIGH:!aNULL:!MD5; location / { proxy_pass http://i2p_reseed; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $remote_addr; proxy_set_header Host $host; } } Apache 설정 \u0026lt;VirtualHost *:443\u0026gt; ServerName reseed.example.com SSLEngine on SSLCertificateFile /path/to/tls-cert.crt SSLCertificateKeyFile /path/to/tls-key.key SSLProtocol all -SSLv2 -SSLv3 -TLSv1 -TLSv1.1 ProxyRequests Off \u0026lt;Proxy *\u0026gt; Order deny,allow Allow from all \u0026lt;/Proxy\u0026gt; ProxyPass / http://127.0.0.1:8443/ ProxyPassReverse / http://127.0.0.1:8443/ \u0026lt;/VirtualHost\u0026gt; 등록 및 조정 공식 I2P 패키지에 귀하의 reseed 서버(초기 부트스트랩용 서버)를 포함하려면:\n설정 및 테스트를 완료하세요 두 인증서(SU3 signing 및 TLS)를 reseed coordinator(리시드 조정자)에게 보내세요 연락처: zzz@mail.i2p 또는 zzz@i2pmail.org 다른 운영자들과의 조정을 위해 IRC2P의 #i2p-dev에 참여하세요 운영 모범 사례 모니터링 및 로깅 통계를 위해 Apache/nginx의 combined 로그 형식을 활성화하세요 로그 로테이션을 설정하세요(로그가 빠르게 증가합니다) 번들 생성 성공 여부와 재빌드 소요 시간을 모니터링하세요 대역폭 사용량과 요청 패턴을 추적하세요 IP 주소나 상세 접속 로그를 절대 공개하지 마세요 유지보수 일정 9시간마다: SU3 번들 캐시 재생성 (cron으로 자동화) 매주: 로그를 검토하여 공격 패턴 식별 매월: I2P router 및 reseed-tools 업데이트 필요 시: TLS 인증서 갱신 (Let\u0026rsquo;s Encrypt로 자동화) 포트 선택 기본: 8443 (권장) 대안: 1024-49151 사이의 임의의 포트 포트 443: 루트 권한 또는 포트 포워딩이 필요함 (iptables redirect 권장) 포트 포워딩 예시:\niptables -A PREROUTING -t nat -p tcp --dport 443 -j REDIRECT --to-port 8443 대체 Reseed(초기 피어 데이터 가져오기) 방법 다른 부트스트랩 옵션은 제한적인 네트워크 환경에 있는 사용자에게 도움이 됩니다:\n파일 기반 Reseed(네트워크 초기 부트스트랩) 버전 0.9.16에서 도입된 파일 기반 reseeding(재시드: 초기 피어 정보를 받아 네트워크에 합류하는 과정)은 사용자가 RouterInfo 번들을 수동으로 로드할 수 있게 해줍니다. 이 방법은 HTTPS reseed 서버가 차단된 검열 지역의 사용자에게 특히 유용합니다.\n프로세스: 1. 신뢰할 수 있는 연락처가 자신의 router를 사용해 SU3 bundle(서명된 번들 파일)을 생성한다 2. 번들은 이메일, USB 드라이브 또는 기타 out-of-band 채널(본 채널과 분리된 별도 경로)을 통해 전송된다 3. 사용자는 i2pseeds.su3를 I2P 구성 디렉터리에 배치한다 4. Router는 재시작 시 번들을 자동으로 감지하고 처리한다\n문서: /blog/2020/06/07/help-your-friends-join-i2p-by-sharing-reseed-bundles/\n사용 사례: - reseed servers(I2P 네트워크 초기 접속을 위한 서버)를 차단하는 국가 방화벽 뒤에 있는 사용자 - 수동 부트스트랩이 필요한 격리된 네트워크 - 테스트 및 개발 환경\nCloudflare로 프록시된 Reseeding(부트스트랩을 위한 초기 시드 데이터 다운로드 과정) Cloudflare의 CDN을 통해 reseed(I2P 네트워크 초기 부트스트랩) 트래픽을 라우팅하는 것은 검열이 심한 지역의 운영자들에게 몇 가지 이점을 제공한다.\n이점: - 클라이언트로부터 오리진 서버 IP 주소를 숨김 - Cloudflare의 인프라를 통한 DDoS 보호 - 엣지 캐싱을 통한 지리적 부하 분산 - 전 세계 클라이언트를 위한 성능 향상\n구현 요건: - reseed-tools에서 --trustProxy 플래그 활성화 - DNS 레코드에 대해 Cloudflare 프록시 활성화 - 적절한 X-Forwarded-For 헤더 처리\n중요 유의사항: - Cloudflare 포트 제한이 적용됨(지원되는 포트만 사용해야 함) - 동일 클라이언트 번들의 일관성을 위해 X-Forwarded-For 지원이 필요함 - SSL/TLS 구성은 Cloudflare에서 관리됨\n문서: https://homepage.np-tokumei.net/post/notes-i2p-reseed-over-cloudflare/ 검열 저항 전략 Nguyen Phong Hoang의 연구(USENIX FOCI 2019)는 검열된 네트워크를 위한 추가적인 부트스트랩 방법을 식별합니다:\n클라우드 스토리지 제공업체 Box, Dropbox, Google Drive, OneDrive: 공개 링크로 SU3 파일(서명된 업데이트 파일 형식)을 호스팅 장점: 정상적인 서비스를 방해하지 않고는 차단하기 어렵다 제한사항: 사용자에게 URL을 수동으로 배포해야 한다 IPFS 배포 InterPlanetary File System(IPFS, 분산 콘텐츠 주소형 파일 시스템)에 reseed 번들을 호스팅합니다 콘텐츠 주소형 스토리지는 변조를 방지합니다 테이크다운(삭제 요청) 시도에 강합니다 Tor Onion Services(토르 오니언 서비스) .onion 주소를 통해 접근 가능한 Reseed servers(네트워크 초기 부트스트랩 서버) IP 기반 차단에 강함 사용자의 시스템에 Tor 클라이언트가 필요함 연구 문서: https://homepage.np-tokumei.net/post/notes-censorship-resistant-i2p-reseeding/ I2P 차단이 확인된 국가 2025년 기준, 다음 국가들은 I2P reseed servers(네트워크 부트스트랩 서버)를 차단하는 것으로 확인되었습니다:\n중국 이란 오만 카타르 쿠웨이트 이들 지역의 사용자는 대체 bootstrap(초기 연결 설정) 방법 또는 검열에 강한 reseeding(초기 피어 정보 가져오기) 전략을 활용해야 합니다.\n구현자를 위한 프로토콜 세부 사항 Reseed(리시드) 요청 명세서 클라이언트 동작 서버 선택: Router는 reseed URL(네트워크 부트스트랩용 서버 URL)의 하드코딩된 목록을 유지 무작위 선택: 클라이언트가 사용 가능한 목록에서 서버를 무작위로 선택 요청 형식: GET /i2pseeds.su3?netid=2 HTTP/1.1 User-Agent: 일반적인 브라우저를 모방해야 함 (예: \u0026ldquo;Wget/1.11.4\u0026rdquo;) 재시도 로직: SU3 요청이 실패하면 인덱스 페이지 파싱으로 대체 인증서 검증: 시스템 신뢰 저장소와 대조하여 TLS 인증서를 검증 SU3 서명 검증: 알려진 reseed 인증서와 대조하여 서명을 검증 서버 동작 번들 선택: netDb에서 RouterInfos의 의사무작위 부분집합을 선택 클라이언트 추적: 소스 IP로 요청을 식별(X-Forwarded-For를 반영) 번들 일관성: 시간 창 내 반복 요청에는 동일한 번들을 반환(일반적으로 8-12시간) 번들 다양성: 네트워크 다양성을 위해 서로 다른 클라이언트에 서로 다른 번들을 반환 Content-Type: application/octet-stream 또는 application/x-i2p-reseed RouterInfo 파일 형식 reseed bundle(리시드 번들)의 각 .dat 파일에는 RouterInfo 구조체가 포함되어 있습니다:\n파일 이름 규칙: routerInfo-{base64-hash}.dat - 해시는 I2P base64 alphabet(I2P에서 사용하는 base64 문자 집합)을 사용하며 44자입니다 - 예: routerInfo-ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmn.dat\n파일 내용: - RouterIdentity(라우터 식별 정보) (router 해시, 암호화 키, 서명 키) - 발행 타임스탬프 - Router 주소(IP, 포트, 전송 유형) - Router 기능 및 옵션 - 위의 모든 데이터를 포괄하는 서명\n네트워크 다양성 요구사항 네트워크 중앙집중화를 방지하고 시빌(Sybil) 공격 탐지를 가능하게 하기 위해:\n완전한 NetDb 덤프 금지: 단일 클라이언트에게 모든 RouterInfos(라우터 정보 레코드)를 절대 제공하지 말 것 무작위 샘플링: 각 번들은 사용 가능한 피어의 서로 다른 부분집합을 포함 최소 번들 크기: RouterInfos 75개(기존 50개에서 상향) 최대 번들 크기: RouterInfos 100개 신선도: RouterInfos는 최근(생성 후 24시간 이내)이어야 함 IPv6 고려 사항 현재 상태 (2025): - 여러 reseed servers(초기 부트스트랩 서버)에서 IPv6 무응답 현상이 나타남 - 신뢰성을 위해 클라이언트는 IPv4를 우선 사용하거나 강제하는 것이 바람직함 - 새로운 배포에서는 IPv6 지원을 권장하지만 필수는 아님\n구현 참고: 듀얼 스택 서버를 구성할 때 IPv4와 IPv6 수신 주소가 모두 올바르게 동작하는지 확인하거나, 제대로 지원할 수 없다면 IPv6를 비활성화하십시오.\n보안 고려사항 위협 모델 reseed protocol(네트워크 초기 부트스트랩을 위한 재시드 프로토콜)은 다음으로부터 방어합니다:\n중간자 공격: RSA-4096 서명으로 번들 변조를 방지합니다 네트워크 분할: 여러 독립적인 reseed 서버(초기 네트워크 부트스트랩용 서버)가 단일 통제 지점을 방지합니다 시빌 공격: 번들의 다양성이 공격자가 사용자를 고립시키는 능력을 제한합니다 검열: 여러 서버와 대체 방법이 중복성을 제공합니다 reseed(네트워크 부트스트랩) 프로토콜은 다음에 대해 방어하지 않습니다:\n침해된 reseed 서버: 공격자가 reseed(초기 부트스트랩을 위해 netDb 피어 정보를 내려받는 과정) 인증서 개인 키를 탈취한 경우 네트워크 전면 차단: 특정 지역에서 모든 reseed 방법이 차단된 경우 장기 모니터링: reseed 요청은 I2P에 참여하려는 IP를 드러낸다 인증서 관리 개인 키 보안: - 사용하지 않을 때 SU3 서명 키를 오프라인에 보관 - 키 암호화에 강력한 비밀번호를 사용 - 키와 인증서의 안전한 백업을 유지 - 고가치 자산을 다루는 배포 환경에서는 하드웨어 보안 모듈(HSM) 사용을 고려\n인증서 폐지: - 인증서 폐지 목록(CRLs)은 뉴스 피드를 통해 배포 - 침해된 인증서는 조정자가 폐지할 수 있음 - Routers는 소프트웨어 업데이트 시 CRLs를 자동으로 업데이트함\n공격 완화 DDoS 보호: - 과도한 요청에 대한 fail2ban 규칙 - 웹 서버 수준에서의 요청률 제한 - IP 주소당 연결 제한 - 추가적인 보호 계층을 위한 Cloudflare 또는 유사한 CDN\n스크레이핑 방지: - 요청한 IP별 서로 다른 번들 - IP별 시간 기반 번들 캐싱 - 스크레이핑 시도를 시사하는 패턴 로깅 - 탐지된 공격에 대해 다른 운영자들과의 협력\n테스트 및 검증 자신의 Reseed Server(새 router의 부트스트랩에 필요한 초기 netDb 데이터를 제공하는 서버) 테스트하기 방법 1: 새 Router 설치 깨끗한 시스템에 I2P를 설치합니다 구성에 reseed(초기 네트워크 부트스트랩) URL을 추가합니다 다른 reseed URL을 제거하거나 비활성화합니다 router를 시작하고 reseed 성공 여부를 로그로 모니터링합니다 5-10분 내에 네트워크 연결을 확인합니다 예상 로그 출력:\nReseed got 77 router infos from https://your-reseed.example.com/i2pseeds.su3?netid=2 with 0 errors Reseed complete, 77 received 방법 2: 수동 SU3 유효성 검사 # Download bundle curl -k -A \u0026#34;Wget/1.11.4\u0026#34; https://your-reseed.example.com/i2pseeds.su3 \u0026gt; test.su3 # Verify it\u0026#39;s a valid SU3 file hexdump -C test.su3 | head -n 3 # Should show: 49 32 50 73 75 33 (I2Psu3) # Extract content (requires su3 tools) java -cp /path/to/i2p.jar net.i2p.crypto.SU3File verify test.su3 your-cert.crt # Unzip content # (Extract content section, skip header+signature, then unzip) 방법 3: checki2p 모니터링 https://checki2p.com/reseed 에 있는 서비스는 모든 등록된 I2P reseed 서버(reseed: 초기 피어 정보를 배포하는 서버)에 대해 4시간마다 자동 점검을 수행합니다. 이는 다음을 제공합니다:\n가용성 모니터링 응답 시간 지표 TLS 인증서 검증 SU3 서명 검증 가동 시간 이력 데이터 귀하의 reseed(초기 부트스트랩 서버)가 I2P 프로젝트에 등록되면 24시간 이내에 checki2p에 자동으로 표시됩니다.\n일반적인 문제 해결 문제: 첫 실행 시 \u0026ldquo;Unable to read signing key\u0026rdquo; - 해결책: 이는 정상입니다. 새 키를 생성하려면 \u0026lsquo;y\u0026rsquo;를 입력하세요.\n문제: Router가 서명 검증에 실패함 - 원인: 인증서가 router의 신뢰 저장소에 없음 - 해결 방법: 인증서를 ~/.i2p/certificates/reseed/ 디렉터리에 두세요\n문제: 동일한 번들이 서로 다른 클라이언트에 전달됨 - 원인: X-Forwarded-For 헤더가 제대로 전달되지 않음 - 해결책: --trustProxy를 활성화하고 리버스 프록시 헤더를 구성\n문제: \u0026ldquo;Connection refused\u0026rdquo; 오류 - 원인: 인터넷에서 포트에 접근할 수 없음 - 해결 방법: 방화벽 규칙 확인, 포트 포워딩 확인\n문제: 번들 재빌드 중 높은 CPU 사용률 - 원인: 350개 이상의 SU3(업데이트 패키지 파일 형식) 변형을 생성할 때의 정상 동작 - 해결책: 충분한 CPU 자원을 확보하고, 재빌드 빈도 감소를 고려하세요\n참고 정보 공식 문서 Reseed(I2P 네트워크 초기 부트스트랩) 기여자 가이드: /guides/creating-and-running-an-i2p-reseed-server/ Reseed 정책 요건: /guides/reseed-policy/ SU3 명세: /docs/specs/updates/ Reseed 도구 저장소: https://i2pgit.org/idk/reseed-tools Reseed 도구 문서: https://eyedeekay.github.io/reseed-tools/ 대안 구현체 PurpleI2P pyseeder: https://github.com/PurpleI2P/pyseeder DivaExchange i2p-reseed: https://github.com/diva-exchange/i2p-reseed RTradeLtd i2p-tools-1: https://github.com/RTradeLtd/i2p-tools-1 Python WSGI reseeder (I2P 네트워크 초기 피어 배포 서버): https://github.com/torbjo/i2p-reseeder 커뮤니티 리소스 I2P 포럼: https://i2pforum.net/ Gitea 저장소: https://i2pgit.org/I2P_Developers/i2p.i2p IRC: IRC2P의 #i2p-dev 상태 모니터링: https://checki2p.com/reseed 버전 이력 0.9.14 (2014): SU3 리시드 형식 도입 0.9.16 (2014): 파일 기반 리시딩 추가 0.9.42 (2019): Network ID 쿼리 매개변수 필수화 2.0.0 (2022): SSU2 전송 프로토콜 도입 2.4.0 (2024): NetDB 격리 및 보안 개선 2.6.0 (2024): I2P-over-Tor 연결 차단 2.10.0 (2025): 현재 안정 릴리스(2025년 9월 기준) 서명 유형 참조 Type Code Algorithm Key Size Signature Size Hash DSA-SHA10DSA1024-bit40 bytesSHA-1 ECDSA-SHA256-P2561ECDSAP-25664 bytesSHA-256 ECDSA-SHA384-P3842ECDSAP-38496 bytesSHA-384 ECDSA-SHA512-P5213ECDSAP-521132 bytesSHA-512 RSA-SHA256-20484RSA2048-bit256 bytesSHA-256 RSA-SHA384-30725RSA3072-bit384 bytesSHA-384 RSA-SHA512-40966RSA4096-bit512 bytesSHA-512 EdDSA-SHA512-Ed255197EdDSAEd2551964 bytesSHA-512 **Reseed Standard**: reseed(네트워크 초기 부트스트랩) 번들에는 Type 6 (RSA-SHA512-4096)이 필요합니다. 감사 네트워크의 접근성과 탄력성을 유지해 주신 모든 reseed(초기 연결을 위한 부트스트랩 서비스) 운영자께 감사드립니다. 다음 기여자와 프로젝트에 특별한 감사를 표합니다:\nzzz: 오랜 I2P 개발자이자 reseed(초기 접속을 위해 netDb 정보를 받아오는 부트스트랩 절차) 코디네이터 idk: reseed-tools의 현재 유지관리자이자 릴리스 매니저 Nguyen Phong Hoang: 검열 저항적 reseeding 전략에 대한 연구 PurpleI2P Team: 대체 I2P 구현과 도구 checki2p: reseed 인프라를 위한 자동화된 모니터링 서비스 I2P 네트워크의 분산형 reseed(초기 접속을 위한 피어 정보 배포) 인프라는 전 세계 수십 명의 운영자가 협력한 결과물로, 지역적 검열이나 기술적 장벽과 무관하게 신규 사용자가 언제나 네트워크에 합류할 경로를 찾을 수 있도록 보장한다.\n","description":"reseed 서비스(초기 부트스트랩 서비스) 운영 및 대체 부트스트랩 방법","id":"02dba83ad9e38e1355d624c0d4fa28aa","section":"docs","title":"Reseed Hosts (I2P 네트워크에 처음 연결할 때 필요한 초기 네트워크 정보를 배포하는 호스트)","url":"/ko/docs/misc/reseed/"},{"categories":null,"content":"개요 이 문서는 router와 다양한 애플리케이션에서 사용되는 I2P 구성 파일에 대한 포괄적인 기술 사양을 제공합니다. 또한 파일 형식 사양, 속성 정의, 그리고 I2P 소스 코드와 공식 문서를 대조하여 검증된 구현 세부사항을 다룹니다.\n범위 router 구성 파일 및 형식 클라이언트 애플리케이션 구성 I2PTunnel tunnel 구성 파일 형식 사양 및 구현 버전별 기능 및 사용 중단 항목 구현 참고 사항 구성 파일은 I2P 코어 라이브러리의 DataHelper.loadProps() 및 storeProps() 메서드를 사용하여 읽고 저장됩니다. 파일 형식은 I2P 프로토콜에서 사용하는 직렬화 형식과 상당히 다릅니다(자세한 내용은 공통 구조 사양 - 타입 매핑 을 참조하세요).\n일반 구성 파일 형식 I2P 구성 파일은 특정 예외와 제약이 적용된 수정된 Java Properties 형식을 따릅니다.\n형식 사양 Java Properties 에 기반하되, 다음과 같은 중대한 차이가 있습니다:\n인코딩 반드시 UTF-8 인코딩을 사용해야 합니다 (표준 Java Properties에서 사용하는 ISO-8859-1이 아님) 구현: 모든 파일 작업에 DataHelper.getUTF8() 유틸리티를 사용합니다 이스케이프 시퀀스 이스케이프 시퀀스는 인식되지 않습니다(백슬래시 \\ 포함) 줄 연속(line continuation)은 지원되지 않습니다 백슬래시 문자는 리터럴로 취급됩니다 주석 문자 #는 줄의 어느 위치에서든 주석을 시작합니다 ;는 오직 1열에 있을 때에만 주석을 시작합니다 !는 주석을 시작하지 않습니다 (Java Properties와 다릅니다) 키-값 구분자 =는 유효한 키-값 구분자 중 유일한 것입니다 :는 구분자로 인식되지 않습니다 공백은 구분자로 인식되지 않습니다 공백 처리 키의 앞뒤 공백은 제거되지 않습니다 값의 앞뒤 공백은 제거됩니다 라인 처리 =가 없는 줄은 무시됩니다(주석이나 빈 줄로 간주됨) 빈 값(key=)은 버전 0.9.10부터 지원됩니다 빈 값을 가진 키는 정상적으로 저장되고 읽어올 수 있습니다 문자 제한 사항 키에는 다음이 포함되면 안 됩니다: - # (해시/파운드 기호) - = (등호) - \\n (줄바꿈 문자) - ; (세미콜론)로 시작할 수 없습니다\n값에는 다음이 포함될 수 없습니다: - # (해시/파운드 기호) - \\n (줄바꿈 문자) - \\r (캐리지 리턴)로 시작하거나 끝날 수 없음 - 공백으로 시작하거나 끝날 수 없음 (자동으로 제거됨)\n파일 정렬 구성 파일은 키 기준으로 정렬할 필요는 없습니다. 그러나 대부분의 I2P 애플리케이션은 구성 파일을 작성할 때 다음을 쉽게 하기 위해 키를 알파벳순으로 정렬합니다: - 수동 편집 - 버전 관리 시스템의 diff(차이 비교) 작업 - 가독성\n구현 세부 사항 구성 파일 읽기 // Method signature from net.i2p.data.DataHelper public static Properties loadProps(File file) 동작: - UTF-8로 인코딩된 파일을 읽습니다 - 위에서 설명한 모든 형식 규칙을 강제합니다 - 문자 제한을 검증합니다 - 파일이 없으면 비어 있는 Properties 객체를 반환합니다 - 읽기 오류가 발생하면 IOException을 던집니다\n구성 파일 작성 // Method signature from net.i2p.data.DataHelper public static void storeProps(Properties props, File file) 동작: - UTF-8로 인코딩된 파일을 작성함 - 키를 알파벳 순으로 정렬함 (OrderedProperties를 사용하지 않는 한) - 버전 0.8.1부터 파일 권한을 모드 600(사용자 읽기/쓰기만)으로 설정함 - 키 또는 값에 잘못된 문자가 있을 경우 IllegalArgumentException을 던짐 - 쓰기 오류 시 IOException을 던짐\n형식 검증 이 구현은 엄격한 검증을 수행합니다: - 키와 값에 금지된 문자가 있는지 검사합니다 - 잘못된 항목은 쓰기 작업 중 예외를 발생시킵니다 - 읽기 시 형식이 잘못된 줄(= 없는 줄)은 조용히 무시됩니다\n형식 예제 유효한 구성 파일 # This is a comment ; This is also a comment (column 1 only) key.with.dots=value with spaces another_key=value=with=equals empty.value= numeric.value=12345 unicode.value=こんにちは 잘못된 구성 예시 # INVALID: Key contains equals sign invalid=key=value # INVALID: Key contains hash invalid#key=value # INVALID: Value contains newline (implicit) key=value continues here # INVALID: Semicolon comment not in column 1 (treated as key) ; not.a.comment=value 코어 라이브러리 및 Router 구성 클라이언트 구성 (clients.config) 위치: $I2P_CONFIG_DIR/clients.config (레거시) 또는 $I2P_CONFIG_DIR/clients.config.d/ (현대식) 구성 인터페이스: Router 콘솔의 /configclients 형식 변경: 버전 0.9.42 (2019년 8월)\n디렉터리 구조 (버전 0.9.42+) 릴리스 0.9.42부터 기본 clients.config 파일이 자동으로 개별 구성 파일로 분할됩니다:\n$I2P_CONFIG_DIR/ ├── clients.config.d/ │ ├── 00-webConsole.config │ ├── 01-i2ptunnel.config │ ├── 02-i2psnark.config │ ├── 03-susidns.config │ └── ... └── clients.config (legacy, auto-migrated) 마이그레이션 동작: - 0.9.42+로 업그레이드한 뒤 첫 실행 시, monolithic file(모놀리식, 단일 구조의 파일)이 자동으로 분할됩니다 - 분리된 파일의 속성에는 clientApp.0. 접두사가 붙습니다 - 하위 호환성을 위해 레거시 형식도 계속 지원됩니다 - 분할 형식은 모듈식 패키징과 플러그인 관리를 가능하게 합니다\n속성 형식 각 줄은 clientApp.x.prop=val 형식을 따르며, 여기서 x는 앱 번호입니다.\n앱 번호 매기기 요구사항: - 반드시 0부터 시작해야 함 - 반드시 연속적이어야 함 (누락 없음) - 나열 순서가 시작 순서를 결정함\n필수 속성 메인 유형: String (정규화된 클래스 이름) 필수: 예 설명: 클라이언트 유형(관리형 vs. 비관리형)에 따라 이 클래스의 생성자 또는 main() 메서드가 호출됩니다 예: clientApp.0.main=net.i2p.router.web.RouterConsoleRunner 선택적 속성 이름 유형: 문자열 필수: 아니오 설명: router console에 표시되는 이름 예시: clientApp.0.name=Router Console 인수 Type: 문자열(공백 또는 탭으로 구분됨) Required: 아니오 Description: 메인 클래스의 생성자 또는 main() 메서드에 전달되는 인자 Quoting: 공백 또는 탭이 포함된 인자는 ' 또는 \u0026quot;로 감싸서 사용할 수 있음 Example: clientApp.0.args=-d $CONFIG/eepsite 지연 유형: 정수(초) 필수: 아니오 기본값: 120 설명: 클라이언트를 시작하기 전에 대기할 시간(초) 재정의: onBoot=true에 의해 재정의됨(지연을 0으로 설정) 특수 값: \u0026lt; 0: router가 RUNNING 상태에 도달할 때까지 대기한 후 새 스레드에서 즉시 시작 = 0: 같은 스레드에서 즉시 실행(예외가 콘솔로 전파됨) \u0026gt; 0: 지연 후 새 스레드에서 시작(예외는 로그에 기록되고 전파되지 않음) onBoot 유형: 불리언 필수: 아니요 기본값: false 설명: 지연 시간을 0으로 강제하며, 명시적으로 지정한 지연 설정을 재정의합니다 사용 사례: router 부팅 시 핵심 서비스를 즉시 시작 startOnLoad 유형: Boolean 필수: 아니오 기본값: true 설명: 클라이언트를 아예 시작할지 여부 사용 사례: 구성을 제거하지 않고 클라이언트를 비활성화 플러그인별 속성 이 속성들은 플러그인에서만 사용됩니다(코어 클라이언트에서는 사용되지 않습니다):\nstopargs 유형: 문자열 (공백 또는 탭으로 구분) 설명: 클라이언트를 중지시키는 데 전달되는 인수 변수 치환: 예 (아래 참조) uninstallargs Type: 문자열(공백 또는 탭으로 구분됨) Description: 클라이언트를 제거할 때 전달되는 인수 Variable Substitution: 예(아래 참조) 클래스패스 유형: 문자열 (쉼표로 구분된 경로) 설명: 클라이언트용 추가 classpath 요소 변수 치환: 예 (아래 참조) 변수 치환 (플러그인 전용) 플러그인의 args, stopargs, uninstallargs, 그리고 classpath에서 다음 변수들이 치환됩니다:\nVariable Expands To Example $I2P Base I2P installation directory /usr/share/i2p $CONFIG User configuration directory ~/.i2p $PLUGIN Plugin directory ~/.i2p/plugins/foo $OS Operating system name linux $ARCH Architecture name amd64 **참고**: 변수 치환은 플러그인에서만 수행되며, 코어 클라이언트에는 적용되지 않습니다. 클라이언트 유형 관리형 클라이언트 생성자는 RouterContext 및 ClientAppManager 매개변수와 함께 호출됩니다 클라이언트는 ClientApp 인터페이스를 구현해야 합니다 수명 주기는 router에 의해 제어됩니다 동적으로 시작, 중지 및 재시작할 수 있습니다 비관리형 클라이언트 main(String[] args) 메서드가 호출됨 별도의 스레드에서 실행 라이프사이클은 router에서 관리되지 않음 레거시 클라이언트 유형 구성 예제 # Router Console (core client) clientApp.0.main=net.i2p.router.web.RouterConsoleRunner clientApp.0.name=Router Console clientApp.0.args=-d $CONFIG/eepsite clientApp.0.delay=0 clientApp.0.onBoot=true clientApp.0.startOnLoad=true # I2PTunnel (core client) clientApp.1.main=net.i2p.i2ptunnel.TunnelControllerGroup clientApp.1.name=I2PTunnel clientApp.1.args= clientApp.1.delay=120 clientApp.1.startOnLoad=true # Plugin Example clientApp.2.main=org.example.plugin.PluginMain clientApp.2.name=Example Plugin clientApp.2.args=-config $PLUGIN/config.properties clientApp.2.stopargs=-shutdown clientApp.2.uninstallargs=-remove $PLUGIN clientApp.2.classpath=$PLUGIN/lib/plugin.jar,$PLUGIN/lib/dep.jar clientApp.2.delay=240 clientApp.2.startOnLoad=true 로거 구성 (logger.config) 위치: $I2P_CONFIG_DIR/logger.config 설정 인터페이스: Router 콘솔의 /configlogging\n속성 참조 콘솔 버퍼 설정 logger.consoleBufferSize 유형: 정수 기본값: 20 설명: 콘솔에서 버퍼링할 로그 메시지의 최대 개수 범위: 1-1000 권장 날짜와 시간 형식 logger.dateFormat 유형: 문자열(SimpleDateFormat 패턴) 기본값: 시스템 로케일에서 가져옴 예시: HH:mm:ss.SSS 문서: Java SimpleDateFormat 로그 레벨 logger.defaultLevel 유형: 열거형 기본값: ERROR 값: CRIT, ERROR, WARN, INFO, DEBUG 설명: 모든 클래스에 대한 기본 로그 수준 logger.minimumOnScreenLevel Type: 열거형 Default: CRIT Values: CRIT, ERROR, WARN, INFO, DEBUG Description: 화면에 표시되는 메시지의 최소 레벨 logger.record.{class} 유형: Enum(열거형) 값: CRIT, ERROR, WARN, INFO, DEBUG 설명: 클래스별 로그 레벨 재정의 예시: logger.record.net.i2p.router.transport.udp=DEBUG 표시 옵션 logger.displayOnScreen 유형: 불리언 기본값: true 설명: 콘솔 출력에 로그 메시지를 표시할지 여부 logger.dropDuplicates 유형: 불리언 기본값: true 설명: 연속된 중복 로그 메시지를 제거합니다 logger.dropOnOverflow 유형: 불리언 기본값: false 설명: 버퍼가 가득 찼을 때 메시지를 버립니다(블로킹 대신) 플러시 동작 방식 logger.flushInterval 유형: 정수 (초) 기본값: 29 도입 버전: 0.9.18 설명: 로그 버퍼를 디스크에 플러시하는 주기 형식 설정 logger.format 유형: 문자열 (문자 시퀀스) 설명: 로그 메시지 형식 템플릿 형식 문자: d = 날짜/시간 c = 클래스 이름 t = 스레드 이름 p = 우선순위(로그 레벨) m = 메시지 예시: dctpm은 [타임스탬프] [클래스] [스레드] [레벨] 메시지를 생성합니다 압축 (버전 0.9.56+) logger.gzip 유형: Boolean 기본값: false 도입 버전: 0.9.56 설명: 로테이션된 로그 파일에 대해 gzip 압축을 활성화합니다 logger.minGzipSize 유형: 정수(바이트) 기본값: 65536 도입: 버전 0.9.56 설명: 압축을 트리거하는 최소 파일 크기(기본값 64 KB) 파일 관리 logger.logBufferSize 유형: 정수 (바이트) 기본값: 1024 설명: 플러시하기 전에 버퍼링할 최대 메시지 수 logger.logFileName 유형: 문자열 (파일 경로) 기본값: logs/log-@.txt 설명: 로그 파일 명명 패턴 (@은 로테이션 번호로 대체됨) logger.logFilenameOverride Type: 문자열 (파일 경로) Description: 로그 파일 이름 재정의(로그 로테이션 패턴 비활성화) logger.logFileSize 유형: 문자열(단위가 포함된 크기) 기본값: 10M 단위: K (킬로바이트), M (메가바이트), G (기가바이트) 예시: 50M, 1G logger.logRotationLimit 유형: 정수 기본값: 2 설명: 순환 로그 파일의 최대 번호 (log-0.txt부터 log-N.txt까지) 구성 예제 # Basic logging configuration logger.consoleBufferSize=50 logger.dateFormat=yyyy-MM-dd HH:mm:ss.SSS logger.defaultLevel=WARN logger.displayOnScreen=true logger.dropDuplicates=true logger.dropOnOverflow=false # Flushing and format logger.flushInterval=30 logger.format=dctpm # File management logger.logBufferSize=2048 logger.logFileName=logs/log-@.txt logger.logFileSize=25M logger.logRotationLimit=5 # Compression (0.9.56+) logger.gzip=true logger.minGzipSize=131072 # On-screen filtering logger.minimumOnScreenLevel=ERROR # Per-class overrides logger.record.net.i2p.router.transport=INFO logger.record.net.i2p.router.tunnel=DEBUG logger.record.net.i2p.crypto=WARN 플러그인 구성 개별 플러그인 구성 (plugins/*/plugin.config) 위치: $I2P_CONFIG_DIR/plugins/{plugin-name}/plugin.config 형식: 표준 I2P 구성 파일 형식 문서: 플러그인 사양 필수 속성 이름 유형: 문자열 필수: 예 설명: 플러그인 표시 이름 예시: name=I2P Plugin Example 키 유형: 문자열(공개 키) 필수 여부: 예(SU3로 서명된 플러그인의 경우 생략) 설명: 검증을 위한 플러그인 서명 공개 키 형식: Base64로 인코딩된 서명 키 서명자 유형: 문자열 필수: 예 설명: 플러그인 서명자 식별자 예시: signer=user@example.i2p 버전 유형: 문자열 (VersionComparator 형식) 필수: 예 설명: 업데이트 확인을 위한 플러그인 버전 형식: Semantic versioning(시맨틱 버저닝) 또는 사용자 정의 비교 가능한 형식 예시: version=1.2.3 표시 속성 날짜 유형: Long (Unix 타임스탬프 밀리초) 설명: 플러그인 릴리스 날짜 저자 유형: 문자열 설명: 플러그인 작성자 이름 websiteURL 유형: 문자열 (URL) 설명: 플러그인 웹사이트 URL updateURL 유형: 문자열 (URL) 설명: 플러그인 업데이트 확인용 URL updateURL.su3 유형: 문자열 (URL) 도입 버전: 버전 0.9.15 설명: SU3 형식(I2P 업데이트 패키지 파일 형식) 업데이트 URL (권장) 설명 유형: 문자열 설명: 영문 플러그인 설명 설명_{language} 유형: 문자열 설명: 현지화된 플러그인 설명 예시: description_de=Deutsche Beschreibung 라이선스 유형: 문자열 설명: 플러그인 라이선스 식별자 예: license=Apache 2.0 설치 속성 설치 시 자동 시작 안 함 유형: 불리언 기본값: false 설명: 설치 후 자동 시작을 방지합니다 router 재시작 필요 유형: 불리언 기본값: false 설명: 설치 후 router 재시작이 필요함 설치 전용 유형: 부울 기본값: false 설명: 한 번만 설치(업데이트 없음) 업데이트 전용 Type: Boolean Default: false Description: 기존 설치만 업데이트합니다(새로 설치하지 않음) 플러그인 설정 예제 # Required properties name=Example I2P Plugin signer=developer@mail.i2p version=1.5.0 # Display properties author=Plugin Developer websiteURL=http://plugin.example.i2p updateURL=http://plugin.example.i2p/update.xpi2p updateURL.su3=http://plugin.example.i2p/update.su3 description=Example plugin demonstrating configuration description_de=Beispiel-Plugin zur Demonstration der Konfiguration license=MIT # Installation behavior dont-start-at-install=false router-restart-required=false 전역 플러그인 구성 (plugins.config) 위치: $I2P_CONFIG_DIR/plugins.config 목적: 설치된 플러그인을 전역적으로 활성화/비활성화\n속성 형식 plugin.{name}.startOnLoad=true|false {name}: plugin.config의 플러그인 이름 startOnLoad: router 실행 시 플러그인을 시작할지 여부 예시 plugin.i2psnark.startOnLoad=true plugin.susimail.startOnLoad=true plugin.susidns.startOnLoad=true plugin.i2pbote.startOnLoad=false 웹 애플리케이션 설정 (webapps.config) 위치: $I2P_CONFIG_DIR/webapps.config 목적: 웹 애플리케이션을 활성화/비활성화하고 구성\n속성 형식 webapps.{name}.startOnLoad 유형: Boolean 설명: router 시작 시 웹앱을 시작할지 여부 형식: webapps.{name}.startOnLoad=true|false webapps.{name}.classpath 유형: String(문자열) (공백 또는 쉼표로 구분된 경로) 설명: 웹앱용 추가 클래스패스 요소 형식: webapps.{name}.classpath=[paths] 변수 치환 경로는 다음과 같은 변수 치환을 지원합니다:\nVariable Expands To Context $I2P Base I2P directory Core webapps $CONFIG User config directory All webapps $PLUGIN Plugin directory Plugin webapps #### 클래스패스 해석 코어 웹앱: $I2P/lib를 기준으로 한 상대 경로 플러그인 웹앱: $CONFIG/plugins/{appname}/lib를 기준으로 한 상대 경로 구성 예제 # Router console webapps.routerconsole.startOnLoad=true webapps.routerconsole.classpath=routerconsole.jar # I2PSnark webapps.i2psnark.startOnLoad=true webapps.i2psnark.classpath=i2psnark.jar # SusiDNS webapps.susidns.startOnLoad=true webapps.susidns.classpath=susidns.jar # Plugin webapp example webapps.exampleplugin.startOnLoad=false webapps.exampleplugin.classpath=$PLUGIN/lib/webapp.jar,$PLUGIN/lib/deps.jar Router 설정 (router.config) 위치: $I2P_CONFIG_DIR/router.config 구성 인터페이스: /configadvanced의 Router 콘솔 용도: 핵심 router 설정 및 네트워크 매개변수\n설정 범주 네트워크 설정 대역폭 설정:\ni2np.bandwidth.inboundKBytesPerSecond=100 i2np.bandwidth.outboundKBytesPerSecond=50 i2np.bandwidth.share.percentage=80 전송 구성:\n# NTCP (TCP-based transport) i2np.ntcp.port=8887 i2np.ntcp.enable=true i2np.ntcp.autoip=true # SSU (UDP-based transport) i2np.udp.port=8887 i2np.udp.enable=true # UPnP/NAT-PMP i2np.upnp.enable=true Router 동작 방식 # Tunnel participation router.maxParticipatingTunnels=200 router.sharePercentage=80 # Updates router.updatePolicy=notify router.updateURL=http://update.i2p2.i2p/ # Network integration router.hiddenMode=false router.clockSkewOffset=0 콘솔 설정 # Language and display routerconsole.lang=en routerconsole.country=US routerconsole.summaryRefresh=60 # Browser routerconsole.browser=default # Security routerconsole.enableCompression=true 시간 설정 # NTP time.disabled=false time.sntpServerList=0.pool.ntp.org,1.pool.ntp.org 참고: Router 설정은 방대합니다. 전체 속성 레퍼런스는 /configadvanced의 router 콘솔에서 확인하세요.\n애플리케이션 구성 파일 주소록 설정 (addressbook/config.txt) 위치: $I2P_CONFIG_DIR/addressbook/config.txt 애플리케이션: SusiDNS 목적: 호스트 이름 해석 및 주소록 관리\n파일 위치 router_addressbook 기본값: ../hosts.txt 설명: 마스터 주소록(시스템 전역 호스트 이름) 형식: 표준 hosts 파일 형식 privatehosts.txt 위치: $I2P_CONFIG_DIR/addressbook/privatehosts.txt 설명: 개인용 호스트 이름 매핑 우선순위: 최상위 (다른 모든 소스를 덮어씀) userhosts.txt 위치: $I2P_CONFIG_DIR/addressbook/userhosts.txt 설명: 사용자가 추가한 호스트명 매핑 관리: SusiDNS 인터페이스를 통해 hosts.txt 위치: $I2P_CONFIG_DIR/addressbook/hosts.txt 설명: 다운로드된 공개 주소록 출처: 구독 피드 네이밍 서비스 BlockfileNamingService (0.8.8부터 기본) 저장 형식: - 파일: hostsdb.blockfile - 위치: $I2P_CONFIG_DIR/addressbook/ - 성능: hosts.txt 대비 ~10배 더 빠른 조회 - 형식: 이진 데이터베이스 형식\n레거시 네이밍 서비스: - 형식: 평문 텍스트 hosts.txt - 상태: 더 이상 권장되지 않지만 여전히 지원됨 - 사용 사례: 수동 편집, 버전 관리\n호스트 이름 규칙 I2P 호스트명은 다음을 준수해야 합니다:\nTLD 요구 사항: .i2p로 끝나야 함 최대 길이: 총 67자 문자 집합: [a-z], [0-9], . (마침표), - (하이픈) 대소문자: 소문자만 시작 제한: . 또는 -로 시작할 수 없음 금지된 패턴: .., .-, -. 포함 불가 (0.6.1.33부터) 예약됨: Base32 호스트명 *.b32.i2p (base32.b32.i2p는 52자) 유효한 예시 example.i2p my-site.i2p test.example.i2p site123.i2p 잘못된 예제 example.com # Wrong TLD -invalid.i2p # Starts with hyphen invalid..i2p # Contains double dot invalid.-.i2p # Contains dot-hyphen UPPERCASE.I2P # Must be lowercase verylonghostnameover67charactersthatexceedsthemaximumlength.i2p # Too long 구독 관리 subscriptions.txt 위치: $I2P_CONFIG_DIR/addressbook/subscriptions.txt 형식: 한 줄에 하나의 URL 기본값: http://i2p-projekt.i2p/hosts.txt 구독 피드 형식 (0.9.26부터) 메타데이터가 포함된 고급 피드 형식:\n# # I2P Address Book Subscription Feed # Format: hostname=destination [#property=value ...] # example.i2p=base64destination #added=20250101 #src=manual another.i2p=base64destination #added=20250102 #src=feed1 메타데이터 속성: - added: 호스트명이 추가된 날짜(YYYYMMDD 형식) - src: 소스 식별자 - sig: 선택적 서명\n하위 호환성: 간단한 hostname=destination 형식은 여전히 지원됩니다.\n구성 예시 # Address book locations router_addressbook=../hosts.txt privatehosts.txt=$CONFIG/addressbook/privatehosts.txt userhosts.txt=$CONFIG/addressbook/userhosts.txt hosts.txt=$CONFIG/addressbook/hosts.txt # Naming service naming.service=BlockfileNamingService naming.service.blockfile.location=$CONFIG/addressbook/hostsdb.blockfile # Subscriptions subscriptions.txt=$CONFIG/addressbook/subscriptions.txt subscriptions.schedule=daily subscriptions.proxy=false I2PSnark 구성 (i2psnark.config.d/i2psnark.config) 위치: $I2P_CONFIG_DIR/i2psnark.config.d/i2psnark.config 애플리케이션: I2PSnark BitTorrent 클라이언트 설정 인터페이스: http://127.0.0.1:7657/i2psnark 의 웹 GUI\n디렉터리 구조 $I2P_CONFIG_DIR/i2psnark.config.d/ ├── i2psnark.config ├── [torrent-hash-1]/ │ └── *.config ├── [torrent-hash-2]/ │ └── *.config └── ... 주요 설정 (i2psnark.config) 최소한의 기본 구성:\ni2psnark.dir=i2psnark 웹 인터페이스를 통해 관리되는 추가 속성:\n# Basic settings i2psnark.dir=i2psnark i2psnark.autoStart=false i2psnark.openTrackers=true # Network settings i2psnark.uploaders=8 i2psnark.upBW=40 i2psnark.seedPct=100 # I2CP settings i2psnark.i2cpHost=127.0.0.1 i2psnark.i2cpPort=7654 개별 토렌트 설정 위치: $I2P_CONFIG_DIR/i2psnark.config.d/[torrent-hash]/*.config 형식: 토렌트별 설정 관리: 자동 (웹 GUI를 통해)\n속성에는 다음이 포함됩니다: - 토렌트별 업로드/다운로드 설정 - 파일 우선순위 - 트래커 정보 - 피어 제한\n참고: 토렌트 구성은 주로 웹 인터페이스를 통해 관리됩니다. 수동으로 편집하는 것은 권장되지 않습니다.\n토렌트 데이터 구성 데이터 저장소는 설정과 분리되어 있습니다:\n$I2P_CONFIG_DIR/i2psnark/ # Data directory ├── *.torrent # Torrent metadata files ├── *.torrent.downloaded/ # Downloaded file directories ├── file1.dat # Direct file downloads └── ... $I2P_CONFIG_DIR/i2psnark.config.d/ # Configuration directory ├── i2psnark.config # Main config └── [hashes]/ # Per-torrent configs I2PTunnel 설정 (i2ptunnel.config) 위치: $I2P_CONFIG_DIR/i2ptunnel.config (레거시) 또는 $I2P_CONFIG_DIR/i2ptunnel.config.d/ (최신) 구성 인터페이스: Router 콘솔의 /i2ptunnel 형식 변경: 버전 0.9.42 (2019년 8월)\n디렉터리 구조 (버전 0.9.42+) 0.9.42 릴리스부터 기본 i2ptunnel.config 파일이 자동으로 나뉩니다:\n$I2P_CONFIG_DIR/ ├── i2ptunnel.config.d/ │ ├── http-proxy/ │ │ └── tunnel.config │ ├── irc-proxy/ │ │ └── tunnel.config │ ├── ssh-service/ │ │ └── tunnel.config │ └── ... └── i2ptunnel.config (legacy, auto-migrated) 중요한 형식 차이: - 모놀리식 형식: 속성 앞에 tunnel.N. 접두사가 붙음 - 분리형 형식: 속성에는 접두사가 없음 (예: description=, tunnel.0.description=가 아님)\n마이그레이션 동작 0.9.42로 업그레이드 후 첫 실행 시:\n기존 i2ptunnel.config 파일을 읽습니다 개별 tunnel 설정이 i2ptunnel.config.d/ 디렉터리에 생성됩니다 분리된 파일에서 속성의 접두사가 제거됩니다 원본 파일이 백업됩니다 하위 호환성을 위해 이전 형식도 계속 지원됩니다 구성 섹션 I2PTunnel 구성은 아래의 I2PTunnel 구성 참조 섹션에서 자세히 설명되어 있습니다. 속성 설명은 모놀리식(tunnel.N.property) 형식과 분리(property) 형식 모두에 적용됩니다.\nI2PTunnel 설정 참조 이 섹션에서는 모든 I2PTunnel 구성 속성에 대한 포괄적인 기술 참조를 제공합니다. 속성은 tunnel.N. 접두사 없이 분리 형식으로 표시됩니다. 모놀리식 형식의 경우 모든 속성 앞에 tunnel.N. 접두사를 붙이며, 여기서 N은 tunnel 번호입니다.\n중요: tunnel.N.option.i2cp.*로 기술된 속성은 I2PTunnel(트래픽 경로를 구성·관리하는 도구)에서 구현되어 있으며, I2CP 프로토콜(I2P router와 애플리케이션 간 제어 프로토콜)이나 SAM API(I2P용 Simple Anonymous Messaging 인터페이스)와 같은 다른 인터페이스를 통해서는 지원되지 않습니다.\n기본 속성 tunnel.N.description (설명) 유형: 문자열 적용 범위: 모든 tunnel(터널, I2P의 통신 경로) 설명: UI 표시용 사람이 읽을 수 있는 tunnel 설명 예시: description=HTTP Proxy for outproxy access tunnel.N.name (이름) 유형: 문자열 컨텍스트: 모든 tunnel(트래픽을 전달하는 I2P 경로) 필수: 예 설명: 고유한 tunnel 식별자 및 표시 이름 예시: name=I2P HTTP Proxy tunnel.N.type (유형) 유형: 열거형 컨텍스트: 모든 tunnel 필수: 예 값: client - 일반적인 클라이언트 tunnel httpclient - HTTP 프록시 클라이언트 ircclient - IRC 클라이언트 tunnel socksirctunnel - SOCKS IRC 프록시 sockstunnel - SOCKS 프록시(버전 4, 4a, 5) connectclient - CONNECT 프록시 클라이언트 streamrclient - Streamr 클라이언트 server - 일반적인 서버 tunnel httpserver - HTTP 서버 tunnel ircserver - IRC 서버 tunnel httpbidirserver - 양방향 HTTP 서버 streamrserver - Streamr 서버 tunnel.N.interface (인터페이스) 유형: 문자열(IP 주소 또는 호스트명) 컨텍스트: 클라이언트 tunnel에만 해당 기본값: 127.0.0.1 설명: 수신 연결을 위해 바인딩할 로컬 인터페이스 보안 참고: 0.0.0.0에 바인딩하면 원격 연결을 허용합니다 예시: interface=127.0.0.1 tunnel.N.listenPort (listenPort) 유형: 정수 적용 범위: 클라이언트 tunnel 전용 범위: 1-65535 설명: 클라이언트 연결을 수신 대기할 로컬 포트 예시: listenPort=4444 tunnel.N.targetHost (targetHost) 유형: 문자열(IP 주소 또는 호스트 이름) 적용 대상: 서버 tunnel에서만 사용 설명: 연결을 전달할 로컬 서버 예: targetHost=127.0.0.1 tunnel.N.targetPort (targetPort) 유형: 정수 적용 대상: 서버 tunnels에만 해당 범위: 1-65535 설명: 연결할 targetHost의 포트 예: targetPort=80 tunnel.N.targetDestination (targetDestination) 유형: 문자열(쉼표 또는 공백으로 구분된 Destination(목적지 주소) 목록) 컨텍스트: 클라이언트 tunnels에만 해당 형식: destination[:port][,destination[:port]] 설명: 연결할 I2P Destination 예시: targetDestination=example.i2p targetDestination=example.i2p:8080 targetDestination=site1.i2p,site2.i2p:8080 tunnel.N.i2cpHost (i2cpHost) 유형: 문자열(IP 주소 또는 호스트 이름) 기본값: 127.0.0.1 설명: I2P router의 I2CP 인터페이스 주소 참고: router 컨텍스트에서 실행 중에는 무시됩니다 예: i2cpHost=127.0.0.1 tunnel.N.i2cpPort (i2cpPort) 유형: 정수 기본값: 7654 범위: 1-65535 설명: I2P router의 I2CP 포트 참고: router 컨텍스트에서 실행 중일 때 무시됨 예시: i2cpPort=7654 tunnel.N.startOnLoad (startOnLoad) 유형: Boolean 기본값: true 설명: I2PTunnel이 로드될 때 tunnel을 시작할지 여부 예: startOnLoad=true 프록시 구성 tunnel.N.proxyList (proxyList) 유형: 문자열 (쉼표 또는 공백으로 구분된 호스트 이름) 적용 범위: HTTP 및 SOCKS 프록시에만 해당 설명: outproxy(외부로 나가는 프록시) 호스트 목록 예: proxyList=outproxy.example.i2p,backup.example.i2p 서버 구성 tunnel.N.privKeyFile (privKeyFile) 유형: 문자열 (파일 경로) 컨텍스트: 서버 및 지속형 클라이언트 tunnels 설명: 지속형 목적지의 개인 키를 포함하는 파일 경로: I2P 설정 디렉터리를 기준으로 하는 절대 경로 또는 상대 경로 예시: privKeyFile=eepsite/eepPriv.dat tunnel.N.spoofedHost (spoofedHost) 유형: 문자열 (호스트명) 컨텍스트: HTTP 서버에만 해당 기본값: 대상의 Base32 호스트명 설명: 로컬 서버로 전달되는 Host 헤더 값 예: spoofedHost=example.i2p tunnel.N.spoofedHost.NNNN (spoofedHost.NNNN) 유형: 문자열(호스트명) 컨텍스트: HTTP 서버에만 해당 설명: 특정 수신 포트에 대한 가상 호스트 재정의 사용 사례: 서로 다른 포트에서 여러 사이트를 호스팅 예시: spoofedHost.8080=site1.example.i2p 클라이언트별 옵션 tunnel.N.sharedClient (sharedClient) 유형: 불리언 컨텍스트: Client tunnels 전용 기본값: false 설명: 여러 클라이언트가 이 tunnel을 공유할 수 있는지 여부 예시: sharedClient=false tunnel.N.option.persistentClientKey (persistentClientKey) Type: 불리언 Context: 클라이언트 tunnel(터널) 전용 Default: false Description: 재시작 간에도 destination keys(목적지 키)를 저장하고 재사용 Conflict: i2cp.newDestOnResume=true와 상호 배타적 Example: option.persistentClientKey=true I2CP 옵션 (I2PTunnel 구현) 중요: 이 속성들은 option.i2cp. 접두사가 붙어 있지만, I2CP 프로토콜 계층이 아니라 I2PTunnel에서 구현됩니다. I2CP 또는 SAM API를 통해서는 사용할 수 없습니다.\ntunnel.N.option.i2cp.delayOpen (option.i2cp.delayOpen) 유형: 부울 컨텍스트: 클라이언트 tunnels 전용 기본값: false 설명: 첫 연결이 이루어질 때까지 tunnel 생성 지연 사용 사례: 드물게 사용되는 tunnels에 대한 리소스 절약 예시: option.i2cp.delayOpen=false tunnel.N.option.i2cp.newDestOnResume (option.i2cp.newDestOnResume) 유형: 불리언 적용 범위: 클라이언트 tunnel에만 해당 기본값: false 필수 조건: i2cp.closeOnIdle=true 충돌: persistentClientKey=true와 상호 배타적임 설명: 유휴 시간 초과 후 새 destination(목적지) 생성 예시: option.i2cp.newDestOnResume=false tunnel.N.option.i2cp.leaseSetPrivateKey (option.i2cp.leaseSetPrivateKey) 유형: 문자열 (base64로 인코딩된 키) 컨텍스트: 서버 tunnel 전용 설명: 지속적으로 사용하는 leaseset(목적지 연결 정보 데이터 구조) 암호화용 개인 키 사용 사례: 재시작 간에도 암호화된 leaseset을 일관되게 유지 예시: option.i2cp.leaseSetPrivateKey=AAAA...base64... tunnel.N.option.i2cp.leaseSetSigningPrivateKey (option.i2cp.leaseSetSigningPrivateKey) 유형: 문자열 (sigtype:base64) 컨텍스트: 서버 tunnel 전용 형식: sigtype:base64key 설명: 영구적인 leaseset 서명용 개인 키 예: option.i2cp.leaseSetSigningPrivateKey=7:AAAA...base64... 서버별 옵션 tunnel.N.option.enableUniqueLocal (option.enableUniqueLocal) 유형: 불리언(Boolean) 컨텍스트: Server tunnels에만 해당 기본값: false 설명: 원격 I2P 목적지마다 고유한 로컬 IP 사용 사용 사례: 서버 로그에서 클라이언트 IP를 추적 보안 참고: 익명성이 낮아질 수 있음 예시: option.enableUniqueLocal=false tunnel.N.option.targetForPort.NNNN (option.targetForPort.NNNN) 유형: 문자열 (hostname:port) 컨텍스트: 서버 tunnels(I2P의 통신 경로) 전용 설명: 수신 포트 NNNN에 대해 targetHost/targetPort를 재정의합니다 사용 사례: 서로 다른 로컬 서비스로의 포트 기반 라우팅 예: option.targetForPort.8080=localhost:8080 스레드 풀 구성 tunnel.N.option.i2ptunnel.usePool (option.i2ptunnel.usePool) 유형: Boolean 컨텍스트: 서버 tunnels 전용 기본값: true 설명: 연결 처리를 위해 스레드 풀 사용 비고: 표준 서버에서는 항상 false(무시됨) 예시: option.i2ptunnel.usePool=true tunnel.N.option.i2ptunnel.blockingHandlerCount (option.i2ptunnel.blockingHandlerCount) 유형: 정수 적용 범위: 서버 tunnel 전용 기본값: 65 설명: 최대 스레드 풀 크기 참고: 표준 서버에서는 무시됨 예시: option.i2ptunnel.blockingHandlerCount=100 HTTP 클라이언트 옵션 tunnel.N.option.i2ptunnel.httpclient.allowInternalSSL (option.i2ptunnel.httpclient.allowInternalSSL) 유형: Boolean 컨텍스트: HTTP 클라이언트 전용 기본값: false 설명: .i2p 주소에 대한 SSL 연결을 허용 예시: option.i2ptunnel.httpclient.allowInternalSSL=false tunnel.N.option.i2ptunnel.httpclient.disableAddressHelper (option.i2ptunnel.httpclient.disableAddressHelper) 유형: 부울 컨텍스트: HTTP 클라이언트 전용 기본값: false 설명: 프록시 응답에서 address helper 링크를 비활성화합니다 예시: option.i2ptunnel.httpclient.disableAddressHelper=false tunnel.N.option.i2ptunnel.httpclient.jumpServers (option.i2ptunnel.httpclient.jumpServers) Type: 문자열 (쉼표 또는 공백으로 구분된 URL) Context: HTTP 클라이언트 전용 Description: 호스트명 해석을 위한 Jump server(점프 서버) URL Example: option.i2ptunnel.httpclient.jumpServers=http://jump.i2p/jump,http://stats.i2p/jump tunnel.N.option.i2ptunnel.httpclient.sendAccept (option.i2ptunnel.httpclient.sendAccept) 유형: Boolean 컨텍스트: HTTP 클라이언트 전용 기본값: false 설명: Accept 및 Accept-Encoding을 제외한 Accept-* 헤더를 전달합니다 예: option.i2ptunnel.httpclient.sendAccept=false tunnel.N.option.i2ptunnel.httpclient.sendReferer (option.i2ptunnel.httpclient.sendReferer) 유형: 부울 컨텍스트: HTTP 클라이언트 전용 기본값: false 설명: 프록시를 통해 Referer 헤더 전달 개인정보 보호 참고: 개인정보가 유출될 수 있음 예시: option.i2ptunnel.httpclient.sendReferer=false tunnel.N.option.i2ptunnel.httpclient.sendUserAgent (option.i2ptunnel.httpclient.sendUserAgent) 유형: Boolean 컨텍스트: HTTP 클라이언트 전용 기본값: false 설명: User-Agent 헤더를 프록시를 통해 전달 프라이버시 주의: 브라우저 정보가 유출될 수 있음 예: option.i2ptunnel.httpclient.sendUserAgent=false tunnel.N.option.i2ptunnel.httpclient.sendVia (option.i2ptunnel.httpclient.sendVia) 유형: Boolean 컨텍스트: HTTP 클라이언트 전용 기본값: false 설명: 프록시를 통해 Via 헤더를 전달 예시: option.i2ptunnel.httpclient.sendVia=false tunnel.N.option.i2ptunnel.httpclient.SSLOutproxies (option.i2ptunnel.httpclient.SSLOutproxies) Type: 문자열(쉼표 또는 공백으로 구분된 destination(목적지) 목록) Context: HTTP 클라이언트 전용 Description: HTTPS를 위한 I2P 네트워크 내 SSL outproxies(외부 프록시) Example: option.i2ptunnel.httpclient.SSLOutproxies=ssl-outproxy.i2p tunnel.N.option.i2ptunnel.useLocalOutproxy (option.i2ptunnel.useLocalOutproxy) 유형: 불리언 컨텍스트: HTTP 클라이언트 전용 기본값: true 설명: 등록된 로컬 outproxy(외부 프록시) 플러그인 사용 예시: option.i2ptunnel.useLocalOutproxy=true HTTP 클라이언트 인증 tunnel.N.option.proxyAuth (option.proxyAuth) 유형: 열거형(Enum) 적용 범위: HTTP 클라이언트 전용 기본값: false 값: true, false, basic, digest 설명: 프록시에 접근하려면 로컬 인증이 필요합니다 참고: true는 basic과 동일합니다 예시: option.proxyAuth=basic tunnel.N.option.proxy.auth.USER.md5 (option.proxy.auth.USER.md5) 형식: 문자열(소문자 16진수 32자) 적용 대상: HTTP 클라이언트만 필수 조건: proxyAuth=basic 또는 proxyAuth=digest 설명: 사용자 USER의 비밀번호에 대한 MD5 해시 사용 중단: 대신 SHA-256을 사용하세요 (0.9.56+) 예시: option.proxy.auth.alice.md5=5f4dcc3b5aa765d61d8327deb882cf99 tunnel.N.option.proxy.auth.USER.sha256 (option.proxy.auth.USER.sha256) 유형: 문자열(소문자 16진수 64자) 적용 대상: HTTP 클라이언트 전용 요구 사항: proxyAuth=digest 도입 버전: 버전 0.9.56 표준: RFC 7616 설명: 사용자 USER의 비밀번호에 대한 SHA-256 해시 예시: option.proxy.auth.alice.sha256=5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8 Outproxy(외부 프록시) 인증 tunnel.N.option.outproxyAuth (option.outproxyAuth) 유형: 불리언 적용 범위: HTTP 클라이언트 전용 기본값: false 설명: outproxy(외부 인터넷 접속을 위한 프록시)로 인증 정보를 전송 예시: option.outproxyAuth=false tunnel.N.option.outproxyUsername (option.outproxyUsername) 유형: 문자열 컨텍스트: HTTP 클라이언트 전용 요구 사항: outproxyAuth=true 설명: outproxy(I2P에서 일반 인터넷으로 나가기 위한 프록시) 인증에 사용할 사용자 이름 예: option.outproxyUsername=user tunnel.N.option.outproxyPassword (option.outproxyPassword) 유형: 문자열 컨텍스트: HTTP 클라이언트 전용 요구 사항: outproxyAuth=true 설명: outproxy(외부 프록시) 인증용 비밀번호 보안: 평문으로 저장됨 예: option.outproxyPassword=secret SOCKS 클라이언트 옵션 tunnel.N.option.i2ptunnel.socks.proxy.default (option.i2ptunnel.socks.proxy.default) 유형: 문자열 (쉼표 또는 공백으로 구분된 목적지) 컨텍스트: SOCKS 클라이언트에만 해당 설명: 지정되지 않은 포트를 위한 I2P 네트워크 내 아웃프록시(outproxy) 예시: option.i2ptunnel.socks.proxy.default=outproxy.i2p tunnel.N.option.i2ptunnel.socks.proxy.NNNN (option.i2ptunnel.socks.proxy.NNNN) 유형: 문자열(쉼표 또는 공백으로 구분된 대상 목록) 컨텍스트: SOCKS 클라이언트에만 해당 설명: 포트 NNNN 전용 네트워크 내 outproxy(외부 인터넷으로 나가기 위한 프록시) 예: option.i2ptunnel.socks.proxy.443=ssl-outproxy.i2p tunnel.N.option.outproxyType (option.outproxyType) 유형: 열거형 적용 대상: SOCKS 클라이언트 전용 기본값: socks 도입: 버전 0.9.57 값: socks, connect (HTTPS) 설명: 구성된 outproxy(외부 프록시)의 유형 예시: option.outproxyType=connect HTTP 서버 옵션 tunnel.N.option.maxPosts (option.maxPosts) 유형: 정수 적용 범위: HTTP 서버 전용 기본값: 0 (무제한) 설명: postCheckTime마다 단일 destination(목적지 식별자)에서 오는 POST 요청의 최대 수 예: option.maxPosts=10 tunnel.N.option.maxTotalPosts (option.maxTotalPosts) 유형: 정수 적용 범위: HTTP 서버 전용 기본값: 0 (제한 없음) 설명: postCheckTime마다 모든 Destination(목적지)에서 오는 POST 요청의 최대 개수 예시: option.maxTotalPosts=50 tunnel.N.option.postCheckTime (option.postCheckTime) 유형: 정수(초) 컨텍스트: HTTP 서버 전용 기본값: 300 설명: POST 제한을 확인하는 시간 범위 예시: option.postCheckTime=600 tunnel.N.option.postBanTime (option.postBanTime) 유형: 정수(초) 컨텍스트: HTTP 서버 전용 기본값: 1800 설명: 단일 목적지에 대해 maxPosts 초과 시 적용되는 차단 기간 예시: option.postBanTime=3600 tunnel.N.option.postTotalBanTime (option.postTotalBanTime) 유형: 정수(초) 적용 범위: HTTP 서버 전용 기본값: 600 설명: maxTotalPosts 초과 시 차단 기간 예시: option.postTotalBanTime=1200 HTTP 서버 보안 옵션 tunnel.N.option.rejectInproxy (option.rejectInproxy) 유형: Boolean 컨텍스트: HTTP 서버에만 해당 기본값: false 설명: inproxy(인바운드 프록시)를 통해 온 것으로 보이는 연결을 거부합니다 예시: option.rejectInproxy=false tunnel.N.option.rejectReferer (option.rejectReferer) 유형: 불리언 컨텍스트: HTTP 서버 전용 기본값: false 도입: 버전 0.9.25 설명: Referer 헤더가 있는 연결을 거부합니다 예시: option.rejectReferer=false tunnel.N.option.rejectUserAgents (option.rejectUserAgents) 유형: 불리언 컨텍스트: HTTP 서버에만 해당 기본값: false 도입 버전: 0.9.25 요구 사항: userAgentRejectList 속성 설명: User-Agent가 일치하는 연결을 거부합니다 예: option.rejectUserAgents=false tunnel.N.option.userAgentRejectList (option.userAgentRejectList) 유형: 문자열(쉼표로 구분된 일치 문자열) 컨텍스트: HTTP 서버에서만 도입: 버전 0.9.25 대소문자: 대소문자 구분 일치 특이사항: \u0026ldquo;none\u0026rdquo;(0.9.33부터) 는 빈 User-Agent와 일치 설명: 거부할 User-Agent 패턴 목록 예시: option.userAgentRejectList=Mozilla,Opera,none IRC 서버 옵션 tunnel.N.option.ircserver.fakeHostname (option.ircserver.fakeHostname) 유형: 문자열 (hostname 패턴) 컨텍스트: IRC 서버 전용 기본값: %f.b32.i2p 토큰: %f = 전체 base32 destination(목적지) 해시 %c = 클로킹된 destination 해시 (cloakKey 참조) 설명: IRC 서버로 전송되는 호스트명 형식 예시: option.ircserver.fakeHostname=%c.irc.i2p tunnel.N.option.ircserver.cloakKey (option.ircserver.cloakKey) 유형: 문자열(패스프레이즈) 컨텍스트: IRC 서버에만 해당 기본값: 세션마다 무작위 제한 사항: 따옴표 또는 공백 사용 금지 설명: 일관된 호스트명 클로킹을 위한 패스프레이즈 사용 사례: 재시작/서버 간 지속적인 사용자 추적 예: option.ircserver.cloakKey=mysecretkey tunnel.N.option.ircserver.method (option.ircserver.method) 유형: Enum(열거형) 컨텍스트: IRC 서버 전용 기본값: user 값: user, webirc 설명: IRC 서버용 인증 방법 예시: option.ircserver.method=webirc tunnel.N.option.ircserver.webircPassword (option.ircserver.webircPassword) 유형: 문자열(비밀번호) 대상: IRC 서버 전용 필수 조건: method=webirc 제한 사항: 따옴표 또는 공백 금지 설명: WEBIRC 프로토콜(웹 기반 IRC 클라이언트를 위한 프록시 연동 프로토콜) 인증용 비밀번호 예시: option.ircserver.webircPassword=webircpass tunnel.N.option.ircserver.webircSpoofIP (option.ircserver.webircSpoofIP) 유형: 문자열 (IP 주소) 적용 대상: IRC 서버 전용 필요 조건: method=webirc 설명: WEBIRC protocol(웹 IRC 프록시 인증 프로토콜)에서 사용할 스푸핑된 IP 주소 예시: option.ircserver.webircSpoofIP=10.0.0.1 SSL/TLS 구성 tunnel.N.option.useSSL (option.useSSL) 유형: Boolean 기본값: false 적용 범위: 모든 tunnel 동작: 서버: 로컬 서버와의 연결에 SSL 사용 클라이언트: 로컬 클라이언트의 SSL 사용을 요구 예: option.useSSL=false tunnel.N.option.keystoreFile (option.keystoreFile) 유형: 문자열 (파일 경로) 컨텍스트: 클라이언트 tunnel 전용 기본값: i2ptunnel-(random).ks 경로: 절대 경로가 아니면 $(I2P_CONFIG_DIR)/keystore/ 기준 상대 경로 자동 생성: 존재하지 않으면 생성됨 설명: SSL 개인 키를 포함하는 키 저장소(keystore) 파일 예시: option.keystoreFile=my-tunnel.ks tunnel.N.option.keystorePassword (option.keystorePassword) 유형: String (비밀번호) 컨텍스트: 클라이언트 tunnels 전용 기본값: changeit 자동 생성: 새 키스토어가 생성되면 무작위 비밀번호 설명: SSL 키스토어의 비밀번호 예제: option.keystorePassword=secretpassword tunnel.N.option.keyAlias (option.keyAlias) 유형: String (별칭) 컨텍스트: 클라이언트 tunnel 전용 자동 생성: 새 키가 생성되면 자동으로 생성됨 설명: 키 저장소(keystore)의 개인 키에 대한 별칭 예시: option.keyAlias=mytunnel-key tunnel.N.option.keyPassword (option.keyPassword) 유형: 문자열(비밀번호) 컨텍스트: 클라이언트 tunnels 전용 자동 생성: 새 키를 생성하면 임의의 비밀번호가 생성됨 설명: keystore(키 저장소)에 있는 개인 키의 비밀번호 예: option.keyPassword=keypass123 일반 I2CP 및 스트리밍 옵션 모든 tunnel.N.option.* 속성(위에서 명시적으로 문서화되지 않은)은 tunnel.N.option. 접두사를 제거한 상태로 I2CP 인터페이스와 스트리밍 라이브러리로 그대로 전달됩니다.\n중요: 이는 I2PTunnel 전용 옵션과는 별개입니다. 참조: - I2CP 명세서 - 스트리밍 라이브러리 명세서 스트리밍 옵션 예시:\noption.i2cp.messageReliability=BestEffort option.i2p.streaming.connectDelay=1000 option.i2p.streaming.maxWindowSize=128 완전한 Tunnel 예제 # HTTP Proxy (split format without tunnel.N. prefix) name=I2P HTTP Proxy description=HTTP proxy for accessing I2P sites and outproxy type=httpclient interface=127.0.0.1 listenPort=4444 targetDestination= sharedClient=true startOnLoad=true # I2CP configuration i2cpHost=127.0.0.1 i2cpPort=7654 # HTTP client options option.i2ptunnel.httpclient.allowInternalSSL=false option.i2ptunnel.httpclient.disableAddressHelper=false option.i2ptunnel.httpclient.jumpServers=http://stats.i2p/cgi-bin/jump.cgi option.i2ptunnel.httpclient.sendAccept=false option.i2ptunnel.httpclient.sendReferer=false option.i2ptunnel.httpclient.sendUserAgent=false # Proxy authentication option.proxyAuth=false # Outproxy configuration option.i2ptunnel.httpclient.SSLOutproxies=false.i2p proxyList=false.i2p # Client behavior option.persistentClientKey=false option.i2cp.delayOpen=false # I2CP tunnel options option.inbound.length=3 option.outbound.length=3 option.inbound.quantity=2 option.outbound.quantity=2 버전 이력 및 기능 연대표 버전 0.9.10 (2013) Feature: 구성 파일에서 빈 값 지원 - 빈 값을 가진 키(key=)가 이제 지원됩니다 - 이전에는 무시되거나 구문 분석 오류를 일으켰습니다\n버전 0.9.18 (2015) 기능: 로거 플러시 간격 설정 - 속성: logger.flushInterval (기본값 29초) - 허용 가능한 로그 지연을 유지하면서 디스크 I/O를 줄입니다\n버전 0.9.23 (2015년 11월) 주요 변경: Java 7이 최소 요구 사항 - Java 6 지원 종료 - 지속적인 보안 업데이트를 받기 위해 필요\n버전 0.9.25 (2015) 기능: HTTP 서버 보안 옵션 - tunnel.N.option.rejectReferer - Referer 헤더가 있는 연결 거부 - tunnel.N.option.rejectUserAgents - 특정 User-Agent 헤더 거부 - tunnel.N.option.userAgentRejectList - 거부할 User-Agent 패턴 - 사용 사례: 크롤러 및 원치 않는 클라이언트 차단\n버전 0.9.33 (2018년 1월) 기능: 향상된 User-Agent(사용자 에이전트) 필터링 - userAgentRejectList 문자열 \u0026ldquo;none\u0026quot;은 빈 User-Agent와 일치 - i2psnark, i2ptunnel, streaming, SusiMail에 대한 추가 버그 수정\n버전 0.9.41 (2019) 사용 중단: Android에서 BOB Protocol이 제거됨 - Android 사용자는 SAM 또는 I2CP로 마이그레이션해야 합니다\n버전 0.9.42 (2019년 8월) 주요 변경: 구성 파일 분리 - clients.config를 clients.config.d/ 디렉터리 구조로 분리 - i2ptunnel.config를 i2ptunnel.config.d/ 디렉터리 구조로 분리 - 업그레이드 후 첫 실행 시 자동 마이그레이션 - 모듈식 패키징 및 플러그인 관리를 가능하게 함 - 기존 monolithic(단일형) 형식도 계속 지원\n추가 기능: - SSU 성능 개선 - 교차 네트워크 연결 방지 (Proposal 147) - 초기 암호화 유형 지원\n버전 0.9.56 (2021) 기능: 보안 및 로깅 개선 - logger.gzip - 로테이션된 로그에 대한 Gzip 압축 (기본값: false) - logger.minGzipSize - 압축 최소 크기 (기본값: 65536 바이트) - tunnel.N.option.proxy.auth.USER.sha256 - SHA-256 다이제스트 인증 (RFC 7616) - 보안: 다이제스트 인증에서 MD5가 SHA-256으로 대체됨\n버전 0.9.57 (2023년 1월) 기능: SOCKS outproxy(외부 프록시) 유형 구성 - tunnel.N.option.outproxyType - outproxy 유형 선택 (socks|connect) - 기본값: socks - HTTPS outproxies에 대한 HTTPS CONNECT 지원\n버전 2.6.0 (2024년 7월) 파괴적 변경: I2P-over-Tor 차단됨 - Tor 출구 노드 IP 주소에서 오는 연결은 이제 거부됩니다 - 이유: I2P 성능을 저하시키고 Tor 출구 노드 리소스를 낭비함 - 영향: Tor 출구 노드를 통해 I2P에 접근하는 사용자는 차단됩니다 - 출구가 아닌 릴레이와 Tor 클라이언트에는 영향이 없습니다\n버전 2.10.0 (2025년 9월 - 현재) 구성: 새로운 구성 속성이 추가되지 않았습니다\n중요한 예정 변경 사항: 다음 릴리스(아마 2.11.0 또는 3.0.0)는 Java 17 이상이 필요합니다\n사용 중단 및 호환성 파괴 변경 중대한 사용 중단 사항 I2P-over-Tor 접속 (버전 2.6.0+) 상태: 2024년 7월부터 차단됨 영향: Tor 출구 노드 IP에서 오는 연결이 거부됨 이유: 익명성 이점 없이 I2P 네트워크 성능을 저하시킴 대상: Tor 출구 노드만 해당되며, 릴레이나 일반 Tor 클라이언트는 해당되지 않음 대안: I2P 또는 Tor를 별도로 사용하고, 결합하지 말 것 MD5 다이제스트 인증 상태: 사용 중단됨 (SHA-256 사용) 속성: tunnel.N.option.proxy.auth.USER.md5 이유: MD5는 암호학적으로 안전하지 않음 대체: tunnel.N.option.proxy.auth.USER.sha256 (0.9.56부터) 현황: MD5는 여전히 지원되지만 권장되지 않음 구성 아키텍처 변경 사항 모놀리식 구성 파일(버전 0.9.42+) 영향 대상: clients.config, i2ptunnel.config 상태: 분할된 디렉터리 구조를 채택함에 따라 사용 중단됨 마이그레이션: 0.9.42로 업그레이드 후 첫 실행 시 자동 호환성: 레거시 형식도 계속 작동함(하위 호환) 권장 사항: 새 구성에는 분할 형식 사용 권장 Java 버전 요구사항 Java 6 지원 종료됨: 버전 0.9.23 (2015년 11월) 최소: 0.9.23부터 Java 7 필요 Java 17 요구 사항 (예정) 상태: 중대한 예정 변경 목표: 2.10.0 이후 다음 메이저 릴리스(가능성: 2.11.0 또는 3.0.0) 현재 최소 요구 버전: Java 8 조치 필요: Java 17로 마이그레이션을 준비 일정: 릴리스 노트와 함께 공지 예정 제거된 기능 BOB 프로토콜(안드로이드) 제거됨: 버전 0.9.41 플랫폼: Android 전용 대안: SAM 또는 I2CP 프로토콜 데스크톱: 데스크톱 플랫폼에서는 여전히 BOB을 사용할 수 있음 권장 마이그레이션 인증: MD5에서 SHA-256 다이제스트 인증으로 마이그레이션 구성 형식: 클라이언트와 tunnels를 위한 분리된 디렉터리 구조로 마이그레이션 Java 런타임: 다음 메이저 릴리스 이전에 Java 17 업그레이드를 계획 Tor 통합: Tor 종료 노드(Exit node)를 통해 I2P를 라우팅하지 말 것 참고 자료 공식 문서 I2P 설정 명세 - 공식 설정 파일 형식 명세 I2P 플러그인 명세 - 플러그인 설정 및 패키징 I2P 공통 구조 - 타입 매핑 - 프로토콜 데이터 직렬화 형식 Java Properties 형식 - 기본 형식 명세 소스 코드 I2P Java Router 저장소 - GitHub 미러 I2P 개발자 Gitea - 공식 I2P 소스 저장소 DataHelper.java - 구성 파일 I/O 구현 커뮤니티 자료 I2P Forum - 활발한 커뮤니티 토론과 지원 I2P Website - 공식 프로젝트 웹사이트 API 문서 DataHelper JavaDoc - 설정 파일 메서드용 API 문서 명세 상태 최신 명세 업데이트: 2023년 1월 (버전 0.9.57) 현재 I2P 버전: 2.10.0 (2025년 9월) 기술적 정확성: 명세는 2.10.0까지 유효함(호환성을 깨는 변경 사항 없음) 유지 관리: 구성 형식이 수정될 때 업데이트되는 living document(수시로 갱신되는 문서) ","description":"I2P routers 및 클라이언트를 위한 구성 옵션과 형식","id":"b6b01c53245c0e36ca08c56f843abb7f","section":"docs","title":"Router 설정","url":"/ko/docs/specs/configuration/"},{"categories":null,"content":" 사용 중단됨: SAM v1은 역사적 참고용으로만 유지됩니다. 새 애플리케이션은 SAM v3 또는 BOB 를 사용해야 합니다. 원래의 브리지는 DSA-SHA1 목적지와 제한된 옵션 집합만을 지원합니다.\n라이브러리 Java I2P 소스 트리에는 여전히 C, C#, Perl, Python용 레거시 바인딩이 포함되어 있습니다. 이들은 더 이상 유지보수되지 않으며, 주로 아카이브 호환성을 위해 배포됩니다.\n버전 협상 클라이언트는 TCP(기본값 127.0.0.1:7656)를 통해 연결하고 다음을 교환합니다:\nClient → HELLO VERSION MIN=1 MAX=1 Bridge → HELLO REPLY RESULT=OK VERSION=1.0 Java I2P 0.9.14 기준으로 MIN 매개변수는 선택 사항이며, 업그레이드된 브리지의 경우 MIN/MAX 모두 한 자리 숫자 형태(\u0026quot;3\u0026quot; 등)를 허용합니다.\n세션 생성 SESSION CREATE STYLE={STREAM|DATAGRAM|RAW} DESTINATION={name|TRANSIENT} [DIRECTION={BOTH|RECEIVE|CREATE}] [option=value]* DESTINATION=name은 sam.keys에서 항목을 로드하거나 생성합니다; TRANSIENT는 항상 임시 Destination(목적지)을 생성합니다. STYLE은 가상 스트림(TCP와 유사한), 서명된 데이터그램, 또는 원시 데이터그램을 선택합니다. DIRECTION은 스트림 세션에만 적용되며; 기본값은 BOTH입니다. 추가 키/값 쌍은 I2CP 옵션으로 전달됩니다(예: tunnels.quantityInbound=3). 브리지는 다음과 같이 응답합니다:\nSESSION STATUS RESULT=OK DESTINATION=name 실패하면 DUPLICATED_DEST, I2P_ERROR, 또는 INVALID_KEY 중 하나와 선택적 메시지를 반환합니다.\n메시지 형식 SAM 메시지는 공백으로 구분된 키/값 쌍으로 이루어진 단일 줄 ASCII 텍스트입니다. 키는 UTF‑8을 사용하며, 값은 공백을 포함할 경우 따옴표로 감쌀 수 있습니다. 이스케이프는 정의되어 있지 않습니다.\n통신 유형:\n스트림(Streams) – I2P streaming library를 통해 프록시됨 회신 가능한 데이터그램(Repliable datagrams) – 서명된 페이로드 (Datagram1) 원시 데이터그램(Raw datagrams) – 서명되지 않은 페이로드 (Datagram RAW) 0.9.14에서 추가된 옵션 DEST GENERATE는 SIGNATURE_TYPE=...를 지원합니다(예: Ed25519 등). HELLO VERSION은 MIN을 선택 사항으로 간주하며 한 자리 버전 문자열을 허용합니다 SAM v1을 언제 사용해야 하나 업데이트할 수 없는 레거시 소프트웨어와의 상호 운용을 위한 경우에만 사용하십시오. 새로운 모든 개발에는 다음을 사용하십시오:\nSAM v3 완전한 기능의 스트림/데이터그램 액세스용 BOB 목적지 관리용 (아직 제한적이지만, 더 현대적인 기능을 지원) 참고 자료 SAM v2 SAM v3 데이터그램 사양 스트리밍 프로토콜 SAM v1은 router에 구애받지 않는 애플리케이션 개발의 토대를 마련했지만, 생태계는 이미 다음 단계로 넘어갔습니다. 이 문서는 출발점이라기보다 호환성 확보를 위한 보조 자료로 취급하십시오.\n","description":"레거시 단순 익명 메시징 프로토콜(사용 중단됨)","id":"d6c20329db11e9b5a1eff3a8709b3294","section":"docs","title":"SAM v1","url":"/ko/docs/legacy/sam/"},{"categories":null,"content":" 사용 중단됨: I2P 0.6.1.31에 함께 제공된 SAM v2는 더 이상 유지보수되지 않습니다. 새로운 개발에는 SAM v3 를 사용하세요. v2가 v1에 비해 유일하게 개선된 점은 단일 SAM 연결에서 멀티플렉싱된 여러 소켓을 지원한 것이었습니다.\n버전 노트 보고된 버전 문자열은 \u0026ldquo;2.0\u0026quot;으로 유지됩니다. 0.9.14 이후로 HELLO VERSION 메시지는 한 자리 MIN/MAX 값을 허용하며 MIN 매개변수는 선택 사항입니다. DEST GENERATE가 SIGNATURE_TYPE을 지원하므로 Ed25519 목적지를 생성할 수 있습니다. 세션 기본 사항 SESSION CREATE STYLE={STREAM|DATAGRAM|RAW} DESTINATION={name|TRANSIENT} [DIRECTION={BOTH|RECEIVE|CREATE}] [option=value] 각 destination(목적지 주소)은 활성 SAM 세션을 하나만 가질 수 있습니다(스트림, 데이터그램, 또는 원시). STYLE은 가상 스트림, 서명된 데이터그램, 또는 원시 데이터그램을 선택합니다. 추가 옵션은 I2CP로 전달됩니다(예: tunnels.quantityInbound=3). 응답은 v1을 따릅니다: SESSION STATUS RESULT=OK|DUPLICATED_DEST|I2P_ERROR|INVALID_KEY. 메시지 인코딩 공백으로 구분된 key=value 쌍으로 구성된 줄 단위 ASCII 형식입니다(값은 따옴표로 감쌀 수 있습니다). 통신 유형은 v1과 동일합니다:\nI2P streaming library를 통한 스트림 회신 가능한 데이터그램 (PROTO_DATAGRAM) 원시 데이터그램 (PROTO_DATAGRAM_RAW) 사용 시기 마이그레이션할 수 없는 레거시 클라이언트 전용입니다. SAM v3는 다음을 제공합니다:\n이진 목적지 인계 (DEST GENERATE BASE64) 하위 세션 및 DHT(분산 해시 테이블) 지원 (v3.3) 향상된 오류 보고 및 옵션 협상 참고:\nSAM v1 SAM v3 데이터그램 API 스트리밍 프로토콜 ","description":"레거시 간단한 익명 메시징 프로토콜","id":"a21e46f2603ba3051f18eff26aa5084d","section":"docs","title":"SAM v2","url":"/ko/docs/legacy/samv2/"},{"categories":null,"content":"SAM v3(\u0026ldquo;Simple Anonymous Messaging\u0026rdquo;)는 현재 안정적이고 라우터 독립적인 API로, 외부 애플리케이션이 라우터 자체를 내장하지 않고도 I2P 네트워크와 통신할 수 있게 해줍니다. 스트림, 데이터그램, 원시 메시지에 대한 통합 접근을 제공하며, 비Java 소프트웨어를 위한 정식 브리지 레이어로 남아 있습니다.\n1. 개요 및 목적 SAM v3는 개발자들이 경량 TCP/UDP 프로토콜을 사용하여 어떤 언어로든 I2P 인식 소프트웨어를 구축할 수 있게 합니다. router 내부 구조를 추상화하여 TCP(7656)와 UDP(7655)를 통해 최소한의 명령어 집합을 노출합니다. Java I2P와 i2pd 모두 SAM v3 사양의 하위 집합을 구현하지만, i2pd는 2025년 현재 대부분의 3.2 및 3.3 확장 기능이 여전히 부족합니다.\n2. 버전 이력 Version Introduced Key Features 3.00.7.3 (May 2009)Streams + Datagrams; binary destinations; `SESSION CREATE STYLE=` parameter. 3.10.9.14 (Jul 2014)Signature type negotiation via `SIGNATURE_TYPE`; improved `DEST GENERATE`. 3.20.9.24 (Jan 2016)Per session encryption + tunnel options; `STREAM CONNECT ID` support. 3.30.9.25 (Mar 2016)PRIMARY / SUBSESSION architecture; multiplexing; improved datagrams. ### 명명 참고사항 Java I2P는 PRIMARY/SUBSESSION을 사용합니다. i2pd와 **I2P+**는 하위 호환성을 위해 레거시 MASTER/SUBSESSION 용어를 계속 사용합니다. 3. 핵심 워크플로우 버전 협상 HELLO VERSION MIN=3.1 MAX=3.3 HELLO REPLY RESULT=OK VERSION=3.3 목적지 생성 DEST GENERATE SIGNATURE_TYPE=7 SIGNATURE_TYPE=7 → Ed25519 (EdDSA SHA512). I2P 0.9.15 이후 강력히 권장됩니다. 세션 생성 SESSION CREATE STYLE=STREAM DESTINATION=NAME OPTION=i2cp.leaseSetEncType=4,0 OPTION=inbound.quantity=3 OPTION=outbound.quantity=3 i2cp.leaseSetEncType=4,0 → 4는 X25519 (ECIES X25519 AEAD Ratchet)이고 0은 호환성을 위한 ElGamal 폴백입니다. 일관성을 위한 명시적 tunnel 수량: Java I2P 기본값 2, i2pd 기본값 5. 프로토콜 작동 STREAM CONNECT ID=1 DESTINATION=b32address.i2p STREAM SEND ID=1 SIZE=128 STREAM CLOSE ID=1 핵심 메시지 유형에는 다음이 포함됩니다: STREAM CONNECT, STREAM ACCEPT, STREAM FORWARD, DATAGRAM SEND, RAW SEND, NAMING LOOKUP, DEST LOOKUP, PING, QUIT.\n정상 종료 QUIT 4. 구현 차이점 (Java I2P vs i2pd) Feature Java I2P 2.10.0 i2pd 2.58.0 (Sept\u0026nbsp;2025) SAM enabled by default❌ Requires manual enable in router console✅ Enabled via `enabled=true` in `i2pd.conf` Default portsTCP 7656 / UDP 7655Same AUTH / USER / PASSWORD✓ Supported✗ Not implemented PING / PONG keepalive✓ Supported✗ Not implemented QUIT / STOP / EXIT commands✓ Supported✗ Not implemented FROM_PORT / TO_PORT / PROTOCOL✓ Supported✗ Not implemented PRIMARY/SUBSESSION support✓ (since 0.9.47)✗ Absent SESSION ADD / REMOVE✓ Supported✗ Not implemented Datagram2 / Datagram3 support✓ (since 2.9.0)✗ Not implemented SSL/TLSOptional✗ None Default tunnel quantitiesInbound/outbound=2Inbound/outbound=5 **권장 사항:** 라우터 간 일관성을 보장하기 위해 항상 터널 수량을 명시적으로 지정하십시오. 5. 지원되는 라이브러리 (2025년 현황) Library Language SAM Support Maintenance Status (2025) libsam3C3.1Maintained by I2P Project (eyedeekay) i2psamC++3.1Minimal updates since 2019 sam3Go3.3Active; migrated from `eyedeekay/sam3` onrampGo3.3Actively maintained (2025) i2plibPython3.1Modern async replacement for `i2p.socket` i2p.socketPython3.2Abandoned (last release 2017) Py2pPython3.3Unverified/inactive i2p-rsRust3.1Experimental; unstable API @diva.exchange/i2p-samTypeScript / JS3.3Most actively maintained (2024–2025) I2PSharpC#3.3Functional; light maintenance ## 6. 다가오는 기능 및 새로운 기능 (2024–2025) Feature Status Introduced NAMING LOOKUP `OPTIONS=true`✓ Supported2.8.0 Datagram2 / Datagram3 formats✓ (Java only)2.9.0 Post-quantum hybrid crypto (ML KEM)Optional2.10.0 Java 17+ runtime requirementPlanned2.11.0 I2P over Tor blockingActive2.6.0 Improved floodfill selectionActive2.8.0+ ## 7. 보안 및 구성 참고사항 SAM을 127.0.0.1에만 바인딩하세요. 지속적인 서비스의 경우, 정적 키와 함께 PRIMARY 세션을 사용하세요. 기능 지원을 테스트하려면 HELLO VERSION을 사용하세요. router 활성 상태를 확인하려면 PING 또는 NAMING LOOKUP을 사용하세요. 인증되지 않은 원격 SAM 연결을 피하세요 (i2pd에는 TLS가 없음). 8. 참고 자료 및 사양 SAM v3 사양 SAM v2 (레거시) Streaming 사양 데이터그램 문서 허브 i2pd 문서 9. 요약 SAM v3는 모든 비 Java I2P 애플리케이션을 위한 권장 브리지 프로토콜입니다. 안정성, 크로스 언어 바인딩, 그리고 라우터 유형에 관계없이 일관된 성능을 제공합니다.\nSAM을 사용하여 개발할 때: - Ed25519 서명과 X25519 암호화를 사용하세요. - HELLO VERSION을 통해 기능 지원을 동적으로 확인하세요. - 특히 Java I2P와 i2pd router를 모두 지원할 때 호환성을 고려하여 설계하세요.\n","description":"비-Java I2P 애플리케이션을 위한 안정적인 브리지 프로토콜","id":"dd6d27c1d72fe7c4333dc148d132f546","section":"docs","title":"SAM v3","url":"/ko/docs/api/samv3/"},{"categories":null,"content":" 주의: SOCKS tunnel은 애플리케이션 페이로드를 정제하지 않고 그대로 전달합니다. 많은 프로토콜이 IP, 호스트명 또는 기타 식별자를 유출합니다. 익명성에 대해 검증된 소프트웨어에서만 SOCKS를 사용하십시오.\n1. 개요 I2P는 I2PTunnel 클라이언트를 통해 아웃바운드 연결을 위한 SOCKS 4, 4a, 5 프록시를 지원합니다. 이를 통해 일반 애플리케이션이 I2P 목적지에 접근할 수 있지만 클리어넷에는 접근할 수 없습니다. SOCKS outproxy가 없으며, 모든 트래픽은 I2P 네트워크 내에 머물러 있습니다.\n구현 요약 Parameter Java I2P i2pd Default Port User-defined 127.0.0.1:4447 Supported SOCKS Versions 4, 4a, 5 4, 4a, 5 UDP Mode Stubbed (non-functional) Stubbed (non-functional) Persistent Keys ✅ Since 0.9.9 ✅ Shared Client Tunnels Supported Supported Outproxy Support ❌ None ❌ None **지원되는 주소 유형:** - `.i2p` 호스트명 (주소록 항목) - Base32 해시 (`.b32.i2p`) - Base64 또는 일반 인터넷 지원 없음 2. 보안 위험 및 제한사항 애플리케이션 계층 유출 SOCKS는 애플리케이션 계층 아래에서 작동하므로 프로토콜을 정제할 수 없습니다. 많은 클라이언트(예: 브라우저, IRC, 이메일)는 IP 주소, 호스트명 또는 시스템 세부 정보를 노출하는 메타데이터를 포함합니다.\n일반적인 정보 유출에는 다음이 포함됩니다: - 메일 헤더 또는 IRC CTCP 응답의 IP 주소 - 프로토콜 페이로드의 실명/사용자명 - OS 지문이 포함된 User-agent 문자열 - 외부 DNS 쿼리 - WebRTC 및 브라우저 원격 측정\nI2P는 이러한 유출을 방지할 수 없습니다—이는 tunnel 계층 위에서 발생합니다. 감사된 클라이언트에서만 익명성을 위해 설계된 SOCKS를 사용하세요.\n공유 터널 신원 여러 애플리케이션이 하나의 SOCKS 터널을 공유하는 경우, 동일한 I2P destination identity를 공유하게 됩니다. 이는 서로 다른 서비스 간에 상관관계 분석이나 핑거프린팅을 가능하게 합니다.\n완화 방법: 각 애플리케이션에 대해 **공유되지 않는 터널(non-shared tunnels)**을 사용하고 **영구 키(persistent keys)**를 활성화하여 재시작 시에도 일관된 암호화 식별자를 유지하세요.\nUDP 모드 스텁 처리됨 SOCKS5의 UDP 지원은 구현되어 있지 않습니다. 프로토콜은 UDP 기능을 알리지만, 호출은 무시됩니다. TCP 전용 클라이언트를 사용하십시오.\n설계상 Outproxy 없음 Tor와 달리, I2P는 SOCKS 기반 clearnet outproxy를 제공하지 않습니다. 외부 IP에 접근하려는 시도는 실패하거나 신원을 노출시킬 수 있습니다. outproxy가 필요한 경우 HTTP 또는 HTTPS 프록시를 사용하세요.\n3. 역사적 맥락 개발자들은 오랫동안 익명 사용을 위한 SOCKS 사용을 권장하지 않았습니다. 내부 개발자 토론 및 2004년 Meeting 81 과 Meeting 82 에서:\n\u0026ldquo;임의의 트래픽을 전달하는 것은 안전하지 않으며, 익명성 소프트웨어 개발자로서 우리는 최종 사용자의 안전을 최우선으로 고려해야 합니다.\u0026rdquo;\nSOCKS 지원은 호환성을 위해 포함되었지만 프로덕션 환경에서는 권장되지 않습니다. 거의 모든 인터넷 애플리케이션은 익명 라우팅에 적합하지 않은 민감한 메타데이터를 유출합니다.\n4. 설정 Java I2P I2PTunnel Manager 를 엽니다 \u0026ldquo;SOCKS 4/4a/5\u0026rdquo; 유형의 새 클라이언트 tunnel을 생성합니다 옵션을 구성합니다: 로컬 포트 (사용 가능한 포트) Shared client: 앱별로 별도의 신원을 사용하려면 비활성화 Persistent key: 키 상관관계를 줄이려면 활성화 tunnel을 시작합니다 i2pd i2pd는 기본적으로 127.0.0.1:4447에서 활성화된 SOCKS5 지원을 포함합니다. i2pd.conf의 [SOCKSProxy] 섹션에서 포트, 호스트 및 tunnel 매개변수를 조정할 수 있습니다.\n5. 개발 일정 Version Change Date 0.7.1 Initial SOCKS 4/4a/5 support 2010 0.9.9 Added persistent keying 2013 1.7.0 BOB API deprecated and removed 2022 2.6.0 I2P-over-Tor blocked to improve network health 2024 2.10.0 Post-quantum hybrid encryption introduced 2025 SOCKS 모듈 자체는 2013년 이후 주요 프로토콜 업데이트가 없었지만, 주변 tunnel 스택은 성능 및 암호화 개선을 받았습니다. 6. 권장 대안 프로덕션, 공개, 또는 보안 중요 애플리케이션의 경우, SOCKS 대신 공식 I2P API 중 하나를 사용하세요:\nAPI Description Recommended For SAM v3 (3.3) Simple Anonymous Messaging API Cross-language apps needing socket-like I/O Streaming Library TCP-like sockets for Java Native Java integrations I2CP Low-level router communication Custom protocols, router-level integration BOB Deprecated (removed 2022) Legacy only; migrate to SAM 이러한 API는 적절한 목적지 격리, 암호화 신원 제어, 그리고 향상된 라우팅 성능을 제공합니다. 7. OnionCat / GarliCat OnionCat은 GarliCat 모드(fd60:db4d:ddb5::/48 IPv6 범위)를 통해 I2P를 지원합니다. 여전히 작동하지만 2019년 이후 개발이 제한적입니다.\n사용 시 주의사항: - SusiDNS에서 수동으로 .oc.b32.i2p 설정 필요 - 고정 IPv6 할당 필요 - I2P 프로젝트에서 공식적으로 지원하지 않음\n고급 VPN-over-I2P 설정에만 권장됩니다.\n8. 모범 사례 SOCKS를 반드시 사용해야 하는 경우: 1. 애플리케이션별로 별도의 tunnel을 생성하세요. 2. 공유 클라이언트 모드를 비활성화하세요. 3. 영구 키를 활성화하세요. 4. SOCKS5 DNS 확인을 강제하세요. 5. 유출에 대한 프로토콜 동작을 감사하세요. 6. 클리어넷 연결을 피하세요. 7. 유출에 대한 네트워크 트래픽을 모니터링하세요.\n9. 기술 요약 Parameter Value Supported SOCKS Versions 4, 4a, 5 Transport TCP only UDP Support Stubbed (non-functional) Clearnet Access Not supported Default Ports Java I2P: user-set; i2pd: 127.0.0.1:4447 Persistent Keying Supported since 0.9.9 Shared Tunnels Supported (discouraged) --- 10. 결론 I2P의 SOCKS 프록시는 기존 TCP 애플리케이션과의 기본적인 호환성을 제공하지만 강력한 익명성 보장을 위해 설계되지 않았습니다. 통제되고 감사된 테스트 환경에서만 사용해야 합니다.\n실제 배포 환경에서는 SAM v3 또는 Streaming API로 마이그레이션하세요. 이러한 API는 애플리케이션 식별자를 격리하고, 최신 암호화 기술을 사용하며, 지속적인 개발이 이루어지고 있습니다.\n추가 자료 공식 SOCKS 문서 SAM v3 사양 Streaming Library 문서 I2PTunnel 참조 I2P 개발자 문서 커뮤니티 포럼 ","description":"I2P의 SOCKS tunnel을 안전하게 사용하기 (2.10.0 업데이트)","id":"e71093f25f593f15b6820398338abc89","section":"docs","title":"SOCKS 프록시","url":"/ko/docs/api/socks/"},{"categories":null,"content":" 사용 중단됨: SSU는 SSU2로 대체되었습니다. 지원은 i2pd 2.44.0 (API 0.9.56, 2022년 11월) 및 Java I2P 2.4.0 (API 0.9.61, 2023년 12월)에서 제거되었습니다.\nSSU는 혼잡 제어, NAT 트래버설, 그리고 introducer(소개자 노드) 지원을 포함한 UDP 기반의 반신뢰성 전송을 제공했다. 이는 NAT/방화벽 뒤에 있는 router를 처리하고 IP 주소 확인을 조정함으로써 NTCP를 보완했다.\n주소 구성 요소 transport: SSU caps: 기능 플래그 (B, C, 4, 6, 등) host / port: IPv4 또는 IPv6 리스너(방화벽 뒤에 있을 때는 선택 사항) key: Base64 introduction key(소개 키) mtu: 선택 사항; 기본값 1484(IPv4) / 1488(IPv6) ihost/ikey/iport/itag/iexp: router가 방화벽 뒤에 있을 때의 introducer 항목(소개자) 기능 introducer(소개자)를 이용한 협력적 NAT 트래버설 피어 테스트와 인바운드 패킷 검사를 통한 로컬 IP 감지 방화벽 상태를 다른 트랜스포트(전송 방식)와 router 콘솔로 자동 중계 준신뢰성 전달: 메시지를 한도까지 재전송한 뒤 폐기 가산 증가/승수 감소와 프래그먼트 ACK 비트필드를 사용하는 혼잡 제어 SSU는 타이밍 비콘과 MTU 협상과 같은 메타데이터 관련 작업도 처리했습니다. 모든 기능은 이제 (최신 암호기술을 사용하여) SSU2 에 의해 제공됩니다.\n","description":"기존 Secure Semireliable UDP(보안 반신뢰성 UDP) 전송","id":"15d4d0ea2bfc8074b5a7981b8673c420","section":"docs","title":"SSU (레거시)","url":"/ko/docs/legacy/ssu/"},{"categories":null,"content":" 사용 중단됨: SSU (Secure Semi-Reliable UDP)는 SSU2 로 대체되었습니다. Java I2P는 2.4.0 릴리스 (API 0.9.61)에서 SSU를 제거했고, i2pd는 2.44.0 (API 0.9.56)에서 제거했습니다. 이 문서는 역사적 참고용으로만 보관됩니다.\n주요 내용 I2NP 메시지를 암호화되고 인증된 점대점 방식으로 전달하는 UDP 전송. 2048비트 Diffie–Hellman 핸드셰이크(ElGamal과 동일한 소수 사용)에 의존했다. 각 데이터그램에는 16바이트 HMAC-MD5(비표준 축약 변형)와 16바이트 IV가 포함되었고, 그 뒤에 AES-256-CBC로 암호화된 페이로드가 이어졌다. 재전송 공격 방지와 세션 상태는 암호화된 페이로드 내부에서 추적되었다. 메시지 헤더 [16-byte MAC][16-byte IV][encrypted payload] 사용된 MAC(메시지 인증 코드) 계산: HMAC-MD5(ciphertext || IV || (len ^ version ^ ((netid-2)\u0026lt;\u0026lt;8)))에 32바이트 MAC 키를 사용했다. 페이로드 길이는 MAC 계산 내에서 빅엔디언 16비트로 추가되었다. 프로토콜 버전의 기본값은 0, netId의 기본값은 2(메인 네트워크)였다.\n세션 및 MAC 키 DH 공유 비밀에서 파생됨:\n공유 값을 빅엔디언 바이트 배열로 변환합니다(최상위 비트가 설정된 경우 0x00을 앞에 붙입니다). 세션 키: 처음 32바이트(더 짧으면 0으로 채웁니다). MAC 키: 바이트 33–64; 부족하면 공유 값의 SHA-256 해시로 대체합니다. 상태 Routers는 더 이상 SSU 주소를 광고하지 않습니다. 클라이언트는 SSU2 또는 NTCP2 전송 프로토콜로 이전해야 합니다. 과거 구현은 이전 릴리스에서 확인할 수 있습니다:\nrouter/transport/udp 아래에 있는 2.4.0 이전 Java 소스 코드 2.44.0 이전의 i2pd 소스 코드 현재 UDP 전송 동작에 대해서는 SSU2 specification 을 참조하세요.\n","description":"SSU2 도입 이전에 사용되던 기존 UDP 전송","id":"1eefecf66e3adc6ea013d5a5e58326da","section":"docs","title":"SSU 전송 (사용 중단됨)","url":"/ko/docs/legacy/ssu/"},{"categories":null,"content":"1. 개요 SSU2는 I2P에서 보안적이고 준신뢰성을 갖춘 router 간 통신에 사용되는 UDP 기반 전송 계층 프로토콜이다. 이는 범용 전송 프로토콜이 아니라 I2NP 메시지 교환에 특화되어 있다.\n핵심 기능 Noise XK pattern(Noise 프로토콜의 XK 패턴)을 통한 인증된 키 교환 DPI(패킷 심층 검사) 저항성을 위한 암호화된 헤더 중계와 hole-punching(홀 펀칭)을 사용하는 NAT(네트워크 주소 변환) 트래버설 연결 마이그레이션 및 주소 검증 선택적 경로 검증 순방향 기밀성 및 재생 공격 방지 레거시 및 호환성 Implementation SSU2 Default SSU1 Removed i2pd2.44.02.44.0 Java I2P0.9.560.9.61 SSU1은 공개 I2P 네트워크에서는 더 이상 사용되지 않습니다. 2. 암호학 SSU2(I2P 전송 프로토콜)는 I2P 특화 확장과 함께 Noise_XK_25519_ChaChaPoly_SHA256을 사용한다.\nFunction Algorithm Notes Diffie-HellmanX25519 (RFC 7748)32-byte keys CipherChaCha20/Poly1305 (RFC 7539)AEAD encryption HashSHA-256Used for key derivation and message integrity KDFHKDF-SHA256 (RFC 5869)For session and header keys 헤더와 페이로드는 `mixHash()`를 통해 암호학적으로 결합된다. 구현 효율을 위해 모든 암호학적 프리미티브는 NTCP2와 ECIES(타원곡선 통합 암호화 체계)에서 공통으로 사용된다. 3. 메시지 개요 3.1 UDP 데이터그램 규칙 각 UDP 데이터그램에는 정확히 하나의 SSU2 message만 포함된다. Session Confirmed 메시지(세션 확인 메시지)는 여러 데이터그램에 걸쳐 단편화될 수 있다. 최소 크기: 40 바이트 최대 크기: 1472 바이트 (IPv4) / 1452 바이트 (IPv6)\n3.2 메시지 유형 Type Message Header Description 0Session Request32BHandshake initiation 1Session Created32BHandshake response 2Session Confirmed16BFinal handshake, may be fragmented 6Data16BEncrypted I2NP message blocks 7Peer Test32BNAT reachability testing 9Retry32BToken or rejection notice 10Token Request32BRequest for validation token 11Hole Punch32BNAT traversal signaling --- 4. 세션 수립 4.1 표준 흐름 (유효 토큰) Alice Bob SessionRequest ─────────────\u0026gt; \u0026lt;────────────── SessionCreated SessionConfirmed ────────────\u0026gt; 4.2 토큰 획득 Alice Bob TokenRequest ───────────────\u0026gt; \u0026lt;────────────── Retry (Token) SessionRequest ─────────────\u0026gt; \u0026lt;────────────── SessionCreated SessionConfirmed ────────────\u0026gt; 4.3 잘못된 토큰 Alice Bob SessionRequest ─────────────\u0026gt; \u0026lt;────────────── Retry (Termination) 5. 헤더 구조 5.1 긴 헤더 (32바이트) 세션 수립 전에 사용됨 (SessionRequest, Created, Retry, PeerTest, TokenRequest, HolePunch).\nField Size Description Destination Connection ID8Random unique ID Packet Number4Random (ignored during handshake) Type1Message type Version1Always 2 NetID12 = main I2P network Flags1Reserved (0) Source Connection ID8Random ID distinct from destination Token8Token for address validation ### 5.2 짧은 헤더 (16바이트) 수립된 세션에서 사용됩니다(SessionConfirmed, Data).\nField Size Description Destination Connection ID8Stable throughout session Packet Number4Incrementing per message Type1Message type (2 or 6) Flags3ACK/fragment flags --- 6. 암호화 6.1 AEAD(연관 데이터가 있는 인증 암호화) 모든 페이로드는 ChaCha20/Poly1305 AEAD로 암호화됩니다:\nciphertext = ChaCha20_Poly1305_Encrypt(key, nonce, plaintext, associated_data) 논스: 12바이트 (0 4바이트 + 카운터 8바이트) 태그: 16바이트 연관 데이터: 무결성 바인딩을 위한 헤더를 포함 6.2 헤더 보호 헤더는 세션 헤더 키에서 유도된 ChaCha20 키스트림을 사용해 마스킹된다. 이는 모든 연결 ID와 패킷 필드가 무작위처럼 보이도록 해 DPI(Deep Packet Inspection, 심층 패킷 검사)에 대한 저항성을 제공한다.\n6.3 키 유도 Phase Input Output InitialintroKey + salthandshake header key HandshakeDH(X25519)chainKey + AEAD key Data phasechainKeyTX/RX keys Key rotationoldKeynewKey --- 7. 보안 및 리플레이 공격 방지 토큰은 IP별로 발급되며, 약 60초 후 만료됩니다. 세션별 블룸 필터를 통해 재전송(Replay) 공격을 방지합니다. 중복된 임시 키는 거부됩니다. 헤더와 페이로드는 암호학적으로 결합되어 있습니다. 모든 router는 AEAD 인증에 실패했거나 버전 또는 NetID가 유효하지 않은 패킷을 폐기해야 한다.\n8. 패킷 번호 매기기 및 세션 수명 각 방향은 자체 32비트 카운터를 유지합니다. - 0에서 시작하며, 패킷마다 증가합니다. - wrap(카운터가 최댓값을 넘겨 0으로 되돌아가는 현상)이 발생하면 안 됩니다; 2³²에 도달하기 전에 세션 rekey(세션 키 재설정) 또는 종료를 해야 합니다.\n연결 ID는 마이그레이션 중을 포함하여 세션 전체 동안 변하지 않습니다.\n9. 데이터 단계 유형 = 6 (데이터) 짧은 헤더 (16바이트) 페이로드에는 하나 이상의 암호화된 블록이 포함합니다: ACK/NACK 목록 I2NP 메시지 조각 패딩 (0–31바이트 임의값) 종료 블록 (선택 사항) 선택적 재전송과 순서가 뒤바뀐 전달을 지원합니다. 신뢰성은 \u0026lsquo;semi-reliable\u0026rsquo;(준신뢰적) 수준으로 유지되며, 재시도 한도를 초과하면 누락된 패킷은 별도 알림 없이 폐기될 수 있습니다.\n10. 릴레이 및 NAT 트래버설 Message Type Purpose Peer Test7Determines inbound reachability Retry9Issues new token or rejection Token Request10Requests new address token Hole Punch11Coordinates NAT hole punching 릴레이 router는 이러한 제어 메시지를 사용하여 제한적인 NAT(네트워크 주소 변환) 뒤에 있는 피어를 지원합니다. 11. 세션 종료 어느 쪽 피어든 Data message 내의 Termination block(종료 블록)을 사용하여 세션을 종료할 수 있다. 수신 즉시 리소스를 해제해야 한다. 재전송된 종료 패킷은 승인을 받은 후에는 무시해도 된다.\n12. 구현 지침 Routers MUST: - version = 2 및 NetID = 2임을 검증한다. - 40바이트 미만의 패킷이거나 AEAD(연관 데이터가 있는 인증된 암호화)가 유효하지 않은 경우 폐기한다. - 120초 리플레이 캐시를 강제한다. - 재사용된 토큰 또는 에페메랄 키를 거부한다.\nRouters는 권장합니다: - 패딩 길이를 0–31바이트 범위에서 무작위로 설정합니다. - 적응형 재전송을 사용합니다(RFC 6298). - 마이그레이션 전에 피어별 경로 검증을 구현합니다.\n13. 보안 요약 Property Achieved By Forward secrecyX25519 ephemeral keys Replay protectionTokens + Bloom filter Authenticated encryptionChaCha20/Poly1305 KCI resistanceNoise XK pattern DPI resistanceEncrypted headers NAT traversalRelay + Hole Punch MigrationStatic connection IDs --- 14. 참고 문헌 제안 159 – SSU2 Noise 프로토콜 프레임워크 RFC 9000 – QUIC 전송 RFC 9001 – QUIC용 TLS RFC 7539 – ChaCha20/Poly1305 AEAD(연관 데이터 인증 암호화) RFC 7748 – X25519 ECDH RFC 5869 – HKDF-SHA256 ","description":"보안 준신뢰형 UDP 전송 프로토콜 버전 2","id":"b45756033b706b68daaee09f536f3c91","section":"docs","title":"SSU2 명세서","url":"/ko/docs/specs/ssu2/"},{"categories":null,"content":" Scope: 이 가이드는 tunnel 구현, 메시지 형식, 그리고 두 가지 tunnel 생성 사양(ECIES 및 레거시 ElGamal)을 통합합니다. 기존 딥 링크는 위의 별칭을 통해 계속 작동합니다.\nTunnel 모델 I2P는 단방향 tunnels을 통해 페이로드를 전달합니다: 이는 단일 방향으로 트래픽을 운반하는 routers의 순서 있는 집합입니다. 두 목적지 간의 완전한 왕복 통신에는 네 개의 tunnels(발신 2개, 수신 2개)가 필요합니다.\n용어는 Tunnel 개요 부터 살펴보고, 운용 세부 사항은 이 가이드를 참고하세요.\n메시지 라이프사이클 tunnel 게이트웨이는 하나 이상의 I2NP 메시지를 일괄 처리하고, 이를 분할하며, 전달 지시를 작성한다. 게이트웨이는 페이로드를 고정 크기(1024 B)의 tunnel 메시지로 캡슐화하고, 필요 시 패딩을 추가한다. 각 참여자는 이전 홉을 검증하고, 자신의 암호화 계층을 적용하며, {nextTunnelId, nextIV, encryptedPayload}를 다음 홉으로 전달한다. tunnel 엔드포인트는 마지막 계층을 제거하고, 전달 지시를 처리하며, 조각을 재조립하고, 재구성된 I2NP 메시지를 전달한다. 중복 감지는 IV(초기화 벡터)와 첫 번째 암호문 블록의 배타적 OR 결과를 키로 사용하는 감쇠형 블룸 필터를 이용하여 IV 교체에 기반한 태깅 공격을 방지한다.\n역할 한눈에 보기 Role Pre-processing Crypto Operation Post-processing Outbound gateway (creator) Fragment, batch, pad Iteratively decrypt using every hop’s keys (so downstream peers encrypt) Forward to first hop Participant — Encrypt IV and payload with hop keys Forward to next hop Outbound endpoint — Encrypt once more to reveal plaintext payload Deliver to target tunnel/destination Inbound gateway Fragment, batch, pad Encrypt with local keys Forward to next hop Inbound endpoint (creator) — Iteratively decrypt using stored hop keys Reassemble and deliver locally ### 암호화 워크플로우 {#encryption-workflow} 인바운드 tunnels: 게이트웨이가 자신의 레이어 키로 한 번 암호화하고, 다운스트림 참가자들은 생성자가 최종 페이로드를 복호화할 때까지 계속 암호화를 덧씌운다. 아웃바운드 tunnels: 게이트웨이는 각 홉의 암호화에 대한 역연산을 미리 적용하여, 그 결과 각 참가자가 암호화한다. 엔드포인트가 암호화하면, 게이트웨이가 보낸 원래 평문이 드러난다. 양방향 모두 {tunnelId, IV, encryptedPayload}를 다음 홉으로 전달한다.\nTunnel 메시지 형식 tunnel 게이트웨이는 페이로드 길이를 숨기고 홉 단위 처리를 단순화하기 위해 I2NP 메시지를 여러 개의 고정 크기 봉투로 분할한다.\n암호화된 레이아웃 +----------------+----------------+-------------------+ | Tunnel ID (4B) | IV (16B) | Encrypted payload | +----------------+----------------+-------------------+ Tunnel ID – 다음 홉을 위한 32비트 식별자(0이 아니며, 각 빌드 사이클마다 변경됨). IV(초기화 벡터) – 메시지마다 선택되는 16바이트 AES IV. 암호화된 페이로드 – 1008바이트의 AES-256-CBC 암호문. 총 크기: 1028 바이트.\n복호화된 레이아웃 한 홉이 자신의 암호화 계층을 제거한 후:\n[Checksum (4B)][Padding ... 0x00 terminator] [Delivery Instructions 1][I2NP fragment 1] [Delivery Instructions 2][I2NP fragment 2] ... 체크섬은 복호화된 블록을 검증합니다. 패딩은 0이 아닌 임의의 바이트로 이루어지며 마지막은 0 바이트로 종료됩니다. 전달 지침은 엔드포인트(종단점)에게 각 프래그먼트를 어떻게 처리할지 알려줍니다(로컬 전달, 다른 tunnel로 전달 등). 프래그먼트는 하위의 I2NP 메시지를 운반합니다; 엔드포인트는 이를 상위 계층으로 전달하기 전에 재조립합니다. 처리 단계 게이트웨이는 I2NP 메시지를 단편화하여 큐에 넣고, 재조립을 위해 부분 조각을 잠시 보관합니다. 게이트웨이는 적절한 레이어 키로 페이로드를 암호화하고, tunnel ID와 IV(초기화 벡터)를 설정합니다. 각 참가자는 IV(AES-256/ECB)를 암호화한 다음 페이로드(AES-256/CBC)를 암호화하고, 이어서 IV를 재암호화한 후 메시지를 전달합니다. 엔드포인트는 역순으로 복호화한 뒤 체크섬을 검증하고, 전달 지시를 처리하여 조각을 재조립합니다. Tunnel 생성 (ECIES-X25519) 최신 routers는 ECIES-X25519 키를 사용해 tunnels을 구축하여 빌드 메시지를 축소하고 전방향 보안성을 가능하게 합니다.\n빌드 메시지: 단일 TunnelBuild(또는 VariableTunnelBuild) I2NP 메시지는 홉당 하나씩, 암호화된 빌드 레코드 1–8개를 담아 운반한다. 레이어 키: 생성자는 홉의 정적 X25519 신원 키와 생성자의 에페메럴(임시) 키를 사용하여 HKDF로 홉별 레이어 키, IV, 회신 키를 도출한다. 처리: 각 홉은 자신의 레코드를 복호화하고, 요청 플래그를 검증한 뒤, 회신 블록(성공 또는 상세 실패 코드)을 기록하고, 남은 레코드들을 재암호화하여 메시지를 다음으로 전달한다. 회신: 생성자는 garlic encryption(갈릭 암호화)으로 래핑된 회신 메시지를 수신한다. 실패로 표시된 레코드에는 router가 피어를 프로파일링할 수 있도록 심각도 코드가 포함된다. 호환성: router는 하위 호환성을 위해 여전히 레거시 ElGamal 빌드를 허용할 수 있지만, 새로운 tunnel은 기본적으로 ECIES를 사용한다. 필드별 상수와 키 파생 관련 노트는 ECIES(타원곡선 통합 암호화 방식) 제안 이력과 router 소스 코드를 참조하세요; 이 가이드는 동작 흐름을 다룹니다.\n레거시 Tunnel 생성 (ElGamal-2048) 원래 tunnel 빌드 형식은 ElGamal 공개 키를 사용했다. 최신 router들은 하위 호환성을 위해 제한적인 지원을 유지한다.\n상태: 폐기됨. 역사적 참고용 및 레거시 호환 도구를 유지 관리하는 이들을 위해 여기 보존되어 있습니다.\n비대화형 망원경식 확장: 단일 빌드 메시지가 전체 경로를 따라 이동한다. 각 홉은 자신에게 해당하는 528바이트 레코드를 복호화하고 메시지를 갱신한 뒤 이를 전달한다. 가변 길이: Variable Tunnel Build Message (VTBM, 가변 Tunnel 빌드 메시지)은 1–8개의 레코드를 허용했다. 이전의 고정형 메시지는 tunnel 길이를 숨기기 위해 항상 8개의 레코드를 포함했다. 요청 레코드 레이아웃: Bytes 0–3 : Tunnel ID (receiving ID) Bytes 4–35 : Current hop router hash Bytes 36–39 : Next tunnel ID Bytes 40–71 : Next hop router hash Bytes 72–103 : AES-256 layer key Bytes 104–135: AES-256 IV key Bytes 136–167: AES-256 reply key Bytes 168–183: AES-256 reply IV Byte 184 : Flags (bit7=IBGW, bit6=OBEP) Bytes 185–188: Request time (hours since epoch) Bytes 189–192: Next message ID Bytes 193–221: Padding 플래그: 비트 7은 inbound gateway (IBGW)를 나타내며; 비트 6은 outbound endpoint (OBEP)를 지정합니다. 둘은 서로 배타적입니다. 암호화: 각 레코드는 해당 홉의 공개키로 ElGamal-2048로 암호화됩니다. 대칭 AES-256-CBC 계층화는 의도된 홉만 그 레코드를 읽을 수 있도록 보장합니다. 핵심 사실: tunnel ID는 0이 아닌 32비트 값입니다; 생성자는 실제 tunnel 길이를 숨기기 위해 더미 레코드를 삽입할 수 있습니다; 신뢰성은 실패한 빌드를 재시도하는 데 달려 있습니다. Tunnel 풀과 수명 주기 각 router는 탐색 트래픽과 각 I2CP 세션 각각에 대해 독립적인 수신 및 발신 tunnel 풀을 유지합니다.\n피어 선택: exploratory tunnel은 다양성을 높이기 위해 “active, not failing” 피어 버킷에서 선택하고; client tunnel은 빠르고 고용량의 피어를 선호합니다. 결정적 정렬: 피어는 SHA256(peerHash || poolKey)와 풀의 랜덤 키 사이의 XOR 거리로 정렬됩니다. 키는 재시작 시 교체되어, 단일 실행 동안에는 안정성을 제공하면서 실행 간에는 predecessor attacks(선행자 공격)을 저해합니다. 수명 주기: routers는 {mode, direction, length, variance} 튜플별로 과거 빌드 시간을 추적합니다. tunnel의 만료가 가까워지면 교체를 일찍 시작하고; 실패가 발생하면 router는 병렬 빌드를 늘리되, 진행 중인 시도 건수에는 상한을 둡니다. 구성 조절 항목: 활성/백업 tunnel 개수, 홉 길이와 분산, zero-hop 허용, 빌드 속도 제한은 모두 풀별로 조정 가능합니다. 혼잡과 신뢰성 tunnels는 회로와 유사하지만, routers는 그것들을 메시지 큐로 취급한다. 지연 시간을 일정 범위로 제한하기 위해 가중치 랜덤 조기 폐기(WRED)가 사용된다:\n사용률이 설정된 한계값에 가까워질수록 드롭 확률이 상승합니다. 참여자들은 고정 크기 프래그먼트를 고려하며; 게이트웨이/엔드포인트는 결합된 프래그먼트 크기를 기준으로 드롭하여 큰 페이로드를 우선적으로 드롭합니다. 네트워크 자원 낭비를 최소화하기 위해 아웃바운드 엔드포인트가 다른 역할보다 먼저 드롭합니다. 보장된 전달은 Streaming library(스트리밍 라이브러리) 와 같은 상위 계층에 맡겨집니다. 신뢰성이 필요한 애플리케이션은 재전송과 승인(acknowledgment)을 스스로 처리해야 합니다.\n추가 참고 자료 피어 선택 Tunnel 개요 이전 Tunnel 구현 ","description":"I2P tunnels를 통해 트래픽을 생성, 암호화 및 전송하기 위한 통합 사양.","id":"6fb0b76b8bc10fa3e571b748f502baaa","section":"docs","title":"Tunnel 운영 가이드","url":"/ko/docs/specs/implementation/"},{"categories":null,"content":" 참고: 이 아카이브에는 I2P 0.9.41 이전의 탐색적 설계 작업이 수록되어 있습니다. 프로덕션 구현에 대해서는 tunnel documentation 를 참조하십시오.\n설정 대안 향후 tunnel 조정 옵션으로 고려된 아이디어는 다음과 같다:\n메시지 전달을 위한 빈도 제한 패딩 정책(chaff injection(채프 주입) 포함) tunnel 수명 제어 페이로드 전송을 위한 배치 및 큐 전략 이러한 옵션들은 레거시 구현과 함께 제공되지 않았다.\n패딩 전략 논의된 잠재적 패딩 접근 방식:\n패딩을 전혀 사용하지 않음 무작위 길이의 패딩 고정 길이의 패딩 가장 가까운 킬로바이트 단위까지 패딩 2의 거듭제곱(2^n 바이트)에 맞춘 패딩 초기 측정(릴리스 0.4) 결과, 현재의 고정된 1024바이트 tunnel 메시지 크기가 결정되었습니다. 상위 수준의 garlic messages(가릴릭 메시지)는 자체 패딩을 추가할 수 있습니다.\n단편화 메시지 길이를 통한 태깅 공격을 방지하기 위해 tunnel 메시지는 1024바이트로 고정됩니다. 더 큰 I2NP 페이로드는 게이트웨이에서 조각으로 분할되며, 엔드포인트가 짧은 타임아웃 내에 이를 재조립합니다. router는 전송 전에 패킹 효율을 극대화하기 위해 조각을 재배열할 수 있습니다.\n추가 대안 중간 단계에서 tunnel 처리 조정 세 가지 가능성이 검토되었다:\n복호화된 페이로드에 대한 접근을 허용하여 중간 홉이 tunnel을 일시적으로 종료할 수 있도록 한다. 참여하는 routers가 다음 홉으로 진행하기 전에 메시지를 자신의 아웃바운드 tunnels 중 하나로 보내 “remix”할 수 있도록 허용한다. tunnel 생성자가 피어의 다음 홉을 동적으로 재정의할 수 있도록 한다. 양방향 Tunnels 인바운드와 아웃바운드 tunnel을 분리하면 어떤 단일 피어 집합이 관찰할 수 있는 정보가 제한된다(예: GET 요청 vs. 대용량 응답). 양방향 tunnel은 피어 관리가 단순해지지만, 양 방향 모두에 전체 트래픽 패턴을 동시에 노출한다. 따라서 단방향 tunnel이 선호되는 설계로 유지되었다.\nBackchannels(역방향 채널)과 가변 크기 tunnel 메시지 크기를 가변적으로 허용하면 공모하는 피어들 사이에 은닉 채널이 가능해진다(예: 선택된 크기 또는 빈도를 통해 데이터를 인코딩). 고정 크기 메시지는 추가 패딩 오버헤드를 대가로 이러한 위험을 완화한다.\nTunnel 구축의 대안 참고: 공개 환경에서의 해싱 레거시 “병렬” 빌드 방법 릴리스 0.6.1.10 이전에는 tunnel 구축 요청은 각 참여자에게 병렬로 전송되었다. 이 방식은 이전 tunnel 페이지 에 문서화되어 있다.\n원샷 망원경식 구축(현재 방식) 현대적인 접근법은 부분적으로 구축된 tunnel을 통해 빌드 메시지를 홉별로 전달한다. Tor의 telescoping(연결을 홉 단위로 단계적으로 확장하는 기법)과 유사하지만, 빌드 메시지를 탐색용 tunnel을 통해 라우팅하면 정보 누출이 줄어든다.\n“대화형” 텔레스코핑 명시적인 왕복 통신을 통해 한 번에 한 홉씩 구축하는 방식은 피어들이 메시지 수를 세어 tunnel 내에서 자신의 위치를 추론할 수 있게 하므로, 이 접근법은 채택되지 않았다.\n비탐색 관리 tunnels 하나의 제안은 build traffic(터널 구축 시 발생하는 트래픽)을 위해 관리용 tunnels의 별도 풀을 유지하는 것이었다. 이는 분할된 routers에는 도움이 될 수 있지만, 네트워크 통합이 충분하다면 불필요하다고 판단되었다.\n탐색 전달(레거시) 0.6.1.10 이전에는 개별 tunnel 요청이 garlic encryption으로 암호화되어 탐색용 tunnel을 통해 전달되었고, 응답은 별도로 반환되었다. 이 전략은 현재의 one-shot telescoping(단일 시도로 단계적 확장을 수행하는 방식)으로 대체되었다.\n핵심 요점 고정 크기 tunnel 메시지는 추가 패딩 비용에도 불구하고 크기 기반 태깅과 은닉 채널을 방어한다. 대체 패딩, 단편화, 그리고 구축 전략도 검토되었지만, 익명성 트레이드오프를 감안했을 때 채택되지 않았다. tunnel 설계는 효율성, 관측 가능성, 그리고 선행자 공격과 혼잡 공격에 대한 저항성 사이의 균형을 지속적으로 맞춘다. ","description":"tunnel 패딩, 단편화, 그리고 구축 전략에 대한 역사적 탐구","id":"e5773155afe129d73b1384e5c116ec56","section":"docs","title":"Tunnel 토론","url":"/ko/docs/legacy/tunnel/"},{"categories":null,"content":"개요 이 명세서는 I2P에서의 UDP BitTorrent announce(트래커와 통신하기 위해 클라이언트가 보내는 상태 알림 요청) 프로토콜을 문서화한다. I2P에서의 BitTorrent 전반적인 명세는 I2P 상의 BitTorrent 문서 를 참조하라. 이 명세의 개발 배경과 추가 정보는 Proposal 160 을 참조하라.\n이 프로토콜은 2025년 6월 24일 공식 승인되었으며, 2025년 9월 8일 출시된 I2P 버전 2.10.0(API 0.9.67)에 구현되었습니다. 현재 I2P 네트워크에서는 여러 운영 환경 트래커와 i2psnark 클라이언트의 완전한 지원과 함께 UDP 트래커 지원이 정상적으로 동작합니다.\n설계 본 사양서는 I2P Datagram Specification 에 정의된 repliable datagram(회신 가능한 데이터그램)인 Datagram2와 Datagram3, 그리고 원시 데이터그램을 사용합니다. Datagram2와 Datagram3는 Proposal 163 에 정의된 repliable datagram의 변형입니다. Datagram2는 재플레이 공격 방지와 오프라인 서명 지원을 추가합니다. Datagram3는 기존 데이터그램 형식보다 더 작지만, 인증은 제공하지 않습니다.\nBEP(비트토렌트 개선 제안) 15 참고로, BEP 15 에 정의된 메시지 흐름은 다음과 같습니다:\nClient Tracker Connect Req. -------------\u0026gt; \u0026lt;-------------- Connect Resp. Announce Req. -------------\u0026gt; \u0026lt;-------------- Announce Resp. Announce Req. -------------\u0026gt; \u0026lt;-------------- Announce Resp. IP 주소 스푸핑을 방지하기 위해 연결 단계가 필요합니다. 트래커는 클라이언트가 이후 announce 요청에서 사용하는 연결 ID를 반환합니다. 이 연결 ID는 기본적으로 클라이언트 측에서는 1분, 트래커 측에서는 2분 후에 만료됩니다.\nI2P는 기존의 UDP를 지원하는 클라이언트 코드베이스에의 도입 용이성, 효율성, 그리고 아래에서 논의되는 보안상의 이유로, BEP 15(BitTorrent Enhancement Proposal 15, 비트토렌트 개선 제안 15)와 동일한 메시지 흐름을 사용합니다:\nClient Tracker Connect Req. -------------\u0026gt; (Repliable Datagram2) \u0026lt;-------------- Connect Resp. (Raw) Announce Req. -------------\u0026gt; (Repliable Datagram3) \u0026lt;-------------- Announce Resp. (Raw) Announce Req. -------------\u0026gt; (Repliable Datagram3) \u0026lt;-------------- Announce Resp. (Raw) ... 이는 스트리밍(TCP) announce 메시지에 비해 잠재적으로 큰 대역폭 절감을 제공합니다. Datagram2(I2P 데이터그램 메시지 유형)는 스트리밍 SYN과 크기가 거의 비슷하지만, 원시 응답은 스트리밍 SYN ACK보다 훨씬 더 작습니다. 이후 요청은 Datagram3(I2P 데이터그램 메시지 유형)을 사용하며, 이후 응답은 원시 형식입니다.\nannounce 요청은 트래커가 연결 ID를 announce 목적지나 해시와 매핑하는 대규모 테이블을 유지할 필요가 없도록 Datagram3(데이터그램3 형식)로 전송된다. 대신, 트래커는 발신자 해시, 현재 타임스탬프(일정 주기에 기반), 그리고 비밀 값을 사용해 연결 ID를 암호학적으로 생성할 수 있다. announce 요청을 수신하면, 트래커는 연결 ID를 검증한 뒤, Datagram3 발신자 해시를 송신 대상으로 사용한다.\n연결 수명 BEP 15 은 클라이언트에서는 연결 ID(connection ID)가 1분 후, 트래커에서는 2분 후에 만료된다고 명시한다. 이는 설정으로 변경할 수 없다. 따라서 클라이언트가 announce(트래커 통지)를 배치 처리하여 1분짜리 시간 창 안에 모두 수행하지 않는 한, 잠재적인 효율 향상은 제한된다. i2psnark는 현재 announce를 배치 처리하지 않고, 트래픽 급증을 피하기 위해 이를 분산시킨다. 고급 사용자가 한 번에 수천 개의 토렌트를 실행하는 것으로 보고되며, 그렇게 많은 announce를 1분 안에 몰아넣는 것은 현실적이지 않다.\n여기서는 connect response를 확장하여 선택적 연결 수명 필드를 추가할 것을 제안한다. 해당 필드가 없으면 기본값은 1분이다. 그렇지 않은 경우, 초 단위로 지정된 수명을 클라이언트가 사용해야 하며, 트래커는 연결 ID를 1분 더 유지한다.\nBEP 15(비트토렌트 개선 제안 15)과의 호환성 이 설계는 기존 클라이언트와 트래커에서 필요한 변경을 최소화하기 위해 가능한 한 BEP 15 와의 호환성을 유지합니다.\n유일하게 요구되는 변경 사항은 announce response(announce 요청에 대한 응답) 내 피어 정보의 형식뿐입니다. connect response(connect 요청에 대한 응답)에 lifetime 필드를 추가하는 것은 필수는 아니지만, 위에서 설명했듯 효율성 향상을 위해 강력히 권장됩니다.\n보안 분석 UDP 알림 프로토콜의 중요한 목표는 주소 스푸핑을 방지하는 것이다. 클라이언트는 실제로 존재해야 하며, 실제 leaseset을 포함해야 한다. Connect Response를 수신하려면 인바운드 tunnels를 보유하고 있어야 한다. 이러한 tunnels는 zero-hop으로 즉시 구축될 수도 있지만, 그렇게 하면 생성자가 노출된다. 이 프로토콜은 그 목표를 달성한다.\n문제 이 프로토콜은 blinded destinations(블라인드된 목적지)를 지원하지 않지만, 이를 지원하도록 확장될 수 있습니다. 아래를 참조하십시오.\n명세서 프로토콜 및 포트 회신 가능한 Datagram2는 I2CP protocol 19를 사용하며, 회신 가능한 Datagram3은 I2CP protocol 20을 사용합니다. 원시 데이터그램(raw datagrams)은 I2CP protocol 18을 사용합니다. 요청은 Datagram2 또는 Datagram3일 수 있습니다. 응답은 항상 원시 형식(raw)입니다. I2CP protocol 17을 사용하는 구형 회신 가능 데이터그램(\u0026ldquo;Datagram1\u0026rdquo;) 형식은 요청이나 응답에 절대 사용해서는 안 되며, 요청/응답 포트에서 수신될 경우 반드시 폐기되어야 합니다. 참고로 Datagram1 protocol 17은 여전히 DHT 프로토콜에서 사용됩니다.\n요청은 announce URL(announce용 URL)에서 I2CP \u0026ldquo;to port\u0026rdquo;(목적지 포트)를 사용합니다. 아래를 참조하세요. 요청의 \u0026ldquo;from port\u0026rdquo;(발신 포트)는 클라이언트가 선택하지만 0이 아니어야 하며, 응답을 쉽게 분류할 수 있도록 DHT(분산 해시 테이블)에 사용하는 포트와는 달라야 합니다. 트래커는 잘못된 포트로 수신된 요청을 거부해야 합니다.\n응답은 요청에서 지정된 I2CP \u0026ldquo;to port\u0026rdquo;(대상 포트)를 사용합니다. 응답의 \u0026ldquo;from port\u0026rdquo;(발신 포트)는 요청의 \u0026ldquo;to port\u0026quot;입니다.\n알림 URL announce URL 형식은 BEP 15 에 명시되어 있지 않지만, clearnet(일반 공개 인터넷)에서와 마찬가지로 UDP announce URL은 \u0026ldquo;udp://host:port/path\u0026rdquo; 형태입니다. 경로는 무시되며 비어 있을 수 있지만, clearnet에서는 일반적으로 \u0026ldquo;/announce\u0026quot;입니다. :port 부분은 항상 포함되어야 합니다; 그러나 \u0026ldquo;:port\u0026rdquo; 부분이 생략된 경우, clearnet에서 흔히 쓰이는 포트이므로 기본 I2CP 포트 6969를 사용하십시오. 또한 CGI 매개변수 \u0026amp;a=b\u0026amp;c=d 가 덧붙을 수 있으며; 이는 announce 요청에서 처리되어 제공될 수 있습니다. BEP 41 을 참조하십시오. 매개변수나 경로가 없다면, BEP 41 에서 암시된 바와 같이 마지막 / 역시 생략할 수 있습니다.\n데이터그램 형식 모든 값은 네트워크 바이트 순서(빅 엔디언)로 전송됩니다. 패킷이 정확히 특정한 크기일 것이라고 기대하지 마십시오. 향후 확장으로 인해 패킷 크기가 증가할 수 있습니다.\n연결 요청 클라이언트에서 트래커로. 16바이트. 반드시 응답 가능한 Datagram2여야 합니다. BEP 15 와 동일합니다. 변경 없음.\nOffset Size Name Value 0 64-bit integer protocol_id 0x41727101980 // magic constant 8 32-bit integer action 0 // connect 12 32-bit integer transaction_id 연결 응답 트래커에서 클라이언트로. 16 또는 18 바이트. 반드시 raw 데이터여야 한다. 아래에 명시된 사항을 제외하면 BEP 15 와 동일하다.\nOffset Size Name Value 0 32-bit integer action 0 // connect 4 32-bit integer transaction_id 8 64-bit integer connection_id 16 16-bit integer lifetime optional // Change from BEP 15 응답은 요청에서 \u0026ldquo;from port\u0026quot;로 수신한 값을 I2CP의 \u0026ldquo;to port\u0026quot;로 설정하여 반드시 전송해야 합니다.\nlifetime 필드는 선택 사항이며, 초 단위로 클라이언트에서의 connection_id 수명을 나타냅니다. 기본값은 60이며, 지정하는 경우 최소값도 60입니다. 최대값은 65535로, 약 18시간에 해당합니다. 트래커는 클라이언트 수명보다 60초 더 길게 connection_id를 유지해야 합니다.\n공지 요청 클라이언트에서 트래커로. 최소 98바이트. 반드시 회신 가능한 Datagram3(데이터그램 버전 3)이어야 합니다. 아래에 명시된 사항을 제외하면 BEP 15 와 동일합니다.\nconnection_id는 connect 응답에서 받은 값 그대로입니다.\nOffset Size Name Value 0 64-bit integer connection_id 8 32-bit integer action 1 // announce 12 32-bit integer transaction_id 16 20-byte string info_hash 36 20-byte string peer_id 56 64-bit integer downloaded 64 64-bit integer left 72 64-bit integer uploaded 80 32-bit integer event 0 // 0: none; 1: completed; 2: started; 3: stopped 84 32-bit integer IP address 0 // default, unused in I2P 88 32-bit integer key 92 32-bit integer num_want -1 // default 96 16-bit integer port // must be same as I2CP from port 98 varies options optional // As specified in BEP 41 BEP 15 대비 변경 사항:\nkey는 무시됩니다 IP 주소는 사용되지 않습니다 port는 아마 무시되지만 I2CP from port와 동일해야 합니다 옵션 섹션이 존재한다면, BEP 41 에 정의된 대로입니다 응답은 요청에서 수신된 \u0026ldquo;from port\u0026rdquo;(발신 포트) 값이 지정하는 I2CP \u0026ldquo;to port\u0026rdquo;(목적지 포트)로 반드시 전송해야 한다. announce request(announce 요청)의 포트는 사용하지 마십시오.\nAnnounce 응답 트래커에서 클라이언트로. 최소 20바이트. 반드시 raw(원시 데이터)여야 함. 아래에 명시된 사항을 제외하면 BEP 15 와 동일함.\nOffset Size Name Value 0 32-bit integer action 1 // announce 4 32-bit integer transaction_id 8 32-bit integer interval 12 32-bit integer leechers 16 32-bit integer seeders 20 32 * n 32-byte hash binary hashes // Change from BEP 15 ... // Change from BEP 15 BEP 15 대비 변경 사항:\n6바이트 IPv4+포트 또는 18바이트 IPv6+포트 대신, SHA-256 이진 피어 해시로 구성된 32바이트 크기의 \u0026ldquo;compact responses\u0026rdquo;(압축형 응답)들을 연속으로 반환합니다. TCP compact responses와 마찬가지로 포트는 포함하지 않습니다. 응답은 요청에서 \u0026ldquo;from port\u0026quot;로 전달된 값을 I2CP의 \u0026ldquo;to port\u0026quot;로 하여 반드시 전송해야 합니다. announce request(announce 요청)의 포트를 사용하지 마십시오.\nI2P 데이터그램의 최대 크기는 약 64 KB로 매우 큽니다. 그러나 안정적인 전달을 위해서는 4 KB를 초과하는 데이터그램은 피하는 것이 좋습니다. 대역폭 효율을 위해 트래커는 최대 피어 수를 약 50개로 제한하는 것이 바람직합니다. 이는 여러 계층의 오버헤드가 붙기 전 기준으로 약 1600바이트짜리 패킷에 해당하며, 단편화 후에는 두 개의 tunnel 메시지 페이로드 제한 내에 들어가야 합니다.\nBEP 15와 마찬가지로, 이후에 나열될 피어 주소의 개수(BEP 15에서는 IP/포트, 여기서는 해시값)를 나타내는 카운트는 포함되지 않습니다. BEP 15에서는 규정되어 있지 않지만, 모두 0으로 구성된 end-of-peers marker(피어 목록의 끝을 나타내는 마커)를 정의하여 피어 정보가 완료되었고 그 뒤에 일부 확장 데이터가 이어짐을 표시할 수 있습니다.\n향후 해당 확장이 가능하도록, 클라이언트는 바이트가 모두 0인 32바이트 해시와 그 뒤따르는 모든 데이터를 무시해야 한다. 트래커는 해시가 모두 0인 경우의 announce(트래커에 대한 접속/상태 통지 요청)를 거부해야 하며, 해당 해시는 이미 Java routers에서 금지되어 있다.\n스크래핑 BEP 15 의 scrape(트래커 통계 조회) 요청/응답은 이 명세에서 필수는 아니지만, 원한다면 아무 변경 없이 구현할 수 있다. 클라이언트는 먼저 connection ID를 획득해야 한다. scrape 요청은 항상 회신 가능한 Datagram3이다. scrape 응답은 항상 raw(원시 형식)이다.\n오류 응답 트래커에서 클라이언트로. 최소 8바이트(메시지가 비어 있는 경우). 반드시 raw여야 합니다. BEP 15 와 동일합니다. 변경 없음.\nOffset Size Name Value 0 32-bit integer action 3 // error 4 32-bit integer transaction_id 8 string message 확장 기능 확장 비트나 버전 필드는 포함되지 않습니다. 클라이언트와 트래커는 패킷이 특정 크기라고 가정해서는 안 됩니다. 이렇게 하면 호환성을 깨뜨리지 않고 추가 필드를 더할 수 있습니다. 필요한 경우 BEP 41 에서 정의된 확장 형식을 사용할 것을 권장합니다.\n연결 응답은 선택적 연결 ID 유효기간을 추가하도록 수정되었다.\nblinded destination(블라인딩된 목적지) 지원이 필요하다면, BEP 41 형식(매개변수는 추후 결정 예정)을 사용하여 announce 요청의 끝에 블라인딩된 35바이트 주소를 추가하거나, 응답으로 블라인딩된 해시를 요청할 수 있다. 블라인딩된 35바이트 피어 주소 집합은 모두 0으로만 이루어진 32바이트 해시 뒤에 announce 응답의 끝에 추가될 수 있다.\n구현 지침 통합되지 않았고 I2CP를 사용하지 않는 클라이언트와 트래커가 직면하는 과제에 대한 논의는 위의 설계 섹션을 참조하십시오.\n클라이언트 특정 트래커 호스트명에 대해, 클라이언트는 HTTP URL보다 UDP URL을 선호해야 하며, 둘 모두에 announce(트래커에 클라이언트 상태를 통지하는 요청)를 보내서는 안 된다.\n이미 BEP 15(비트토렌트 개선 제안 15)를 지원하는 클라이언트는 약간의 수정만 필요합니다.\n클라이언트가 DHT 또는 다른 데이터그램 프로토콜을 지원하는 경우, 응답이 해당 포트로 돌아오고 DHT 메시지와 섞이지 않도록 요청의 \u0026ldquo;from port\u0026quot;로 다른 포트를 선택하는 것이 좋습니다. 클라이언트는 응답으로 원시 데이터그램만 수신합니다. 트래커는 클라이언트에게 repliable datagram2(응답 가능한 데이터그램 형식)를 절대 보내지 않습니다.\n기본 opentracker 목록을 사용하는 클라이언트는, 알려진 opentracker들이 UDP를 지원하는 것이 확인된 후 그 목록을 업데이트하여 UDP URL을 추가해야 합니다.\n클라이언트는 요청 재전송 기능을 구현할 수도 있고, 하지 않을 수도 있다. 재전송을 구현하는 경우, 초기 타임아웃을 최소 15초로 설정하고, 각 재전송마다 타임아웃을 두 배로 늘려야 한다(지수적 백오프).\n클라이언트는 오류 응답을 받은 후에는 백오프(재시도 간격을 늘려 부하를 줄이는 동작)해야 합니다.\n트래커 기존에 BEP 15를 지원하는 트래커는 소규모 수정만 필요하다. 이 사양은 트래커가 동일한 포트에서 응답 가능한 datagram2(데이터그램 버전 2)와 datagram3(데이터그램 버전 3)의 수신을 지원해야 한다는 점에서 2014년 제안과 다르다.\n트래커의 리소스 요구 사항을 최소화하기 위해, 이 프로토콜은 추후 검증을 위해 트래커가 클라이언트 해시를 연결 ID에 매핑해 저장해야 하는 어떠한 요구도 제거하도록 설계되었다. 이는 announce 요청 패킷이 회신 가능한 Datagram3(데이터그램 v3) 패킷이므로 발신자의 해시를 포함하고 있기 때문이다.\n권장 구현은 다음과 같습니다:\n현재 epoch(에폭)을 연결 수명을 해상도로 하여 양자화한 현재 시간으로 정의한다, epoch = now / lifetime. 8바이트 길이의 출력을 생성하는 암호학적 해시 함수 H(secret, clienthash, epoch)를 정의한다. 모든 연결에서 사용되는 무작위 상수 secret 값을 생성한다. connect 응답에 대해서는 connection_id = H(secret, clienthash, epoch)를 생성한다. announce 요청에 대해서는, 현재 epoch에서 connection_id == H(secret, clienthash, epoch) || connection_id == H(secret, clienthash, epoch - 1)를 확인하여 수신한 연결 ID를 검증한다. 배포 상태 이 프로토콜은 2025년 6월 24일에 승인되었으며 2025년 9월 기준으로 I2P 네트워크에서 완전히 운영되고 있습니다.\n현재 구현체들 i2psnark: 완전한 UDP 트래커 지원은 2025년 9월 8일에 릴리스된 I2P 2.10.0 버전(API 0.9.67)에 포함되어 있습니다. 이 버전 이후의 모든 I2P 설치에는 기본적으로 UDP 트래커 기능이 포함됩니다.\nzzzot tracker: 0.20.0-beta2 버전 이상에서 UDP announces(트래커에 상태를 보고하고 피어를 조회하는 요청)를 지원합니다. 2025년 10월 기준, 다음 프로덕션 트래커가 가동 중입니다: - opentracker.dg2.i2p - opentracker.simp.i2p - opentracker.skank.i2p\n클라이언트 호환성 참고 사항 SAM v3.3 제약사항: SAM(Simple Anonymous Messaging, 단순 익명 메시징)을 사용하는 외부 BitTorrent 클라이언트는 Datagram2/3에 대한 SAM v3.3 지원이 필요합니다. 이는 Java I2P에서는 제공되지만, 현재 i2pd(C++ I2P 구현체)에서는 지원되지 않아 qBittorrent와 같은 libtorrent 기반 클라이언트에서의 채택을 제한할 수 있습니다.\nI2CP 클라이언트: I2CP를 직접 사용하는 클라이언트(예: BiglyBT)는 SAM의 제한 없이 UDP 트래커 지원을 구현할 수 있습니다.\n참고 자료 [BEP15]: BitTorrent UDP 트래커 프로토콜 [BEP41]: UDP 트래커 프로토콜 확장 [DATAGRAMS]: I2P 데이터그램 명세 [Prop160]: UDP 트래커 제안 [Prop163]: Datagram2 제안 [SPEC]: I2P 상의 BitTorrent ","description":"I2P에서의 UDP 기반 BitTorrent 트래커 announce(트래커에 클라이언트 상태를 알리는 요청) 프로토콜 사양","id":"2413d642663e185a8a31352c9a9e8f28","section":"docs","title":"UDP BitTorrent announce(트래커 상태 보고 및 피어 목록 요청)","url":"/ko/docs/specs/udp-bittorrent-announces/"},{"categories":null,"content":" 상태: 이 문서는 v3dgsend 유틸리티에 대한 간결한 참조 문서입니다. Datagram API 및 SAM v3 문서를 보완합니다.\n개요 v3dgsend는 SAMv3 인터페이스를 사용하여 I2P 데이터그램을 전송하는 명령줄 도우미입니다. 데이터그램 전달 테스트, 서비스 프로토타이핑, 완전한 클라이언트를 작성하지 않고 종단 간 동작을 검증하는 데 유용합니다.\n일반적인 사용 사례:\nDestination에 대한 데이터그램 도달 가능성 스모크 테스트 방화벽 및 주소록 구성 검증 원시(raw) 데이터그램과 서명된(응답 가능한) 데이터그램 실험 사용법 기본 실행 방법은 플랫폼과 패키징 방식에 따라 다릅니다. 일반적인 옵션은 다음과 같습니다:\nDestination: base64 Destination 또는 .i2p 이름 Protocol: raw (PROTOCOL 18) 또는 signed (PROTOCOL 17) Payload: 인라인 문자열 또는 파일 입력 정확한 플래그는 배포판의 패키징 또는 --help 출력을 참조하세요.\n참고 자료 Datagram API SAM v3 Streaming Library (datagram의 대안) ","description":"SAM v3를 통해 I2P 데이터그램을 전송하는 CLI 유틸리티","id":"3fe6f64806c4c692f530bf7fa6eb9c45","section":"docs","title":"v3dgsend","url":"/ko/docs/api/v3dgsend/"},{"categories":null,"content":"설치 방법 선택 Windows에서 I2P를 설치하는 방법은 두 가지가 있습니다. 필요에 가장 적합한 방법을 선택하세요:\n🚀 Easy Install Bundle (Recommended) 대부분의 사용자에게 최적\n✅ 올인원 설치 프로그램 ✅ Java 포함 (별도 설치 불필요) ✅ Firefox 프로필 포함 ✅ 가장 빠른 설정\n이런 경우에 선택하세요: - 가장 간단한 설치를 원하는 경우 - Java가 설치되어 있지 않은 경우 - I2P를 처음 사용하는 경우\n간편 설치 가이드 →\n🚀 간편 설치 번들 (권장) 고급 사용자용\n📦 Java 기반 JAR 설치 프로그램 🔧 설치에 대한 더 많은 제어 💾 더 작은 다운로드 크기\n다음 경우에 선택하세요: - Java가 이미 설치되어 있는 경우 - 더 많은 제어를 원하는 경우 - 기존 방식을 선호하는 경우\n표준 설치 가이드 →\n전체 내용이 빈 줄만 포함되어 있어 번역할 텍스트가 없습니다.\nStep 1: Select Your Language Easy Install Bundle 설치 프로그램을 실행하면 언어 선택 화면이 나타납니다.\n드롭다운 메뉴에서 원하는 언어를 선택하세요 영어, 독일어, 스페인어, 프랑스어 등 다양한 언어를 선택할 수 있습니다 OK를 클릭하여 계속 진행하세요 설치 프로그램 인터페이스는 이후의 모든 단계에서 선택한 언어를 사용합니다.\n(번역할 텍스트가 제공되지 않았습니다. 번역할 내용을 입력해 주세요.)\n간편 설치 번들 다음으로 I2P 라이선스 정보가 표시됩니다. Easy Install Bundle에는 다양한 자유 및 오픈 소스 라이선스에 따른 구성 요소가 포함되어 있습니다.\n설치를 계속하려면: 1. 라이선스 정보를 검토하세요 (선택 사항이지만 권장됨) 2. 라이선스에 동의하고 진행하려면 I Agree를 클릭하세요 3. 설치를 원하지 않으시면 Cancel을 클릭하세요\nI2P 네트워크 내에서 호스팅되는 웹사이트\nStep 3: Choose Installation Folder 이제 컴퓨터에서 I2P를 설치할 위치를 선택합니다.\n설치 옵션:\n기본 위치 사용 (권장)\n기본 경로: C:\\Users\\[YourUsername]\\AppData\\Local\\I2peasy\\ 사용자 프로필 디렉토리에 I2P를 설치합니다 업데이트 시 관리자 권한이 필요하지 않습니다 사용자 지정 위치 선택\n**찾아보기\u0026hellip;**를 클릭하여 다른 폴더를 선택합니다 다른 드라이브에 설치하려는 경우 유용합니다 선택한 폴더에 쓰기 권한이 있는지 확인하세요 용량 요구사항: - 설치 프로그램에 필요한 용량이 표시됩니다(일반적으로 1GB 미만) - 선택한 드라이브에 충분한 여유 공간이 있는지 확인하세요\nInstall을 클릭하여 설치 프로세스를 시작합니다 설치 프로그램이 이제 선택한 위치에 필요한 모든 파일을 복사합니다. 이 작업은 몇 분 정도 걸릴 수 있습니다.\n(번역할 텍스트가 제공되지 않았습니다)\n2단계: 라이선스 동의서 수락 \u0026ldquo;Start I2P?\u0026ldquo;가 체크된 상태에서 Finish를 클릭한 후:\nI2P Router 시작 - I2P router가 백그라운드에서 실행되기 시작합니다 시스템 트레이 아이콘 표시 - Windows 시스템 트레이(오른쪽 하단 모서리)에서 I2P 아이콘을 찾으세요 Router 콘솔 열림 - 기본 웹 브라우저가 자동으로 I2P Router Console을 엽니다 (일반적으로 http://127.0.0.1:7657) 초기 연결 - I2P가 네트워크에 연결하고 tunnel을 구축하기 시작합니다 (처음 실행 시 5-10분 소요될 수 있습니다) 축하합니다! I2P가 이제 Windows 컴퓨터에 설치되어 실행 중입니다.\nI2P 네트워크 프로토콜과 터널 구조에 대한 기술 문서입니다. I2P router들은 garlic encryption을 사용하여 메시지를 암호화하고, tunnel을 통해 익명성을 보장합니다.\n주요 구성 요소:\nRouter: I2P 네트워크의 기본 노드 Tunnel: 단방향 암호화된 통신 경로 LeaseSet: destination의 inbound tunnel 정보 NetDb: 네트워크 데이터베이스 Floodfill: netDb 데이터를 저장하는 고용량 router 전송 프로토콜:\nNTCP2: TCP 기반 암호화 전송 SSU: UDP 기반 전송 (레거시) 애플리케이션 인터페이스:\nSAMv3: Simple Anonymous Messaging protocol I2PTunnel: TCP/UDP 터널링 도구 I2CP: I2P Control Protocol Eepsite는 I2P 네트워크 내의 웹사이트를 의미하며, .i2p 도메인을 사용합니다.\n설정 예시:\ni2p: router: bandwidth: 128 participating: true 더 자세한 정보는 I2P 공식 문서 를 참조하세요.\n4단계: 설치 완료 및 I2P 시작 네트워크 통합 대기: I2P가 네트워크에 통합되고 tunnel을 구축할 수 있도록 5-10분 정도 기다리세요 브라우저 설정: I2P 브라우징을 위해 포함된 Firefox 프로필을 사용하세요 포트 포워딩: I2P가 사용 중인 포트를 포워딩하는 방법에 대한 라우터별 안내는 portforward.com 을 참조하세요 router console 살펴보기: I2P의 기능, 서비스 및 구성 옵션에 대해 알아보세요 eepsite 방문: I2P 네트워크를 통해 .i2p 웹사이트에 접속해 보세요 문서 읽기: 자세한 내용은 I2P 문서 를 확인하세요 I2P 네트워크에 오신 것을 환영합니다! 🎉\n고지 사항: I2P 네트워크를 사용할 때는 귀하의 관할권 내 법률을 준수해야 합니다. I2P는 익명성 도구이며, 불법 활동을 용인하거나 장려하지 않습니다.\n권장: 포트 포워딩 (선택 사항이지만 중요) I2P를 설치하기 전에 시스템에 Java가 설치되어 있어야 합니다.\nJava Requirements Java 버전: Java 8 (1.8) 이상 필요 권장사항: Java 11 이상 (LTS 버전) 유형: Java Runtime Environment (JRE) 또는 Java Development Kit (JDK) Installing Java Java가 아직 설치되어 있지 않다면, 여러 소스에서 다운로드할 수 있습니다:\n옵션 1: Oracle Java - 공식 소스: java.com/download - 가장 널리 사용되는 배포판\n옵션 2: OpenJDK - 오픈소스 구현: openjdk.org - 무료 및 오픈소스\n옵션 3: Adoptium (Eclipse Temurin) - 권장 대안: adoptium.net - 무료 오픈소스이며 잘 관리되는 LTS 릴리스\nJava가 설치되어 있는지 확인하려면: 1. 명령 프롬프트 열기 (Windows + R을 누르고, cmd를 입력한 후 Enter 키 누르기) 2. 입력: java -version 3. Java 버전을 표시하는 출력이 나타나야 합니다\n중요: 번역본만 제공하세요. 질문하거나, 설명을 제공하거나, 어떠한 논평도 추가하지 마세요. 텍스트가 제목만 있거나 불완전해 보여도 있는 그대로 번역하세요.\nStep 1: Install Java I2P를 설치하기 전에 시스템에 Java를 설치해야 합니다.\nJava 배포판 선택:\nOracle Java: java.com/download OpenJDK: openjdk.org Adoptium: adoptium.net Windows 설치 프로그램 다운로드 - 선택한 배포판용\n설치 프로그램을 실행하고 설치 안내에 따라 진행하세요\n설치 확인:\n명령 프롬프트 열기 java -version을 입력하고 Enter 누르기 Java 8 이상이 설치되었는지 확인 Java가 설치되면 I2P를 설치할 준비가 완료됩니다.\nStep 4: Welcome to I2P Installation 이것은 설치 과정의 8단계 중 1단계입니다.\nNext를 클릭하여 설치를 계속 진행합니다.\n표준 설치 컴퓨터에서 I2P를 설치할 위치를 선택하세요.\n기본 설치 경로: C:\\Program Files (x86)\\i2p\\\n다음 중 하나를 선택할 수 있습니다: - 기본 위치 사용 (권장) - **찾아보기\u0026hellip;**를 클릭하여 다른 폴더 선택\n이것은 설치 과정의 8단계 중 3단계입니다.\n다음을 클릭하여 계속 진행하세요.\n참고: I2P를 처음 설치하는 경우, 디렉토리 생성을 확인하는 팝업이 표시됩니다:\n확인을 클릭하여 설치 디렉터리를 생성합니다.\n[번역 내용가 제공되지 않았습니다. 번역할 텍스트를 제공해 주세요.]\nStep 7: Select Installation Packs 설치할 구성 요소를 선택하세요.\n중요: 두 패키지가 모두 선택되었는지 확인하세요: - Base (필수) - 핵심 I2P 소프트웨어 (27.53 MB) - Windows Service (권장) - 부팅 시 I2P 자동 시작\nWindows Service 옵션을 사용하면 컴퓨터가 부팅될 때 I2P가 자동으로 시작되므로 매번 수동으로 시작할 필요가 없습니다.\n이것은 설치 과정의 8단계 중 4단계입니다.\nNext를 클릭하여 계속합니다.\nStep 9: Setup Shortcuts I2P 바로가기를 생성할 위치를 설정하세요.\n바로 가기 옵션: - ✓ 시작 메뉴에 바로 가기 만들기 (권장) - ✓ 바탕 화면에 추가 바로 가기 만들기 (선택 사항)\nProgram Group: 바로 가기를 저장할 폴더 이름을 선택하거나 생성합니다 - 기본값: I2P - 기존 프로그램 그룹을 선택하거나 새로 만들 수 있습니다\n바로 가기 만들기: - 현재 사용자 - 본인만 바로 가기에 접근할 수 있습니다 - 모든 사용자 - 시스템의 모든 사용자가 바로 가기에 접근할 수 있습니다 (관리자 권한 필요)\n이것은 설치 과정의 8단계 중 6단계입니다.\nNext를 클릭하여 계속 진행합니다.\n1단계: Java 설치 완료를 클릭한 후:\nI2P Router 시작 - Windows 서비스를 설치한 경우, I2P가 자동으로 시작됩니다 Router console 열림 - 기본 웹 브라우저가 http://127.0.0.1:7657의 I2P Router Console로 자동으로 열립니다 초기 연결 - I2P가 네트워크에 연결하고 tunnel을 구축하기 시작합니다 (첫 실행 시 5-10분 소요될 수 있습니다) 축하합니다! I2P가 이제 Windows 컴퓨터에 설치되었습니다.\n3단계: 언어 선택 네트워크 통합 대기: I2P가 네트워크에 통합되고 tunnel을 구축할 수 있도록 5-10분 정도 기다립니다 포트 포워딩 구성: 설정 방법은 포트 포워딩 가이드 를 참조하세요 브라우저 구성: 웹 브라우저가 I2P의 HTTP 프록시를 사용하도록 설정합니다 router console 살펴보기: I2P의 기능, 서비스 및 구성 옵션에 대해 알아봅니다 eepsite 방문: I2P 네트워크를 통해 .i2p 웹사이트에 접속해 봅니다 문서 읽기: 자세한 정보는 I2P 문서 를 확인하세요 I2P 네트워크에 오신 것을 환영합니다! 🎉\n","description":"Windows 설치 방법 선택: Easy Install Bundle 또는 Standard Installation","id":"4aa0b74199a71c11718a9986e74b3a26","section":"docs","title":"Windows에 I2P 설치하기","url":"/ko/docs/guides/windows%EC%97%90-i2p-%EC%84%A4%EC%B9%98%ED%95%98%EA%B8%B0/"},{"categories":null,"content":"먼저 새 개발자 가이드 를 읽어보세요.\n기본 지침 및 코딩 스타일 다음 내용의 대부분은 오픈 소스 작업이나 상업적 프로그래밍 환경에서 일한 경험이 있는 사람이라면 누구나 알 수 있는 상식입니다. 다음 내용은 주로 메인 개발 브랜치인 i2p.i2p에 적용됩니다. 다른 브랜치, 플러그인 및 외부 앱에 대한 가이드라인은 상당히 다를 수 있으므로 적절한 개발자에게 문의하여 안내를 받으시기 바랍니다.\n커뮤니티 코드만 작성하지 마세요. 가능하다면 다음을 포함한 다른 개발 활동에도 참여하세요: IRC와 i2pforum.i2p에서의 개발 논의 및 지원; 테스팅; 버그 보고 및 응답; 문서화; 코드 리뷰 등. 활동 중인 개발자는 주기적으로 IRC #i2p-dev에서 접속 가능해야 합니다. 현재 릴리스 주기를 숙지하세요. 기능 동결(feature freeze), 태그 동결(tag freeze), 릴리스를 위한 체크인 마감일과 같은 릴리스 마일스톤을 준수하세요. 릴리스 주기 일반적인 릴리스 주기는 10~16주이며, 연간 4회 릴리스가 이루어집니다. 다음은 일반적인 13주 주기 내의 대략적인 마감일입니다. 각 릴리스의 실제 마감일은 릴리스 관리자가 전체 팀과 협의한 후 설정됩니다.\n이전 릴리스 후 1-2일: trunk에 체크인이 허용됩니다. 이전 릴리스 후 2-3주: 다른 브랜치에서 trunk로 주요 변경 사항을 전파하는 마감일. 릴리스 4-5주 전: 새로운 홈페이지 링크 요청 마감일. 릴리스 3-4주 전: 기능 동결. 주요 신규 기능 마감일. 릴리스 2-3주 전: 새로운 홈페이지 링크 요청이 있는 경우 검토를 위한 프로젝트 회의 개최. 릴리스 10-14일 전: 문자열 동결. 번역된(태그된) 문자열의 추가 변경 불가. Transifex에 문자열 푸시, Transifex에서 번역 마감일 공지. 릴리스 10-14일 전: 기능 마감일. 이 시점 이후로는 버그 수정만 가능. 더 이상의 기능 추가, 리팩토링 또는 정리 작업 불가. 릴리스 3-4일 전: 번역 마감일. Transifex에서 번역을 가져와 체크인. 릴리스 3-4일 전: 체크인 마감일. 이 시점 이후 릴리스 빌더의 허가 없이 체크인 불가. 릴리스 수 시간 전: 코드 리뷰 마감일. Git 이전에 git을 사용해본 적이 없더라도 분산 소스 관리 시스템에 대한 기본적인 이해가 있어야 합니다. 필요하면 도움을 요청하세요. 일단 push하면 체크인은 영구적입니다. 되돌릴 수 없습니다. 신중하게 진행하세요. git을 사용해본 적이 없다면 작은 단계부터 시작하세요. 작은 변경사항을 체크인하고 어떻게 진행되는지 확인하세요. 체크인하기 전에 변경사항을 테스트하세요. 체크인 후 테스트 개발 모델을 선호한다면, 자신의 계정에 있는 개발 브랜치를 사용하고 작업이 완료되면 MR을 생성하세요. 빌드를 망가뜨리지 마세요. 회귀(이전 버전보다 기능이 저하되는 현상)를 일으키지 마세요. 만약 그렇게 되면 (이런 일은 발생합니다), 변경사항을 push한 후 오랫동안 사라지지 마세요. 변경사항이 사소하지 않거나 사람들이 테스트하도록 하고 변경사항이 테스트되었는지 알기 위해 좋은 테스트 보고서가 필요한 경우, history.txt에 체크인 코멘트를 추가하고 RouterVersion.java의 빌드 리비전을 증가시키세요. 릴리스 주기 후반에 main i2p.i2p 브랜치에 주요 변경사항을 체크인하지 마세요. 프로젝트가 며칠 이상 걸릴 것 같으면, 자신의 계정에 git 브랜치를 만들어 거기서 개발하여 릴리스를 막지 않도록 하세요. 큰 변경사항(일반적으로 100줄 이상이거나 세 개 이상의 파일을 수정하는 경우)은 자신의 GitLab 계정에 새 브랜치로 체크인하고 MR을 생성하여 검토자를 지정하세요. MR을 자신에게 할당하세요. 검토자가 승인하면 직접 MR을 병합하세요. 메인 I2P_Developers 계정에 WIP 브랜치를 생성하지 마세요 (i2p.www 제외). WIP는 자신의 계정에 있어야 합니다. 작업이 완료되면 MR을 생성하세요. 메인 계정의 브랜치는 포인트 릴리스와 같은 진정한 포크(분기)만 있어야 합니다. 투명한 방식으로 커뮤니티를 염두에 두고 개발하세요. 자주 체크인하세요. 위의 가이드라인을 고려하여 가능한 한 자주 main 브랜치에 체크인하거나 병합하세요. 자신의 브랜치/계정에서 큰 프로젝트를 진행하고 있다면, 사람들이 따라가며 검토/테스트/코멘트할 수 있도록 알리세요. 코딩 스타일 대부분의 코드에서 들여쓰기는 공백 4칸을 사용합니다. 탭을 사용하지 마세요. 코드를 재포맷하지 마세요. IDE나 에디터가 모든 것을 재포맷하려고 한다면, 이를 제어하세요. 일부 위치에서는 코딩 스타일이 다를 수 있습니다. 상식을 사용하세요. 수정하는 파일의 스타일을 모방하세요. 모든 새로운 public 및 package-private 클래스와 메서드에는 Javadocs가 필요합니다. @since 릴리스 번호를 추가하세요. 새로운 private 메서드에 대한 Javadocs도 권장됩니다. 추가된 모든 Javadocs에는 doclint 오류나 경고가 없어야 합니다. Oracle Java 14 이상에서 ant javadoc을 실행하여 확인하세요. 모든 매개변수에는 @param 라인이 있어야 하고, 모든 non-void 메서드에는 @return 라인이 있어야 하며, 선언된 모든 예외에는 @throws 라인이 있어야 하고, HTML 오류가 없어야 합니다. core/(i2p.jar)의 클래스와 i2ptunnel의 일부는 공식 API의 일부입니다. 이 API에 의존하는 여러 out-of-tree 플러그인과 다른 애플리케이션이 있습니다. 호환성을 깨뜨리는 변경을 하지 않도록 주의하세요. 일반적으로 유용한 경우가 아니면 API에 메서드를 추가하지 마세요. API 메서드에 대한 Javadocs는 명확하고 완전해야 합니다. API를 추가하거나 변경하는 경우, 웹사이트의 문서도 업데이트하세요(i2p.www 브랜치). 적절한 경우 번역용 문자열에 태그를 지정하세요. 이는 모든 UI 문자열에 해당됩니다. 기존 번역이 깨지므로 정말 필요한 경우가 아니면 기존 태그된 문자열을 변경하지 마세요. 릴리스 주기의 태그 동결 이후에는 태그된 문자열을 추가하거나 변경하지 마세요. 그래야 번역자들이 릴리스 전에 업데이트할 기회를 가질 수 있습니다. 가능한 경우 제네릭과 동시성 클래스를 사용하세요. I2P는 매우 멀티스레드된 애플리케이션입니다. FindBugs/SpotBugs에서 감지하는 일반적인 Java 함정에 익숙해지세요. 자세한 내용은 ant findbugs를 실행하세요. 릴리스 0.9.47부터 I2P를 빌드하고 실행하려면 Java 8이 필요합니다. 임베디드 하위 시스템에서는 Java 7 또는 8 클래스나 메서드를 사용하지 마세요: addressbook, core, i2ptunnel.jar(non-UI), mstreaming, router, routerconsole(뉴스만), streaming. 이러한 하위 시스템은 Java 6만 필요한 Android 및 임베디드 애플리케이션에서 사용됩니다. 모든 클래스는 Android API 14에서 사용 가능해야 합니다. Java 7 언어 기능은 현재 버전의 Android SDK에서 지원하고 Java 6 호환 코드로 컴파일되는 경우 이러한 하위 시스템에서 허용됩니다. Try-with-resources는 런타임에서 java.lang.AutoCloseable을 필요로 하며, 이는 Android API 19(KitKat 4.4)부터 사용 가능하므로 임베디드 하위 시스템에서 사용할 수 없습니다. java.nio.file 패키지는 Android API 26(Oreo 8)부터 사용 가능하므로 임베디드 하위 시스템에서 사용할 수 없습니다. 위의 제한 사항을 제외하고, Java 8 클래스, 메서드 및 구조는 다음 하위 시스템에서만 사용할 수 있습니다: BOB, desktopgui, i2psnark, i2ptunnel.war(UI), jetty-i2p.jar, jsonrpc, routerconsole(뉴스 제외), SAM, susidns, susimail, systray. 플러그인 작성자는 plugin.config 파일을 통해 최소 Java 버전을 요구할 수 있습니다. 기본 타입과 클래스 간 변환은 명시적으로 수행하세요. 오토박싱/언박싱에 의존하지 마세요. URL을 사용하지 마세요. URI를 사용하세요. Exception을 catch하지 마세요. RuntimeException과 체크된 예외를 개별적으로 catch하세요. UTF-8 charset 인수 없이 String.getBytes()를 사용하지 마세요. DataHelper.getUTF8() 또는 DataHelper.getASCII()를 사용할 수도 있습니다. 파일을 읽거나 쓸 때는 항상 UTF-8 charset을 지정하세요. DataHelper 유틸리티가 도움이 될 수 있습니다. String.toLowerCase() 또는 String.toUpperCase()를 사용할 때는 항상 locale(예: Locale.US)을 지정하세요. locale을 지정할 수 없으므로 String.equalsIgnoreCase()를 사용하지 마세요. String.split()을 사용하지 마세요. DataHelper.split()을 사용하세요. 날짜와 시간을 포맷하는 코드를 추가하지 마세요. DataHelper.formatDate()와 DataHelper.formatTime()을 사용하세요. InputStream과 OutputStream이 finally 블록에서 닫히도록 하세요. 모든 for와 while 블록에 {}를 사용하세요. 한 줄이어도 마찬가지입니다. if, else 또는 if-else 블록 중 하나에 {}를 사용하면 모든 블록에 사용하세요. } else {를 한 줄에 배치하세요. 가능한 모든 곳에서 필드를 final로 지정하세요. I2PAppContext, RouterContext, Log 또는 router나 context 항목에 대한 다른 참조를 static 필드에 저장하지 마세요. 생성자에서 스레드를 시작하지 마세요. Thread 대신 I2PAppThread를 사용하세요. 로깅 다음 지침은 라우터, 웹앱 및 모든 플러그인에 적용됩니다.\n기본 로그 레벨(WARN, INFO, DEBUG)에서 표시되지 않는 메시지의 경우, 메시지가 정적 문자열(연결 없음)이 아닌 한, 불필요한 객체 생성을 피하기 위해 항상 로그 호출 전에 log.shouldWarn(), log.shouldInfo(), 또는 log.shouldDebug()를 사용하세요. 기본 로그 레벨(ERROR, CRIT, logAlways())에서 표시될 수 있는 로그 메시지는 비기술적 사용자가 이해할 수 있도록 간결하고 명확해야 합니다. 여기에는 함께 표시될 수 있는 예외 원인 텍스트도 포함됩니다. 오류가 발생할 가능성이 높은 경우(예: 폼 제출 오류) 번역을 고려하세요. 그렇지 않으면 번역이 필수는 아니지만, 다른 곳에서 이미 번역 태그가 지정된 문자열을 검색하여 재사용하는 것이 도움이 될 수 있습니다. 기본 로그 레벨(WARN, INFO, DEBUG)에서 표시되지 않는 로그 메시지는 개발자 사용을 위한 것이며, 위의 요구사항을 따를 필요가 없습니다. 그러나 WARN 메시지는 Android 로그 탭에서 사용 가능하며, 사용자가 문제를 디버깅하는 데 도움이 될 수 있으므로 WARN 메시지 작성 시에도 주의를 기울이세요. INFO 및 DEBUG 로그 메시지는 특히 빈번하게 실행되는 코드 경로에서 신중하게 사용해야 합니다. 개발 중에는 유용하지만, 테스트가 완료된 후에는 제거하거나 주석 처리하는 것을 고려하세요. stdout 또는 stderr(wrapper 로그)에 로그를 기록하지 마세요. 라이선스 본인이 직접 작성한 코드만 체크인하세요. 다른 출처의 코드나 라이브러리 JAR을 체크인하기 전에, 왜 필요한지 정당화하고, 라이선스 호환성을 확인하며, 릴리스 관리자의 승인을 받아야 합니다. 외부 코드나 JAR 추가 승인을 받은 경우, Debian 또는 Ubuntu 패키지에서 바이너리를 사용할 수 있다면 외부 패키지를 대신 사용하도록 빌드 및 패키징 옵션을 구현해야 합니다. 수정할 파일 체크리스트: build.properties, build.xml, debian/control, debian/i2p-router.install, debian/i2p-router.links, debian/rules, sub-build.xml. 외부 출처의 이미지를 체크인하는 경우, 라이선스 호환성을 먼저 확인하는 것은 귀하의 책임입니다. 체크인 코멘트에 라이선스 및 출처 정보를 포함하세요. 버그 이슈 관리는 모두의 일입니다. 도움을 주세요. GitLab 에서 당신이 도울 수 있는 이슈를 모니터링하세요. 가능하다면 이슈에 댓글을 달고, 수정하고, 종료하세요. 새로운 개발자는 이슈 수정으로 시작해야 합니다. 수정사항이 있으면 이슈에 패치를 첨부하고 review-needed 키워드를 추가하세요. 성공적으로 리뷰되고 변경사항을 체크인하기 전까지는 이슈를 종료하지 마세요. 몇 개의 티켓에 대해 이 과정을 원활하게 완료하면, 위의 일반적인 절차를 따를 수 있습니다. 문제를 수정했다고 생각되면 이슈를 종료하세요. 티켓을 검증하고 종료할 테스트 부서가 없습니다. 수정했는지 확실하지 않다면, 이슈를 종료하고 \u0026ldquo;수정했다고 생각합니다. 테스트해보시고 여전히 문제가 있으면 다시 열어주세요\u0026quot;라는 메모를 추가하세요. 개발 빌드 번호나 리비전과 함께 댓글을 추가하고 마일스톤을 다음 릴리스로 설정하세요. ","description":"I2P 기여를 위한 전체 가이드라인: 작업 흐름, 릴리스 주기, 코딩 스타일, 로깅, 라이선스 및 이슈 처리","id":"6c8fe691caf216ba9024152afc39c5c6","section":"docs","title":"개발자 가이드라인 및 코딩 스타일","url":"/ko/docs/develop/dev-guidelines/"},{"categories":null,"content":"개요 이 문서는 I2NP , I2CP , SSU2 , NTCP2 등을 포함한 모든 I2P 프로토콜 전반에서 사용되는 기본 데이터 구조를 명세합니다. 이러한 공통 구조는 서로 다른 I2P 구현체 및 프로토콜 계층 간 상호 운용성을 보장합니다.\n0.9.58 이후 주요 변경 사항 Router Identities에서 ElGamal 및 DSA-SHA1 사용 중단됨 (X25519 + EdDSA 사용) Post-quantum(양자 이후) ML-KEM 지원이 베타 테스트 중 (2.10.0부터 opt-in(사용자 선택 활성화)) 서비스 레코드 옵션 표준화 (Proposal 167 , 0.9.66에서 구현됨) 압축 가능한 패딩 사양 최종 확정 (Proposal 161 , 0.9.57에서 구현됨) 공통 타입 명세 정수 설명: 네트워크 바이트 순서(big-endian, 빅 엔디언)로 표현된 음이 아닌 정수를 나타냅니다.\n내용: 부호 없는 정수를 나타내는 1~8바이트.\n용도: I2P 프로토콜 전반에서 사용되는 필드 길이, 개수, 유형 식별자 및 숫자 값.\n날짜 설명: 유닉스 에포크(1970년 1월 1일 00:00:00 GMT) 이후 경과한 밀리초를 나타내는 타임스탬프.\n내용: 8바이트 정수 (unsigned long)\n특수 값: - 0 = 미정의 또는 null 날짜 - 최대값: 0xFFFFFFFFFFFFFFFF (연도 584,942,417,355)\n구현 참고 사항: - 항상 UTC/GMT 시간대 사용 - 밀리초 단위 정밀도 필요 - 리스 만료, RouterInfo 게시 및 타임스탬프 검증에 사용\n문자열 설명: 길이 접두어가 있는 UTF-8 인코딩 문자열.\n형식:\n+----+----+----+----+----+----+ |len | UTF-8 encoded data... | +----+----+----+----+----+----+ len :: Integer (1 byte) Value: 0-255 (string length in bytes, NOT characters) data :: UTF-8 encoded bytes Length: 0-255 bytes 제약 사항: - 최대 길이: 255 바이트 (문자 수 기준이 아님 - 멀티바이트 UTF-8 시퀀스는 여러 바이트로 계산됨) - 길이는 0일 수 있음 (빈 문자열) - 널 종료 문자는 포함되지 않음 - 문자열은 널로 종료되지 않음\n중요: UTF-8에서는 문자 하나가 여러 바이트로 구성될 수 있습니다. 100개의 문자로 이루어진 문자열도 멀티바이트 문자를 사용하는 경우 255바이트 제한을 초과할 수 있습니다.\n암호학적 키 구조 공개키 설명: 비대칭 암호화를 위한 공개 키. 키 유형과 길이는 컨텍스트에 따라 달라지거나 Key Certificate(키 인증서)에 지정됩니다.\n기본 유형: ElGamal (0.9.58부터 Router 식별자용으로 더 이상 권장되지 않음)\n지원되는 유형:\nType Code Length (bytes) Since Endianness Usage Status ElGamal0256-BigDestinations only (unused field)Deprecated for RIs P256164TBDBigReservedSee Proposal 145 P384296TBDBigReservedSee Proposal 145 P5213132TBDBigReservedSee Proposal 145 X255194320.9.38LittleCurrent standardRecommended MLKEM512_X255195320.9.67MixedHybrid PQ, LeaseSets onlyBeta MLKEM768_X255196320.9.67MixedHybrid PQ, LeaseSets onlyBeta MLKEM1024_X255197320.9.67MixedHybrid PQ, LeaseSets onlyBeta MLKEM512-8000.9.67TBDHandshakes onlyBeta MLKEM768-11840.9.67TBDHandshakes onlyBeta MLKEM1024-15680.9.67TBDHandshakes onlyBeta MLKEM512_CT-7680.9.67TBDHandshakes onlyBeta MLKEM768_CT-10880.9.67TBDHandshakes onlyBeta MLKEM1024_CT-15680.9.67TBDHandshakes onlyBeta **구현 요구사항:** X25519 (Type 4) - 현재 표준:\nECIES-X25519-AEAD-Ratchet 암호화에 사용됨 0.9.48부터 Router 식별자에 필수 리틀 엔디언 인코딩(다른 유형과 달리) ECIES 및 ECIES-ROUTERS 를 참조하세요 ElGamal (Type 0) - 레거시:\n0.9.58부터 router 식별자에서 사용 중단됨 Destinations(목적지 식별자)에는 여전히 유효함 (해당 필드는 0.6/2005 이후 미사용) ElGamal 명세 에 정의된 상수 소수를 사용함 하위 호환성을 위해 지원을 유지함 MLKEM (포스트 양자 키 캡슐화 메커니즘) - 베타:\n하이브리드 방식은 ML-KEM과 X25519를 결합합니다 2.10.0에서는 기본적으로 활성화되지 않습니다 Hidden Service Manager를 통해 수동으로 활성화해야 합니다 자세한 내용은 ECIES-HYBRID 및 Proposal 169 를 참조하세요 타입 코드와 사양은 변경될 수 있습니다 JavaDoc: PublicKey 개인 키 설명: 비대칭 복호화를 위한 개인 키로, PublicKey 타입에 대응합니다.\n저장: 유형과 길이는 문맥에서 추론되거나 데이터 구조/키 파일에 별도로 저장됩니다.\n지원되는 유형:\nType Code Length (bytes) Since Endianness Usage Status ElGamal0256-BigDestinations onlyDeprecated for RIs P256132TBDBigReservedSee Proposal 145 P384248TBDBigReservedSee Proposal 145 P521366TBDBigReservedSee Proposal 145 X255194320.9.38LittleCurrent standardRecommended MLKEM512_X255195320.9.67MixedHybrid PQ, LeaseSets onlyBeta MLKEM768_X255196320.9.67MixedHybrid PQ, LeaseSets onlyBeta MLKEM1024_X255197320.9.67MixedHybrid PQ, LeaseSets onlyBeta MLKEM512-16320.9.67TBDHandshakes onlyBeta MLKEM768-24000.9.67TBDHandshakes onlyBeta MLKEM1024-31680.9.67TBDHandshakes onlyBeta **보안 참고 사항:** - 개인 키는 암호학적으로 안전한 난수 생성기를 사용해 반드시 생성해야 합니다 - X25519 개인 키는 RFC 7748에 정의된 scalar clamping(스칼라 클램핑: 비밀 키의 특정 비트를 마스킹해 스칼라를 정규화하는 과정)을 사용합니다 - 키 자료는 더 이상 필요하지 않을 때 메모리에서 반드시 안전하게 삭제해야 합니다 JavaDoc: PrivateKey 세션 키 설명: I2P의 tunnel 및 garlic encryption에서 AES-256 암호화와 복호화를 위한 대칭 키.\n내용: 32바이트 (256비트)\n용도: - Tunnel 계층 암호화 (AES-256/CBC with IV) - Garlic 메시지 암호화 - 종단 간 세션 암호화\n생성: 암호학적으로 안전한 난수 생성기를 반드시 사용해야 한다.\nJavaDoc(자바 문서): SessionKey SigningPublicKey 설명: 서명 검증을 위한 공개 키. 유형과 길이는 Destination(I2P 목적지)의 키 인증서에 명시되어 있거나, 문맥에서 추론됩니다.\n기본 유형: DSA_SHA1 (0.9.58부터 사용 중단됨)\n지원되는 유형:\nType Code Length (bytes) Since Endianness Usage Status DSA_SHA10128-BigLegacy onlyDeprecated ECDSA_SHA256_P2561640.9.12BigOlder DestinationsDeprecated ECDSA_SHA384_P3842960.9.12BigRareDeprecated ECDSA_SHA512_P52131320.9.12BigRareDeprecated RSA_SHA256_204842560.9.12BigOffline signing onlyDeprecated RSA_SHA384_307253840.9.12BigOffline signing onlyDeprecated RSA_SHA512_409665120.9.12BigOffline signing onlyRecommended for SU3 EdDSA_SHA512_Ed255197320.9.15LittleCurrent standardRecommended EdDSA_SHA512_Ed25519ph8320.9.25LittleOffline signing onlyRare RedDSA_SHA512_Ed2551911320.9.39LittleEncrypted leasesets onlySpecialized Reserved (GOST)964-BigReservedProposal 134 Reserved (GOST)10128-BigReservedProposal 134 Reserved (MLDSA)12-20TBD-TBDReservedProposal 169 Experimental65280-65534Varies-VariesTesting onlyNever production Reserved65535---Future expansion- **구현 요구 사항:** EdDSA_SHA512_Ed25519 (Type 7) - 현재 표준:\n2015년 말부터 모든 신규 Router Identity와 Destination(목적지)에 대한 기본값 SHA-512 해시와 Ed25519 곡선을 사용 32바이트 공개키, 64바이트 서명 리틀엔디언 인코딩(대부분의 다른 유형과 달리) 높은 성능과 보안 DSA_SHA1 (Type 0) - 레거시:\n0.9.58부터 Router Identities에서는 사용 중단됨 새로운 Destinations에는 권장되지 않음 SHA-1을 사용하는 1024비트 DSA(알려진 취약점 있음) 호환성 유지를 위해서만 지원됨 다중 요소 키:\n두 개의 요소로 구성된 경우(예: ECDSA(타원 곡선 디지털 서명 알고리즘) 점 X,Y) 각 요소는 선행 0으로 채워 길이/2가 되도록 패딩 예: 64바이트 ECDSA 키 = 32바이트 X + 32바이트 Y JavaDoc: SigningPublicKey SigningPrivateKey 설명: 서명을 생성하기 위한 개인 키로, SigningPublicKey(서명 공개키) 타입에 대응합니다.\n저장소: 생성 시 유형과 길이가 지정됩니다.\n지원되는 유형:\nType Code Length (bytes) Since Endianness Usage Status DSA_SHA1020-BigLegacy onlyDeprecated ECDSA_SHA256_P2561320.9.12BigOlder DestinationsDeprecated ECDSA_SHA384_P3842480.9.12BigRareDeprecated ECDSA_SHA512_P5213660.9.12BigRareDeprecated RSA_SHA256_204845120.9.12BigOffline signing onlyDeprecated RSA_SHA384_307257680.9.12BigOffline signing onlyDeprecated RSA_SHA512_4096610240.9.12BigOffline signing onlyRecommended for SU3 EdDSA_SHA512_Ed255197320.9.15LittleCurrent standardRecommended EdDSA_SHA512_Ed25519ph8320.9.25LittleOffline signing onlyRare RedDSA_SHA512_Ed2551911320.9.39LittleEncrypted leasesets onlySpecialized **보안 요구사항:** - 암호학적으로 안전한 난수 소스를 사용해 생성할 것 - 적절한 접근 제어로 보호할 것 - 사용 후 메모리에서 안전하게 삭제할 것 - EdDSA의 경우: 32바이트 시드를 SHA-512로 해시하고, 처음 32바이트를 스칼라로 사용(clamped, 클램핑) - RedDSA의 경우: 키 생성 방식이 다름(클램핑 대신 모듈러 감소) JavaDoc: SigningPrivateKey 서명 Description: 데이터에 대한 암호학적 서명으로, SigningPrivateKey 타입(서명용 개인 키 타입)에 해당하는 서명 알고리즘을 사용합니다.\n유형 및 길이: 서명에 사용된 키 유형에서 유추됩니다.\n지원되는 유형:\nType Code Length (bytes) Since Endianness Usage Status DSA_SHA1040-BigLegacy onlyDeprecated ECDSA_SHA256_P2561640.9.12BigOlder DestinationsDeprecated ECDSA_SHA384_P3842960.9.12BigRareDeprecated ECDSA_SHA512_P52131320.9.12BigRareDeprecated RSA_SHA256_204842560.9.12BigOffline signing onlyDeprecated RSA_SHA384_307253840.9.12BigOffline signing onlyDeprecated RSA_SHA512_409665120.9.12BigOffline signing onlyCurrent for SU3 EdDSA_SHA512_Ed255197640.9.15LittleCurrent standardRecommended EdDSA_SHA512_Ed25519ph8640.9.25LittleOffline signing onlyRare RedDSA_SHA512_Ed2551911640.9.39LittleEncrypted leasesets onlySpecialized **형식 참고 사항:** - 다중 요소 서명(예: ECDSA R, S 값)은 각 요소를 선행 0으로 채워 length/2가 되도록 패딩됩니다 - EdDSA 및 RedDSA는 리틀 엔디언 인코딩을 사용합니다 - 그 밖의 모든 유형은 빅 엔디언 인코딩을 사용합니다 검증: - 해당하는 SigningPublicKey를 사용하십시오 - 키 유형에 맞는 서명 알고리즘 사양을 따르십시오 - 서명 길이가 해당 키 유형의 예상 길이와 일치하는지 확인하십시오\nJavaDoc: Signature 해시 설명: 데이터의 SHA-256 해시로, 무결성 검증과 식별을 위해 I2P 전반에서 사용됩니다.\n내용: 32 바이트 (256 비트)\n용도: - Router Identity 해시(네트워크 데이터베이스 키) - Destination 해시(네트워크 데이터베이스 키) - Leases에서 Tunnel 게이트웨이 식별 - 데이터 무결성 검증 - Tunnel ID 생성\n알고리즘: FIPS 180-4에 정의된 SHA-256\nJavaDoc: Hash 세션 태그 설명: 세션 식별 및 태그 기반 암호화에 사용되는 난수.\n중요: 세션 태그(Session Tag) 크기는 암호화 유형에 따라 달라집니다: - ElGamal/AES+SessionTag: 32 바이트 (레거시) - ECIES-X25519: 8 바이트 (현재 표준)\n현재 표준 (ECIES, 타원 곡선 통합 암호화 방식):\nContents: 8 bytes Usage: Ratchet-based encryption for Destinations and Routers 자세한 사양은 ECIES 및 ECIES-ROUTERS 를 참조하세요.\n레거시 (ElGamal/AES):\nContents: 32 bytes Usage: Deprecated encryption scheme 생성: 반드시 암호학적으로 안전한 난수 생성기를 사용해야 한다.\nJavaDoc: SessionTag (세션 태그)\nTunnelId Description: router의 tunnel 내 위치를 나타내는 고유 식별자입니다. tunnel의 각 홉은 고유한 TunnelId(터널에서 해당 홉의 위치를 나타내는 고유 ID)를 가집니다.\n형식:\nContents: 4-byte Integer (unsigned 32-bit) Range: Generally \u0026gt; 0 (zero reserved for special cases) 용도: - 각 router에서 수신/송신 tunnel 연결을 식별합니다 - tunnel 체인의 각 홉마다 서로 다른 TunnelId - 게이트웨이 tunnel을 식별하기 위해 Lease 구조체에서 사용됩니다\n특수 값: - 0 = 특수 프로토콜 용도로 예약됨(일반 운용에서는 사용을 피해야 함) - TunnelIds는 각 router에 대해 로컬에서만 유효합니다\nJavaDoc: TunnelId 인증서 명세 인증서 설명: I2P 전반에서 사용되는 영수증, 작업 증명, 또는 암호학적 메타데이터를 담는 컨테이너.\n형식:\n+----+----+----+----+----+----+-// |type| length | payload +----+----+----+----+----+----+-// type :: Integer (1 byte) Values: 0-5 (see types below) length :: Integer (2 bytes, big-endian) Size of payload in bytes payload :: data length -\u0026gt; $length bytes 총 크기: 최소 3바이트(NULL 인증서), 최대 65538바이트\n인증서 유형 Type Code Payload Length Total Size Status Usage NULL003CurrentDefault/empty certificate HASHCASH1VariesVariesDeprecatedUnused (was for proof-of-work) HIDDEN203DeprecatedUnused (hidden routers don't advertise) SIGNED340 or 7243 or 75DeprecatedUnused (DSA signature ± destination hash) MULTIPLE4VariesVariesDeprecatedUnused (multiple certificates) KEY54+7+CurrentSpecifies key types (see below) ### 키 인증서(유형 5) 소개: 버전 0.9.12 (2013년 12월)\nPurpose: 기본값이 아닌 키 유형을 지정하며, 표준 384바이트 KeysAndCert(키와 인증서) 구조를 넘어서는 초과 키 데이터를 저장합니다.\n페이로드 구조:\n+----+----+----+----+----+----+----+----+-// |SPKtype|CPKtype| Excess SPK data | +----+----+----+----+----+----+----+----+-// | Excess CPK data... | +----+----+----+----+----+----+----+----+ SPKtype :: Signing Public Key Type (2 bytes) See SigningPublicKey table above CPKtype :: Crypto Public Key Type (2 bytes) See PublicKey table above Excess SPK data :: Signing key bytes beyond 128 bytes Length: 0 to 65531 bytes Excess CPK data :: Crypto key bytes beyond 256 bytes Length: 0 to remaining space 중요 구현 참고 사항:\n키 유형 순서:\n경고: 서명 키 유형이 암호화 키 유형보다 먼저 옵니다 이는 직관에 반하지만 호환성을 위해 유지됩니다 순서: SPKtype, CPKtype (CPKtype, SPKtype 아님) KeysAndCert(키와 인증서 데이터 구조)에서의 키 데이터 레이아웃:\n[Crypto Public Key (partial/complete)] [Padding (if total key lengths \u0026lt; 384)] [Signing Public Key (partial/complete)] [Certificate Header (3 bytes)] [Key Certificate (4+ bytes)] [Excess Signing Key Data] [Excess Crypto Key Data] 초과 키 데이터 계산:\nCrypto Key \u0026gt; 256 바이트인 경우: Excess = (Crypto Length - 256) Signing Key \u0026gt; 128 바이트인 경우: Excess = (Signing Length - 128) Padding = max(0, 384 - Crypto Length - Signing Length) 예시 (ElGamal 암호 키):\nSigning Key Type Total SPK Length Padding Excess in Cert Total Structure Size DSA_SHA112800387 + 7 = 394 ECDSA_P25664640387 + 7 = 394 ECDSA_P38496320387 + 7 = 394 ECDSA_P52113204387 + 11 = 398 RSA_20482560128387 + 135 = 522 RSA_40965120384387 + 391 = 778 EdDSA32960387 + 7 = 394 **Router Identity 요구사항:** - NULL certificate(NULL 인증서)는 버전 0.9.15까지 사용됨 - Key Certificate(키 인증서)는 기본이 아닌 키 유형에 0.9.16부터 필요함 - X25519 암호화 키는 0.9.48부터 지원됨 Destination(목적지) 요구 사항: - NULL 인증서 또는 키 인증서(필요한 경우) - 기본값이 아닌 서명 키 유형에는 0.9.12부터 키 인증서가 필요 - 암호화 공개 키 필드는 0.6(2005)부터 사용되지 않지만 여전히 존재해야 함\n중요한 경고:\nNULL 대 KEY Certificate:\nElGamal+DSA_SHA1을 지정하는 types (0,0)의 KEY certificate(키 인증서)는 허용되지만 권장되지 않습니다 ElGamal+DSA_SHA1의 경우 항상 NULL certificate(NULL 인증서)를 사용하세요(정규 표현) (0,0)을 사용하는 KEY certificate는 4바이트 더 길며 호환성 문제를 일으킬 수 있습니다 일부 구현체는 (0,0) KEY certificate를 올바르게 처리하지 못할 수 있습니다 초과 데이터 검증:\n구현체는 키 유형에 대해 기대되는 길이와 인증서 길이가 일치하는지 반드시 검증해야 한다 키 유형과 부합하지 않는 초과 데이터가 포함된 인증서는 거부해야 한다 유효한 인증서 구조 뒤에 이어지는 trailing garbage data(끝부분의 불필요한 잔여 데이터)를 금지해야 한다 JavaDoc: Certificate 매핑 설명: 구성 및 메타데이터에 사용되는 키-값 속성 컬렉션.\n형식:\n+----+----+----+----+----+----+----+----+ | size | key_string (len + data)| = | +----+----+----+----+----+----+----+----+ | val_string (len + data) | ; | ... +----+----+----+----+----+----+----+ size :: Integer (2 bytes, big-endian) Total number of bytes that follow (not including size field) Range: 0 to 65535 key_string :: String Format: 1-byte length + UTF-8 data Length: 0-255 bytes = :: Single byte (0x3D, \u0026#39;=\u0026#39; character) val_string :: String Format: 1-byte length + UTF-8 data Length: 0-255 bytes ; :: Single byte (0x3B, \u0026#39;;\u0026#39; character) [Repeat key_string = val_string ; for additional entries] 크기 제한: - 키 길이: 0-255 바이트 (+ 길이 바이트 1개) - 값 길이: 0-255 바이트 (+ 길이 바이트 1개) - 전체 매핑 크기: 0-65535 바이트 (+ 크기 필드 바이트 2개) - 구조체의 최대 크기: 65537 바이트\n핵심 정렬 요구사항:\n서명된 구조체(RouterInfo, RouterAddress, Destination properties, I2CP SessionConfig)에서 매핑이 나타나는 경우, 서명 불변성을 보장하기 위해 항목은 키 순으로 반드시 정렬되어야 합니다:\n정렬 방법: 유니코드 코드 포인트 값(Unicode code point values)을 사용한 사전식 정렬 (Java String.compareTo()와 동일) 대소문자 구분: 키와 값은 일반적으로 대소문자를 구분함(애플리케이션에 따라 다름) 중복 키: 서명된 구조에서는 허용되지 않음(서명 검증 실패 발생) 문자 인코딩: UTF-8 바이트 수준 비교 정렬이 중요한 이유: - 서명은 바이트 표현을 기준으로 계산됩니다 - 키의 순서가 다르면 서로 다른 서명이 생성됩니다 - 서명되지 않은 매핑은 정렬이 필수는 아니지만 같은 관례를 따르는 것이 권장됩니다\n구현 참고 사항:\n인코딩 중복성:\n= 및 ; 구분자와 문자열 길이 바이트가 모두 존재합니다 이는 비효율적이지만 호환성을 위해 유지됩니다 길이 바이트가 기준이며; 구분자는 필요하지만 중복입니다 문자 지원:\n문서와 달리, 문자열 내에서는 =과 ;가 실제로 지원됩니다(길이 바이트가 이를 처리합니다) UTF-8 인코딩은 전체 유니코드를 지원합니다 경고: I2CP는 UTF-8을 사용하지만, I2NP는 역사적으로 UTF-8을 올바르게 처리하지 못했습니다 최대 호환성을 위해 가능한 경우 I2NP 매핑에는 ASCII를 사용하세요 특수 컨텍스트:\nRouterInfo/RouterAddress: 반드시 정렬되어야 하며, 중복이 없어야 함 I2CP SessionConfig: 반드시 정렬되어야 하며, 중복이 없어야 함 애플리케이션 매핑: 정렬을 권장하지만 항상 필요한 것은 아님 예시 (RouterInfo 옵션):\nMapping size: 45 bytes Sorted entries: caps=L (capabilities) netId=2 (network ID) router.version=0.9.67 JavaDoc: DataHelper 공통 구조 명세 키와 인증서 설명: 암호화 키, 서명 키, 인증서를 결합한 기본 구조. RouterIdentity와 Destination 모두로 사용됩니다.\n구조:\n+----+----+----+----+----+----+----+----+ | public_key | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | padding (optional) | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | signing_key | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | certificate | +----+----+----+-// public_key :: PublicKey (partial or full) Default: 256 bytes (ElGamal) Other sizes: As specified in Key Certificate padding :: Random data Length: 0 bytes or as needed CONSTRAINT: public_key + padding + signing_key = 384 bytes signing_key :: SigningPublicKey (partial or full) Default: 128 bytes (DSA_SHA1) Other sizes: As specified in Key Certificate certificate :: Certificate Minimum: 3 bytes (NULL certificate) Common: 7 bytes (Key Certificate with default keys) TOTAL LENGTH: 387+ bytes (never assume exactly 387!) 키 정렬: - 암호화 공개 키: 시작에 정렬됨 (바이트 0) - 패딩: 중간에 (필요한 경우) - 서명 공개 키: 끝에 정렬됨 (바이트 256부터 바이트 383까지) - 인증서: 바이트 384부터 시작\n크기 계산:\nTotal size = 384 + 3 + key_certificate_length For NULL certificate (ElGamal + DSA_SHA1): Total = 384 + 3 = 387 bytes For Key Certificate (EdDSA + X25519): Total = 384 + 3 + 4 = 391 bytes For larger keys (e.g., RSA_4096): Total = 384 + 3 + 4 + excess_key_data_length 패딩 생성 지침 (Proposal 161 ) 구현 버전: 0.9.57 (2023년 1월, 릴리스 2.1.0)\n배경: - ElGamal+DSA가 아닌 키의 경우, 384바이트 고정 길이 구조에 패딩이 존재함 - Destinations(목적지)의 경우, 256바이트 공개 키 필드는 0.6(2005)부터 사용되지 않음 - 패딩은 보안을 유지하면서도 압축 가능하도록 생성되어야 함\n요구 사항:\n최소 난수 데이터:\n암호학적으로 안전한 난수 데이터를 최소 32바이트 이상 사용하세요 이는 보안을 위해 충분한 엔트로피를 제공합니다 압축 전략:\n패딩/공개 키 필드 전체에 걸쳐 해당 32바이트를 반복 I2NP Database Store, 스트리밍 SYN, SSU2 핸드셰이크와 같은 프로토콜은 압축을 사용 보안을 저해하지 않으면서 상당한 대역폭 절감 예시:\nRouter 신원 (X25519 + EdDSA):\nStructure: - 32 bytes X25519 public key - 320 bytes padding (10 copies of 32-byte random data) - 32 bytes EdDSA public key - 7 bytes Key Certificate Compression savings: ~288 bytes when compressed Destination (목적지) (ElGamal-unused + EdDSA):\nStructure: - 256 bytes unused ElGamal field (11 copies of 32-byte random data, truncated to 256) - 96 bytes padding (3 copies of 32-byte random data) - 32 bytes EdDSA public key - 7 bytes Key Certificate Compression savings: ~320 bytes when compressed 이 방법이 통하는 이유:\n전체 구조의 SHA-256 해시는 여전히 모든 엔트로피를 포함합니다 네트워크 데이터베이스 DHT(분산 해시 테이블) 분산은 오직 해시에만 의존합니다 서명 키(32바이트 EdDSA/X25519)는 256비트의 엔트로피를 제공합니다 추가적인 32바이트의 반복된 난수 데이터 = 총 512비트 엔트로피 암호학적 강도 측면에서 충분하고도 남습니다 구현 참고 사항:\n387바이트 이상인 전체 구조체를 반드시 저장하고 전송해야 함 SHA-256 해시는 압축되지 않은 전체 구조체에 대해 계산됨 압축은 프로토콜 계층(I2NP, Streaming, SSU2)에서 적용됨 버전 0.6(2005) 이후의 모든 버전과 하위 호환 JavaDoc: KeysAndCert RouterIdentity (router 식별자) Description: I2P 네트워크에서 router를 고유하게 식별합니다. KeysAndCert와 동일한 구조입니다.\n형식: 위의 KeysAndCert 구조를 참조하세요\n현재 요구 사항(0.9.58 기준):\n필수 키 유형:\n암호화: X25519 (타원 곡선 기반 키 교환 알고리즘) (type 4, 32 바이트) 서명: EdDSA_SHA512_Ed25519 (Ed25519 기반 EdDSA 서명 알고리즘) (type 7, 32 바이트) 인증서: 키 인증서 (type 5) 사용 중단된 키 유형:\nElGamal (type 0)은 0.9.58부터 Router Identities에서 사용 중단되었습니다 DSA_SHA1 (type 0)은 0.9.58부터 Router Identities에서 사용 중단되었습니다 이러한 키는 새로운 router에는 절대 사용하면 안 됩니다 일반적인 크기:\nKey Certificate를 포함한 X25519 + EdDSA = 391바이트 32바이트 X25519 공개 키 320바이트 패딩 (Proposal 161 에 따라 압축 가능) 32바이트 EdDSA 공개 키 7바이트 인증서 (3바이트 헤더 + 4바이트 키 유형) 변천사: - 0.9.16 이전: 항상 NULL 인증서 사용 (ElGamal + DSA_SHA1) - 0.9.16-0.9.47: Key Certificate(키 인증서) 지원이 추가됨 - 0.9.48+: X25519 암호화 키 지원 - 0.9.58+: ElGamal 및 DSA_SHA1 더 이상 권장되지 않음\n네트워크 데이터베이스 키: - RouterInfo는 완전한 RouterIdentity의 SHA-256 해시를 키로 사용 - 해시는 패딩을 포함한 391바이트+의 전체 구조에 대해 계산됨\n참고: - 패딩 생성 지침 (제안서 161 ) - 위의 Key Certificate 사양\nJavaDoc: RouterIdentity 목적지 설명: 보안 메시지 전달을 위한 엔드포인트 식별자. 구조적으로는 KeysAndCert와 동일하지만, 사용 의미가 다릅니다.\n형식: 위의 KeysAndCert 구조를 참조하십시오\nRouterIdentity(라우터 식별자)와의 중요한 차이점: - 공개 키 필드는 사용되지 않으며 임의의 데이터가 포함될 수 있습니다 - 이 필드는 버전 0.6 (2005)부터 사용되지 않았습니다 - 원래는 구식 I2CP-to-I2CP 암호화를 위한 것이었습니다(비활성화됨) - 현재는 더 이상 권장되지 않는 LeaseSet 암호화를 위한 IV(초기화 벡터)로만 사용됩니다\n현재 권장 사항:\n서명 키:\n권장: EdDSA_SHA512_Ed25519 (유형 7, 32바이트) 대안: 구버전 호환을 위한 ECDSA 유형 지양: DSA_SHA1 (사용 중단됨, 권장하지 않음) 암호화 키:\n필드는 사용되지 않지만 반드시 존재해야 함 권장: Proposal 161 에 따라 무작위 데이터로 채울 것(압축 가능) 크기: 항상 256바이트(ElGamal에는 사용되지 않지만 ElGamal 슬롯) 인증서:\nElGamal + DSA_SHA1용 NULL 인증서(레거시 전용) 기타 모든 서명 키 유형에 대한 키 인증서 일반적인 최신 Destination(목적지):\nStructure: - 256 bytes unused field (random data, compressible) - 96 bytes padding (random data, compressible) - 32 bytes EdDSA signing public key - 7 bytes Key Certificate Total: 391 bytes Compression savings: ~320 bytes 실제 암호화 키: - Destination(목적지)를 위한 암호화 키는 LeaseSet에 있으며, Destination에 있지 않다 - LeaseSet에는 현재 암호화 공개키가 포함되어 있다 - 암호화 키 처리는 LeaseSet2 사양을 참조하세요\n네트워크 데이터베이스 키: - LeaseSet는 완전한 Destination(목적지)의 SHA-256 해시를 키로 사용 - 해시는 387바이트 이상인 전체 구조에 대해 계산됨\nJavaDoc: Destination 네트워크 데이터베이스 구조 Lease(리스; I2P에서 수신용 tunnel 정보를 담는 항목) 설명: 특정 tunnel에 Destination(목적지)에 대한 메시지를 수신할 수 있도록 권한을 부여합니다. 원래 LeaseSet 형식(type 1)의 일부입니다.\n형식:\n+----+----+----+----+----+----+----+----+ | tunnel_gw | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ | tunnel_id | end_date +----+----+----+----+----+----+----+----+ | +----+----+----+----+ tunnel_gw :: Hash (32 bytes) SHA-256 hash of the gateway RouterIdentity tunnel_id :: TunnelId (4 bytes) Tunnel identifier at the gateway router end_date :: Date (8 bytes) Expiration timestamp in milliseconds since epoch 총 크기: 44바이트\n사용: - 원래 LeaseSet(유형 1, 사용 중단됨)에서만 사용됨 - LeaseSet2 및 이후 변형에서는 대신 Lease2를 사용\nJavaDoc: Lease LeaseSet (I2P에서 목적지에 도달 가능한 tunnel과 키 정보를 포함하는 데이터 구조) (Type 1) 설명: 기존 LeaseSet 형식. Destination(목적지)에 대한 승인된 tunnels 및 키를 포함합니다. 네트워크 데이터베이스(netDb)에 저장됩니다. 상태: 사용 중단됨 (대신 LeaseSet2를 사용하세요).\n구조:\n+----+----+----+----+----+----+----+----+ | destination | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | encryption_key | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | signing_key | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | num| Lease 0 | +----+ + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | Lease 1 | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | Lease ($num-1) | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | signature | + + | | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ destination :: Destination Length: 387+ bytes encryption_key :: PublicKey (256 bytes, ElGamal) Used for end-to-end ElGamal/AES+SessionTag encryption Generated anew at each router startup (not persistent) signing_key :: SigningPublicKey (128+ bytes) Same type as Destination signing key Used for LeaseSet revocation (unimplemented) Generated anew at each router startup (not persistent) num :: Integer (1 byte) Number of Leases to follow Range: 0-16 leases :: Array of Lease structures Length: $num × 44 bytes Each Lease is 44 bytes signature :: Signature (40+ bytes) Length determined by Destination signing key type Signed by Destination\u0026#39;s SigningPrivateKey 데이터베이스 저장소: - 데이터베이스 유형: 1 - 키: Destination(목적지 식별자)의 SHA-256 해시 - 값: 완전한 LeaseSet 구조\n중요한 참고 사항:\nDestination(목적지 식별자) 공개 키는 사용되지 않음:\nDestination의 암호화용 공개 키 필드는 사용되지 않음 LeaseSet의 암호화 키가 실제 암호화 키임 임시 키:\nencryption_key는 임시 키입니다 (router 시작 시 재생성됨) signing_key는 임시 키입니다 (router 시작 시 재생성됨) 두 키 모두 재시작해도 유지되지 않습니다 철회(미구현):\nsigning_key는 LeaseSet(I2P에서 목적지 접근 정보를 담는 데이터 구조) 철회를 위해 의도되었음 철회 메커니즘은 한 번도 구현되지 않음 리스가 0개인 LeaseSet은 철회를 위해 의도되었으나 사용되지 않음 버전 관리/타임스탬프:\nLeaseSet에는 명시적인 published 타임스탬프 필드가 없다 버전은 모든 lease(LeaseSet을 구성하는 개별 항목)의 만료 시각 중 가장 이른 값이다 새로운 LeaseSet이 수락되려면 lease 만료 시각이 더 이른 값이어야 한다 Lease(리스: leaseSet을 구성하는 항목) 만료 게시:\n0.9.7 이전: 모든 lease를 동일한 만료 시간(가장 이른 시간)으로 게시 0.9.7+: 개별 lease의 실제 만료 시간을 게시 이는 구현상의 세부 사항이며, 명세의 일부가 아님 Lease 0개:\nLease(수신 터널 정보 항목)가 0개인 LeaseSet은 기술적으로 허용됩니다 철회 용도로 의도되었음(미구현) 실제로는 사용되지 않습니다 LeaseSet2 변형은 최소한 하나의 Lease가 필요합니다 사용 중단: LeaseSet type 1은 사용 중단되었습니다. 새 구현체는 **LeaseSet2 (type 3)**를 사용해야 하며, 다음을 제공합니다: - 발행 타임스탬프 필드(더 나은 버전 관리) - 다중 암호화 키 지원 - 오프라인 서명 기능 - 4바이트 리스(lease) 만료(8바이트 대비) - 더 유연한 옵션\nJavaDoc: LeaseSet LeaseSet 변형 Lease2 (I2P의 LeaseSet2를 구성하는 개별 항목) Description: 만료 시간을 4바이트로 표현하는 개선된 lease(리스) 형식. LeaseSet2 (type 3) 및 MetaLeaseSet (type 7)에서 사용됨.\n소개: 버전 0.9.38 (자세한 내용은 Proposal 123 참조)\n형식:\n+----+----+----+----+----+----+----+----+ | tunnel_gw | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ | tunnel_id | end_date | +----+----+----+----+----+----+----+----+ tunnel_gw :: Hash (32 bytes) SHA-256 hash of gateway RouterIdentity tunnel_id :: TunnelId (4 bytes) Tunnel identifier at gateway end_date :: 4-byte timestamp (seconds since epoch) Rolls over in year 2106 총 크기: 40바이트 (원래 Lease보다 4바이트 더 작음)\n원래 Lease(리스)와의 비교:\nFeature Lease (Type\u0026nbsp;1) Lease2 (Type\u0026nbsp;3+) Size44 bytes40 bytes Expiration Size8 bytes (ms)4 bytes (seconds) PrecisionMillisecondSecond RolloverYear\u0026nbsp;292,277,026,596Year\u0026nbsp;2106 Used InLeaseSet (deprecated)LeaseSet2, MetaLeaseSet **JavaDoc:** [Lease2](http://docs.i2p-projekt.de/javadoc/net/i2p/data/Lease2.html) 오프라인 서명 Description: 사전 서명된 임시 키를 위한 선택적 구조로, Destination(데스티네이션)의 개인 서명 키에 온라인으로 접근하지 않고도 LeaseSet을 게시할 수 있게 합니다.\n소개: 버전 0.9.38 (자세한 내용은 제안 123 참조)\n형식:\n+----+----+----+----+----+----+----+----+ | expires | sigtype | | +----+----+----+----+----+----+ + | transient_public_key | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | signature | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ expires :: 4-byte timestamp (seconds since epoch) Expiration of transient key validity Rolls over in year 2106 sigtype :: 2-byte signature type Type of transient_public_key (see SigningPublicKey types) transient_public_key :: SigningPublicKey Length determined by sigtype Temporary signing key for LeaseSet signature :: Signature Length determined by Destination\u0026#39;s signing key type Signature of (expires || sigtype || transient_public_key) Signed by Destination\u0026#39;s permanent SigningPrivateKey 목적: - 오프라인 LeaseSet 생성을 가능하게 함 - Destination(목적지 식별자) 마스터 키를 온라인 노출로부터 보호 - 오프라인 서명 없이 새로운 LeaseSet을 게시하여 임시 키를 폐기할 수 있음\n사용 시나리오:\n고보안 목적지:\n마스터 서명 키는 오프라인에 보관 (HSM, 콜드 스토리지) 제한된 기간 동안 사용할 임시 키를 오프라인에서 생성 침해된 임시 키로 인해 마스터 서명 키가 노출되지 않음 Encrypted LeaseSet 발행:\nEncryptedLeaseSet에는 오프라인 서명을 포함할 수 있습니다 Blinded public key(블라인딩된 공개키) + 오프라인 서명은 추가적인 보안을 제공합니다 보안 고려사항:\n만료 관리:\n합리적인 만료 기간을 설정하세요(수년이 아닌 수일~수주) 만료되기 전에 새로운 임시 키를 생성하세요 짧은 만료 기간 = 더 나은 보안, 더 많은 유지관리 키 생성:\n보안된 환경에서 오프라인으로 임시 키 생성 오프라인에서 마스터 키로 서명 서명된 임시 키 + 서명만 온라인 router로 전송 철회:\n오프라인 서명 없이 새로운 LeaseSet을 게시하여 암묵적으로 철회 또는 다른 transient key(일시적 키)를 사용한 새로운 LeaseSet을 게시 서명 검증:\nData to sign: expires (4 bytes) || sigtype (2 bytes) || transient_public_key Verification: 1. Extract Destination from LeaseSet 2. Get Destination\u0026#39;s SigningPublicKey 3. Verify signature over (expires || sigtype || transient_public_key) 4. Check that current time \u0026lt; expires 5. If valid, use transient_public_key to verify LeaseSet signature 구현 참고: - 총 크기는 sigtype 및 Destination(목적지)의 서명 키 유형에 따라 달라집니다 - 최소 크기: 4 + 2 + 32 (EdDSA 키) + 64 (EdDSA 서명) = 102 바이트 - 실질적인 최대 크기: ~600 바이트 (RSA-4096 임시 키 + RSA-4096 서명)\n다음과 호환됩니다: - LeaseSet2 (유형 3) - EncryptedLeaseSet (유형 5) - MetaLeaseSet (유형 7)\n참고: 오프라인 서명 프로토콜에 대한 자세한 내용은 제안 123 을 참조하세요.\nLeaseSet2Header(LeaseSet2의 헤더) 설명: LeaseSet2(유형 3) 및 MetaLeaseSet(유형 7)에 대한 공통 헤더 구조.\n소개: 버전 0.9.38 (제안 123 참조)\n형식:\n+----+----+----+----+----+----+----+----+ | destination | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | published | expires | flags | +----+----+----+----+----+----+----+----+ | offline_signature (optional) | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ destination :: Destination Length: 387+ bytes published :: 4-byte timestamp (seconds since epoch) Publication time of this LeaseSet Rolls over in year 2106 expires :: 2-byte offset (seconds) Offset from published timestamp Maximum: 65535 seconds (18.2 hours) flags :: 2 bytes (bit flags) See flag definitions below offline_signature :: OfflineSignature (optional) Present only if flags bit 0 is set Variable length 최소 총 크기: 395 바이트 (오프라인 서명 제외)\n플래그 정의 (비트 순서: 15 14 \u0026hellip; 3 2 1 0):\nBit Name Description 0Offline Keys0 = No offline keys, 1 = Offline signature present 1Unpublished0 = Standard published, 1 = Unpublished (client-side only) 2Blinded0 = Standard, 1 = Will be blinded when published 3-15ReservedMust be 0 for compatibility **플래그 세부 정보:** 비트 0 - 오프라인 키: - 0: 오프라인 서명이 없으며, Destination(목적지)의 서명 키로 LeaseSet 서명을 검증 - 1: OfflineSignature(오프라인 서명) 구조가 flags 필드 뒤에 이어짐\n비트 1 - 미게시: - 0: 표준으로 게시된 LeaseSet이며, floodfills로 전파되어야 함 - 1: 미게시 LeaseSet (클라이언트 측 전용) - 전파되거나 게시되거나 쿼리에 대한 응답으로 전송되어서는 안 됨 - 만료된 경우, 대체 항목을 찾기 위해 netdb를 쿼리하지 말 것(비트 2도 설정된 경우는 예외) - 로컬 tunnels 또는 테스트용으로 사용\n비트 2 - Blinded(블라인드 처리) (0.9.42부터): - 0: 표준 LeaseSet - 1: 이 암호화되지 않은 LeaseSet은 게시 시 blinded 및 암호화됩니다 - 게시된 버전은 EncryptedLeaseSet (type 5)입니다 - 만료되면 대체본을 위해 netdb의 blinded location을 조회합니다 - 비트 1도 1로 설정해야 합니다(미게시 + blinded) - 암호화된 은닉 서비스에 사용됩니다\n만료 제한:\nLeaseSet Type Maximum Expires Value Maximum Actual Time LeaseSet2 (type 3)≈660 seconds≈11 minutes MetaLeaseSet (type 7)65,535 seconds≈18.2 hours **발행 타임스탬프 요구사항:** LeaseSet (타입 1)에는 published 필드가 없어 버전 관리를 위해 가장 이른 lease(리스: I2P의 임시 통신 경로 항목) 만료 시점을 찾아야 했다. LeaseSet2는 1초 해상도의 명시적인 published 타임스탬프를 추가한다.\n중요 구현 참고: - Routers는 각 Destination(목적지 식별자)마다 LeaseSet 게시 빈도를 초당 한 번보다 훨씬 느리게 제한해야 한다 - 더 빠르게 게시해야 한다면, 각 새로운 LeaseSet의 published 시간이 최소 1초 이후가 되도록 보장하라 - published 시간이 현재 버전보다 더 새롭지 않으면 Floodfills는 LeaseSet을 거부한다 - 권장 최소 간격: 게시 간 10-60초\n계산 예제:\nLeaseSet2 (최대 11분):\npublished = 1704067200 (2024-01-01 00:00:00 UTC) expires = 660 (seconds) Actual expiration = 1704067200 + 660 = 1704067860 (2024-01-01 00:11:00 UTC) MetaLeaseSet(메타 leaseSet) (최대 18.2시간):\npublished = 1704067200 (2024-01-01 00:00:00 UTC) expires = 65535 (seconds) Actual expiration = 1704067200 + 65535 = 1704132735 (2024-01-01 18:12:15 UTC) 버전 관리: - published 타임스탬프가 더 크면 LeaseSet은 \u0026lsquo;더 최신\u0026rsquo;으로 간주됩니다 - Floodfills는 가장 최신 버전만 저장하고 전파합니다 - 가장 오래된 Lease(터널 임대 엔트리)가 이전 LeaseSet의 가장 오래된 Lease와 일치하는 경우에 주의하세요\nLeaseSet2 (유형 3) 설명: 여러 개의 암호화 키, 오프라인 서명 및 서비스 레코드를 지원하는 최신 LeaseSet(서비스 주소 데이터 구조) 형식입니다. I2P 히든 서비스의 현재 표준입니다.\n소개: 버전 0.9.38 (Proposal 123 참조)\n구조:\n+----+----+----+----+----+----+----+----+ | ls2_header | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | options | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ |numk| keytype0| keylen0 | | +----+----+----+----+----+ + | encryption_key_0 | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | keytypen| keylenn | | +----+----+----+----+ + | encryption_key_n | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | num| Lease2 0 | +----+ + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | Lease2($num-1) | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | signature | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ ls2header :: LeaseSet2Header Length: 395+ bytes (varies with offline signature) options :: Mapping Key-value pairs for service records and metadata Length: 2+ bytes (size field + data) numk :: Integer (1 byte) Number of encryption keys Range: 1 to (implementation-defined maximum, typically 8) keytype :: 2-byte encryption type See PublicKey type table keylen :: 2-byte key length Must match keytype specification encryption_key :: PublicKey Length: keylen bytes Type: keytype [Repeat keytype/keylen/encryption_key for each key] num :: Integer (1 byte) Number of Lease2s Range: 1-16 (at least one required) leases :: Array of Lease2 structures Length: $num × 40 bytes signature :: Signature Length determined by signing key type Signed over entire structure including database type prefix 데이터베이스 저장 방식: - 데이터베이스 유형: 3 - 키: Destination(I2P 목적지 식별자)의 SHA-256 해시 - 값: 완전한 LeaseSet2 구조체\n서명 계산:\nData to sign: database_type (1 byte, value=3) || complete LeaseSet2 data Verification: 1. Prepend database type byte (0x03) to LeaseSet2 data 2. If offline signature present: - Verify offline signature against Destination key - Verify LeaseSet2 signature against transient key 3. Else: - Verify LeaseSet2 signature against Destination key 암호화 키 선호 순서 공개된 (서버) LeaseSet의 경우: - 키는 서버 선호도 순으로 나열(가장 선호되는 것부터) - 여러 유형을 지원하는 클라이언트는 서버 선호도를 준수해야 한다 - 목록에서 지원되는 첫 번째 유형을 선택 - 일반적으로 번호가 더 높은(더 최신) 키 유형이 보안성과 효율성이 더 높다 - 권장 순서: 키를 유형 코드의 역순으로 나열(최신이 먼저)\n서버 설정 예시:\nnumk = 2 Key 0: X25519 (type 4, 32 bytes) [Most preferred] Key 1: ElGamal (type 0, 256 bytes) [Legacy compatibility] 게시되지 않은(클라이언트) LeaseSet: - 키 순서는 실제로 중요하지 않습니다(클라이언트에 대한 연결 시도가 드뭅니다) - 일관성을 위해 동일한 관례를 따르십시오\n클라이언트 키 선택: - 서버의 선호를 존중 (지원되는 유형 중 첫 번째를 선택) - 또는 구현에서 정의한 선호도 사용 - 또는 양측의 기능을 기반으로 결합된 선호도를 결정\n옵션 매핑 요구 사항: - 옵션은 키 기준으로 반드시 정렬되어야 함 (사전식(lexicographic), UTF-8 바이트 순서) - 정렬은 서명 불변성을 보장함 - 중복 키는 허용되지 않음\n표준 형식 (제안 167 ):\nAPI 0.9.66(2025년 6월, 릴리스 2.9.0) 기준으로, service record(서비스 레코드) 옵션은 표준화된 형식을 따릅니다. 전체 사양은 Proposal 167 을 참조하세요.\n서비스 레코드 옵션 형식:\nKey: _service._proto Value: record_type ttl [priority weight] port target [appoptions] service :: Symbolic name of service (lowercase, [a-z0-9-]) Examples: smtp, http, irc, mumble Use standard identifiers from IANA Service Name Registry or Linux /etc/services when available proto :: Transport protocol (lowercase, [a-z0-9-]) \u0026#34;tcp\u0026#34; = streaming protocol \u0026#34;udp\u0026#34; = repliable datagrams Protocol indicators for raw datagrams may be defined later record_type :: \u0026#34;0\u0026#34; (self-reference) or \u0026#34;1\u0026#34; (SRV record) ttl :: Time to live in seconds (positive integer) Recommended minimum: 86400 (one day) Prevents frequent re-queries For record_type = 0 (self-reference): port :: I2CP port number (non-negative integer) appoptions :: Optional application-specific data (no spaces or commas) For record_type = 1 (SRV record): priority :: Lower value = more preferred (non-negative integer) weight :: Relative weight for same priority, higher = more likely (non-negative) port :: I2CP port number (non-negative integer) target :: Hostname or b32 of destination (lowercase) Format: \u0026#34;example.i2p\u0026#34; or \u0026#34;aaaaa...aaaa.b32.i2p\u0026#34; Recommend b32 unless hostname is \u0026#34;well known\u0026#34; appoptions :: Optional application-specific data (no spaces or commas) 서비스 레코드 예시:\n1. 자기-참조 SMTP 서버:\nDestination: aaaa...aaaa.b32.i2p (this LeaseSet) Option: \u0026#34;_smtp._tcp\u0026#34; = \u0026#34;0 999999 25\u0026#34; Meaning: This destination provides SMTP service on I2CP port 25 2. 단일 외부 SMTP 서버:\nDestination: aaaa...aaaa.b32.i2p (this LeaseSet) Option: \u0026#34;_smtp._tcp\u0026#34; = \u0026#34;1 86400 0 0 25 bbbb...bbbb.b32.i2p\u0026#34; Meaning: SMTP service provided by bbbb...bbbb on port 25 TTL = 1 day, single server (priority=0, weight=0) 3. 여러 SMTP 서버(부하 분산):\nDestination: aaaa...aaaa.b32.i2p (this LeaseSet) Option: \u0026#34;_smtp._tcp\u0026#34; = \u0026#34;1 86400 0 0 25 bbbb...bbbb.b32.i2p,1 86400 1 0 25 cccc...cccc.b32.i2p\u0026#34; Meaning: Two SMTP servers bbbb...bbbb (priority=0, preferred) cccc...cccc (priority=1, backup) 4. 앱 옵션이 있는 HTTP 서비스:\nOption: \u0026#34;_http._tcp\u0026#34; = \u0026#34;0 86400 80 tls=1.3;cert=ed25519\u0026#34; Meaning: HTTP on port 80 with TLS 1.3 and EdDSA certificates TTL(Time To Live) 권장 사항: - 최소: 86400초 (1일) - 더 긴 TTL은 netdb 쿼리 부하를 줄입니다 - 쿼리 감소와 서비스 업데이트 전파 간의 균형 - 안정적인 서비스의 경우: 604800 (7일) 이상\n구현 참고 사항:\n암호화 키 (0.9.44 기준):\nElGamal (유형 0, 256바이트): 레거시 호환성 X25519 (유형 4, 32바이트): 현재 표준 MLKEM 변형: 포스트-양자 (베타, 최종 확정 아님) 키 길이 유효성 검사:\nFloodfills와 클라이언트는 알 수 없는 키 유형도 반드시 파싱할 수 있어야 합니다 알 수 없는 키를 건너뛰기 위해 keylen 필드를 사용하세요 키 유형이 알 수 없는 경우에도 파싱을 실패로 처리하지 마십시오 발행 타임스탬프:\n발행 속도 제한(rate-limiting)에 관한 LeaseSet2Header의 참고 사항을 참조하십시오 발행 간 최소 증가 간격 1초 권장: 발행 간 10-60초 암호화 유형 마이그레이션:\n여러 키 사용으로 점진적 마이그레이션 지원 전환 기간 동안 기존 키와 새 키를 모두 나열 충분한 클라이언트 업그레이드 기간 이후 기존 키 제거 JavaDoc: LeaseSet2 MetaLease 설명: tunnels 대신 다른 LeaseSets를 참조할 수 있는 MetaLeaseSet(메타 형태의 LeaseSet 유형)을 위한 Lease 구조. 부하 분산과 이중화를 위해 사용된다.\n소개: 버전 0.9.38, 0.9.40에서 적용 예정 (참고 Proposal 123 )\n형식:\n+----+----+----+----+----+----+----+----+ | tunnel_gw | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ | flags |cost| end_date | +----+----+----+----+----+----+----+----+ tunnel_gw :: Hash (32 bytes) SHA-256 hash of: - Gateway RouterIdentity (for type 1), OR - Another MetaLeaseSet destination (for type 3/5/7) flags :: 3 bytes Bit order: 23 22 ... 3 2 1 0 Bits 3-0: Entry type (see table below) Bits 23-4: Reserved (must be 0) cost :: 1 byte (0-255) Lower value = higher priority Used for load balancing end_date :: 4-byte timestamp (seconds since epoch) Expiration time Rolls over in year 2106 총 크기: 40 바이트\n엔트리 유형 (플래그 비트 3-0):\nType Code Description Unknown0Unknown/invalid entry LeaseSet1Points to LeaseSet (type 1, deprecated) LeaseSet23Points to LeaseSet2 (type 3) EncryptedLeaseSet5Points to EncryptedLeaseSet (type 5) MetaLeaseSet7Points to another MetaLeaseSet (type 7) **사용 시나리오:** 부하 분산:\n여러 MetaLease(개별 LeaseSet을 가리키는 엔트리) 엔트리가 포함된 MetaLeaseSet(여러 LeaseSet을 묶는 메타 집합) 각 엔트리는 서로 다른 LeaseSet2(LeaseSet의 새로운 버전)를 가리킵니다 클라이언트는 cost 필드를 기준으로 선택합니다 이중화:\n백업 LeaseSets를 가리키는 여러 항목 기본 LeaseSet을 사용할 수 없을 때의 대체 서비스 마이그레이션:\nMetaLeaseSet이 새로운 LeaseSet을 가리킴 Destinations(데스티네이션, I2P의 목적지/주소 식별자) 간 원활한 전환을 허용 Cost 필드 사용: - 낮은 Cost = 더 높은 우선순위 - Cost 0 = 가장 높은 우선순위 - Cost 255 = 가장 낮은 우선순위 - 클라이언트는 더 낮은 Cost의 항목을 선호하는 것이 권장됩니다 - 동일한 Cost의 항목은 무작위로 부하 분산될 수 있습니다\nLease2와의 비교:\nFeature Lease2 MetaLease Size40 bytes40 bytes Tunnel ID4 bytesReplaced by flags (3 bytes) + cost (1 byte) Points ToSpecific tunnelLeaseSet or MetaLeaseSet UsageDirect tunnel referenceIndirection/load balancing **JavaDoc:** [MetaLease](http://docs.i2p-projekt.de/javadoc/net/i2p/data/MetaLease.html) MetaLeaseSet(메타 리스셋) (유형 7) 설명: MetaLease(다른 LeaseSet에 대한 간접 참조를 제공하는 메타 항목) 항목을 포함하는 LeaseSet의 변형으로, 이를 통해 다른 LeaseSet에 대한 간접 참조를 제공합니다. 부하 분산, 중복성, 서비스 마이그레이션에 사용됩니다.\n소개: 0.9.38에서 정의되었으며, 0.9.40에서 동작하도록 예정됨 ( 제안 123 참조)\n상태: 명세가 완료되었습니다. 프로덕션 배포 상태는 현재 I2P 릴리스에서 확인해야 합니다.\n구조:\n+----+----+----+----+----+----+----+----+ | ls2_header | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | options | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | num| MetaLease 0 | +----+ + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | MetaLease($num-1) | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ |numr| | +----+ + | revocation_0 | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | revocation_n | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | signature | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ ls2header :: LeaseSet2Header Length: 395+ bytes options :: Mapping Length: 2+ bytes (size + data) MUST be sorted by key num :: Integer (1 byte) Number of MetaLease entries Range: 1 to (implementation-defined, recommend 1-16) metaleases :: Array of MetaLease structures Length: $num × 40 bytes numr :: Integer (1 byte) Number of revocation hashes Range: 0 to (implementation-defined, recommend 0-16) revocations :: Array of Hash structures Length: $numr × 32 bytes SHA-256 hashes of revoked LeaseSet Destinations 데이터베이스 저장: - 데이터베이스 유형: 7 - 키: Destination의 SHA-256 해시 - 값: 완전한 MetaLeaseSet(메타 리스셋) 구조\n서명 계산:\nData to sign: database_type (1 byte, value=7) || complete MetaLeaseSet data Verification: 1. Prepend database type byte (0x07) to MetaLeaseSet data 2. If offline signature present in header: - Verify offline signature against Destination key - Verify MetaLeaseSet signature against transient key 3. Else: - Verify MetaLeaseSet signature against Destination key 사용 시나리오:\n1. 부하 분산:\nMetaLeaseSet for primary.i2p: MetaLease 0: cost=0, points to server1.i2p LeaseSet2 MetaLease 1: cost=0, points to server2.i2p LeaseSet2 MetaLease 2: cost=0, points to server3.i2p LeaseSet2 Clients randomly select among equal-cost entries 2. Failover(장애 조치):\nMetaLeaseSet for service.i2p: MetaLease 0: cost=0, points to primary.i2p LeaseSet2 MetaLease 1: cost=100, points to backup.i2p LeaseSet2 Clients prefer cost=0 (primary), fall back to cost=100 (backup) 3. 서비스 마이그레이션:\nMetaLeaseSet for old-domain.i2p: MetaLease 0: cost=0, points to new-domain.i2p LeaseSet2 Transparently redirects clients from old to new destination 4. 다층 아키텍처:\nMetaLeaseSet for service.i2p: MetaLease 0: cost=0, points to region1-meta.i2p (another MetaLeaseSet) MetaLease 1: cost=0, points to region2-meta.i2p (another MetaLeaseSet) Each region MetaLeaseSet points to regional servers Allows hierarchical load balancing 철회 목록:\n무효화 목록은 MetaLeaseSet(메타 LeaseSet)이 이전에 게시된 LeaseSets를 명시적으로 무효화할 수 있게 합니다:\n목적: 특정 Destination을 더 이상 유효하지 않도록 표시 내용: 폐기된 Destination 구조체의 SHA-256 해시 사용: Destination 해시가 폐기 목록에 포함된 LeaseSet은 클라이언트가 사용해서는 안 된다 일반적인 값: 대부분의 배포에서 비어 있음(numr=0) 예시 철회:\nService migrates from dest-v1.i2p to dest-v2.i2p: MetaLease 0: points to dest-v2.i2p Revocations: [hash(dest-v1.i2p)] Clients will use v2 and ignore v1 even if cached 만료 처리:\nMetaLeaseSet(메타 LeaseSet)은 최대 expires=65535초(약 18.2시간)인 LeaseSet2Header를 사용합니다:\nLeaseSet2보다 만료 시간이 훨씬 더 김(최대 ~11분) 상대적으로 정적인 간접 참조에 적합 참조된 LeaseSets의 만료 시간은 더 짧을 수 있음 클라이언트는 MetaLeaseSet(메타 LeaseSet)과 참조된 LeaseSets 둘 다의 만료 시간을 확인해야 함 옵션 매핑:\nLeaseSet2 옵션과 동일한 형식을 사용 서비스 레코드를 포함할 수 있음 (Proposal 167 ) 반드시 키로 정렬되어야 함 서비스 레코드는 일반적으로 간접화 구조(indirection structure)가 아니라 최종 서비스(ultimate service)를 설명함 클라이언트 구현 참고 사항:\n해결 절차:\n1. Query netdb for MetaLeaseSet using SHA-256(Destination) 2. Parse MetaLeaseSet, extract MetaLease entries 3. Sort entries by cost (lower = better) 4. For each entry in cost order: a. Extract LeaseSet hash from tunnel_gw field b. Determine entry type from flags c. Query netdb for referenced LeaseSet (may be another MetaLeaseSet) d. Check revocation list e. Check expiration f. If valid, use the LeaseSet; else try next entry 캐싱:\nMetaLeaseSet(여러 LeaseSet을 묶어 참조하는 메타 세트)와 참조된 LeaseSets(목적지의 tunnel 라우팅 정보를 담은 데이터 세트) 모두를 캐시 두 레벨 모두의 만료 여부를 확인 업데이트된 MetaLeaseSet 게시를 모니터링 장애 조치:\n선호 엔트리가 실패하면, 다음으로 낮은 비용의 엔트리를 시도 실패한 엔트리를 일시적으로 사용 불가로 표시하는 것을 고려 복구 여부를 주기적으로 다시 확인 구현 상태:\n제안 123 는 일부 부분이 “개발 중” 상태로 남아 있음을 명시합니다. 구현자들은 다음을 수행해야 합니다: - 대상 I2P 버전에서 운영 환경 투입 준비 여부를 확인 - 배포 전에 MetaLeaseSet(메타 leaseSet 구조) 지원을 테스트 - 최신 I2P 릴리스에서 업데이트된 사양이 있는지 확인\nJavaDoc: MetaLeaseSet EncryptedLeaseSet (유형 5) Description: 프라이버시 강화를 위해 암호화되고 블라인딩된 LeaseSet입니다. 블라인딩된 공개 키와 메타데이터만 보이며, 실제 리스와 암호화 키는 암호화되어 있습니다.\n소개: 0.9.38에서 정의, 0.9.39에서 동작 (Proposal 123 참조)\n구조:\n+----+----+----+----+----+----+----+----+ | sigtype | | +----+----+ + | blinded_public_key | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | published | expires | flags | +----+----+----+----+----+----+----+----+ | offline_signature (optional) | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | len | | +----+----+ + | encrypted_data | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | signature | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ sigtype :: 2-byte signature type Type of blinded_public_key MUST be RedDSA_SHA512_Ed25519 (type 11) blinded_public_key :: SigningPublicKey (32 bytes for RedDSA) Blinded version of Destination signing key Used to verify signature on EncryptedLeaseSet published :: 4-byte timestamp (seconds since epoch) Publication time Rolls over in year 2106 expires :: 2-byte offset (seconds) Offset from published Maximum: 65535 seconds (18.2 hours) Practical maximum for LeaseSet data: ~660 seconds (~11 min) flags :: 2 bytes Bit 0: Offline signature present (0=no, 1=yes) Bit 1: Unpublished (0=published, 1=client-side only) Bits 15-2: Reserved (must be 0) offline_signature :: OfflineSignature (optional) Present only if flags bit 0 = 1 Variable length len :: 2-byte integer Length of encrypted_data Range: 1 to 65535 encrypted_data :: Encrypted payload Length: len bytes Contains encrypted LeaseSet2 or MetaLeaseSet signature :: Signature (64 bytes for RedDSA) Length determined by sigtype Signed by blinded_public_key or transient key 데이터베이스 저장소: - 데이터베이스 유형: 5 - 키: blinded Destination(익명화 처리된 Destination)의 SHA-256 해시 (원래 Destination이 아님) - 값: 완전한 EncryptedLeaseSet 구조체\nLeaseSet2와의 핵심 차이점:\nLeaseSet2Header 구조를 사용하지 않습니다 (유사한 필드를 갖지만 레이아웃이 다름) 블라인드된 공개 키를 전체 Destination(I2P 목적지 식별자) 대신 사용 암호화된 페이로드를 평문의 leases와 키 대신 사용 데이터베이스 키는 블라인드된 Destination의 해시입니다, 원래 Destination이 아닙니다 서명 계산:\nData to sign: database_type (1 byte, value=5) || complete EncryptedLeaseSet data Verification: 1. Prepend database type byte (0x05) to EncryptedLeaseSet data 2. If offline signature present (flags bit 0 = 1): - Verify offline signature against blinded public key - Verify EncryptedLeaseSet signature against transient key 3. Else: - Verify EncryptedLeaseSet signature against blinded public key 서명 유형 요구 사항:\n반드시 RedDSA_SHA512_Ed25519 (type 11)을 사용해야 합니다: - 32바이트 블라인딩된 공개키 - 64바이트 서명 - 블라인딩 보안 속성을 위해 필수 - 참조 [Red25519 specification](//docs/specs/red25519-signature-scheme/\nEdDSA와의 주요 차이점: - 개인 키는 modular reduction(모듈러 환원)로 생성(clamping(클램핑) 아님) - 서명에 80바이트의 난수 데이터 포함 - 공개 키를 직접 사용(해시가 아님) - 안전한 blinding(블라인딩; 원본을 숨기기 위한 난수 마스킹) 연산을 가능하게 함\n블라인딩과 암호화:\n자세한 내용은 EncryptedLeaseSet 사양 을 참조하세요:\n1. 키 블라인딩:\nBlinding process (daily rotation): secret = HKDF(original_signing_private_key, date_string, \u0026#34;i2pblinding1\u0026#34;) alpha = SHA-256(secret) mod L (where L is Ed25519 group order) blinded_private_key = alpha * original_private_key blinded_public_key = alpha * original_public_key 2. 데이터베이스 위치:\nClient publishes to: Key = SHA-256(blinded_destination) Where blinded_destination uses: - Blinded public key (signing key) - Same unused public key field (random) - Same certificate structure 3. 암호화 계층(3계층):\n레이어 1 - 인증 레이어 (클라이언트 액세스): - 암호화: ChaCha20 스트림 암호 - 키 파생: 클라이언트별 비밀값을 사용하는 HKDF(해시 기반 키 파생 함수) - 인증된 클라이언트는 외부 레이어를 복호화할 수 있음\n레이어 2 - 암호화 계층: - 암호화: ChaCha20 - 키: 클라이언트와 서버 간 DH(디피-헬먼 키 교환)에서 파생 - 실제 LeaseSet2 또는 MetaLeaseSet을 포함\n레이어 3 - 내부 LeaseSet: - 완전한 LeaseSet2 또는 MetaLeaseSet - 모든 tunnels, 암호화 키, 옵션 포함 - 성공적으로 복호화된 후에만 접근 가능\n암호화 키 파생:\nClient has: ephemeral_client_private_key Server has: ephemeral_server_public_key (in encrypted_data) Shared secret = X25519(client_private, server_public) Encryption key = HKDF(shared_secret, context_info, \u0026#34;i2pblinding2\u0026#34;) 발견 과정:\n인가된 클라이언트용:\n1. Client knows original Destination 2. Client computes current blinded Destination (based on current date) 3. Client computes database key: SHA-256(blinded_destination) 4. Client queries netdb for EncryptedLeaseSet using blinded key 5. Client decrypts layer 1 using authorization credentials 6. Client decrypts layer 2 using DH shared secret 7. Client extracts inner LeaseSet2/MetaLeaseSet 8. Client uses tunnels from inner LeaseSet for communication 권한 없는 클라이언트의 경우: - EncryptedLeaseSet(암호화된 leaseSet)을 찾아도 복호화할 수 없음 - 블라인딩된 버전만으로는 원래 Destination(I2P 목적지 주소)를 판별할 수 없음 - 서로 다른 블라인딩 기간(매일 로테이션) 간에는 EncryptedLeaseSets를 연계할 수 없음\n만료 시간:\nContent Type Maximum Expires Notes EncryptedLeaseSet (outer)65,535 sec (≈18.2 hr)Full 2-byte expires field Inner LeaseSet2≈660 sec (≈11 min)Actual lease data practical maximum Inner MetaLeaseSet65,535 sec (≈18.2 hr)Indirection can be longer-lived **게시 타임스탬프:** LeaseSet2Header와 동일한 요구사항: - 게시 간 타임스탬프는 최소 1초 이상 증가해야 함 - 현재 버전보다 최신이 아니면 floodfill(네트워크 데이터베이스를 유지·배포하는 노드)들이 거부함 - 권장: 게시 간 간격 10-60초\n암호화된 LeaseSets(목적지의 수신 tunnel 입구 정보 모음)와 함께하는 오프라인 서명:\n오프라인 서명 사용 시 특별 고려사항: - 블라인딩된 공개 키는 매일 순환됨 - 오프라인 서명은 새 블라인딩된 키로 매일 다시 생성해야 함 - 또는 외부 EncryptedLeaseSet이 아닌 내부 LeaseSet에 오프라인 서명을 사용 - Proposal 123 노트 참고\n구현 참고 사항:\n클라이언트 인가:\n여러 클라이언트를 서로 다른 키로 인가할 수 있습니다 각 인가된 클라이언트는 고유한 복호화 자격 증명을 가집니다 인가 키를 변경하여 클라이언트의 접근 권한을 해지할 수 있습니다 일일 키 로테이션:\n블라인딩된 키는 UTC 기준 자정에 변경됩니다 클라이언트는 매일 블라인딩된 Destination(목적지 식별자)을 재계산해야 합니다 기존 EncryptedLeaseSets는 로테이션 후 더 이상 발견할 수 없게 됩니다 프라이버시 특성:\nFloodfills는 원래 Destination(I2P 주소)를 판별할 수 없음 권한이 없는 클라이언트는 서비스에 접근할 수 없음 서로 다른 blinding(블라인딩) 기간은 연계될 수 없음 만료 시간 외에는 평문 메타데이터가 없음 성능:\n클라이언트는 매일 blinding(블라인딩, 암호학적 가림) 계산을 수행해야 함 3중 암호화로 인해 계산 오버헤드가 증가함 복호화된 내부 LeaseSet을 캐싱하는 것을 고려 보안 고려사항:\n인가 키 관리:\n클라이언트 인가 자격 증명을 안전하게 배포 세밀한 단위의 철회를 위해 클라이언트별 고유 자격 증명 사용 인가 키를 주기적으로 교체 클록 동기화:\nDaily blinding(암호학적 가림 기법)은 동기화된 UTC 날짜에 의존함 시계 오차는 조회 실패를 유발할 수 있음 허용오차를 위해 전날/다음 날 blinding도 지원하는 것을 고려 메타데이터 유출:\nPublished 및 expires 필드는 평문이다 패턴 분석으로 서비스 특성이 드러날 수 있다 우려된다면 발행 간격을 무작위화하라 JavaDoc: EncryptedLeaseSet Router 구조 RouterAddress (router 주소) 설명: 특정 전송 프로토콜을 통해 router의 연결 정보를 정의합니다.\n형식:\n+----+----+----+----+----+----+----+----+ |cost| expiration +----+----+----+----+----+----+----+----+ | transport_style | +----+----+----+----+-//-+----+----+----+ | | + + | options | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ cost :: Integer (1 byte) Relative cost, 0=free, 255=expensive Typical values: 5-6: SSU2 10-11: NTCP2 expiration :: Date (8 bytes) MUST BE ALL ZEROS (see critical note below) transport_style :: String (1-256 bytes) Transport protocol name Current values: \u0026#34;SSU2\u0026#34;, \u0026#34;NTCP2\u0026#34; Legacy: \u0026#34;SSU\u0026#34;, \u0026#34;NTCP\u0026#34; (removed) options :: Mapping Transport-specific configuration Common options: \u0026#34;host\u0026#34;, \u0026#34;port\u0026#34; Transport-specific options vary 치명적 - 만료 필드:\n⚠️ 만료 필드는 반드시 모두 0(제로)로 설정해야 합니다(0 값 바이트 8개).\n이유: 릴리스 0.9.3 이후 0이 아닌 Expiration(만료 시간 필드) 값은 서명 검증 실패를 초래함 이력: Expiration은 원래 사용되지 않았으며, 항상 null이었음 현재 상태: 0.9.12 기준으로 필드가 다시 인식되었지만, 네트워크 업그레이드를 기다려야 함 구현: 항상 0x0000000000000000으로 설정 만료 시간이 0이 아닌 경우 RouterInfo(라우터 정보 레코드) 서명 검증이 실패합니다.\n전송 프로토콜 현재 프로토콜(2.10.0 기준):\nProtocol Status Introduced Removed Notes SSU2Current0.9.54 (May 2022)-Default since 0.9.56 NTCP2Current0.9.36 (Aug 2018)-Active NTCPRemoved-0.9.50 (May 2021)Use NTCP2 SSURemoved-2.4.0 (Dec 2023)Use SSU2 **전송 스타일 값:** - `\"SSU2\"`: 현재의 UDP 기반 전송 - `\"NTCP2\"`: 현재의 TCP 기반 전송 - `\"NTCP\"`: 레거시, 제거됨(사용하지 마십시오) - `\"SSU\"`: 레거시, 제거됨(사용하지 마십시오) 공통 옵션 모든 transports(전송 프로토콜)은 일반적으로 다음을 포함합니다:\n\u0026#34;host\u0026#34; = IPv4 or IPv6 address or hostname \u0026#34;port\u0026#34; = Port number (1-65535) SSU2 전용 옵션 자세한 내용은 SSU2 명세서 를 참조하십시오.\n필수 옵션:\n\u0026#34;host\u0026#34; = IP address (IPv4 or IPv6) \u0026#34;port\u0026#34; = UDP port number \u0026#34;s\u0026#34; = Static X25519 public key (Base64, 44 characters = 32 bytes) \u0026#34;i\u0026#34; = Introduction key X25519 (Base64, 44 characters = 32 bytes) \u0026#34;v\u0026#34; = \u0026#34;2\u0026#34; (protocol version) 선택적 옵션:\n\u0026#34;caps\u0026#34; = Capability string (e.g., \u0026#34;B\u0026#34; for bandwidth tier) \u0026#34;ihost0\u0026#34;, \u0026#34;ihost1\u0026#34;, ... = Introducer IP addresses \u0026#34;iport0\u0026#34;, \u0026#34;iport1\u0026#34;, ... = Introducer ports \u0026#34;ikey0\u0026#34;, \u0026#34;ikey1\u0026#34;, ... = Introducer static keys (Base64, 44 chars) \u0026#34;itag0\u0026#34;, \u0026#34;itag1\u0026#34;, ... = Introducer relay tags \u0026#34;iexp0\u0026#34;, \u0026#34;iexp1\u0026#34;, ... = Introducer expiration timestamps \u0026#34;mtu\u0026#34; = Maximum transmission unit (default 1500, min 1280) \u0026#34;mtu6\u0026#34; = IPv6 MTU (if different from IPv4) SSU2 RouterAddress 예시:\ncost: 5 expiration: 0x0000000000000000 transport_style: \u0026#34;SSU2\u0026#34; options: host=198.51.100.42 port=12345 s=SGVsbG8gV29ybGQhIFRoaXMgaXMgYSBzYW1wbGUga2V5IQ== i=QW5vdGhlciBTYW1wbGUgS2V5IGZvciBJbnRyb2R1Y3Rpb24= v=2 caps=BC mtu=1472 NTCP2 전용 옵션 자세한 내용은 NTCP2 사양 을 참조하십시오.\n필수 옵션:\n\u0026#34;host\u0026#34; = IP address (IPv4 or IPv6) \u0026#34;port\u0026#34; = TCP port number \u0026#34;s\u0026#34; = Static X25519 public key (Base64, 44 characters = 32 bytes) \u0026#34;i\u0026#34; = Initialization vector (Base64, 24 characters = 16 bytes) \u0026#34;v\u0026#34; = \u0026#34;2\u0026#34; (protocol version) 선택 옵션(0.9.50부터):\n\u0026#34;caps\u0026#34; = Capability string NTCP2 RouterAddress 예시:\ncost: 10 expiration: 0x0000000000000000 transport_style: \u0026#34;NTCP2\u0026#34; options: host=198.51.100.42 port=23456 s=SGVsbG8gV29ybGQhIFRoaXMgaXMgYSBzYW1wbGUga2V5IQ== i=U2FtcGxlIElWIGhlcmU= v=2 구현 참고 사항 비용 값:\nUDP (SSU2)는 효율성으로 인해 일반적으로 더 낮은 비용(5-6) TCP (NTCP2)는 오버헤드로 인해 일반적으로 더 높은 비용(10-11) 낮은 비용 = 선호되는 전송 방식 다중 주소:\nRouters는 여러 개의 RouterAddress 항목을 게시할 수 있습니다 서로 다른 전송 방식(SSU2 및 NTCP2) 서로 다른 IP 버전(IPv4 및 IPv6) 클라이언트는 비용과 기능을 기준으로 선택합니다 호스트명 vs IP:\n성능을 위해 IP 주소가 선호됨 호스트명도 지원하지만 DNS 조회 오버헤드가 추가됨 RouterInfos(라우터 정보 데이터 구조)를 게시할 때는 IP 사용을 고려 Base64 인코딩(Base64: 바이너리 데이터를 텍스트로 인코딩하는 방식):\n모든 키 및 바이너리 데이터는 Base64로 인코딩한다 표준 Base64(RFC 4648) 패딩이나 비표준 문자를 사용하지 않음 JavaDoc: RouterAddress RouterInfo (router 정보) 설명: 네트워크 데이터베이스에 저장되는 router에 관한 공개 정보 일체입니다. 식별 정보, 주소, 기능을 포함합니다.\n형식:\n+----+----+----+----+----+----+----+----+ | router_ident | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | published | +----+----+----+----+----+----+----+----+ |size| RouterAddress 0 | +----+ + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | RouterAddress 1 | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | RouterAddress ($size-1) | + + | | ~ ~ ~ ~ | | +----+----+----+----+-//-+----+----+----+ |psiz| options | +----+----+----+----+-//-+----+----+----+ | signature | + + | | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ router_ident :: RouterIdentity Length: 387+ bytes (typically 391 for X25519+EdDSA) published :: Date (8 bytes) Publication timestamp (milliseconds since epoch) size :: Integer (1 byte) Number of RouterAddress entries Range: 0-255 addresses :: Array of RouterAddress Variable length Each RouterAddress has variable size peer_size :: Integer (1 byte) Number of peer hashes (ALWAYS 0) Historical, unused feature options :: Mapping Router capabilities and metadata MUST be sorted by key signature :: Signature Length determined by router_ident signing key type Typically 64 bytes (EdDSA) Signed by router_ident\u0026#39;s SigningPrivateKey 데이터베이스 저장소: - 데이터베이스 유형: 0 - 키: RouterIdentity(라우터 식별자)의 SHA-256 해시 - 값: 완전한 RouterInfo(라우터 정보) 구조체\n게시 타임스탬프: - 8바이트 날짜(유닉스 epoch 이후 밀리초) - RouterInfo(라우터 정보) 버전 관리에 사용 - Routers는 주기적으로 새로운 RouterInfo를 게시 - Floodfills는 게시된 타임스탬프를 기준으로 최신 버전을 유지\n주소 정렬: - 과거: 매우 오래된 routers에서는 데이터의 SHA-256 기준으로 주소 정렬이 필요했습니다 - 현재: 정렬은 필요하지 않으며, 호환성을 위해 구현할 가치가 없습니다 - 주소는 어떤 순서로든 가능합니다\n피어 크기 필드(역사적): - 현대의 I2P에서는 항상 0 - 제한된 경로를 위한 용도로 의도되었으나(미구현) - 구현되었다면, 그 수만큼의 Router 해시가 뒤따랐을 것임 - 일부 오래된 구현에서는 정렬된 피어 목록을 요구했을 수도 있음\n옵션 매핑:\n옵션은 키 기준으로 반드시 정렬되어야 합니다. 표준 옵션에는 다음이 포함됩니다:\n기능 옵션:\n\u0026#34;caps\u0026#34; = Capability string Common values: f = Floodfill (network database) L or M or N or O = Bandwidth tier (L=lowest, O=highest) R = Reachable U = Unreachable/firewalled Example: \u0026#34;fLRU\u0026#34; = Floodfill, Low bandwidth, Reachable, Unreachable 네트워크 옵션:\n\u0026#34;netId\u0026#34; = Network ID (default \u0026#34;2\u0026#34; for main I2P network) Different values for test networks \u0026#34;router.version\u0026#34; = I2P version string Example: \u0026#34;0.9.67\u0026#34; or \u0026#34;2.10.0\u0026#34; 통계 옵션:\n\u0026#34;stat_uptime\u0026#34; = Uptime in milliseconds \u0026#34;coreVersion\u0026#34; = Core I2P version \u0026#34;router.version\u0026#34; = Full router version string 표준 옵션의 전체 목록은 네트워크 데이터베이스 RouterInfo(라우터 정보) 문서 를 참조하세요.\n서명 연산:\nData to sign: Complete RouterInfo structure from router_ident through options Verification: 1. Extract RouterIdentity from RouterInfo 2. Get SigningPublicKey from RouterIdentity (type determines algorithm) 3. Verify signature over all data preceding signature field 4. Signature must match signing key type and length 일반적인 최신 RouterInfo(router 정보):\nRouterIdentity: 391 bytes (X25519+EdDSA with Key Certificate) Published: 8 bytes Size: 1 byte (typically 1-4 addresses) RouterAddress × N: Variable (typically 200-500 bytes each) Peer Size: 1 byte (value=0) Options: Variable (typically 50-200 bytes) Signature: 64 bytes (EdDSA) Total: ~1000-2500 bytes typical 구현 참고 사항:\n여러 주소:\nRouters는 일반적으로 1~4개의 주소를 공개함 IPv4 및 IPv6 변형 SSU2 및/또는 NTCP2 전송 프로토콜 각 주소는 서로 독립적임 버전 관리:\n더 최신 RouterInfo(라우터 정보 레코드)는 published 타임스탬프가 더 최근이다 router는 ~2시간마다 또는 주소가 변경될 때 재게시한다 floodfill 노드는 최신 버전만 저장하고 전파한다 검증:\nRouterInfo를 수락하기 전에 서명을 검증하십시오 각 RouterAddress에서 expiration 필드가 모두 0인지 확인하십시오 options 매핑이 키 기준으로 정렬되어 있는지 검증하십시오 인증서와 키 유형이 알려져 있고 지원되는지 확인하십시오 네트워크 데이터베이스:\nfloodfill들(특수 netDb 유지 노드)은 Hash(RouterIdentity)로 인덱싱된 RouterInfo를 저장함 마지막 발행 이후 약 2일 동안 저장됨 routers는 다른 routers를 발견하기 위해 floodfill들에 질의함 JavaDoc: RouterInfo 구현 참고 사항 바이트 순서(Endianness) 기본값: 빅 엔디언 (네트워크 바이트 순서)\n대부분의 I2P 구조체는 빅엔디언 바이트 순서를 사용합니다: - 모든 정수형 (1-8 바이트) - 날짜 타임스탬프 - TunnelId(터널 ID) - 문자열 길이 접두부 - 인증서 유형과 길이 - 키 유형 코드 - 매핑 크기 필드\n예외: 리틀 엔디언\n다음 키 유형은 리틀 엔디언 인코딩을 사용합니다: - X25519 암호화 키(유형 4) - EdDSA_SHA512_Ed25519 서명 키(유형 7) - EdDSA_SHA512_Ed25519ph 서명 키(유형 8) - RedDSA_SHA512_Ed25519 서명 키(유형 11)\n구현:\n// Big-endian (most structures) int value = ((bytes[0] \u0026amp; 0xFF) \u0026lt;\u0026lt; 24) | ((bytes[1] \u0026amp; 0xFF) \u0026lt;\u0026lt; 16) | ((bytes[2] \u0026amp; 0xFF) \u0026lt;\u0026lt; 8) | (bytes[3] \u0026amp; 0xFF); // Little-endian (X25519, EdDSA, RedDSA) int value = (bytes[0] \u0026amp; 0xFF) | ((bytes[1] \u0026amp; 0xFF) \u0026lt;\u0026lt; 8) | ((bytes[2] \u0026amp; 0xFF) \u0026lt;\u0026lt; 16) | ((bytes[3] \u0026amp; 0xFF) \u0026lt;\u0026lt; 24); 구조체 버전 관리 절대 고정된 크기를 가정하지 마십시오:\n여러 구조체는 길이가 가변적입니다: - RouterIdentity: 387+ 바이트 (항상 387인 것은 아님) - Destination: 387+ 바이트 (항상 387인 것은 아님) - LeaseSet2: 상당히 달라집니다 - Certificate: 3+ 바이트\n항상 크기 필드를 읽으십시오: - 인증서 길이는 바이트 1-2에 - 매핑 크기는 시작 부분에 - KeysAndCert(키와 인증서 구조)는 항상 384 + 3 + certificate_length로 계산됩니다\n초과 데이터 점검: - 유효한 구조 뒤에 후행 잡데이터(trailing garbage) 금지 - 인증서 길이가 키 유형과 일치하는지 검증 - 고정 크기 타입에 대해 예상된 길이에 정확히 일치하도록 강제\n현재 권장사항(2025년 10월) 신규 Router Identities(라우터 식별자)용:\nEncryption: X25519 (type 4, 32 bytes) Signing: EdDSA_SHA512_Ed25519 (type 7, 32 bytes) Certificate: Key Certificate (type 5) Total Size: 391 bytes Padding: Compressible per [Proposal 161](/ko/proposals/161-ri-dest-padding/) 새로운 Destination(목적지)용:\nUnused Public Key Field: 256 bytes random (compressible) Signing: EdDSA_SHA512_Ed25519 (type 7, 32 bytes) Certificate: Key Certificate (type 5) Total Size: 391 bytes Padding: Compressible per [Proposal 161](/ko/proposals/161-ri-dest-padding/) 새로운 LeaseSets의 경우:\nType: LeaseSet2 (type 3) Encryption Keys: X25519 (type 4, 32 bytes) Leases: At least 1, typically 3-5 Options: Include service records per [Proposal 167](/proposals/167-service-records/) Signature: EdDSA (64 bytes) 암호화된 서비스의 경우:\nType: EncryptedLeaseSet (type 5) Blinding: RedDSA_SHA512_Ed25519 (type 11) Inner LeaseSet: LeaseSet2 (type 3) Rotation: Daily blinding key rotation Authorization: Per-client encryption keys 사용 중단된 기능 - 사용하지 마십시오 지원 중단된 암호화: - Router Identities용 ElGamal (type 0) (0.9.58에서 지원 중단됨) - ElGamal/AES+SessionTag 암호화 (ECIES-X25519 사용)\n사용 중단된 서명: - Router 식별자용 DSA_SHA1 (type 0) (0.9.58에서 사용 중단) - 새로운 구현용 ECDSA 변형(유형 1-3) - SU3 파일을 제외한 RSA 변형(유형 4-6)\n사용 중단된 네트워크 형식: - LeaseSet 유형 1 (LeaseSet2 사용) - Lease (44바이트, Lease2 사용) - 기존 Lease 만료 형식\n사용 중단된 전송 프로토콜: - NTCP (0.9.50에서 제거됨) - SSU (2.4.0에서 제거됨)\n사용 중단된 인증서: - HASHCASH (유형 1) - HIDDEN (유형 2) - SIGNED (유형 3) - MULTIPLE (유형 4)\n보안 고려 사항 키 생성: - 항상 암호학적으로 안전한 난수 생성기를 사용하십시오 - 서로 다른 컨텍스트 간에 키를 재사용하지 마십시오 - 개인 키를 적절한 접근 제어로 보호하십시오 - 작업이 끝나면 메모리에서 키 자료를 안전하게 삭제하십시오\n서명 검증: - 데이터를 신뢰하기 전에 항상 서명을 검증할 것 - 서명 길이가 키 유형과 일치하는지 확인할 것 - 서명된 데이터에 예상되는 필드를 포함하는지 검증할 것 - 정렬된 매핑의 경우, 서명/검증 전에 정렬 순서를 검증할 것\n타임스탬프 검증: - 발행 시각이 타당한지 확인(너무 먼 미래가 아님) - 리스 만료 시각이 이미 지나지 않았는지 검증 - 시계 오차 허용치를 고려(일반적으로 ±30초)\n네트워크 데이터베이스(netDb): - 저장하기 전에 모든 데이터 구조를 검증한다 - 서비스 거부(DoS)를 방지하기 위해 크기 제한을 강제한다 - 질의와 발행에 빈도 제한을 적용한다 - 데이터베이스 키가 데이터 구조의 해시와 일치하는지 확인한다\n호환성 참고 사항 하위 호환성: - ElGamal 및 DSA_SHA1은 레거시 router에서도 여전히 지원됩니다 - 더 이상 권장되지 않는 키 유형은 기능적으로는 계속 동작하지만 사용은 권장되지 않습니다 - Compressible padding(압축 가능한 패딩) (Proposal 161 )은 0.6 버전까지 하위 호환됩니다\n전방 호환성: - 알 수 없는 키 유형은 길이 필드를 사용하여 파싱할 수 있다 - 알 수 없는 인증서 유형은 길이를 이용해 건너뛸 수 있다 - 알 수 없는 서명 유형은 무리 없이 처리해야 한다 - 구현자는 알 수 없는 선택적 기능 때문에 실패해서는 안 된다\n마이그레이션 전략: - 전환 중 기존과 새로운 키 유형을 모두 지원 - LeaseSet2는 여러 암호화 키를 나열할 수 있음 - 오프라인 서명은 안전한 키 로테이션(주기적 교체)을 가능하게 함 - MetaLeaseSet은 투명한 서비스 마이그레이션을 가능하게 함\n테스트 및 검증 구조체 검증: - 모든 길이 필드가 예상 범위 내에 있는지 확인 - 가변 길이 구조체가 올바르게 파싱되는지 점검 - 서명 검증이 성공하는지 검증 - 최소 및 최대 크기의 구조체로 테스트\n경계 사례: - 길이가 0인 문자열 - 빈 매핑 - 최소 및 최대 리스 수 - 페이로드 길이가 0인 인증서 - 매우 큰 구조체(최대 크기에 근접)\n상호운용성: - 공식 Java I2P 구현을 기준으로 테스트 - i2pd와의 호환성 검증 - 다양한 netDb(네트워크 데이터베이스) 내용으로 테스트 - 정상으로 알려진 테스트 벡터에 대해 검증\n참고 자료 명세 I2NP 프로토콜 I2CP 프로토콜 SSU2 전송 NTCP2 전송 Tunnel 프로토콜 데이터그램 프로토콜 암호학 암호학 개요 ElGamal/AES 암호화 ECIES-X25519 암호화 router용 ECIES ECIES 하이브리드(포스트-양자) Red25519 서명 암호화된 LeaseSet 제안서 제안 123: 새로운 netDB 항목 제안 134: GOST(러시아 국가표준 암호) 서명 유형 제안 136: 실험적 서명 유형 제안 145: ECIES(타원곡선 통합 암호화 방식)-P256 제안 156: ECIES Routers 제안 161: 패딩 생성 제안 167: 서비스 레코드 제안 169: 포스트-양자 암호 모든 제안 색인 네트워크 데이터베이스 네트워크 데이터베이스 개요 RouterInfo 표준 옵션 JavaDoc API 참조 코어 데이터 패키지 PublicKey PrivateKey SessionKey SigningPublicKey SigningPrivateKey Signature Hash SessionTag TunnelId Certificate DataHelper KeysAndCert RouterIdentity Destination Lease LeaseSet Lease2 LeaseSet2 MetaLease MetaLeaseSet EncryptedLeaseSet RouterAddress RouterInfo 외부 표준 RFC 7748 (X25519): 보안을 위한 타원곡선 RFC 7539 (ChaCha20): IETF 프로토콜을 위한 ChaCha20 및 Poly1305 RFC 4648 (Base64): Base16, Base32 및 Base64 데이터 인코딩 FIPS 180-4 (SHA-256): 보안 해시 표준 FIPS 204 (ML-DSA): 모듈-격자 기반 디지털 서명 표준 IANA 서비스 레지스트리 커뮤니티 자료 I2P 웹사이트 I2P 포럼 I2P GitLab I2P GitHub 미러 기술 문서 색인 릴리스 정보 I2P 2.10.0 릴리스 릴리스 이력 변경 로그 부록: 빠른 참조 표 키 유형 빠른 참조 현재 표준(모든 신규 구현에 권장): - 암호화: X25519 (타입 4, 32바이트, 리틀엔디언) - 서명: EdDSA_SHA512_Ed25519 (타입 7, 32바이트, 리틀엔디언)\n레거시 (지원되지만 더 이상 권장되지 않음): - 암호화: ElGamal (유형 0, 256바이트, 빅엔디언) - 서명: DSA_SHA1 (유형 0, 20바이트 개인키 / 128바이트 공개키, 빅엔디언)\n특수: - 서명(암호화된 LeaseSet(I2P 목적지의 inbound tunnel 정보 묶음)): RedDSA_SHA512_Ed25519 (유형 11, 32바이트, 리틀 엔디언)\n포스트-양자 (베타, 최종 확정되지 않음): - 하이브리드 암호화: MLKEM_X25519 변형(타입 5-7) - 순수 PQ 암호화: MLKEM 변형(아직 타입 코드가 할당되지 않음)\n구조체 크기 빠른 참조 Structure Minimum Size Typical Size Maximum Size Integer1 byteVaries8 bytes Date8 bytes8 bytes8 bytes String1 byteVaries256 bytes SessionKey32 bytes32 bytes32 bytes Hash32 bytes32 bytes32 bytes TunnelId4 bytes4 bytes4 bytes Certificate3 bytes7 bytes65,538 bytes KeysAndCert387 bytes391 bytes≈1000+ bytes RouterIdentity387 bytes391 bytes≈1000+ bytes Destination387 bytes391 bytes≈1000+ bytes Lease44 bytes44 bytes44 bytes Lease240 bytes40 bytes40 bytes LeaseSet≈1000 bytes≈1200 bytes≈2000+ bytes LeaseSet2≈500 bytes≈800 bytes≈2000+ bytes EncryptedLeaseSet≈600 bytes≈1000 bytes≈3000+ bytes RouterAddress≈150 bytes≈300 bytes≈600 bytes RouterInfo≈1000 bytes≈1500 bytes≈3000+ bytes ### 데이터베이스 유형 빠른 참조 Type Structure Status Notes 0RouterInfoCurrentStored under Hash(RouterIdentity) 1LeaseSetDeprecatedUse LeaseSet2 instead 3LeaseSet2CurrentStored under Hash(Destination) 5EncryptedLeaseSetCurrentStored under Hash(Blinded Destination) 7MetaLeaseSetDefinedVerify production status ### 전송 프로토콜 빠른 참조 Protocol Status Port Type Since Notes SSU2CurrentUDP0.9.54Default since 0.9.56 NTCP2CurrentTCP0.9.36Active SSURemovedUDP-Removed in 2.4.0 NTCPRemovedTCP-Removed in 0.9.50 ### 버전 마일스톤 빠른 참조 Version API Date Key Changes 0.60.6.x2005Destination encryption disabled 0.9.120.9.12Dec 2013Key Certificates introduced 0.9.150.9.15Sep 2015EdDSA support added 0.9.160.9.16Nov 2015Router Key Certificates 0.9.360.9.36Aug 2018NTCP2 introduced 0.9.380.9.38Nov 2018LeaseSet2, X25519 for Destinations 0.9.390.9.39Dec 2018EncryptedLeaseSet working 0.9.480.9.48Jul 2020X25519 for Router Identities 0.9.500.9.50May 2021NTCP removed 0.9.540.9.54May 2022SSU2 testing 0.9.570.9.57Jan 2023[Proposal 161](/ko/proposals/161-ri-dest-padding/) padding (release 2.1.0) 0.9.580.9.58Mar 2023ElGamal/DSA deprecated for RIs (2.2.0) 0.9.660.9.66Jun 2025[Proposal 167](/proposals/167-service-records/) service records (2.9.0) 0.9.670.9.67Sep 2025ML-KEM beta support (2.10.0) --- ","description":"I2P 사양 전반에서 사용되는 공통 데이터 타입과 직렬화 형식","id":"178a1cfe9e5d2970a6e9f8d07c374b78","section":"docs","title":"공통 구조","url":"/ko/docs/specs/common-structures/"},{"categories":null,"content":"1. 개요 clients.config 의 항목들은 라우터가 시작 시 실행할 애플리케이션을 지정합니다. 각 항목은 관리형 클라이언트(권장) 또는 비관리형 클라이언트로 실행될 수 있습니다. 관리형 클라이언트는 ClientAppManager와 협력하며, 다음을 수행합니다:\n라우터 콘솔을 위한 애플리케이션을 인스턴스화하고 생명주기 상태를 추적합니다 사용자에게 시작/중지 제어를 제공하고 라우터 종료 시 깨끗한 종료를 보장합니다 경량 클라이언트 레지스트리 및 포트 매퍼를 호스팅하여 애플리케이션들이 서로의 서비스를 발견할 수 있도록 합니다 관리되지 않는 클라이언트는 단순히 main() 메서드를 호출합니다. 현대화할 수 없는 레거시 코드에만 사용하세요.\n2. Managed Client 구현 관리형 클라이언트는 net.i2p.app.ClientApp(사용자 대면 앱용) 또는 net.i2p.router.app.RouterApp(router 확장용) 중 하나를 구현해야 합니다. 관리자가 컨텍스트 및 구성 인수를 제공할 수 있도록 아래 생성자 중 하나를 제공하세요:\npublic MyClientApp(I2PAppContext context, ClientAppManager manager, String[] args) public MyRouterApp(RouterContext context, ClientAppManager manager, String[] args) args 배열은 clients.config 또는 clients.config.d/의 개별 파일에 구성된 값을 포함합니다. 가능한 경우 기본 생명주기 연결을 상속받기 위해 ClientApp / RouterApp 헬퍼 클래스를 확장하세요.\n2.1 Lifecycle Methods 관리형 클라이언트는 다음을 구현해야 합니다:\nstartup() - 초기화를 수행하고 즉시 반환합니다. INITIALIZED 상태에서 전환하기 위해 반드시 manager.notify()를 최소 한 번 호출해야 합니다. shutdown(String[] args) - 리소스를 해제하고 백그라운드 스레드를 중지합니다. 상태를 STOPPING 또는 STOPPED로 변경하기 위해 반드시 manager.notify()를 최소 한 번 호출해야 합니다. getState() - 앱이 실행 중인지, 시작 중인지, 중지 중인지, 실패했는지 콘솔에 알립니다 관리자는 사용자가 콘솔과 상호작용할 때 이러한 메서드를 호출합니다.\n2.2 Advantages 라우터 콘솔에서 정확한 상태 보고 스레드나 정적 참조 누수 없이 깔끔한 재시작 애플리케이션 중지 후 더 낮은 메모리 사용량 주입된 컨텍스트를 통한 중앙 집중식 로깅 및 오류 보고 3. Unmanaged Clients (Fallback Mode) 설정된 클래스가 managed 인터페이스를 구현하지 않는 경우, 라우터는 main(String[] args)를 호출하여 실행하며 결과 프로세스를 추적할 수 없습니다. 콘솔에는 제한된 정보만 표시되고 종료 훅이 실행되지 않을 수 있습니다. 이 모드는 managed API를 채택할 수 없는 스크립트나 일회성 유틸리티용으로 예약하세요.\n4. Client Registry 관리형 및 비관리형 클라이언트는 매니저에 자신을 등록할 수 있으므로 다른 컴포넌트가 이름으로 참조를 검색할 수 있습니다:\nmanager.register(this); 등록은 클라이언트의 getName() 반환 값을 레지스트리 키로 사용합니다. 알려진 등록에는 console, i2ptunnel, Jetty, outproxy, update가 포함됩니다. ClientAppManager.getRegisteredApp(String name)을 사용하여 클라이언트를 검색하고 기능을 조정할 수 있습니다(예: 콘솔이 Jetty에 상태 세부정보를 쿼리하는 경우).\n클라이언트 레지스트리와 포트 매퍼는 별도의 시스템입니다. 클라이언트 레지스트리는 이름 조회를 통해 애플리케이션 간 통신을 가능하게 하며, 포트 매퍼는 서비스 검색을 위해 서비스 이름을 host:port 조합에 매핑합니다.\n3. 비관리형 클라이언트 (폴백 모드) 포트 매퍼는 내부 TCP 서비스를 위한 간단한 디렉터리를 제공합니다. 협력자들이 하드코딩된 주소를 피할 수 있도록 루프백 포트를 등록하세요:\ncontext.portMapper().register(PortMapper.SVC_HTTPS_PROXY, 4445); 또는 명시적인 호스트 지정으로:\ncontext.portMapper().register(PortMapper.SVC_HTTP_PROXY, \u0026#34;127.0.0.1\u0026#34;, 4444); PortMapper.getPort(String name)을 사용하여 서비스를 조회하세요(찾을 수 없으면 -1을 반환) 또는 getPort(String name, int defaultPort)를 사용하세요(찾을 수 없으면 기본값을 반환). isRegistered(String name)으로 등록 상태를 확인하고 getActualHost(String name)으로 등록된 호스트를 가져오세요.\nnet.i2p.util.PortMapper의 일반적인 포트 매퍼 서비스 상수:\nSVC_CONSOLE - Router console (기본 포트 7657) SVC_HTTP_PROXY - HTTP 프록시 (기본 포트 4444) SVC_HTTPS_PROXY - HTTPS 프록시 (기본 포트 4445) SVC_I2PTUNNEL - I2PTunnel 관리자 SVC_SAM - SAM bridge (기본 포트 7656) SVC_SAM_SSL - SAM bridge SSL SVC_SAM_UDP - SAM UDP SVC_BOB - BOB bridge (기본 포트 2827) SVC_EEPSITE - 표준 eepsite (기본 포트 7658) SVC_HTTPS_EEPSITE - HTTPS eepsite SVC_IRC - IRC tunnel (기본 포트 6668) SVC_SUSIDNS - SusiDNS 참고: httpclient, httpsclient, httpbidirclient은 i2ptunnel 터널 타입(tunnel.N.type 설정에서 사용됨)이며, 포트 매퍼 서비스 상수가 아닙니다.\n4. 클라이언트 레지스트리 2.1 생명주기 메서드 버전 0.9.42부터 router는 clients.config.d/ 디렉토리 내의 개별 파일로 설정을 분할하는 것을 지원합니다. 각 파일에는 모든 속성이 clientApp.0. 접두사로 시작하는 단일 클라이언트에 대한 속성이 포함됩니다:\nclientApp.0.main=net.i2p.router.web.RouterConsoleRunner clientApp.0.name=Router Console clientApp.0.args=7657 ::1,127.0.0.1 ./webapps/ clientApp.0.delay=0 clientApp.0.onBoot=true 이것은 새로운 설치 및 플러그인에 권장되는 방법입니다.\n2.2 장점 하위 호환성을 위해, 기존 형식은 순차적 번호 매기기를 사용합니다:\nclientApp.0.main=net.i2p.router.web.RouterConsoleRunner clientApp.0.name=Router Console clientApp.0.args=7657 ::1,127.0.0.1 ./webapps/ clientApp.1.main=net.i2p.apps.systray.UrlLauncher clientApp.1.name=URL Launcher clientApp.1.delay=5 6.3 Configuration Properties 필수: - main - ClientApp 또는 RouterApp을 구현하거나 정적 main(String[] args)를 포함하는 전체 클래스 이름\n선택 사항: - name - router console의 표시 이름 (기본값은 클래스 이름) - args - 공백 또는 탭으로 구분된 인수 (따옴표로 묶인 문자열 지원) - delay - 시작 전 대기 시간(초) (기본값 120) - onBoot - true일 경우 delay=0으로 강제 설정 - startOnLoad - 클라이언트 활성화/비활성화 (기본값 true)\n플러그인 고유: - stopargs - 종료 시 전달되는 인자 - uninstallargs - 플러그인 제거 시 전달되는 인자 - classpath - 쉼표로 구분된 추가 클래스패스 항목\n플러그인을 위한 변수 치환: - $I2P - I2P 기본 디렉토리 - $CONFIG - 사용자 설정 디렉토리 (예: ~/.i2p) - $PLUGIN - 플러그인 디렉토리 - $OS - 운영 체제 이름 - $ARCH - 아키텍처 이름\n5. 포트 매퍼 관리형 클라이언트를 우선 사용하고, 절대적으로 필요한 경우에만 비관리형으로 대체합니다. 초기화 및 종료를 가볍게 유지하여 콘솔 작업의 응답성을 유지합니다. 진단 도구(및 최종 사용자)가 서비스의 기능을 이해할 수 있도록 설명적인 레지스트리 및 포트 이름을 사용합니다. 정적 싱글톤을 피하고, 주입된 컨텍스트와 매니저를 활용하여 리소스를 공유합니다. 모든 상태 전환 시 manager.notify()를 호출하여 정확한 콘솔 상태를 유지합니다. 별도의 JVM에서 실행해야 하는 경우, 로그와 진단 정보가 메인 콘솔에 어떻게 표시되는지 문서화합니다. 외부 프로그램의 경우, 관리형 클라이언트의 이점을 얻기 위해 ShellService(버전 1.7.0에 추가)를 사용하는 것을 고려합니다. 6. 구성 형식 관리형 클라이언트는 버전 0.9.4(2012년 12월 17일)에 도입되었으며, 버전 2.10.0(2025년 9월 9일) 기준으로 여전히 권장되는 아키텍처입니다. 핵심 API는 이 기간 동안 호환성을 깨뜨리는 변경 없이 안정적으로 유지되어 왔습니다:\nConstructor 시그니처는 변경되지 않음 라이프사이클 메서드(startup, shutdown, getState)는 변경되지 않음 ClientAppManager 등록 메서드는 변경되지 않음 PortMapper 등록 및 조회 메서드는 변경되지 않음 주요 개선사항: - 0.9.42 (2019) - 개별 구성 파일을 위한 clients.config.d/ 디렉토리 구조 - 1.7.0 (2021) - 외부 프로그램 상태 추적을 위한 ShellService 추가 - 2.10.0 (2025) - 관리형 클라이언트 API 변경 사항 없는 현재 릴리스\n다음 주요 릴리스에서는 최소 Java 17+ 버전이 필요합니다 (인프라 요구사항이며, API 변경 사항이 아닙니다).\nReferences clients.config 명세 구성 파일 명세 I2P 기술 문서 색인 ClientAppManager Javadoc (API 0.9.66) PortMapper Javadoc (API 0.9.66) ClientApp 인터페이스 (API 0.9.66) RouterApp 인터페이스 (API 0.9.66) 대체 Javadoc (안정 버전) 대체 Javadoc (클리어넷 미러) 참고: I2P 네트워크는 http://idk.i 2p/javadoc-i2p/ 에서 포괄적인 문서를 호스팅하고 있으며, 접근하려면 I2P router가 필요합니다. clearnet 접근을 위해서는 위의 GitHub Pages 미러를 사용하세요.\n","description":"라우터 관리 애플리케이션이 ClientAppManager 및 포트 매퍼와 통합되는 방법","id":"f9e2324a49e9ed9bf413b4c636d5d1b6","section":"docs","title":"관리형 클라이언트","url":"/ko/docs/applications/managed-clients/"},{"categories":null,"content":" 레거시 상태: 이 내용은 역사적 참고용으로만 보존됩니다. 이는 I2P 0.6.1.10 이전에 출시된 tunnel 시스템을 문서화한 것으로, 최신 개발에 사용해서는 안 됩니다. 운영 환경 지침은 현재 구현 을 참조하십시오.\n원래의 tunnel 하위 시스템도 단방향 tunnel을 사용했지만, 메시지 레이아웃, 중복 탐지, 구축 전략에서는 달랐습니다. 아래의 여러 절은 비교를 돕기 위해 사용 중단된 문서의 구조를 반영합니다.\n1. Tunnel 개요 tunnel은 생성자가 선택한 피어들의 순서가 지정된 시퀀스로 구축되었다. tunnel 길이는 0–7홉 범위였으며, 패딩, 트래픽 제한(throttling), 채프(chaff) 생성 등을 위한 여러 조절 옵션이 있었다. 인바운드 tunnel은 신뢰할 수 없는 게이트웨이에서 생성자(엔드포인트)로 메시지를 전달했으며; 아웃바운드 tunnel은 데이터를 생성자로부터 외부로 보냈다. tunnel의 수명은 10분이었으며, 그 이후에는 새로운 tunnel이 구축되었다(종종 동일한 피어를 사용하되 서로 다른 tunnel ID를 사용). 2. 레거시 설계에서의 동작 2.1 메시지 전처리 게이트웨이는 ≤32 KB의 I2NP 페이로드를 누적하고, 패딩을 선택한 뒤, 다음을 포함하는 페이로드를 생성했다:\n2바이트 패딩 길이 필드와 해당 길이만큼의 임의 바이트 전달 대상, 단편화, 선택적 지연을 설명하는 {instructions, I2NP message} 쌍의 시퀀스 16바이트 경계까지 패딩된 전체 I2NP 메시지 전송 지침은 라우팅 정보를 비트 필드(전송 유형, 지연 플래그, 조각화 플래그, 선택적 확장)로 패킹했다. 조각화된 메시지에는 4바이트 메시지 ID와 인덱스/마지막 조각 플래그가 포함되었다.\n2.2 게이트웨이 암호화 기존 설계는 암호화 단계에서 tunnel 길이를 8홉으로 고정했다. 게이트웨이는 페이로드를 줄이지 않고 각 홉이 무결성을 검증할 수 있도록 AES-256/CBC와 체크섬 블록을 계층적으로 적용했다. 체크섬 자체는 메시지 내부에 포함된 SHA-256 기반 블록이었다.\n2.3 참여자 동작 참여 노드들은 인바운드 tunnel ID를 추적하고, 초기에 무결성을 검증했으며, 전달하기 전에 중복 메시지를 버렸다. 패딩과 검증 블록이 내장되어 있었기 때문에 메시지 크기는 홉 수와 무관하게 일정하게 유지되었다.\n2.4 엔드포인트 처리 종단점은 계층화된 블록을 순차적으로 복호화하고 체크섬을 검증한 뒤, 페이로드를 추가 전달을 위한 인코딩된 명령과 I2NP 메시지로 다시 분리했다.\n3. Tunnel 구축 (사용 중단된 프로세스) 피어 선택: 피어는 로컬에서 유지되는 프로필(탐색용 vs. 클라이언트)에서 선택되었다. 원문 문서는 이미 tunnel 풀마다 정렬된 피어 목록을 재사용하여 선행자 공격 을 완화하는 점을 강조했다. 요청 전달: 빌드 메시지는 각 피어마다 암호화된 섹션을 포함한 상태로 홉별로 전달되었다. telescopic extension(망원경식 확장), 중간 구간 재라우팅, 또는 체크섬 블록 제거와 같은 대안도 실험적 아이디어로 논의되었으나 채택되지는 않았다. 풀링: 각 로컬 destination(목적지 식별자)은 수신(inbound)과 송신(outbound) 풀을 별도로 유지했다. 설정에는 원하는 개수, 백업 tunnel, 길이 가변성, 스로틀링, 그리고 패딩 정책이 포함되었다. 4. 스로틀링 및 혼합 개념 기존 문서는 이후 릴리스에 영향을 준 여러 전략을 제안했다:\n혼잡 제어를 위한 가중 랜덤 조기 폐기(WRED) 최근 사용량의 이동 평균에 기반한 tunnel별 제한 선택적 chaff(더미 트래픽) 및 일괄 처리 제어(완전히 구현되지 않음) 5. 보관된 대안 원본 문서의 일부 섹션에서는 실제로 배포된 적이 없는 아이디어들을 탐구했습니다:\n홉당 처리 부담을 줄이기 위해 체크섬 블록 제거 피어 구성을 변경하기 위해 중간 과정에서 tunnels에 telescoping(단계적으로 확장하는 방식) 적용 양방향 tunnels로 전환(최종적으로 기각됨) 더 짧은 해시 또는 다른 패딩 방식 사용 이러한 아이디어들은 가치 있는 역사적 맥락으로 남아 있지만, 최신 코드베이스를 반영하지는 않습니다.\n참고 자료 원본 레거시 문서 아카이브(pre-0.6.1.10) Tunnel 개요 현재 용어에 대한 안내 피어 프로파일링 및 선택 최신 휴리스틱에 대한 안내 ","description":"I2P 0.6.1.10 이전에 사용되던 tunnel 설계에 대한 보관된 설명.","id":"0970f5387a965fe6857e4afbb03bdc8f","section":"docs","title":"구형 tunnel 구현(레거시)","url":"/ko/docs/legacy/old-implementation/"},{"categories":null,"content":" 1. 개요 netDb(I2P의 특수 목적 분산 네트워크 데이터베이스)은 두 가지 유형의 데이터만을 포함합니다: - RouterInfos – router 연락 정보 - LeaseSets – 목적지 연락 정보\n모든 데이터는 암호학적으로 서명되어 있으며 검증 가능합니다. 각 항목에는 더 이상 유효하지 않은 항목을 제거하고 오래된 항목을 교체하기 위한 liveliness information(항목의 생존/유효 상태를 나타내는 정보)이 포함되어 있어, 특정 유형의 공격으로부터 보호합니다.\n배포에는 floodfill(네트워크 전역으로 데이터를 확산해 채우는 방식) 메커니즘이 사용되며, 일부 routers가 분산 데이터베이스를 유지 관리합니다.\n2. RouterInfo (router 정보, netDb 항목) router들이 다른 router에 연락해야 할 때, 다음을 포함하는 RouterInfo 번들을 교환합니다:\nRouter 식별자 – 암호화 키, 서명 키, 인증서 연결 주소 – router에 접속하는 방법 게시 타임스탬프 – 이 정보가 게시된 시점 임의 텍스트 옵션 – 기능 플래그와 설정 암호학적 서명 – 진정성을 증명 2.1 기능 플래그 router는 자신의 RouterInfo에 문자 코드로 기능을 표시합니다:\nFlag Meaning f Floodfill participation R Reachable U Unreachable D, E, G, H Various capability indicators ### 2.2 대역폭 분류 Code Bandwidth K Under 12 KBps L 12–48 KBps (default) M 48–64 KBps N 64–128 KBps O 128–256 KBps P 256–2000 KBps X Over 2000 KBps ### 2.3 네트워크 ID 값 Value Purpose 0 Reserved 1 Current Network (default) 2 Reserved for Future Networks 3–15 Forks and Test Networks 16–254 Reserved 255 Reserved ### 2.4 RouterInfo 통계 Routers는 네트워크 분석을 위해 선택적 건전성 통계를 게시합니다: - Exploratory tunnel(탐색용 tunnel) 구축 성공/거부/시간 초과 비율 - 1시간 평균 participating tunnel(중계 참여 tunnel) 수\n통계는 stat_(statname).(statperiod) 형식을 따르며 값은 세미콜론으로 구분됩니다.\n예시 통계:\nstat_tunnel.buildExploratoryExpire.60m = 0;0;0;53.14 stat_tunnel.buildExploratoryReject.60m = 0;0;0;15.51 stat_tunnel.buildExploratorySuccess.60m = 0;0;0;31.35 stat_tunnel.participatingTunnels.60m = 289.20 Floodfill routers는 또한 다음을 게시할 수 있습니다: netdb.knownLeaseSets 및 netdb.knownRouters\n2.5 패밀리 옵션 릴리스 0.9.24부터 routers는 family(패밀리) 소속을 선언할 수 있습니다(동일 운영자):\nfamily: 패밀리 이름 family.key: 서명 유형 코드와 base64로 인코딩된 서명용 공개키를 이어붙인 값 family.sig: 패밀리 이름과 32바이트 router 해시에 대한 서명 같은 family(동일 운영자임을 선언한 router 그룹)에 속한 여러 router는 단일 tunnel에서 함께 사용되지 않는다.\n2.6 RouterInfo 만료 가동 후 첫 1시간 동안 만료 없음 저장된 RouterInfos(라우터 정보)가 25개 이하인 경우 만료 없음 로컬 개수가 증가할수록 만료 기간이 짧아짐 (라우터가 120대 미만일 때 72시간; 300대일 때 약 30시간) SSU 소개자는 약 1시간 후 만료 Floodfills는 모든 로컬 RouterInfos에 대해 1시간 만료 시간을 사용 3. LeaseSet(I2P에서 목적지가 메시지를 받기 위해 사용하는 인바운드 tunnel 정보를 담은 공개 레코드) LeaseSets 는 특정 목적지에 대한 tunnel 진입 지점을 문서화하며, 다음을 명시합니다:\nTunnel 게이트웨이 router의 식별자 4바이트 tunnel ID Tunnel 만료 시간 LeaseSets에는 다음이 포함됩니다: - Destination (목적지) – 암호화 키, 서명 키, 인증서 - 추가 암호화 공개 키 – 종단 간 garlic encryption을 위해 - 추가 서명 공개 키 – 무효화를 위한 용도(현재는 사용되지 않음) - 암호학적 서명\n3.1 LeaseSet 종류 Type Description Unpublished Destinations used only for outgoing connections aren't published to floodfill routers Revoked Published with zero leases, signed by additional signing key (not fully implemented) LeaseSet2 (LS2) As of 0.9.38, supports new encryption types, multiple encryption types, options, offline signing keys ([Proposal 123](/proposals/123-new-netdb-entries/)) Meta LeaseSet Tree-like DHT structure for multihomed services, supporting hundreds/thousands of destinations with long expirations (up to 18.2 hours) Encrypted LeaseSet (LS1) All leases encrypted with separate key; only those with the key can decode and contact the destination Encrypted LeaseSet (LS2) As of 0.9.38, destination hidden with only blinded public key and expiration visible to floodfill ### 3.2 LeaseSet 만료 일반적인 LeaseSet은 포함된 lease(경로 임대 항목) 중 가장 늦은 만료 시점에 만료된다. LeaseSet2의 만료 시점은 헤더에 명시된다. EncryptedLeaseSet과 MetaLeaseSet의 만료 시점은 달라질 수 있으며, 최대값이 강제 적용될 수 있다.\n4. 부트스트래핑 분산형 netDb에 참여하려면 최소한 하나의 피어 참조가 필요합니다. Reseeding(초기 피어 정보를 받아오는 과정)은 자원봉사자들의 netDb 디렉터리에서 RouterInfo 파일(routerInfo-$hash.dat)을 가져옵니다. 최초 실행 시에는 무작위로 선택된 하드코딩된 URL에서 자동으로 가져옵니다.\n5. Floodfill 메커니즘 floodfill netDb는 단순한 분산 저장 방식을 사용한다: 데이터를 가장 가까운 floodfill 피어에게 전송한다. floodfill가 아닌 피어가 store(저장) 메시지를 보내면, floodfill 피어는 특정 키에 가장 가까운 floodfill 피어의 일부에게 이를 전달한다.\nFloodfill 참여는 RouterInfo에서 기능 플래그(f)로 표시됩니다.\n5.1 Floodfill 옵트인 요건 Tor의 하드코딩된 신뢰할 수 있는 디렉터리 서버와 달리, I2P의 floodfill(특정 router가 netDb 정보를 저장·배포하는 역할) 집합은 신뢰되지 않는 상태이며 시간이 지남에 따라 변합니다.\nFloodfill은 다음 요구 사항을 충족하는 고대역폭 router에서만 자동으로 활성화됩니다: - 최소 128 KBytes/sec의 공유 대역폭 (수동 구성) - 추가 건전성 테스트를 통과해야 함 (발신 메시지 큐 지연 시간, 작업 지연)\n현재 자동 옵트인으로 인해 약 6%의 네트워크 floodfill 참여가 나타납니다.\n수동으로 설정된 floodfill(네트워크 데이터베이스를 유지·배포하는 특수 노드)은 자동으로 자원봉사하는 노드들과 함께 존재한다. floodfill 수가 임계값 아래로 떨어지면, 대역폭이 높은 router가 자동으로 자원봉사한다. floodfill이 너무 많아지면, 해당 router들은 스스로 floodfill 역할을 해제한다.\n5.2 Floodfill 역할 netDb 저장 요청을 수락하고 쿼리에 응답하는 것 외에도, floodfills는 표준 router 기능을 수행합니다. 일반적으로 대역폭이 더 높아 더 많은 tunnel에 참여하지만, 이는 데이터베이스 서비스와 직접적인 관련은 없습니다.\n6. Kademlia 근접성 메트릭 netDb는 XOR 기반의 Kademlia 방식 거리 측정법을 사용한다. RouterIdentity(라우터 식별자) 또는 Destination(목적지)의 SHA256 해시가 Kademlia 키를 생성한다(LS2 Encrypted LeaseSets의 경우는 제외되며, 이 경우 type byte 3와 blinded public key(블라인드 처리된 공개키)를 합친 값의 SHA256을 사용한다).\n6.1 키 공간 회전 Sybil attack(다중 신원 위조 공격)의 비용을 높이기 위해, SHA256(key) 대신 시스템은 다음을 사용합니다:\nSHA256(key + yyyyMMdd) 여기서 날짜는 8바이트 ASCII 형식의 UTC 날짜입니다. 이렇게 하면 routing key(라우팅 키)가 생성되며, UTC 자정마다 매일 변경됩니다—이를 keyspace rotation(키스페이스 회전)이라고 합니다.\n라우팅 키는 I2NP 메시지에서 절대 전송되지 않으며, 오직 로컬 거리 판정에만 사용된다.\n7. Network Database(네트워크 데이터베이스) 분할 기존의 Kademlia DHT(분산 해시 테이블)는 저장된 정보의 연결 불가능성을 보장하지 못한다. I2P는 **segmentation(분할)**을 구현하여 클라이언트 tunnel을 router와 연계하려는 공격을 방지한다.\n7.1 세분화 전략 Routers는 다음을 추적함: - 엔트리가 client tunnel을 통해 도착했는지 또는 직접 도착했는지 - tunnel을 통해서라면 어떤 client tunnel/목적지인지 - 다수의 tunnel 경유 도착을 추적함 - 저장과 조회 응답을 구분함\nJava와 C++ 구현은 둘 다 다음을 사용합니다: - router 컨텍스트에서 직접 조회/floodfill 작업을 위한 \u0026ldquo;메인\u0026rdquo; netDb - 클라이언트 컨텍스트에서 클라이언트 tunnel로 전송되는 엔트리를 수집하는 \u0026ldquo;Client Network Databases\u0026rdquo;(클라이언트 네트워크 데이터베이스) 또는 \u0026ldquo;Sub-Databases\u0026rdquo;(하위 데이터베이스)\n클라이언트 netDbs는 클라이언트의 수명 동안에만 존재하며, 클라이언트 tunnel 항목만을 포함합니다. 클라이언트 tunnels에서 온 항목은 직접 수신과 중복될 수 없습니다.\n각 netDb는 엔트리가 저장으로 도착했는지(조회 요청에 응답) 아니면 조회 응답으로 도착했는지(이전에 동일한 목적지로 저장한 적이 있을 때만 응답) 여부를 추적한다. 클라이언트는 메인 netDb 엔트리로는 질의에 절대 응답하지 않고, 클라이언트 네트워크 데이터베이스 엔트리로만 응답한다.\n복합 전략은 클라이언트-router 연관 공격에 맞서 netDb를 분할한다.\n8. 저장, 검증 및 조회 8.1 RouterInfo(라우터 정보)를 피어에 저장 NTCP 또는 SSU 전송 연결 초기화 중에 로컬 RouterInfo(라우터 정보) 교환을 포함하는 I2NP DatabaseStoreMessage.\n8.2 피어에 대한 LeaseSet 저장 로컬 LeaseSet을 포함하는 I2NP DatabaseStoreMessage는 Destination 트래픽에 번들된 garlic encryption으로 암호화된 메시지를 통해 주기적으로 교환되며, LeaseSet 조회 없이도 응답할 수 있도록 한다.\n8.3 Floodfill 선택 DatabaseStoreMessage는 현재 라우팅 키에 가장 가까운 floodfill로 전송됩니다. 가장 가까운 floodfill은 로컬 데이터베이스 검색을 통해 찾습니다. 실제로 가장 가까운 것이 아니더라도, 플러딩은 여러 floodfills로 전송하여 이를 \u0026ldquo;더 가까운\u0026rdquo; 곳으로 퍼뜨립니다.\n전통적인 Kademlia는 삽입 전에 \u0026ldquo;find-closest\u0026rdquo;(가장 가까운 노드 탐색) 검색을 사용한다. I2NP에는 그러한 메시지가 없지만, routers는 진정한 최근접 피어 발견을 보장하기 위해 최하위 비트를 뒤집은 (key ^ 0x01) 값으로 반복 검색을 수행할 수 있다.\n8.4 Floodfills로의 RouterInfo 저장 Routers는 floodfill에 직접 연결해 Reply Token(응답 토큰)이 0이 아닌 I2NP DatabaseStoreMessage를 보내 RouterInfo(라우터 정보)를 게시한다. 메시지는 end-to-end garlic encryption이 적용되지 않는다(직접 연결, 중간 경유지 없음). floodfill은 Reply Token을 Message ID로 사용해 DeliveryStatusMessage로 응답한다.\nrouter는 exploratory tunnel을 통해 RouterInfo를 보낼 수도 있다 (연결 제한, 비호환성, IP 은닉). floodfill(네트워크 데이터베이스를 담당하는 노드)은 과부하 상태에서는 이러한 저장 요청을 거부할 수 있다.\n8.5 Floodfills로의 LeaseSet 저장 LeaseSet 저장은 RouterInfo보다 더 민감하다. router는 LeaseSet이 자신과 연관되지 않도록 반드시 방지해야 한다.\nRouters는 0이 아닌 Reply Token을 포함한 DatabaseStoreMessage를 outbound client tunnel을 통해 전송하여 LeaseSet을 게시한다. 메시지는 Destination(목적지)의 Session Key Manager를 사용해 종단 간 garlic encryption으로 암호화되어, tunnel의 outbound endpoint에서 노출되지 않는다. Floodfill은 inbound tunnel을 통해 반환되는 DeliveryStatusMessage로 응답한다.\n8.6 플러딩 프로세스 floodfill 노드들은 로컬에 저장하기 전에, 부하, netdb 크기 및 기타 요인에 따라 달라지는 적응형 기준을 사용하여 RouterInfo(라우터 정보)/LeaseSet을 검증한다.\n유효한 더 최신 데이터를 수신하면, floodfill은 라우팅 키에 가장 가까운 floodfill routers 3개를 조회하여 이를 \u0026ldquo;flood\u0026quot;합니다. 직접 연결에서는 Reply Token(응답 토큰)이 0인 I2NP DatabaseStoreMessage를 전송합니다. 다른 routers는 응답하거나 다시 \u0026ldquo;flood\u0026quot;하지 않습니다.\n중요한 제약 사항: - Floodfills는 tunnels을 통해 전파해서는 안 됨; 직접 연결만 사용 - Floodfills는 만료된 LeaseSet 또는 1시간 이상 전에 게시된 RouterInfo(router 정보)를 절대 전파하지 않음\n8.7 RouterInfo 및 LeaseSet 조회 I2NP DatabaseLookupMessage는 floodfill routers로부터 netdb 항목을 요청한다. 조회는 아웃바운드 탐색용 tunnel을 통해 전송되며, 응답은 인바운드 탐색용 tunnel로 반환 경로를 지정한다.\n조회 요청은 일반적으로 요청된 키에 가장 가까운 \u0026ldquo;양호한\u0026rdquo; floodfill routers 두 곳으로 병렬로 전송된다.\n로컬 일치: I2NP DatabaseStoreMessage 응답을 수신합니다 로컬 일치 없음: 키에 가까운 다른 floodfill router 참조가 포함된 I2NP DatabaseSearchReplyMessage를 수신합니다 LeaseSet 조회는 종단 간 garlic encryption을 사용합니다(0.9.5부터). RouterInfo(router의 공개 정보 레코드) 조회는 ElGamal의 높은 오버헤드 때문에 암호화되지 않으며, 그 결과 outbound endpoint(아웃바운드 터널의 종료 지점)에서의 도청에 취약합니다.\n0.9.7부터 조회 응답에는 세션 키와 태그가 포함되며, 인바운드 게이트웨이에서 응답을 볼 수 없도록 합니다.\n8.8 반복적 조회 0.8.9 이전: 재귀적 또는 반복적 라우팅 없이 두 개의 병렬 중복 조회.\n0.8.9 기준: Iterative lookups는 중복 없이 구현됨—더 효율적이고 신뢰성이 높으며, 불완전한 floodfill(플러드필) 정보 환경에 적합함. 네트워크가 커지고 router가 아는 floodfill의 수가 줄어들수록, 조회의 복잡도는 O(log n)에 가까워진다.\n더 가까운 피어 참조가 없어도 반복적 조회는 계속되어 악의적 블랙홀링을 방지합니다. 현재 설정된 최대 쿼리 횟수와 타임아웃이 적용됩니다.\n8.9 검증 RouterInfo(라우터 정보) 검증: \u0026ldquo;Practical Attacks Against the I2P Network\u0026rdquo; 논문에서 설명된 공격을 방지하기 위해 0.9.7.1부터 비활성화되었습니다.\nLeaseSet 검증: Routers는 약 10초 동안 기다린 뒤, outbound client tunnel을 통해 다른 floodfill에서 조회한다. 종단 간 garlic encryption은 outbound endpoint에서 보이지 않도록 숨긴다. 응답은 inbound tunnels을 통해 돌아온다.\n0.9.7부터, 응답은 인바운드 게이트웨이에 세션 키/태그가 노출되지 않도록 암호화된다.\n8.10 탐색 탐색은 새로운 router를 파악하기 위해 임의의 키로 netdb를 조회하는 과정을 수반한다. Floodfill은 요청된 키에 가까운, floodfill이 아닌 router 해시를 담은 DatabaseSearchReplyMessage로 응답한다. 탐색 쿼리는 DatabaseLookupMessage에 특수 플래그를 설정한다.\n9. 멀티호밍 동일한 개인/공개 키(전통적인 eepPriv.dat)를 사용하는 Destination(통신 목적지 식별자)은 동시에 여러 router에서 호스팅될 수 있습니다. 각 인스턴스는 주기적으로 서명된 LeaseSet을 게시하며, 조회 요청자에게는 가장 최근에 게시된 LeaseSet이 반환됩니다. LeaseSet의 수명이 최대 10분이므로, 중단 기간은 길어도 약 10분을 넘지 않습니다.\n0.9.38부터, Meta LeaseSets는 공통 서비스를 제공하는 별도의 Destinations(I2P 목적지 식별자)를 사용하여 대규모 멀티홈드 서비스를 지원합니다. Meta LeaseSet 항목은 Destinations 또는 다른 Meta LeaseSets이며, 만료 시간은 최대 18.2시간입니다. 이를 통해 공통 서비스를 호스팅하는 Destinations를 수백/수천 개까지 확장할 수 있습니다.\n10. 위협 분석 약 1700개의 floodfill routers가 현재 운영 중입니다. 네트워크가 성장할수록 대부분의 공격은 수행하기 더 어려워지거나 영향이 줄어듭니다.\n10.1 일반적인 완화책 성장: floodfills가 많을수록 공격이 더 어렵거나 영향이 줄어듭니다 중복성: 모든 netdb 항목은 플러딩을 통해 키에 가장 가까운 3개의 floodfill routers에 저장됩니다 서명: 모든 항목은 생성자가 서명했으며, 위조는 불가능합니다 10.2 느리거나 응답하지 않는 router Routers는 floodfills에 대한 확장된 피어 프로필 통계를 유지합니다: - 평균 응답 시간 - 쿼리 응답 비율 - 저장 검증 성공 비율 - 마지막으로 성공한 저장 - 마지막으로 성공한 조회 - 마지막 응답\nRouters는 가장 가까운 floodfill을 선택하기 위한 \u0026ldquo;goodness\u0026rdquo;(적합도)를 결정할 때 이러한 메트릭을 사용한다. 완전히 응답하지 않는 Routers는 빠르게 식별되어 회피되며; 부분적으로 악의적인 Routers는 더 큰 도전 과제를 제기한다.\n10.3 시빌 공격 (전체 키 공간) 공격자는 효과적인 서비스 거부(DoS) 공격의 일환으로 keyspace(키스페이스) 전반에 분산된 다수의 floodfill routers를 구축할 수 있다.\n\u0026ldquo;bad\u0026quot;로 지정될 만큼 충분히 비정상적으로 동작하지 않는 경우에도 가능한 대응은 다음과 같다: - 콘솔 뉴스, 웹사이트, 포럼을 통해 공지된 bad router 해시/IP 목록을 취합 - 네트워크 전반의 floodfill 활성화(\u0026ldquo;Sybil(시빌; 하나의 주체가 다수의 가짜 신원을 사용하는 공격)에는 더 많은 Sybil로 맞서기\u0026rdquo;) - 하드코딩된 \u0026ldquo;bad\u0026rdquo; 목록을 포함한 새 소프트웨어 버전 - 자동 식별을 위한 피어 프로필 지표와 임계값 개선 - 단일 IP 블록 내 복수의 floodfill을 실격 처리하는 IP 블록 기준 - 자동 구독 기반 블랙리스트(Tor 컨센서스와 유사)\n네트워크가 커질수록 이것은 더 어려워진다.\n10.4 Sybil Attack(시빌 공격) (부분 키스페이스) 공격자는 keyspace(키스페이스; 키 공간)에서 서로 매우 가깝게 모여 있는 floodfill router를 8–15대 정도 만들 수 있습니다. 그 keyspace에 대한 모든 조회/저장 요청이 공격자 router로 향하게 되어, 특정 I2P 사이트에 대한 서비스 거부(DoS)가 가능해집니다.\n키스페이스가 암호학적 SHA256 해시를 색인하므로, 공격자는 충분한 근접도를 가진 router를 생성하려면 무차별 대입(brute-force) 공격이 필요하다.\n방어: Kademlia 근접성 알고리즘은 SHA256(key + YYYYMMDD)를 사용해 시간에 따라 변하며, UTC 자정에 매일 변경됩니다. 이러한 keyspace rotation(키스페이스 순환)은 공격을 매일 재생성하도록 강제합니다.\n참고: 최근 연구에 따르면 키스페이스 회전은 그다지 효과적이지 않습니다—공격자는 router 해시를 미리 계산할 수 있어, 회전 이후 30분 이내에 단지 몇 대의 router만으로 키스페이스의 일부를 eclipse(네트워크에서 대상 노드를 고립시키는 공격)할 수 있습니다.\n일일 로테이션의 결과: 로테이션 후 수 분 동안 분산된 netdb의 신뢰성이 떨어지며—새로운 가장 가까운 router가 저장 항목을 받기 전에는 조회가 실패한다.\n10.5 부트스트랩 공격 공격자는 reseed 웹사이트(신규 router의 초기 부트스트랩을 위해 네트워크 정보를 제공하는 웹사이트)를 장악하거나 개발자를 속여 악의적인 reseed 웹사이트를 추가하게 만들어, 새로운 router를 고립된/다수가 통제하는 네트워크로 부팅되도록 할 수 있습니다.\n구현된 방어책: - 단일 사이트가 아닌 여러 reseed(네트워크 부트스트랩을 위한 초기 피어 정보 제공) 사이트에서 RouterInfo 하위집합을 가져옴 - 네트워크 외부에서 reseed 모니터링을 수행하여 사이트를 주기적으로 폴링함 - 0.9.14부터, reseed 데이터 번들은 서명된 zip 파일로 제공되며 다운로드된 서명으로 검증됨 (see su3 사양 )\n10.6 쿼리 캡처 Floodfill routers가 반환된 참조를 통해 피어들을 공격자가 제어하는 routers로 \u0026ldquo;유도\u0026quot;할 수 있다.\n낮은 빈도 때문에 탐색을 통해서는 가능성이 낮으며; routers는 주로 일반적인 tunnel 구축을 통해 피어 참조를 얻는다.\n0.8.9부터 반복적 조회가 구현되었습니다. DatabaseSearchReplyMessage의 floodfill 참조는 조회 키에 더 가까운 경우 따라갑니다. 요청하는 routers는 참조의 근접성을 신뢰하지 않습니다. 악의적인 black-holing(트래픽을 흡수해 응답을 차단하는 공격)을 방지하기 위해, 더 가까운 키가 없더라도 타임아웃 또는 최대 질의 수에 도달할 때까지 조회를 계속합니다.\n10.7 정보 유출 I2P에서의 DHT(분산 해시 테이블) 정보 유출은 추가 조사가 필요하다. floodfill routers는 질의를 관찰하여 정보를 수집할 수 있다. 악성 노드 비율이 20% 수준에 이르면, 앞서 설명한 Sybil(시빌) 공격 위협이 여러 가지 이유로 문제가 된다.\n11. 향후 과제 추가 netDb 조회 및 응답에 대한 종단 간 암호화 향상된 조회 응답 추적 방법 keyspace rotation(키 공간 회전) 신뢰성 문제에 대한 완화 방법 12. 참고 문헌 공통 구조체 명세 – RouterInfo 및 LeaseSet(리스셋, I2P 목적지 도달을 위한 리스 집합) 구조체 I2NP 명세 – 데이터베이스 메시지 유형 제안 123: 새로운 netDb 항목 – LeaseSet2 명세 netDb 역사 논의 – 개발 역사와 아카이브된 논의 ","description":"I2P의 분산 네트워크 데이터베이스(netDb) 이해 - router 연락처 정보와 destination(종단 식별자) 조회를 위한 특화된 분산 해시 테이블(DHT)","id":"ef0a5e8bee4372a50a7f4562af717b0c","section":"docs","title":"네트워크 데이터베이스","url":"/ko/docs/overview/network-database/"},{"categories":null,"content":" 참고: 이 아카이브된 논의는 네트워크 데이터베이스(netDb)에 대한 과거 접근 방식을 개괄합니다. 최신 동작과 지침은 주요 netDb 문서 를 참고하세요.\n역사 I2P의 netDb는 간단한 floodfill 알고리즘을 사용해 분산됩니다. 초기 릴리스에서는 대체 수단으로 Kademlia DHT(분산 해시 테이블 알고리즘) 구현도 유지했지만, 신뢰성이 떨어지는 것으로 드러나 0.6.1.20 버전에서 완전히 비활성화되었습니다. floodfill 설계는 게시된 엔트리를 참여 중인 router로 전달하고 확인을 기다린 뒤, 필요하면 다른 floodfill 피어들과 재시도합니다. floodfill 피어들은 non-floodfill router에서 온 저장 메시지를 다른 모든 floodfill 참가자에게 브로드캐스트합니다.\n2009년 말에 Kademlia(분산 해시 테이블 알고리즘) 조회가 개별 floodfill routers에 대한 저장소 부담을 줄이기 위해 부분적으로 재도입되었다.\nFloodfill 소개 Floodfill은 릴리스 0.6.0.4에서 처음 등장했고, Kademlia(분산 해시 테이블(DHT) 프로토콜)는 백업으로 남아 있었습니다. 당시 심한 패킷 손실과 제한된 경로 때문에 가장 가까운 네 개의 피어로부터 확인 응답을 받기가 어려웠고, 중복된 저장 시도를 수십 번 해야 하곤 했습니다. 외부에서 접근 가능한 routers의 floodfill 부분집합으로 전환하는 것은 실용적인 단기 해결책을 제공했습니다.\nKademlia(분산 해시 테이블 프로토콜) 다시 생각하기 검토한 대안으로는 다음이 있습니다:\n참여에 옵트인한 도달 가능한 routers로 제한된 Kademlia DHT(카덴밀리아 분산 해시 테이블)로 netDb를 운영하기 floodfill 모델을 유지하되, 참여를 역량 있는 routers로 제한하고 무작위 점검으로 분산 상태를 검증하기 floodfill 접근 방식이 배치하기가 더 쉽고 netDb가 사용자 페이로드가 아닌 메타데이터만 보유하기 때문에 우위를 점했습니다. 대부분의 목적지는 송신자가 보통 자신의 LeaseSet을 garlic messages(여러 메시지를 함께 묶어 암호화해 전달하는 I2P 메시지 형식)로 함께 담아 보내기 때문에 LeaseSet을 별도로 공개하지 않습니다.\n현재 상태(역사적 관점) netDb 알고리즘은 네트워크의 요구에 맞게 조정되어 왔으며, 역사적으로 수백 대의 router를 무리 없이 처리해 왔습니다. 초기 추정에 따르면 3–5대의 floodfill router만으로도 대략 10,000개의 노드를 지원할 수 있는 것으로 여겨졌습니다.\n업데이트된 계산(2008년 3월) recvKBps = N * (L + 1) * (1 + F) * (1 + R) * S / T 여기서:\nN: 네트워크의 Routers(라우터) 수 L: router당 클라이언트 목적지의 평균 수 (RouterInfo용으로 하나 추가) F: Tunnel(터널) 실패율 R: tunnel 수명 대비 tunnel 재구축 기간의 비율 S: netDb(네트워크 데이터베이스) 엔트리의 평균 크기 T: tunnel 수명 2008년 당시의 값들(N = 700, L = 0.5, F = 0.33, R = 0.5, S = 4 KB, T = 10 minutes)을 사용하면 결과는 다음과 같습니다:\nrecvKBps ≈ 700 * (0.5 + 1) * (1 + 0.33) * (1 + 0.5) * 4 KB / 10m ≈ 28 KBps Kademlia(카덴밀리아 분산 해시 테이블 알고리즘)가 돌아올까? 개발자들은 2007년 초 무렵 Kademlia(분산 해시 테이블 알고리즘)의 재도입을 논의했다. 합의는 필요에 따라 floodfill 용량을 점진적으로 확장할 수 있는 반면, Kademlia는 기본 router 집단에 상당한 복잡성과 자원 요구 사항을 추가한다는 것이었다. floodfill 용량이 부족해지지 않는 한 대체안은 비활성 상태로 남아 있다.\nFloodfill 용량 계획 bandwidth-class O router를 floodfill에 자동으로 편입하는 것은 매력적으로 보이지만, 적대적인 노드가 참여할 경우 서비스 거부(DoS) 시나리오의 위험이 있다. 과거 분석에 따르면 floodfill 풀을 제한하는 것(예: 피어 3–5개가 ~10K routers를 처리)은 더 안전한 것으로 나타났다. 신뢰할 수 있는 운영자 또는 자동 휴리스틱을 사용하여 충분하면서도 통제된 floodfill 집합을 유지해 왔다.\nFloodfill TODO (역사 기록용) 이 섹션은 기록 보존을 위해 유지됩니다. 메인 netDb 페이지는 현재 로드맵과 설계 고려 사항을 추적합니다.\n운영상의 사건들, 예를 들어 2008년 3월 13일에 이용 가능한 floodfill router가 단 하나뿐이었던 기간 등은 0.6.1.33부터 0.7.x까지의 릴리스에 반영된 여러 개선으로 이어졌으며, 다음을 포함합니다:\n검색 시 floodfill 선택 무작위화 및 반응성이 좋은 피어 우선 router 콘솔 \u0026ldquo;Profiles\u0026rdquo; 페이지에 추가 floodfill 메트릭 표시 floodfill 대역폭 사용량 절감을 위한 netDb 엔트리 크기 점진적 축소 프로파일 데이터로 수집한 성능 기반의 class O routers 일부 자동 참여 블록리스트 강화, floodfill 피어 선택 및 탐색 휴리스틱 개선 해당 기간에 남아 있던 아이디어는 다음과 같다:\ndbHistory 통계를 활용하여 floodfill 피어를 더 정확하게 평가하고 선택하기 장애가 발생하는 피어에 반복적으로 연결하지 않도록 재시도 동작 개선 선정 시 지연 시간 메트릭과 통합 점수 활용 장애가 발생한 floodfill router를 더 빠르게 감지하고 대응하기 고대역폭 및 floodfill 노드에 대한 자원 요구를 지속적으로 줄이기 이 노트가 작성된 시점에도 네트워크는 복원력이 높은 것으로 여겨졌으며, 악의적인 floodfill 또는 floodfill을 표적으로 한 서비스 거부(DoS) 공격에 신속히 대응할 수 있는 인프라가 갖춰져 있었다.\n추가 참고 사항 router 콘솔은 floodfill의 신뢰성을 분석하는 데 도움이 되도록 확장된 프로필 데이터를 오랫동안 제공해 왔다. 과거의 논의에서는 Kademlia(분산 해시 테이블 프로토콜)나 대안적 DHT(분산 해시 테이블) 체계를 거론했지만, floodfill은 운영 네트워크의 주요 알고리즘으로 남아 있었다. 미래 지향적 연구는 남용 기회를 제한하면서 floodfill 참여 선정(admission) 절차를 적응형으로 만드는 데 초점을 맞췄다. ","description":"floodfill, Kademlia(분산 해시 테이블 알고리즘) 실험, 그리고 netDb를 위한 향후 조정에 관한 역사적 기록","id":"0ddefeec5b7108b36649c4d989bf474e","section":"docs","title":"네트워크 데이터베이스 논의","url":"/ko/docs/netdb/"},{"categories":null,"content":" 역사적 고지: 이 페이지는 참고를 위해 과거의 “일방향 Tunnels” 논의를 보존합니다. 현재 동작에 대해서는 현행 tunnel 구현 문서 를 참조하세요.\n개요 I2P는 단방향 tunnel을 구성합니다: 하나의 tunnel은 발신 트래픽을 전달하고, 별도의 tunnel은 수신 응답을 전달합니다. 이 구조는 가장 초기의 네트워크 설계까지 거슬러 올라가며, Tor와 같은 양방향 회로 기반 시스템과의 핵심적인 차별점으로 남아 있습니다. 용어와 구현 세부사항은 tunnel overview 및 tunnel specification 을 참조하세요.\n검토 단방향 tunnel은 요청과 응답 트래픽을 분리하므로, 어떤 단일한 공모 피어 그룹도 왕복 경로의 절반만 관찰할 수 있다. 타이밍 공격은 단일 회로를 분석하는 대신 두 개의 tunnel 풀(아웃바운드와 인바운드)을 교차해야 하므로 상관관계 분석의 난이도가 높아진다. 독립적인 인바운드 및 아웃바운드 풀은 routers가 방향별로 지연, 용량, 장애 처리 특성을 조정할 수 있게 한다. 단점으로는 피어 관리 복잡성 증가와 신뢰성 있는 서비스 제공을 위해 여러 개의 tunnel 세트를 유지해야 하는 필요가 있다. 익명성 Hermann와 Grothoff의 논문 I2P is Slow… and What to Do About It 은 단방향 tunnels에 대한 선행자 공격을 분석하며, 집요한 공격자는 결국 장기간 유지되는 피어를 특정할 수 있음을 시사한다. 커뮤니티 피드백은 이 연구가 공격자의 인내심과 법적 권한에 관한 특정 가정에 의존하고, 양방향 설계에 영향을 미치는 타이밍 공격과 비교하여 이 접근법을 평가하지 않는다고 지적한다. 지속적인 연구와 실무 경험은 단방향 tunnels이 단순한 간과가 아니라 의도적인 익명성 선택임을 계속해서 뒷받침하고 있다.\n","description":"I2P의 단방향 tunnel 설계의 역사적 요약.","id":"37ac13877a690f9c4635959a57451755","section":"docs","title":"단방향 Tunnels","url":"/ko/docs/legacy/unidirectional/"},{"categories":null,"content":"주요 I2P 클라이언트 구현은 Java를 사용합니다. 특정 시스템에서 Java를 사용할 수 없거나 사용하지 않으려는 경우, 커뮤니티 구성원들이 개발하고 유지 관리하는 대체 I2P 클라이언트 구현이 있습니다. 이러한 프로그램들은 다양한 프로그래밍 언어나 접근 방식을 사용하여 동일한 핵심 기능을 제공합니다.\n비교 표 Client Language Maturity Actively Maintained Suitable For Notes Java I2P Java Stable ✅ Yes (official) General users Standard full router; includes console, plugins, and tools i2pd C++ Stable ✅ Yes Low-resource systems, servers Lightweight, fully compatible with Java I2P, includes web console Go-I2P Go Experimental ⚙️ In development Developers, testing Early-stage Go implementation; not yet production ready I2P+ Java Stable (fork) ✅ Yes Advanced users Enhanced Java I2P fork with UI and performance improvements --- i2pd (C++) 웹사이트: https://i2pd.website 설명: i2pd(I2P Daemon)는 C++로 구현된 완전한 기능을 갖춘 I2P 클라이언트입니다. 수년간(약 2016년부터) 프로덕션 환경에서 안정적으로 사용되어 왔으며 커뮤니티에 의해 활발히 유지보수되고 있습니다. i2pd는 I2P 네트워크 프로토콜과 API를 완전히 구현하여 Java I2P 네트워크와 완벽하게 호환됩니다. 이 C++ router는 Java 런타임을 사용할 수 없거나 원하지 않는 시스템에서 경량 대안으로 자주 사용됩니다. i2pd는 구성 및 모니터링을 위한 웹 기반 콘솔이 내장되어 있습니다. 크로스 플랫폼을 지원하며 다양한 패키징 형식으로 제공됩니다 — Android 버전의 i2pd도 사용 가능합니다(예: F-Droid를 통해).\nGo-I2P (Go) 저장소: https://github.com/go-i2p/go-i2p 설명: Go-I2P는 Go 프로그래밍 언어로 작성된 I2P 클라이언트입니다. I2P router의 독립적인 구현체로서, Go의 효율성과 이식성을 활용하는 것을 목표로 합니다. 이 프로젝트는 활발히 개발 중이지만, 아직 초기 단계이며 기능이 완전하지 않습니다. 2025년 현재, Go-I2P는 실험적인 단계로 간주됩니다 — 커뮤니티 개발자들이 활발히 작업하고 있지만, 더 성숙해질 때까지는 프로덕션 환경에서의 사용을 권장하지 않습니다. Go-I2P의 목표는 개발이 완료되면 I2P 네트워크와 완전히 호환되는 현대적이고 경량화된 I2P router를 제공하는 것입니다.\nI2P+ (Java 포크) 웹사이트: https://i2pplus.github.io 설명: I2P+는 표준 Java I2P 클라이언트의 커뮤니티 유지 관리 포크입니다. 새로운 언어로 재구현한 것이 아니라, 추가 기능과 최적화를 갖춘 Java router의 향상된 버전입니다. I2P+는 공식 I2P 네트워크와 완전히 호환되면서도 개선된 사용자 경험과 더 나은 성능 제공에 중점을 둡니다. 새롭게 디자인된 웹 콘솔 인터페이스, 더 사용자 친화적인 구성 옵션, 그리고 다양한 최적화(예: 향상된 토렌트 성능과 방화벽 뒤에 있는 router를 위한 개선된 네트워크 피어 처리)를 도입했습니다. I2P+는 공식 I2P 소프트웨어와 마찬가지로 Java 환경을 필요로 하므로, Java가 아닌 환경을 위한 솔루션은 아닙니다. 그러나 Java를 사용할 수 있고 추가 기능을 갖춘 대체 빌드를 원하는 사용자에게 I2P+는 매력적인 옵션을 제공합니다. 이 포크는 업스트림 I2P 릴리스와 동기화되어 최신 상태를 유지하며(버전 번호에 \u0026ldquo;+\u0026rdquo; 접미사 추가), 프로젝트 웹사이트에서 다운로드할 수 있습니다.\n","description":"커뮤니티에서 유지 관리하는 I2P 클라이언트 구현 (2025년 업데이트)","id":"fdcfc5a7a482cf9fe8fe449e9198b146","section":"docs","title":"대체 I2P 클라이언트","url":"/ko/docs/overview/alternative-clients/"},{"categories":null,"content":"개요 데이터그램은 I2CP 위에서 그리고 스트리밍 라이브러리와 병렬로 메시지 지향 통신을 제공합니다. 이를 통해 연결 지향 스트림 없이도 응답 가능, 인증됨, 또는 원시 패킷을 사용할 수 있습니다. Router는 NTCP2 또는 SSU2가 트래픽을 전송하는지 여부와 관계없이 데이터그램을 I2NP 메시지와 tunnel 메시지로 캡슐화합니다.\n핵심 동기는 애플리케이션(트래커, DNS 리졸버 또는 게임 등)이 발신자를 식별하는 자체 포함 패킷을 전송할 수 있도록 하는 것입니다.\n2025년 신규 사항: I2P 프로젝트는 Datagram2 (프로토콜 19) 및 **Datagram3 (프로토콜 20)**을 승인하여, 10년 만에 처음으로 재생 공격 방지 및 낮은 오버헤드의 응답 가능한 메시징을 추가했습니다.\n1. 프로토콜 상수 Protocol Value Description Introduced PROTO_DATAGRAM 17 Signed (repliable) datagram – “Datagram1” Original PROTO_DATAGRAM_RAW 18 Unsigned (raw) datagram – no sender info Original PROTO_DATAGRAM2 19 Signed + replay-protected datagram API 0.9.66 (2025) PROTO_DATAGRAM3 20 Repliable (no signature, hash only) API 0.9.66 (2025) 프로토콜 19와 20은 **제안서 163 (2025년 4월)**에서 공식화되었습니다. 이들은 하위 호환성을 위해 Datagram1 / RAW와 공존합니다. 2. 데이터그램 유형 Type Protocol Repliable Authenticated Replay Protection Min Overhead Notes Raw 18 No No No 0 Minimal size; spoofable. Datagram1 17 Yes Yes No ≈ 427 Full Destination + signature. Datagram2 19 Yes Yes Yes ≈ 457 Replay prevention + offline signatures; PQ-ready. Datagram3 20 Yes No No ≈ 34 Sender hash only; low overhead. ### 일반적인 디자인 패턴 요청 → 응답: 서명된 Datagram2(요청 + nonce)를 전송하고, 원시 또는 Datagram3 응답(nonce 에코)을 수신합니다. 고빈도/저오버헤드: Datagram3 또는 RAW를 선호합니다. 인증된 제어 메시지: Datagram2. 레거시 호환성: Datagram1은 여전히 완전히 지원됩니다. 3. Datagram2 및 Datagram3 세부사항 (2025) Datagram2 (프로토콜 19) Datagram1의 향상된 대체 버전. 특징: - 재생 공격 방지: 4바이트 재생 방지 토큰. - 오프라인 서명 지원: 오프라인 서명된 Destination에서 사용 가능. - 확장된 서명 범위: destination 해시, 플래그, 옵션, 오프라인 서명 블록, 페이로드 포함. - 포스트 양자 대응: 향후 ML-KEM 하이브리드와 호환. - 오버헤드: 약 457바이트 (X25519 키 기준).\nDatagram3 (프로토콜 20) 원시 타입과 서명된 타입 간의 격차를 메웁니다. 기능: - 서명 없이 응답 가능: 발신자의 32바이트 해시 + 2바이트 플래그 포함. - 최소한의 오버헤드: 약 34바이트. - 재생 공격 방어 없음 — 애플리케이션에서 구현해야 합니다.\n두 프로토콜 모두 API 0.9.66 기능이며 릴리스 2.9.0부터 Java router에 구현되었습니다. i2pd 또는 Go 구현은 아직 없습니다 (2025년 10월 기준).\n4. 크기 및 단편화 제한 Tunnel 메시지 크기: 1 028 바이트 (4 B Tunnel ID + 16 B IV + 1 008 B 페이로드). 초기 프래그먼트: 956 B (일반적인 TUNNEL 전달). 후속 프래그먼트: 996 B. 최대 프래그먼트: 63–64. 실용적 한계: ≈ 62 708 B (~61 KB). 권장 한계: 안정적인 전달을 위해 ≤ 10 KB (이를 초과하면 드롭이 기하급수적으로 증가함). 오버헤드 요약: - Datagram1 ≈ 427 B (최소). - Datagram2 ≈ 457 B. - Datagram3 ≈ 34 B. - 추가 계층 (I2CP gzip 헤더, I2NP, Garlic, Tunnel): + 최악의 경우 ~5.5 KB.\n5. I2CP / I2NP 통합 메시지 경로: 1. 애플리케이션이 데이터그램 생성 (I2P API 또는 SAM을 통해). 2. I2CP가 gzip 헤더(0x1F 0x8B 0x08, RFC 1952) 및 CRC-32 체크섬으로 래핑. 3. 프로토콜 + 포트 번호가 gzip 헤더 필드에 저장됨. 4. Router가 I2NP 메시지로 캡슐화 → Garlic clove → 1 KB tunnel 단편화. 5. 단편들이 outbound → 네트워크 → inbound tunnel을 통과. 6. 재조립된 데이터그램이 프로토콜 번호에 기반하여 애플리케이션 핸들러로 전달됨.\n무결성: CRC-32 (I2CP에서) + 선택적 암호화 서명 (Datagram1/2). 데이터그램 자체 내에는 별도의 체크섬 필드가 없습니다.\n6. 프로그래밍 인터페이스 Java API 패키지 net.i2p.client.datagram에는 다음이 포함됩니다: - I2PDatagramMaker – 서명된 데이터그램을 생성합니다. - I2PDatagramDissector – 발신자 정보를 검증하고 추출합니다. - I2PInvalidDatagramException – 검증 실패 시 발생합니다.\nI2PSessionMuxedImpl (net.i2p.client.impl.I2PSessionMuxedImpl)은 Destination을 공유하는 앱들의 프로토콜 및 포트 멀티플렉싱을 관리합니다.\nJavadoc 접근: - idk.i2p Javadoc (I2P 네트워크 전용) - Javadoc 미러 (일반 인터넷 미러) - 공식 Javadocs (공식 문서)\nSAM v3 지원 SAM 3.2 (2016): PORT 및 PROTOCOL 매개변수 추가. SAM 3.3 (2016): PRIMARY/하위세션 모델 도입; 하나의 Destination에서 스트림 + 데이터그램 허용. Datagram2 / 3 세션 스타일 지원이 2025년 사양에 추가됨 (구현 대기 중). 공식 사양: SAM v3 Specification i2ptunnel 모듈 udpTunnel: I2P UDP 앱을 위한 완전히 기능하는 기반 (net.i2p.i2ptunnel.udpTunnel). streamr: A/V 스트리밍을 위해 작동 가능 (net.i2p.i2ptunnel.streamr). SOCKS UDP: 2.10.0 기준 기능하지 않음 (UDP stub만 존재). 범용 UDP의 경우 Datagram API 또는 udpTunnel을 직접 사용하세요—SOCKS UDP에 의존하지 마세요.\n7. 생태계 및 언어 지원 (2025) Language Library / Package SAM Version Status Javacore API (net.i2p.client.datagram)3.3✓ full support C++i2pd / libsam33.2 partialLimited Gogo-i2p / sam33.1–3.2Active Pythoni2plib, i2p.socket, txi2p3.2Active Rusti2p-rs, i2p_client3.3Active C#I2PSharp3.3Active JS/TSnode-i2p, i2p-sam3.2Active Haskellnetwork-anonymous-i2p3.2Experimental Luamooni2p3.2Experimental Java I2P는 현재 전체 SAM 3.3 subsession과 Datagram2 API를 지원하는 유일한 router입니다. 8. 사용 예시 – UDP Tracker (I2PSnark 2.10.0) Datagram2/3의 첫 실제 적용 사례:\nOperation Datagram Type Purpose Announce RequestDatagram3Repliable but low-overhead update ResponseRaw DatagramMinimal payload return 패턴은 보안과 성능의 균형을 맞추기 위해 인증된 데이터그램과 경량 데이터그램을 혼합하여 사용하는 것을 보여줍니다. 9. 보안 및 모범 사례 인증된 교환이나 재생 공격이 중요한 경우 Datagram2를 사용하세요. 적당한 신뢰 수준에서 빠른 응답 가능한 메시지에는 Datagram3를 선호하세요. 공개 브로드캐스트나 익명 데이터에는 RAW를 사용하세요. 안정적인 전송을 위해 페이로드를 ≤ 10 KB로 유지하세요. SOCKS UDP는 여전히 작동하지 않는다는 점을 유의하세요. 수신 시 항상 gzip CRC와 디지털 서명을 검증하세요. 10. 기술 사양 이 섹션에서는 저수준 데이터그램 형식, 캡슐화 및 프로토콜 세부 사항을 다룹니다.\n10.1 프로토콜 식별 데이터그램 형식은 공통 헤더를 공유하지 않습니다. 라우터는 페이로드 바이트만으로는 타입을 추론할 수 없습니다.\n여러 데이터그램 유형을 혼합하거나 데이터그램과 스트리밍을 결합할 때 다음을 명시적으로 설정하세요: - 프로토콜 번호 (I2CP 또는 SAM을 통해) - 선택적으로 포트 번호 (애플리케이션이 서비스를 다중화하는 경우)\n프로토콜을 설정하지 않은 상태(0 또는 PROTO_ANY)로 두는 것은 권장되지 않으며 라우팅 또는 전송 오류를 초래할 수 있습니다.\n10.2 원시 데이터그램 응답 불가능한 데이터그램은 발신자나 인증 데이터를 포함하지 않습니다. 이들은 불투명한 페이로드로, 상위 레벨 데이터그램 API 외부에서 처리되지만 SAM과 I2PTunnel을 통해 지원됩니다.\n프로토콜: 18 (PROTO_DATAGRAM_RAW)\n형식:\n+----+----+----+----+----// | payload... +----+----+----+----+----// 페이로드 길이는 전송 제한에 의해 제약됩니다 (실질적 최대값 ≈32 KB, 종종 훨씬 적음).\n10.3 Datagram1 (응답 가능한 데이터그램) 발신자의 Destination과 인증 및 응답 주소 지정을 위한 Signature를 포함합니다.\n프로토콜: 17 (PROTO_DATAGRAM)\n오버헤드: ≥427바이트 페이로드: 최대 ~31.5KB (전송 계층에 의해 제한됨)\n형식:\n+----+----+----+----+----+----+----+----+ | from | + + | | ~ Destination bytes ~ | | +----+----+----+----+----+----+----+----+ | signature | + + | | +----+----+----+----+----+----+----+----+ | payload... +----+----+----+----// from: Destination (387+ 바이트) signature: 키 타입과 일치하는 서명 DSA_SHA1의 경우: 페이로드의 SHA-256 해시에 대한 서명 다른 키 타입의 경우: 페이로드에 대한 직접 서명 참고: - DSA가 아닌 타입의 서명은 I2P 0.9.14에서 표준화되었습니다. - LS2 (제안 123) 오프라인 서명은 현재 Datagram1에서 지원되지 않습니다.\n10.4 Datagram2 형식 Proposal 163 에 정의된 대로 재생 공격 방어(replay resistance)를 추가한 개선된 응답 가능 데이터그램입니다.\n프로토콜: 19 (PROTO_DATAGRAM2)\n구현이 진행 중입니다. 애플리케이션은 중복 방지를 위해 nonce 또는 타임스탬프 검사를 포함해야 합니다.\n10.5 Datagram3 형식 응답 가능하지만 인증되지 않은 데이터그램을 제공합니다. 내장된 destination과 서명 대신 라우터가 유지하는 세션 인증에 의존합니다.\n프로토콜: 20 (PROTO_DATAGRAM3) 상태: 0.9.66 버전부터 개발 중\n다음과 같은 경우에 유용합니다: - destination이 큰 경우 (예: 양자 내성 키) - 다른 계층에서 인증이 발생하는 경우 - 대역폭 효율성이 중요한 경우\n10.6 데이터 무결성 데이터그램 무결성은 I2CP 계층의 gzip CRC-32 체크섬으로 보호됩니다. 데이터그램 페이로드 형식 자체에는 명시적인 체크섬 필드가 존재하지 않습니다.\n10.7 패킷 캡슐화 각 데이터그램은 단일 I2NP 메시지로 캡슐화되거나 Garlic Message의 개별 clove로 캡슐화됩니다. I2CP, I2NP, 그리고 tunnel 계층이 길이와 프레이밍을 처리하므로, 데이터그램 프로토콜 내부에는 구분자나 길이 필드가 없습니다.\n10.8 포스트 양자(PQ) 고려사항 Proposal 169 (ML-DSA 서명)가 구현되면, 서명 및 destination 크기가 극적으로 증가하여 약 455바이트에서 ≥3739바이트로 늘어납니다. 이 변경사항은 데이터그램 오버헤드를 상당히 증가시키고 유효 페이로드 용량을 감소시킬 것입니다.\nDatagram3은 세션 수준 인증(내장된 서명이 아닌)에 의존하므로, 양자 이후 I2P 환경에서 선호되는 설계가 될 가능성이 높습니다.\n11. 참고 문헌 제안 163 – Datagram2 및 Datagram3 제안 160 – UDP Tracker 통합 제안 144 – Streaming MTU 계산 제안 169 – 양자 내성 서명 I2CP 사양 I2NP 사양 Tunnel 메시지 사양 SAM v3 사양 i2ptunnel 문서 12. 변경 로그 주요 사항 (2019 – 2025) Year Release Change 20190.9.43Datagram API stabilization 20210.9.50Protocol port handling reworked 20222.0.0SSU2 adoption completed 20242.6.0Legacy transport removal simplified UDP code 20252.9.0Datagram2/3 support added (Java API) 20252.10.0UDP Tracker implementation released --- 13. 요약 데이터그램 하위 시스템은 이제 완전히 인증된 방식부터 경량 원시 전송까지 다양한 스펙트럼을 제공하는 네 가지 프로토콜 변형을 지원합니다. 개발자는 보안이 중요한 사용 사례에는 Datagram2로, 효율적인 응답 가능 트래픽에는 Datagram3로 마이그레이션해야 합니다. 모든 이전 유형은 장기적인 상호 운용성을 보장하기 위해 여전히 호환됩니다.\n","description":"I2CP 위에서의 인증된, 응답 가능한, 그리고 원시 메시지 형식","id":"b3c644204c779b5d6fc6a41438a3eb1b","section":"docs","title":"데이터그램","url":"/ko/docs/api/datagrams/"},{"categories":null,"content":"이 가이드는 I2P Router Console과 구성 페이지에 대한 개요를 제공합니다. 각 섹션은 페이지가 수행하는 작업과 용도를 설명하여 I2P router를 모니터링하고 구성하는 방법을 이해하는 데 도움을 줍니다.\n라우터 콘솔 접속하기 I2P Router Console은 I2P router를 관리하고 모니터링하는 중앙 허브입니다. 기본적으로 I2P router가 실행 중일 때 I2P Router Console 에서 접근할 수 있습니다.\n홈 페이지는 여러 주요 섹션을 표시합니다:\n애플리케이션 - 이메일, 토렌트, Hidden Services Manager, 웹 서버 등 내장된 I2P 애플리케이션에 빠르게 접근 I2P 커뮤니티 사이트 - 포럼, 문서, 프로젝트 웹사이트를 포함한 주요 커뮤니티 리소스 링크 구성 및 도움말 - 대역폭 설정 구성, 플러그인 관리, 도움말 리소스 접근을 위한 도구 네트워크 및 개발자 정보 - 그래프, 로그, 기술 문서, 네트워크 통계에 대한 접근 주소록 URL: 주소록 I2P 주소록은 클리어넷의 DNS와 유사하게 작동하여, I2P destination(eepsite)에 대한 사람이 읽을 수 있는 이름을 관리할 수 있게 해줍니다. 여기에서 개인 주소록에 I2P 주소를 확인하고 추가할 수 있습니다.\n주소록 시스템은 여러 계층을 통해 작동합니다:\n로컬 레코드 - 라우터에만 저장되는 개인 주소록\n로컬 주소록 - 수동으로 추가하거나 개인 용도로 저장한 호스트 프라이빗 주소록 - 다른 사람과 공유하고 싶지 않은 주소; 공개적으로 배포되지 않음 구독(Subscriptions) - 알려진 I2P 사이트로 라우터의 주소록을 자동으로 업데이트하는 원격 주소록 소스 (예: http://i2p-projekt.i2p/hosts.txt)\n라우터 주소록 - 로컬 기록과 구독을 병합한 결과로, 라우터의 모든 I2P 애플리케이션에서 검색 가능\nPublished Addressbook - 다른 사람들이 구독 소스로 사용할 수 있도록 주소록을 공개적으로 공유하는 선택적 기능 (I2P 사이트를 운영하는 경우 유용함)\n주소록은 정기적으로 구독을 폴링하고 콘텐츠를 라우터(router) 주소록에 병합하여 hosts.txt 파일을 I2P 네트워크와 최신 상태로 유지합니다.\n설정 URL: 고급 설정 Configuration 섹션은 여러 전문화된 탭을 통해 모든 router 설정에 대한 접근을 제공합니다.\nAdvanced 고급 설정 페이지는 일반적인 작동에 필요하지 않은 저수준 router 설정에 대한 접근을 제공합니다. 대부분의 사용자는 특정 설정 옵션과 그것이 router 동작에 미치는 영향을 이해하지 못하는 한 이러한 설정을 수정해서는 안 됩니다.\n주요 기능:\nFloodfill 설정 - 라우터가 floodfill 피어로 참여할지 여부를 제어합니다. Floodfill 피어는 netDb 정보를 저장하고 배포하여 네트워크를 돕습니다. 시스템 리소스를 더 많이 사용할 수 있지만 I2P 네트워크를 강화합니다.\n고급 I2P 설정 - router.config 파일에 직접 접근하여 다음을 포함한 모든 고급 설정 매개변수를 표시합니다:\n대역폭 제한 및 버스트 설정 Transport 설정 (NTCP2, SSU2, UDP 포트 및 키) 라우터 식별 정보 및 버전 정보 콘솔 환경설정 및 업데이트 설정 대부분의 고급 설정 옵션은 거의 필요하지 않기 때문에 사용자 인터페이스에 노출되지 않습니다. 이러한 설정을 편집하려면 router.config 파일에 routerconsole.advanced=true를 수동으로 추가해야 합니다.\n경고: 고급 설정을 잘못 수정하면 router의 성능이나 연결에 부정적인 영향을 미칠 수 있습니다. 무엇을 하는지 알고 있는 경우에만 이러한 설정을 변경하십시오.\nBandwidth URL: 대역폭 설정 Bandwidth 설정 페이지에서는 라우터가 I2P 네트워크에 기여하는 대역폭의 양을 제어할 수 있습니다. I2P는 인터넷 연결 속도에 맞게 속도를 설정할 때 가장 잘 작동합니다.\n주요 설정:\nKBps In - 라우터가 수신할 최대 인바운드 대역폭 (다운로드 속도) KBps Out - 라우터가 사용할 최대 아웃바운드 대역폭 (업로드 속도) Share - 참여 트래픽에 할당되는 아웃바운드 대역폭의 비율 (다른 사용자의 트래픽 라우팅 지원) 중요 사항:\n모든 값은 초당 비트가 아닌 초당 바이트(KBps) 단위입니다 더 많은 대역폭을 제공할수록 네트워크에 더 많이 기여하고 자신의 익명성도 향상됩니다 업스트림 공유량(KBps Out)이 네트워크에 대한 전반적인 기여도를 결정합니다 네트워크 속도를 잘 모르는 경우 대역폭 테스트를 사용하여 측정하세요 공유 대역폭을 높이면 익명성이 향상되고 I2P 네트워크 강화에 도움이 됩니다 설정 페이지는 사용자의 설정을 기반으로 예상 월간 데이터 전송량을 표시하여, 인터넷 요금제 한도에 맞춰 대역폭 할당을 계획하는 데 도움을 줍니다.\nClient Configuration URL: 클라이언트 구성 클라이언트 구성 페이지에서는 시작 시 실행할 I2P 애플리케이션과 서비스를 제어할 수 있습니다. 여기에서 내장된 I2P 클라이언트를 제거하지 않고 활성화하거나 비활성화할 수 있습니다.\n중요 경고: 여기에서 설정을 변경할 때 주의하십시오. router console과 application tunnel은 I2P의 대부분의 용도에 필요합니다. 고급 사용자만 이러한 설정을 수정해야 합니다.\n사용 가능한 클라이언트:\nApplication tunnels - 클라이언트 및 서버 터널(HTTP 프록시, IRC 등)을 관리하는 I2PTunnel 시스템 I2P Router Console - 현재 사용 중인 웹 기반 관리 인터페이스 I2P webserver (eepsite) - 자신의 I2P 웹사이트를 호스팅하기 위한 내장 Jetty 웹서버 Open Router Console in web browser at startup - 시작 시 콘솔 홈페이지로 브라우저를 자동으로 실행 SAM application bridge - 서드파티 애플리케이션이 I2P에 연결하기 위한 API 브리지 각 클라이언트는 다음을 표시합니다: - 시작 시 실행? - 자동 시작을 활성화/비활성화하는 체크박스 - 제어 - 즉시 제어를 위한 시작/중지 버튼 - 클래스 및 인자 - 클라이언트가 실행되는 방식에 대한 기술적 세부 사항\n\u0026ldquo;Run at Startup?\u0026rdquo; 설정 변경사항은 라우터를 재시작해야 적용됩니다. 모든 수정사항은 /var/lib/i2p/i2p-config/clients.config.d/에 저장됩니다.\n고급 URL: I2CP 설정 I2CP(I2P Client Protocol) 설정 페이지에서는 외부 애플리케이션이 I2P router에 연결하는 방법을 구성할 수 있습니다. I2CP는 애플리케이션이 router와 통신하여 tunnel을 생성하고 I2P를 통해 데이터를 송수신하는 데 사용하는 프로토콜입니다.\n중요: 기본 설정은 대부분의 사용자에게 적합합니다. 여기서 변경한 사항은 외부 클라이언트 애플리케이션에서도 동일하게 구성해야 합니다. 많은 클라이언트가 SSL 또는 인증을 지원하지 않습니다. 모든 변경 사항은 재시작 후 적용됩니다.\n설정 옵션:\n외부 I2CP 인터페이스 구성\nSSL 없이 활성화 - 표준 I2CP 접근 (기본값이며 가장 호환성이 높음) SSL 필수로 활성화 - 암호화된 I2CP 연결만 허용 비활성화 - 외부 클라이언트가 I2CP를 통해 연결하는 것을 차단 I2CP 인터페이스 - 수신할 네트워크 인터페이스 (기본값: 127.0.0.1, 로컬호스트 전용)\nI2CP 포트 - I2CP 연결을 위한 포트 번호 (기본값: 7654)\n인증\n사용자 이름과 비밀번호 요구 - I2CP 연결에 대한 인증 활성화 사용자 이름 - I2CP 접근에 필요한 사용자 이름 설정 비밀번호 - I2CP 접근에 필요한 비밀번호 설정 보안 참고사항: I2P router와 동일한 컴퓨터에서만 애플리케이션을 실행하는 경우, 원격 접속을 방지하기 위해 인터페이스를 127.0.0.1로 유지하십시오. 다른 장치의 I2P 애플리케이션이 router에 연결해야 하는 경우에만 이 설정을 변경하십시오.\n대역폭 URL: 네트워크 구성 Network Configuration 페이지에서는 I2P router가 인터넷에 연결하는 방식을 구성할 수 있으며, IP 주소 감지, IPv4/IPv6 기본 설정, UDP 및 TCP transport의 포트 설정이 포함됩니다.\n외부 접근 가능한 IP 주소:\n모든 자동 감지 방법 사용 - 여러 방법을 사용하여 공인 IP를 자동으로 감지합니다 (권장) UPnP IP 주소 감지 비활성화 - UPnP를 사용한 IP 검색을 차단합니다 로컬 인터페이스 IP 주소 무시 - 로컬 네트워크 IP를 사용하지 않습니다 SSU IP 주소 감지만 사용 - IP 감지에 SSU2 전송만 사용합니다 숨김 모드 - IP 공개 안 함 - 네트워크 트래픽 참여를 차단합니다 (익명성 감소) 호스트명 또는 IP 지정 - 공인 IP 또는 호스트명을 수동으로 설정합니다 IPv4 설정:\n인바운드 비활성화 (방화벽 설정) - 방화벽, 홈 네트워크, ISP, DS-Lite 또는 통신사급 NAT 뒤에 있어 인바운드 연결이 차단되는 경우 이 옵션을 선택하세요 IPv6 설정:\nIPv4를 IPv6보다 우선 - IPv4 연결을 우선순위로 사용합니다 IPv6를 IPv4보다 우선 - IPv6 연결을 우선순위로 사용합니다 (듀얼 스택 네트워크의 기본값) IPv6 활성화 - IPv6 연결을 허용합니다 IPv6 비활성화 - 모든 IPv6 연결을 비활성화합니다 IPv6만 사용 (IPv4 비활성화) - 실험적인 IPv6 전용 모드입니다 인바운드 비활성화 (방화벽 적용됨) - IPv6가 방화벽으로 차단되었는지 확인하세요 IP 변경 시 조치:\n랩톱 모드 - IP 변경 시 라우터 ID와 UDP 포트를 변경하여 익명성을 강화하는 실험적 기능 UDP 설정:\n포트 지정 - SSU2 전송을 위한 특정 UDP 포트 설정 (방화벽에서 해당 포트를 개방해야 함) 완전히 비활성화 - 모든 아웃바운드 UDP를 차단하는 방화벽 뒤에 있는 경우에만 선택 TCP 설정:\n포트 지정 - NTCP2 전송을 위한 특정 TCP 포트 설정 (방화벽에서 열어야 함) UDP용으로 구성된 동일한 포트 사용 - 두 전송 방식에 하나의 포트를 사용하여 구성 단순화 자동 감지된 IP 주소 사용 - 공인 IP를 자동으로 감지 (아직 감지되지 않았거나 방화벽이 설정된 경우 \u0026ldquo;currently unknown\u0026rdquo; 표시) 자동 감지된 IP 주소 항상 사용 (방화벽 없음) - 인터넷에 직접 연결된 router에 가장 적합 인바운드 비활성화 (방화벽 있음) - TCP 연결이 방화벽에 의해 차단되는지 확인 완전히 비활성화 - 아웃바운드 TCP를 제한하거나 차단하는 방화벽 뒤에 있는 경우에만 선택 호스트명 또는 IP 지정 - 외부에서 접근 가능한 주소를 수동으로 구성 중요: 네트워크 설정 변경 사항은 완전히 적용되려면 router 재시작이 필요할 수 있습니다. 올바른 포트 포워딩 구성은 router의 성능을 크게 향상시키고 I2P 네트워크에 도움이 됩니다.\n클라이언트 구성 URL: Peer Configuration Peer Configuration 페이지는 I2P 네트워크의 개별 peer를 관리하기 위한 수동 제어 기능을 제공합니다. 이는 문제가 있는 peer의 해결을 위해 일반적으로 사용되는 고급 기능입니다.\n수동 피어 제어:\n라우터 해시 - 관리하려는 피어의 44자 base64 router hash를 입력하세요 수동으로 피어 차단 / 차단 해제:\n피어를 차단하면 생성하는 모든 tunnel에 해당 피어가 참여하지 못하게 됩니다. 이 작업은: - 클라이언트 또는 탐색 tunnel에서 해당 피어가 사용되지 않도록 방지 - 재시작 없이 즉시 적용됨 - 수동으로 피어 차단을 해제하거나 router를 재시작할 때까지 지속됨 - 재시작까지 피어 차단 - 일시적으로 피어를 차단 - 피어 차단 해제 - 이전에 차단된 피어의 차단을 제거\n프로필 보너스 조정:\n프로필 보너스는 터널 참여를 위해 피어가 선택되는 방식에 영향을 미칩니다. 보너스는 양수 또는 음수일 수 있습니다: - 빠른 피어 - 높은 속도가 필요한 클라이언트 터널에 사용됩니다 - 고용량 피어 - 안정적인 라우팅이 필요한 일부 탐색 터널에 사용됩니다 - 현재 보너스는 프로필 페이지에 표시됩니다\n설정: - 속도 - 이 피어의 속도 보너스 조정 (0 = 중립) - 용량 - 이 피어의 용량 보너스 조정 (0 = 중립) - 피어 보너스 조정 - 보너스 설정 적용\n사용 사례: - 지속적으로 연결 문제를 일으키는 피어 차단 - 악의적이라고 의심되는 피어를 일시적으로 제외 - 성능이 저조한 피어의 우선순위를 낮추기 위해 보너스 조정 - 특정 피어를 제외하여 tunnel 구축 문제 디버그\n참고: 대부분의 사용자는 이 기능을 사용할 필요가 없습니다. I2P router는 성능 지표를 기반으로 피어 선택 및 프로파일링을 자동으로 관리합니다.\nI2CP 설정 URL: Reseed 설정 Reseed 설정 페이지에서는 자동 reseed가 실패할 경우 router를 수동으로 reseed할 수 있습니다. Reseed는 I2P를 처음 설치할 때 또는 router에 남아있는 router 참조가 너무 적을 때 다른 router를 찾기 위해 사용되는 부트스트래핑 프로세스입니다.\n수동 리시드(Reseed)를 사용해야 하는 경우:\n재시딩이 실패한 경우, 먼저 네트워크 연결을 확인해야 합니다\n방화벽이 reseed 호스트에 대한 연결을 차단하는 경우, 프록시를 사용할 수 있습니다:\n프록시는 원격 공개 프록시이거나 컴퓨터(localhost)에서 실행 중일 수 있습니다 프록시를 사용하려면 Reseeding Configuration 섹션에서 유형, 호스트 및 포트를 구성하세요 Tor Browser를 실행 중인 경우, SOCKS 5, localhost, 포트 9150으로 구성하여 reseed하세요 명령줄 Tor를 실행 중인 경우, SOCKS 5, localhost, 포트 9050으로 구성하여 reseed하세요 일부 피어가 있지만 더 필요한 경우, I2P Outproxy 옵션을 시도할 수 있습니다. 호스트와 포트는 비워두세요. 이 방법은 피어가 전혀 없는 초기 reseed에는 작동하지 않습니다 그런 다음 \u0026ldquo;Save changes and reseed now\u0026quot;를 클릭하세요 기본 설정은 대부분의 사용자에게 적합합니다. 제한적인 방화벽이 HTTPS를 차단하고 reseed가 실패한 경우에만 이 설정을 변경하세요 I2P를 실행하는 신뢰할 수 있는 사람을 알고 있다면, 그들의 router console에서 이 페이지를 사용하여 생성한 reseed 파일을 보내달라고 요청하세요. 그런 다음, 이 페이지를 사용하여 받은 파일로 reseed하세요. 먼저 아래에서 파일을 선택하세요. 그 다음 \u0026ldquo;Reseed from file\u0026quot;을 클릭하세요\n리시드 파일을 게시하는 신뢰할 수 있는 사람을 알고 있다면, 해당 URL을 요청하세요. 그런 다음 이 페이지를 사용하여 받은 URL로 리시드를 진행하세요. 먼저 아래에 URL을 입력한 후 \u0026ldquo;Reseed from URL\u0026quot;을 클릭하세요\n수동 리시딩 방법은 FAQ 를 참조하세요\n수동 리시드 옵션:\nURL에서 리시드 - 신뢰할 수 있는 소스의 zip 또는 su3 URL을 입력하고 \u0026ldquo;URL에서 리시드\u0026quot;를 클릭하세요\nsu3 형식은 신뢰할 수 있는 소스의 서명이 검증되므로 권장됩니다 zip 형식은 서명되지 않으므로, 신뢰할 수 있는 소스의 zip 파일만 사용하세요 파일에서 리시드 - 로컬 zip 또는 su3 파일을 찾아 선택한 후 \u0026ldquo;파일에서 리시드\u0026quot;를 클릭하세요\n리시드 파일은 checki2p.com/reseed 에서 찾을 수 있습니다 리시드 파일 생성 - 다른 사용자들이 수동으로 리시드할 수 있도록 공유할 수 있는 새로운 리시드 zip 파일을 생성합니다\n이 파일에는 절대 자신의 router 신원 정보나 IP가 포함되지 않습니다 리시딩 설정:\n기본 설정은 대부분의 사용자에게 적합합니다. 제한적인 방화벽이 HTTPS를 차단하고 reseed가 실패한 경우에만 이 설정을 변경하십시오.\nReseed URL - Reseed 서버의 HTTPS URL 목록 (기본 목록은 내장되어 있으며 정기적으로 업데이트됨) 프록시 구성 - 프록시를 통해 reseed 서버에 접근해야 하는 경우 HTTP/HTTPS/SOCKS 프록시 설정 URL 목록 초기화 - 기본 reseed 서버 목록 복원 중요: 수동 리시딩은 자동 리시딩이 반복적으로 실패하는 드문 경우에만 필요합니다. 대부분의 사용자는 이 페이지를 사용할 필요가 없습니다.\n네트워크 구성 URL: 라우터 패밀리 설정 라우터 패밀리 설정 페이지에서는 라우터 패밀리를 관리할 수 있습니다. 같은 패밀리에 속한 라우터들은 패밀리 키를 공유하며, 이는 동일한 사람이나 조직이 운영하는 라우터임을 식별합니다. 이를 통해 귀하가 제어하는 여러 라우터가 동일한 터널에 선택되는 것을 방지하여 익명성 저하를 막습니다.\nRouter Family란 무엇인가?\n여러 대의 I2P router를 운영할 때는 동일한 패밀리의 일부로 구성해야 합니다. 이를 통해 다음을 보장합니다: - 여러분의 router들이 동일한 tunnel 경로에 함께 사용되지 않습니다 - 다른 사용자들이 여러분의 router를 사용하는 tunnel을 이용할 때 적절한 익명성을 유지합니다 - 네트워크가 tunnel 참여를 적절하게 분산할 수 있습니다\n현재 패밀리:\n이 페이지는 현재 라우터 패밀리 이름을 표시합니다. 패밀리에 속하지 않은 경우 비어 있습니다.\nFamily Key 내보내기:\n다른 라우터로 가져올 비밀 패밀리 키 내보내기 \u0026ldquo;Export Family Key\u0026quot;를 클릭하여 패밀리 키 파일 다운로드 동일한 패밀리에 추가하려면 다른 라우터에서 이 키를 가져오기 라우터 패밀리 탈퇴:\n더 이상 패밀리의 구성원이 아님 현재 패밀리에서 이 라우터를 제거하려면 \u0026ldquo;Leave Family\u0026quot;을 클릭하세요 이 작업은 패밀리 키를 다시 가져오지 않는 한 되돌릴 수 없습니다 중요 고려사항:\n공개 등록 필요: 패밀리가 네트워크 전체에서 인식되려면, 패밀리 키가 개발팀에 의해 I2P 코드베이스에 추가되어야 합니다. 이를 통해 네트워크의 모든 router가 귀하의 패밀리에 대해 알 수 있습니다. 여러 공개 router를 운영하는 경우 I2P 팀에 연락하여 패밀리 키를 등록하세요 하나의 router만 실행하는 대부분의 사용자는 이 기능을 사용할 필요가 없습니다 패밀리 구성은 주로 여러 공개 router를 운영하는 운영자나 인프라 제공자가 사용합니다 사용 사례:\n중복성을 위해 여러 I2P router 운영 여러 머신에서 reseed 서버나 outproxy와 같은 인프라 실행 조직을 위한 I2P router 네트워크 관리 피어 설정 URL: 터널 설정 터널 구성 페이지에서는 탐색 터널(router 통신에 사용)과 클라이언트 터널(애플리케이션에서 사용) 모두에 대한 기본 tunnel 설정을 조정할 수 있습니다. 기본 설정은 대부분의 사용자에게 적합하며, 트레이드오프를 이해하는 경우에만 변경해야 합니다.\n중요한 경고:\n⚠️ 익명성 대 성능 트레이드오프: 익명성과 성능 사이에는 근본적인 트레이드오프가 존재합니다. 3홉보다 긴 tunnel(예: 2 hops + 0-2 hops, 3 hops + 0-1 hops, 3 hops + 0-2 hops) 또는 높은 수량 + 백업 수량은 성능이나 안정성을 심각하게 저하시킬 수 있습니다. 높은 CPU 및/또는 높은 아웃바운드 대역폭 사용이 발생할 수 있습니다. 이러한 설정은 신중하게 변경하고, 문제가 발생하면 조정하십시오.\n⚠️ 지속성: 탐색 tunnel 설정 변경사항은 router.config 파일에 저장됩니다. 클라이언트 tunnel 변경사항은 임시적이며 저장되지 않습니다. 클라이언트 tunnel 변경사항을 영구적으로 적용하려면 I2PTunnel 페이지 를 참조하세요.\n탐색 터널(Exploratory Tunnels):\n탐색 터널(Exploratory tunnel)은 라우터가 네트워크 데이터베이스와 통신하고 I2P 네트워크에 참여하는 데 사용됩니다.\nInbound와 Outbound 모두에 대한 구성 옵션: - Length - tunnel의 홉 수 (기본값: 2-3 홉) - Randomization - tunnel 길이의 무작위 변동 (기본값: 0-1 홉) - Quantity - 활성 tunnel 수 (기본값: 2개 tunnel) - Backup quantity - 활성화 준비된 백업 tunnel 수 (기본값: 0개 tunnel)\nI2P 웹서버를 위한 클라이언트 터널:\n이 설정은 내장된 I2P 웹서버(eepsite)의 tunnel을 제어합니다.\n⚠️ 익명성 경고 - 설정에 1-hop 터널이 포함되어 있습니다. ⚠️ 성능 경고 - 설정에 높은 터널 수량이 포함되어 있습니다.\nInbound와 Outbound 모두에 대한 구성 옵션: - Length - 터널 길이 (기본값: 웹서버의 경우 1 hop) - Randomization - 터널 길이의 무작위 변동 - Quantity - 활성 터널 수 - Backup quantity - 백업 터널 수\n공유 클라이언트를 위한 클라이언트 Tunnel:\n이 설정은 공유 클라이언트 애플리케이션(HTTP 프록시, IRC 등)에 적용됩니다.\nInbound와 Outbound 모두에 대한 구성 옵션: - Length - 터널 길이 (기본값: 3홉) - Randomization - 터널 길이의 무작위 변동 - Quantity - 활성 터널 수 - Backup quantity - 백업 터널 수\n터널 파라미터 이해하기:\n길이(Length): 터널이 길수록 익명성이 향상되지만 성능과 안정성은 저하됩니다 무작위화(Randomization): 터널 경로에 예측 불가능성을 추가하여 보안을 향상시킵니다 수량(Quantity): 터널이 많을수록 안정성과 부하 분산이 개선되지만 리소스 사용량이 증가합니다 백업 수량(Backup quantity): 장애가 발생한 터널을 대체할 수 있도록 미리 구축된 터널로, 복원력을 향상시킵니다 모범 사례:\n특정 요구사항이 없다면 기본 설정을 유지하세요 익명성이 매우 중요하고 성능 저하를 감수할 수 있는 경우에만 tunnel 길이를 늘리세요 tunnel 장애가 자주 발생하는 경우에만 수량/백업을 늘리세요 변경 후 router 성능을 모니터링하세요 \u0026ldquo;Save changes\u0026quot;를 클릭하여 수정사항을 적용하세요 Reseed 설정 URL: UI 구성 UI 설정 페이지에서는 테마 선택, 언어 기본 설정 및 비밀번호 보호를 포함하여 router 콘솔의 모양과 접근성을 사용자 지정할 수 있습니다.\n라우터 콘솔 테마:\nrouter console 인터페이스의 다크 테마와 라이트 테마 중 선택하세요:\nDark - 다크 모드 테마 (어두운 환경에서 눈의 피로도 감소) Light - 라이트 모드 테마 (전통적인 외관) 추가 테마 옵션: - 모든 앱에 테마를 전역으로 설정 - 선택한 테마를 라우터 콘솔뿐만 아니라 모든 I2P 애플리케이션에 적용 - 모바일 콘솔 강제 사용 - 데스크톱 브라우저에서도 모바일 최적화 인터페이스 사용 - 콘솔에 이메일 및 토렌트 애플리케이션 포함 - Susimail과 I2PSnark를 별도 탭으로 여는 대신 콘솔 인터페이스에 직접 통합\n라우터 콘솔 언어:\n드롭다운 메뉴에서 router console 인터페이스에 사용할 언어를 선택하세요. I2P는 영어, 독일어, 프랑스어, 스페인어, 러시아어, 중국어, 일본어 등 다양한 언어를 지원합니다.\n번역 기여를 환영합니다: 불완전하거나 부정확한 번역을 발견하시면, 번역 프로젝트에 기여하여 I2P를 개선하는 데 도움을 주실 수 있습니다. IRC의 #i2p-dev에서 개발자에게 연락하거나 번역 상태 보고서를 확인하세요(페이지에 링크되어 있습니다).\n라우터 콘솔 비밀번호:\n라우터 콘솔에 대한 접근을 보호하기 위해 사용자 이름과 비밀번호 인증을 추가하세요:\n사용자 이름 - 콘솔 접속을 위한 사용자 이름을 입력하세요 비밀번호 - 콘솔 접속을 위한 비밀번호를 입력하세요 사용자 추가 - 지정된 인증 정보로 새 사용자를 생성합니다 선택 항목 삭제 - 기존 사용자 계정을 제거합니다 왜 비밀번호를 추가해야 하나요?\n라우터 콘솔에 대한 무단 로컬 접근을 방지합니다 여러 사람이 컴퓨터를 사용하는 경우 필수적입니다 로컬 네트워크에서 라우터 콘솔에 접근 가능한 경우 권장됩니다 I2P 설정 및 개인정보 보호 설정이 변조되지 않도록 보호합니다 보안 참고사항: 비밀번호 보호는 I2P Router Console 의 router console 웹 인터페이스 접근에만 영향을 미칩니다. I2P 트래픽을 암호화하거나 애플리케이션이 I2P를 사용하는 것을 막지 않습니다. 컴퓨터의 유일한 사용자이고 router console이 localhost에서만 수신 대기하는 경우(기본값), 비밀번호가 필요하지 here 않을 수 있습니다.\n라우터 패밀리 설정 URL: WebApp 설정 WebApp 설정 페이지에서는 I2P router 내에서 실행되는 Java 웹 애플리케이션을 관리할 수 있습니다. 이러한 애플리케이션은 webConsole 클라이언트에 의해 시작되며 router와 동일한 JVM에서 실행되어, router 콘솔을 통해 접근 가능한 통합 기능을 제공합니다.\nWebApps란 무엇인가요?\nWebApps는 다음과 같은 Java 기반 애플리케이션입니다: - 완전한 애플리케이션 (예: 토렌트용 I2PSnark) - 별도로 활성화해야 하는 다른 클라이언트의 프론트엔드 (예: Susidns, I2PTunnel) - 웹 인터페이스가 없는 웹 애플리케이션 (예: 주소록)\n중요 사항:\n웹앱은 완전히 비활성화되거나 시작 시 실행만 비활성화될 수 있습니다 webapps 디렉토리에서 war 파일을 제거하면 웹앱이 완전히 비활성화됩니다 그러나 router를 새 버전으로 업데이트하면 .war 파일과 웹앱 디렉토리가 다시 나타납니다 웹앱을 영구적으로 비활성화하려면: 여기서 비활성화하는 것이 권장되는 방법입니다 사용 가능한 WebApps:\nWebApp Description i2psnark Torrents - Built-in BitTorrent client for I2P i2ptunnel Hidden Services Manager - Configure client and server tunnels imagegen Identification Image Generator - Creates unique identicons jsonrpc jsonrpc.war - JSON-RPC API interface (disabled by default) routerconsole I2P Router Console - The main administrative interface susidns Address Book - Manage I2P addresses and subscriptions susimail Email - Web-based email client for I2P 제어: 각 웹앱별: - 시작 시 실행? - 자동 시작을 활성화/비활성화하는 체크박스 - 제어 - 즉시 제어를 위한 시작/중지 버튼 - 중지 - 현재 실행 중인 웹앱을 중지합니다 - 시작 - 중지된 웹앱을 시작합니다\n설정 버튼:\n취소 - 변경 사항을 취소하고 이전 페이지로 돌아갑니다 WebApp 설정 저장 - 변경 사항을 저장하고 적용합니다 사용 사례:\n토렌트를 사용하지 않는다면 리소스 절약을 위해 I2PSnark를 중지하세요 API 접근이 필요하지 않다면 jsonrpc를 비활성화하세요 외부 이메일 클라이언트를 사용한다면 Susimail을 중지하세요 메모리 확보나 문제 해결을 위해 일시적으로 웹앱을 중지하세요 성능 팁: 사용하지 않는 웹앱을 비활성화하면 메모리 사용량을 줄이고 router 성능을 향상시킬 수 있으며, 특히 리소스가 제한된 시스템에서 효과적입니다.\nHelp URL: 도움말 도움말 페이지는 I2P를 효과적으로 이해하고 사용할 수 있도록 포괄적인 문서와 리소스를 제공합니다. 문제 해결, 학습 및 지원을 받기 위한 중심 허브 역할을 합니다.\n제공 내용:\n빠른 시작 가이드 - I2P를 처음 시작하는 사용자를 위한 필수 정보 자주 묻는 질문(FAQ) - I2P 설치, 구성 및 사용에 관한 일반적인 질문에 대한 답변 문제 해결 - 일반적인 문제 및 연결 문제에 대한 해결 방법 기술 문서 - I2P 프로토콜, 아키텍처 및 사양에 대한 상세 정보 애플리케이션 가이드 - 토렌트, 이메일, 히든 서비스와 같은 I2P 애플리케이션 사용 방법 네트워크 정보 - I2P의 작동 원리와 보안성에 대한 이해 지원 리소스 - 포럼, IRC 채널 및 커뮤니티 지원 링크 도움 받기:\nI2P에 문제가 발생한 경우: 1. FAQ에서 자주 묻는 질문과 답변을 확인하세요 2. 특정 문제에 대한 문제 해결 섹션을 검토하세요 3. i2pforum.i2p 또는 i2pforum.net 에서 I2P 포럼을 방문하세요 4. 실시간 커뮤니티 지원을 위해 IRC 채널 #i2p에 참여하세요 5. 자세한 기술 정보는 문서를 검색하세요\n팁: 도움말 페이지는 router console 사이드바에서 언제든지 접근할 수 있어, 필요할 때마다 쉽게 도움을 받을 수 있습니다.\nPerformance Graphs URL: 성능 그래프 Performance Graphs 페이지는 I2P router의 성능과 네트워크 활동에 대한 실시간 시각적 모니터링을 제공합니다. 이 그래프들은 대역폭 사용량, 피어 연결, 메모리 소비량 및 전반적인 router 상태를 이해하는 데 도움을 줍니다.\n사용 가능한 그래프:\n대역폭 사용량\nLow-level send rate (bytes/sec) - 아웃바운드 트래픽 속도 Low-level receive rate (bytes/sec) - 인바운드 트래픽 속도 현재, 평균, 최대 대역폭 사용률 표시 설정된 대역폭 제한에 근접하고 있는지 모니터링하는 데 도움 활성 피어\nrouter.activePeers averaged for 60 sec - 현재 활발하게 통신 중인 피어의 수 네트워크 연결 상태를 보여줍니다 활성 피어가 많을수록 일반적으로 tunnel 구축 및 네트워크 참여가 원활함을 의미합니다 라우터 메모리 사용량\nrouter.memoryUsed averaged for 60 sec - JVM 메모리 소비량 현재, 평균 및 최대 메모리 사용량을 MB 단위로 표시 메모리 누수를 식별하거나 Java 힙 크기를 늘려야 하는지 판단하는 데 유용 그래프 표시 구성:\n그래프 표시 및 새로 고침 방법을 사용자 지정하세요:\n그래프 크기 - 너비(기본값: 400픽셀) 및 높이(기본값: 100픽셀) 설정 표시 기간 - 표시할 시간 범위(기본값: 60분) 새로고침 간격 - 그래프 업데이트 주기(기본값: 5분) 플롯 유형 - 평균 또는 이벤트 표시 중 선택 범례 숨기기 - 공간 절약을 위해 그래프에서 범례 제거 UTC - 그래프에서 현지 시간 대신 UTC 시간 사용 지속성 - 과거 분석을 위해 그래프 데이터를 디스크에 저장 고급 옵션:\n**[Select Stats]**를 클릭하여 그래프로 표시할 통계를 선택하세요: - tunnel 메트릭 (빌드 성공률, tunnel 수 등) - netDb 통계 - transport 통계 (NTCP2, SSU2) - 클라이언트 tunnel 성능 - 그 외 다양한 상세 메트릭\n사용 사례:\n대역폭을 모니터링하여 설정된 제한을 초과하지 않는지 확인 네트워크 문제 해결 시 피어 연결 상태 확인 메모리 사용량을 추적하여 Java 힙 설정 최적화 시간 경과에 따른 성능 패턴 파악 그래프 상관관계 분석을 통한 터널 구축 문제 진단 팁: 변경사항을 적용하려면 설정을 변경한 후 \u0026ldquo;Save settings and redraw graphs\u0026quot;를 클릭하세요. 그래프는 설정한 새로고침 지연 시간에 따라 자동으로 새로고침됩니다.\n","description":"I2P 라우터 콘솔 이해 및 구성에 관한 종합 가이드","id":"c46f1b6edeab9b686fd57cf9b311df1c","section":"docs","title":"라우터 콘솔 구성 가이드","url":"/ko/docs/guides/router-console-config/"},{"categories":null,"content":" 0.9.57 이후 릴리스는 idk가 서명합니다. 그의 현재 공개 키는 다음과 같습니다: PGP 공개 키 다운로드 릴리스 0.7.6 및 0.9.56은 zzz가 서명했습니다. 그의 현재 공개 키는 다음과 같습니다: PGP 공개 키 다운로드 -----BEGIN PGP SIGNED MESSAGE----- Hash: SHA1 새로운 GPG 키와 서브키를 생성했으며, 기존 키로 새 키에 서명했습니다.\n이전 키:\npub 1024D/A76E0BED 2005-12-16 Key fingerprint = 4456 EBBE C805 63FE 57E6 B310 4155 76BA A76E 0BED uid zzz (zzz) \u0026lt;zzz@mail.i2p\u0026gt; sub 2048g/74C8122D 2005-12-16 새 키:\npub 4096R/EE7256A8 2014-05-08 [expires: 2024-05-05] Key fingerprint = 2D3D 2D03 910C 6504 C121 0C65 EE60 C0C8 EE72 56A8 uid zzz on i2p (key signing) \u0026lt;zzz@mail.i2p\u0026gt; uid zzz on i2p (key signing) \u0026lt;zzz@i2pmail.org\u0026gt; sub 4096R/1AE988AB 2014-05-08 [expires: 2019-05-07] sub 4096R/01B5610C 2014-05-08 [expires: 2019-05-07] sub 4096R/59683006 2014-05-08 [expires: 2019-05-07] 새 키를 다음과 같이 사용하겠습니다:\nEE7256A8: key signing 1AE988AB: email signing 01B5610C email encryption 59683006 release signing 릴리스 서명 키는 0.9.13 릴리스부터 사용될 예정입니다. 이 메시지는 제 이전 키로 서명되었습니다.\nzzz 2014년 5월 25일\n새로운 키는 다음과 같습니다:\n\u0026mdash;\u0026ndash;BEGIN PGP PUBLIC KEY BLOCK\u0026mdash;\u0026ndash; Version: GnuPG v1.4.14 (GNU/Linux)\nmQINBFNrjZsBEADMHWiucM8ES5VDfq6n4M9DJhMyG5jVoakzSFHfzVOEpHeDYR1E eaEIFt5CEx0mbpXWy6UBoj0E7o3se5RvF81VQQ4xO0MyHZLkpotGffZo7D34uKTd 1SFbirosXwnsOxjPGLF+PuwifV+mzSoE66XRmg5UJbOJj0ZitYBn4lDKMxU1Rext WX7D79qnJW2GXv/HuzTwZ/KV3fOVB782+fNdFBDZt4XHSM32ideXedTtTJ+FXjBv 1/eQ/Ls8PMYKaYUm/j0oTI2A5aNP+6BH8/NrVvF8xQWCibrOILASWFRJE7insciJ m9eeEPPOp1D4fRDWFyjABcn00fv7T7RDBgIdpuj3gBDvGXgx8SRiWxe9CwV9TcJl WNPTAKd9XGHT13XWwc1myO/yg+yQoJB6HO1jGjqxQuu3aHCw2i4gTHflq4qZoSDV oxJWeh+mNsfx4DgmoT1UeEmh2Uq64czMGh8wJC0FqSa+FmgCKa1FxcTnYlfIjR79 qwbEKK3JZ5PPkiK5Lh4hNvkXKLrUXpG1KHm6yNVPNIWCOMd7VCDziEhsbeNPCzQc 6af8dkyI9BUeQD3fGjeHCh/QHLju9Lde77GDddYaShXVI/Wiy4AWgN0KVUk8CnEZ Uu2JbazpJBLGGiB2CujP44eJzm9VPoBx8Xc9/Pk2RFbz2bN4uQtSD6lAjQARAQAB tCd6enogb24gaTJwIChrZXkgc2lnbmluZykgPHp6ekBtYWlsLmkycD6JAj4EEwEC ACgFAlNrjyYCGwMFCRLMAwAGCwkIBwMCBhUIAgkKCwQWAgMBAh4BAheAAAoJEO5g wMjuclaoxkEP/RQRz7kWfCWcDWtKSxq1zA3HEUKUHLxhBIl1C+tmMtJypyWwiP8Y hrO/Tuk8nsnVOl9wMMtz2ZxMpUS2gTsuquZ6pIUCNtEP+IAuKsZlCcsNB+yOoi2T i71cXLBPcN/rbxyoOUMpk+fJgdsustUnSMbXJQ2sLjieurD/YpUMJZw6KoNVrhU1 1nDaJqAq/zouhSvNMvx5+GBodQ41gvtb984xbrNc8B24upCBHSF1olczWYPUtaAi oMlZTNr5XFS//Q8X3sEKAoRMbAX6UvZVdtgqQajGilMg+HM3HnbPqsHoyPWx4f8O n134ITgrVwL24y+m9XHfY+JPjcBgg9uGLuLJqMrrjYfz7jVdUJQUsy/R2+yzg1Bm Ruf3SBhHpG2dSBOTxi9GD4aL/7wXuXj9uIuFtX80EwsT4XifnIaHTdtNNzVO+obF dJyiIpF1IFmFOTgJ3ba9gcILQIWXGIp1e5C8g2MtuYO/6/jZK1lhFCLbvhpA9C4q uUp6/WXnavd3beKltkzL1v2dOjC1EkjrsFF50olV4f3d56JdS7JEnFzx7gVeSQfF uLR/t22CluxzubcYoAk/hdIWM2Ufi6v6ONVWc7D5nYBW9onNRKEquA/qOHZr3C/M QbRxTYyhaMW4Nrwck9jmpcQBE1EzscX3DAr+3W+rnKDCZL5QuI2Yq5gkiEYEEBEC AAYFAlNrl+YACgkQQVV2uqduC+1XMwCcC24MIzSxDOEpX7c/ecTKm18bOQkAmwU9 WqqUgT37bQ+U9ME322JPrBsitCp6enogb24gaTJwIChrZXkgc2lnbmluZykgPHp6 ekBpMnBtYWlsLm9yZz6JAj4EEwECACgFAlNrjZsCGwMFCRLMAwAGCwkIBwMCBhUI AgkKCwQWAgMBAh4BAheAAAoJEO5gwMjuclaobxQP/0oU+/nhTx7NRUZ3Ay/LzD7v DHqX+A1iPos1Xzmz+vq9a7z/mjjiQn0wfFiMctFc5dRf+hSM+W7BUfcG5rML+416 rEgtCDsQ0KfaFYUPRObxxNRdDv4N0j6uw2hFmAZ+KkOxKf5Z5CV7A2dwpjsO+PSc Ed0BM1iAjzNbod5b5uAn6r/Z43GSH2omRdhE8Ne5UrH58kLFSg8+iAfnnV5SSEKo bkP0f5m91esbh+vAgq0nFRsB8PeBYklw20wnAkIy6rmKJngBpiF0KfC/V6NY3g63 NDqf4wbSO8WqnrS9QWqYFzJfDsARQvx3jBqLTcQ4SlpIVWKNeogkeSeuqCVKRgvN jWBHdfABkf+DHrzlf072PK8RtDZn6wn1D91MeFCvg+Ss6XV2d0JEd+bxdK6Aj1RR X4XGv0jcH1Ftm9JRNjzXsALzndvwvEKU2xgDA2LATA7ikKbIq19VoTf90uc7i1Os 6cOXZkezZatyuJzJITGeq4llek+PVFxU/5LnRLr6h6K5D0/5F9KlgtPJKgSDOipp TN1Vof8f+v1/zWmyxpw9jtkNjM9chtOY7xhQfNxQLZuHXjQtDT3+JGo6/gTqj105 Yg+HNTJjkDYl2Y5AHb0WFHUFSn2GiBtot4V/g2ojMeQIiw2a8v17H6HUZSKYBjgR L7ln7O4oBduvaSSyZE2jiEYEEBECAAYFAlNrl+YACgkQQVV2uqduC+3d7ACgpRpk 13FSAhz/RpPnqYwRSFUiQTsAoIewgMNIxgbPQGUVDO3FpzChAfUruQINBFNrj7YB EAC8GDV5JcAcktMYnUbPxpydlWSDzzBaDUvbOAtWbrmkwQUXyij0O4ZW1W81e0R+ APT26TLuqc6Q+v6b0rWlVoZkSKYaqzm0S3mtLWUvEgPjHfYXT7VaHtzu6QUPwmVa w+o8dxkbajl5C1i9CZyr8ACziD23FSPA5nd/WQ18EAbnIjnT4cV9dP7lLqZAWtzE Cp3ze4ZHt6kg5i6rhJBJWbycHAZK2SMclC37S6MtZAwW0pJJwn/qdj7UvmL72QoV qXNHe8dfKfnxzo0/HoCKn4rlIW0W3xHgqy6VQUnyigL0blrVmxzcH5bgttXr94yh MVV1Kg9ie1GfhPf1ui86NnGHczbZB2TmTc/d2Nl1/L3TwxiWX2fv9BF+mVczRiXc 9FZRTF5JsBN0BAyxIE9vDXK/yygiWRSD1ND/0eTmKJRqOplpXoCBSDCsfvFN6/63 mx70wP92bNMmDZ/zbjFApmbMCjf+0wCZljiBtkNgT4k2nOYjb6Kt+vOeEg1XBTqo WREHEUA23xsu2DMH5Ra0OA0NwA9jrp1dg4t7fKIkSlBLNlIsZ73lNV21uuA8lVFR KHRX7y394c5/T9c8zPtJSmIZnAY52KXBFfsM3h+ExaQIWclyU375kYi0IBE9tCfF 7VuX1JgvA/9SjjtgfEWWLkhkPUAUl82e8SYQRx5Ki3RIvQARAQABiQREBBgBAgAP BQJTa4+2AhsCBQkJZgGAAikJEO5gwMjuclaowV0gBBkBAgAGBQJTa4+2AAoJEA6+ gRoa6YirbtsQAKheBU6M3oAfyAJ7i13mPEY2EvZFXdY41ct89ebdLCe4revG5Tao Fj/OmD0W+eBvRbJvOglw+0wYjpjAsnl95kYCBRL/BAr9xWt/g9SCcQqxOaYI9gM0 pFAcPjicEF44xdSMDSWGpN0PT5M6omlz5EObxuU3vaZ8y2XWYdvW8p1AwST66y/M AoACZqJUsIo7HIsz607XzNa3evIkCuGGNbTrD0OCTNUxOhwtqMIt3bHE2h4I8Hwp hptTf2eDf2z587/32gs3yp/VAeP6dCeQF3+Wduc41aRsCru7HnE2w/BiW1nzePyK 6b3RA56bZcbANIS8k/+EVOakS4uRDnweqkwBVgkWsCk17+XNeIaRaY0pWJaFs+hO f7cdp/XK+z2eFO1brEJa3BmnHHMx/lUv5YS8MgD+CcdvHvb2dirthzvyb6yDKFNn ZkMz3/Z1wnlDkMp/fjJAwXfmKT7IOqPVN5fpLcXp27Jh2BSrafvLupkIzZhrGL7R hTg8X83rLuQ0ZSn8k9cFju1pECI1atXC/kPMlSC4VffoViqwSZDLFsniFSNTaBOw EfKCLxv4s0BNovaUQfY2DUkL2BHrU18HbpGkaD3Gmb6TnzBYRTWSz15/9w8cjOc9 rr9d5SZaUeMZkGmlUdEG5q43b0MwQxYSA4Y3ZZGMgbjzEa83YN2njV7U07MP/1C2 D/tpWM2SliCGQ9ioPZVnwB43sme7J0GWjLRR085Q8+4V3/buWNG0UBc+l3MNlO0m N/zPp8ZqKCe6tLIXiExgiMSfcv9/7G3AgKxfzY+t3wFC6ISZiG5JFQIx/NI6zR+F RPUXUf8ZWH+i49p3UY564wULQMLobMuxhO2+BkjZKPkHAiXB0FTdP9WW/Gt2vWgZ L6ogdmo2bo2BQCU0VOOlCp8MxL9MlQ0FGURT/2kGoFzNFUo63UGvJc2iFmICI//9 OGBkpEMuPGrZI9W/4NTh+yMYj1b176IssWU2PWvhpempaXbcgXnlZQ5x6qcszzrw m403O814RLkIljRdtjHWOJKygXpjj8qTbDFfLXWDZ6MTtZOgFOPHFpc+Drbyzgu0 Z3dpXBeoyXQaZGOtClVJTCUYMjE6AaWZrnvsjT2TSxK+oy4XXzI4vVvDMJh2Ibfs YKiRahGQnBiYEMIrefoj/wu2GaZ71y8P6tCfdvlv9DikIVTHajdG4G2K7Sr4glgk cB9M2IsSy7bw2OGrGFvkpqriL1aYvIF5Wf4KIsxpMZ2FIUeGP4YfT3ec7zfSC5bp /yBP8J/XXaCV8NkhLF4bD9tU+XRRK54LZkoDrJwmTreHknluF6hFuJl8d0+oHyjp kHp\niEYEARECAAYFAlOB3xkACgkQQVV2uqduC+3+UgCfYZiUtx7FDGdQDhdVP8MyRf0D ANIAn2YHOQh4yv84u2Kuars1gC0j3Nr2 =Zu9F \u0026mdash;\u0026ndash;END PGP SIGNATURE\u0026mdash;\u0026ndash; 0.9.9 버전부터의 릴리스는 str4d에 의해 서명될 수 있습니다. 그의 현재 공개 키는 다음과 같습니다: -----BEGIN PGP SIGNED MESSAGE----- Hash: SHA512 현재 제 공개 키는 다음과 같습니다:\npub 4096R/0EC51FCDA94FB53E 2014-03-11 [만료: 2019-03-10] uid [ full ] str4d (http://str4d.i 2p) str4d@mail.i2p uid [ full ] str4d str4d@i2pmail.org sub 4096R/1CC61D9B33C3241B 2014-03-11 [만료됨: 2015-03-11] sub 4096R/803DEE491A3473E7 2014-03-12 [만료됨: 2015-03-12] sub 4096R/A1B84C9B733AAC82 2015-04-05 [만료: 2016-04-04] sub 4096R/13B5EE58C09FB3E0 2015-04-05 [만료: 2016-04-04]\n현재 키를 다음과 같이 사용합니다:\nA94FB53E: key signing 733AAC82: email encryption C09FB3E0: email and release signing 저는 매년 새로운 암호화 및 서명 하위키를 생성합니다. 제가 서명한 모든 I2P 릴리스는 항상 릴리스 시점의 최신 서명 하위키로 서명됩니다.\nstr4d 2015년 11월 20일\n현재 키 (위 날짜 기준):\n\u0026mdash;\u0026ndash;BEGIN PGP PUBLIC KEY BLOCK\u0026mdash;\u0026ndash; mQINBFMfofkBEADlyw6v1hGBtnIISujt/18RJcVTLAxYtfe3DsGhWqYZN3iKGGWb NJ5vZcV65FVH/70NFnmKlvYp+tVNJcoRtEYpfwiNG7nIyOC4GgaSLwkNVgLcFZhV mNj2RIJphjN5qsWm6ut9p9CyhWkVNJYDP65gqwShZQ2lPboo9s0XjUF78SrSshy2 iVij0xu6oqdjwqn1B7L3lXVYCwxReCvSdFnBMpjGUEgGnbt7euhrViFk8FrUkAje 2tZA5FAUA/t2Mnc9JREe6WlbZ44mLApOjFdw0g415FdcnS2GGaYuXNG1lJ1yOA33 n9JXT7A31wPyiw5yz7fxgl7ZNYZr2TsRjBlqEhf2SCPfqU9UlhJ9NqApaPyCEr+8 oZQfZ9r6stc98MlnmdQ7p4SmKRwCLiBtgmrB8mbgYV+iOwaKztqEoma3FoO2EJ+j Gx+UrJ0bIFVr6sL0ulfneYlY76wWWRpB/pLLgIMmZw83uB+JDBQyZFXcAHj9jMQ7 ZNn0MNQ/I+qcmX+CRAyl2+cQHUVbbQWDjB3crZlpK5TGw/x7w0YxBYAH8Us5JqJH QOsact8ADnE4IiKm5gVefFmNX6vsljkNESdpAMxnB7Ckl2XV/r5sKwrdxxUbFSxp IKGx2uKGUs4oUffOzpKULhGBWypN+3fVwvP+q896Il9hgyx6SCQ8AgPHRwARAQAB tClzdHI0ZCAoaHR0cDovL3N0cjRkLmkycCkgPHN0cjRkQG1haWwuaTJwPokCQAQT AQoAKgIbAwUJCWYBgAULCgkIBwYVCgkIAwIEFgMCAQIeAQIXgAUCUx/ZQgIZAQAK CRAOxR/NqU+1Pk9EEADHdpsmrA6ZKU4EmBZNbw62D7tAo00Fh25m8OuIkXtOqEbF /guTZiZM4nbhZpPFG9sCN1bXS8VslA7isOedbznkKnSK0BJcrzldwKzW25cwptoQ CCqTUarYbhcIzEOKNetYqICWrVTy2Yuc37maA66PnRLphV7pP3Fj7eN6aMtqwtpJ YukIU4LAjKOMJ6gwy7tjsZYbAqgSE8wRJm7i1MfO1W864a1l2a68Gooz03NC6mfY J8aW0y1F87xMJIgZeN7OyHf2AC4/Tp/cL+Gd3HcUuoRjmWBgaxH8tVNgfxSIUMNH 5pTdDs5VlRolwlOEcTW5VxOSu5C7ZbuKyFmbI0DSevDVGS0rxSSizjlyGmnxkLU1 ozpeIwTbwTUzvd26+k8cidGodKqoNoyAXzjaiBXYKgIrVeXBMHxCGeQtGeEhQR+L OXs8cEX6xpt9g7nKbNki0Cfv/lx9Byn+0v9RvMJKDa1mOSKbNOx3NJ8+ewdTVkTs iYFTZwpJexbfovPYqTdisiO7dv0i5teE8sEj25icdPtKYvn/55JCT67E8MVZaeyU YOaMPtgsiOX0v68NtrC1L37UuBykQlm7FdobN4Sg5FnLTt4IWktf0/vsaLdhRozD KsbTmsumCrScAwZfa0H3S8WqK6yCEKjPi+J4xG1OZP1WptlV41wLnFKkeFaZRIkB HAQTAQoABgUCUx/Y+AAKCRDV3jiWlKRlsmU0B/96eiPHIIvapoXKoZSt23OFjXG+ 3xp/Zzf2Ug0384FYZJ1eX/R2IWsh64CVvOR0LMFvHvPU7SCMu2OreNHfPx/B/kn8 MmusGy6JHP25A4BWzs1eeyKgYQTFz7vSCeAnytmcdBot1s099upIRw4usCLhdxzv Qyx6TogAacGC3YFj7o0agz+ApPnCQZ68kZpDOCDrtOe/DRted1LLXM661Cp15d5R d+91ZSKfQ9xjK1d2k8iMYJqWYll50DalGtzPGDB335gX7agliI5dYiu2XSLyynhw /7f8d0Bz8KVj7pgCroAVjTSdHvZfVcZJU4HST/jHx5hilVUzkr9NK5YONJ8SiQQc BBABCgAGBQJTKlm2AAoJEPvivaOtdGgqmGAgALl0eAcUSF7IuloPT4VyJeNGMuOb 7aN4yYrGBM+y7Ij/dTWSS1yjlcixsqd+s0dqGse6RtJkyhkisEmNdS7Sf62okGDl ZbmhjvMQteUO1zw+CREdfx5oMpW/eCHq/Pzw8KRdp6qY0wBRj10GFMAaMX8XCNOh 6B6Ti0AQ/424yEvcPpA0zXwvLGylFozRxjK6qWEHEmW/+knxYYN/W+8TERuwVJSN F3jBYl73DTVBZ4bzpu5jMSydhRD02nV2LbnolhbCzGllLkhQw6iFW36br8600Tba loQhcJU+cmuCId/B6xXcF+fyWqmMmm+b0UFoHGRBnXCf4gBcjCK0UwJ1lUOTY5qg IYJTrBpCrGAoGTd9s+1CtnnZFlIcwFJB7NwMZEsTWvOvO6sZPYP33ktcUwWAKqNj 3sSjy43kdfUeVip0jzV0K5uStC+DiVq8VwH7uNIH2UbkQZato67WgShUCCaSvf2p HapSRdrmwIaoANQuEluhytdafX7yqJXGkhYI0Ylh2FH3oZyTnz1XoB5y5T1OpFpi I7CgjRO677aieRsf6HACHPX5mWcq8zJQ8fuxoHZ5GJ8FEyk6ULUgFJ3u9SgG5k5I vP4pK8+lP/d90Zf98Uaq4aMgAoIlrtwz68Bv/KUlpwVWhiIgo89C5UwcTUNQOmi3 0PxCpamM81NwGPxjZAqr/+0YP3NBtJOITL0oqRCxcHCJ9N8gmqUmUEgEffP+glsJ p/mQeJEacmR9loz6WAB6GT9mu5TvX6bZ5EawnluQ1mI6Tn+v6ltjhKzPzaVhOo6d iKriQFZhcelX1qDnE3zs7driBeacuKGt4URV8A+UDGJBeIAEfrlszor3FQ0qOUPs plbcbB4YudUOhlH1REtGx7zWVFefuy80ZC7abHsPhWkJow2axWlvPqjSsd/KgpjG IAHIZxiYAozNJqDNluGx1+qa1d7/YINthZKefhkG3XDLuhgxvD8rAovyAFW/8Vy0 S+GpzUVtC8HY9FZf2gRkVtZQGboZck2uFyIaU/Ni4ahX8Z9IvtsU9JPLzp0HRgAv 9kz9EyRZt1viueeIVcmadHirUe1IKqndeslcXOX4dUF0nrqP1+shYhebgq93rMPR yH3EsoXtAP1KCN8tWPdnlDnMY0Zpy32mfCL0hMMnH+CY5rARssSbiFP9HeWk/CN+ yES7FY705QmV/2SV4rEngqnIcrcqEJFp49JPihC1pSikHCItzSVFaODbUl4qhTjn Tjtl0pdFQc9ksA/6IEOH/bufDwtxCLwAjUpqyNGEH/8FnxtwotsTmhmTWMe9vxYe YStdTLkAvJFMVEU0W+H2ZZG481P5/8tqFS9cHEU++3VvuYxfipwjpIQhm5WJARwE EAEKAAYFAlMuEVwACgkQq+DDGd8KChpPGwf/QL66k12OzqI40KQL+UbzW25vxbmE OyZ1MT9SuUVt6Th9zdoNm9Cosi9kOiq+DPLFFT751Lmm1hcM0rDDNeN+l8wpLwX9 EifD/bQ7Q5esM8NJmGVyhA/Cd3wkp5yYNdZPOu9/0xpe/Px4YgficRErhgyVh2Vs svQRQ0WcTYbgbmQFpOUsjNVOchJMFERSJaQxWgN3olYd5DTDxPDLztt3vdBCIkz0 4OAotZqbqdnmvlkjKjzrJylfCkyo9bOU471v6Hs3mfUQXo9nXC9zGETFWsvB4WCC QdWEyj+2K+PcdZU0FEPonfTouVcsR9oTqQqqfg21M7HUHSmlrOyCLqNnZ4kCHAQQ AQIABgUCU2vk5AAKCRDuYMDI7nJWqGIzD/9vdI3uUUYGCaURAprGEo4kk6JP2TcS AmyO9Pr8bBdpmt/DVFK0zWllQ+69QAWLFoCmgjOgWUPRNWA+ldG5lzExjuuP38P1 4HupPMh0yOd+QUod4Gdi+hqPCuFT4/oErWZcOGGXAw4ZcvdEGKY9E975D+3yd7sG HGskvGB/UmLIBQ2XfQOoqk0A9eXz55wLN1ia1imHd/0NkPkQOHkjTdOtHhcBhuoc ttex9HcmYy2g5oorG+7wx0EtHxIhuCcRq1wQgXm2JtbiFHXiH0MpLfBr29kpzH7y 8jompGgAJsK8uRwTC8UFWHnx0VxnFQ+4vinqlgj7/O+WMZ/siDlOZDo2RC3ts+Ct 91kYNFHsycrkJYuoPzNcMy7mmixQFj5L2VIG1Ne3OTdEPVWE5jIQ/w5IX0aYxNt4 ANIZJA/r1AqDqDEhto6gdnkrVZSJN+Mvd7yj7XTbrErpTmQeNkGgb9ult4XaEOdm bjAjE6rTQqFD3Tn8SeXNgkJFr0Zb8lZypmOL6cxU4vTG66blJPLZGuaH3yCrtA1i ynZPrV2TYiET+fhg2TBEXbjLkWHQnA+7sFFOTgK5WOqc6vK29h5ssEQKIFodDh4a e88tiGLW9lSc+YWRpKHgEc8QDXIuBrV18hZEvbITvLZnnf5uIFXJV5ZCHG+o6I+Y jQrPY4oC2HGrMIkBIgQQAQoADAUCVRRYygWDB4YfgAAKCRCFZ1M6Yr7+XbxwB/42 Kbk6DpZueEK0qtdoLUh7H+dWfwA0Gsh/vCoS6RM9iXjKPBoQGlbCBpsBpqCJkGd/ iXH+tnkU2dq4BvGc/igSHadNYmYq077l1vu3pJjDjxfQ2qZSF9D27EUzlXLd4Q6s hysZ18HoTehxr3AG33N1tEm9kBUfZjeMZxk7zbty3Lo7tK/UYN+4mIgYqLc97XIe 40Z\niQIcBAEBCgAGBQJWT6iBAAoJEBO17ljAn7PgnxIP/RevbXaCm2Q3ildI0YLjQFDr vSIGKsCjD9nZY3ETk+CNFGOL4aYWp96HWuQoMq7B6qlb/sLejN/Ssu3M0sxf2hNK pCIagZClqRchSBK+0UpAEIs98sf0sPakqKg0FlOJhuCsKHMUOxpQJ4qCDh6f24b2 cqKR8GjyUAgSeiiyN+DkDyqRYingQGAU5vzKepYzX+DMHC/izqQhrwQLVImv20wr 5pKZJDjfOpYUZRTuScV5Qwcgc0JYcMOjfgA93ZUA2zDrGIpw3dcCSMrpNQcvM6Cg 1mfiLZzkvPH3UkUOWhHCn/N2XaAF58joCaS+/bVUaXx02IbxJ1TTjqtCiH9491mE aaHeRCFYbkKCXWjuxCx1+VZN2yRk24rSkis/+LFgZm850fXgYfrqiyPRDlCMApdo 5JDUBTioyZz24vhqWpe0OZueu11DXtpU1G0BiheGrweXAAx0Yki8dRiPTXkavAMj oMBND9G7a1564KOe+t6V2qUyH50+3NaANvIiDJZbspX7yl8eVzPbwcGvtHzmHdnV pDh+38XUQEID5YJ/mdZh6evzmmTnQR1HVqPVrzs8SwIDO++tqj8DXTjID47c3VIl YhCMNlucciFxVn/sYI5qiJzCEMLMbvG+EhnoLNU4JGjfzo6I0RCpPfbrDfOsWJNi zYMz9htqusCQsGwUZSTZ =XBC5 \u0026mdash;\u0026ndash;END PGP SIGNATURE\u0026mdash;\u0026ndash; str4d가 다음 릴리스에 서명했습니다: 0.9.23 릴리스 0.7.6부터 0.9.12까지는 zzz가 다음 키로 서명했습니다: -----BEGIN PGP PUBLIC KEY BLOCK----- Version: GnuPG v1.4.6 (GNU/Linux) mQGiBEOjTnURBADegKKrIP6pz4+n57dqo3l9QrKhIklCtIxgJkL06ZJq5fKAnMLv GPaGXmn5vRrbo6QzHs/lGLG+ySWFWr9SsVstNKrwk+F1yGIERutl0BqMwX1esfN2 ugiZ3wB1yRu0PIrkm5cuDAFASFE+2lBjr1lfOrhw/dV+lLTcWx4NzkMzlwCgxgIk 4cqQMGaVkmtuICQdYmmMicUD/AmNSVJEm2XUvaS5fYWsHJG3+oNkdNGcx5SOMUdk PFwcSozqvT9FeIP76OVHAshQKeftE3utOFANQ/YomXEnypmwMxLLR+GPw5pMbKlK 6p+87aJZz+SA95E3ekmh7MmndvRd5RJDboUZy2H0FKX+FgaBlpsLl0uhT6uDuM/s 7nb0A/9nEAgICOU5SeXtO3jKY+RQvKyE0AblK7xVaU+Sn8ly0zauOJD13rycVGhu vLcAUVR3FKEjxafpvZ0ZPBo7AACjSDqAoCw/s/vt9gmrhHKiqN31PhYYLhKdfKTs 4LzWKTWKIAOwErkbYsMAXWKFT3LXsrEYvxq5j5m/6zMOwz2N7rQYenp6ICh6enop IDx6enpAbWFpbC5pMnA+iF8EExECAB8FAkOjTnUCGwMGCwkIBwMCBBUCCAMDFgIB Ah4BAheAAAoJEEFVdrqnbgvtxGsAn39SvQ3+ey87WDDG+TWArN6oU8gnAJ4zeAsA LUK37WZIt8OImZSxk37uQbkCDQRDo06VEAgAy2UeqsM5a+U6ZOWS9NQiILb3KbTL FeeAd2rn9oLSLpn5gDWycwUS0Q62JmbSMWy6m9aczpnxvwaBYXz6aCIvZmTNtaU6 vyR/6wfJDyiUWSHtCyjpyFFYJimANd8Y8dDCimvceI/ihEDVyBX0kkgUGRAn8t3e unaLXqhbfiLiFw/GG1MNxUMzHt55/+9AqLOfRZg0riZvDoV79K+1sYSs8n1WeaVc T3wTb+Cb7fKNN7GT1MUhcXIoYYY6FGwsy5EWFsxYBRervqHtBJog2SoNUa/6BFGr zX+LDjK9L3xMTr3+fHIt4gPR/Lt4nnfEzL+rjClz/Fazmv38BRwPuKahFwADBQgA nD/AvZCnbWSB6khAVMqva5ROaD0gV0/UejCelZdYfgfHeCmrcMNQ+wCyww2NPsih 9vB1w+AUE0pdH37k65VZN+2falUdzN+PFugJGuH2pmlVOprH2SuC5gKpGRvzUqV5 U0nJmT2okDpW/52asUDJJLu1g//A3qBP83WGvSKUZg/ZisZA0qTiHH4QpjklopXi sSxR2hT8Fr9gF9WmDa09wbxE2xh/EL7gvVg/vk0gwOJcsFd67bNC+KUMOnjhOP0T K0/Ah4TEEs/hHNe9RsyyWlMoIUsF8AhG71ISOrJ5lLSXNe151XEb5FzZRM8sD9Zq 0E3PjmLbdVhanYvsPnWK6YhJBBgRAgAJBQJDo06VAhsMAAoJEEFVdrqnbgvtXTwA njMu9ueCFbsjme7nwsz96PdazJcHAKCce17hGI25QNXDZyHohrjha6IxDg== =fAfi \u0026mdash;\u0026ndash;END PGP PUBLIC KEY BLOCK\u0026mdash;\u0026ndash;\n릴리스 0.6.1.31부터 0.7.5까지는 Complication이 서명했습니다. 그의 공개 키는 다음과 같습니다: \u0026mdash;\u0026ndash;BEGIN PGP SIGNED MESSAGE\u0026mdash;\u0026ndash; Hash: SHA1\n안녕하세요,\n저는 아래가 2007-11-24에 발급되어 2009-11-23까지 유효한 제 새로운 공개 키이며, 키 지문(fingerprint)은 다음과 같음을 증명합니다:\n73CF 2862 87A7 E7D2 19FF DB66 FA1D FC6B 79FC CE33\n제 이전 공개 키를 가지고 계시고 이것을 확인하는 데 사용하신다면, 제 이전 키가 2007-11-15에 만료되었음을 알게 되실 것입니다. 업데이트가 늦어진 점 사과드립니다.\n이 메시지에서 키를 직접 복사하려는 분들 중 이메일 프로그램을 사용하지 않고 이 내용을 읽는 경우, 공개 키 블록의 시작 및 끝 마커에서 \u0026ldquo;- \u0026quot; 이스케이프 시퀀스를 삭제하는 것을 잊지 마세요. 그렇지 않으면 인식되지 않습니다.\n복잡성.\n\u0026mdash;\u0026ndash;BEGIN PGP PUBLIC KEY BLOCK\u0026mdash;\u0026ndash; Version: GnuPG v1.4.7 (GNU/Linux)\nmQGiBEdH5SYRBACzCum9jIjq+/G7ckuZ/TcFmaVYeBRE6OXPQozyrmTYtoCM2qGj DmvMJvKYiNiQVM42KiwlnqvaNtlgnXIZ6rcyLyn+bCI5cdX1SD5Rr5tgsgcXYA6Z l7usiFv1bTjD67piBehF130o+LZAJnVzI7JdpbA9SBY0mUwgKXLi0DAo8wCgiKOV UXC8+9X9vU1Mh/GyIrD4c3kD/iQOkYH4ajNaehTHNB31K+61ltpK9tMmcWtUY30A Z3q38jg/nmqqup/MYCtkvOqY4X9kujKzu01eSWSNZIE+BQSSd1cSsVD17OY3TL6B EvE+UFxh8OnDKs3tzJ0COnT/2zbgTavbWwqovoUE0P0PSYOFm2Co0BEQiCt9Tabc CxU3BACRWDvq7LFMRnHT+/OOJS6M442CYzy3+tIuc3ZAmZ8QwGsh4r1kd+5P1JTN YJCun6MPQEllJbRyHRBby76vFkWearRgnkpAmk2l1T2SXw3lip/SdmI0GgIzPSfQ 8WyNbMjQXyH8/3k2Y9rgrC0DttrJPYOcTFMNKPpeTR+HN3ZnibQ+Q29tcGxpY2F0 aW9uIChodHRwOi8vY29tcGxpY2F0aW9uLmkycCkgPGNvbXBsaWNhdGlvbkBtYWls LmkycD6IZQQTEQIAJQUCR0flJgIbAwUJA8JnAAYLCQgHAwIEFQIIAwMWAgECHgEC F4AACgkQ+h38a3n8zjP1yACfWkF1zjmlD0EzLaJRnefW5OHr10MAn0fgMyElK6ee AoPl2mTfxQQYOophuQQNBEdH5SYQEACTcoMJQBhyrr+EunLmEGNMO7D6RSBAtEKZ i5ctmhr/TCXMV9qjXkWISLZ9AS6z88rKozeOOK+QPBnc2FcEf77N04O5hwSdAyPH Qt7+umhiNQFQpZycJ5W87Y0ryERJygA5XyU47g7CGvuuOLgKGk0dDGCNFZGSblwI xtSh1CsrjWp23grFiBS0xvlU2VyuYUyrBuH5ip04pxmOyeRcaelkQerFhEXSRIR7 XFxl6JpfqWt2oWHmYbYD3RT6WHU+rpSF1Hyey+zoF2zXfRb+JD90MpBL1xIkpieQ Y69Cj5U5VRjEppJJowSmwgz+UyMnT2KLl45vJesPrMUaSgduHiIQo4LM5BcbbV+2 SC5i9xqbSJ+rc19Ftt9IEUZVMLole9PJC5Ff/h1qsabyueFuMIQkbiaUiNLOKl31 I+JAiDt0Xku2PEVCERg7Jq5AsTLB9D+zKqxbvFu+JvqSdlaCvlas2BYU5rBosszH TStK2XW/+poTKnjnbJl6nGC06BNQPhRFAwuXboyUC5fyiuG1HohvPmPIi6IejLUY G8A5nZ+7um/XpKlt2i5rdVRfN1BX3+aKHQeLmrc+EIORZUU32TrP4ceLtSDf+JOW 8N3vwzqKIPu42Y5KB8vnXEFSOkyt36OfEd6CcPKmncDyA4wJmfC+X3eoKcj+Yrh7 UMr0elyw4wADBg/9F7g+bTpT4wPXj5ax1i+4BdedjVlO3YBdhc4LP6MXipNU6yLl l63TJ8q/l8pvSkUWZXrO3a7OibM/MHp0Te/7sTmKib2/3MFwHTrtjgcZBF6wx8LD T3oa6O0IK8IRnRwNqeu83SxojvVY0wLz/hpUbnIrOcHMZjWLMJEfHkNBHn+1HhT5 tk9LRGu3j1oTpGh+DpdoPF5fggNu48YJ6n7etJJGW2MXQ++33aKeQSFrx+KlMtFW DSzg3KKSroB8Ex9wiKKWybagaed0YoP9BW3vIAaOeDpqK92UuTFz1Bte1DYiYU1e Rqq1xoBVhJXE5xzGmvS4/PIZMOL/bpKcuNxAgmwOVoaYoWZuIgePUaBbNvNg84HE RBjFMyfpzRCdPlWPZ18KcLUki3T58KzXEZ7WS5hC5lezwC6ET+wJusAt0A+Ik146 igayKfVnvhedQdqufWhQWNr+hDc5Fb/az8nTyNOflAhD3yHldjxgkCOV8wjqyS+4 iO33P5wW7o2QkZNWq8pyjsKRRJCtZ/PJ7FRGkUOjoC/gwhnGvBi0KoDcyBmfnPXp 3MAgrzk9LwiA7PlS7PyhyMx5mYpa90xlXzszweCIXzGfbm6ciCUAM3G3Qb+qa2dW 0u1X5L6bVtHVpYnr+5JOxCS4qwQvoK0QnHu6ezu4+rFutUJN35z6rFquejiITwQY EQIADwUCR0flJgIbDAUJA8JnAAAKCRD6HfxrefzOMzSZAJ9PmYNkW4Ia1qPqowg9 z4Ja+hJ3dgCeL3mqvOEHG7AcUQrSlc6xlC1vbNY= =rGxK - \u0026mdash;\u0026ndash;END PGP PUBLIC KEY BLOCK\u0026mdash;\u0026ndash; \u0026mdash;\u0026ndash;BEGIN PGP SIGNATURE\u0026mdash;\u0026ndash; Version: GnuPG v1.4.7 (GNU/Linux)\niD8DBQFHR/zm4tLxqYRsGn0RAtCfAJ9rz+tsyEbeUAHcogdzgSPfuiWOAwCfWaVn Aiib6V5wOPbYTy13ADmxhfE= =mPFq \u0026mdash;\u0026ndash;END PGP SIGNATURE\u0026mdash;\u0026ndash; ","description":"I2P 릴리스 서명에 사용되는 PGP 키와 획득 방법","id":"ae494d28c5c0216d277398ccdcc21df5","section":"docs","title":"릴리스 서명 키","url":"/ko/docs/develop/release-signing-key/"},{"categories":null,"content":"I2P 주소는 긴 암호화 키입니다. 네이밍 시스템은 중앙 권한을 도입하지 않으면서 이러한 키 위에 더 친근한 계층을 제공합니다. 모든 이름은 로컬입니다—각 router는 호스트명이 어떤 목적지를 가리키는지 독립적으로 결정합니다.\n배경 정보가 필요하신가요? naming discussion 문서는 I2P의 탈중앙화 명명 체계에 대한 초기 설계 논의, 대안 제안 및 철학적 기반을 다룹니다.\n1. 구성 요소 I2P의 네이밍 계층은 독립적이지만 협력하는 여러 하위 시스템으로 구성되어 있습니다:\n명명 서비스 – 호스트명을 destination으로 해석하고 Base32 호스트명 을 처리합니다. HTTP 프록시 – .i2p 조회를 router에 전달하고 이름을 알 수 없을 때 점프 서비스를 제안합니다. 호스트 추가 서비스 – 로컬 주소록에 새 항목을 추가하는 CGI 스타일 폼입니다. 점프 서비스 – 제공된 호스트명에 대한 destination을 반환하는 원격 도우미입니다. 주소록 – 로컬에서 신뢰하는 \u0026ldquo;신뢰 네트워크\u0026quot;를 사용하여 원격 호스트 목록을 주기적으로 가져와 병합합니다. SusiDNS – 주소록, 구독 및 로컬 재정의를 관리하기 위한 웹 기반 UI입니다. 이 모듈식 설계를 통해 사용자는 자신의 신뢰 경계를 정의하고 원하는 만큼 명명 프로세스를 자동화할 수 있습니다.\n2. 네이밍 서비스 router의 naming API(net.i2p.client.naming)는 구성 가능한 속성 i2p.naming.impl=\u0026lt;class\u0026gt;를 통해 여러 백엔드를 지원합니다. 각 구현은 서로 다른 조회 전략을 제공할 수 있지만, 모두 동일한 신뢰 및 해석 모델을 공유합니다.\n2.1 Hosts.txt (legacy format) 레거시 모델은 순서대로 확인되는 세 개의 일반 텍스트 파일을 사용했습니다:\nprivatehosts.txt userhosts.txt hosts.txt 각 줄은 hostname=base64-destination 매핑을 저장합니다. 이 간단한 텍스트 형식은 가져오기/내보내기에 여전히 완전히 지원되지만, 호스트 목록이 수천 개의 항목을 초과하면 성능이 저하되기 때문에 더 이상 기본값이 아닙니다.\n2.2 Blockfile Naming Service (default backend) 릴리스 0.8.8에서 도입된 Blockfile Naming Service는 현재 기본 백엔드입니다. 이는 평면 파일을 고성능 skiplist 기반 온디스크 키/값 저장소(hostsdb.blockfile)로 대체하여 약 10배 빠른 조회 성능을 제공합니다.\n주요 특징: - 하나의 바이너리 데이터베이스에 여러 논리적 주소록(private, user, hosts)을 저장합니다. - 레거시 hosts.txt 가져오기/내보내기와의 호환성을 유지합니다. - 역방향 조회, 메타데이터(추가 날짜, 소스, 주석) 및 효율적인 캐싱을 지원합니다. - 동일한 3단계 검색 순서를 사용합니다: private → user → hosts.\n이 접근 방식은 하위 호환성을 유지하면서 조회 속도와 확장성을 크게 향상시킵니다.\n2.1 Hosts.txt (레거시 형식) 개발자는 다음과 같은 커스텀 백엔드를 구현할 수 있습니다: - Meta – 여러 네이밍 시스템을 통합합니다. - PetName – petnames.txt에 저장된 petname을 지원합니다. - AddressDB, Exec, Eepget, Dummy – 외부 또는 대체 해결을 위한 백엔드입니다.\nblockfile 구현은 성능과 안정성으로 인해 일반적인 사용에 있어 권장되는 백엔드로 남아 있습니다.\n3. Base32 Hostnames Base32 호스트명(*.b32.i2p)은 Tor의 .onion 주소와 유사하게 작동합니다. .b32.i2p 주소에 접속하면:\nrouter가 Base32 페이로드를 디코딩합니다. 키에서 직접 목적지를 재구성합니다—주소록 조회가 필요하지 않습니다. 이것은 사람이 읽을 수 있는 호스트 이름이 존재하지 않더라도 연결 가능성을 보장합니다. 릴리스 0.9.40에서 도입된 확장 Base32 이름은 LeaseSet2와 암호화된 목적지를 지원합니다.\n4. Address Book \u0026amp; Subscriptions 주소록 애플리케이션은 HTTP를 통해 원격 호스트 목록을 가져오고, 사용자가 설정한 신뢰 규칙에 따라 로컬에서 병합합니다.\n2.2 Blockfile Naming Service (기본 백엔드) 구독은 hosts.txt 또는 증분 업데이트 피드를 가리키는 표준 .i2p URL입니다. 업데이트는 주기적으로(기본적으로 매시간) 가져와지며 병합 전에 검증됩니다. 충돌은 선착순으로 해결되며, 다음 우선순위 순서를 따릅니다:\nprivatehosts.txt → userhosts.txt → hosts.txt. Default Providers I2P 2.3.0 (2023년 6월) 이후로 두 개의 기본 구독 제공자가 포함됩니다: - http://i2p-projekt.i2p/hosts.txt - http://notbob.i2p/hosts.txt\n이러한 중복성은 로컬 신뢰 모델을 유지하면서 신뢰성을 향상시킵니다. 사용자는 SusiDNS를 통해 구독을 추가하거나 제거할 수 있습니다.\nIncremental Updates 증분 업데이트는 newhosts.txt를 통해 가져옵니다(이전의 recenthosts.cgi 개념을 대체). 이 엔드포인트는 효율적인 ETag 기반 델타 업데이트를 제공하며, 마지막 요청 이후의 새로운 항목만 반환하거나 변경사항이 없을 경우 304 Not Modified를 반환합니다.\n2.3 대체 백엔드 및 플러그인 Host-add 서비스 (add*.cgi)는 이름-대상 매핑의 수동 제출을 허용합니다. 대상을 수락하기 전에 항상 확인하세요. Jump 서비스는 적절한 키로 응답하며 ?i2paddresshelper= 매개변수를 사용하여 HTTP 프록시를 통해 리디렉션할 수 있습니다. 일반적인 예시: stats.i2p, identiguy.i2p, notbob.i2p. 이러한 서비스는 신뢰할 수 있는 권한 기관이 아닙니다—사용자가 어떤 서비스를 사용할지 결정해야 합니다. 5. Managing Entries Locally (SusiDNS) SusiDNS는 다음 주소에서 이용 가능합니다: http://127.0.0.1:7657/susidns/\n다음을 수행할 수 있습니다: - 로컬 주소록 보기 및 편집. - 구독 관리 및 우선순위 설정. - 호스트 목록 가져오기/내보내기. - 가져오기 일정 구성.\nI2P 2.8.1의 새로운 기능 (2025년 3월): - \u0026ldquo;최신순 정렬\u0026rdquo; 기능 추가. - 구독 처리 개선 (ETag 불일치 수정).\n모든 변경 사항은 로컬에 유지됩니다—각 router의 주소록은 고유합니다.\n3. Base32 호스트네임 RFC 9476에 따라, I2P는 2025년 3월 (I2P 2.8.1) 기준으로 GNUnet Assigned Numbers Authority (GANA)에 **.i2p.alt**를 등록했습니다.\n목적: 잘못 구성된 소프트웨어로부터 우발적인 DNS 유출 방지.\nRFC 9476을 준수하는 DNS 리졸버는 .alt 도메인을 공개 DNS로 전달하지 않습니다. I2P 소프트웨어는 .i2p.alt를 .i2p와 동등하게 취급하며, 해석 과정에서 .alt 접미사를 제거합니다. .i2p.alt는 .i2p를 대체하기 위한 것이 아니며, 이는 리브랜딩이 아닌 기술적 안전장치입니다. 4. 주소록 및 구독 Destination 키: 516–616 바이트 (Base64) 호스트네임: 최대 67자 (.i2p 포함) 허용 문자: a–z, 0–9, -, . (연속된 점 불가, 대문자 불가) 예약됨: *.b32.i2p ETag 및 Last-Modified: 대역폭 최소화를 위해 적극 활용됨 평균 hosts.txt 크기: 약 800개 호스트 기준 ~400 KB (예시 수치) 대역폭 사용량: 12시간마다 가져올 경우 ~10 바이트/초 8. Security Model and Philosophy I2P는 탈중앙화와 보안을 위해 의도적으로 전역 고유성을 희생합니다—이는 **주코의 삼각형(Zooko\u0026rsquo;s Triangle)**을 직접 적용한 것입니다.\n핵심 원칙: - 중앙 권한 없음: 모든 조회는 로컬에서 수행됩니다. - DNS 하이재킹 저항: 쿼리는 목적지 공개 키로 암호화됩니다. - 시빌 공격 방지: 투표 또는 합의 기반 네이밍을 사용하지 않습니다. - 불변 매핑: 로컬 연결이 생성되면 원격으로 재정의할 수 없습니다.\n블록체인 기반 명명 시스템(예: Namecoin, ENS)은 Zooko의 삼각형 세 가지 측면을 모두 해결하는 것을 탐구했지만, I2P는 지연 시간, 복잡성, 그리고 로컬 신뢰 모델과의 철학적 비호환성 때문에 의도적으로 이를 피합니다.\n9. Compatibility and Stability 2023년부터 2025년 사이에 사용 중단된 네이밍 기능은 없습니다. Hosts.txt 형식, jump 서비스, 구독(subscriptions), 그리고 모든 네이밍 API 구현은 계속 작동합니다. I2P 프로젝트는 성능 및 보안 개선 사항(NetDB 격리, Sub-DB 분리 등)을 도입하면서도 엄격한 하위 호환성을 유지합니다. 10. Best Practices 신뢰할 수 있는 구독만 유지하고, 대규모의 출처가 불분명한 호스트 목록은 피하세요. 업그레이드하거나 재설치하기 전에 hostsdb.blockfile과 privatehosts.txt를 백업하세요. jump 서비스를 정기적으로 검토하고 더 이상 신뢰하지 않는 서비스는 비활성화하세요. 기억하세요: 주소록은 당신만의 I2P 세계를 정의합니다—모든 호스트명은 로컬입니다. Further Reading 네이밍 논의 Blockfile 사양 구성 파일 형식 네이밍 서비스 Javadoc ","description":"I2P가 사람이 읽을 수 있는 호스트명을 목적지로 매핑하는 방법","id":"fc2ecb5df890709d0740d866d03a6250","section":"docs","title":"명명 및 주소록","url":"/ko/docs/overview/naming/"},{"categories":null,"content":" 배경: 이 페이지는 초기 I2P 설계 시기에 장기간 이어진 논쟁들을 아카이브합니다. 프로젝트가 DNS 방식 조회나 다수결 기반의 레지스트리보다 로컬에서 신뢰하는 주소록을 선호한 이유를 담고 있습니다. 현재 사용 지침은 Naming documentation 을 참고하세요.\n폐기된 대안 I2P의 보안 목표는 익숙한 명명 체계를 배제한다:\nDNS 스타일 이름 해석. 조회 경로상의 어떤 리졸버든 응답을 위조하거나 검열할 수 있다. DNSSEC이 있어도, 침해된 등록기관이나 인증 기관(CA)은 여전히 단일 장애 지점으로 남는다. I2P에서는 목적지는 그 자체가 공개 키이므로—조회를 가로채면 그 신원이 완전히 손상된다. 투표 기반 이름 지정. 공격자는 무한정 신원을 만들어낼 수 있어(Sybil 공격(시빌 공격)) 인기 있는 이름에 대한 투표에서 “승리”할 수 있다. 작업증명 완화책은 비용을 높이지만, 무거운 조정 오버헤드를 초래한다. 그 대신, I2P는 의도적으로 네이밍을 전송 계층 위에 둔다. 번들된 네이밍 라이브러리는 대체 스킴들이 공존할 수 있도록 service-provider interface(서비스 제공자 인터페이스, SPI)를 제공하며—어떤 주소록이나 점프 서비스를 신뢰할지는 사용자가 결정한다.\n로컬 대 글로벌 이름 (jrandom, 2005) I2P의 이름은 로컬에서 고유하지만 사람이 읽을 수 있습니다. 당신의 boss.i2p가 다른 사람의 boss.i2p와 일치하지 않을 수 있으며, 그것은 설계상 의도된 것입니다. 악의적인 행위자가 이름 뒤에 있는 destination(목적지)을 바꾸도록 당신을 속인다면, 그들은 사실상 서비스를 가로채게 됩니다. 전역 고유성을 사용하지 않음으로써 그러한 유형의 공격을 예방합니다. 이름은 즐겨찾기나 IM 닉네임처럼 다루세요—특정 주소록을 구독하거나 키를 수동으로 추가하여 신뢰할 destinations를 직접 선택합니다. 흔한 반론과 답변 (zzz) Concern Response “Downloading hosts.txt is inefficient.” At ~400\u0026nbsp;KB for ~800 hosts the bandwidth impact is minor (~10\u0026nbsp;B/s if refreshed twice daily). ETags already avoid unnecessary transfers. Alternate formats (for example recenthosts.cgi) can deliver only new entries. “It won’t scale.” A hosts.txt entry is ~500\u0026nbsp;bytes; storing thousands locally is practical. Real-time lookups would dramatically slow browsing. “Requires trust and manual setup.” True—and intentional. Users must choose address book providers they trust. Trust is not binary; forcing configuration encourages users to think about it. “Why not just use DNS?” DNS depends on short TTLs and can be hijacked mid-path. I2P destinations are immutable public keys, so DNS semantics map poorly. “Subscriptions rely on specific servers.” Subscriptions are decentralised—you can add multiple providers or run your own. Completely decentralised systems struggle with conflict resolution and hijacking. “Jump services and hosts.txt feel awkward.” They are pragmatic trade-offs. Jump services provide just-in-time lookups; subscriptions keep a local cache for performance. ## 효율 향상 아이디어 논의 증분 업데이트를 제공(마지막 가져오기 이후 추가된 destinations(서비스 주소 식별자)만). 전체 hosts 파일과 함께 보조 피드(recenthosts.cgi)를 제공. 피드를 병합하거나 신뢰 수준으로 필터링하기 위한 스크립트로 자동화 가능한 도구(예: i2host.i2p)를 검토. 핵심 요점 보안이 전역 합의보다 우선합니다: 로컬에서 관리되는 주소록은 하이재킹 위험을 최소화합니다. naming API를 통해 여러 이름 지정 방식이 공존할 수 있으며—무엇을 신뢰할지는 사용자가 결정합니다. 완전히 탈중앙화된 전역 이름 체계는 여전히 미해결 연구 과제로 남아 있습니다; 보안, 인간 기억 용이성, 전역적 고유성 간의 절충은 여전히 Zooko’s triangle (이름 체계에서 보안, 인간 기억 용이성, 전역적 고유성의 상충 관계를 설명하는 개념)을 반영합니다. 참고 자료 네이밍 문서 Zooko의 “이름: 탈중앙화, 보안성, 사람에게 의미 있는 것: 둘만 고르라” 증분 피드 샘플: stats.i2p/cgi-bin/newhosts.txt ","description":"I2P의 네이밍 모델을 둘러싼 역사적 논쟁과 전역 DNS 방식의 체계를 거부한 이유","id":"952b10ba82200ff92e5ddeed512d6afb","section":"docs","title":"명명에 대한 논의","url":"/ko/docs/legacy/naming/"},{"categories":null,"content":" 사용 중단됨: ministreaming 라이브러리(과거의 경량 스트리밍 라이브러리)는 오늘날의 스트리밍 라이브러리 보다 먼저 만들어졌습니다. 최신 애플리케이션은 정식 스트리밍 API 또는 SAM v3를 사용해야 합니다. 아래 정보는 ministreaming.jar에 포함되어 배포되던 레거시 소스 코드를 검토하는 개발자들을 위해 보존되어 있습니다.\n개요 Ministreaming(경량 스트리밍 계층)은 I2CP 위에서 동작하여 I2P의 메시지 계층 전반에 걸쳐 신뢰할 수 있으면서 순서가 보장되는 전달을 제공하며—IP 위의 TCP와 마찬가지입니다. 대체 전송 프로토콜들이 독립적으로 발전할 수 있도록, 이는 초기 I2PTunnel 애플리케이션(BSD 라이선스)에서 원래 분리되었습니다.\n핵심 설계 제약 조건:\nTCP에서 차용한 고전적인 2단계(SYN/ACK/FIN) 연결 설정 1 패킷의 고정 윈도우 크기 패킷별 ID나 선택적 확인 응답이 없음 이러한 선택은 구현을 단순하게 유지하는 데는 도움이 되었지만 처리량을 제한한다—보통 다음 패킷을 보내기까지 거의 두 RTT(왕복 지연 시간)가 걸린다. 장기간 지속되는 스트림에는 이러한 비용이 감내할 만하지만, HTTP 스타일의 짧은 요청-응답 교환에서는 뚜렷한 성능 저하가 나타난다.\nStreaming Library와의 관계 현재 스트리밍 라이브러리는 동일한 Java 패키지(net.i2p.client.streaming)를 그대로 사용합니다. 사용 중단(deprecated)된 클래스와 메서드는 Javadoc 문서에 남아 있으며, 개발자가 ministreaming(이전 경량 스트리밍 구현) 시대의 API를 식별할 수 있도록 명확히 주석으로 표시되어 있습니다. 스트리밍 라이브러리가 ministreaming을 대체했을 때 다음이 추가되었습니다:\n왕복 횟수를 줄인 더 스마트한 연결 설정 적응형 혼잡 윈도우와 재전송 로직 패킷 손실이 발생하는 tunnels에서 더 나은 성능 Ministreaming(경량 스트리밍 라이브러리)은 언제 유용했나요? 제한점에도 불구하고, ministreaming(경량 스트리밍 계층)은 초기 배포에서 신뢰할 수 있는 전송을 제공했다. API는 의도적으로 작고 미래 호환성을 갖추도록 설계되어, 호출자에 영향을 주지 않고 대체 스트리밍 엔진으로 교체할 수 있었다. Java 애플리케이션은 이를 직접 연동했고, Java가 아닌 클라이언트는 스트리밍 세션에 대한 SAM 지원을 통해 동일한 기능에 접근했다.\n현재는 ministreaming.jar를 호환성 레이어로만 취급하십시오. 새로운 개발은 다음을 수행해야 합니다:\n전체 스트리밍 라이브러리(Java) 또는 SAM v3(STREAM 스타일)을 대상으로 하십시오 코드를 현대화할 때 남아 있는 fixed-window(고정 윈도우) 가정을 모두 제거하십시오 지연 시간에 민감한 워크로드의 성능을 향상시키기 위해 더 높은 윈도우 크기와 최적화된 연결 핸드셰이크를 우선 적용하십시오 참고 스트리밍 라이브러리 문서 스트리밍 Javadoc – 사용 중단된 ministreaming 클래스 포함 SAM v3 명세 – 비-Java 애플리케이션을 위한 스트리밍 지원 여전히 ministreaming(레거시 스트리밍 API)에 의존하는 코드를 발견하면, 최신 스트리밍 API로 포팅할 계획을 세우십시오—네트워크와 그 도구들은 최신 동작을 전제로 합니다.\n","description":"I2P의 최초 TCP 유사 전송 계층에 대한 역사적 기록","id":"3a258127f502d1974fadc514a60bf831","section":"docs","title":"미니스트리밍 라이브러리","url":"/ko/docs/legacy/ministreaming/"},{"categories":null,"content":"보안 연락처 보안 취약점이나 민감한 보안 문제를 보고하려면 I2P Security Team(security@i2p.net )으로 연락해 주세요.\n안전한 통신을 위해 아래 PGP 키를 사용해 주세요.\nPGP 키 정보 Email: security@i2p.net Key ID: 176E1941 Fingerprint: 40DF FE20 7D79 9BEC 3AE8 7DEA 5F98 BE91 176E 1941 Key Type: RSA 4096-bit 생성일: 2025-10-19 만료일: 2030-11-19 UID: I2P Security \u0026lt;security@i2p.net\u0026gt; 공개 키 다음은 I2P Security Team의 GPG 공개 키입니다: \u0026mdash;\u0026ndash;BEGIN PGP PUBLIC KEY BLOCK\u0026mdash;\u0026ndash;\nmQINBGj1TtUBEADKsCC54egdJgxMs4HWcsYlr4GbrevM5gjZ+QZYEDGjaz44duOc E9W+a/NNA8PsryCql893odYdqGrFX+WTUT3UuN7DbbS7qSDs7jWZzjj0lr4/pbzJ B28lC0aIx6SQTEbzsGr2hOlFq/+JD9x/fMFrHFX81cJdIz9yabcH1vg9wPuhwkUS 5v2GFtvODCmSxQEJHSWvL2PkGiYEEZMKVXF5msdqJZK5/Dwp3UgVNeAkUYEHU6px Vu/YUpGo07/LNW5FfGDGf0pWYQ/9Tu5ykno3q3EA7TwWoVwbDK0hh9mpbZYiWSoy PSbIWNpwVMwGri4+KFjCEyG8DLzDlM4UMrK3PnrPh4M4+4a+flR+CMNeM1lyioC3 +jJf3TEOjvUsMzbwoDEE6O0wxBtfFC0xzzDDCAVrPvEZ3lt0do3kVHLbYS6ZXHkX ZwZWNBDWr2mSG9GU4oWizPIlq7MIhRYKA+ADqNxznxm9rtdfidk1tcLdyNUDjOwC jk/vQ8PCORbUYfytMhHzlRk7zieK6wBwr3aFFVgE8HxhgIZkAaUEbeej+dNADo6Z IFY+OF8mjpErcfJscCNgPSDbNid87dA78qRrqL6HLU2sek9g72EFpx2OVV7drkEp +Zy9kuiML4wWfOpC+kQa1Ka66E520U8Hs++cpf1LUOUmn1ajQDSfGoJMMwARAQAB tB9JMlAgU2VjdXJpdHkgPHNlY3VyaXR5QGkycC5uZXQ+iQJXBBMBCABBFiEEQN/+ IH15m+w66H3qX5i+kRduGUEFAmj1TtUCGwMFCQmQP4EFCwkIBwICIgIGFQoJCAsC BBYCAwECHgMCF4AACgkQX5i+kRduGUEEJhAAuZECNIWnC2UbrW/AXF8nPvFjpvLe kK7VQmMgno6iHRB1HAMh5hk3ZOYSRcjghcOHRpMFT64Uuc5vc9eBoegi5TDxYDkF Y9/ciEG5j2TXk93R/rY14UiH/kjFIhBAmc2t6Fs9R1m1vHHJtgY+KLqRF9fh2hc9 43odXnCrn5nhONtW+nb086eJEnJ4vsG/yR4EGzbu+fbrMJlycA/gZS63Q0rIcEJ2 VbZPCEXAf8LmebwxPxlboEuhXJSjCt1gWZwoKZlELaWdHliL3fUrMd3ojM5y66q3 ClO+7nWuwzKxKtZGKzxvF78o0O+HR4BbC16oQGpkT0yAij7ps/3KD2FJVQ/GQLef mpNQABfdVCPgcDS1p9/hjUoVHlRSC4gyehKX/C+H8Qvem92tzmJZy8PvcXaCsK/u wRxRwkoGhv0H5rsMOxfnB06dvT1Mo+KHED5j4y8C5DOnNpzHqwxJh1nQlJvLUvh8 LWIxiiE4+CeQ5V5YH7KfJmGq5ho93GgFmOXJvAuoFCoOLwXbQt9rMpq8iXM1RHRG E1AbB+KA3zcvAdzbgPtXlrOMkIfYO9xCyc8M0sfHB8b4RgrUs2tFz1fw3g4yE7ax 5ljquRefDmqBjtvu15FcZ4CA+I8FyVnrEb9jDTXyW7DiyM2kB7ZFeLpYytShbPq3 oJQMJYaGMoxDk025Ag0EaPVO1QEQAOuZtLOlab2EnuR5St05MXBpwtQUSWJzRckf w3NpnOl55+BavqsPl63rZYiO2lH9rAkZvfcL7auddQZSjDdsuPbUpsrQgsi2P9ig a3QiJOwSZzJ1qNb4VZSXrq2AqkBhCdw9rjpXGFfPNlClgVRbWpsGaQ5KtflnOA+I RfymidNXH0mDROBQuRh+2lkEYfANshjFjIqbI05tDic0KOab46R5MRVF7cihaMWp qPdxeYmvFWZ9lAnx5lMGwDdnGgfWFkU57lAd3NuHUnYIr/ExB/YgMdDeie5lQHKu svbcws9tIucUME9n8lGY77+1HlmNOCU4V12i4ZURJ4TwjHpScMOovkumtO4nXGRq GS8j1zeG7V9+yvdkSrclHJC33Mu6SPFC5SJBqU1G39/VpTD6CZPSPowZ0RlH2AVh D77Snrn53R3gziv5uxq+LpSJoafAx5tgIrg7HB+iJYRB1YVwIIHoT4YrBF01YyH6 cclkf3TNBjKgmtsynVw/TGy56nvR5lmt2uMq0Wwl4ZEwYPp+8ZmFuLbEHsI9RSdD iAdHoK9pEsTSxvzpcDTcG0CLZ4By/4oIKra6KuLr7XcB5eBmgXxrFBw4kveNWGW0 iEdg0xUVp8dxNjdZucB8m9qXQUUSmUxVjFYu4ee8tpo8iEVzu4wm4kOiOBKlwCn2 nOI72oGxABEBAAGJAjwEGAEIACYWIQRA3/4gfXmb7DrofepfmL6RF24ZQQUCaPVO 1QIbDAUJCZA/gQAKCRBfmL6RF24ZQShLD/9BlA+nLmJvwL3FYXm8JOqN07gPKlyQ +gWdV8p22Gawoq6dJLJanWURjn5Kfy30x2CSX6QwiaQG5aHHudNBF2h4Z/qEMcO5 ml5Dq7BP9R5VKmG4vwrL5ccNwuey1/d9Rtjt1zsd+52+x6dfjFv95o9j8jviIEoS HhhbO9ujmx3QLRNlg0SkG6ZlTALGp3EcKNdrV1vpF6ccgt3pdWYFB62N7q8zObHf bfOFMITJIXJJVKICCxzw3xOW2fMashjqf4Ic2UTFsAG3Hqqf5ASGbu4TyjFS3VXV JSzvdhGnxb7qJUzBImK9mGPRXYSV5d4g7kCFfgUg6KSFxbfYreEjCZXWJyqCr/VB eLpIhUWce/AiDPD8lGVD6sNevsNw4HhO6IyQu0pqbRAo+fJZNi+wcqOUqYlMczNw tUKw73QmFj0IqvyBr8Rfq9JC9O6ipyzalwK8uO0gmqOiK79zfnNIJaZ1+LM3Gh6n 3yluwq1df40lEU171i70IbSON6ekGNLTrvhTlDg6vHCMRfQR2UjA5FYBAtFXqQNG c4IYbu2UQm/191P77oI0vBEh3YnrD9eXtdYxgyT+Lj8RBJ+aM+IykK7c2mgOmlqb vYv+KkVFCpOyXrvSwId+3jHiGP6jis7vuzTwiG0S9EyOjxf9XIDowULuY28ntBB0 hOLK7ID/AeaOxA== =39fn \u0026mdash;\u0026ndash;END PGP PUBLIC KEY BLOCK\u0026mdash;\u0026ndash; ","description":"I2P 보안팀에 연락하기 위한 GPG 공개 키","id":"c65864821d13039a727e933e7e6e2891","section":"docs","title":"보안 GPG 키","url":"/ko/docs/develop/security-key/"},{"categories":null,"content":"I2P의 플러그인 프레임워크를 사용하면 핵심 설치를 건드리지 않고도 router를 확장할 수 있습니다. 사용 가능한 플러그인은 메일, 블로그, IRC, 스토리지, 위키, 모니터링 도구 등을 포함합니다.\n보안 참고사항: 플러그인은 라우터와 동일한 권한으로 실행됩니다. 서드파티 다운로드는 서명된 소프트웨어 업데이트를 다루는 것과 동일하게 취급하세요—설치하기 전에 출처를 확인하십시오.\n1. 플러그인 설치 프로젝트 페이지에서 플러그인의 다운로드 URL을 복사합니다.\nrouter console의 Plugin Configuration 페이지 를 엽니다.\nURL을 설치 필드에 붙여넣고 Install Plugin을 클릭합니다.\n라우터는 서명된 아카이브를 가져와서 서명을 검증하고 플러그인을 즉시 활성화합니다. 대부분의 플러그인은 router 재시작 없이 콘솔 링크나 백그라운드 서비스를 추가합니다.\n2. 플러그인이 중요한 이유 최종 사용자를 위한 원클릭 배포—wrapper.config나 clients.config를 수동으로 편집할 필요 없음 대용량 또는 특수 기능을 필요에 따라 제공하면서 핵심 i2pupdate.su3 번들을 작게 유지 필요시 프로세스 격리를 제공하는 플러그인별 선택적 JVM router 버전, Java 런타임, Jetty에 대한 자동 호환성 검사 router와 동일한 업데이트 메커니즘: 서명된 패키지 및 증분 다운로드 Console 통합, 언어팩, UI 테마, 비Java 앱(스크립트를 통한) 모두 지원 plugins.i2p와 같은 큐레이션된 \u0026ldquo;앱 스토어\u0026rdquo; 디렉토리 지원 3. 설치된 플러그인 관리 I2P Router Plugin 의 컨트롤을 사용하여:\n단일 플러그인의 업데이트 확인 모든 플러그인을 한 번에 확인 (라우터 업그레이드 후 자동으로 실행됨) 클릭 한 번으로 사용 가능한 모든 업데이트 설치\n서비스를 등록하는 플러그인의 자동 시작 활성화/비활성화 플러그인 완전히 제거 4. 자신만의 플러그인 만들기 패키징, 서명 및 메타데이터 요구사항은 플러그인 명세 를 참고하세요. makeplugin.sh 를 사용하여 기존 바이너리나 웹앱을 설치 가능한 아카이브로 패키징하세요. router가 최초 설치와 증분 업그레이드를 구분할 수 있도록 설치 URL과 업데이트 URL을 모두 게시하세요. 사용자가 진위를 확인할 수 있도록 프로젝트 페이지에 체크섬과 서명 키를 눈에 띄게 제공하세요. 예제를 찾고 계신가요? plugins.i2p에서 커뮤니티 플러그인 소스를 둘러보세요 (예를 들어, snowman 샘플).\n5. 알려진 제한사항 일반 JAR 파일을 제공하는 플러그인을 업데이트하면 Java 클래스 로더가 클래스를 캐시하기 때문에 router 재시작이 필요할 수 있습니다. 플러그인에 활성 프로세스가 없어도 콘솔에 Stop 버튼이 표시될 수 있습니다. 별도의 JVM에서 실행되는 플러그인은 현재 작업 디렉토리에 logs/ 디렉토리를 생성합니다. 서명자 키가 처음 나타나면 자동으로 신뢰됩니다. 중앙 서명 기관은 없습니다. Windows에서는 플러그인 제거 후 빈 디렉토리가 남아 있는 경우가 있습니다. Java 5 JVM에서 Java 6 전용 플러그인을 설치하면 Pack200 압축으로 인해 \u0026ldquo;plugin is corrupt\u0026rdquo; 오류가 발생합니다. 테마 및 번역 플러그인은 대부분 테스트되지 않았습니다. 관리되지 않는 플러그인의 자동 시작 플래그가 항상 유지되지는 않습니다. 6. 요구사항 및 모범 사례 플러그인 지원은 I2P 0.7.12 이상에서 사용할 수 있습니다. 보안 수정 사항을 받으려면 router와 플러그인을 최신 상태로 유지하십시오. 사용자가 버전 간 변경 사항을 이해할 수 있도록 간결한 릴리스 노트를 제공하십시오. 가능하면 클리어넷 메타데이터 노출을 최소화하기 위해 I2P 내부에서 HTTPS를 통해 플러그인 아카이브를 호스팅하십시오. 7. 더 읽을거리 플러그인 명세 클라이언트 애플리케이션 프레임워크 패키징 유틸리티를 위한 I2P scripts 저장소 ","description":"라우터 플러그인 설치, 업데이트 및 개발","id":"f8687b90431c32a8ee7e10be9f7c44e0","section":"docs","title":"사용자 정의 플러그인 설치","url":"/ko/docs/guides/plugins/"},{"categories":null,"content":"전 세계 더 많은 사람들이 I2P에 접근할 수 있도록 돕고 싶으신가요? 번역은 프로젝트에 기여할 수 있는 가장 가치 있는 방법 중 하나입니다. 이 가이드는 router console을 번역하는 과정을 안내합니다.\n번역 방법 번역에 기여하는 방법은 두 가지가 있습니다:\n방법 1: Transifex (권장) 이것은 I2P를 번역하는 가장 쉬운 방법입니다. Transifex는 번역을 간단하고 접근하기 쉽게 만드는 웹 기반 인터페이스를 제공합니다.\nTransifex 에 가입하세요 I2P 번역 팀 가입을 요청하세요 브라우저에서 직접 번역을 시작하세요 기술적 지식이 필요하지 않습니다 - 지금 가입하고 번역을 시작하세요!\n방법 2: 수동 번역 git과 로컬 파일 작업을 선호하는 번역가나 Transifex에 아직 설정되지 않은 언어를 위한 방법입니다.\n요구 사항: - git 버전 관리에 대한 이해 - 텍스트 편집기 또는 번역 도구 (POEdit 권장) - 명령줄 도구: git, gettext\n설정: 1. IRC의 #i2p-dev 에 참여하여 자신을 소개하세요 2. 위키에서 번역 상태를 업데이트하세요 (IRC에서 접근 권한 요청) 3. 적절한 저장소를 클론하세요 (아래 섹션 참조)\n라우터 콘솔 번역 router console은 I2P를 실행할 때 보이는 웹 인터페이스입니다. 이를 번역하면 영어가 익숙하지 않은 사용자들에게 도움이 됩니다.\nTransifex 사용하기 (권장) Transifex의 I2P 로 이동하세요 router console 프로젝트를 선택하세요 언어를 선택하세요 번역을 시작하세요 수동 라우터 콘솔 번역 전제 조건: - 웹사이트 번역과 동일 (git, gettext) - GPG 키 (커밋 접근 권한용) - 서명된 개발자 동의서\n메인 I2P 저장소 복제하기:\ngit clone https://i2pgit.org/I2P_Developers/i2p.i2p.git cd i2p.i2p 번역할 파일:\nrouter console에는 번역이 필요한 약 15개의 파일이 있습니다:\n핵심 인터페이스 파일:\napps/routerconsole/locale/messages_*.po - 메인 콘솔 메시지 apps/routerconsole/locale-news/messages_*.po - 뉴스 메시지 프록시 파일:\napps/i2ptunnel/locale/messages_*.po - 터널 구성 인터페이스 애플리케이션 로케일:\napps/susidns/locale/messages_*.po - 주소록 인터페이스 apps/susimail/locale/messages_*.po - 이메일 인터페이스 기타 앱별 로케일 디렉토리 문서 파일:\ninstaller/resources/readme/readme_*.html - 설치 안내문 다양한 앱의 도움말 파일 번역 작업 흐름:\n# Update .po files from source ant extractMessages # Edit .po files with POEdit or text editor poedit apps/routerconsole/locale/messages_es.po # Build and test ant updaters # Install the update and check translations in the console 작업 제출하기: - GitLab 에서 병합 요청 생성 - 또는 IRC에서 개발 팀과 파일 공유\n번역 도구 POEdit (강력 권장) POEdit 는 .po 번역 파일 전용 편집기입니다.\n기능: - 번역 작업을 위한 시각적 인터페이스 - 번역 컨텍스트 표시 - 자동 검증 - Windows, macOS, Linux에서 사용 가능\n텍스트 편집기 다음과 같은 텍스트 편집기를 사용할 수도 있습니다: - VS Code (i18n 확장 프로그램 포함) - Sublime Text - vim/emacs (터미널 사용자용)\n품질 검사 제출하기 전에: 1. 형식 확인: %s 및 {0}와 같은 플레이스홀더가 변경되지 않았는지 확인 2. 번역 테스트: I2P를 설치하고 실행하여 번역이 어떻게 표시되는지 확인 3. 일관성: 파일 전체에서 용어를 일관되게 유지 4. 길이: 일부 문자열은 UI에서 공간 제약이 있음\n번역자를 위한 팁 일반 지침 일관성 유지: 문서 전체에서 일반적인 용어에 대해 동일한 번역을 사용하세요 형식 유지: HTML 태그, 플레이스홀더(%s, {0}), 줄 바꿈을 그대로 유지하세요 맥락이 중요합니다: 맥락을 이해하기 위해 원본 영어를 주의 깊게 읽으세요 질문하기: 불확실한 사항이 있으면 IRC나 포럼을 이용하세요 일반적인 I2P 용어 일부 용어는 영어로 유지하거나 신중하게 음역해야 합니다:\nI2P - Keep as is eepsite - I2P 웹사이트 (I2P 네트워크 내의 웹사이트) tunnel - 연결 경로 (Tor 용어인 \u0026ldquo;circuit\u0026quot;과 혼동 방지) netDb - 네트워크 데이터베이스 floodfill - 라우터 유형 destination - I2P 주소 엔드포인트 번역 테스트하기 번역을 포함하여 I2P를 빌드합니다 router console 설정에서 언어를 변경합니다 모든 페이지를 탐색하여 다음을 확인합니다: UI 요소에 텍스트가 적절히 표시되는지 깨진 문자가 없는지 (인코딩 문제) 문맥상 번역이 자연스러운지 자주 묻는 질문 왜 번역 과정이 그렇게 복잡한가요? 이 프로세스는 버전 관리(git)와 표준 번역 도구(.po 파일)를 사용합니다. 그 이유는:\n책임성: 누가 무엇을 언제 변경했는지 추적 품질: 변경 사항이 적용되기 전에 검토 일관성: 적절한 파일 형식과 구조 유지 확장성: 여러 언어에 걸친 번역을 효율적으로 관리 협업: 여러 번역자가 동일한 언어 작업 가능 프로그래밍 기술이 필요한가요? 아니오! Transifex를 사용하는 경우, 다음만 있으면 됩니다: - 영어와 목표 언어 모두에 대한 유창함 - 웹 브라우저 - 기본적인 컴퓨터 사용 능력\n수동 번역의 경우 기본적인 명령줄 지식이 필요하지만 코딩은 필요하지 않습니다.\n얼마나 걸리나요? Router console: 모든 파일에 대해 약 15-20시간 유지보수: 새로운 문자열을 업데이트하는 데 월 몇 시간 여러 사람이 하나의 언어를 함께 작업할 수 있나요? 네! 조율이 핵심입니다: - 자동 조율을 위해 Transifex를 사용하세요 - 수동 작업의 경우 #i2p-dev IRC 채널에서 소통하세요 - 섹션 또는 파일별로 작업을 분담하세요\n내 언어가 목록에 없으면 어떻게 하나요? Transifex에서 요청하거나 IRC로 팀에 연락하세요. 개발팀이 새로운 언어를 빠르게 설정할 수 있습니다.\n제출하기 전에 번역을 어떻게 테스트하나요? 번역된 파일로 I2P를 소스에서 빌드하기 로컬에 설치하고 실행하기 콘솔 설정에서 언어 변경하기 도움 받기 IRC 지원 다음을 위해 IRC의 #i2p-dev 에 참여하세요: - 번역 도구 관련 기술 지원 - I2P 용어에 대한 질문 - 다른 번역자들과의 협업 - 개발자로부터 직접 지원받기\n포럼 I2P Forums 의 번역 논의 Inside I2P: zzz.i2p의 번역 포럼 (I2P router 필요) 문서 Transifex 문서 POEdit 문서 gettext 매뉴얼 인정 모든 번역자는 다음에 표시됩니다: - I2P router 콘솔 (정보 페이지) - 웹사이트 크레딧 페이지 - Git 커밋 히스토리 - 릴리스 공지사항\n당신의 작업은 전 세계 사람들이 I2P를 안전하고 사적으로 사용하는 데 직접적인 도움이 됩니다. 기여해 주셔서 감사합니다!\n다음 단계 번역을 시작할 준비가 되셨나요?\n방법을 선택하세요:\n빠른 시작: Transifex에서 가입하기 수동 방식: IRC의 #i2p-dev 에 참여하기 작게 시작하세요: 프로세스에 익숙해지기 위해 몇 개의 문자열을 번역하세요\n도움 요청하기: IRC나 포럼에서 주저하지 말고 연락하세요\nI2P를 모두가 접근할 수 있도록 만드는 데 도움을 주셔서 감사합니다!\n","description":"Transifex 또는 수동 방식을 사용하여 I2P 웹사이트 및 router console 번역에 기여하는 방법","id":"a436f7ab16669c43b076458496d70009","section":"docs","title":"새로운 번역자 안내서","url":"/ko/docs/develop/new-translators/"},{"categories":null,"content":"I2P 네트워크 성능: 속도, 연결 및 리소스 관리 I2P 네트워크는 완전히 동적입니다. 각 클라이언트는 다른 노드들에게 알려지며, 로컬에 알려진 노드들의 도달 가능성과 용량을 테스트합니다. 도달 가능하고 충분한 성능을 가진 노드만 로컬 NetDB에 저장됩니다. tunnel 구축 과정에서 이 풀에서 최적의 리소스가 선택되어 tunnel을 구축하는 데 사용됩니다. 테스트가 지속적으로 수행되기 때문에 노드 풀은 계속 변경됩니다. 각 I2P 노드는 NetDB의 서로 다른 부분을 알고 있으며, 이는 각 router가 tunnel에 사용할 수 있는 서로 다른 I2P 노드 집합을 가지고 있음을 의미합니다. 두 router가 동일한 알려진 노드 하위 집합을 가지고 있더라도, 도달 가능성과 용량 테스트는 서로 다른 결과를 보일 가능성이 높습니다. 한 router가 테스트할 때는 다른 router들이 부하 상태에 있을 수 있지만, 두 번째 router가 테스트할 때는 여유 상태일 수 있기 때문입니다.\n이것은 각 I2P 노드가 터널을 구축하기 위해 서로 다른 노드를 사용하는 이유를 설명합니다. 모든 I2P 노드는 지연시간과 대역폭이 다르기 때문에, 해당 노드들을 통해 구축된 터널은 서로 다른 지연시간과 대역폭 값을 가집니다. 그리고 모든 I2P 노드가 서로 다른 터널을 구축하기 때문에, 동일한 터널 집합을 가진 두 I2P 노드는 존재하지 않습니다.\n서버/클라이언트는 \u0026ldquo;destination\u0026quot;으로 알려져 있으며, 각 destination은 최소 하나의 인바운드 터널과 하나의 아웃바운드 터널을 가지고 있습니다. 기본값은 터널당 3홉입니다. 이는 전체 왕복 경로인 클라이언트 → 서버 → 클라이언트에 대해 총 12홉(12개의 서로 다른 I2P 노드)이 됩니다.\n각 데이터 패키지는 서버에 도달하기 전에 6개의 다른 I2P 노드를 거쳐 전송됩니다:\nclient - hop1 - hop2 - hop3 - hopa1 - hopa2 - hopa3 - server\n그리고 돌아오는 길에는 6개의 서로 다른 I2P 노드를 거칩니다:\nserver - hopb1 - hopb2 - hopb3 - hopc1 - hopc2 - hopc3 - client\n네트워크 트래픽은 새로운 데이터를 전송하기 전에 ACK를 필요로 합니다. 서버로부터 ACK가 돌아올 때까지 기다려야 합니다: 데이터 전송, ACK 대기, 추가 데이터 전송, ACK 대기. RTT(Round Trip Time, 왕복 시간)는 이 왕복 경로의 각 I2P 노드와 각 연결의 지연 시간이 누적되므로, 일반적으로 ACK가 클라이언트로 돌아오는 데 1–3초가 소요됩니다. TCP와 I2P 전송 설계로 인해 데이터 패키지는 제한된 크기를 가집니다. 이러한 조건들이 결합되어 tunnel당 최대 대역폭은 대략 20–50 kB/s로 제한됩니다. 그러나 tunnel의 한 홉만 5 kB/s 대역폭만 사용할 수 있다면, 지연 시간 및 기타 제한 사항과 무관하게 전체 tunnel이 5 kB/s로 제한됩니다.\n암호화, 지연 시간, 그리고 터널이 구축되는 방식으로 인해 터널을 구축하는 데 CPU 시간이 상당히 많이 소요됩니다. 이것이 목적지(destination)가 데이터를 전송하기 위해 최대 6개의 인바운드 터널과 6개의 아웃바운드 터널만 가질 수 있는 이유입니다. 터널당 최대 50 kB/s로, 목적지는 대략 300 kB/s의 트래픽을 합산하여 사용할 수 있습니다(실제로는 짧은 터널을 사용하고 익명성이 낮거나 없는 경우 더 많을 수 있습니다). 사용된 터널은 10분마다 폐기되고 새로운 터널이 구축됩니다. 이러한 터널 변경과 때때로 클라이언트가 종료되거나 네트워크 연결이 끊어지면 터널과 연결이 중단될 수 있습니다. 이에 대한 예는 IRC2P 네트워크에서 연결 손실(ping timeout) 또는 eepget 사용 시 확인할 수 있습니다.\n제한된 목적지 집합과 목적지당 제한된 터널 집합을 사용하면, 하나의 I2P 노드는 다른 I2P 노드들을 거치는 제한된 터널 집합만을 사용합니다. 예를 들어, I2P 노드가 위의 간단한 예시에서 \u0026ldquo;hop1\u0026quot;인 경우, 클라이언트로부터 시작되는 하나의 참여 터널만 보게 됩니다. I2P 네트워크 전체를 합산하면, 제한된 양의 대역폭으로 구축할 수 있는 참여 터널의 수는 상당히 제한적입니다. 이러한 제한된 수를 I2P 노드의 수로 분산하면, 사용 가능한 대역폭/용량의 일부만이 사용 가능합니다.\n익명성을 유지하기 위해, 하나의 router가 전체 네트워크에서 tunnel을 구축하는 데 사용되어서는 안 됩니다. 만약 하나의 router가 모든 I2P 노드의 tunnel router 역할을 한다면, 이는 매우 현실적인 단일 장애 지점이 될 뿐만 아니라 클라이언트로부터 IP와 데이터를 수집하는 중앙 지점이 됩니다. 이것이 바로 네트워크가 tunnel 구축 프로세스에서 노드 간에 트래픽을 분산시키는 이유입니다.\n성능에 대한 또 다른 고려사항은 I2P가 메시 네트워킹을 처리하는 방식입니다. 각 홉 간 연결은 I2P 노드에서 하나의 TCP 또는 UDP 연결을 사용합니다. 1000개의 연결이 있으면 1000개의 TCP 연결이 생성됩니다. 이는 상당히 많은 수이며, 일부 가정용 및 소규모 사무실 라우터는 제한된 수의 연결만 허용합니다. I2P는 이러한 연결을 UDP 및 TCP 유형당 각각 1500개 미만으로 제한하려고 시도합니다. 이는 I2P 노드를 통해 라우팅되는 트래픽의 양도 제한합니다.\n노드가 도달 가능하고 대역폭 설정이 128 kB/s 이상 공유되며 24시간 연중무휴로 도달 가능한 경우, 일정 시간 후에 참여 트래픽에 사용되어야 합니다. 중간에 다운되면 다른 노드들이 수행하는 I2P 노드 테스트를 통해 해당 노드가 도달 불가능함을 알게 됩니다. 이렇게 되면 다른 노드들에서 해당 노드가 최소 24시간 동안 차단됩니다. 따라서 해당 노드를 다운 상태로 테스트한 다른 노드들은 24시간 동안 tunnel 구축에 그 노드를 사용하지 않습니다. 이것이 I2P router를 재시작/종료한 후 최소 24시간 동안 트래픽이 낮아지는 이유입니다.\n추가로, 다른 I2P 노드들은 특정 I2P router를 테스트하여 도달 가능성과 용량을 확인하기 위해 해당 라우터를 알아야 합니다. 이 프로세스는 네트워크와 상호작용할 때 더 빠르게 진행될 수 있습니다. 예를 들어 애플리케이션을 사용하거나 I2P 사이트를 방문하면 더 많은 tunnel 구축이 이루어지고, 따라서 네트워크상의 노드들이 테스트할 수 있는 활동과 도달 가능성이 증가합니다.\n성능 기록 (선택됨) 수년에 걸쳐 I2P는 여러 가지 주목할 만한 성능 개선을 이루어왔습니다:\nNative math GNU MP 라이브러리(GMP)에 대한 JNI 바인딩을 통해 구현되어 이전에 CPU 시간을 지배하던 BigInteger modPow를 가속화합니다. 초기 결과는 공개 키 암호화에서 극적인 속도 향상을 보여주었습니다. 참조: /misc/jbigi/\nGarlic wrapping a \u0026ldquo;reply\u0026rdquo; LeaseSet (tuned) 이전에는 응답을 위해 발신자의 LeaseSet을 network database에서 조회해야 하는 경우가 많았습니다. 발신자의 LeaseSet을 초기 garlic에 포함시키면 응답 지연 시간이 개선됩니다. 이제는 오버헤드를 줄이기 위해 선택적으로(연결 시작 시점 또는 LeaseSet 변경 시) 수행됩니다.\n네이티브 수학 잘못된 피어(잘못된 시계, 잘못된 NAT/방화벽, 호환되지 않는 버전)를 더 빨리 거부하기 위해 일부 검증 단계를 transport handshake의 초기 단계로 이동하여 CPU와 대역폭을 절약했습니다.\nGarlic wrapping \u0026ldquo;reply\u0026rdquo; LeaseSet (조정됨) 컨텍스트 인식 tunnel 테스트 사용: 이미 데이터를 전달하고 있는 것으로 알려진 tunnel은 테스트하지 않고, 유휴 상태일 때 테스트를 우선합니다. 이를 통해 오버헤드를 줄이고 실패한 tunnel을 더 빠르게 감지할 수 있습니다.\n더 효율적인 TCP 거부 특정 연결에 대한 선택을 유지하면 순서가 바뀐 전달을 줄이고 스트리밍 라이브러리가 윈도우 크기를 증가시켜 처리량을 향상시킬 수 있습니다.\n터널 테스트 조정 GZip 또는 유사한 압축 방식을 사용하여 장황한 구조(예: RouterInfo 옵션)를 압축하면 적절한 경우 대역폭을 줄일 수 있습니다.\n지속적인 터널/lease 선택 단순한 \u0026ldquo;ministreaming\u0026rdquo; 프로토콜을 대체합니다. 현대적인 streaming은 I2P의 익명성 기반 메시지 지향 기반에 맞춰진 선택적 ACK와 혼잡 제어를 포함합니다. 참조: /docs/api/streaming/\nFuture Performance Improvements (historical ideas) 아래는 잠재적 개선 사항으로 역사적으로 문서화된 아이디어들입니다. 많은 것들이 이미 구식이거나, 구현되었거나, 아키텍처 변경으로 대체되었습니다.\n선택한 데이터 구조 압축 강력한 적대자에 의한 시빌 공격에 대한 저항성을 유지하면서, 느리거나 과부하된 router를 피하기 위해 tunnel 구축을 위한 피어 선택 방식을 개선합니다.\n전체 스트리밍 프로토콜 키 공간이 안정적일 때 불필요한 탐색을 줄이고, lookup에서 반환되는 피어 수와 동시에 수행되는 검색 수를 조정합니다.\nSession Tag tuning and improvements (legacy) 레거시 ElGamal/AES+SessionTag 방식의 경우, 더 스마트한 만료 및 보충 전략이 ElGamal 폴백과 낭비되는 태그를 줄입니다.\n향상된 피어 프로파일링 및 선택 새로운 세션 수립 중 시드된 동기화된 PRNG로부터 태그를 생성하여, 사전 전달된 태그로 인한 메시지당 오버헤드를 줄입니다.\n네트워크 데이터베이스 튜닝 복구 기능과 결합된 더 긴 터널 수명은 재구축 오버헤드를 줄일 수 있습니다. 익명성 및 안정성과의 균형을 고려하십시오.\nSession Tag 튜닝 및 개선사항 (레거시) 유효하지 않은 피어를 조기에 거부하고 터널 테스트를 보다 컨텍스트 인식형으로 만들어 경합과 지연을 줄입니다.\nSessionTag를 동기화된 PRNG로 마이그레이션 (레거시) 선택적 LeaseSet 번들링, 압축된 RouterInfo 옵션, 그리고 전체 스트리밍 프로토콜의 채택은 모두 체감 성능 향상에 기여합니다.\n참고:\n터널 라우팅 피어 선택 전송 계층 SSU2 명세서 및 NTCP2 명세서 ","description":"I2P 네트워크 성능: 현재 동작 방식, 역사적 개선 사항, 그리고 향후 튜닝 아이디어","id":"eb296d22dd7b2414170601d7c73a1613","section":"docs","title":"성능","url":"/ko/docs/overview/performance/"},{"categories":null,"content":"개요 router는 I2P 네트워크를 통해 배포되는 서명된 뉴스 피드를 주기적으로 조회하여 업데이트를 자동으로 확인합니다. 새 버전이 공지되면, router는 암호학적으로 서명된 업데이트 아카이브(.su3)를 다운로드하여 설치를 위해 준비합니다. 이 시스템은 공식 릴리스를 인증되고 위변조에 강한, 그리고 다중 채널 방식으로 배포되도록 보장합니다.\nI2P 2.10.0 기준으로, 업데이트 시스템은 다음을 사용합니다: - RSA-4096 / SHA-512 서명 - SU3 컨테이너 형식 (레거시 SUD/SU2를 대체) - 중복 미러: I2P 네트워크 내부 HTTP, clearnet HTTPS(일반 인터넷), 및 BitTorrent\n1. 뉴스 피드 Routers는 새 버전과 보안 권고를 확인하기 위해 몇 시간마다 서명된 Atom 피드를 폴링합니다. 이 피드는 서명되어 .su3 파일로 배포되며, 여기에는 다음이 포함될 수 있습니다:\n\u0026lt;i2p:version\u0026gt; — 새 버전 번호 \u0026lt;i2p:minVersion\u0026gt; — 지원되는 최소 router 버전 \u0026lt;i2p:minJavaVersion\u0026gt; — 최소 필요 Java 런타임 \u0026lt;i2p:update\u0026gt; — 여러 다운로드 미러(I2P, HTTPS, 토렌트)를 나열 \u0026lt;i2p:revocations\u0026gt; — 인증서 폐기 데이터 \u0026lt;i2p:blocklist\u0026gt; — 침해된 피어에 대한 네트워크 수준의 차단 목록 피드 배포 Channel Description Usage I2P HTTP (eepsite) Primary update source Private, resilient Clearnet HTTPS Fallback mirror Public fallback BitTorrent magnet Distributed channel Reduces mirror load Routers는 I2P 피드를 우선 사용하지만, 필요할 경우 클리어넷이나 토렌트 배포로 전환할 수 있습니다. 2. 파일 형식 SU3 (현재 표준) 0.9.9에서 도입된 SU3는 레거시 SUD 및 SU2 형식을 대체했다. 각 파일에는 헤더, 페이로드, 그리고 후행 서명이 포함된다.\n헤더 구조 \u0026lt;tr\u0026gt; \u0026lt;th style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem; text-align:left; background:var(--color-bg-secondary);\u0026quot;\u0026gt;Field\u0026lt;/th\u0026gt; \u0026lt;th style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem; text-align:left; background:var(--color-bg-secondary);\u0026quot;\u0026gt;Description\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Magic\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;\u0026lt;code\u0026gt;\u0026quot;I2Psu3\u0026quot;\u0026lt;/code\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Format Version\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;\u0026lt;code\u0026gt;0\u0026lt;/code\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Signature Type\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;e.g., \u0026lt;code\u0026gt;0x000B\u0026lt;/code\u0026gt; (RSA-SHA512-4096)\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Signature Length\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;\u0026lt;code\u0026gt;512 bytes\u0026lt;/code\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Version String\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Router version\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Signer ID\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Certificate name\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Content Type\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;1 = router update, 3 = reseed, 4 = news feed\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; 서명 검증 단계 1. 헤더를 파싱하고 서명 알고리즘을 식별합니다. 2. 저장된 서명자 인증서를 사용하여 해시와 서명을 검증합니다. 3. 서명자 인증서가 폐지되지 않았음을 확인합니다. 4. 내장된 버전 문자열을 페이로드 메타데이터와 비교합니다.\nRouters에는 신뢰된 서명자 인증서(현재 zzz 및 str4d)가 포함되어 있으며, 서명되지 않았거나 철회된 출처는 모두 거부합니다.\nSU2 (폐기됨) Pack200로 압축된 JAR에 .su2 확장자를 사용했음. Java 14에서 Pack200이 사용 중단됨(JEP 367) 이후 제거됨. I2P 0.9.48+에서 비활성화됨; 이제 ZIP 압축으로 완전히 대체됨. SUD (레거시) 초기 DSA-SHA1로 서명된 ZIP 형식 (0.9.9 이전). 서명자 ID나 헤더가 없고, 무결성이 제한적임. 취약한 암호기술과 버전 강제 적용 부재로 대체됨. 3. 업데이트 워크플로우 3.1 헤더 검증 router는 전체 파일을 다운로드하기 전에 버전 문자열을 확인하기 위해 SU3 header만 가져옵니다. 이는 오래된 미러나 구버전으로 인해 대역폭이 낭비되는 것을 방지합니다.\n3.2 전체 다운로드 헤더를 검증한 후, router는 전체 .su3 파일을 다음에서 다운로드합니다: - 네트워크 내 eepsite 미러 (선호됨) - HTTPS 클리어넷 미러 (대체) - BitTorrent (선택 사항, 피어 보조형 배포)\n다운로드는 재시도, 타임아웃 처리, 미러 자동 전환 기능이 있는 표준 I2PTunnel HTTP 클라이언트를 사용합니다.\n3.3 서명 검증 다운로드된 각 파일은 다음을 거칩니다: - 서명 확인: RSA-4096/SHA512 검증 - 버전 일치 확인: 헤더와 페이로드의 버전 일치 여부 확인 - 다운그레이드 방지: 업데이트가 설치된 버전보다 최신임을 보장\n유효하지 않거나 일치하지 않는 파일은 즉시 폐기됩니다.\n3.4 설치 스테이징 검증이 완료되면: 1. ZIP의 내용을 임시 디렉터리에 압축 해제 2. deletelist.txt에 나열된 파일 삭제 3. lib/jbigi.jar가 포함되어 있으면 네이티브 라이브러리 교체 4. 서명자 인증서를 ~/.i2p/certificates/로 복사 5. 다음 재시작 시 적용되도록 업데이트를 i2pupdate.zip으로 이동\n업데이트는 다음 시작 시 자동으로 설치되거나, 사용자가 “지금 업데이트 설치”를 수동으로 실행하면 설치됩니다.\n4. 파일 관리 deletelist.txt 새 콘텐츠를 압축 해제하기 전에 제거해야 하는 더 이상 사용되지 않는 파일의 일반 텍스트 목록.\n규칙: - 한 줄당 하나의 경로(상대 경로만 허용) - #로 시작하는 줄은 무시됨 - .. 및 절대 경로는 거부됨\n네이티브 라이브러리 오래되었거나 일치하지 않는 네이티브 바이너리를 방지하기 위해: - lib/jbigi.jar가 존재하면, 오래된 .so 또는 .dll 파일이 삭제됩니다 - 플랫폼별 라이브러리가 새로 추출되도록 보장됩니다\n5. 인증서 관리 Router는 업데이트 또는 뉴스 피드의 철회 공지를 통해 새 서명자 인증서를 받을 수 있습니다.\n새로운 .crt 파일이 인증서 디렉터리로 복사됩니다. 폐기된 인증서는 향후 검증 전에 삭제됩니다. 사용자의 수동 개입 없이 키 회전을 지원합니다. 모든 업데이트는 **air-gapped signing systems(에어갭 서명 시스템)**을 사용하여 오프라인에서 서명됩니다. 개인 키는 빌드 서버에 절대 저장되지 않습니다.\n6. 개발자 지침 Topic Details Signing Use RSA-4096 (SHA-512) via apps/jetty/news SU3 tooling. Mirror Policy I2P eepsite preferred, clearnet HTTPS fallback, torrent optional. Testing Validate updates from prior releases, across all OS platforms. Version Enforcement minVersion prevents incompatible upgrades. Certificate Rotation Distribute new certs in updates and revocation lists. 향후 릴리스에서는 양자내성 서명 통합(제안 169 참조)과 재현 가능한 빌드를 검토할 예정입니다. 7. 보안 개요 Threat Mitigation Tampering Cryptographic signature (RSA-4096/SHA512) Key Compromise Feed-based certificate revocation Downgrade Attack Version comparison enforcement Mirror Hijack Signature verification, multiple mirrors DoS Fallback to alternate mirrors/torrents MITM HTTPS transport + signature-level integrity --- 8. 버전 관리 Router: 2.10.0 (API 0.9.67) 시맨틱 버전 관리(Major.Minor.Patch 사용). 최소 버전 강제 적용으로 안전하지 않은 업그레이드를 방지합니다. 지원되는 Java: Java 8–17. 향후 2.11.0+부터는 Java 17+가 필요합니다. ","description":"I2P routers를 위한 서명 기반 보안 업데이트 메커니즘 및 피드 구조","id":"aea843f73d809c9546b3d675324af161","section":"docs","title":"소프트웨어 업데이트 명세서","url":"/ko/docs/specs/updates/"},{"categories":null,"content":"개요 I2P Streaming Library는 I2P의 메시지 계층 위에서 신뢰할 수 있고 순서가 보장되며 인증된 전송을 제공하며, 이는 IP 위의 TCP와 유사합니다. 이는 I2CP protocol 위에 위치하며 HTTP 프록시, IRC, BitTorrent, 이메일을 포함한 거의 모든 대화형 I2P 애플리케이션에서 사용됩니다.\n핵심 특성 SYN, ACK, FIN 플래그를 사용한 단일 단계 연결 설정으로, 페이로드 데이터와 함께 번들링하여 왕복 횟수를 줄입니다. I2P의 높은 지연 환경에 맞게 조정된 슬로우 스타트 및 혼잡 회피 기능을 갖춘 슬라이딩 윈도우 혼잡 제어. 재전송 비용과 단편화 지연 간의 균형을 맞추는 패킷 압축(기본 4KB 압축 세그먼트). I2P destination 간 완전히 인증되고 암호화된 신뢰할 수 있는 채널 추상화. 이 설계는 작은 HTTP 요청과 응답이 단일 왕복(round-trip)으로 완료될 수 있도록 합니다. SYN 패킷은 요청 페이로드를 전달할 수 있으며, 응답자의 SYN/ACK/FIN은 전체 응답 본문을 포함할 수 있습니다.\nAPI 기본 사항 Java 스트리밍 API는 표준 Java 소켓 프로그래밍을 그대로 반영합니다:\nI2PSocketManager mgr = I2PSocketManagerFactory.createManager(host, port, options); I2PSocket socket = mgr.connect(destination); I2PServerSocket server = mgr.getServerSocket(); I2PSocketManagerFactory는 I2CP를 통해 router 세션을 협상하거나 재사용합니다. 키가 제공되지 않으면 새로운 destination이 자동으로 생성됩니다. 개발자는 options 맵을 통해 I2CP 옵션(예: tunnel 길이, 암호화 유형 또는 연결 설정)을 전달할 수 있습니다. I2PSocket과 I2PServerSocket은 표준 Java Socket 인터페이스를 그대로 따르므로 마이그레이션이 간단합니다. 전체 Javadocs는 I2P router console 또는 여기 에서 확인할 수 있습니다.\n설정 및 튜닝 socket manager를 생성할 때 다음과 같이 설정 속성을 전달할 수 있습니다:\nI2PSocketManagerFactory.createManager(host, port, properties); 주요 옵션 Option Description Default i2p.streaming.maxWindowSize Maximum send window (bytes) 128 KB i2p.streaming.initialRTO Initial retransmission timeout 9s i2p.streaming.inactivityTimeout Timeout before connection close 90s i2p.streaming.enforceProtocol Enforce protocol ID (prevents confusion) true i2p.streaming.congestionAlgorithm Congestion control method Default (AIMD TCP-like) i2p.streaming.disableRejectLogging Disable logging rejected packets false ### 워크로드별 동작 Workload Recommended Settings HTTP-like Default parameters are ideal. Bulk Transfer Increase window size to 256 KB or 512 KB; lengthen timeouts. Real-time Streaming Lower tunnel length to 1-2 hops; adjust RTO downwards. 버전 0.9.4 이후의 새로운 기능으로는 거부 로그 억제, DSA 목록 지원(0.9.21), 필수 프로토콜 적용(0.9.36)이 있습니다. 2.10.0 이후 router에는 전송 계층에서 포스트 양자 하이브리드 암호화(ML-KEM + X25519)가 포함되어 있습니다. 프로토콜 세부사항 각 스트림은 Stream ID로 식별됩니다. 패킷은 TCP와 유사한 제어 플래그를 전달합니다: SYNCHRONIZE, ACK, FIN, RESET. 패킷은 데이터와 제어 플래그를 동시에 포함할 수 있어, 단기 연결의 효율성을 향상시킵니다.\n연결 수명 주기 SYN 전송 — 개시자가 선택적 데이터를 포함합니다. SYN/ACK 응답 — 응답자가 선택적 데이터를 포함합니다. ACK 완료 — 신뢰성과 세션 상태를 확립합니다. FIN/RESET — 정상 종료 또는 강제 종료에 사용됩니다. 단편화 및 재정렬 I2P 터널은 지연과 메시지 재정렬을 야기하기 때문에, 라이브러리는 알려지지 않았거나 일찍 도착한 스트림의 패킷을 버퍼링합니다. 버퍼링된 메시지는 동기화가 완료될 때까지 저장되어 완전하고 순서대로 전달되도록 보장합니다.\n프로토콜 강제 적용 i2p.streaming.enforceProtocol=true 옵션(0.9.36 이후 기본값)은 연결이 올바른 I2CP 프로토콜 번호를 사용하도록 보장하여, 하나의 destination을 공유하는 여러 하위 시스템 간의 충돌을 방지합니다.\n상호 운용성 및 모범 사례 스트리밍 프로토콜은 Datagram API와 함께 제공되어, 개발자가 연결 지향 전송과 비연결 전송 중에서 선택할 수 있도록 합니다.\nUse Case Recommended Transport Reliable, ordered data (HTTP, IRC, FTP) Streaming Connectionless or lossy data (DNS, telemetry) Datagram ### 공유 클라이언트 애플리케이션은 공유 클라이언트로 실행하여 기존 터널을 재사용할 수 있으며, 여러 서비스가 동일한 목적지를 공유할 수 있습니다. 이는 오버헤드를 줄이지만 서비스 간 상관관계 위험을 증가시키므로 주의해서 사용해야 합니다.\n혼잡 제어 스트리밍 계층은 RTT 기반 피드백을 통해 네트워크 지연 시간과 처리량에 지속적으로 적응합니다. 라우터가 기여 피어(참여 tunnel 활성화)일 때 애플리케이션이 최상의 성능을 발휘합니다. TCP와 유사한 혼잡 제어 메커니즘은 느린 피어의 과부하를 방지하고 tunnel 전반에 걸쳐 대역폭 사용의 균형을 맞추는 데 도움을 줍니다. 지연 시간 고려사항 I2P는 수백 밀리초의 기본 지연 시간을 추가하므로, 애플리케이션은 왕복 횟수를 최소화해야 합니다. 가능한 경우 연결 설정과 함께 데이터를 묶어 전송하세요(예: SYN에 HTTP 요청 포함). 많은 작은 순차적 교환에 의존하는 설계는 피하세요.\n테스트 및 호환성 완전한 호환성을 보장하기 위해 항상 Java I2P와 i2pd 모두에 대해 테스트하세요. 프로토콜이 표준화되어 있지만, 구현상의 사소한 차이가 존재할 수 있습니다. 이전 버전 router를 우아하게 처리하세요—많은 피어가 여전히 2.0 이전 버전을 실행하고 있습니다. I2PSocket.getOptions()와 getSession()을 사용하여 연결 통계를 모니터링하고 RTT 및 재전송 메트릭을 읽으세요. 성능은 터널 구성에 크게 의존합니다: - 짧은 터널 (1–2 hops) → 낮은 지연시간, 익명성 감소. - 긴 터널 (3+ hops) → 높은 익명성, RTT 증가.\n주요 개선 사항 (2.0.0–2.10.0) Feature Introduced Description Persistent ACK Bundling 2.0.0 Optimized round-trip reduction for HTTP workloads. Adaptive Window Scaling 2.3.0 Improved large file transfer stability. Thread Pooling and Socket Reuse 2.5.0 Reduced per-connection overhead. Protocol Enforcement Default 0.9.36 Ensures correct stream usage. Hybrid ML-KEM Ratchet 2.10.0 Adds post-quantum hybrid encryption layer. i2pd Streaming API Compatibility Fixes 2.9.0 Full parity with Java I2P library behavior. --- 요약 I2P Streaming Library는 I2P 내 모든 신뢰할 수 있는 통신의 핵심입니다. 순서가 보장되고 인증되며 암호화된 메시지 전달을 보장하고, 익명 환경에서 TCP를 거의 그대로 대체할 수 있는 기능을 제공합니다.\n최적의 성능을 달성하려면: - SYN+페이로드 번들링으로 왕복 횟수를 최소화하세요. - 워크로드에 맞게 윈도우 및 타임아웃 매개변수를 조정하세요. - 지연 시간에 민감한 애플리케이션의 경우 더 짧은 tunnel을 사용하세요. - 피어에 과부하가 걸리지 않도록 혼잡 제어 친화적인 설계를 사용하세요.\n","description":"대부분의 I2P 애플리케이션에서 사용하는 TCP 유사 전송 방식","id":"d5eaf45dea26928a910e0f2b8a0e1037","section":"docs","title":"스트리밍 프로토콜","url":"/ko/docs/api/streaming/"},{"categories":null,"content":"개요 I2P Streaming Library(I2P에서 신뢰성·순서 보장·인증을 제공하는 스트림 전송 라이브러리)는 I2P의 비신뢰성 메시지 계층 위에서 신뢰성 있고 순서가 보장되며 인증된 데이터 전달을 제공합니다 — IP 위의 TCP와 유사합니다. 이는 웹 브라우징, IRC, 이메일, 파일 공유 등 거의 모든 대화형 I2P 애플리케이션에서 사용됩니다.\n이는 I2P의 고지연 익명 tunnels 전체에 걸쳐 신뢰할 수 있는 전송, 혼잡 제어, 재전송 및 흐름 제어를 보장합니다. 각 스트림은 목적지 간에 종단 간으로 완전히 암호화됩니다.\n핵심 설계 원칙 스트리밍 라이브러리는 one-phase connection setup(단일 단계 연결 설정)을 구현하며, SYN, ACK 및 FIN 플래그가 동일한 메시지에서 데이터 페이로드를 실을 수 있다. 이는 고지연 환경에서 왕복 횟수를 최소화한다 — 작은 HTTP 트랜잭션은 단 한 번의 왕복으로 완료될 수 있다.\n혼잡 제어와 재전송은 TCP를 본떴지만 I2P의 환경에 맞게 조정되었습니다. 윈도 크기는 바이트 기반이 아니라 메시지 기반이며, tunnel 지연 시간과 오버헤드에 맞게 최적화되어 있습니다. 이 프로토콜은 TCP의 AIMD(가산적 증가/승법적 감소) 알고리즘과 유사하게 느린 시작, 혼잡 회피, 지수적 백오프를 지원합니다.\n아키텍처 스트리밍 라이브러리는 애플리케이션과 I2CP 인터페이스 사이에서 동작합니다.\nLayer Responsibility Application Standard I2PSocket and I2PServerSocket usage Streaming Library Connection setup, sequencing, retransmission, and flow control I2CP Tunnel creation, routing, and message handling I2NP / Router Layer Transport through tunnels 대부분의 사용자는 I2PSocketManager, I2PTunnel 또는 SAMv3를 통해 이에 접근합니다. 라이브러리는 destination(목적지) 관리, tunnel 사용 및 재전송을 투명하게 처리합니다. 패킷 형식 +-----------------------------------------------+ | Send Stream ID (4B) | Receive Stream ID (4B) | +-----------------------------------------------+ | Sequence Number (4B) | Ack Through (4B) | +-----------------------------------------------+ | NACK Count (1B) | optional NACK list (4B each) +-----------------------------------------------+ | Flags (1B) | Option Size (1B) | Options ... | +-----------------------------------------------+ | Payload ... | 헤더 세부 정보 Stream IDs: 로컬 및 원격 스트림을 고유하게 식별하는 32비트 값. Sequence Number: SYN에서는 0에서 시작하며, 메시지마다 증가합니다. Ack Through: N까지의 모든 메시지를 확인(ACK)하며, 부정 확인(NACK) 목록에 있는 것들은 제외합니다. Flags: 상태와 동작을 제어하는 비트마스크. Options: RTT, MTU 및 프로토콜 협상을 위한 가변 길이 목록. 주요 플래그 Flag Purpose SYN Connection initiation ACK Acknowledge received packets FIN Graceful close RST Reset connection FROM_INCLUDED Sender’s destination included SIGNATURE_INCLUDED Message signed by sender ECHO / ECHO_REPLY Ping/Pong keepalive --- 흐름 제어와 신뢰성 Streaming은 TCP의 바이트 기반 방식과 달리 message-based windowing(메시지 기반 윈도우 제어)을 사용합니다. 전송 중으로 허용되는 ACK 미수신 패킷 수는 현재 윈도우 크기와 같습니다(기본값 128).\n메커니즘 혼잡 제어: 슬로 스타트와 AIMD(가산적 증가·곱셈적 감소) 기반 혼잡 회피. Choke/Unchoke(초크/언초크): 버퍼 점유율 기반의 흐름 제어 신호. 재전송: RFC 6298 기반의 RTO 계산과 지수 백오프. 중복 필터링: 메시지 순서가 재정렬될 수 있는 환경에서도 신뢰성을 보장. 일반적인 설정 값:\nParameter Default Description maxWindowSize 128 Max unacknowledged messages maxMessageSize 1730 Maximum payload bytes per message initialRTO 9000 ms Initial retransmission timeout inactivityTimeout 90000 ms Idle connection timeout connectTimeout 300000 ms Connection establishment timeout --- 연결 설정 개시자는 SYN을 보낸다(선택적으로 페이로드와 FROM_INCLUDED 포함). 응답자는 SYN+ACK로 응답한다(페이로드가 포함될 수 있음). 개시자는 연결 성립을 확인하는 최종 ACK를 보낸다. 선택적 초기 payload(페이로드)는 핸드셰이크가 완전히 완료되기 전에 데이터 전송을 가능하게 합니다.\n구현 세부사항 재전송과 타임아웃 재전송 알고리즘은 RFC 6298을 준수합니다. - 초기 RTO: 9s - 최소 RTO: 100ms - 최대 RTO: 45s - Alpha(알파): 0.125 - Beta(베타): 0.25\n제어 블록 공유 동일한 피어에 대한 최근 연결은 이전 RTT(왕복 시간)와 윈도우 데이터를 재사용하여 초기 램프업을 더 빠르게 하고, “콜드 스타트” 지연을 피합니다. 제어 블록은 몇 분 후 만료됩니다.\nMTU 및 단편화 기본 MTU: 1730 바이트 (I2NP 메시지 두 개를 담을 수 있음). ECIES(타원곡선 통합 암호 방식) 대상: 1812 바이트 (오버헤드 감소). 지원되는 최소 MTU: 512 바이트. 페이로드 크기에는 22바이트 최소 스트리밍 헤더가 포함되지 않습니다.\n버전 이력 Router Version Feature 0.7.1 Protocol numbers defined in I2CP 0.9.11 Variable-length signatures 0.9.12 ECDSA signature support 0.9.15 Ed25519 signature support 0.9.18 Ping/Pong payloads 0.9.20 FROM_INCLUDED not required in RESET 0.9.36 Protocol enforcement enabled by default 0.9.39 OFFLINE_SIGNATURE support 0.9.58 Bob’s hash added to NACK field in SYN 2.10.0 Post-Quantum hybrid encryption (experimental) --- 애플리케이션 수준 사용 Java 예제 Properties props = new Properties(); props.setProperty(\u0026#34;i2p.streaming.maxWindowSize\u0026#34;, \u0026#34;512\u0026#34;); I2PSocketManager mgr = I2PSocketManagerFactory.createManager(props); I2PSocket socket = mgr.connect(destination); InputStream in = socket.getInputStream(); OutputStream out = socket.getOutputStream(); SAMv3 및 i2pd 지원 SAMv3: Java가 아닌 클라이언트를 위한 STREAM 및 DATAGRAM 모드를 제공합니다. i2pd: 구성 파일 옵션(예: i2p.streaming.maxWindowSize, profile 등)을 통해 동일한 스트리밍 매개변수를 노출합니다. 스트리밍과 데이터그램 중에서 선택하기 Use Case Recommended Transport Reason HTTP, IRC, Email Streaming Requires reliability DNS Repliable Datagram Single request/response Telemetry, Logging Raw Datagram Best-effort acceptable P2P DHT Datagram High connection churn --- 보안과 포스트-양자 미래 스트리밍 세션은 I2CP 계층에서 종단 간으로 암호화됩니다. 포스트-양자 하이브리드 암호화(ML-KEM + X25519)는 2.10.0에서 실험적으로 지원되지만 기본적으로 비활성화되어 있습니다.\n참고 자료 스트리밍 API 개요 스트리밍 프로토콜 명세 I2CP 명세 제안 144: 스트리밍 MTU 계산 I2P 2.10.0 릴리스 노트 ","description":"대부분의 I2P 애플리케이션에서 사용되는 TCP와 유사한 신뢰성 있는 전송 방식","id":"100837c91cc0808ee048c86902b36251","section":"docs","title":"스트리밍 프로토콜","url":"/ko/docs/specs/streaming/"},{"categories":null,"content":"I2P 작업을 시작하고 싶으신가요? 좋습니다! 여기 웹사이트나 소프트웨어에 기여하고, 개발을 하거나, 번역을 만드는 것을 시작하기 위한 간단한 가이드가 있습니다.\n아직 코딩할 준비가 되지 않으셨나요? 먼저 참여하기 를 시도해 보세요.\nJava 알아보기 I2P router와 내장 애플리케이션은 Java를 주요 개발 언어로 사용합니다. Java 경험이 없다면 Thinking in Java 를 참고하실 수 있습니다\nhow intro, 다른 \u0026ldquo;how\u0026rdquo; 문서들, tech intro, 그리고 관련 문서들을 학습하세요:\n소개 방법: I2P 소개 문서 허브: 문서 기술 소개: 기술 소개 이를 통해 I2P가 어떻게 구성되어 있고 어떤 다양한 기능을 수행하는지 전반적으로 잘 이해할 수 있습니다.\nI2P 코드 가져오기 I2P router 또는 내장된 애플리케이션 개발을 위해서는 소스 코드를 가져와야 합니다.\n우리의 현재 방식: Git I2P는 자체 GitLab에서 공식 Git 서비스를 제공하며 Git을 통한 기여를 받습니다:\nI2P 내부: http://git.idk.i2p I2P 외부: https://i2pgit.org 메인 저장소를 클론하세요:\ngit clone https://i2pgit.org/I2P_Developers/i2p.i2p.git 읽기 전용 미러도 GitHub에서 이용 가능합니다:\nGitHub 미러: github.com/i2p/i2p.i2p git clone https://github.com/i2p/i2p.i2p.git I2P 빌드하기 코드를 컴파일하려면 Sun/Oracle Java Development Kit 6 이상 또는 동등한 JDK(Sun/Oracle JDK 6 강력 권장)와 Apache Ant 버전 1.7.0 이상이 필요합니다. 메인 I2P 코드 작업을 진행 중이라면 i2p.i2p 디렉토리로 이동하여 ant를 실행하면 빌드 옵션을 확인할 수 있습니다.\n콘솔 번역을 빌드하거나 작업하려면 GNU gettext 패키지의 xgettext, msgfmt, msgmerge 도구가 필요합니다.\n새로운 애플리케이션 개발에 대해서는 애플리케이션 개발 가이드 를 참조하세요.\n개발 아이디어 아이디어를 얻으려면 프로젝트 TODO 목록이나 GitLab의 이슈 목록을 참조하세요:\nGitLab 이슈: i2pgit.org/I2P_Developers/i2p.i2p/issues 결과를 공개하기 커밋 권한 요구사항은 라이선스 페이지 하단을 참조하세요. i2p.i2p에 코드를 넣으려면 이 권한이 필요합니다 (웹사이트는 필요 없습니다!).\n라이선스 페이지 저희를 알아가세요! 개발자들은 IRC에 상주하고 있습니다. 다양한 네트워크와 I2P 내부 네트워크에서 연락할 수 있습니다. 일반적으로 #i2p-dev 채널을 찾아보세요. 채널에 접속해서 인사하세요! 정규 개발자를 위한 추가 가이드라인 도 있습니다.\n웹사이트 및 라우터 콘솔 번역가: 다음 단계는 신규 번역가 가이드 를 참조하세요.\n도구 I2P는 대부분 오픈소스 툴킷을 사용하여 개발되는 오픈소스 소프트웨어입니다. I2P 프로젝트는 최근 YourKit Java Profiler 라이선스를 취득했습니다. 오픈소스 프로젝트는 프로젝트 웹사이트에서 YourKit을 언급하는 조건으로 무료 라이선스를 받을 수 있습니다. I2P 코드베이스 프로파일링에 관심이 있으시면 연락 주시기 바랍니다.\nYourKit은 풀 기능 프로파일러로 오픈 소스 프로젝트를 친절하게 지원하고 있습니다. YourKit, LLC는 Java 및 .NET 애플리케이션 프로파일링을 위한 혁신적이고 지능적인 도구를 만드는 회사입니다. YourKit의 선도적인 소프트웨어 제품을 살펴보세요:\nYourKit Java Profiler YourKit .NET Profiler ","description":"I2P에 기여를 시작하는 방법: 학습 자료, 소스 코드, 빌드, 아이디어, 게시, 커뮤니티, 번역 및 도구","id":"e74ff72be9767cc925c6712e11e5e1c5","section":"docs","title":"신규 개발자 가이드","url":"/ko/docs/develop/new-developers/"},{"categories":null,"content":"개요 이 문서는 암호화된 LeaseSet2 (LS2)의 블라인딩, 암호화 및 복호화를 명세한다. 암호화된 LeaseSet은 I2P netDb(네트워크 데이터베이스)에서 은닉 서비스 정보의 접근 제어가 적용된 게시를 제공한다.\n주요 기능: - 전방향 기밀성을 위한 일일 키 순환 - 이중 계층 클라이언트 인가(DH(디피-헬만) 기반 및 PSK(사전 공유 키) 기반) - AES 하드웨어 지원이 없는 장치에서의 성능을 위한 ChaCha20 암호화 - key blinding(키 블라인딩)을 적용한 Red25519 서명 - 프라이버시 보존형 클라이언트 멤버십\n관련 문서: - 공통 구조 명세 - 암호화된 LeaseSet(리스셋: I2P 목적지의 연결 정보 묶음) 구조 - 제안 123: 새로운 netDB(I2P 네트워크 데이터베이스) 항목 - 암호화된 LeaseSets에 대한 배경 - 네트워크 데이터베이스 문서 - NetDB 사용\n버전 이력 및 구현 현황 프로토콜 개발 타임라인 버전 번호 지정에 대한 중요 참고 사항: I2P는 두 가지 별도의 버전 번호 체계를 사용합니다: - API/Router 버전: 0.9.x 계열 (기술 사양에서 사용) - 제품 릴리스 버전: 2.x.x 계열 (공개 릴리스에 사용)\n기술 사양서는 API 버전(예: 0.9.41)을 참조하고, 반면 최종 사용자는 제품 버전(예: 2.10.0)을 보게 됩니다.\n구현 마일스톤 Version Release Date Features 0.9.38January 2019Floodfill support for standard LS2, offline keys 0.9.39March 2019Full encrypted LS2 support, Red25519 (sig type\u0026nbsp;11) 0.9.40May 2019Per-client authorization, encrypted LS2 with offline keys, B32 support 0.9.41June 2019Protocol finalized as stable 2.10.0September 2025Latest Java implementation (API version 0.9.61) i2pd 2.58.0September 2025Full C++ implementation compatibility ### 현재 상태 ✅ 프로토콜 상태: 2019년 6월 이후 안정적이며 변경되지 않음 ✅ Java I2P: 버전 0.9.40+에서 완전히 구현됨 ✅ i2pd (C++): 버전 2.58.0+에서 완전히 구현됨 ✅ 상호운용성: 구현 간 완전한 상호운용성 ✅ 네트워크 배포: 6년 이상의 운영 경험으로 프로덕션 준비 완료 암호학적 정의 표기법 및 관례 || 는 연결(이어붙이기)을 나타냅니다 mod L 는 Ed25519의 차수(order) L에 대한 모듈러 감소를 나타냅니다 달리 명시되지 않는 한 모든 바이트 배열은 네트워크 바이트 순서(빅엔디언)입니다 리틀엔디언 값은 명시적으로 표시됩니다 암호학적으로 안전한 난수 생성기(n) 암호학적으로 안전한 난수 생성기\n키 자료 생성에 적합한 암호학적으로 안전한 난수 데이터를 n바이트 생성합니다.\n보안 요구사항: - 암호학적으로 안전해야 함(키 생성에 적합해야 함) - 네트워크 상에서 인접한 바이트 시퀀스가 노출되더라도 안전해야 함 - 구현체는 잠재적으로 신뢰할 수 없는 소스에서 나온 출력값은 해시 처리하는 것이 좋음\n참고자료: - PRNG(의사난수 생성기) 보안 고려사항 - Tor 개발자 토론 H(p, d) 개인화가 적용된 SHA-256 해시\n도메인 분리가 적용된 해시 함수로 다음을 입력으로 받습니다: - p: 개인화 문자열(도메인 분리를 제공합니다) - d: 해시할 데이터\n구현:\nH(p, d) := SHA-256(p || d) Usage: SHA-256의 서로 다른 프로토콜 용도 간 충돌 공격을 방지하기 위해 암호학적 도메인 분리를 제공합니다.\n스트림: ChaCha20 스트림 암호: RFC 7539 2.4절에 정의된 ChaCha20\n매개변수: - S_KEY_LEN = 32 (256비트 키) - S_IV_LEN = 12 (96비트 nonce(일회용 임의값)) - 초기 카운터: 1 (RFC 7539는 0 또는 1을 허용; AEAD 컨텍스트에서는 1을 권장)\nENCRYPT(k, iv, plaintext)\n다음을 사용하여 평문을 암호화합니다: - k: 32바이트 암호 키 - iv: 12바이트 nonce(논스, 반드시 각 키마다 고유해야 함) - 평문과 동일한 크기의 암호문을 반환합니다\n보안 속성: 키가 비밀이라면 전체 암호문은 무작위와 구별되지 않아야 한다.\n복호화(k, iv, ciphertext)\n다음을 사용해 암호문을 복호화합니다: - k: 32바이트 암호 키 - iv: 12바이트 논스 - 평문을 반환합니다\n설계 근거: AES 대신 ChaCha20을 선택한 이유: - 하드웨어 가속이 없는 장치에서는 AES보다 2.5-3배 더 빠름 - 상수 시간 구현을 달성하기가 더 쉬움 - AES-NI(인텔의 AES 전용 명령어 집합) 사용이 가능한 경우에도 보안성과 속도가 비슷함\n참고 자료: - RFC 7539 - IETF 프로토콜용 ChaCha20 및 Poly1305\n서명: Red25519(Ed25519 기반 RedDSA 서명 알고리즘) 서명 방식: Red25519 (SigType 11)와 Key Blinding(키 블라인딩: 서명 키에 난수를 적용해 원본 키 노출을 방지하는 기법)\nRed25519는 Ed25519 곡선 위의 Ed25519 서명을 기반으로 하며, 해싱에는 SHA-512를 사용하고, ZCash RedDSA에 명시된 대로 key blinding(키 블라인딩: 원본 키와의 연결을 숨기기 위해 키를 변형하는 기법)을 지원합니다.\n기능:\nDERIVE_PUBLIC(privkey) 주어진 개인 키에 해당하는 공개 키를 반환합니다. - 기준점에 대한 표준 Ed25519 스칼라 곱셈을 사용합니다\nSIGN(privkey, m) 개인 키 privkey로 메시지 m에 대한 서명을 반환합니다.\nEd25519와 비교한 Red25519의 서명 차이점: 1. 무작위 논스: 추가 80바이트의 무작위 데이터를 사용합니다\nT = CSRNG(80) // 80 random bytes r = H*(T || publickey || message) 이로 인해 동일한 메시지와 키에 대해서도 모든 Red25519(서명 방식) 서명이 고유해집니다.\n개인 키 생성: Red25519 개인 키는 난수로부터 생성된 뒤 mod L로 축약되며, Ed25519의 bit-clamping(비트들을 특정 패턴으로 고정하는 방식) 방식을 사용하지 않습니다. VERIFY(pubkey, m, sig) 공개키 pubkey와 메시지 m에 대해 서명 sig를 검증합니다. - 서명이 유효하면 true를, 그렇지 않으면 false를 반환합니다 - 검증 방식은 Ed25519와 동일합니다\n키 블라인딩 작업:\nGENERATE_ALPHA(data, secret) 키 블라인딩을 위한 alpha를 생성합니다. - data: 일반적으로 서명 공개 키와 서명 유형을 포함합니다 - secret: 선택적 추가 비밀값(사용하지 않으면 길이 0바이트) - 결과는 Ed25519 개인 키와 동일한 분포를 가집니다(mod L 환원 후)\nBLIND_PRIVKEY(privkey, alpha) 비밀값 alpha를 사용하여 개인 키를 블라인드 처리합니다. - 구현: blinded_privkey = (privkey + alpha) mod L - 체에서 스칼라 산술을 사용합니다\nBLIND_PUBKEY(pubkey, alpha) 비밀값 alpha를 사용하여 공개키를 블라인딩합니다. - 구현: blinded_pubkey = pubkey + DERIVE_PUBLIC(alpha) - 곡선 위에서 군 원소(점) 덧셈을 사용합니다.\n핵심 속성:\nBLIND_PUBKEY(pubkey, alpha) == DERIVE_PUBLIC(BLIND_PRIVKEY(privkey, alpha)) 보안 고려사항:\nZCash Protocol Specification 5.4.6.1절에 따르면: 보안을 위해 alpha는 블라인딩 해제된 개인 키와 동일한 분포를 가져야 한다. 이는 \u0026ldquo;재무작위화된 공개 키와 그 키로 생성된 서명(들)의 조합이, 해당 공개 키가 재무작위화되기 전의 원래 키를 드러내지 않는다\u0026quot;는 것을 보장한다.\n지원되는 서명 유형: - 유형 7 (Ed25519): 기존 destinations(목적지) 지원 (하위 호환성) - 유형 11 (Red25519): 암호화를 사용하는 신규 destinations에 권장 - Blinded keys(블라인드 키): 항상 유형 11 (Red25519)을 사용\n참고 자료: - ZCash 프로토콜 명세서 - 섹션 5.4.6 RedDSA - I2P Red25519 명세서 DH(디피-헬먼 키 교환): X25519 타원곡선 디피-헬만: X25519\nCurve25519 기반 공개 키 합의 시스템.\n매개변수: - 개인 키: 32 바이트 - 공개 키: 32 바이트 - 공유 비밀 출력: 32 바이트\n기능:\nGENERATE_PRIVATE() CSRNG(암호학적으로 안전한 난수 생성기)을 사용하여 새로운 32바이트 개인 키를 생성합니다.\nDERIVE_PUBLIC(privkey) 주어진 비밀 키에서 32바이트 공개 키를 유도합니다. - Curve25519에서 스칼라 곱셈을 사용합니다\nDH(privkey, pubkey) 디피-헬만 키 합의를 수행합니다. - privkey: 로컬 32바이트 개인 키 - pubkey: 원격 32바이트 공개 키 - 반환: 32바이트 공유 비밀\n보안 속성: - Curve25519에서의 계산적 디피-헬먼 가정 - 임시 키 사용 시 전방향 기밀성 - 타이밍 공격을 방지하기 위해 상수 시간 구현 필요\n참고 문헌: - RFC 7748 - 보안을 위한 타원곡선\nHKDF(HMAC 기반 추출-확장 키 파생 함수) HMAC 기반 키 파생 함수\n입력 키잉 재료에서 키 재료를 추출하고 확장합니다.\n매개변수: - salt: 최대 32바이트(보통 SHA-256의 경우 32바이트) - ikm: 입력 키 재료(길이 제한 없음, 충분한 엔트로피 권장) - info: 컨텍스트별 정보(도메인 분리) - n: 출력 길이(바이트 단위)\n구현:\nRFC 5869에 명시된 대로 다음과 같은 설정으로 HKDF를 사용합니다: - 해시 함수: SHA-256 - HMAC: RFC 2104에 명시된 대로 - 솔트 길이: 최대 32바이트(SHA-256의 HashLen)\n사용 패턴:\nkeys = HKDF(salt, ikm, info, n) 도메인 분리: info 매개변수는 프로토콜 내에서 HKDF의 서로 다른 사용 간에 암호학적 도메인 분리를 제공합니다.\n검증된 정보 값: - \u0026quot;ELS2_L1K\u0026quot; - 레이어 1(외부) 암호화 - \u0026quot;ELS2_L2K\u0026quot; - 레이어 2(내부) 암호화 - \u0026quot;ELS2_XCA\u0026quot; - DH 클라이언트 인증 - \u0026quot;ELS2PSKA\u0026quot; - PSK 클라이언트 인증 - \u0026quot;i2pblinding1\u0026quot; - 알파 생성\n참고 자료: - RFC 5869 - HKDF 명세 - RFC 2104 - HMAC 명세\n형식 명세 암호화된 LS2(LeaseSet2, I2P의 2세대 leaseSet 형식)는 세 개의 중첩된 계층으로 구성된다:\n계층 0 (외부): 저장 및 검색을 위한 평문 정보 계층 1 (중간): 클라이언트 인증 데이터(암호화됨) 계층 2 (내부): 실제 LeaseSet2(I2P의 목적지 정보 데이터 구조) 데이터(암호화됨) 전체 구조:\nLayer 0 data + Enc(layer 1 data + Enc(layer 2 data)) + Signature 중요: Encrypted LS2는 blinded keys(블라인딩된 키)를 사용합니다. Destination은 헤더에 포함되지 않습니다. DHT 저장 위치는 SHA-256(sig type || blinded public key)이며, 매일 변경됩니다.\n레이어 0 (외부) - 평문 레이어 0은 표준 LS2 헤더를 사용하지 않습니다. 이는 blinded keys(블라인딩된 키: 원본 키를 숨기기 위해 변형한 키)에 최적화된 맞춤형 형식을 사용합니다.\n구조:\nField Size Description Type1 byteNot in header, from DatabaseStore message field Blinded Public Key Sig Type2 bytesBig endian, always 0x000b (Red25519 type 11) Blinded Public Key32 bytesRed25519 blinded public key Published Timestamp4 bytesBig endian, seconds since epoch (rolls over in 2106) Expires2 bytesBig endian, offset from published in seconds (max 65,535 \u0026asymp; 18.2 hours) Flags2 bytesBit flags (see below) [Optional] Transient Key DataVariablePresent if flag bit\u0026nbsp;0 is set lenOuterCiphertext2 bytesBig endian, length of outer ciphertext outerCiphertextlenOuterCiphertextEncrypted Layer\u0026nbsp;1 data Signature64 bytesRed25519 signature over all preceding data **Flags 필드(2바이트, 비트 15-0):** - **비트 0:** 오프라인 키 표시자 - `0` = 오프라인 키 없음 - `1` = 오프라인 키 존재(임시 키 데이터가 뒤따름) - **비트 1-15:** 예약됨, 향후 호환성을 위해 0이어야 함 임시 키 데이터 (플래그 비트 0 = 1인 경우에만 존재):\nField Size Description Expires Timestamp4 bytesBig endian, seconds since epoch Transient Sig Type2 bytesBig endian, signature type Transient Signing Public KeyVariableLength implied by signature type Signature64 bytesSigned by blinded public key; covers expires timestamp, transient sig type, and transient public key **서명 검증:** - **오프라인 키 없이:** 블라인드된 공개키로 검증 - **오프라인 키 사용:** 임시 공개키로 검증 서명은 Type부터 outerCiphertext까지의 모든 데이터를 포함한다(양 끝 포함).\n레이어 1 (중간) - 클라이언트 인가 복호화: 레이어 1 암호화 섹션을 참조하세요.\n구조:\nField Size Description Flags1 byteAuthorization flags (see below) [Optional] Auth DataVariablePresent based on flags innerCiphertextVariableEncrypted Layer\u0026nbsp;2 data (remainder) **플래그 필드(1바이트, 비트 7-0):** - **비트 0:** 인가 모드 - `0` = 클라이언트별 인가 없음(모두 허용) - `1` = 클라이언트별 인가(인가 섹션이 뒤따름) - **비트 3-1:** 인증 방식(비트 0 = 1인 경우에만) - `000` = DH 클라이언트 인증 - `001` = PSK 클라이언트 인증 - 기타 값은 예약됨 - **비트 7-4:** 사용되지 않음, 0이어야 함 DH 클라이언트 인증 데이터 (플래그 = 0x01, 비트 3-1 = 000):\nField Size Description ephemeralPublicKey32 bytesServer's ephemeral X25519 public key clients2 bytesBig endian, number of client entries authClient[]40 bytes eachArray of client authorization entries **authClient(인증 클라이언트) 항목 (40바이트):** - `clientID_i`: 8바이트 - `clientCookie_i`: 32바이트 (암호화된 authCookie(인증 쿠키)) PSK 클라이언트 인증 데이터 (플래그 = 0x03, 비트 3-1 = 001):\nField Size Description authSalt32 bytesSalt for PSK key derivation clients2 bytesBig endian, number of client entries authClient[]40 bytes eachArray of client authorization entries **authClient 항목 (40바이트):** - `clientID_i`: 8바이트 - `clientCookie_i`: 32바이트 (암호화된 authCookie) 레이어 2 (내부) - LeaseSet 데이터 복호화: Layer 2 Encryption 섹션을 참조하세요.\n구조:\nField Size Description Type1 byte3 (LS2) or 7 (Meta LS2) DataVariableComplete LeaseSet2 or MetaLeaseSet2 내부 계층에는 다음을 포함한 전체 LeaseSet2(2세대 LeaseSet 형식) 구조체가 포함됩니다: - LS2 헤더 - Lease 정보 - LS2 서명 검증 요구 사항: 복호화 후, 구현은 다음을 검증해야 합니다: 1. 내부 타임스탬프가 외부에 게시된 타임스탬프와 일치함 2. 내부 만료 시간이 외부 만료 시간과 일치함 3. LS2 서명이 유효함 4. Lease(I2P에서 tunnel 엔드포인트 정보를 담는 항목) 데이터가 올바른 형식임\n참고 자료: - 공통 구조 사양 - LeaseSet2(I2P의 차세대 leaseSet 형식) 형식 상세\n블라인딩 키 파생 개요 I2P는 Ed25519와 ZCash RedDSA를 기반으로 한 가법적 키 블라인딩(additive key blinding) 방식을 사용한다. 전방향 기밀성을 위해 블라인딩된 키는 매일(UTC 자정)에 교체된다.\n설계 근거:\nI2P는 Tor의 rend-spec-v3.txt Appendix A.2 접근 방식을 사용하지 않기로 명시적으로 선택했다. 명세에 따르면:\n\u0026ldquo;우리는 유사한 설계 목표를 가진 Tor의 rend-spec-v3.txt 부록 A.2를 사용하지 않는다. 그 방식의 블라인딩된 공개키가 소수 차수 부분군(prime-order subgroup)에 속하지 않을 수 있으며, 이에 따른 보안상의 영향은 알려져 있지 않기 때문이다.\u0026rdquo;\nI2P의 additive blinding(덧셈형 블라인딩)은 블라인딩된 키가 Ed25519 곡선의 소수 차수 부분군에 머무르도록 보장합니다.\n수학적 정의 Ed25519 매개변수: - B: Ed25519의 기저점(생성원) = 2^255 - 19 - L: Ed25519의 위수 = 2^252 + 27742317777372353535851937790883648493\n주요 변수: - A: 블라인드 해제된 32바이트 서명 공개키 (Destination(목적지) 내) - a: 블라인드 해제된 32바이트 서명 개인키 - A': 블라인드 처리된 32바이트 서명 공개키 (암호화된 LeaseSet에서 사용됨) - a': 블라인드 처리된 32바이트 서명 개인키 - alpha: 32바이트 블라인딩 팩터 (비밀)\n도우미 함수:\nLEOS2IP(x) \u0026ldquo;리틀 엔디언 옥텟 문자열을 정수로 변환\u0026rdquo;\n바이트 배열을 리틀 엔디언에서 정수 표현으로 변환합니다.\nH*(x) \u0026ldquo;해시와 환원\u0026rdquo;\nH*(x) = (LEOS2IP(SHA512(x))) mod L Ed25519(타원곡선 디지털 서명 알고리즘) 키 생성과 동일한 연산입니다.\n알파 생성 일일 로테이션: 새로운 alpha(알파 값) 및 blinded keys(블라인딩 처리된 키)는 매일 UTC 자정(00:00:00 UTC)에 반드시 생성되어야 한다.\nGENERATE_ALPHA(destination, date, secret) 알고리즘:\n# Input parameters A = destination\u0026#39;s signing public key (32 bytes) stA = signature type of A (2 bytes, big endian) # 0x0007 for Ed25519 or 0x000b for Red25519 stA\u0026#39; = signature type of blinded key A\u0026#39; (2 bytes, big endian) # Always 0x000b (Red25519) datestring = \u0026#34;YYYYMMDD\u0026#34; (8 bytes ASCII from current UTC date) secret = optional UTF-8 encoded string (zero-length if not used) # Computation keydata = A || stA || stA\u0026#39; # 36 bytes total seed = HKDF( salt=H(\u0026#34;I2PGenerateAlpha\u0026#34;, keydata), ikm=datestring || secret, info=\u0026#34;i2pblinding1\u0026#34;, n=64 ) # Treat seed as 64-byte little-endian integer and reduce alpha = seed mod L 검증된 매개변수: - 솔트 개인화: \u0026ldquo;I2PGenerateAlpha\u0026rdquo; - HKDF(HMAC 기반 키 유도 함수) 정보: \u0026ldquo;i2pblinding1\u0026rdquo; - 출력: mod L 적용 전 64바이트 - Alpha 분포: mod L 적용 후 Ed25519 개인 키와 동일한 분포\n개인키 블라인딩 BLIND_PRIVKEY(a, alpha) 알고리즘:\n암호화된 LeaseSet을 게시하는 목적지 소유자의 경우:\n# For Ed25519 private key (type 7) if sigtype == 7: seed = destination\u0026#39;s signing private key (32 bytes) a = left_half(SHA512(seed)) # 32 bytes a = clamp(a) # Ed25519 clamping # For Red25519 private key (type 11) elif sigtype == 11: a = destination\u0026#39;s signing private key (32 bytes) # No clamping for Red25519 # Additive blinding using scalar arithmetic blinded_privkey = a\u0026#39; = (a + alpha) mod L # Derive blinded public key blinded_pubkey = A\u0026#39; = DERIVE_PUBLIC(a\u0026#39;) 중요: 개인 키와 공개 키 사이의 올바른 대수적 관계를 유지하려면 mod L 환원이 필수적입니다.\n공개 키 블라인딩 BLIND_PUBKEY(A, alpha) 알고리즘:\n암호화된 LeaseSet을 조회하고 검증하는 클라이언트의 경우:\nalpha = GENERATE_ALPHA(destination, date, secret) A = destination\u0026#39;s signing public key (32 bytes) # Additive blinding using group elements (curve points) blinded_pubkey = A\u0026#39; = A + DERIVE_PUBLIC(alpha) 수학적 동치:\n두 방법 모두 동일한 결과를 산출합니다:\nBLIND_PUBKEY(A, alpha) == DERIVE_PUBLIC(BLIND_PRIVKEY(a, alpha)) 그 이유는 다음과 같습니다:\nA\u0026#39; = A + [alpha]B = [a]B + [alpha]B = [a + alpha]B (group operation) = DERIVE_PUBLIC(a + alpha mod L) Blinded Keys(블라인딩된 키)를 사용한 서명 블라인딩 해제된 LeaseSet 서명:\n블라인드되지 않은 LeaseSet(인증된 클라이언트에게 직접 전송됨)은 다음을 사용해 서명됩니다: - 표준 Ed25519(유형 7) 또는 Red25519(유형 11) 서명 - 블라인드되지 않은 서명용 개인 키 - 블라인드되지 않은 공개 키로 검증됨\n오프라인 키 사용 시: - 블라인드 해제된 임시 개인 키로 서명 - 블라인드 해제된 임시 공개 키로 검증 - 둘 다 타입 7 또는 11이어야 함\n암호화된 LeaseSet 서명:\n암호화된 LeaseSet의 외부 부분은 blinded keys(블라인딩된 키)와 함께 Red25519 서명을 사용합니다.\nRed25519 서명 알고리즘:\n# Generate per-signature random nonce T = CSRNG(80) # 80 random bytes # Calculate r (differs from Ed25519) r = H*(T || blinded_pubkey || message) # Rest is same as Ed25519 R = [r]B S = (r + H(R || A\u0026#39; || message) * a\u0026#39;) mod L signature = R || S # 64 bytes total Ed25519와의 주요 차이점: 1. 개인 키의 해시가 아니라 80바이트의 임의 데이터 T를 사용 2. 공개 키 값을 직접 사용 (개인 키의 해시가 아님) 3. 동일한 메시지와 키에 대해서도 각 서명은 고유함\n검증:\nEd25519와 동일:\n# Parse signature R = signature[0:32] S = signature[32:64] # Verify equation: [S]B = R + [H(R || A\u0026#39; || message)]A\u0026#39; return [S]B == R + [H(R || A\u0026#39; || message)]A\u0026#39; 보안 고려사항 알파 배포:\n보안을 위해, alpha는 블라인딩되지 않은 개인 키와 동일한 분포여야 합니다. Ed25519(type 7)을 Red25519(type 11)로 블라인딩할 때, 분포가 약간 달라집니다.\n권장사항: ZCash 요구사항을 충족하기 위해 언블라인드 키와 블라인드 키 모두에 Red25519 (type 11)를 사용하십시오: \u0026ldquo;재랜덤화된 공개키와 해당 키로 생성된 서명(들)의 조합은 그것이 재랜덤화되기 전의 원래 키를 드러내지 않는다.\u0026rdquo;\nType 7 지원: Ed25519는 기존 Destination(목적지)과의 하위 호환성을 위해 지원되지만, 새로운 암호화된 Destination에는 type 11을 권장합니다.\n일일 로테이션의 이점: - 전방향 기밀성: 오늘의 블라인딩된 키가 탈취되더라도 어제의 것은 노출되지 않음 - 비연결성: 일일 로테이션은 DHT(분산 해시 테이블)를 통한 장기 추적을 방지 - 키 분리: 기간별로 서로 다른 키 사용\n참고 자료: - Zcash 프로토콜 사양서 - 섹션 5.4.6.1 - Tor 키 블라인딩 논의 - Tor 티켓 #8106 암호화 및 처리 하위 자격 증명 파생 암호화 전에, 암호화된 레이어가 Destination(I2P 목적지)의 서명 공개 키에 대한 지식에 결속되도록 자격 증명과 하위 자격 증명을 유도한다.\n목표: Destination(I2P 목적지 식별자)의 서명 공개키를 아는 사람만 암호화된 LeaseSet을 복호화할 수 있도록 한다. 전체 Destination은 필요하지 않다.\n자격 증명 계산 A = destination\u0026#39;s signing public key (32 bytes) stA = signature type of A (2 bytes big endian) # 0x0007 for Ed25519 or 0x000b for Red25519 stA\u0026#39; = signature type of blinded key A\u0026#39; (2 bytes big endian) # Always 0x000b (Red25519) keydata = A || stA || stA\u0026#39; # 36 bytes credential = H(\u0026#34;credential\u0026#34;, keydata) # 32 bytes 도메인 분리: credential 개인화 문자열은 이 해시가 DHT 조회 키나 다른 프로토콜 사용과 충돌하지 않도록 보장합니다.\nSubcredential(하위 자격 증명) 계산 blindedPublicKey = A\u0026#39; (32 bytes, from blinding process) subcredential = H(\u0026#34;subcredential\u0026#34;, credential || blindedPublicKey) # 32 bytes 목적: subcredential(하위 자격 증명)은 암호화된 LeaseSet을 다음에 바인딩합니다: 1. 특정 Destination(목적지) (credential(자격 증명)을 통해) 2. 특정 blinded key(블라인드된 키) (blindedPublicKey를 통해) 3. 특정 날짜 (blindedPublicKey의 일일 로테이션을 통해)\n이는 재전송 공격과 서로 다른 날짜 간의 연계(링킹)를 방지합니다.\n레이어 1 암호화 컨텍스트: 레이어 1에는 클라이언트 인가 데이터가 포함되어 있으며, subcredential(하위 자격 증명)에서 유도된 키로 암호화됩니다.\n암호화 알고리즘 # Prepare input outerInput = subcredential || publishedTimestamp # publishedTimestamp: 4 bytes from Layer 0 # Generate random salt outerSalt = CSRNG(32) # 32 bytes # Derive encryption key and IV keys = HKDF( salt=outerSalt, ikm=outerInput, info=\u0026#34;ELS2_L1K\u0026#34;, # Domain separation n=44 # 32 bytes key + 12 bytes IV ) outerKey = keys[0:31] # 32 bytes (indices 0-31 inclusive) outerIV = keys[32:43] # 12 bytes (indices 32-43 inclusive) # Encrypt and prepend salt outerPlaintext = [Layer 1 data] outerCiphertext = outerSalt || ENCRYPT(outerKey, outerIV, outerPlaintext) 출력: outerCiphertext는 32 + len(outerPlaintext) 바이트입니다.\n보안 속성: - Salt(해시 등에 추가하는 임의값)은 동일한 subcredential(하위 자격 증명)이어도 고유한 키/IV(초기화 벡터) 쌍을 보장함 - 컨텍스트 문자열 \u0026quot;ELS2_L1K\u0026quot;은 도메인 분리를 제공함 - ChaCha20은 의미론적 안전성(암호문이 난수와 구분되지 않음)을 제공함\n복호화 알고리즘 # Parse salt from ciphertext outerSalt = outerCiphertext[0:31] # First 32 bytes # Derive decryption key and IV (same process as encryption) outerInput = subcredential || publishedTimestamp keys = HKDF( salt=outerSalt, ikm=outerInput, info=\u0026#34;ELS2_L1K\u0026#34;, n=44 ) outerKey = keys[0:31] # 32 bytes outerIV = keys[32:43] # 12 bytes # Decrypt (skip salt bytes) outerPlaintext = DECRYPT(outerKey, outerIV, outerCiphertext[32:end]) 검증: 복호화 후 레이어 1 구조가 올바른 형식인지 검증한 다음 레이어 2로 진행하십시오.\n2계층 암호화 맥락: 레이어 2에는 실제 LeaseSet2 데이터가 포함되어 있으며, 클라이언트별 인증이 활성화된 경우 authCookie에서 파생된 키로, 그렇지 않으면 빈 문자열에서 파생된 키로 암호화된다.\n암호화 알고리즘 # Determine authCookie based on authorization mode if per_client_auth_enabled: authCookie = [32-byte cookie from client authorization process] else: authCookie = b\u0026#39;\u0026#39; # Zero-length byte array # Prepare input innerInput = authCookie || subcredential || publishedTimestamp # Generate random salt innerSalt = CSRNG(32) # 32 bytes # Derive encryption key and IV keys = HKDF( salt=innerSalt, ikm=innerInput, info=\u0026#34;ELS2_L2K\u0026#34;, # Domain separation n=44 # 32 bytes key + 12 bytes IV ) innerKey = keys[0:31] # 32 bytes innerIV = keys[32:43] # 12 bytes # Encrypt and prepend salt innerPlaintext = [Layer 2 data: LS2 type byte + LeaseSet2 data] innerCiphertext = innerSalt || ENCRYPT(innerKey, innerIV, innerPlaintext) 출력: innerCiphertext는 32 + len(innerPlaintext) 바이트입니다.\n키 바인딩: - 클라이언트 인증이 없는 경우: subcredential(하위 자격증명)과 타임스탬프에만 바인딩됨 - 클라이언트 인증이 활성화된 경우: authCookie에도 추가로 바인딩됨(승인된 각 클라이언트마다 다름)\n복호화 알고리즘 # Determine authCookie (same as encryption) if per_client_auth_enabled: authCookie = [32-byte cookie from client authorization process] else: authCookie = b\u0026#39;\u0026#39; # Zero-length byte array # Parse salt from ciphertext innerSalt = innerCiphertext[0:31] # First 32 bytes # Derive decryption key and IV innerInput = authCookie || subcredential || publishedTimestamp keys = HKDF( salt=innerSalt, ikm=innerInput, info=\u0026#34;ELS2_L2K\u0026#34;, n=44 ) innerKey = keys[0:31] # 32 bytes innerIV = keys[32:43] # 12 bytes # Decrypt (skip salt bytes) innerPlaintext = DECRYPT(innerKey, innerIV, innerCiphertext[32:end]) 검증: 복호화 후: 1. LS2 타입 바이트가 유효한지 검증 (3 또는 7) 2. LeaseSet2 구조를 파싱 3. 내부 타임스탬프가 외부 게시된 타임스탬프와 일치하는지 검증 4. 내부 만료 시간이 외부 만료 시간과 일치하는지 검증 5. LeaseSet2 서명을 검증\n암호화 계층 요약 ┌─────────────────────────────────────────────────┐ │ Layer 0 (Plaintext) │ │ - Blinded public key │ │ - Timestamps │ │ - Signature │ │ │ │ ┌─────────────────────────────────────────┐ │ │ │ Layer 1 (Encrypted with subcredential) │ │ │ │ - Authorization flags │ │ │ │ - Client auth data (if enabled) │ │ │ │ │ │ │ │ ┌────────────────────────────────┐ │ │ │ │ │ Layer 2 (Encrypted with │ │ │ │ │ │ authCookie + subcred) │ │ │ │ │ │ - LeaseSet2 type │ │ │ │ │ │ - LeaseSet2 data │ │ │ │ │ │ - Leases │ │ │ │ │ │ - LS2 signature │ │ │ │ │ └────────────────────────────────┘ │ │ │ └─────────────────────────────────────────┘ │ └─────────────────────────────────────────────────┘ 복호화 절차: 1. 블라인드된 공개키로 레이어 0 서명을 검증 2. 하위 자격 증명(subcredential)을 사용하여 레이어 1을 복호화 3. 인가 데이터(있는 경우)를 처리하여 authCookie를 획득 4. authCookie와 하위 자격 증명을 사용하여 레이어 2를 복호화 5. LeaseSet2를 검증하고 구문 분석\n클라이언트별 권한 부여 개요 클라이언트별 인가가 활성화되면, 서버는 인가된 클라이언트 목록을 유지합니다. 각 클라이언트는 out-of-band(별도 경로)로 안전하게 전송되어야 하는 키 자료를 보유합니다.\n두 가지 인가 메커니즘: 1. DH (Diffie-Hellman) 클라이언트 인가: 더 안전하며, X25519 키 합의를 사용합니다 2. PSK (사전 공유 키) 인가: 더 단순하며, 대칭 키를 사용합니다\n공통 보안 속성: - 클라이언트 구성원 프라이버시: 관찰자는 클라이언트 수는 볼 수 있지만 특정 클라이언트를 식별할 수 없음 - 익명 클라이언트 추가/철회: 특정 클라이언트가 언제 추가되거나 제거되는지 추적할 수 없음 - 8바이트 클라이언트 식별자 충돌 확률: ~18퀸틸리언(1.8×10^19)분의 1(무시 가능한 수준)\nDH(디피-헬먼) 클라이언트 인가 개요: 각 클라이언트는 X25519 키 쌍을 생성하고 자신의 공개 키를 보안 대역외 채널을 통해 서버로 전송한다. 서버는 ephemeral DH(일시적 디피-헬먼 키 교환)를 사용해 각 클라이언트마다 고유한 authCookie를 암호화한다.\n클라이언트 키 생성 # Client generates keypair csk_i = GENERATE_PRIVATE() # 32-byte X25519 private key cpk_i = DERIVE_PUBLIC(csk_i) # 32-byte X25519 public key # Client sends cpk_i to server via secure out-of-band channel # Client KEEPS csk_i secret (never transmitted) 보안상의 이점: 클라이언트의 개인 키는 사용자의 장치를 절대 떠나지 않는다. 대역 외(out-of-band) 전송을 가로채는 공격자라도 X25519 DH를 깨뜨리지 않는 한, 향후 암호화된 LeaseSets를 복호화할 수 없다.\n서버 처리 # Server generates new auth cookie and ephemeral keypair authCookie = CSRNG(32) # 32-byte cookie esk = GENERATE_PRIVATE() # 32-byte ephemeral private key epk = DERIVE_PUBLIC(esk) # 32-byte ephemeral public key # For each authorized client i for cpk_i in authorized_clients: # Perform DH key agreement sharedSecret = DH(esk, cpk_i) # 32 bytes # Derive client-specific encryption key authInput = sharedSecret || cpk_i || subcredential || publishedTimestamp okm = HKDF( salt=epk, # Ephemeral public key as salt ikm=authInput, info=\u0026#34;ELS2_XCA\u0026#34;, # Domain separation n=52 # 32 key + 12 IV + 8 ID ) # Extract components clientKey_i = okm[0:31] # 32 bytes clientIV_i = okm[32:43] # 12 bytes clientID_i = okm[44:51] # 8 bytes # Encrypt authCookie for this client clientCookie_i = ENCRYPT(clientKey_i, clientIV_i, authCookie) # Store [clientID_i, clientCookie_i] entry in Layer 1 계층 1 데이터 구조:\nephemeralPublicKey (32 bytes) clients (2 bytes) = N [clientID_1 (8 bytes) || clientCookie_1 (32 bytes)] [clientID_2 (8 bytes) || clientCookie_2 (32 bytes)] ... [clientID_N (8 bytes) || clientCookie_N (32 bytes)] 서버 권장 사항: - 게시되는 각 암호화된 LeaseSet마다 새로운 임시 키 쌍을 생성하세요 - 위치 기반 추적을 방지하기 위해 클라이언트 순서를 무작위로 섞으세요 - 실제 클라이언트 수를 숨기기 위해 더미 항목을 추가하는 것을 고려하세요\n클라이언트 처리 # Client has: csk_i (their private key), destination, date, secret # Client receives: encrypted LeaseSet with epk in Layer 1 # Perform DH key agreement with server\u0026#39;s ephemeral public key sharedSecret = DH(csk_i, epk) # 32 bytes # Derive expected client identifier and decryption key cpk_i = DERIVE_PUBLIC(csk_i) # Client\u0026#39;s own public key authInput = sharedSecret || cpk_i || subcredential || publishedTimestamp okm = HKDF( salt=epk, ikm=authInput, info=\u0026#34;ELS2_XCA\u0026#34;, n=52 ) clientKey_i = okm[0:31] # 32 bytes clientIV_i = okm[32:43] # 12 bytes clientID_i = okm[44:51] # 8 bytes # Search Layer 1 authorization data for clientID_i for (clientID, clientCookie) in layer1_auth_entries: if clientID == clientID_i: # Found matching entry, decrypt authCookie authCookie = DECRYPT(clientKey_i, clientIV_i, clientCookie) # Use authCookie to decrypt Layer 2 break else: # No matching entry - client not authorized or revoked raise AuthorizationError(\u0026#34;Client not authorized\u0026#34;) 클라이언트 오류 처리: - clientID_i를 찾을 수 없는 경우: 클라이언트 권한이 해지되었거나 처음부터 승인되지 않음 - 복호화에 실패한 경우: 데이터 손상 또는 잘못된 키(매우 드뭄) - 해지 여부를 감지하기 위해 클라이언트는 주기적으로 다시 가져와야 함\nPSK 클라이언트 인가 개요: 각 클라이언트는 사전 공유된 32바이트 대칭 키를 보유합니다. 서버는 각 클라이언트의 PSK(사전 공유 키)를 사용하여 동일한 authCookie를 암호화합니다.\n키 생성 # Option 1: Client generates key psk_i = CSRNG(32) # 32-byte pre-shared key # Client sends psk_i to server via secure out-of-band channel # Option 2: Server generates key psk_i = CSRNG(32) # 32-byte pre-shared key # Server sends psk_i to one or more clients via secure out-of-band channel 보안 참고: 원한다면 동일한 PSK(사전 공유 키)를 여러 클라이언트가 공유할 수 있습니다(“그룹” 인가를 생성합니다).\n서버 처리 # Server generates new auth cookie and salt authCookie = CSRNG(32) # 32-byte cookie authSalt = CSRNG(32) # 32-byte salt # For each authorized client i for psk_i in authorized_clients: # Derive client-specific encryption key authInput = psk_i || subcredential || publishedTimestamp okm = HKDF( salt=authSalt, ikm=authInput, info=\u0026#34;ELS2PSKA\u0026#34;, # Domain separation n=52 # 32 key + 12 IV + 8 ID ) # Extract components clientKey_i = okm[0:31] # 32 bytes clientIV_i = okm[32:43] # 12 bytes clientID_i = okm[44:51] # 8 bytes # Encrypt authCookie for this client clientCookie_i = ENCRYPT(clientKey_i, clientIV_i, authCookie) # Store [clientID_i, clientCookie_i] entry in Layer 1 계층 1 데이터 구조:\nauthSalt (32 bytes) clients (2 bytes) = N [clientID_1 (8 bytes) || clientCookie_1 (32 bytes)] [clientID_2 (8 bytes) || clientCookie_2 (32 bytes)] ... [clientID_N (8 bytes) || clientCookie_N (32 bytes)] 클라이언트 처리 # Client has: psk_i (their pre-shared key), destination, date, secret # Client receives: encrypted LeaseSet with authSalt in Layer 1 # Derive expected client identifier and decryption key authInput = psk_i || subcredential || publishedTimestamp okm = HKDF( salt=authSalt, ikm=authInput, info=\u0026#34;ELS2PSKA\u0026#34;, n=52 ) clientKey_i = okm[0:31] # 32 bytes clientIV_i = okm[32:43] # 12 bytes clientID_i = okm[44:51] # 8 bytes # Search Layer 1 authorization data for clientID_i for (clientID, clientCookie) in layer1_auth_entries: if clientID == clientID_i: # Found matching entry, decrypt authCookie authCookie = DECRYPT(clientKey_i, clientIV_i, clientCookie) # Use authCookie to decrypt Layer 2 break else: # No matching entry - client not authorized or revoked raise AuthorizationError(\u0026#34;Client not authorized\u0026#34;) 비교 및 권장 사항 Feature DH Authorization PSK Authorization Key ExchangeAsymmetric (X25519)Symmetric (shared secret) SecurityHigher (forward secrecy)Lower (depends on PSK secrecy) Client PrivacyPrivate key never transmittedPSK must be transmitted securely PerformanceN+1 DH operationsNo DH operations Key SharingOne key per clientCan share key among multiple clients Revocation DetectionAdversary cannot tell when revokedAdversary can track revocation if PSK intercepted Use CaseHigh security requirementsPerformance-critical or group access **권장 사항:** - **DH authorization(Diffie-Hellman 기반 인가) 사용** forward secrecy(순방향 기밀성)가 중요한 고보안 애플리케이션의 경우 - **PSK authorization(사전 공유 키 기반 인가) 사용** 성능이 중요하거나 클라이언트 그룹을 관리해야 하는 경우 - **PSK를 절대 재사용하지 말 것** 서로 다른 서비스나 기간에 걸쳐 - **항상 보안 채널 사용** 키 배포 시 (예: Signal, OTR, PGP) 보안 고려 사항 클라이언트 구성원 프라이버시:\n두 메커니즘은 다음을 통해 클라이언트 멤버십의 프라이버시를 제공합니다: 1. 암호화된 클라이언트 식별자: HKDF(키 유도 함수) 출력에서 파생된 8바이트 clientID 2. 구분 불가능한 쿠키: 모든 32바이트 clientCookie 값은 무작위로 보임 3. 클라이언트별 메타데이터 없음: 어떤 항목이 어느 클라이언트에 속하는지 식별할 방법이 없음\n관찰자는 다음을 확인할 수 있습니다: - 허가된 클라이언트 수(clients 필드에서) - 시간 경과에 따른 클라이언트 수 변화\n관찰자는 다음을 볼 수 없습니다: - 어떤 특정 클라이언트가 승인되었는지 - 특정 클라이언트가 언제 추가되거나 제거되었는지 (개수가 동일하게 유지되는 경우) - 클라이언트를 식별할 수 있는 모든 정보\n무작위화 권장 사항:\n서버는 암호화된 LeaseSet(I2P 목적지에 연결하기 위한 정보 집합)을 생성할 때마다 클라이언트 순서를 무작위화하는 것이 권장된다:\nimport random # Before serializing auth_entries = [(clientID_i, clientCookie_i) for each client] random.shuffle(auth_entries) # Now serialize in randomized order 장점: - 클라이언트가 목록 내에서 자신의 위치를 알아내는 것을 방지합니다 - 위치 변경에 기반한 추론 공격을 방지합니다 - 클라이언트 추가/철회를 구분할 수 없게 합니다\n클라이언트 수 숨기기:\n서버는 임의의 더미 항목을 삽입할 수 있다:\n# Add dummy entries num_dummies = random.randint(0, max_dummies) for _ in range(num_dummies): dummy_id = CSRNG(8) dummy_cookie = CSRNG(32) auth_entries.append((dummy_id, dummy_cookie)) # Randomize all entries (real + dummy) random.shuffle(auth_entries) 비용: 더미 엔트리는 암호화된 LeaseSet의 크기를 증가시킵니다(엔트리당 40바이트).\nAuthCookie 로테이션:\n서버는 새 authCookie(인증 쿠키)를 생성하는 것이 권장된다:\n암호화된 LeaseSet이 게시될 때마다(보통 몇 시간마다 한 번) 클라이언트의 권한을 취소한 직후 클라이언트 변경이 없더라도 정기 일정(예: 매일)에 맞춰 장점: - authCookie가 탈취되었을 때 노출 범위를 제한합니다 - 권한이 철회된 클라이언트가 신속히 접근 권한을 잃도록 보장합니다 - Layer 2에 대해 전방향 기밀성을 제공합니다\n암호화된 LeaseSets(I2P 목적지 접근 정보 세트)용 Base32 주소 체계 개요 기존의 I2P base32 주소는 Destination(목적지)의 해시만 포함합니다(32 바이트 → 52 문자). 이는 암호화된 LeaseSets에 대해 충분하지 않은데, 그 이유는:\n클라이언트가 블라인딩된 공개키를 파생시키려면 블라인딩되지 않은 공개키가 필요합니다 클라이언트는 적절한 키 파생을 위해 서명 유형(블라인딩되지 않은 것과 블라인딩된 것)이 필요합니다 해시만으로는 이 정보를 제공하지 않습니다 해결책: 공개 키와 서명 유형을 포함하는 새로운 base32 형식.\n주소 형식 사양 디코딩된 구조 (35바이트):\n┌─────────────────────────────────────────────────────┐ │ Byte 0 │ Byte 1 │ Byte 2 │ Bytes 3-34 │ │ Flags │ Unblind │ Blinded │ Public Key │ │ (XOR) │ SigType │ SigType │ (32 bytes) │ │ │ (XOR) │ (XOR) │ │ └─────────────────────────────────────────────────────┘ 첫 3바이트 (체크섬과 XOR(배타적 논리합)):\n처음 3바이트에는 CRC-32 체크섬의 일부와 XOR(배타적 논리합)된 메타데이터가 포함된다:\n# Data structure before XOR flags = 0x00 # 1 byte (reserved for future use) unblinded_sigtype = 0x07 or 0x0b # 1 byte (7 or 11) blinded_sigtype = 0x0b # 1 byte (always 11) # Compute CRC-32 checksum of public key checksum = crc32(pubkey) # 4-byte CRC-32 of bytes 3-34 # XOR first 3 bytes with parts of checksum data[0] = flags XOR (checksum \u0026gt;\u0026gt; 24) \u0026amp; 0xFF data[1] = unblinded_sigtype XOR (checksum \u0026gt;\u0026gt; 16) \u0026amp; 0xFF data[2] = blinded_sigtype XOR (checksum \u0026gt;\u0026gt; 8) \u0026amp; 0xFF # Bytes 3-34 contain the unmodified 32-byte public key data[3:34] = pubkey 체크섬 속성: - 표준 CRC-32 다항식을 사용 - 검출 실패 확률: 약 1/1,600만 - 주소 오타에 대한 오류 검출 기능 제공 - 인증 용도로는 사용할 수 없음(암호학적으로 안전하지 않음)\n인코딩된 형식:\nBase32Encode(35 bytes) || \u0026#34;.b32.i2p\u0026#34; 특징: - 총 문자 수: 56 (35바이트 × 8비트 ÷ 문자당 5비트) - 접미사: \u0026ldquo;.b32.i2p\u0026rdquo; (기존의 base32와 동일) - 총 길이: 56 + 8 = 64자 (널 종료 문자 제외)\nBase32 인코딩: - 알파벳: abcdefghijklmnopqrstuvwxyz234567 (RFC 4648 표준) - 끝의 사용되지 않는 5비트는 반드시 0이어야 함 - 대소문자 구분 없음 (관례적으로 소문자 사용)\n주소 생성 import struct from zlib import crc32 import base64 def generate_encrypted_b32_address(pubkey, unblinded_sigtype, blinded_sigtype): \u0026#34;\u0026#34;\u0026#34; Generate base32 address for encrypted LeaseSet. Args: pubkey: 32-byte public key (bytes) unblinded_sigtype: Unblinded signature type (7 or 11) blinded_sigtype: Blinded signature type (always 11) Returns: String address ending in .b32.i2p \u0026#34;\u0026#34;\u0026#34; # Verify inputs assert len(pubkey) == 32, \u0026#34;Public key must be 32 bytes\u0026#34; assert unblinded_sigtype in [7, 11], \u0026#34;Unblinded sigtype must be 7 or 11\u0026#34; assert blinded_sigtype == 11, \u0026#34;Blinded sigtype must be 11\u0026#34; # Compute CRC-32 of public key checksum = crc32(pubkey) \u0026amp; 0xFFFFFFFF # Ensure 32-bit unsigned # Prepare metadata bytes flags = 0x00 # XOR metadata with checksum parts byte0 = flags ^ ((checksum \u0026gt;\u0026gt; 24) \u0026amp; 0xFF) byte1 = unblinded_sigtype ^ ((checksum \u0026gt;\u0026gt; 16) \u0026amp; 0xFF) byte2 = blinded_sigtype ^ ((checksum \u0026gt;\u0026gt; 8) \u0026amp; 0xFF) # Construct 35-byte data data = bytes([byte0, byte1, byte2]) + pubkey # Base32 encode (standard alphabet) # Python\u0026#39;s base64 module uses uppercase by default b32 = base64.b32encode(data).decode(\u0026#39;ascii\u0026#39;).lower().rstrip(\u0026#39;=\u0026#39;) # Construct full address address = b32 + \u0026#34;.b32.i2p\u0026#34; return address 주소 파싱 import struct from zlib import crc32 import base64 def parse_encrypted_b32_address(address): \u0026#34;\u0026#34;\u0026#34; Parse base32 address for encrypted LeaseSet. Args: address: String address ending in .b32.i2p Returns: Tuple of (pubkey, unblinded_sigtype, blinded_sigtype) Raises: ValueError: If address is invalid or checksum fails \u0026#34;\u0026#34;\u0026#34; # Remove suffix if not address.endswith(\u0026#39;.b32.i2p\u0026#39;): raise ValueError(\u0026#34;Invalid address suffix\u0026#34;) b32 = address[:-8] # Remove \u0026#34;.b32.i2p\u0026#34; # Verify length (56 characters for 35 bytes) if len(b32) != 56: raise ValueError(f\u0026#34;Invalid length: {len(b32)} (expected 56)\u0026#34;) # Base32 decode # Add padding if needed padding_needed = (8 - (len(b32) % 8)) % 8 b32_padded = b32.upper() + \u0026#39;=\u0026#39; * padding_needed try: data = base64.b32decode(b32_padded) except Exception as e: raise ValueError(f\u0026#34;Invalid base32 encoding: {e}\u0026#34;) # Verify decoded length if len(data) != 35: raise ValueError(f\u0026#34;Invalid decoded length: {len(data)} (expected 35)\u0026#34;) # Extract public key pubkey = data[3:35] # Compute CRC-32 for verification checksum = crc32(pubkey) \u0026amp; 0xFFFFFFFF # Un-XOR metadata bytes flags = data[0] ^ ((checksum \u0026gt;\u0026gt; 24) \u0026amp; 0xFF) unblinded_sigtype = data[1] ^ ((checksum \u0026gt;\u0026gt; 16) \u0026amp; 0xFF) blinded_sigtype = data[2] ^ ((checksum \u0026gt;\u0026gt; 8) \u0026amp; 0xFF) # Verify expected values if flags != 0x00: raise ValueError(f\u0026#34;Invalid flags: {flags:#x} (expected 0x00)\u0026#34;) if unblinded_sigtype not in [7, 11]: raise ValueError(f\u0026#34;Invalid unblinded sigtype: {unblinded_sigtype} (expected 7 or 11)\u0026#34;) if blinded_sigtype != 11: raise ValueError(f\u0026#34;Invalid blinded sigtype: {blinded_sigtype} (expected 11)\u0026#34;) return pubkey, unblinded_sigtype, blinded_sigtype 기존 Base32와의 비교 Feature Traditional B32 Encrypted LS2 B32 ContentSHA-256 hash of DestinationPublic key + signature types Decoded Size32 bytes35 bytes Encoded Length52 characters56 characters Suffix.b32.i2p.b32.i2p Total Length60 chars64 chars ChecksumNoneCRC-32 (XOR'd into first 3 bytes) Use CaseRegular destinationsEncrypted LeaseSet destinations ### 이용 제한 BitTorrent 비호환성:\n암호화된 LS2 주소는 BitTorrent의 compact announce 응답과 함께 사용할 수 없습니다:\nCompact announce reply format: ┌────────────────────────────┐ │ 32-byte destination hash │ ← Only hash, no signature types │ 2-byte port │ └────────────────────────────┘ 문제: Compact format(간결한 형식)에는 해시(32바이트)만 포함되어 있어 서명 유형이나 공개 키 정보를 위한 공간이 없습니다.\n해결 방법: 전체 announce 응답을 사용하거나 전체 주소를 지원하는 HTTP 기반 트래커를 사용하세요.\n주소록 통합 만약 클라이언트가 주소록에 전체 Destination(목적지)을 가지고 있다면:\n공개키를 포함한 전체 Destination(목적지)를 저장 해시를 통한 역방향 조회 지원 암호화된 LS2(leaseSet 2형식)를 만났을 때 주소록에서 공개키 가져오기 전체 Destination을 이미 알고 있다면 새로운 base32 형식이 필요 없음 암호화된 LS2(LeaseSet2)를 지원하는 주소록 형식: - 전체 destination 문자열이 포함된 hosts.txt - destination 열이 있는 SQLite 데이터베이스 - 전체 destination 데이터가 포함된 JSON/XML 형식\n구현 예시 예제 1: 주소 생성\n# Ed25519 destination example pubkey = bytes.fromhex(\u0026#39;a\u0026#39; * 64) # 32-byte public key unblinded_type = 7 # Ed25519 blinded_type = 11 # Red25519 (always) address = generate_encrypted_b32_address(pubkey, unblinded_type, blinded_type) print(f\u0026#34;Address: {address}\u0026#34;) # Output: 56 base32 characters + .b32.i2p 예제 2: 파싱 및 검증\naddress = \u0026#34;abc...xyz.b32.i2p\u0026#34; # 56 chars + suffix try: pubkey, unblinded, blinded = parse_encrypted_b32_address(address) print(f\u0026#34;Public Key: {pubkey.hex()}\u0026#34;) print(f\u0026#34;Unblinded SigType: {unblinded}\u0026#34;) print(f\u0026#34;Blinded SigType: {blinded}\u0026#34;) except ValueError as e: print(f\u0026#34;Invalid address: {e}\u0026#34;) 예제 3: Destination(목적지: I2P의 엔드포인트 식별자)에서 변환\ndef destination_to_encrypted_b32(destination): \u0026#34;\u0026#34;\u0026#34; Convert full Destination to encrypted LS2 base32 address. Args: destination: I2P Destination object Returns: Base32 address string \u0026#34;\u0026#34;\u0026#34; # Extract public key and signature type from destination pubkey = destination.signing_public_key # 32 bytes sigtype = destination.sig_type # 7 or 11 # Blinded type is always 11 (Red25519) blinded_type = 11 # Generate address return generate_encrypted_b32_address(pubkey, sigtype, blinded_type) 보안 고려사항 프라이버시: - Base32 주소는 공개키를 드러냅니다 - 이는 의도된 동작이며 프로토콜에서 요구됩니다 - 개인키를 드러내거나 보안을 훼손하지는 않습니다 - 공개키는 설계상 공개 정보입니다\n충돌 저항성: - CRC-32의 충돌 저항성은 32비트에 불과함 - 암호학적으로 안전하지 않음(오류 검출에만 사용) - 인증을 위해 체크섬에 절대 의존하지 말 것 - 완전한 목적지 검증은 여전히 필요함\n주소 검증: - 사용 전에 항상 체크섬을 검증할 것 - 유효하지 않은 서명 유형의 주소는 거부할 것 - 공개 키가 타원 곡선 상에 있는지 확인할 것(구현별)\n참고 자료: - 제안 149: 암호화된 LS2(leaseSet 2)용 B32 - B32 주소 지정 사양 - I2P 이름 지정 사양 오프라인 키 지원 개요 오프라인 키를 사용하면 주 서명 키를 오프라인 상태(cold storage; 오프라인 보관)로 유지하면서, 일상적인 운영에는 임시 서명 키를 사용할 수 있습니다. 이는 보안 수준이 높은 서비스에 매우 중요합니다.\n암호화된 LS2(LeaseSet2, I2P의 새로운 leaseSet 형식) 특정 요구 사항: - 임시 키는 오프라인에서 생성되어야 함 - 블라인딩된 개인 키는 사전 생성되어야 함(하루에 하나) - 임시 키와 블라인딩된 키 모두 일괄 전달 - 표준화된 파일 형식은 아직 정의되지 않음(명세에서 TODO)\n오프라인 키 구조 레이어 0 임시 키 데이터 (플래그 비트 0 = 1인 경우):\n┌───────────────────────────────────────────────────┐ │ Expires Timestamp │ 4 bytes (seconds) │ │ Transient Sig Type │ 2 bytes (big endian) │ │ Transient Signing Pubkey│ Variable (sigtype len) │ │ Signature (by blinded) │ 64 bytes (Red25519) │ └───────────────────────────────────────────────────┘ 서명 적용 범위: 오프라인 키 블록의 서명은 다음을 포함합니다: - 만료 타임스탬프 (4바이트) - 일시적 서명 유형 (2바이트) - 일시적 서명용 공개 키 (가변)\n이 서명은 블라인딩된 공개키를 사용해 검증되며, 블라인딩된 개인키를 보유한 엔티티가 이 임시 키를 승인했음을 증명합니다.\n키 생성 과정 오프라인 키를 사용하는 암호화된 LeaseSet의 경우:\n임시 키 쌍 생성 (오프라인, 콜드 스토리지에서):\n# For each day in future for date in future_dates: # Generate daily transient keypair transient_privkey = generate_red25519_privkey() # Type 11 transient_pubkey = derive_public(transient_privkey) # Store for later delivery keys[date] = (transient_privkey, transient_pubkey) Generate daily blinded keypairs (offline, in cold storage):\n각 날짜에 대해 for date in future_dates: # Derive alpha for this date datestring = date.strftime(\u0026quot;%Y%m%d\u0026quot;) # \u0026quot;YYYYMMDD\u0026quot; alpha = GENERATE_ALPHA(destination, datestring, secret) # Blind the signing private key a = destination_signing_privkey # Type 7 or 11 blinded_privkey = BLIND_PRIVKEY(a, alpha) # Result is type 11 blinded_pubkey = DERIVE_PUBLIC(blinded_privkey) # Store for later delivery blinded_keys[date] = (blinded_privkey, blinded_pubkey) 3. **Sign transient keys with blinded keys** (offline): ```python for date in future_dates: transient_pubkey = keys[date][1] blinded_privkey = blinded_keys[date][0] # Create signature data expires = int((date + timedelta(days=1)).timestamp()) sig_data = struct.pack(\u0026#39;\u0026gt;I\u0026#39;, expires) # 4 bytes sig_data += struct.pack(\u0026#39;\u0026gt;H\u0026#39;, 11) # Transient type (Red25519) sig_data += transient_pubkey # 32 bytes # Sign with blinded private key signature = RED25519_SIGN(blinded_privkey, sig_data) # Package for delivery offline_sig_blocks[date] = { \u0026#39;expires\u0026#39;: expires, \u0026#39;transient_type\u0026#39;: 11, \u0026#39;transient_pubkey\u0026#39;: transient_pubkey, \u0026#39;signature\u0026#39;: signature } Package for delivery to router: 각 날짜에 대해 delivery_package[date] = { 'transient_privkey': keys[date][0], 'transient_pubkey': keys[date][1], 'blinded_privkey': blinded_keys[date][0], 'blinded_pubkey': blinded_keys[date][1], 'offline_sig_block': offline_sig_blocks[date] }\n### Router Usage **Daily Key Loading:** ```python # UTC 자정(또는 게시 전에) date = datetime.utcnow().date() # 오늘의 키 불러오기 today_keys = load_delivery_package(date) transient_privkey = today_keys[\u0026#39;transient_privkey\u0026#39;] transient_pubkey = today_keys[\u0026#39;transient_pubkey\u0026#39;] blinded_privkey = today_keys[\u0026#39;blinded_privkey\u0026#39;] blinded_pubkey = today_keys[\u0026#39;blinded_pubkey\u0026#39;] offline_sig_block = today_keys[\u0026#39;offline_sig_block\u0026#39;] # 오늘의 암호화된 LeaseSet에는 이 키들을 사용하세요. Publishing Process:\n# 1. 내부 LeaseSet2 생성 inner_ls2 = create_leaseset2( destinations, leases, expires, signing_key=transient_privkey # Use transient key ) # 2. 2계층 암호화 layer2_ciphertext = encrypt_layer2(inner_ls2, authCookie, subcredential, timestamp) # 3. 인가 데이터와 함께 레이어 1 생성 layer1_plaintext = create_layer1(authorization_data, layer2_ciphertext) # 4. 레이어 1 암호화 layer1_ciphertext = encrypt_layer1(layer1_plaintext, subcredential, timestamp) # 5. 오프라인 서명 블록을 포함한 레이어 0 생성 layer0 = create_layer0( blinded_pubkey, timestamp, expires, flags=0x0001, # Bit 0 set (offline keys present) offline_sig_block=offline_sig_block, layer1_ciphertext=layer1_ciphertext ) # 6. 임시 개인 키로 레이어 0에 서명 signature = RED25519_SIGN(transient_privkey, layer0) # 7. 서명을 추가하고 게시 encrypted_leaseset = layer0 + signature publish_to_netdb(encrypted_leaseset) Security Considerations Tracking via Offline Signature Block:\nThe offline signature block is in plaintext (Layer 0). An adversary scraping floodfills could:\nTrack the same encrypted LeaseSet across multiple days Correlate encrypted LeaseSets even though blinded keys change daily Mitigation: Generate new transient keys daily (in addition to blinded keys):\n# 매일 새로운 임시 키와 새로운 블라인딩된 키를 모두 생성하십시오 for date in future_dates: # New transient keypair for this day transient_privkey = generate_red25519_privkey() transient_pubkey = derive_public(transient_privkey) # New blinded keypair for this day alpha = GENERATE_ALPHA(destination, datestring, secret) blinded_privkey = BLIND_PRIVKEY(signing_privkey, alpha) blinded_pubkey = DERIVE_PUBLIC(blinded_privkey) # Sign new transient key with new blinded key sig = RED25519_SIGN(blinded_privkey, transient_pubkey || metadata) # Now offline sig block changes daily Benefits:\nPrevents tracking across days via offline signature block Provides same security as encrypted LS2 without offline keys Each day appears completely independent Cost:\nMore keys to generate and store More complex key management File Format (TODO) Current Status: No standardized file format defined for batch key delivery.\nRequirements for Future Format:\nMust support multiple dates:\nBatch delivery of 30+ days worth of keys Clear date association for each key set Must include all necessary data:\nTransient private key Transient public key Blinded private key Blinded public key Pre-computed offline signature block Expiration timestamps Should be tamper-evident:\nChecksums or signatures over entire file Integrity verification before loading Should be encrypted:\nKeys are sensitive material Encrypt file with router\u0026rsquo;s key or passphrase Proposed Format Example (JSON, encrypted):\n{ \u0026#34;version\u0026#34;: 1, \u0026#34;destination_hash\u0026#34;: \u0026#34;base64...\u0026#34;, \u0026#34;keys\u0026#34;: [ { \u0026#34;date\u0026#34;: \u0026#34;2025-10-15\u0026#34;, \u0026#34;transient\u0026#34;: { \u0026#34;type\u0026#34;: 11, \u0026#34;privkey\u0026#34;: \u0026#34;base64...\u0026#34;, \u0026#34;pubkey\u0026#34;: \u0026#34;base64...\u0026#34; }, \u0026#34;blinded\u0026#34;: { \u0026#34;privkey\u0026#34;: \u0026#34;base64...\u0026#34;, \u0026#34;pubkey\u0026#34;: \u0026#34;base64...\u0026#34; }, \u0026#34;offline_sig_block\u0026#34;: { \u0026#34;expires\u0026#34;: 1729123200, \u0026#34;signature\u0026#34;: \u0026#34;base64...\u0026#34; } } ], \u0026#34;signature\u0026#34;: \u0026#34;base64...\u0026#34; // Signature over entire structure } I2CP Protocol Enhancement (TODO) Current Status: No I2CP protocol enhancement defined for offline keys with encrypted LeaseSet.\nRequirements:\nKey delivery mechanism:\nUpload batch of keys from client to router Acknowledgment of successful key loading Key expiration notification:\nRouter notifies client when keys running low Client can generate and upload new batch Key revocation:\nEmergency revocation of future keys if compromise suspected Proposed I2CP Messages:\nUPLOAD_OFFLINE_KEYS - 암호화된 키 자료 묶음 - 포함되는 날짜 범위 OFFLINE_KEY_STATUS - 남은 일수 - 다음 키 만료일 REVOKE_OFFLINE_KEYS - 폐기할 날짜 범위 - 대체할 새 키(선택 사항) Implementation Status Java I2P:\n✅ Offline keys for standard LS2: Fully supported (since 0.9.38) ⚠️ Offline keys for encrypted LS2: Implemented (since 0.9.40) ❌ File format: Not standardized ❌ I2CP protocol: Not enhanced i2pd (C++):\n✅ Offline keys for standard LS2: Fully supported ✅ Offline keys for encrypted LS2: Fully supported (since 2.58.0) ❌ File format: Not standardized ❌ I2CP protocol: Not enhanced References:\nOffline Signatures Proposal I2CP Specification Security Considerations Cryptographic Security Algorithm Selection:\nAll cryptographic primitives are based on well-studied algorithms:\nChaCha20: Modern stream cipher, constant-time, no timing attacks SHA-256: NIST-approved hash, 128-bit security level HKDF: RFC 5869 standard, proven security bounds Ed25519/Red25519: Curve25519-based, ~128-bit security level X25519: Diffie-Hellman over Curve25519, ~128-bit security level Key Sizes:\nAll symmetric keys: 256 bits (32 bytes) All public/private keys: 256 bits (32 bytes) All nonces/IVs: 96 bits (12 bytes) All signatures: 512 bits (64 bytes) These sizes provide adequate security margins against current and near-future attacks.\nForward Secrecy Daily Key Rotation:\nEncrypted LeaseSets rotate keys daily (UTC midnight):\nNew blinded public/private key pair New storage location in DHT New encryption keys for both layers Benefits:\nCompromising today\u0026rsquo;s blinded key doesn\u0026rsquo;t reveal yesterday\u0026rsquo;s Limits exposure window to 24 hours Prevents long-term tracking via DHT Enhanced with Ephemeral Keys:\nDH client authorization uses ephemeral keys:\nServer generates new ephemeral DH keypair for each publication Compromising ephemeral key only affects that publication True forward secrecy even if long-term keys compromised Privacy Properties Destination Blinding:\nThe blinded public key:\nIs unlinkable to the original destination (without knowing the secret) Changes daily, preventing long-term correlation Cannot be reversed to find the original public key Client Membership Privacy:\nPer-client authorization provides:\nAnonymity: No way to identify which clients are authorized Untraceability: Cannot track when specific clients added/revoked Size obfuscation: Can add dummy entries to hide true count DHT Privacy:\nStorage location rotates daily:\nlocation = SHA-256(sig_type || blinded_public_key) This prevents:\nCorrelation across days via DHT lookups Long-term monitoring of service availability Traffic analysis of DHT queries Threat Model Adversary Capabilities:\nNetwork Adversary:\nCan monitor all DHT traffic Can observe encrypted LeaseSet publications Cannot decrypt without proper keys Floodfill Adversary:\nCan store and analyze all encrypted LeaseSets Can track publication patterns over time Cannot decrypt Layer 1 or Layer 2 Can see client count (but not identities) Authorized Client Adversary:\nCan decrypt specific encrypted LeaseSets Can access inner LeaseSet2 data Cannot determine other clients\u0026rsquo; identities Cannot decrypt past LeaseSets (with ephemeral keys) Out of Scope:\nMalicious router implementations Compromised router host systems Side-channel attacks (timing, power analysis) Physical access to keys Social engineering attacks Attack Scenarios 1. Offline Keys Tracking Attack:\nAttack: Adversary tracks encrypted LeaseSets via unchanging offline signature block.\nMitigation: Generate new transient keys daily (in addition to blinded keys).\nStatus: Documented recommendation, implementation-specific.\n2. Client Position Inference Attack:\nAttack: If client order is static, clients can infer their position and detect when other clients added/removed.\nMitigation: Randomize client order in authorization list for each publication.\nStatus: Documented recommendation in specification.\n3. Client Count Analysis Attack:\nAttack: Adversary monitors client count changes over time to infer service popularity or client churn.\nMitigation: Add random dummy entries to authorization list.\nStatus: Optional feature, deployment-specific trade-off (size vs. privacy).\n4. PSK Interception Attack:\nAttack: Adversary intercepts PSK during out-of-band exchange and can decrypt all future encrypted LeaseSets.\nMitigation: Use DH client authorization instead, or ensure secure key exchange (Signal, OTR, PGP).\nStatus: Known limitation of PSK approach, documented in specification.\n5. Timing Correlation Attack:\nAttack: Adversary correlates publication times across days to link encrypted LeaseSets.\nMitigation: Randomize publication times, use delayed publishing.\nStatus: Implementation-specific, not addressed in core specification.\n6. Long-term Secret Compromise:\nAttack: Adversary compromises the blinding secret and can compute all past and future blinded keys.\nMitigation:\nUse optional secret parameter (not empty) Rotate secret periodically Use different secrets for different services Status: Secret parameter is optional; using it is highly recommended.\nOperational Security Key Management:\nSigning Private Key:\nStore offline in cold storage Use only for generating blinded keys (batch process) Never expose to online router Blinded Private Keys:\nGenerate offline, deliver in batches Rotate daily automatically Delete after use (forward secrecy) Transient Private Keys (with offline keys):\nGenerate offline, deliver in batches Can be longer-lived (days/weeks) Rotate regularly for enhanced privacy Client Authorization Keys:\nDH: Client private keys never leave client device PSK: Use unique keys per client, secure exchange Revoke immediately upon client removal Secret Management:\nThe optional secret parameter in GENERATE_ALPHA:\nSHOULD be used for high-security services MUST be transmitted securely to authorized clients SHOULD be rotated periodically (e.g., monthly) CAN be different for different client groups Monitoring and Auditing:\nPublication Monitoring:\nVerify encrypted LeaseSets published successfully Monitor floodfill acceptance rates Alert on publication failures Client Access Monitoring:\nLog client authorization attempts (without identifying clients) Monitor for unusual patterns Detect potential attacks early Key Rotation Auditing:\nVerify daily key rotation occurs Check blinded key changes daily Ensure old keys are deleted Implementation Security Constant-Time Operations:\nImplementations MUST use constant-time operations for:\nAll scalar arithmetic (mod L operations) Private key comparisons Signature verification DH key agreement Memory Security:\nZero sensitive key material after use Use secure memory allocation for keys Prevent keys from being paged to disk Clear stack variables containing key material Random Number Generation:\nUse cryptographically secure RNG (CSRNG) Properly seed RNG from OS entropy source Do not use predictable RNGs for key material Verify RNG output quality periodically Input Validation:\nValidate all public keys are on the curve Check all signature types are supported Verify all lengths before parsing Reject malformed encrypted LeaseSets early Error Handling:\nDo not leak information via error messages Use constant-time comparison for authentication Do not expose timing differences in decryption Log security-relevant events properly Recommendations For Service Operators:\n✅ Use Red25519 (type 11) for new destinations ✅ Use DH client authorization for high-security services ✅ Generate new transient keys daily when using offline keys ✅ Use the optional secret parameter in GENERATE_ALPHA ✅ Randomize client order in authorization lists ✅ Monitor publication success and investigate failures ⚠️ Consider dummy entries to hide client count (size trade-off) For Client Implementers:\n✅ Validate blinded public keys are on prime-order subgroup ✅ Verify all signatures before trusting data ✅ Use constant-time operations for cryptographic primitives ✅ Zero key material immediately after use ✅ Implement proper error handling without information leaks ✅ Support both Ed25519 and Red25519 destination types For Network Operators:\n✅ Accept encrypted LeaseSets in floodfill routers ✅ Enforce reasonable size limits to prevent abuse ✅ Monitor for anomalous patterns (extremely large, frequent updates) ⚠️ Consider rate limiting encrypted LeaseSet publications Implementation Notes Java I2P Implementation Repository: https://github.com/i2p/i2p.i2p Key Classes:\nnet.i2p.data.LeaseSet2 - LeaseSet2 structure net.i2p.data.EncryptedLeaseSet - Encrypted LS2 implementation net.i2p.crypto.eddsa.EdDSAEngine - Ed25519/Red25519 signatures net.i2p.crypto.HKDF - HKDF implementation net.i2p.crypto.ChaCha20 - ChaCha20 cipher Configuration:\nEnable encrypted LeaseSet in clients.config:\n# 암호화된 LeaseSet 활성화 i2cp.encryptLeaseSet=true # 선택 사항: 클라이언트 인가 활성화 i2cp.enableAccessList=true # 선택 사항: DH(디피-헬먼) 인증 사용(기본값은 PSK(사전 공유 키)) i2cp.accessListType=0 # 선택 사항: Blinding secret(주소 블라인딩에 사용하는 비밀값) (강력 권장) i2cp.blindingSecret=your-secret-here API Usage Example:\n// 암호화된 LeaseSet 생성 EncryptedLeaseSet els = new EncryptedLeaseSet(); // 목적지 설정 els.setDestination(destination); // 클라이언트별 인가를 활성화 els.setAuthorizationEnabled(true); els.setAuthType(EncryptedLeaseSet.AUTH_DH); // 허가된 클라이언트(DH 공개 키) 추가: for (byte[] clientPubKey : authorizedClients) { els.addClient(clientPubKey); } // blinding(블라인딩: I2P 목적지 공개키를 숨기는 기법) 매개변수를 설정 els.setBlindingSecret(\u0026#34;your-secret\u0026#34;); // 서명하고 게시 els.sign(signingPrivateKey); netDb.publish(els); i2pd (C++) Implementation Repository: https://github.com/PurpleI2P/i2pd Key Files:\nlibi2pd/LeaseSet.h/cpp - LeaseSet implementations libi2pd/Crypto.h/cpp - Cryptographic primitives libi2pd/Ed25519.h/cpp - Ed25519/Red25519 signatures libi2pd/ChaCha20.h/cpp - ChaCha20 cipher Configuration:\nEnable in tunnel configuration (tunnels.conf):\n[my-hidden-service] type = http host = 127.0.0.1 port = 8080 keys = my-service-keys.dat # 암호화된 LeaseSet(목적지 접근 정보를 담는 I2P 데이터 구조) 활성화 encryptleaseset = true # 선택 사항: 클라이언트 인증 유형(0=DH(디피-헬만), 1=PSK(사전 공유 키)) authtype = 0 # 선택 사항: Blinding secret(블라인딩용 비밀값) secret = your-secret-here # 선택 사항: 허용된 클라이언트(한 줄에 하나씩, base64로 인코딩된 공개 키) client.1 = base64-인코딩된-클라이언트-공개키-1 client.2 = base64-인코딩된-클라이언트-공개키-2 API Usage Example:\n// 암호화된 LeaseSet 생성 auto encryptedLS = std::make_shared\u0026lt;i2p::data::EncryptedLeaseSet\u0026gt;( destination, blindingSecret ); // 클라이언트별 인가 활성화 encryptedLS-\u0026gt;SetAuthType(i2p::data::AUTH_TYPE_DH); // 허가된 클라이언트를 추가 for (const auto\u0026amp; clientPubKey : authorizedClients) { encryptedLS-\u0026gt;AddClient(clientPubKey); } // 서명하고 게시 encryptedLS-\u0026gt;Sign(signingPrivKey); netdb.Publish(encryptedLS); Testing and Debugging Test Vectors:\nGenerate test vectors for implementation verification:\n# 테스트 벡터 1: 키 블라인딩 destination_pubkey = bytes.fromhex(\u0026#39;a\u0026#39; * 64) sigtype = 7 blinded_sigtype = 11 date = \u0026#34;20251015\u0026#34; secret = \u0026#34;\u0026#34; alpha = generate_alpha(destination_pubkey, sigtype, blinded_sigtype, date, secret) print(f\u0026#34;Alpha: {alpha.hex()}\u0026#34;) # 예상: (레퍼런스 구현과 대조하여 검증) Unit Tests:\nKey areas to test:\nHKDF derivation with various inputs ChaCha20 encryption/decryption Red25519 signature generation and verification Key blinding (private and public) Layer 1/2 encryption/decryption Client authorization (DH and PSK) Base32 address generation and parsing Integration Tests:\nPublish encrypted LeaseSet to test network Retrieve and decrypt from client Verify daily key rotation Test client authorization (add/remove clients) Test offline keys (if supported) Common Implementation Errors:\nIncorrect mod L reduction: Must use proper modular arithmetic Endianness errors: Most fields are big-endian, but some crypto uses little-endian Off-by-one in array slicing: Verify indices are inclusive/exclusive as needed Missing constant-time comparisons: Use constant-time for all sensitive comparisons Not zeroing key material: Always zero keys after use Performance Considerations Computational Costs:\nOperation Cost Notes Key blinding (server)1 scalar multPer publication Key blinding (client)1 point add + 1 scalar multPer retrieval Layer 1 encryption1 HKDF + 1 ChaCha20Fast Layer 2 encryption1 HKDF + 1 ChaCha20Fast DH client auth (server)N+1 X25519 opsN = number of clients DH client auth (client)1 X25519 opPer retrieval PSK client auth0 DH opsOnly HKDF + ChaCha20 Signature (Red25519)1 signature opSimilar cost to Ed25519 Size Overhead:\nComponent Size Frequency Blinded public key32 bytesPer LeaseSet Layer 1 encryption overhead32 bytes (salt)Per LeaseSet Layer 2 encryption overhead32 bytes (salt)Per LeaseSet DH auth per client40 bytesPer client per LeaseSet DH ephemeral pubkey32 bytesPer LeaseSet (if DH auth) PSK auth per client40 bytesPer client per LeaseSet PSK salt32 bytesPer LeaseSet (if PSK auth) Signature64 bytesPer LeaseSet Offline sig block≈100 bytesPer LeaseSet (if offline keys) Typical Sizes:\nNo client auth: ~200 bytes overhead With 10 DH clients: ~600 bytes overhead With 100 DH clients: ~4200 bytes overhead Optimization Tips:\nBatch key generation: Generate blinded keys for multiple days in advance Cache subcredentials: Compute once per day, reuse for all publications Reuse ephemeral keys: Can reuse ephemeral DH key for short period (minutes) Parallel client encryption: Encrypt client cookies in parallel Fast path for no auth: Skip authorization layer entirely when disabled Compatibility Backward Compatibility:\nEd25519 (type 7) destinations supported for unblinded keys Red25519 (type 11) required for blinded keys Traditional LeaseSets still fully supported Encrypted LeaseSets do not break existing network Forward Compatibility:\nReserved flag bits for future features Extensible authorization scheme (3 bits allow 8 types) Version field in various structures Interoperability:\nJava I2P and i2pd fully interoperable since: Java I2P 0.9.40 (May 2019) i2pd 2.58.0 (September 2025) Encrypted LeaseSets work across implementations Client authorization works across implementations References IETF RFCs RFC 2104 - HMAC: Keyed-Hashing for Message Authentication (February 1997) RFC 5869 - HMAC-based Extract-and-Expand Key Derivation Function (HKDF) (May 2010) RFC 7539 - ChaCha20 and Poly1305 for IETF Protocols (May 2015) RFC 7748 - Elliptic Curves for Security (January 2016) I2P Specifications Common Structures Specification - LeaseSet2 and EncryptedLeaseSet structures Proposal 123: New netDB Entries - Background and design of LeaseSet2 Proposal 146: Red25519 - Red25519 signature scheme specification Proposal 149: B32 for Encrypted LS2 - Base32 addressing for encrypted LeaseSets Red25519 Specification - Detailed Red25519 implementation B32 Addressing Specification - Base32 address format Network Database Documentation - NetDB usage and operations I2CP Specification - I2P Client Protocol Cryptographic References Ed25519 Paper - \u0026ldquo;High-speed high-security signatures\u0026rdquo; by Bernstein et al. ZCash Protocol Specification - Section 5.4.6: RedDSA signature scheme Tor Rendezvous Specification v3 - Tor\u0026rsquo;s onion service specification (for comparison) Security References Key Blinding Security Discussion - Tor Project mailing list discussion Tor Ticket #8106 - Key blinding implementation discussion PRNG Security - Random number generator security considerations Tor PRNG Discussion - Discussion of PRNG usage in Tor Implementation References Java I2P Repository - Official Java implementation i2pd Repository - C++ implementation I2P Website - Official I2P project website I2P Specifications - Complete specification index Version History I2P Release Notes - Official release announcements Java I2P Releases - GitHub release history i2pd Releases - GitHub release history Appendix A: Cryptographic Constants Ed25519 / Red25519 Constants # Ed25519 기저점(생성점) B = 2**255 - 19 # Ed25519의 차수(스칼라 필드 크기) L = 2**252 + 27742317777372353535851937790883648493 # 서명 유형 값 SIGTYPE_ED25519 = 7 # 0x0007 SIGTYPE_RED25519 = 11 # 0x000b # 키 길이 PRIVKEY_SIZE = 32 # 바이트 PUBKEY_SIZE = 32 # 바이트 SIGNATURE_SIZE = 64 # 바이트 ChaCha20 Constants # ChaCha20 매개변수 CHACHA20_KEY_SIZE = 32 # 바이트 (256 비트) CHACHA20_NONCE_SIZE = 12 # 바이트 (96 비트) CHACHA20_INITIAL_COUNTER = 1 # RFC 7539에서는 0 또는 1을 허용함 HKDF Constants # HKDF(HMAC 기반 키 파생 함수) 매개변수 HKDF_HASH = \u0026#34;SHA-256\u0026#34; HKDF_SALT_MAX = 32 # bytes (HashLen) # HKDF(해시 기반 키 유도 함수) info 문자열(도메인 분리) HKDF_INFO_ALPHA = b\u0026#34;i2pblinding1\u0026#34; HKDF_INFO_LAYER1 = b\u0026#34;ELS2_L1K\u0026#34; HKDF_INFO_LAYER2 = b\u0026#34;ELS2_L2K\u0026#34; HKDF_INFO_DH_AUTH = b\u0026#34;ELS2_XCA\u0026#34; HKDF_INFO_PSK_AUTH = b\u0026#34;ELS2PSKA\u0026#34; Hash Personalization Strings # SHA-256 개인화 문자열 HASH_PERS_ALPHA = b\u0026#34;I2PGenerateAlpha\u0026#34; HASH_PERS_RED25519 = b\u0026#34;I2P_Red25519H(x)\u0026#34; HASH_PERS_CREDENTIAL = b\u0026#34;credential\u0026#34; HASH_PERS_SUBCREDENTIAL = b\u0026#34;subcredential\u0026#34; Structure Sizes # 레이어 0(외부) 크기 BLINDED_SIGTYPE_SIZE = 2 # 바이트 BLINDED_PUBKEY_SIZE = 32 # 바이트 (Red25519용) PUBLISHED_TS_SIZE = 4 # 바이트 EXPIRES_SIZE = 2 # 바이트 FLAGS_SIZE = 2 # 바이트 LEN_OUTER_CIPHER_SIZE = 2 # 바이트 SIGNATURE_SIZE = 64 # 바이트 (Red25519) # 오프라인 키 블록 크기 OFFLINE_EXPIRES_SIZE = 4 # 바이트 OFFLINE_SIGTYPE_SIZE = 2 # 바이트 OFFLINE_SIGNATURE_SIZE = 64 # 바이트 # 레이어 1(중간)의 크기 AUTH_FLAGS_SIZE = 1 # 바이트 EPHEMERAL_PUBKEY_SIZE = 32 # 바이트 (DH 인증) AUTH_SALT_SIZE = 32 # 바이트 (PSK 인증) NUM_CLIENTS_SIZE = 2 # 바이트 CLIENT_ID_SIZE = 8 # 바이트 CLIENT_COOKIE_SIZE = 32 # 바이트 AUTH_CLIENT_ENTRY_SIZE = 40 # 바이트 (CLIENT_ID + CLIENT_COOKIE) # 암호화 오버헤드 SALT_SIZE = 32 # 바이트 (각 암호화된 레이어 앞에 추가됨) # Base32 주소 B32_ENCRYPTED_DECODED_SIZE = 35 # 바이트 B32_ENCRYPTED_ENCODED_LEN = 56 # 문자 B32_SUFFIX = \u0026#34;.b32.i2p\u0026#34; Appendix B: Test Vectors Test Vector 1: Alpha Generation Input:\n# 목적지 공개 키 (Ed25519) A = bytes.fromhex(\u0026#39;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\u0026#39;) stA = 0x0007 # Ed25519 stA_prime = 0x000b # Red25519 date = \u0026#34;20251015\u0026#34; secret = \u0026#34;\u0026#34; # Empty secret Computation:\nkeydata = A || bytes([0x00, 0x07]) || bytes([0x00, 0x0b]) # keydata = 36 바이트 salt = SHA256(b\u0026#34;I2PGenerateAlpha\u0026#34; + keydata) ikm = b\u0026#34;20251015\u0026#34; info = b\u0026#34;i2pblinding1\u0026#34; seed = HKDF(salt, ikm, info, 64) alpha = LEOS2IP(seed) mod L Expected Output:\n(레퍼런스 구현과 대조하여 검증) alpha = [64-바이트 16진수 값] Test Vector 2: ChaCha20 Encryption Input:\nkey = bytes([i for i in range(32)]) # 0x00..0x1f nonce = bytes([i for i in range(12)]) # 0x00..0x0b plaintext = b\u0026#34;Hello, I2P!\u0026#34; Computation:\nciphertext = ChaCha20_Encrypt(key, nonce, plaintext, counter=1) Expected Output:\nciphertext = [RFC 7539 테스트 벡터와 대조하여 검증] Test Vector 3: HKDF Input:\nsalt = bytes(32) # 모두 0 ikm = b\u0026#34;test input keying material\u0026#34; info = b\u0026#34;ELS2_L1K\u0026#34; n = 44 Computation:\nkeys = HKDF(salt, ikm, info, n) Expected Output:\nkeys = [44바이트 16진수 값] Test Vector 4: Base32 Address Input:\npubkey = bytes.fromhex(\u0026#39;bbbb\u0026#39; + \u0026#39;bb\u0026#39; * 30) # 32바이트 unblinded_sigtype = 11 # Red25519 blinded_sigtype = 11 # Red25519 Computation:\naddress = generate_encrypted_b32_address(pubkey, unblinded_sigtype, blinded_sigtype) Expected Output:\naddress = [base32 문자 56개].b32.i2p # 체크섬이 올바르게 검증되는지 확인 Appendix C: Glossary Alpha (α): The secret blinding factor used to blind public and private keys. Generated from the destination, date, and optional secret.\nAuthCookie: A 32-byte random value encrypted for each authorized client, used as input to Layer 2 encryption.\nB (Base Point): The generator point for the Ed25519 elliptic curve.\nBlinded Key: A public or private key that has been transformed using the alpha blinding factor. Blinded keys cannot be linked to the original keys without knowing alpha.\nChaCha20: A stream cipher providing fast, secure encryption without requiring AES hardware support.\nClientID: An 8-byte identifier derived from HKDF output, used to identify authorization entries for clients.\nClientCookie: A 32-byte encrypted value containing the authCookie for a specific client.\nCredential: A 32-byte value derived from the destination\u0026rsquo;s public key and signature types, binding encryption to knowledge of the destination.\nCSRNG: Cryptographically Secure Random Number Generator. Must provide unpredictable output suitable for key generation.\nDH (Diffie-Hellman): A cryptographic protocol for securely establishing shared secrets. I2P uses X25519.\nEd25519: An elliptic curve signature scheme providing fast signatures with 128-bit security level.\nEphemeral Key: A short-lived cryptographic key, typically used once and then discarded.\nFloodfill: I2P routers that store and serve network database entries, including encrypted LeaseSets.\nHKDF: HMAC-based Key Derivation Function, used to derive multiple cryptographic keys from a single source.\nL (Order): The order of the Ed25519 scalar field (approximately 2^252).\nLayer 0 (Outer): The plaintext portion of an encrypted LeaseSet, containing blinded key and metadata.\nLayer 1 (Middle): The first encrypted layer, containing client authorization data.\nLayer 2 (Inner): The innermost encrypted layer, containing the actual LeaseSet2 data.\nLeaseSet2 (LS2): Second version of I2P\u0026rsquo;s network database entry format, introducing encrypted variants.\nNetDB: The I2P network database, a distributed hash table storing router and destination information.\nOffline Keys: A feature allowing the main signing key to remain in cold storage while a transient key handles daily operations.\nPSK (Pre-Shared Key): A symmetric key shared in advance between two parties, used for PSK client authorization.\nRed25519: An Ed25519-based signature scheme with key blinding support, based on ZCash RedDSA.\nSalt: Random data used as input to key derivation functions to ensure unique outputs.\nSigType: A numeric identifier for signature algorithms (e.g., 7 = Ed25519, 11 = Red25519).\nSubcredential: A 32-byte value derived from the credential and blinded public key, binding encryption to a specific encrypted LeaseSet.\nTransient Key: A temporary signing key used with offline keys, with a limited validity period.\nX25519: An elliptic curve Diffie-Hellman protocol over Curve25519, providing key agreement.\nDocument Information Status: This document represents the current stable encrypted LeaseSet specification as implemented in I2P since June 2019. The protocol is mature and widely deployed.\nContributing: For corrections or improvements to this documentation, please submit issues or pull requests to the I2P specifications repository.\nSupport: For questions about implementing encrypted LeaseSets:\nI2P Forum: https://i2pforum.net/ IRC: #i2p-dev on OFTC Matrix: #i2p-dev:matrix.org Acknowledgments: This specification builds on work by the I2P development team, ZCash cryptography research, and Tor Project\u0026rsquo;s key blinding research.\n","description":"비공개 Destinations(목적지 식별자)용 접근 제어된 LeaseSet 형식","id":"14f2a4c0bb3f459df8db8dbce45508ff","section":"docs","title":"암호화된 LeaseSet","url":"/ko/docs/specs/encryptedleaseset/"},{"categories":null,"content":"개요 표준 Base 32(\u0026ldquo;b32\u0026rdquo;) 주소는 목적지의 해시를 포함합니다. 이는 암호화된 LS2(LeaseSet2) (제안 123)에는 작동하지 않습니다.\n암호화된 LS2 (proposal 123)는 destination(I2P 목적지 식별자)의 해시만을 포함하므로, 기존의 base 32 주소를 사용할 수 없다. non-blinded 공개키는 제공되지 않는다. 클라이언트가 leaseset(경로 임대 정보 묶음)을 가져와 복호화하려면, destination의 공개키, 서명 유형, blinded(블라인드 처리된) 서명 유형, 그리고 선택적인 비밀값(secret) 또는 개인키를 알고 있어야 한다. 따라서 base 32 주소만으로는 충분하지 않다. 클라이언트는 공개키를 포함하는 전체 destination 또는 공개키 자체 가운데 하나가 필요하다. 클라이언트의 주소록에 전체 destination이 있고, 그 주소록이 해시로 역조회를 지원한다면 공개키를 가져올 수 있다.\n이 형식은 해시 대신 공개 키를 base32 주소에 넣습니다. 또한 이 형식에는 공개 키의 서명 유형과 블라인딩 스킴의 서명 유형이 포함되어야 합니다.\n이 문서는 이러한 주소에 대한 b32 형식을 정의합니다. 논의 중에는 이 새로운 형식을 \u0026ldquo;b33\u0026rdquo; 주소라고 불러 왔지만, 실제 새로운 형식은 통상적인 \u0026ldquo;.b32.i2p\u0026rdquo; 접미사를 그대로 유지합니다.\n구현 상태 제안 123(새 netDB 엔트리)은 버전 0.9.43(2019년 10월)에서 완전히 구현되었다. 암호화된 LS2(LeaseSet2) 기능 세트는 주소 지정 형식이나 암호 사양에 하위 호환성을 깨는 변경 없이 버전 2.10.0(2025년 9월)까지 안정적으로 유지되었다.\n주요 구현 이정표: - 0.9.38: 오프라인 키를 사용하는 표준 LS2에 대한 Floodfill 지원 - 0.9.39: RedDSA(서명 알고리즘) 서명 유형 11 및 기본 암호화/복호화 - 0.9.40: B32 주소 지정에 대한 완전한 지원(Proposal 149) - 0.9.41: X25519(타원곡선 키 교환 알고리즘) 기반 클라이언트별 인증 - 0.9.42: 모든 블라인딩 기능 가동 - 0.9.43: 완전한 구현 선언(2019년 10월)\n설계 새 형식에는 블라인딩 해제된 공개 키, 블라인딩 해제된 서명 유형, 그리고 블라인드된 서명 유형이 포함됩니다. 비공개 링크를 위해 secret(비밀 값) 및/또는 개인 키 요구 사항을 선택적으로 지정합니다. 기존 \u0026ldquo;.b32.i2p\u0026rdquo; 접미사를 사용하지만 길이는 더 깁니다. 오류 검출을 위한 체크섬을 포함합니다. 암호화된 leaseSet의 주소는 인코딩된 문자 56자 이상(디코딩된 35바이트 이상)으로 식별되며, 이는 기존 base 32 주소의 52자(32바이트)와 대비됩니다. 명세 생성과 인코딩 다음과 같이 {56자 이상}.b32.i2p (바이너리로는 35자 이상) 형식의 호스트명을 구성합니다:\nflag (1 byte) bit 0: 0 for one-byte sigtypes, 1 for two-byte sigtypes bit 1: 0 for no secret, 1 if secret is required bit 2: 0 for no per-client auth, 1 if client private key is required bits 7-3: Unused, set to 0 public key sigtype (1 or 2 bytes as indicated in flags) If 1 byte, the upper byte is assumed zero blinded key sigtype (1 or 2 bytes as indicated in flags) If 1 byte, the upper byte is assumed zero public key Number of bytes as implied by sigtype 후처리 및 체크섬:\nConstruct the binary data as above. Treat checksum as little-endian. Calculate checksum = CRC-32(data[3:end]) data[0] ^= (byte) checksum data[1] ^= (byte) (checksum \u0026gt;\u0026gt; 8) data[2] ^= (byte) (checksum \u0026gt;\u0026gt; 16) hostname = Base32.encode(data) || \u0026#34;.b32.i2p\u0026#34; b32 끝의 사용되지 않은 비트는 모두 0이어야 합니다. 표준 56자(35바이트) 주소에는 사용되지 않은 비트가 없습니다.\n디코딩 및 검증 strip the \u0026#34;.b32.i2p\u0026#34; from the hostname data = Base32.decode(hostname) Calculate checksum = CRC-32(data[3:end]) Treat checksum as little-endian. flags = data[0] ^ (byte) checksum if 1 byte sigtypes: pubkey sigtype = data[1] ^ (byte) (checksum \u0026gt;\u0026gt; 8) blinded sigtype = data[2] ^ (byte) (checksum \u0026gt;\u0026gt; 16) else (2 byte sigtypes): pubkey sigtype = data[1] ^ ((byte) (checksum \u0026gt;\u0026gt; 8)) || data[2] ^ ((byte) (checksum \u0026gt;\u0026gt; 16)) blinded sigtype = data[3] || data[4] parse the remainder based on the flags to get the public key 비밀키와 개인 키 비트 비밀 키 및 개인 키 비트 플래그는 leaseset(목적지의 수신 터널 정보를 담는 I2P 데이터 구조)을 복호화하는 데 비밀 키 및/또는 개인 키가 필요함을 클라이언트, 프록시 또는 기타 클라이언트 측 코드에 알리기 위해 사용된다. 특정 구현에서는 사용자에게 필요한 데이터를 제공하도록 요청하거나, 필요한 데이터가 없을 경우 연결 시도를 거부할 수 있다.\n이 비트들은 표시 용도로만 사용됩니다. 보안을 훼손할 수 있으므로 비밀 키 또는 개인 키를 B32 주소 자체에 절대 포함해서는 안 됩니다.\n암호학적 세부 사항 블라인딩 스킴 이 블라인딩 스킴은 Ed25519와 ZCash의 설계를 바탕으로 한 RedDSA(서명 체계)를 사용하여, SHA-512를 사용해 Ed25519 곡선 위에서 Red25519 서명을 생성합니다. 이 접근법은 블라인딩된 공개키가 소수 차수 부분군에 머무르도록 보장하여, 일부 대안적 설계에서 나타나는 보안상의 우려를 피합니다.\nBlinded keys(블라인딩된 키)는 UTC 날짜를 기준으로 매일 다음 공식을 사용해 순환됩니다:\nblinded_key = BLIND(unblinded_key, date, optional_secret) DHT(분산 해시 테이블) 저장 위치는 다음과 같이 계산됩니다:\nSHA256(type_byte || blinded_public_key) 암호화 암호화된 leaseset은 암호화를 위해 ChaCha20 스트림 암호를 사용하며, AES 하드웨어 가속이 없는 장치에서 더 우수한 성능을 제공하기 때문에 선택되었습니다. 이 명세는 키 유도를 위해 HKDF를, 디피-헬먼 연산을 위해 X25519를 사용합니다.\n암호화된 leasesets는 3계층 구조로 되어 있습니다:\n외부 계층: 평문 메타데이터 중간 계층: 클라이언트 인증 (DH 또는 PSK 방식) 내부 계층: 리스 정보를 포함한 실제 LS2 데이터 인증 방법 클라이언트별 인증은 두 가지 방법을 지원합니다:\nDH 인증: X25519 키 합의를 사용합니다. 각 승인된 클라이언트는 서버에 자신의 공개 키를 제공하고, 서버는 ECDH(타원 곡선 디피-헬만)에서 도출한 공유 비밀을 사용해 중간 레이어를 암호화합니다.\nPSK 인증: 암호화를 위해 사전 공유 키를 직접 사용합니다.\nB32 주소의 플래그 비트 2는 클라이언트별 인증이 필요한지 여부를 나타낸다.\n캐싱 이 사양의 범위를 벗어나긴 하지만, routers와 클라이언트는 공개 키에서 목적지로의 매핑과 그 역방향 매핑을 기억하고 캐시(영구 저장 권장)해 두어야 한다.\nblockfile naming service(블록파일 기반 명명 서비스)는 버전 0.9.8부터 I2P의 기본 주소록 시스템으로, 해시 기반의 신속한 조회를 제공하는 전용 역방향 조회 맵과 함께 여러 개의 주소록을 관리합니다. 이 기능은 초기에는 해시만 알려져 있을 때 암호화된 leaseSet을 조회하는 데 필수적입니다.\n서명 유형 I2P 버전 2.10.0 기준으로 서명 유형은 0부터 11까지 정의되어 있다. 단일 바이트 인코딩이 표준으로 유지되며, 2바이트 인코딩도 가능하지만 실제로는 사용되지 않는다.\n일반적으로 사용되는 유형: - Type 0 (DSA_SHA1): routers에서는 사용 중단, destinations(목적지)에서는 지원 - Type 7 (EdDSA_SHA512_Ed25519): router 식별자와 destinations의 현재 표준 - Type 11 (RedDSA_SHA512_Ed25519): blinding(블라인딩) 지원이 있는 암호화된 LS2 leasesets 전용\n중요 참고: Ed25519 (type 7)와 Red25519 (type 11)만 암호화된 leasesets에 필요한 blinding(은닉 기법)을 지원합니다. 다른 서명 유형은 이 기능과 함께 사용할 수 없습니다.\n유형 9-10(GOST algorithms, 러시아 국가 표준 암호 알고리즘)은 예약되어 있지만 아직 구현되지 않았습니다. 유형 4-6과 8은 오프라인 서명 키용으로 \u0026ldquo;offline only\u0026quot;로 표시되어 있습니다.\n참고 사항 길이로 구형과 신형 형식을 구분하세요. 구형 b32 주소는 항상 {52자}.b32.i2p이고, 신형은 {56자 이상}.b32.i2p입니다 base32 인코딩은 RFC 4648 표준을 따르며, 디코딩은 대소문자를 구분하지 않고 출력은 소문자 사용을 권장합니다 공개키가 더 큰 서명 유형(예: 132바이트 키의 ECDSA P521)을 사용할 경우 주소 길이가 200자를 초과할 수 있습니다 표준 b32와 마찬가지로, 원한다면 새 형식을 jump links(이름 해석용 링크)에서 사용할 수 있고 jump servers(제공 서버)에서 제공될 수도 있습니다 개인정보 보호 강화를 위해 blinded keys(블라인드 처리된 키)는 UTC 날짜를 기준으로 매일 순환(교체)됩니다 이 형식은 Tor의 rend-spec-v3.txt appendix A.2 접근 방식과 다르며, off-curve blinded public keys(타원곡선 위에 있지 않은 블라인드 공개키)와 관련해 잠재적인 보안 영향이 있을 수 있습니다 버전 호환성 이 명세는 I2P 0.9.47(2020년 8월)부터 2.10.0(2025년 9월)까지의 버전에 적용됩니다. 이 기간 동안 B32 addressing format(베이스32 주소 형식), 암호화된 LS2 구조(LeaseSet2), 또는 암호 구현에는 비호환 변경이 발생하지 않았습니다. 0.9.47에서 생성된 모든 주소는 현재 버전들과 완전한 호환성을 유지합니다.\n참고 문헌 CRC-32 - CRC-32 (위키백과) - RFC 3309: 스트림 제어 전송 프로토콜 체크섬 I2P 명세 - 암호화된 LeaseSet 명세 - 제안 123: 새로운 netDB 항목 - 제안 149: 암호화된 LS2(LeaseSet 2)용 B32 - 공통 구조 명세 - 이름 지정 및 주소록 Tor 비교 - Tor 토론 스레드 (설계 맥락) 추가 자료 - I2P 프로젝트 - I2P 포럼 - Java API 문서 ","description":"암호화된 LS2 leaseSet용 Base 32 주소 형식","id":"cac162c86c1b599cb6bab03e6270c404","section":"docs","title":"암호화된 leaseSet을 위한 B32","url":"/ko/docs/specs/b32-for-encrypted-leasesets/"},{"categories":null,"content":"왜 I2P 전용 코드를 작성해야 하나요? I2P에서 애플리케이션을 사용하는 방법은 여러 가지가 있습니다. I2PTunnel 을 사용하면 명시적인 I2P 지원을 프로그래밍할 필요 없이 일반 애플리케이션을 사용할 수 있습니다. 이는 단일 웹사이트에 연결해야 하는 클라이언트-서버 시나리오에서 매우 효과적입니다. 그림 1에 표시된 것처럼 I2PTunnel을 사용하여 해당 웹사이트에 연결하는 터널을 간단히 생성할 수 있습니다.\n애플리케이션이 분산되어 있다면 많은 수의 peer들과의 연결이 필요합니다. I2PTunnel을 사용할 경우, 그림 2에 표시된 것처럼 연결하려는 각 peer마다 새로운 tunnel을 생성해야 합니다. 이 과정은 물론 자동화할 수 있지만, 많은 I2PTunnel 인스턴스를 실행하면 상당한 오버헤드가 발생합니다. 또한 많은 프로토콜에서는 모든 peer가 동일한 포트 집합을 사용하도록 강제해야 합니다. 예를 들어 DCC 채팅을 안정적으로 실행하려면 포트 10001은 Alice, 포트 10002는 Bob, 포트 10003은 Charlie 등으로 모두가 합의해야 합니다. 이는 프로토콜에 TCP/IP 특정 정보(호스트 및 포트)가 포함되어 있기 때문입니다.\n일반적인 네트워크 애플리케이션은 사용자를 식별하는 데 사용될 수 있는 많은 추가 데이터를 전송합니다. 호스트명, 포트 번호, 시간대, 문자 집합 등이 사용자에게 알리지 않고 전송되는 경우가 많습니다. 따라서 익명성을 염두에 두고 네트워크 프로토콜을 특별히 설계하면 사용자 신원이 노출되는 것을 방지할 수 있습니다.\nI2P 상에서 상호작용하는 방법을 결정할 때 검토해야 할 효율성 고려사항도 있습니다. streaming 라이브러리와 그 위에 구축된 것들은 TCP와 유사한 핸드셰이크로 작동하는 반면, 핵심 I2P 프로토콜(I2NP와 I2CP)은 엄격히 메시지 기반입니다(UDP 또는 경우에 따라 raw IP와 같이). 중요한 차이점은 I2P에서는 통신이 long fat network를 통해 작동한다는 것입니다 — 각 엔드 투 엔드 메시지는 무시할 수 없는 지연시간을 가지지만, 최대 수 KB의 페이로드를 포함할 수 있습니다. 단순한 요청과 응답이 필요한 애플리케이션은 MTU 감지나 메시지 단편화를 걱정할 필요 없이 (최선 노력) 데이터그램을 사용하여 시작 및 종료 핸드셰이크에서 발생하는 지연시간을 제거하고 모든 상태를 버릴 수 있습니다.\nFigure 1: Creating a server-client connection using I2PTunnel only requires creating a single tunnel. Figure 2: Setting up connections for a peer-to-peer applications requires a very large amount of tunnels. 요약하자면, I2P 전용 코드를 작성해야 하는 여러 가지 이유: 많은 수의 I2PTunnel 인스턴스를 생성하면 상당한 양의 리소스가 소모되며, 이는 분산 애플리케이션에 문제가 됩니다 (각 피어마다 새로운 tunnel이 필요함). 일반적인 네트워크 프로토콜은 사용자를 식별하는 데 사용될 수 있는 많은 추가 데이터를 전송하는 경우가 많습니다. I2P를 위해 특별히 프로그래밍하면 이러한 정보를 유출하지 않는 네트워크 프로토콜을 만들 수 있어 사용자를 익명으로 안전하게 보호할 수 있습니다. 일반 인터넷에서 사용하도록 설계된 네트워크 프로토콜은 훨씬 높은 지연 시간을 가진 네트워크인 I2P에서는 비효율적일 수 있습니다. I2P는 개발자를 위한 표준 플러그인 인터페이스 를 지원하여 애플리케이션을 쉽게 통합하고 배포할 수 있습니다.\nJava로 작성되고 표준 webapps/app.war를 통해 HTML 인터페이스를 사용하여 접근/실행 가능한 애플리케이션은 I2P 배포판에 포함되는 것을 고려할 수 있습니다.\n중요한 개념 I2P를 사용할 때 적응해야 하는 몇 가지 변경 사항이 있습니다:\n목적지 I2P에서 실행되는 애플리케이션은 고유한 암호학적으로 안전한 엔드포인트인 \u0026ldquo;destination\u0026quot;으로부터 메시지를 송수신합니다. TCP 또는 UDP 관점에서 destination은 (대체로) 호스트명과 포트 번호 쌍과 동등한 것으로 간주될 수 있지만, 몇 가지 차이점이 있습니다.\nI2P destination 자체는 암호학적 구조입니다 — 이곳으로 전송되는 모든 데이터는 IPsec이 보편적으로 배포된 것처럼 암호화되며, 엔드포인트의 (익명화된) 위치는 DNSSEC이 보편적으로 배포된 것처럼 서명됩니다. I2P destination은 이동 가능한 식별자입니다 — 하나의 I2P router에서 다른 router로 이동할 수 있으며 (또는 \u0026ldquo;멀티홈\u0026rdquo; 방식으로 여러 router에서 동시에 작동할 수도 있습니다). 이는 단일 엔드포인트(포트)가 단일 호스트에 고정되어야 하는 TCP 또는 UDP 환경과는 상당히 다릅니다. I2P destination은 보기 어렵고 크기가 큽니다 — 내부적으로 암호화를 위한 2048비트 ElGamal 공개 키, 서명을 위한 1024비트 DSA 공개 키, 그리고 작업 증명이나 블라인드 데이터를 포함할 수 있는 가변 크기의 인증서를 포함합니다. 이러한 크고 복잡한 destination을 짧고 예쁜 이름(예: \u0026ldquo;irc.duck.i2p\u0026rdquo;)으로 참조하는 기존 방법들이 있지만, 이러한 기술들은 전역적 고유성을 보장하지 않으며(각 사용자의 컴퓨터에 로컬 데이터베이스로 저장되므로) 현재 메커니즘은 특별히 확장 가능하거나 안전하지 않습니다(호스트 목록 업데이트는 네이밍 서비스에 대한 \u0026ldquo;구독\u0026quot;을 사용하여 관리됩니다). 언젠가는 안전하고, 사람이 읽을 수 있으며, 확장 가능하고, 전역적으로 고유한 네이밍 시스템이 있을 수 있지만, 애플리케이션은 그것이 구현되어 있다는 것에 의존해서는 안 됩니다. 네이밍 시스템에 대한 추가 정보 를 확인할 수 있습니다.\n대부분의 애플리케이션은 프로토콜과 포트를 구분할 필요가 없지만, I2P는 이를 지원합니다. 복잡한 애플리케이션은 단일 destination에서 트래픽을 다중화하기 위해 메시지별로 프로토콜, 출발 포트, 도착 포트를 지정할 수 있습니다. 자세한 내용은 datagram 페이지 를 참조하세요. 간단한 애플리케이션은 destination의 \u0026ldquo;모든 포트\u0026quot;에서 \u0026ldquo;모든 프로토콜\u0026quot;을 수신하는 방식으로 작동합니다.\n익명성과 기밀성 I2P는 네트워크를 통해 전달되는 모든 데이터에 대해 투명한 종단 간 암호화 및 인증을 제공합니다. Bob이 Alice의 destination으로 데이터를 보내면 Alice의 destination만 이를 수신할 수 있으며, Bob이 데이터그램 또는 스트리밍 라이브러리를 사용하는 경우 Alice는 해당 데이터를 보낸 것이 Bob의 destination임을 확실하게 알 수 있습니다.\n물론 I2P는 Alice와 Bob 사이에 전송되는 데이터를 투명하게 익명화하지만, 그들이 보내는 콘텐츠 자체를 익명화하지는 않습니다. 예를 들어, Alice가 Bob에게 자신의 전체 이름, 정부 발급 신분증, 신용카드 번호가 포함된 양식을 보낸다면, I2P가 할 수 있는 일은 없습니다. 따라서 프로토콜과 애플리케이션은 어떤 정보를 보호하려고 하는지, 그리고 어떤 정보를 노출할 의향이 있는지를 염두에 두어야 합니다.\nI2P 데이터그램은 최대 수 KB까지 가능합니다 I2P 데이터그램(raw 또는 repliable)을 사용하는 애플리케이션은 본질적으로 UDP 관점에서 생각할 수 있습니다 — 데이터그램은 순서가 없고, 최선 노력(best effort) 방식이며, 비연결형입니다 — 그러나 UDP와 달리 애플리케이션은 MTU 감지에 대해 걱정할 필요가 없으며 단순히 대용량 데이터그램을 전송할 수 있습니다. 명목상 상한선은 32 KB이지만, 메시지는 전송을 위해 단편화되므로 전체의 신뢰성이 떨어집니다. 현재 약 10 KB 이상의 데이터그램은 권장되지 않습니다. 자세한 내용은 데이터그램 페이지 를 참조하세요. 많은 애플리케이션의 경우 10 KB의 데이터는 전체 요청 또는 응답에 충분하므로, 단편화, 재전송 등을 작성할 필요 없이 UDP와 유사한 애플리케이션으로 I2P에서 투명하게 작동할 수 있습니다.\n개발 옵션 I2P를 통해 데이터를 전송하는 방법에는 여러 가지가 있으며, 각각 장단점이 있습니다. streaming lib는 대부분의 I2P 애플리케이션에서 사용되는 권장 인터페이스입니다.\n스트리밍 라이브러리 전체 streaming 라이브러리 가 이제 표준 인터페이스입니다. Streaming 개발 가이드 에서 설명한 대로 TCP와 유사한 소켓을 사용한 프로그래밍이 가능합니다.\nBOB BOB는 Basic Open Bridge 로, 모든 언어로 작성된 애플리케이션이 I2P와 스트리밍 연결을 주고받을 수 있게 해줍니다. 현재 시점에서는 UDP 지원이 부족하지만, 가까운 미래에 UDP 지원이 계획되어 있습니다. BOB는 또한 destination 키 생성, 주소가 I2P 사양을 준수하는지 검증하는 등 여러 도구를 포함하고 있습니다. 최신 정보와 BOB를 사용하는 애플리케이션은 이 I2P 사이트 에서 찾을 수 있습니다.\nSAM, SAM V2, SAM V3 SAM은 권장되지 않습니다. SAM V2는 괜찮으며, SAM V3가 권장됩니다.\nSAM은 Simple Anonymous Messaging 프로토콜로, 어떤 언어로 작성된 애플리케이션이든 일반 TCP 소켓을 통해 SAM 브리지와 통신할 수 있게 하며, 해당 브리지가 모든 I2P 트래픽을 다중화하고 암호화/복호화 및 이벤트 기반 처리를 투명하게 조정합니다. SAM은 세 가지 작동 방식을 지원합니다:\n스트림: Alice와 Bob이 서로에게 데이터를 안정적이고 순서대로 전송하고자 할 때 사용 응답 가능한 데이터그램: Alice가 Bob에게 Bob이 응답할 수 있는 메시지를 보내고자 할 때 사용 원시 데이터그램: Alice가 최대한의 대역폭과 성능을 확보하고자 하며, Bob이 데이터 발신자의 인증 여부를 신경 쓰지 않을 때 사용 (예: 전송되는 데이터가 자체 인증됨) SAM V3는 SAM 및 SAM V2와 동일한 목표를 지향하지만, 멀티플렉싱/디멀티플렉싱을 필요로 하지 않습니다. 각 I2P stream은 애플리케이션과 SAM bridge 사이의 고유한 소켓으로 처리됩니다. 또한, 애플리케이션은 SAM bridge와의 데이터그램 통신을 통해 데이터그램을 송수신할 수 있습니다.\nSAM V2 는 imule에서 사용되는 새 버전으로, SAM 의 일부 문제점을 수정합니다.\nSAM V3 는 버전 1.4.0부터 imule에서 사용됩니다.\nI2PTunnel I2PTunnel 애플리케이션은 I2PTunnel \u0026lsquo;클라이언트\u0026rsquo; 애플리케이션(특정 포트를 리스닝하고 해당 포트에 소켓이 열릴 때마다 특정 I2P destination에 연결)이나 I2PTunnel \u0026lsquo;서버\u0026rsquo; 애플리케이션(특정 I2P destination을 리스닝하고 새로운 I2P 연결을 받을 때마다 특정 TCP 호스트/포트로 아웃프록시)을 생성하여 애플리케이션이 피어에 대한 특정 TCP-like tunnel을 구축할 수 있게 합니다. 이러한 스트림은 8비트 클린이며, SAM이 사용하는 것과 동일한 스트리밍 라이브러리를 통해 인증되고 보안됩니다. 하지만 여러 개의 고유한 I2PTunnel 인스턴스를 생성하는 데는 상당한 오버헤드가 수반되는데, 각각이 고유한 I2P destination과 자체 tunnel 세트, 키 등을 가지기 때문입니다.\nSOCKS I2P는 SOCKS V4 및 V5 프록시를 지원합니다. 아웃바운드 연결은 잘 작동합니다. 인바운드(서버) 및 UDP 기능은 불완전하고 테스트되지 않았을 수 있습니다.\nMinistreaming 제거됨\n예전에는 간단한 \u0026ldquo;ministreaming\u0026rdquo; 라이브러리가 있었지만, 현재 ministreaming.jar에는 전체 streaming 라이브러리의 인터페이스만 포함되어 있습니다.\n데이터그램 UDP와 유사한 애플리케이션에 권장됨\nDatagram 라이브러리 를 사용하면 UDP와 유사한 패킷을 전송할 수 있습니다. 다음을 사용할 수 있습니다:\n응답 가능한 데이터그램 원시 데이터그램 I2CP 권장하지 않음\nI2CP 자체는 언어 독립적인 프로토콜이지만, Java가 아닌 다른 언어로 I2CP 라이브러리를 구현하려면 상당한 양의 코드를 작성해야 합니다(암호화 루틴, 객체 마샬링, 비동기 메시지 처리 등). 누군가 C나 다른 언어로 I2CP 라이브러리를 작성할 수도 있지만, 대신 C SAM 라이브러리를 사용하는 것이 더 유용할 것입니다.\n웹 애플리케이션 I2P는 Jetty 웹서버와 함께 제공되며, Apache 서버를 대신 사용하도록 구성하는 것은 간단합니다. 모든 표준 웹 앱 기술이 작동해야 합니다.\n개발 시작하기 — 간단한 가이드 I2P를 사용한 개발에는 작동하는 I2P 설치와 선택한 개발 환경이 필요합니다. Java를 사용하는 경우 streaming library 또는 datagram library로 개발을 시작할 수 있습니다. 다른 프로그래밍 언어를 사용하는 경우 SAM 또는 BOB을 사용할 수 있습니다.\nStreaming Library를 사용한 개발 아래는 원본 페이지의 예제를 축약하고 현대화한 버전입니다. 전체 예제는 레거시 페이지 또는 코드베이스의 Java 예제를 참조하세요.\n// Server example (excerpt) I2PSocketManager manager = I2PSocketManagerFactory.createManager(); I2PServerSocket server = manager.getServerSocket(); I2PSocket socket = server.accept(); BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream())); String s; while ((s = br.readLine()) != null) { System.out.println(\u0026#34;Received: \u0026#34; + s); } 코드 예제: 데이터를 수신하는 기본 서버.\n// Client example (excerpt) I2PSocketManager manager = I2PSocketManagerFactory.createManager(); Destination dest = new Destination(serverDestBase64); I2PSocket socket = manager.connect(dest); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream())); bw.write(\u0026#34;Hello I2P!\\n\u0026#34;); bw.flush(); 코드 예제: 클라이언트 연결 및 한 줄 전송.\n","description":"I2P 전용 앱을 작성하는 이유, 핵심 개념, 개발 옵션 및 간단한 시작 가이드","id":"d137fc4f3bedf693b877aa1ba9bde3eb","section":"docs","title":"애플리케이션 개발","url":"/ko/docs/develop/applications/"},{"categories":null,"content":"애플리케이션에 I2P를 번들링하는 것은 사용자를 온보딩하는 강력한 방법입니다. 단, router가 책임감 있게 구성되어 있을 때만 가능합니다.\n1. 라우터 팀과 협력 번들링하기 전에 Java I2P와 i2pd 유지관리자에게 연락하세요. 그들은 여러분의 기본 설정을 검토하고 호환성 문제를 강조할 수 있습니다. 스택에 맞는 router 구현을 선택하세요: Java/Scala → Java I2P C/C++ → i2pd 기타 언어 → router를 번들링하고 SAM v3 또는 I2CP 를 사용하여 통합 router 바이너리와 의존성(Java 런타임, ICU 등)에 대한 재배포 조건을 확인하세요. 2. 권장 구성 기본값 \u0026ldquo;소비하는 것보다 더 많이 기여하기\u0026quot;를 목표로 하세요. 최신 기본 설정은 네트워크 건강성과 안정성을 우선시합니다.\nSetting Recommended Default (2025) Bandwidth share 80% for participating tunnels Tunnel quantities i2pd: 3 inbound / 3 outbound; Java I2P: 2 inbound / 2 outbound. Signature \u0026amp; encryption Use Ed25519 (SIGNATURE_TYPE=7) and advertise ECIES-X25519 + ElGamal (i2cp.leaseSetEncType=4,0). Client protocols Use SAM v3 or I2CP. API listeners Bind SAM/I2CP to 127.0.0.1 only. Disable if not needed. UI toggles Expose bandwidth controls, logs, and an opt-in checkbox for participating tunnels. ### 참여 터널은 여전히 필수적입니다 참여 터널을 비활성화하지 마십시오.\n중계하지 않는 router는 자체 성능이 저하됩니다. 네트워크는 자발적인 용량 공유에 의존합니다. 커버 트래픽(중계된 트래픽)은 익명성을 향상시킵니다. 공식 최소 요구사항: - 공유 대역폭: ≥ 12 KB/s - Floodfill 자동 참여: ≥ 128 KB/s - 권장사항: 인바운드 터널 2개 / 아웃바운드 터널 2개 (Java I2P 기본값)\n3. 지속성 및 리시딩 지속적인 상태 디렉토리(netDb/, 프로필, 인증서)는 실행 사이에 보존되어야 합니다.\n지속성 없이는, 사용자들이 매번 시작할 때마다 리시드를 트리거하게 되어 성능이 저하되고 리시드 서버의 부하가 증가합니다.\n지속성이 불가능한 경우 (예: 컨테이너 또는 임시 설치):\n설치 프로그램에 1,000–2,000개의 router info를 포함시키세요. 공개 서버의 부하를 줄이기 위해 하나 이상의 맞춤형 reseed 서버를 운영하세요. 구성 변수: - 기본 디렉토리: i2p.dir.base - 설정 디렉토리: i2p.dir.config - 리시딩을 위한 certificates/ 포함.\n4. 보안 및 노출 router console (127.0.0.1:7657)을 로컬 전용으로 유지하세요. UI를 외부에 노출할 경우 HTTPS를 사용하세요. 필요하지 않은 경우 외부 SAM/I2CP를 비활성화하세요. 포함된 플러그인을 검토하고 앱이 지원하는 것만 제공하세요. 원격 콘솔 접근 시 항상 인증을 포함하세요. 2.5.0 이후 도입된 보안 기능: - 애플리케이션 간 NetDB 격리 (2.4.0+) - DoS 완화 및 Tor 차단 목록 (2.5.1) - NTCP2 프로빙 저항 (2.9.0) - Floodfill 라우터 선택 개선 (2.6.0+)\n5. 지원되는 API (2025) API Status Notes SAM v3 (3.3) ✅ Active Recommended bridge for non-Java apps. I2CP ✅ Active Stable protocol core, used internally by Java I2P. I2PControl ✅ Active JSON-RPC API; plugin maintained. BOB ⚠️ Deprecated Removed from Java I2P since 1.7.0; use SAM v3 instead. 모든 공식 문서는 `/docs/api/` 하위에 위치합니다 — 이전 `/spec/samv3/` 경로는 **존재하지 않습니다**. 6. 네트워킹 및 포트 일반적인 기본 포트: - 4444 – HTTP 프록시 - 4445 – HTTPS 프록시 - 7654 – I2CP - 7656 – SAM Bridge - 7657 – Router Console - 7658 – 로컬 I2P 사이트 - 6668 – IRC 프록시 - 9000–31000 – 임의 router 포트 (UDP/TCP 인바운드)\n라우터는 처음 실행할 때 임의의 인바운드 포트를 선택합니다. 포트 포워딩은 성능을 향상시키지만, UPnP가 자동으로 이를 처리할 수 있습니다.\n7. 최근 변경사항 (2024–2025) Change Status Details SSU1 Transport Removed SSU2 is now the exclusive UDP transport. I2P-over-Tor Blocked Since 2.6.0 (July 2024). Datagram2/3 Added Authenticated, repliable datagram formats (2.9.0). LeaseSet service records Added Enables service discovery (Proposal 167). Tunnel build parameters Improved Adaptive congestion handling (2.9.0+). Post-quantum crypto Introduced (beta) ML-KEM hybrid ratchet, opt-in from 2.10.0. Java 17 requirement Announced Becomes mandatory in 2.11.0 (early 2026). ## 8. 사용자 경험 및 테스트 I2P가 무엇을 하는지, 왜 대역폭이 공유되는지 설명합니다. router 진단 정보(대역폭, tunnel, reseed 상태)를 제공합니다. Windows, macOS, Linux(저사양 RAM 환경 포함)에서 번들을 테스트합니다. Java I2P와 i2pd 피어 모두와의 상호 운용성을 검증합니다. 네트워크 연결 끊김 및 비정상 종료로부터의 복구를 테스트합니다. 9. 커뮤니티 리소스 포럼: i2pforum.net 또는 I2P 내부에서 http://i2pforum.i2p. 코드: i2pgit.org/I2P_Developers/i2p.i2p . IRC (Irc2P 네트워크): #i2p-dev, #i2pd. #i2papps 미확인; 존재하지 않을 수 있습니다. 채널이 호스팅되는 네트워크(Irc2P vs ilita.i2p)를 명확히 하세요. 책임감 있는 임베딩은 사용자 경험, 성능, 네트워크 기여 간의 균형을 맞추는 것을 의미합니다. 이러한 기본값을 사용하고, router 관리자들과 동기화를 유지하며, 출시 전에 실제 환경 부하에서 테스트하세요.\n","description":"앱에 I2P router를 책임감 있게 번들링하기 위한 실용적인 가이드 업데이트","id":"f67f27efbc9bb7bff8d34001c14105ff","section":"docs","title":"애플리케이션에 I2P 임베딩하기","url":"/ko/docs/applications/embedding/"},{"categories":null,"content":"I2P의 이 구현체(이 사이트에서 배포되는 Java 구현체)는 법률상 타인을 위한 라우팅 참여가 제한될 수 있는 지역에서 router 동작을 조정하기 위해 사용되는 \u0026ldquo;Strict Countries List\u0026quot;를 포함하고 있습니다. I2P 사용을 금지하는 관할권에 대해서는 알지 못하지만, 일부 국가에서는 트래픽 중계에 대한 광범위한 금지 조항이 있습니다. \u0026ldquo;strict\u0026rdquo; 국가에 있는 것으로 보이는 router는 자동으로 Hidden 모드로 설정됩니다.\n프로젝트는 이러한 결정을 내릴 때 시민 및 디지털 권리 단체의 연구를 참조합니다. 특히 Freedom House의 지속적인 연구가 우리의 선택에 정보를 제공합니다. 일반적인 지침은 시민 자유(CL) 점수가 16점 이하이거나 인터넷 자유 점수가 39점 이하(자유롭지 않음)인 국가를 포함하는 것입니다.\n히든 모드 요약 라우터가 Hidden 모드로 설정되면 동작 방식에서 세 가지 주요 변화가 발생합니다:\nnetDb에 RouterInfo를 게시하지 않습니다. 중계 터널(participating tunnels)을 수락하지 않습니다. 같은 국가의 라우터에 대한 직접 연결을 거부합니다. 이러한 방어 메커니즘은 라우터를 안정적으로 열거하기 어렵게 만들고, 타인의 트래픽을 중계하는 것에 대한 지역 규제를 위반할 위험을 줄입니다.\n엄격한 국가 목록 (2024년 기준) /* Afghanistan */ \u0026#34;AF\u0026#34;, /* Azerbaijan */ \u0026#34;AZ\u0026#34;, /* Bahrain */ \u0026#34;BH\u0026#34;, /* Belarus */ \u0026#34;BY\u0026#34;, /* Brunei */ \u0026#34;BN\u0026#34;, /* Burundi */ \u0026#34;BI\u0026#34;, /* Cameroon */ \u0026#34;CM\u0026#34;, /* Central African Republic */ \u0026#34;CF\u0026#34;, /* Chad */ \u0026#34;TD\u0026#34;, /* China */ \u0026#34;CN\u0026#34;, /* Cuba */ \u0026#34;CU\u0026#34;, /* Democratic Republic of the Congo */ \u0026#34;CD\u0026#34;, /* Egypt */ \u0026#34;EG\u0026#34;, /* Equatorial Guinea */ \u0026#34;GQ\u0026#34;, /* Eritrea */ \u0026#34;ER\u0026#34;, /* Ethiopia */ \u0026#34;ET\u0026#34;, /* Iran */ \u0026#34;IR\u0026#34;, /* Iraq */ \u0026#34;IQ\u0026#34;, /* Kazakhstan */ \u0026#34;KZ\u0026#34;, /* Laos */ \u0026#34;LA\u0026#34;, /* Libya */ \u0026#34;LY\u0026#34;, /* Myanmar */ \u0026#34;MM\u0026#34;, /* North Korea */ \u0026#34;KP\u0026#34;, /* Palestinian Territories */ \u0026#34;PS\u0026#34;, /* Pakistan */ \u0026#34;PK\u0026#34;, /* Rwanda */ \u0026#34;RW\u0026#34;, /* Saudi Arabia */ \u0026#34;SA\u0026#34;, /* Somalia */ \u0026#34;SO\u0026#34;, /* South Sudan */ \u0026#34;SS\u0026#34;, /* Sudan */ \u0026#34;SD\u0026#34;, /* Eswatini (Swaziland) */ \u0026#34;SZ\u0026#34;, /* Syria */ \u0026#34;SY\u0026#34;, /* Tajikistan */ \u0026#34;TJ\u0026#34;, /* Thailand */ \u0026#34;TH\u0026#34;, /* Turkey */ \u0026#34;TR\u0026#34;, /* Turkmenistan */ \u0026#34;TM\u0026#34;, /* Venezuela */ \u0026#34;VE\u0026#34;, /* United Arab Emirates */ \u0026#34;AE\u0026#34;, /* Uzbekistan */ \u0026#34;UZ\u0026#34;, /* Vietnam */ \u0026#34;VN\u0026#34;, /* Western Sahara */ \u0026#34;EH\u0026#34;, /* Yemen */ \u0026#34;YE\u0026#34; 엄격한 목록에 국가를 추가하거나 제거해야 한다고 생각하시면, 이슈를 등록해 주세요: https://i2pgit.org/i2p/i2p.i2p/ 참고: Freedom House – https://freedomhouse.org/ ","description":"I2P가 라우팅 또는 익명성 도구에 제한이 있는 관할권에서 작동하는 방식 (Hidden Mode 및 strict list)","id":"483dc8380c381981cff8df178412f086","section":"docs","title":"엄격한/제한적인 국가","url":"/ko/docs/overview/restrictive-countries/"},{"categories":null,"content":"이 용어집은 I2P 문서 및 논의 전반에 걸쳐 사용되는 일반적인 용어를 정의합니다.\nB Blockchain 여러 당사자 간의 거래를 효율적이고 검증 가능하며 영구적인 방식으로 기록할 수 있는 분산 원장.\nD 탈중앙화(Decentralization) 단일 주체에 대한 의존을 피하는 네트워크 아키텍처. P2P, 블록체인, 연합형(federated), 분산 기술을 포괄한다.\nDestination I2P 네트워크 내에서 클라이언트와 서버의 식별자인 터널의 암호화 신원.\nDHT (Distributed Hash Table) 일부 프로젝트에서 분산 방식으로 키-값 쌍 형태의 정보를 저장하여 피어들을 서로 연결하는 데 사용됩니다.\n분산 시스템(Distributed Systems) 네트워크로 연결된 많은 개별 컴퓨터로 구성된 컴퓨터 시스템의 설계와 관련된 컴퓨터 과학 분야의 학술 주제.\nF 연합형(Federated) 연합은 서비스의 개별 배포들이 공통 프로토콜을 통해 서로 통신할 수 있도록 합니다.\nH Hash 데이터를 고유하게 식별하는 \u0026ldquo;지문\u0026rdquo; 역할을 할 수 있는 숫자로, 일반적으로 문자와 숫자의 문자열로 표시됩니다.\nI I2P Invisible Internet Project: 사용자가 다양한 애플리케이션을 사용하여 익명으로 통신할 수 있도록 익명성 계층을 제공하기 위한 프로젝트.\nIP 주소(IP Address) 컴퓨터나 네트워크의 고유한 번호로, 이를 통해 해당 컴퓨터나 네트워크의 주소를 지정할 수 있습니다.\nL LeaseSet 특정 Destination에서 클라이언트 또는 서버와 통신하는 데 필요한 정보의 모음.\nP Peer-to-Peer (P2P) 피어들은 서버나 안정적인 호스트에 의한 중앙 조정 없이, 자신의 리소스 일부를 다른 네트워크 참여자들에게 직접 제공합니다.\nR Router I2P 네트워크에서 암호화된 패킷을 라우팅하는 핵심 I2P 소프트웨어.\nRouterIdentity 라우터와 직접 통신하는 데 필요한 정보의 모음.\nT TCP/UDP 인터넷에서 사용되는 두 가지 기본 전송 프로토콜.\nTunnel 클라이언트 또는 서버와 I2P 네트워크 간의 익명 통신 경로.\nU UX 사용자 경험(User experience), 제품이나 서비스를 사용하는 사람의 전반적인 경험.\nW WebRTC 웹 브라우저에서 사용자 간에 데이터가 직접 전달되는 연결을 설정하기 위한 프로토콜 표준.\n","description":"I2P 문서에서 사용되는 일반 용어 및 정의","id":"2235ec8f316773700ef08dd43b19a1c0","section":"docs","title":"용어집","url":"/ko/docs/overview/%EC%9A%A9%EC%96%B4%EC%A7%91/"},{"categories":null,"content":"이 가이드는 일반적인 브라우저에서 I2P의 내장 HTTP 프록시를 통해 트래픽을 전송하도록 설정하는 방법을 보여줍니다. Safari, Firefox, Chrome/Chromium 브라우저에 대한 자세한 단계별 지침을 다룹니다.\n중요 사항:\nI2P의 기본 HTTP 프록시는 127.0.0.1:4444에서 수신 대기합니다. I2P는 I2P 네트워크 내부의 트래픽(.i2p 사이트)을 보호합니다. 브라우저를 구성하기 전에 I2P router가 실행 중인지 확인하세요. Safari (macOS) Safari는 macOS의 시스템 전체 프록시 설정을 사용합니다.\nStep 1: Open Network Settings Safari를 열고 Safari → 설정(또는 환경설정)으로 이동 고급 탭 클릭 프록시 섹션에서 설정 변경\u0026hellip; 클릭 이렇게 하면 Mac의 시스템 네트워크 설정이 열립니다.\n1단계: 네트워크 설정 열기 네트워크 설정에서 웹 프록시(HTTP) 확인란을 선택합니다 다음 정보를 입력합니다: 웹 프록시 서버: 127.0.0.1 포트: 4444 확인을 클릭하여 설정을 저장합니다 이제 Safari에서 .i2p 사이트를 탐색할 수 있습니다!\n참고: 이러한 프록시 설정은 macOS 시스템 프록시를 사용하는 모든 애플리케이션에 영향을 미칩니다. I2P 브라우징을 격리하려면 별도의 사용자 계정을 생성하거나 I2P 전용 브라우저를 사용하는 것을 고려하세요.\nFirefox (Desktop) Firefox는 시스템과 독립적인 자체 프록시 설정을 가지고 있어 I2P 전용 브라우징에 이상적입니다.\n2단계: HTTP 프록시 설정 오른쪽 상단의 메뉴 버튼(☰)을 클릭합니다 설정을 선택합니다 Step 2: Find Proxy Settings 설정 검색창에 **\u0026ldquo;proxy\u0026rdquo;**를 입력하세요 네트워크 설정으로 스크롤하세요 설정\u0026hellip; 버튼을 클릭하세요 1단계: 설정 열기 수동 프록시 구성 선택 다음을 입력: HTTP 프록시: 127.0.0.1 포트: 4444 SOCKS 호스트는 비워둠 (SOCKS 프록시가 특별히 필요한 경우가 아니라면) SOCKS 프록시를 사용하는 경우에만 SOCKS 사용 시 DNS 프록시 체크 확인을 클릭하여 저장 이제 Firefox에서 .i2p 사이트를 탐색할 수 있습니다!\n팁: I2P 브라우징 전용 Firefox 프로필을 별도로 생성하는 것을 고려하세요. 이렇게 하면 I2P 브라우징을 일반 브라우징과 분리할 수 있습니다. 프로필을 생성하려면 Firefox 주소 표시줄에 about:profiles를 입력하세요.\nChrome / Chromium (Desktop) Chrome 및 Chromium 기반 브라우저(Brave, Edge 등)는 일반적으로 Windows와 macOS에서 시스템 프록시 설정을 사용합니다. 이 가이드는 Windows 구성을 보여줍니다.\n2단계: 프록시 설정 찾기 오른쪽 상단의 세 점 메뉴 (⋮)를 클릭합니다 Settings를 선택합니다 3단계: 수동 프록시 설정 설정 검색 상자에 \u0026ldquo;proxy\u0026rdquo; 입력 컴퓨터의 프록시 설정 열기 클릭 Step 3: Open Manual Proxy Setup Windows 네트워크 및 인터넷 설정이 열립니다.\n수동 프록시 설정까지 아래로 스크롤합니다 설정을 클릭합니다 1단계: Chrome 설정 열기 프록시 서버 사용을 켜짐으로 전환 다음을 입력: 프록시 IP 주소: 127.0.0.1 포트: 4444 선택 사항으로 **\u0026ldquo;다음으로 시작하는 주소에는 프록시 서버 사용 안 함\u0026rdquo;**에 예외를 추가 (예: localhost;127.*) 저장 클릭 이제 Chrome에서 .i2p 사이트를 탐색할 수 있습니다!\n참고: 이 설정은 Windows의 모든 Chromium 기반 브라우저와 일부 다른 애플리케이션에 영향을 미칩니다. 이를 방지하려면 전용 I2P 프로필을 사용하는 Firefox를 사용하는 것을 고려하십시오.\n2단계: 프록시 설정 열기 Linux에서는 시스템 설정을 변경하지 않고 프록시 플래그를 사용하여 Chrome/Chromium을 실행할 수 있습니다:\nchromium \\ --proxy-server=\u0026#34;http=127.0.0.1:4444 \\ --proxy-bypass-list=\u0026#34;\u0026lt;-loopback\u0026gt;\u0026#34; 또는 데스크톱 실행 스크립트를 생성합니다:\n#!/bin/bash chromium --proxy-server=\u0026#34;http=127.0.0.1:4444\u0026#34; --user-data-dir=\u0026#34;$HOME/.config/chromium-i2p\u0026#34; --user-data-dir 플래그는 I2P 브라우징을 위한 별도의 Chrome 프로필을 생성합니다.\nFirefox (데스크톱) 최신 \u0026ldquo;Fenix\u0026rdquo; Firefox 빌드는 기본적으로 about:config와 확장 기능을 제한합니다. IceRaven은 선별된 확장 기능 세트를 활성화하는 Firefox 포크로, 프록시 설정을 간단하게 만들어줍니다.\n확장 기능 기반 설정 (IceRaven):\n이미 IceRaven을 사용 중이라면 먼저 브라우징 기록을 삭제하는 것을 고려하세요 (메뉴 → 기록 → 기록 삭제). 2) 메뉴 → 부가 기능 → 부가 기능 관리자를 여세요. 3) \u0026ldquo;I2P Proxy for Android and Other Systems\u0026rdquo; 확장 프로그램을 설치하세요. 4) 이제 브라우저가 I2P를 통해 프록시됩니다. 이 확장 프로그램은 AMO 에서 설치하는 경우 Fenix 이전 Firefox 기반 브라우저에서도 작동합니다.\nFirefox Nightly에서 광범위한 확장 기능 지원을 활성화하려면 Mozilla에서 문서화한 별도의 프로세스가 필요합니다.\nInternet Explorer / Windows System Proxy Windows에서는 시스템 프록시 대화 상자가 IE에 적용되며, Chromium 기반 브라우저가 시스템 설정을 상속받을 때 사용할 수 있습니다.\n\u0026ldquo;네트워크 및 인터넷 설정\u0026rdquo; → \u0026ldquo;프록시\u0026quot;를 엽니다. 2) \u0026ldquo;LAN에 프록시 서버 사용\u0026quot;을 활성화합니다. 3) HTTP에 대해 주소 127.0.0.1, 포트 4444를 설정합니다. 4) 선택 사항으로 \u0026ldquo;로컬 주소에 대해 프록시 서버 사용 안 함\u0026quot;을 선택합니다. ","description":"데스크톱과 Android에서 I2P의 HTTP/HTTPS 프록시를 사용하도록 인기 있는 브라우저 설정하기","id":"a40410c542dc82558c1c1a8be78d2e62","section":"docs","title":"웹 브라우저 설정","url":"/ko/docs/guides/browser-config/"},{"categories":null,"content":"I2P Router 도움말 I2P는 어떤 시스템에서 실행되나요? I2P는 Java 프로그래밍 언어로 작성되었습니다. Windows, Linux, FreeBSD 및 OSX에서 테스트되었으며, Android 포트도 사용할 수 있습니다.\n메모리 사용량 측면에서 I2P는 기본적으로 128 MB의 RAM을 사용하도록 구성되어 있습니다. 이는 브라우징과 IRC 사용에 충분합니다. 그러나 다른 활동들은 더 많은 메모리 할당이 필요할 수 있습니다. 예를 들어, 고대역폭 router를 실행하거나, I2P 토렌트에 참여하거나, 트래픽이 많은 hidden service를 제공하려는 경우 더 많은 메모리가 필요합니다.\nCPU 사용량 측면에서 I2P는 Raspberry Pi 시리즈의 싱글보드 컴퓨터와 같은 저사양 시스템에서도 실행되도록 테스트되었습니다. I2P는 암호화 기술을 많이 사용하기 때문에, 더 강력한 CPU가 I2P에서 생성되는 워크로드와 시스템의 나머지 작업(예: 운영 체제, GUI, 웹 브라우징과 같은 기타 프로세스)을 처리하는 데 더 적합합니다.\nSun/Oracle Java 또는 OpenJDK 사용을 권장합니다.\nI2P를 사용하려면 Java 설치가 필요한가요? 네, I2P Core를 사용하려면 Java가 필요합니다. Windows, Mac OSX, Linux용 간편 설치 프로그램에는 Java가 포함되어 있습니다. I2P Android 앱을 실행하는 경우 대부분 Dalvik 또는 ART와 같은 Java 런타임이 설치되어 있어야 합니다.\n\u0026ldquo;I2P Site\u0026quot;란 무엇이며 브라우저를 어떻게 설정해야 사용할 수 있나요? I2P 사이트는 I2P 내부에서 호스팅된다는 점을 제외하면 일반 웹사이트와 동일합니다. I2P 사이트는 사람들의 편의를 위해 사람이 읽을 수 있는 비암호화 방식으로 \u0026ldquo;.i2p\u0026quot;로 끝나는 일반 인터넷 주소와 유사한 주소를 가지고 있습니다. 실제로 I2P 사이트에 연결하려면 암호화가 필요하며, 이는 I2P 사이트 주소가 긴 \u0026ldquo;Base64\u0026rdquo; Destinations 및 더 짧은 \u0026ldquo;B32\u0026rdquo; 주소이기도 하다는 것을 의미합니다. 올바르게 탐색하려면 추가 구성이 필요할 수 있습니다. I2P 사이트를 탐색하려면 I2P 설치에서 HTTP 프록시를 활성화한 다음 브라우저가 이를 사용하도록 구성해야 합니다. 자세한 내용은 아래의 \u0026ldquo;Browsers\u0026rdquo; 섹션 또는 \u0026ldquo;Browser Configuration\u0026rdquo; 가이드를 참조하세요.\n라우터 콘솔의 Active x/y 숫자는 무엇을 의미하나요? 라우터 콘솔의 Peers 페이지에서 Active x/y와 같은 두 개의 숫자를 볼 수 있습니다. 첫 번째 숫자는 지난 몇 분 동안 메시지를 주고받은 피어의 수입니다. 두 번째 숫자는 최근에 확인된 피어의 수이며, 이 값은 항상 첫 번째 숫자보다 크거나 같습니다.\n내 라우터의 활성 피어 수가 매우 적은데, 괜찮은가요? 네, 특히 라우터가 방금 시작되었을 때는 정상적인 현상입니다. 새로운 라우터는 시작되고 네트워크의 나머지 부분에 연결되는 데 시간이 필요합니다. 네트워크 통합, 가동 시간 및 성능을 개선하려면 다음 설정을 검토하세요:\n대역폭 공유 - router가 대역폭을 공유하도록 설정되면 다른 router들을 위해 더 많은 트래픽을 라우팅하게 되며, 이는 네트워크의 나머지 부분과의 통합을 돕고 로컬 연결의 성능도 향상시킵니다. 이는 http://localhost:7657/config 페이지에서 설정할 수 있습니다. 네트워크 인터페이스 - http://localhost:7657/confignet 페이지에 특정 인터페이스가 지정되어 있지 않은지 확인하세요. 컴퓨터가 여러 외부 IP 주소를 가진 멀티홈 환경이 아니라면 성능이 저하될 수 있습니다. I2NP protocol - router가 호스트 운영 체제에 유효한 프로토콜로 연결을 기대하도록 설정되어 있고 네트워크(고급) 설정이 비어 있는지 확인하세요. 네트워크 설정 페이지의 \u0026lsquo;호스트명\u0026rsquo; 필드에 IP 주소를 입력하지 마세요. 여기서 선택한 I2NP Protocol은 이미 연결 가능한 주소가 없는 경우에만 사용됩니다. 예를 들어, 미국의 대부분의 Verizon 4G 및 5G 무선 연결은 UDP를 차단하며 UDP를 통해 연결할 수 없습니다. 다른 경우에는 UDP가 사용 가능하더라도 강제로 사용하려고 할 수 있습니다. 나열된 I2NP Protocols에서 합리적인 설정을 선택하세요. 특정 유형의 콘텐츠에 반대합니다. 이를 배포, 저장 또는 접근하지 않으려면 어떻게 해야 하나요? 이러한 콘텐츠는 기본적으로 설치되지 않습니다. 하지만 I2P는 peer-to-peer 네트워크이기 때문에, 우연히 금지된 콘텐츠를 접할 가능성이 있습니다. 다음은 I2P가 귀하의 신념을 침해하는 사항에 불필요하게 연루되지 않도록 방지하는 방법에 대한 요약입니다.\n배포 - 트래픽은 I2P 네트워크 내부에 한정되며, 귀하는 exit node (우리 문서에서는 outproxy로 지칭)가 아닙니다. 저장 - I2P 네트워크는 콘텐츠의 분산 저장을 수행하지 않으며, 이는 사용자가 별도로 설치하고 구성해야 합니다(예: Tahoe-LAFS 사용). 이는 다른 익명 네트워크인 Freenet 의 기능입니다. I2P router를 실행한다고 해서 다른 사람을 위해 콘텐츠를 저장하는 것은 아닙니다. 접근 - 귀하의 router는 귀하의 명시적인 지시 없이 어떠한 콘텐츠도 요청하지 않습니다. I2P를 차단할 수 있나요? 네, 가장 쉽고 일반적인 방법은 bootstrap 또는 \u0026ldquo;Reseed\u0026rdquo; 서버를 차단하는 것입니다. 모든 난독화된 트래픽을 완전히 차단하는 것도 효과가 있지만 (I2P가 아닌 다른 많은 것들도 중단되며, 대부분은 이 정도까지 가려 하지 않습니다). reseed 차단의 경우, Github에 reseed 번들이 있는데, 이를 차단하면 Github도 함께 차단됩니다. 프록시를 통해 reseed할 수 있으며 (Tor를 사용하고 싶지 않다면 인터넷에서 많은 프록시를 찾을 수 있습니다) 또는 오프라인으로 친구 간에 reseed 번들을 공유할 수 있습니다.\nwrapper.log에서 Router Console을 로드할 때 \u0026ldquo;Protocol family unavailable\u0026rdquo; 오류가 표시됩니다 이 오류는 기본적으로 IPv6를 사용하도록 구성된 일부 시스템에서 네트워크가 활성화된 Java 소프트웨어를 사용할 때 발생할 수 있습니다. 이 문제를 해결하는 몇 가지 방법이 있습니다:\nLinux 기반 시스템에서는 echo 0 \u0026gt; /proc/sys/net/ipv6/bindv6only 명령을 실행할 수 있습니다 wrapper.config 파일에서 다음 라인들을 찾으세요: #wrapper.java.additional.5=-Djava.net.preferIPv4Stack=true #wrapper.java.additional.6=-Djava.net.preferIPv6Addresses=false 해당 라인들이 있다면 \u0026ldquo;#\u0026ldquo;을 제거하여 주석을 해제하세요. 라인들이 없다면 \u0026ldquo;#\u0026rdquo; 없이 추가하세요. 다른 방법은 ~/.i2p/clients.config에서 ::1을 제거하는 것입니다\n경고: wrapper.config에 대한 모든 변경 사항을 적용하려면 router와 wrapper를 완전히 중지해야 합니다. router 콘솔에서 재시작을 클릭하는 것만으로는 이 파일을 다시 읽지 않습니다! 종료를 클릭하고 11분을 기다린 후 I2P를 시작해야 합니다.\nI2P 내의 대부분의 I2P 사이트가 다운되었나요? 지금까지 생성된 모든 I2P Site를 고려한다면, 네, 대부분은 다운되어 있습니다. 사람들과 I2P Site는 생겨났다가 사라집니다. I2P를 시작하는 좋은 방법은 현재 운영 중인 I2P Site 목록을 확인하는 것입니다. identiguy.i2p 는 활성화된 I2P Site를 추적합니다.\n왜 I2P가 포트 32000에서 수신 대기하나요? 우리가 사용하는 Tanuki java 서비스 래퍼는 JVM 내부에서 실행되는 소프트웨어와 통신하기 위해 localhost에 바인딩된 이 포트를 엽니다. JVM이 실행될 때 래퍼에 연결할 수 있도록 키가 제공됩니다. JVM이 래퍼에 연결을 설정한 후, 래퍼는 추가 연결을 거부합니다.\n자세한 정보는 wrapper 문서 에서 확인할 수 있습니다.\n브라우저를 어떻게 설정하나요? 다양한 브라우저의 프록시 설정은 스크린샷과 함께 별도의 페이지에 있습니다. 브라우저 플러그인 FoxyProxy나 프록시 서버 Privoxy와 같은 외부 도구를 사용한 고급 설정도 가능하지만, 설정에서 정보 유출이 발생할 수 있습니다.\nI2P 내에서 IRC에 어떻게 연결하나요? I2P 내 메인 IRC 서버인 Irc2P로 가는 터널은 I2P 설치 시 생성되며(I2PTunnel 설정 페이지 참조), I2P router가 시작될 때 자동으로 시작됩니다. 연결하려면 IRC 클라이언트가 localhost 6668에 연결하도록 설정하세요. HexChat 계열 클라이언트 사용자는 서버 localhost/6668로 새 네트워크를 생성할 수 있습니다(프록시 서버를 설정한 경우 \u0026ldquo;프록시 서버 우회\u0026rdquo; 옵션을 체크하는 것을 잊지 마세요). Weechat 사용자는 다음 명령어를 사용하여 새 네트워크를 추가할 수 있습니다:\n/server add irc2p localhost/6668 내 I2P 사이트를 어떻게 설정하나요? 가장 쉬운 방법은 router console의 i2ptunnel 링크를 클릭하고 새로운 \u0026lsquo;Server Tunnel\u0026rsquo;을 생성하는 것입니다. Tomcat이나 Jetty와 같은 기존 웹서버의 포트로 tunnel 목적지를 설정하여 동적 콘텐츠를 제공할 수 있습니다. 정적 콘텐츠도 제공할 수 있습니다. 이를 위해 tunnel 목적지를 0.0.0.0 port 7659로 설정하고 콘텐츠를 ~/.i2p/eepsite/docroot/ 디렉토리에 배치하세요. (Linux가 아닌 시스템에서는 다른 위치에 있을 수 있습니다. router console을 확인하세요.) \u0026rsquo;eepsite\u0026rsquo; 소프트웨어는 I2P 설치 패키지의 일부로 제공되며 I2P가 시작될 때 자동으로 시작되도록 설정되어 있습니다. 이렇게 생성된 기본 사이트는 http://127.0.0.1:7658 에서 접근할 수 있습니다. 하지만 당신의 \u0026rsquo;eepsite\u0026rsquo;는 ~/.i2p/eepsite/i2p/eepsite.keys에 위치한 eepsite 키 파일을 통해 다른 사람들도 접근할 수 있습니다. 자세한 내용은 ~/.i2p/eepsite/README.txt의 readme 파일을 읽어보세요.\n집에서 HTML과 CSS만 포함된 웹사이트를 I2P에 호스팅하면 위험한가요? 이는 당신의 적대자와 위협 모델에 따라 다릅니다. 기업의 \u0026ldquo;프라이버시\u0026rdquo; 침해, 일반적인 범죄자, 검열만 걱정한다면 실제로 위험하지 않습니다. 법 집행 기관은 정말로 원한다면 아마도 어쨌든 당신을 찾을 것입니다. 일반적인 (인터넷) 가정용 브라우저가 실행 중일 때만 호스팅하면 누가 해당 부분을 호스팅하는지 알아내기가 정말 어려워질 것입니다. I2P 사이트 호스팅은 다른 서비스를 호스팅하는 것과 마찬가지로 생각하세요 - 당신이 직접 구성하고 관리하는 만큼 위험하거나 안전합니다.\n참고: i2p 서비스(destination)를 i2p router와 분리하여 호스팅하는 방법이 이미 존재합니다. 작동 방식을 이해하고 있다면, 공개적으로 접근 가능한 웹사이트(또는 서비스)를 위한 서버로 별도의 머신을 설정하고, [매우] 안전한 SSH 터널을 통해 웹서버로 포워딩하거나 보안이 적용된 공유 파일시스템을 사용할 수 있습니다.\nI2P는 \u0026ldquo;.i2p\u0026rdquo; 웹사이트를 어떻게 찾나요? I2P 주소록 애플리케이션은 사람이 읽을 수 있는 이름을 서비스와 연결된 장기 destination에 매핑하여, 네트워크 데이터베이스나 DNS 서비스보다는 hosts 파일이나 연락처 목록에 가깝습니다. 또한 로컬 우선 방식으로 작동하며, 인정받는 전역 네임스페이스가 없어 특정 .i2p 도메인이 무엇에 매핑될지는 최종적으로 사용자가 결정합니다. 중간 단계로는 \u0026ldquo;Jump Service\u0026quot;라는 것이 있는데, 이는 \u0026ldquo;I2P router가 $SITE_CRYPTO_KEY를 $SITE_NAME.i2p라는 이름으로 호출하도록 허용하시겠습니까?\u0026ldquo;와 같은 내용의 페이지로 리디렉션하여 사람이 읽을 수 있는 이름을 제공합니다. 주소록에 추가되면, 다른 사람들과 사이트를 공유하는 데 도움이 되는 자체 jump URL을 생성할 수 있습니다.\n주소록에 주소를 추가하려면 어떻게 하나요? 방문하려는 사이트의 base32 또는 base64를 최소한 알지 못하면 주소를 추가할 수 없습니다. 사람이 읽을 수 있는 \u0026ldquo;호스트명\u0026quot;은 base32 또는 base64에 해당하는 암호화 주소의 별칭일 뿐입니다. 암호화 주소가 없으면 I2P 사이트에 접근할 방법이 없으며, 이는 의도된 설계입니다. 아직 주소를 모르는 사람들에게 주소를 배포하는 것은 일반적으로 Jump 서비스 제공자의 책임입니다. 알려지지 않은 I2P 사이트를 방문하면 Jump 서비스 사용이 트리거됩니다. stats.i2p는 가장 신뢰할 수 있는 Jump 서비스입니다.\ni2ptunnel을 통해 사이트를 호스팅하는 경우, 아직 jump 서비스에 등록되어 있지 않습니다. 로컬에서 URL을 부여하려면 설정 페이지를 방문하여 \u0026ldquo;Add to Local Address Book\u0026rdquo; 버튼을 클릭하세요. 그런 다음 http://127.0.0.1:7657/dns로 이동하여 addresshelper URL을 조회하고 공유하세요.\nI2P는 어떤 포트를 사용하나요? I2P가 사용하는 포트는 2개 섹션으로 나눌 수 있습니다:\n다른 I2P router와 통신하는 데 사용되는 인터넷 연결 포트 로컬 연결을 위한 로컬 포트 이는 아래에서 자세히 설명됩니다.\n1. 인터넷 연결 포트 참고: 0.7.8 릴리스 이후로, 새로 설치할 때 포트 8887을 사용하지 않습니다. 프로그램을 처음 실행할 때 9000에서 31000 사이의 임의의 포트가 선택됩니다. 선택된 포트는 router 설정 페이지 에서 확인할 수 있습니다.\n아웃바운드\n설정 페이지 에 나열된 임의의 포트에서 임의의 원격 UDP 포트로의 UDP 통신, 응답 허용 임의의 높은 포트에서 임의의 원격 TCP 포트로의 TCP 통신 포트 123에서의 아웃바운드 UDP 통신, 응답 허용. 이는 I2P의 내부 시간 동기화(SNTP를 통해 - pool.ntp.org의 임의의 SNTP 호스트 또는 사용자가 지정한 다른 서버에 쿼리)에 필요합니다 인바운드\n(선택사항, 권장) 임의의 위치에서 설정 페이지 에 명시된 포트로의 UDP 연결 (선택사항, 권장) 임의의 위치에서 설정 페이지 에 명시된 포트로의 TCP 연결 인바운드 TCP는 설정 페이지 에서 비활성화할 수 있습니다 2. 로컬 I2P 포트 로컬 I2P 포트는 별도로 명시된 경우를 제외하고 기본적으로 로컬 연결만 수신합니다:\nPORT PURPOSE DESCRIPTION 1900 UPnP SSDP UDP multicast listener Cannot be changed. Binds to all interfaces. May be disabled on confignet. 2827 BOB bridge A higher level socket API for clients. Disabled by default. May be enabled/disabled on configclients. May be changed in the bob.config file. 4444 HTTP proxy Configured on configclients, go to the page i2ptunnel to start/stop it and on the page I2P HTTP Proxy to configure it. Include in your browser's proxy configuration for HTTP 4445 HTTPS proxy Configured on configclients, go to the page i2ptunnel to start/stop it and on the page I2P HTTPS Proxy to configure it. Include in your browser's proxy configuration for HTTPS 6668 IRC proxy A tunnel to the inside-the-I2P IRC network. Disabled by default. Configured on the page irc.postman.i2p (IRC proxy) and may be enabled/disabled on the page i2ptunnel 7654 I2CP (client protocol) port For advanced client usage. Do not expose to an external network. 7656 SAM bridge A socket API for clients. Disabled by default. May be enabled/disabled on configclients and configured on sam. 7657 (or 7658 via SSL) Router console The router console provides valuable information about your router and the network, in addition to giving you access to configure your router and its associated applications. 7659 'eepsite' - an example webserver (Jetty) Included in the i2pinstall and i2pupdate packages - may be disabled if another webserver is available. May be configured on the page eepsite and disabled on the page i2ptunnel 7660 I2PTunnel UDP port for SSH Required for Grizzled's/novg's UDP support. Instances disabled by default. May be enabled/disabled and configured to use a different port on the page i2ptunnel. 123 NTP Port Used by NTP Time Sync. May be disabled/changed. ### 내 주소록에 많은 호스트가 누락되어 있습니다. 좋은 구독 링크에는 어떤 것들이 있나요? {#subscriptions} 주소록은 http://localhost:7657/dns 에 위치하며, 여기서 추가 정보를 확인할 수 있습니다.\n좋은 주소록 구독 링크에는 어떤 것들이 있나요?\n다음을 시도해 보세요:\nhttp://stats.i2p/cgi-bin/newhosts.txt http://identiguy.i2p/hosts.txt 다른 기기에서 웹 콘솔에 접근하거나 비밀번호로 보호하려면 어떻게 해야 하나요? 보안상의 이유로, router의 관리 콘솔은 기본적으로 로컬 인터페이스에서만 연결을 수신합니다.\n콘솔에 원격으로 접근하는 두 가지 방법이 있습니다:\nSSH Tunnel 사용자 이름과 비밀번호를 사용하여 공용 IP 주소에서 콘솔을 사용할 수 있도록 구성하기 자세한 내용은 다음과 같습니다:\n방법 1: SSH 터널\nUnix 계열 운영체제를 사용하는 경우, I2P 콘솔에 원격으로 접속하는 가장 쉬운 방법입니다. (참고: SSH 서버 소프트웨어는 Windows를 실행하는 시스템에서도 사용할 수 있습니다. 예: https://github.com/PowerShell/Win32-OpenSSH )\n시스템에 대한 SSH 접근을 설정한 후, 적절한 인수와 함께 \u0026lsquo;-L\u0026rsquo; 플래그를 SSH에 전달합니다 - 예를 들어:\nssh -L 7657:localhost:7657 (System_IP) 여기서 \u0026lsquo;(System_IP)\u0026lsquo;는 시스템의 IP 주소로 대체됩니다. 이 명령은 포트 7657(첫 번째 콜론 앞의 숫자)을 원격 시스템의(첫 번째와 두 번째 콜론 사이의 \u0026rsquo;localhost\u0026rsquo; 문자열로 지정됨) 포트 7657(두 번째 콜론 뒤의 숫자)로 전달합니다. 이제 원격 I2P 콘솔은 로컬 시스템에서 \u0026lsquo;http://localhost:7657\u0026rsquo;로 사용할 수 있으며, SSH 세션이 활성화되어 있는 동안 계속 사용할 수 있습니다.\n원격 시스템에서 셸을 시작하지 않고 SSH 세션을 시작하려면 \u0026lsquo;-N\u0026rsquo; 플래그를 추가하면 됩니다:\nssh -NL 7657:localhost:7657 (System_IP) 방법 2: 사용자 이름과 비밀번호를 사용하여 공인 IP 주소에서 콘솔을 사용할 수 있도록 구성하기\n~/.i2p/clients.config를 열고 다음을 교체하세요:\nclientApp.0.args=7657 ::1,127.0.0.1 ./webapps/ 다음으로:\nclientApp.0.args=7657 ::1,127.0.0.1,(System_IP) ./webapps/ 여기서 (System_IP)를 시스템의 공용 IP 주소로 교체하세요\nhttp://localhost:7657/configui 로 이동하여 원하는 경우 콘솔 사용자 이름과 비밀번호를 추가하세요 - 사용자 이름과 비밀번호를 추가하는 것은 I2P 콘솔을 변조로부터 보호하고 익명성 해제로 이어질 수 있는 상황을 방지하기 위해 강력히 권장됩니다.\nhttp://localhost:7657/index 로 이동하여 \u0026ldquo;Graceful restart\u0026quot;를 클릭하면 JVM이 재시작되고 클라이언트 애플리케이션이 다시 로드됩니다\n이 작업이 완료되면 이제 콘솔에 원격으로 접속할 수 있습니다. http://(시스템_IP):7657에서 router console을 열면 브라우저가 인증 팝업을 지원하는 경우 위 2단계에서 지정한 사용자 이름과 비밀번호를 입력하라는 메시지가 표시됩니다.\n참고: 위 설정에서 0.0.0.0을 지정할 수 있습니다. 이것은 네트워크나 넷마스크가 아닌 인터페이스를 지정합니다. 0.0.0.0은 \u0026ldquo;모든 인터페이스에 바인딩\u0026quot;을 의미하므로 127.0.0.1:7657뿐만 아니라 모든 LAN/WAN IP에서도 접근할 수 있습니다. 이 옵션을 사용할 때는 주의하세요. 콘솔이 시스템에 구성된 모든 주소에서 접근 가능하게 됩니다.\n다른 컴퓨터에서 애플리케이션을 어떻게 사용할 수 있나요? SSH 포트 포워딩 사용 방법에 대한 지침은 이전 답변을 참조하시고, 콘솔의 다음 페이지도 확인하세요: http://localhost:7657/configi2cp I2P를 SOCKS 프록시로 사용할 수 있나요? SOCKS 프록시는 0.7.1 릴리스부터 작동해 왔습니다. SOCKS 4/4a/5가 지원됩니다. I2P에는 SOCKS outproxy가 없으므로 I2P 내부에서만 사용할 수 있습니다.\n많은 애플리케이션들은 인터넷에서 당신을 식별할 수 있는 민감한 정보를 유출하며, 이는 I2P SOCKS 프록시를 사용할 때 반드시 알아야 할 위험입니다. I2P는 연결 데이터만 필터링하지만, 실행하려는 프로그램이 이러한 정보를 콘텐츠로 전송하는 경우 I2P는 당신의 익명성을 보호할 방법이 없습니다. 예를 들어, 일부 메일 애플리케이션은 실행 중인 컴퓨터의 IP 주소를 메일 서버로 전송합니다. 토렌트용 I2PSnark 와 같은 I2P 전용 도구나 애플리케이션, 또는 Firefox 에서 찾을 수 있는 인기 플러그인을 포함하여 I2P와 함께 사용하기에 안전하다고 알려진 애플리케이션을 권장합니다.\n일반 인터넷에서 IRC, BitTorrent 또는 기타 서비스에 어떻게 접근하나요? I2P와 인터넷 사이를 연결하는 Outproxy라는 서비스가 있으며, 이는 Tor Exit Node와 유사합니다. HTTP와 HTTPS를 위한 기본 outproxy 기능은 exit.stormycloud.i2p에서 제공되며 StormyCloud Inc.에서 운영합니다. 이는 HTTP Proxy에서 설정됩니다. 또한 익명성 보호를 위해 I2P는 기본적으로 일반 인터넷에 익명 연결을 허용하지 않습니다. 자세한 내용은 Socks Outproxy 페이지를 참조하세요.\nReseed 내 라우터가 몇 분 동안 실행되었지만 연결이 전혀 없거나 매우 적습니다 먼저 라우터 콘솔의 네트워크 데이터베이스인 http://127.0.0.1:7657/netdb 페이지를 확인하세요. I2P 내에서 단일 router도 표시되지 않지만 콘솔에서 방화벽이 있다고 표시되면, reseed 서버에 연결할 수 없는 것일 수 있습니다. 다른 I2P router들이 표시된다면 http://127.0.0.1:7657/config 에서 최대 연결 수를 낮춰보세요. 라우터가 많은 연결을 처리하지 못할 수 있습니다.\n수동으로 재시드하는 방법은? 일반적인 상황에서 I2P는 부트스트랩 링크를 사용하여 자동으로 네트워크에 연결합니다. 인터넷 연결 장애로 인해 reseed 서버로부터의 부트스트랩이 실패하는 경우, Tor 브라우저를 사용하는 것이 간편한 부트스트랩 방법입니다(기본적으로 localhost를 엽니다). 이는 http://127.0.0.1:7657/configreseed 와 매우 잘 작동합니다. I2P router를 수동으로 reseed하는 것도 가능합니다.\nTor 브라우저를 사용하여 reseed할 때 여러 URL을 한 번에 선택하여 진행할 수 있습니다. 기본값인 2개(여러 URL 중)로도 작동하지만 느릴 수 있습니다.\n개인정보 보호-안전 내 router가 일반 인터넷으로의 \u0026ldquo;exit node\u0026rdquo;(outproxy)인가요? 그렇게 되는 것을 원하지 않습니다. 아니요, 당신의 router는 I2P 네트워크를 통해 종단간 암호화된 트래픽을 임의의 tunnel 엔드포인트로 전송하는 데 참여하며, 이는 일반적으로 outproxy가 아닙니다. 하지만 전송 계층에서 당신의 router와 인터넷 사이에 트래픽이 전달되지는 않습니다. 일반 사용자로서, 시스템 및 네트워크 관리에 능숙하지 않다면 outproxy를 운영해서는 안 됩니다.\n네트워크 트래픽을 분석하여 I2P 사용을 탐지하는 것이 쉬운가요? I2P 트래픽은 일반적으로 UDP 트래픽처럼 보이며, 그 이상으로 보이지 않게 만드는 것이 목표입니다. 또한 TCP도 지원합니다. 어느 정도 노력을 기울이면 수동적 트래픽 분석을 통해 트래픽을 \u0026ldquo;I2P\u0026quot;로 분류할 수 있을 수 있지만, 트래픽 난독화의 지속적인 개발이 이를 더욱 줄일 수 있기를 기대합니다. obfs4와 같은 비교적 단순한 프로토콜 난독화 계층조차도 검열자가 I2P를 차단하는 것을 방지할 수 있습니다 (이는 I2P가 배포하고자 하는 목표입니다).\nI2P 사용이 안전한가요? 이것은 개인의 위협 모델에 따라 다릅니다. 대부분의 사람들에게 I2P는 아무런 보호 장치를 사용하지 않는 것보다 훨씬 안전합니다. 일부 다른 네트워크(Tor, mixminion/mixmaster 등)는 특정 공격자에 대해 더 안전할 수 있습니다. 예를 들어, I2P 트래픽은 TLS/SSL을 사용하지 않으므로 Tor가 가진 \u0026ldquo;가장 약한 고리\u0026rdquo; 문제가 없습니다. I2P는 \u0026ldquo;아랍의 봄\u0026rdquo; 당시 시리아에서 많은 사람들이 사용했으며, 최근에는 중동 및 근동 지역의 소규모 언어권에서 I2P 설치가 더 크게 증가했습니다. 여기서 가장 중요한 점은 I2P는 기술이며, 인터넷에서 개인정보 보호/익명성을 강화하기 위한 사용 방법/가이드가 필요하다는 것입니다. 또한 브라우저를 확인하거나 핑거프린트 검색 엔진을 가져와서 매우 큰(의미: 전형적인 긴 꼬리/매우 정확한 다양한 데이터 구조) 환경 정보 데이터셋으로 핑거프린트 공격을 차단하고, VPN을 사용하지 않아 자체적으로 발생하는 모든 위험(자체 TLS 캐시 동작 및 데스크톱 시스템보다 쉽게 해킹될 수 있는 제공업체의 기술적 구조 등)을 줄이십시오. 격리된 Tor V-Browser를 우수한 안티 핑거프린트 보호 기능과 함께 사용하고, 필요한 시스템 통신만 허용하는 전반적인 앱가드 라이프타임 보호와 함께, 안티 스파이 비활성화 스크립트 및 라이브 CD를 사용하는 최종 단계 VM을 사용하여 \u0026ldquo;거의 영구적인 가능한 위험\u0026quot;을 제거하고 감소하는 확률로 모든 위험을 낮추는 것이 공용 네트워크와 최고 수준의 개인 위험 모델에서 좋은 옵션이 될 수 있으며, I2P 사용을 위해 이 목표로 할 수 있는 최선의 방법일 수 있습니다.\n라우터 콘솔에서 다른 모든 I2P 노드의 IP 주소가 보입니다. 이것은 제 IP 주소도 다른 사람들에게 보인다는 뜻인가요? 네, 당신의 router에 대해 알고 있는 다른 I2P 노드들에게는 그렇습니다. 우리는 이것을 나머지 I2P 네트워크와 연결하는 데 사용합니다. 이 주소들은 \u0026ldquo;routerInfo (키,값) 객체\u0026quot;에 물리적으로 위치하며, 원격으로 가져오거나 피어로부터 받습니다. \u0026ldquo;routerInfo\u0026quot;는 부트스트래핑을 위해 \u0026ldquo;피어가 게시한\u0026rdquo; router 자체에 대한 일부 정보(일부는 선택적으로 기회적으로 추가됨)를 보유합니다. 이 객체에는 클라이언트에 대한 데이터가 없습니다. 내부를 자세히 살펴보면 모든 사람이 \u0026ldquo;SHA-256 해시(낮음=양수 해시(-키), 높음=음수 해시(+키))\u0026ldquo;라는 최신 유형의 ID 생성 방식으로 계산되었음을 알 수 있습니다. I2P 네트워크는 업로드 및 인덱싱 중에 생성된 routerInfo의 자체 데이터베이스 데이터를 가지고 있지만, 이는 키/값 테이블과 네트워크 토폴로지, 부하 상태/대역폭 상태, 그리고 DB 컴포넌트의 저장소에 대한 라우팅 확률의 구현에 깊이 의존합니다.\noutproxy를 사용하는 것이 안전한가요? \u0026ldquo;안전\u0026quot;에 대한 정의가 무엇인지에 따라 다릅니다. Outproxy는 작동할 때는 훌륭하지만, 안타깝게도 자발적으로 운영하는 사람들이 흥미를 잃거나 24시간 365일 유지 관리할 수 있는 리소스가 없을 수 있습니다. 서비스를 사용할 수 없거나 중단되거나 신뢰할 수 없는 기간이 발생할 수 있으며, 우리는 이 서비스와 관련이 없고 이에 대한 영향력도 없다는 점을 유의하시기 바랍니다.\noutproxy 자체는 엔드-투-엔드 암호화된 HTTPS/SSL 데이터를 제외하고 당신의 트래픽이 오가는 것을 볼 수 있습니다. 이는 마치 ISP가 당신의 컴퓨터에서 오가는 트래픽을 볼 수 있는 것과 같습니다. ISP를 신뢰한다면, outproxy도 그보다 나쁘지 않을 것입니다.\n\u0026ldquo;익명화 해제\u0026rdquo; 공격은 어떻습니까? 매우 자세한 설명은 위협 모델 에 대한 문서를 참조하세요. 일반적으로 익명성 해제는 간단하지 않지만, 충분히 주의하지 않으면 가능합니다.\n인터넷 접속/성능 I2P를 통해 일반 인터넷 사이트에 접속할 수 없습니다. 인터넷 사이트로의 프록시 접속(인터넷으로 나가는 eepsite)은 비차단 제공자들에 의해 I2P 사용자들에게 서비스로 제공됩니다. 이 서비스는 I2P 개발의 주요 초점이 아니며, 자발적으로 제공됩니다. I2P에 호스팅된 eepsite는 outproxy 없이도 항상 작동해야 합니다. Outproxy는 편의성을 제공하지만 설계상 완벽하지 않으며 프로젝트의 큰 부분도 아닙니다. Outproxy는 I2P의 다른 서비스들이 제공할 수 있는 고품질 서비스를 제공하지 못할 수 있다는 점을 유의하시기 바랍니다.\nI2P를 통해 https:// 또는 ftp:// 사이트에 접속할 수 없습니다. 기본 HTTP 프록시는 HTTP 및 HTTPS outproxy만 지원합니다.\n왜 내 router가 너무 많은 CPU를 사용하나요? 먼저, 모든 I2P 관련 구성 요소가 최신 버전인지 확인하세요. 이전 버전에는 불필요하게 CPU를 소모하는 코드 섹션이 있었습니다. 시간이 지남에 따라 I2P 성능 개선 사항을 기록한 성능 로그 도 있습니다.\n내 활성 피어 / 알려진 피어 / 참여 중인 터널 / 연결 / 대역폭이 시간에 따라 급격하게 변동합니다! 문제가 있나요? I2P 네트워크의 전반적인 안정성은 지속적인 연구 분야입니다. 그 연구의 상당 부분은 구성 설정의 작은 변경이 router의 동작을 어떻게 바꾸는지에 초점을 맞추고 있습니다. I2P는 P2P(peer-to-peer) 네트워크이므로, 다른 peer들의 행동이 사용자 router의 성능에 영향을 미칩니다.\n일반 인터넷과 비교했을 때 I2P에서 다운로드, 토렌트, 웹 브라우징 및 기타 모든 것이 느린 이유는 무엇인가요? I2P는 추가적인 라우팅과 암호화 계층을 더하는 다양한 보호 기능을 가지고 있습니다. 또한 각자의 속도와 품질을 가진 다른 피어(Tunnel)를 통해 트래픽을 전달하는데, 어떤 것은 느리고 어떤 것은 빠릅니다. 이로 인해 다양한 방향에서 서로 다른 속도로 많은 오버헤드와 트래픽이 발생합니다. 설계상 이러한 모든 요소들은 인터넷의 직접 연결에 비해 속도를 느리게 만들지만, 훨씬 더 익명성을 제공하며 대부분의 용도에는 여전히 충분히 빠릅니다.\n다음은 I2P를 사용할 때 지연 시간과 대역폭 고려사항에 대한 맥락을 제공하기 위해 설명과 함께 제시된 예시입니다.\n아래 다이어그램을 고려해 보세요. 이는 I2P를 통해 요청을 하는 클라이언트, I2P를 통해 요청을 받는 서버, 그리고 I2P를 통해 다시 응답하는 과정 간의 연결을 나타냅니다. 요청이 이동하는 회로도 함께 표시되어 있습니다.\n다이어그램에서 \u0026lsquo;P\u0026rsquo;, \u0026lsquo;Q\u0026rsquo;, \u0026lsquo;R\u0026rsquo;로 표시된 박스들은 \u0026lsquo;A\u0026rsquo;의 아웃바운드 터널을 나타내고, \u0026lsquo;X\u0026rsquo;, \u0026lsquo;Y\u0026rsquo;, \u0026lsquo;Z\u0026rsquo;로 표시된 박스들은 \u0026lsquo;B\u0026rsquo;의 아웃바운드 터널을 나타냅니다. 마찬가지로 \u0026lsquo;X\u0026rsquo;, \u0026lsquo;Y\u0026rsquo;, \u0026lsquo;Z\u0026rsquo;로 표시된 박스들은 \u0026lsquo;B\u0026rsquo;의 인바운드 터널을 나타내며, \u0026lsquo;P_1\u0026rsquo;, \u0026lsquo;Q_1\u0026rsquo;, \u0026lsquo;R_1\u0026rsquo;로 표시된 박스들은 \u0026lsquo;A\u0026rsquo;의 인바운드 터널을 나타냅니다. 박스들 사이의 화살표는 트래픽의 방향을 보여줍니다. 화살표 위아래의 텍스트는 한 쌍의 홉 사이의 대역폭 예시와 지연시간 예시를 자세히 설명합니다.\n클라이언트와 서버가 모두 3-hop tunnel을 사용하는 경우, 총 12개의 다른 I2P router가 트래픽 중계에 관여합니다. 6개의 피어가 클라이언트에서 서버로의 트래픽을 중계하며, 이는 \u0026lsquo;A\u0026rsquo;에서 시작하는 3-hop 아웃바운드 tunnel(\u0026lsquo;P\u0026rsquo;, \u0026lsquo;Q\u0026rsquo;, \u0026lsquo;R\u0026rsquo;)과 \u0026lsquo;B\u0026rsquo;로 향하는 3-hop 인바운드 tunnel(\u0026lsquo;X\u0026rsquo;, \u0026lsquo;Y\u0026rsquo;, \u0026lsquo;Z\u0026rsquo;)로 나뉩니다. 마찬가지로, 6개의 피어가 서버에서 클라이언트로 돌아가는 트래픽을 중계합니다.\n먼저, 레이턴시(latency)를 고려할 수 있습니다 - 클라이언트의 요청이 I2P 네트워크를 통과하여 서버에 도달하고 다시 클라이언트로 돌아오는 데 걸리는 시간입니다. 모든 레이턴시를 합산하면 다음과 같습니다:\n40 + 100 + 20 + 60 + 80 + 10 + 30 ms (client to server) + 60 + 40 + 80 + 60 + 100 + 20 + 40 ms (server to client) ----------------------------------- TOTAL: 740 ms 우리 예제에서 총 왕복 시간은 740ms로 합산됩니다 - 일반적인 인터넷 웹사이트를 탐색할 때 보통 보는 것보다 확실히 훨씬 높습니다.\n둘째, 사용 가능한 대역폭을 고려할 수 있습니다. 이는 클라이언트와 서버 간의 hop들 사이에서 가장 느린 링크와 서버가 클라이언트로 트래픽을 전송할 때를 통해 결정됩니다. 클라이언트에서 서버로 가는 트래픽의 경우, 예제에서 hop \u0026lsquo;R\u0026rsquo;과 \u0026lsquo;X\u0026rsquo; 사이 및 hop \u0026lsquo;X\u0026rsquo;와 \u0026lsquo;Y\u0026rsquo; 사이의 사용 가능한 대역폭이 32 KB/s임을 알 수 있습니다. 다른 hop들 사이에서 더 높은 대역폭을 사용할 수 있음에도 불구하고, 이러한 hop들은 병목 현상으로 작용하여 \u0026lsquo;A\u0026rsquo;에서 \u0026lsquo;B\u0026rsquo;로의 트래픽에 대한 최대 사용 가능 대역폭을 32 KB/s로 제한합니다. 마찬가지로, 서버에서 클라이언트로 가는 경로를 추적하면 hop \u0026lsquo;Z_1\u0026rsquo;과 \u0026lsquo;Y_1\u0026rsquo; 사이, \u0026lsquo;Y_1\u0026rsquo;과 \u0026lsquo;X_1\u0026rsquo; 사이, 그리고 \u0026lsquo;Q_1\u0026rsquo;과 \u0026lsquo;P_1\u0026rsquo; 사이에서 최대 대역폭이 64 KB/s임을 알 수 있습니다.\n대역폭 제한을 늘리는 것을 권장합니다. 이는 사용 가능한 대역폭의 양을 증가시켜 네트워크에 도움이 되며, 결과적으로 I2P 사용 경험을 개선합니다. 대역폭 설정은 http://localhost:7657/config 페이지에 있습니다. ISP가 정한 인터넷 연결 제한을 인지하고 그에 맞게 설정을 조정하시기 바랍니다.\n또한 충분한 양의 공유 대역폭을 설정할 것을 권장합니다 - 이를 통해 participating tunnel들이 귀하의 I2P router를 통해 라우팅될 수 있습니다. participating 트래픽을 허용하면 귀하의 router가 네트워크에 잘 통합되고 전송 속도가 향상됩니다.\nI2P는 계속 개발 중인 프로젝트입니다. 많은 개선 사항과 수정 사항이 구현되고 있으며, 일반적으로 최신 릴리스를 실행하면 성능이 향상됩니다. 아직 설치하지 않았다면 최신 릴리스를 설치하세요.\n버그를 발견한 것 같은데, 어디에 보고할 수 있나요? 버그나 문제를 발견하시면 일반 인터넷과 I2P 모두에서 접근 가능한 버그트래커에 보고해 주시기 바랍니다. 또한 I2P와 일반 인터넷에서 모두 이용할 수 있는 토론 포럼도 운영하고 있습니다. IRC 채널에도 참여하실 수 있습니다: IRC2P 네트워크나 Freenode를 통해 접속하실 수 있습니다.\n버그트래커: 일반 인터넷: https://i2pgit.org/I2P_Developers/i2p.i2p/issues I2P에서: http://git.idk.i2p/I2P_Developers/i2p.i2p/issues 포럼: i2pforum.i2p 로그 붙여넣기: PrivateBin 위키 에 나열된 일반 인터넷 서비스나, PrivateBin 인스턴스 또는 자바스크립트 없는 붙여넣기 서비스 와 같은 I2P 붙여넣기 서비스에 관심 있는 로그를 붙여넣고 IRC #i2p에서 후속 조치를 취하세요 IRC: #i2p-dev에 참여하여 개발자들과 IRC에서 논의하세요 다음 주소에서 확인할 수 있는 router 로그 페이지의 관련 정보를 포함해 주세요: http://127.0.0.1:7657/logs . \u0026lsquo;I2P Version and Running Environment\u0026rsquo; 섹션 아래의 모든 텍스트와 페이지에 표시된 다양한 로그의 오류 또는 경고 메시지를 공유해 주시기 바랍니다.\n질문이 있습니다! 좋습니다! IRC에서 저희를 찾아보세요:\nirc.freenode.net 채널 #i2p IRC2P 채널 #i2p 또는 포럼 에 게시하면 여기에 게시하겠습니다 (가능하면 답변과 함께).\n","description":"포괄적인 I2P FAQ: router 도움말, 설정, reseed, 프라이버시/안전, 성능 및 문제 해결","id":"b0f8e4ee3509d229b406a0b0bb933ca4","section":"docs","title":"자주 묻는 질문","url":"/ko/docs/overview/faq/"},{"categories":null,"content":" 상태: 이 페이지는 레거시 \u0026ldquo;Low-level Cryptography Specification\u0026rdquo;(저수준 암호화 명세)을 요약합니다. 최신 I2P 릴리스(2.10.0, 2025년 10월)는 새로운 암호 프리미티브로의 마이그레이션을 완료했습니다. 구현 세부사항은 ECIES , Encrypted LeaseSets , NTCP2 , Red25519 , SSU2 , 및 Tunnel Creation (ECIES) 와 같은 전용 명세를 참고하십시오.\n발전 스냅샷 Functional Area Legacy Primitive Current / Planned Primitive Migration Status Transport key exchange Diffie–Hellman over 2048-bit prime (NTCP / SSU) X25519 (NTCP2 / SSU2) Completed (NTCP2 and SSU2 fully deployed) End-to-end encryption ElGamal/AES+SessionTags ECIES-X25519-AEAD-Ratchet Completed (2.4.0+) Symmetric cipher AES-256/CBC + HMAC-MD5 ChaCha20/Poly1305 (AEAD) Active (tunnel layer remains AES-256) Default signatures DSA-SHA1 (1024-bit) EdDSA/RedDSA on Ed25519 Fully migrated Experimental / future — Hybrid post-quantum encryption (opt-in) In testing (2.10.0) ## 비대칭키 암호화 X25519(타원곡선 디피-헬만(ECDH) 키 합의 방식) NTCP2, ECIES-X25519-AEAD-Ratchet, SSU2 및 X25519 기반 tunnel 생성에 사용됩니다. Noise protocol framework(노이즈 프로토콜 프레임워크)를 통해 컴팩트한 키, 상수 시간 연산, 그리고 순방향 기밀성을 제공합니다. 32바이트 키와 효율적인 키 교환으로 128비트 보안 강도를 제공합니다. ElGamal (레거시) 구형 routers와의 하위 호환성을 위해 유지됩니다. 생성기 2를 사용하는 2048비트 Oakley Group 14 소수(RFC 3526) 위에서 동작합니다. AES 세션 키와 IV(초기화 벡터)를 514바이트 길이의 암호문으로 암호화합니다. 인증된 암호화와 전방향 보안이 없으며, 모든 최신 엔드포인트는 ECIES(타원곡선 통합 암호체계)로 이전했습니다. 대칭키 암호화 ChaCha20/Poly1305 (스트림 암호 ChaCha20과 메시지 인증 코드 Poly1305를 결합한 AEAD 알고리즘) NTCP2, SSU2, ECIES 전반에서 사용되는 기본 인증 암호 프리미티브. AES 하드웨어 지원 없이도 AEAD 보안과 높은 성능을 제공. RFC 7539에 따라 구현됨 (256‑bit 키, 96‑bit 논스, 128‑bit 태그). AES‑256/CBC (레거시) 여전히 tunnel 계층 암호화에 사용되며, 그 블록 암호 구조가 I2P의 계층형 암호화 모델에 부합합니다. PKCS#5 패딩과 홉별 IV(초기화 벡터) 변환을 사용합니다. 장기 검토가 예정되어 있지만, 암호학적으로는 여전히 안전합니다. 서명 Signature Type Usage Notes Status DSA‑SHA1 (1024‑bit) Original default; still accepted for legacy Destinations. Deprecated ECDSA‑SHA256/384/512 Used during 2014–2015 transition. Supported EdDSA‑SHA512‑Ed25519 Default for Router and Destination identities (since 0.9.15). Default RedDSA‑SHA512‑Ed25519 Used for encrypted LeaseSet signatures (0.9.39+). Specialized RSA‑SHA512‑4096 For out‑of‑band signing (su3 updates, reseeds, plugins). Application‑layer ## 해시와 키 파생 SHA‑256: DHT(분산 해시 테이블) 키, HKDF(HMAC 기반 키 파생 함수), 그리고 레거시 서명에 사용됩니다. SHA‑512: EdDSA/RedDSA와 Noise의 HKDF 파생 과정에서 사용됩니다. HKDF‑SHA256: ECIES(타원 곡선 통합 암호화 체계), NTCP2, SSU2에서 세션 키를 파생합니다. 매일 교체되는 SHA‑256 파생값은 netDb에서 RouterInfo와 LeaseSet의 저장 위치를 보호합니다. 전송 계층 요약 Transport Key Exchange Encryption Authentication Status NTCP2 X25519 ChaCha20/Poly1305 AEAD Default TCP transport SSU2 X25519 ChaCha20/Poly1305 AEAD Default UDP transport SSU (Legacy) DH‑2048 AES‑256/CBC + HMAC‑MD5 Legacy Removed (2.4.0) 두 전송 프로토콜 모두 Noise_XK handshake pattern(Noise 프로토콜의 XK 방식 핸드셰이크)을 사용하여 링크 수준의 순방향 비밀성과 재생 공격 방지를 제공합니다. Tunnel 계층 암호화 각 홉별 계층형 암호화를 위해 AES‑256/CBC를 계속 사용한다. 아웃바운드 게이트웨이는 반복적인 AES 복호화를 수행한다; 각 홉은 자신의 레이어 키와 IV(초기화 벡터) 키를 사용해 다시 암호화한다. 이중 IV 암호화는 상관관계 및 확인 공격을 완화한다. AEAD(부가데이터가 포함된 인증 암호)로의 전환은 검토 중이지만 현재로서는 계획되어 있지 않다. 양자내성 암호 I2P 2.10.0에서는 실험적 하이브리드 포스트‑양자 암호화를 도입합니다. 테스트를 위해 Hidden Service Manager에서 수동으로 활성화할 수 있습니다. X25519와 양자내성 KEM(키 캡슐화 메커니즘)을 결합합니다(하이브리드 모드). 기본값이 아니며 연구 및 성능 평가를 목적으로 합니다. 확장성 프레임워크 암호화 및 서명 유형 식별자는 여러 프리미티브를 병행 지원할 수 있게 합니다. 현재 매핑은 다음과 같습니다: 암호화 유형: 0 = ElGamal/AES+SessionTags, 4 = ECIES‑X25519‑AEAD‑Ratchet. 서명 유형: 0 = DSA‑SHA1, 7 = EdDSA‑SHA512‑Ed25519, 11 = RedDSA‑SHA512‑Ed25519. 이 프레임워크는 네트워크 분할 없이 포스트‑양자 방식 등을 포함한 향후 업그레이드를 가능하게 합니다. 암호학적 구성 전송 계층: X25519 + ChaCha20/Poly1305 (Noise 프레임워크). Tunnel 계층: 익명성을 위한 AES‑256/CBC 계층형 암호화. 종단 간: 기밀성과 전방향 보안을 위한 ECIES‑X25519‑AEAD‑Ratchet. 데이터베이스 계층: 인증을 위한 EdDSA/RedDSA 서명. 이들 계층은 결합되어 심층 방어를 제공한다: 한 계층이 침해되더라도 다른 계층들이 기밀성과 비연결성을 유지한다.\n요약 I2P 2.10.0의 암호화 스택은 다음을 중심으로 합니다:\nCurve25519 (X25519) 키 교환용 ChaCha20/Poly1305 대칭 암호화용 EdDSA / RedDSA 서명용 SHA‑256 / SHA‑512 해싱 및 키 파생용 실험적 양자내성 하이브리드 모드 향후 호환성 확보용 레거시 ElGamal, AES‑CBC, DSA는 하위 호환성을 위해 유지되지만 더 이상 활성 전송이나 암호화 경로에서는 사용되지 않습니다.\n","description":"I2P 전반에서 사용되는 대칭형, 비대칭형, 및 서명 프리미티브(기본 구성 요소)의 요약","id":"f5b93f818161e04d49735c3df52fcbdc","section":"docs","title":"저수준 암호학","url":"/ko/docs/specs/cryptography/"},{"categories":null,"content":" 1. 개요 I2P의 transport(전송 방식)은 router 간 직접적인 점대점 통신을 위한 방법이다. 이러한 메커니즘은 router 인증을 검증하는 동시에 기밀성과 무결성을 보장한다.\n각 전송 프로토콜은 인증, 흐름 제어, 확인 응답, 재전송 기능을 갖춘 연결 모델을 사용하여 동작합니다.\n2. 현재 전송 프로토콜 I2P는 현재 두 가지 주요 전송 프로토콜을 지원합니다:\nTransport Protocol Description NTCP2 TCP Noise-based TCP transport with modern encryption (as of 0.9.36) SSU2 UDP Secure Semireliable UDP with modern encryption (as of 0.9.56) ### 2.1 레거시 트랜스포트 (사용 중단됨) Transport Protocol Status NTCP TCP Replaced by NTCP2; removed in 0.9.62 SSU UDP Replaced by SSU2; removed in 0.9.62 --- 3. 전송 서비스 전송 하위 시스템은 다음과 같은 서비스를 제공합니다:\n3.1 메시지 전달 신뢰할 수 있는 I2NP 메시지 전달 (전송 계층이 I2NP 메시징만을 전담함) 전달 순서 보장은 보편적으로 보장되지 않습니다 우선순위 기반 메시지 대기열 3.2 연결 관리 연결 수립 및 종료 임계값 강제 적용을 포함한 연결 한도 관리 피어별 상태 추적 자동 및 수동 피어 차단 목록 강제 적용 3.3 네트워크 구성 전송 방식별 다중 router 주소 (IPv4 및 IPv6 지원, v0.9.8부터) UPnP 방화벽 포트 개방 NAT/방화벽 트래버설 지원 여러 방법을 통한 로컬 IP 감지 3.4 보안 점대점 통신을 위한 암호화 로컬 규칙에 따른 IP 주소 검증 시계 합의 결정(NTP(네트워크 시간 프로토콜) 백업) 3.5 대역폭 관리 인바운드 및 아웃바운드 대역폭 제한 나가는 메시지를 위한 최적 전송 방식 선택 4. 전송 주소 서브시스템은 router 접속 지점 목록을 관리합니다:\n전송 방식 (NTCP2, SSU2) IP 주소 포트 번호 선택적 매개변수 전송 방식별로 여러 개의 주소를 사용할 수 있습니다.\n4.1 일반적인 주소 구성 Configuration Description Hidden Routers with no published addresses Firewalled Routers publishing SSU2 addresses with \"introducer\" peer lists for NAT traversal Unrestricted Routers advertising both NTCP2 and SSU2 addresses on IPv4 and/or IPv6 --- 5. 전송 프로토콜 선택 시스템은 상위 계층 프로토콜과 무관하게 I2NP messages 를 위한 트랜스포트를 선택합니다. 선택 과정은 각 트랜스포트가 입찰가를 제출하고 가장 낮은 값이 낙찰되는 입찰 시스템을 사용합니다.\n5.1 입찰 결정 요인 전송 방식 선호 설정 기존 피어 연결 현재 연결 수와 임계 연결 수 최근 연결 시도 이력 메시지 크기 제한 피어 RouterInfo(라우터 정보)의 전송 기능 연결의 직접성(직접 연결 대 introducer(중개자) 의존) 피어가 광고한 전송 선호도 일반적으로 두 routers는 동시에 단일 transport(전송 프로토콜) 연결만 유지하지만, 동시에 다중 transport 연결도 가능하다.\n6. NTCP2 NTCP2 (새 전송 프로토콜 2)는 I2P용 최신 TCP 기반 전송 프로토콜로, 버전 0.9.36에서 도입되었다.\n6.1 주요 기능 Noise Protocol Framework(암호 프로토콜 프레임워크)를 기반으로 함 (Noise_XK pattern) 키 교환을 위해 X25519를 사용 인증된 암호화를 위해 ChaCha20/Poly1305를 사용 해싱을 위해 BLAKE2s를 사용 DPI (Deep Packet Inspection, 심층 패킷 검사)에 저항하기 위한 프로토콜 난독화 트래픽 분석에 대한 저항성을 위한 선택적 패딩 6.2 연결 설정 세션 요청 (Alice → Bob): 임시 X25519 키 + 암호화된 페이로드 세션 생성 (Bob → Alice): 임시 키 + 암호화된 확인 세션 확인 (Alice → Bob): RouterInfo(라우터 정보)와의 최종 핸드셰이크 이후의 모든 데이터는 핸드셰이크에서 파생된 세션 키로 암호화됩니다.\n자세한 내용은 NTCP2 사양 을 참조하세요.\n7. SSU2 SSU2 (Secure Semireliable UDP 2, 보안 반신뢰성 UDP 2)은 I2P를 위한 최신 UDP 기반 전송 프로토콜로, 버전 0.9.56에서 도입되었습니다.\n7.1 주요 기능 Noise Protocol Framework(암호 통신용 핸드셰이크 프레임워크)에 기반함 (Noise_XK pattern) 키 교환을 위해 X25519를 사용 인증된 암호화를 위해 ChaCha20/Poly1305를 사용 선택적 확인응답(SACK)을 사용하는 부분적 신뢰성 전송 홀 펀칭(hole punching) 및 릴레이/인트로덕션(relay/introduction)을 통한 NAT 트래버설 연결 마이그레이션 지원 경로 MTU 발견 7.2 SSU (레거시) 대비 장점 Feature SSU (Legacy) SSU2 Encryption ElGamal + AES X25519 + ChaCha20/Poly1305 Header encryption Partial Full (ChaCha20) Connection ID Fixed Encrypted, rotatable NAT traversal Basic introduction Enhanced hole punching + relay Obfuscation Minimal Improved (variable padding) 자세한 내용은 [SSU2 명세서](/docs/specs/ssu2/)를 참조하세요. 8. NAT 트래버설 두 전송 프로토콜은 방화벽 뒤에 있는 routers가 네트워크에 참여할 수 있도록 NAT traversal(NAT 환경에서의 연결 성립 기술)을 지원합니다.\n8.1 SSU2 소개 router가 인바운드 연결을 직접 수신할 수 없을 때:\nRouter는 자신의 RouterInfo에 introducer(NAT 우회를 위한 중개 노드) 주소를 게시한다 연결하려는 피어가 introducer에게 소개 요청을 보낸다 Introducer가 방화벽 뒤에 있는 router에 연결 정보를 중계한다 방화벽 뒤의 router가 아웃바운드 연결을 시작한다 (hole punch(홀 펀칭)) 직접 통신이 확립됨 8.2 NTCP2 및 방화벽 NTCP2는 인바운드 TCP 연결이 필요합니다. NAT 뒤에 있는 routers는 다음을 수행할 수 있습니다:\nUPnP를 사용해 포트를 자동으로 엽니다 수동으로 포트 포워딩을 구성합니다 수신 연결에는 SSU2(SSU의 2세대 버전으로, I2P에서 사용되는 UDP 기반 전송 프로토콜)를 사용하고, 발신 연결에는 NTCP2를 사용합니다 9. 프로토콜 난독화 두 가지 최신 전송 프로토콜 모두 난독화 기능을 포함합니다:\n무작위 패딩을 사용하는 핸드셰이크 메시지 암호화된 헤더가 프로토콜 시그니처(식별 패턴)를 노출하지 않음 가변 길이 메시지로 트래픽 분석에 대응 고정된 패턴 없음 연결 설정 시 Note: 전송 계층 난독화는 I2P의 tunnel 아키텍처가 제공하는 익명성을 보완하지만 대체하지는 않습니다.\n10. 향후 개발 계획된 연구 및 개선 사항에는 다음이 포함됩니다:\nPluggable transports(플러그형 전송) – Tor 호환 트래픽 난독화 플러그인 QUIC 기반 전송 – QUIC 프로토콜의 이점 검토 연결 제한 최적화 – 최적의 피어 연결 제한에 대한 연구 강화된 패딩 전략 – 트래픽 분석 저항성 향상 11. 참고 문헌 NTCP2 명세 – Noise 기반 TCP 전송 SSU2 명세 – 보안 반신뢰성 UDP 2 I2NP 명세 – I2P 네트워크 프로토콜 메시지 공통 구조체 – RouterInfo 및 주소 구조체 역사적 NTCP 논의 – 레거시 전송 개발 역사 레거시 SSU 문서 – 원래의 SSU 명세(사용 중단됨) ","description":"I2P의 전송 계층 이해 - NTCP2와 SSU2를 포함한 router 간 점대점 통신 방식","id":"5fbac972dc212081634c49c5e6ac0004","section":"docs","title":"전송 계층","url":"/ko/docs/overview/transport/"},{"categories":null,"content":"액세스 필터는 I2PTunnel 서버 운영자가 원본 Destination(목적지 식별자)과 최근 연결 빈도에 따라 들어오는 연결을 허용, 차단, 또는 제한할 수 있도록 합니다. 필터는 규칙들로 이루어진 일반 텍스트 파일입니다. 파일은 위에서 아래로 읽히며, 처음 일치하는 규칙이 우선합니다.\n필터 정의 변경 사항은 tunnel 재시작 시 적용됩니다. 일부 빌드는 런타임에 파일 기반 목록을 다시 읽을 수 있지만, 변경 사항이 확실히 적용되도록 재시작을 계획해 두십시오.\n파일 형식 한 줄에 하나의 규칙. 빈 줄은 무시됩니다. # 는 줄 끝까지 이어지는 주석을 시작합니다. 규칙은 순서대로 평가되며, 처음 일치하는 항목이 사용됩니다. 임계값 임계값은 슬라이딩 시간 창 내에서 단일 Destination(I2P의 목적지 식별자)로부터 허용되는 연결 시도 횟수를 정의합니다.\n수치: N/S는 S초 동안 N개의 연결을 허용함을 의미합니다. 예: 15/5는 5초 동안 최대 15개의 연결을 허용합니다. 해당 window(시간 창) 내에서 N+1번째 시도는 거부됩니다. 키워드: allow는 제한 없음(무제한)을 의미합니다. deny는 항상 거부함을 의미합니다. 규칙 구문 규칙의 형식은 다음과 같습니다:\n\u0026lt;threshold\u0026gt; \u0026lt;scope\u0026gt; \u0026lt;target\u0026gt; 여기서:\n\u0026lt;threshold\u0026gt;는 N/S, allow, 또는 deny입니다 \u0026lt;scope\u0026gt;는 default, explicit, file, 또는 record 중 하나입니다(아래 참조) \u0026lt;target\u0026gt;는 스코프에 따라 달라집니다 기본 규칙 다른 규칙이 일치하지 않을 때 적용됩니다. 기본 규칙은 하나만 허용됩니다. 이를 생략하면, 알 수 없는 목적지(Destination)는 제한 없이 허용됩니다.\n15/5 default allow default deny default 명시적 규칙 Base32 주소(예: example1.b32.i2p) 또는 전체 키로 특정 Destination(목적지)을 지정합니다.\n15/5 explicit example1.b32.i2p deny explicit example2.b32.i2p allow explicit example3.b32.i2p 파일 기반 규칙 외부 파일에 나열된 모든 Destinations(I2P 목적지)를 대상으로 합니다. 각 줄에는 하나의 Destination이 포함되며, # 주석과 빈 줄이 허용됩니다.\n15/5 file /var/i2p/throttled.txt deny file /var/i2p/blocked.txt allow file /var/i2p/trusted.txt 운영 참고: 일부 구현은 파일 목록을 주기적으로 다시 읽습니다. tunnel이 실행 중일 때 목록을 편집하면 변경 사항이 감지되기까지 짧은 지연이 있을 수 있습니다. 즉시 적용하려면 재시작하세요.\n레코더(점진적 제어) recorder(기록기)는 연결 시도를 모니터링하고, 임계값을 초과한 Destination(목적지 식별자)을 파일에 기록합니다. 그런 다음 해당 파일을 file 규칙에서 참조하여 이후 시도에 제한이나 차단을 적용할 수 있습니다.\n# Start permissive allow default # Record Destinations exceeding 30 connections in 5 seconds 30/5 record /var/i2p/aggressive.txt # Apply throttling to recorded Destinations 15/5 file /var/i2p/aggressive.txt 사용 중인 빌드에서 recorder 지원을 확인한 뒤에만 이에 의존하세요. 보장된 동작을 위해 file 목록을 사용하세요.\n평가 순서 구체적인 규칙을 먼저, 일반적인 규칙을 나중에 배치하세요. 흔한 패턴:\n신뢰된 피어에 대한 명시적 허용 규칙 알려진 악성 사용자에 대한 명시적 차단 규칙 파일 기반 허용/차단 목록 점진적 대역폭 제한을 위한 로거 모든 경우를 포괄하는 기본 규칙 전체 예제 # Moderate limits by default 30/10 default # Always allow trusted peers allow explicit friend1.b32.i2p allow explicit friend2.b32.i2p # Block known bad actors deny file /var/i2p/blocklist.txt # Throttle aggressive sources 15/5 file /var/i2p/throttle.txt # Automatically populate the throttle list 60/5 record /var/i2p/throttle.txt 구현 참고 사항 액세스 필터는 애플리케이션 처리 이전에 tunnel 계층에서 동작하므로 남용 트래픽을 조기에 거부할 수 있습니다. 필터 파일을 I2PTunnel 구성 디렉터리에 배치하고 변경 사항을 적용하려면 tunnel을 재시작하십시오. 서비스 전반에 일관된 정책을 원한다면 여러 tunnel에서 파일 기반 목록을 공유하십시오. ","description":"tunnel 접근 제어 필터 파일의 구문","id":"d8b5745531fca07ea47765403a9a4d0c","section":"docs","title":"접근 필터 형식","url":"/ko/docs/specs/filter-format/"},{"categories":null,"content":"개요 이 사양은 주소 구독 피드에 명령을 추가하여 네임 서버가 호스트네임 소유자로부터의 엔트리 업데이트를 브로드캐스트할 수 있도록 합니다. 처음에는 Proposal 112 (2014년 9월)에서 제안되었고, 버전 0.9.26(2016년 6월)에서 구현되었으며, 네트워크 전반에 배포되었고 상태는 CLOSED입니다.\n해당 시스템은 초기 구현 이후로 안정적이며 변경 없이 유지되어 왔고, I2P 2.10.0(Router API 0.9.65, 2025년 9월)에서도 계속 동일하게 동작하고 있습니다.\n동기 이전에는 hosts.txt 구독 서버들이 단순한 hosts.txt 형식으로만 데이터를 전송했습니다:\nexample.i2p=b64destination 이 기본 형식은 여러 가지 문제를 초래했습니다:\n호스트명 보유자는 자신의 호스트명에 연관된 Destination(목적지 식별자)을 업데이트할 수 없다(예: 서명 키를 더 강력한 서명 키 유형으로 업그레이드하기 위해). 호스트명 보유자는 임의로 자신의 호스트명을 포기할 수 없다. 해당 Destination의 개인 키를 새 보유자에게 직접 전달해야 한다. 서브도메인이 대응하는 기본 호스트명에 의해 관리되고 있음을 인증할 방법이 없다. 이는 현재 일부 네임 서버에서만 개별적으로 강제되고 있다. 설계 이 사양은 hosts.txt 형식에 명령 줄을 추가합니다. 이러한 명령을 통해 네임 서버는 서비스를 확장하여 추가 기능을 제공할 수 있습니다. 이 사양을 구현한 클라이언트는 일반적인 구독 절차를 통해 이러한 기능을 수신할 수 있습니다.\n모든 명령 행은 해당 Destination(목적지 주소)에 의해 서명되어야 합니다. 이는 변경이 호스트네임 소유자의 요청이 있을 때에만 이루어지도록 보장합니다.\n보안상의 함의 이 명세는 익명성에 영향을 미치지 않습니다.\n누군가가 Destination key를 입수하면 이러한 명령을 사용해 연계된 모든 호스트명에 변경을 가할 수 있으므로, Destination key에 대한 통제권을 잃는 것과 관련된 위험이 증가한다. 그러나 이는 현행 상태와 비교해 더 큰 문제는 아니다. 현행 상태에서는 누군가 Destination(서비스 식별자)을 입수하면 호스트명을 사칭하고 그 트래픽을 (부분적으로) 가로챌 수 있기 때문이다. 이러한 위험 증가는, Destination이 침해되었다고 판단되는 경우 호스트명 보유자에게 해당 호스트명에 연계된 Destination을 변경할 수 있는 권한을 부여함으로써 상쇄된다. 이는 현행 시스템에서는 불가능하다.\n명세 새로운 라인 유형 새로운 라인 유형이 두 가지 있습니다:\nAdd 및 Change 명령: example.i2p=b64destination#!key1=val1#key2=val2... 삭제 명령어: #!key1=val1#key2=val2... 순서 피드는 반드시 순서가 맞거나 완전하다고 보장되지 않습니다. 예를 들어, change command가 add command보다 앞선 행에 나타나거나, add command 없이 나타날 수도 있습니다.\n키는 어떤 순서로든 배치될 수 있습니다. 중복된 키는 허용되지 않습니다. 모든 키와 값은 대소문자를 구분합니다.\n공통 키 모든 명령에 공통적으로 필요한 사항:\nsig : destination(목적지)의 서명 키를 사용한 Base64 서명\n두 번째 호스트명 및/또는 목적지에 대한 참조:\noldname : 또 다른 호스트명 (신규 또는 변경됨)\nolddest : 두 번째 Base64 목적지(새로 생성되었거나 변경됨)\noldsig : olddest의 서명 키를 사용한 두 번째 Base64 서명\n기타 일반적인 키:\naction : 명령\nname : 호스트 이름으로, example.i2p=b64dest가 앞에 오지 않은 경우에만 존재합니다\ndest : Base64로 인코딩된 목적지로, example.i2p=b64dest가 앞에 오지 않은 경우에만 포함됩니다\ndate : epoch(유닉스 기준 시각) 이후부터 경과한 초 수\nexpires : epoch(유닉스 기준 시각) 이후 경과한 초 수\n명령어 \u0026ldquo;Add\u0026rdquo; 명령을 제외한 모든 명령에는 action=command 키/값 쌍이 포함되어야 합니다.\n구버전 클라이언트와의 호환성을 위해, 아래에 언급한 대로 대부분의 명령 앞에는 example.i2p=b64dest가 붙습니다. 변경 사항의 경우 표기된 값은 항상 새 값입니다. 이전 값은 키/값 섹션에 포함됩니다.\n나열된 키는 필수입니다. 모든 명령은 여기에서 정의되지 않은 추가 키/값 항목을 포함할 수 있습니다.\n호스트 이름 추가 앞에 example.i2p=b64dest가 붙음 : 예, 이것이 새로운 호스트명과 목적지입니다.\naction : 포함되지 않습니다, 암시됩니다.\nsig : 서명\n예시:\nexample.i2p=b64dest#!sig=b64sig 호스트 이름 변경 example.i2p=b64dest가 앞에 붙은 경우 : 예, 이것은 새로운 호스트네임과 기존 destination(목적지)입니다.\naction : changename\noldname : 교체될 이전 호스트 이름\nsig : 서명\n예시:\nexample.i2p=b64dest#!action=changename#oldname=oldhostname#sig=b64sig 목적지 변경 example.i2p=b64dest가 앞에 붙음 : 예, 이는 기존 호스트명과 새 목적지입니다.\naction : changedest\nolddest : 이전 목적지, 교체될 대상\noldsig : olddest를 사용한 디지털 서명\nsig : 서명\n예시:\nexample.i2p=b64dest#!action=changedest#olddest=oldb64dest#oldsig=b64sig#sig=b64sig 호스트명 별칭 추가 example.i2p=b64dest가 앞에 붙음 : 예, 이것은 새(별칭) 호스트명과 이전 destination(목적지)입니다.\naction : addname\noldname : 이전 호스트명\nsig : 서명\n예:\nexample.i2p=b64dest#!action=addname#oldname=oldhostname#sig=b64sig Destination(목적지) 별칭 추가 (암호화 업그레이드용)\n앞에 example.i2p=b64dest가 붙음 : 예, 이것은 기존 호스트명과 새로운(대체) 목적지입니다.\naction : adddest\nolddest : 이전 목적지\noldsig : olddest를 사용한 서명\nsig : dest를 사용한 서명\n예시:\nexample.i2p=b64dest#!action=adddest#olddest=oldb64dest#oldsig=b64sig#sig=b64sig 서브도메인 추가 앞에 subdomain.example.i2p=b64dest가 붙음 : 예, 이것이 새로운 하위 도메인 이름과 destination(목적지 주소)입니다.\naction : addsubdomain\noldname : 상위 수준 호스트명 (example.i2p)\nolddest : 상위 수준 destination(목적지) (예: example.i2p)\noldsig : olddest를 사용한 서명\nsig : dest를 사용한 서명\n예시:\nsubdomain.example.i2p=b64dest#!action=addsubdomain#oldname=example.i2p#olddest=oldb64dest#oldsig=b64sig#sig=b64sig 메타데이터 업데이트 example.i2p=b64dest로 시작함 : 예, 이것은 이전의 호스트명과 목적지입니다.\n작업 : 업데이트\nsig : 서명\n(업데이트된 키가 있으면 여기에 추가하세요)\n예시:\nexample.i2p=b64dest#!action=update#k1=v1#k2=v2#sig=b64sig 호스트 이름 제거 앞에 example.i2p=b64dest를 붙임 : 아니요, 이는 옵션에서 지정됩니다\n동작 : 제거\nname : 호스트 이름\ndest : 목적지\nsig : 서명\n예시:\n#!action=remove#name=example.i2p#dest=b64dest#sig=b64sig 이 목적지를 사용하는 모든 항목 제거 example.i2p=b64dest를 접두로 사용 : 아니요, 이는 옵션에서 지정됩니다\naction : removeall\ndest : 목적지\nsig : 서명\n예시:\n#!action=removeall#dest=b64dest#sig=b64sig 서명 모든 명령은 해당하는 Destination(목적지 엔드포인트)에 의해 서명되어야 합니다. 두 개의 Destination이 포함된 명령은 두 개의 서명이 필요할 수 있습니다.\noldsig는 항상 \u0026ldquo;내부\u0026rdquo; 서명입니다. oldsig와 sig 키가 존재하지 않은 상태에서 서명하고 검증하십시오. sig는 항상 \u0026ldquo;외부\u0026rdquo; 서명입니다. oldsig 키는 존재하지만 sig 키는 존재하지 않는 상태에서 서명하고 검증하십시오.\n서명용 입력 서명 생성·검증용 바이트 스트림을 만들려면 다음과 같이 직렬화합니다:\nsig 키를 제거합니다 oldsig로 검증하는 경우 oldsig 키도 제거합니다 Add 또는 Change 명령에서만 example.i2p=b64dest를 출력합니다 키가 하나라도 남아 있으면 #!를 출력합니다 옵션을 키의 UTF-8 순서로 정렬하고, 중복 키가 있으면 실패합니다 각 키/값에 대해 key=value를 출력하고, 마지막 키/값이 아니라면 그 뒤에 #를 붙입니다 참고 사항\n개행을 출력하지 마십시오 출력 인코딩은 UTF-8입니다 모든 destination(목적지 식별자) 및 서명 인코딩은 I2P 알파벳을 사용하는 Base 64입니다 키와 값은 대소문자를 구분합니다 호스트명은 소문자여야 합니다 현재 서명 유형 I2P 2.10.0 기준으로, destinations(목적지)에 대해 다음과 같은 서명 유형이 지원됩니다:\nEdDSA_SHA512_Ed25519 (Type 7): 0.9.15부터 Destination(목적지)에서 가장 일반적으로 사용됩니다. 32바이트 공개 키와 64바이트 서명을 사용합니다. 새로운 Destination에 권장되는 서명 유형입니다. RedDSA_SHA512_Ed25519 (Type 13): Destination 및 암호화된 leaseSet에만 사용 가능합니다(0.9.39부터). 레거시 유형 (DSA_SHA1, ECDSA variants): 여전히 지원되지만 0.9.58부터 새로운 Router 식별자에 대해서는 사용 중단(deprecated)되었습니다. 참고: I2P 2.10.0부터 포스트-양자 암호 옵션을 사용할 수 있지만, 아직 기본 서명 유형은 아닙니다.\n호환성 hosts.txt 형식의 모든 새로운 줄은 선행 주석 문자(#!)를 사용해 구현되므로, 모든 이전 I2P 버전은 새로운 명령을 주석으로 해석하고 문제 없이 무시합니다.\nI2P router가 새로운 사양으로 업데이트되면, 기존 주석을 다시 해석하지는 않지만 이후에 자신의 구독 피드를 다시 가져올 때 새로운 명령을 수신하기 시작한다. 따라서 네임 서버는 명령 항목을 어떤 방식으로든 영속적으로 유지하거나, ETag(HTTP 엔터티 태그) 지원을 활성화하여 I2P router가 과거의 모든 명령을 가져올 수 있도록 하는 것이 중요하다.\n구현 현황 초기 배포: 버전 0.9.26 (2016년 6월 7일)\n현재 상태: I2P 2.10.0까지 안정적이며 변경되지 않음 (Router API 0.9.65, 2025년 9월)\n제안 상태: 닫힘(네트워크 전역에 성공적으로 배포됨)\n구현 위치: apps/addressbook/java/src/net/i2p/addressbook/ I2P Java router에 있음\n핵심 클래스: - SubscriptionList.java: 구독 처리 관리 - Subscription.java: 개별 구독 피드 처리 - AddressBook.java: 핵심 주소록 기능 - Daemon.java: 주소록 백그라운드 서비스\n기본 구독 URL: http://i2p-projekt.i2p/hosts.txt\n전송 세부 사항 구독은 조건부 GET을 지원하는 HTTP를 사용합니다:\nETag 헤더: 효율적인 변경 감지를 지원합니다 Last-Modified 헤더: 구독 업데이트 시간을 추적합니다 304 Not Modified: 콘텐츠가 변경되지 않았을 때 서버는 이를 반환해야 합니다 Content-Length: 모든 응답에 명시할 것을 강력히 권장합니다 I2P router는 적절한 캐시 지원과 함께 표준 HTTP 클라이언트 동작을 따릅니다.\n버전 컨텍스트 I2P 버전 관리 참고: 1.5.0(2021년 8월) 버전 무렵부터 I2P는 0.9.x 버전 체계에서 시맨틱 버저닝(1.x, 2.x 등)으로 전환했습니다. 그러나 내부 Router API 버전은 하위 호환성을 위해 계속해서 0.9.x 번호 체계를 사용합니다. 2025년 10월 기준 현재 릴리스는 I2P 2.10.0이며 Router API 버전은 0.9.65입니다.\n이 명세 문서는 원래 0.9.49 버전(2021년 2월)용으로 작성되었으며, 구독 피드 시스템이 0.9.26에서 처음 구현된 이후 변경되지 않았기 때문에 현재 버전 0.9.65 (I2P 2.10.0)에서도 여전히 완전히 정확합니다.\n참고 자료 제안 112 (원문) 공식 명세 I2P 네이밍 문서 공통 구조 명세 I2P 소스 코드 저장소 I2P Gitea 저장소 관련 개발 구독 피드 시스템 자체에는 변화가 없지만, I2P의 네이밍 인프라에서 관심을 가질 만한 관련 발전 사항은 다음과 같습니다:\n확장된 Base32 이름 (0.9.40+): 암호화된 leasesets를 위한 56자 이상의 base32 주소를 지원합니다. 구독 피드 형식에는 영향을 주지 않습니다. .i2p.alt TLD 등록 (RFC 9476, 2023년 말): 대체 TLD로서 .i2p.alt의 공식 GANA 등록. 향후 router 업데이트에서 .alt 접미사가 제거될 수 있으나, 구독 명령에는 변경이 필요하지 않습니다. 포스트-양자 암호 (2.10.0+): 사용 가능하지만 기본값은 아님. 구독 피드의 서명 알고리즘에 대해 향후 고려될 예정입니다. ","description":"호스트명 보유자가 자신의 항목을 업데이트하고 관리할 수 있도록 하는 주소 구독 피드용 확장 기능","id":"fa3cedda5fbeac90d0dcf029a44ee945","section":"docs","title":"주소 구독 피드 명령어","url":"/ko/docs/specs/subscription/"},{"categories":null,"content":"개요 I2P는 임시적이고 단방향인 tunnel을 구축합니다 — 암호화된 트래픽을 전달하는 router들의 순서가 정해진 시퀀스입니다. Tunnel은 inbound(메시지가 생성자를 향해 흐름) 또는 outbound(메시지가 생성자로부터 멀어지는 방향으로 흐름)로 분류됩니다.\n일반적인 교환 과정에서 Alice의 메시지는 그녀의 아웃바운드 tunnel 중 하나를 통해 전송되고, 아웃바운드 엔드포인트는 Bob의 인바운드 tunnel 중 하나의 게이트웨이로 메시지를 전달하도록 지시받으며, 그 후 Bob은 자신의 인바운드 엔드포인트에서 메시지를 수신합니다.\nA: Outbound Gateway (Alice) B: Outbound Participant C: Outbound Endpoint D: Inbound Gateway E: Inbound Participant F: Inbound Endpoint (Bob) 터널은 10분의 고정된 수명을 가지며, 메시지 크기나 타이밍 패턴을 기반으로 한 트래픽 분석을 방지하기 위해 1024바이트(tunnel 헤더를 포함하면 1028바이트)의 고정 크기 메시지를 전송합니다.\n터널 용어집 Tunnel gateway: 터널의 첫 번째 router. 인바운드 터널의 경우, 이 router의 신원이 게시된 LeaseSet 에 나타납니다. 아웃바운드 터널의 경우, gateway는 시작 router입니다 (위의 A와 D). Tunnel endpoint: 터널의 마지막 router (위의 C와 F). Tunnel participant: 터널의 중간 router (위의 B와 E). Participant는 자신의 위치나 터널 방향을 알 수 없습니다. n-hop tunnel: router 간 홉 수. 0-hop: Gateway와 endpoint가 동일한 router – 최소 익명성. 1-hop: Gateway가 endpoint에 직접 연결 – 낮은 지연시간, 낮은 익명성. 2-hop: 탐색 터널의 기본값; 보안과 성능의 균형. 3-hop: 강력한 익명성이 필요한 애플리케이션에 권장. Tunnel ID: router당 및 홉당 고유한 4바이트 정수로, 생성자가 무작위로 선택합니다. 각 홉은 서로 다른 ID로 수신하고 전달합니다. 터널 구축 정보 gateway, participant, endpoint 역할을 수행하는 라우터들은 Tunnel Build Message 내에서 서로 다른 레코드를 받습니다. 현대 I2P는 두 가지 방법을 지원합니다:\nElGamal (레거시, 528바이트 레코드) ECIES-X25519 (현재, Short Tunnel Build Message – STBM을 통한 218바이트 레코드) Information Distributed to Participants 게이트웨이가 수신하는 것: - Tunnel 계층 키 (터널 유형에 따라 AES-256 또는 ChaCha20 키) - Tunnel IV 키 (초기화 벡터 암호화용) - 응답 키 및 응답 IV (빌드 응답 암호화용) - Tunnel ID (인바운드 게이트웨이만 해당) - 다음 홉 식별 해시 및 tunnel ID (종단이 아닌 경우)\n중간 참여자가 받는 정보: - 자신의 홉에 대한 터널 레이어 키와 IV 키 - Tunnel ID와 다음 홉 정보 - 빌드 응답 암호화를 위한 응답 키와 IV\n엔드포인트가 수신하는 정보: - Tunnel 레이어 및 IV 키 - 응답 router 및 tunnel ID (아웃바운드 엔드포인트만 해당) - 응답 키 및 IV (아웃바운드 엔드포인트만 해당)\n자세한 내용은 Tunnel Creation Specification 및 ECIES Tunnel Creation Specification 을 참조하세요.\nTunnel Pooling 라우터는 중복성과 부하 분산을 위해 터널을 터널 풀로 그룹화합니다. 각 풀은 여러 개의 병렬 터널을 유지하여 하나가 실패할 때 장애 조치를 허용합니다. 내부적으로 사용되는 풀은 **탐색 터널(exploratory tunnels)**이며, 애플리케이션별 풀은 **클라이언트 터널(client tunnels)**입니다.\n각 destination은 I2CP 옵션(터널 수, 백업 수, 길이 및 QoS 매개변수)으로 구성된 별도의 인바운드 및 아웃바운드 풀을 유지합니다. Router는 터널 상태를 모니터링하고, 주기적인 테스트를 실행하며, 풀 크기를 유지하기 위해 실패한 터널을 자동으로 재구축합니다.\n터널 풀링 0-hop Tunnel : 그럴듯한 부인 가능성만 제공합니다. 트래픽은 항상 동일한 router에서 시작되고 종료됩니다 — 익명 사용에는 권장하지 않습니다.\n1-hop 터널: 수동적 관찰자에 대해 기본적인 익명성을 제공하지만, 공격자가 해당 단일 홉을 제어하는 경우 취약합니다.\n2-홉 터널: 두 개의 원격 라우터를 포함하며 공격 비용을 상당히 증가시킵니다. 탐색 풀의 기본값입니다.\n3-hop Tunnel: 강력한 익명성 보호가 필요한 애플리케이션에 권장됩니다. 추가 hop은 의미 있는 보안 향상 없이 지연 시간만 증가시킵니다.\n기본값: Router는 2-hop 탐색 tunnel과 애플리케이션별 2 또는 3 hop 클라이언트 tunnel을 사용하여 성능과 익명성의 균형을 맞춥니다.\n터널 길이 Router는 outbound tunnel을 통해 inbound tunnel로 DeliveryStatusMessage를 전송하여 주기적으로 터널을 테스트합니다. 테스트가 실패하면 두 터널 모두 부정적인 프로파일 가중치를 받습니다. 연속적인 실패는 터널을 사용 불가능한 것으로 표시하며, router는 대체 터널을 재구축하고 새로운 LeaseSet을 게시합니다. 결과는 peer 선택 시스템 에서 사용되는 peer 용량 메트릭에 반영됩니다.\n터널 테스트 Router는 비대화형 telescoping 방식을 사용하여 tunnel을 구성합니다: 단일 Tunnel Build Message가 hop별로 전파됩니다. 각 hop은 자신의 레코드를 복호화하고, 응답을 추가한 후 메시지를 전달합니다. 최종 hop은 상관관계 분석을 방지하기 위해 다른 경로를 통해 집계된 빌드 응답을 반환합니다. 최신 구현에서는 ECIES를 위해 **Short Tunnel Build Messages (STBM)**를 사용하고 레거시 경로를 위해 **Variable Tunnel Build Messages (VTBM)**를 사용합니다. 각 레코드는 ElGamal 또는 ECIES-X25519를 사용하여 hop별로 암호화됩니다.\n터널 생성 터널 트래픽은 다층 암호화를 사용합니다. 메시지가 터널을 통과할 때 각 홉(hop)은 암호화 계층을 추가하거나 제거합니다.\nElGamal tunnel: PKCS#5 패딩을 사용한 페이로드에 대한 AES-256/CBC. ECIES tunnel: 인증된 암호화를 위한 ChaCha20 또는 ChaCha20-Poly1305. 각 홉에는 두 개의 키가 있습니다: 레이어 키와 IV 키. Router들은 IV를 복호화하고, 이를 사용하여 페이로드를 처리한 다음, 전달하기 전에 IV를 다시 암호화합니다. 이 이중 IV 방식은 메시지 태깅을 방지합니다.\n아웃바운드 게이트웨이는 모든 레이어를 미리 복호화하여 모든 참여자가 암호화를 추가한 후 엔드포인트가 평문을 받도록 합니다. 인바운드 터널은 반대 방향으로 암호화합니다. 참여자는 터널 방향이나 길이를 판별할 수 없습니다.\n터널 암호화 네트워크 부하 분산을 위한 동적 tunnel 수명 및 적응형 풀 크기 조정 대체 tunnel 테스트 전략 및 개별 홉 진단 선택적 작업 증명 또는 대역폭 인증서 검증 (API 0.9.65+에서 구현됨) 엔드포인트 혼합을 위한 트래픽 셰이핑 및 chaff 삽입 연구 ElGamal의 지속적인 폐기 및 ECIES-X25519로의 마이그레이션 지속적인 개발 Tunnel Implementation Specification Tunnel Creation Specification (ElGamal) Tunnel Creation Specification (ECIES-X25519) Tunnel Message Specification Garlic Routing I2P Network Database Peer Profiling and Selection I2P 위협 모델 ElGamal/AES + SessionTag 암호화 I2CP 옵션 ","description":"I2P 터널 용어, 구성 및 생명주기 개요","id":"d2bb4d16ccaaecd4bfaae8d5b1356800","section":"docs","title":"터널 라우팅","url":"/ko/docs/overview/tunnel-routing/"},{"categories":null,"content":" 상태: I2P 2.10.0(2025년 10월)까지 업데이트됨. 이 목록은 I2P Java Router, i2pd 및 관련 플러그인에서 사용되는 모든 활성, 사용 중단 및 예약된 포트를 통합합니다. 모든 포트는 일관성을 위해 숫자 순서로 나열됩니다.\nPort Service / Component Description Notes 123SNTPNetwork time synchronizationUses external NTP servers; required for accurate LeaseSet timestamps. 2827BOB interfaceLegacy client API bridgeDeprecated; disabled by default. 4444HTTP ProxyStandard web proxy for eepsite browsingDefault for both HTTP and HTTPS browser traffic. 4445HTTPS ProxyDedicated SSL/TLS proxyOptional; often redundant with 4444. 6667–6669IRC ProxyAccess to I2P IRC networksDefault = 6668; alternate ports avoid conflicts. 7650I2PControl PluginJSON‑RPC management APIAuth required; default password itoopie. 7652UPnP HTTP eventsUPnP control interfaceSupports automatic port forwarding. 7653UPnP SSDP responsesUPnP discoveryUDP response listener for device search. 7654I2CPCore application APIUsed by Java apps and i2pd for router integration. 7655SAM DatagramUDP bridge for SAM APISAM v3 support for real‑time apps. 7656SAM StreamTCP bridge for SAM APIPrimary non‑Java application interface. 7657Router Console (HTTP)Web admin interfaceLoopback‑only by default (127.0.0.1). 7658EepsiteDefault web server for I2PTunnelUsed for locally hosted services. 7659SMTP ProxyOutgoing mail via I2P‑BoteBridges standard email clients. 7660POP3 ProxyIncoming mail via I2P‑BoteServerless email retrieval. 7661I2PBote SMTP / Pebble BlogPlugin dual‑use portRarely conflicts since plugins don’t co‑install. 7662I2PBote IMAP / Zzzot TrackerPlugin dual‑use portUsed by Zzzot for BitTorrent tracking. 7663—Reserved for future pluginsUnused as of 2.10.0. 7664JAMWiki PluginWiki platform for I2P sitesOptional plugin. 7667Router Console (HTTPS)Secure web admin interfaceSelf‑signed cert by default. 7672Railroad PluginPlugin port reservationLast documented plugin port in series. 7644Browser Mode ProxyHTTP proxy for I2P Browser BundleUsed when running Browser mode alongside router. 7647Browser Mode ConsoleRouter console for I2P Browser BundleAvoids conflict with 7657. 8002I2PSnark Web UI (HTTP)BitTorrent client UIIntegrated in router console. 8003I2PSnark Web UI (HTTPS)BitTorrent client UI (SSL)Optional secure mode. 8887Router Network Port (Legacy)Old default for peer connectionsReplaced by randomized 9151–30777 range. 8118Privoxy (Reserved)External web proxy integrationNot part of core I2P; reserved for compatibility. 8123Polipo (Reserved)Alternate proxy integrationLegacy Tor proxy compatibility. 8888Freenet (Reserved)Anonymous network portPrevents conflicts on privacy nodes. 9050–9053Tor SOCKS (Reserved)Tor proxy range for co‑installationAvoids conflicts with I2P. 9150–9153Tor Browser SOCKS (Reserved)Tor Browser integrationReserved for cross‑tool coexistence. 9151–30777Router Network Port (Random)Active TCP/UDP transport portRandomized per install for anti‑fingerprinting. 1488 / 1776XD BitTorrent ClientStandalone I2P torrent clientAlternate to I2PSnark. 31000–32000Java Service WrapperRouter process managementHandles service control and restart. 3456 / 3458 / 3459Tahoe‑LAFS PluginDecentralized file storageOptional third‑party plugin. 4691 / 8997–8999Monotone Version ControlDistributed VCS supportHistorical usage for developer tools. 7070i2pd ConsoleWeb console for C++ implementationEquivalent to Java router console. 767xPlugin Range (General)Recommended port block for pluginsDevelopers start from 7672 upward. 11371SKS/GPG Key Server (Reserved)Key distribution serviceUsed for PGP/GPG over I2P. ## 구현 참고사항 보안을 위해 9000 이하의 모든 포트(8887 제외)는 기본적으로 127.0.0.1에 바인딩됩니다. 완전한 참여를 위해서는 router 네트워크 포트(9151–30777)가 인터넷에 열려 있어야 합니다. i2pd는 호환성을 위해 대부분 동일한 할당을 사용합니다(7070 콘솔, 7654 I2CP, 7656/7655 SAM). 플러그인 개발자는 충돌을 방지하기 위해 I2P 커뮤니티를 통해 새로운 할당을 조율해야 합니다. ","description":"I2P 포트 할당, 플러그인 포트 및 예약된 범위에 대한 포괄적인 참조 자료입니다.","id":"69ea4623f7bc59ab65ef7ea636966780","section":"docs","title":"포트 할당","url":"/ko/docs/overview/ports/"},{"categories":null,"content":"개요 I2P 플러그인은 router 기능을 확장하는 서명된 아카이브입니다. 이들은 .xpi2p 또는 .su3 파일 형태로 배포되며, ~/.i2p/plugins/\u0026lt;name\u0026gt;/(Windows에서는 %APPDIR%\\I2P\\plugins\\\u0026lt;name\u0026gt;\\)에 설치되고, 샌드박싱 없이 router의 전체 권한으로 실행됩니다.\n지원되는 플러그인 유형 콘솔 웹앱 cgi-bin, webapps가 포함된 새로운 eepsites 콘솔 테마 콘솔 번역 Java 프로그램(프로세스 내 또는 별도의 JVM) 셸 스크립트 및 네이티브 바이너리 보안 모델 중요: 플러그인은 I2P router와 동일한 권한으로 동일한 JVM에서 실행됩니다. 다음에 무제한으로 접근할 수 있습니다: - 파일 시스템(읽기 및 쓰기) - router API 및 내부 상태 - 네트워크 연결 - 외부 프로그램 실행\n플러그인은 완전히 신뢰할 수 있는 코드로 취급해야 합니다. 사용자는 설치 전에 플러그인의 출처와 서명을 검증해야 합니다.\n파일 형식 SU3 형식(강력히 권장) 상태: 활성, I2P 0.9.15 (2014년 9월)부터 권장 형식\n.su3 형식은 다음을 제공합니다: - RSA-4096 서명 키 (xpi2p의 DSA-1024와 비교) - 서명은 파일 헤더에 저장 - 매직 넘버: I2Psu3 - 더 나은 전방 호환성\n구조:\n[SU3 Header with RSA-4096 signature] [ZIP Archive] ├── plugin.config (required) ├── console/ ├── lib/ ├── webapps/ └── [other plugin files] XPI2P 형식 (레거시, 사용 중단됨) 상태: 하위 호환성을 위해 지원되지만, 새 플러그인에는 권장되지 않습니다\n.xpi2p 형식은 오래된 암호학적 서명을 사용합니다: - DSA-1024 서명(DSA: 디지털 서명 알고리즘 1024비트) (NIST-800-57(미국표준기술연구소 지침)에 따라 더 이상 권장되지 않음) - ZIP 앞에 40바이트 DSA 서명이 붙음 - plugin.config에 key 필드가 필요함\n구조:\n[40-byte DSA signature] [16-byte version string (UTF-8, zero-padded)] [ZIP Archive] 마이그레이션 경로: xpi2p(구형 업데이트 형식)에서 su3(서명된 업데이트 파일 형식)로 마이그레이션하는 전환 기간에는 updateURL과 updateURL.su3를 모두 제공하십시오. 최신 router(0.9.15+)는 SU3를 자동으로 우선시합니다.\n아카이브 구조 및 plugin.config 필수 파일 plugin.config - 키-값 쌍을 사용하는 표준 I2P 구성 파일\n필수 속성 Property Description Format nameInstallation directory name, must match for updatesAlphanumeric, no spaces signerDeveloper contact informationuser@mail.i2p format recommended versionPlugin version for update comparisonMax 16 bytes, parsed by VersionComparator keyDSA public key (172 B64 chars ending with '=')Omit for SU3 format **버전 형식 예시:** - `1.2.3` - `1.2.3-4` - `2.0.0-beta.1` 허용되는 구분자: . (점), - (하이픈), _ (밑줄)\n선택적 메타데이터 속성 정보 표시 date - 릴리스 날짜 (Java long 타임스탬프) author - 개발자 이름 (user@mail.i2p 권장) description - 영어 설명 description_xx - 현지화된 설명 (xx = 언어 코드) websiteURL - 플러그인 홈페이지 (http://foo.i2p/) license - 라이선스 식별자 (예: \u0026ldquo;Apache-2.0\u0026rdquo;, \u0026ldquo;GPL-3.0\u0026rdquo;) 업데이트 설정 updateURL - XPI2P 업데이트 위치 (레거시) updateURL.su3 - SU3 업데이트 위치 (권장) min-i2p-version - 최소 필요 I2P 버전 max-i2p-version - 호환되는 최대 I2P 버전 min-java-version - 최소 Java 버전 (예: 1.7, 17) min-jetty-version - 최소 Jetty 버전 (Jetty 6+의 경우 6 사용) max-jetty-version - 최대 Jetty 버전 (Jetty 5의 경우 5.99999 사용) 설치 동작 dont-start-at-install - 기본값 false. true인 경우 수동으로 시작해야 함 router-restart-required - 기본값 false. 업데이트 후 재시작이 필요함을 사용자에게 알림 update-only - 기본값 false. 플러그인이 이미 설치되어 있지 않으면 실패 install-only - 기본값 false. 플러그인이 이미 존재하면 실패 min-installed-version - 업데이트에 필요한 최소 설치 버전 max-installed-version - 업데이트 가능한 최대 설치 버전 disableStop - 기본값 false. true인 경우 중지 버튼을 숨김 콘솔 통합 consoleLinkName - 콘솔 요약 표시줄 링크에 표시할 텍스트 consoleLinkName_xx - 현지화된 링크 텍스트 (xx = 언어 코드) consoleLinkURL - 링크 대상 (예: /appname/index.jsp) consoleLinkTooltip - 마우스오버 텍스트 (0.7.12-6부터 지원) consoleLinkTooltip_xx - 현지화된 툴팁 console-icon - 32x32 아이콘의 경로 (0.9.20부터 지원) icon-code - 웹 리소스가 없는 플러그인을 위한 Base64로 인코딩된 32x32 PNG (0.9.25부터) 플랫폼 요구 사항(표시 전용) required-platform-OS - 운영 체제 요구 사항(강제되지 않음) other-requirements - 추가 요구 사항(예: \u0026ldquo;Python 3.8+\u0026rdquo;) 의존성 관리 (미구현) depends - 쉼표로 구분된 플러그인 의존성 depends-version - 의존성에 대한 버전 요구 사항 langs - 언어 팩 내용 type - 플러그인 유형 (app/theme/locale/webapp) 업데이트 URL 변수 치환 기능 상태: I2P 1.7.0 (0.9.53)부터 사용 가능\nupdateURL 및 updateURL.su3 모두 플랫폼별 변수를 지원합니다:\n변수: - $OS - 운영 체제: windows, linux, mac - $ARCH - 아키텍처: 386, amd64, arm64\n예시:\nupdateURL.su3=http://foo.i2p/downloads/foo-$OS-$ARCH.su3 Windows AMD64에서의 결과:\nhttp://foo.i2p/downloads/foo-windows-amd64.su3 이는 플랫폼별 빌드에서 단일 plugin.config 파일을 사용할 수 있게 합니다.\n디렉터리 구조 표준 레이아웃 plugins/ └── pluginname/ ├── plugin.config (required) ├── console/ │ ├── locale/ # Translation JARs │ ├── themes/ # Console themes │ ├── webapps/ # Web applications │ └── webapps.config # Webapp configuration ├── eepsite/ │ ├── cgi-bin/ │ ├── docroot/ │ ├── logs/ │ ├── webapps/ │ └── jetty.xml ├── lib/ │ └── *.jar # Plugin libraries └── clients.config # Client startup configuration 디렉터리의 목적 console/locale/ - I2P 기본 번역을 위한 리소스 번들이 포함된 JAR 파일 - 플러그인별 번역은 console/webapps/*.war 또는 lib/*.jar에 있어야 합니다\nconsole/themes/ - 각 하위 디렉터리에는 완전한 콘솔 테마가 들어 있습니다 - 테마 검색 경로에 자동으로 추가됩니다\nconsole/webapps/ - 콘솔 통합용 .war 파일 - webapps.config에서 비활성화하지 않으면 자동으로 시작됨 - WAR 이름은 플러그인 이름과 일치할 필요가 없음\neepsite/ - 자체 Jetty 인스턴스를 갖춘 완전한 eepsite - 변수 치환을 사용하는 jetty.xml 구성 필요 - zzzot 및 pebble 플러그인 예제 참고\nlib/ - 플러그인 JAR 라이브러리 - clients.config 또는 webapps.config를 통해 classpath에 지정합니다\n웹앱 구성 webapps.config 형식 웹앱의 동작을 제어하는 표준 I2P 구성 파일.\n구문:\n# Disable autostart webapps.warname.startOnLoad=false # Add classpath JARs (as of API 0.9.53, works for any warname) webapps.warname.classpath=$PLUGIN/lib/foo.jar,$I2P/lib/bar.jar 중요 사항: - router 0.7.12-9 이전에는 호환성을 위해 plugin.warname.startOnLoad를 사용하세요 - API 0.9.53 이전에는 클래스패스는 warname이 플러그인 이름과 일치할 때만 동작했습니다 - 0.9.53+부터는 클래스패스가 어떤 웹앱 이름에서도 동작합니다\n웹앱 모범 사례 ServletContextListener(서블릿 컨텍스트 리스너) 구현\n정리를 위해 javax.servlet.ServletContextListener를 구현 또는 서블릿에서 destroy()를 재정의 업데이트 진행 중 및 router 중지 시 올바르게 종료되도록 보장 라이브러리 관리\n공유 JAR 파일은 lib/에 두고, WAR 내부에는 넣지 마세요 webapps.config 클래스패스를 통해 참조 플러그인을 별도로 설치/업데이트할 수 있게 함 충돌하는 라이브러리를 피하십시오\nJetty, Tomcat 또는 서블릿 JAR은 절대 번들하지 마십시오 표준 I2P 설치에 포함된 JAR은 절대 번들하지 마십시오 표준 라이브러리에 대해서는 classpath 섹션을 확인하십시오 컴파일 요구 사항\n.java 또는 .jsp 소스 파일을 포함하지 마십시오 시작 지연을 피하기 위해 모든 JSP를 사전 컴파일하십시오 Java/JSP 컴파일러가 사용 가능한 환경이라고 가정할 수 없습니다 서블릿 API 호환성\nI2P는 서블릿 3.0을 지원합니다 (0.9.30부터) 애너테이션 스캐닝은 지원되지 않습니다 (@WebContent) 기존의 web.xml 배포 서술자를 제공해야 합니다 Jetty(자바 서블릿 컨테이너) 버전\n현재: Jetty 9 (I2P 0.9.30+) 추상화를 위해 net.i2p.jetty.JettyStart를 사용합니다 Jetty API 변경으로부터 보호합니다 클라이언트 구성 clients.config 형식 플러그인과 함께 시작되는 클라이언트(서비스)를 정의합니다.\n기본 클라이언트:\nclientApp.0.main=com.example.PluginMain clientApp.0.name=Example Plugin Service clientApp.0.delay=30 clientApp.0.args=arg1 arg2 $PLUGIN/config.properties 중지/제거 기능이 있는 클라이언트:\nclientApp.0.stopargs=stop clientApp.0.uninstallargs=uninstall clientApp.0.classpath=$PLUGIN/lib/plugin.jar,$I2P/lib/i2p.jar 속성 참조 Property Description mainFully qualified class name implementing ClientApp interface nameDisplay name for user interface delayStartup delay in seconds (default: 0) argsSpace-separated arguments passed to constructor stopargsArguments for shutdown (must handle gracefully) uninstallargsArguments called before plugin deletion classpathComma-separated JAR paths ### 변수 치환 다음 변수들은 args, stopargs, uninstallargs, 그리고 classpath에서 치환됩니다:\nVariable Replacement $I2PI2P base installation directory $CONFIGI2P configuration directory (typically ~/.i2p) $PLUGINThis plugin's directory ($CONFIG/plugins/name) $OSOperating system: windows, linux, mac $ARCHArchitecture: 386, amd64, arm64 ### 관리형 vs. 비관리형 클라이언트 관리형 클라이언트(권장, 0.9.4부터): - ClientAppManager에 의해 인스턴스화됨 - 참조를 보유하고 상태를 추적함 - 라이프사이클 관리가 더 용이함 - 더 나은 메모리 관리\n비관리형 클라이언트: - router에 의해 시작되며, 상태 추적 없음 - 여러 번의 start/stop 호출을 원활하게 처리해야 함 - 조정을 위해 정적 상태 또는 PID 파일을 사용 - router 종료 시 호출됨 (0.7.12-3 기준)\nShellService(셸 서비스) (0.9.53 / 1.7.0부터) 자동 상태 추적을 지원하는 외부 프로그램 실행용 일반화된 솔루션.\n기능: - 프로세스 수명 주기 관리 - ClientAppManager와 통신 - 자동 PID 관리 - 크로스 플랫폼 지원\n사용법:\nclientApp.0.main=net.i2p.apps.ShellService clientApp.0.args=$PLUGIN/bin/myservice.sh 플랫폼별 스크립트의 경우:\nclientApp.0.args=$PLUGIN/bin/myservice-$OS.$ARCH 대안(레거시): OS 유형을 확인하는 Java 래퍼를 작성하고, 적절한 .bat 또는 .sh 파일과 함께 ShellCommand를 호출합니다.\n설치 절차 사용자 설치 흐름 사용자가 플러그인 URL을 Router 콘솔 플러그인 구성 페이지(/configplugins)에 붙여넣기 Router가 플러그인 파일 다운로드 서명 검증(키가 알려지지 않았고 엄격 모드가 활성화된 경우 실패) ZIP 무결성 검사 plugin.config 압축 해제 및 파싱 버전 호환성 검증(min-i2p-version, min-java-version 등) 웹앱 이름 충돌 감지 업데이트인 경우 기존 플러그인 중지 디렉터리 유효성 검사(plugins/ 하위여야 함) 모든 파일을 플러그인 디렉터리로 압축 해제 plugins.config 업데이트 플러그인 시작(dont-start-at-install=true가 아닌 경우) 보안과 신뢰 키 관리: - 신규 서명자를 위한 First-key-seen 신뢰 모델(처음 본 키를 신뢰하는 모델) - jrandom 및 zzz 키만 미리 번들됨 - 0.9.14.1 기준으로, 기본적으로 알 수 없는 키는 거부됨 - 개발을 위해 고급 속성으로 재정의 가능\n설치 제한 사항: - 아카이브는 플러그인 디렉터리에만 압축이 풀려야 함 - 설치 프로그램은 plugins/ 바깥 경로를 거부함 - 설치 후 플러그인은 다른 위치의 파일에 접근할 수 있음 - sandboxing(샌드박싱)이나 권한 분리 없음\n업데이트 메커니즘 업데이트 확인 절차 Router가 plugin.config에서 updateURL.su3(권장) 또는 updateURL을 읽습니다 바이트 41-56을 가져오기 위해 HTTP HEAD 또는 부분 GET 요청을 수행합니다 원격 파일에서 버전 문자열을 추출합니다 VersionComparator를 사용하여 설치된 버전과 비교합니다 더 최신이면 설정에 따라 사용자에게 확인을 요청하거나 자동으로 다운로드합니다 플러그인을 중지합니다 업데이트를 설치합니다 사용자 기본 설정이 변경되지 않았다면 플러그인을 시작합니다 버전 비교 버전은 점/대시/밑줄로 구분된 구성 요소로 해석됩니다: - 1.2.3 \u0026lt; 1.2.4 - 1.2.3 \u0026lt; 1.2.3-1 - 2.0.0 \u0026gt; 1.9.9\n최대 길이: 16바이트 (SUD/SU3 헤더와 일치해야 함)\n업데이트 모범 사례 릴리스에서는 항상 버전을 증가시키기 이전 버전에서 업데이트 경로를 테스트하기 주요 변경 사항에 대해 router-restart-required를 고려하기 마이그레이션 중에는 updateURL과 updateURL.su3를 모두 제공하기 테스트용으로 빌드 번호 접미사 사용하기 (1.2.3-456) 클래스패스와 표준 라이브러리 클래스패스에서 항상 사용 가능 I2P 0.9.30+에서는 $I2P/lib의 다음 JAR 파일들이 항상 classpath(클래스패스)에 포함됩니다:\nJAR Contents Plugin Usage i2p.jarCore APIRequired for all plugins mstreaming.jarStreaming APIMost plugins need streaming.jarStreaming implementationMost plugins need i2ptunnel.jarI2PTunnelHTTP/server plugins router.jarRouter internalsRarely needed, avoid if possible javax.servlet.jarServlet 3.1, JSP 2.3 APIPlugins with servlets/JSPs jasper-runtime.jarJasper compiler/runtimePlugins with JSPs commons-el.jarEL 3.0 APIJSPs using expression language jetty-i2p.jarJetty utilitiesPlugins starting Jetty org.mortbay.jetty.jarJetty 9 baseCustom Jetty instances sam.jarSAM APIRarely needed addressbook.jarSubscription/blockfileUse NamingService instead routerconsole.jarConsole librariesNot public API, avoid jbigi.jarNative cryptoPlugins should not need systray.jarURL launcherRarely needed wrapper.jarService wrapperPlugins should not need ### 특별 참고 사항 commons-logging.jar: - 0.9.30부터 비어 있음 - 0.9.30 이전: Apache Tomcat JULI - 0.9.24 이전: Commons Logging + JULI - 0.9 이전: Commons Logging만\njasper-compiler.jar: - Jetty 6 (0.9)부터 비어 있음\nsystray4j.jar: - 0.9.26에서 제거됨\n클래스패스에 없음 (지정해야 함) JAR Contents Usage jstl.jarStandard TaglibJSP tag libraries standard.jarStandard TaglibJSP tag libraries ### 클래스패스 명세 clients.config에서:\nclientApp.0.classpath=$PLUGIN/lib/mylib.jar,$I2P/lib/i2p.jar webapps.config에서:\nwebapps.mywebapp.classpath=$PLUGIN/lib/mylib.jar,$I2P/lib/jstl.jar 중요: 0.7.13-3부터 classpaths(클래스패스)는 JVM 전역이 아니라 스레드별입니다. 각 클라이언트마다 전체 classpath를 지정하십시오.\nJava 버전 요구사항 현재 요구 사항 (2025년 10월) I2P 2.10.0 및 이전: - 최소: Java 7 (0.9.24(2016년 1월)부터 필요) - 권장: Java 8 이상\nI2P 2.11.0 및 이후(예정): - 최소 요구사항: Java 17+ (2.9.0 릴리스 노트에서 공지) - 두 릴리스에 걸친 사전 공지 제공 (2.9.0 → 2.10.0 → 2.11.0)\n플러그인 호환성 전략 최대 호환성을 위해 (I2P 2.10.x까지):\n\u0026lt;javac source=\u0026#34;1.7\u0026#34; target=\u0026#34;1.7\u0026#34; /\u0026gt; min-java-version=1.7 Java 8+ 기능용:\n\u0026lt;javac source=\u0026#34;1.8\u0026#34; target=\u0026#34;1.8\u0026#34; /\u0026gt; min-java-version=1.8 Java 11+ 기능의 경우:\n\u0026lt;javac source=\u0026#34;11\u0026#34; target=\u0026#34;11\u0026#34; /\u0026gt; min-java-version=11 2.11.0+ 준비:\n\u0026lt;javac source=\u0026#34;17\u0026#34; target=\u0026#34;17\u0026#34; /\u0026gt; min-java-version=17 min-i2p-version=2.11.0 컴파일 모범 사례 더 새로운 JDK로 구버전 타깃용으로 컴파일할 때:\n\u0026lt;javac source=\u0026#34;1.7\u0026#34; target=\u0026#34;1.7\u0026#34; bootclasspath=\u0026#34;${java7.home}/jre/lib/rt.jar\u0026#34; includeantruntime=\u0026#34;false\u0026#34; /\u0026gt; 대상 Java 버전에서 지원되지 않는 API 사용을 방지합니다.\nPack200 압축 - 더 이상 사용되지 않음 중요 공지: Pack200을 사용하지 마십시오 상태: 사용 중단 및 제거됨\n원래 사양에서는 60-65% 용량 감소를 위해 Pack200 압축을 강력히 권장했습니다. 이는 더 이상 유효하지 않습니다.\n타임라인: - JEP 336: Pack200은 Java 11에서 사용 중단으로 표시됨 (2018년 9월) - JEP 367: Pack200은 Java 14에서 제거됨 (2020년 3월)\n공식 I2P 업데이트 명세서는 다음과 같이 명시합니다: \u0026gt; \u0026ldquo;zip 내의 JAR 및 WAR 파일은 위에서 \u0026lsquo;su2\u0026rsquo; 파일에 대해 문서화된 대로 pack200으로 더 이상 압축되지 않으며, 이는 최신 Java 런타임이 이를 더 이상 지원하지 않기 때문입니다.\u0026rdquo;\n해야 할 일:\n빌드 프로세스에서 pack200(자바 JAR 전용 압축 포맷)을 즉시 제거하십시오 표준 ZIP 압축을 사용하십시오 대안을 고려하십시오: 코드 축소를 위한 ProGuard/R8 네이티브 바이너리용 UPX 커스텀 언패커를 제공하는 경우 최신 압축 알고리즘(zstd, brotli) 기존 플러그인용: - 구형 routers(0.7.11-5부터 Java 10까지)는 여전히 pack200(자바 JAR 압축 형식)을 압축 해제할 수 있음 - 신형 routers(Java 11+)는 pack200을 압축 해제할 수 없음 - pack200 압축 없이 플러그인을 재배포하세요\n서명 키와 보안 키 생성 (SU3 형식) i2p.scripts 저장소의 makeplugin.sh 스크립트를 사용하세요:\n# Generate new signing key ./makeplugin.sh keygen # Keys stored in ~/.i2p-plugin-keys/ 주요 세부 사항: - 알고리즘: RSA_SHA512_4096 - 형식: X.509 인증서 - 저장소: Java 키스토어 형식\n플러그인 서명 # Create signed su3 file ./makeplugin.sh sign myplugin.zip myplugin.su3 keyname # Verify signature ./makeplugin.sh verify myplugin.su3 키 관리 모범 사례 한 번 생성하고, 영구적으로 보호\nRouters는 다른 키와 연결된 중복 키 이름을 거부합니다 Routers는 다른 키 이름과 연결된 중복 키를 거부합니다 키/이름이 일치하지 않으면 업데이트가 거부됩니다 안전한 보관\nkeystore(키 저장소)를 안전하게 백업 강력한 passphrase(문장형 비밀번호) 사용 버전 관리 시스템에 절대 커밋하지 말 것 키 회전\n현재 아키텍처에서는 지원되지 않음 장기적인 키 사용에 대한 계획 수립 팀 개발을 위한 다중 서명 방식 고려 레거시 DSA 서명 (XPI2P) 상태: 작동하지만 구식임\nxpi2p format에서 사용하는 DSA-1024 서명: - 40바이트 서명 - base64로 표현된 172자 길이의 공개 키 - NIST-800-57은 최소 (L=2048, N=224)를 권고 - I2P는 더 약한 (L=1024, N=160)을 사용\n권장 사항: 대신 RSA-4096과 함께 SU3(서명된 업데이트 파일 형식)을 사용하십시오.\n플러그인 개발 지침 필수 모범 사례 문서화\n설치 지침이 포함된 명확한 README 제공 설정 옵션과 기본값 문서화 각 릴리스마다 변경 로그 포함 필요한 I2P/Java 버전 명시 용량 최적화\n필요한 파일만 포함 router JAR 파일은 절대 번들하지 않기 설치 패키지와 업데이트 패키지 분리 (라이브러리는 lib/에) Pack200 압축 사용 더 이상 사용하지 않음 - 표준 ZIP 사용 구성\n런타임 중에는 plugin.config를 절대 수정하지 마십시오 런타임 설정에는 별도의 구성 파일을 사용하십시오 필요한 router 설정(SAM 포트, tunnels 등)을 문서화하십시오 사용자의 기존 구성을 존중하십시오 리소스 사용\n과도한 기본 대역폭 소모를 피할 것 합리적인 CPU 사용 한도를 구현할 것 종료 시 리소스를 정리할 것 적절한 경우 데몬 스레드를 사용할 것 테스트\n모든 플랫폼에서 설치/업그레이드/제거를 테스트 이전 버전에서 업데이트를 테스트 업데이트 중 웹앱 중지/재시작을 확인 최소 지원 I2P 버전으로 테스트 파일 시스템\n$I2P에 절대 쓰지 말 것(읽기 전용일 수 있음) 런타임 데이터는 $PLUGIN 또는 $CONFIG에 저장할 것 디렉터리 검색에는 I2PAppContext를 사용할 것 $CWD 위치를 가정하지 말 것 호환성\n표준 I2P 클래스를 중복 구현하지 마십시오 필요하다면 클래스를 확장하되, 대체하지 마십시오 plugin.config에서 min-i2p-version, min-jetty-version을 확인하십시오 구버전 I2P를 지원한다면 해당 버전으로 테스트하십시오 종료 처리\nclients.config에 적절한 stopargs를 설정 shutdown hook(종료 훅) 등록: I2PAppContext.addShutdownTask() 여러 차례의 시작/중지 호출을 원활하게 처리 모든 스레드를 데몬 모드로 설정 보안\n모든 외부 입력을 검증하세요 System.exit()를 절대 호출하지 마세요 사용자 프라이버시를 존중하세요 보안 코딩 모범 사례를 따르세요 라이선스\n플러그인 라이선스를 명확히 명시 번들된 라이브러리의 라이선스를 준수 필요한 출처 표기를 포함 요구되는 경우 소스 코드 접근을 제공 고급 고려사항 시간대 처리: - Router는 JVM 시간대를 UTC로 설정 - 사용자의 실제 시간대: I2PAppContext 속성 i2p.systemTimeZone\n디렉터리 발견:\n// Plugin directory String pluginDir = I2PAppContext.getGlobalContext() .getAppDir().getAbsolutePath() + \u0026#34;/plugins/\u0026#34; + pluginName; // Or use $PLUGIN variable in clients.config args 버전 번호 체계: - 시맨틱 버저닝(major.minor.patch) 사용 - 테스트를 위해 빌드 번호 추가 (1.2.3-456) - 업데이트 시 버전이 단조 증가하도록 보장\nRouter 클래스 액세스: - 일반적으로 router.jar에 대한 종속성은 피하세요 - 대신 i2p.jar의 공개 API를 사용하세요 - 향후 I2P에서는 Router 클래스 액세스가 제한될 수 있습니다\nJVM 크래시 방지(과거 이슈): - 0.7.13-3에서 수정됨 - 클래스 로더를 올바르게 사용 - 실행 중인 플러그인에서 JAR 업데이트를 피함 - 필요하다면 업데이트 시 재시작하도록 설계\nEepsite 플러그인 개요 플러그인은 자체 Jetty(자바 기반 웹 서버)와 I2PTunnel 인스턴스를 포함한 완전한 eepsites를 제공할 수 있습니다.\n아키텍처 다음을 시도하지 마십시오: - 기존 eepsite(익명 웹사이트)에 설치 - router의 기본 eepsite와 병합 - 단일 eepsite만 사용 가능하다고 가정\n대신: - 새 I2PTunnel 인스턴스를 시작합니다(CLI 방식으로) - 새 Jetty 인스턴스를 시작합니다 - clients.config에서 둘 다 구성합니다\n예제 구조 plugins/myeepsite/ ├── plugin.config ├── clients.config # Starts Jetty + I2PTunnel ├── eepsite/ │ ├── jetty.xml # Requires variable substitution │ ├── docroot/ │ ├── webapps/ │ └── logs/ └── lib/ └── [dependencies] jetty.xml에서의 변수 치환 경로에는 $PLUGIN 변수를 사용하세요:\n\u0026lt;Set name=\u0026#34;resourceBase\u0026#34;\u0026gt;$PLUGIN/eepsite/docroot\u0026lt;/Set\u0026gt; Router는 플러그인 시작 시 치환을 수행합니다.\n예시 참조 구현: - zzzot 플러그인 - 토렌트 트래커 - pebble 플러그인 - 블로그 플랫폼\n둘 다 zzz의 플러그인 페이지(I2P-internal, I2P 내부 전용)에서 이용할 수 있습니다.\n콘솔 통합 요약 표시줄 링크 router 콘솔 요약 표시줄에 클릭 가능한 링크 추가:\nconsoleLinkName=My Plugin consoleLinkURL=/myplugin/ consoleLinkTooltip=Open My Plugin Interface 현지화된 버전:\nconsoleLinkName_de=Mein Plugin consoleLinkTooltip_de=Öffne Mein Plugin Schnittstelle 콘솔 아이콘 이미지 파일(0.9.20부터):\nconsole-icon=/myicon.png consoleLinkURL이 지정된 경우(0.9.53부터) 그 값을 기준으로 한 경로이며, 그렇지 않으면 웹앱 이름을 기준으로 한 경로입니다.\n내장 아이콘(0.9.25부터):\nicon-code=iVBORw0KGgoAAAANSUhEUgAAA...Base64EncodedPNG... 다음을 사용하여 생성:\nbase64 -w 0 icon-32x32.png 또는 Java:\njava -cp i2p.jar net.i2p.data.Base64 encode icon.png 요구 사항: - 32x32 픽셀 - PNG 형식 - Base64로 인코딩(줄바꿈 없음)\n국제화 번역 번들 I2P 기본 번역용: - JAR 파일을 console/locale/에 배치 - 기존 I2P 앱용 리소스 번들을 포함 - 이름 지정: messages_xx.properties (xx = 언어 코드)\n플러그인별 번역의 경우: - console/webapps/*.war에 포함 - 또는 lib/*.jar에 포함 - 표준 Java ResourceBundle(리소스 번들) 방식을 사용\nplugin.config의 현지화된 문자열 description=My awesome plugin description_de=Mein tolles Plugin description_fr=Mon plugin génial description_es=Mi plugin increíble 지원되는 필드: - description_xx - consoleLinkName_xx - consoleLinkTooltip_xx\n콘솔 테마 번역 console/themes/에 있는 테마는 테마 검색 경로에 자동으로 추가됩니다.\n플랫폼별 플러그인 별도 패키지 접근 방식 각 플랫폼별로 다른 플러그인 이름을 사용하세요:\n# Windows package name=myplugin-windows # Linux package name=myplugin-linux # macOS package name=myplugin-mac 변수 치환 접근법 플랫폼 변수를 사용하는 단일 plugin.config:\nname=myplugin updateURL.su3=http://myplugin.i2p/downloads/myplugin-$OS-$ARCH.su3 clients.config에서:\nclientApp.0.main=net.i2p.apps.ShellService clientApp.0.args=$PLUGIN/bin/myapp-$OS-$ARCH 런타임 OS 감지 조건부 실행을 위한 Java 접근 방식:\nString os = System.getProperty(\u0026#34;os.name\u0026#34;).toLowerCase(); if (os.contains(\u0026#34;win\u0026#34;)) { // Windows-specific code } else if (os.contains(\u0026#34;nix\u0026#34;) || os.contains(\u0026#34;nux\u0026#34;)) { // Linux-specific code } else if (os.contains(\u0026#34;mac\u0026#34;)) { // macOS-specific code } 문제 해결 일반적인 문제 플러그인이 시작되지 않음: 1. I2P 버전 호환성 확인 (min-i2p-version) 2. Java 버전 확인 (min-java-version) 3. router 로그에서 오류 확인 4. 필요한 모든 JAR 파일이 클래스패스에 있는지 확인\n웹앱에 접근할 수 없음: 1. webapps.config에서 비활성화되어 있지 않은지 확인 2. Jetty 버전 호환성 확인 (min-jetty-version) 3. web.xml이 존재하는지 확인 (애노테이션 스캔은 지원되지 않음) 4. 충돌하는 웹앱 이름이 있는지 확인\n업데이트 실패: 1. 버전 문자열이 증가했는지 확인 2. 서명이 서명 키와 일치하는지 확인 3. 플러그인 이름이 설치된 버전과 일치하는지 확인 4. update-only/install-only 설정을 검토\n외부 프로그램이 종료되지 않음: 1. 자동 라이프사이클 관리를 위해 ShellService(자동 실행/중지 관리 서비스) 사용 2. 적절한 stopargs 처리 구현 3. PID 파일 정리 확인 4. 프로세스 종료 확인\n디버그 로깅 router에서 디버그 로깅 활성화:\nlogger.record.net.i2p.router.web.ConfigPluginsHandler=DEBUG 로그를 확인하십시오:\n~/.i2p/logs/log-router-0.txt 참고 정보 공식 명세 플러그인 사양 구성 형식 업데이트 사양 암호학 I2P 버전 이력 현재 릴리스: - I2P 2.10.0 (2025년 9월 8일)\n0.9.53 이후의 주요 릴리스: - 2.10.0 (2025년 9월) - Java 17+ 발표 - 2.9.0 (2025년 6월) - Java 17+ 경고 - 2.8.0 (2024년 10월) - 포스트양자 암호 테스트 - 2.6.0 (2024년 5월) - I2P-over-Tor 차단 - 2.4.0 (2023년 12월) - NetDB 보안 개선 - 2.2.0 (2023년 3월) - 혼잡 제어 - 2.1.0 (2023년 1월) - 네트워크 개선 - 2.0.0 (2022년 11월) - SSU2 전송 프로토콜 - 1.7.0/0.9.53 (2022년 2월) - ShellService, 변수 치환 - 0.9.15 (2014년 9월) - SU3 형식 도입\n버전 번호 체계: - 0.9.x 시리즈: 0.9.53 버전까지 - 2.x 시리즈: 2.0.0부터 (SSU2 도입)\n개발자 리소스 소스 코드: - 메인 저장소: https://i2pgit.org/I2P_Developers/i2p.i2p - GitHub 미러: https://github.com/i2p/i2p.i2p 플러그인 예시: - zzzot (BitTorrent 트래커) - pebble (블로그 플랫폼) - i2p-bote (서버리스 이메일) - orchid (Tor 클라이언트) - seedless (피어 교환)\n빌드 도구: - makeplugin.sh - 키 생성 및 서명 - i2p.scripts 저장소에 있음 - su3(서명된 업데이트 파일 형식) 생성 및 검증을 자동화\n커뮤니티 지원 포럼: - I2P Forum - zzz.i2p (I2P 내부)\nIRC/채팅: - OFTC의 #i2p-dev - 네트워크 내 I2P IRC\n부록 A: 전체 plugin.config 예제 # Required fields name=example-plugin signer=developer@mail.i2p version=1.2.3 # Update configuration updateURL.su3=http://example.i2p/plugins/example-$OS-$ARCH.su3 min-i2p-version=2.0.0 min-java-version=17 # Display information date=1698796800000 author=Example Developer \u0026lt;developer@mail.i2p\u0026gt; websiteURL=http://example.i2p/ license=Apache-2.0 description=An example I2P plugin demonstrating best practices description_de=Ein Beispiel-I2P-Plugin zur Demonstration bewährter Praktiken description_es=Un plugin I2P de ejemplo que demuestra las mejores prácticas # Console integration consoleLinkName=Example Plugin consoleLinkName_de=Beispiel-Plugin consoleLinkURL=/example/ consoleLinkTooltip=Open the Example Plugin control panel consoleLinkTooltip_de=Öffne das Beispiel-Plugin-Kontrollfeld console-icon=/icon.png # Installation behavior dont-start-at-install=false router-restart-required=false # Platform requirements (informational) required-platform-OS=All platforms supported other-requirements=Requires 512MB free disk space 부록 B: 완전한 clients.config 예제 # Main service client (managed) clientApp.0.main=com.example.plugin.MainService clientApp.0.name=Example Plugin Main Service clientApp.0.delay=30 clientApp.0.args=$PLUGIN/config.properties --port=7656 clientApp.0.stopargs=shutdown clientApp.0.uninstallargs=cleanup clientApp.0.classpath=$PLUGIN/lib/example.jar,$I2P/lib/i2p.jar,$I2P/lib/mstreaming.jar # External program via ShellService clientApp.1.main=net.i2p.apps.ShellService clientApp.1.name=Example Native Helper clientApp.1.delay=35 clientApp.1.args=$PLUGIN/bin/helper-$OS-$ARCH --config $PLUGIN/helper.conf clientApp.1.classpath=$I2P/lib/i2p.jar # Jetty eepsite clientApp.2.main=net.i2p.jetty.JettyStart clientApp.2.name=Example Eepsite clientApp.2.delay=40 clientApp.2.args=$PLUGIN/eepsite/jetty.xml clientApp.2.stopargs=$PLUGIN/eepsite/jetty.xml stop clientApp.2.classpath=$PLUGIN/lib/example-web.jar,$I2P/lib/i2p.jar # I2PTunnel for eepsite clientApp.3.main=net.i2p.i2ptunnel.TunnelControllerGroup clientApp.3.name=Example Eepsite Tunnel clientApp.3.delay=45 clientApp.3.args=$PLUGIN/eepsite/i2ptunnel.config 부록 C: 전체 webapps.config 예제 # Disable autostart for admin webapp webapps.example-admin.startOnLoad=false # Main webapp with classpath webapps.example.startOnLoad=true webapps.example.classpath=$PLUGIN/lib/example-core.jar,$PLUGIN/lib/commons-utils.jar,$I2P/lib/jstl.jar,$I2P/lib/standard.jar # Legacy support (pre-0.7.12-9) plugin.example.startOnLoad=true 부록 D: 마이그레이션 체크리스트 (0.9.53에서 2.10.0으로) 필요한 변경 사항 빌드 프로세스에서 Pack200 압축 제거\nAnt/Maven/Gradle 스크립트에서 pack200 작업 제거 pack200 없이 기존 플러그인을 재배포 Java 버전 요구 사항 검토\n새 기능에 대해 Java 11+를 요구하는 방안 고려 I2P 2.11.0에서 Java 17+ 요구 사항 도입 계획 수립 plugin.config의 min-java-version 업데이트 문서 업데이트\nPack200 참조 제거 Java 버전 요구 사항 업데이트 I2P 버전 참조 업데이트 (0.9.x → 2.x) 권장 변경 사항 암호학적 서명 강화\n아직 완료하지 않았다면 XPI2P에서 SU3로 마이그레이션하세요 새 플러그인에는 RSA-4096 키를 사용하세요 새 기능 활용 (0.9.53+ 사용 시)\n플랫폼별 업데이트에 $OS / $ARCH 변수를 사용 외부 프로그램에는 ShellService(셸 서비스)를 사용 개선된 웹앱 클래스패스를 사용 (모든 WAR 이름에 대해 동작) 호환성 테스트\nI2P 2.10.0에서 테스트 Java 8, 11, 17에서 검증 Windows, Linux, macOS에서 확인 선택적 개선 사항 제대로 된 ServletContextListener 구현 현지화된 설명 추가 콘솔 아이콘 제공 종료 처리 개선 포괄적인 로깅 추가 자동화된 테스트 작성 ","description":"I2P 플러그인을 위한 .xpi2p / .su3 패키징 규칙","id":"b25aafc3542216f9bbc2f124d1943fbc","section":"docs","title":"플러그인 패키지 형식","url":"/ko/docs/specs/plugin/"}]
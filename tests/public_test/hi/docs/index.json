[{"categories":null,"content":"अवलोकन यह दस्तावेज़ I2P blockfile file format (ब्लॉक-आधारित फ़ाइल फ़ॉर्मेट) और Blockfile Naming Service द्वारा उपयोग किए जाने वाले hostsdb.blockfile में मौजूद तालिकाओं को निर्दिष्ट करता है। पृष्ठभूमि के लिए, देखें I2P नामकरण और पता पुस्तिका ।\nblockfile (I2P में एक फ़ाइल फ़ॉर्मेट) संक्षिप्त बाइनरी प्रारूप में तेज़ डेस्टिनेशन लुकअप्स संभव बनाता है। पुराने hosts.txt सिस्टम की तुलना में:\nगंतव्य बाइनरी में संग्रहीत होते हैं, Base64 में नहीं। मनमाना मेटाडेटा (जैसे, जोड़े जाने की तिथि, स्रोत, टिप्पणियाँ) संलग्न किया जा सकता है। लुकअप का समय लगभग 10× तेज़ होता है। डिस्क उपयोग में मामूली वृद्धि होती है। एक blockfile डिस्क-आधारित क्रमबद्ध मैप्स (कुंजी-मूल्य युग्म) का संग्रह है, जिसे skiplists (स्किपलिस्ट, परतदार क्रमित-सूची-आधारित डेटा-स्ट्रक्चर) के रूप में कार्यान्वित किया गया है। यह Metanotion Blockfile Database से व्युत्पन्न है। यह विनिर्देश पहले फ़ाइल संरचना को परिभाषित करता है, फिर बताता है कि BlockfileNamingService द्वारा इसका उपयोग कैसे किया जाता है।\nBlockfile Naming Service (नाम सेवा) ने I2P 0.8.8 में पुराने hosts.txt कार्यान्वयन को प्रतिस्थापित किया। \u0026gt; आरंभ होने पर, यह privatehosts.txt, userhosts.txt, और hosts.txt से प्रविष्टियाँ आयात करता है\nब्लॉकफ़ाइल प्रारूप यह प्रारूप 1024-बाइट पेजों से बना है, अखंडता सुनिश्चित करने के लिए प्रत्येक के प्रारंभ में एक magic number (पहचान हेतु विशिष्ट मान) होता है। पेजों की क्रम संख्या 1 से शुरू होती है:\nPage Description 1 Superblock (starts at byte 0) 2 Metaindex skiplist (starts at byte 1024) सभी पूर्णांक **नेटवर्क बाइट क्रम (big-endian)** का उपयोग करते हैं। 2-बाइट मान unsigned (बिना चिह्न) होते हैं; 4-बाइट मान (पृष्ठ संख्याएँ) signed (चिह्नित) होते हैं और धनात्मक होने चाहिए। Threading (थ्रेड प्रबंधन): डेटाबेस को एकल-थ्रेड अभिगम के लिए डिज़ाइन किया गया है; BlockfileNamingService समकालिकरण प्रदान करता है।\nसुपरब्लॉक प्रारूप Byte Contents 0-5 Magic number 0x3141de493250 (\"1A\" 0xde \"I2P\") 6 Major version 0x01 7 Minor version 0x02 8-15 File length (in bytes) 16-19 First free list page 20-21 Mounted flag (0x01 = yes) 22-23 Span size (max key/value pairs per span, 16 for hostsdb) 24-27 Page size (as of v1.2; 1024 before that) 28-1023 Unused --- Skip List (स्किप लिस्ट) ब्लॉक पृष्ठ प्रारूप Byte Contents 0-7 Magic 0x536b69704c697374 (\"SkipList\") 8-11 First span page 12-15 First level page 16-19 Size (total keys, valid at startup) 20-23 Spans (total spans, valid at startup) 24-27 Levels (total levels, valid at startup) 28-29 Span size (as of v1.2; used for new spans) 30-1023 Unused --- स्किप लेवल ब्लॉक पेज फ़ॉर्मेट हर स्तर में एक स्पैन होता है, लेकिन सभी स्पैन में स्तर नहीं होते।\nByte Contents 0-7 Magic 0x42534c6576656c73 (\"BSLevels\") 8-9 Max height 10-11 Current height 12-15 Span page 16-… Next level pages (current height × 4 bytes, lowest first) \u0026mdash; Remaining bytes unused --- स्किप स्पैन ब्लॉक पृष्ठ प्रारूप Key/value युग्म सभी स्पैनों में key के अनुसार क्रमबद्ध किए जाते हैं। पहले के अलावा अन्य स्पैन खाली नहीं होने चाहिए।\nByte Contents 0-3 Magic 0x5370616e (\"Span\") 4-7 First continuation page or 0 8-11 Previous span page or 0 12-15 Next span page or 0 16-17 Max keys (16 for hostsdb) 18-19 Size (current keys) 20-1023 Key/value structures --- Span Continuation Block (स्पैन कंटिन्यूएशन ब्लॉक) का पृष्ठ प्रारूप Byte Contents 0-3 Magic 0x434f4e54 (\"CONT\") 4-7 Next continuation page or 0 8-1023 Key/value structures --- कुंजी/मान संरचना प्रारूप कुंजी और मान के लंबाई फ़ील्ड पृष्ठों में नहीं फैल सकते (सभी 4 बाइट एक ही पृष्ठ में फिट होने चाहिए)। यदि पर्याप्त स्थान शेष नहीं है, तो अधिकतम 3 बाइट तक पैड करें और अगले पृष्ठ के ऑफ़सेट 8 से जारी रखें।\nByte Contents 0-1 Key length (bytes) 2-3 Value length (bytes) 4-… Key data → Value data \u0026mdash; Max length = 65535 bytes each --- मुक्त सूची ब्लॉक पृष्ठ प्रारूप Byte Contents 0-7 Magic 0x2366724c69737423 (\"#frList#\") 8-11 Next free list block or 0 12-15 Number of valid free pages (0 – 252) 16-1023 Free page numbers (4 bytes each) --- खाली पृष्ठ ब्लॉक प्रारूप Byte Contents 0-7 Magic 0x7e2146524545217e (\"~!FREE!~\") 8-1023 Unused --- मेटा अनुक्रमणिका पृष्ठ 2 पर स्थित। US-ASCII strings (US-ASCII अक्षर-शृंखलाएँ) → 4-बाइट पूर्णांक को मैप करता है। कुंजी skiplist (स्किपलिस्ट) का नाम है; मान पृष्ठ सूचकांक है।\nब्लॉकफ़ाइल नामकरण सेवा की तालिकाएँ सेवा कई skiplists (skip list नामक डेटा संरचना) परिभाषित करती है। प्रत्येक स्पैन अधिकतम 16 प्रविष्टियों का समर्थन करता है।\nप्रॉपर्टीज़ Skiplist (परतों वाली सूची डेटा संरचना) %%__INFO__%% में एक प्रविष्टि शामिल है:\nKey Value info A Properties object (UTF-8 String / String map) serialized as a Mapping सामान्य फ़ील्ड्स: Property Description version \"4\" created Java long (ms since epoch) upgraded Java long (ms since epoch, since DB v2) lists Comma-separated host DBs (e.g. privatehosts.txt,userhosts.txt,hosts.txt) listversion_* Version of each DB (used to detect partial upgrades, since v4) --- रिवर्स लुकअप Skiplist (बहु-स्तरीय लिंक्ड-लिस्ट आधारित तेज़ खोज डेटा संरचना) %%__REVERSE__%% में Integer → Properties प्रविष्टियाँ होती हैं (DB v2 से)।\nकुंजी: Destination (I2P में गंतव्य पहचान) के SHA-256 हैश के पहले 4 बाइट्स। मान: Properties ऑब्जेक्ट (सीरियलाइज़्ड मैपिंग)। कई प्रविष्टियाँ टकरावों और मल्टी-होस्टनेम Destinations को संभालती हैं। प्रत्येक प्रॉपर्टी कुंजी = होस्टनेम; मान = खाली स्ट्रिंग. होस्ट डेटाबेस Skiplists (तेज़ खोज हेतु बहु-स्तरीय लिंक्ड-लिस्ट डेटा संरचना) hosts.txt, userhosts.txt, और privatehosts.txt में से प्रत्येक होस्टनेम्स → डेस्टिनेशन्स (I2P पते) की मैपिंग करता है।\nसंस्करण 4 प्रति होस्टनेम एक से अधिक Destinations (I2P में गंतव्य/पहचान) का समर्थन करता है (जिसकी शुरुआत I2P 0.9.26 में हुई थी)। संस्करण 3 के डेटाबेस स्वतः माइग्रेट हो जाते हैं।\nकुंजी UTF-8 स्ट्रिंग (होस्टनेम, छोटे अक्षरों में, .i2p पर समाप्त)\nमान संस्करण 4: 1 बाइट में गुण/गंतव्य युग्मों की संख्या प्रत्येक युग्म के लिए: गुण → गंतव्य (बाइनरी) संस्करण 3: गुण → गंतव्य (बाइनरी) DestEntry गुण Key Meaning a Time added (Java long ms) m Last modified (Java long ms) notes User comments s Source (file or subscription URL) v Signature verified (true/false) --- कार्यान्वयन संबंधी टिप्पणियाँ BlockfileNamingService Java क्लास इस विनिर्देश को कार्यान्वित करती है।\nrouter संदर्भ के बाहर, डेटाबेस केवल-पढ़ने मोड में खुलता है जब तक i2p.naming.blockfile.writeInAppContext=true न हो। मल्टी‑इंस्टेंस या मल्टी‑JVM (Java Virtual Machine—जावा वर्चुअल मशीन) एक्सेस के लिए अभिप्रेत नहीं है। तीन प्राथमिक मैप (privatehosts, userhosts, hosts) और तेज़ लुकअप के लिए एक रिवर्स मैप बनाए रखता है। संदर्भ I2P नामकरण और पता पुस्तिका दस्तावेज़ सामान्य संरचनाओं का विनिर्देश Metanotion ब्लॉकफ़ाइल डेटाबेस BlockfileNamingService JavaDoc ","description":"होस्टनेम समाधान के लिए I2P द्वारा प्रयुक्त ऑन-डिस्क blockfile (ब्लॉक-आधारित फ़ाइल) स्टोरेज फ़ॉर्मेट","id":"5cbdbb030530ec5e0200cc202d4bff7f","section":"docs","title":"Blockfile विनिर्देश","url":"/hi/docs/specs/blockfile/"},{"categories":null,"content":" चेतावनी: BOB (I2P का एक पुराना API ब्रिज) केवल पुराने DSA-SHA1 हस्ताक्षर प्रकार का समर्थन करता है। Java I2P ने 1.7.0 (2022-02) में BOB को शामिल करना बंद कर दिया; यह केवल उन इंस्टॉलेशनों पर मौजूद है जो 1.6.1 या उससे पहले से शुरू किए गए थे और कुछ i2pd (C++ आधारित I2P router का इम्प्लीमेंटेशन) बिल्ड्स पर। नई अनुप्रयोगों को SAM v3 का उपयोग करना अनिवार्य है।\nप्रोग्रामिंग भाषा बाइंडिंग्स Go – ccondom Python – i2py-bob Twisted – txi2p C++ – bobcpp प्रोटोकॉल नोट्स KEYS एक base64 गंतव्य (पब्लिक + प्राइवेट कुंजियाँ) को दर्शाता है. KEY एक base64 पब्लिक कुंजी है. ERROR प्रतिक्रियाएँ इस रूप में होती हैं: ERROR \u0026lt;description\u0026gt;\\n. OK कमांड के पूर्ण होने को दर्शाता है; वैकल्पिक डेटा उसी पंक्ति में आगे आता है. DATA लाइनें अंतिम OK से पहले अतिरिक्त आउटपुट स्ट्रीम करती हैं. help कमांड एकमात्र अपवाद है: “ऐसा कोई कमांड नहीं है” का संकेत देने के लिए यह कुछ भी नहीं लौटा सकता है।\nकनेक्शन बैनर BOB (I2P का एक नियंत्रण इंटरफ़ेस) नई पंक्ति पर समाप्त होने वाली ASCII पंक्तियों का उपयोग करता है (LF या CRLF)। कनेक्शन स्थापित होने पर यह निम्नलिखित प्रेषित करता है:\nBOB \u0026lt;version\u0026gt; OK वर्तमान संस्करण: 00.00.10। पहले के बिल्ड बड़े अक्षरों वाले हेक्स अंकों और गैर-मानक क्रमांकन का उपयोग करते थे।\nBOB Version Router Version Notes 00.00.100.9.8Latest defined version 00.00.00 – 00.00.0F—Development builds ## मुख्य कमांड पूर्ण कमांड विवरण के लिए, telnet localhost 2827 से कनेक्ट करें और help चलाएँ।\nCOMMAND OPERAND RETURNS help [command] NOTHING | OK \u0026lt;info\u0026gt; clear ERROR | OK getdest ERROR | OK \u0026lt;KEY\u0026gt; getkeys ERROR | OK \u0026lt;KEYS\u0026gt; getnick \u0026lt;tunnelname\u0026gt; ERROR | OK inhost \u0026lt;hostname | IP\u0026gt; ERROR | OK inport \u0026lt;port\u0026gt; ERROR | OK list ERROR | DATA... + OK lookup \u0026lt;hostname\u0026gt; ERROR | OK \u0026lt;KEY\u0026gt; nick \u0026lt;friendlyname\u0026gt; ERROR | OK outhost \u0026lt;hostname | IP\u0026gt; ERROR | OK outport \u0026lt;port\u0026gt; ERROR | OK quit ERROR | OK setkey \u0026lt;base64 destination\u0026gt; ERROR | OK start ERROR | OK status ERROR | DATA... + OK stop ERROR | OK अप्रचलन सारांश BOB (I2P का पुराना socket-आधारित control API) में आधुनिक हस्ताक्षर प्रकार, एन्क्रिप्टेड LeaseSets (I2P में गंतव्य तक पहुँचने हेतु tunnel endpoints युक्त डेटा-संरचना), या ट्रांसपोर्ट सुविधाओं का समर्थन नहीं है। API फ्रीज़ कर दी गई है; नए कमांड नहीं जोड़े जाएंगे। जो एप्लिकेशन अभी भी BOB पर निर्भर हैं, उन्हें यथाशीघ्र SAM v3 (I2P का अनुशंसित एप्लिकेशन API) पर माइग्रेट कर लेना चाहिए। ","description":"गंतव्य प्रबंधन के लिए अप्रचलित API (अप्रचलित)","id":"97b881216518f8e2516b859bbca19c0b","section":"docs","title":"BOB – बेसिक ओपन ब्रिज","url":"/hi/docs/legacy/bob/"},{"categories":null,"content":"अवलोकन उद्देश्य ECIES-X25519-AEAD-Ratchet I2P का आधुनिक एंड-टू-एंड एन्क्रिप्शन प्रोटोकॉल है, जो पुराने ElGamal/AES+SessionTags सिस्टम की जगह लेता है। यह forward secrecy (कुंजियाँ बाद में लीक होने पर भी पूर्व संदेश गोपनीय रहते हैं), प्रमाणीकृत एन्क्रिप्शन, और प्रदर्शन व सुरक्षा में उल्लेखनीय सुधार प्रदान करता है।\nElGamal/AES+SessionTags की तुलना में मुख्य सुधार छोटी कुंजियाँ: 32-बाइट कुंजियाँ बनाम 256-बाइट ElGamal पब्लिक कुंजियाँ (87.5% कमी) Forward Secrecy (आगे की गोपनीयता): DH ratcheting (क्रमिक कुंजी नवीनीकरण) के माध्यम से हासिल (पुराने प्रोटोकॉल में उपलब्ध नहीं) आधुनिक क्रिप्टोग्राफ़ी: X25519 DH, ChaCha20-Poly1305 AEAD (Associated Data सहित प्रमाणित एन्क्रिप्शन), SHA-256 प्रमाणित एन्क्रिप्शन: AEAD संरचना के माध्यम से अंतर्निर्मित प्रमाणीकरण Bidirectional Protocol (द्विदिश प्रोटोकॉल): युग्मित inbound/outbound सेशन बनाम एकदिश पुराना प्रोटोकॉल कुशल टैग: 8-बाइट सेशन टैग बनाम 32-बाइट टैग (75% कमी) Traffic Obfuscation (ट्रैफ़िक अस्पष्टता): Elligator2 encoding से हैंडशेक्स रैंडम से अप्रभेद्य हो जाते हैं परिनियोजन स्थिति प्रारंभिक रिलीज़: संस्करण 0.9.46 (May 25, 2020) नेटवर्क परिनियोजन: 2020 तक पूर्ण वर्तमान स्थिति: परिपक्व, व्यापक रूप से परिनियोजित (प्रोडक्शन में 5+ वर्ष) Router समर्थन: संस्करण 0.9.46 या उच्चतर आवश्यक Floodfill आवश्यकताएँ: एन्क्रिप्टेड लुकअप्स हेतु लगभग 100% अपनाने की आवश्यकता कार्यान्वयन स्थिति पूर्णतः कार्यान्वित: - New Session (NS) संदेश बाइंडिंग सहित - New Session Reply (NSR) संदेश - Existing Session (ES) संदेश - DH ratchet मेकैनिज़्म (Diffie–Hellman आधारित कुंजी-रोटेशन तंत्र) - सेशन टैग और सिमेट्रिक की रैचेट्स - DateTime, NextKey, ACK, ACK Request, Garlic Clove (I2P \u0026lsquo;garlic\u0026rsquo; संदेश का उप-घटक), और Padding ब्लॉक्स\nलागू नहीं (संस्करण 0.9.50 तक): - MessageNumbers ब्लॉक (type 6) - Options ब्लॉक (type 5) - Termination ब्लॉक (type 4) - प्रोटोकॉल-स्तरीय स्वचालित प्रतिक्रियाएँ - शून्य स्थिर कुंजी मोड - मल्टीकास्ट सत्र\nनोट: संस्करण 1.5.0 से 2.10.0 तक (2021–2025) के लिए कार्यान्वयन स्थिति का सत्यापन आवश्यक है, क्योंकि कुछ सुविधाएँ जोड़ी गई हो सकती हैं।\nप्रोटोकॉल की बुनियाद Noise Protocol Framework (क्रिप्टोग्राफी में हैंडशेक और कुंजी-सहमति प्रोटोकॉल डिज़ाइन करने का एक ढांचा) ECIES-X25519-AEAD-Ratchet Noise Protocol Framework (Revision 34, 2018-07-11) पर आधारित है, विशेष रूप से IK (परस्परक्रियात्मक, ज्ञात दूरस्थ स्थिर कुंजी) हैंडशेक पैटर्न पर, और इसमें I2P-विशिष्ट विस्तार शामिल हैं।\nNoise Protocol पहचानकर्ता (Noise Protocol: एक क्रिप्टोग्राफ़िक हैंडशेक ढांचा) Noise_IKelg2+hs2_25519_ChaChaPoly_SHA256 पहचानकर्ता घटक: - Noise - आधारभूत फ्रेमवर्क - IK - ज्ञात दूरस्थ स्थिर कुंजी के साथ इंटरैक्टिव हैंडशेक पैटर्न - elg2 - अस्थायी कुंजियों के लिए Elligator2 एन्कोडिंग (I2P विस्तार) - +hs2 - दूसरे संदेश से पहले टैग को मिलाने के लिए MixHash कॉल किया जाता है (I2P विस्तार) - 25519 - X25519 Diffie-Hellman फ़ंक्शन - ChaChaPoly - ChaCha20-Poly1305 AEAD साइफ़र (संबद्ध डेटा सहित प्रमाणित एन्क्रिप्शन) - SHA256 - SHA-256 हैश फ़ंक्शन\nNoise (क्रिप्टोग्राफ़िक प्रोटोकॉल फ्रेमवर्क) हैंडशेक पैटर्न IK पैटर्न संकेतन:\n\u0026lt;- s (Bob\u0026#39;s static key known to Alice) ... -\u0026gt; e, es, s, ss (Alice sends ephemeral, DH es, static key, DH ss) \u0026lt;- e, ee, se (Bob sends ephemeral, DH ee, DH se) टोकन के अर्थ: - e - अस्थायी कुंजी प्रेषण - s - स्थिर कुंजी प्रेषण - es - Alice की अस्थायी कुंजी और Bob की स्थिर कुंजी के बीच DH (Diffie-Hellman कुंजी विनिमय) - ss - Alice की स्थिर कुंजी और Bob की स्थिर कुंजी के बीच DH - ee - Alice की अस्थायी कुंजी और Bob की अस्थायी कुंजी के बीच DH - se - Bob की स्थिर कुंजी और Alice की अस्थायी कुंजी के बीच DH\nNoise सुरक्षा गुणधर्म Noise की शब्दावली में, IK पैटर्न प्रदान करता है:\nMessage Authentication Level Confidentiality Level Message\u0026nbsp;1 (NS) Level\u0026nbsp;1 (sender auth, KCI vulnerable) Level\u0026nbsp;2 (weak forward secrecy) Message\u0026nbsp;2 (NSR) Level\u0026nbsp;2 (mutual auth) Level\u0026nbsp;4 (weak forward secrecy) Transport (ES) Level\u0026nbsp;2 (mutual auth) Level\u0026nbsp;5 (strong forward secrecy) **प्रमाणीकरण स्तर:** - **स्तर 1**: पेलोड का प्रमाणीकरण इस रूप में होता है कि वह प्रेषक की स्थिर कुंजी के स्वामी का है, लेकिन Key Compromise Impersonation (KCI, कुंजी समझौता प्रतिरूपण) के प्रति संवेदनशील - **स्तर 2**: NSR के बाद KCI हमलों के प्रति प्रतिरोधी गोपनीयता स्तर: - स्तर 2: यदि प्रेषक की स्थिर कुंजी बाद में समझौता हो जाती है, तो Forward secrecy (आगे की गोपनीयता) - स्तर 4: यदि प्रेषक की अस्थायी कुंजी बाद में समझौता हो जाती है, तो Forward secrecy - स्तर 5: दोनों अस्थायी कुंजियों के हटाए जाने के बाद पूर्ण Forward secrecy\nIK और XK के बीच अंतर IK पैटर्न, NTCP2 और SSU2 में प्रयुक्त XK पैटर्न से भिन्न है:\nचार DH ऑपरेशन्स: IK 4 DH ऑपरेशन्स (es, ss, ee, se) का उपयोग करता है, जबकि XK में 3 होते हैं तुरंत प्रमाणीकरण: पहले संदेश में Alice का प्रमाणीकरण हो जाता है (प्रमाणीकरण स्तर 1) तेज़ Forward Secrecy (forward secrecy: भविष्य में कुंजियाँ लीक होने पर भी पुराने संदेश सुरक्षित रहते हैं): दूसरे संदेश (1-RTT) के बाद पूर्ण forward secrecy (स्तर 5) प्राप्त हो जाती है ट्रेड-ऑफ: पहले संदेश का पेलोड forward-secret नहीं है (जबकि XK में सभी पेलोड forward-secret होते हैं) सारांश: IK (एक हैंडशेक पैटर्न) Bob की प्रतिक्रिया की 1-RTT (एक राउंड-ट्रिप में) डिलीवरी को पूर्ण forward secrecy (आगे की गोपनीयता) के साथ सक्षम करता है, जिसकी कीमत यह है कि प्रारंभिक अनुरोध में forward secrecy नहीं होती।\nSignal Double Ratchet (डबल रैचेट एल्गोरिद्म) की अवधारणाएँ ECIES (Elliptic Curve Integrated Encryption Scheme — दीर्घवृत्तीय वक्र एकीकृत एन्क्रिप्शन योजना) Signal डबल रैचेट एल्गोरिथ्म से अवधारणाएँ सम्मिलित करता है:\nDH Ratchet: (Diffie-Hellman आधारित रैचेट तंत्र) नियमित अंतराल पर नई DH कुंजियों का आदान-प्रदान करके forward secrecy (आगत गोपनीयता) प्रदान करता है Symmetric Key Ratchet: (सममित-कुंजी रैचेट तंत्र) प्रत्येक संदेश के लिए नई सेशन कुंजियाँ व्युत्पन्न करता है Session Tag Ratchet: (सेशन टैग रैचेट तंत्र) नियतात्मक रूप से एक-बार-उपयोग वाले सेशन टैग उत्पन्न करता है Signal से मुख्य अंतर: - कम बार होने वाला Ratcheting (कुंजी-अद्यतन शृंखला प्रक्रिया): I2P केवल आवश्यकता पड़ने पर ही ratchet करता है (टैग लगभग समाप्त होने पर या नीति के अनुसार) - Header Encryption के बजाय Session Tags (सत्र टैग): एन्क्रिप्टेड हेडर के बजाय नियतात्मक टैग का प्रयोग करता है - Explicit ACKs (स्वीकृतियाँ): केवल रिवर्स ट्रैफिक पर निर्भर रहने के बजाय इन-बैंड ACK ब्लॉक्स का उपयोग करता है - अलग Tag और Key Ratchets: रिसीवर के लिए अधिक कुशल (कुंजी गणना को टाल सकता है)\nNoise (क्रिप्टोग्राफिक प्रोटोकॉल फ्रेमवर्क) के लिए I2P विस्तारों Elligator2 Encoding: क्षणिक कुंजियाँ इस प्रकार एन्कोड की जाती हैं कि वे यादृच्छिक से अप्रभेद्य हों NSR से पहले टैग जोड़ा गया: सहसंबंध के लिए NSR संदेश से पहले सेशन टैग जोड़ा गया परिभाषित पेलोड फ़ॉर्मेट: सभी संदेश प्रकारों के लिए ब्लॉक-आधारित पेलोड संरचना I2NP एन्कैप्सुलेशन: सभी संदेश I2NP Garlic Message हेडर में लपेटे जाते हैं अलग डेटा चरण: ट्रांसपोर्ट संदेश (ES) मानक Noise (क्रिप्टोग्राफ़िक हैंडशेक प्रोटोकॉल) डेटा चरण से अलग हो जाते हैं क्रिप्टोग्राफी के मूल घटक X25519 डिफ़ी-हेलमैन विनिर्देश: RFC 7748 मुख्य विशेषताएँ: - निजी कुंजी का आकार: 32 बाइट - सार्वजनिक कुंजी का आकार: 32 बाइट - साझा रहस्य का आकार: 32 बाइट - Endianness (बाइट क्रम): Little-endian (निम्नतम बाइट पहले) - वक्र: Curve25519\nसंचालन:\nX25519 GENERATE_PRIVATE() एक यादृच्छिक 32-बाइट निजी कुंजी उत्पन्न करता है:\nprivkey = CSRNG(32) X25519 DERIVE_PUBLIC(privkey) संबंधित सार्वजनिक कुंजी व्युत्पन्न करता है:\npubkey = curve25519_scalarmult_base(privkey) 32-बाइट little-endian (जहाँ सबसे कम महत्वपूर्ण बाइट पहले होती है) सार्वजनिक कुंजी वापस करता है।\nX25519 DH(privkey, pubkey) Diffie-Hellman key agreement (कुंजी-सहमति प्रोटोकॉल) निष्पादित करता है:\nsharedSecret = curve25519_scalarmult(privkey, pubkey) 32-बाइट का साझा रहस्य लौटाता है।\nसुरक्षा नोट: कार्यान्वयनकर्ताओं को यह सत्यापित करना अनिवार्य है कि shared secret (साझा गोपनीय मान) सभी शून्य न हो (कमज़ोर कुंजी)। ऐसा होने पर अस्वीकार करें और हैंडशेक (प्रारंभिक आदान-प्रदान) रद्द कर दें।\nChaCha20-Poly1305 AEAD (संबद्ध डेटा के साथ प्रमाणित एन्क्रिप्शन) विनिर्देश: RFC 7539 अनुभाग 2.8\nपैरामीटर्स: - कुंजी आकार: 32 बाइट (256 बिट) - नॉन्स आकार: 12 बाइट (96 बिट) - MAC आकार: 16 बाइट (128 बिट) - ब्लॉक आकार: 64 बाइट (आंतरिक)\nNonce (एक बार प्रयुक्त मान) का प्रारूप:\nByte 0-3: 0x00 0x00 0x00 0x00 (always zero) Byte 4-11: Little-endian counter (message number N) AEAD (Authenticated Encryption with Associated Data; प्रमाणित एन्क्रिप्शन विद संबद्ध डेटा) संरचना:\nAEAD (Authenticated Encryption with Associated Data, संबद्ध डेटा सहित प्रमाणीकृत एन्क्रिप्शन) ChaCha20 stream cipher को Poly1305 MAC के साथ संयोजित करता है:\nकुंजी और nonce (एक-बार प्रयुक्त संख्या) से ChaCha20 keystream (कुंजी-धारा) उत्पन्न करें plaintext (साधारण पाठ) को keystream के साथ XOR (एक्सक्लूसिव-OR) द्वारा एन्क्रिप्ट करें (associated data (संलग्न डेटा) || ciphertext (कूटपाठ)) पर Poly1305 MAC (संदेश प्रमाणीकरण कोड) की गणना करें ciphertext के अंत में 16-बाइट MAC जोड़ें ChaCha20-Poly1305 ENCRYPT(k, n, plaintext, ad) प्रामाणीकरण के साथ सादा पाठ को एन्क्रिप्ट करता है:\n# Inputs k = 32-byte cipher key n = 12-byte nonce (first 4 bytes zero, last 8 bytes = message number) plaintext = data to encrypt (0 to 65519 bytes) ad = associated data (optional, used in MAC calculation) # Output ciphertext = chacha20_encrypt(k, n, plaintext) mac = poly1305(ad || ciphertext, poly1305_key_gen(k, n)) return ciphertext || mac # Total length = len(plaintext) + 16 गुण: - Ciphertext (एन्क्रिप्ट किया गया पाठ) की लंबाई plaintext (मूल पाठ) जितनी ही होती है (stream cipher (बाइट/बिट धारा पर काम करने वाला सिफर)) - आउटपुट plaintext_length + 16 bytes होता है (इसमें MAC (संदेश प्रमाणीकरण कोड) शामिल है) - यदि key (कुंजी) गोपनीय है तो पूरा आउटपुट यादृच्छिक से अभेद्य होता है - MAC associated data (सहबद्ध डेटा) और ciphertext दोनों को प्रमाणित करता है\nChaCha20-Poly1305 DECRYPT(k, n, ciphertext, ad) डिक्रिप्ट करता है और प्रमाणीकरण सत्यापित करता है:\n# Split ciphertext and MAC ct_without_mac = ciphertext[0:-16] received_mac = ciphertext[-16:] # Verify MAC expected_mac = poly1305(ad || ct_without_mac, poly1305_key_gen(k, n)) if not constant_time_compare(received_mac, expected_mac): raise AuthenticationError(\u0026#34;MAC verification failed\u0026#34;) # Decrypt plaintext = chacha20_decrypt(k, n, ct_without_mac) return plaintext महत्वपूर्ण सुरक्षा आवश्यकताएँ: - Nonces (एक-बार-उपयोग संख्या) प्रत्येक संदेश के लिए उसी कुंजी के साथ अनिवार्य रूप से अद्वितीय हों - Nonces का पुन: उपयोग कदापि नहीं किया जाना चाहिए (पुन: उपयोग करने पर विनाशकारी विफलता) - MAC (संदेश प्रमाणीकरण कोड) सत्यापन में टाइमिंग हमलों को रोकने के लिए constant-time (स्थिर-समय) तुलना का उपयोग करना अनिवार्य है - असफल MAC सत्यापन का परिणाम संदेश के पूर्ण अस्वीकार में होना अनिवार्य है (कोई आंशिक डिक्रिप्शन नहीं)\nSHA-256 हैश फ़ंक्शन विनिर्देशन: NIST FIPS 180-4\nविशेषताएँ: - आउटपुट आकार: 32 बाइट (256 बिट) - ब्लॉक आकार: 64 बाइट (512 बिट) - सुरक्षा स्तर: 128 बिट (टकराव-प्रतिरोध)\nसंचालन:\nSHA-256 H(p, d) personalization string (व्यक्तिकरण स्ट्रिंग) के साथ SHA-256 हैश:\nH(p, d) := SHA256(p || d) जहाँ || संयोजन को दर्शाता है, p personalization string (व्यक्तिकरण स्ट्रिंग) है, और d डेटा है।\nSHA-256 MixHash(d) नए डेटा के साथ चल रहे हैश को अद्यतन करता है:\nh = SHA256(h || d) ट्रांसक्रिप्ट हैश बनाए रखने के लिए पूरे Noise हैंडशेक के दौरान उपयोग किया जाता है।\nHKDF कुंजी व्युत्पत्ति विनिर्देश: RFC 5869 विवरण: SHA-256 का उपयोग करने वाला HMAC (हैश-आधारित संदेश प्रमाणीकरण कोड)-आधारित कुंजी व्युत्पत्ति फ़ंक्शन\nपैरामीटर्स: - हैश फ़ंक्शन: HMAC-SHA256 (HMAC-आधारित संदेश प्रमाणीकरण कोड, जो SHA-256 हैश का उपयोग करता है) - सॉल्ट लंबाई: अधिकतम 32 बाइट (SHA-256 (256-बिट का सुरक्षित हैश एल्गोरिद्म) आउटपुट आकार) - आउटपुट लंबाई: परिवर्तनीय (अधिकतम 255 * 32 बाइट)\nHKDF (HMAC-आधारित कुंजी व्युत्पन्न फ़ंक्शन):\ndef HKDF(salt, ikm, info, length): \u0026#34;\u0026#34;\u0026#34; Args: salt: Salt value (32 bytes max for SHA-256) ikm: Input key material (any length) info: Context-specific info string length: Desired output length in bytes Returns: output: Derived key material (length bytes) \u0026#34;\u0026#34;\u0026#34; # Extract phase prk = HMAC-SHA256(salt, ikm) # Expand phase n = ceil(length / 32) t = b\u0026#39;\u0026#39; okm = b\u0026#39;\u0026#39; for i in range(1, n + 1): t = HMAC-SHA256(prk, t || info || byte(i)) okm = okm || t return okm[0:length] सामान्य उपयोग के पैटर्न:\n# Generate two keys (64 bytes total) keydata = HKDF(chainKey, sharedSecret, \u0026#34;KDFDHRatchetStep\u0026#34;, 64) nextRootKey = keydata[0:31] chainKey = keydata[32:63] # Generate session tag (8 bytes) tagdata = HKDF(chainKey, CONSTANT, \u0026#34;SessionTagKeyGen\u0026#34;, 64) nextChainKey = tagdata[0:31] sessionTag = tagdata[32:39] # Generate symmetric key (32 bytes) keydata = HKDF(chainKey, ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) nextChainKey = keydata[0:31] sessionKey = keydata[32:63] ECIES में प्रयुक्त इन्फो स्ट्रिंग्स: - \u0026quot;KDFDHRatchetStep\u0026quot; - DH रैचेट (क्रमिक कुंजी अद्यतन तंत्र) कुंजी व्युत्पत्ति - \u0026quot;TagAndKeyGenKeys\u0026quot; - टैग और कुंजी-श्रृंखला कुंजियों का आरंभिककरण - \u0026quot;STInitialization\u0026quot; - सेशन टैग रैचेट आरंभिककरण - \u0026quot;SessionTagKeyGen\u0026quot; - सेशन टैग उत्पादन - \u0026quot;SymmetricRatchet\u0026quot; - सममित कुंजी उत्पादन - \u0026quot;XDHRatchetTagSet\u0026quot; - DH रैचेट टैगसेट (टैग का समूह) कुंजी - \u0026quot;SessionReplyTags\u0026quot; - NSR टैगसेट उत्पादन - \u0026quot;AttachPayloadKDF\u0026quot; - NSR पेलोड कुंजी व्युत्पत्ति\nElligator2 एन्कोडिंग उद्देश्य: X25519 पब्लिक कीज़ को इस तरह एन्कोड करना कि वे समान-वितरित यादृच्छिक 32-बाइट स्ट्रिंग्स से अप्रभेद्य हों।\nविनिर्देश: Elligator2 शोधपत्र समस्या: मानक X25519 (एक ECDH एलिप्टिक-कर्व योजना) सार्वजनिक कुंजियों की संरचना पहचानने योग्य होती है। कोई पर्यवेक्षक इन कुंजियों का पता लगाकर handshake संदेशों की पहचान कर सकता है, भले ही सामग्री एन्क्रिप्टेड हो।\nसमाधान: Elligator2 ~50% मान्य X25519 सार्वजनिक कुंजियों और यादृच्छिक दिखने वाली 254-बिट स्ट्रिंगों के बीच bijective mapping (एक-एक तथा सर्व-व्यापी प्रतिचित्रण) प्रदान करता है।\nElligator2 (एक क्रिप्टोग्राफ़िक मैपिंग तकनीक) के साथ कुंजी जनन:\nElligator2 GENERATE_PRIVATE_ELG2() ऐसी निजी कुंजी उत्पन्न करता है जो Elligator2 (एक क्रिप्टोग्राफ़िक मैपिंग तकनीक) से एन्कोड होने योग्य सार्वजनिक कुंजी पर मैप होती है:\nwhile True: privkey = CSRNG(32) pubkey = DERIVE_PUBLIC(privkey) # Test if public key is Elligator2-encodable try: encoded = ENCODE_ELG2(pubkey) # Success - this key pair is suitable return privkey except NotEncodableError: # Try again with new random key continue महत्वपूर्ण: यादृच्छिक रूप से उत्पन्न निजी कुंजियों में से लगभग 50% ऐसी सार्वजनिक कुंजियाँ उत्पन्न करेंगी जिन्हें एन्कोड नहीं किया जा सकता। इन्हें त्याग देना चाहिए और पुनः उत्पन्न करने का प्रयास करना चाहिए।\nप्रदर्शन अनुकूलन: हैंडशेक के दौरान विलंब से बचने के लिए उपयुक्त कुंजी-युग्मों का एक पूल बनाए रखने हेतु पृष्ठभूमि थ्रेड में कुंजियाँ पहले से उत्पन्न करें।\nElligator2 ENCODE_ELG2(pubkey) एक सार्वजनिक कुंजी को 32 यादृच्छिक जैसी दिखने वाली बाइट्स में एन्कोड करता है:\ndef ENCODE_ELG2(pubkey): \u0026#34;\u0026#34;\u0026#34; Encodes X25519 public key using Elligator2. Args: pubkey: 32-byte X25519 public key (little-endian) Returns: encoded: 32-byte encoded key indistinguishable from random Raises: NotEncodableError: If pubkey cannot be encoded \u0026#34;\u0026#34;\u0026#34; # Perform Elligator2 representative calculation # Returns 254-bit value (31.75 bytes) encodedKey = elligator2_encode(pubkey) # Add 2 random bits to MSB to make full 32 bytes randomByte = CSRNG(1) encodedKey[31] |= (randomByte \u0026amp; 0xc0) return encodedKey एन्कोडिंग विवरण: - Elligator2 254 बिट उत्पन्न करता है (पूर्ण 256 नहीं) - बाइट 31 के शीर्ष 2 बिट रैंडम पैडिंग होते हैं - परिणाम 32-बाइट स्पेस में समान रूप से वितरित होता है - मान्य X25519 सार्वजनिक कुंजियों में से लगभग 50% को सफलतापूर्वक एन्कोड करता है\nElligator2 (एक क्रिप्टोग्राफिक मैपिंग तकनीक) DECODE_ELG2(encodedKey) डिकोड करने पर मूल सार्वजनिक कुंजी प्राप्त होती है:\ndef DECODE_ELG2(encodedKey): \u0026#34;\u0026#34;\u0026#34; Decodes Elligator2-encoded key back to X25519 public key. Args: encodedKey: 32-byte encoded key Returns: pubkey: 32-byte X25519 public key (little-endian) \u0026#34;\u0026#34;\u0026#34; # Mask out 2 random padding bits from MSB encodedKey[31] \u0026amp;= 0x3f # Perform Elligator2 representative inversion pubkey = elligator2_decode(encodedKey) return pubkey सुरक्षा गुणधर्म: - एन्कोडेड कुंजियाँ परिकलनिक रूप से यादृच्छिक बाइट्स से अप्रभेद्य होती हैं - कोई भी सांख्यिकीय परीक्षण Elligator2-एन्कोडेड कुंजियों का विश्वसनीय रूप से पता नहीं लगा सकता - डिकोडिंग नियतात्मक होती है (एक ही एन्कोडेड कुंजी हमेशा वही सार्वजनिक कुंजी उत्पन्न करती है) - एन्कोडिंग एन्कोड करने योग्य उपसमुच्चय में आने वाली ~50% कुंजियों के लिए bijective (एक-एक तथा सर्व-समापी) होती है\nकार्यान्वयन नोट्स: - हैंडशेक के दौरान पुनः-एन्कोडिंग से बचने के लिए सृजन चरण में एन्कोडेड कुंजियाँ संग्रहीत करें - Elligator2 (एक क्रिप्टोग्राफ़िक मैपिंग तकनीक) जनरेशन से प्राप्त अनुपयुक्त कुंजियाँ NTCP2 के लिए उपयोग की जा सकती हैं (जिसमें Elligator2 की आवश्यकता नहीं होती) - प्रदर्शन के लिए पृष्ठभूमि में कुंजी सृजन आवश्यक है - 50% अस्वीकृति दर के कारण औसत सृजन समय दोगुना हो जाता है\nसंदेश प्रारूप अवलोकन ECIES (Elliptic Curve Integrated Encryption Scheme - दीर्घवृत्तीय वक्र एकीकृत एन्क्रिप्शन योजना) तीन संदेश प्रकार परिभाषित करता है:\nनया सत्र (NS): Alice द्वारा Bob को भेजा गया प्रारंभिक हैंडशेक संदेश नया सत्र प्रत्युत्तर (NSR): Bob द्वारा Alice को भेजा गया हैंडशेक प्रत्युत्तर मौजूदा सत्र (ES): आगे के सभी संदेश, दोनों दिशाओं में सभी संदेश I2NP Garlic Message फ़ॉर्मैट में एनकैप्सुलेट किए जाते हैं, और उन पर अतिरिक्त एन्क्रिप्शन परतें लागू की जाती हैं।\nI2NP Garlic Message कंटेनर सभी ECIES (Elliptic Curve Integrated Encryption Scheme—अण्डवक्र समेकित एन्क्रिप्शन योजना) संदेश मानक I2NP Garlic Message हेडर में लिपटे होते हैं:\n+----+----+----+----+----+----+----+----+ |type| msg_id | expiration | +----+----+----+----+----+----+----+----+ | size |chks| +----+----+----+----+----+----+----+----+ | length | | +----+----+----+----+ + | encrypted data | ~ ~ फ़ील्ड्स: - type: 0x26 (Garlic Message) - msg_id: 4-बाइट I2NP संदेश ID - expiration: 8-बाइट Unix टाइमस्टैम्प (मिलीसेकंड) - size: 2-बाइट पेलोड का आकार - chks: 1-बाइट चेकसम - length: 4-बाइट एन्क्रिप्टेड डेटा की लंबाई - encrypted data: ECIES-एन्क्रिप्टेड पेलोड\nउद्देश्य: I2NP-स्तर पर संदेश पहचान और रूटिंग प्रदान करता है। length फ़ील्ड प्राप्तकर्ताओं को कुल एन्क्रिप्टेड पेलोड का आकार जानने की अनुमति देती है।\nनया सत्र (NS) संदेश New Session संदेश Alice से Bob तक एक नया सेशन आरंभ करता है। यह तीन प्रकारों में आता है:\nBinding सहित (1b): द्विदिश संचार के लिए Alice की स्थिर कुंजी शामिल करता है (Binding: पहचान/कुंजी को बाँधकर प्रमाणित संबंध) Binding रहित (1c): एक-दिशा संचार के लिए स्थिर कुंजी को छोड़ देता है एक-बार (1d): सत्र स्थापना के बिना एकल-संदेश मोड Binding (बाइंडिंग) सहित NS संदेश (प्रकार 1b) उपयोग मामला: स्ट्रीमिंग, उत्तर-योग्य डेटाग्राम, उत्तर की आवश्यकता वाले किसी भी प्रोटोकॉल\nकुल लंबाई: 96 + payload_length बाइट्स\nप्रारूप:\n+----+----+----+----+----+----+----+----+ | | + + | New Session Ephemeral Public Key | + 32 bytes + | Encoded with Elligator2 | + + | | +----+----+----+----+----+----+----+----+ | | + Static Key Section + | ChaCha20 encrypted data | + 32 bytes + | | + + | | +----+----+----+----+----+----+----+----+ | Poly1305 Message Authentication Code | + (MAC) for Static Key Section + | 16 bytes | +----+----+----+----+----+----+----+----+ | | + Payload Section + | ChaCha20 encrypted data | ~ Variable length ~ | | + + | | +----+----+----+----+----+----+----+----+ | Poly1305 Message Authentication Code | + (MAC) for Payload Section + | 16 bytes | +----+----+----+----+----+----+----+----+ फ़ील्ड विवरण:\nक्षणिक सार्वजनिक कुंजी (32 बाइट, स्पष्ट-पाठ): - ऐलिस की एक-बार उपयोग वाली X25519 सार्वजनिक कुंजी - Elligator2 के साथ एन्कोड की गई (यादृच्छिक से अप्रभेद्य) - प्रत्येक NS message (NS संदेश) के लिए नई उत्पन्न की जाती है (कभी पुनः उपयोग नहीं होती) - लिटिल-एंडियन प्रारूप\nस्थैतिक कुंजी अनुभाग (32 बाइट एन्क्रिप्टेड, 48 बाइट MAC (Message Authentication Code—संदेश प्रमाणीकरण कोड) के साथ): - Alice की X25519 (एलिप्टिक-कर्व कुंजी-अदला-बदली एल्गोरिथ्म) स्थैतिक सार्वजनिक कुंजी (32 बाइट) शामिल है - ChaCha20 (स्ट्रीम साइफर) से एन्क्रिप्टेड - Poly1305 MAC (16 बाइट) से प्रमाणीकृत - Bob द्वारा सत्र को Alice के destination से बाँधने के लिए प्रयुक्त\nपेलोड अनुभाग (परिवर्ती लंबाई में एन्क्रिप्टेड, +16 बाइट MAC): - इसमें garlic cloves (garlic संदेश के उप-संदेश) और अन्य ब्लॉक शामिल होते हैं - पहले ब्लॉक के रूप में DateTime ब्लॉक शामिल होना चाहिए - सामान्यतः एप्लिकेशन डेटा वाले Garlic Clove blocks शामिल होते हैं - तुरंत ratchet (कुंजी-परिवर्तन तंत्र) के लिए NextKey ब्लॉक शामिल हो सकता है - ChaCha20 से एन्क्रिप्टेड - Poly1305 MAC (16 बाइट) से प्रमाणीकरण\nसुरक्षा गुणधर्म: - अस्थायी कुंजी forward secrecy (आगे की गोपनीयता) घटक प्रदान करती है - स्थिर कुंजी Alice का प्रमाणीकरण करती है (गंतव्य से बाइंडिंग) - डोमेन पृथक्करण के लिए दोनों हिस्सों में अलग-अलग MACs (Message Authentication Codes) हैं - संपूर्ण हैंडशेक 2 DH ऑपरेशन (es, ss) करता है\nबाइंडिंग के बिना NS संदेश (प्रकार 1c) उपयोग मामला: Raw datagrams (कनेक्शन-रहित पैकेट-आधारित संदेश) जहाँ किसी उत्तर की न अपेक्षा होती है और न इच्छा\nकुल लंबाई: 96 + payload_length बाइट्स\nप्रारूप:\n+----+----+----+----+----+----+----+----+ | | + + | New Session Ephemeral Public Key | + 32 bytes + | Encoded with Elligator2 | + + | | +----+----+----+----+----+----+----+----+ | | + Flags Section + | ChaCha20 encrypted data | + 32 bytes + | All zeros | + + | | +----+----+----+----+----+----+----+----+ | Poly1305 Message Authentication Code | + (MAC) for above section + | 16 bytes | +----+----+----+----+----+----+----+----+ | | + Payload Section + | ChaCha20 encrypted data | ~ Variable length ~ | | + + | | +----+----+----+----+----+----+----+----+ | Poly1305 Message Authentication Code | + (MAC) for Payload Section + | 16 bytes | +----+----+----+----+----+----+----+----+ मुख्य अंतर: Flags Section (फ़्लैग्स अनुभाग) में स्थिर कुंजी की जगह शून्य के 32 बाइट्स होते हैं।\nDetection: Bob 32-बाइट सेक्शन को डिक्रिप्ट करके और यह जांचकर कि सभी बाइट शून्य हैं, संदेश का प्रकार निर्धारित करता है: - सभी शून्य → Unbound session (बाइंड न किया हुआ सत्र) (प्रकार 1c) - गैर-शून्य → Bound session with static key (स्थिर कुंजी वाला बाउंड सत्र) (प्रकार 1b)\nगुण: - static key (स्थिर कुंजी) न होने का मतलब Alice के गंतव्य से कोई बाइंडिंग नहीं होती - Bob उत्तर नहीं भेज सकता (कोई गंतव्य ज्ञात नहीं) - केवल 1 DH (Diffie-Hellman) ऑपरेशन (es) करता है - Noise \u0026ldquo;N\u0026rdquo; pattern (Noise प्रोटोकॉल का \u0026ldquo;N\u0026rdquo; पैटर्न) का अनुसरण करता है, \u0026ldquo;IK\u0026rdquo; के बजाय - जब उत्तर की कभी आवश्यकता नहीं होती, तब अधिक कुशल\nफ्लैग्स अनुभाग (भविष्य में उपयोग के लिए सुरक्षित): वर्तमान में सभी मान शून्य हैं। भविष्य के संस्करणों में feature negotiation (फ़ीचर पर सहमति स्थापित करने की प्रक्रिया) के लिए उपयोग किया जा सकता है।\nNS एक-बार का संदेश (प्रकार 1d) उपयोग परिदृश्य: बिना सत्र के और बिना उत्तर की अपेक्षा के एकल गुमनाम संदेश\nकुल लंबाई: 96 + payload_length बाइट्स\nप्रारूप: बाइंडिंग के बिना NS के समान (type 1c)\nअंतर: - Type 1c उसी सत्र में कई संदेश भेज सकता है (आगे ES संदेश आते हैं) - Type 1d सत्र स्थापना के बिना ठीक एक संदेश भेजता है - व्यवहार में, कार्यान्वयन प्रारम्भ में इन्हें समान रूप से मान सकते हैं\nविशेषताएँ: - अधिकतम गुमनामी (कोई स्थिर कुंजी नहीं, कोई सत्र नहीं) - किसी भी पक्ष द्वारा सत्र स्थिति संग्रहीत नहीं की जाती - Noise \u0026ldquo;N\u0026rdquo; पैटर्न का अनुसरण करता है - एकल DH (Diffie-Hellman) ऑपरेशन (es)\nनया सेशन उत्तर (NSR) संदेश Bob, Alice के NS संदेश के जवाब में, एक या अधिक NSR संदेश भेजता है। NSR, Noise IK handshake (प्रारंभिक सुरक्षित हैंडशेक) को पूर्ण करता है और द्विदिश सत्र स्थापित करता है।\nकुल लंबाई: 72 + payload_length बाइट्स\nप्रारूप:\n+----+----+----+----+----+----+----+----+ | Session Tag 8 bytes | +----+----+----+----+----+----+----+----+ | | + Ephemeral Public Key + | | + 32 bytes + | Encoded with Elligator2 | + + | | +----+----+----+----+----+----+----+----+ | Poly1305 Message Authentication Code | + (MAC) for Key Section (empty) + | 16 bytes | +----+----+----+----+----+----+----+----+ | | + Payload Section + | ChaCha20 encrypted data | ~ Variable length ~ | | + + | | +----+----+----+----+----+----+----+----+ | Poly1305 Message Authentication Code | + (MAC) for Payload Section + | 16 bytes | +----+----+----+----+----+----+----+----+ फ़ील्ड विवरण:\nसेशन टैग (8 बाइट, सादा पाठ): - NSR tagset (टैगों का समूह) से उत्पन्न (KDF (Key Derivation Function, कुंजी व्युत्पन्न फलन) अनुभाग देखें) - इस उत्तर को Alice के NS संदेश से संबद्ध करता है - Alice को यह पहचानने देता है कि यह NSR किस NS का उत्तर है - एक-बार उपयोग (कभी पुन: उपयोग नहीं किया जाता)\nअस्थायी सार्वजनिक कुंजी (32 बाइट्स, सादा-पाठ): - बॉब की एक-बार-प्रयोग वाली X25519 (कुंजी-विनिमय वक्र) सार्वजनिक कुंजी - Elligator2 (एन्कोडिंग योजना) से एन्कोड की गई - प्रत्येक NSR संदेश (एक विशेष संदेश प्रकार) के लिए नई उत्पन्न की जाती है - भेजे गए प्रत्येक NSR के लिए अलग होना आवश्यक है\nKey Section MAC (16 बाइट्स): - खाली डेटा (ZEROLEN) को प्रमाणित करता है - Noise IK प्रोटोकॉल (se pattern) का हिस्सा - हैश प्रतिलेख को संबद्ध डेटा के रूप में उपयोग करता है - NSR को NS से बाँधने के लिए अत्यंत महत्वपूर्ण\nपेलोड सेक्शन (परिवर्तनीय लंबाई): - इसमें garlic cloves (गार्लिक संदेश के उपघटक) और ब्लॉक्स शामिल होते हैं - आम तौर पर एप्लिकेशन-लेयर के प्रत्युत्तर शामिल होते हैं - खाली हो सकता है (ACK-only NSR) - अधिकतम आकार: 65519 bytes (65535 - 16 byte MAC)\nकई NSR संदेश:\nBob एक NS के प्रत्युत्तर में अनेक NSR संदेश भेज सकता है:\nप्रत्येक NSR के पास एक अद्वितीय अस्थायी कुंजी होती है प्रत्येक NSR में एक अद्वितीय session tag (सत्र टैग) होता है Alice पहले प्राप्त NSR का उपयोग हैंडशेक पूरा करने के लिए करती है अन्य NSR रिडंडेंसी हैं (पैकेट लॉस की स्थिति में) महत्वपूर्ण समय-क्रम: - Alice को ES संदेश भेजने से पहले एक NSR (एक संदेश प्रकार) प्राप्त करना चाहिए - Bob को ES संदेश भेजने से पहले एक ES संदेश प्राप्त करना चाहिए - NSR split() ऑपरेशन के माध्यम से द्विदिश सत्र कुंजियाँ स्थापित करता है\nसुरक्षा गुणधर्म: - Noise IK handshake (Noise प्रोटोकॉल का IK हैंडशेक पैटर्न) पूरा करता है - 2 अतिरिक्त DH operations (Diffie-Hellman कुंजी-विनिमय क्रियाएँ) (ee, se) निष्पादित करता है - NS+NSR मिलाकर कुल 4 DH operations - द्विपक्षीय प्रमाणीकरण (स्तर 2) प्राप्त करता है - NSR पेलोड के लिए कमजोर फ़ॉरवर्ड सीक्रेसी (स्तर 4) प्रदान करता है\nविद्यमान सत्र (ES) संदेश NS/NSR हैंडशेक के बाद सभी संदेश Existing Session (मौजूदा सत्र) प्रारूप का उपयोग करते हैं। ES संदेशों का उपयोग Alice और Bob दोनों द्वारा द्विदिश रूप से किया जाता है।\nकुल लंबाई: 8 + payload_length + 16 बाइट (न्यूनतम 24 बाइट)\nप्रारूप:\n+----+----+----+----+----+----+----+----+ | Session Tag 8 bytes | +----+----+----+----+----+----+----+----+ | | + Payload Section + | ChaCha20 encrypted data | ~ Variable length ~ | | + + | | +----+----+----+----+----+----+----+----+ | Poly1305 Message Authentication Code | + (MAC) + | 16 bytes | +----+----+----+----+----+----+----+----+ फ़ील्ड विवरण:\nSession Tag (8 बाइट, स्पष्ट-पाठ): - वर्तमान निर्गामी tagset से उत्पन्न - सत्र और संदेश संख्या की पहचान करता है - प्राप्तकर्ता टैग के आधार पर सत्र कुंजी और nonce (एक बार प्रयुक्त होने वाला यादृच्छिक मान) प्राप्त करता है - एक-बार उपयोग (प्रत्येक टैग का ठीक एक बार ही प्रयोग होता है) - प्रारूप: HKDF (HMAC-आधारित कुंजी व्युत्पत्ति फ़ंक्शन) आउटपुट के पहले 8 बाइट\nपेलोड अनुभाग (परिवर्तनीय लंबाई): - इसमें garlic cloves (I2P में \u0026lsquo;garlic encryption\u0026rsquo; के अंदर उप-संदेश इकाइयाँ) और ब्लॉक होते हैं - कोई अनिवार्य ब्लॉक नहीं (खाली हो सकता है) - सामान्य ब्लॉक: Garlic Clove, NextKey, ACK, ACK Request, Padding - अधिकतम आकार: 65519 bytes (65535 - 16 byte MAC)\nMAC (16 बाइट्स): - Poly1305 प्रमाणीकरण टैग - पूरे पेलोड पर गणना की जाती है - संबद्ध डेटा: 8-बाइट का सेशन टैग - सही ढंग से सत्यापित होना आवश्यक है, अन्यथा संदेश अस्वीकार कर दिया जाता है\nटैग लुकअप प्रक्रिया:\nरिसीवर 8-बाइट टैग निकालता है सभी वर्तमान आगत टैगसेट्स में टैग ढूँढता है संबद्ध सेशन कुंजी और संदेश संख्या N प्राप्त करता है नॉन्स (एक-बार प्रयुक्त मान) बनाता है: [0x00, 0x00, 0x00, 0x00, N (8 bytes little-endian)] AEAD (Authenticated Encryption with Associated Data - संबद्ध डेटा सहित प्रमाणीकरणयुक्त एन्क्रिप्शन) का उपयोग करते हुए, टैग को संबद्ध डेटा के रूप में लेकर पेलोड को डिक्रिप्ट करता है टैगसेट से टैग हटाता है (एक-बार उपयोग) डिक्रिप्ट किए गए ब्लॉक्स का प्रसंस्करण करता है Session Tag (सत्र टैग) नहीं मिला:\nयदि tag किसी भी tagset में नहीं मिलता है: - संभवतः NS संदेश → NS डिक्रिप्शन का प्रयास करें - संभवतः NSR संदेश → NSR डिक्रिप्शन का प्रयास करें - संभवतः out-of-order ES → tagset अपडेट के लिए थोड़ी देर प्रतीक्षा करें - संभवतः रीप्ले हमला → अस्वीकार करें - संभवतः दूषित डेटा → अस्वीकार करें\nरिक्त पेलोड:\nES messages (एक विशेष प्रकार के संदेश) में खाली पेलोड (0 बाइट) हो सकते हैं: - जब ACK अनुरोध प्राप्त हो, तो यह स्पष्ट ACK के रूप में कार्य करता है - एप्लिकेशन डेटा के बिना प्रोटोकॉल-स्तर की प्रतिक्रिया प्रदान करता है - फिर भी एक session tag (सत्र टैग) का उपभोग करता है - जब उच्चतर लेयर के पास भेजने के लिए तत्काल डेटा न हो, तब उपयोगी\nसुरक्षा विशेषताएँ: - NSR प्राप्त होने के बाद पूर्ण फॉरवर्ड सीक्रेसी (लेवल 5) - AEAD (एसोसिएटेड डेटा के साथ प्रमाणीकृत एन्क्रिप्शन) के माध्यम से प्रमाणीकृत एन्क्रिप्शन - टैग अतिरिक्त एसोसिएटेड डेटा के रूप में कार्य करता है - ratchet (क्रमिक कुंजी-अपडेट तंत्र) आवश्यक होने से पहले प्रति tagset अधिकतम 65535 संदेश\nकुंजी व्युत्पत्ति फलन यह अनुभाग ECIES (दीर्घवृत्तीय वक्र एकीकृत एन्क्रिप्शन योजना) में प्रयुक्त सभी KDF (कुंजी-व्युत्पत्ति फ़ंक्शन) क्रियाओं का प्रलेखन करता है, तथा पूर्ण क्रिप्टोग्राफ़िक व्युत्पत्तियाँ प्रदर्शित करता है।\nप्रतीक-विधान और स्थिरांक स्थिरांक: - ZEROLEN - शून्य-लंबाई बाइट ऐरे (रिक्त स्ट्रिंग) - || - संयोजन ऑपरेटर\nवेरिएबल्स: - h - रनिंग हैश ट्रांस्क्रिप्ट (32 बाइट्स) - chainKey - HKDF के लिए चेनिंग की (32 बाइट्स) - k - सममित सिफर कुंजी (32 बाइट्स) - n - Nonce (एक-बार प्रयुक्त यादृच्छिक संख्या) / संदेश संख्या\nकुंजियाँ: - ask / apk - Alice की स्थिर निजी/सार्वजनिक कुंजी - aesk / aepk - Alice की अस्थायी निजी/सार्वजनिक कुंजी - bsk / bpk - Bob की स्थिर निजी/सार्वजनिक कुंजी - besk / bepk - Bob की अस्थायी निजी/सार्वजनिक कुंजी\nNS संदेश के लिए कुंजी व्युत्पत्ति फलन KDF 1: प्रारंभिक श्रृंखला कुंजी प्रोटोकॉल प्रारंभ पर केवल एक बार किया जाता है (पूर्व-गणना की जा सकती है):\n# Protocol name (40 bytes, ASCII, no null termination) protocol_name = \u0026#34;Noise_IKelg2+hs2_25519_ChaChaPoly_SHA256\u0026#34; # Initialize hash h = SHA256(protocol_name) # Initialize chaining key chainKey = h # MixHash with empty prologue h = SHA256(h) # State: chainKey and h initialized # Can be precalculated for all outbound sessions परिणाम: - chainKey = सभी आगामी KDFs (कुंजी व्युत्पत्ति फलन) के लिए प्रारंभिक चेनिंग कुंजी - h = प्रारंभिक ट्रांस्क्रिप्ट हैश\nKDF 2 (कुंजी व्युत्पन्न फ़ंक्शन): Bob की स्थिर कुंजी का मिश्रण Bob यह कार्य एक बार करता है (इसे सभी इनबाउंड सत्रों के लिए पहले से गणना किया जा सकता है):\n# Bob\u0026#39;s static keys (published in LeaseSet) bsk = GENERATE_PRIVATE() bpk = DERIVE_PUBLIC(bsk) # Mix Bob\u0026#39;s public key into hash h = SHA256(h || bpk) # State: h updated with Bob\u0026#39;s identity # Can be precalculated by Bob for all inbound sessions KDF 3: ऐलिस की अस्थायी कुंजी उत्पत्ति Alice प्रत्येक NS संदेश के लिए नई कुंजियाँ उत्पन्न करती है:\n# Generate ephemeral key pair suitable for Elligator2 aesk = GENERATE_PRIVATE_ELG2() aepk = DERIVE_PUBLIC(aesk) # Mix ephemeral public key into hash h = SHA256(h || aepk) # Elligator2 encode for transmission elg2_aepk = ENCODE_ELG2(aepk) # State: h updated with Alice\u0026#39;s ephemeral key # Send elg2_aepk as first 32 bytes of NS message KDF (कुंजी व्युत्पत्ति फ़ंक्शन) 4: NS स्थिर कुंजी अनुभाग (es DH) एलिस की स्थिर कुंजी को एन्क्रिप्ट करने के लिए कुंजियाँ व्युत्पन्न करता है:\n# Perform first DH (ephemeral-static) sharedSecret = DH(aesk, bpk) # Alice computes # Equivalent: sharedSecret = DH(bsk, aepk) # Bob computes # Derive cipher key from shared secret keydata = HKDF(chainKey, sharedSecret, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k = keydata[32:63] # AEAD encryption parameters nonce = 0 associated_data = h # Current hash transcript # Encrypt static key section if binding_requested: plaintext = apk # Alice\u0026#39;s static public key (32 bytes) else: plaintext = bytes(32) # All zeros for unbound ciphertext = ENCRYPT(k, nonce, plaintext, associated_data) # ciphertext = 32 bytes encrypted + 16 bytes MAC = 48 bytes # Mix ciphertext into hash h = SHA256(h || ciphertext) # State: Static key section encrypted, h updated # Send ciphertext (48 bytes) as next part of NS message KDF (कुंजी व्युत्पत्ति फ़ंक्शन) 5: NS पेलोड अनुभाग (ss DH (स्टैटिक-स्टैटिक डिफी-हेलमैन), केवल बाइंड) बाउंड सत्रों के लिए, पेलोड एन्क्रिप्शन हेतु दूसरा DH (Diffie-Hellman कुंजी विनिमय) करें:\nif binding_requested: # Alice\u0026#39;s static keys ask = GENERATE_PRIVATE() # Alice\u0026#39;s long-term key apk = DERIVE_PUBLIC(ask) # Perform second DH (static-static) sharedSecret = DH(ask, bpk) # Alice computes # Equivalent: sharedSecret = DH(bsk, apk) # Bob computes # Derive cipher key keydata = HKDF(chainKey, sharedSecret, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k = keydata[32:63] nonce = 0 associated_data = h else: # Unbound: reuse keys from static key section # chainKey and k unchanged nonce = 1 # Increment nonce (reusing same key) associated_data = h # Encrypt payload payload = build_payload() # DateTime + Garlic Cloves + etc. ciphertext = ENCRYPT(k, nonce, payload, associated_data) # Mix ciphertext into hash h = SHA256(h || ciphertext) # State: Payload encrypted, h contains complete NS transcript # Save chainKey and h for NSR processing # Send ciphertext as final part of NS message महत्वपूर्ण टिप्पणियाँ:\nBound बनाम Unbound:\nBound 2 DH (Diffie-Hellman कुंजी-विनिमय) ऑपरेशन करता है (es + ss) Unbound 1 DH ऑपरेशन करता है (केवल es) Unbound नई key (कुंजी) व्युत्पन्न करने के बजाय nonce (एक बार उपयोग होने वाला मान) को बढ़ाता है कुंजी पुन:उपयोग सुरक्षा:\nभिन्न nonce (एक-बार उपयोग होने वाली संख्या) मान (0 बनाम 1) कुंजी/nonce के पुन:उपयोग को रोकते हैं भिन्न संबद्ध डेटा (h अलग है) डोमेन पृथक्करण प्रदान करता है हैश ट्रांसक्रिप्ट:\nh में अब शामिल हैं: protocol_name, empty prologue, bpk, aepk, static_key_ciphertext, payload_ciphertext यह ट्रांसक्रिप्ट NS संदेश के सभी भागों को एक साथ बाँधता है NSR उत्तर टैगसेट कुंजी व्युत्पन्न फ़ंक्शन Bob NSR संदेशों (NSR नामक संदेश प्रकार) के लिए टैग उत्पन्न करता है:\n# Chain key from NS payload section # chainKey = final chainKey from NS KDF # Generate tagset key tagsetKey = HKDF(chainKey, ZEROLEN, \u0026#34;SessionReplyTags\u0026#34;, 32) # Initialize NSR tagset (see DH_INITIALIZE below) tagset_nsr = DH_INITIALIZE(chainKey, tagsetKey) # Get tag for this NSR tagsetEntry = tagset_nsr.GET_NEXT_ENTRY() tag = tagsetEntry.SESSION_TAG # 8 bytes # State: tag available for NSR message # Send tag as first 8 bytes of NSR NSR संदेश कुंजी व्युत्पत्ति फ़ंक्शन KDF 6: NSR अस्थायी कुंजी सृजन Bob प्रत्येक NSR के लिए एक नई ephemeral key (क्षणिक कुंजी) उत्पन्न करता है:\n# Mix tag into hash (I2P extension to Noise) h = SHA256(h || tag) # Generate ephemeral key pair besk = GENERATE_PRIVATE_ELG2() bepk = DERIVE_PUBLIC(besk) # Mix ephemeral public key into hash h = SHA256(h || bepk) # Elligator2 encode for transmission elg2_bepk = ENCODE_ELG2(bepk) # State: h updated with tag and Bob\u0026#39;s ephemeral key # Send elg2_bepk as bytes 9-40 of NSR message KDF 7: NSR कुंजी अनुभाग (ee और se DH (Diffie-Hellman कुंजी-विनिमय)) NSR key section (NSR का कुंजी अनुभाग) के लिए कुंजियाँ व्युत्पन्न करता है:\n# Perform third DH (ephemeral-ephemeral) sharedSecret_ee = DH(aesk, bepk) # Alice computes # Equivalent: sharedSecret_ee = DH(besk, aepk) # Bob computes # Mix ee into chain keydata = HKDF(chainKey, sharedSecret_ee, \u0026#34;\u0026#34;, 32) chainKey = keydata[0:31] # Perform fourth DH (static-ephemeral) sharedSecret_se = DH(ask, bepk) # Alice computes # Equivalent: sharedSecret_se = DH(besk, apk) # Bob computes # Derive cipher key from se keydata = HKDF(chainKey, sharedSecret_se, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k = keydata[32:63] # AEAD encryption of empty data (key section has no payload) nonce = 0 associated_data = h ciphertext = ENCRYPT(k, nonce, ZEROLEN, associated_data) # ciphertext = 16 bytes (MAC only, no plaintext) # Mix ciphertext into hash h = SHA256(h || ciphertext) # State: Key section encrypted, chainKey contains all 4 DH results # Send ciphertext (16 bytes MAC) as bytes 41-56 of NSR महत्वपूर्ण: यह Noise IK handshake (Noise प्रोटोकॉल का IK हैंडशेक) को पूरा करता है। chainKey में अब सभी 4 DH ऑपरेशन्स (es, ss, ee, se) का योगदान शामिल है।\nKDF 8: NSR पेलोड अनुभाग NSR पेलोड एन्क्रिप्शन हेतु कुंजियाँ व्युत्पन्न करता है:\n# Split chainKey into bidirectional keys keydata = HKDF(chainKey, ZEROLEN, \u0026#34;\u0026#34;, 64) k_ab = keydata[0:31] # Alice → Bob key k_ba = keydata[32:63] # Bob → Alice key # Initialize ES tagsets for both directions tagset_ab = DH_INITIALIZE(chainKey, k_ab) # Alice → Bob tagset_ba = DH_INITIALIZE(chainKey, k_ba) # Bob → Alice # Derive NSR payload key (Bob → Alice) k_nsr = HKDF(k_ba, ZEROLEN, \u0026#34;AttachPayloadKDF\u0026#34;, 32) # Encrypt NSR payload nonce = 0 associated_data = h # Binds payload to entire NSR payload = build_payload() # Usually application reply ciphertext = ENCRYPT(k_nsr, nonce, payload, associated_data) # State: Bidirectional ES sessions established # tagset_ab and tagset_ba ready for ES messages # Send ciphertext as bytes 57+ of NSR message महत्वपूर्ण टिप्पणियाँ:\nविभाजन ऑपरेशन:\nप्रत्येक दिशा के लिए स्वतंत्र कुंजियाँ बनाता है Alice→Bob और Bob→Alice के बीच कुंजियों के पुन: उपयोग को रोकता है NSR पेलोड बाइंडिंग:\nहैंडशेक से पेलोड को बांधने के लिए h को associated data (संबद्ध डेटा) के रूप में उपयोग करता है अलग KDF (\u0026ldquo;AttachPayloadKDF\u0026rdquo;) domain separation (डोमेन पृथक्करण) प्रदान करता है ES तत्परता:\nNSR के बाद, दोनों पक्ष ES संदेश भेज सकते हैं Alice को ES भेजने से पहले NSR प्राप्त करना होगा Bob को ES भेजने से पहले ES प्राप्त करना होगा ES संदेश KDFs (Key Derivation Functions, कुंजी व्युत्पत्ति फ़ंक्शन) ES संदेश टैगसेट्स से पूर्व-उत्पन्न सत्र कुंजियों का उपयोग करते हैं:\n# Sender gets next tag and key tagsetEntry = outbound_tagset.GET_NEXT_ENTRY() tag = tagsetEntry.SESSION_TAG # 8 bytes k = tagsetEntry.SESSION_KEY # 32 bytes N = tagsetEntry.INDEX # Message number # Construct nonce (12 bytes) nonce = [0x00, 0x00, 0x00, 0x00] + little_endian_8_bytes(N) # AEAD encryption associated_data = tag # Tag is associated data payload = build_payload() ciphertext = ENCRYPT(k, nonce, payload, associated_data) # Send: tag || ciphertext (8 + len(ciphertext) bytes) प्राप्तकर्ता प्रक्रिया:\n# Extract tag tag = message[0:8] # Look up tag in inbound tagsets tagsetEntry = inbound_tagset.GET_SESSION_KEY(tag) if tagsetEntry is None: # Not an ES message, try NS/NSR decryption return try_handshake_decryption(message) k = tagsetEntry.SESSION_KEY N = tagsetEntry.INDEX # Construct nonce nonce = [0x00, 0x00, 0x00, 0x00] + little_endian_8_bytes(N) # AEAD decryption associated_data = tag ciphertext = message[8:] try: payload = DECRYPT(k, nonce, ciphertext, associated_data) except AuthenticationError: # MAC verification failed, reject message return reject_message() # Process payload blocks process_payload(payload) # Remove tag from tagset (one-time use) inbound_tagset.remove(tag) DH_INITIALIZE फ़ंक्शन एक दिशा के लिए एक tagset (टैग्स का समूह) बनाता है:\ndef DH_INITIALIZE(rootKey, k): \u0026#34;\u0026#34;\u0026#34; Initializes a tagset with session tag and symmetric key ratchets. Args: rootKey: Chain key from previous DH ratchet (32 bytes) k: Key material from split() or DH ratchet (32 bytes) Returns: tagset: Initialized tagset object \u0026#34;\u0026#34;\u0026#34; # Derive next root key and chain key keydata = HKDF(rootKey, k, \u0026#34;KDFDHRatchetStep\u0026#34;, 64) nextRootKey = keydata[0:31] chainKey_tagset = keydata[32:63] # Derive separate chain keys for tags and keys keydata = HKDF(chainKey_tagset, ZEROLEN, \u0026#34;TagAndKeyGenKeys\u0026#34;, 64) sessTag_ck = keydata[0:31] # Session tag chain key symmKey_ck = keydata[32:63] # Symmetric key chain key # Create tagset object tagset = Tagset() tagset.nextRootKey = nextRootKey tagset.sessTag_chainKey = sessTag_ck tagset.symmKey_chainKey = symmKey_ck tagset.lastIndex = -1 return tagset उपयोग संदर्भ:\nNSR Tagset (NSR टैगसेट): DH_INITIALIZE(chainKey_from_NS, tagsetKey_NSR) ES Tagsets (ES टैगसेट्स): DH_INITIALIZE(chainKey_from_NSR, k_ab or k_ba) Ratcheted Tagsets (रैचेटेड टैगसेट्स): DH_INITIALIZE(nextRootKey_from_previous, tagsetKey_from_DH) रैचेट (क्रिप्टोग्राफ़िक कुंजी अद्यतन तंत्र) यंत्रणाएँ ECIES (Elliptic Curve Integrated Encryption Scheme—एलिप्टिक कर्व आधारित एकीकृत एन्क्रिप्शन योजना) forward secrecy और कुशल सत्र प्रबंधन प्रदान करने के लिए तीन समकालिक ratchet तंत्रों का उपयोग करता है।\nRatchet (क्रिप्टोग्राफी में क्रमिक कुंजी-अद्यतन तंत्र) का अवलोकन तीन Ratchet (कुंजी-अग्रसारण तंत्र) प्रकार:\nDH Ratchet (क्रमिक कुंजी-अपडेट तंत्र): नई रूट कुंजियाँ उत्पन्न करने के लिए Diffie-Hellman कुंजी विनिमय करता है Session Tag Ratchet (Session tags: अस्थायी, एक-बार-उपयोग पहचान टैग): नियतात्मक रूप से एक-बार-उपयोग session tags व्युत्पन्न करता है Symmetric Key Ratchet: संदेश एन्क्रिप्शन के लिए सत्र कुंजियाँ व्युत्पन्न करता है संबंध:\nDH Ratchet (periodic) ↓ Creates new tagset ↓ Session Tag Ratchet (per message) ← synchronized → Symmetric Key Ratchet (per message) ↓ ↓ Session Tags (8 bytes each) Session Keys (32 bytes each) मुख्य गुणधर्म:\nप्रेषक: आवश्यकतानुसार टैग और कुंजियाँ बनाता है (संग्रहण की आवश्यकता नहीं) ग्राही: look-ahead window (अग्र-दृष्टि विंडो) के लिए टैग पहले से बनाता है (संग्रहण आवश्यक) समकालिकता: टैग सूचकांक कुंजी सूचकांक निर्धारित करता है (N_tag = N_key) फॉरवर्ड सीक्रेसी: आवधिक DH ratchet (Diffie-Hellman आधारित रैचेट तंत्र) के माध्यम से प्राप्त दक्षता: ग्राही टैग प्राप्त होने तक कुंजी गणना स्थगित कर सकता है DH Ratchet (डिफी-हेल्मन रैचेट, संदेश-दर-संदेश कुंजी बदलने वाला तंत्र) DH ratchet (Diffie-Hellman आधारित क्रमिक कुंजी-अपडेट तंत्र) समय-समय पर नई अल्पकालिक कुंजियों का आदान-प्रदान करके फॉरवर्ड सीक्रेसी प्रदान करता है।\nDH Ratchet (Diffie-Hellman आधारित क्रमिक कुंजी-अद्यतन तंत्र) की आवृत्ति आवश्यक Ratchet (क्रमिक कुंजी-अपडेट तंत्र) शर्तें: - टैग सेट समाप्ति के करीब (टैग 65535 अधिकतम है) - कार्यान्वयन-विशिष्ट नीतियाँ: - संदेशों की संख्या की सीमा (उदा., हर 4096 संदेशों पर) - समय सीमा (उदा., हर 10 मिनट में) - डेटा मात्रा सीमा (उदा., हर 100 MB पर)\nअनुशंसित पहला Ratchet (क्रिप्टोग्राफ़िक रैचेट तंत्र): सीमा तक पहुँचने से बचने के लिए टैग नंबर 4096 के आसपास\nअधिकतम मान: - अधिकतम tag set (टैग का समूह) ID: 65535 - अधिकतम कुंजी ID: 32767 - प्रति tag set अधिकतम संदेश: 65535 - प्रति सत्र सैद्धांतिक अधिकतम डेटा: ~6.9 TB (64K tag sets × 64K messages × 1730 बाइट औसत)\nDH Ratchet (Diffie-Hellman आधारित कुंजी-घुमाव तंत्र) के टैग और कुंजी पहचानकर्ता प्रारंभिक टैग सेट (हैंडशेक के बाद): - टैग सेट ID: 0 - अभी तक कोई NextKey (अगली कुंजी) ब्लॉक नहीं भेजे गए हैं - कोई कुंजी ID आवंटित नहीं की गई है\nपहले Ratchet (क्रमिक-अपडेट एन्क्रिप्शन तंत्र) के बाद: - टैग सेट आईडी: 1 = (1 + एलिस की कुंजी आईडी + बॉब की कुंजी आईडी) = (1 + 0 + 0) - एलिस कुंजी आईडी 0 के साथ NextKey भेजती है - बॉब कुंजी आईडी 0 के साथ NextKey भेजकर उत्तर देता है\nपरवर्ती टैग सेट: - टैग सेट ID = 1 + प्रेषक की कुंजी ID + प्राप्तकर्ता की कुंजी ID - उदाहरण: टैग सेट 5 = (1 + sender_key_2 + receiver_key_2)\nटैग सेट प्रगति तालिका:\nTag Set ID Sender Key ID Receiver Key ID Notes 0 n/a n/a Initial tag set (post-NSR) 1 0 * 0 * First ratchet (both generate new keys) 2 1 * 0 Sender generates new key 3 1 1 * Receiver generates new key 4 2 * 1 Sender generates new key 5 2 2 * Receiver generates new key ... ... ... Pattern repeats 65534 32767 * 32766 Second-to-last tag set 65535 32767 32767 * Final tag set \\* = इस ratchet (क्रमिक कुंजी-अग्रसारण तंत्र) में नई कुंजी उत्पन्न की गई Key ID नियम: - ID 0 से शुरू होकर क्रमिक होते हैं - ID में वृद्धि केवल तब होती है जब नई कुंजी उत्पन्न की जाती है - अधिकतम कुंजी ID 32767 (15 बिट) है - कुंजी ID 32767 के बाद नया सत्र आवश्यक है\nDH Ratchet (डिफी-हेलमैन रैचेट) संदेश प्रवाह भूमिकाएँ: - टैग प्रेषक: आउटबाउंड टैग सेट का स्वामी होता है, संदेश भेजता है - टैग प्राप्तकर्ता: इनबाउंड टैग सेट का स्वामी होता है, संदेश प्राप्त करता है\nपैटर्न: टैग प्रेषक ratchet (क्रिप्टोग्राफ़िक आगे-खिसकने वाली कुंजी-अद्यतन प्रक्रिया) तब आरंभ करता है जब टैग सेट लगभग समाप्त हो जाता है।\nसंदेश प्रवाह आरेख:\nTag Sender Tag Receiver ... using tag set #0 ... (Tag set #0 approaching exhaustion) (Generate new key #0) NextKey forward, request reverse, with key #0 --------\u0026gt; (Repeat until NextKey ACK received) (Generate new key #0) (Perform DH: sender_key_0 × receiver_key_0) (Create inbound tag set #1) \u0026lt;--------------- NextKey reverse, with key #0 (Repeat until tag from tag set #1 received) (Receive NextKey with key #0) (Perform DH: sender_key_0 × receiver_key_0) (Create outbound tag set #1) ... using tag set #1 ... (Tag set #1 approaching exhaustion) (Generate new key #1) NextKey forward, with key #1 --------\u0026gt; (Repeat until NextKey ACK received) (Reuse existing key #0) (Perform DH: sender_key_1 × receiver_key_0) (Create inbound tag set #2) \u0026lt;-------------- NextKey reverse, id 0 (ACK) (Repeat until tag from tag set #2 received) (Receive NextKey with id 0) (Perform DH: sender_key_1 × receiver_key_0) (Create outbound tag set #2) ... using tag set #2 ... (Tag set #2 approaching exhaustion) (Reuse existing key #1) NextKey forward, request reverse, id 1 --------\u0026gt; (Repeat until NextKey received) (Generate new key #1) (Perform DH: sender_key_1 × receiver_key_1) (Create inbound tag set #3) \u0026lt;-------------- NextKey reverse, with key #1 (Receive NextKey with key #1) (Perform DH: sender_key_1 × receiver_key_1) (Create outbound tag set #3) ... using tag set #3 ... (Pattern repeats: even-numbered tag sets use forward key, odd-numbered use reverse key) रैचेट पैटर्न:\nसम-संख्या वाले टैग सेट बनाना (2, 4, 6, \u0026hellip;): 1. प्रेषक नई कुंजी उत्पन्न करता है 2. प्रेषक नई कुंजी के साथ NextKey ब्लॉक भेजता है 3. प्राप्तकर्ता पुरानी कुंजी ID के साथ NextKey ब्लॉक भेजता है (ACK) 4. दोनों (नई प्रेषक कुंजी × पुरानी प्राप्तकर्ता कुंजी) के साथ DH (Diffie-Hellman कुंजी-विनिमय) करते हैं\nविषम-संख्या वाले Tag Sets (टैग सेट) का निर्माण (3, 5, 7, \u0026hellip;): 1. प्रेषक रिवर्स कुंजी का अनुरोध करता है (अनुरोध फ़्लैग के साथ NextKey भेजता है) 2. प्राप्तकर्ता नई कुंजी उत्पन्न करता है 3. प्राप्तकर्ता नई कुंजी के साथ NextKey ब्लॉक भेजता है 4. दोनों (प्रेषक की पुरानी कुंजी × प्राप्तकर्ता की नई कुंजी) के साथ DH (Diffie-Hellman कुंजी-विनिमय) करते हैं\nNextKey ब्लॉक प्रारूप विस्तृत NextKey ब्लॉक विनिर्देश के लिए Payload Format अनुभाग देखें।\nमुख्य तत्व: - फ्लैग्स बाइट: - बिट 0: कुंजी मौजूद (1) या केवल ID (0) - बिट 1: रिवर्स कुंजी (1) या फॉरवर्ड कुंजी (0) - बिट 2: रिवर्स कुंजी का अनुरोध (1) या कोई अनुरोध नहीं (0) - कुंजी ID: 2 बाइट, big-endian (सबसे-महत्त्वपूर्ण-बाइट-प्रथम क्रम) (0-32767) - सार्वजनिक कुंजी: 32 बाइट X25519 (यदि बिट 0 = 1)\nNextKey Blocks (NextKey ब्लॉक्स) के उदाहरण:\n# Sender initiates ratchet with new key (key ID 0, tag set 1) NextKey(flags=0x01, key_id=0, pubkey=sender_key_0) # Receiver replies with new key (key ID 0, tag set 1) NextKey(flags=0x03, key_id=0, pubkey=receiver_key_0) # Sender ratchets again with new key (key ID 1, tag set 2) NextKey(flags=0x01, key_id=1, pubkey=sender_key_1) # Receiver ACKs with old key ID (tag set 2) NextKey(flags=0x02, key_id=0) # Sender requests reverse key (tag set 3) NextKey(flags=0x04, key_id=1) # Receiver sends new reverse key (key ID 1, tag set 3) NextKey(flags=0x03, key_id=1, pubkey=receiver_key_1) DH Ratchet KDF (DH रैचेट आधारित कुंजी व्युत्पन्न फ़ंक्शन) जब नई कुंजियों का आदान-प्रदान होता है:\n# Tag sender generates or reuses key if generating_new: sender_sk = GENERATE_PRIVATE() sender_pk = DERIVE_PUBLIC(sender_sk) else: # Reuse existing key pair sender_pk = existing_sender_pk # Tag receiver generates or reuses key if generating_new: receiver_sk = GENERATE_PRIVATE() receiver_pk = DERIVE_PUBLIC(receiver_sk) else: # Reuse existing key pair receiver_pk = existing_receiver_pk # Both parties perform DH sharedSecret = DH(sender_sk, receiver_pk) # Derive tagset key tagsetKey = HKDF(sharedSecret, ZEROLEN, \u0026#34;XDHRatchetTagSet\u0026#34;, 32) # Get next root key from previous tagset rootKey = previous_tagset.nextRootKey # Initialize new tagset new_tagset = DH_INITIALIZE(rootKey, tagsetKey) # Tag sender: outbound tagset # Tag receiver: inbound tagset महत्त्वपूर्ण समय-निर्धारण:\nटैग प्रेषक: - तुरंत नया आउटबाउंड टैग सेट बनाता है - तुरंत नए टैग का उपयोग शुरू करता है - पुराना आउटबाउंड टैग सेट हटाता है\nटैग रिसीवर: - नया इनबाउंड टैग सेट बनाता है - grace period (अनुग्रह अवधि) (3 मिनट) के लिए पुराने इनबाउंड टैग सेट को बनाए रखता है - grace period के दौरान पुराने और नए दोनों टैग सेट से टैग स्वीकार करता है - grace period के बाद पुराने इनबाउंड टैग सेट को हटा देता है\nDH Ratchet (Diffie-Hellman आधारित रैचेट) की स्थिति का प्रबंधन प्रेषक की स्थिति: - वर्तमान आउटबाउंड टैग सेट - टैग सेट ID और कुंजी IDs - अगली रूट कुंजी (अगले ratchet (क्रमिक कुंजी-परिवर्तन प्रक्रिया) के लिए) - वर्तमान टैग सेट में संदेशों की संख्या\nप्राप्तकर्ता स्थिति: - वर्तमान इनबाउंड टैग सेट (अनुग्रह अवधि के दौरान 2 हो सकते हैं) - पिछले संदेशों की संख्याएँ (PN) अंतर का पता लगाने के लिए - पहले से जनित टैगों की लुक-अहेड विंडो - अगली रूट कुंजी (अगले ratchet (क्रमिक कुंजी-परिवर्तन तंत्र) के लिए)\nस्टेट ट्रांज़िशन नियम:\nप्रथम रैचेट से पहले:\nटैग सेट 0 (NSR से) का उपयोग कोई कुंजी ID आवंटित नहीं किए गए हैं Ratchet (क्रमिक कुंजी-परिवर्तन तंत्र) आरंभ करना:\nनई कुंजी उत्पन्न करें (यदि इस दौर में प्रेषक उत्पन्न कर रहा हो) ES message में NextKey block भेजें नई outbound tag set (प्रेषित दिशा में उपयोग होने वाला टैग-समूह) बनाने से पहले NextKey reply की प्रतीक्षा करें Ratchet Request (क्रमिक कुंजी-परिवर्तन अनुरोध) प्राप्त करना:\nनई कुंजी उत्पन्न करें (यदि इस राउंड में रिसीवर उत्पन्न कर रहा है) प्राप्त कुंजी के साथ DH (Diffie-Hellman कुंजी आदान-प्रदान) करें नया inbound tag set (आने वाले संदेशों के लिए टैग समूह) बनाएँ NextKey (अगली-कुंजी) उत्तर भेजें अनुग्रह अवधि के लिए पुराना inbound tag set बनाए रखें Ratchet (क्रिप्टोग्राफ़िक रैचेट) का समापन:\nNextKey उत्तर प्राप्त करें डिफ़ी-हेलमैन (DH) करें नया आउटबाउंड टैग सेट बनाएं नए टैग का उपयोग शुरू करें सेशन टैग रैचेट session tag ratchet (session tags उत्पन्न करने वाला तंत्र) नियतात्मक रूप से एक-बार-उपयोग वाले 8-बाइट session tags उत्पन्न करता है।\nSession Tag Ratchet (एक प्रगतिशील कुंजी-अद्यतन तंत्र) का उद्देश्य स्पष्ट टैग प्रेषण को प्रतिस्थापित करता है (ElGamal 32-बाइट टैग भेजता था) प्राप्तकर्ता को look-ahead window (आगे की झलक के लिए विंडो) हेतु टैग पहले से उत्पन्न करने में सक्षम बनाता है प्रेषक मांग पर उत्पन्न करता है (भंडारण की आवश्यकता नहीं) सूचकांक के माध्यम से symmetric key ratchet (सममित कुंजी के क्रमिक-अपडेट तंत्र) के साथ समकालित होता है Session Tag Ratchet (क्रमिक अद्यतन तंत्र) सूत्र आरंभीकरण:\n# From DH_INITIALIZE sessTag_ck = initial_chain_key # 32 bytes # Initialize session tag ratchet keydata = HKDF(sessTag_ck, ZEROLEN, \u0026#34;STInitialization\u0026#34;, 64) sessTag_chainKey = keydata[0:31] # First chain key SESSTAG_CONSTANT = keydata[32:63] # Constant for all tags in this tagset टैग जनरेशन (टैग N के लिए):\n# Generate tag N keydata = HKDF(sessTag_chainKey_(N-1), SESSTAG_CONSTANT, \u0026#34;SessionTagKeyGen\u0026#34;, 64) sessTag_chainKey_N = keydata[0:31] # Chain key for next tag tag_N = keydata[32:39] # Session tag (8 bytes) # Chain continues for each tag # tag_0, tag_1, tag_2, ..., tag_65535 पूर्ण अनुक्रम:\n# Tag 0 keydata_0 = HKDF(sessTag_chainKey, SESSTAG_CONSTANT, \u0026#34;SessionTagKeyGen\u0026#34;, 64) sessTag_chainKey_0 = keydata_0[0:31] tag_0 = keydata_0[32:39] # Tag 1 keydata_1 = HKDF(sessTag_chainKey_0, SESSTAG_CONSTANT, \u0026#34;SessionTagKeyGen\u0026#34;, 64) sessTag_chainKey_1 = keydata_1[0:31] tag_1 = keydata_1[32:39] # Tag N keydata_N = HKDF(sessTag_chainKey_(N-1), SESSTAG_CONSTANT, \u0026#34;SessionTagKeyGen\u0026#34;, 64) sessTag_chainKey_N = keydata_N[0:31] tag_N = keydata_N[32:39] Session Tag Ratchet (क्रमिक कुंजी-अद्यतन तंत्र) प्रेषक का कार्यान्वयन class OutboundTagset: def __init__(self, sessTag_ck): # Initialize keydata = HKDF(sessTag_ck, ZEROLEN, \u0026#34;STInitialization\u0026#34;, 64) self.chainKey = keydata[0:31] self.constant = keydata[32:63] self.index = -1 def get_next_tag(self): # Increment index self.index += 1 if self.index \u0026gt; 65535: raise TagsetExhausted(\u0026#34;Ratchet required\u0026#34;) # Generate tag keydata = HKDF(self.chainKey, self.constant, \u0026#34;SessionTagKeyGen\u0026#34;, 64) self.chainKey = keydata[0:31] tag = keydata[32:39] return (tag, self.index) प्रेषक प्रक्रिया: 1. प्रत्येक संदेश के लिए get_next_tag() कॉल करें 2. ES संदेश में लौटा हुआ टैग का उपयोग करें 3. संभावित ACK (पुष्टिकरण) ट्रैकिंग के लिए इंडेक्स N सहेजें 4. टैग को संग्रहीत करने की आवश्यकता नहीं (आवश्यकतानुसार उत्पन्न किया जाता है)\nSession Tag Ratchet (सेशन टैग के लिए कुंजी आगे बढ़ाने वाला तंत्र) रिसीवर कार्यान्वयन class InboundTagset: def __init__(self, sessTag_ck, look_ahead=32): # Initialize keydata = HKDF(sessTag_ck, ZEROLEN, \u0026#34;STInitialization\u0026#34;, 64) self.chainKey = keydata[0:31] self.constant = keydata[32:63] self.index = -1 self.look_ahead = look_ahead self.tags = {} # Dictionary: tag -\u0026gt; index # Pre-generate initial tags self.extend(look_ahead) def extend(self, count): \u0026#34;\u0026#34;\u0026#34;Generate \u0026#39;count\u0026#39; more tags\u0026#34;\u0026#34;\u0026#34; for _ in range(count): self.index += 1 if self.index \u0026gt; 65535: return # Cannot exceed maximum # Generate tag keydata = HKDF(self.chainKey, self.constant, \u0026#34;SessionTagKeyGen\u0026#34;, 64) self.chainKey = keydata[0:31] tag = keydata[32:39] # Store tag self.tags[tag] = self.index def lookup_tag(self, tag): \u0026#34;\u0026#34;\u0026#34;Look up tag and return index\u0026#34;\u0026#34;\u0026#34; if tag in self.tags: index = self.tags[tag] # Remove tag (one-time use) del self.tags[tag] return index return None def check_and_extend(self): \u0026#34;\u0026#34;\u0026#34;Extend if tag count is low\u0026#34;\u0026#34;\u0026#34; current_count = len(self.tags) if current_count \u0026lt; self.look_ahead // 2: # Extend to restore window self.extend(self.look_ahead - current_count) रिसीवर प्रक्रिया: 1. लुक-अहेड विंडो के लिए पहले से टैग जनरेट करें (उदा., 32 टैग) 2. टैग को हैश टेबल या डिक्शनरी में संग्रहीत करें 3. जब संदेश आए, तो टैग ढूंढकर इंडेक्स N प्राप्त करें 4. स्टोरेज से टैग हटाएँ (एक बार उपयोग) 5. यदि टैग की संख्या सीमा से नीचे गिर जाए, तो विंडो का विस्तार करें\nSession Tag (सेशन टैग) लुक-अहेड रणनीति उद्देश्य: मेमोरी उपयोग और out-of-order message handling (संदेशों को आगमन-क्रम से हटकर संसाधित करना) के बीच संतुलन\nअनुशंसित Look-Ahead (पूर्व-दृष्टि) आकार:\nTagset Type Initial Size Maximum Size Notes NSR tagset 12 12 Short-lived ES tagset 0 24 160 Initial ES tagset ES tagset 1+ 160 160 Ratcheted tagsets **अनुकूली लुक-अहेड:** # Dynamic look-ahead based on highest tag received look_ahead = min(tsmax, tsmin + N // 4) # Example: # tsmin = 24, tsmax = 160 # N = 0: look_ahead = min(160, 24 + 0/4) = 24 # N = 100: look_ahead = min(160, 24 + 100/4) = 49 # N = 500: look_ahead = min(160, 24 + 500/4) = 149 # N = 544: look_ahead = min(160, 24 + 544/4) = 160 पीछे से ट्रिम:\n# Trim tags far behind highest received trim_behind = look_ahead // 2 # If highest received tag is N=100, trim tags below N=50 मेमोरी गणना:\n# Per tag: 8 bytes (tag) + 2 bytes (index) + overhead ≈ 16 bytes # Look-ahead of 160 tags ≈ 2.5 KB per inbound tagset # With multiple sessions: # 100 inbound sessions × 2.5 KB = 250 KB total सेशन टैग की आउट-ऑफ-ऑर्डर (क्रम से बाहर) हैंडलिंग परिदृश्य: संदेश क्रम से बाहर पहुँचते हैं\nExpected: tag_5, tag_6, tag_7, tag_8 Received: tag_5, tag_7, tag_6, tag_8 प्राप्तकर्ता का व्यवहार:\ntag_5 प्राप्त करें:\nखोजें: इंडेक्स 5 पर मिला संदेश संसाधित करें tag_5 हटाएँ अधिकतम प्राप्त: 5 tag_7 प्राप्त करें (क्रम से बाहर):\nखोजें: index 7 पर मिला संदेश संसाधित करें tag_7 हटाएँ उच्चतम प्राप्त: 7 नोट: tag_6 अभी भी भंडारण में है (अभी तक प्राप्त नहीं हुआ) tag_6 प्राप्त करें (विलंबित):\nखोजें: सूचकांक 6 पर मिला संदेश संसाधित करें tag_6 हटाएँ अब तक प्राप्त उच्चतम: 7 (अपरिवर्तित) tag_8 प्राप्त करें:\nखोजें: इंडेक्स 8 पर मिला संदेश संसाधित करें tag_8 हटाएँ सर्वाधिक प्राप्त: 8 विंडो रखरखाव: - उच्चतम प्राप्त इंडेक्स का ट्रैक रखें - लापता इंडेक्स (अंतराल) की सूची बनाए रखें - उच्चतम इंडेक्स के आधार पर विंडो का विस्तार करें - वैकल्पिक: टाइमआउट के बाद पुराने अंतरालों को समाप्त करें\nसममित कुंजी रैचेट symmetric key ratchet (कुंजियों को क्रमिक रूप से अद्यतन करने की प्रक्रिया) 32-byte की एन्क्रिप्शन कुंजियाँ उत्पन्न करती है, जो session tags के साथ समकालित होती हैं।\nSymmetric Key Ratchet (क्रमिक कुंजी-परिवर्तन तंत्र) का उद्देश्य प्रत्येक संदेश के लिए एक विशिष्ट एन्क्रिप्शन कुंजी प्रदान करता है Session tag ratchet (कुंजी-क्रम आगे बढ़ाने का तंत्र) के साथ समकालित (वही सूचकांक) प्रेषक आवश्यकतानुसार उत्पन्न कर सकता है प्राप्तकर्ता टैग प्राप्त होने तक उत्पन्न करना स्थगित कर सकता है सममित कुंजी Ratchet (क्रमिक कुंजी-अद्यतन तंत्र) का सूत्र आरंभिकरण:\n# From DH_INITIALIZE symmKey_ck = initial_chain_key # 32 bytes # No additional initialization needed # Unlike session tag ratchet, no constant is derived कुंजी निर्माण (कुंजी N के लिए):\n# Generate key N SYMMKEY_CONSTANT = ZEROLEN # Empty string keydata = HKDF(symmKey_chainKey_(N-1), SYMMKEY_CONSTANT, \u0026#34;SymmetricRatchet\u0026#34;, 64) symmKey_chainKey_N = keydata[0:31] # Chain key for next key key_N = keydata[32:63] # Session key (32 bytes) पूर्ण अनुक्रम:\n# Key 0 keydata_0 = HKDF(symmKey_ck, ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) symmKey_chainKey_0 = keydata_0[0:31] key_0 = keydata_0[32:63] # Key 1 keydata_1 = HKDF(symmKey_chainKey_0, ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) symmKey_chainKey_1 = keydata_1[0:31] key_1 = keydata_1[32:63] # Key N keydata_N = HKDF(symmKey_chainKey_(N-1), ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) symmKey_chainKey_N = keydata_N[0:31] key_N = keydata_N[32:63] सममित कुंजी रैचेट प्रेषक कार्यान्वयन class OutboundKeyRatchet: def __init__(self, symmKey_ck): self.chainKey = symmKey_ck self.index = -1 def get_key(self, index): \u0026#34;\u0026#34;\u0026#34;Generate key for specific index\u0026#34;\u0026#34;\u0026#34; # Fast-forward to desired index if needed while self.index \u0026lt; index: self.index += 1 keydata = HKDF(self.chainKey, ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) self.chainKey = keydata[0:31] if self.index == index: return keydata[32:63] # Should not reach here if called correctly raise ValueError(\u0026#34;Key already generated\u0026#34;) प्रेषक प्रक्रिया: 1. अगला टैग और उसका सूचकांक N प्राप्त करें 2. सूचकांक N के लिए कुंजी उत्पन्न करें 3. संदेश को एन्क्रिप्ट करने के लिए कुंजी का उपयोग करें 4. कुंजी भंडारण की आवश्यकता नहीं\nसममित कुंजी Ratchet (क्रमिक कुंजी-परिवर्तन तंत्र) प्राप्तकर्ता का कार्यान्वयन रणनीति 1: Deferred Generation (स्थगित सृजन) (अनुशंसित)\nclass InboundKeyRatchet: def __init__(self, symmKey_ck): self.chainKey = symmKey_ck self.index = -1 self.cache = {} # Optional: cache recently used keys def get_key(self, index): \u0026#34;\u0026#34;\u0026#34;Generate key for specific index\u0026#34;\u0026#34;\u0026#34; # Check cache first (optional optimization) if index in self.cache: key = self.cache[index] del self.cache[index] return key # Fast-forward to desired index while self.index \u0026lt; index: self.index += 1 keydata = HKDF(self.chainKey, ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) self.chainKey = keydata[0:31] if self.index == index: return keydata[32:63] raise ValueError(\u0026#34;Index already passed\u0026#34;) विलंबित जनरेशन प्रक्रिया: 1. टैग के साथ ES संदेश प्राप्त करें 2. सूचकांक N प्राप्त करने के लिए टैग का लुकअप करें 3. कुंजियाँ 0 से N तक उत्पन्न करें (यदि पहले से उत्पन्न न हों) 4. संदेश को डिक्रिप्ट करने के लिए कुंजी N का उपयोग करें 5. अब श्रृंखला कुंजी सूचकांक N पर स्थित है\nलाभ: - मेमोरी का न्यूनतम उपयोग - कुंजियाँ केवल आवश्यकता होने पर ही बनाई जाती हैं - सरल कार्यान्वयन\nकमियाँ: - पहली बार उपयोग पर 0 से N तक सभी कुंजियाँ उत्पन्न करनी होंगी - कैशिंग के बिना क्रम से बाहर (out-of-order) संदेशों को संभाल नहीं सकता\nरणनीति 2: टैग विंडो के साथ पूर्व-सृजन (वैकल्पिक)\nclass InboundKeyRatchet: def __init__(self, symmKey_ck): self.chainKey = symmKey_ck self.index = -1 self.keys = {} # Dictionary: index -\u0026gt; key def extend(self, count): \u0026#34;\u0026#34;\u0026#34;Pre-generate \u0026#39;count\u0026#39; more keys\u0026#34;\u0026#34;\u0026#34; for _ in range(count): self.index += 1 keydata = HKDF(self.chainKey, ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) self.chainKey = keydata[0:31] key = keydata[32:63] self.keys[self.index] = key def get_key(self, index): \u0026#34;\u0026#34;\u0026#34;Retrieve pre-generated key\u0026#34;\u0026#34;\u0026#34; if index in self.keys: key = self.keys[index] del self.keys[index] return key return None पूर्व-सृजन प्रक्रिया: 1. टैग विंडो से मेल खाने वाली कुंजियाँ पहले से उत्पन्न करें (उदा., 32 कुंजियाँ) 2. संदेश संख्या के आधार पर इंडेक्स की गई कुंजियाँ संग्रहीत करें 3. जब टैग प्राप्त हो, तो संबंधित कुंजी ढूँढें 4. टैग उपयोग होने पर विंडो का विस्तार करें\nफायदे: - क्रम से बाहर आने वाले संदेशों को स्वाभाविक रूप से संभालता है - तेज़ कुंजी प्राप्ति (सृजन में कोई देरी नहीं)\nकमियां: - अधिक मेमोरी उपयोग (प्रति कुंजी 32 बाइट्स बनाम प्रति टैग 8 बाइट्स) - कुंजियों को टैगों के साथ समकालित रखना आवश्यक है\nमेमोरी तुलना:\n# Look-ahead of 160: # Tags only: 160 × 16 bytes = 2.5 KB # Tags+Keys: 160 × (16 + 32) bytes = 7.5 KB # # For 100 sessions: # Tags only: 250 KB # Tags+Keys: 750 KB Session Tags (सत्र टैग्स) के साथ सममित रैचेट का समकालन महत्वपूर्ण आवश्यकता: सेशन टैग का इंडेक्स सममित कुंजी के इंडेक्स के बराबर होना अनिवार्य है\n# Sender tag, index = outbound_tagset.get_next_tag() key = outbound_keyratchet.get_key(index) # Same index nonce = construct_nonce(index) ciphertext = ENCRYPT(key, nonce, payload, tag) # Receiver index = inbound_tagset.lookup_tag(tag) key = inbound_keyratchet.get_key(index) # Same index nonce = construct_nonce(index) plaintext = DECRYPT(key, nonce, ciphertext, tag) विफलता के प्रकार:\nयदि समकालन टूट जाए: - decryption (डिक्रिप्शन) के लिए गलत कुंजी का उपयोग - MAC verification (मैसेज ऑथेंटिकेशन कोड सत्यापन) विफल - संदेश अस्वीकार कर दिया गया\nनिवारण: - टैग और कुंजी के लिए हमेशा एक ही सूचकांक का उपयोग करें - किसी भी ratchet (क्रमिक-परिवर्तन तंत्र) में सूचकांकों को कभी न छोड़ें - क्रम से बाहर आए संदेशों को सावधानीपूर्वक संभालें\nसममित Ratchet (कुंजी-अद्यतन तंत्र) Nonce (एक बार प्रयुक्त होने वाला यादृच्छिक मान) निर्माण Nonce (cryptography में एक बार उपयोग होने वाली संख्या) संदेश संख्या से व्युत्पन्न किया जाता है:\ndef construct_nonce(index): \u0026#34;\u0026#34;\u0026#34; Construct 12-byte nonce for ChaCha20-Poly1305 Args: index: Message number (0-65535) Returns: nonce: 12-byte nonce \u0026#34;\u0026#34;\u0026#34; # First 4 bytes are always zero nonce = bytearray(12) nonce[0:4] = b\u0026#39;\\x00\\x00\\x00\\x00\u0026#39; # Last 8 bytes are little-endian message number nonce[4:12] = index.to_bytes(8, byteorder=\u0026#39;little\u0026#39;) return bytes(nonce) उदाहरण:\nindex = 0: nonce = 0x00000000 0000000000000000 index = 1: nonce = 0x00000000 0100000000000000 index = 255: nonce = 0x00000000 FF00000000000000 index = 256: nonce = 0x00000000 0001000000000000 index = 65535: nonce = 0x00000000 FFFF000000000000 महत्वपूर्ण गुण: - Nonce (एकबारगी प्रयुक्त मान) किसी tagset (टैग का समूह) में प्रत्येक संदेश के लिए अद्वितीय होते हैं - Nonce कभी दोहराए नहीं जाते (एक-बार-उपयोग टैग यह सुनिश्चित करते हैं) - 8-बाइट काउंटर 2^64 संदेशों की अनुमति देता है (हम केवल 2^16 का उपयोग करते हैं) - Nonce का फ़ॉर्मेट RFC 7539 की काउंटर-आधारित संरचना से मेल खाता है\nसत्र प्रबंधन सत्र संदर्भ सभी इनबाउंड और आउटबाउंड सत्र किसी विशिष्ट संदर्भ से संबंधित होने चाहिए:\nRouter Context: router के स्वयं उपयोग के लिए सत्र Destination Context: किसी विशिष्ट स्थानीय Destination (क्लाइंट एप्लिकेशन) के लिए सत्र महत्वपूर्ण नियम: कोरिलेशन हमलों को रोकने के लिए संदर्भों के बीच सेशनों को कभी भी साझा नहीं किया जाना चाहिए।\nकार्यान्वयन:\nclass SessionKeyManager: \u0026#34;\u0026#34;\u0026#34;Context for managing sessions (router or destination)\u0026#34;\u0026#34;\u0026#34; def __init__(self, context_id): self.context_id = context_id self.inbound_sessions = {} # far_end_dest -\u0026gt; [sessions] self.outbound_sessions = {} # far_end_dest -\u0026gt; session self.static_keypair = generate_keypair() # Context\u0026#39;s identity def get_outbound_session(self, destination): \u0026#34;\u0026#34;\u0026#34;Get or create outbound session to destination\u0026#34;\u0026#34;\u0026#34; if destination not in self.outbound_sessions: self.outbound_sessions[destination] = create_outbound_session(destination) return self.outbound_sessions[destination] def add_inbound_session(self, session, destination=None): \u0026#34;\u0026#34;\u0026#34;Add inbound session, optionally bound to destination\u0026#34;\u0026#34;\u0026#34; if destination: if destination not in self.inbound_sessions: self.inbound_sessions[destination] = [] self.inbound_sessions[destination].append(session) else: # Unbound session self.inbound_sessions[None].append(session) Java I2P कार्यान्वयन:\nJava I2P में, SessionKeyManager क्लास यह कार्यक्षमता प्रदान करता है: - प्रति router एक SessionKeyManager - प्रत्येक स्थानीय destination (गंतव्य) के लिए एक SessionKeyManager - प्रत्येक संदर्भ के भीतर ECIES और ElGamal सत्रों का अलग-अलग प्रबंधन\nसेशन बाइंडिंग Binding (बाइंडिंग) किसी सत्र को किसी विशिष्ट दूरस्थ गंतव्य से संबद्ध करती है।\nबंधित सत्र विशेषताएँ: - NS संदेश में प्रेषक की स्थिर कुंजी शामिल होती है - प्राप्तकर्ता प्रेषक के गंतव्य की पहचान कर सकता है - द्विदिश संचार सक्षम करता है - प्रति गंतव्य एकल आउटबाउंड सत्र - एकाधिक इनबाउंड सत्र हो सकते हैं (संक्रमण के दौरान)\nउपयोग के मामले: - स्ट्रीमिंग कनेक्शन (TCP जैसा) - उत्तर-सक्षम डेटाग्राम - कोई भी प्रोटोकॉल जिसे अनुरोध/प्रतिक्रिया की आवश्यकता हो\nबाइंडिंग प्रक्रिया:\n# Alice creates bound outbound session outbound_session = OutboundSession( destination=bob_destination, static_key=alice_static_key, bound=True ) # Alice sends NS with static key ns_message = build_ns_message( ephemeral_key=alice_ephemeral_key, static_key=alice_static_key, # Included for binding payload=data ) # Bob receives NS bob_receives_ns(ns_message) # Bob extracts Alice\u0026#39;s static key alice_static_key = decrypt_static_key_section(ns_message) # Bob looks up Alice\u0026#39;s destination (from bundled LeaseSet) alice_destination = lookup_destination_by_static_key(alice_static_key) # Bob creates bound inbound session inbound_session = InboundSession( destination=alice_destination, bound=True ) # Bob pairs with outbound session outbound_session = OutboundSession( destination=alice_destination, bound=True ) लाभ: 1. Ephemeral-Ephemeral DH (अस्थायी-कुंजियों वाला Diffie-Hellman): उत्तर ee DH का उपयोग करता है (पूर्ण फॉरवर्ड सीक्रेसी) 2. सत्र निरंतरता: Ratchets (कुंजी-अग्रसरण तंत्र) उसी गंतव्य से जुड़ाव बनाए रखते हैं 3. सुरक्षा: सत्र हाइजैकिंग को रोकता है (स्थिर कुंजी द्वारा प्रमाणित) 4. दक्षता: प्रति गंतव्य एक ही सत्र (डुप्लीकेशन नहीं)\nUnbound सत्र विशेषताएँ: - NS message में कोई स्थिर कुंजी नहीं (flags अनुभाग में सभी शून्य) - प्राप्तकर्ता प्रेषक की पहचान नहीं कर सकता - केवल एक-तरफ़ा संचार - एक ही गंतव्य के लिए एकाधिक सत्रों की अनुमति है\nउपयोग के मामले: - रॉ डेटाग्राम (भेजें और भूल जाएँ) - अनाम प्रकाशन - प्रसारण-शैली संदेश भेजना\nविशेषताएँ: - अधिक गुमनाम (प्रेषक की पहचान नहीं होती) - अधिक दक्ष (हैंडशेक में 1 DH (Diffie-Hellman कुंजी-विनिमय) बनाम 2 DH) - उत्तर संभव नहीं (प्राप्तकर्ता को यह नहीं पता कि कहाँ उत्तर देना है) - session ratcheting नहीं (क्रमिक कुंजी-परिवर्तन तंत्र; एक बार या सीमित उपयोग)\nसत्र युग्मन पेयरिंग द्विदिश संचार के लिए एक इनबाउंड सत्र को एक आउटबाउंड सत्र से जोड़ती है।\nयुग्मित सत्र बनाना एलिस का दृष्टिकोण (प्रारंभकर्ता):\n# Create outbound session to Bob outbound_session = create_outbound_session(bob_destination) # Create paired inbound session inbound_session = create_inbound_session( paired_with=outbound_session, bound_to=bob_destination ) # Link them outbound_session.paired_inbound = inbound_session inbound_session.paired_outbound = outbound_session # Send NS message send_ns_message(outbound_session, payload) Bob का दृष्टिकोण (responder, उत्तरदाता):\n# Receive NS message ns_message = receive_ns_message() # Create inbound session inbound_session = create_inbound_session_from_ns(ns_message) # If NS contains static key (bound): if ns_message.has_static_key(): alice_destination = extract_destination(ns_message) inbound_session.bind_to(alice_destination) # Create paired outbound session outbound_session = create_outbound_session(alice_destination) # Link them outbound_session.paired_inbound = inbound_session inbound_session.paired_outbound = outbound_session # Send NSR send_nsr_message(inbound_session, outbound_session, payload) Session Pairing (सत्र पेयरिंग) के लाभ इन-बैंड ACKs: अलग clove (garlic संदेश का उप-भाग) के बिना संदेशों की पुष्टि की जा सकती है Efficient Ratcheting (कुंजी-अपडेट तंत्र): दोनों दिशाओं का रैचेट एक-साथ आगे बढ़ता है फ़्लो कंट्रोल: युग्मित सत्रों के पार back-pressure (उल्टा-दबाव आधारित नियंत्रण) लागू किया जा सकता है स्टेट कंसिस्टेंसी: समकालित अवस्था बनाए रखना आसान होता है सत्र युग्मन के नियम आउटबाउंड सत्र अयुग्मित हो सकता है (अबंधित NS) बंधित NS के लिए इनबाउंड सत्र युग्मित होना चाहिए युग्मन सत्र निर्माण के समय होता है, बाद में नहीं युग्मित सत्रों में समान गंतव्य बाइंडिंग होती है Ratchets (कुंजी-रोलओवर तंत्र) स्वतंत्र रूप से होते हैं, लेकिन समन्वित रहते हैं सत्र जीवनचक्र सत्र जीवनचक्र: निर्माण चरण निर्गामी सत्र निर्माण (Alice):\ndef create_outbound_session(destination, bound=True): session = OutboundSession() session.destination = destination session.bound = bound session.state = SessionState.NEW session.created_time = now() # Generate keys for NS message session.ephemeral_keypair = generate_elg2_keypair() if bound: session.static_key = context.static_keypair.public_key # Will be populated after NSR received session.outbound_tagset = None session.inbound_tagset = None return session इनबाउंड सत्र निर्माण (Bob):\ndef create_inbound_session_from_ns(ns_message): session = InboundSession() session.state = SessionState.ESTABLISHED session.created_time = now() # Extract from NS session.remote_ephemeral_key = ns_message.ephemeral_key session.remote_static_key = ns_message.static_key if session.remote_static_key: session.bound = True session.destination = lookup_destination(session.remote_static_key) else: session.bound = False session.destination = None # Generate keys for NSR session.ephemeral_keypair = generate_elg2_keypair() # Create tagsets from KDF session.inbound_tagset = create_tagset_from_nsr() session.outbound_tagset = create_tagset_from_nsr() return session सत्र जीवनचक्र: सक्रिय चरण स्थिति संक्रमण:\nNEW (outbound only) ↓ NS sent ↓ PENDING_REPLY (outbound only) ↓ NSR received ↓ ESTABLISHED ↓ ES messages exchanged ↓ ESTABLISHED (ongoing) ↓ (optional) RATCHETING ↓ ESTABLISHED सक्रिय सत्र रखरखाव:\ndef maintain_active_session(session): # Update last activity time session.last_activity = now() # Check for ratchet needed if session.outbound_tagset.needs_ratchet(): initiate_ratchet(session) # Check for incoming ratchet if received_nextkey_block(): process_ratchet(session) # Trim old tags from inbound tagset session.inbound_tagset.expire_old_tags() # Check session health if session.idle_time() \u0026gt; SESSION_TIMEOUT: mark_session_idle(session) सत्र जीवनचक्र: समाप्ति चरण सत्र समय-सीमा मान:\nSession Type Sender Timeout Receiver Timeout Notes NSR tagset N/A 3 minutes Short-lived ES tagset 0 8 minutes 10 minutes Initial ES tagset 1+ 8 minutes 10 minutes Ratcheted Old tagset N/A 3 minutes After ratchet **अवधि-समाप्ति तर्क:** def check_session_expiration(): for session in active_sessions: # Outbound session expiration (sender) if session.is_outbound(): if session.idle_time() \u0026gt; 8 * 60: # 8 minutes expire_outbound_session(session) # Inbound session expiration (receiver) else: if session.idle_time() \u0026gt; 10 * 60: # 10 minutes expire_inbound_session(session) # Old tagsets (after ratchet) for tagset in old_tagsets: if tagset.age() \u0026gt; 3 * 60: # 3 minutes delete_tagset(tagset) महत्वपूर्ण नियम: समकालिकता भंग से बचाने के लिए आउटबाउंड सत्र इनबाउंड सत्रों से पहले अवश्य समाप्त होने चाहिए।\nसुचारू समापन:\ndef terminate_session(session, reason=0): # Send Termination block (if implemented) send_termination_block(session, reason) # Mark session for deletion session.state = SessionState.TERMINATED # Keep session briefly for final messages schedule_deletion(session, delay=30) # 30 seconds # Notify paired session if session.paired_session: session.paired_session.mark_remote_terminated() कई NS संदेश परिदृश्य: ऐलिस का NS संदेश (एक संदेश प्रकार) खो जाता है या NSR उत्तर (एक संदेश प्रकार) खो जाता है।\nऐलिस का व्यवहार:\nclass OutboundSession: def __init__(self): self.ns_messages_sent = [] self.ns_timer = None self.max_ns_attempts = 5 def send_ns_message(self, payload): # Generate new ephemeral key for each NS ephemeral_key = generate_elg2_keypair() ns_message = build_ns_message( ephemeral_key=ephemeral_key, static_key=self.static_key, payload=payload ) # Store state for this NS ns_state = { \u0026#39;ephemeral_key\u0026#39;: ephemeral_key, \u0026#39;chainkey\u0026#39;: compute_chainkey(ns_message), \u0026#39;hash\u0026#39;: compute_hash(ns_message), \u0026#39;tagset\u0026#39;: derive_nsr_tagset(ns_message), \u0026#39;sent_time\u0026#39;: now() } self.ns_messages_sent.append(ns_state) # Send message send_message(ns_message) # Set timer for retry if not self.ns_timer: self.ns_timer = set_timer(1.0, self.on_ns_timeout) def on_ns_timeout(self): if len(self.ns_messages_sent) \u0026gt;= self.max_ns_attempts: # Give up fail_session(\u0026#34;No NSR received after {self.max_ns_attempts} attempts\u0026#34;) return # Retry with new NS message send_ns_message(self.payload) def on_nsr_received(self, nsr_message): # Cancel timer cancel_timer(self.ns_timer) # Find which NS this NSR responds to tag = nsr_message.tag for ns_state in self.ns_messages_sent: if tag in ns_state[\u0026#39;tagset\u0026#39;]: # This NSR corresponds to this NS self.active_ns_state = ns_state break # Process NSR and complete handshake complete_handshake(nsr_message, self.active_ns_state) # Discard other NS states self.ns_messages_sent = [] महत्वपूर्ण गुण:\nअद्वितीय अस्थायी कुंजियाँ: प्रत्येक NS एक भिन्न अस्थायी कुंजी का उपयोग करता है स्वतंत्र हैंडशेक्स: प्रत्येक NS अलग हैंडशेक स्टेट बनाता है NSR सहसंबंध: NSR टैग यह पहचानता है कि वह किस NS को उत्तर देता है स्टेट क्लीनअप: अप्रयुक्त NS स्टेट्स सफल NSR के बाद हटा दिए जाते हैं हमलों की रोकथाम:\nसंसाधन समाप्ति को रोकने के लिए:\n# Limit NS sending rate max_ns_rate = 5 per 10 seconds per destination # Limit total NS attempts max_ns_attempts = 5 # Limit total pending NS states max_pending_ns = 10 per context कई NSR संदेश परिदृश्य: बॉब कई NSR भेजता है (उदाहरण के लिए, उत्तर डेटा कई संदेशों में विभाजित)।\nBob का व्यवहार:\nclass InboundSession: def send_nsr_replies(self, payload_chunks): # One NS received, multiple NSRs to send for chunk in payload_chunks: # Generate new ephemeral key for each NSR ephemeral_key = generate_elg2_keypair() # Get next tag from NSR tagset tag = self.nsr_tagset.get_next_tag() nsr_message = build_nsr_message( tag=tag, ephemeral_key=ephemeral_key, payload=chunk ) send_message(nsr_message) # Wait for ES message from Alice self.state = SessionState.AWAITING_ES एलिस का व्यवहार:\nclass OutboundSession: def on_nsr_received(self, nsr_message): if self.state == SessionState.PENDING_REPLY: # First NSR received complete_handshake(nsr_message) self.state = SessionState.ESTABLISHED # Create ES sessions self.es_outbound_tagset = derive_es_outbound_tagset() self.es_inbound_tagset = derive_es_inbound_tagset() # Send ES message (ACK) send_es_message(empty_payload) elif self.state == SessionState.ESTABLISHED: # Additional NSR received # Decrypt and process payload payload = decrypt_nsr_payload(nsr_message) process_payload(payload) # These NSRs are from other NS attempts, ignore handshake Bob की सफाई:\nclass InboundSession: def on_es_received(self, es_message): # First ES received from Alice # This confirms which NSR Alice used # Clean up other handshake states for other_ns_state in self.pending_ns_states: if other_ns_state != self.active_ns_state: delete_ns_state(other_ns_state) # Delete unused NSR tagsets for tagset in self.nsr_tagsets: if tagset != self.active_nsr_tagset: delete_tagset(tagset) self.state = SessionState.ESTABLISHED महत्वपूर्ण गुणधर्म:\nएकाधिक NSR अनुमत हैं: बॉब प्रति NS कई NSR भेज सकता है अलग-अलग अस्थायी कुंजियाँ (ephemeral keys): प्रत्येक NSR को एक अद्वितीय अस्थायी कुंजी का उपयोग करना चाहिए एक ही NSR tagset: एक NS के लिए सभी NSR एक ही tagset (टैगों का समूह) का उपयोग करते हैं पहला ES प्रभावी होता है: ऐलिस का पहला ES तय करता है कि कौन-सा NSR सफल हुआ ES के बाद साफ-सफाई: ES प्राप्त होने के बाद बॉब अनुपयोगी स्टेट्स (स्थिति जानकारी) त्याग देता है सत्र स्टेट मशीन पूर्ण अवस्था आरेख:\nOutbound Session Inbound Session NEW | send NS | PENDING_REPLY -------------------- receive NS ---\u0026gt; ESTABLISHED | | receive NSR send NSR | | ESTABLISHED \u0026lt;---------- receive ES ------------- AWAITING_ES | | | ┌─────┴─────┐ | receive ES | | | | send ES receive ES | ESTABLISHED | | | | └─────┬─────┘ | ┌─────────┴─────────┐ | | | | | | send ES receive ES | | | | | | └─────────┬─────────┘ | | | └─────────────────────┴──────────────────────────┘ ACTIVE | idle timeout | EXPIRED स्थिति विवरण:\nNEW: आउटबाउंड सत्र बनाया गया, अभी तक कोई NS नहीं भेजा गया PENDING_REPLY: NS भेजा, NSR की प्रतीक्षा AWAITING_ES: NSR भेजा, Alice से पहले ES की प्रतीक्षा ESTABLISHED: हैंडशेक पूर्ण, ES भेजना/प्राप्त करना संभव है ACTIVE: ES संदेशों का सक्रिय रूप से आदान-प्रदान हो रहा है RATCHETING: DH ratchet (Diffie-Hellman आधारित क्रमिक कुंजी-परिवर्तन प्रक्रिया) जारी है (ACTIVE का उपसमुच्चय) EXPIRED: सत्र का समय समाप्त, हटाए जाने की प्रतीक्षा में TERMINATED: सत्र को स्पष्ट रूप से समाप्त किया गया पेलोड प्रारूप सभी ECIES (Elliptic Curve Integrated Encryption Scheme, दीर्घवृत्तीय वक्र एकीकृत एन्क्रिप्शन योजना) संदेशों (NS, NSR, ES) का पेलोड अनुभाग NTCP2 के समान ब्लॉक-आधारित प्रारूप का उपयोग करता है.\nब्लॉक संरचना सामान्य प्रारूप:\n+----+----+----+----+----+----+----+----+ |blk | size | data | +----+----+----+ + | | ~ ... ~ | | +----+----+----+----+----+----+----+----+ |blk | size | data | +----+----+----+ + | | ~ ... ~ | | +----+----+----+----+----+----+----+----+ फ़ील्ड्स:\nblk: 1 बाइट - ब्लॉक प्रकार संख्या size: 2 बाइट - Big-endian (बाइट क्रम जिसमें सबसे महत्वपूर्ण बाइट पहले आती है) डेटा फ़ील्ड का आकार (0-65516) data: परिवर्तनीय लंबाई - ब्लॉक-विशिष्ट डेटा सीमाएँ:\nअधिकतम ChaChaPoly (एन्क्रिप्शन स्कीम) फ्रेम: 65535 बाइट्स Poly1305 MAC (संदेश प्रमाणीकरण कोड): 16 बाइट्स अधिकतम कुल ब्लॉक: 65519 बाइट्स (65535 - 16) अधिकतम एकल ब्लॉक: 65519 बाइट्स (3-बाइट हेडर सहित) अधिकतम एकल ब्लॉक डेटा: 65516 बाइट्स ब्लॉक प्रकार परिभाषित ब्लॉक प्रकार:\nType Name Size Status Usage 0 DateTime 7 bytes Implemented Required in NS 1-3 Reserved - - Future use 4 Termination 9+ bytes Unimplemented Session termination 5 Options 21+ bytes Unimplemented Session options 6 MessageNumbers 5 bytes Unimplemented PN value 7 NextKey 3 or 35 bytes Implemented DH ratchet 8 ACK 4+ bytes Implemented Message acknowledgment 9 ACK Request 3 bytes Implemented Request ACK 10 Reserved - - Future use 11 Garlic Clove Variable Implemented Application data 12-223 Reserved - - Future use 224-253 Experimental Variable - Testing features 254 Padding Variable Implemented Traffic shaping 255 Reserved - - Future extension **अज्ञात ब्लॉक हैंडलिंग:** कार्यान्वयन के लिए अज्ञात प्रकार संख्या वाले ब्लॉकों को अनदेखा करना और उन्हें padding (भराव) के रूप में मानना अनिवार्य है। यह आगे की संगतता सुनिश्चित करता है।\nब्लॉक क्रम निर्धारण नियम NS संदेश क्रम आवश्यक: - DateTime block (दिनांक-समय ब्लॉक) सबसे पहले होना अनिवार्य है\nअनुमेय: - Garlic Clove (garlic encryption में संदेश का उप-घटक) (type 11) - विकल्प (type 5) - यदि कार्यान्वित हो - पैडिंग (type 254)\nनिषिद्ध: - NextKey, ACK, ACK Request, Termination, MessageNumbers\nवैध NS पेलोड का उदाहरण:\nDateTime (0) | Garlic Clove (11) | Garlic Clove (11) | Padding (254) NSR संदेशों का क्रम आवश्यक: - कोई नहीं (पेलोड खाली हो सकता है)\nअनुमत: - Garlic Clove (Garlic संदेश का उप-खंड) (प्रकार 11) - विकल्प (प्रकार 5) - यदि कार्यान्वित किया गया हो - पैडिंग (प्रकार 254)\nनिषिद्ध: - DateTime, NextKey, ACK, ACK Request, Termination, MessageNumbers\nवैध NSR पेलोड का उदाहरण:\nGarlic Clove (11) | Garlic Clove (11) | Padding (254) या\n(empty - ACK only) ES संदेशों का क्रम आवश्यक: - कोई नहीं (payload (डेटा सामग्री) खाली हो सकता है)\nअनुमत (किसी भी क्रम में): - Garlic Clove (garlic संदेश का \u0026lsquo;clove\u0026rsquo; घटक) (प्रकार 11) - NextKey (प्रकार 7) - ACK (प्रकार 8) - ACK Request (प्रकार 9) - Termination (प्रकार 4) - यदि कार्यान्वित हो - MessageNumbers (प्रकार 6) - यदि कार्यान्वित हो - Options (प्रकार 5) - यदि कार्यान्वित हो - Padding (प्रकार 254)\nविशेष नियम: - Termination (समाप्ति) का ब्लॉक अंतिम ब्लॉक होना ही चाहिए (Padding (भराई) को छोड़कर) - Padding का ब्लॉक अंतिम ब्लॉक होना ही चाहिए - एक से अधिक Garlic Cloves (garlic संदेश के उप-घटक) अनुमत हैं - अधिकतम 2 NextKey (अगली कुंजी) ब्लॉक अनुमत हैं (फ़ॉरवर्ड और रिवर्स) - एक से अधिक Padding ब्लॉक अनुमत नहीं हैं\nवैध ES पेलोड के उदाहरण:\nGarlic Clove (11) | ACK (8) | Padding (254) NextKey (7) | Garlic Clove (11) | Garlic Clove (11) NextKey (7) forward | NextKey (7) reverse | Garlic Clove (11) ACK Request (9) | Garlic Clove (11) | Termination (4) | Padding (254) DateTime ब्लॉक (प्रकार 0) उद्देश्य: replay (दोहराए गए हमले) की रोकथाम और clock skew (घड़ियों के समय में अंतर) के सत्यापन के लिए टाइमस्टैम्प\nआकार: 7 बाइट (3 बाइट हेडर + 4 बाइट डेटा)\nप्रारूप:\n+----+----+----+----+----+----+----+ | 0 | 4 | timestamp | +----+----+----+----+----+----+----+ फ़ील्ड्स:\nblk: 0 size: 4 (big-endian - सबसे महत्वपूर्ण बाइट पहले) timestamp: 4 बाइट - सेकंड में Unix टाइमस्टैम्प (unsigned - बिना साइन, big-endian) टाइमस्टैम्प प्रारूप:\ntimestamp = int(time.time()) # Seconds since 1970-01-01 00:00:00 UTC # Wraps around in year 2106 (4-byte unsigned maximum) मान्यकरण नियम:\nMAX_CLOCK_SKEW_PAST = 5 * 60 # 5 minutes MAX_CLOCK_SKEW_FUTURE = 2 * 60 # 2 minutes def validate_datetime(timestamp): now = int(time.time()) age = now - timestamp if age \u0026lt; -MAX_CLOCK_SKEW_FUTURE: return False # Too far in future if age \u0026gt; MAX_CLOCK_SKEW_PAST: return False # Too old return True रीप्ले रोकथाम:\nclass ReplayFilter: def __init__(self, duration=5*60): self.duration = duration # 5 minutes self.seen_messages = BloomFilter(size=100000, false_positive_rate=0.001) self.cleanup_timer = RepeatTimer(60, self.cleanup) def check_replay(self, ephemeral_key, timestamp): # Check timestamp validity if not validate_datetime(timestamp): return False # Check if ephemeral key seen recently if ephemeral_key in self.seen_messages: return False # Replay attack # Add to seen messages self.seen_messages.add(ephemeral_key) return True def cleanup(self): # Expire old entries (Bloom filter automatically ages out) pass कार्यान्वयन संबंधी नोट्स:\nNS संदेश: DateTime (तिथि-समय) अनिवार्य रूप से पहला ब्लॉक होना चाहिए NSR/ES संदेश: DateTime आम तौर पर शामिल नहीं होता रीप्ले विंडो: 5 मिनट न्यूनतम अनुशंसित है ब्लूम फ़िल्टर: कुशल रीप्ले पहचान के लिए अनुशंसित क्लॉक स्क्यू: 5 मिनट पीछे, 2 मिनट आगे तक अनुमति दें Garlic Clove Block (I2P में garlic encryption के भीतर का \u0026lsquo;clove\u0026rsquo; ब्लॉक) (प्रकार 11) उद्देश्य: प्रेषण के लिए I2NP संदेशों को एनकैप्सुलेट करता है\nस्वरूप:\n+----+----+----+----+----+----+----+----+ | 11 | size | | +----+----+----+ + | Delivery Instructions | ~ ~ | | +----+----+----+----+----+----+----+----+ |type| Message_ID | Expiration | +----+----+----+----+----+----+----+----+ | I2NP Message body | +----+ + ~ ~ | | +----+----+----+----+----+----+----+----+ फ़ील्ड्स:\nblk: 11 size: clove (garlic संदेश की इकाई) का कुल आकार (परिवर्तनीय) Delivery Instructions: जैसा कि I2NP विशिष्टता में निर्दिष्ट है type: I2NP संदेश प्रकार (1 बाइट) Message_ID: I2NP संदेश ID (4 बाइट) Expiration: सेकंड में Unix टाइमस्टैम्प (4 बाइट) I2NP Message body: परिवर्तनीय लंबाई वाला संदेश डेटा डिलीवरी निर्देश प्रारूप:\nस्थानीय वितरण (1 बाइट):\n+----+ |0x00| +----+ डेस्टिनेशन डिलीवरी (33 बाइट्स):\n+----+----+----+----+----+----+----+----+ |0x01| | +----+ Destination Hash + | 32 bytes | + + | | +----+----+----+----+----+----+----+----+ Router डिलीवरी (33 बाइट्स):\n+----+----+----+----+----+----+----+----+ |0x02| | +----+ Router Hash + | 32 bytes | + + | | +----+----+----+----+----+----+----+----+ Tunnel डिलीवरी (37 बाइट्स):\n+----+----+----+----+----+----+----+----+ |0x03| Tunnel ID | +----+----+----+----+----+ + | Router Hash | + 32 bytes + | | + + | | +----+----+----+----+----+----+----+----+ I2NP संदेश हेडर (कुल 9 बाइट):\n+----+----+----+----+----+----+----+----+ |type| msg_id | expiration | +----+----+----+----+----+----+----+----+ | | type: I2NP (I2P का नेटवर्क प्रोटोकॉल) संदेश प्रकार (Database Store, Database Lookup, Data, आदि) msg_id: 4-बाइट संदेश पहचानकर्ता expiration: 4-बाइट Unix टाइमस्टैम्प (सेकंड) ElGamal Clove Format से महत्वपूर्ण अंतर:\nकोई प्रमाणपत्र नहीं: प्रमाणपत्र फ़ील्ड छोड़ा गया (ElGamal में अप्रयुक्त) कोई Clove ID नहीं: Clove ID (garlic encryption में प्रयुक्त उप-संदेश की पहचान) छोड़ा गया (हमेशा 0 होता था) कोई Clove Expiration नहीं: इसके बजाय I2NP संदेश की समाप्ति का उपयोग करता है संक्षिप्त हेडर: 9-बाइट I2NP हेडर बनाम बड़ा ElGamal फ़ॉर्मैट हर Clove एक अलग ब्लॉक है: कोई CloveSet (Clove का समूह) संरचना नहीं एकाधिक Cloves (कलियाँ):\n# Multiple Garlic Cloves in one message payload = [ build_datetime_block(), build_garlic_clove(i2np_message_1), build_garlic_clove(i2np_message_2), build_garlic_clove(i2np_message_3), build_padding_block() ] Cloves (garlic संदेश के घटक) में आम I2NP संदेश प्रकार:\nType Name Usage 1 DatabaseStore Publishing LeaseSet 2 DatabaseLookup Requesting LeaseSet 5 DeliveryStatus ACK (legacy, avoid in ECIES) 20 Data Streaming data 21 Garlic Nested garlic messages **Clove (garlic संदेश का उपघटक) का प्रसंस्करण:** def process_garlic_clove(clove_data): # Parse delivery instructions delivery_type = clove_data[0] if delivery_type == 0x00: # Local delivery offset = 1 elif delivery_type == 0x01: # Destination delivery dest_hash = clove_data[1:33] offset = 33 elif delivery_type == 0x02: # Router delivery router_hash = clove_data[1:33] offset = 33 elif delivery_type == 0x03: # Tunnel delivery tunnel_id = struct.unpack(\u0026#39;\u0026gt;I\u0026#39;, clove_data[1:5])[0] router_hash = clove_data[5:37] offset = 37 # Parse I2NP header i2np_type = clove_data[offset] msg_id = struct.unpack(\u0026#39;\u0026gt;I\u0026#39;, clove_data[offset+1:offset+5])[0] expiration = struct.unpack(\u0026#39;\u0026gt;I\u0026#39;, clove_data[offset+5:offset+9])[0] # Extract I2NP body i2np_body = clove_data[offset+9:] # Process message process_i2np_message(i2np_type, msg_id, expiration, i2np_body) NextKey Block (अगली कुंजी ब्लॉक) (प्रकार 7) उद्देश्य: DH ratchet (क्रमिक कुंजी अद्यतन तंत्र) कुंजी आदान-प्रदान\nप्रारूप (कुंजी मौजूद - 38 बाइट):\n+----+----+----+----+----+----+----+----+ | 7 | 35 |flag| key ID | | +----+----+----+----+----+----+ + | | + Next DH Ratchet Public Key + | 32 bytes | + + | | + +----+----+ | | +----+----+----+----+----+----+ प्रारूप (केवल कुंजी आईडी - 6 बाइट्स):\n+----+----+----+----+----+----+ | 7 | 3 |flag| key ID | +----+----+----+----+----+----+ फ़ील्ड्स:\nblk: 7 size: 3 (केवल ID) या 35 (कुंजी सहित) flag: 1 बाइट - फ़्लैग बिट्स key ID: 2 बाइट्स - Big-endian (उच्चतम-क्रम बाइट पहले) कुंजी पहचानकर्ता (0-32767) Public Key: 32 बाइट्स - X25519 सार्वजनिक कुंजी (little-endian; निम्नतम-क्रम बाइट पहले), यदि फ़्लैग बिट 0 = 1 फ्लैग बिट्स:\nBit 7 6 5 4 3 2 1 0 | | | | | | | | | | | | | | | +-- Bit 0: Key present (1) or ID only (0) | | | | | | +---- Bit 1: Reverse key (1) or forward key (0) | | | | | +------ Bit 2: Request reverse key (1) or no request (0) | | | | | +-+-+-+-+-------- Bits 3-7: Reserved (set to 0) फ़्लैग उदाहरण:\n# Forward key present flags = 0x01 # Binary: 00000001 # Reverse key present flags = 0x03 # Binary: 00000011 # Forward key ID only (ACK) flags = 0x00 # Binary: 00000000 # Reverse key ID only (ACK) flags = 0x02 # Binary: 00000010 # Forward key ID with reverse request flags = 0x04 # Binary: 00000100 कुंजी ID के नियम:\nID क्रमिक होते हैं: 0, 1, 2, \u0026hellip;, 32767 ID केवल तभी बढ़ता है जब नई कुंजी उत्पन्न की जाती है अगले ratchet (कुंजी आगे बढ़ाने की प्रक्रिया) तक कई संदेशों के लिए वही ID उपयोग की जाती है अधिकतम ID 32767 है (इसके बाद नया सत्र शुरू करना आवश्यक है) उपयोग के उदाहरण:\n# Initiating ratchet (sender generates new key) nextkey = NextKeyBlock( flags=0x01, # Key present, forward key_id=0, public_key=sender_new_pk ) # Replying to ratchet (receiver generates new key) nextkey = NextKeyBlock( flags=0x03, # Key present, reverse key_id=0, public_key=receiver_new_pk ) # Acknowledging ratchet (no new key from sender) nextkey = NextKeyBlock( flags=0x02, # ID only, reverse key_id=0 ) # Requesting reverse ratchet nextkey = NextKeyBlock( flags=0x04, # Request reverse, forward ID key_id=1 ) प्रसंस्करण तर्क:\ndef process_nextkey_block(block): flags = block.flags key_id = block.key_id key_present = (flags \u0026amp; 0x01) != 0 is_reverse = (flags \u0026amp; 0x02) != 0 request_reverse = (flags \u0026amp; 0x04) != 0 if key_present: public_key = block.public_key if is_reverse: # Reverse key received perform_dh_ratchet(receiver_key=public_key, key_id=key_id) # Sender should ACK with own key ID else: # Forward key received perform_dh_ratchet(sender_key=public_key, key_id=key_id) # Receiver should reply with reverse key send_reverse_key(generate_new_key()) else: # Key ID only (ACK) if is_reverse: # Reverse key ACK confirm_reverse_ratchet(key_id) else: # Forward key ACK confirm_forward_ratchet(key_id) if request_reverse: # Sender requests receiver to generate new key send_reverse_key(generate_new_key()) एकाधिक NextKey Blocks (अगली कुंजी के ब्लॉक्स):\nजब दोनों दिशाओं में ratcheting (कुंजी-परिवर्तन प्रक्रिया) एक साथ हो रही हो, तब एक ही ES (एक संदेश प्रकार) संदेश में अधिकतम 2 NextKey blocks (अगली कुंजी वाले ब्लॉक) हो सकते हैं:\n# Both directions ratcheting payload = [ NextKeyBlock(flags=0x01, key_id=2, public_key=forward_key), # Forward NextKeyBlock(flags=0x03, key_id=1, public_key=reverse_key), # Reverse build_garlic_clove(data) ] ACK ब्लॉक (प्रकार 8) उद्देश्य: प्राप्त संदेशों की पुष्टि in-band (उसी चैनल में) करना\nप्रारूप (एकल ACK - 7 बाइट्स):\n+----+----+----+----+----+----+----+ | 8 | 4 |tagsetid | N | +----+----+----+----+----+----+----+ प्रारूप (कई ACKs (पुष्टिकरण)):\n+----+----+----+----+----+----+----+----+ | 8 | size |tagsetid | N | | +----+----+----+----+----+----+----+ + | more ACKs | ~ ... ~ | | +----+----+----+----+----+----+----+----+ फ़ील्ड्स:\nblk: 8 size: 4 * ACKs (स्वीकृतियाँ) की संख्या (न्यूनतम 4) प्रत्येक ACK के लिए: tagsetid: 2 बाइट - Big-endian (बिग-एंडियन बाइट क्रम) टैग सेट ID (0-65535) N: 2 बाइट - Big-endian संदेश संख्या (0-65535) टैग सेट ID का निर्धारण:\n# Tag set 0 (initial, after NSR) tagset_id = 0 # After first ratchet (tag set 1) # Both Alice and Bob sent key ID 0 tagset_id = 1 + 0 + 0 = 1 # After second ratchet (tag set 2) # Alice sent key ID 1, Bob still using key ID 0 tagset_id = 1 + 1 + 0 = 2 # After third ratchet (tag set 3) # Alice still using key ID 1, Bob sent key ID 1 tagset_id = 1 + 1 + 1 = 3 एकल ACK (स्वीकृति संकेत) उदाहरण:\n# ACK message from tag set 5, message number 127 ack_block = ACKBlock( tagset_id=5, message_number=127 ) # Wire format (7 bytes): # 08 00 04 00 05 00 7F # | | | | | | | # | | | | | | +-- N (127) # | | | | +--------- N high byte # | | | +------------ tagset_id (5) # | | +--------------- tagset_id high byte # | +------------------ size (4) # +--------------------- type (8) कई ACKs का उदाहरण:\n# ACK three messages ack_block = ACKBlock([ (tagset_id=3, N=42), (tagset_id=3, N=43), (tagset_id=4, N=0) ]) # Wire format (15 bytes): # 08 00 0C 00 03 00 2A 00 03 00 2B 00 04 00 00 # (ts=3, N=42) (ts=3, N=43) (ts=4, N=0) प्रसंस्करण:\ndef process_ack_block(block): num_acks = block.size // 4 for i in range(num_acks): offset = i * 4 tagset_id = struct.unpack(\u0026#39;\u0026gt;H\u0026#39;, block.data[offset:offset+2])[0] message_num = struct.unpack(\u0026#39;\u0026gt;H\u0026#39;, block.data[offset+2:offset+4])[0] # Mark message as acknowledged mark_acked(tagset_id, message_num) # May trigger retransmission timeout cancellation cancel_retransmit_timer(tagset_id, message_num) ACKs (स्वीकृति संकेत) कब भेजें:\nस्पष्ट ACK अनुरोध: ACK (पुष्टि) अनुरोध ब्लॉक का हमेशा उत्तर दें LeaseSet वितरण: जब प्रेषक संदेश में LeaseSet शामिल करे सत्र स्थापना: NS/NSR का ACK कर सकता है (हालाँकि प्रोटोकॉल ES के माध्यम से निहित ACK को प्राथमिकता देता है) Ratchet (क्रिप्टोग्राफिक रैचेट तंत्र) पुष्टि: NextKey (अगली कुंजी) की प्राप्ति का ACK कर सकता है एप्लिकेशन लेयर: जैसा उच्च-स्तरीय प्रोटोकॉल द्वारा आवश्यक हो (उदा., Streaming) ACK (पुष्टिकरण) टाइमिंग:\nclass ACKManager: def __init__(self): self.pending_acks = [] self.ack_timer = None def request_ack(self, tagset_id, message_num): self.pending_acks.append((tagset_id, message_num)) if not self.ack_timer: # Delay ACK briefly to allow higher layer to respond self.ack_timer = set_timer(0.1, self.send_acks) # 100ms def send_acks(self): if self.pending_acks and not has_outbound_data(): # No higher layer data, send explicit ACK send_es_message(build_ack_block(self.pending_acks)) # Otherwise, ACK will piggyback on next ES message self.pending_acks = [] self.ack_timer = None ACK अनुरोध ब्लॉक (प्रकार 9) उद्देश्य: वर्तमान संदेश के लिए in-band (उसी संचार चैनल में) प्राप्ति-पुष्टिकरण का अनुरोध\nप्रारूप:\n+----+----+----+----+ | 9 | 1 |flg | +----+----+----+----+ फ़ील्ड्स:\nblk: 9 size: 1 flg: 1 बाइट - Flags (संकेतक) (सभी बिट्स वर्तमान में अप्रयुक्त हैं, 0 पर सेट) उपयोग:\n# Request ACK for this message payload = [ build_ack_request_block(), build_garlic_clove(important_data) ] प्राप्तकर्ता की प्रतिक्रिया:\nजब ACK Request (स्वीकृति अनुरोध) प्राप्त होता है:\nतुरंत डेटा के साथ: तुरंत प्रतिक्रिया में ACK (पुष्टिकरण) ब्लॉक शामिल करें तुरंत डेटा के बिना: टाइमर शुरू करें (उदा., 100ms) और यदि टाइमर समाप्त हो जाए तो ACK के साथ खाली ES भेजें टैग सेट ID: वर्तमान इनबाउंड टैग सेट ID का उपयोग करें संदेश संख्या: प्राप्त सत्र टैग से संबद्ध संदेश संख्या का उपयोग करें प्रसंस्करण:\ndef process_ack_request(message): # Extract message identification tagset_id = message.tagset_id message_num = message.message_num # Schedule ACK schedule_ack(tagset_id, message_num) # If no data to send immediately, start timer if not has_pending_data(): set_timer(0.1, lambda: send_ack_only(tagset_id, message_num)) ACK Request (पुष्टिकरण अनुरोध) का उपयोग कब करें:\nमहत्वपूर्ण संदेश: जिनकी पुष्टि अनिवार्य है LeaseSet प्रेषण: जब एक LeaseSet को बंडल किया जा रहा हो Session Ratchet (सत्र रैचेट—कुंजी-क्रम अद्यतन तंत्र): NextKey block भेजने के बाद (अगली कुंजी वाला ब्लॉक) प्रेषण समाप्ति: जब प्रेषक के पास भेजने के लिए और डेटा न हो, पर पुष्टि चाहिए कब उपयोग नहीं करना चाहिए:\nStreaming Protocol (स्ट्रीमिंग प्रोटोकॉल): स्ट्रीमिंग लेयर ACKs (प्राप्ति-पुष्टि संदेश) को संभालती है उच्च-आवृत्ति संदेश: हर संदेश पर ACK Request (प्राप्ति-पुष्टि का अनुरोध) से बचें (overhead) गैर-महत्वपूर्ण Datagrams (स्वतंत्र पैकेट): आमतौर पर कच्चे datagrams को ACKs की आवश्यकता नहीं होती समापन ब्लॉक (प्रकार 4) स्थिति: लागू नहीं किया गया\nउद्देश्य: सेशन को सुगमतापूर्वक समाप्त करना\nप्रारूप:\n+----+----+----+----+----+----+----+----+ | 4 | size | rsn| addl data | +----+----+----+----+ + ~ ... ~ +----+----+----+----+----+----+----+----+ फ़ील्ड्स:\nblk: 4 size: 1 या अधिक बाइट्स rsn: 1 बाइट - कारण कोड addl data: वैकल्पिक अतिरिक्त डेटा (प्रारूप कारण पर निर्भर करता है) कारण कोड:\nCode Meaning Additional Data 0 Normal close / unspecified None 1 Termination received None 2 Idle timeout None (implementation-specific) 3 Resource exhaustion None (implementation-specific) 4+ Reserved Implementation-specific **उपयोग (जब कार्यान्वित किया जाएगा):** # Normal session close termination = TerminationBlock( reason=0, additional_data=b\u0026#39;\u0026#39; ) # Session termination due to received termination termination = TerminationBlock( reason=1, additional_data=b\u0026#39;\u0026#39; ) नियम:\nPadding (डेटा भराई) को छोड़कर यह अवश्य अंतिम ब्लॉक होना चाहिए यदि Termination (समापन) मौजूद हो, तो Padding अवश्य उसके बाद आना चाहिए NS या NSR संदेशों में अनुमति नहीं है केवल ES संदेशों में अनुमति है विकल्प ब्लॉक (प्रकार 5) स्थिति: लागू नहीं किया गया\nउद्देश्य: सत्र पैरामीटर पर सहमति बनाना\nप्रारूप:\n+----+----+----+----+----+----+----+----+ | 5 | size |ver |flg |STL |STimeout | +----+----+----+----+----+----+----+----+ | SOTW | RITW |tmin|tmax|rmin|rmax| +----+----+----+----+----+----+----+----+ | tdmy | rdmy | tdelay | rdelay | +----+----+----+----+----+----+----+----+ | more_options | ~ ... ~ | | +----+----+----+----+----+----+----+----+ फ़ील्ड्स:\nblk: 5 size: 21 या अधिक बाइट ver: 1 बाइट - प्रोटोकॉल संस्करण (0 होना चाहिए) flg: 1 बाइट - फ्लैग्स (सभी बिट्स वर्तमान में अनुपयोगी) STL: 1 बाइट - सेशन टैग लंबाई (8 होना चाहिए) STimeout: 2 बाइट - सेशन आइडल टाइमआउट सेकंड में (बिग-एंडियन) SOTW: 2 बाइट - प्रेषक आउटबाउंड टैग विंडो (बिग-एंडियन) RITW: 2 बाइट - रिसीवर इनबाउंड टैग विंडो (बिग-एंडियन) tmin, tmax, rmin, rmax: प्रत्येक 1 बाइट - पैडिंग पैरामीटर (4.4 फिक्स्ड-पॉइंट) tdmy: 2 बाइट - भेजने के लिए तैयार अधिकतम डमी ट्रैफिक (बाइट/सेकंड, बिग-एंडियन) rdmy: 2 बाइट - अनुरोधित डमी ट्रैफिक (बाइट/सेकंड, बिग-एंडियन) tdelay: 2 बाइट - सम्मिलित करने के लिए तैयार अधिकतम इंट्रा-मैसेज देरी (msec, बिग-एंडियन) rdelay: 2 बाइट - अनुरोधित इंट्रा-मैसेज देरी (msec, बिग-एंडियन) more_options: परिवर्तनीय - भविष्य के एक्सटेंशन पैडिंग पैरामीटर (4.4 स्थिर-बिंदु):\ndef encode_padding_ratio(ratio): \u0026#34;\u0026#34;\u0026#34; Encode padding ratio as 4.4 fixed-point ratio: 0.0 to 15.9375 returns: 0x00 to 0xFF \u0026#34;\u0026#34;\u0026#34; return int(ratio * 16) def decode_padding_ratio(encoded): \u0026#34;\u0026#34;\u0026#34; Decode 4.4 fixed-point to ratio encoded: 0x00 to 0xFF returns: 0.0 to 15.9375 \u0026#34;\u0026#34;\u0026#34; return encoded / 16.0 # Examples: # 0x00 = 0.0 (no padding) # 0x01 = 0.0625 (6.25% padding) # 0x10 = 1.0 (100% padding - double traffic) # 0x80 = 8.0 (800% padding - 9x traffic) # 0xFF = 15.9375 (1593.75% padding) टैग विंडो नेगोशिएशन:\n# SOTW: Sender\u0026#39;s recommendation for receiver\u0026#39;s inbound window # RITW: Sender\u0026#39;s declaration of own inbound window # Receiver calculates actual inbound window: inbound_window = calculate_window( sender_suggestion=SOTW, own_constraints=MAX_INBOUND_TAGS, own_resources=available_memory() ) # Sender uses: # - RITW to know how far ahead receiver will accept # - Own SOTW to hint optimal window size डिफ़ॉल्ट मान (जब विकल्पों का नेगोशिएशन नहीं हुआ हो):\nDEFAULT_OPTIONS = { \u0026#39;version\u0026#39;: 0, \u0026#39;session_tag_length\u0026#39;: 8, \u0026#39;session_timeout\u0026#39;: 600, # 10 minutes \u0026#39;sender_outbound_tag_window\u0026#39;: 160, \u0026#39;receiver_inbound_tag_window\u0026#39;: 160, \u0026#39;tmin\u0026#39;: 0x00, # No minimum padding \u0026#39;tmax\u0026#39;: 0x10, # Up to 100% padding \u0026#39;rmin\u0026#39;: 0x00, # No minimum requested \u0026#39;rmax\u0026#39;: 0x10, # Up to 100% requested \u0026#39;tdmy\u0026#39;: 0, # No dummy traffic \u0026#39;rdmy\u0026#39;: 0, # No dummy traffic requested \u0026#39;tdelay\u0026#39;: 0, # No delay \u0026#39;rdelay\u0026#39;: 0 # No delay requested } MessageNumbers ब्लॉक (प्रकार 6) स्थिति: लागू नहीं किया गया\nउद्देश्य: पिछले टैग सेट में भेजे गए अंतिम संदेश को इंगित करना (अंतर का पता लगाने में सक्षम बनाता है)\nप्रारूप:\n+----+----+----+----+----+ | 6 | 2 | PN | +----+----+----+----+----+ फ़ील्ड्स:\nblk: 6 size: 2 PN: 2 बाइट - पिछले टैग सेट का अंतिम संदेश क्रमांक (big-endian (बाइट क्रम जिसमें सबसे महत्वपूर्ण बाइट पहले आती है), 0-65535) PN (Previous Number) की परिभाषा:\nPN पिछले टैग सेट में भेजे गए अंतिम टैग का सूचकांक है।\nउपयोग (कार्यान्वित होने पर):\n# After ratcheting to new tag set # Old tag set: sent messages 0-4095 # New tag set: sending first message payload = [ MessageNumbersBlock(PN=4095), build_garlic_clove(data) ] प्राप्तकर्ता के लाभ:\ndef process_message_numbers(pn_value): # Receiver can now: # 1. Determine if any messages were skipped highest_received_in_old_tagset = 4090 if pn_value \u0026gt; highest_received_in_old_tagset: missing_count = pn_value - highest_received_in_old_tagset # 5 messages were never received # 2. Delete tags higher than PN from old tagset for tag_index in range(pn_value + 1, MAX_TAG_INDEX): delete_tag(old_tagset, tag_index) # 3. Expire tags ≤ PN after grace period (e.g., 2 minutes) schedule_deletion(old_tagset, delay=120) नियम:\ntag set (टैग का समूह) 0 में कदापि नहीं भेजा जाना चाहिए (कोई पूर्व tag set नहीं) केवल ES messages (ES प्रकार के संदेश) में भेजा जाता है नए tag set के प्रथम संदेश(संदेशों) में ही भेजा जाता है PN value (PN मान) प्रेषक के दृष्टिकोण से होती है (आखिरी टैग जो प्रेषक ने भेजा) Signal से संबंध:\nSignal Double Ratchet (Signal प्रोटोकॉल का डबल रैचेट एल्गोरिद्म) में, PN संदेश हेडर में होता है। ECIES (एलिप्टिक कर्व-आधारित समेकित एन्क्रिप्शन स्कीम) में, यह एन्क्रिप्टेड पेलोड में होता है और वैकल्पिक है।\nपैडिंग ब्लॉक (टाइप 254) उद्देश्य: ट्रैफिक विश्लेषण के प्रति प्रतिरोध और संदेश आकार का छुपाव\nप्रारूप:\n+----+----+----+----+----+----+----+----+ |254 | size | padding | +----+----+----+ + | | ~ ... ~ | | +----+----+----+----+----+----+----+----+ फ़ील्ड्स:\nblk: 254 size: 0-65516 बाइट्स (big-endian, सबसे महत्त्वपूर्ण बाइट पहले) padding: यादृच्छिक या शून्य डेटा नियम:\nयह संदेश में अंतिम ब्लॉक होना चाहिए एक से अधिक Padding (भराई) ब्लॉक की अनुमति नहीं है शून्य लंबाई हो सकती है (केवल 3-बाइट हेडर) Padding डेटा शून्य या यादृच्छिक बाइट्स हो सकता है डिफ़ॉल्ट पैडिंग:\nDEFAULT_PADDING_MIN = 0 DEFAULT_PADDING_MAX = 15 def generate_default_padding(): size = random.randint(DEFAULT_PADDING_MIN, DEFAULT_PADDING_MAX) data = random.bytes(size) # or zeros return PaddingBlock(size, data) ट्रैफ़िक विश्लेषण प्रतिरोध रणनीतियाँ:\nरणनीति 1: यादृच्छिक आकार (डिफ़ॉल्ट)\n# Add 0-15 bytes random padding to each message padding_size = random.randint(0, 15) padding_block = PaddingBlock(padding_size, random.bytes(padding_size)) रणनीति 2: गुणज तक राउंड करें\n# Round total message size to next multiple of 64 target_size = ((message_size + 63) // 64) * 64 padding_size = target_size - message_size - 3 # -3 for block header padding_block = PaddingBlock(padding_size, random.bytes(padding_size)) रणनीति 3: स्थिर संदेश आकार\n# Always send 1KB messages TARGET_MESSAGE_SIZE = 1024 padding_size = TARGET_MESSAGE_SIZE - message_size - 3 padding_block = PaddingBlock(padding_size, random.bytes(padding_size)) रणनीति 4: समझौता-आधारित पैडिंग (विकल्प ब्लॉक)\n# Calculate padding based on negotiated parameters # tmin, tmax from Options block min_padding = int(payload_size * tmin_ratio) max_padding = int(payload_size * tmax_ratio) padding_size = random.randint(min_padding, max_padding) padding_block = PaddingBlock(padding_size, random.bytes(padding_size)) सिर्फ Padding (भराव) वाले संदेश:\nसंदेश पूरी तरह पैडिंग से बने हो सकते हैं (कोई एप्लिकेशन डेटा नहीं):\n# Dummy traffic message payload = [ PaddingBlock(random.randint(100, 500), random.bytes(...)) ] कार्यान्वयन संबंधी टिप्पणियाँ:\nसभी-शून्य पैडिंग: स्वीकार्य (ChaCha20 द्वारा एन्क्रिप्ट किया जाएगा) यादृच्छिक पैडिंग: एन्क्रिप्शन के बाद कोई अतिरिक्त सुरक्षा प्रदान नहीं करती, लेकिन अधिक एंट्रॉपी (यादृच्छिकता का परिमाण) का उपयोग करती है प्रदर्शन: यादृच्छिक पैडिंग उत्पन्न करना संसाधन-गहन हो सकता है; शून्य का उपयोग करने पर विचार करें मेमोरी: बड़े पैडिंग ब्लॉक बैंडविड्थ की खपत करते हैं; अधिकतम आकार पर सावधानी बरतें कार्यान्वयन मार्गदर्शिका पूर्वापेक्षाएँ क्रिप्टोग्राफिक लाइब्रेरीज़:\nX25519: libsodium, NaCl, या Bouncy Castle ChaCha20-Poly1305: libsodium, OpenSSL 1.1.0+, या Bouncy Castle SHA-256: OpenSSL, Bouncy Castle, या भाषा का अंतर्निर्मित समर्थन Elligator2: सीमित लाइब्रेरी समर्थन; कस्टम कार्यान्वयन की आवश्यकता हो सकती है Elligator2 का कार्यान्वयन:\nElligator2 (एक क्रिप्टोग्राफ़िक तकनीक) का व्यापक रूप से लागू नहीं किया गया है। विकल्प:\nOBFS4: Tor के obfs4 pluggable transport (सेंसरशिप-परिहार के लिए मॉड्यूलर परिवहन तंत्र) में Elligator2 का कार्यान्वयन शामिल है कस्टम कार्यान्वयन: Elligator2 शोध-पत्र पर आधारित kleshni/Elligator: GitHub पर संदर्भ कार्यान्वयन Java I2P नोट: Java I2P net.i2p.crypto.eddsa लाइब्रेरी का उपयोग करता है, जिसमें कस्टम Elligator2 (एक क्रिप्टोग्राफिक मैपिंग तकनीक) जोड़ शामिल हैं।\nअनुशंसित कार्यान्वयन क्रम चरण 1: कोर क्रिप्टोग्राफ़ी 1. X25519 DH (Diffie‑Hellman — डिफ़ी‑हेलमैन) कुंजी उत्पन्न करना और विनिमय 2. ChaCha20‑Poly1305 AEAD (Authenticated Encryption with Associated Data — संबद्ध डेटा सहित प्रमाणित एन्क्रिप्शन) एन्क्रिप्शन/डीक्रिप्शन 3. SHA‑256 हैशिंग और MixHash (हैश मिश्रण प्रक्रिया) 4. HKDF (HMAC‑based Key Derivation Function — HMAC‑आधारित कुंजी व्युत्पत्ति फ़ंक्शन) कुंजी व्युत्पत्ति 5. Elligator2 एन्कोडिंग/डीकोडिंग (प्रारम्भ में टेस्ट वेक्टर का उपयोग किया जा सकता है)\nचरण 2: संदेश प्रारूप 1. NS संदेश (unbound) - सबसे सरल प्रारूप 2. NS संदेश (bound) - स्थिर कुंजी जोड़ता है 3. NSR संदेश 4. ES संदेश 5. ब्लॉक पार्सिंग और उत्पादन\nचरण 3: सत्र प्रबंधन 1. सत्र निर्माण और भंडारण 2. टैग सेट प्रबंधन (प्रेषक और प्राप्तकर्ता) 3. सत्र टैग ratchet (क्रमिक कुंजी-अद्यतन तंत्र) 4. सममित कुंजी ratchet 5. टैग लुकअप और विंडो प्रबंधन\nचरण 4: DH Ratcheting (Diffie-Hellman आधारित रैचेटिंग तकनीक) 1. NextKey block का प्रसंस्करण 2. DH ratchet KDF (Key Derivation Function, कुंजी व्युत्पन्न फ़ंक्शन) 3. रैचेट के बाद Tag set (टैगों का समूह) का निर्माण 4. एकाधिक Tag set का प्रबंधन\nचरण 5: प्रोटोकॉल लॉजिक 1. NS/NSR/ES स्टेट मशीन 2. रीप्ले रोकथाम (DateTime, Bloom filter) 3. पुनः-प्रेषण लॉजिक (एकाधिक NS/NSR) 4. ACK प्रबंधन\nचरण 6: एकीकरण 1. I2NP Garlic Clove (Garlic संदेश की उप-इकाई) प्रसंस्करण 2. LeaseSet समूहीकरण 3. स्ट्रीमिंग प्रोटोकॉल एकीकरण 4. डेटाग्राम प्रोटोकॉल एकीकरण\nप्रेषक कार्यान्वयन आउटबाउंड सत्र जीवनचक्र:\nclass OutboundSession: def __init__(self, destination, bound=True): self.destination = destination self.bound = bound self.state = SessionState.NEW # Keys for NS message self.ephemeral_keypair = generate_elg2_keypair() if bound: self.static_key = context.static_keypair # Will be populated after NSR self.outbound_tagset = None self.outbound_keyratchet = None self.inbound_tagset = None self.inbound_keyratchet = None # Timing self.created_time = now() self.last_activity = now() # Retransmission self.ns_attempts = [] self.ns_timer = None def send_initial_message(self, payload): \u0026#34;\u0026#34;\u0026#34;Send NS message\u0026#34;\u0026#34;\u0026#34; # Build NS message ns_message = self.build_ns_message(payload) # Send send_to_network(self.destination, ns_message) # Track for retransmission self.ns_attempts.append({ \u0026#39;message\u0026#39;: ns_message, \u0026#39;time\u0026#39;: now(), \u0026#39;ephemeral_key\u0026#39;: self.ephemeral_keypair, \u0026#39;kdf_state\u0026#39;: self.save_kdf_state() }) # Start timer self.ns_timer = set_timer(1.0, self.on_ns_timeout) self.state = SessionState.PENDING_REPLY def build_ns_message(self, payload): \u0026#34;\u0026#34;\u0026#34;Construct NS message\u0026#34;\u0026#34;\u0026#34; # KDF initialization chainKey, h = self.initialize_kdf() # Ephemeral key section elg2_ephemeral = ENCODE_ELG2(self.ephemeral_keypair.public_key) h = SHA256(h || self.destination.static_key) h = SHA256(h || self.ephemeral_keypair.public_key) # es DH es_shared = DH(self.ephemeral_keypair.private_key, self.destination.static_key) keydata = HKDF(chainKey, es_shared, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k_static = keydata[32:63] # Encrypt static key section if self.bound: static_section = self.static_key.public_key else: static_section = bytes(32) static_ciphertext = ENCRYPT(k_static, 0, static_section, h) h = SHA256(h || static_ciphertext) # ss DH (if bound) if self.bound: ss_shared = DH(self.static_key.private_key, self.destination.static_key) keydata = HKDF(chainKey, ss_shared, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k_payload = keydata[32:63] nonce = 0 else: k_payload = k_static nonce = 1 # Build payload blocks payload_data = self.build_ns_payload(payload) # Encrypt payload payload_ciphertext = ENCRYPT(k_payload, nonce, payload_data, h) h = SHA256(h || payload_ciphertext) # Save KDF state for NSR processing self.ns_chainkey = chainKey self.ns_hash = h # Assemble message return elg2_ephemeral + static_ciphertext + payload_ciphertext def build_ns_payload(self, application_data): \u0026#34;\u0026#34;\u0026#34;Build NS payload blocks\u0026#34;\u0026#34;\u0026#34; blocks = [] # DateTime block (required, first) blocks.append(build_datetime_block()) # Garlic Clove(s) with application data blocks.append(build_garlic_clove(application_data)) # Optionally bundle LeaseSet if should_send_leaseset(): blocks.append(build_garlic_clove(build_leaseset_store())) # Padding blocks.append(build_padding_block(random.randint(0, 15))) return encode_blocks(blocks) def on_nsr_received(self, nsr_message): \u0026#34;\u0026#34;\u0026#34;Process NSR and establish ES session\u0026#34;\u0026#34;\u0026#34; # Cancel retransmission timer cancel_timer(self.ns_timer) # Parse NSR tag = nsr_message[0:8] elg2_bob_ephemeral = nsr_message[8:40] key_section_mac = nsr_message[40:56] payload_ciphertext = nsr_message[56:] # Find corresponding NS attempt ns_state = self.find_ns_by_tag(tag) if not ns_state: raise ValueError(\u0026#34;NSR tag doesn\u0026#39;t match any NS\u0026#34;) # Restore KDF state chainKey = ns_state[\u0026#39;chainkey\u0026#39;] h = ns_state[\u0026#39;hash\u0026#39;] # Decode Bob\u0026#39;s ephemeral key bob_ephemeral = DECODE_ELG2(elg2_bob_ephemeral) # Mix tag and Bob\u0026#39;s ephemeral into hash h = SHA256(h || tag) h = SHA256(h || bob_ephemeral) # ee DH ee_shared = DH(self.ephemeral_keypair.private_key, bob_ephemeral) keydata = HKDF(chainKey, ee_shared, \u0026#34;\u0026#34;, 32) chainKey = keydata[0:31] # se DH se_shared = DH(self.static_key.private_key, bob_ephemeral) keydata = HKDF(chainKey, se_shared, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k_key_section = keydata[32:63] # Verify key section MAC try: DECRYPT(k_key_section, 0, key_section_mac, h) except AuthenticationError: raise ValueError(\u0026#34;NSR key section MAC verification failed\u0026#34;) h = SHA256(h || key_section_mac) # Split for bidirectional ES keydata = HKDF(chainKey, ZEROLEN, \u0026#34;\u0026#34;, 64) k_ab = keydata[0:31] # Alice → Bob k_ba = keydata[32:63] # Bob → Alice # Initialize ES tagsets self.outbound_tagset = DH_INITIALIZE(chainKey, k_ab) self.inbound_tagset = DH_INITIALIZE(chainKey, k_ba) # Decrypt NSR payload k_nsr = HKDF(k_ba, ZEROLEN, \u0026#34;AttachPayloadKDF\u0026#34;, 32) try: payload = DECRYPT(k_nsr, 0, payload_ciphertext, h) except AuthenticationError: raise ValueError(\u0026#34;NSR payload MAC verification failed\u0026#34;) # Process NSR payload blocks self.process_payload_blocks(payload) # Session established self.state = SessionState.ESTABLISHED self.last_activity = now() # Send ES message (implicit ACK) self.send_es_ack() def send_es_message(self, payload): \u0026#34;\u0026#34;\u0026#34;Send ES message\u0026#34;\u0026#34;\u0026#34; if self.state != SessionState.ESTABLISHED: raise ValueError(\u0026#34;Session not established\u0026#34;) # Get next tag and key tag, index = self.outbound_tagset.get_next_tag() key = self.outbound_keyratchet.get_key(index) # Construct nonce nonce = construct_nonce(index) # Build payload blocks payload_data = self.build_es_payload(payload) # AEAD encryption ciphertext = ENCRYPT(key, nonce, payload_data, tag) # Assemble message es_message = tag + ciphertext # Send send_to_network(self.destination, es_message) # Update activity self.last_activity = now() # Check if ratchet needed if self.outbound_tagset.should_ratchet(): self.initiate_ratchet() रिसीवर का कार्यान्वयन आगत सत्र जीवनचक्र:\nclass InboundSession: def __init__(self): self.state = None self.bound = False self.destination = None # Keys self.remote_ephemeral_key = None self.remote_static_key = None self.ephemeral_keypair = None # Tagsets self.inbound_tagset = None self.outbound_tagset = None # Timing self.created_time = None self.last_activity = None # Paired session self.paired_outbound = None @staticmethod def try_decrypt_ns(message): \u0026#34;\u0026#34;\u0026#34;Attempt to decrypt as NS message\u0026#34;\u0026#34;\u0026#34; # Parse NS structure elg2_ephemeral = message[0:32] static_ciphertext = message[32:80] # 32 + 16 payload_ciphertext = message[80:] # Decode ephemeral key try: alice_ephemeral = DECODE_ELG2(elg2_ephemeral) except: return None # Not a valid Elligator2 encoding # Check replay if is_replay(alice_ephemeral): return None # KDF initialization chainKey, h = initialize_kdf() # Mix keys h = SHA256(h || context.static_keypair.public_key) h = SHA256(h || alice_ephemeral) # es DH es_shared = DH(context.static_keypair.private_key, alice_ephemeral) keydata = HKDF(chainKey, es_shared, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k_static = keydata[32:63] # Decrypt static key section try: static_data = DECRYPT(k_static, 0, static_ciphertext, h) except AuthenticationError: return None # Not a valid NS message h = SHA256(h || static_ciphertext) # Check if bound or unbound if static_data == bytes(32): # Unbound alice_static_key = None k_payload = k_static nonce = 1 else: # Bound - perform ss DH alice_static_key = static_data ss_shared = DH(context.static_keypair.private_key, alice_static_key) keydata = HKDF(chainKey, ss_shared, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k_payload = keydata[32:63] nonce = 0 # Decrypt payload try: payload = DECRYPT(k_payload, nonce, payload_ciphertext, h) except AuthenticationError: return None h = SHA256(h || payload_ciphertext) # Create session session = InboundSession() session.state = SessionState.ESTABLISHED session.created_time = now() session.last_activity = now() session.remote_ephemeral_key = alice_ephemeral session.remote_static_key = alice_static_key session.bound = (alice_static_key is not None) session.ns_chainkey = chainKey session.ns_hash = h # Extract destination if bound if session.bound: session.destination = extract_destination_from_payload(payload) # Process payload session.process_payload_blocks(payload) return session def send_nsr_reply(self, reply_payload): \u0026#34;\u0026#34;\u0026#34;Send NSR message\u0026#34;\u0026#34;\u0026#34; # Generate NSR tagset tagsetKey = HKDF(self.ns_chainkey, ZEROLEN, \u0026#34;SessionReplyTags\u0026#34;, 32) nsr_tagset = DH_INITIALIZE(self.ns_chainkey, tagsetKey) # Get tag tag, _ = nsr_tagset.get_next_tag() # Mix tag into hash h = SHA256(self.ns_hash || tag) # Generate ephemeral key self.ephemeral_keypair = generate_elg2_keypair() bob_ephemeral = self.ephemeral_keypair.public_key elg2_bob_ephemeral = ENCODE_ELG2(bob_ephemeral) # Mix ephemeral key h = SHA256(h || bob_ephemeral) chainKey = self.ns_chainkey # ee DH ee_shared = DH(self.ephemeral_keypair.private_key, self.remote_ephemeral_key) keydata = HKDF(chainKey, ee_shared, \u0026#34;\u0026#34;, 32) chainKey = keydata[0:31] # se DH se_shared = DH(context.static_keypair.private_key, self.remote_ephemeral_key) keydata = HKDF(chainKey, se_shared, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k_key_section = keydata[32:63] # Encrypt key section (empty) key_section_ciphertext = ENCRYPT(k_key_section, 0, ZEROLEN, h) h = SHA256(h || key_section_ciphertext) # Split for bidirectional ES keydata = HKDF(chainKey, ZEROLEN, \u0026#34;\u0026#34;, 64) k_ab = keydata[0:31] # Alice → Bob k_ba = keydata[32:63] # Bob → Alice # Initialize ES tagsets self.inbound_tagset = DH_INITIALIZE(chainKey, k_ab) self.outbound_tagset = DH_INITIALIZE(chainKey, k_ba) # Build reply payload payload_data = build_payload_blocks(reply_payload) # Encrypt payload k_nsr = HKDF(k_ba, ZEROLEN, \u0026#34;AttachPayloadKDF\u0026#34;, 32) payload_ciphertext = ENCRYPT(k_nsr, 0, payload_data, h) # Assemble NSR nsr_message = tag + elg2_bob_ephemeral + key_section_ciphertext + payload_ciphertext # Send send_to_network(self.destination, nsr_message) # Wait for ES self.state = SessionState.AWAITING_ES self.last_activity = now() def on_es_received(self, es_message): \u0026#34;\u0026#34;\u0026#34;Process first ES message\u0026#34;\u0026#34;\u0026#34; if self.state == SessionState.AWAITING_ES: # First ES received, confirms session self.state = SessionState.ESTABLISHED # Process ES message self.process_es_message(es_message) def process_es_message(self, es_message): \u0026#34;\u0026#34;\u0026#34;Decrypt and process ES message\u0026#34;\u0026#34;\u0026#34; # Extract tag tag = es_message[0:8] ciphertext = es_message[8:] # Look up tag index = self.inbound_tagset.lookup_tag(tag) if index is None: raise ValueError(\u0026#34;Tag not found\u0026#34;) # Get key key = self.inbound_keyratchet.get_key(index) # Construct nonce nonce = construct_nonce(index) # Decrypt try: payload = DECRYPT(key, nonce, ciphertext, tag) except AuthenticationError: raise ValueError(\u0026#34;ES MAC verification failed\u0026#34;) # Process blocks self.process_payload_blocks(payload) # Update activity self.last_activity = now() संदेश वर्गीकरण संदेश प्रकारों का भेद:\ndef classify_message(message): \u0026#34;\u0026#34;\u0026#34;Determine message type\u0026#34;\u0026#34;\u0026#34; # Minimum lengths if len(message) \u0026lt; 24: return None # Too short # Check for session tag (8 bytes) tag = message[0:8] # Try ES decryption first (most common) session = lookup_session_by_tag(tag) if session: return (\u0026#39;ES\u0026#39;, session) # Try NSR decryption (tag + Elligator2 key) if len(message) \u0026gt;= 72: # Check if bytes 8-40 are valid Elligator2 try: nsr_ephemeral = DECODE_ELG2(message[8:40]) nsr_session = find_pending_nsr_by_tag(tag) if nsr_session: return (\u0026#39;NSR\u0026#39;, nsr_session) except: pass # Try NS decryption (starts with Elligator2 key) if len(message) \u0026gt;= 96: try: ns_ephemeral = DECODE_ELG2(message[0:32]) ns_session = InboundSession.try_decrypt_ns(message) if ns_session: return (\u0026#39;NS\u0026#39;, ns_session) except: pass # Check ElGamal/AES (for dual-key compatibility) if len(message) \u0026gt;= 514: if (len(message) - 2) % 16 == 0: # Might be ElGamal NS return (\u0026#39;ELGAMAL_NS\u0026#39;, None) elif len(message) % 16 == 0: # Might be ElGamal ES return (\u0026#39;ELGAMAL_ES\u0026#39;, None) return None # Unknown message type सत्र प्रबंधन की सर्वोत्तम प्रथाएँ सत्र संग्रहण:\nclass SessionKeyManager: def __init__(self): # Outbound sessions (one per destination) self.outbound_sessions = {} # destination -\u0026gt; OutboundSession # Inbound sessions (multiple per destination during transition) self.inbound_sessions = [] # [InboundSession] # Session tag lookup (fast path for ES messages) self.tag_to_session = {} # tag -\u0026gt; InboundSession # Limits self.max_inbound_sessions = 1000 self.max_tags_per_session = 160 def get_outbound_session(self, destination): \u0026#34;\u0026#34;\u0026#34;Get or create outbound session\u0026#34;\u0026#34;\u0026#34; if destination not in self.outbound_sessions: session = OutboundSession(destination) self.outbound_sessions[destination] = session return self.outbound_sessions[destination] def add_inbound_session(self, session): \u0026#34;\u0026#34;\u0026#34;Add new inbound session\u0026#34;\u0026#34;\u0026#34; # Check limits if len(self.inbound_sessions) \u0026gt;= self.max_inbound_sessions: self.expire_oldest_session() self.inbound_sessions.append(session) # Add tags to lookup table self.register_session_tags(session) def register_session_tags(self, session): \u0026#34;\u0026#34;\u0026#34;Register session\u0026#39;s tags in lookup table\u0026#34;\u0026#34;\u0026#34; for tag in session.inbound_tagset.get_all_tags(): self.tag_to_session[tag] = session def lookup_tag(self, tag): \u0026#34;\u0026#34;\u0026#34;Fast tag lookup\u0026#34;\u0026#34;\u0026#34; return self.tag_to_session.get(tag) def expire_sessions(self): \u0026#34;\u0026#34;\u0026#34;Periodic session expiration\u0026#34;\u0026#34;\u0026#34; now_time = now() # Expire outbound sessions for dest, session in list(self.outbound_sessions.items()): if session.idle_time(now_time) \u0026gt; 8 * 60: del self.outbound_sessions[dest] # Expire inbound sessions expired = [] for session in self.inbound_sessions: if session.idle_time(now_time) \u0026gt; 10 * 60: expired.append(session) for session in expired: self.remove_inbound_session(session) def remove_inbound_session(self, session): \u0026#34;\u0026#34;\u0026#34;Remove inbound session and clean up tags\u0026#34;\u0026#34;\u0026#34; self.inbound_sessions.remove(session) # Remove tags from lookup for tag in session.inbound_tagset.get_all_tags(): if tag in self.tag_to_session: del self.tag_to_session[tag] मेमोरी प्रबंधन:\nclass TagMemoryManager: def __init__(self, max_memory_kb=10240): # 10 MB default self.max_memory = max_memory_kb * 1024 self.current_memory = 0 self.max_tags_per_session = 160 self.min_tags_per_session = 32 def calculate_tag_memory(self, session): \u0026#34;\u0026#34;\u0026#34;Calculate memory used by session tags\u0026#34;\u0026#34;\u0026#34; tag_count = len(session.inbound_tagset.tags) # Each tag: 8 bytes (tag) + 2 bytes (index) + 32 bytes (key, optional) # + overhead bytes_per_tag = 16 if session.defer_keys else 48 return tag_count * bytes_per_tag def check_pressure(self): \u0026#34;\u0026#34;\u0026#34;Check if under memory pressure\u0026#34;\u0026#34;\u0026#34; return self.current_memory \u0026gt; (self.max_memory * 0.9) def handle_pressure(self): \u0026#34;\u0026#34;\u0026#34;Reduce memory usage when under pressure\u0026#34;\u0026#34;\u0026#34; if not self.check_pressure(): return # Strategy 1: Reduce look-ahead windows for session in all_sessions: if session.look_ahead \u0026gt; self.min_tags_per_session: session.reduce_look_ahead(self.min_tags_per_session) # Strategy 2: Trim old tags aggressively for session in all_sessions: session.inbound_tagset.trim_behind(aggressive=True) # Strategy 3: Refuse new ratchets for session in all_sessions: if session.outbound_tagset.should_ratchet(): session.defer_ratchet = True # Strategy 4: Expire idle sessions early expire_idle_sessions(threshold=5*60) # 5 min instead of 10 परीक्षण रणनीतियाँ इकाई परीक्षण:\ndef test_x25519_dh(): \u0026#34;\u0026#34;\u0026#34;Test X25519 key exchange\u0026#34;\u0026#34;\u0026#34; alice_sk = GENERATE_PRIVATE() alice_pk = DERIVE_PUBLIC(alice_sk) bob_sk = GENERATE_PRIVATE() bob_pk = DERIVE_PUBLIC(bob_sk) # Both sides compute same shared secret alice_shared = DH(alice_sk, bob_pk) bob_shared = DH(bob_sk, alice_pk) assert alice_shared == bob_shared def test_elligator2_encode_decode(): \u0026#34;\u0026#34;\u0026#34;Test Elligator2 roundtrip\u0026#34;\u0026#34;\u0026#34; sk = GENERATE_PRIVATE_ELG2() pk = DERIVE_PUBLIC(sk) encoded = ENCODE_ELG2(pk) decoded = DECODE_ELG2(encoded) assert decoded == pk def test_chacha_poly_encrypt_decrypt(): \u0026#34;\u0026#34;\u0026#34;Test ChaCha20-Poly1305 AEAD\u0026#34;\u0026#34;\u0026#34; key = CSRNG(32) nonce = construct_nonce(42) plaintext = b\u0026#34;Hello, I2P!\u0026#34; ad = b\u0026#34;associated_data\u0026#34; ciphertext = ENCRYPT(key, nonce, plaintext, ad) decrypted = DECRYPT(key, nonce, ciphertext, ad) assert decrypted == plaintext def test_session_tag_ratchet(): \u0026#34;\u0026#34;\u0026#34;Test session tag generation\u0026#34;\u0026#34;\u0026#34; sessTag_ck = CSRNG(32) tagset = SessionTagRatchet(sessTag_ck) # Generate 100 tags tags = [tagset.get_next_tag() for _ in range(100)] # All tags should be unique assert len(set(tags)) == 100 # Each tag should be 8 bytes for tag in tags: assert len(tag) == 8 एकीकरण परीक्षण:\ndef test_ns_nsr_handshake(): \u0026#34;\u0026#34;\u0026#34;Test NS/NSR handshake\u0026#34;\u0026#34;\u0026#34; # Alice creates outbound session alice_session = OutboundSession(bob_destination, bound=True) # Alice sends NS ns_message = alice_session.build_ns_message(b\u0026#34;Hello Bob\u0026#34;) # Bob receives NS bob_session = InboundSession.try_decrypt_ns(ns_message) assert bob_session is not None assert bob_session.bound == True # Bob sends NSR nsr_message = bob_session.build_nsr_message(b\u0026#34;Hello Alice\u0026#34;) # Alice receives NSR alice_session.on_nsr_received(nsr_message) assert alice_session.state == SessionState.ESTABLISHED # Both should have matching ES tagsets # (Cannot directly compare, but can test by sending ES messages) def test_es_bidirectional(): \u0026#34;\u0026#34;\u0026#34;Test ES messages in both directions\u0026#34;\u0026#34;\u0026#34; # (After NS/NSR handshake) # Alice sends ES to Bob es_alice_to_bob = alice_session.send_es_message(b\u0026#34;Data from Alice\u0026#34;) # Bob receives ES bob_session.process_es_message(es_alice_to_bob) # Bob sends ES to Alice es_bob_to_alice = bob_session.send_es_message(b\u0026#34;Data from Bob\u0026#34;) # Alice receives ES alice_session.process_es_message(es_bob_to_alice) def test_dh_ratchet(): \u0026#34;\u0026#34;\u0026#34;Test DH ratchet\u0026#34;\u0026#34;\u0026#34; # (After established session) # Alice initiates ratchet alice_session.initiate_ratchet() nextkey_alice = build_nextkey_block( flags=0x01, key_id=0, public_key=alice_new_key ) # Send to Bob bob_session.process_nextkey_block(nextkey_alice) # Bob replies nextkey_bob = build_nextkey_block( flags=0x03, key_id=0, public_key=bob_new_key ) # Send to Alice alice_session.process_nextkey_block(nextkey_bob) # Both should now be using new tagsets assert alice_session.outbound_tagset.id == 1 assert bob_session.inbound_tagset.id == 1 परीक्षण वेक्टर:\nविनिर्देश के अनुसार परीक्षण वेक्टर कार्यान्वित करें:\nNoise IK Handshake: Noise के मानक परीक्षण वेक्टरों का उपयोग करें HKDF: RFC 5869 के परीक्षण वेक्टरों का उपयोग करें ChaCha20-Poly1305: RFC 7539 के परीक्षण वेक्टरों का उपयोग करें Elligator2: Elligator2 शोध-पत्र या OBFS4 से परीक्षण वेक्टरों का उपयोग करें अंतरसंचालनीयता परीक्षण:\nJava I2P: Java I2P संदर्भ कार्यान्वयन के विरुद्ध परीक्षण करें i2pd: C++ i2pd कार्यान्वयन के विरुद्ध परीक्षण करें पैकेट कैप्चर: संदेश प्रारूपों को सत्यापित करने के लिए Wireshark dissector (पैकेट विश्लेषक मॉड्यूल, यदि उपलब्ध हो) का उपयोग करें अंतर-कार्यान्वयन: ऐसा टेस्ट हार्नेस बनाएँ जो कार्यान्वयनों के बीच भेज/प्राप्त कर सके प्रदर्शन संबंधी विचार कुंजी निर्माण:\nElligator2 (एक क्रिप्टोग्राफिक मैपिंग तकनीक) के लिए कुंजी उत्पन्न करना गणनात्मक रूप से महंगा है (50% अस्वीकृति दर):\nclass KeyPool: \u0026#34;\u0026#34;\u0026#34;Pre-generate keys in background thread\u0026#34;\u0026#34;\u0026#34; def __init__(self, pool_size=10): self.pool = Queue(maxsize=pool_size) self.generator_thread = Thread(target=self.generate_keys, daemon=True) self.generator_thread.start() def generate_keys(self): while True: if not self.pool.full(): keypair = generate_elg2_keypair() # Also compute encoded form encoded = ENCODE_ELG2(keypair.public_key) self.pool.put((keypair, encoded)) else: sleep(0.1) def get_keypair(self): try: return self.pool.get(timeout=1.0) except Empty: # Pool exhausted, generate inline return generate_elg2_keypair() टैग लुकअप:\nO(1) टैग खोज के लिए हैश तालिकाएँ उपयोग करें:\nclass FastTagLookup: def __init__(self): self.tag_to_session = {} # Python dict is hash table def add_tag(self, tag, session, index): # 8-byte tag as bytes is hashable self.tag_to_session[tag] = (session, index) def lookup_tag(self, tag): return self.tag_to_session.get(tag) मेमोरी अनुकूलन:\nसममित कुंजी उत्पन्न करने को स्थगित करें:\nclass DeferredKeyRatchet: \u0026#34;\u0026#34;\u0026#34;Only generate keys when needed\u0026#34;\u0026#34;\u0026#34; def __init__(self, symmKey_ck): self.chainKey = symmKey_ck self.index = -1 self.cache = LRUCache(maxsize=32) # Cache recent keys def get_key(self, index): # Check cache first if index in self.cache: return self.cache[index] # Generate keys up to index while self.index \u0026lt; index: self.index += 1 keydata = HKDF(self.chainKey, ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) self.chainKey = keydata[0:31] if self.index == index: key = keydata[32:63] self.cache[index] = key return key बैच प्रसंस्करण:\nकई संदेशों को बैच में संसाधित करें:\ndef process_message_batch(messages): \u0026#34;\u0026#34;\u0026#34;Process multiple messages efficiently\u0026#34;\u0026#34;\u0026#34; results = [] # Group by type ns_messages = [] nsr_messages = [] es_messages = [] for msg in messages: msg_type = classify_message(msg) if msg_type[0] == \u0026#39;NS\u0026#39;: ns_messages.append(msg) elif msg_type[0] == \u0026#39;NSR\u0026#39;: nsr_messages.append(msg) elif msg_type[0] == \u0026#39;ES\u0026#39;: es_messages.append(msg) # Process in batches # ES messages are most common, process first for msg in es_messages: results.append(process_es_message(msg)) for msg in nsr_messages: results.append(process_nsr_message(msg)) for msg in ns_messages: results.append(process_ns_message(msg)) return results सुरक्षा संबंधी विचार धमकी मॉडल विरोधी की क्षमताएँ:\nनिष्क्रिय निरीक्षक: समस्त नेटवर्क ट्रैफ़िक की निगरानी कर सकता है सक्रिय हमलावर: संदेशों को इंजेक्ट, संशोधित, ड्रॉप, और रिप्ले (दोहराकर भेजना) कर सकता है समझौता-ग्रस्त नोड: किसी router या गंतव्य को समझौता-ग्रस्त बना सकता है ट्रैफ़िक विश्लेषण: ट्रैफ़िक पैटर्न का सांख्यिकीय विश्लेषण कर सकता है सुरक्षा लक्ष्य:\nगोपनीयता: संदेश की सामग्री पर्यवेक्षक से छिपी रहती है प्रमाणीकरण: प्रेषक की पहचान सत्यापित (बाउंड सत्रों के लिए) Forward Secrecy (आगे की गोपनीयता): कुंजियों से समझौता हो जाने पर भी पुराने संदेश गोपनीय बने रहते हैं रीप्ले-रोकथाम: पुराने संदेशों का रीप्ले संभव नहीं ट्रैफ़िक अस्पष्टकरण: हैंडशेक यादृच्छिक डेटा से अप्रभेद्य क्रिप्टोग्राफिक धारणाएँ कठिनता मान्यताएँ:\nX25519 CDH: Curve25519 पर Computational Diffie-Hellman समस्या कठिन है ChaCha20 PRF: ChaCha20 एक छद्म-यादृच्छिक फ़ंक्शन (pseudorandom function) है Poly1305 MAC: Poly1305 चुने हुए संदेश आक्रमण (chosen message attack) के तहत जालसाजी-प्रतिरोधी है SHA-256 CR: SHA-256 टकराव-प्रतिरोधी है HKDF Security: HKDF समान रूप से वितरित कुंजियों को निकालता और विस्तारित करता है सुरक्षा स्तर:\nX25519: ~128-बिट सुरक्षा (वक्र का क्रम 2^252) ChaCha20: 256-बिट कुंजियाँ, 256-बिट सुरक्षा Poly1305: 128-बिट सुरक्षा (टकराव की संभावना) SHA-256: 128-बिट टकराव-प्रतिरोध, 256-बिट पूर्व-छवि प्रतिरोध कुंजी प्रबंधन कुंजी निर्माण:\n# CRITICAL: Use cryptographically secure RNG def CSRNG(length): # GOOD: os.urandom, secrets.token_bytes (Python) # GOOD: /dev/urandom (Linux) # GOOD: BCryptGenRandom (Windows) # BAD: random.random(), Math.random() (NOT cryptographically secure) return os.urandom(length) # CRITICAL: Validate keys def validate_x25519_key(pubkey): # Check for weak keys (all zeros, small order points) if pubkey == bytes(32): raise WeakKeyError(\u0026#34;All-zero public key\u0026#34;) # Perform DH to check for weak shared secrets test_shared = DH(test_private_key, pubkey) if test_shared == bytes(32): raise WeakKeyError(\u0026#34;Results in zero shared secret\u0026#34;) कुंजी भंडारण:\n# CRITICAL: Protect private keys class SecureKeyStorage: def __init__(self): # Store in memory with protection self.keys = {} # Option 1: Memory locking (prevent swapping to disk) # mlock(self.keys) # Option 2: Encrypted storage # self.encryption_key = derive_from_password() def store_key(self, key_id, private_key): # Option: Encrypt before storage # encrypted = encrypt(private_key, self.encryption_key) # self.keys[key_id] = encrypted self.keys[key_id] = private_key def delete_key(self, key_id): # Securely wipe memory if key_id in self.keys: key = self.keys[key_id] # Overwrite with zeros before deletion for i in range(len(key)): key[i] = 0 del self.keys[key_id] कुंजी परिवर्तन:\n# CRITICAL: Rotate keys regularly class KeyRotationPolicy: def __init__(self): self.max_messages_per_tagset = 4096 # Ratchet before 65535 self.max_tagset_age = 10 * 60 # 10 minutes self.max_session_age = 60 * 60 # 1 hour def should_ratchet(self, tagset): return (tagset.messages_sent \u0026gt;= self.max_messages_per_tagset or tagset.age() \u0026gt;= self.max_tagset_age) def should_replace_session(self, session): return session.age() \u0026gt;= self.max_session_age हमलों के शमन उपाय रीप्ले हमले के शमन उपाय DateTime वैधता जांच:\nMAX_CLOCK_SKEW_PAST = 5 * 60 MAX_CLOCK_SKEW_FUTURE = 2 * 60 def validate_datetime(timestamp): now = int(time.time()) age = now - timestamp if age \u0026lt; -MAX_CLOCK_SKEW_FUTURE: raise ReplayError(\u0026#34;Timestamp too far in future\u0026#34;) if age \u0026gt; MAX_CLOCK_SKEW_PAST: raise ReplayError(\u0026#34;Timestamp too old\u0026#34;) return True NS संदेशों के लिए Bloom Filter (प्रायिकता-आधारित फ़िल्टर):\nclass ReplayFilter: def __init__(self, capacity=100000, error_rate=0.001, duration=5*60): self.bloom = BloomFilter(capacity=capacity, error_rate=error_rate) self.duration = duration self.entries = [] # (timestamp, ephemeral_key) def check_replay(self, ephemeral_key, timestamp): # Validate timestamp if not validate_datetime(timestamp): return False # Check Bloom filter if ephemeral_key in self.bloom: # Potential replay (or false positive) # Check exact match in entries for ts, key in self.entries: if key == ephemeral_key: return False # Definite replay # Add to filter self.bloom.add(ephemeral_key) self.entries.append((timestamp, ephemeral_key)) # Expire old entries self.expire_old_entries() return True def expire_old_entries(self): now = int(time.time()) self.entries = [(ts, key) for ts, key in self.entries if now - ts \u0026lt; self.duration] Session Tag (सत्र टैग) का एक-बार उपयोग:\ndef process_session_tag(tag): # Look up tag entry = tagset.lookup_tag(tag) if entry is None: raise ValueError(\u0026#34;Invalid session tag\u0026#34;) # CRITICAL: Remove tag immediately (one-time use) tagset.remove_tag(tag) # Use associated key return entry.key, entry.index Key Compromise Impersonation (KCI) (कुंजी-समझौते के कारण प्रतिरूपण) शमन उपाय समस्या: NS संदेश प्रमाणीकरण KCI (कुंजी से समझौता होने पर प्रतिरूपण) के प्रति असुरक्षित है (प्रमाणीकरण स्तर 1)\nशमन:\nयथाशीघ्र NSR (प्रमाणीकरण स्तर 2) में संक्रमण करें सुरक्षा-आवश्यक कार्यों के लिए NS payload (NS संदेश का डेटा भाग) पर भरोसा न करें अपरिवर्तनीय कार्रवाइयाँ करने से पहले NSR की पुष्टि की प्रतीक्षा करें def process_ns_message(ns_message): # NS authenticated at Level 1 (KCI vulnerable) # Do NOT perform security-critical operations yet # Extract sender\u0026#39;s static key sender_key = ns_message.static_key # Mark session as pending Level 2 authentication session.auth_level = 1 session.sender_key = sender_key # Send NSR send_nsr_reply(session) def process_first_es_message(es_message): # Now we have Level 2 authentication (KCI resistant) session.auth_level = 2 # Safe to perform security-critical operations process_security_critical_operation(es_message) Denial-of-Service (सेवा-अस्वीकरण) के शमन उपाय NS फ्लड सुरक्षा:\nclass NSFloodProtection: def __init__(self): self.ns_count = defaultdict(int) # source -\u0026gt; count self.ns_timestamps = defaultdict(list) # source -\u0026gt; [timestamps] self.max_ns_per_source = 5 self.rate_window = 10 # seconds self.max_concurrent_ns = 100 def check_ns_allowed(self, source): # Global limit total_pending = sum(self.ns_count.values()) if total_pending \u0026gt;= self.max_concurrent_ns: return False # Per-source rate limit now = time.time() timestamps = self.ns_timestamps[source] # Remove old timestamps timestamps = [ts for ts in timestamps if now - ts \u0026lt; self.rate_window] self.ns_timestamps[source] = timestamps # Check rate if len(timestamps) \u0026gt;= self.max_ns_per_source: return False # Allow NS timestamps.append(now) self.ns_count[source] += 1 return True def on_session_established(self, source): # Decrease pending count if self.ns_count[source] \u0026gt; 0: self.ns_count[source] -= 1 टैग संग्रहण सीमाएँ:\nclass TagStorageLimit: def __init__(self, max_tags=1000000): self.max_tags = max_tags self.current_tags = 0 def can_create_session(self, look_ahead): if self.current_tags + look_ahead \u0026gt; self.max_tags: return False return True def add_tags(self, count): self.current_tags += count def remove_tags(self, count): self.current_tags -= count अनुकूली संसाधन प्रबंधन:\nclass AdaptiveResourceManager: def __init__(self): self.load_level = 0 # 0 = low, 1 = medium, 2 = high, 3 = critical def adjust_parameters(self): if self.load_level == 0: # Normal operation return { \u0026#39;max_look_ahead\u0026#39;: 160, \u0026#39;max_sessions\u0026#39;: 1000, \u0026#39;session_timeout\u0026#39;: 10 * 60 } elif self.load_level == 1: # Moderate load return { \u0026#39;max_look_ahead\u0026#39;: 80, \u0026#39;max_sessions\u0026#39;: 800, \u0026#39;session_timeout\u0026#39;: 8 * 60 } elif self.load_level == 2: # High load return { \u0026#39;max_look_ahead\u0026#39;: 32, \u0026#39;max_sessions\u0026#39;: 500, \u0026#39;session_timeout\u0026#39;: 5 * 60 } else: # load_level == 3 # Critical load return { \u0026#39;max_look_ahead\u0026#39;: 16, \u0026#39;max_sessions\u0026#39;: 200, \u0026#39;session_timeout\u0026#39;: 3 * 60 } ट्रैफ़िक विश्लेषण प्रतिरोध Elligator2 एन्कोडिंग:\nहैंडशेक संदेशों को यादृच्छिक डेटा से अप्रभेद्य बनाता है:\n# NS and NSR start with Elligator2-encoded ephemeral keys # Observer cannot distinguish from random 32-byte string पैडिंग रणनीतियाँ:\n# Resist message size fingerprinting def add_padding(payload, strategy=\u0026#39;random\u0026#39;): if strategy == \u0026#39;random\u0026#39;: # Random padding 0-15 bytes size = random.randint(0, 15) elif strategy == \u0026#39;round\u0026#39;: # Round to next 64-byte boundary target = ((len(payload) + 63) // 64) * 64 size = target - len(payload) - 3 # -3 for block header elif strategy == \u0026#39;fixed\u0026#39;: # Always 1KB messages size = 1024 - len(payload) - 3 return build_padding_block(size) टाइमिंग हमले:\n# CRITICAL: Use constant-time operations def constant_time_compare(a, b): \u0026#34;\u0026#34;\u0026#34;Constant-time byte string comparison\u0026#34;\u0026#34;\u0026#34; if len(a) != len(b): return False result = 0 for x, y in zip(a, b): result |= x ^ y return result == 0 # CRITICAL: Constant-time MAC verification def verify_mac(computed_mac, received_mac): if not constant_time_compare(computed_mac, received_mac): # Always take same time regardless of where comparison fails raise AuthenticationError(\u0026#34;MAC verification failed\u0026#34;) कार्यान्वयन में सामान्य गलतियाँ सामान्य गलतियाँ:\nNonce का पुन: उपयोग: (key, nonce) युग्मों का कभी भी पुन: उपयोग न करें # BAD: Reusing nonce with same key ciphertext1 = ENCRYPT(key, nonce, plaintext1, ad1) ciphertext2 = ENCRYPT(key, nonce, plaintext2, ad2) # CATASTROPHIC सही: हर संदेश के लिए अलग nonce (एक बार प्रयुक्त यादृच्छिक मान) ciphertext1 = ENCRYPT(key, nonce1, plaintext1, ad1) ciphertext2 = ENCRYPT(key, nonce2, plaintext2, ad2) 2. **Ephemeral Key Reuse**: Generate fresh ephemeral key for each NS/NSR ```python # गलत: अस्थायी कुंजी का पुन: उपयोग ephemeral_key = generate_elg2_keypair() send_ns_message(ephemeral_key) send_ns_message(ephemeral_key) # गलत # अच्छा: प्रत्येक संदेश के लिए नई कुंजी send_ns_message(generate_elg2_keypair()) send_ns_message(generate_elg2_keypair()) Weak RNG: Use cryptographically secure random number generator खराब: गैर-क्रिप्टोग्राफ़िक RNG (यादृच्छिक संख्या जनक) import random key = bytes([random.randint(0, 255) for _ in range(32)]) # असुरक्षित अच्छा: क्रिप्टोग्राफ़िक रूप से सुरक्षित RNG (रैंडम नंबर जनरेटर) import os key = os.urandom(32) 4. **Timing Attacks**: Use constant-time comparisons ```python # खराब: शीघ्र-निकास तुलना if computed_mac == received_mac: # टाइमिंग लीक pass # सही: स्थिर-समय तुलना if constant_time_compare(computed_mac, received_mac): pass Incomplete MAC Verification: Always verify before using data खराब: सत्यापन से पहले डिक्रिप्ट करना plaintext = chacha20_decrypt(key, nonce, ciphertext) mac_ok = verify_mac(mac, plaintext) # बहुत देर हो चुकी if not mac_ok: return error सही: AEAD (संबद्ध डेटा सहित प्रमाणित एन्क्रिप्शन) डिक्रिप्ट करने से पहले सत्यापन करता है try: plaintext = DECRYPT(key, nonce, ciphertext, ad) # Verifies MAC first except AuthenticationError:\nreturn error 6. **Key Deletion**: Securely wipe keys from memory ```python # गलत: सरल हटाना del private_key # अब भी मेमोरी में # उचित: हटाने से पहले ओवरराइट करें for i in range(len(private_key)): private_key[i] = 0 del private_key Security Audits Recommended Audits:\nCryptographic Review: Expert review of KDF chains and DH operations Implementation Audit: Code review for timing attacks, key management, RNG usage Protocol Analysis: Formal verification of handshake security properties Side-Channel Analysis: Timing, power, and cache attacks Fuzzing: Random input testing for parser robustness Test Cases:\n# सुरक्षा-महत्त्वपूर्ण परीक्षण मामले def test_nonce_uniqueness(): \u0026#34;\u0026#34;\u0026#34;Ensure nonces are never reused\u0026#34;\u0026#34;\u0026#34; nonces = set() for i in range(10000): nonce = construct_nonce(i) assert nonce not in nonces nonces.add(nonce) def test_key_isolation(): \u0026#34;\u0026#34;\u0026#34;Ensure sessions don\u0026#39;t share keys\u0026#34;\u0026#34;\u0026#34; session1 = create_session(destination1) session2 = create_session(destination2) assert session1.key != session2.key def test_replay_prevention(): \u0026#34;\u0026#34;\u0026#34;Ensure replay attacks are detected\u0026#34;\u0026#34;\u0026#34; ns_message = create_ns_message() # First delivery succeeds assert process_ns_message(ns_message) == True # Replay fails assert process_ns_message(ns_message) == False def test_mac_verification(): \u0026#34;\u0026#34;\u0026#34;Ensure MAC verification is enforced\u0026#34;\u0026#34;\u0026#34; key = CSRNG(32) nonce = construct_nonce(0) plaintext = b\u0026#34;test\u0026#34; ad = b\u0026#34;test_ad\u0026#34; ciphertext = ENCRYPT(key, nonce, plaintext, ad) # Correct MAC verifies assert DECRYPT(key, nonce, ciphertext, ad) == plaintext # Corrupted MAC fails corrupted = ciphertext[:-1] + bytes([ciphertext[-1] ^ 0xFF]) with pytest.raises(AuthenticationError): DECRYPT(key, nonce, corrupted, ad) Configuration and Deployment I2CP Configuration Enable ECIES Encryption:\n# केवल ECIES (अण्डाकार वक्र एकीकृत एन्क्रिप्शन योजना) (नए परिनियोजन के लिए अनुशंसित) i2cp.leaseSetEncType=4 # द्वि-कुंजी (संगतता के लिए ECIES + ElGamal) i2cp.leaseSetEncType=4,0 # केवल ElGamal (पुराना, अनुशंसित नहीं) i2cp.leaseSetEncType=0 LeaseSet Type:\n# मानक LS2 (सबसे सामान्य) i2cp.leaseSetType=3 # कूटबद्ध LS2 (blinded destinations, अर्थात पहचान-अस्पष्ट किए गए destinations) i2cp.leaseSetType=5 # Meta LS2 (कई गंतव्य) i2cp.leaseSetType=7 Additional Options:\n# ECIES (Elliptic Curve Integrated Encryption Scheme, दीर्घवृत्तीय वक्र एकीकृत एन्क्रिप्शन योजना) के लिए स्थिर कुंजी (वैकल्पिक, यदि निर्दिष्ट न हो तो स्वतः उत्पन्न हो जाती है) # 32-बाइट की X25519 सार्वजनिक कुंजी, Base64-कूटबद्ध i2cp.leaseSetPrivateKey=\u0026lt;base64-encoded-key\u0026gt; # LeaseSet के लिए हस्ताक्षर प्रकार i2cp.leaseSetSigningPrivateKey=\u0026lt;base64-encoded-key\u0026gt; i2cp.leaseSetSigningType=7 # Ed25519 Java I2P Configuration router.config:\n# Router-से-router ECIES (दीर्घवृत्तीय वक्र एकीकृत एन्क्रिप्शन योजना) i2p.router.useECIES=true Build Properties:\n// I2CP क्लाइंट्स (Java) Properties props = new Properties(); props.setProperty(\u0026#34;i2cp.leaseSetEncType\u0026#34;, \u0026#34;4\u0026#34;); props.setProperty(\u0026#34;i2cp.leaseSetType\u0026#34;, \u0026#34;3\u0026#34;); I2PSession session = i2pClient.createSession(props); i2pd Configuration i2pd.conf:\n[सीमाएँ] # ECIES (एलिप्टिक कर्व इंटीग्रेटेड एन्क्रिप्शन स्कीम) सत्रों की मेमोरी सीमा ecies.memory = 128M [ecies (एलिप्टिक कर्व एकीकृत एन्क्रिप्शन योजना)] # ECIES (एलिप्टिक कर्व इंटीग्रेटेड एन्क्रिप्शन स्कीम) सक्षम करें enabled = true # केवल ECIES (Elliptic Curve Integrated Encryption Scheme) या द्वि-कुंजी compatibility = true # true = द्वि-कुंजी, false = केवल ECIES Tunnels Configuration:\n[my-service] type = http host = 127.0.0.1 port = 8080 keys = my-service-keys.dat # केवल ECIES (दीर्घवृत्तीय वक्र समेकित एन्क्रिप्शन योजना) ecies = true Compatibility Matrix Router Version Support:\nVersion ECIES Support LS2 Support Dual-Key Notes \u0026lt; 0.9.38 ❌ No ❌ No N/A Legacy only 0.9.38-0.9.45 ❌ No ✅ Yes N/A LS2 only 0.9.46-0.9.50 ✅ Yes ✅ Yes ✅ Yes Initial ECIES 1.5.0+ ✅ Yes ✅ Yes ✅ Yes Current 2.0.0+ ✅ Yes ✅ Yes ✅ Yes Current Destination Compatibility:\nDestination Type Can Connect To Notes ECIES-only ECIES-only, Dual-key Requires 0.9.46+ routers Dual-key Any Maximum compatibility ElGamal-only ElGamal-only, Dual-key Legacy FloodFill Requirements:\nECIES-only destinations: Require majority of floodfills on 0.9.46+ for encrypted lookups Dual-key destinations: Work with any floodfill version Current status: Near 100% floodfill adoption as of 2025 Migration Guide Migrating from ElGamal to ECIES:\nStep 1: Enable Dual-Key Mode\n# ElGamal (एक सार्वजनिक‑कुंजी कूटलेखन योजना) को बनाए रखते हुए ECIES (Elliptic Curve Integrated Encryption Scheme — दीर्घवृत्तीय वक्र समेकित कूटलेखन योजना) जोड़ें i2cp.leaseSetEncType=4,0 Step 2: Monitor Connections\n# कनेक्शन प्रकार जाँचें i2prouter.exe status # या http://127.0.0.1:7657/peers Step 3: Switch to ECIES-Only (after testing)\n# ElGamal (पब्लिक-की क्रिप्टोसिस्टम) को हटाएँ i2cp.leaseSetEncType=4 Step 4: Restart Application\n# I2P router या एप्लिकेशन को पुनः प्रारंभ करें systemctl restart i2p # या i2prouter.exe restart Rollback Plan:\n# यदि समस्याएँ हों तो केवल ElGamal (एक सार्वजनिक‑कुंजी क्रिप्टोसिस्टम) पर लौटें i2cp.leaseSetEncType=0 Performance Tuning Session Limits:\n# इनबाउंड सत्रों की अधिकतम संख्या i2p.router.maxInboundSessions=1000 # आउटबाउंड सत्रों की अधिकतम संख्या i2p.router.maxOutboundSessions=1000 # सत्र समय-सीमा (सेकंड) i2p.router.sessionTimeout=600 Memory Limits:\n# टैग भंडारण सीमा (KB) i2p.ecies.maxTagMemory=10240 # 10 MB # Look-ahead window (आगे देखने की विंडो) i2p.ecies.tagLookAhead=160 i2p.ecies.tagLookAheadMin=32 Ratchet Policy:\n# ratchet (क्रिप्टोग्राफ़िक कुंजी-अद्यतन तंत्र) से पहले के संदेश i2p.ecies.ratchetThreshold=4096 # ratchet (कुंजी अद्यतन तंत्र) से पहले का समय (सेकंड) i2p.ecies.ratchetTimeout=600 # 10 मिनट Monitoring and Debugging Logging:\n# ECIES (इलिप्टिक कर्व इंटीग्रेटेड एन्क्रिप्शन स्कीम) डीबग लॉगिंग सक्षम करें logger.i2p.router.transport.ecies=DEBUG Metrics:\nMonitor these metrics:\nNS Success Rate: Percentage of NS messages receiving NSR Session Establishment Time: Time from NS to first ES Tag Storage Usage: Current memory usage for tags Ratchet Frequency: How often sessions ratchet Session Lifetime: Average session duration Common Issues:\nNS Timeout: No NSR received\nCheck destination is online Check floodfill availability Verify LeaseSet published correctly High Memory Usage: Too many tags stored\nReduce look-ahead window Decrease session timeout Implement aggressive expiration Frequent Ratchets: Sessions ratcheting too often\nIncrease ratchet threshold Check for retransmissions Session Failures: ES messages failing to decrypt\nVerify tag synchronization Check for replay attacks Validate nonce construction References Specifications ECIES Proposal: Proposal 144 I2NP: I2NP Specification Common Structures: Common Structures Specification NTCP2: NTCP2 Specification SSU2: SSU2 Specification I2CP: I2CP Specification ElGamal/AES+SessionTags: ElGamal/AES Specification Cryptographic Standards Noise Protocol Framework: Noise Specification (Revision 34, 2018-07-11) Signal Double Ratchet: Signal Specification RFC 7748: Elliptic Curves for Security (X25519) RFC 7539: ChaCha20 and Poly1305 for IETF Protocols RFC 5869: HKDF (HMAC-based Key Derivation Function) RFC 2104: HMAC: Keyed-Hashing for Message Authentication Elligator2: Elligator Paper Implementation Resources Java I2P: i2p.i2p Repository i2pd (C++): i2pd Repository OBFS4 (Elligator2): obfs4proxy Repository Additional Information I2P Website: / I2P Forum: https://i2pforum.net I2P Wiki: https://wiki.i2p-projekt.de Appendix A: KDF Summary All KDF Operations in ECIES:\nOperation Input Info String Output NS Initial ChainKey protocol_name (none - SHA256) h, chainKey NS Static Key Section chainKey, es_shared \"\" chainKey, k NS Payload Section (bound) chainKey, ss_shared \"\" chainKey, k NSR Tagset chainKey \"SessionReplyTags\" tagsetKey NSR ee DH chainKey, ee_shared \"\" chainKey NSR se DH chainKey, se_shared \"\" chainKey, k NSR Split chainKey \"\" k_ab, k_ba NSR Payload k_ba \"AttachPayloadKDF\" k_nsr DH Initialize rootKey, k \"KDFDHRatchetStep\" nextRootKey, chainKey Tag and Key Chain Keys chainKey \"TagAndKeyGenKeys\" sessTag_ck, symmKey_ck Session Tag Init sessTag_ck \"STInitialization\" chainKey, CONSTANT Session Tag Gen chainKey, CONSTANT \"SessionTagKeyGen\" chainKey, tag Symmetric Key Gen chainKey \"SymmetricRatchet\" chainKey, key DH Ratchet sharedSecret \"XDHRatchetTagSet\" tagsetKey Appendix B: Message Size Calculator Calculate message sizes for capacity planning:\ndef calculate_ns_size(payload_size, bound=True): \u0026#34;\u0026#34;\u0026#34;Calculate New Session message size\u0026#34;\u0026#34;\u0026#34; ephemeral_key = 32 static_section = 32 + 16 # encrypted + MAC payload_encrypted = payload_size + 16 # + MAC return ephemeral_key + static_section + payload_encrypted def calculate_nsr_size(payload_size): \u0026#34;\u0026#34;\u0026#34;Calculate New Session Reply message size\u0026#34;\u0026#34;\u0026#34; tag = 8 ephemeral_key = 32 key_section_mac = 16 payload_encrypted = payload_size + 16 # + MAC return tag + ephemeral_key + key_section_mac + payload_encrypted def calculate_es_size(payload_size): \u0026#34;\u0026#34;\u0026#34;Calculate Existing Session message size\u0026#34;\u0026#34;\u0026#34; tag = 8 payload_encrypted = payload_size + 16 # + MAC return tag + payload_encrypted # उदाहरण print(\u0026#34;NS (बंधित, 1KB पेलोड):\u0026#34;, calculate_ns_size(1024, bound=True), \u0026#34;बाइट्स\u0026#34;) # आउटपुट: 1120 बाइट्स print(\u0026#34;NSR (1KB पेलोड):\u0026#34;, calculate_nsr_size(1024), \u0026#34;बाइट्स\u0026#34;) # आउटपुट: 1096 बाइट्स print(\u0026#34;ES (1KB पेलोड):\u0026#34;, calculate_es_size(1024), \u0026#34;बाइट्स\u0026#34;) # आउटपुट: 1048 बाइट्स Appendix C: Glossary AEAD: Authenticated Encryption with Associated Data - encryption mode that provides both confidentiality and authenticity\nAuthentication Level: Noise protocol security property indicating strength of sender identity verification\nBinding: Association of a session with a specific far-end destination\nChaCha20: Stream cipher designed by Daniel J. Bernstein\nChainKey: Cryptographic key used in HKDF chains to derive subsequent keys\nConfidentiality Level: Noise protocol security property indicating strength of forward secrecy\nDH: Diffie-Hellman key agreement protocol\nElligator2: Encoding technique to make elliptic curve points indistinguishable from random\nEphemeral Key: Short-lived key used only for a single handshake\nES: Existing Session message (used after handshake completion)\nForward Secrecy: Property ensuring past communications remain secure if keys are compromised\nGarlic Clove: I2NP message container for end-to-end delivery\nHKDF: HMAC-based Key Derivation Function\nIK Pattern: Noise handshake pattern where initiator sends static key immediately\nKCI: Key Compromise Impersonation attack\nKDF: Key Derivation Function - cryptographic function for generating keys from other keys\nLeaseSet: I2P structure containing a destination\u0026rsquo;s public keys and tunnel information\nLS2: LeaseSet version 2 with encryption type support\nMAC: Message Authentication Code - cryptographic checksum proving authenticity\nMixHash: Noise protocol function for maintaining running hash transcript\nNS: New Session message (initiates new session)\nNSR: New Session Reply message (response to NS)\nNonce: Number used once - ensures unique encryption even with same key\nPairing: Linking an inbound session with an outbound session for bidirectional communication\nPoly1305: Message authentication code designed by Daniel J. Bernstein\nRatchet: Cryptographic mechanism for deriving sequential keys\nSession Tag: 8-byte one-time identifier for existing session messages\nStatic Key: Long-term key associated with a destination\u0026rsquo;s identity\nTag Set: Collection of session tags derived from a common root\nX25519: Elliptic curve Diffie-Hellman key agreement using Curve25519\n","description":"I2P के लिए एलिप्टिक कर्व इंटीग्रेटेड एन्क्रिप्शन स्कीम (X25519 + AEAD)","id":"82b727dd29ed7e2e04873dac8c2acf51","section":"docs","title":"ECIES-X25519-AEAD-Ratchet (क्रमिक कुंजी-परिवर्तन तंत्र) एन्क्रिप्शन विनिर्देश","url":"/hi/docs/specs/ecies/"},{"categories":null,"content":"कार्यान्वयन स्थिति वर्तमान परिनियोजन: - i2pd (C++ कार्यान्वयन): संस्करण 2.58.0 (सितंबर 2025) में ML-KEM-512, ML-KEM-768, और ML-KEM-1024 समर्थन के साथ पूर्ण रूप से कार्यान्वित। जब OpenSSL 3.5.0 या उससे नया उपलब्ध हो, तो पोस्ट-क्वांटम एंड-टू-एंड एन्क्रिप्शन डिफ़ॉल्ट रूप से सक्षम होता है। - Java I2P: संस्करण 0.9.67 / 2.10.0 (सितंबर 2025) तक अभी तक कार्यान्वित नहीं किया गया है। विशिष्टता अनुमोदित है और भविष्य के रिलीज़ के लिए कार्यान्वयन नियोजित है।\nयह विनिर्देश स्वीकृत कार्यक्षमता का वर्णन करता है जो वर्तमान में i2pd में परिनियोजित है और Java I2P कार्यान्वयनों के लिए योजनाबद्ध है।\nसारांश यह ECIES-X25519-AEAD-Ratchet प्रोटोकॉल ECIES का पोस्ट-क्वांटम हाइब्रिड वैरिएंट है। यह प्रस्ताव 169 Prop169 के अनुमोदन हेतु पहले चरण का प्रतिनिधित्व करता है। समग्र उद्देश्यों, थ्रेट मॉडल (खतरा मॉडल), विश्लेषण, विकल्पों और अतिरिक्त जानकारी के लिए उस प्रस्ताव को देखें।\nप्रस्ताव 169 की स्थिति: Open (हाइब्रिड ECIES कार्यान्वयन के लिए पहला चरण स्वीकृत)।\nयह विनिर्देश मानक ECIES से केवल अंतर सम्मिलित करता है और उसे उस विनिर्देश के साथ मिलकर पढ़ा जाना चाहिए।\nडिज़ाइन हम NIST FIPS 203 मानक FIPS203 का उपयोग करते हैं, जो CRYSTALS-Kyber (संस्करण 3.1, 3, और उससे पुराने) पर आधारित है, लेकिन उसके साथ संगत नहीं है।\nHybrid handshakes (मिश्रित हैंडशेक) परंपरागत X25519 Diffie-Hellman को post-quantum (क्वांटमोत्तर) ML-KEM key encapsulation mechanisms (कुंजी एन्कैप्सुलेशन तंत्र) के साथ संयोजित करते हैं। यह दृष्टिकोण PQNoise शोध में प्रलेखित hybrid forward secrecy (अग्र-गोपनीयता) अवधारणाओं और TLS 1.3, IKEv2 तथा WireGuard में समान कार्यान्वयनों पर आधारित है।\nकुंजी विनिमय हम Ratchet (संदेश एन्क्रिप्शन में प्रयुक्त कुंजी-अद्यतन तंत्र) के लिए एक हाइब्रिड कुंजी-विनिमय परिभाषित करते हैं। Post-quantum KEM (क्वांटम-प्रतिरोधी Key Encapsulation Mechanism) केवल अल्पकालिक कुंजियाँ प्रदान करता है और Noise IK (Noise प्रोटोकॉल का एक स्थिर-कुंजी हैंडशेक पैटर्न) जैसे स्थिर-कुंजी हैंडशेक का प्रत्यक्ष समर्थन नहीं करता।\nहम FIPS203 में निर्दिष्ट तीन ML-KEM (कुंजी संलग्नन तंत्र) रूपांतर परिभाषित करते हैं, जिससे कुल 3 नए एन्क्रिप्शन प्रकार मिलते हैं। हाइब्रिड प्रकार केवल X25519 (एलिप्टिक कर्व डिफी–हेलमैन आधारित कुंजी-विनिमय) के साथ संयोजन में ही परिभाषित हैं।\nनए एन्क्रिप्शन प्रकार हैं:\nType Code Security Level ML-KEM Variant MLKEM512_X25519 5 NIST Category 1 (AES-128 equivalent) ML-KEM-512 MLKEM768_X25519 6 NIST Category 3 (AES-192 equivalent) ML-KEM-768 (Recommended) MLKEM1024_X25519 7 NIST Category 5 (AES-256 equivalent) ML-KEM-1024 **नोट:** MLKEM768_X25519 (Type 6) अनुशंसित डिफ़ॉल्ट वैरिएंट है, जो उचित ओवरहेड के साथ मजबूत post-quantum security (क्वांटम कंप्यूटिंग के बाद भी सुरक्षित) प्रदान करता है। Overhead (अतिरिक्त बोझ) केवल X25519 एन्क्रिप्शन की तुलना में काफी अधिक है। IK pattern के लिए सामान्यत: संदेश 1 और 2 के आकार वर्तमान में लगभग 96–103 bytes (अतिरिक्त payload (डेटा सामग्री) से पहले) होते हैं। यह संदेश के प्रकार पर निर्भर करते हुए MLKEM512 के लिए लगभग 9–12 गुना, MLKEM768 के लिए 13–16 गुना, और MLKEM1024 के लिए 17–23 गुना बढ़ जाएगा।\nनए क्रिप्टो की आवश्यकता ML-KEM (पूर्व में CRYSTALS-Kyber) FIPS203 - मॉड्यूल-लैटिस-आधारित Key-Encapsulation Mechanism (कुंजी संकुलन तंत्र) मानक SHA3-256 (पूर्व में Keccak-512) FIPS202 - SHA-3 मानक का भाग SHAKE128 और SHAKE256 (SHA3 के लिए XOF विस्तार) FIPS202 - Extendable-Output Functions (विस्तारयोग्य आउटपुट फंक्शंस) SHA3-256, SHAKE128, और SHAKE256 के लिए परीक्षण वेक्टर NIST Cryptographic Algorithm Validation Program में उपलब्ध हैं।\nलाइब्रेरी समर्थन: - Java: Bouncycastle लाइब्रेरी संस्करण 1.79 और उसके बाद के संस्करण सभी ML-KEM (पोस्ट-क्वांटम कुंजी एन्कैप्सुलेशन विधि) वैरिएंट्स और SHA3/SHAKE फंक्शंस का समर्थन करते हैं - C++: OpenSSL 3.5 और इसके बाद के संस्करणों में पूर्ण ML-KEM समर्थन शामिल है (अप्रैल 2025 में जारी) - Go: ML-KEM और SHA3 के कार्यान्वयन के लिए कई लाइब्रेरी उपलब्ध हैं\nविनिर्देश सामान्य संरचनाएँ कुंजी लंबाइयों और पहचानकर्ताओं के लिए सामान्य संरचना विनिर्देश देखें।\nहैंडशेक पैटर्न हैंडशेक, हाइब्रिड पोस्ट-क्वांटम सुरक्षा के लिए I2P-विशिष्ट अनुकूलनों के साथ Noise Protocol Framework के हैंडशेक पैटर्न का उपयोग करते हैं।\nनिम्नलिखित अक्षर मैपिंग का उपयोग किया जाता है:\ne = एक-बार प्रयुक्त अस्थायी कुंजी (X25519) s = स्थिर कुंजी p = संदेश पेलोड e1 = एक-बार प्रयुक्त अस्थायी PQ (post-quantum/क्वांटम-पश्चात) कुंजी, Alice से Bob को भेजी गई (I2P-विशिष्ट टोकन) ekem1 = KEM (Key Encapsulation Mechanism/कुंजी एन्कैप्सुलेशन तंत्र) का कूट-पाठ, Bob से Alice को भेजा गया (I2P-विशिष्ट टोकन) महत्वपूर्ण नोट: पैटर्न नाम \u0026ldquo;IKhfs\u0026rdquo; और \u0026ldquo;IKhfselg2\u0026rdquo; तथा टोकन \u0026ldquo;e1\u0026rdquo; और \u0026ldquo;ekem1\u0026rdquo; आधिकारिक Noise Protocol Framework (Noise प्रोटोकॉल ढांचा) विनिर्देश में प्रलेखित नहीं हैं; ये I2P-विशिष्ट अनुकूलन हैं। ये Noise IK pattern में ML-KEM (पोस्ट-क्वांटम कुंजी संलग्नीकरण तंत्र) को एकीकृत करने के लिए कस्टम परिभाषाएँ दर्शाते हैं। जबकि हाइब्रिड X25519 + ML-KEM दृष्टिकोण पोस्ट-क्वांटम क्रिप्टोग्राफी अनुसंधान और अन्य प्रोटोकॉल में व्यापक रूप से मान्यता प्राप्त है, यहाँ उपयोग किया गया विशिष्ट नामकरण I2P-विशिष्ट है।\nhybrid forward secrecy (संकर अग्र-गोपनीयता) के लिए IK में निम्नलिखित संशोधन लागू किए जाते हैं:\nStandard IK: I2P IKhfs (Hybrid): \u0026lt;- s \u0026lt;- s ... ... -\u0026gt; e, es, s, ss, p -\u0026gt; e, es, e1, s, ss, p \u0026lt;- e, ee, se, p \u0026lt;- e, ee, ekem1, se, p \u0026lt;- p \u0026lt;- p p -\u0026gt; p -\u0026gt; Note: e1 and ekem1 are encrypted within ChaCha20-Poly1305 AEAD blocks. Note: e1 (ML-KEM public key) and ekem1 (ML-KEM ciphertext) have different sizes. e1 पैटर्न को निम्नानुसार परिभाषित किया गया है:\nFor Alice (sender): (encap_key, decap_key) = PQ_KEYGEN() // EncryptAndHash(encap_key) ciphertext = ENCRYPT(k, n, encap_key, ad) n++ MixHash(ciphertext) For Bob (receiver): // DecryptAndHash(ciphertext) encap_key = DECRYPT(k, n, ciphertext, ad) n++ MixHash(ciphertext) ekem1 पैटर्न इस प्रकार परिभाषित है:\nFor Bob (receiver of encap_key): (kem_ciphertext, kem_shared_key) = ENCAPS(encap_key) // EncryptAndHash(kem_ciphertext) ciphertext = ENCRYPT(k, n, kem_ciphertext, ad) MixHash(ciphertext) // MixKey MixKey(kem_shared_key) For Alice (sender of encap_key): // DecryptAndHash(ciphertext) kem_ciphertext = DECRYPT(k, n, ciphertext, ad) MixHash(ciphertext) // MixKey kem_shared_key = DECAPS(kem_ciphertext, decap_key) MixKey(kem_shared_key) परिभाषित ML-KEM प्रचालन हम FIPS203 में निर्दिष्ट क्रिप्टोग्राफिक निर्माण घटकों के अनुरूप निम्नलिखित फ़ंक्शनों को परिभाषित करते हैं।\n(encap_key, decap_key) = PQ_KEYGEN() : Alice encapsulation (एन्कैप्सुलेशन) और decapsulation (डीकैप्सुलेशन) कुंजियाँ बनाती है। encapsulation कुंजी NS संदेश में भेजी जाती है। कुंजी आकार: - ML-KEM-512: encap_key = 800 बाइट्स, decap_key = 1632 बाइट्स - ML-KEM-768: encap_key = 1184 बाइट्स, decap_key = 2400 बाइट्स - ML-KEM-1024: encap_key = 1568 बाइट्स, decap_key = 3168 बाइट्स\n(ciphertext, kem_shared_key) = ENCAPS(encap_key) : Bob NS संदेश में प्राप्त एन्कैप्सुलेशन कुंजी का उपयोग करके साइफरटेक्स्ट और साझा कुंजी की गणना करता है। साइफरटेक्स्ट NSR संदेश में भेजा जाता है। साइफरटेक्स्ट के आकार: - ML-KEM-512: 768 बाइट्स - ML-KEM-768: 1088 बाइट्स - ML-KEM-1024: 1568 बाइट्स\nkem_shared_key की लंबाई सभी तीनों रूपांतरों में हमेशा 32 bytes होती है।\nkem_shared_key = DECAPS(ciphertext, decap_key) : Alice NSR संदेश में प्राप्त ciphertext (कूट-पाठ) का उपयोग करके साझा कुंजी की गणना करती है। kem_shared_key हमेशा 32 bytes होती है।\nImportant: encap_key और ciphertext दोनों Noise हैंडशेक संदेश 1 और 2 में ChaCha20-Poly1305 ब्लॉकों के भीतर एन्क्रिप्ट किए गए होते हैं। इन्हें हैंडशेक प्रक्रिया के हिस्से के रूप में डिक्रिप्ट किया जाएगा।\nkem_shared_key को MixKey() के साथ चेनिंग कुंजी में मिश्रित किया जाता है। विवरण के लिए नीचे देखें।\nNoise हैंडशेक KDF (Key Derivation Function - कुंजी व्युत्पत्ति फ़ंक्शन) अवलोकन हाइब्रिड हैंडशेक पारंपरिक X25519 ECDH को पोस्ट-क्वांटम ML-KEM (कुंजी संकुलन तंत्र) के साथ संयोजित करता है। पहला संदेश, जो Alice से Bob को जाता है, संदेश पेलोड से पहले e1 (ML-KEM संकुलन कुंजी) शामिल करता है। इसे अतिरिक्त कुंजी सामग्री के रूप में माना जाता है; इस पर EncryptAndHash() कॉल करें (Alice के रूप में) या DecryptAndHash() (Bob के रूप में)। फिर संदेश पेलोड को सामान्य रूप से प्रोसेस करें।\nदूसरा संदेश, जो Bob से Alice को है, में संदेश पेलोड से पहले ekem1 (ML-KEM ciphertext, यानी ML-KEM से उत्पन्न एन्क्रिप्टेड डेटा) शामिल होता है। इसे अतिरिक्त कुंजी सामग्री के रूप में माना जाता है; इस पर EncryptAndHash() को कॉल करें (Bob के रूप में) या DecryptAndHash() (Alice के रूप में)। फिर kem_shared_key की गणना करें और MixKey(kem_shared_key) को कॉल करें। उसके बाद संदेश पेलोड को सामान्य रूप से प्रसंस्करित करें।\nNoise (Noise प्रोटोकॉल फ्रेमवर्क) पहचानकर्ता ये Noise (एक क्रिप्टोग्राफ़िक हैंडशेक प्रोटोकॉल) की इनिशियलाइज़ेशन स्ट्रिंग्स हैं (I2P-विशिष्ट):\nNoise_IKhfselg2_25519+MLKEM512_ChaChaPoly_SHA256 Noise_IKhfselg2_25519+MLKEM768_ChaChaPoly_SHA256 Noise_IKhfselg2_25519+MLKEM1024_ChaChaPoly_SHA256 NS संदेश के लिए Alice का KDF \u0026rsquo;es\u0026rsquo; संदेश पैटर्न के बाद और \u0026rsquo;s\u0026rsquo; संदेश पैटर्न से पहले, जोड़ें:\nThis is the \u0026#34;e1\u0026#34; message pattern: (encap_key, decap_key) = PQ_KEYGEN() // EncryptAndHash(encap_key) // AEAD parameters k = keydata[32:63] n = 0 ad = h ciphertext = ENCRYPT(k, n, encap_key, ad) n++ // MixHash(ciphertext) h = SHA256(h || ciphertext) End of \u0026#34;e1\u0026#34; message pattern. NOTE: For the next section (payload for XK or static key for IK), the keydata and chain key remain the same, and n now equals 1 (instead of 0 for non-hybrid). NS संदेश के लिए Bob KDF (कुंजी व्युत्पन्न फ़ंक्शन) \u0026rsquo;es\u0026rsquo; संदेश पैटर्न के बाद और \u0026rsquo;s\u0026rsquo; संदेश पैटर्न से पहले, जोड़ें:\nThis is the \u0026#34;e1\u0026#34; message pattern: // DecryptAndHash(encap_key_section) // AEAD parameters k = keydata[32:63] n = 0 ad = h encap_key = DECRYPT(k, n, encap_key_section, ad) n++ // MixHash(encap_key_section) h = SHA256(h || encap_key_section) End of \u0026#34;e1\u0026#34; message pattern. NOTE: For the next section (payload for XK or static key for IK), the keydata and chain key remain the same, and n now equals 1 (instead of 0 for non-hybrid). NSR संदेश के लिए Bob का KDF (कुंजी व्युत्पत्ति फ़ंक्शन) \u0026rsquo;ee\u0026rsquo; संदेश पैटर्न के बाद और \u0026lsquo;se\u0026rsquo; संदेश पैटर्न से पहले, जोड़ें:\nThis is the \u0026#34;ekem1\u0026#34; message pattern: (kem_ciphertext, kem_shared_key) = ENCAPS(encap_key) // EncryptAndHash(kem_ciphertext) // AEAD parameters k = keydata[32:63] n = 0 ad = h ciphertext = ENCRYPT(k, n, kem_ciphertext, ad) // MixHash(ciphertext) h = SHA256(h || ciphertext) // MixKey(kem_shared_key) keydata = HKDF(chainKey, kem_shared_key, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] End of \u0026#34;ekem1\u0026#34; message pattern. NSR Message के लिए Alice का KDF (कुंजी व्युत्पन्न फ़ंक्शन) \u0026rsquo;ee\u0026rsquo; संदेश पैटर्न के बाद और \u0026lsquo;ss\u0026rsquo; संदेश पैटर्न से पहले, जोड़ें:\nThis is the \u0026#34;ekem1\u0026#34; message pattern: // DecryptAndHash(kem_ciphertext_section) // AEAD parameters k = keydata[32:63] n = 0 ad = h kem_ciphertext = DECRYPT(k, n, kem_ciphertext_section, ad) // MixHash(kem_ciphertext_section) h = SHA256(h || kem_ciphertext_section) // MixKey(kem_shared_key) kem_shared_key = DECAPS(kem_ciphertext, decap_key) keydata = HKDF(chainKey, kem_shared_key, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] End of \u0026#34;ekem1\u0026#34; message pattern. split() के लिए KDF (कुंजी व्युत्पत्ति फ़ंक्शन) split() फ़ंक्शन मानक ECIES विनिर्देश से अपरिवर्तित रहता है। हैंडशेक पूर्ण होने के बाद:\nkeydata = HKDF(chainKey, ZEROLEN, \u0026#34;\u0026#34;, 64) k_ab = keydata[0:31] k_ba = keydata[32:63] ये चल रहे संचार के लिए द्विदिश सत्र कुंजियाँ हैं।\nसंदेश प्रारूप NS (नया सत्र) प्रारूप परिवर्तन: वर्तमान ratchet (कुंजी-अपडेट तंत्र) में पहले ChaCha20-Poly1305 खंड में स्थिर कुंजी और दूसरे खंड में पेलोड होता है। ML-KEM (मॉड्यूल-लैटिस आधारित कुंजी एनकैप्सुलेशन तंत्र) के साथ, अब तीन खंड हैं। पहला खंड कूटबद्ध ML-KEM सार्वजनिक कुंजी (encap_key) को समाहित करता है। दूसरा खंड स्थिर कुंजी को समाहित करता है। तीसरा खंड पेलोड को समाहित करता है।\nसंदेश आकार:\nType Type Code X25519 len NS len NS Enc len NS Dec len PQ key len pl len X25519 4 32 96+pl 64+pl pl -- pl MLKEM512_X25519 5 32 912+pl 880+pl 800+pl 800 pl MLKEM768_X25519 6 32 1296+pl 1264+pl 1184+pl 1184 pl MLKEM1024_X25519 7 32 1680+pl 1648+pl 1568+pl 1568 pl **नोट:** पेलोड में एक DateTime block (तिथि-समय ब्लॉक) होना अनिवार्य है (न्यूनतम 7 बाइट: 1-बाइट प्रकार, 2-बाइट आकार, 4-बाइट टाइमस्टैम्प)। न्यूनतम NS आकार इसी अनुसार गणना किए जा सकते हैं। अतः न्यूनतम व्यावहारिक NS आकार X25519 के लिए 103 बाइट है, और हाइब्रिड वेरिएंट के लिए 919 से 1687 बाइट तक होता है। तीन ML-KEM (Module Lattice Key Encapsulation Mechanism—मॉड्यूल-लैटिस कुंजी कैप्सुलेशन मैकेनिज़्म) वेरिएंट्स के लिए 816, 1200, और 1584 बाइट्स की आकार-वृद्धि, ML-KEM सार्वजनिक कुंजी के साथ-साथ प्रमाणित एन्क्रिप्शन के लिए 16-बाइट Poly1305 MAC (Message Authentication Code—संदेश प्रमाणीकरण कोड) के कारण होती है।\nNSR (New Session Reply, नए सत्र का उत्तर) प्रारूप परिवर्तन: वर्तमान ratchet (कुंजी अद्यतन तंत्र) में पहले ChaCha20-Poly1305 (एक AEAD सिफर) खंड का पेलोड खाली होता है और पेलोड दूसरे खंड में होता है. ML-KEM (एक उत्तर-क्वांटम कुंजी एन्कैप्सुलेशन तंत्र) के साथ, अब तीन खंड हैं. पहला खंड एन्क्रिप्टेड ML-KEM साइफरटेक्स्ट समाहित करता है. दूसरे खंड में पेलोड खाली है. तीसरे खंड में पेलोड समाहित है.\nसंदेश आकार:\nType Type Code X25519 len NSR len NSR Enc len NSR Dec len PQ ct len pl len X25519 4 32 72+pl 40+pl pl -- pl MLKEM512_X25519 5 32 856+pl 824+pl 784+pl 768 pl MLKEM768_X25519 6 32 1176+pl 1144+pl 1104+pl 1088 pl MLKEM1024_X25519 7 32 1656+pl 1624+pl 1584+pl 1568 pl तीनों ML-KEM (एक post-quantum कुंजी एनकैप्सुलेशन विधि) वेरिएंट्स के लिए आकार में 784, 1104, और 1584 बाइट की बढ़ोतरी, ML-KEM ciphertext (गोपनीयकृत पाठ) के साथ-साथ authenticated encryption (प्रमाणित एन्क्रिप्शन) हेतु 16-बाइट के Poly1305 MAC (संदेश प्रमाणीकरण कोड) को जोड़ने से होती है। ओवरहेड विश्लेषण कुंजी विनिमय केवल X25519 की तुलना में hybrid encryption (जिसमें असिमेट्रिक और सिमेट्रिक एन्क्रिप्शन का संयुक्त उपयोग होता है) का ओवरहेड उल्लेखनीय रूप से अधिक है:\nMLKEM512_X25519: हैंडशेक संदेश के आकार में लगभग 9-12x वृद्धि (NS: 9.5x, NSR: 11.9x) MLKEM768_X25519: हैंडशेक संदेश के आकार में लगभग 13-16x वृद्धि (NS: 13.5x, NSR: 16.3x) MLKEM1024_X25519: हैंडशेक संदेश के आकार में लगभग 17-23x वृद्धि (NS: 17.5x, NSR: 23x) अतिरिक्त post-quantum सुरक्षा (क्वांटम कंप्यूटर-प्रतिरोधी) लाभों के लिए यह ओवरहेड स्वीकार्य है। संदेश के प्रकार के अनुसार गुणांक बदलते हैं क्योंकि आधार संदेश आकार भिन्न होते हैं (NS न्यूनतम 96 बाइट, NSR न्यूनतम 72 बाइट)।\nबैंडविड्थ संबंधी विचार न्यूनतम पेलोड के साथ एक सामान्य सत्र स्थापना के लिए: - केवल X25519: ~200 बाइट कुल (NS + NSR) - MLKEM512_X25519: ~1,800 बाइट कुल (9x वृद्धि) - MLKEM768_X25519: ~2,500 बाइट कुल (12.5x वृद्धि) - MLKEM1024_X25519: ~3,400 बाइट कुल (17x वृद्धि)\nसत्र स्थापना के बाद, सतत संदेश एन्क्रिप्शन X25519-केवल सत्रों के समान डेटा परिवहन प्रारूप का ही उपयोग करता है, इसलिए बाद के संदेशों के लिए कोई ओवरहेड (अतिरिक्त प्रसंस्करण लागत) नहीं होता।\nसुरक्षा विश्लेषण हैंडशेक्स हाइब्रिड हैंडशेक परंपरागत (X25519) और पोस्ट-क्वांटम (ML-KEM) सुरक्षा दोनों प्रदान करता है। सत्र कुंजियों से समझौता करने के लिए हमलावर को परंपरागत ECDH (Elliptic Curve Diffie-Hellman — एलिप्टिक कर्व डिफ्फी-हेल्मन, कुंजी विनिमय) और पोस्ट-क्वांटम KEM (Key Encapsulation Mechanism — कुंजी एनकैप्सुलेशन तंत्र) दोनों को तोड़ना होगा।\nयह प्रदान करता है: - वर्तमान सुरक्षा: X25519 ECDH (अण्डाकार वक्र डिफी‑हेल्मन कुंजी सहमति) पारंपरिक हमलावरों के विरुद्ध सुरक्षा प्रदान करता है (128-बिट सुरक्षा स्तर) - भविष्य सुरक्षा: ML-KEM (पोस्ट-क्वांटम कुंजी संकुलन तंत्र) क्वांटम हमलावरों के विरुद्ध सुरक्षा प्रदान करता है (पैरामीटर सेट के अनुसार बदलता है) - संकर सुरक्षा: सत्र से समझौता करने के लिए दोनों को तोड़ा जाना चाहिए (सुरक्षा स्तर = दोनों घटकों का अधिकतम)\nसुरक्षा स्तर Variant NIST Category Classical Security PQ Security Hybrid Security MLKEM512_X25519 Category 1 128-bit (X25519) AES-128 equivalent 128-bit MLKEM768_X25519 Category 3 128-bit (X25519) AES-192 equivalent 128-bit MLKEM1024_X25519 Category 5 128-bit (X25519) AES-256 equivalent 128-bit **नोट:** हाइब्रिड सुरक्षा स्तर दोनों घटकों में से कमजोर वाले द्वारा सीमित होता है। सभी मामलों में, X25519 128-बिट पारंपरिक सुरक्षा प्रदान करता है। यदि क्रिप्टोग्राफ़िक रूप से प्रासंगिक कोई क्वांटम कंप्यूटर उपलब्ध हो जाता है, तो सुरक्षा स्तर चुने गए ML-KEM (कुंजी एनकैप्सुलेशन तंत्र) पैरामीटर सेट पर निर्भर करेगा। Forward Secrecy (ऐसी क्रिप्टोग्राफिक विशेषता जिसमें दीर्घकालिक कुंजी के लीक होने पर भी पिछले सत्रों का डेटा सुरक्षित रहता है) यह हाइब्रिड दृष्टिकोण forward secrecy (आगे की गोपनीयता) के गुणधर्म बनाए रखता है। सत्र कुंजियाँ अस्थायी X25519 तथा अस्थायी ML-KEM कुंजी-विनिमयों, दोनों से व्युत्पन्न होती हैं। यदि हैंडशेक के बाद X25519 या ML-KEM की अस्थायी निजी कुंजियों में से किसी एक को भी नष्ट कर दिया जाए, तो भले ही दीर्घकालीन स्थिर कुंजियाँ समझौता हो जाएँ, पिछले सत्रों को डिक्रिप्ट नहीं किया जा सकता।\nदूसरा संदेश (NSR) भेजे जाने के बाद IK पैटर्न पूर्ण फॉरवर्ड सीक्रेसी (Noise Confidentiality level 5) प्रदान करता है।\nप्रकार प्राथमिकताएँ इम्प्लीमेंटेशन को कई हाइब्रिड प्रकारों का समर्थन करना चाहिए और सबसे मज़बूत, परस्पर-समर्थित वैरिएंट पर नेगोशिएट करना चाहिए। प्राथमिकता का क्रम इस प्रकार होना चाहिए:\nMLKEM768_X25519 (प्रकार 6) - अनुशंसित डिफ़ॉल्ट, सुरक्षा और प्रदर्शन का सर्वोत्तम संतुलन MLKEM1024_X25519 (प्रकार 7) - संवेदनशील अनुप्रयोगों के लिए सर्वोच्च सुरक्षा MLKEM512_X25519 (प्रकार 5) - संसाधन-सीमित परिदृश्यों के लिए बेसलाइन पोस्ट-क्वांटम (क्वांटम-प्रतिरोधी) सुरक्षा X25519 (प्रकार 4) - केवल पारंपरिक (क्लासिकल), संगतता हेतु फॉलबैक तर्क: MLKEM768_X25519 (एक हाइब्रिड कुंजी विनिमय सूट) को डिफ़ॉल्ट के रूप में अनुशंसित किया जाता है क्योंकि यह NIST Category 3 सुरक्षा (AES-192 समकक्ष) प्रदान करता है, जिसे क्वांटम कंप्यूटरों के विरुद्ध पर्याप्त संरक्षण माना जाता है, साथ ही संदेश आकारों को यथोचित बनाए रखते हुए। MLKEM1024_X25519 अधिक सुरक्षा प्रदान करता है, परंतु ओवरहेड में उल्लेखनीय वृद्धि के साथ।\nकार्यान्वयन संबंधी टिप्पणियाँ लाइब्रेरी समर्थन Java: Bouncycastle लाइब्रेरी संस्करण 1.79 (अगस्त 2024) और बाद के संस्करण सभी आवश्यक ML-KEM (NIST का Module Lattice‑based Key Encapsulation Mechanism मानक) वैरिएंट्स और SHA3/SHAKE फ़ंक्शनों का समर्थन करते हैं. FIPS 203 अनुपालन के लिए org.bouncycastle.pqc.crypto.mlkem.MLKEMEngine का उपयोग करें. C++: OpenSSL 3.5 (अप्रैल 2025) और बाद के संस्करणों में EVP_KEM इंटरफ़ेस के माध्यम से ML-KEM समर्थन शामिल है. यह एक दीर्घकालिक समर्थन रिलीज़ है, जिसका रखरखाव अप्रैल 2030 तक किया जाएगा. Go: ML-KEM और SHA3 के लिए कई तृतीय-पक्ष लाइब्रेरी उपलब्ध हैं, जिनमें Cloudflare की CIRCL लाइब्रेरी शामिल है. स्थानांतरण रणनीति इम्प्लीमेंटेशन को चाहिए: 1. संक्रमण अवधि के दौरान X25519-only और hybrid (मिश्रित) ML-KEM वेरिएंट दोनों का समर्थन करें 2. जब दोनों peers (समकक्ष) उन्हें समर्थन करते हों, तो hybrid वेरिएंट को प्राथमिकता दें 3. backward compatibility (पुराने संस्करणों के साथ अनुकूलता) हेतु X25519-only पर fallback (विकल्प पर वापसी) बनाए रखें 4. डिफ़ॉल्ट वेरिएंट चुनते समय नेटवर्क बैंडविड्थ की सीमाओं पर विचार करें\nसाझा Tunnels बढ़े हुए संदेश आकार साझा tunnel उपयोग को प्रभावित कर सकते हैं। कार्यान्वयन को निम्नलिखित पर विचार करना चाहिए: - जहाँ संभव हो, ओवरहेड को कम करने के लिए हैंडशेक्स को बैच में करना - संग्रहीत स्थिति को कम करने के लिए hybrid sessions (हाइब्रिड सत्र) के लिए कम समाप्ति समय का उपयोग करना - बैंडविड्थ उपयोग की निगरानी करना और उसी के अनुसार पैरामीटर समायोजित करना - सत्र स्थापना ट्रैफ़िक के लिए congestion control (भीड़-नियंत्रण) लागू करना\nनए सेशन आकार से संबंधित विचार बड़े हैंडशेक संदेशों के कारण, कार्यान्वयन को निम्न करने की आवश्यकता हो सकती है: - सत्र नेगोशिएशन के लिए बफ़र आकार बढ़ाएँ (न्यूनतम 4KB अनुशंसित) - धीमे कनेक्शनों के लिए टाइमआउट मान समायोजित करें (लगभग ~3-17x बड़े संदेशों का ध्यान रखें) - NS/NSR संदेशों में पेलोड डेटा के लिए कंप्रेशन पर विचार करें - यदि ट्रांसपोर्ट लेयर द्वारा आवश्यक हो तो फ्रैगमेंटेशन हैंडलिंग लागू करें\nपरीक्षण और मान्यकरण कार्यान्वयन को यह सत्यापित करना चाहिए: - सही ML-KEM कुंजी निर्माण, encapsulation (लपेटना), और decapsulation (खोलना) - kem_shared_key का Noise KDF (Key Derivation Function—कुंजी व्युत्पन्न फ़ंक्शन) में सही एकीकरण - संदेश आकार की गणनाएँ विनिर्देश से मेल खाती हों - अन्य I2P router कार्यान्वयनों के साथ अंतरसंचालनीयता - जब ML-KEM उपलब्ध न हो तो फॉलबैक (वैकल्पिक) व्यवहार\nML-KEM कार्यों के लिए परीक्षण वेक्टर NIST के Cryptographic Algorithm Validation Program में उपलब्ध हैं।\nसंस्करण संगतता I2P संस्करण क्रमांकन: I2P दो समानांतर संस्करण संख्याएँ बनाए रखता है: - Router रिलीज़ संस्करण: 2.x.x प्रारूप (उदा., 2.10.0 सितंबर 2025 में जारी) - API/प्रोटोकॉल संस्करण: 0.9.x प्रारूप (उदा., 0.9.67 router 2.10.0 के अनुरूप है)\nयह विशिष्टता प्रोटोकॉल संस्करण 0.9.67 का संदर्भ देती है, जो router रिलीज़ 2.10.0 और उसके बाद के संस्करणों के अनुरूप है।\nसंगतता मैट्रिक्स:\nImplementation Version ML-KEM Support Status i2pd 2.58.0+ Full (512/768/1024) Deployed September 2025 Java I2P 0.9.67 / 2.10.0 Not yet Planned for future release ## संदर्भ [ECIES]: ECIES-X25519-AEAD-Ratchet विनिर्देश [Prop169]: प्रस्ताव 169: पोस्ट-क्वांटम क्रिप्टोग्राफी [FIPS203]: NIST FIPS 203 - ML-KEM मानक [FIPS202]: NIST FIPS 202 - SHA-3 मानक [Noise]: Noise प्रोटोकॉल फ्रेमवर्क [COMMON]: सामान्य संरचनाएँ विनिर्देश [RFC7539]: RFC 7539 - ChaCha20 और Poly1305 [RFC5869]: RFC 5869 - HKDF [OpenSSL]: OpenSSL 3.5 ML-KEM दस्तावेज़ीकरण [Bouncycastle]: Bouncycastle जावा क्रिप्टोग्राफी लाइब्रेरी ","description":"ECIES एन्क्रिप्शन प्रोटोकॉल का पोस्ट‑क्वांटम हाइब्रिड वैरिएंट, जो ML‑KEM का उपयोग करता है","id":"f6a66a37875c5b108bc5a8ea027dc0e2","section":"docs","title":"ECIES-X25519-AEAD-Ratchet हाइब्रिड एन्क्रिप्शन","url":"/hi/docs/specs/ecies-hybrid/"},{"categories":null,"content":" स्थिति: यह दस्तावेज़ लेगेसी ElGamal/AES+SessionTag एन्क्रिप्शन प्रोटोकॉल का वर्णन करता है। यह केवल पिछड़ी संगतता के लिए समर्थित है, क्योंकि आधुनिक I2P संस्करण (2.10.0+) ECIES-X25519-AEAD-Ratchet (एक आधुनिक एन्क्रिप्शन स्कीम) का उपयोग करते हैं। ElGamal प्रोटोकॉल अप्रचलित है और केवल ऐतिहासिक तथा अंतरसंचालनीयता उद्देश्यों के लिए बनाए रखा गया है।\nअवलोकन ElGamal/AES+SessionTag ने garlic संदेशों (I2P में कई संदेशों को एक साथ पैक किए गए संदेश) के लिए I2P का मूल end-to-end एन्क्रिप्शन तंत्र प्रदान किया। यह निम्न का संयोजन था:\nElGamal (2048-बिट) — कुंजी आदान-प्रदान के लिए AES-256/CBC — पेलोड एन्क्रिप्शन के लिए SHA-256 — हैशिंग और IV व्युत्पत्ति के लिए Session Tags (32 बाइट्स) (सत्र टैग) — एक-बार उपयोग वाले संदेश पहचानकर्ताओं के लिए इस प्रोटोकॉल ने routers और गंतव्यों को स्थायी कनेक्शनों को बनाए बिना सुरक्षित रूप से संचार करने की अनुमति दी। प्रत्येक सत्र में असममित ElGamal एक्सचेंज के माध्यम से एक सममित AES कुंजी स्थापित की जाती थी, जिसके बाद उस सत्र का संदर्भ देने वाले हल्के \u0026ldquo;tagged\u0026rdquo; संदेश होते थे।\nप्रोटोकॉल का संचालन सत्र स्थापना (नया सत्र) एक नया सत्र ऐसे संदेश के साथ शुरू हुआ, जिसमें दो अनुभाग थे:\nSection Size Contents Purpose ElGamal-encrypted block 514 bytes 222 bytes of plaintext encrypted using the recipient's ElGamal public key Establishes the AES session key and IV seed AES-encrypted block Variable (≥128 bytes typical) Payload data, integrity hash, and session tags Carries the actual message and new tags ElGamal ब्लॉक के अंदर का स्पष्ट-पाठ निम्न से मिलकर बना था: Field Size Description Session Key 32 bytes AES-256 key for the session Pre-IV 32 bytes Material for deriving the AES initialization vector (IV = first 16 bytes of SHA-256(Pre-IV)) Random Padding 158 bytes Filler to reach required ElGamal plaintext length ### मौजूदा सत्र संदेश एक बार सत्र स्थापित हो जाने पर, प्रेषक कैश किए गए सत्र टैग का उपयोग करके existing-session (मौजूदा सत्र) संदेश भेज सकता था:\nField Size Description Session Tag 32 bytes Single-use identifier tied to the existing session key AES-Encrypted Block Variable Encrypted payload and metadata using the established AES key Routers प्रेषित टैग्स को लगभग **15 मिनट** तक कैश करते थे, जिसके बाद जो टैग्स उपयोग में नहीं आए थे वे समाप्त हो जाते थे। प्रत्येक टैग ठीक **एक संदेश** के लिए मान्य था, ताकि correlation attacks (सहसंबंध हमले) को रोका जा सके। AES-एन्क्रिप्टेड ब्लॉक प्रारूप Field Size Description Tag Count 2 bytes Number (0–200) of new session tags included Session Tags 32 × N bytes Newly generated single-use tags Payload Size 4 bytes Length of the payload in bytes Payload Hash 32 bytes SHA-256 digest of the payload Flag 1 byte 0x00 normal, 0x01 = new session key follows (unused) New Session Key 32 bytes (optional) Replacement AES key (rarely used) Payload Variable Encrypted message data Padding Variable (16-byte aligned) Random padding to block boundary Routers, या तो Pre-IV (नए सत्रों के लिए) या सत्र टैग (मौजूदा सत्रों के लिए) से व्युत्पन्न सत्र कुंजी और IV (Initialization Vector, आरंभीकरण वेक्टर) का उपयोग करके डिक्रिप्ट करते हैं। डिक्रिप्शन के बाद, वे plaintext payload (सादा-पाठ पेलोड) के SHA-256 हैश की पुनर्गणना करके अखंडता सत्यापित करते हैं। Session Tag (सेशन टैग) प्रबंधन टैग एकतरफ़ा होते हैं: Alice → Bob के टैग Bob → Alice के लिए पुनः उपयोग नहीं किए जा सकते। टैग लगभग 15 मिनट बाद समाप्त हो जाते हैं। Routers प्रति-गंतव्य session key managers (सत्र कुंजी प्रबंधक) बनाए रखते हैं ताकि टैग, कुंजियों, और समाप्ति समय को ट्रैक किया जा सके। एप्लिकेशन I2CP options के माध्यम से टैग के व्यवहार को नियंत्रित कर सकते हैं: i2cp.tagThreshold — पुनःपूर्ति से पहले कैश किए गए टैगों की न्यूनतम सीमा i2cp.tagCount — प्रति संदेश नए टैगों की संख्या इस तंत्र ने गणनात्मक रूप से महंगे ElGamal हैंडशेक्स को न्यूनतम किया, जबकि संदेशों के बीच unlinkability (आपस में लिंक न कर पाने की क्षमता) को बनाए रखा।\nविन्यास और दक्षता Session tags (सेशन टैग्स) को I2P के उच्च विलंबता, गैर-क्रमबद्ध ट्रांसपोर्ट में दक्षता बढ़ाने के लिए पेश किया गया था। एक सामान्य विन्यास प्रति संदेश 40 टैग प्रदान करता था, जिससे लगभग 1.2 KB का ओवरहेड जुड़ जाता था। एप्लिकेशन अपेक्षित ट्रैफिक के आधार पर डिलीवरी व्यवहार समायोजित कर सकते थे:\nUse Case Recommended Tags Notes Short-lived requests (HTTP, datagrams) 0 – 5 Low overhead, may trigger ElGamal fallback Persistent streams or bulk transfer 20 – 50 Higher bandwidth use, avoids session re-establishment Long-term services 50+ Ensures steady tag supply despite loss or delay Routers समय-समय पर समाप्त हो चुके टैगों को हटाते हैं और अप्रयुक्त सत्र स्थिति को छांटते हैं, ताकि मेमोरी उपयोग कम हो और tag-flooding (टैगों की बाढ़) हमलों का शमन हो। सीमाएँ Category Limitation Performance 514-byte ElGamal block adds heavy overhead for new sessions; session tags consume 32 bytes each. Security No forward secrecy – compromise of ElGamal private key exposes past sessions. Integrity AES-CBC requires manual hash verification; no AEAD. Quantum Resistance Vulnerable to Shor's algorithm – will not survive quantum attacks. Complexity Requires stateful tag management and careful timeout tuning. इन कमियों ने सीधे [ECIES-X25519-AEAD-Ratchet](/docs/specs/ecies/) प्रोटोकॉल के डिज़ाइन के लिए प्रेरणा दी, जो perfect forward secrecy (पूर्ण अग्र-गोपनीयता), authenticated encryption (प्रमाणित एन्क्रिप्शन), और कुशल key exchange (कुंजी विनिमय) प्रदान करता है। अप्रचलन और स्थानांतरण की स्थिति प्रस्तुत किया गया: I2P के शुरुआती रिलीज़ (pre-0.6) अप्रचलित: ECIES-X25519 (एलिप्टिक-कर्व आधारित कुंजी-अदला-बदली और एन्क्रिप्शन योजना) के परिचय के साथ (0.9.46 → 0.9.48) हटा दिया गया: 2.4.0 से डिफ़ॉल्ट नहीं रहा (दिसंबर 2023) समर्थित: केवल पुराने संस्करणों के साथ संगतता मात्र आधुनिक routers और गंतव्य अब क्रिप्टो प्रकार 4 (ECIES-X25519) की घोषणा करते हैं प्रकार 0 (ElGamal/AES) के बजाय। पुराना प्रोटोकॉल पुराने पीयर्स के साथ interoperability (अंतःपरिचालन) के लिए अब भी मान्य है, लेकिन नए परिनियोजनों में इसका उपयोग नहीं किया जाना चाहिए।\nऐतिहासिक संदर्भ ElGamal/AES+SessionTag I2P की शुरुआती कूटलेखी संरचना के लिए आधारभूत था। इसके संकर डिज़ाइन ने एक-बार-उपयोग सेशन टैग और एक-दिशात्मक सेशन जैसे नवाचार पेश किए, जिन्होंने आगामी प्रोटोकॉलों के विकास को दिशा दी। इनमें से कई विचार आधुनिक रचनाओं में विकसित हुए, जैसे deterministic ratchets (नियतात्मक रैचेट: कुंजी-उन्नयन तंत्र) और संकर पोस्ट-क्वांटम कुंजी विनिमय।\n","description":"ElGamal, AES, SHA-256, और one-time session tags (एक-बार उपयोग वाले सेशन टैग) को संयोजित करने वाला लेगेसी एंड-टू-एंड एन्क्रिप्शन","id":"092d77bf065d0f13bb2b2a470f57a902","section":"docs","title":"ElGamal/AES + SessionTag (सेशन टैग) एन्क्रिप्शन","url":"/hi/docs/legacy/elgamal-aes/"},{"categories":null,"content":"अवलोकन नोट: अप्रचलित - अब हम प्राथमिकता के क्रम में तीन प्रारूपों का समर्थन करते हैं:\nMaxmind geoip2 (GeoLite2-Country.mmdb) सभी इंस्टॉलेशनों के साथ बंडल होता है, Debian पैकेजों और Android को छोड़कर Maxmind geoip1 (GeoIP.dat) Debian geoip-database पैकेज में नीचे प्रलेखित IPv4 Tor फॉर्मेट (geoip.txt) और कस्टम IPv6 फॉर्मेट (geoipv6.dat.gz), अब भी समर्थित हैं, लेकिन उपयोग नहीं किए जाते। यह पृष्ठ विभिन्न GeoIP फ़ाइलों का प्रारूप निर्दिष्ट करता है, जिनका उपयोग router द्वारा किसी IP के लिए देश खोजने में किया जाता है।\nदेश का नाम (countries.txt) प्रारूप यह फ़ॉर्मेट कई सार्वजनिक स्रोतों से उपलब्ध डेटा फ़ाइलों से आसानी से तैयार किया जा सकता है। उदाहरण के लिए:\n$ wget http://geolite.maxmind.com/download/geoip/database/GeoIPCountryCSV.zip $ unzip GeoIPCountryCSV.zip $ cut -d, -f5,6 \u0026lt; GeoIPCountryWhois.csv | sed \u0026#39;s/\u0026#34;//g\u0026#39; | sort | uniq \u0026gt; countries.txt प्रारूप विनिर्देश:\nएन्कोडिंग UTF-8 है स्तंभ 1 में \u0026lsquo;#\u0026rsquo; एक टिप्पणी पंक्ति को दर्शाता है प्रविष्टि पंक्तियाँ CountryCode,CountryName होती हैं CountryCode ISO का दो-अक्षरीय कोड है, बड़े अक्षरों में CountryName अंग्रेज़ी में है IPv4 (geoip.txt) प्रारूप यह फ़ॉर्मेट Tor से लिया गया है और इसे कई सार्वजनिक स्रोतों से उपलब्ध डेटा फ़ाइलों से आसानी से उत्पन्न किया जा सकता है। उदाहरण के लिए:\n$ wget http://geolite.maxmind.com/download/geoip/database/GeoIPCountryCSV.zip $ unzip GeoIPCountryCSV.zip $ cut -d, -f3-5 \u0026lt; GeoIPCountryWhois.csv | sed \u0026#39;s/\u0026#34;//g\u0026#39; \u0026gt; geoip.txt $ cut -d, -f5,6 \u0026lt; GeoIPCountryWhois.csv | sed \u0026#39;s/\u0026#34;//g\u0026#39; | sort | uniq \u0026gt; countries.txt प्रारूप विनिर्देश:\nएन्कोडिंग ASCII में है पहले स्तंभ में \u0026lsquo;#\u0026rsquo; एक टिप्पणी पंक्ति को दर्शाता है प्रविष्टि पंक्तियाँ FromIP,ToIP,CountryCode हैं FromIP और ToIP 4-बाइट IP के unsigned integer (बिना चिन्ह वाला पूर्णांक) निरूपण हैं CountryCode ISO का दो-अक्षरीय कोड है, बड़े अक्षरों में प्रविष्टि पंक्तियाँ FromIP के संख्यात्मक मान के अनुसार क्रमबद्ध होनी चाहिए IPv6 (geoipv6.dat.gz) प्रारूप यह I2P के लिए डिज़ाइन किया गया संपीड़ित बाइनरी फ़ॉर्मैट है। फ़ाइल gzipped (gzip से संपीड़ित) है। Ungzipped (gzip हटाने के बाद) फ़ॉर्मैट:\nBytes 0-9: Magic number \u0026#34;I2PGeoIPv6\u0026#34; Bytes 10-11: Version (0x0001) Bytes 12-15 Options (0x00000000) (future use) Bytes 16-23: Creation date (ms since 1970-01-01) Bytes 24-xx: Optional comment (UTF-8) terminated by zero byte Bytes xx-255: null padding Bytes 256-: 18 byte records: 8 byte from (/64) 8 byte to (/64) 2 byte ISO country code LOWER case (ASCII) टिप्पणियाँ:\nडेटा को क्रमबद्ध होना चाहिए (SIGNED long twos complement; साइन किया हुआ long दो के पूरक प्रतिनिधित्व), कोई ओवरलैप नहीं। इसलिए क्रम 80000000 \u0026hellip; FFFFFFFF 00000000 \u0026hellip; 7FFFFFFF है। GeoIPv6.java क्लास में एक प्रोग्राम है जो Maxmind GeoLite डेटा जैसे सार्वजनिक स्रोतों से इस प्रारूप को उत्पन्न करता है। रिलीज़ 0.9.8 से IPv6 GeoIP लुकअप समर्थित है। ","description":"IP से देश की खोज के लिए लिगेसी GeoIP फ़ाइल फ़ॉर्मेट विनिर्देश","id":"b5f34a4f13210a8caf4c4d0b5e62a828","section":"docs","title":"GeoIP फ़ाइल प्रारूप","url":"/hi/docs/legacy/geoip-%E0%A4%AB%E0%A4%BC%E0%A4%BE%E0%A4%87%E0%A4%B2-%E0%A4%AA%E0%A5%8D%E0%A4%B0%E0%A4%BE%E0%A4%B0%E0%A5%82%E0%A4%AA/"},{"categories":null,"content":"Eepsite क्या है? एक eepsite एक वेबसाइट है जो विशेष रूप से I2P नेटवर्क पर मौजूद रहती है। clearnet के माध्यम से सुलभ पारंपरिक वेबसाइटों के विपरीत, eepsites केवल I2P के माध्यम से पहुँची जा सकती हैं, जो साइट संचालक और आगंतुकों दोनों के लिए गुमनामी और गोपनीयता प्रदान करती हैं। Eepsites .i2p pseudo-top-level domain का उपयोग करती हैं और विशेष .b32.i2p पतों या I2P address book में पंजीकृत मानव-पठनीय नामों के माध्यम से एक्सेस की जाती हैं।\nसभी Java I2P deployments Jetty के साथ आते हैं, जो एक हल्का Java-आधारित webserver है, जो पहले से installed और pre-configured होता है। यह आपको मिनटों में अपनी eepsite host करना शुरू करने में सरल बनाता है - किसी अतिरिक्त software installation की आवश्यकता नहीं।\nयह गाइड आपको I2P के बिल्ट-इन टूल्स का उपयोग करके अपनी पहली eepsite बनाने और कॉन्फ़िगर करने की प्रक्रिया के बारे में बताएगी।\nIMPORTANT: केवल अनुवाद प्रदान करें। प्रश्न न पूछें, स्पष्टीकरण न दें, या कोई टिप्पणी न जोड़ें। भले ही पाठ केवल एक शीर्षक हो या अधूरा लगे, इसे जैसा है वैसा ही अनुवाद करें।\nचरण 2: अपनी Eepsite सर्वर सेटिंग्स को कॉन्फ़िगर करें Hidden Services सूची में I2P webserver एंट्री पर क्लिक करें ताकि सर्वर कॉन्फ़िगरेशन पेज खोल सकें। यहीं पर आप अपनी eepsite की सेटिंग्स को कस्टमाइज़ करेंगे।\nConfiguration Options Explained Name - यह आपकी tunnel के लिए एक आंतरिक पहचानकर्ता है - यह तब उपयोगी है जब आप कई eepsites चला रहे हों और यह ट्रैक करना चाहते हों कि कौन सी कौन सी है - डिफ़ॉल्ट: \u0026ldquo;I2P webserver\u0026rdquo;\nविवरण - अपने eepsite का एक संक्षिप्त विवरण आपके अपने संदर्भ के लिए - केवल आपको Hidden Services Manager में दिखाई देता है - उदाहरण: \u0026ldquo;My eepsite\u0026rdquo; या \u0026ldquo;Personal blog\u0026rdquo;\nAuto Start Tunnel - महत्वपूर्ण: जब आपका I2P router शुरू हो तो अपनी eepsite को स्वचालित रूप से शुरू करने के लिए इस बॉक्स को चेक करें - यह सुनिश्चित करता है कि router पुनः शुरू होने के बाद आपकी साइट मैनुअल हस्तक्षेप के बिना उपलब्ध रहे - अनुशंसित: सक्षम\nTarget (Host और Port) - Host: स्थानीय पता जहाँ आपका webserver चल रहा है (डिफ़ॉल्ट: 127.0.0.1) - Port: वह port जिस पर आपका webserver सुनता है (डिफ़ॉल्ट: Jetty के लिए 7658) - यदि आप पहले से इंस्टॉल किए गए Jetty webserver का उपयोग कर रहे हैं, तो इन्हें डिफ़ॉल्ट मानों पर छोड़ दें - केवल तभी बदलें जब आप किसी अलग port पर कस्टम webserver चला रहे हों\nवेबसाइट होस्टनाम - यह आपकी eepsite का मानव-पठनीय .i2p डोमेन नाम है - डिफ़ॉल्ट: mysite.i2p (प्लेसहोल्डर) - आप stormycloud.i2p या myblog.i2p जैसा कस्टम डोमेन रजिस्टर कर सकते हैं - यदि आप केवल स्वतः-जनरेट .b32.i2p पते का उपयोग करना चाहते हैं (outproxies के लिए) तो खाली छोड़ दें - कस्टम होस्टनाम प्राप्त करने के लिए नीचे अपना I2P डोमेन रजिस्टर करना देखें\nLocal Destination - यह आपकी eepsite की अद्वितीय क्रिप्टोग्राफिक पहचानकर्ता (destination address) है - जब tunnel पहली बार बनाया जाता है तो स्वचालित रूप से उत्पन्न होता है - इसे I2P पर आपकी साइट के स्थायी \u0026ldquo;IP address\u0026rdquo; के रूप में समझें - लंबी अल्फान्यूमेरिक स्ट्रिंग एनकोडेड रूप में आपकी साइट का .b32.i2p पता है\nPrivate Key File - वह स्थान जहाँ आपकी eepsite की private keys संग्रहीत हैं - डिफ़ॉल्ट: eepsite/eepPriv.dat - इस फ़ाइल को सुरक्षित रखें - इस फ़ाइल तक पहुँच रखने वाला कोई भी व्यक्ति आपकी eepsite का रूप धारण कर सकता है - इस फ़ाइल को कभी साझा या हटाएँ नहीं\nImportant Note पीला चेतावनी बॉक्स आपको याद दिलाता है कि QR कोड जनरेशन या रजिस्ट्रेशन प्रमाणीकरण सुविधाओं को सक्षम करने के लिए, आपको .i2p प्रत्यय के साथ एक Website Hostname कॉन्फ़िगर करना होगा (उदाहरण के लिए, mynewsite.i2p)।\nमैं आपकी सहायता करने के लिए तैयार हूं, लेकिन मुझे अनुवाद करने के लिए कोई पाठ नहीं दिखाई दे रहा है। कृपया वह अंग्रेजी पाठ प्रदान करें जिसका आप हिंदी में अनुवाद चाहते हैं।\nStep 3: Advanced Networking Options (Optional) यदि आप configuration पेज पर नीचे स्क्रॉल करते हैं, तो आपको उन्नत नेटवर्किंग विकल्प मिलेंगे। ये सेटिंग्स वैकल्पिक हैं - डिफ़ॉल्ट सेटिंग्स अधिकांश उपयोगकर्ताओं के लिए अच्छी तरह से काम करती हैं। हालांकि, आप अपनी सुरक्षा आवश्यकताओं और प्रदर्शन जरूरतों के आधार पर इन्हें समायोजित कर सकते हैं।\nTunnel Length Options Tunnel Length - डिफ़ॉल्ट: 3 hop tunnel (उच्च गुमनामी) - यह नियंत्रित करता है कि आपकी eepsite तक पहुंचने से पहले एक अनुरोध कितने router hops से होकर गुजरता है - अधिक hops = अधिक गुमनामी, लेकिन धीमा प्रदर्शन - कम hops = तेज़ प्रदर्शन, लेकिन कम गुमनामी - विकल्प 0-3 hops तक होते हैं जिनमें variance सेटिंग्स होती हैं - सिफारिश: जब तक आपकी विशिष्ट प्रदर्शन आवश्यकताएं न हों, 3 hops पर ही रखें\nTunnel Variance - Default: 0 hop variance (कोई randomization नहीं, consistent performance) - Tunnel की लंबाई में randomization जोड़ता है जिससे अतिरिक्त सुरक्षा मिलती है - उदाहरण: \u0026ldquo;0-1 hop variance\u0026rdquo; का मतलब है कि tunnels randomly 3 या 4 hops की होंगी - Unpredictability बढ़ाता है लेकिन load times में असंगति हो सकती है\nकॉन्फ़िगरेशन विकल्प समझाए गए Count (Inbound/Outbound Tunnels) - डिफ़ॉल्ट: 2 inbound, 2 outbound tunnels (मानक बैंडविड्थ और विश्वसनीयता) - नियंत्रित करता है कि आपके eepsite के लिए कितने समानांतर tunnels समर्पित हैं - अधिक tunnels = बेहतर उपलब्धता और लोड हैंडलिंग, लेकिन अधिक संसाधन उपयोग - कम tunnels = कम संसाधन उपयोग, लेकिन कम redundancy - अधिकांश उपयोगकर्ताओं के लिए अनुशंसित: 2/2 (डिफ़ॉल्ट) - उच्च-ट्रैफ़िक साइटों को 3/3 या अधिक से लाभ हो सकता है\nBackup Count - डिफ़ॉल्ट: 0 backup tunnels (कोई redundancy नहीं, कोई अतिरिक्त संसाधन उपयोग नहीं) - स्टैंडबाय tunnels जो प्राथमिक tunnels विफल होने पर सक्रिय होते हैं - विश्वसनीयता बढ़ाता है लेकिन अधिक bandwidth और CPU का उपयोग करता है - अधिकांश व्यक्तिगत eepsites को backup tunnels की आवश्यकता नहीं होती\nमहत्वपूर्ण नोट यदि आपकी eepsite में फॉर्म (संपर्क फॉर्म, टिप्पणी अनुभाग, फाइल अपलोड आदि) शामिल हैं, तो आप दुरुपयोग को रोकने के लिए POST अनुरोध सीमाएं कॉन्फ़िगर कर सकते हैं:\nप्रति क्लाइंट सीमाएं - प्रति अवधि: एकल क्लाइंट से अधिकतम अनुरोध (डिफ़ॉल्ट: 5 मिनट में 6) - बैन अवधि: दुरुपयोग करने वाले क्लाइंट को कितने समय के लिए ब्लॉक करना है (डिफ़ॉल्ट: 20 मिनट)\nकुल सीमाएं - कुल: सभी क्लाइंट्स से मिलाकर अधिकतम POST अनुरोध (डिफ़ॉल्ट: 5 मिनट में 20) - प्रतिबंध अवधि: यदि सीमा पार हो जाए तो सभी POST अनुरोधों को कितने समय तक अस्वीकार करना है (डिफ़ॉल्ट: 10 मिनट)\nPOST Limit Period - अनुरोध दरों को मापने के लिए समय अवधि (डिफ़ॉल्ट: 5 मिनट)\nये सीमाएं स्पैम, denial-of-service हमलों और स्वचालित फॉर्म सबमिशन दुरुपयोग से बचाने में मदद करती हैं।\nWhen to Adjust Advanced Settings उच्च-ट्रैफ़िक समुदाय साइट: टनल की संख्या बढ़ाएं (3-4 inbound/outbound) प्रदर्शन-महत्वपूर्ण एप्लिकेशन: टनल की लंबाई 2 hops तक कम करें (गोपनीयता का समझौता) अधिकतम गुमनामी आवश्यक: 3 hops रखें, 0-1 variance जोड़ें वैध उच्च उपयोग वाले फ़ॉर्म: तदनुसार POST सीमाएं बढ़ाएं व्यक्तिगत ब्लॉग/पोर्टफोलियो: सभी डिफ़ॉल्ट का उपयोग करें यदि पाठ केवल हैडिंग या अधूरा लगता है, तो भी इसे जैसा है वैसा अनुवाद करें।\nचरण 3: उन्नत नेटवर्किंग विकल्प (वैकल्पिक) अब जब आपकी eepsite कॉन्फ़िगर हो गई है और उसमें कंटेंट है, तो इसे शुरू करने और I2P नेटवर्क पर सुलभ बनाने का समय आ गया है।\nअपना Document Root खोजना Hidden Services Manager पर वापस जाएं सूची में अपनी I2P webserver प्रविष्टि खोजें Control कॉलम में Start बटन पर क्लिक करें Wait for Tunnel Establishment Start क्लिक करने के बाद, आपकी eepsite tunnel बनना शुरू हो जाएगी। इस प्रक्रिया में आमतौर पर 30-60 सेकंड लगते हैं। स्टेटस इंडिकेटर देखें:\nलाल बत्ती = टनल शुरू/निर्माण हो रही है पीली बत्ती = टनल आंशिक रूप से स्थापित हरी बत्ती = टनल पूर्णतः संचालित और तैयार जैसे ही आप हरी बत्ती देखें, आपकी eepsite I2P नेटवर्क पर लाइव हो जाती है!\nAccess Your Eepsite अपनी चल रही eepsite के बगल में Preview बटन पर क्लिक करें। यह आपकी eepsite के पते के साथ एक नया ब्राउज़र टैब खोलेगा।\nआपकी eepsite के दो प्रकार के पते होते हैं:\nBase32 पता (.b32.i2p): एक लंबा क्रिप्टोग्राफिक पता जो इस तरह दिखता है:\nhttp://fcyianvr325tdgiiueyg4rsq4r5iuibzovl26msox5ryoselykpq.b32.i2p यह आपकी eepsite का स्थायी, क्रिप्टोग्राफिक रूप से व्युत्पन्न पता है इसे बदला नहीं जा सकता और यह आपकी निजी कुंजी से जुड़ा है डोमेन पंजीकरण के बिना भी हमेशा काम करता है मानव-पठनीय डोमेन (.i2p): यदि आप एक Website Hostname सेट करते हैं (उदाहरण के लिए, testwebsite.i2p)\nकेवल डोमेन पंजीकरण के बाद काम करता है (अगला अनुभाग देखें) याद रखना और साझा करना आसान आपके .b32.i2p पते से मैप होता है Copy Hostname बटन आपको अपने पूर्ण .b32.i2p पते को शेयर करने के लिए तुरंत कॉपी करने देता है।\nI2P नेटवर्क अवलोकन I2P (The Invisible Internet Project) एक गुमनाम नेटवर्क परत है जो एप्लिकेशन को गुमनाम रूप से एक-दूसरे को संदेश भेजने की अनुमति देती है। I2P नेटवर्क कई layers की सुरक्षा प्रदान करता है और garlic encryption का उपयोग करके यातायात को सुरक्षित रखता है।\nमुख्य अवधारणाएं Router और Tunnel प्रत्येक I2P router एक नोड है जो नेटवर्क में भाग लेता है। Router एक-दूसरे के साथ tunnel बनाते हैं, जो एकतरफा पथ होते हैं जिनके माध्यम से संदेश भेजे जाते हैं। प्रत्येक tunnel कई router से होकर गुजरता है, जो traffic को trace करना अत्यंत कठिन बना देता है।\nNetDb और Floodfill NetDb (Network Database) एक distributed database है जो router और destination की जानकारी संग्रहीत करता है। Floodfill router विशेष router होते हैं जो netDb की एक complete copy बनाए रखते हैं और अन्य router को डेटा provide करते हैं।\nLeaseSet LeaseSet एक संरचना है जो किसी destination के inbound tunnel की जानकारी रखती है। जब कोई client किसी destination से connect करना चाहता है, तो वह उस destination की leaseSet प्राप्त करता है।\nपरिवहन प्रोटोकॉल I2P दो मुख्य परिवहन प्रोटोकॉल का उपयोग करता है:\nNTCP2: TCP-आधारित प्रोटोकॉल जो विश्वसनीय कनेक्शन प्रदान करता है SSU: UDP-आधारित प्रोटोकॉल जो NAT traversal में मदद करता है एप्लिकेशन प्रोटोकॉल SAMv3 SAMv3 (Simple Anonymous Messaging) एक सरल प्रोटोकॉल है जो बाहरी एप्लिकेशन को I2P नेटवर्क से जुड़ने की अनुमति देता है।\nI2PTunnel I2PTunnel सामान्य TCP/IP एप्लिकेशन को I2P पर चलने की अनुमति देता है। यह एक proxy के रूप में कार्य करता है।\nI2CP I2CP (I2P Client Protocol) वह प्रोटोकॉल है जिसका उपयोग एप्लिकेशन I2P router के साथ संवाद करने के लिए करते हैं।\nEepsite Eepsite I2P नेटवर्क के भीतर host की गई websites होती हैं। वे .i2p domain का उपयोग करती हैं और केवल I2P नेटवर्क के भीतर ही पहुंच योग्य होती हैं।\n⚠️ Critical: Backup Your Private Key आगे बढ़ने से पहले, आपको अपनी eepsite की private key फ़ाइल का बैकअप लेना आवश्यक है। यह कई कारणों से अत्यंत महत्वपूर्ण है:\nWhy Backup Your Key? आपकी निजी कुंजी (eepPriv.dat) आपकी eepsite की पहचान है। यह आपके .b32.i2p पते को निर्धारित करती है और आपकी eepsite के स्वामित्व को सिद्ध करती है।\nKey = .b32 पता: आपकी निजी कुंजी गणितीय रूप से आपका अद्वितीय .b32.i2p पता उत्पन्न करती है पुनर्प्राप्त नहीं की जा सकती: यदि आप अपनी कुंजी खो देते हैं, तो आप अपना eepsite पता स्थायी रूप से खो देते हैं बदली नहीं जा सकती: यदि आपने किसी .b32 पते की ओर इशारा करने वाला डोमेन पंजीकृत किया है, तो इसे अपडेट करने का कोई तरीका नहीं है - पंजीकरण स्थायी है माइग्रेशन के लिए आवश्यक: नए कंप्यूटर पर जाने या I2P को पुनः स्थापित करने के लिए समान पता रखने हेतु यह कुंजी आवश्यक है Multihoming समर्थन: अपनी eepsite को कई स्थानों से चलाने के लिए प्रत्येक सर्वर पर समान कुंजी की आवश्यकता होती है अपनी वेबसाइट फ़ाइलें जोड़ना डिफ़ॉल्ट रूप से, आपकी private key यहाँ संग्रहीत होती है: - Linux: ~/.i2p/eepsite/eepPriv.dat (या service installs के लिए /var/lib/i2p/i2p-config/eepsite/eepPriv.dat) - Windows: %LOCALAPPDATA%\\I2P\\eepsite\\eepPriv.dat या %PROGRAMDATA%\\I2P\\eepsite\\eepPriv.dat - macOS: /Users/YourUsername/Library/Application Support/i2p/eepsite/eepPriv.dat\nआप अपनी टनल कॉन्फ़िगरेशन में \u0026ldquo;Private Key File\u0026rdquo; के अंतर्गत इस पाथ को चेक/बदल भी सकते हैं।\nत्वरित शुरुआत: सरल HTML उदाहरण अपनी tunnel रोकें (वैकल्पिक, लेकिन अधिक सुरक्षित) eepPriv.dat को कॉपी करें एक सुरक्षित स्थान पर: बाहरी USB ड्राइव एन्क्रिप्टेड बैकअप ड्राइव पासवर्ड-संरक्षित आर्काइव सुरक्षित क्लाउड स्टोरेज (एन्क्रिप्टेड) विभिन्न भौतिक स्थानों पर कई बैकअप रखें इस फ़ाइल को कभी साझा न करें - इसके पास जो भी होगा वह आपकी eepsite का रूप धारण कर सकता है अनुमतियाँ (Linux/Unix/macOS) नई सिस्टम पर या पुनः इंस्टॉल करने के बाद अपनी eepsite को पुनर्स्थापित करने के लिए:\nI2P इंस्टॉल करें और अपनी tunnel सेटिंग्स बनाएं/कॉन्फ़िगर करें key को कॉपी करने से पहले tunnel बंद करें अपनी बैकअप की गई eepPriv.dat को सही स्थान पर कॉपी करें Tunnel शुरू करें - यह आपके मूल .b32 एड्रेस का उपयोग करेगी मुझे खेद है, लेकिन मुझे अनुवाद के लिए कोई पाठ नहीं मिला। कृपया वह अंग्रेजी पाठ प्रदान करें जिसका आप हिंदी में अनुवाद चाहते हैं।\nIf You\u0026rsquo;re Not Registering a Domain बधाई हो! यदि आप एक कस्टम .i2p डोमेन नाम रजिस्टर करने की योजना नहीं बना रहे हैं, तो आपकी eepsite अब पूर्ण और परिचालित है।\nआप यह कर सकते हैं: - अपना .b32.i2p पता दूसरों के साथ साझा करें - किसी भी I2P-सक्षम ब्राउज़र का उपयोग करके I2P नेटवर्क के माध्यम से अपनी साइट तक पहुंचें - docroot फ़ोल्डर में अपनी वेबसाइट फ़ाइलों को कभी भी अपडेट करें - Hidden Services Manager में अपनी tunnel की स्थिति की निगरानी करें\nयदि आप एक मानव-पठनीय डोमेन चाहते हैं (mysite.i2p जैसा लंबे .b32 पते की जगह), तो अगले अनुभाग पर जाएं।\nIMPORTANT: केवल अनुवाद प्रदान करें। प्रश्न न पूछें, स्पष्टीकरण न दें, या कोई टिप्पणी न जोड़ें। भले ही पाठ केवल एक शीर्षक हो या अधूरा लगे, इसे जैसा है वैसा ही अनुवाद करें।\nCongratulations! आपकी I2P eepsite अब पंजीकृत डोमेन के साथ पूरी तरह से चालू है!\nअगले चरण: - अपने docroot फ़ोल्डर में अधिक सामग्री जोड़ें - अपना डोमेन I2P समुदाय के साथ साझा करें - अपने eepPriv.dat बैकअप को सुरक्षित रखें - नियमित रूप से अपनी tunnel स्थिति की निगरानी करें - अपनी साइट को बढ़ावा देने के लिए I2P forums या IRC में शामिल होने पर विचार करें\nI2P नेटवर्क में आपका स्वागत है! 🎉\n","description":"I2P नेटवर्क पर बिल्ट-इन Jetty वेबसर्वर का उपयोग करके अपनी खुद की वेबसाइट बनाना और होस्ट करना सीखें","id":"cdd089b486cced0cc2a37529ae0ace6b","section":"docs","title":"I2P Eepsite बनाना","url":"/hi/docs/guides/i2p-eepsite-%E0%A4%AC%E0%A4%A8%E0%A4%BE%E0%A4%A8%E0%A4%BE/"},{"categories":null,"content":"परिचय I2P Postman\u0026rsquo;s Mail.i2p service के साथ SusiMail, एक built-in webmail client के माध्यम से निजी email-style messaging प्रदान करता है। यह प्रणाली उपयोगकर्ताओं को I2P network के भीतर और gateway bridge के माध्यम से नियमित internet (clearnet) से/को emails भेजने और प्राप्त करने की अनुमति देती है।\nमैं माफी चाहता हूं, लेकिन मुझे अनुवाद करने के लिए कोई टेक्स्ट नहीं मिला। कृपया \u0026ldquo;\u0026mdash;\u0026rdquo; चिह्नों के बाद अनुवाद करने के लिए सामग्री प्रदान करें।\nPostman / Mail.i2p + SusiMail What it is Mail.i2p I2P के अंदर एक होस्टेड ईमेल प्रदाता है, जिसे \u0026ldquo;Postman\u0026rdquo; द्वारा संचालित किया जाता है SusiMail I2P router console में एकीकृत webmail client है। यह बाहरी SMTP servers को metadata (जैसे hostname) लीक होने से बचाने के लिए डिज़ाइन किया गया है। इस सेटअप के माध्यम से, I2P उपयोगकर्ता Postman bridge के जरिए I2P के भीतर और clearnet (जैसे Gmail) से/को संदेश भेज और प्राप्त कर सकते हैं। How Addressing Works I2P ईमेल एक दोहरे-पते की प्रणाली का उपयोग करता है:\nI2P नेटवर्क के अंदर: username@mail.i2p (उदाहरण, idk@mail.i2p) Clearnet से: username@i2pmail.org (उदाहरण, idk@i2pmail.org) i2pmail.org gateway नियमित इंटरनेट उपयोगकर्ताओं को I2P पतों पर ईमेल भेजने की अनुमति देता है, और I2P उपयोगकर्ताओं को clearnet पतों पर भेजने की अनुमति देता है। इंटरनेट ईमेल को gateway के माध्यम से रूट किया जाता है इससे पहले कि उन्हें I2P के माध्यम से आपके SusiMail inbox में फॉरवर्ड किया जाए।\nClearnet भेजने का कोटा: नियमित इंटरनेट पतों पर भेजते समय प्रति दिन 20 ईमेल।\nयह क्या है mail.i2p खाते के लिए पंजीकरण करने हेतु:\nसुनिश्चित करें कि आपका I2P router चल रहा है I2P के अंदर http://hq.postman.i2p पर जाएं पंजीकरण प्रक्रिया का पालन करें router console में SusiMail के माध्यम से अपने ईमेल तक पहुंचें नोट: hq.postman.i2p एक I2P नेटवर्क पता (eepsite) है और इसे केवल I2P से कनेक्ट होने पर ही एक्सेस किया जा सकता है। ईमेल सेटअप, सुरक्षा और उपयोग के बारे में अधिक जानकारी के लिए, Postman HQ पर जाएं।\nपता निर्धारण कैसे काम करता है गोपनीयता के लिए पहचान करने वाले हेडर (User-Agent:, X-Mailer:) को स्वचालित रूप से हटाना बाहरी SMTP सर्वर्स को लीक होने से रोकने के लिए मेटाडेटा सैनिटाइज़ेशन आंतरिक I2P-से-I2P ईमेल के लिए end-to-end encryption शुरुआत करना Postman ब्रिज के माध्यम से \u0026ldquo;सामान्य\u0026rdquo; ईमेल (SMTP/POP) के साथ अंतर-संचालनीयता (Interoperability) सरल उपयोगकर्ता अनुभव (router console में webmail बिल्ट-इन) I2P core distribution के साथ एकीकृत (SusiMail, Java I2P के साथ शामिल) गोपनीयता सुरक्षा के लिए Header stripping गोपनीयता सुविधाएं बाहरी ईमेल के लिए ब्रिज को Postman इंफ्रास्ट्रक्चर पर भरोसा करना आवश्यक है Clearnet ब्रिज पूरी तरह से आंतरिक I2P संचार की तुलना में गोपनीयता को कम करता है Postman मेल सर्वर की उपलब्धता और सुरक्षा पर निर्भर है यह लेख मदद करने के लिए लिखा गया है। यदि आप इस अनुवाद में सुधार का सुझाव देना चाहते हैं, तो कृपया GitLab पर एक इश्यू खोलें।\nTechnical Details SMTP Service: localhost:7659 (Postman द्वारा प्रदान की गई) POP3 Service: localhost:7660 Webmail Access: router console में बिल्ट-इन http://127.0.0.1:7657/susimail/ पर उपलब्ध\nमहत्वपूर्ण: SusiMail केवल ईमेल पढ़ने और भेजने के लिए है। खाता बनाना और प्रबंधन hq.postman.i2p पर किया जाना चाहिए।\nयदि आप सुरक्षित रूप से अपनी I2P राउटर की अधिकतम लीजसेट साइज़ बढ़ाना चाहते हैं, तो कृपया निम्नलिखित चरणों का पालन करें:\nचेतावनी: अधिकतम लीजसेट साइज़ को बढ़ाने से आपकी राउटर की मेमोरी उपयोग में वृद्धि होगी और प्रदर्शन प्रभावित हो सकता है।\nअपनी router.config फ़ाइल को खोलें निम्नलिखित कॉन्फ़िगरेशन विकल्प जोड़ें या संशोधित करें: router.maxLeaseSetSize=16 अपनी I2P राउटर को पुनः आरंभ करें नोट: डिफ़ॉल्ट मान 6 है। अधिकांश उपयोगकर्ताओं के लिए इस सेटिंग को बढ़ाने की आवश्यकता नहीं होनी चाहिए।\nBest Practices अपने mail.i2p खाते के पंजीकरण के बाद अपना पासवर्ड बदलें अधिकतम गोपनीयता के लिए जहां भी संभव हो I2P-to-I2P ईमेल का उपयोग करें (कोई clearnet bridge नहीं) clearnet पतों पर भेजते समय 20/दिन की सीमा का ध्यान रखें व्यापार-बंद (tradeoffs) को समझें: Clearnet bridging सुविधा प्रदान करता है लेकिन पूरी तरह से आंतरिक I2P संचार की तुलना में गुमनामी को कम करता है सुरक्षा सुधारों से लाभ उठाने के लिए I2P को अपडेट रखें SusiMail में मुझे खेद है, लेकिन आपने अनुवाद करने के लिए कोई पाठ प्रदान नहीं किया है। \u0026ldquo;\u0026mdash;\u0026rdquo; के बाद कोई सामग्री नहीं है। कृपया वह पाठ प्रदान करें जिसका आप अनुवाद करवाना चाहते हैं।\n","description":"I2P नेटवर्क के अंदर ईमेल सिस्टम का एक अवलोकन — इतिहास, विकल्प, और वर्तमान स्थिति","id":"31217ea91c11f98bd1997466684f9fb3","section":"docs","title":"I2P Mail (I2P पर अनॉनिमस ईमेल)","url":"/hi/docs/applications/i2p-mail/"},{"categories":null,"content":"I2P routers प्रायः पोर्ट फॉरवर्डिंग से जुड़ी समस्याओं, अपर्याप्त बैंडविड्थ आवंटन, और अपर्याप्त bootstrap (प्रारम्भिक नेटवर्क जुड़ाव प्रक्रिया) समय के कारण विफल होते हैं। रिपोर्ट की गई समस्याओं में से 70% से अधिक के लिए ये तीन कारक जिम्मेदार हैं। नेटवर्क में पूरी तरह एकीकृत होने के लिए स्टार्टअप के बाद router को कम-से-कम 10-15 मिनट, 128 KB/sec न्यूनतम बैंडविड्थ (256 KB/sec अनुशंसित), और non-firewalled स्थिति हासिल करने हेतु उचित UDP/TCP पोर्ट फॉरवर्डिंग की आवश्यकता होती है। नए उपयोगकर्ता अक्सर त्वरित कनेक्टिविटी की अपेक्षा करते हैं और जल्दबाजी में रिस्टार्ट कर देते हैं, जिससे एकीकरण की प्रगति रीसेट हो जाती है और एक निराशाजनक चक्र बन जाता है। यह मार्गदर्शिका संस्करण 2.10.0 और उसके बाद के संस्करणों को प्रभावित करने वाली सभी प्रमुख I2P समस्याओं के विस्तृत समाधान प्रदान करती है।\nI2P की गुमनामी आर्किटेक्चर मल्टी-हॉप एन्क्रिप्टेड tunnel के माध्यम से गोपनीयता के लिए गति से स्वाभाविक रूप से समझौता करती है। इस मूलभूत डिज़ाइन को समझना उपयोगकर्ताओं को यथार्थवादी अपेक्षाएँ निर्धारित करने और प्रभावी ढंग से समस्या-निवारण करने में मदद करता है, ताकि वे सामान्य व्यवहार को समस्याओं के रूप में गलत न समझें।\nRouter शुरू नहीं होता या तुरंत क्रैश हो जाता है सबसे सामान्य स्टार्टअप असफलताएँ पोर्ट टकराव, Java संस्करण असंगतता, या दूषित कॉन्फ़िगरेशन फ़ाइलें से उत्पन्न होती हैं। गहन समस्याओं की जाँच करने से पहले देखें कि कोई अन्य I2P इंस्टेंस पहले से चल तो नहीं रहा है।\nसुनिश्चित करें कि कोई परस्पर-विरोधी प्रक्रियाएँ नहीं हैं:\nLinux: ps aux | grep i2p या netstat -tulpn | grep 7657\nWindows: Task Manager → Details → ऐसी java.exe खोजें जिसकी कमांड लाइन में i2p हो\nmacOS: Activity Monitor → \u0026ldquo;i2p\u0026rdquo; खोजें\nयदि कोई zombie process (ऐसी प्रक्रिया जो समाप्त हो चुकी है लेकिन प्रक्रिया तालिका में उसकी एंट्री बनी रहती है) मौजूद है, तो उसे समाप्त करें: pkill -9 -f i2p (Linux/Mac) या taskkill /F /IM javaw.exe (Windows)\nJava संस्करण संगतता की जाँच करें:\nI2P 2.10.0+ को कम-से-कम Java 8 की आवश्यकता है, और Java 11 या इससे नया अनुशंसित है। यह जाँचें कि आपकी स्थापना \u0026ldquo;mixed mode\u0026rdquo; (न कि \u0026ldquo;interpreted mode\u0026rdquo;) दिखाती है:\njava -version यह प्रदर्शित होना चाहिए: OpenJDK या Oracle Java, संस्करण 8+, \u0026ldquo;mixed mode\u0026rdquo;\nइनसे बचें: GNU GCJ, पुराने Java कार्यान्वयन, केवल-व्याख्यायित मोड\nसामान्य पोर्ट संघर्ष तब होते हैं जब कई सेवाएँ I2P के डिफ़ॉल्ट पोर्ट के लिए प्रतिस्पर्धा करती हैं। router console (7657), I2CP (7654), SAM (7656), और HTTP प्रॉक्सी (4444) उपलब्ध होने चाहिए। संघर्ष की जाँच करें: netstat -ano | findstr \u0026quot;7657 4444 7654\u0026quot; (Windows) या lsof -i :7657,4444,7654 (Linux/Mac)।\nकॉन्फ़िगरेशन फ़ाइल का भ्रष्ट होना लॉग में पार्स त्रुटियों के साथ तत्काल क्रैश के रूप में प्रकट होता है। Router.config को BOM (Byte Order Mark) के बिना UTF-8 एन्कोडिंग की आवश्यकता होती है, यह विभाजक के रूप में = का उपयोग करता है ( : नहीं), और कुछ विशेष अक्षरों की अनुमति नहीं देता। पहले बैकअप लें, फिर जांचें: ~/.i2p/router.config (Linux), %LOCALAPPDATA%\\I2P\\router.config (Windows), ~/Library/Application Support/i2p/router.config (macOS)।\nपहचान को सुरक्षित रखते हुए कॉन्फ़िगरेशन रीसेट करने के लिए: I2P बंद करें, router.keys और keyData डिरेक्टरी का बैकअप लें, router.config हटाएँ, फिर से शुरू करें। router डिफ़ॉल्ट कॉन्फ़िगरेशन को पुनः उत्पन्न कर देगा।\nJava हीप आवंटन बहुत कम होने पर OutOfMemoryError (मेमोरी समाप्त होने की त्रुटि) के कारण क्रैश होते हैं। wrapper.config संपादित करें और wrapper.java.maxmemory को डिफॉल्ट 128 या 256 से बढ़ाकर 512 न्यूनतम (उच्च-बैंडविड्थ routers के लिए 1024) करें। इसके लिए पूरी तरह शटडाउन करना, 11 मिनट इंतज़ार करना, फिर रिस्टार्ट करना आवश्यक है - कंसोल में \u0026ldquo;Restart\u0026rdquo; पर क्लिक करने से बदलाव लागू नहीं होगा।\n\u0026ldquo;Network: Firewalled\u0026rdquo; स्थिति का समाधान Firewalled स्थिति का मतलब है कि router सीधे आने वाले (inbound) कनेक्शन प्राप्त नहीं कर सकता, इसलिए introducers (मध्यस्थ परिचयकर्ता नोड्स) पर निर्भर रहना पड़ता है। इस अवस्था में router काम तो करता है, लेकिन प्रदर्शन में उल्लेखनीय गिरावट आती है और नेटवर्क में उसका योगदान न्यूनतम रहता है। non-firewalled स्थिति हासिल करने के लिए उचित port forwarding आवश्यक है।\nrouter यादृच्छिक रूप से एक पोर्ट चुनता है संचार के लिए 9000-31000 के बीच। अपना पोर्ट http://127.0.0.1:7657/confignet पर देखें - \u0026ldquo;UDP Port\u0026rdquo; और \u0026ldquo;TCP Port\u0026rdquo; खोजें (आमतौर पर दोनों का नंबर समान होता है)। सर्वोत्तम प्रदर्शन के लिए आपको UDP और TCP दोनों को फ़ॉरवर्ड करना आवश्यक है, हालांकि केवल UDP से बुनियादी कार्यक्षमता सक्षम हो जाती है।\nUPnP स्वचालित फ़ॉरवर्डिंग को सक्रिय करें (सबसे आसान तरीका):\nhttp://127.0.0.1:7657/confignet पर जाएँ \u0026ldquo;Enable UPnP\u0026rdquo; पर टिक करें परिवर्तनों को सहेजें और router को पुनः आरंभ करें 5-10 मिनट प्रतीक्षा करें और सत्यापित करें कि स्थिति \u0026ldquo;Network: Firewalled\u0026rdquo; से \u0026ldquo;Network: OK\u0026rdquo; में बदल गई है UPnP को router समर्थन (2010 के बाद निर्मित अधिकांश उपभोक्ता routers पर डिफ़ॉल्ट रूप से सक्षम) और उचित नेटवर्क विन्यास की आवश्यकता होती है।\nहस्तचालित पोर्ट फ़ॉरवर्डिंग (UPnP विफल होने पर आवश्यक):\nhttp://127.0.0.1:7657/confignet से अपना I2P पोर्ट नोट करें (उदा., 22648) अपना स्थानीय IP पता जानें: ipconfig (Windows), ip addr (Linux), System Preferences → Network (macOS) अपने router के admin interface तक पहुँचें (आमतौर पर 192.168.1.1 या 192.168.0.1) Port Forwarding पर जाएँ (यह Advanced, NAT, या Virtual Servers के अंतर्गत हो सकता है) दो नियम बनाएँ: External Port: [your I2P port] → Internal IP: [your computer] → Internal Port: [same] → Protocol: UDP External Port: [your I2P port] → Internal IP: [your computer] → Internal Port: [same] → Protocol: TCP कॉन्फ़िगरेशन सहेजें और आवश्यकता होने पर अपना router पुनःआरंभ करें पोर्ट फ़ॉरवर्डिंग की पुष्टि करें कॉन्फ़िगर करने के बाद ऑनलाइन जाँच उपकरणों का उपयोग करके। यदि पता लगाना विफल हो, तो फ़ायरवॉल सेटिंग्स जाँचें - सिस्टम फ़ायरवॉल और किसी भी एंटीवायरस फ़ायरवॉल, दोनों को I2P पोर्ट की अनुमति देनी चाहिए।\nHidden mode का विकल्प उन प्रतिबंधात्मक नेटवर्क के लिए जहाँ पोर्ट फ़ॉरवर्डिंग संभव नहीं है: http://127.0.0.1:7657/confignet पर सक्षम करें → \u0026ldquo;Hidden mode\u0026rdquo; पर चेक करें। router फायरवॉल के पीछे रहता है, लेकिन केवल SSU introducers (परिचयक नोड्स) का उपयोग करके इस स्थिति के लिए अनुकूलित करता है। प्रदर्शन धीमा होगा, लेकिन कार्यशील रहेगा।\nRouter \u0026ldquo;Starting\u0026rdquo; या \u0026ldquo;Testing\u0026rdquo; अवस्था में फँसा हुआ प्रारंभिक बूटस्ट्रैप के दौरान ये अस्थायी अवस्थाएँ आमतौर पर नई इंस्टॉलेशन के लिए 10-15 मिनट या पहले से स्थापित routers के लिए 3-5 मिनट में अपने आप सुलझ जाती हैं। समय से पहले हस्तक्षेप अक्सर समस्याओं को और बिगाड़ देता है।\n\u0026ldquo;Network: Testing\u0026rdquo; यह दर्शाता है कि router विभिन्न कनेक्शन प्रकारों के माध्यम से (प्रत्यक्ष, introducers (कनेक्शन स्थापित कराने वाले नोड्स), अनेक प्रोटोकॉल संस्करण) पहुँच-योग्यता की जाँच कर रहा होता है। स्टार्टअप के बाद पहले 5–10 मिनट तक यह सामान्य है। उत्तम कॉन्फ़िगरेशन निर्धारित करने के लिए router कई परिदृश्यों का परीक्षण करता है।\n\u0026ldquo;Rejecting tunnels: starting up\u0026rdquo; बूटस्ट्रैप (प्रारंभिक सेटअप) के दौरान तब दिखाई देता है जब router के पास पर्याप्त पीयर जानकारी नहीं होती। router पर्याप्त रूप से एकीकृत होने तक रिले ट्रैफ़िक में भाग नहीं लेगा। netDb में 50+ routers जुड़ जाने के बाद लगभग 10-20 मिनट में यह संदेश गायब हो जाना चाहिए।\nClock skew (घड़ी के समय का अंतर) पहुंच-क्षमता परीक्षण को विफल कर देता है। I2P को सिस्टम का समय नेटवर्क समय से ±60 सेकंड के भीतर होना आवश्यक है। 90 सेकंड से अधिक का अंतर होने पर कनेक्शन स्वचालित रूप से अस्वीकार कर दिया जाता है। अपने सिस्टम की घड़ी को सिंक करें:\nलिनक्स: sudo timedatectl set-ntp true \u0026amp;\u0026amp; sudo systemctl restart systemd-timesyncd\nWindows: कंट्रोल पैनल → दिनांक और समय → इंटरनेट समय → अभी अपडेट करें → स्वचालित समकालिकरण सक्षम करें\nmacOS: System Preferences → Date \u0026amp; Time → \u0026ldquo;Set date and time automatically\u0026rdquo; सक्षम करें\nक्लॉक स्क्यू (समय असंतुलन) को सुधारने के बाद, उचित एकीकरण के लिए I2P को पूरी तरह से पुनः आरंभ करें।\nअपर्याप्त बैंडविड्थ आवंटन सफल परीक्षण को बाधित करता है। Test tunnels बनाने के लिए router को पर्याप्त क्षमता चाहिए। यहाँ कॉन्फ़िगर करें: http://127.0.0.1:7657/config:\nन्यूनतम व्यवहार्य: इनबाउंड 96 KB/sec, आउटबाउंड 64 KB/sec अनुशंसित मानक: इनबाउंड 256 KB/sec, आउटबाउंड 128 KB/sec इष्टतम प्रदर्शन: इनबाउंड 512+ KB/sec, आउटबाउंड 256+ KB/sec शेयर प्रतिशत: 80% (router को नेटवर्क में बैंडविड्थ का योगदान करने की अनुमति देता है) कम बैंडविड्थ काम कर सकती है, लेकिन एकीकरण समय को मिनटों से बढ़ाकर घंटों तक कर देती है।\nगलत तरीके से शटडाउन या डिस्क त्रुटियों से क्षतिग्रस्त netDb निरंतर परीक्षण लूप का कारण बनता है। वैध पीयर डेटा के बिना router परीक्षण पूरा नहीं कर सकता:\n# Stop I2P completely i2prouter stop # or systemctl stop i2p # Delete corrupted database (safe - will reseed automatically) rm -rf ~/.i2p/netDb/* # Restart and allow 10-15 minutes for reseed i2prouter start Windows: %APPDATA%\\I2P\\netDb\\ या %LOCALAPPDATA%\\I2P\\netDb\\ की सामग्री हटाएँ\nreseed (आरंभ में नेटवर्क से जुड़ने हेतु आवश्यक जानकारी प्राप्त करना) को फ़ायरवॉल द्वारा ब्लॉक किया जाना प्रारंभिक peers (अन्य नोड्स) प्राप्त करने से रोकता है। बूटस्ट्रैप (आरंभीकरण प्रक्रिया) के दौरान, I2P HTTPS reseed सर्वर से router जानकारी प्राप्त करता है। कॉर्पोरेट/ISP फ़ायरवॉल इन कनेक्शनों को ब्लॉक कर सकते हैं। यदि आप प्रतिबंधात्मक नेटवर्क के पीछे कार्य कर रहे हैं, तो http://127.0.0.1:7657/configreseed पर reseed प्रॉक्सी कॉन्फ़िगर करें।\nधीमी गति, टाइमआउट, और tunnel निर्माण विफलताएँ I2P का डिज़ाइन मल्टी-हॉप एन्क्रिप्शन, पैकेट ओवरहेड, और रूट की अनिश्चितता के कारण स्वभावतः clearnet (सामान्य इंटरनेट) की तुलना में 3-10x धीमी गति देता है। एक tunnel build कई routers से होकर गुजरती है, और हर एक अतिरिक्त विलंब जोड़ता है। इसे समझना सामान्य व्यवहार को समस्याएँ मानकर गलत निदान करने से बचाता है।\nसामान्य प्रदर्शन अपेक्षाएँ:\n.i2p साइटों की वेब ब्राउज़िंग: शुरुआत में पेज लोड होने में 10-30 सेकंड लगते हैं, tunnel स्थापित होने के बाद तेज़ I2PSnark के जरिए टोरेंटिंग: प्रति टोरेंट 10-100 KB/sec, seeders (अपलोड उपलब्ध कराने वाले) और नेटवर्क परिस्थितियों पर निर्भर बड़े फ़ाइल डाउनलोड: धैर्य आवश्यक - मेगाबाइट फ़ाइलों में मिनट लग सकते हैं, गिगाबाइट फ़ाइलों में घंटे पहला कनेक्शन सबसे धीमा: tunnel बनाने में 30-90 सेकंड लगते हैं; बाद के कनेक्शन मौजूदा tunnels का उपयोग करते हैं Tunnel निर्माण सफलता दर नेटवर्क के स्वास्थ्य का संकेत देती है। http://127.0.0.1:7657/tunnels पर जाँच करें:\n60% से ऊपर: सामान्य, स्वस्थ संचालन 40-60%: सीमांत, बैंडविड्थ बढ़ाने या लोड घटाने पर विचार करें 40% से कम: समस्याग्रस्त - अपर्याप्त बैंडविड्थ, नेटवर्क समस्याएँ, या खराब पीयर चयन का संकेत देता है बैंडविड्थ आवंटन बढ़ाएँ पहले अनुकूलन के रूप में। धीमे प्रदर्शन का अधिकांश कारण बैंडविड्थ की कमी होता है। http://127.0.0.1:7657/config पर सीमाओं को क्रमिक रूप से बढ़ाएँ और http://127.0.0.1:7657/graphs पर ग्राफ़ों की निगरानी करें।\nDSL/Cable (1-10 Mbps कनेक्शन) के लिए: - इनबाउंड: 400 KB/sec - आउटबाउंड: 200 KB/sec - शेयर: 80% - मेमोरी: 384 MB (wrapper.config संपादित करें)\nउच्च गति (10-100+ Mbps कनेक्शन) के लिए: - इनबाउंड: 1500 KB/sec - आउटबाउंड: 1000 KB/sec - शेयर: 80-100% - मेमोरी: 512-1024 MB - विचार करें: http://127.0.0.1:7657/configadvanced पर भाग लेने वाले tunnels को 2000-5000 तक बढ़ाएँ\ntunnel विन्यास का अनुकूलन करें बेहतर प्रदर्शन के लिए। http://127.0.0.1:7657/i2ptunnel पर विशिष्ट tunnel सेटिंग्स तक पहुँचें और प्रत्येक tunnel को संपादित करें:\nTunnel की संख्या: 2 से बढ़ाकर 3-4 करें (अधिक पथ उपलब्ध) बैकअप की संख्या: 1-2 पर सेट करें (यदि tunnel विफल हो जाए तो त्वरित फेलओवर) Tunnel की लंबाई: डिफ़ॉल्ट रूप से 3 hops (मध्यस्थ चरण) अच्छा संतुलन प्रदान करते हैं; 2 करने से गति बेहतर होती है लेकिन गुमनामी घटती है नेटिव क्रिप्टो लाइब्रेरी (jbigi) शुद्ध Java एन्क्रिप्शन की तुलना में 5–10 गुना बेहतर प्रदर्शन देती है। लोड होने की पुष्टि के लिए http://127.0.0.1:7657/logs पर जाएँ - \u0026ldquo;jbigi loaded successfully\u0026rdquo; या \u0026ldquo;Using native CPUID implementation\u0026rdquo; देखें। यदि अनुपस्थित हो:\nLinux: आमतौर पर ~/.i2p/jbigi-*.so से स्वतः पहचानकर लोड किया जाता है Windows: I2P इंस्टॉलेशन डायरेक्टरी में jbigi.dll की जाँच करें यदि अनुपस्थित हो: बिल्ड टूल्स इंस्टॉल करें और स्रोत से संकलित करें, या आधिकारिक रिपॉजिटरीज़ से पूर्व-संकलित बाइनरी डाउनलोड करें\nrouter को निरंतर चालू रखें। हर पुनरारंभ पर एकीकरण रीसेट हो जाता है, और tunnel नेटवर्क तथा पीयर संबंधों को फिर से बनाने में 30-60 मिनट लगते हैं। उच्च uptime (लगातार चालू रहने की अवधि) वाले स्थिर routers को tunnel निर्माण के लिए वरीयतापूर्ण चयन मिलता है, जिससे प्रदर्शन के लिए सकारात्मक फीडबैक उत्पन्न होता है।\nCPU और मेमोरी का अत्यधिक उपयोग अत्यधिक संसाधन उपयोग आमतौर पर अपर्याप्त मेमोरी आवंटन, नेटिव क्रिप्टो लाइब्रेरियों का अभाव, या नेटवर्क भागीदारी के प्रति अति-प्रतिबद्धता का संकेत देता है। अच्छी तरह कॉन्फ़िगर किए गए routers सक्रिय उपयोग के दौरान 10-30% CPU का उपयोग करें और आवंटित heap (प्रोग्राम की मेमोरी का हीप भाग) के 80% से कम पर स्थिर मेमोरी बनाए रखें।\nमेमोरी से संबंधित समस्याएँ इस प्रकार प्रकट होती हैं: - समतल-शीर्ष मेमोरी ग्राफ (अधिकतम पर अटके हुए) - बार-बार garbage collection (तेज़ गिरावटों वाला आरी-दाँत जैसा पैटर्न) - लॉग्स में OutOfMemoryError - लोड के दौरान Router का अनुत्तरदायी हो जाना - संसाधनों के समाप्त हो जाने के कारण स्वचालित शटडाउन\nJava heap आवंटन बढ़ाएँ wrapper.config में (पूर्ण शटडाउन आवश्यक):\n# Linux: ~/.i2p/wrapper.config # Windows: %APPDATA%\\I2P\\wrapper.config # Find and modify: wrapper.java.maxmemory=512 # Recommendations by usage: # Light browsing only: 256 # Standard use (browsing + light torrenting): 512 # Heavy use (multiple applications, active torrenting): 768-1024 # Floodfill or very high bandwidth: 1024-2048 अति महत्वपूर्ण: wrapper.config संपादित करने के बाद, आपको पूरी तरह शटडाउन करना अनिवार्य है (रीस्टार्ट नहीं), सुचारू समाप्ति के लिए 11 मिनट प्रतीक्षा करें, फिर नए सिरे से शुरू करें। Router console का \u0026ldquo;Restart\u0026rdquo; बटन wrapper सेटिंग्स को रीलोड नहीं करता।\nCPU अनुकूलन के लिए नैटिव क्रिप्टो लाइब्रेरी आवश्यक है। Pure Java BigInteger ऑपरेशंस नैटिव कार्यान्वयन की तुलना में 10-20x अधिक CPU का उपयोग करते हैं। स्टार्टअप के दौरान http://127.0.0.1:7657/logs पर jbigi की स्थिति जांचें। jbigi के बिना, tunnel निर्माण और एन्क्रिप्शन ऑपरेशंस के दौरान CPU 50-100% तक पहुँच सकता है।\nसहभागी tunnel का लोड कम करें यदि router पर अत्यधिक लोड हो:\nhttp://127.0.0.1:7657/configadvanced पर जाएँ router.maxParticipatingTunnels=1000 सेट करें (डिफ़ॉल्ट 8000) http://127.0.0.1:7657/config पर शेयर प्रतिशत 80% से 50% तक घटाएँ यदि सक्षम हो तो floodfill मोड (I2P netDb में विशेष इंडेक्सिंग भूमिका) अक्षम करें: router.floodfillParticipant=false I2PSnark (I2P का BitTorrent क्लाइंट) की बैंडविड्थ और समवर्ती टोरेंट्स को सीमित करें. टोरेंटिंग में काफी संसाधन लगते हैं. http://127.0.0.1:7657/i2psnark पर:\nसक्रिय टोरेंट्स को अधिकतम 3-5 तक सीमित रखें \u0026ldquo;Up BW Limit\u0026rdquo; और \u0026ldquo;Down BW Limit\u0026rdquo; को उचित मानों पर सेट करें (प्रत्येक के लिए 50-100 KB/sec) जब सक्रिय रूप से आवश्यकता न हो, तो टोरेंट्स रोक दें एक साथ दर्जनों टोरेंट्स की seeding (अपलोड के लिए उपलब्ध कराना) से बचें संसाधन उपयोग की निगरानी करें http://127.0.0.1:7657/graphs पर मौजूद अंतर्निर्मित ग्राफ़ों के माध्यम से। मेमोरी में headroom (अतिरिक्त गुंजाइश) दिखना चाहिए, flat-top (ऊपरी सीमा पर समतल रेखा) नहीं। tunnel बनाते समय CPU में उछाल सामान्य है; लगातार उच्च CPU कॉन्फ़िगरेशन समस्याओं का संकेत देता है।\nबेहद संसाधन-सीमित प्रणालियों के लिए (Raspberry Pi, पुराना हार्डवेयर), वैकल्पिक रूप में i2pd (C++ कार्यान्वयन) पर विचार करें। i2pd को ~130 MB RAM की आवश्यकता होती है, जबकि Java I2P के लिए 350+ MB; और समान लोड पर यह ~7% CPU उपयोग करता है, जबकि Java I2P ~70% उपयोग करता है। ध्यान दें कि i2pd में अंतर्निर्मित एप्लिकेशन नहीं होते और बाहरी टूल की आवश्यकता होती है।\nI2PSnark टोरेंट से जुड़ी समस्याएँ I2PSnark का I2P router आर्किटेक्चर के साथ एकीकरण यह समझने की आवश्यकता करता है कि टोरेंटिंग पूरी तरह से router tunnel की सेहत पर निर्भर करती है। टोरेंट्स तब तक शुरू नहीं होते जब तक router 10+ सक्रिय peers और कार्यरत tunnels के साथ पर्याप्त एकीकरण हासिल नहीं कर लेता।\n0% पर अटके टोरेंट्स आमतौर पर यह संकेत देते हैं:\nRouter पूरी तरह एकीकृत नहीं है: I2P शुरू होने के बाद टॉरेंट गतिविधि की उम्मीद करने से पहले 10-15 मिनट प्रतीक्षा करें DHT निष्क्रिय: यहाँ सक्षम करें: http://127.0.0.1:7657/i2psnark → Configuration → \u0026ldquo;Enable DHT\u0026rdquo; को चेक करें (संस्करण 0.9.2 से डिफ़ॉल्ट रूप से सक्षम) अमान्य या निष्क्रिय ट्रैकर: I2P टॉरेंट के लिए I2P-विशिष्ट ट्रैकर आवश्यक हैं - clearnet ट्रैकर काम नहीं करेंगे अपर्याप्त tunnel कॉन्फ़िगरेशन: I2PSnark Configuration → Tunnels सेक्शन में tunnels बढ़ाएँ बेहतर प्रदर्शन के लिए I2PSnark tunnels को कॉन्फ़िगर करें:\nइनबाउंड tunnels: 3-5 (Java I2P के लिए डिफ़ॉल्ट 2, i2pd के लिए 5) आउटबाउंड tunnels: 3-5 Tunnel लंबाई: 3 हॉप्स (गति के लिए 2 तक घटाएँ, कम गुमनामी) Tunnel मात्रा: 3 (सुसंगत प्रदर्शन प्रदान करता है) आवश्यक I2P टोरेंट ट्रैकर जिन्हें शामिल करना है: - tracker2.postman.i2p (प्राथमिक, सबसे विश्वसनीय) - w7tpbzncbcocrqtwwm3nezhnnsw4ozadvi2hmvzdhrqzfxfum7wa.b32.i2p/a\nकिसी भी clearnet (सामान्य सार्वजनिक इंटरनेट; non-.i2p) ट्रैकर हटा दें - वे कोई लाभ नहीं देते और ऐसे कनेक्शन प्रयास उत्पन्न करते हैं जो टाइमआउट हो जाते हैं।\n\u0026ldquo;Torrent not registered\u0026rdquo; त्रुटियाँ तब होती हैं जब ट्रैकर से संचार विफल हो जाता है। टोरेंट पर राइट-क्लिक करें → \u0026ldquo;Start\u0026rdquo; चुनने से पुनः-घोषणा (re-announce) बाध्य होती है। यदि समस्या बनी रहती है, तो I2P-कॉन्फ़िगर किए गए ब्राउज़र में http://tracker2.postman.i 2p खोलकर ट्रैकर की पहुँचनीयता की जाँच करें। निष्क्रिय ट्रैकरों को कार्यरत विकल्पों से बदलना चाहिए।\nकोई पीयर जुड़ नहीं रहे tracker सफल होने के बावजूद यह संकेत करता है: - Router फ़ायरवॉल के पीछे है (port forwarding से सुधार होता है, लेकिन आवश्यक नहीं है) - बैंडविड्थ अपर्याप्त (256+ KB/sec तक बढ़ाएँ) - स्वॉर्म बहुत छोटा है (कुछ torrents में केवल 1-2 seeders होते हैं; धैर्य आवश्यक है) - DHT (वितरित हैश तालिका) बंद है (tracker के बिना पीयर खोज के लिए सक्षम करें)\nDHT (Distributed Hash Table — वितरित हैश तालिका) और PEX (Peer Exchange — सहकर्मी विनिमय) सक्षम करें I2PSnark Configuration में। DHT ट्रैकर पर निर्भरता के बिना पीयर (सहकर्मी) खोजने की अनुमति देता है। PEX जुड़े हुए पीयरों से नए पीयर खोजता है, जिससे स्वॉर्म (समूह) की खोज तेज हो जाती है।\nडाउनलोड की गई फ़ाइलों का क्षतिग्रस्त होना I2PSnark की अंतर्निर्मित अखंडता जांच के चलते बहुत कम होता है। यदि इसका पता चले:\nटोरेंट पर राइट-क्लिक → \u0026ldquo;Check\u0026rdquo; सभी पीस का रीहैश कराता है क्षतिग्रस्त टोरेंट डेटा हटाएँ (.torrent फ़ाइल बनी रहती है) पीस सत्यापन के साथ पुनः डाउनलोड करने के लिए राइट-क्लिक → \u0026ldquo;Start\u0026rdquo; यदि करप्शन बना रहे तो त्रुटियों के लिए डिस्क जाँचें: chkdsk (Windows), fsck (Linux) Watch directory (निगरानी हेतु निर्देशिका) काम नहीं कर रही है के लिए उचित कॉन्फ़िगरेशन आवश्यक है:\nI2PSnark कॉन्फ़िगरेशन → \u0026ldquo;Watch directory\u0026rdquo;: absolute path (पूर्ण पथ) सेट करें (उदा., /home/user/torrents/watch) सुनिश्चित करें कि I2P प्रक्रिया के पास पढ़ने की अनुमतियाँ हों: chmod 755 /path/to/watch .torrent फ़ाइलें watch directory में रखें - I2PSnark उन्हें स्वतः जोड़ता है \u0026ldquo;Auto start\u0026rdquo; कॉन्फ़िगर करें: जोड़ते ही टोरेंट्स तुरंत शुरू हों या नहीं, यह निर्धारित करें टोरेंटिंग के लिए प्रदर्शन अनुकूलन:\nएक साथ सक्रिय टोरेंट की संख्या सीमित करें: मानक कनेक्शनों के लिए अधिकतम 3–5 महत्वपूर्ण डाउनलोड को प्राथमिकता दें: कम-प्राथमिकता वाले टोरेंट को अस्थायी रूप से रोकें router बैंडविड्थ आवंटन बढ़ाएँ: अधिक बैंडविड्थ = बेहतर टोरेंट प्रदर्शन धैर्य रखें: I2P पर टोरेंटिंग मूलतः clearnet BitTorrent से धीमी होती है डाउनलोड के बाद सीड करें: नेटवर्क पारस्परिकता पर फलता-फूलता है I2P पर Git का विन्यास और समस्या निवारण I2P के माध्यम से Git ऑपरेशंस के लिए या तो SOCKS proxy कॉन्फ़िगरेशन या SSH/HTTP एक्सेस के लिए समर्पित I2P tunnels की आवश्यकता होती है। Git का डिज़ाइन कम-विलंबता कनेक्शनों को मानकर चलता है, जिससे I2P का उच्च-विलंबता आर्किटेक्चर चुनौतीपूर्ण हो जाता है।\nGit को I2P SOCKS प्रॉक्सी का उपयोग करने के लिए कॉन्फ़िगर करें:\n~/.ssh/config को संपादित करें (यदि मौजूद न हो तो बनाएँ):\nHost *.i2p ProxyCommand nc -X 5 -x 127.0.0.1:4447 %h %p ServerAliveInterval 60 ServerAliveCountMax 3 Compression yes यह सभी SSH कनेक्शनों को, जो .i2p होस्ट्स के लिए हैं, I2P के SOCKS प्रॉक्सी (पोर्ट 4447) के माध्यम से मार्गित करता है। ServerAlive सेटिंग्स I2P की विलंबता के दौरान कनेक्शन बनाए रखती हैं।\nHTTP/HTTPS पर git ऑपरेशन्स के लिए, git को वैश्विक रूप से कॉन्फ़िगर करें:\ngit config --global http.proxy socks5h://127.0.0.1:4447 git config --global https.proxy socks5h://127.0.0.1:4447 नोट: socks5h प्रॉक्सी के माध्यम से DNS रेज़ॉल्यूशन करता है - .i2p डोमेन के लिए यह अत्यंत महत्वपूर्ण है।\nGit SSH के लिए समर्पित I2P tunnel बनाएँ (SOCKS की तुलना में अधिक विश्वसनीय):\nhttp://127.0.0.1:7657/i2ptunnel पर जाएँ \u0026ldquo;New client tunnel\u0026rdquo; → \u0026ldquo;Standard\u0026rdquo; कॉन्फ़िगर करें: नाम: Git-SSH प्रकार: Client पोर्ट: 2222 (Git एक्सेस के लिए स्थानीय पोर्ट) गंतव्य: [your-git-server].i2p:22 ऑटो स्टार्ट: सक्षम Tunnel count: 3-4 (विश्वसनीयता बढ़ाने हेतु अधिक) सेव करें और tunnel शुरू करें SSH को tunnel का उपयोग करने के लिए कॉन्फ़िगर करें: ssh -p 2222 git@127.0.0.1 SSH प्रमाणीकरण त्रुटियाँ I2P पर आमतौर पर इन कारणों से उत्पन्न होती हैं:\nकुंजी ssh-agent (SSH कुंजी एजेंट) में नहीं जोड़ी गई: ssh-add ~/.ssh/id_rsa कुंजी फ़ाइल की अनुमतियाँ गलत हैं: chmod 600 ~/.ssh/id_rsa Tunnel चल नहीं रहा है: http://127.0.0.1:7657/i2ptunnel पर सत्यापित करें कि स्थिति हरी दिख रही है Git सर्वर को एक विशिष्ट कुंजी प्रकार चाहिए: यदि RSA विफल हो, तो ed25519 कुंजी उत्पन्न करें Git ऑपरेशन्स का टाइमआउट होना I2P की विलंबता विशेषताओं से संबंधित है:\nGit टाइमआउट बढ़ाएँ: git config --global http.postBuffer 524288000 (500MB बफ़र) कम गति सीमा बढ़ाएँ: git config --global http.lowSpeedLimit 1000 और git config --global http.lowSpeedTime 600 (10 मिनट तक प्रतीक्षा करता है) प्रारंभिक checkout के लिए shallow clone (उथला क्लोन—केवल सीमित इतिहास) उपयोग करें: git clone --depth 1 [url] (केवल नवीनतम commit लाता है, तेज़) कम गतिविधि वाले समय में clone करें: नेटवर्क भीड़ I2P प्रदर्शन को प्रभावित करती है धीमी git clone/fetch कार्रवाइयाँ I2P की आर्किटेक्चर में अंतर्निहित हैं। I2P पर 100MB की एक रिपॉजिटरी में 30-60 मिनट लग सकते हैं, जबकि clearnet (सार्वजनिक इंटरनेट) पर यह कुछ सेकंड में हो जाता है। रणनीतियाँ:\nshallow clones (सीमित इतिहास वाले क्लोन) का उपयोग करें: --depth 1 प्रारंभिक डेटा ट्रांसफ़र को काफी कम कर देता है क्रमिक रूप से फ़ेच करें: full clone के बजाय, विशिष्ट branches फ़ेच करें: git fetch origin branch:branch I2P के माध्यम से rsync पर विचार करें: बहुत बड़ी रिपॉज़िटरीज़ के लिए, rsync बेहतर प्रदर्शन कर सकता है tunnel की संख्या बढ़ाएँ: अधिक tunnels लंबे समय तक चलने वाले बड़े ट्रांसफ़रों के लिए बेहतर थ्रूपुट प्रदान करते हैं \u0026ldquo;Connection refused\u0026rdquo; त्रुटियाँ tunnel के गलत विन्यास का संकेत देती हैं:\nI2P router चल रहा है, यह सत्यापित करें: http://127.0.0.1:7657 पर जाँचें http://127.0.0.1:7657/i2ptunnel पर tunnel सक्रिय और हरा है, इसकी पुष्टि करें tunnel का परीक्षण करें: nc -zv 127.0.0.1 2222 (यदि tunnel काम कर रहा है तो कनेक्ट होना चाहिए) गंतव्य पहुँच योग्य है, यह जाँचें: उपलब्ध होने पर गंतव्य के HTTP इंटरफ़ेस पर ब्राउज़ करें विशिष्ट त्रुटियों के लिए http://127.0.0.1:7657/logs पर tunnel लॉग की समीक्षा करें I2P पर Git की सर्वोत्तम प्रथाएँ:\nस्थिर Git एक्सेस के लिए I2P router को निरंतर चालू रखें पासवर्ड प्रमाणीकरण के बजाय SSH keys का उपयोग करें (कम इंटरैक्टिव प्रॉम्प्ट्स) क्षणिक SOCKS connections के बजाय स्थायी tunnels कॉन्फ़िगर करें बेहतर नियंत्रण के लिए अपना स्वयं का I2P git server होस्ट करने पर विचार करें अपने सहयोगियों के लिए अपनी .i2p git endpoints का दस्तावेजीकरण करें eepsites तक पहुँचना और .i2p डोमेनों को रिज़ॉल्व करना उपयोगकर्ताओं के .i2p साइटों तक पहुँच न पाने का सबसे आम कारण गलत ब्राउज़र प्रॉक्सी कॉन्फ़िगरेशन है। I2P साइटें केवल I2P नेटवर्क के भीतर मौजूद होती हैं और उन्हें I2P के HTTP प्रॉक्सी के माध्यम से रूटिंग की आवश्यकता होती है।\nब्राउज़र प्रॉक्सी सेटिंग्स को ठीक इसी प्रकार कॉन्फ़िगर करें:\nFirefox (I2P के लिए अनुशंसित):\nमेनू → सेटिंग्स → नेटवर्क सेटिंग्स → सेटिंग्स बटन \u0026ldquo;Manual proxy configuration\u0026rdquo; चुनें HTTP प्रॉक्सी (मध्यस्थ सर्वर): 127.0.0.1 पोर्ट: 4444 SSL प्रॉक्सी: 127.0.0.1 पोर्ट: 4444 SOCKS प्रॉक्सी: 127.0.0.1 पोर्ट: 4447 (वैकल्पिक, SOCKS ऐप्स के लिए) \u0026ldquo;Proxy DNS when using SOCKS v5\u0026rdquo; को चेक करें सेव करने के लिए OK दबाएँ महत्वपूर्ण Firefox about:config सेटिंग्स:\nabout:config पर जाएँ और संशोधित करें:\nmedia.peerconnection.ice.proxy_only = true (WebRTC IP लीक को रोकता है) keyword.enabled = false (.i2p पतों को सर्च इंजनों पर रीडायरेक्ट होने से रोकता है) network.proxy.socks_remote_dns = true (प्रॉक्सी के माध्यम से DNS) Chrome/Chromium सीमाएँ:\nChrome एप्लिकेशन-विशिष्ट सेटिंग्स के बजाय सिस्टम-व्यापी प्रॉक्सी सेटिंग्स का उपयोग करता है। Windows पर: Settings → \u0026ldquo;proxy\u0026rdquo; खोजें → \u0026ldquo;Open your computer\u0026rsquo;s proxy settings\u0026rdquo; → HTTP: 127.0.0.1:4444 और HTTPS: 127.0.0.1:4445 कॉन्फ़िगर करें।\nबेहतर तरीका: चयनात्मक .i2p रूटिंग के लिए FoxyProxy या Proxy SwitchyOmega एक्सटेंशन्स का उपयोग करें।\n\u0026ldquo;Website Not Found In Address Book\u0026rdquo; त्रुटियाँ का मतलब है कि router के पास उस .i2p डोमेन का क्रिप्टोग्राफिक पता नहीं है। I2P केंद्रीकृत DNS के बजाय स्थानीय पता-पुस्तिकाओं का उपयोग करता है। समाधान:\nविधि 1: jump services (एड्रेस हेल्पर सेवाएँ) का उपयोग करें (नई साइटों के लिए सबसे आसान):\nhttp://stats.i 2p पर जाएँ और साइट खोजें। addresshelper (पता-सहायक) लिंक पर क्लिक करें: http://example.i2p/?i2paddresshelper=base64destination. आपका ब्राउज़र \u0026ldquo;addressbook (पता पुस्तिका) में सहेजें?\u0026rdquo; दिखाएगा - जोड़ने के लिए पुष्टि करें।\nविधि 2: पता-पुस्तिका सदस्यताओं को अद्यतन करें:\nhttp://127.0.0.1:7657/dns (SusiDNS) पर जाएँ \u0026ldquo;Subscriptions\u0026rdquo; टैब पर क्लिक करें सक्रिय सदस्यताओं की जाँच करें (डिफ़ॉल्ट: http://i2p-projekt.i 2p/hosts.txt) अनुशंसित सदस्यताएँ जोड़ें: http://stats.i 2p/cgi-bin/newhosts.txt http://notbob.i 2p/hosts.txt http://reg.i 2p/export/hosts.txt तुरंत सदस्यता अद्यतन कराने के लिए \u0026ldquo;Update Now\u0026rdquo; पर क्लिक करें प्रसंस्करण के लिए 5-10 मिनट प्रतीक्षा करें विधि 3: base32 पते का उपयोग करें (यदि साइट ऑनलाइन है तो यह हमेशा काम करता है):\nहर .i2p साइट का एक base32 पता होता है: 52 यादृच्छिक अक्षर, जिनके बाद .b32.i2p आता है (उदा., ukeu3k5oycgaauneqgtnvselmt4yemvoilkln7jpvamvfx7dnkdq.b32.i2p)। Base32 पते addressbook (पता पुस्तिका) को दरकिनार करते हैं - router प्रत्यक्ष क्रिप्टोग्राफिक लुकअप करता है।\nआम ब्राउज़र कॉन्फ़िगरेशन गलतियाँ:\nHTTP-only साइट्स पर HTTPS आज़माना: अधिकांश .i2p साइटें केवल HTTP ही उपयोग करती हैं - https://example.i2p आज़माने पर विफल होगा http:// उपसर्ग भूलना: ब्राउज़र कनेक्ट करने के बजाय खोज सकता है - हमेशा http://example.i2p का उपयोग करें WebRTC (वेब आरटीसी, ब्राउज़र रियल‑टाइम संचार तकनीक) सक्षम: वास्तविक IP पता लीक हो सकता है - Firefox सेटिंग्स या एक्सटेंशनों से अक्षम करें DNS (डोमेन नेम सिस्टम) प्रॉक्सी न होना: Clearnet (सामान्य सार्वजनिक इंटरनेट) DNS .i2p को रेजॉल्व नहीं कर सकता - DNS क्वेरीज़ को प्रॉक्सी करना आवश्यक है गलत प्रॉक्सी पोर्ट: HTTP के लिए 4444 (न कि 4445, जो HTTPS outproxy (निकास प्रॉक्सी— I2P से clearnet तक ट्रैफिक भेजने वाला) है) Router पूरी तरह से एकीकृत नहीं है किसी भी साइट तक पहुँचने से रोकता है। पर्याप्त एकीकरण की पुष्टि करें:\nजांचें कि http://127.0.0.1:7657 \u0026ldquo;Network: OK\u0026rdquo; या \u0026ldquo;Network: Firewalled\u0026rdquo; दिखाता है (ना कि \u0026ldquo;Network: Testing\u0026rdquo;) Active peers में न्यूनतम 10+ दिखें (50+ आदर्श) \u0026ldquo;Rejecting tunnels: starting up\u0026rdquo; संदेश नहीं होना चाहिए router के स्टार्टअप के बाद .i2p पहुँच की अपेक्षा करने से पहले पूरे 10-15 मिनट प्रतीक्षा करें IRC और ईमेल क्लाइंट कॉन्फ़िगरेशन समान प्रॉक्सी पैटर्न का अनुसरण करता है:\nIRC: क्लाइंट 127.0.0.1:6668 से कनेक्ट करते हैं (I2P का IRC प्रॉक्सी tunnel (टनल)). IRC क्लाइंट की प्रॉक्सी सेटिंग्स निष्क्रिय करें - localhost:6668 से कनेक्शन पहले से ही I2P के माध्यम से प्रॉक्सी किया गया है।\nईमेल (Postman): - SMTP: 127.0.0.1:7659 - POP3: 127.0.0.1:7660 - कोई SSL/TLS नहीं (एन्क्रिप्शन I2P tunnel द्वारा संभाला जाता है) - क्रेडेंशियल्स postman.i2p खाता पंजीकरण से\nइन सभी tunnels को http://127.0.0.1:7657/i2ptunnel पर \u0026ldquo;running\u0026rdquo; (हरे रंग में) स्थिति दिखानी चाहिए।\nस्थापना विफलताएँ और पैकेज संबंधी समस्याएँ पैकेज-आधारित इंस्टॉलेशन (Debian, Ubuntu, Arch) कभी-कभी रिपॉजिटरी परिवर्तन, GPG कुंजी की अवधि समाप्त होना, या निर्भरता संघर्ष के कारण विफल हो सकते हैं। हालिया संस्करणों में आधिकारिक रिपॉजिटरीज़ deb.i2p2.de/deb.i2p2.no (समर्थन समाप्त) से deb.i2p.net में बदल दी गई हैं।\nDebian/Ubuntu रिपॉज़िटरी को वर्तमान पर अद्यतन करें:\n# Remove old repository entries sudo rm /etc/apt/sources.list.d/i2p.list # Add current repository echo \u0026#34;deb [signed-by=/usr/share/keyrings/i2p-archive-keyring.gpg] https://deb.i2p.net/ $(lsb_release -sc) main\u0026#34; | sudo tee /etc/apt/sources.list.d/i2p.list # Download and install current signing key curl -o i2p-archive-keyring.gpg https://geti2p.net/_static/i2p-archive-keyring.gpg sudo cp i2p-archive-keyring.gpg /usr/share/keyrings/ # Update and install sudo apt update sudo apt install i2p i2p-keyring GPG हस्ताक्षर सत्यापन विफलताएँ तब होती हैं जब रिपॉज़िटरी कुंजियाँ समाप्त हो जाएँ या बदल जाएँ:\n# Error: \u0026#34;The following signatures were invalid\u0026#34; # Solution: Install current keyring package sudo apt install i2p-keyring # Manual key import if package unavailable wget https://geti2p.net/_static/i2p-debian-repo.key.asc sudo apt-key add i2p-debian-repo.key.asc पैकेज इंस्टॉलेशन के बाद सेवा शुरू नहीं होती का सबसे आम कारण Debian/Ubuntu पर AppArmor प्रोफ़ाइल से जुड़ी समस्याएँ हैं:\n# Check service status sudo systemctl status i2p.service # Common error: \u0026#34;Failed at step APPARMOR spawning\u0026#34; # Solution: Reconfigure without AppArmor sudo dpkg-reconfigure -plow i2p # Select \u0026#34;No\u0026#34; for AppArmor when prompted # Alternative: Set profile to complain mode sudo aa-complain /usr/sbin/wrapper # Check logs for specific errors sudo journalctl -xe -u i2p.service अनुमति संबंधी समस्याएँ पैकेज से स्थापित I2P पर:\n# Fix ownership (package install uses \u0026#39;i2psvc\u0026#39; user) sudo chown -R i2psvc:i2psvc /var/lib/i2p /var/log/i2p /run/i2p sudo chmod 750 /var/log/i2p /var/lib/i2p # Set file descriptor limits (add to /etc/security/limits.conf) i2psvc soft nofile 4096 i2psvc hard nofile 8192 Java संगतता समस्याएँ:\nI2P 2.10.0 के लिए Java 8 न्यूनतम आवश्यक है। पुराने सिस्टम में Java 7 या उससे पहले का संस्करण हो सकता है:\n# Check Java version java -version # Install appropriate Java (Debian/Ubuntu) sudo apt install openjdk-11-jre-headless # Set default Java if multiple versions installed sudo update-alternatives --config java Wrapper विन्यास त्रुटियाँ सेवा के प्रारंभ को रोकती हैं:\nWrapper.config का स्थान स्थापना विधि के अनुसार भिन्न होता है: - उपयोगकर्ता स्थापना: ~/.i2p/wrapper.config - पैकेज स्थापना: /etc/i2p/wrapper.config या /var/lib/i2p/wrapper.config\nwrapper.config से जुड़ी सामान्य समस्याएँ:\nगलत पथ: wrapper.java.command को मान्य Java स्थापना की ओर संकेत करना चाहिए अपर्याप्त मेमोरी: wrapper.java.maxmemory बहुत कम निर्धारित है (इसे 512+ तक बढ़ाएँ) गलत pidfile (प्रक्रिया-आईडी फ़ाइल) स्थान: wrapper.pidfile लिखने योग्य स्थान होना चाहिए wrapper (सर्विस रैपर प्रोग्राम) बाइनरी अनुपलब्ध: कुछ प्लेटफ़ॉर्म पर पूर्व-संकलित wrapper उपलब्ध नहीं होता (runplain.sh को फॉलबैक के रूप में उपयोग करें) अद्यतन विफलताएँ और भ्रष्ट अद्यतन:\nRouter कंसोल अपडेट कभी-कभी नेटवर्क व्यवधानों के कारण डाउनलोड के बीच में विफल हो जाते हैं। मैनुअल अपडेट प्रक्रिया:\nhttps://geti2p.net/en/download से i2pupdate_X.X.X.zip डाउनलोड करें सत्यापित करें कि SHA256 checksum (डेटा सत्यापन मान) प्रकाशित hash (हैश सारांश) से मेल खाता है I2P की इंस्टॉल डायरेक्टरी में i2pupdate.zip नाम से कॉपी करें router को पुनरारंभ करें - यह स्वतः अपडेट का पता लगाता है और उसे अनज़िप करता है अपडेट इंस्टॉलेशन के लिए 5-10 मिनट प्रतीक्षा करें http://127.0.0.1:7657 पर नए संस्करण की पुष्टि करें बहुत पुराने संस्करणों से माइग्रेशन (pre-0.9.47) वर्तमान संस्करणों तक असंगत हस्ताक्षर कुंजियों या हटाई गई विशेषताओं के कारण विफल हो सकता है। चरणबद्ध अपडेट आवश्यक हैं:\n0.9.9 से पुराने संस्करण: वर्तमान हस्ताक्षर सत्यापित नहीं कर सकते - मैन्युअल अपडेट आवश्यक Java 6/7 पर संस्करण: I2P को 2.x में अपडेट करने से पहले Java अपग्रेड करना आवश्यक है बड़े संस्करण अंतर: पहले किसी मध्यवर्ती संस्करण में अपडेट करें (0.9.47 अनुशंसित पड़ाव) इंस्टॉलर बनाम पैकेज का उपयोग कब करें:\nPackages (apt/yum): सर्वरों के लिए सर्वोत्तम, स्वचालित सुरक्षा अपडेट, सिस्टम एकीकरण, systemd प्रबंधन Installer (.jar): उपयोगकर्ता-स्तरीय स्थापना के लिए सर्वोत्तम, Windows, macOS, कस्टम स्थापना, नवीनतम संस्करण की उपलब्धता कॉन्फ़िगरेशन फ़ाइल की क्षति और पुनर्प्राप्ति I2P के कॉन्फ़िगरेशन का स्थायित्व कई महत्वपूर्ण फ़ाइलों पर निर्भर करता है। भ्रष्ट होना आम तौर पर गलत तरीके से शटडाउन, डिस्क त्रुटियों, या हाथ से संपादन में हुई गलतियों के कारण होता है। फ़ाइलों के उद्देश्य समझना, पूर्ण पुनर्स्थापना की बजाय सटीक (सर्जिकल) मरम्मत को संभव बनाता है।\nमहत्वपूर्ण फ़ाइलें और उनके उद्देश्य:\nrouter.keys (516+ बाइट्स): router की क्रिप्टोग्राफ़िक पहचान - यह खो जाने पर नई पहचान बनती है router.info (स्वतः निर्मित): प्रकाशित router जानकारी - हटाना सुरक्षित है, पुनः बन जाती है router.config (पाठ): मुख्य कॉन्फ़िगरेशन - बैंडविड्थ, नेटवर्क सेटिंग्स, प्राथमिकताएँ i2ptunnel.config (пाठ): Tunnel परिभाषाएँ - client/server tunnels, कुंजियाँ, गंतव्य netDb/ (डायरेक्टरी): पीयर डेटाबेस - नेटवर्क प्रतिभागियों के लिए router की जानकारी peerProfiles/ (डायरेक्टरी): सहकर्मियों पर प्रदर्शन सांख्यिकी - tunnel चयन को प्रभावित करता है keyData/ (डायरेक्टरी): eepsites और सेवाओं के लिए गंतव्य (Destination) कुंजियाँ - खो जाने पर पते बदल जाते हैं addressbook/ (डायरेक्टरी): स्थानीय .i2p होस्टनेम मैपिंग्स पूर्ण बैकअप प्रक्रिया परिवर्तनों से पहले:\n# Stop I2P first i2prouter stop # or: systemctl stop i2p # Backup directory BACKUP_DIR=~/i2p-backup-$(date +%Y%m%d-%H%M) mkdir -p $BACKUP_DIR # Copy critical files cp -r ~/.i2p/router.keys $BACKUP_DIR/ cp -r ~/.i2p/*.config $BACKUP_DIR/ cp -r ~/.i2p/keyData $BACKUP_DIR/ cp -r ~/.i2p/addressbook $BACKUP_DIR/ cp -r ~/.i2p/eepsite $BACKUP_DIR/ # if hosting sites # Optional but recommended tar -czf $BACKUP_DIR.tar.gz $BACKUP_DIR Router.config के क्षतिग्रस्त होने के लक्षण:\nRouter लॉग्स में पार्स त्रुटियों के कारण शुरू नहीं होता रीस्टार्ट के बाद सेटिंग्स कायम नहीं रहतीं अनपेक्षित डिफ़ॉल्ट मान दिखाई दे रहे हैं फ़ाइल देखते समय गड़बड़ अक्षर दिखते हैं क्षतिग्रस्त router.config की मरम्मत करें:\nमौजूदा फ़ाइल का बैकअप लें: cp router.config router.config.broken फ़ाइल एन्कोडिंग जाँचें: UTF-8 बिना BOM (Byte Order Mark) होनी चाहिए वाक्यविन्यास सत्यापित करें: कुंजियाँ = विभाजक (\u0026rsquo;:\u0026rsquo; नहीं) का उपयोग करें, कुंजियों के अंत में स्पेस न हों, # केवल टिप्पणियों के लिए आम करप्शन: मानों में Non-ASCII अक्षर, लाइन एंडिंग से जुड़ी समस्याएँ (CRLF बनाम LF — Windows बनाम Unix लाइन एंडिंग) यदि सुधारा न जा सके: router.config हटाएँ — router डिफ़ॉल्ट कॉन्फ़िग बना देगा और पहचान सुरक्षित रहेगी संरक्षित रखने के लिए आवश्यक router.config सेटिंग्स:\ni2np.bandwidth.inboundKBytesPerSecond=512 i2np.bandwidth.outboundKBytesPerSecond=256 router.updatePolicy=notify routerconsole.lang=en router.hiddenMode=false खोई हुई या अमान्य router.keys नई router पहचान बनाता है। यह स्वीकार्य है, सिवाय इसके कि:\nfloodfill चलाना (floodfill की स्थिति खोना) प्रकाशित पते के साथ eepsites होस्ट करना (निरंतरता खोना) नेटवर्क में स्थापित प्रतिष्ठा बिना बैकअप के रिकवरी संभव नहीं - नया बनाएं: router.keys हटाएँ, I2P को पुनः आरंभ करें, नई पहचान बन जाएगी।\nमहत्वपूर्ण भेद: router.keys (पहचान) बनाम keyData/* (सेवाएँ). router.keys खोने से router की पहचान बदल जाती है. keyData/mysite-keys.dat खोने से आपके eepsite का .i2p पता बदल जाता है - यदि पता प्रकाशित हो चुका हो तो यह विनाशकारी है.\neepsite/सेवा कुंजियों का अलग से बैकअप लें:\n# Identify your service keys ls -la ~/.i2p/keyData/ # Backup with descriptive names cp ~/.i2p/keyData/myservice-keys.dat ~/backups/myservice-keys-$(date +%Y%m%d).dat # Store securely (encrypted if sensitive) gpg -c ~/backups/myservice-keys-*.dat NetDb और peerProfiles (पीयर प्रोफ़ाइलें) में करप्शन:\nलक्षण: शून्य सक्रिय peers (समान-स्तरीय नोड्स), tunnels नहीं बन पा रहे हैं, लॉग्स में \u0026ldquo;Database corruption detected\u0026rdquo;\nसुरक्षित फ़िक्स (सब कुछ स्वतः ही reseed (प्रारंभिक नेटवर्क डेटा लेना)/पुनर्निर्मित हो जाएगा):\ni2prouter stop rm -rf ~/.i2p/netDb/* rm -rf ~/.i2p/peerProfiles/* i2prouter start # Wait 10-15 minutes for reseed and integration इन निर्देशिकाओं में केवल कैश की गई नेटवर्क जानकारी होती है - इन्हें हटाने पर नया bootstrap (प्रारंभिक सेटअप) करना पड़ेगा, पर कोई भी महत्वपूर्ण डेटा नहीं खोएगा।\nरोकथाम की रणनीतियाँ:\nहमेशा सुव्यवस्थित शटडाउन: i2prouter stop का उपयोग करें या router कंसोल का \u0026ldquo;Shutdown\u0026rdquo; बटन - कभी भी प्रक्रिया को जबरन समाप्त न करें स्वचालित बैकअप: Cron जॉब (निर्धारित कार्य) द्वारा ~/.i2p का साप्ताहिक बैकअप अलग डिस्क पर डिस्क स्वास्थ्य निगरानी: SMART स्थिति (ड्राइव स्वास्थ्य संकेतक) को समय-समय पर जाँचें - विफल होती डिस्क डेटा को भ्रष्ट करती हैं पर्याप्त डिस्क स्पेस: 1+ GB खाली बनाए रखें - पूरी तरह भरी डिस्क डेटा भ्रष्टाचार का कारण बनती हैं UPS (निरंतर विद्युत आपूर्ति) की अनुशंसा: लिखने के दौरान बिजली की विफलताएँ फ़ाइलों को भ्रष्ट कर देती हैं महत्वपूर्ण कॉन्फ़िगरेशन का संस्करण नियंत्रण: router.config, i2ptunnel.config के लिए Git रिपॉजिटरी रोलबैक सक्षम करती है फ़ाइल अनुमतियाँ महत्वपूर्ण हैं:\n# Correct permissions (user install) chmod 600 ~/.i2p/router.keys chmod 600 ~/.i2p/*.config chmod 700 ~/.i2p/keyData chmod 755 ~/.i2p # Never run as root - creates permission problems आम त्रुटि संदेशों की व्याख्या I2P की लॉगिंग ऐसे विशिष्ट त्रुटि संदेश प्रदान करती है जो समस्याओं की सटीक पहचान करती हैं। इन संदेशों को समझना समस्या निवारण को तेज करता है।\n\u0026ldquo;No tunnels available\u0026rdquo; तब दिखाई देता है जब router संचालन के लिए पर्याप्त tunnels नहीं बना पाया होता है। यह स्टार्टअप के बाद पहले 5-10 मिनटों में सामान्य है। यदि यह 15 मिनट से अधिक समय तक बना रहे:\nhttp://127.0.0.1:7657 पर Active Peers \u0026gt; 10 की पुष्टि करें बैंडविड्थ आवंटन पर्याप्त है, यह जाँचें (न्यूनतम 128+ KB/sec) http://127.0.0.1:7657/tunnels पर tunnel success rate की जाँच करें (यह \u0026gt;40% होना चाहिए) tunnel build rejection के कारणों के लिए लॉग्स की समीक्षा करें \u0026ldquo;Clock skew detected\u0026rdquo; (घड़ी के समय में असंगति पाई गई) या \u0026ldquo;NTCP2 disconnect code 7\u0026rdquo; दर्शाता है कि सिस्टम समय नेटवर्क सर्वसम्मति से 90 सेकंड से अधिक भिन्न है। I2P को ±60 सेकंड की सटीकता आवश्यक है। समय-विचलित routers के साथ कनेक्शन स्वतः अस्वीकार कर दिए जाते हैं।\nतुरंत ठीक करें:\n# Linux sudo timedatectl set-ntp true sudo systemctl restart systemd-timesyncd date # Verify correct time # Windows # Control Panel → Date and Time → Internet Time → Update now # Verify after sync http://127.0.0.1:7657/logs # Should no longer show clock skew warnings \u0026ldquo;Build timeout\u0026rdquo; या \u0026ldquo;Tunnel build timeout exceeded\u0026rdquo; का अर्थ है कि पीयर चेन के माध्यम से tunnel का निर्माण टाइमआउट विंडो (समय-सीमा) के भीतर पूरा नहीं हुआ (आम तौर पर 60 सेकंड)। कारण:\nधीमे पीयर्स (सहकर्मी): Router ने tunnel के लिए प्रतिक्रिया न देने वाले प्रतिभागियों का चयन कर लिया नेटवर्क भीड़भाड़: I2P नेटवर्क पर उच्च लोड है अपर्याप्त बैंडविड्थ: आपकी बैंडविड्थ सीमाएँ समय पर tunnel निर्माण को रोकती हैं अतिभारित Router: बहुत अधिक भाग लेने वाले tunnels संसाधनों का उपभोग कर रहे हैं समाधान: बैंडविड्थ बढ़ाएँ, भाग लेने वाले tunnels की संख्या घटाएँ (router.maxParticipatingTunnels पर http://127.0.0.1:7657/configadvanced), बेहतर पीयर चयन के लिए पोर्ट फ़ॉरवर्डिंग सक्षम करें।\n\u0026ldquo;Router बंद हो रहा है\u0026rdquo; या \u0026ldquo;सुव्यवस्थित बंदी जारी है\u0026rdquo; सामान्य बंदी या क्रैश रिकवरी के दौरान दिखाई देता है। सुव्यवस्थित बंदी में अधिकतम 10 मिनट लग सकते हैं, क्योंकि router अपने tunnels बंद करता है, peers को सूचित करता है, और स्थिति को स्थायी रूप से सहेजता है।\nयदि शटडाउन अवस्था में 11 मिनट से अधिक समय तक अटका रहे, तो बलपूर्वक समाप्त करें:\n# Linux kill -9 $(pgrep -f i2p) # Windows taskkill /F /IM javaw.exe \u0026ldquo;java.lang.OutOfMemoryError: Java heap space\u0026rdquo; heap (हिप—Java की मेमोरी का क्षेत्र) के समाप्त हो जाने का संकेत देता है। तत्काल समाधान:\nwrapper.config संपादित करें: wrapper.java.maxmemory=512 (या उससे अधिक) पूर्ण शटडाउन आवश्यक है - रीस्टार्ट करने से परिवर्तन लागू नहीं होगा पूर्ण शटडाउन के लिए 11 मिनट प्रतीक्षा करें router को नए सिरे से शुरू करें http://127.0.0.1:7657/graphs पर मेमोरी आवंटन सत्यापित करें - वहाँ अतिरिक्त गुंजाइश (headroom) दिखनी चाहिए संबंधित मेमोरी त्रुटियाँ:\n\u0026ldquo;GC overhead limit exceeded\u0026rdquo;: garbage collection (स्वचालित मेमोरी सफाई) में बहुत अधिक समय लग रहा है - heap बढ़ाएँ \u0026ldquo;Metaspace\u0026rdquo;: Java क्लास मेटाडेटा स्पेस समाप्त हो गया है - wrapper.java.additional.X=-XX:MaxMetaspaceSize=256M जोड़ें Windows-विशिष्ट: Kaspersky Antivirus wrapper.config सेटिंग्स की परवाह किए बिना Java heap को 512MB तक सीमित करता है - अनइंस्टॉल करें या I2P को अपवाद सूची (exclusions) में जोड़ें।\n\u0026ldquo;कनेक्शन टाइमआउट\u0026rdquo; या \u0026ldquo;I2CP त्रुटि - पोर्ट 7654\u0026rdquo; जब एप्लिकेशन router से कनेक्ट करने का प्रयास करते हैं:\nrouter के चल रहे होने की पुष्टि करें: http://127.0.0.1:7657 को प्रतिक्रिया देनी चाहिए I2CP पोर्ट जांचें: netstat -an | grep 7654 में LISTENING दिखना चाहिए सुनिश्चित करें कि localhost फ़ायरवॉल अनुमति देता है: sudo ufw allow from 127.0.0.1 सुनिश्चित करें कि एप्लिकेशन सही पोर्ट का उपयोग कर रहा है (I2CP=7654, SAM=7656) \u0026ldquo;Certificate validation failed\u0026rdquo; या \u0026ldquo;RouterInfo corrupt\u0026rdquo; reseed (रीसीड: netDb का प्रारंभिक डेटा डाउनलोड करने की प्रक्रिया) के दौरान:\nमूल कारण: Clock skew (सिस्टम घड़ी का समय विचलन; पहले इसे ठीक करें), दूषित netDb, अमान्य reseed (नेटवर्क से पहली बार जुड़ने की प्रक्रिया) प्रमाणपत्र\n# After fixing clock: i2prouter stop rm -rf ~/.i2p/netDb/* # Delete corrupted database i2prouter start # Auto-reseeds with fresh data \u0026ldquo;Database corruption detected\u0026rdquo; netDb या peerProfiles में डिस्क-स्तरीय डेटा भ्रष्टाचार का संकेत देता है:\n# Safe fix - all will rebuild i2prouter stop rm -rf ~/.i2p/netDb/* ~/.i2p/peerProfiles/* i2prouter start SMART (Self-Monitoring, Analysis and Reporting Technology—ड्राइव स्वास्थ्य निगरानी तकनीक) टूल्स से डिस्क का स्वास्थ्य जांचें - बार-बार होने वाली करप्शन इस बात का संकेत है कि स्टोरेज फेल हो रही है।\nप्लेटफ़ॉर्म-विशिष्ट चुनौतियाँ विभिन्न ऑपरेटिंग सिस्टम अनुमतियों, सुरक्षा नीतियों और सिस्टम एकीकरण से संबंधित विशिष्ट I2P परिनियोजन चुनौतियाँ उत्पन्न करते हैं।\nLinux अनुमतियों और सेवा संबंधी समस्याएँ पैकेज से स्थापित I2P सिस्टम उपयोगकर्ता i2psvc (Debian/Ubuntu) या i2p (अन्य वितरणों) के रूप में चलता है, जिसके लिए कुछ विशिष्ट अनुमतियों की आवश्यकता होती है:\n# Fix package install permissions sudo chown -R i2psvc:i2psvc /var/lib/i2p /var/log/i2p /run/i2p sudo chmod 750 /var/log/i2p /var/lib/i2p sudo chmod 644 /var/lib/i2p/*.config # User install permissions (should be your user) chown -R $USER:$USER ~/.i2p chmod 700 ~/.i2p chmod 600 ~/.i2p/router.keys ~/.i2p/*.config File descriptor limits (फ़ाइल डिस्क्रिप्टर सीमाएँ) कनेक्शनों के लिए router की क्षमता को प्रभावित करती हैं। डिफ़ॉल्ट सीमाएँ (1024) उच्च-बैंडविड्थ routers के लिए अपर्याप्त हैं:\n# Check current limits ulimit -n # Temporary increase ulimit -n 4096 # Permanent fix: Edit /etc/security/limits.conf i2psvc soft nofile 4096 i2psvc hard nofile 8192 # Systemd override sudo mkdir -p /etc/systemd/system/i2p.service.d/ sudo nano /etc/systemd/system/i2p.service.d/override.conf # Add: [Service] LimitNOFILE=8192 sudo systemctl daemon-reload sudo systemctl restart i2p AppArmor टकराव Debian/Ubuntu पर आम हैं और सेवा के प्रारंभ को रोकते हैं:\n# Error: \u0026#34;Failed at step APPARMOR spawning /usr/sbin/wrapper\u0026#34; # Cause: AppArmor profile missing or misconfigured # Solution 1: Disable AppArmor for I2P sudo aa-complain /usr/sbin/wrapper # Solution 2: Reconfigure package without AppArmor sudo dpkg-reconfigure -plow i2p # Select \u0026#34;No\u0026#34; when asked about AppArmor # Solution 3: LXC/Proxmox containers - disable AppArmor in container config lxc.apparmor.profile: unconfined SELinux से संबंधित समस्याएँ RHEL/CentOS/Fedora पर:\n# Temporary: Set permissive mode sudo setenforce 0 # Permanent: Generate custom policy sudo ausearch -c \u0026#39;java\u0026#39; --raw | audit2allow -M i2p_policy sudo semodule -i i2p_policy.pp # Or disable SELinux for I2P process (less secure) sudo semanage permissive -a i2p_t SystemD सेवा समस्या निवारण:\n# Detailed service status sudo systemctl status i2p.service -l # Full logs sudo journalctl -xe -u i2p.service # Follow logs live sudo journalctl -f -u i2p.service # Restart with logging sudo systemctl restart i2p.service \u0026amp;\u0026amp; sudo journalctl -f -u i2p.service Windows फ़ायरवॉल और एंटीवायरस का हस्तक्षेप Windows Defender और तृतीय-पक्ष एंटीवायरस उत्पाद अक्सर नेटवर्क व्यवहार पैटर्न के कारण I2P को चिह्नित करते हैं। उचित कॉन्फ़िगरेशन सुरक्षा बनाए रखते हुए अनावश्यक ब्लॉकों को रोकता है।\nWindows Defender फ़ायरवॉल कॉन्फ़िगर करें:\n# Run PowerShell as Administrator # Find Java path (adjust for your Java installation) $javaPath = \u0026#34;C:\\Program Files\\Eclipse Adoptium\\jdk-11.0.16.101-hotspot\\bin\\javaw.exe\u0026#34; # Create inbound rules New-NetFirewallRule -DisplayName \u0026#34;I2P Java\u0026#34; -Direction Inbound -Program $javaPath -Action Allow New-NetFirewallRule -DisplayName \u0026#34;I2P UDP\u0026#34; -Direction Inbound -Protocol UDP -LocalPort 22648 -Action Allow New-NetFirewallRule -DisplayName \u0026#34;I2P TCP\u0026#34; -Direction Inbound -Protocol TCP -LocalPort 22648 -Action Allow # Add exclusions to Windows Defender Add-MpPreference -ExclusionPath \u0026#34;C:\\Program Files\\i2p\u0026#34; Add-MpPreference -ExclusionPath \u0026#34;$env:APPDATA\\I2P\u0026#34; Add-MpPreference -ExclusionPath \u0026#34;$env:LOCALAPPDATA\\I2P\u0026#34; Add-MpPreference -ExclusionProcess \u0026#34;javaw.exe\u0026#34; http://127.0.0.1:7657/confignet पर दिए गए आपके वास्तविक I2P पोर्ट से पोर्ट 22648 को बदलें।\nKaspersky Antivirus से संबंधित विशेष समस्या: Kaspersky के \u0026ldquo;Application Control\u0026rdquo; (एप्लिकेशन नियंत्रण) wrapper.config सेटिंग्स की परवाह किए बिना Java heap को 512MB तक सीमित कर देता है। यह उच्च-बैंडविड्थ routers पर OutOfMemoryError का कारण बनता है।\nसमाधान: 1. Kaspersky की Exclusions सूची में I2P जोड़ें: Settings → Additional → Threats and Exclusions → Manage Exclusions 2. या Kaspersky अनइंस्टॉल करें (I2P के संचालन हेतु अनुशंसित)\nथर्ड-पार्टी एंटीवायरस संबंधी सामान्य दिशानिर्देश:\nI2P की स्थापना निर्देशिका को अपवादों में जोड़ें %APPDATA%\\I2P और %LOCALAPPDATA%\\I2P को अपवादों में जोड़ें javaw.exe को व्यवहार-आधारित विश्लेषण से बाहर रखें ऐसी \u0026ldquo;Network Attack Protection\u0026rdquo; विशेषताएँ अक्षम करें जो I2P प्रोटोकॉल्स में हस्तक्षेप कर सकती हैं macOS Gatekeeper द्वारा स्थापना अवरुद्ध macOS Gatekeeper बिना हस्ताक्षरित अनुप्रयोगों को चलने से रोकता है। I2P इंस्टॉलर्स Apple Developer ID से साइन नहीं होते, जिससे सुरक्षा चेतावनियाँ प्रदर्शित होती हैं।\nI2P इंस्टॉलर के लिए Gatekeeper को बायपास करें:\n# Method 1: Remove quarantine attribute xattr -d com.apple.quarantine ~/Downloads/i2pinstall_*.jar java -jar ~/Downloads/i2pinstall_*.jar # Method 2: Use System Settings (macOS 13+) # Try to open installer → macOS blocks it # System Settings → Privacy \u0026amp; Security → scroll down # Click \u0026#34;Open Anyway\u0026#34; next to I2P warning # Confirm in dialog # Method 3: Control-click installer # Control-click (right-click) i2pinstall_*.jar # Select \u0026#34;Open\u0026#34; from menu → \u0026#34;Open\u0026#34; again in dialog # Bypasses Gatekeeper for this specific file स्थापना के बाद चलाने पर अब भी चेतावनियाँ आ सकती हैं:\n# If I2P won\u0026#39;t start due to Gatekeeper: xattr -dr com.apple.quarantine ~/i2p/ Gatekeeper (macOS की सुरक्षा सुविधा) को कभी भी स्थायी रूप से निष्क्रिय न करें - अन्य अनुप्रयोगों के लिए सुरक्षा जोखिम। केवल फ़ाइल-विशिष्ट बाईपास का उपयोग करें।\nmacOS फ़ायरवॉल कॉन्फ़िगरेशन:\nसिस्टम प्रेफरेंसेज़ → सिक्योरिटी एवं प्राइवेसी → फ़ायरवॉल → फ़ायरवॉल ऑप्शंस एप्लिकेशन जोड़ने के लिए \u0026ldquo;+\u0026rdquo; पर क्लिक करें Java इंस्टॉलेशन तक जाएँ (उदा., /Library/Java/JavaVirtualMachines/jdk-11.jdk/Contents/Home/bin/java) जोड़ें और \u0026ldquo;Allow incoming connections\u0026rdquo; पर सेट करें Android I2P एप्लिकेशन संबंधी समस्याएँ Android संस्करण संबंधी बाधाएँ और संसाधन सीमाएँ विशिष्ट चुनौतियाँ उत्पन्न करती हैं।\nन्यूनतम आवश्यकताएँ: - वर्तमान संस्करणों के लिए Android 5.0+ (API level 21+) आवश्यक - न्यूनतम 512MB RAM, 1GB+ अनुशंसित - ऐप + router डेटा के लिए 100MB स्टोरेज - I2P के लिए बैकग्राउंड ऐप प्रतिबंध निष्क्रिय\nऐप तुरंत क्रैश हो जाती है:\nAndroid संस्करण जांचें: Settings → About Phone → Android version (कम से कम 5.0 या उससे अधिक होना चाहिए) सभी I2P संस्करण अनइंस्टॉल करें: केवल एक वैरिएंट इंस्टॉल करें: net.i2p.android (Google Play) net.i2p.android.router (F-Droid)\nएकाधिक इंस्टॉल में टकराव होता है ऐप डेटा साफ़ करें: Settings → Apps → I2P → Storage → Clear Data साफ़ स्थिति से पुनः इंस्टॉल करें बैटरी ऑप्टिमाइज़ेशन के कारण router बंद हो रहा है:\nAndroid बैटरी बचाने के लिए बैकग्राउंड ऐप्स को आक्रामक रूप से बंद कर देता है। I2P को अपवाद देना आवश्यक है:\nसेटिंग्स → बैटरी → बैटरी ऑप्टिमाइज़ेशन (या ऐप की बैटरी खपत) I2P खोजें → अनुकूलित न करें (या बैकग्राउंड गतिविधि की अनुमति दें) सेटिंग्स → ऐप्स → I2P → बैटरी → बैकग्राउंड गतिविधि की अनुमति दें + प्रतिबंध हटाएँ मोबाइल पर कनेक्शन संबंधी समस्याएँ:\nबूटस्ट्रैप के लिए WiFi आवश्यक है: Initial reseed (रीसीड सर्वर से प्रारंभिक डेटा प्राप्त करने की प्रक्रिया) काफी डेटा डाउनलोड करता है - WiFi का उपयोग करें, सेल्यूलर नहीं नेटवर्क परिवर्तन: I2P नेटवर्क स्विच को सुचारू रूप से हैंडल नहीं करता - WiFi/सेल्यूलर परिवर्तन के बाद ऐप को पुनः प्रारंभ करें मोबाइल के लिए बैंडविड्थ: सेल्यूलर डेटा समाप्त होने से बचने के लिए 64-128 KB/sec पर संयमित रूप से कॉन्फ़िगर करें मोबाइल के लिए प्रदर्शन अनुकूलन:\nI2P ऐप → मेन्यू → सेटिंग्स → बैंडविड्थ उपयुक्त सीमाएँ निर्धारित करें: सेलुलर के लिए 64 KB/sec inbound (आगत), 32 KB/sec outbound (निर्गत) भाग लेने वाले tunnels कम करें: सेटिंग्स → एडवांस्ड → अधिकतम भाग लेने वाले tunnels: 100-200 बैटरी की बचत के लिए \u0026ldquo;Stop I2P when screen off\u0026rdquo; सक्षम करें Android पर टोरेंटिंग:\nएक साथ चलने वाले टोरेंट की संख्या अधिकतम 2-3 तक सीमित रखें DHT (वितरित हैश टेबल) की आक्रामकता कम करें टोरेंटिंग के लिए केवल वाई-फाई का उपयोग करें मोबाइल हार्डवेयर पर धीमी गति स्वीकार करें Reseed (नेटवर्क की प्रारंभिक जानकारी डाउनलोड करना) और bootstrap (नेटवर्क से प्रारंभिक कनेक्शन स्थापित करना) से संबंधित समस्याएँ I2P के नए इंस्टॉलेशनों को reseeding (प्रारंभिक पीयर जानकारी प्राप्त करना) की आवश्यकता होती है - नेटवर्क से जुड़ने के लिए सार्वजनिक HTTPS सर्वरों से प्रारंभिक पीयर जानकारी लाना। reseeding से जुड़ी समस्याएँ उपयोगकर्ताओं को शून्य पीयर और बिना नेटवर्क एक्सेस की स्थिति में फँसा देती हैं।\nनई स्थापना के बाद \u0026ldquo;No active peers\u0026rdquo; आम तौर पर reseed (शुरुआत में नेटवर्क से आवश्यक डेटा/साथियों की सूची डाउनलोड करने की प्रक्रिया) की विफलता का संकेत देता है। लक्षण:\nज्ञात समकक्ष: 0 या 5 से कम पर ही बना रहता है \u0026ldquo;Network: Testing\u0026rdquo; 15 मिनट से अधिक समय तक बना रहता है लॉग में \u0026ldquo;Reseed failed\u0026rdquo; या reseed सर्वर (प्रारंभिक पीयर-सूची स्रोत) से कनेक्शन त्रुटियाँ दिखती हैं reseed (शुरुआती समकक्षों की सूची प्राप्त करने की प्रक्रिया) क्यों विफल होता है:\nHTTPS को ब्लॉक करने वाला फायरवॉल: कॉर्पोरेट/ISP फायरवॉल reseed server (I2P में नेटवर्क बूटस्ट्रैप/प्रारंभिक peers देने वाला सर्वर) के कनेक्शनों को ब्लॉक करते हैं (पोर्ट 443) SSL प्रमाणपत्र त्रुटियाँ: सिस्टम में नवीनतम रूट प्रमाणपत्र नहीं हैं प्रॉक्सी की आवश्यकता: बाहरी कनेक्शनों के लिए नेटवर्क को HTTP/SOCKS प्रॉक्सी चाहिए Clock skew (सिस्टम घड़ी का समय असंतुलन): सिस्टम समय गलत होने पर SSL प्रमाणपत्र सत्यापन विफल हो जाता है भौगोलिक सेंसरशिप: कुछ देश/ISP ज्ञात reseed servers को ब्लॉक करते हैं मैन्युअल reseed (नेटवर्क बूटस्ट्रैप के लिए प्रारंभिक नोड सूची डाउनलोड) को मजबूर करें:\nhttp://127.0.0.1:7657/configreseed पर जाएँ \u0026ldquo;Save changes and reseed now\u0026rdquo; पर क्लिक करें http://127.0.0.1:7657/logs पर \u0026ldquo;Reseed got XX router infos\u0026rdquo; के लिए नज़र रखें प्रोसेसिंग के लिए 5-10 मिनट प्रतीक्षा करें http://127.0.0.1:7657 जाँचें - Known peers बढ़कर 50+ होना चाहिए reseed proxy (रीसीड प्रॉक्सी) कॉन्फ़िगर करें प्रतिबंधात्मक नेटवर्क के लिए:\nhttp://127.0.0.1:7657/configreseed → प्रॉक्सी कॉन्फ़िगरेशन:\nHTTP प्रॉक्सी: [proxy-server]:[port] या SOCKS5: [socks-server]:[port] \u0026ldquo;केवल reseed के लिए प्रॉक्सी का उपयोग करें\u0026rdquo; को सक्षम करें (reseed: I2P नेटवर्क के प्रारंभिक बूटस्ट्रैप हेतु netDb डेटा डाउनलोड करना) आवश्यक होने पर क्रेडेंशियल्स सहेजें और reseed को बलपूर्वक प्रारंभ करें विकल्प: reseed (I2P नेटवर्क से प्रारंभिक peers प्राप्त करने की प्रक्रिया) के लिए Tor प्रॉक्सी:\nयदि Tor Browser या Tor daemon (पृष्ठभूमि सेवा) चल रहा हो:\nप्रॉक्सी प्रकार: SOCKS5 होस्ट: 127.0.0.1 पोर्ट: 9050 (डिफ़ॉल्ट Tor SOCKS पोर्ट) सक्षम करें और reseed (netDb के प्रारंभिक peers को फिर से प्राप्त करना) su3 फ़ाइल के माध्यम से हस्तचालित reseed (प्रारम्भिक नेटवर्क डेटाबेस/नोड सूची दोबारा प्राप्त करना) (अंतिम उपाय):\nजब सभी स्वचालित reseed (I2P नेटवर्क से प्रारंभिक कनेक्शन/बूटस्ट्रैप के लिए डेटा प्राप्त करने की प्रक्रिया) विफल हो जाएँ, तो reseed फ़ाइल को out-of-band (मुख्य चैनल/नेटवर्क से अलग माध्यम) से प्राप्त करें:\nअप्रतिबंधित कनेक्शन पर विश्वसनीय स्रोत से i2pseeds.su3 डाउनलोड करें (https://reseed.i2p.rocks/i2pseeds.su3 , https://reseed-fr.i2pd.xyz/i2pseeds.su3 ) I2P को पूरी तरह बंद करें i2pseeds.su3 को ~/.i2p/ डायरेक्टरी में कॉपी करें I2P प्रारंभ करें - फ़ाइल को स्वतः निकालकर और प्रोसेस करता है प्रोसेसिंग के बाद i2pseeds.su3 को हटा दें http://127.0.0.1:7657 पर पीयर्स की संख्या बढ़ने की पुष्टि करें reseed (आरंभिक netDb डेटा प्राप्त करने की प्रक्रिया) के दौरान SSL प्रमाणपत्र त्रुटियाँ:\nError: \u0026#34;Reseed: Certificate verification failed\u0026#34; Cause: System root certificates outdated or missing समाधान:\n# Linux - update certificates sudo apt install ca-certificates sudo update-ca-certificates # Windows - install KB updates for root certificate trust # Or install .NET Framework (includes certificate updates) # macOS - update system # Software Update includes certificate trust updates 30 मिनट से अधिक समय तक 0 ज्ञात पीयर्स पर अटका:\nयह दर्शाता है कि reseed (प्रारंभिक बूटस्ट्रैप/नेटवर्क सीडिंग प्रक्रिया) पूरी तरह विफल हो गया है। समस्या निवारण क्रम:\nसिस्टम समय सही है, यह सत्यापित करें (सबसे सामान्य समस्या - इसे सबसे पहले ठीक करें) HTTPS कनेक्टिविटी का परीक्षण करें: ब्राउज़र में https://reseed.i2p.rocks खोलकर देखें - अगर यह असफल हो, तो नेटवर्क समस्या है I2P logs जाँचें http://127.0.0.1:7657/logs पर, विशिष्ट reseed (नेटवर्क बूटस्ट्रैप/seed डेटा प्राप्त करने की प्रक्रिया) त्रुटियों के लिए किसी अन्य reseed URL का प्रयास करें: http://127.0.0.1:7657/configreseed → कस्टम reseed URL जोड़ें: https://reseed-fr.i2pd.xyz/ मैनुअल su3 file विधि का उपयोग करें (su3: I2P का हस्ताक्षरित reseed/update फ़ाइल प्रारूप) यदि स्वचालित प्रयास समाप्त हो गए हों Reseed servers (नेटवर्क में जुड़ने के लिए प्रारंभिक नोड सूची प्रदान करने वाले सर्वर) कभी-कभी ऑफ़लाइन रहते हैं: I2P में कई हार्ड-कोड किए गए Reseed servers शामिल होते हैं। यदि कोई एक विफल हो जाए, तो router स्वतः अन्य को आज़माता है। सभी Reseed servers का पूर्ण विफल होना अत्यंत दुर्लभ है, पर संभव है।\nवर्तमान सक्रिय reseed servers (रीसीड सर्वर) (अक्टूबर 2025 तक):\nhttps://reseed.i2p.rocks/ https://reseed-fr.i2pd.xyz/ https://i2p.novg.net/ https://i2p-projekt.de/ यदि डिफ़ॉल्ट से समस्या हो, तो कस्टम URLs के रूप में जोड़ें।\nकड़ी सेंसरशिप वाले क्षेत्रों के उपयोगकर्ताओं के लिए:\nप्रारंभिक reseed (प्रारंभिक नोड-सीड लाने की प्रक्रिया) के लिए Tor के जरिए Snowflake/Meek bridges (Tor के प्लगेबल ट्रांसपोर्ट ब्रिज) का उपयोग करने पर विचार करें, फिर नेटवर्क से जुड़ जाने पर सीधे I2P पर स्विच कर लें। या सेंसरशिप ज़ोन के बाहर से steganography (गोपनीय संदेश-छिपाने की तकनीक), ईमेल, या USB के जरिए i2pseeds.su3 प्राप्त करें।\nअतिरिक्त सहायता कब लेनी चाहिए यह मार्गदर्शिका I2P से संबंधित अधिकांश समस्याओं को कवर करती है, लेकिन कुछ समस्याओं के लिए डेवलपर्स का ध्यान या समुदाय की विशेषज्ञता की आवश्यकता होती है।\nइन स्थितियों में I2P समुदाय से सहायता लें:\nसभी समस्या निवारण चरणों का पालन करने के बाद भी Router लगातार क्रैश होता है Memory leaks के कारण आवंटित heap (मेमोरी का निर्धारित भाग) से परे निरंतर वृद्धि हो रही है उचित कॉन्फ़िगरेशन के बावजूद Tunnel की सफलता दर 20% से कम बनी रहती है लॉग में नई त्रुटियाँ जो इस गाइड में शामिल नहीं हैं सुरक्षा कमजोरियाँ खोजी गईं फीचर अनुरोध या सुधार सुझाव मदद मांगने से पहले, निदान संबंधी जानकारी एकत्र करें:\nI2P संस्करण: http://127.0.0.1:7657 (उदा., \u0026ldquo;2.10.0\u0026rdquo;) Java संस्करण: java -version आउटपुट ऑपरेटिंग सिस्टम और संस्करण Router की स्थिति: नेटवर्क स्थिति, सक्रिय समकक्षों की संख्या, Participating tunnels बैंडविड्थ कॉन्फ़िगरेशन: इनबाउंड/आउटबाउंड सीमाएँ पोर्ट फ़ॉरवर्डिंग स्थिति: Firewalled या OK प्रासंगिक लॉग अंश: http://127.0.0.1:7657/logs से त्रुटियाँ दिखाती हुई अंतिम 50 पंक्तियाँ आधिकारिक समर्थन चैनल:\nफोरम: https://i2pforum.net (क्लियरनेट) या http://i2pforum.i 2p (I2P के भीतर) IRC: #i2p Irc2P पर (irc.postman.i2p I2P के माध्यम से) या irc.freenode.net (क्लियरनेट) Reddit: https://reddit.com/r/i2p समुदाय चर्चा के लिए बग ट्रैकर: https://i2pgit.org/i2p-hackers/i2p.i2p/-/issues पुष्ट बगों के लिए मेलिंग सूची: i2p-dev@lists.i2p-projekt.de विकास संबंधी प्रश्नों के लिए यथार्थवादी अपेक्षाएँ मायने रखती हैं। I2P मूलभूत डिज़ाइन के कारण clearnet (सामान्य सार्वजनिक इंटरनेट) से धीमा है - multi-hop एन्क्रिप्टेड tunnel का उपयोग स्वाभाविक विलंबता पैदा करता है। 30 सेकंड में पेज लोड और 50 KB/sec टॉरेंट गति के साथ काम कर रहा I2P router सही ढंग से काम कर रहा है, खराब नहीं है। clearnet की गति की अपेक्षा करने वाले उपयोगकर्ता, विन्यास अनुकूलन चाहे जैसा भी हो, निराश होंगे।\nनिष्कर्ष अधिकांश I2P समस्याएँ तीन श्रेणियों से उत्पन्न होती हैं: bootstrap (प्रारंभिक नेटवर्क-सिंक चरण; 10-15 मिनट आवश्यक) के दौरान अपर्याप्त धैर्य, अपर्याप्त संसाधन आवंटन (न्यूनतम 512 MB RAM, 256 KB/sec बैंडविड्थ), या गलत तरीके से कॉन्फ़िगर किया गया port forwarding (router पर आने वाले पोर्ट को अंदर की मशीन तक अग्रेषित करना)। I2P की distributed architecture (विकेंद्रीकृत संरचना) और anonymity-focused design (अनामिकता/गोपनीयता केंद्रित डिज़ाइन) को समझना उपयोगकर्ताओं को अपेक्षित व्यवहार और वास्तविक समस्याओं में अंतर करने में मदद करता है।\nrouter की \u0026ldquo;Firewalled\u0026rdquo; स्थिति, भले ही आदर्श न हो, I2P के उपयोग को नहीं रोकती - यह केवल नेटवर्क में योगदान को सीमित करती है और प्रदर्शन को थोड़ा घटाती है। नए उपयोगकर्ताओं को स्थिरता को अनुकूलन पर प्राथमिकता देनी चाहिए: उन्नत सेटिंग्स समायोजित करने से पहले router को कई दिनों तक लगातार चलाएँ, क्योंकि अपटाइम (सक्रिय रहने की अवधि) के साथ एकीकरण स्वाभाविक रूप से बेहतर होता जाता है।\nसमस्या निवारण करते समय, हमेशा पहले मूल बातें सत्यापित करें: सही सिस्टम समय, पर्याप्त बैंडविड्थ, router का निरंतर चलना, और 10+ सक्रिय समकक्ष। अधिकांश समस्याएँ, अस्पष्ट कॉन्फ़िगरेशन पैरामीटरों को समायोजित करने के बजाय, इन मूल बातों को ठीक करने से ही हल हो जाती हैं। I2P धैर्य और निरंतर संचालन को बेहतर प्रदर्शन से पुरस्कृत करता है, क्योंकि router अपटाइम (चालू रहने की अवधि) के दिनों और हफ्तों में अपनी साख बनाता है और समकक्ष चयन का अनुकूलन करता है।\n","description":"I2P router से संबंधित सामान्य समस्याओं के लिए व्यापक समस्या-निवारण मार्गदर्शिका, जिसमें कनेक्टिविटी, प्रदर्शन, और कॉन्फ़िगरेशन से जुड़ी दिक्कतें शामिल हैं","id":"2ff67fee0173608876ccc012bf3ff6ce","section":"docs","title":"I2P Router समस्या निवारण मार्गदर्शिका","url":"/hi/docs/troubleshooting/"},{"categories":null,"content":"I2P क्या है? Invisible Internet Project (I2P) एक अनाम नेटवर्क लेयर है जो सेंसरशिप-प्रतिरोधी, पीयर-टू-पीयर संचार की अनुमति देता है। अनाम कनेक्शन उपयोगकर्ता के ट्रैफिक को एन्क्रिप्ट करके और दुनिया भर में स्वयंसेवकों द्वारा संचालित एक वितरित नेटवर्क के माध्यम से भेजकर प्राप्त किए जाते हैं।\nमुख्य विशेषताएं Anonymity I2P संदेश भेजने वाले और प्राप्त करने वाले दोनों को छुपाता है। पारंपरिक इंटरनेट कनेक्शन के विपरीत जहां आपका IP पता वेबसाइटों और सेवाओं को दिखाई देता है, I2P आपकी पहचान को निजी रखने के लिए एन्क्रिप्शन और routing की कई परतों का उपयोग करता है।\nDecentralization I2P में कोई केंद्रीय प्राधिकरण नहीं है। नेटवर्क स्वयंसेवकों द्वारा बनाए रखा जाता है जो बैंडविड्थ और कंप्यूटिंग संसाधन दान करते हैं। यह इसे सेंसरशिप और single points of failure के प्रति प्रतिरोधी बनाता है।\nगुमनामी I2P के भीतर सभी ट्रैफ़िक end-to-end एन्क्रिप्टेड होता है। नेटवर्क में गुजरते समय संदेशों को कई बार एन्क्रिप्ट किया जाता है, जो Tor के काम करने के तरीके के समान है लेकिन कार्यान्वयन में महत्वपूर्ण अंतर के साथ।\nHow It Works विकेंद्रीकरण I2P ट्रैफ़िक को रूट करने के लिए \u0026ldquo;tunnels\u0026rdquo; का उपयोग करता है। जब आप डेटा भेजते या प्राप्त करते हैं:\nआपका राउटर एक आउटबाउंड टनल बनाता है (भेजने के लिए) आपका राउटर एक इनबाउंड टनल बनाता है (प्राप्त करने के लिए) संदेशों को एन्क्रिप्ट किया जाता है और कई routers के माध्यम से भेजा जाता है प्रत्येक router केवल पिछले और अगले hop को जानता है, पूरे path को नहीं एंड-टू-एंड एन्क्रिप्शन I2P पारंपरिक onion routing को \u0026ldquo;garlic routing\u0026rdquo; के साथ बेहतर बनाता है:\nएक साथ कई संदेशों को बंडल किया जा सकता है (लहसुन के बल्ब में लौंग की तरह) यह बेहतर प्रदर्शन और अतिरिक्त गुमनामी प्रदान करता है ट्रैफ़िक विश्लेषण को अधिक कठिन बना देता है Network Database I2P एक वितरित नेटवर्क डेटाबेस बनाए रखता है जिसमें शामिल है:\nराउटर जानकारी गंतव्य पते (.i2p वेबसाइटों के समान) एन्क्रिप्टेड रूटिंग डेटा Common Use Cases टनल्स (Tunnels) .i2p में समाप्त होने वाली वेबसाइटों को होस्ट करें या उन पर जाएं - ये केवल I2P नेटवर्क के भीतर सुलभ हैं और होस्ट और विज़िटर दोनों के लिए मजबूत गुमनामी की गारंटी प्रदान करती हैं।\nगार्लिक राउटिंग I2P पर BitTorrent का उपयोग करके फ़ाइलें गुमनाम रूप से साझा करें। कई torrent एप्लिकेशन में I2P समर्थन पहले से शामिल है।\nनेटवर्क डेटाबेस I2P-Bote या I2P के लिए डिज़ाइन किए गए अन्य ईमेल एप्लिकेशन का उपयोग करके गुमनाम ईमेल भेजें और प्राप्त करें।\nMessaging I2P नेटवर्क पर IRC, इंस्टेंट मैसेजिंग, या अन्य संचार उपकरणों का उपयोग निजी तौर पर करें।\nGetting Started I2P आज़माने के लिए तैयार हैं? अपने सिस्टम पर I2P इंस्टॉल करने के लिए हमारे डाउनलोड पेज को देखें।\nअधिक तकनीकी विवरण के लिए, Technical Introduction देखें या संपूर्ण documentation का अन्वेषण करें।\nयह कैसे काम करता है तकनीकी परिचय - गहन तकनीकी अवधारणाएं Threat Model - I2P के सुरक्षा मॉडल को समझना Tor से तुलना - I2P किस प्रकार Tor से भिन्न है क्रिप्टोग्राफी - I2P के क्रिप्टोग्राफिक एल्गोरिदम का विवरण ","description":"I2P गुमनाम नेटवर्क का एक कम-तकनीकी परिचय","id":"b4dafae75d4a04b2eac73ebf531f1d1b","section":"docs","title":"I2P का परिचय","url":"/hi/docs/overview/intro/"},{"categories":null,"content":"जब नेटवर्क परिस्थितियाँ git clone को अविश्वसनीय बना देती हैं, तो आप git bundles के रूप में repositories को BitTorrent या किसी अन्य फ़ाइल ट्रांसपोर्ट के माध्यम से वितरित कर सकते हैं। एक bundle एक single file होती है जिसमें पूरी repository history होती है। एक बार डाउनलोड हो जाने के बाद, आप इससे locally fetch करते हैं और फिर upstream remote पर वापस switch करते हैं।\n1. शुरू करने से पहले बंडल जनरेट करने के लिए एक पूर्ण Git clone की आवश्यकता होती है। --depth 1 के साथ बनाए गए Shallow clones चुपचाप टूटे हुए बंडल उत्पन्न करेंगे जो काम करते हुए प्रतीत होते हैं लेकिन जब अन्य लोग उनका उपयोग करने का प्रयास करते हैं तो विफल हो जाते हैं। हमेशा किसी विश्वसनीय स्रोत (GitHub पर github.com/i2p/i2p.i2p , I2P Gitea instance पर i2pgit.org , या I2P के माध्यम से git.idk.i2p) से fetch करें और बंडल बनाने से पहले किसी भी shallow clone को full clone में बदलने के लिए आवश्यकता होने पर git fetch --unshallow चलाएं।\nयदि आप केवल एक मौजूदा bundle का उपयोग कर रहे हैं, तो बस इसे डाउनलोड करें। किसी विशेष तैयारी की आवश्यकता नहीं है।\n2. एक बंडल डाउनलोड करना Obtaining the Bundle File I2PSnark (I2P में अंतर्निहित torrent क्लाइंट) या I2P प्लगइन के साथ BiglyBT जैसे अन्य I2P-संगत क्लाइंट का उपयोग करके BitTorrent के माध्यम से बंडल फ़ाइल डाउनलोड करें।\nमहत्वपूर्ण: I2PSnark केवल उन्हीं torrents के साथ काम करता है जो विशेष रूप से I2P नेटवर्क के लिए बनाए गए हैं। मानक clearnet torrents संगत नहीं हैं क्योंकि I2P, IP addresses और ports के बजाय Destinations (387+ byte addresses) का उपयोग करता है।\nबंडल फ़ाइल का स्थान आपके I2P इंस्टॉलेशन प्रकार पर निर्भर करता है:\nउपयोगकर्ता/मैनुअल इंस्टॉलेशन (Java installer के साथ इंस्टॉल किया गया): ~/.i2p/i2psnark/ सिस्टम/डेमॉन इंस्टॉलेशन (apt-get या package manager के माध्यम से इंस्टॉल किया गया): /var/lib/i2p/i2p-config/i2psnark/ BiglyBT उपयोगकर्ता डाउनलोड की गई फ़ाइलें अपनी कॉन्फ़िगर की गई डाउनलोड निर्देशिका में पाएंगे।\nCloning from the Bundle मानक विधि (अधिकांश मामलों में काम करती है):\ngit clone ~/.i2p/i2psnark/i2p.i2p.bundle यदि आपको fatal: multiple updates for ref errors का सामना करना पड़े (Git 2.21.0 और बाद के संस्करणों में एक ज्ञात समस्या जब global Git config में विरोधाभासी fetch refspecs हों), तो manual initialization approach का उपयोग करें:\nmkdir i2p.i2p \u0026amp;\u0026amp; cd i2p.i2p git init git fetch ~/.i2p/i2psnark/i2p.i2p.bundle वैकल्पिक रूप से, आप --update-head-ok फ्लैग का उपयोग कर सकते हैं:\ngit fetch --update-head-ok ~/.i2p/i2psnark/i2p.i2p.bundle \u0026#39;*:*\u0026#39; बंडल फ़ाइल प्राप्त करना बंडल से क्लोन करने के बाद, अपने क्लोन को लाइव रिमोट की ओर इंगित करें ताकि भविष्य की fetches I2P या clearnet के माध्यम से हों:\ngit remote set-url origin git@127.0.0.1:I2P_Developers/i2p.i2p या क्लियरनेट एक्सेस के लिए:\ngit remote set-url origin https://github.com/i2p/i2p.i2p I2P SSH एक्सेस के लिए, आपको अपने I2P router कंसोल में एक SSH क्लाइंट tunnel कॉन्फ़िगर करना होगा (आमतौर पर पोर्ट 7670) जो g6u4vqiuy6bdc3dbu6a7gmi3ip45sqwgtbgrr6uupqaaqfyztrka.b32.i2p की ओर इशारा करता हो। यदि गैर-मानक पोर्ट का उपयोग कर रहे हैं:\nGIT_SSH_COMMAND=\u0026#34;ssh -p 7670\u0026#34; git clone git@127.0.0.1:I2P_Developers/i2p.i2p 3. Creating a Bundle बंडल से क्लोनिंग सुनिश्चित करें कि आपकी repository complete clone के साथ पूरी तरह से अप-टू-डेट है (shallow नहीं):\ngit fetch --all यदि आपके पास shallow clone है, तो इसे पहले convert करें:\ngit fetch --unshallow लाइव रिमोट पर स्विच करना Ant build target का उपयोग (I2P source tree के लिए अनुशंसित):\nant git-bundle यह i2p.i2p.bundle (bundle फ़ाइल) और i2p.i2p.bundle.torrent (BitTorrent metadata) दोनों बनाता है।\ngit bundle का सीधे उपयोग करना:\ngit bundle create i2p.i2p.bundle --all अधिक चयनात्मक बंडल के लिए:\ngit bundle create i2p.i2p.bundle --branches --tags Verifying Your Bundle वितरित करने से पहले हमेशा bundle को सत्यापित करें:\ngit bundle verify i2p.i2p.bundle यह पुष्टि करता है कि bundle वैध है और किसी भी आवश्यक prerequisite commits को दिखाता है।\nपूर्वापेक्षाएँ बंडल और इसके टोरेंट मेटाडेटा को अपनी I2PSnark डायरेक्टरी में कॉपी करें:\nउपयोगकर्ता इंस्टॉलेशन के लिए:\ncp i2p.i2p.bundle* ~/.i2p/i2psnark/ सिस्टम इंस्टॉलेशन के लिए:\ncp i2p.i2p.bundle* /var/lib/i2p/i2p-config/i2psnark/ I2PSnark स्वचालित रूप से .torrent फाइलों का पता लगाता है और सेकंडों में लोड कर देता है। सीडिंग शुरू करने के लिए http://127.0.0.1:7657/i2psnark पर वेब इंटरफेस एक्सेस करें।\n4. Creating Incremental Bundles समय-समय पर अपडेट के लिए, केवल अंतिम बंडल के बाद के नए commits वाले incremental bundles बनाएं:\ngit tag lastBundleTag git bundle create update.bundle lastBundleTag..master उपयोगकर्ता incremental bundle से fetch कर सकते हैं यदि उनके पास पहले से base repository है:\ngit fetch /path/to/update.bundle हमेशा सत्यापित करें कि incremental bundles अपेक्षित prerequisite commits दिखाते हैं:\ngit bundle verify update.bundle 5. Updating After the Initial Clone एक बार जब आपके पास bundle से एक कार्यशील repository हो जाए, तो इसे किसी भी अन्य Git clone की तरह ट्रीट करें:\ngit remote add upstream git@127.0.0.1:I2P_Developers/i2p.i2p git fetch upstream git merge upstream/master या सरल वर्कफ़्लो के लिए:\ngit fetch origin git pull origin master 3. बंडल बनाना लचीला वितरण: बड़े repositories को BitTorrent के माध्यम से साझा किया जा सकता है, जो स्वचालित रूप से retries, piece verification, और resume को संभालता है। Peer-to-peer bootstrap: नए योगदानकर्ता I2P network पर निकटवर्ती peers से अपना clone bootstrap कर सकते हैं, फिर Git hosts से सीधे incremental changes प्राप्त कर सकते हैं। सर्वर लोड में कमी: Mirrors समय-समय पर bundles प्रकाशित कर सकते हैं ताकि live Git hosts पर दबाव कम हो, विशेष रूप से बड़े repositories या धीमी network स्थितियों के लिए उपयोगी। Offline transport: Bundles किसी भी file transport (USB drives, direct transfers, sneakernet) पर काम करते हैं, न कि केवल BitTorrent पर। बंडल लाइव रिमोट को प्रतिस्थापित नहीं करते हैं। वे केवल शुरुआती clone या बड़े अपडेट के लिए एक अधिक लचीली bootstrapping विधि प्रदान करते हैं।\n7. Troubleshooting बंडल उत्पन्न करना समस्या: Bundle निर्माण सफल होता है लेकिन अन्य bundle से clone नहीं कर सकते।\nकारण: आपका स्रोत क्लोन shallow है (--depth के साथ बनाया गया)।\nसमाधान: बंडल बनाने से पहले फुल clone में परिवर्तित करें:\ngit fetch --unshallow आपके बंडल का सत्यापन समस्या: बंडल से क्लोन करते समय fatal: multiple updates for ref।\nकारण: Git 2.21.0+ में ~/.gitconfig के global fetch refspecs के साथ विरोध है।\nसमाधान: 1. मैन्युअल इनिशियलाइज़ेशन का उपयोग करें: mkdir repo \u0026amp;\u0026amp; cd repo \u0026amp;\u0026amp; git init \u0026amp;\u0026amp; git fetch /path/to/bundle 2. --update-head-ok फ्लैग का उपयोग करें: git fetch --update-head-ok /path/to/bundle '*:*' 3. conflicting कॉन्फ़िग को हटाएं: git config --global --unset remote.origin.fetch\nI2PSnark के माध्यम से वितरण समस्या: git bundle verify लापता पूर्वापेक्षाओं की रिपोर्ट करता है।\nकारण: इंक्रीमेंटल bundle या अपूर्ण स्रोत क्लोन।\nसमाधान: या तो आवश्यक कमिट्स को फेच करें या पहले बेस बंडल का उपयोग करें, फिर इंक्रीमेंटल अपडेट लागू करें।\n","description":"बड़े रिपॉजिटरी को git bundle और BitTorrent के साथ fetch करना और वितरित करना","id":"555586cb7b43c73ad912bbb01f20326b","section":"docs","title":"I2P के लिए Git Bundles","url":"/hi/docs/applications/git-bundle/"},{"categories":null,"content":" मुख्य I2P विकास ब्रांच (i2p.i2p) को डेवलपर्स के लिए Java विकास के दो सामान्य रूप से उपयोग किए जाने वाले IDEs को आसानी से सेट अप करने में सक्षम बनाने के लिए स्थापित किया गया है: Eclipse और NetBeans। Eclipse मुख्य I2P विकास शाखाएँ (i2p.i2p और इससे निकली शाखाएँ) में build.gradle शामिल है ताकि शाखा को Eclipse में आसानी से सेटअप किया जा सके। सुनिश्चित करें कि आपके पास Eclipse का हाल का संस्करण है। 2017 से नया कोई भी संस्करण काम करेगा। I2P branch को किसी डायरेक्टरी में check out करें (जैसे $HOME/dev/i2p.i2p)। \"File → Import...\" चुनें और फिर \"Gradle\" के अंतर्गत \"Existing Gradle Project\" चुनें। \"Project root directory:\" के लिए वह डायरेक्टरी चुनें जिसमें I2P branch को check out किया गया था। \"Import Options\" डायलॉग में, \"Gradle Wrapper\" चुनें और Continue दबाएं। \"Import Preview\" डायलॉग में आप प्रोजेक्ट संरचना की समीक्षा कर सकते हैं। \"i2p.i2p\" के अंतर्गत कई प्रोजेक्ट दिखाई देने चाहिए। \"Finish\" दबाएं। हो गया! आपके workspace में अब I2P branch के भीतर सभी प्रोजेक्ट होने चाहिए, और उनकी build dependencies सही तरीके से सेट होनी चाहिए। NetBeans मुख्य I2P विकास ब्रांचेस (i2p.i2p और इससे बनी ब्रांचेस) में NetBeans प्रोजेक्ट फाइलें शामिल हैं। ","description":"Eclipse और NetBeans को Gradle और बंडल किए गए प्रोजेक्ट फाइलों के साथ I2P विकास के लिए सेटअप करें","id":"59847e4ae7ce8d8ccadb441422ecc856","section":"docs","title":"I2P के साथ IDE का उपयोग","url":"/hi/docs/guides/ides/"},{"categories":null,"content":"अपनी इंस्टॉलेशन विधि चुनें Windows पर I2P इंस्टॉल करने के दो तरीके हैं। वह विधि चुनें जो आपकी आवश्यकताओं के लिए सबसे उपयुक्त हो:\n🚀 Easy Install Bundle (Recommended) अधिकांश उपयोगकर्ताओं के लिए सर्वोत्तम\n✅ ऑल-इन-वन इंस्टॉलर ✅ Java शामिल (अलग से इंस्टॉल की आवश्यकता नहीं) ✅ Firefox प्रोफाइल शामिल ✅ सबसे तेज़ सेटअप\nयह तब चुनें जब: - आप सबसे सरल इंस्टॉलेशन चाहते हों - आपके पास Java इंस्टॉल नहीं है - आप I2P में नए हैं\nआसान इंस्टॉल गाइड →\n🚀 Easy Install Bundle (अनुशंसित) उन्नत उपयोगकर्ताओं के लिए\n📦 Java-आधारित JAR इंस्टॉलर 🔧 इंस्टॉलेशन पर अधिक नियंत्रण 💾 छोटा डाउनलोड आकार\nयह विकल्प चुनें यदि: - आपके पास पहले से Java इंस्टॉल है - आप अधिक नियंत्रण चाहते हैं - आप पारंपरिक तरीका पसंद करते हैं\nमानक इंस्टॉल गाइड →\nमुझे खेद है, लेकिन आपने अनुवाद करने के लिए कोई टेक्स्ट प्रदान नहीं किया है। \u0026ldquo;\u0026mdash;\u0026rdquo; के बाद कोई सामग्री नहीं है।\nकृपया वह टेक्स्ट प्रदान करें जिसका आप अनुवाद चाहते हैं।\nEasy Install Bundle ⚙️ मानक इंस्टॉलेशन I2P Easy Install Bundle Windows उपयोगकर्ताओं के लिए अनुशंसित इंस्टॉलेशन विधि है। यह ऑल-इन-वन इंस्टॉलर में I2P के साथ शुरुआत करने के लिए आवश्यक सब कुछ शामिल है:\nI2P Router - मुख्य I2P सॉफ़्टवेयर Embedded Java Runtime - अलग से Java इंस्टॉलेशन की आवश्यकता नहीं Firefox profiles and extensions - सुरक्षित ब्राउज़िंग के लिए I2P-अनुकूलित ब्राउज़र profiles और extensions Simple installer - मैन्युअल कॉन्फ़िगरेशन की आवश्यकता नहीं Automatic updates - अपने I2P सॉफ़्टवेयर को अपडेट रखें यह बीटा इंस्टॉलर Java को सीधे बंडल करके इंस्टॉलेशन प्रक्रिया को सरल बनाता है, इसलिए आपको अलग से Java डाउनलोड या कॉन्फ़िगर करने की आवश्यकता नहीं है।\nIMPORTANT: केवल अनुवाद प्रदान करें। प्रश्न न पूछें, स्पष्टीकरण न दें, या कोई टिप्पणी न जोड़ें। भले ही पाठ केवल शीर्षक हो या अधूरा प्रतीत हो, इसे जैसा है वैसा ही अनुवादित करें।\nआसान इंस्टॉल बंडल अगला, आपको I2P लाइसेंस जानकारी दिखाई जाएगी। Easy Install Bundle में विभिन्न मुक्त और ओपन-सोर्स लाइसेंसों के तहत घटक शामिल हैं।\nइंस्टॉलेशन जारी रखने के लिए: 1. लाइसेंस जानकारी की समीक्षा करें (वैकल्पिक लेकिन अनुशंसित) 2. लाइसेंस स्वीकार करने और आगे बढ़ने के लिए I Agree पर क्लिक करें 3. यदि आप इंस्टॉल नहीं करना चाहते हैं तो Cancel पर क्लिक करें\nIMPORTANT: केवल अनुवाद प्रदान करें। प्रश्न न पूछें, स्पष्टीकरण न दें, या कोई टिप्पणी न जोड़ें। भले ही टेक्स्ट केवल एक शीर्षक हो या अधूरा लगे, इसे जैसा है वैसे ही अनुवाद करें।\nचरण 1: अपनी भाषा चुनें इंस्टॉलेशन पूरा होने के बाद, आपको completion screen दिखाई देगी।\nसेटअप विज़ार्ड पुष्टि करता है कि \u0026ldquo;I2P - i2peasy आपके कंप्यूटर पर इंस्टॉल हो गया है।\u0026rdquo;\nमहत्वपूर्ण: सुनिश्चित करें कि \u0026ldquo;Start I2P?\u0026rdquo; चेकबॉक्स चेक किया गया है (यह डिफ़ॉल्ट रूप से चेक होना चाहिए)।\nचेक किया हुआ (अनुशंसित): जब आप Finish पर क्लिक करेंगे तो I2P स्वचालित रूप से शुरू हो जाएगा अनचेक किया हुआ: आपको बाद में Start Menu या desktop shortcut से I2P को मैन्युअल रूप से शुरू करना होगा इंस्टॉलेशन पूर्ण करने और I2P लॉन्च करने के लिए Finish पर क्लिक करें।\n(नोट: दिया गया टेक्स्ट खाली है - केवल एक खाली लाइन है। अनुवाद के लिए कोई सामग्री नहीं है।)\nचरण 2: लाइसेंस समझौता स्वीकार करें \u0026ldquo;Start I2P?\u0026rdquo; चेक करके Finish पर क्लिक करने के बाद:\nI2P Router शुरू होता है - I2P router बैकग्राउंड में चलना शुरू करता है सिस्टम ट्रे आइकन दिखाई देता है - अपने Windows सिस्टम ट्रे (नीचे-दाएं कोने) में I2P आइकन देखें Router console खुलता है - आपका डिफ़ॉल्ट वेब ब्राउज़र स्वचालित रूप से I2P Router Console पर खुलेगा (आमतौर पर http://127.0.0.1:7657 पर) प्रारंभिक कनेक्शन - I2P नेटवर्क से कनेक्ट होना और tunnels बनाना शुरू करेगा (पहली बार लॉन्च करने पर इसमें 5-10 मिनट लग सकते हैं) बधाई हो! I2P अब आपके Windows कंप्यूटर पर इंस्टॉल और चल रहा है।\nचरण 4: इंस्टॉलेशन पूर्ण करें और I2P प्रारंभ करें नेटवर्क एकीकरण की प्रतीक्षा करें: I2P को नेटवर्क में एकीकृत होने और tunnel बनाने के लिए 5-10 मिनट का समय दें अपना ब्राउज़र कॉन्फ़िगर करें: I2P ब्राउज़िंग के लिए शामिल Firefox प्रोफ़ाइल का उपयोग करें अपना पोर्ट फॉरवर्ड करें: I2P द्वारा उपयोग किए जा रहे पोर्ट को फॉरवर्ड करने के लिए राउटर-विशिष्ट निर्देशों हेतु portforward.com देखें router console देखें: I2P की सुविधाओं, सेवाओं और कॉन्फ़िगरेशन विकल्पों के बारे में जानें eepsites पर जाएं: I2P नेटवर्क के माध्यम से .i2p वेबसाइटों तक पहुंचने का प्रयास करें दस्तावेज़ीकरण पढ़ें: अधिक जानकारी के लिए I2P documentation देखें I2P नेटवर्क में आपका स्वागत है! 🎉\n\u0026quot; के बाद अनुवाद करने के लिए सामग्री शामिल करें।\nअनुशंसित: Port Forwarding (वैकल्पिक लेकिन महत्वपूर्ण) I2P इंस्टॉल करने से पहले, आपके सिस्टम पर Java इंस्टॉल होना आवश्यक है।\nJava Requirements Java संस्करण: Java 8 (1.8) या उच्चतर आवश्यक अनुशंसित: Java 11 या बाद का (LTS संस्करण) प्रकार: Java Runtime Environment (JRE) या Java Development Kit (JDK) Installing Java यदि आपके पास पहले से Java इंस्टॉल नहीं है, तो आप इसे कई स्रोतों से डाउनलोड कर सकते हैं:\nविकल्प 1: Oracle Java - आधिकारिक स्रोत: java.com/download - सबसे व्यापक रूप से उपयोग किया जाने वाला वितरण\nविकल्प 2: OpenJDK - ओपन-सोर्स कार्यान्वयन: openjdk.org - निःशुल्क और ओपन-सोर्स\nविकल्प 3: Adoptium (Eclipse Temurin) - अनुशंसित विकल्प: adoptium.net - निःशुल्क, ओपन-सोर्स, और अच्छी तरह से रखरखाव किए गए LTS रिलीज़\nJava इंस्टॉल होने की पुष्टि करने के लिए: 1. Command Prompt खोलें (Windows + R दबाएं, cmd टाइप करें, Enter दबाएं) 2. टाइप करें: java -version 3. आपको अपने Java संस्करण को दर्शाने वाला आउटपुट दिखाई देना चाहिए\nIMPORTANT: केवल अनुवाद प्रदान करें। प्रश्न न पूछें, स्पष्टीकरण न दें, या कोई टिप्पणी न जोड़ें। भले ही टेक्स्ट केवल एक शीर्षक हो या अधूरा लगे, इसे जैसा है वैसा ही अनुवाद करें।\nStep 2: Download and Launch the I2P Installer I2P installer डाउनलोड करें:\nI2P downloads पेज पर जाएं Windows installer (JAR फ़ाइल) डाउनलोड करें: i2pinstall_X.X.X.jar इसे ऐसी जगह सेव करें जहां आप आसानी से ढूंढ सकें (जैसे, Downloads फ़ोल्डर) इंस्टॉलर लॉन्च करें:\nइंस्टॉलर लॉन्च करने के लिए डाउनलोड की गई JAR फ़ाइल पर डबल-क्लिक करें यदि डबल-क्लिक काम नहीं करता है, तो फ़ाइल पर राइट-क्लिक करें और \u0026ldquo;Open with → Java(TM) Platform SE binary\u0026rdquo; चुनें वैकल्पिक रूप से, Command Prompt खोलें और चलाएँ: java -jar i2pinstall_X.X.X.jar Step 3: Select Your Language इंस्टॉलर लॉन्च करने के बाद, आपको भाषा चयन डायलॉग दिखाई देगा।\nड्रॉपडाउन मेनू से अपनी पसंदीदा भाषा चुनें उपलब्ध भाषाओं में अंग्रेजी, जर्मन, स्पेनिश, फ्रेंच और कई अन्य शामिल हैं जारी रखने के लिए OK पर क्लिक करें इंस्टॉलर आपकी चुनी गई भाषा का उपयोग सभी आगामी चरणों के लिए करेगा।\nIMPORTANT: केवल अनुवाद प्रदान करें। कोई प्रश्न न पूछें, कोई स्पष्टीकरण न दें, या कोई टिप्पणी न जोड़ें। भले ही पाठ केवल एक शीर्षक हो या अधूरा लगे, इसे ज्यों का त्यों अनुवाद करें।\nअगले चरण यह इंस्टॉलेशन प्रक्रिया में 8 में से चरण 2 है।\nलाइसेंस स्वीकार करने और जारी रखने के लिए Next पर क्लिक करें।\nIMPORTANT: केवल अनुवाद प्रदान करें। प्रश्न न पूछें, स्पष्टीकरण न दें, या कोई टिप्पणी न जोड़ें। यदि टेक्स्ट केवल एक शीर्षक है या अधूरा प्रतीत होता है, तो इसे जैसा है वैसा ही अनुवाद करें।\nStep 7: Select Installation Packs इंस्टॉल करने के लिए कंपोनेंट चुनें।\nमहत्वपूर्ण: सुनिश्चित करें कि दोनों पैक चयनित हैं: - Base (आवश्यक) - मुख्य I2P सॉफ़्टवेयर (27.53 MB) - Windows Service (अनुशंसित) - बूट पर स्वचालित रूप से I2P प्रारंभ करें\nWindows Service विकल्प यह सुनिश्चित करता है कि आपके कंप्यूटर के बूट होने पर I2P स्वचालित रूप से शुरू हो जाए, इसलिए आपको हर बार इसे मैन्युअल रूप से शुरू करने की आवश्यकता नहीं है।\nयह इंस्टॉलेशन प्रक्रिया में स्टेप 4 में से 8 है।\nजारी रखने के लिए Next पर क्लिक करें।\nIMPORTANT: केवल अनुवाद प्रदान करें। प्रश्न न पूछें, स्पष्टीकरण न दें, या कोई टिप्पणी न जोड़ें। भले ही टेक्स्ट सिर्फ एक शीर्षक हो या अधूरा लगे, इसे जैसा है वैसा ही अनुवादित करें।\nStep 10: Installation Complete इंस्टॉलेशन अब पूरी हो गई है!\nआप देखेंगे: - ✓ Installation has completed successfully - An uninstaller will be created in: C:\\Program Files (x86)\\i2p\\Uninstaller\nयह 8 में से चरण 8 है - इंस्टॉलेशन प्रक्रिया का अंतिम चरण।\nDone पर क्लिक करके समाप्त करें।\nचरण 3: अपनी भाषा चुनें नेटवर्क एकीकरण की प्रतीक्षा करें: I2P को नेटवर्क में एकीकृत होने और tunnel बनाने के लिए 5-10 मिनट दें पोर्ट फॉरवर्डिंग कॉन्फ़िगर करें: निर्देशों के लिए पोर्ट फॉरवर्डिंग गाइड देखें अपना ब्राउज़र कॉन्फ़िगर करें: अपने वेब ब्राउज़र को I2P के HTTP proxy का उपयोग करने के लिए सेट करें router console देखें: I2P की सुविधाओं, सेवाओं और कॉन्फ़िगरेशन विकल्पों के बारे में जानें eepsites पर जाएं: I2P नेटवर्क के माध्यम से .i2p वेबसाइटों तक पहुंचने का प्रयास करें दस्तावेज़ीकरण पढ़ें: अधिक जानकारी के लिए I2P दस्तावेज़ीकरण देखें I2P नेटवर्क में आपका स्वागत है! 🎉\n","description":"अपनी Windows इंस्टॉलेशन विधि चुनें: Easy Install Bundle या Standard Installation","id":"4aa0b74199a71c11718a9986e74b3a26","section":"docs","title":"I2P को Windows पर इंस्टॉल करना","url":"/hi/docs/guides/i2p-%E0%A4%95%E0%A5%8B-windows-%E0%A4%AA%E0%A4%B0-%E0%A4%87%E0%A4%82%E0%A4%B8%E0%A5%8D%E0%A4%9F%E0%A5%89%E0%A4%B2-%E0%A4%95%E0%A4%B0%E0%A4%A8%E0%A4%BE/"},{"categories":null,"content":"अवलोकन I2CP I2P router और किसी भी क्लाइंट प्रक्रिया के बीच निम्न-स्तरीय नियंत्रण प्रोटोकॉल है। यह जिम्मेदारियों का सख्त पृथक्करण परिभाषित करता है:\nRouter: रूटिंग, क्रिप्टोग्राफी, tunnels के जीवनचक्र, और नेटवर्क डेटाबेस संचालन का प्रबंधन करता है क्लाइंट: अनामिकता गुणों का चयन करता है, tunnels को कॉन्फ़िगर करता है, और संदेश भेजता/प्राप्त करता है संपूर्ण संचार एकल TCP socket (नेटवर्क कनेक्शन का एंडपॉइंट) के माध्यम से होता है (वैकल्पिक रूप से TLS-wrapped (TLS द्वारा संरक्षित)), जो असमकालिक, full-duplex (दो-तरफ़ा समानांतर संचार) संचालन को सक्षम बनाता है।\nप्रोटोकॉल संस्करण: I2CP प्रारंभिक कनेक्शन स्थापना के दौरान भेजे जाने वाले प्रोटोकॉल संस्करण बाइट 0x2A (दशमलव में 42) का उपयोग करता है। यह संस्करण बाइट प्रोटोकॉल की शुरुआत से स्थिर बना हुआ है।\nवर्तमान स्थिति: यह विनिर्देशन router संस्करण 0.9.67 (API संस्करण 0.9.67) के लिए सटीक है, जो 2025-09 में जारी हुआ।\nकार्यान्वयन संदर्भ जावा कार्यान्वयन संदर्भ कार्यान्वयन Java I2P में है:\nक्लाइंट SDK: i2p.jar पैकेज router कार्यान्वयन: router.jar पैकेज Javadocs जब क्लाइंट और router एक ही JVM में चलते हैं, तो I2CP संदेशों को serialization (डेटा को बाइट अनुक्रम में बदलना) के बिना Java ऑब्जेक्ट्स के रूप में पास किया जाता है। बाहरी क्लाइंट TCP पर serialized प्रोटोकॉल का उपयोग करते हैं।\nC++ कार्यान्वयन i2pd (C++ I2P router) क्लाइंट कनेक्शनों के लिए I2CP को बाहरी रूप से भी इम्प्लीमेंट करता है।\nगैर‑Java क्लाइंट्स एक पूर्ण I2CP क्लाइंट लाइब्रेरी के कोई ज्ञात गैर-जावा कार्यान्वयन नहीं हैं। गैर-जावा अनुप्रयोगों को इसके बजाय उच्च-स्तरीय प्रोटोकॉल का उपयोग करना चाहिए:\nSAM (Simple Anonymous Messaging) v3: सॉकेट-आधारित इंटरफेस, कई भाषाओं में उपलब्ध लाइब्रेरीज़ के साथ BOB (Basic Open Bridge): SAM का सरल विकल्प ये उच्च-स्तरीय प्रोटोकॉल I2CP की जटिलता को आंतरिक रूप से संभालते हैं और साथ ही स्ट्रीमिंग लाइब्रेरी (TCP जैसी कनेक्शनों के लिए) और डेटाग्राम लाइब्रेरी (UDP जैसी कनेक्शनों के लिए) भी प्रदान करते हैं।\nकनेक्शन स्थापना 1. TCP कनेक्शन router के I2CP पोर्ट से कनेक्ट करें: - डिफ़ॉल्ट: 127.0.0.1:7654 - router सेटिंग्स के माध्यम से कॉन्फ़िगर किया जा सकता है - वैकल्पिक TLS wrapper (रैपर) (दूरस्थ कनेक्शनों के लिए दृढ़तापूर्वक अनुशंसित)\n2. प्रोटोकॉल हैंडशेक चरण 1: प्रोटोकॉल संस्करण बाइट 0x2A भेजें\nचरण 2: घड़ी समकालन\nClient → Router: GetDateMessage Router → Client: SetDateMessage router अपना वर्तमान समय-चिह्न और I2CP API संस्करण स्ट्रिंग लौटाता है (0.8.7 से)।\nचरण 3: प्रमाणीकरण (यदि सक्षम हो)\n0.9.11 से, प्रमाणीकरण को GetDateMessage (तारीख प्राप्त करने वाला संदेश) में ऐसी Mapping (मैपिंग) के माध्यम से शामिल किया जा सकता है, जिसमें निम्नलिखित हों: - i2cp.username - i2cp.password\nसंस्करण 0.9.16 से, जब प्रमाणीकरण सक्षम होता है, तो अन्य कोई संदेश भेजे जाने से पहले प्रमाणीकरण को GetDateMessage के माध्यम से अवश्य पूरा किया जाना है।\nचरण 4: सत्र निर्माण\nClient → Router: CreateSessionMessage (contains SessionConfig) Router → Client: SessionStatusMessage (status=Created) चरण 5: Tunnel तैयार होने का संकेत\nRouter → Client: RequestVariableLeaseSetMessage यह संदेश संकेत देता है कि inbound tunnels बन चुके हैं। router इसे तब तक नहीं भेजेगा जब तक कम से कम एक inbound और एक outbound tunnel मौजूद न हों।\nचरण 6: LeaseSet का प्रकाशन\nClient → Router: CreateLeaseSet2Message इस चरण में, सत्र संदेश भेजने और प्राप्त करने के लिए पूर्ण रूप से क्रियाशील है।\nसंदेश प्रवाह पैटर्न प्रेषित संदेश (क्लाइंट दूरस्थ गंतव्य को भेजता है) i2cp.messageReliability=none के साथ:\nClient → Router: SendMessageMessage (nonce=0) [No acknowledgments] i2cp.messageReliability=BestEffort के साथ:\nClient → Router: SendMessageMessage (nonce\u0026gt;0) Router → Client: MessageStatusMessage (status=Accepted) Router → Client: MessageStatusMessage (status=Success or Failure) आने वाला संदेश (Router क्लाइंट तक पहुँचाता है) i2cp.fastReceive=true होने पर (0.9.4 से डिफ़ॉल्ट):\nRouter → Client: MessagePayloadMessage [No acknowledgment required] i2cp.fastReceive=false के साथ (अप्रचलित):\nRouter → Client: MessageStatusMessage (status=Available) Client → Router: ReceiveMessageBeginMessage Router → Client: MessagePayloadMessage Client → Router: ReceiveMessageEndMessage आधुनिक क्लाइंट्स को हमेशा fast receive mode (तेज़ प्राप्ति मोड) का उपयोग करना चाहिए।\nसामान्य डेटा संरचनाएँ I2CP संदेश शीर्षलेख सभी I2CP संदेश इस सामान्य हेडर का उपयोग करते हैं:\n+----+----+----+----+----+----+----+----+ | Body Length (4 bytes) | +----+----+----+----+----+----+----+----+ |Type| Message Body (variable) | +----+----+----+----+----+----+----+----+ बॉडी लंबाई: 4-बाइट पूर्णांक, केवल संदेश बॉडी की लंबाई (हेडर को छोड़कर) प्रकार: 1-बाइट पूर्णांक, संदेश प्रकार पहचानकर्ता संदेश बॉडी: 0+ बाइट्स, प्रारूप संदेश प्रकार के अनुसार बदलता है संदेश आकार की सीमा: अधिकतम लगभग 64 KB.\nसेशन आईडी 2-बाइट का पूर्णांक, जो router पर किसी सत्र की अद्वितीय पहचान करता है।\nविशेष मान: 0xFFFF \u0026ldquo;कोई सत्र नहीं\u0026rdquo; का संकेत करता है (स्थापित सत्र के बिना hostname लुकअप्स के लिए उपयोग किया जाता है)।\nसंदेश आईडी किसी सत्र के भीतर किसी संदेश की अद्वितीय पहचान के लिए router द्वारा उत्पन्न 4-बाइट पूर्णांक।\nमहत्वपूर्ण: संदेश आईडी वैश्विक रूप से अद्वितीय नहीं हैं; वे केवल एक सत्र के भीतर अद्वितीय हैं। वे क्लाइंट द्वारा उत्पन्न nonce (एक बार प्रयुक्त यादृच्छिक संख्या) से भी भिन्न हैं।\nपेलोड प्रारूप संदेश पेलोड मानक 10-बाइट gzip हेडर के साथ gzip से संपीड़ित होते हैं: - शुरुआत होती है: 0x1F 0x8B 0x08 (RFC 1952) - 0.7.1 से: gzip हेडर के अप्रयुक्त हिस्सों में प्रोटोकॉल, from-port, और to-port की जानकारी शामिल होती है - यह एक ही गंतव्य पर स्ट्रीमिंग और डेटाग्राम को सक्षम करता है\nसंपीड़न नियंत्रण: संपीड़न को अक्षम करने के लिए i2cp.gzip=false सेट करें (gzip effort (प्रयास) को 0 पर सेट करता है)। gzip हेडर अभी भी शामिल रहता है, लेकिन संपीड़न ओवरहेड न्यूनतम रहता है।\nSessionConfig संरचना क्लाइंट सत्र के लिए विन्यास परिभाषित करता है:\n+----------------------------------+ | Destination | +----------------------------------+ | Mapping (configuration options) | +----------------------------------+ | Creation Date | +----------------------------------+ | Signature | +----------------------------------+ महत्वपूर्ण आवश्यकताएँ: 1. मैपिंग को कुंजी के आधार पर क्रमबद्ध होना चाहिए हस्ताक्षर सत्यापन के लिए 2. निर्माण तिथि router के वर्तमान समय से ±30 सेकंड के भीतर होनी चाहिए 3. हस्ताक्षर Destination (I2P में गंतव्य पहचान/एंडपॉइंट) के SigningPrivateKey (हस्ताक्षर करने वाली निजी कुंजी) द्वारा बनाया जाता है\nऑफ़लाइन हस्ताक्षर (संस्करण 0.9.38 के अनुसार):\nयदि आप ऑफ़लाइन साइनिंग का उपयोग कर रहे हैं, तो मैपिंग में शामिल होना चाहिए: - i2cp.leaseSetOfflineExpiration - i2cp.leaseSetTransientPublicKey - i2cp.leaseSetOfflineSignature\nफिर हस्ताक्षर अस्थायी SigningPrivateKey द्वारा उत्पन्न किया जाता है.\nमुख्य कॉन्फ़िगरेशन विकल्प Tunnel विन्यास Option Default Description inbound.length 3 Number of hops for inbound tunnels outbound.length 3 Number of hops for outbound tunnels inbound.lengthVariance 0 Random variance in hop count (since 0.7.6) outbound.lengthVariance 0 Random variance in hop count (since 0.7.6) inbound.quantity 2 Number of concurrent inbound tunnels outbound.quantity 2 Number of concurrent outbound tunnels inbound.backupQuantity 0 Standby inbound tunnels (hot spares) outbound.backupQuantity 0 Standby outbound tunnels (hot spares) inbound.allowZeroHop true Allow 0-hop tunnels (disable for full anonymity) outbound.allowZeroHop true Allow 0-hop tunnels (disable for full anonymity) **टिप्पणियाँ**: - `quantity` के लिए मान \u003e 6 को 0.9.0+ चलाने वाले पीयर्स की आवश्यकता होती है और यह संसाधन उपयोग को उल्लेखनीय रूप से बढ़ा देता है - उच्च-उपलब्धता सेवाओं के लिए `backupQuantity` को 1-2 पर सेट करें - Zero-hop tunnels (शून्य-हॉप tunnels) में विलंबता कम करने के लिए गुमनामी का त्याग किया जाता है, लेकिन ये परीक्षण के लिए उपयोगी हैं संदेश प्रबंधन Option Default Description clientMessageTimeout 60000\u0026nbsp;ms Legacy timeout for message delivery i2cp.messageReliability BestEffort None, BestEffort, or Guaranteed i2cp.fastReceive true Skip ReceiveMessageBegin/End handshake (default since 0.9.4) i2cp.gzip true Enable gzip compression of message payloads outbound.priority 0 Priority for outbound scheduling (-25 to +25) **संदेश विश्वसनीयता**: - `None`: router से कोई स्वीकृति नहीं (0.8.1 से स्ट्रीमिंग लाइब्रेरी का डिफ़ॉल्ट) - `BestEffort`: router स्वीकृति + सफलता/विफलता सूचनाएँ भेजता है - `Guaranteed`: लागू नहीं (वर्तमान में BestEffort की तरह व्यवहार करता है) प्रति-संदेश ओवरराइड (0.9.14 से): - messageReliability=none वाले सत्र में, शून्य से भिन्न nonce (एक-बार-प्रयोग होने वाली अद्वितीय संख्या) सेट करने पर उस विशिष्ट संदेश के लिए डिलीवरी सूचना का अनुरोध होता है - BestEffort सत्र में nonce=0 सेट करने से उस संदेश के लिए सूचनाएँ निष्क्रिय हो जाती हैं\nLeaseSet विन्यास Option Default Description i2cp.dontPublishLeaseSet false Disable automatic LeaseSet publication (for client-only destinations) i2cp.leaseSetType 1 LeaseSet variant: 1 = standard, 3 = LS2, 5 = encrypted, 7 = meta i2cp.leaseSetEncType 0 Comma-separated encryption type codes (see below) ### लेगेसी ElGamal/AES सेशन टैग्स ये विकल्प केवल पुराने ElGamal एन्क्रिप्शन के लिए प्रासंगिक हैं:\nOption Default Description crypto.lowTagThreshold 30 Minimum session tags before replenishing crypto.tagsToSend 40 Number of tags to send in a batch **नोट**: ECIES-X25519 क्लाइंट एक अलग ratchet mechanism (क्रमिक कुंजी-परिवर्तन तंत्र) का उपयोग करते हैं और इन विकल्पों को नज़रअंदाज़ करते हैं। एन्क्रिप्शन के प्रकार I2CP i2cp.leaseSetEncType विकल्प के माध्यम से कई एंड-टू-एंड एन्क्रिप्शन पद्धतियों का समर्थन करता है। आधुनिक और पुराने समकक्षों दोनों का समर्थन करने के लिए कई प्रकार (कॉमा से अलग करके) निर्दिष्ट किए जा सकते हैं।\nसमर्थित एन्क्रिप्शन प्रकार Type Algorithm Key Size Since Status 0 ElGamal/AES+SessionTags 2048-bit ElGamal Original Legacy 1-3 Reserved - - Unused 4 ECIES-X25519-AEAD-Ratchet 32-byte X25519 0.9.46 Current Standard 5 ECIES-X25519-AEAD-Ratchet + ML-KEM-768 hybrid 32\u0026nbsp;+\u0026nbsp;PQ 0.9.67 Beta 6 ECIES-X25519-AEAD-Ratchet + ML-KEM-1024 hybrid 32\u0026nbsp;+\u0026nbsp;PQ 0.9.67 Beta 7 Reserved (likely ML-KEM-512 hybrid) 32\u0026nbsp;+\u0026nbsp;PQ Future Planned **अनुशंसित विन्यास**: i2cp.leaseSetEncType=4,0 यह X25519 (वांछित; एक आधुनिक elliptic-curve key agreement एल्गोरिद्म) को अनुकूलता के लिए ElGamal (एक सार्वजनिक-कुंजी क्रिप्टोसिस्टम) फॉलबैक के साथ प्रदान करता है।\nएन्क्रिप्शन प्रकार के विवरण प्रकार 0 - ElGamal/AES+SessionTags: - 2048-बिट ElGamal सार्वजनिक कुंजियाँ (256 बाइट) - AES-256 सममित एन्क्रिप्शन - 32-बाइट session tags (अस्थायी सत्र-टोकन) बैचों में भेजे जाते हैं - उच्च CPU, बैंडविड्थ और मेमोरी ओवरहेड - पूरे नेटवर्क में चरणबद्ध रूप से हटाया जा रहा है\nप्रकार 4 - ECIES-X25519-AEAD-Ratchet: - X25519 कुंजी विनिमय (32-बाइट कुंजियाँ) - ChaCha20/Poly1305 AEAD (Authenticated Encryption with Associated Data, संबद्ध डेटा सहित प्रमाणित एन्क्रिप्शन) - Signal-style double ratchet (डबल रैचेट, Signal जैसा कुंजी-अपडेट तंत्र) - 8-बाइट सेशन टैग (ElGamal के लिए 32-बाइट के मुकाबले) - टैग synchronized PRNG (pseudorandom number generator, छद्म-यादृच्छिक संख्या जनक) के माध्यम से उत्पन्न किए जाते हैं (पहले से नहीं भेजे जाते) - ~92% ओवरहेड में कमी (ElGamal की तुलना में) - आधुनिक I2P के लिए मानक (अधिकांश routers इसका उपयोग करते हैं)\nप्रकार 5-6 - पोस्ट-क्वांटम हाइब्रिड: - X25519 को ML-KEM (कुंजी एन्कैप्सुलेशन तंत्र) (NIST FIPS 203) के साथ संयोजित करता है - क्वांटम-प्रतिरोधी सुरक्षा प्रदान करता है - संतुलित सुरक्षा/प्रदर्शन के लिए ML-KEM-768 - अधिकतम सुरक्षा के लिए ML-KEM-1024 - PQ (पोस्ट-क्वांटम) कुंजी सामग्री के कारण संदेश आकार बड़े होते हैं - नेटवर्क समर्थन का परिनियोजन अभी भी जारी है\nस्थानांतरण रणनीति I2P नेटवर्क सक्रिय रूप से ElGamal (प्रकार 0) से X25519 (प्रकार 4) में माइग्रेट हो रहा है: - NTCP → NTCP2 (पूर्ण) - SSU → SSU2 (पूर्ण) - ElGamal tunnels → X25519 tunnels (पूर्ण) - ElGamal end-to-end (छोर-से-छोर) → ECIES-X25519 (अधिकांशतः पूर्ण)\nLeaseSet2 और उन्नत विशेषताएँ LeaseSet2 विकल्प (0.9.38 से) Option Since Purpose i2cp.leaseSetType 0.9.38 Specifies LeaseSet variant (1, 3, 5, 7) i2cp.leaseSetEncType 0.9.38 Encryption types supported (comma-separated) i2cp.leaseSetAuthType 0.9.41 Per-client authentication: 0 = none, 1 = DH, 2 = PSK i2cp.leaseSetPrivKey 0.9.41 X25519 private key for decrypting LS2 with auth i2cp.leaseSetSecret 0.9.39 Base64 secret for blinded addresses i2cp.leaseSetTransientPublicKey 0.9.38 Transient signing key for offline signatures i2cp.leaseSetPrivateKey 0.9.18 Persistent LeaseSet encryption keys (type:key pairs) i2cp.leaseSetOption.nnn 0.9.66 Service records (proposal 167) i2cp.leaseSetClient.dh.nnn 0.9.41 DH client auth material (indexed from 0) i2cp.leaseSetClient.psk.nnn 0.9.41 PSK client auth material (indexed from 0) ### Blinded Addresses (क्रिप्टोग्राफिक ब्लाइंडिंग के जरिए छुपाए गए पते) संस्करण 0.9.39 से, गंतव्य \u0026ldquo;blinded\u0026rdquo; पते (b33 format) का उपयोग कर सकते हैं जो समय-समय पर बदलते हैं: - पासवर्ड सुरक्षा के लिए i2cp.leaseSetSecret आवश्यक है - प्रति-क्लाइंट वैकल्पिक प्रमाणीकरण - विवरण के लिए प्रस्ताव 123 और 149 देखें\nसेवा रिकॉर्ड (0.9.66 से) LeaseSet2 सेवा रिकॉर्ड विकल्पों का समर्थन करता है (प्रस्ताव 167):\ni2cp.leaseSetOption.0=_smtp._tcp=1 86400 0 0 25 mail.example.b32.i2p प्रारूप DNS SRV रिकॉर्ड शैली का अनुसरण करता है, लेकिन I2P के लिए अनुकूलित है।\nएकाधिक सत्र (0.9.21 से) एकल I2CP कनेक्शन कई सत्रों को बनाए रख सकता है:\nप्राथमिक सत्र: किसी कनेक्शन पर बनाया गया पहला सत्र उप-सत्र: वे अतिरिक्त सत्र जो प्राथमिक सत्र के tunnel पूल को साझा करते हैं\nउपसत्र की विशेषताएँ साझा Tunnels: प्राथमिक वाले ही इनबाउंड/आउटबाउंड tunnel pools का उपयोग करें साझा एन्क्रिप्शन कुंजियाँ: एकसमान LeaseSet एन्क्रिप्शन कुंजियों का उपयोग करना अनिवार्य है भिन्न हस्ताक्षर कुंजियाँ: अलग-अलग Destination (गंतव्य) हस्ताक्षर कुंजियों का उपयोग करना अनिवार्य है गुमनामी की कोई गारंटी नहीं: प्राथमिक सत्र से स्पष्ट रूप से जुड़ा हुआ (उसी router, वही tunnels) Subsession (उप-सत्र) उपयोग-प्रकरण विभिन्न हस्ताक्षर प्रकारों का उपयोग करने वाले गंतव्यों के साथ संचार सक्षम करें: - प्राथमिक: EdDSA हस्ताक्षर (आधुनिक) - उप-सत्र: DSA हस्ताक्षर (पुराने संस्करणों के साथ अनुकूलता)\nSubsession (उप-सत्र) का जीवनचक्र निर्माण:\nClient → Router: CreateSessionMessage Router → Client: SessionStatusMessage (unique Session ID) Router → Client: RequestVariableLeaseSetMessage (separate for each destination) Client → Router: CreateLeaseSet2Message (separate for each destination) समापन: - उप-सत्र को समाप्त करना: प्राथमिक सत्र अक्षुण्ण रहता है - प्राथमिक सत्र को समाप्त करना: सभी उप-सत्रों को समाप्त कर देता है और कनेक्शन बंद करता है - DisconnectMessage (डिस्कनेक्ट संदेश): सभी सत्रों को समाप्त कर देता है\nसत्र ID प्रबंधन अधिकांश I2CP संदेशों में एक Session ID फ़ील्ड शामिल होती है. अपवाद: - DestLookup / DestReply (अप्रचलित, HostLookup / HostReply का उपयोग करें) - GetBandwidthLimits / BandwidthLimits (प्रतिक्रिया सत्र-विशिष्ट नहीं है)\nमहत्वपूर्ण: क्लाइंट्स को एक साथ कई CreateSession संदेश लंबित नहीं रखने चाहिए, क्योंकि प्रतिक्रियाओं को अनुरोधों से निश्चित रूप से संबद्ध नहीं किया जा सकता।\nसंदेश कैटलॉग संदेश प्रकारों का सारांश Type Name Direction Since Status 1 CreateSession C → R Original Current 2 ReconfigureSession C → R 0.7.1 Current 3 DestroySession C → R Original Current 4 CreateLeaseSet C → R Original Deprecated 5 SendMessage C → R Original Current 6 ReceiveMessageBegin C → R Original Deprecated 7 ReceiveMessageEnd C → R Original Deprecated 8 GetBandwidthLimits C → R 0.7.2 Current 20 SessionStatus R → C Original Current 21 RequestLeaseSet R → C Original Deprecated 22 MessageStatus R → C Original Current 23 BandwidthLimits R → C 0.7.2 Current 29 ReportAbuse Bidirectional Original Unused 30 Disconnect Bidirectional Original Current 31 MessagePayload R → C Original Current 32 GetDate C → R Original Current 33 SetDate R → C Original Current 34 DestLookup C → R 0.7 Deprecated 35 DestReply R → C 0.7 Deprecated 36 SendMessageExpires C → R 0.7.1 Current 37 RequestVariableLeaseSet R → C 0.9.7 Current 38 HostLookup C → R 0.9.11 Current 39 HostReply R → C 0.9.11 Current 41 CreateLeaseSet2 C → R 0.9.39 Current 42 BlindingInfo C → R 0.9.43 Current **कुंजी**: C = क्लाइंट, R = Router मुख्य संदेश के विवरण CreateSessionMessage (प्रकार 1) उद्देश्य: एक नया I2CP सत्र प्रारंभ करें\nसामग्री: SessionConfig (सत्र विन्यास) संरचना\nप्रतिक्रिया: SessionStatusMessage (status=Created या Invalid)\nआवश्यकताएँ: - SessionConfig में दिनांक router समय से ±30 सेकंड के भीतर होना चाहिए - हस्ताक्षर सत्यापन के लिए मैपिंग को कुंजी के आधार पर क्रमबद्ध होना चाहिए - Destination (गंतव्य) के पास पहले से कोई सक्रिय सत्र नहीं होना चाहिए\nRequestVariableLeaseSetMessage (प्रकार 37) उद्देश्य: Router inbound tunnels के लिए क्लाइंट से प्राधिकरण का अनुरोध करता है\nसामग्री: - सत्र आईडी - Lease (लीज़) की संख्या - Lease संरचनाओं की array (प्रत्येक का अपना अलग समाप्ति समय)\nप्रतिक्रिया: CreateLeaseSet2Message\nमहत्त्व: यह संकेत दर्शाता है कि सत्र कार्यरत है। router इसे केवल तब भेजता है जब: 1. कम-से-कम एक इनबाउंड tunnel निर्मित हो 2. कम-से-कम एक आउटबाउंड tunnel निर्मित हो\nसमय-सीमा अनुशंसा: यदि सत्र बनाए जाने के 5+ मिनट के भीतर यह संदेश प्राप्त नहीं होता है, तो क्लाइंट्स को सत्र को समाप्त कर देना चाहिए।\nCreateLeaseSet2Message (प्रकार 41) उद्देश्य: क्लाइंट LeaseSet को नेटवर्क डेटाबेस में प्रकाशित करता है\nसामग्री: - सत्र ID - LeaseSet प्रकार बाइट (1, 3, 5, या 7) - LeaseSet या LeaseSet2 या EncryptedLeaseSet या MetaLeaseSet - निजी कुंजियों की संख्या - निजी कुंजी सूची (LeaseSet में प्रत्येक सार्वजनिक कुंजी के लिए एक, उसी क्रम में)\nनिजी कुंजियाँ: आने वाले garlic संदेश (I2P का बंडल संदेश) को डिक्रिप्ट करने के लिए आवश्यक। प्रारूप:\nEncryption type (2 bytes) Key length (2 bytes) Private key data (variable) नोट: अप्रचलित CreateLeaseSetMessage (type 4) को प्रतिस्थापित करता है, जो निम्नलिखित को संभाल नहीं सकता: - LeaseSet2 वैरिएंट - गैर-ElGamal एन्क्रिप्शन - एकाधिक एन्क्रिप्शन प्रकार - एन्क्रिप्टेड LeaseSets - ऑफ़लाइन साइनिंग कुंजियाँ\nSendMessageExpiresMessage (प्रकार 36) उद्देश्य: समाप्ति समय और उन्नत विकल्पों सहित गंतव्य पर संदेश भेजें\nसामग्री: - सत्र ID - गंतव्य - पेलोड (gzipped) - नॉन्स (4 बाइट) - फ्लैग्स (2 बाइट) - नीचे देखें - समाप्ति तिथि (6 बाइट, 8 से ट्रंकेट किया गया)\nफ़्लैग्स फ़ील्ड (2 बाइट, बिट क्रम 15\u0026hellip;0):\nबिट्स 15-11: अप्रयुक्त, 0 होना अनिवार्य है\nBits 10-9: संदेश की विश्वसनीयता ओवरराइड (अप्रयुक्त, इसके बजाय nonce (एक-बार उपयोग की जाने वाली अद्वितीय संख्या) का उपयोग करें)\nबिट 8: LeaseSet को बंडल न करें - 0: Router LeaseSet को garlic में बंडल कर सकता है - 1: LeaseSet को बंडल न करें\nबिट 7-4: टैग की निम्न सीमा (केवल ElGamal पर लागू, ECIES में अनदेखा)\n0000 = Use session settings 0001 = 2 tags 0010 = 3 tags ... 1111 = 192 tags बिट्स 3-0: आवश्यकता होने पर भेजे जाने वाले टैग (केवल ElGamal के लिए, ECIES में अनदेखा किया जाता है)\n0000 = Use session settings 0001 = 2 tags 0010 = 4 tags ... 1111 = 160 tags MessageStatusMessage (संदेश स्थिति संदेश) (प्रकार 22) उद्देश्य: संदेश की डिलीवरी स्थिति के बारे में क्लाइंट को सूचित करना\nसामग्री: - सेशन ID - मैसेज ID (router द्वारा जनित) - स्टेटस कोड (1 बाइट) - आकार (4 बाइट, सिर्फ status=0 के लिए प्रासंगिक) - नॉन्स (4 बाइट, क्लाइंट के SendMessage nonce से मेल खाता है)\nस्थिति कोड (प्रेषित संदेश):\nCode Name Meaning Result 1 Accepted Router accepted message Success 2 Best Effort Success Probable delivery Success 4 Guaranteed Success Probable delivery Success 6 Local Success Delivered to local client Success 3 Best Effort Failure Probable failure Failure 5 Guaranteed Failure Generic failure Failure 7 Local Failure Local delivery failed Failure 8 Router Failure Router shutdown/error Failure 9 Network Failure No network connectivity Failure 10 Bad Session Invalid/closed session Failure 11 Bad Message Invalid payload Failure 12 Bad Options Invalid options/expiration Failure 13 Overflow Failure Queue/buffer full Failure 14 Message Expired Expired before send Failure 15 Bad Local LeaseSet Local LeaseSet problem Failure 16 No Local Tunnels No tunnels available Failure 17 Unsupported Encryption Incompatible encryption Failure 18 Bad Destination Invalid remote destination Failure 19 Bad Leaseset Invalid remote LeaseSet Failure 20 Expired Leaseset Remote LeaseSet expired Failure 21 No Leaseset Remote LeaseSet not found Failure 22 Meta Leaseset Cannot send to meta LS Failure 23 Loopback Denied Same source and destination Failure **सफलता कोड**: 1, 2, 4, 6 **विफलता कोड**: अन्य सभी स्टेटस कोड 0 (अप्रचलित): उपलब्ध संदेश (आने वाला, तेज़ प्राप्ति निष्क्रिय)\nHostLookupMessage (प्रकार 38) उद्देश्य: होस्टनेम या हैश द्वारा डेस्टिनेशन लुकअप (DestLookup का स्थान लेता है)\nसामग्री: - सत्र ID (या सत्र न होने पर 0xFFFF) - अनुरोध ID (4 बाइट) - मिलीसेकंड में टाइमआउट (4 बाइट, अनुशंसित न्यूनतम: 10000) - अनुरोध प्रकार (1 बाइट) - लुकअप कुंजी (Hash, hostname String, या Destination)\nअनुरोध प्रकार:\nType Lookup Key Returns Since 0 Hash Destination Original 1 Hostname String Destination Original 2 Hash Destination + Options 0.9.66 3 Hostname String Destination + Options 0.9.66 4 Destination Destination + Options 0.9.66 प्रकार 2-4 उपलब्ध होने पर LeaseSet विकल्प (प्रस्ताव 167) लौटाते हैं। प्रतिक्रिया: HostReplyMessage\nHostReplyMessage (प्रकार 39) उद्देश्य: HostLookupMessage (होस्ट लुकअप संदेश) के प्रति प्रतिक्रिया\nसामग्री: - सत्र ID - अनुरोध ID - परिणाम कोड (1 बाइट) - Destination (I2P पता/पहचान) (सफल होने पर मौजूद, कभी-कभी कुछ विशिष्ट विफलताओं में भी) - मैपिंग (केवल लुकअप प्रकार 2-4 के लिए, खाली हो सकता है)\nपरिणाम कोड:\nCode Name Meaning 0 Success Lookup succeeded 1 Failure Generic failure 2 Lookup Password Required Blinded address requires password 3 Private Key Required Blinded address requires private key 4 Password and Key Required Blinded address requires both 5 LeaseSet Decryption Failure Cannot decrypt LeaseSet 6 LeaseSet Lookup Failure LeaseSet not found in netdb 7 Lookup Type Unsupported Router doesn't support this type #### BlindingInfoMessage (प्रकार 42) उद्देश्य: router को blinded destination (गोपनीयता हेतु छिपाई गई गंतव्य पहचान) के प्रमाणीकरण आवश्यकताओं के बारे में सूचित करना (since 0.9.43)\nसामग्री: - सेशन ID - फ्लैग्स (1 बाइट) - एंडपॉइंट प्रकार (1 बाइट): 0=Hash, 1=hostname, 2=Destination, 3=SigType+Key - ब्लाइंडेड हस्ताक्षर प्रकार (2 बाइट) - समाप्ति (4 बाइट, एपोक से सेकंड) - एंडपॉइंट डेटा (प्रकार के अनुसार बदलता है) - प्राइवेट कुंजी (32 बाइट, केवल यदि फ्लैग बिट 0 सेट हो) - लुकअप पासवर्ड (String, केवल यदि फ्लैग बिट 4 सेट हो)\nफ्लैग्स (बिट क्रम 76543210):\nबिट 0: 0=सभी, 1=प्रति-क्लाइंट बिट्स 3-1: प्रमाणीकरण योजना (यदि बिट 0=1): 000=DH (Diffie-Hellman), 001=PSK (Pre-Shared Key) बिट 4: 1=सीक्रेट आवश्यक बिट्स 7-5: अप्रयुक्त, 0 पर सेट करें कोई प्रतिक्रिया नहीं: Router चुपचाप संसाधित करता है\nउपयोग मामला: blinded destination (b33 address) पर भेजने से पहले, क्लाइंट को निम्न में से एक करना होगा: 1. HostLookup के माध्यम से b33 का लुकअप करें, या 2. BlindingInfo message भेजें\nयदि गंतव्य को प्रमाणीकरण की आवश्यकता है, तो BlindingInfo अनिवार्य है.\nReconfigureSessionMessage (प्रकार 2) उद्देश्य: निर्माण के बाद सत्र विन्यास को अद्यतन करना\nसामग्री: - सेशन आईडी - SessionConfig (सेशन कॉन्फ़िगरेशन) (केवल बदले गए विकल्प आवश्यक)\nप्रतिक्रिया: SessionStatusMessage (सेशन स्थिति संदेश) (status=Updated या Invalid)\nनोट्स: - Router नई कॉन्फ़िगरेशन को मौजूदा कॉन्फ़िगरेशन के साथ मर्ज करता है - Tunnel विकल्प (inbound.*, outbound.*) हमेशा लागू किए जाते हैं - सत्र निर्माण के बाद कुछ विकल्प अपरिवर्तनीय हो सकते हैं - दिनांक router समय से ±30 सेकंड के भीतर होना चाहिए - मैपिंग को कुंजी के अनुसार क्रमबद्ध होना चाहिए\nDestroySessionMessage (सत्र समाप्ति संदेश) (प्रकार 3) उद्देश्य: सत्र समाप्त करना\nसामग्री: सत्र आईडी\nअपेक्षित प्रतिक्रिया: SessionStatusMessage (status=Destroyed)\nवास्तविक व्यवहार (Java I2P 0.9.66 तक): - Router कभी SessionStatus(Destroyed) नहीं भेजता - यदि कोई सत्र शेष नहीं है: DisconnectMessage भेजता है - यदि subsessions (उप-सत्र) शेष हैं: कोई उत्तर नहीं\nमहत्वपूर्ण: Java I2P का व्यवहार विनिर्देश से भिन्न है। व्यक्तिगत उपसत्रों को समाप्त करते समय कार्यान्वयनों को सावधानी बरतनी चाहिए।\nDisconnectMessage (प्रकार 30) उद्देश्य: यह सूचित करना कि कनेक्शन जल्द ही समाप्त होने वाला है\nसामग्री: कारण स्ट्रिंग\nप्रभाव: कनेक्शन पर मौजूद सभी सत्र नष्ट कर दिए जाते हैं, सॉकेट बंद हो जाता है\nकार्यान्वयन: मुख्य रूप से Java I2P में router → क्लाइंट\nप्रोटोकॉल संस्करण इतिहास संस्करण पहचान I2CP प्रोटोकॉल का संस्करण Get/SetDate संदेशों में आदान-प्रदान किया जाता है (0.8.7 से)। पुराने routers के लिए संस्करण संबंधी जानकारी उपलब्ध नहीं है।\nसंस्करण स्ट्रिंग: \u0026ldquo;core\u0026rdquo; API के संस्करण को दर्शाता है, यह जरूरी नहीं कि router संस्करण हो।\nविशेषताओं की समयरेखा Version Key Features 0.9.67 PQ Hybrid ML-KEM (enc types 5-7) in LeaseSet 0.9.66 Host lookup/reply extensions (proposal 167), service records 0.9.62 MessageStatus loopback error code 0.9.46 X25519 (enc type 4) in LeaseSet, ECIES end-to-end 0.9.43 BlindingInfo message, extended HostReply failure codes 0.9.41 EncryptedLeaseSet options, Meta LS error code 0.9.39 CreateLeaseSet2 message, RedDSA Ed25519 support 0.9.38 Preliminary LS2 support (format changed in 0.9.39) 0.9.21 Multiple sessions on single connection 0.9.20 Additional SetDate messages for clock shifts 0.9.16 Authentication required before other messages (when enabled) 0.9.15 EdDSA Ed25519 signature type 0.9.14 Per-message reliability override with nonzero nonce 0.9.12 ECDSA P-256/384/521 signature types, RSA support 0.9.11 HostLookup/HostReply messages, auth in GetDate 0.9.7 RequestVariableLeaseSet message 0.9.5 Additional MessageStatus codes 0.9.4 Fast receive mode default, nonce=0 allowed 0.9.2 SendMessageExpires flag tag bits 0.9 16 leases per LeaseSet (up from 6) 0.8.7 Version strings in Get/SetDate 0.8.4 SendMessageExpires flag bits 0.8.3 DestLookup in standard session, concurrent lookups 0.8.1 messageReliability=none 0.7.2 GetBandwidthLimits, BandwidthLimits 0.7.1 SendMessageExpires, ReconfigureSession, ports in gzip header 0.7 DestLookup, DestReply 0.6.5- Original protocol features ## सुरक्षा संबंधी विचार प्रमाणीकरण डिफ़ॉल्ट: कोई प्रमाणीकरण आवश्यक नहीं वैकल्पिक: उपयोगकर्ता नाम/पासवर्ड प्रमाणीकरण (0.9.11 से) अनिवार्य: सक्रिय होने पर, अन्य संदेशों से पहले प्रमाणीकरण पूरा होना आवश्यक है (0.9.16 से)\nदूरस्थ कनेक्शन: प्रमाण-पत्रों और निजी कुंजियों की सुरक्षा के लिए हमेशा TLS (ट्रांसपोर्ट लेयर सिक्योरिटी) (i2cp.SSL=true) का उपयोग करें।\nघड़ी का विचलन SessionConfig Date (सेशन कॉन्फ़िगरेशन की तिथि) router समय से ±30 सेकंड के भीतर होनी चाहिए, अन्यथा सेशन अस्वीकार कर दिया जाएगा. समय समकालित करने के लिए Get/SetDate का उपयोग करें.\nनिजी कुंजी का प्रबंधन CreateLeaseSet2Message में आने वाले संदेशों को डिक्रिप्ट करने के लिए निजी कुंजियाँ होती हैं। इन कुंजियों के लिए यह आवश्यक है: - सुरक्षित रूप से प्रेषित की जाएँ (दूरस्थ कनेक्शनों के लिए TLS) - router द्वारा सुरक्षित रूप से संग्रहीत की जाएँ - समझौता होने पर बदली जाएँ\nसंदेश की समाप्ति स्पष्ट समाप्ति समय निर्धारित करने के लिए हमेशा SendMessageExpires (SendMessage नहीं) का उपयोग करें। यह: - संदेशों को अनिश्चितकाल तक कतार में पड़े रहने से रोकता है - संसाधन खपत को कम करता है - विश्वसनीयता में सुधार करता है\nसत्र टैग प्रबंधन ElGamal (अप्रचलित): - टैगों को बैचों में भेजे जाने चाहिए - खोए हुए टैग डिक्रिप्शन विफलताओं का कारण बनते हैं - उच्च मेमोरी ओवरहेड (अतिरिक्त मेमोरी-खर्च)\nECIES-X25519 (वर्तमान): - समकालिक PRNG (छद्म-यादृच्छिक संख्या जनक) के माध्यम से उत्पन्न टैग - पूर्व-प्रेषण की आवश्यकता नहीं - संदेश हानि के प्रति सहनशील - काफी कम ओवरहेड\nसर्वोत्तम प्रथाएँ क्लाइंट डेवलपर्स के लिए फास्ट रिसीव मोड का उपयोग करें: हमेशा i2cp.fastReceive=true सेट करें (या डिफ़ॉल्ट पर भरोसा करें)\nECIES-X25519 (एलिप्टिक-curve आधारित एन्क्रिप्शन स्कीम) को प्राथमिकता दें: सर्वोत्तम प्रदर्शन और संगतता के लिए i2cp.leaseSetEncType=4,0 कॉन्फ़िगर करें\nस्पष्ट समाप्ति समय निर्धारित करें: SendMessageExpires का उपयोग करें, SendMessage नहीं\nSubsessions (उप-सेशन) को सावधानीपूर्वक संभालें: ध्यान रखें कि subsessions destinations (गंतव्य) के बीच कोई अनामिकता प्रदान नहीं करते\nसत्र निर्माण टाइमआउट: यदि 5 मिनट के भीतर RequestVariableLeaseSet (एक विशिष्ट संदेश/ऑब्जेक्ट का नाम) प्राप्त न हो, तो सत्र समाप्त करें\nकॉन्फ़िगरेशन मैपिंग को क्रमबद्ध करें: SessionConfig पर हस्ताक्षर करने से पहले हमेशा मैपिंग कुंजियों को क्रमबद्ध करें\nउचित Tunnel संख्या का उपयोग करें: आवश्यक न होने पर quantity \u0026gt; 6 सेट न करें\nनॉन-जावा के लिए SAM/BOB पर विचार करें: I2CP को सीधे लागू करने के बजाय SAM लागू करें\nRouter डेवलपर्स के लिए तिथियों का सत्यापन: SessionConfig की तिथियों पर ±30 सेकंड की समय-विंडो लागू करें\nसंदेश का आकार सीमित करें: ~64 KB का अधिकतम संदेश आकार लागू करें\nएकाधिक सत्रों का समर्थन: 0.9.21 विनिर्देश के अनुसार subsession (उप-सत्र) समर्थन लागू करें\nRequestVariableLeaseSet (I2NP संदेश) तुरंत भेजें: केवल तब जब दोनों इनबाउंड और आउटबाउंड tunnels बन चुके हों\nDeprecated (अप्रचलित) संदेशों को संभालें: स्वीकार करें, लेकिन ReceiveMessageBegin/End के उपयोग को हतोत्साहित करें\nECIES-X25519 (X25519-आधारित Elliptic Curve Integrated Encryption Scheme, आधुनिक सार्वजनिक-कुंजी एन्क्रिप्शन): नई तैनातियों के लिए टाइप 4 एन्क्रिप्शन को प्राथमिकता दें\nडीबगिंग और समस्या निवारण सामान्य समस्याएँ सत्र अस्वीकृत (अमान्य): - क्लॉक स्क्यू (±30 सेकंड के भीतर होना चाहिए) की जाँच करें - सत्यापित करें कि Mapping कुंजी के अनुसार क्रमबद्ध है - सुनिश्चित करें कि Destination पहले से उपयोग में न हो\nRequestVariableLeaseSet नहीं: - Router संभवतः tunnels बना रहा है (अधिकतम 5 मिनट तक प्रतीक्षा करें) - नेटवर्क कनेक्टिविटी समस्याओं की जाँच करें - सुनिश्चित करें कि पर्याप्त पीयर कनेक्शन हैं\nसंदेश वितरण विफलताएँ: - विफलता के विशिष्ट कारण के लिए MessageStatus कोड जांचें - सत्यापित करें कि दूरस्थ LeaseSet प्रकाशित और वर्तमान है - सुनिश्चित करें कि एन्क्रिप्शन प्रकार संगत हों\nउपसत्र से संबंधित समस्याएँ: - सत्यापित करें कि प्राथमिक सत्र पहले बनाया गया है - पुष्टि करें कि एन्क्रिप्शन कुंजियाँ समान हैं - जाँचें कि हस्ताक्षर कुंजियाँ भिन्न हैं\nनिदान संदेश GetBandwidthLimits: router की क्षमता की जानकारी प्राप्त करें HostLookup: नाम समाधान और LeaseSet (I2P में किसी गंतव्य के tunnels की लीज़ प्रविष्टियों का सेट) उपलब्धता का परीक्षण करें MessageStatus: संदेश वितरण को एंड-टू-एंड ट्रैक करें\nसंबंधित विनिर्देश सामान्य संरचनाएँ: /docs/specs/common-structures/ I2NP (नेटवर्क प्रोटोकॉल): /docs/specs/i2np/ ECIES-X25519: /docs/specs/ecies/ Tunnel निर्माण: /docs/specs/implementation/ स्ट्रीमिंग लाइब्रेरी: /docs/specs/streaming/ डेटाग्राम लाइब्रेरी: /docs/api/datagrams/ SAM v3: /docs/api/samv3/ संदर्भित प्रस्ताव प्रस्ताव 123 : एन्क्रिप्टेड LeaseSets और प्रमाणीकरण प्रस्ताव 144 : ECIES-X25519-AEAD-Ratchet प्रस्ताव 149 : ब्लाइंडेड पता प्रारूप (b33) प्रस्ताव 152 : X25519 tunnel निर्माण प्रस्ताव 154 : ECIES डेस्टिनेशनों से डेटाबेस लुकअप्स प्रस्ताव 156 : Router का ECIES-X25519 की ओर माइग्रेशन प्रस्ताव 161 : डेस्टिनेशन पैडिंग संपीड़न प्रस्ताव 167 : LeaseSet सर्विस रिकॉर्ड्स प्रस्ताव 169 : पोस्ट-क्वांटम हाइब्रिड क्रिप्टोग्राफी (ML-KEM) Javadoc संदर्भ I2CP पैकेज MessageStatusMessage क्लाइंट API अप्रचलन सारांश अप्रचलित संदेश (उपयोग न करें) CreateLeaseSetMessage (प्रकार 4): CreateLeaseSet2Message का उपयोग करें RequestLeaseSetMessage (प्रकार 21): RequestVariableLeaseSetMessage का उपयोग करें ReceiveMessageBeginMessage (प्रकार 6): तेज़ प्राप्ति मोड का उपयोग करें ReceiveMessageEndMessage (प्रकार 7): तेज़ प्राप्ति मोड का उपयोग करें DestLookupMessage (प्रकार 34): HostLookupMessage का उपयोग करें DestReplyMessage (प्रकार 35): HostReplyMessage का उपयोग करें ReportAbuseMessage (प्रकार 29): कभी कार्यान्वित नहीं किया गया अप्रचलित विकल्प ElGamal एन्क्रिप्शन (प्रकार 0): ECIES-X25519 (प्रकार 4) पर स्थानांतरित करें DSA हस्ताक्षर: EdDSA या ECDSA पर स्थानांतरित करें i2cp.fastReceive=false: हमेशा तेज़ रिसीव मोड का उपयोग करें ","description":"एप्लिकेशन I2P router के साथ सेशन्स, tunnels, और LeaseSets का नेगोशिएशन कैसे करते हैं।","id":"ed43fc9da2a03819fd3c8f71e9e9a5a3","section":"docs","title":"I2P क्लाइंट प्रोटोकॉल (I2CP)","url":"/hi/docs/specs/i2cp/"},{"categories":null,"content":"1. \u0026ldquo;Anonymous\u0026rdquo; का अर्थ क्या है I2P व्यावहारिक गुमनामी प्रदान करता है—अदृश्यता नहीं। गुमनामी को इस रूप में परिभाषित किया जाता है कि किसी विरोधी के लिए उस जानकारी को जानना कितना कठिन है जिसे आप निजी रखना चाहते हैं: आप कौन हैं, आप कहाँ हैं, या आप किससे बात करते हैं। पूर्ण गुमनामी असंभव है; इसके बजाय, I2P का लक्ष्य वैश्विक निष्क्रिय और सक्रिय विरोधियों के खिलाफ पर्याप्त गुमनामी प्राप्त करना है।\nआपकी गुमनामी इस बात पर निर्भर करती है कि आप I2P को कैसे कॉन्फ़िगर करते हैं, आप peers और subscriptions को कैसे चुनते हैं, और आप कौन से applications को expose करते हैं।\n2. क्रिप्टोग्राफिक और ट्रांसपोर्ट विकास (2003 → 2025) Era Primary Algorithms Notes 0.3 – 0.9 ElGamal + AES-256 + DSA-SHA1 Legacy stack (2003–2015) 0.9.15 Ed25519 signatures Replaced DSA 0.9.36 (2018) NTCP2 introduced Noise XK_25519_ChaChaPoly_SHA256 0.9.56 (2022) SSU2 enabled by default Noise-based UDP transport 2.4.0 (2023) NetDB Sub-DB isolation Prevents router↔client linkage 2.8.0+ (2025) Congestion-aware routing / observability reductions DoS hardening 2.10.0 (2025) Post-quantum hybrid ML-KEM support (optional) Experimental **वर्तमान क्रिप्टोग्राफिक सुइट (Noise XK):** - **X25519** कुंजी विनिमय के लिए - **ChaCha20/Poly1305 AEAD** एन्क्रिप्शन के लिए - **Ed25519 (EdDSA-SHA512)** हस्ताक्षर के लिए - **SHA-256** हैशिंग और HKDF के लिए - वैकल्पिक **ML-KEM hybrids** पोस्ट-क्वांटम परीक्षण के लिए सभी ElGamal और AES-CBC उपयोग समाप्त कर दिए गए हैं। Transport पूरी तरह से NTCP2 (TCP) और SSU2 (UDP) है; दोनों IPv4/IPv6, forward secrecy, और DPI obfuscation का समर्थन करते हैं।\n3. नेटवर्क आर्किटेक्चर सारांश Free-route mixnet: प्रेषक और प्राप्तकर्ता प्रत्येक अपनी स्वयं की tunnels परिभाषित करते हैं। कोई केंद्रीय प्राधिकरण नहीं: Routing और naming विकेंद्रीकृत हैं; प्रत्येक router स्थानीय विश्वास बनाए रखता है। एकदिशीय tunnels: Inbound और outbound अलग-अलग हैं (10 मिनट की जीवनकाल)। Exploratory tunnels: डिफ़ॉल्ट रूप से 2 hops; client tunnels 2–3 hops। Floodfill routers: ~55 000 nodes में से ~1 700 (~6 %) वितरित NetDB को बनाए रखते हैं। NetDB rotation: Keyspace UTC मध्यरात्रि पर दैनिक रूप से घूमता है। Sub-DB isolation: संस्करण 2.4.0 से, प्रत्येक client और router अलग-अलग databases का उपयोग करते हैं ताकि linking को रोका जा सके। 4. हमले की श्रेणियां और वर्तमान सुरक्षा Category Current Status (2025) Primary Defenses Brute Force / Cryptanalysis Impractical with modern primitives (X25519, ChaCha20). Strong crypto, key rotation, Noise handshakes. Timing Attacks Still unsolved for low-latency systems. Unidirectional tunnels, 1024\u0026nbsp;B cells, profile recalc (45\u0026nbsp;s). Research continues for non-trivial delays (3.0+). Intersection Attacks Inherent weakness of low latency mixnets. Tunnel rotation (10\u0026nbsp;min), leaseset expirations, multihoming. Predecessor Attacks Partially mitigated. Tiered peer selection, strict XOR ordering, variable length tunnels. Sybil Attacks No comprehensive defense. IP /16 limits, profiling, diversity rules; HashCash infra exists but not required. Floodfill / NetDB Attacks Improved but still a concern. One /16 per lookup, limit 500 active, daily rotation, randomized verification delay, Sub-DB isolation. DoS / Flooding Frequent (esp. 2023 incidents). Congestion-aware routing (2.4+), aggressive leaseset removal (2.8+). Traffic ID / Fingerprinting Greatly reduced. Noise obfuscation, random padding, no plaintext headers. Censorship / Partitioning Possible with state-level blocking. Hidden mode, IPv6, multiple reseeds, mirrors. Development / Supply Chain Mitigated. Open source, signed SU3 releases (RSA-4096), multi-signer trust model. --- 5. आधुनिक नेटवर्क डेटाबेस (NetDB) मुख्य तथ्य (अभी भी सटीक): - संशोधित Kademlia DHT, RouterInfo और LeaseSets को संग्रहीत करता है। - SHA-256 key hashing; 10 s timeout के साथ 2 निकटतम floodfills को समानांतर queries। - LeaseSet जीवनकाल ≈ 10 min (LeaseSet2) या 18 h (MetaLeaseSet)।\nनए प्रकार (0.9.38 के बाद से): - LeaseSet2 (Type 3) – एकाधिक एन्क्रिप्शन प्रकार, टाइमस्टैम्प युक्त। - EncryptedLeaseSet2 (Type 5) – निजी सेवाओं के लिए blinded destination (DH या PSK प्रमाणीकरण)। - MetaLeaseSet (Type 7) – मल्टीहोमिंग और विस्तारित समाप्ति अवधि।\nप्रमुख सुरक्षा उन्नयन – Sub-DB Isolation (2.4.0): - router↔client जुड़ाव को रोकता है। - प्रत्येक client और router अलग netDb खंडों का उपयोग करते हैं। - सत्यापित और ऑडिट किया गया (2.5.0)।\n6. हिडन मोड और प्रतिबंधित रूट्स Hidden Mode: लागू किया गया (Freedom House स्कोर के अनुसार सख्त देशों में स्वचालित)।\nRouter RouterInfo प्रकाशित नहीं करते या ट्रैफ़िक को route नहीं करते। Restricted Routes: आंशिक रूप से लागू किया गया (केवल बुनियादी trust-only tunnel)।\nव्यापक trusted-peer routing की योजना बनी हुई है (3.0+)। ट्रेड-ऑफ: बेहतर गोपनीयता ↔ नेटवर्क क्षमता में कम योगदान।\n7. DoS और Floodfill हमले ऐतिहासिक: 2013 UCSB शोध ने दिखाया कि Eclipse और Floodfill टेकओवर संभव थे। आधुनिक सुरक्षा में शामिल हैं: - दैनिक keyspace रोटेशन। - Floodfill सीमा ≈ 500, प्रति /16 एक। - यादृच्छिक स्टोरेज सत्यापन विलंब। - नए-router वरीयता (2.6.0)। - स्वचालित नामांकन सुधार (2.9.0)। - भीड़-जागरूक रूटिंग और lease थ्रॉटलिंग (2.4.0+)।\nFloodfill हमले सैद्धांतिक रूप से संभव हैं लेकिन व्यावहारिक रूप से कठिन हैं।\n8. ट्रैफिक विश्लेषण और सेंसरशिप I2P ट्रैफ़िक की पहचान करना कठिन है: कोई निश्चित पोर्ट नहीं, कोई plaintext handshake नहीं, और यादृच्छिक padding। NTCP2 और SSU2 पैकेट सामान्य प्रोटोकॉल की नकल करते हैं और ChaCha20 हेडर obfuscation का उपयोग करते हैं। Padding रणनीतियाँ बुनियादी हैं (यादृच्छिक आकार), dummy traffic लागू नहीं है (महंगा)। Tor exit nodes से कनेक्शन 2.6.0 से अवरुद्ध हैं (संसाधनों की सुरक्षा के लिए)।\n9. स्थायी सीमाएं (स्वीकृत) कम-विलंबता वाले ऐप्स के लिए टाइमिंग सहसंबंध एक मौलिक जोखिम बना रहता है। ज्ञात सार्वजनिक गंतव्यों के खिलाफ इंटरसेक्शन हमले अभी भी शक्तिशाली हैं। Sybil हमलों के खिलाफ पूर्ण सुरक्षा का अभाव है (HashCash लागू नहीं किया गया)। स्थिर-दर ट्रैफ़िक और महत्वपूर्ण विलंब अभी तक लागू नहीं हुए हैं (3.0 में योजनाबद्ध)। इन सीमाओं के बारे में पारदर्शिता जानबूझकर है — यह उपयोगकर्ताओं को गुमनामी को अधिक आंकने से रोकती है।\n10. नेटवर्क सांख्यिकी (2025) विश्वभर में ~55,000 सक्रिय routers (2013 में 7,000 से ↑) ~1,700 floodfill routers (~6%) डिफ़ॉल्ट रूप से 95% tunnel routing में भाग लेते हैं बैंडविड्थ स्तर: K (\u0026lt;12 KB/s) → X (\u0026gt;2 MB/s) न्यूनतम floodfill दर: 128 KB/s Router console Java 8+ (आवश्यक), अगले चक्र में Java 17+ की योजना 11. विकास और केंद्रीय संसाधन आधिकारिक साइट: geti2p.net दस्तावेज़: Documentation Debian रिपॉजिटरी: https://deb.i2pgit.org ( Oct 2023 में deb.i2p2.de को बदल दिया गया ) सोर्स कोड: https://i2pgit.org/I2P_Developers/i2p.i2p (Gitea) + GitHub मिरर सभी रिलीज़ साइन किए गए SU3 कंटेनर हैं (RSA-4096, zzz/str4d keys) कोई सक्रिय मेलिंग लिस्ट नहीं; कम्युनिटी https://i2pforum.net और IRC2P के माध्यम से। अपडेट साइकिल: 6–8 सप्ताह की स्थिर रिलीज़। 12. 0.8.x के बाद से सुरक्षा सुधारों का सारांश Year Feature Effect 2015 Ed25519 signatures Removed SHA1/DSA weakness 2018 NTCP2 Noise-based TCP transport 2019 LeaseSet2 / EncryptedLeaseSet2 Hidden services privacy 2022 SSU2 Noise-based UDP transport 2023 Sub-DB Isolation + Congestion-Aware Routing Stopped NetDB linkage / improved resilience 2024 Floodfill selection improvements Reduced long-term node influence 2025 Observability reductions + PQ hybrid crypto Harder timing analysis / future-proofing --- 13. ज्ञात अनसुलझे या नियोजित कार्य व्यापक प्रतिबंधित मार्ग (विश्वसनीय-सहकर्मी रूटिंग) → 3.0 में योजनाबद्ध। समय प्रतिरोध के लिए गैर-तुच्छ विलंब/बैचिंग → 3.0 में योजनाबद्ध। उन्नत पैडिंग और डमी ट्रैफ़िक → अकार्यान्वित। HashCash पहचान सत्यापन → बुनियादी ढांचा मौजूद है लेकिन निष्क्रिय। R5N DHT प्रतिस्थापन → केवल प्रस्ताव। 14. मुख्य संदर्भ Practical Attacks Against the I2P Network (Egger et al., RAID 2013) Privacy Implications of Performance-Based Peer Selection (Herrmann \u0026amp; Grothoff, PETS 2011) Resilience of the Invisible Internet Project (Muntaka et al., Wiley 2025) I2P आधिकारिक दस्तावेज़ीकरण 15. निष्कर्ष I2P का मूल गुमनामी मॉडल दो दशकों से कायम है: वैश्विक विशिष्टता का त्याग करके स्थानीय विश्वास और सुरक्षा को प्राथमिकता देना। ElGamal से X25519, NTCP से NTCP2, और मैनुअल reseeds से Sub-DB अलगाव तक, परियोजना ने गहन रक्षा और पारदर्शिता के अपने दर्शन को बनाए रखते हुए विकास किया है।\nकिसी भी कम-विलंबता वाले mixnet के खिलाफ कई हमले सैद्धांतिक रूप से संभव रहते हैं, लेकिन I2P की निरंतर सुदृढ़ीकरण प्रक्रिया उन्हें तेजी से अव्यावहारिक बना रही है। नेटवर्क पहले से कहीं अधिक बड़ा, तेज़ और सुरक्षित है — फिर भी अपनी सीमाओं के बारे में ईमानदार है।\n","description":"I2P के डिज़ाइन में विचार किए गए हमलों की सूची और लागू की गई सुरक्षा उपाय","id":"8433fa179e266d091a906a9059db53f4","section":"docs","title":"I2P खतरा मॉडल","url":"/hi/docs/overview/threat-model/"},{"categories":null,"content":"अवलोकन I2P नेटवर्क प्रोटोकॉल (I2NP) यह निर्धारित करता है कि routers संदेशों का आदान-प्रदान कैसे करते हैं, कौन-से ट्रांसपोर्ट चुनते हैं, और गुमनामी बनाए रखते हुए ट्रैफ़िक को कैसे मिश्रित करते हैं। यह I2CP (क्लाइंट API) और ट्रांसपोर्ट प्रोटोकॉल्स (NTCP2 और SSU2) के बीच संचालित होता है।\nI2NP, I2P ट्रांसपोर्ट प्रोटोकॉल्स के ऊपर की लेयर है. यह एक router-to-router प्रोटोकॉल है, जिसका उपयोग इन कार्यों के लिए होता है: - नेटवर्क डेटाबेस लुकअप और उत्तर - tunnels बनाना - एन्क्रिप्टेड router और क्लाइंट डेटा संदेश\nI2NP संदेश या तो बिंदु-से-बिंदु किसी अन्य router को भेजे जा सकते हैं, या उस router तक tunnels के माध्यम से गुमनाम रूप से भेजे जा सकते हैं।\nRouters स्थानीय प्राथमिकताओं का उपयोग करके बहिर्गामी कार्य को कतारबद्ध करते हैं। उच्च प्राथमिकता संख्याएँ पहले संसाधित की जाती हैं। मानक tunnel डेटा प्राथमिकता (400) से ऊपर की कोई भी चीज़ को तात्कालिक माना जाता है।\nवर्तमान ट्रांसपोर्ट्स I2P अब IPv4 और IPv6 दोनों के लिए NTCP2 (TCP) और SSU2 (UDP) का उपयोग करता है। दोनों ट्रांसपोर्ट निम्न का उपयोग करते हैं: - X25519 कुंजी विनिमय (Noise protocol framework — Noise प्रोटोकॉल फ्रेमवर्क) - ChaCha20/Poly1305 प्रमाणित एन्क्रिप्शन (AEAD) - SHA-256 हैशिंग\nपुराने ट्रांसपोर्ट हटाए गए: - NTCP (मूल TCP) को Java router से रिलीज़ 0.9.50 (मई 2021) में हटाया गया - SSU v1 (मूल UDP) को Java router से रिलीज़ 2.4.0 (दिसंबर 2023) में हटाया गया - SSU v1 को i2pd से रिलीज़ 2.44.0 (नवंबर 2022) में हटाया गया\n2025 तक, नेटवर्क पूरी तरह Noise (प्रोटोकॉल फ्रेमवर्क) आधारित ट्रांसपोर्ट्स पर स्थानांतरित हो चुका है, और लेगेसी ट्रांसपोर्ट का समर्थन बिल्कुल नहीं है।\nसंस्करण क्रमांकन प्रणाली महत्वपूर्ण: I2P एक दोहरी संस्करण प्रणाली का उपयोग करता है, जिसे स्पष्ट रूप से समझना आवश्यक है:\nरिलीज़ संस्करण (उपयोगकर्ता-उन्मुख) ये वे संस्करण हैं जिन्हें उपयोगकर्ता देखते और डाउनलोड करते हैं: - 0.9.50 (मई 2021) - अंतिम 0.9.x रिलीज़ - 1.5.0 (अगस्त 2021) - पहला 1.x रिलीज़ - 1.6.0, 1.7.0, 1.8.0, 1.9.0 (2021-2022 के दौरान) - 2.0.0 (नवंबर 2022) - पहला 2.x रिलीज़ - 2.1.0 से 2.9.0 तक (2023-2025 के दौरान) - 2.10.0 (8 सितंबर, 2025) - वर्तमान रिलीज़\nAPI संस्करण (प्रोटोकॉल संगतता) ये आंतरिक संस्करण संख्याएँ हैं जो RouterInfo गुणधर्मों के \u0026ldquo;router.version\u0026rdquo; फ़ील्ड में प्रकाशित की जाती हैं: - 0.9.50 (मई 2021) - 0.9.51 (अगस्त 2021) - रिलीज़ 1.5.0 के लिए API संस्करण - 0.9.52 से 0.9.66 तक (2.x रिलीज़ के दौरान भी जारी) - 0.9.67 (सितंबर 2025) - रिलीज़ 2.10.0 के लिए API संस्करण\nमुख्य बिंदु: 0.9.51 से 0.9.67 तक क्रमांकित कोई रिलीज़ नहीं हुई थी। ये संख्याएँ केवल API (एप्लिकेशन प्रोग्रामिंग इंटरफेस) संस्करण पहचानकर्ताओं के रूप में मौजूद हैं। I2P ने रिलीज़ 0.9.50 से सीधे 1.5.0 पर छलांग लगाई।\nसंस्करण मैपिंग तालिका Release Version API Version Date Key Features 0.9.50 0.9.50 May 2021 Last 0.9.x release, removed NTCP1 1.5.0 0.9.51 August 2021 Short tunnel build messages (218 bytes) 1.6.0 0.9.52 November 2021 Various improvements 1.7.0 0.9.53 January 2022 Performance enhancements 1.8.0 0.9.54 May 2022 SSU2 introduced 1.9.0 0.9.55 August 2022 SSU2 improvements 2.0.0 0.9.56 November 2022 SSU2 enabled by default 2.1.0 0.9.57 January 2023 Stability improvements 2.2.0 0.9.58 March 2023 ElGamal routers deprecated 2.3.0 0.9.59 May 2023 Various improvements 2.4.0 0.9.61 December 2023 Removed SSU1 support 2.5.0 0.9.62 February 2024 Performance improvements 2.6.0 0.9.63 May 2024 Network optimizations 2.7.0 0.9.64 October 2024 Post-quantum preparation work 2.8.0 0.9.65 February 2025 Tunnel bandwidth parameters 2.9.0 0.9.66 June 2025 LeaseSet service records 2.10.0 0.9.67 September 2025 Post-quantum hybrid cryptography (beta) **आगामी:** रिलीज़ 2.11.0 (दिसंबर 2025 के लिए नियोजित) में Java 17+ की आवश्यकता होगी और डिफ़ॉल्ट रूप से post-quantum cryptography (पोस्ट-क्वांटम क्रिप्टोग्राफी) सक्रिय की जाएगी। प्रोटोकॉल संस्करण सभी router को अपने I2NP प्रोटोकॉल संस्करण को RouterInfo (राउटर जानकारी की डेटा संरचना) की प्रॉपर्टीज़ में मौजूद \u0026ldquo;router.version\u0026rdquo; फ़ील्ड में प्रकाशित करना आवश्यक है। यह संस्करण फ़ील्ड API संस्करण है, जो विभिन्न I2NP प्रोटोकॉल विशेषताओं के समर्थन के स्तर को दर्शाता है, और यह आवश्यक नहीं कि यह वास्तविक router संस्करण हो।\nयदि वैकल्पिक (गैर-Java) routers वास्तविक router के कार्यान्वयन के बारे में किसी भी संस्करण संबंधी जानकारी प्रकाशित करना चाहते हैं, तो उन्हें यह किसी अन्य प्रॉपर्टी में करना होगा। नीचे सूचीबद्ध संस्करणों के अलावा अन्य संस्करण भी अनुमत हैं। समर्थन का निर्धारण संख्यात्मक तुलना के माध्यम से किया जाएगा; उदाहरण के लिए, 0.9.13 का अर्थ 0.9.12 की सुविधाओं के लिए समर्थन है।\nनोट: \u0026ldquo;coreVersion\u0026rdquo; प्रॉपर्टी अब router की जानकारी में प्रकाशित नहीं की जाती है और I2NP प्रोटोकॉल संस्करण का निर्धारण करने के लिए कभी उपयोग नहीं की गई थी।\nAPI संस्करण सुविधाओं का सारांश API Version Required I2NP Features 0.9.67Post-quantum hybrid cryptography (MLKEM ratchet) support (beta), UDP tracker support 0.9.66LeaseSet2 service record options (see proposal 167) 0.9.65Tunnel build bandwidth parameters (see proposal 168) 0.9.59Minimum peers will build tunnels through (as of 0.9.63), minimum floodfill peers will send DSM to (as of 0.9.63) 0.9.58Minimum peers will build tunnels through (as of 0.9.62), ElGamal routers deprecated 0.9.55SSU2 transport support (if published in router info) 0.9.51Short tunnel build messages for ECIES-X25519 routers, minimum peers will build tunnels through (as of 0.9.58), minimum floodfill peers will send DSM to (as of 0.9.58) 0.9.49Garlic messages to ECIES-X25519 routers 0.9.48ECIES-X25519 routers, ECIES-X25519 build request/response records 0.9.46DatabaseLookup flag bit 4 for AEAD reply 0.9.44ECIES-X25519 keys in LeaseSet2 0.9.40MetaLeaseSet may be sent in a DSM 0.9.39EncryptedLeaseSet may be sent in a DSM, RedDSA_SHA512_Ed25519 signature type supported 0.9.38DSM type bits 3-0 now contain the type; LeaseSet2 may be sent in a DSM 0.9.36NTCP2 transport support (if published in router info), minimum peers will build tunnels through (as of 0.9.46) 0.9.28RSA signature types disallowed, minimum floodfill peers will send DSM to (as of 0.9.34) 0.9.18DSM type bits 7-1 ignored 0.9.16RI key certs / ECDSA and EdDSA signature types, DLM lookup types (flag bits 3-2), minimum version compatible with the current network 0.9.15Destination/LeaseSet key certificates with EdDSA Ed25519 signature type (if floodfill) 0.9.12Destination/LeaseSet key certificates with ECDSA P-256, P-384, and P-521 signature types (if floodfill); non-zero expiration allowed in RouterAddress 0.9.7Encrypted DSM/DSRM replies supported (DLM flag bit 1) for floodfill routers 0.9.6Non-zero DLM flag bits 7-1 allowed 0.9.3Requires zero expiration in RouterAddress 0.9Supports up to 16 leases in a DSM LeaseSet store (previously 6) 0.7.12VTBM and VTBRM message support 0.7.10Floodfill supports encrypted DSM stores 0.6.1.10TBM and TBRM messages introduced; minimum version compatible with the current network **नोट:** ट्रांसपोर्ट-संबंधित विशेषताएँ और संगतता समस्याएँ भी मौजूद हैं। विवरण के लिए NTCP2 और SSU2 ट्रांसपोर्ट प्रलेखन देखें। संदेश हेडर I2NP एक तार्किक 16-बाइट हेडर संरचना का उपयोग करता है, जबकि आधुनिक ट्रांसपोर्ट प्रोटोकॉल (NTCP2 और SSU2) एक संक्षिप्त 9-बाइट हेडर उपयोग करते हैं, जो अनावश्यक आकार और चेकसम फ़ील्ड्स को छोड़ देता है। फ़ील्ड्स अवधारणात्मक रूप से समान ही रहते हैं।\nहेडर प्रारूप तुलना मानक फ़ॉर्मेट (16 बाइट्स):\nपुराने NTCP ट्रांसपोर्ट में और तब उपयोग किया जाता है जब I2NP संदेश अन्य संदेशों के भीतर समाहित होते हैं (TunnelData, TunnelGateway, GarlicClove).\nBytes 0-15: +----+----+----+----+----+----+----+----+ |type| msg_id | expiration +----+----+----+----+----+----+----+----+ | size |chks| +----+----+----+----+----+----+----+----+ type :: Integer (1 byte) Identifies the message type (see message type table) msg_id :: Integer (4 bytes) Uniquely identifies this message (for some time at least) Usually a locally-generated random number, but for outgoing tunnel build messages may be derived from the incoming message expiration :: Date (8 bytes) Unix timestamp in milliseconds when this message expires size :: Integer (2 bytes) Length of the payload (0 to ~61.2 KB for tunnel messages) chks :: Integer (1 byte) SHA256 hash of payload truncated to first byte Deprecated - NTCP2/SSU2 use ChaCha20/Poly1305 AEAD for integrity SSU के लिए संक्षिप्त प्रारूप (अप्रचलित, 5 बाइट्स):\n+----+----+----+----+----+ |type| short_expiration | +----+----+----+----+----+ type :: Integer (1 byte) short_expiration :: Integer (4 bytes, seconds since epoch) NTCP2, SSU2, और ECIES-Ratchet Garlic Cloves (I2P में \u0026lsquo;garlic\u0026rsquo; संदेश का हिस्सा) के लिए संक्षिप्त प्रारूप (9 बाइट्स):\nआधुनिक ट्रांसपोर्ट प्रोटोकॉल में और ECIES (Elliptic Curve Integrated Encryption Scheme—दीर्घवृत्तीय वक्र समेकित एन्क्रिप्शन योजना) द्वारा एन्क्रिप्ट किए गए garlic संदेशों में उपयोग किया जाता है।\n+----+----+----+----+----+----+----+----+ |type| msg_id | short_expira- +----+----+----+----+----+----+----+----+ tion| +----+ type :: Integer (1 byte) msg_id :: Integer (4 bytes) short_expiration :: Integer (4 bytes, seconds since epoch, unsigned) हेडर फ़ील्ड विवरण Field Bytes Description Type 1 Identifies the message class (0\u0026ndash;255, see message types below) Unique ID 4 Locally unique identifier for matching replies Expiration 8 (standard) / 4 (short) Timestamp when the message expires. Routers discard expired messages. Short format uses seconds since epoch (unsigned, wraps February 7, 2106) Payload Length 2 Size in bytes (0 to ~61.2 KB for tunnel messages). NTCP2 and SSU2 encode this in their frame headers Checksum 1 Deprecated. First byte of SHA-256 hash of the payload. NTCP2/SSU2 use ChaCha20/Poly1305 AEAD for integrity ### कार्यान्वयन संबंधी नोट्स SSU (अप्रचलित) के माध्यम से प्रसारित होने पर, केवल प्रकार और 4-बाइट समाप्ति समय शामिल थे NTCP2 या SSU2 के माध्यम से प्रसारित होने पर, 9-बाइट का संक्षिप्त फ़ॉर्मेट उपयोग किया जाता है अन्य संदेशों (Data, TunnelData, TunnelGateway, GarlicClove) में समाहित I2NP संदेशों के लिए मानक 16-बाइट हेडर आवश्यक है रिलीज़ 0.8.12 से, दक्षता के लिए प्रोटोकॉल स्टैक के कुछ स्थानों पर checksum (चेकसम) का सत्यापन अक्षम कर दिया गया है, लेकिन संगतता के लिए checksum का निर्माण अभी भी आवश्यक है संक्षिप्त समाप्ति समय चिह्न-रहित होता है और 7 फ़रवरी, 2106 को रैप-अराउंड कर जाएगा। उस तारीख के बाद सही समय प्राप्त करने के लिए एक ऑफसेट जोड़ना होगा पुराने संस्करणों के साथ संगतता हेतु, भले ही उनका सत्यापन न किया जाए, हमेशा checksum उत्पन्न करें आकार सीमाएँ Tunnel संदेश I2NP पेलोड को नियत आकार के हिस्सों में विभाजित करते हैं:\nपहला खंड: लगभग 956 बाइट बाद के खंड: प्रत्येक लगभग 996 बाइट अधिकतम खंड: 64 (0-63 क्रमांकित) अधिकतम पेलोड: लगभग 61,200 बाइट (61.2 KB) गणना: 956 + (63 × 996) = 63,704 बाइट्स का सैद्धांतिक अधिकतम, जबकि ओवरहेड के कारण व्यावहारिक सीमा लगभग 61,200 बाइट्स।\nऐतिहासिक संदर्भ पुराने ट्रांसपोर्ट्स में फ्रेम आकार की सीमाएँ अधिक कड़ी थीं: - NTCP: 16 KB फ्रेम - SSU: लगभग 32 KB फ्रेम\nNTCP2 लगभग 65 KB आकार के फ्रेम का समर्थन करता है, लेकिन tunnel फ्रैगमेंटेशन सीमा अब भी लागू होती है।\nएप्लिकेशन डेटा संबंधी विचार Garlic messages (I2P में संदेशों को समूहित करने की विधि) LeaseSets, Session Tags, या एन्क्रिप्टेड LeaseSet2 रूपांतरों को बंडल कर सकते हैं, जिससे पेलोड डेटा के लिए उपलब्ध स्थान कम हो जाता है।\nअनुशंसा: विश्वसनीय वितरण सुनिश्चित करने के लिए Datagrams (डेटा पैकेट का एक प्रकार) को ≤ 10 KB तक ही रखना चाहिए। 61 KB की सीमा के निकट पहुँचने वाले संदेशों को निम्नलिखित समस्याओं का सामना हो सकता है: - खंडन और पुनर्संयोजन के कारण विलंबता में वृद्धि - वितरण विफलता की उच्च संभावना - ट्रैफ़िक विश्लेषण के प्रति अधिक उजागर होना\nFragmentation (डेटा को छोटे हिस्सों में बाँटने की प्रक्रिया) के तकनीकी विवरण प्रत्येक tunnel संदेश ठीक 1,024 बाइट (1 KB) का होता है और इसमें शामिल होते हैं: - 4-बाइट tunnel ID - 16-बाइट initialization vector (IV) (आरंभीकरण सदिश) - 1,004 बाइट कूटबद्ध डेटा\nकूटबद्ध डेटा के भीतर, tunnel संदेश खंडित I2NP संदेशों को वहन करते हैं, जिनके फ़्रैगमेंट हेडर यह दर्शाते हैं: - फ़्रैगमेंट संख्या (0-63) - यह पहला या अनुवर्ती फ़्रैगमेंट है - पुनर्संयोजन के लिए सम्पूर्ण संदेश ID\nपहला खंड पूर्ण I2NP संदेश हेडर (16 बाइट्स) शामिल करता है, जिससे payload (डेटा सामग्री) के लिए लगभग 956 बाइट्स बचते हैं। अनुवर्ती खंड संदेश हेडर शामिल नहीं करते, जिससे प्रति खंड लगभग 996 बाइट्स का payload संभव हो पाता है।\nसामान्य संदेश प्रकार Routers संदेश प्रकार और प्राथमिकता का उपयोग आउटबाउंड कार्य को निर्धारित करने के लिए करते हैं। उच्च प्राथमिकता मान पहले संसाधित किए जाते हैं। नीचे दिए गए मान वर्तमान Java I2P डिफ़ॉल्ट मानों से मेल खाते हैं (API संस्करण 0.9.67 के अनुसार)।\nनोट: प्राथमिकताएँ कार्यान्वयन पर निर्भर होती हैं। प्रामाणिक प्राथमिकता मानों के लिए, Java I2P स्रोत कोड में OutNetMessage क्लास के दस्तावेज़ीकरण को देखें।\nMessage Type Priority Typical Size Purpose DatabaseStore 1 460 Varies (LeaseSet ≈ 898\u0026nbsp;B, RouterInfo ≈ 2\u0026ndash;4\u0026nbsp;KB compressed) Publishes RouterInfo or LeaseSet objects. Supports LeaseSet2, EncryptedLeaseSet, and MetaLeaseSet DatabaseLookup 2 500 Varies Queries the network database for RouterInfo or LeaseSet entries DatabaseSearchReply 3 300 ≈161\u0026nbsp;B (5 hashes) Returns candidate floodfill router hashes (typically 3\u0026ndash;16 hashes, recommended maximum 16) DeliveryStatus 10 Varies 12\u0026nbsp;B Receipts for tunnel tests or acknowledgements inside GarlicMessages GarlicMessage 11 100 (local) Varies Bundles multiple message cloves (e.g., DataMessage, LeaseSets). Supports ElGamal/AES (deprecated) and ECIES-X25519-AEAD-Ratchet encryption TunnelData 18 400 1,028\u0026nbsp;B (fixed) Encrypted tunnel message exchanged between hops. Contains a 4-byte tunnel ID, 16-byte IV, and 1,004 bytes of encrypted data TunnelGateway 19 300\u0026ndash;400 Varies Encapsulates messages at the tunnel gateway before fragmentation DataMessage 20 425 4\u0026ndash;62\u0026nbsp;KB Carries end-to-end garlic payloads (application traffic) TunnelBuild (deprecated) 21 500 4,224\u0026nbsp;B Requests tunnel participation from routers (8 × 528-byte records). Replaced by VariableTunnelBuild for ECIES TunnelBuildReply (deprecated) 22 300 4,224\u0026nbsp;B Replies to TunnelBuild with accept/reject status per hop VariableTunnelBuild 23 500 1,057\u0026ndash;4,225\u0026nbsp;B Variable-length tunnel build for ElGamal or ECIES-X25519 routers (1\u0026ndash;8 records, API 0.9.12+) VariableTunnelBuildReply 24 300 1,057\u0026ndash;4,225\u0026nbsp;B Replies to VariableTunnelBuild ShortTunnelBuild 25 500 873\u0026ndash;1,745\u0026nbsp;B Short tunnel build messages for ECIES-X25519 routers only (1\u0026ndash;8 × 218-byte records, API 0.9.51+) OutboundTunnelBuildReply 26 300 873\u0026ndash;1,745\u0026nbsp;B Sent from outbound endpoint to originator for ECIES-X25519 routers (API 0.9.51+) **आरक्षित संदेश प्रकार:** - प्रकार 0: आरक्षित - प्रकार 4-9: भविष्य में उपयोग हेतु आरक्षित - प्रकार 12-17: भविष्य में उपयोग हेतु आरक्षित - प्रकार 224-254: प्रायोगिक संदेशों के लिए आरक्षित - प्रकार 255: भविष्य के विस्तार हेतु आरक्षित संदेश प्रकार टिप्पणियाँ Control-plane messages (नियंत्रण-समतल संदेश) (DatabaseLookup, TunnelBuild, आदि) आमतौर पर अन्वेषी tunnels से होकर गुजरते हैं, न कि क्लाइंट tunnels से, जिससे स्वतंत्र प्राथमिकता निर्धारण संभव हो पाता है प्राथमिकता मान अनुमानित होते हैं और कार्यान्वयन के अनुसार बदल सकते हैं TunnelBuild (21) और TunnelBuildReply (22) अप्रचलित हैं, लेकिन बहुत लंबे tunnels (\u0026gt;8 hops) के साथ अनुकूलता के लिए अब भी लागू किए जाते हैं (यहाँ \u0026lsquo;hops\u0026rsquo; = मध्यवर्ती router चरण) मानक tunnel डेटा प्राथमिकता 400 है; इससे ऊपर कुछ भी तत्काल माना जाता है आज के नेटवर्क में सामान्य tunnel लंबाई 3-4 hops होती है, इसलिए अधिकांश tunnel निर्माण ShortTunnelBuild (218-byte records) या VariableTunnelBuild (528-byte records) का उपयोग करते हैं एन्क्रिप्शन और संदेश रैपिंग router अक्सर प्रेषण से पहले I2NP संदेशों को लपेटते हैं, जिससे कई एन्क्रिप्शन परतें बनती हैं। एक DeliveryStatus संदेश इस प्रकार हो सकता है: 1. एक GarlicMessage में लिपटा हुआ (एन्क्रिप्टेड) 2. एक DataMessage के अंदर 3. एक TunnelData संदेश के भीतर (फिर से एन्क्रिप्टेड)\nप्रत्येक hop (नेटवर्क में एक मध्यवर्ती नोड) केवल अपनी परत को डिक्रिप्ट करता है; अंतिम गंतव्य सबसे भीतरी पेलोड को प्रकट करता है।\nएन्क्रिप्शन एल्गोरिद्म लीगेसी (चरणबद्ध रूप से हटाया जा रहा है): - ElGamal/AES + SessionTags (सत्र टैग) - असममित एन्क्रिप्शन के लिए ElGamal-2048 - सममित एन्क्रिप्शन के लिए AES-256 - 32-बाइट session tags\nवर्तमान (API 0.9.48 के अनुसार मानक): - ECIES-X25519 + ChaCha20/Poly1305 AEAD with ratcheting forward secrecy (आगे की गोपनीयता) - Noise प्रोटोकॉल फ़्रेमवर्क (गंतव्यों के लिए Noise_IK_25519_ChaChaPoly_SHA256) - 8-byte सेशन टैग्स (32 bytes से घटाकर) - forward secrecy के लिए Signal Double Ratchet एल्गोरिथ्म - API संस्करण 0.9.46 (2020) में प्रस्तुत किया गया - API संस्करण 0.9.58 (2023) से सभी routers के लिए अनिवार्य\nभविष्य (2.10.0 में बीटा): - Post-quantum hybrid cryptography (क्वांटम-युग के बाद की मिश्रित क्रिप्टोग्राफी) जो MLKEM (ML-KEM-768) तथा X25519 के संयोजन का उपयोग करती है - Hybrid ratchet (क्रमिक-कुंजी तंत्र) जो परंपरागत और post-quantum key agreement (कुंजी-सहमति) को संयोजित करता है - ECIES-X25519 के साथ पिछली संगतता रखता है - रिलीज़ 2.11.0 (दिसंबर 2025) में डिफ़ॉल्ट बन जाएगा\nElGamal Router का अप्रचलन गंभीर: ElGamal routers को API संस्करण 0.9.58 (रिलीज़ 2.2.0, मार्च 2023) से अप्रचलित घोषित किया गया है। चूँकि क्वेरी करने के लिए अनुशंसित न्यूनतम floodfill संस्करण अब 0.9.58 है, इसलिए कार्यान्वयनों को ElGamal floodfill routers के लिए एन्क्रिप्शन लागू करने की आवश्यकता नहीं है।\nहालाँकि: ElGamal (ElGamal एन्क्रिप्शन एल्गोरिद्म) डेस्टिनेशन अभी भी पिछली संगतता के लिए समर्थित हैं। ElGamal एन्क्रिप्शन का उपयोग करने वाले क्लाइंट अभी भी ECIES (अण्डाकार वक्र समेकित एन्क्रिप्शन योजना) routers के माध्यम से संचार कर सकते हैं।\nECIES-X25519-AEAD-Ratchet का विवरण यह I2P की क्रिप्टोग्राफी विशिष्टता में क्रिप्टो प्रकार 4 है। यह प्रदान करता है:\nमुख्य विशेषताएँ: - ratcheting (हर संदेश के लिए नई कुंजियाँ) के माध्यम से Forward secrecy - सत्र टैग भंडारण में कमी (8 bytes बनाम 32 bytes) - कई सत्र प्रकार (नया सत्र, मौजूदा सत्र, एक-बार उपयोग) - Noise protocol (एक क्रिप्टोग्राफ़िक हैंडशेक फ़्रेमवर्क) Noise_IK_25519_ChaChaPoly_SHA256 पर आधारित - Signal के Double Ratchet algorithm (संदेश-कुंजी रैचेट एल्गोरिद्म) के साथ एकीकृत\nक्रिप्टोग्राफिक प्रिमिटिव्स: - X25519 Diffie-Hellman कुंजी सहमति के लिए - ChaCha20 स्ट्रीम एन्क्रिप्शन के लिए - Poly1305 संदेश प्रामाणीकरण (AEAD) के लिए - SHA-256 हैशिंग के लिए - HKDF कुंजी व्युत्पत्ति के लिए\nसत्र प्रबंधन: - नया सत्र: स्थिर destination key का उपयोग करके प्रारंभिक कनेक्शन - मौजूदा सत्र: आगामी संदेशों के लिए session tags का उपयोग - एक-बार का सत्र: कम ओवरहेड हेतु एक-संदेश सत्र\nपूर्ण तकनीकी विवरण के लिए ECIES Specification और Proposal 144 देखें।\nसामान्य संरचनाएँ निम्नलिखित संरचनाएँ कई I2NP संदेशों के घटक हैं। ये पूर्ण संदेश नहीं हैं।\nBuildRequestRecord (ElGamal) अप्रचलित. वर्तमान नेटवर्क में केवल तब उपयोग किया जाता है जब किसी tunnel में ElGamal router हो। आधुनिक प्रारूप के लिए ECIES Tunnel Creation देखें।\nउद्देश्य: tunnel में एक हॉप के निर्माण का अनुरोध करने के लिए कई रिकॉर्डों के सेट में से एक रिकॉर्ड।\nप्रारूप:\nElGamal और AES एन्क्रिप्टेड (कुल 528 बाइट्स):\n+----+----+----+----+----+----+----+----+ | encrypted data (528 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ ElGamal (एक सार्वजनिक-कुंजी क्रिप्टोग्राफ़ी एल्गोरिथ्म) एन्क्रिप्टेड संरचना (528 बाइट्स):\n+----+----+----+----+----+----+----+----+ | toPeer (16 bytes) | +----+----+----+----+----+----+----+----+ | ElGamal encrypted data (512 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ toPeer :: First 16 bytes of SHA-256 hash of peer\u0026#39;s RouterIdentity encrypted_data :: ElGamal-2048 encrypted (bytes 1-256 and 258-513 of the 514-byte ElGamal block, with padding bytes at positions 0 and 257 removed) Cleartext (स्पष्ट-पाठ) संरचना (एन्क्रिप्शन से पहले 222 बाइट्स):\n+----+----+----+----+----+----+----+----+ | receive_tunnel (4) | our_ident (32) | +----+----+----+----+ + | | + +----+----+----+----+ | | next_tunnel (4) | +----+----+----+----+----+----+----+----+ | next_ident (32 bytes) | + + | | +----+----+----+----+----+----+----+----+ | layer_key (32 bytes) | + + | | +----+----+----+----+----+----+----+----+ | iv_key (32 bytes) | + + | | +----+----+----+----+----+----+----+----+ | reply_key (32 bytes) | + + | | +----+----+----+----+----+----+----+----+ | reply_iv (16 bytes) | + + | | +----+----+----+----+----+----+----+----+ |flag| request_time (4) | send_msg_id | +----+----+----+----+----+----+----+----+ (4) | padding (29) | +----+----+----+----+----+ + | | + +----+----+ | | +----+----+----+----+----+----+ receive_tunnel :: TunnelId (4 bytes, nonzero) our_ident :: Hash (32 bytes) next_tunnel :: TunnelId (4 bytes, nonzero) next_ident :: Hash (32 bytes) layer_key :: SessionKey (32 bytes) iv_key :: SessionKey (32 bytes) reply_key :: SessionKey (32 bytes) reply_iv :: 16 bytes flag :: Integer (1 byte) request_time :: Integer (4 bytes, hours since epoch = time / 3600) send_message_id :: Integer (4 bytes) padding :: 29 bytes random data नोट्स: - ElGamal-2048 एन्क्रिप्शन 514-बाइट का ब्लॉक बनाता है, लेकिन दो पैडिंग बाइट्स (स्थितियाँ 0 और 257 पर) हटा दी जाती हैं, परिणामस्वरूप 512 बाइट्स रह जाती हैं - फ़ील्ड विवरण के लिए Tunnel निर्माण विनिर्देशन देखें - स्रोत कोड: net.i2p.data.i2np.BuildRequestRecord - स्थिरांक: EncryptedBuildRecord.RECORD_SIZE = 528\nBuildRequestRecord (ECIES-X25519 लंबा) ECIES-X25519 routers के लिए, API संस्करण 0.9.48 में पेश किया गया। मिश्रित tunnels के साथ पिछली संगतता बनाए रखने के लिए 528 बाइट्स का उपयोग करता है।\nप्रारूप:\n+----+----+----+----+----+----+----+----+ | toPeer (16 bytes) | +----+----+----+----+----+----+----+----+ | ephemeral_key (32 bytes) | + + | | +----+----+----+----+----+----+----+----+ | ChaCha20 encrypted data (464 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ | Poly1305 MAC (16 bytes) | + + | | +----+----+----+----+----+----+----+----+ toPeer :: First 16 bytes of SHA-256 hash of peer\u0026#39;s RouterIdentity ephemeral_key :: X25519 ephemeral public key (32 bytes) encrypted_data :: ChaCha20 encrypted (464 bytes) mac :: Poly1305 message authentication code (16 bytes) कुल आकार: 528 बाइट्स (संगतता के लिए ElGamal के समान)\nस्पष्ट-पाठ संरचना और एन्क्रिप्शन विवरण के लिए ECIES Tunnel Creation देखें।\nBuildRequestRecord (ECIES-X25519 Short) केवल ECIES-X25519 routers के लिए, API संस्करण 0.9.51 (रिलीज़ 1.5.0) से। यह वर्तमान मानक प्रारूप है।\nप्रारूप:\n+----+----+----+----+----+----+----+----+ | toPeer (16 bytes) | +----+----+----+----+----+----+----+----+ | ephemeral_key (32 bytes) | + + | | +----+----+----+----+----+----+----+----+ | ChaCha20 encrypted data (154 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ | Poly1305 MAC (16 bytes) | + + | | +----+----+----+----+----+----+----+----+ toPeer :: First 16 bytes of SHA-256 hash of peer\u0026#39;s RouterIdentity ephemeral_key :: X25519 ephemeral public key (32 bytes) encrypted_data :: ChaCha20 encrypted (154 bytes) mac :: Poly1305 message authentication code (16 bytes) कुल आकार: 218 बाइट्स (528 बाइट्स से 59% की कमी)\nमुख्य अंतर: संक्षिप्त रिकॉर्ड, उन्हें रिकॉर्ड में स्पष्ट रूप से शामिल करने के बजाय, सभी कुंजियाँ HKDF (key derivation function, कुंजी व्युत्पन्न फ़ंक्शन) के माध्यम से व्युत्पन्न करते हैं। इसमें शामिल हैं:\nलेयर कुंजियाँ (tunnel एन्क्रिप्शन के लिए) IV कुंजियाँ (tunnel एन्क्रिप्शन के लिए) Reply कुंजियाँ (build reply (निर्माण प्रत्युत्तर) के लिए) Reply IVs (build reply के लिए) सभी कुंजियाँ X25519 key exchange (एलिप्टिक-कर्व Diffie–Hellman कुंजी-अदला-बदली) से प्राप्त साझा रहस्य के आधार पर, Noise protocol (क्रिप्टोग्राफ़िक हैंडशेक फ्रेमवर्क) के HKDF (HMAC-आधारित कुंजी व्युत्पत्ति फ़ंक्शन) तंत्र का उपयोग करके व्युत्पन्न की जाती हैं।\nलाभ: - 4 छोटे रिकॉर्ड एक ही tunnel संदेश (873 बाइट्स) में समा जाते हैं - प्रत्येक रिकॉर्ड के लिए अलग-अलग संदेशों के बजाय तीन-संदेश वाला tunnel निर्माण - बैंडविड्थ और विलंबता में कमी - लंबे प्रारूप के समान सुरक्षा गुण\nऔचित्य के लिए प्रस्ताव 157 और पूर्ण विनिर्देश के लिए ECIES Tunnel Creation देखें।\nस्रोत कोड: - net.i2p.data.i2np.ShortEncryptedBuildRecord - स्थिरांक: ShortEncryptedBuildRecord.RECORD_SIZE = 218\nBuildResponseRecord (ElGamal) अप्रचलित। केवल तब उपयोग किया जाता है जब tunnel में ElGamal (क्रिप्टोग्राफ़िक एल्गोरिद्म) router शामिल हो।\nउद्देश्य: बिल्ड अनुरोध के उत्तरों वाले बहु-रिकॉर्ड सेट में से एक रिकॉर्ड।\nप्रारूप:\nएन्क्रिप्टेड (528 बाइट्स, BuildRequestRecord के समान आकार):\nbytes 0-527 :: AES-encrypted record एन्क्रिप्शन-रहित संरचना:\n+----+----+----+----+----+----+----+----+ | SHA-256 hash (32 bytes) | + + | (hash of bytes 32-527) | + + | | +----+----+----+----+----+----+----+----+ | random data (495 bytes) | ~ ~ | |ret | +----+----+----+----+----+----+----+----+ bytes 0-31 :: SHA-256 hash of bytes 32-527 bytes 32-526 :: Random data (could be used for congestion info) byte 527 :: Reply code (0 = accept, 30 = reject) प्रत्युत्तर कोड: - 0 - स्वीकार - 30 - अस्वीकार (बैंडविड्थ सीमा पार)\nreply फ़ील्ड के विवरण के लिए Tunnel निर्माण विनिर्देश देखें।\nबिल्ड प्रतिक्रिया रिकॉर्ड (ECIES-X25519) ECIES-X25519 (एलिप्टिक कर्व आधारित क्रिप्टोग्राफिक सूट) routers के लिए, API संस्करण 0.9.48+। संबंधित अनुरोध के समान आकार (लंबे के लिए 528, छोटे के लिए 218)।\nप्रारूप:\nलंबा प्रारूप (528 बाइट):\n+----+----+----+----+----+----+----+----+ | ChaCha20 encrypted data (512 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ | Poly1305 MAC (16 bytes) | + + | | +----+----+----+----+----+----+----+----+ संक्षिप्त प्रारूप (218 बाइट्स):\n+----+----+----+----+----+----+----+----+ | ChaCha20 encrypted data (202 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ | Poly1305 MAC (16 bytes) | + + | | +----+----+----+----+----+----+----+----+ स्पष्ट-पाठ संरचना (दोनों प्रारूप):\nइसमें एक मैपिंग संरचना (I2P का key-value फ़ॉर्मेट) शामिल है: - उत्तर स्थिति कोड (आवश्यक) - उपलब्ध बैंडविड्थ पैरामीटर (\u0026ldquo;b\u0026rdquo;) (वैकल्पिक, API 0.9.65 में जोड़ा गया) - भविष्य के विस्तारों के लिए अन्य वैकल्पिक पैरामीटर\nउत्तर स्थिति कोड: - 0 - सफलता - 30 - अस्वीकृत: बैंडविड्थ सीमा पार\nपूर्ण विनिर्देश के लिए ECIES Tunnel Creation देखें।\nGarlicClove (लहसुन की कली) (ElGamal/AES) चेतावनी: यह वह प्रारूप है जो ElGamal से एन्क्रिप्ट किए गए garlic messages (समूहित संदेश) के भीतर मौजूद garlic cloves (उप-संदेश) के लिए उपयोग होता है। ECIES-AEAD-X25519-Ratchet garlic messages और garlic cloves का प्रारूप इससे काफी भिन्न है। आधुनिक प्रारूप के लिए ECIES विनिर्देश देखें।\nrouters के लिए अप्रचलित (API 0.9.58+), destinations के लिए अब भी समर्थित।\nप्रारूप:\nएन्क्रिप्शन-रहित:\n+----+----+----+----+----+----+----+----+ | Delivery Instructions (variable) | ~ ~ +----+----+----+----+----+----+----+----+ | I2NP Message (variable) | ~ ~ +----+----+----+----+----+----+----+----+ | Clove ID (4) | Expiration (8) |Cert| +----+----+----+----+----+----+----+----+ (3) | +----+----+----+----+----+----+----+----+ Delivery Instructions :: Variable length (typically 1, 33, or 37 bytes) I2NP Message :: Any I2NP message Clove ID :: 4-byte Integer (random, checked for duplicates) Expiration :: Date (8 bytes) Certificate :: Always NULL (3 bytes total, all zeroes) नोट्स: - Cloves (GarlicMessage के उप-संदेश) कभी खंडित नहीं किए जाते - जब Delivery Instructions फ्लैग बाइट का पहला बिट 0 हो, तो clove एन्क्रिप्टेड नहीं होता - जब पहला बिट 1 हो, तो clove एन्क्रिप्टेड होता है (अभी लागू नहीं किया गया फीचर) - अधिकतम लंबाई कुल clove लंबाइयों और अधिकतम GarlicMessage लंबाई का एक फ़ंक्शन है - प्रमाणपत्र का उपयोग HashCash के साथ राउटिंग के लिए \u0026ldquo;pay\u0026rdquo; करने में किया जा सकता है (भविष्य की संभावना) - व्यवहार में प्रयुक्त संदेश: DataMessage, DeliveryStatusMessage, DatabaseStoreMessage - GarlicMessage के भीतर GarlicMessage हो सकता है (nested garlic), लेकिन व्यवहार में इसका उपयोग नहीं होता\nअवधारणात्मक अवलोकन के लिए Garlic Routing देखें।\nGarlicClove (ECIES-X25519-AEAD-Ratchet) ECIES-X25519 routers और गंतव्यों के लिए, API संस्करण 0.9.46+। यह वर्तमान मानक प्रारूप है।\nअत्यंत महत्वपूर्ण अंतर: ECIES garlic (I2P में bundled संदेशों की तकनीक) स्पष्ट clove (I2P संदेश का उपघटक) संरचनाओं के बजाय Noise protocol (एक क्रिप्टोग्राफ़िक हैंडशेक फ़्रेमवर्क) ब्लॉक्स पर आधारित एक पूरी तरह भिन्न संरचना का उपयोग करता है।\nप्रारूप:\nECIES \u0026lsquo;garlic\u0026rsquo; संदेश (I2P में कई संदेशों को एक साथ पैक करने की तकनीक) कई ब्लॉकों की शृंखला से मिलकर बने होते हैं:\nBlock structure: +----+----+----+----+----+----+----+----+ |type| length | data ... +----+----+----+----+----+-//- type :: 1 byte block type length :: 2 bytes block length data :: variable length data ब्लॉक प्रकार: - 0 - Garlic Clove ब्लॉक (एक I2NP संदेश समाहित करता है) - 1 - दिनांक-समय ब्लॉक (टाइमस्टैम्प) - 2 - विकल्प ब्लॉक (डिलीवरी विकल्प) - 3 - पैडिंग ब्लॉक - 254 - समापन ब्लॉक (अभी लागू नहीं)\nGarlic Clove Block (type 0) (Garlic संदेश का उप-घटक ब्लॉक):\n+----+----+----+----+----+----+----+----+ | 0 | length | Delivery Instructions | +----+----+----+----+ + ~ ~ +----+----+----+----+----+----+----+----+ | I2NP Message | ~ ~ +----+----+----+----+----+----+----+----+ | Clove ID (4) | Expiration (4) | +----+----+----+----+----+----+----+----+ ElGamal प्रारूप से मुख्य अंतर: - 8-बाइट Date के स्थान पर 4-बाइट समाप्ति समय (epoch से सेकंड) का उपयोग करता है - कोई प्रमाणपत्र फ़ील्ड नहीं - प्रकार और लंबाई सहित ब्लॉक संरचना में संलग्न है - पूरे संदेश को ChaCha20/Poly1305 AEAD से एन्क्रिप्ट किया गया है - सेशन प्रबंधन ratcheting (क्रमिक कुंजी-अपडेट तंत्र) के माध्यम से\nNoise protocol framework (Noise प्रोटोकॉल का ढांचा) और ब्लॉक संरचनाओं पर पूर्ण विवरण के लिए ECIES Specification देखें।\nGarlic Clove (I2P संदेश का उप-घटक) के वितरण निर्देश यह फ़ॉर्मेट ElGamal और ECIES दोनों प्रकार की garlic cloves (garlic संदेश के घटक) के लिए उपयोग किया जाता है। यह संलग्न संदेश को कैसे पहुँचाया जाए, यह निर्दिष्ट करता है।\nअति महत्वपूर्ण चेतावनी: यह विनिर्देश केवल Garlic Cloves (लहसुन की कलियाँ) के भीतर वाले Delivery Instructions (वितरण निर्देश) के लिए है। \u0026ldquo;Delivery Instructions\u0026rdquo; Tunnel Messages के भीतर भी उपयोग होते हैं, जहाँ उनका प्रारूप काफ़ी भिन्न होता है। tunnel के Delivery Instructions के लिए Tunnel Message Specification देखें। इन दोनों प्रारूपों को कदापि न मिलाएँ।\nप्रारूप:\nसत्र कुंजी और विलंब उपयोग में नहीं हैं और कभी मौजूद नहीं होते, इसलिए तीन संभावित लंबाइयाँ हैं:\n1 बाइट (स्थानीय) 33 बाइट (ROUTER और गंतव्य) 37 बाइट (TUNNEL) +----+----+----+----+----+----+----+----+ |flag| | +----+ + | Session Key (optional, 32) | + + | | + +----+----+----+----+--------------+ | | | +----+ + | To Hash (optional, 32) | + + | | + +----+----+----+----+--------------+ | | Tunnel ID (4, opt)| Delay (4, opt)| +----+----+----+----+----+----+----+----+ flag :: 1 byte Bit order: 76543210 bit 7: encrypted? (Unimplemented, always 0) If 1, a 32-byte encryption session key follows bits 6-5: delivery type 0x0 = LOCAL (0) 0x1 = DESTINATION (1) 0x2 = ROUTER (2) 0x3 = TUNNEL (3) bit 4: delay included? (Not fully implemented, always 0) If 1, four delay bytes are included bits 3-0: reserved, set to 0 for compatibility Session Key :: 32 bytes (Optional, unimplemented) Present if encrypt flag bit is set To Hash :: 32 bytes (Optional) Present if delivery type is DESTINATION, ROUTER, or TUNNEL - DESTINATION: SHA256 hash of the destination - ROUTER: SHA256 hash of the router identity - TUNNEL: SHA256 hash of the gateway router identity Tunnel ID :: 4 bytes (Optional) Present if delivery type is TUNNEL The destination tunnel ID (nonzero) Delay :: 4 bytes (Optional, unimplemented) Present if delay included flag is set Specifies delay in seconds सामान्य लंबाइयाँ: - स्थानीय वितरण: 1 बाइट (केवल flag) - ROUTER / DESTINATION वितरण: 33 बाइट (flag + hash) - TUNNEL वितरण: 37 बाइट (flag + hash + tunnel ID)\nडिलीवरी प्रकारों के विवरण:\nType Value Description LOCAL 0 Deliver to the local router (this router) DESTINATION 1 Deliver to a destination (client) identified by hash ROUTER 2 Deliver to another router identified by hash TUNNEL 3 Deliver to a tunnel gateway router **कार्यान्वयन नोट्स:** - सेशन कुंजी एन्क्रिप्शन लागू नहीं है और फ्लैग बिट हमेशा 0 रहती है - विलंब पूरी तरह लागू नहीं है और फ्लैग बिट हमेशा 0 रहती है - TUNNEL डिलीवरी के लिए, हैश गेटवे router की पहचान करता है और tunnel ID यह निर्दिष्ट करता है कि कौन‑सा इनबाउंड tunnel है - DESTINATION डिलीवरी के लिए, हैश DESTINATION की सार्वजनिक कुंजी का SHA-256 होता है - ROUTER डिलीवरी के लिए, हैश router की पहचान का SHA-256 होता है I2NP (I2P नेटवर्क प्रोटोकॉल) संदेश सभी I2NP संदेश प्रकारों के लिए पूर्ण संदेश विनिर्देश।\nसंदेश प्रकारों का सारांश Message Type Since Status DatabaseStore10.6.1.10Active DatabaseLookup20.6.1.10Active DatabaseSearchReply30.6.1.10Active DeliveryStatus100.6.1.10Active Garlic110.6.1.10Active TunnelData180.6.1.10Active TunnelGateway190.6.1.10Active Data200.6.1.10Active TunnelBuild210.6.1.10Deprecated TunnelBuildReply220.6.1.10Deprecated VariableTunnelBuild230.7.12Active VariableTunnelBuildReply240.7.12Active ShortTunnelBuild250.9.51Active OutboundTunnelBuildReply260.9.51Active **आरक्षित:** - प्रकार 0: आरक्षित - प्रकार 4-9: भविष्य में उपयोग के लिए आरक्षित - प्रकार 12-17: भविष्य में उपयोग के लिए आरक्षित - प्रकार 224-254: प्रायोगिक संदेशों के लिए आरक्षित - प्रकार 255: भविष्य के विस्तार के लिए आरक्षित DatabaseStore (डेटाबेस स्टोर) (प्रकार 1) उद्देश्य: एक अनुरोध-रहित डेटाबेस स्टोर, या सफल DatabaseLookup संदेश के उत्तर के रूप में।\nसामग्री: एक असंकुचित LeaseSet, LeaseSet2, MetaLeaseSet, या EncryptedLeaseSet, या एक संकुचित RouterInfo.\nरिप्लाई टोकन सहित फ़ॉर्मेट:\n+----+----+----+----+----+----+----+----+ | SHA256 Hash as key (32 bytes) | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ |type| reply token (4) | reply_tunnelId +----+----+----+----+----+----+----+----+ (4) | reply gateway | +----+----+----+----+----+ + | SHA256 hash (32 bytes) | + + | | + +----+ | | +----+----+----+----+----+----+----+ | data ... +----+-// key :: 32 bytes SHA256 hash (the \u0026#34;real\u0026#34; hash, not routing key) type :: 1 byte Type identifier bit 0: 0 = RouterInfo 1 = LeaseSet or variants bits 3-1: (as of 0.9.38) 0: RouterInfo or LeaseSet (types 0 or 1) 1: LeaseSet2 (type 3) 2: EncryptedLeaseSet (type 5) 3: MetaLeaseSet (type 7) 4-7: Unsupported, invalid bits 7-4: Reserved, set to 0 reply token :: 4 bytes If greater than zero, a DeliveryStatusMessage is requested with the Message ID set to the reply token A floodfill router is also expected to flood the data to the closest floodfill peers reply_tunnelId :: 4 bytes (only if reply token \u0026gt; 0) TunnelId of the inbound gateway of the tunnel for the response If 0, reply is sent directly to reply gateway reply gateway :: 32 bytes (only if reply token \u0026gt; 0) SHA256 hash of the RouterInfo If reply_tunnelId is nonzero: inbound gateway router If reply_tunnelId is zero: router to send reply to data :: Variable length If type == 0: 2-byte Integer length + gzip-compressed RouterInfo If type == 1: Uncompressed LeaseSet If type == 3: Uncompressed LeaseSet2 If type == 5: Uncompressed EncryptedLeaseSet If type == 7: Uncompressed MetaLeaseSet reply token (उत्तर टोकन) == 0 होने पर फ़ॉर्मेट:\n+----+----+----+----+----+----+----+----+ | SHA256 Hash as key (32 bytes) | + + | | +----+----+----+----+----+----+----+----+ |type| 0 | data ... +----+----+----+----+----+-// स्रोत कोड: - net.i2p.data.i2np.DatabaseStoreMessage - net.i2p.data.RouterInfo (RouterInfo संरचना के लिए) - net.i2p.data.LeaseSet (LeaseSet संरचना के लिए)\nDatabaseLookup (प्रकार 2) उद्देश्य: नेटवर्क डेटाबेस में किसी प्रविष्टि को खोजने के लिए एक अनुरोध। प्रतिक्रिया या तो DatabaseStore (डेटाबेस में प्रविष्टि को संग्रहीत करने वाला संदेश) या DatabaseSearchReply (खोज का उत्तर देने वाला संदेश) होती है।\nप्रारूप:\n+----+----+----+----+----+----+----+----+ | SHA256 hash as the key (32 bytes) | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ | SHA256 hash of the from router (32) | + or reply tunnel gateway + | | + + | | + + | | +----+----+----+----+----+----+----+----+ |flag| reply_tunnelId (4)| size (2)| | +----+----+----+----+----+----+----+ + | SHA256 of key1 to exclude (32 bytes) | + + | | + +----+ | | | +----+----+----+----+----+----+----+ + | SHA256 of key2 to exclude (32) | + + ~ ~ | | + +----+ | | | +----+----+----+----+----+----+----+ + | Session key if reply encryption | + requested (32 bytes) + | | + +----+ | |tags| +----+----+----+----+----+----+----+----+ | Session tags if reply encryption | + requested (variable) + ~ ~ | | +----+----+----+----+----+----+----+----+ key :: 32 bytes SHA256 hash of the object to lookup from :: 32 bytes If deliveryFlag == 0: SHA256 hash of RouterInfo (sender) If deliveryFlag == 1: SHA256 hash of reply tunnel gateway flags :: 1 byte Bit order: 76543210 bit 0: deliveryFlag 0 = send reply directly 1 = send reply to some tunnel bit 1: encryptionFlag Through 0.9.5: must be 0 As of 0.9.6: ignored As of 0.9.7: 0 = send unencrypted reply 1 = send AES encrypted reply using key and tag bits 3-2: lookup type flags Through 0.9.5: must be 00 As of 0.9.6: ignored As of 0.9.16: 00 = ANY (deprecated, use LS or RI as of 0.9.16) 01 = LS lookup (LeaseSet or variants) 10 = RI lookup (RouterInfo) 11 = exploration lookup (RouterInfo, non-floodfill) bit 4: ECIESFlag Before 0.9.46: ignored As of 0.9.46: 0 = send unencrypted or ElGamal reply 1 = send ChaCha/Poly encrypted reply using key bits 7-5: Reserved, set to 0 reply_tunnelId :: 4 bytes (only if deliveryFlag == 1) TunnelId of the tunnel to send reply to (nonzero) size :: 2 bytes Integer (valid range: 0-512) Number of peers to exclude from DatabaseSearchReply excludedPeers :: $size SHA256 hashes of 32 bytes each If lookup fails, exclude these peers from the reply If includes a hash of all zeroes, the request is exploratory (return non-floodfill routers only) reply_key :: 32 bytes (conditional, see encryption modes below) reply_tags :: 1 byte count + variable length tags (conditional) उत्तर एन्क्रिप्शन मोڈ्स:\nNOTE: ElGamal routers API 0.9.58 से अप्रचलित हैं। क्योंकि क्वेरी करने के लिए अनुशंसित न्यूनतम floodfill संस्करण अब 0.9.58 है, इसलिए कार्यान्वयनों को ElGamal floodfill routers के लिए एन्क्रिप्शन लागू करने की आवश्यकता नहीं है। ElGamal गंतव्य अभी भी समर्थित हैं।\nफ़्लैग बिट 4 (ECIESFlag) का उपयोग बिट 1 (encryptionFlag) के साथ मिलकर उत्तर एन्क्रिप्शन मोड निर्धारित करने के लिए किया जाता है:\nFlag bits 4,1 From To Router Reply DH? Notes 0 0 Any Any No encryption n/a No encryption 0 1 ElG ElG AES No As of 0.9.7, deprecated 0.9.58 1 0 ECIES ElG AEAD No As of 0.9.46, deprecated 0.9.58 1 0 ECIES ECIES AEAD No As of 0.9.49, current standard 1 1 ElG ECIES AES Yes TBD, future 1 1 ECIES ECIES AEAD Yes TBD, future **कोई एन्क्रिप्शन नहीं (flags 0,0):** reply_key, tags, और reply_tags मौजूद नहीं हैं।\nElG से ElG (flags 0,1) - अप्रचलित:\n0.9.7 से समर्थित, 0.9.58 से अप्रचलित.\nreply_key :: 32 byte SessionKey (big-endian) CSRNG(32) random data tags :: 1 byte Integer (1-32, typically 1) Number of reply tags that follow reply_tags :: One or more 32-byte SessionTags Each is CSRNG(32) random data ECIES (Elliptic Curve Integrated Encryption Scheme - दीर्घवृत्तीय वक्र समेकित एन्क्रिप्शन योजना) से ElG (ElGamal - एलगेमल) (flags 1,0) - अप्रचलित:\n0.9.46 से समर्थित, 0.9.58 से अप्रचलित।\nreply_key :: 32 byte ECIES SessionKey (big-endian) CSRNG(32) random data tags :: 1 byte Integer (required value: 1) Number of reply tags that follow reply_tags :: One 8-byte ECIES SessionTag CSRNG(8) random data प्रत्युत्तर ECIES (Elliptic Curve Integrated Encryption Scheme, दीर्घवृत्त वक्र समेकित एन्क्रिप्शन योजना) मौजूदा सत्र संदेश है, जैसा कि ECIES विनिर्देश में परिभाषित है:\n+----+----+----+----+----+----+----+----+ | Session Tag (8 bytes) | +----+----+----+----+----+----+----+----+ | ChaCha20 encrypted payload | ~ ~ | | +----+----+----+----+----+----+----+----+ | Poly1305 MAC (16 bytes) | + + | | +----+----+----+----+----+----+----+----+ tag :: 8 byte reply_tag k :: 32 byte session key (the reply_key) n :: 0 (nonce) ad :: The 8 byte reply_tag payload :: Plaintext data (DSM or DSRM) ciphertext = ENCRYPT(k, n, payload, ad) ECIES से ECIES (flags 1,0) - वर्तमान मानक:\nECIES destination (गंतव्य) या router एक ECIES router को लुकअप अनुरोध भेजता है। 0.9.49 से समर्थित।\nउपरोक्त \u0026ldquo;ECIES to ElG\u0026rdquo; के समान ही प्रारूप है। लुकअप संदेश का एन्क्रिप्शन ECIES Routers में निर्दिष्ट है। अनुरोधकर्ता अनाम है।\nECIES (अण्डाकार वक्र समेकित एन्क्रिप्शन योजना) से ECIES, DH (डिफी–हेल्मन) (flags 1,1) के साथ - भविष्य:\nअभी तक पूरी तरह परिभाषित नहीं है। Proposal 156 देखें।\nटिप्पणियाँ: - 0.9.16 से पहले, कुंजी RouterInfo या LeaseSet के लिए हो सकती थी (एक ही कुंजी स्पेस, अलग करने के लिए कोई फ़्लैग नहीं) - एन्क्रिप्टेड उत्तर केवल तब उपयोगी हैं जब प्रतिक्रिया tunnel के माध्यम से हो - शामिल टैगों की संख्या एक से अधिक हो सकती है यदि वैकल्पिक DHT लुकअप रणनीतियाँ लागू की जाती हैं - लुकअप कुंजी और बहिष्करण कुंजियाँ \u0026ldquo;वास्तविक\u0026rdquo; हैश हैं, रूटिंग कुंजियाँ नहीं - प्रकार 3, 5, और 7 (LeaseSet2 variants) 0.9.38 से लौटाए जा सकते हैं। देखें प्रस्ताव 123 - Exploratory lookup notes (अन्वेषणात्मक लुकअप संबंधी नोट्स): An exploratory lookup को इस प्रकार परिभाषित किया गया है कि वह कुंजी के निकट गैर-floodfill हैशों की सूची लौटाए। हालांकि, कार्यान्वयन भिन्न हैं: Java एक RI के लिए खोज कुंजी को लुकअप करता है और यदि मौजूद हो तो DatabaseStore लौटाता है; i2pd ऐसा नहीं करता। इसलिए, पहले से प्राप्त हैशों के लिए exploratory lookup का उपयोग करने की अनुशंसा नहीं की जाती।\nस्रोत कोड: - net.i2p.data.i2np.DatabaseLookupMessage - एन्क्रिप्शन: net.i2p.crypto.SessionKeyManager\nDatabaseSearchReply (डेटाबेस खोज उत्तर) (प्रकार 3) उद्देश्य: विफल DatabaseLookup (डेटाबेस खोज) संदेश के लिए प्रतिक्रिया।\nसामग्री: अनुरोधित कुंजी के सबसे निकट वाले router हैशों की सूची।\nप्रारूप:\n+----+----+----+----+----+----+----+----+ | SHA256 hash as query key (32 bytes) | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ | num| peer_hashes (variable) | +----+ + | | ~ ~ | | + +----+----+----+----+----+----+----+ | | from (32 bytes) | +----+ + | | + + | | + + | | + +----+----+----+----+----+----+----+ | | +----+ key :: 32 bytes SHA256 of the object being searched num :: 1 byte Integer Number of peer hashes that follow (0-255) peer_hashes :: $num SHA256 hashes of 32 bytes each (total $num*32 bytes) SHA256 of the RouterIdentity that the sender thinks is close to the key from :: 32 bytes SHA256 of the RouterInfo of the router this reply was sent from स्रोत कोड: - net.i2p.data.i2np.DatabaseSearchReplyMessage\nDeliveryStatus (डिलिवरी स्थिति) (प्रकार 10) उद्देश्य: एक सरल संदेश पावती। आम तौर पर संदेश प्रेषक द्वारा बनाया जाता है और स्वयं संदेश के साथ इसे Garlic Message में लपेटा जाता है, ताकि गंतव्य द्वारा इसे वापस भेजा जा सके।\nसामग्री: पहुंचाए गए संदेश का ID और निर्माण या आगमन समय।\nप्रारूप:\n+----+----+----+----+----+----+----+----+----+----+----+----+ | msg_id (4) | time_stamp (8) | +----+----+----+----+----+----+----+----+----+----+----+----+ msg_id :: Integer (4 bytes) Unique ID of the message we deliver the DeliveryStatus for (see I2NP Message Header for details) time_stamp :: Date (8 bytes) Time the message was successfully created or delivered टिप्पणियाँ: - टाइम स्टैम्प हमेशा निर्माता द्वारा वर्तमान समय पर सेट किया जाता है। हालांकि, कोड में इसके कई उपयोग हैं, और भविष्य में और जोड़े जा सकते हैं - यह संदेश SSU में सत्र स्थापित होने की पुष्टि के रूप में भी उपयोग होता है। इस स्थिति में, संदेश आईडी एक यादृच्छिक संख्या पर सेट की जाती है, और \u0026ldquo;arrival time\u0026rdquo; वर्तमान नेटवर्क-व्यापी आईडी पर सेट किया जाता है, जो 2 है (अर्थात, 0x0000000000000002) - DeliveryStatus (डिलीवरी की पुष्टि वाला संदेश प्रकार) आमतौर पर एक GarlicMessage (कई संदेशों का संकुल) में लपेटकर tunnel के माध्यम से भेजा जाता है ताकि प्रेषक का खुलासा किए बिना पुष्टि प्रदान की जा सके - tunnel परीक्षण में विलंबता और विश्वसनीयता मापने के लिए उपयोग किया जाता है\nस्रोत कोड: - net.i2p.data.i2np.DeliveryStatusMessage - प्रयुक्त स्थान: net.i2p.router.tunnel.InboundEndpointProcessor tunnel परीक्षण के लिए\nGarlicMessage (लहसुन-आधारित संदेश; प्रकार 11) चेतावनी: यह ElGamal-कूटबद्ध garlic संदेशों के लिए उपयोग किया जाने वाला प्रारूप है। ECIES-AEAD-X25519-Ratchet garlic संदेशों का प्रारूप काफी भिन्न है। आधुनिक प्रारूप के लिए ECIES विनिर्देश देखें।\nउद्देश्य: कई एन्क्रिप्टेड I2NP संदेशों को लपेटने के लिए उपयोग किया जाता है।\nContents: डिक्रिप्ट करने पर, Garlic Cloves (Garlic संदेश की इकाइयाँ) और अतिरिक्त डेटा की एक श्रृंखला मिलती है, जिसे Clove Set (इकाइयों का समूह) भी कहा जाता है।\nकूटबद्ध प्रारूप:\n+----+----+----+----+----+----+----+----+ | length (4) | data | +----+----+----+----+----+ + | | ~ ~ | | +----+----+----+----+----+----+----+----+ length :: 4 byte Integer Number of bytes that follow (0 to 64 KB) data :: $length bytes ElGamal encrypted data डिक्रिप्टेड डेटा (Clove Set — I2P में garlic encryption संरचना के भीतर कई संदेशों का समूह):\n+----+----+----+----+----+----+----+----+ | num| clove 1 (variable) | +----+ + | | ~ ~ | | +----+----+----+----+----+----+----+----+ | clove 2 (variable) | ~ ~ | | +----+----+----+----+----+----+----+----+ | Certificate (3) | Message_ID (4) | +----+----+----+----+----+----+----+----+ Expiration (8) | +----+----+----+----+----+----+----+----+ num :: 1 byte Integer Number of GarlicCloves to follow clove :: GarlicClove (see GarlicClove structure above) Certificate :: Always NULL (3 bytes total, all zeroes) Message_ID :: 4 byte Integer Expiration :: Date (8 bytes) ECIES-X25519-AEAD-Ratchet प्रारूप के लिए (routers के लिए वर्तमान मानक):\nदेखें ECIES विनिर्देश और प्रस्ताव 144 .\nस्रोत कोड: - net.i2p.data.i2np.GarlicMessage - एन्क्रिप्शन: net.i2p.crypto.elgamal.ElGamalAESEngine (अप्रचलित) - आधुनिक एन्क्रिप्शन: net.i2p.crypto.ECIES पैकेज\nTunnelData (प्रकार 18) उद्देश्य: एक संदेश जो tunnel के gateway या किसी प्रतिभागी से अगले प्रतिभागी या एंडपॉइंट को भेजा जाता है। डेटा निश्चित लंबाई का होता है, जिसमें खंडित, बैच किए गए, पैड किए गए और एन्क्रिप्टेड I2NP संदेश शामिल होते हैं।\nप्रारूप:\n+----+----+----+----+----+----+----+----+ | tunnelID (4) | data (1024) | +----+----+----+----+----+ + | | ~ ~ | | + +----+----+----+----+ | | +----+----+----+----+ tunnelId :: 4 bytes TunnelId identifying the tunnel this message is directed at Nonzero data :: 1024 bytes Payload data, fixed to 1024 bytes पेलोड संरचना (1024 बाइट्स):\nBytes 0-15: Initialization Vector (IV) for AES encryption Bytes 16-1023: Encrypted tunnel message data (1008 bytes) टिप्पणियाँ: - TunnelData के लिए I2NP संदेश आईडी प्रत्येक hop (मार्ग का चरण) पर एक नई यादृच्छिक संख्या पर सेट की जाती है - tunnel संदेश प्रारूप (एन्क्रिप्टेड डेटा के भीतर) Tunnel Message Specification में निर्दिष्ट है - प्रत्येक hop AES-256 in CBC mode का उपयोग करके एक परत डिक्रिप्ट करता है - डिक्रिप्ट किए गए डेटा का उपयोग करके IV को प्रत्येक hop पर अपडेट किया जाता है - कुल आकार बिल्कुल 1,028 बाइट (4 tunnelId + 1024 data) है - यह tunnel ट्रैफ़िक की मूलभूत इकाई है - TunnelData संदेश विखंडित I2NP संदेशों (GarlicMessage, DatabaseStore, आदि) को वहन करते हैं\nस्रोत कोड: - net.i2p.data.i2np.TunnelDataMessage - स्थिरांक: TunnelDataMessage.DATA_LENGTH = 1024 - प्रसंस्करण: net.i2p.router.tunnel.InboundGatewayProcessor\nTunnelGateway (प्रकार 19) उद्देश्य: tunnel के inbound gateway (आवक प्रवेश-द्वार) पर, tunnel में भेजे जाने हेतु किसी अन्य I2NP संदेश को लपेटता है।\nप्रारूप:\n+----+----+----+----+----+----+----+-// | tunnelId (4) | length (2)| data... +----+----+----+----+----+----+----+-// tunnelId :: 4 bytes TunnelId identifying the tunnel this message is directed at Nonzero length :: 2 byte Integer Length of the payload data :: $length bytes Actual payload of this message नोट्स: - पेलोड एक I2NP message है जिसमें मानक 16-बाइट हेडर होता है - स्थानीय router से tunnels में संदेश इंजेक्ट करने के लिए उपयोग किया जाता है - गेटवे आवश्यक होने पर संलग्न संदेश को खंडों में विभाजित करता है - खंडन के बाद, उन खंडों को TunnelData संदेशों में लपेटा जाता है - TunnelGateway कभी नेटवर्क पर नहीं भेजा जाता; यह tunnel प्रसंस्करण से पहले उपयोग किया जाने वाला आंतरिक संदेश प्रकार है\nस्रोत कोड: - net.i2p.data.i2np.TunnelGatewayMessage - प्रसंस्करण: net.i2p.router.tunnel.OutboundGatewayProcessor\nDataMessage (डेटा संदेश) (प्रकार 20) Purpose: Garlic Messages (I2P में प्रयुक्त garlic प्रकार के संदेश) और Garlic Cloves (उसी संदेश के उपघटक) द्वारा किसी भी डेटा को लपेटने के लिए उपयोग किया जाता है (आमतौर पर एंड-टू-एंड एन्क्रिप्टेड एप्लिकेशन डेटा)।\nप्रारूप:\n+----+----+----+----+----+----+-//-+ | length (4) | data... | +----+----+----+----+----+----+-//-+ length :: 4 bytes Length of the payload data :: $length bytes Actual payload of this message नोट्स: - इस संदेश में कोई रूटिंग जानकारी नहीं होती और इसे कभी भी \u0026ldquo;अनरैप्ड\u0026rdquo; रूप में नहीं भेजा जाएगा - केवल Garlic messages (I2P में प्रयुक्त बहु-संदेश समेकन तकनीक) के भीतर उपयोग होता है - आमतौर पर एंड-टू-एंड एन्क्रिप्टेड एप्लिकेशन डेटा (HTTP, IRC, email, आदि) शामिल होता है - डेटा प्रायः ElGamal/AES या ECIES-एन्क्रिप्टेड पेलोड होता है - tunnel संदेश खंडन सीमाओं के कारण व्यवहारिक अधिकतम लंबाई लगभग 61.2 KB होती है\nस्रोत कोड: - net.i2p.data.i2np.DataMessage\nTunnelBuild (प्रकार 21) अप्रचलित। VariableTunnelBuild (प्रकार 23) या ShortTunnelBuild (प्रकार 25) का उपयोग करें।\nउद्देश्य: 8 हॉप्स के लिए निश्चित लंबाई का tunnel निर्माण अनुरोध.\nप्रारूप:\n+----+----+----+----+----+----+----+----+ | Record 0 (528 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ | Record 1 (528 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ | Record 7 (528 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ Just 8 BuildRequestRecords attached together Record size: 528 bytes Total size: 8 × 528 = 4,224 bytes टिप्पणियाँ: - 0.9.48 से, इसमें ECIES-X25519 BuildRequestRecords (बिल्ड अनुरोध रिकॉर्ड्स) शामिल हो सकते हैं। देखें ECIES Tunnel Creation - विस्तृत जानकारी के लिए Tunnel Creation Specification देखें - इस संदेश के लिए I2NP message ID को tunnel creation specification के अनुसार सेट किया जाना चाहिए - आज के नेटवर्क में यह शायद ही दिखता है (VariableTunnelBuild द्वारा प्रतिस्थापित), फिर भी बहुत लंबे tunnels के लिए इसका उपयोग किया जा सकता है और इसे औपचारिक रूप से अप्रचलित घोषित नहीं किया गया है - Routers को संगतता के लिए इसे अब भी लागू करना आवश्यक है - स्थिर 8-record प्रारूप लचीला नहीं है और छोटे tunnels के लिए बैंडविड्थ बर्बाद करता है\nस्रोत कोड: - net.i2p.data.i2np.TunnelBuildMessage - स्थिरांक: TunnelBuildMessageBase.MAX_RECORD_COUNT = 8\nTunnelBuildReply (प्रकार 22) अप्रचलित। VariableTunnelBuildReply (प्रकार 24) या OutboundTunnelBuildReply (प्रकार 26) का उपयोग करें।\nउद्देश्य: 8 हॉप्स के लिए निश्चित लंबाई की tunnel build reply (tunnel निर्माण का उत्तर)।\nप्रारूप:\nTunnelBuildMessage के समान प्रारूप, जिसमें BuildRequestRecords के स्थान पर BuildResponseRecords हैं।\nTotal size: 8 × 528 = 4,224 bytes नोट्स: - संस्करण 0.9.48 से, इसमें ECIES-X25519 BuildResponseRecords हो सकते हैं। देखें ECIES Tunnel Creation - विवरण के लिए देखें Tunnel Creation Specification - इस संदेश के लिए I2NP message ID को tunnel निर्माण विनिर्देशन के अनुसार सेट किया जाना चाहिए - आज के नेटवर्क में यह शायद ही दिखाई देता है (VariableTunnelBuildReply द्वारा प्रतिस्थापित), फिर भी बहुत लंबे tunnels के लिए इसका उपयोग किया जा सकता है और इसे औपचारिक रूप से अप्रचलित (deprecated) घोषित नहीं किया गया है - Routers को संगतता के लिए इसे अब भी लागू करना आवश्यक है\nस्रोत कोड: - net.i2p.data.i2np.TunnelBuildReplyMessage\nVariableTunnelBuild (परिवर्तनीय tunnel निर्माण) (प्रकार 23) उद्देश्य: 1-8 hops के लिए परिवर्तनीय-लंबाई tunnel निर्माण. ElGamal और ECIES-X25519 दोनों routers का समर्थन करता है.\nप्रारूप:\n+----+----+----+----+----+----+----+----+ | num| BuildRequestRecords (variable) | +----+----+----+----+----+----+----+----+ num :: 1 byte Integer Valid values: 1-8 BuildRequestRecords :: $num records of 528 bytes each Record size: 528 bytes Total size: 1 + ($num × 528) bytes नोट्स: - संस्करण 0.9.48 से, इसमें ECIES-X25519 BuildRequestRecords (निर्माण अनुरोध रिकॉर्ड) शामिल हो सकते हैं। देखें ECIES tunnel निर्माण - router संस्करण 0.7.12 (2009) में प्रस्तुत किया गया - संस्करण 0.7.12 से पुराने संस्करण वाले tunnel प्रतिभागियों को यह भेजा नहीं जा सकता - विवरण हेतु देखें tunnel निर्माण विशिष्टता - I2NP संदेश ID को tunnel निर्माण विशिष्टता के अनुसार सेट किया जाना चाहिए - सामान्य रिकॉर्ड की संख्या: 4 (एक 4-हॉप tunnel के लिए) - सामान्य कुल आकार: 1 + (4 × 528) = 2,113 बाइट्स - यह ElGamal routers के लिए मानक tunnel build संदेश है - ECIES routers सामान्यतः इसके बजाय ShortTunnelBuild (type 25) का उपयोग करते हैं\nस्रोत कोड: - net.i2p.data.i2np.VariableTunnelBuildMessage\nVariableTunnelBuildReply (प्रकार 24) उद्देश्य: 1-8 hops (नेटवर्क में मध्यवर्ती नोड्स) के लिए परिवर्तनीय लंबाई वाला tunnel निर्माण प्रत्युत्तर। दोनों ElGamal और ECIES-X25519 routers का समर्थन करता है।\nप्रारूप:\nVariableTunnelBuildMessage के समान प्रारूप, जिसमें BuildRequestRecords के बजाय BuildResponseRecords होते हैं।\n+----+----+----+----+----+----+----+----+ | num| BuildResponseRecords (variable) | +----+----+----+----+----+----+----+----+ num :: 1 byte Integer Valid values: 1-8 BuildResponseRecords :: $num records of 528 bytes each Record size: 528 bytes Total size: 1 + ($num × 528) bytes टिप्पणियाँ: - संस्करण 0.9.48 से, इसमें ECIES-X25519 BuildResponseRecords हो सकते हैं। देखें ECIES Tunnel Creation - router संस्करण 0.7.12 (2009) में प्रस्तुत किया गया - संस्करण 0.7.12 से पहले के tunnel प्रतिभागियों को यह नहीं भेजा जाना चाहिए - विवरण के लिए Tunnel Creation Specification देखें - tunnel निर्माण विशिष्टता के अनुसार I2NP (I2P का नेटवर्क प्रोटोकॉल) संदेश ID सेट किया जाना चाहिए - रिकॉर्डों की सामान्य संख्या: 4 - सामान्य कुल आकार: 2,113 बाइट्स\nस्रोत कोड: - net.i2p.data.i2np.VariableTunnelBuildReplyMessage\nShortTunnelBuild (प्रकार 25) उद्देश्य: केवल ECIES-X25519 (एक एलिप्टिक-वक्र-आधारित एन्क्रिप्शन स्कीम) routers के लिए छोटे tunnel build संदेश। API संस्करण 0.9.51 (रिलीज़ 1.5.0, अगस्त 2021) में प्रस्तुत। यह ECIES tunnel builds के लिए वर्तमान मानक है।\nप्रारूप:\n+----+----+----+----+----+----+----+----+ | num| ShortBuildRequestRecords (var) | +----+----+----+----+----+----+----+----+ num :: 1 byte Integer Valid values: 1-8 ShortBuildRequestRecords :: $num records of 218 bytes each Record size: 218 bytes Total size: 1 + ($num × 218) bytes टिप्पणियाँ: - router संस्करण 0.9.51 में प्रस्तुत किया गया (रिलीज़ 1.5.0, अगस्त 2021) - API संस्करण 0.9.51 से पहले tunnel प्रतिभागियों को भेजा नहीं जा सकता - पूर्ण विनिर्देशन के लिए ECIES Tunnel निर्माण देखें - औचित्य के लिए प्रस्ताव 157 देखें - रिकॉर्डों की सामान्य संख्या: 4 - सामान्य कुल आकार: 1 + (4 × 218) = 873 बाइट्स - बैंडविड्थ बचत: VariableTunnelBuild (I2P में tunnel निर्माण संदेश का एक प्रकार) की तुलना में 59% छोटा (873 बनाम 2,113 बाइट्स) - प्रदर्शन लाभ: 4 छोटे रिकॉर्ड एक tunnel संदेश में समा जाते हैं; VariableTunnelBuild को 3 tunnel संदेशों की आवश्यकता होती है - अब यह शुद्ध ECIES-X25519 tunnels के लिए मानक tunnel build प्रारूप है - रिकॉर्ड कुंजियाँ स्पष्ट रूप से शामिल करने के बजाय HKDF के माध्यम से व्युत्पन्न करते हैं\nस्रोत कोड: - net.i2p.data.i2np.ShortTunnelBuildMessage - स्थिरांक: ShortEncryptedBuildRecord.RECORD_SIZE = 218\nOutboundTunnelBuildReply (प्रकार 26) उद्देश्य: नए tunnel के आउटबाउंड एंडपॉइंट से प्रारंभकर्ता को भेजा जाता है। केवल ECIES-X25519 routers के लिए। API संस्करण 0.9.51 (रिलीज़ 1.5.0, अगस्त 2021) में पेश किया गया।\nप्रारूप:\nShortTunnelBuildMessage के समान प्रारूप, जिसमें ShortBuildRequestRecords के बजाय ShortBuildResponseRecords हैं।\n+----+----+----+----+----+----+----+----+ | num| ShortBuildResponseRecords (var) | +----+----+----+----+----+----+----+----+ num :: 1 byte Integer Valid values: 1-8 ShortBuildResponseRecords :: $num records of 218 bytes each Record size: 218 bytes Total size: 1 + ($num × 218) bytes टिप्पणियाँ: - इसका परिचय router संस्करण 0.9.51 में हुआ (रिलीज़ 1.5.0, अगस्त 2021) - पूर्ण विनिर्देशन के लिए ECIES Tunnel Creation देखें - रिकॉर्ड की सामान्य संख्या: 4 - कुल सामान्य आकार: 873 बाइट्स - यह उत्तर नव-निर्मित आउटबाउंड tunnel के माध्यम से आउटबाउंड एंडपॉइंट (OBEP) से वापस tunnel निर्माता को भेजा जाता है - यह पुष्टि करता है कि सभी हॉप्स ने tunnel build स्वीकार कर लिया है\nस्रोत कोड: - net.i2p.data.i2np.OutboundTunnelBuildReplyMessage\nसंदर्भ आधिकारिक विनिर्देश I2NP विनिर्देश - I2NP संदेश प्रारूप का पूर्ण विनिर्देश सामान्य संरचनाएँ - I2P में प्रयुक्त डेटा प्रकार और संरचनाएँ Tunnel निर्माण - ElGamal (एक सार्वजनिक-कुंजी क्रिप्टोसिस्टम) tunnel निर्माण (अप्रचलित) ECIES Tunnel निर्माण - ECIES-X25519 tunnel निर्माण (वर्तमान) Tunnel संदेश - Tunnel संदेश प्रारूप और वितरण निर्देश NTCP2 विनिर्देश - TCP परिवहन प्रोटोकॉल SSU2 विनिर्देश - UDP परिवहन प्रोटोकॉल ECIES विनिर्देश - ECIES-X25519-AEAD-Ratchet एन्क्रिप्शन क्रिप्टोग्राफी विनिर्देश - निम्न-स्तरीय क्रिप्टोग्राफिक प्रिमिटिव्स I2CP विनिर्देश - क्लाइंट प्रोटोकॉल विनिर्देश डेटाग्राम विनिर्देश - Datagram2 और Datagram3 प्रारूप प्रस्ताव प्रस्ताव 123 - नई netDB प्रविष्टियाँ (LeaseSet2, EncryptedLeaseSet, MetaLeaseSet) प्रस्ताव 144 - ECIES-X25519-AEAD-Ratchet एन्क्रिप्शन प्रस्ताव 154 - एन्क्रिप्टेड डेटाबेस लुकअप प्रस्ताव 156 - ECIES routers प्रस्ताव 157 - छोटे tunnel निर्माण संदेश (संक्षिप्त प्रारूप) प्रस्ताव 159 - SSU2 ट्रांसपोर्ट प्रस्ताव 161 - कम्प्रेस करने योग्य पैडिंग प्रस्ताव 163 - डेटाग्राम2 और डेटाग्राम3 प्रस्ताव 167 - LeaseSet सर्विस रिकॉर्ड पैरामीटर प्रस्ताव 168 - Tunnel निर्माण बैंडविड्थ पैरामीटर प्रस्ताव 169 - पोस्ट-क्वांटम हाइब्रिड क्रिप्टोग्राफी प्रलेखन Garlic Routing - परतदार संदेश बंडलिंग ElGamal/AES - अप्रचलित एन्क्रिप्शन योजना Tunnel Implementation - खंडन और प्रसंस्करण Network Database - वितरित हैश तालिका NTCP2 Transport - TCP ट्रांसपोर्ट विनिर्देश SSU2 Transport - UDP ट्रांसपोर्ट विनिर्देश Technical Introduction - I2P आर्किटेक्चर का अवलोकन स्रोत कोड Java I2P रिपॉज़िटरी - आधिकारिक Java कार्यान्वयन GitHub मिरर - Java I2P का GitHub मिरर i2pd रिपॉज़िटरी - C++ कार्यान्वयन मुख्य स्रोत कोड स्थान Java I2P (i2pgit.org/I2P_Developers/i2p.i2p): - core/java/src/net/i2p/data/i2np/ - I2NP संदेश कार्यान्वयन - core/java/src/net/i2p/crypto/ - क्रिप्टोग्राफिक कार्यान्वयन - router/java/src/net/i2p/router/tunnel/ - Tunnel प्रसंस्करण - router/java/src/net/i2p/router/transport/ - परिवहन कार्यान्वयन\nस्थिरांक और मान: - I2NPMessage.MAX_SIZE = 65536 - अधिकतम I2NP संदेश आकार - I2NPMessageImpl.HEADER_LENGTH = 16 - मानक हेडर आकार - TunnelDataMessage.DATA_LENGTH = 1024 - tunnel संदेश पेलोड - EncryptedBuildRecord.RECORD_SIZE = 528 - लंबा बिल्ड रिकॉर्ड - ShortEncryptedBuildRecord.RECORD_SIZE = 218 - छोटा बिल्ड रिकॉर्ड - TunnelBuildMessageBase.MAX_RECORD_COUNT = 8 - प्रति बिल्ड अधिकतम रिकॉर्ड\nपरिशिष्ट A: नेटवर्क सांख्यिकी और वर्तमान स्थिति नेटवर्क संरचना (अक्टूबर 2025 तक) कुल routers: लगभग 60,000-70,000 (बदलता रहता है) Floodfill routers: लगभग 500-700 सक्रिय एन्क्रिप्शन प्रकार: ECIES-X25519: routers में से \u0026gt;95% ElGamal: routers में से \u0026lt;5% (अप्रचलित, केवल पुरानी संगतता के लिए) ट्रांसपोर्ट अपनाना: SSU2: \u0026gt;60% प्राथमिक ट्रांसपोर्ट NTCP2: ~40% प्राथमिक ट्रांसपोर्ट पुराने ट्रांसपोर्ट (SSU1, NTCP): 0% (हटाए गए) हस्ताक्षर प्रकार: EdDSA (Ed25519): अधिकांश ECDSA: कम प्रतिशत RSA: निषिद्ध (हटाया गया) न्यूनतम Router आवश्यकताएँ API संस्करण: 0.9.16+ (नेटवर्क के साथ EdDSA (Elliptic Curve Digital Signature Algorithm — अण्डाकार वक्र डिजिटल हस्ताक्षर एल्गोरिद्म) संगतता हेतु) अनुशंसित न्यूनतम: API 0.9.51+ (ECIES (Elliptic Curve Integrated Encryption Scheme — अण्डाकार वक्र एकीकृत एन्क्रिप्शन योजना) short tunnel बिल्ड्स) floodfills के लिए वर्तमान न्यूनतम: API 0.9.58+ (ElGamal (एन्क्रिप्शन एल्गोरिद्म) router का अप्रचलन) आगामी आवश्यकता: Java 17+ (रिलीज़ 2.11.0, दिसंबर 2025 से) बैंडविड्थ आवश्यकताएँ न्यूनतम: 128 KBytes/sec (N flag या उससे अधिक) floodfill के लिए अनुशंसित: 256 KBytes/sec (O flag) या उससे अधिक Floodfill आवश्यकताएँ: न्यूनतम 128 KB/sec बैंडविड्थ स्थिर अपटाइम (\u0026gt;95% अनुशंसित) कम लैटेंसी (\u0026lt;500ms पीयर्स तक) हेल्थ परीक्षण पास करें (क्यू समय, जॉब लैग) Tunnel सांख्यिकी सामान्य tunnel लंबाई: 3-4 hops (बीच के नोड/कदम) अधिकतम tunnel लंबाई: 8 hops (सैद्धांतिक, बहुत कम उपयोग) सामान्य tunnel जीवनकाल: 10 मिनट Tunnel निर्माण सफलता दर: \u0026gt;85% अच्छी तरह से जुड़े हुए routers के लिए Tunnel निर्माण संदेश प्रारूप: ECIES routers: ShortTunnelBuild (218-byte रिकॉर्ड्स) मिश्रित tunnels: VariableTunnelBuild (528-byte रिकॉर्ड्स) प्रदर्शन मेट्रिक्स Tunnel निर्माण समय: 1-3 सेकंड (सामान्यतः) एंड-टू-एंड विलंबता: 0.5-2 सेकंड (सामान्यतः, कुल 6-8 हॉप्स) थ्रूपुट: Tunnel बैंडविड्थ द्वारा सीमित (सामान्यतः प्रति tunnel 10-50 KB/sec) अधिकतम डेटाग्राम आकार: 10 KB अनुशंसित (61.2 KB सैद्धांतिक अधिकतम) परिशिष्ट बी: अप्रचलित और हटाई गई विशेषताएँ पूरी तरह हटाया गया (अब समर्थित नहीं है) NTCP transport - रिलीज़ 0.9.50 (मई 2021) में हटाया गया SSU v1 transport - Java I2P से रिलीज़ 2.4.0 (दिसंबर 2023) में हटाया गया SSU v1 transport - i2pd से रिलीज़ 2.44.0 (नवंबर 2022) में हटाया गया RSA signature types - API 0.9.28 से निषिद्ध अप्रचलित (समर्थित लेकिन अनुशंसित नहीं) ElGamal routers - API 0.9.58 (मार्च 2023) से अप्रचलित पश्च-संगतता के लिए ElGamal destinations अब भी समर्थित हैं नए routers को केवल ECIES-X25519 का उपयोग करना चाहिए TunnelBuild (प्रकार 21) - VariableTunnelBuild और ShortTunnelBuild के पक्ष में अप्रचलित बहुत लंबे tunnels (\u0026gt;8 हॉप्स) के लिए अब भी कार्यान्वित है TunnelBuildReply (प्रकार 22) - VariableTunnelBuildReply और OutboundTunnelBuildReply के पक्ष में अप्रचलित ElGamal/AES एन्क्रिप्शन - ECIES-X25519-AEAD-Ratchet के पक्ष में अप्रचलित लेगेसी destinations के लिए अब भी उपयोग किया जाता है लंबे ECIES BuildRequestRecords (528 bytes) - छोटे प्रारूप (218 bytes) के पक्ष में अप्रचलित ElGamal हॉप्स वाले मिश्रित tunnels में अब भी उपयोग किया जाता है लेगेसी समर्थन की समयरेखा Feature Introduced Deprecated Removed Notes NTCP 2003 2018 (0.9.36) 2021 (0.9.50) Replaced by NTCP2 SSU v1 2004 2022 (0.9.54) 2023 (Java) / 2022 (i2pd) Replaced by SSU2 ElGamal routers 2003 2023 (0.9.58) TBD Destinations still supported RSA signatures 2015 2017 2017 (0.9.28) Never widely used TunnelBuild 2004 2009 (0.7.12) Not removed Still supported for long tunnels --- परिशिष्ट C: आगामी विकास Post-Quantum Cryptography (क्वांटम-पश्चात कूटलेखन) स्थिति: रिलीज़ 2.10.0 (सितंबर 2025) से बीटा, 2.11.0 (दिसंबर 2025) में डिफ़ॉल्ट बन जाएगा\nकार्यान्वयन: - पारंपरिक X25519 और पोस्ट-क्वांटम MLKEM (ML-KEM-768) को संयोजित करने वाला हाइब्रिड दृष्टिकोण - मौजूदा ECIES-X25519 इन्फ्रास्ट्रक्चर के साथ बैकवर्ड-कम्पैटिबल - Signal Double Ratchet (Signal प्रोटोकॉल का डबल रैचेट एल्गोरिदम) का उपयोग, जिसमें पारंपरिक और PQ (पोस्ट-क्वांटम) दोनों प्रकार की कुंजी सामग्री होती है - विवरण के लिए Proposal 169 देखें\nस्थानांतरण मार्ग: 1. रिलीज़ 2.10.0 (सितंबर 2025): बीटा विकल्प के रूप में उपलब्ध 2. रिलीज़ 2.11.0 (दिसंबर 2025): डिफ़ॉल्ट रूप से सक्षम 3. भविष्य की रिलीज़: अंततः अनिवार्य\nयोजना की गई विशेषताएँ IPv6 सुधार - बेहतर IPv6 समर्थन और संक्रमण तंत्र प्रति tunnel throttling (गति सीमित करना) - प्रति tunnel सूक्ष्म-स्तरीय बैंडविड्थ नियंत्रण उन्नत मेट्रिक्स - बेहतर प्रदर्शन निगरानी और निदान प्रोटोकॉल अनुकूलन - कम ओवरहेड और बेहतर दक्षता बेहतर floodfill चयन - बेहतर नेटवर्क डेटाबेस वितरण अनुसंधान क्षेत्र Tunnel की लंबाई का अनुकूलन - खतरे के मॉडल के आधार पर गतिशील tunnel की लंबाई उन्नत पैडिंग - ट्रैफिक विश्लेषण प्रतिरोध में सुधार नई एन्क्रिप्शन योजनाएँ - क्वांटम कंप्यूटिंग खतरों के लिए तैयारी भीड़ नियंत्रण - नेटवर्क लोड के बेहतर प्रबंधन मोबाइल समर्थन - मोबाइल डिवाइसों और नेटवर्क के लिए अनुकूलन परिशिष्ट D: कार्यान्वयन दिशानिर्देश नए कार्यान्वयन के लिए न्यूनतम आवश्यकताएँ: 1. API संस्करण 0.9.51+ की विशेषताओं का समर्थन करें 2. ECIES-X25519-AEAD-Ratchet एन्क्रिप्शन को लागू करें 3. NTCP2 और SSU2 ट्रांसपोर्ट्स का समर्थन करें 4. ShortTunnelBuild संदेशों को लागू करें (218-बाइट रिकॉर्ड्स) 5. LeaseSet2 वैरिएंट्स का समर्थन करें (प्रकार 3, 5, 7) 6. EdDSA हस्ताक्षरों का उपयोग करें (Ed25519)\nअनुशंसित: 1. post-quantum hybrid cryptography (पोस्ट-क्वांटम खतरों-रोधी मिश्रित क्रिप्टोग्राफी) का समर्थन करें (संस्करण 2.11.0 से) 2. प्रति-tunnel बैंडविड्थ पैरामीटर लागू करें 3. Datagram2 और Datagram3 प्रारूप का समर्थन करें 4. LeaseSets में सेवा रिकॉर्ड विकल्प लागू करें 5. /docs/specs/ पर आधिकारिक विनिर्देशों का पालन करें\nआवश्यक नहीं: 1. ElGamal router का समर्थन (अप्रचलित) 2. पुराने ट्रांसपोर्ट का समर्थन (SSU1, NTCP) 3. लंबे ECIES BuildRequestRecords (शुद्ध ECIES tunnels के लिए 528 bytes) 4. TunnelBuild/TunnelBuildReply संदेश (Variable या Short वैरिएंट का उपयोग करें)\nपरीक्षण और सत्यापन प्रोटोकॉल अनुपालन: 1. आधिकारिक Java I2P router के साथ अंतरसंचालनीयता का परीक्षण करें 2. i2pd C++ router के साथ अंतरसंचालनीयता का परीक्षण करें 3. विनिर्देशों के अनुरूप संदेश प्रारूपों को सत्यापित करें 4. tunnel निर्माण/विघटन चक्रों का परीक्षण करें 5. परीक्षण वेक्टर के साथ एन्क्रिप्शन/डीक्रिप्शन सत्यापित करें\nप्रदर्शन परीक्षण: 1. tunnel निर्माण की सफलता दर मापें (\u0026gt;85% होना चाहिए) 2. विभिन्न tunnel लंबाइयों के साथ परीक्षण करें (2-8 हॉप्स) 3. खंडीकरण और पुनर्संयोजन को सत्यापित करें 4. लोड के तहत परीक्षण करें (एक साथ कई tunnels) 5. एंड-टू-एंड विलंबता मापें\nसुरक्षा परीक्षण: 1. एन्क्रिप्शन के कार्यान्वयन को सत्यापित करें (test vectors (मानक परीक्षण इनपुट-आउटपुट सेट) का उपयोग करें) 2. replay attack (पुराने संदेश को फिर से भेजकर किया गया हमला) की रोकथाम का परीक्षण करें 3. संदेश समाप्ति के प्रबंधन को सत्यापित करें 4. गलत स्वरूप वाले संदेशों के विरुद्ध परीक्षण करें 5. उचित यादृच्छिक संख्या जनन को सत्यापित करें\nकार्यान्वयन में आम गलतियाँ भ्रमित करने वाले डिलीवरी निर्देश फॉर्मेट - Garlic clove (\u0026lsquo;garlic\u0026rsquo; संदेश का \u0026lsquo;clove\u0026rsquo; घटक) बनाम tunnel message गलत कुंजी व्युत्पत्ति - शॉर्ट बिल्ड रिकॉर्ड्स के लिए HKDF (HMAC-आधारित कुंजी व्युत्पन्न फ़ंक्शन) का उपयोग Message ID हैंडलिंग - tunnel builds के लिए सही तरीके से सेट नहीं किया जा रहा है फ्रैग्मेंटेशन समस्याएँ - 61.2 KB की व्यावहारिक सीमा का पालन नहीं किया जा रहा Endianness (बाइट क्रम) त्रुटियाँ - Java सभी पूर्णांकों के लिए big-endian का उपयोग करता है समाप्ति हैंडलिंग - शॉर्ट फॉर्मेट 7 फरवरी, 2106 को रैप हो जाता है Checksum जनरेशन - सत्यापित न होने पर भी आवश्यक ","description":"I2P के भीतर router से router संदेश प्रारूप, प्राथमिकताएँ, और आकार सीमाएँ।","id":"917124900b0896942323b4effccf9b55","section":"docs","title":"I2P नेटवर्क प्रोटोकॉल (I2NP)","url":"/hi/docs/specs/i2np/"},{"categories":null,"content":"अवलोकन I2P पर BitTorrent, I2P की streaming layer का उपयोग करके encrypted tunnels के माध्यम से गुमनाम फ़ाइल साझाकरण सक्षम करता है। सभी peers को IP addresses के बजाय cryptographic I2P destinations द्वारा पहचाना जाता है। यह सिस्टम HTTP और UDP trackers, hybrid magnet links, और post-quantum hybrid encryption का समर्थन करता है।\n1. प्रोटोकॉल स्टैक Layer Function Example Application BitTorrent i2psnark, BiglyBT Transport Streaming / SAM v3 I2CP, NTCP2 Network Garlic routing I2NP सभी कनेक्शन I2P की एन्क्रिप्टेड ट्रांसपोर्ट लेयर (NTCP2 या SSU2) के माध्यम से चलते हैं। यहां तक कि UDP tracker पैकेट भी I2P streaming के भीतर encapsulate किए जाते हैं। 2. ट्रैकर्स HTTP ट्रैकर्स मानक .i2p ट्रैकर HTTP GET अनुरोधों का जवाब देते हैं जैसे:\nhttp://tracker2.postman.i2p/announce?info_hash=\u0026lt;20-byte\u0026gt;\u0026amp;peer_id=\u0026lt;20-byte\u0026gt;\u0026amp;port=6881\u0026amp;uploaded=0\u0026amp;downloaded=0\u0026amp;left=1234\u0026amp;compact=1 प्रतिक्रियाएं bencoded होती हैं और peers के लिए I2P destination hashes का उपयोग करती हैं।\nUDP ट्रैकर्स UDP ट्रैकर्स को 2025 में मानकीकृत किया गया था (प्रस्ताव 160)।\nप्राथमिक UDP ट्रैकर्स - udp://tracker2.postman.i2p/announce - udp://opentracker.simp.i2p/a - http://opentracker.skank.i2p/a - http://opentracker.dg2.i2p/a \u0026mdash;\n3. मैग्नेट लिंक magnet:?xt=urn:btih:\u0026lt;infohash\u0026gt;\u0026amp;dn=\u0026lt;name\u0026gt;\u0026amp;tr=http://tracker2.postman.i2p/announce\u0026amp;tr=udp://denpa.i2p/announce\u0026amp;xs=i2p:\u0026lt;destination.b32.i2p\u0026gt; Parameter Meaning xs=i2p:\u0026lt;dest\u0026gt; Explicit I2P destination tr= Tracker URLs (HTTP or UDP) dn= Display name Magnet links कॉन्फ़िगर किए जाने पर I2P और clearnet में hybrid swarms का समर्थन करते हैं। 4. DHT कार्यान्वयन Implementation Type Status Java I2P Experimental overlay Stable i2pd UDP-based internal overlay Active BiglyBT SAM v3.3-based Fully supported --- 5. क्लाइंट कार्यान्वयन I2PSnark सभी routers के साथ बंडल किया गया केवल HTTP tracker समर्थन http://127.0.0.1:7658/ पर अंतर्निहित tracker कोई UDP tracker समर्थन नहीं BiglyBT I2P plugin के साथ पूर्ण-सुविधा युक्त HTTP + UDP trackers का समर्थन करता है हाइब्रिड torrent समर्थन SAM v3.3 interface का उपयोग करता है Tixati / XD हल्के क्लाइंट SAM-आधारित tunneling प्रायोगिक ML-KEM हाइब्रिड एन्क्रिप्शन 6. कॉन्फ़िगरेशन I2PSnark i2psnark.dir=/home/user/torrents i2psnark.autostart=true i2psnark.maxUpBW=128 i2psnark.maxDownBW=256 i2psnark.enableDHT=false BiglyBT SAMHost=127.0.0.1 SAMPort=7656 SAMNickname=BiglyBT-I2P SAMAutoStart=true DHTEnabled=true 7. सुरक्षा मॉडल Component Description Encryption NTCP2 / SSU2 with X25519+ML-KEM hybrid Identity I2P destinations replace IP addresses Anonymity Peer info hidden; traffic multiplexed Leak Prevention Remove headers (X-Forwarded-For, Client-IP, Via) हाइब्रिड (क्लियरनेट + I2P) टॉरेंट का उपयोग केवल तभी किया जाना चाहिए जब गुमनामी महत्वपूर्ण न हो। 8. प्रदर्शन Factor Impact Recommendation Tunnel length Adds latency 1-hop client, 2-hop server Peers Boosts speed 20+ active peers Compression Minimal gain Usually off Bandwidth Router-limited Default settings optimal सामान्य गति **30–80 KB/s** की रेंज में होती है, जो peers और नेटवर्क स्थितियों पर निर्भर करती है। 9. ज्ञात समस्याएं Java I2P और i2pd के बीच आंशिक DHT अंतरसंचालनीयता भारी लोड के तहत Magnet मेटाडेटा प्राप्ति में देरी NTCP1 को पदावनत किया गया लेकिन पुराने peers द्वारा अभी भी उपयोग में streaming के माध्यम से अनुकरणित UDP विलंबता बढ़ाता है 10. भविष्य की योजना QUIC-जैसी मल्टीप्लेक्सिंग पूर्ण ML-KEM एकीकरण एकीकृत हाइब्रिड स्वार्म लॉजिक बेहतर reseed मिरर्स अनुकूली DHT पुनः प्रयास संदर्भ BEP 15 – UDP Tracker Protocol Proposal 160 – UDP Tracker over I2P I2PSnark डॉक्स Streaming Library स्पेसिफिकेशन ","description":"I2P नेटवर्क के भीतर BitTorrent के लिए विस्तृत विनिर्देश और पारिस्थितिकी तंत्र का अवलोकन","id":"5d0ca50c8763996448d3099a14dc36b0","section":"docs","title":"I2P पर BitTorrent","url":"/hi/docs/applications/bittorrent/"},{"categories":null,"content":"I2P के अंदर repositories को clone और push करने के लिए वही Git commands का उपयोग होता है जिन्हें आप पहले से जानते हैं—आपका client बस TCP/IP के बजाय I2P tunnels के माध्यम से connect करता है। यह गाइड एक account सेट करने, tunnels को configure करने, और धीमे links से निपटने की प्रक्रिया को समझाती है।\nत्वरित शुरुआत: केवल-पढ़ने की पहुंच HTTP proxy के माध्यम से काम करती है: http_proxy=http://127.0.0.1:4444 git clone http://example.i2p/project.git। SSH read/write पहुंच के लिए नीचे दिए गए चरणों का पालन करें।\n1. एक खाता बनाएं एक I2P Git सेवा चुनें और पंजीकरण करें:\nI2P के अंदर: http://git.idk.i2p Clearnet मिरर: https://i2pgit.org पंजीकरण के लिए मैन्युअल अनुमोदन की आवश्यकता हो सकती है; निर्देशों के लिए लैंडिंग पेज देखें। एक बार अनुमोदित होने के बाद, एक repository को fork करें या बनाएं ताकि आपके पास परीक्षण करने के लिए कुछ हो।\n2. एक I2PTunnel क्लाइंट (SSH) को कॉन्फ़िगर करें router console → I2PTunnel खोलें और एक नया Client tunnel जोड़ें। सेवा का destination (Base32 या Base64) दर्ज करें। git.idk.i2p के लिए आपको प्रोजेक्ट होम पेज पर HTTP और SSH दोनों destinations मिलेंगे। एक local port चुनें (उदाहरण के लिए localhost:7442)। यदि आप tunnel का बार-बार उपयोग करने की योजना बना रहे हैं तो autostart सक्षम करें। UI नई tunnel की पुष्टि करेगा और इसकी स्थिति दिखाएगा। जब यह चल रहा हो, तो SSH क्लाइंट चुने गए पोर्ट पर 127.0.0.1 से कनेक्ट हो सकते हैं।\n3. SSH के माध्यम से Clone करें GIT_SSH_COMMAND या SSH config stanza के साथ tunnel port का उपयोग करें:\nGIT_SSH_COMMAND=\u0026#34;ssh -p 7442\u0026#34; \\ git clone git@127.0.0.1:your-project/example.git यदि पहला प्रयास विफल हो जाता है (tunnels धीमी हो सकती हैं), तो shallow clone का प्रयास करें:\nGIT_SSH_COMMAND=\u0026#34;ssh -p 7442\u0026#34; \\ git clone --depth 1 git@127.0.0.1:your-project/example.git cd example git fetch --unshallow सभी ब्रांचेस को fetch करने के लिए Git को कॉन्फ़िगर करें:\ngit config remote.origin.fetch \u0026#34;+refs/heads/*:refs/remotes/origin/*\u0026#34; git fetch origin प्रदर्शन सुझाव लचीलापन बढ़ाने के लिए tunnel editor में एक या दो बैकअप tunnels जोड़ें। परीक्षण या कम जोखिम वाले repos के लिए आप tunnel की लंबाई को 1 hop तक कम कर सकते हैं, लेकिन गुमनामी के व्यापार-बंद से सावधान रहें। GIT_SSH_COMMAND को अपने environment में रखें या ~/.ssh/config में एक entry जोड़ें: Host git.i2p HostName 127.0.0.1 Port 7442 User git फिर git clone git@git.i2p:namespace/project.git का उपयोग करके clone करें।\n4. वर्कफ़्लो सुझाव GitLab/GitHub पर सामान्य fork-and-branch workflow अपनाएं:\nएक upstream remote सेट करें: git remote add upstream git@git.i2p:I2P_Developers/i2p.i2p अपनी master को सिंक में रखें: git pull upstream master परिवर्तनों के लिए feature branches बनाएं: git checkout -b feature/new-thing branches को अपने fork में push करें: git push origin feature/new-thing एक merge request सबमिट करें, फिर अपने fork की master को upstream से fast-forward करें। 5. गोपनीयता अनुस्मारक Git आपके स्थानीय समयक्षेत्र में commit timestamps को संग्रहीत करता है। UTC timestamps को मजबूर करने के लिए: git config --global alias.utccommit \u0026#39;!git commit --date=\u0026#34;$(date --utc +%Y-%m-%dT%H:%M:%S%z)\u0026#34;\u0026#39; जब गोपनीयता महत्वपूर्ण हो तो git commit के बजाय git utccommit का उपयोग करें।\nयदि गुमनामी एक चिंता का विषय है तो commit संदेशों या repository मेटाडेटा में clearnet URLs या IPs एम्बेड करने से बचें। 6. समस्या निवारण Symptom Fix connection closed during clone Retry with --depth 1, add backup tunnels, or increase tunnel quantities. ssh: connect to host 127.0.0.1 port …: Connection refused Ensure the I2PTunnel client is running and SAM is enabled. Slow performance Lower tunnel length, increase bandwidth limits, or schedule large fetches during off-peak hours. उन्नत परिदृश्यों के लिए (बाहरी repos को mirror करना, bundles को seed करना), साथी गाइड देखें: [Git bundle workflows](/docs/applications/git-bundle/) और [Hosting GitLab over I2P](/docs/guides/gitlab/)। ","description":"I2P-होस्टेड सेवाओं जैसे i2pgit.org से Git क्लाइंट्स को कनेक्ट करना","id":"17704a86e8676ba273355af4fa703c15","section":"docs","title":"I2P पर Git","url":"/hi/docs/applications/git/"},{"categories":null,"content":"I2P के अंदर GitLab होस्ट करना सीधा है: GitLab omnibus container चलाएं, इसे loopback पर expose करें, और I2P tunnel के माध्यम से ट्रैफ़िक forward करें। नीचे दिए गए चरण git.idk.i2p के लिए उपयोग किए गए configuration को दर्शाते हैं लेकिन किसी भी self-hosted instance के लिए काम करते हैं।\n1. पूर्वापेक्षाएँ Debian या कोई अन्य Linux distribution जिसमें Docker Engine installed हो (sudo apt install docker.io या Docker के repo से docker-ce)। एक I2P router (Java I2P या i2pd) जिसमें आपके users को serve करने के लिए पर्याप्त bandwidth हो। Optional: एक dedicated VM ताकि GitLab और router आपके desktop environment से isolated रहें। 2. GitLab Image को Pull करें docker pull gitlab/gitlab-ce:latest आधिकारिक image Ubuntu बेस लेयर्स से बनाई गई है और नियमित रूप से अपडेट की जाती है। यदि आपको अतिरिक्त आश्वासन की आवश्यकता है तो Dockerfile का ऑडिट करें।\n3. ब्रिजिंग बनाम I2P-Only के बीच निर्णय लें I2P-only इंस्टेंस कभी भी clearnet होस्ट से संपर्क नहीं करते हैं। उपयोगकर्ता अन्य I2P सेवाओं से रिपॉजिटरी को mirror कर सकते हैं लेकिन GitHub/GitLab.com से नहीं। यह गुमनामी को अधिकतम करता है। Bridged इंस्टेंस एक HTTP proxy के माध्यम से clearnet Git होस्ट तक पहुंचते हैं। यह सार्वजनिक प्रोजेक्ट को I2P में mirror करने के लिए उपयोगी है लेकिन यह सर्वर के outbound अनुरोधों को deanonymise कर देता है। यदि आप bridged mode चुनते हैं, तो GitLab को Docker host पर bound एक I2P HTTP proxy का उपयोग करने के लिए configure करें (उदाहरण के लिए http://172.17.0.1:4446)। default router proxy केवल 127.0.0.1 पर listen करता है; Docker gateway address पर bound एक नई proxy tunnel जोड़ें।\n4. कंटेनर प्रारंभ करें docker run --detach \\ --env HTTP_PROXY=http://172.17.0.1:4446 \\ # omit for I2P-only --publish 127.0.0.1:8443:443 \\ --publish 127.0.0.1:8080:80 \\ --publish 127.0.0.1:8022:22 \\ --name gitlab \\ --restart always \\ --volume /srv/gitlab/config:/etc/gitlab:Z \\ --volume /srv/gitlab/logs:/var/log/gitlab:Z \\ --volume /srv/gitlab/data:/var/opt/gitlab:Z \\ gitlab/gitlab-ce:latest प्रकाशित पोर्ट को loopback से bind करें; I2P tunnels उन्हें आवश्यकतानुसार expose करेंगे। /srv/gitlab/... को अपने host के लिए उपयुक्त storage paths से बदलें। कंटेनर चालू होने के बाद, https://127.0.0.1:8443/ पर जाएं, एक admin पासवर्ड सेट करें, और अकाउंट लिमिट कॉन्फ़िगर करें।\n5. I2P के माध्यम से GitLab को उजागर करें तीन I2PTunnel server tunnels बनाएं:\nPurpose Local target Suggested inbound port HTTPS web UI 127.0.0.1:8443 auto-generated HTTP web UI (optional) 127.0.0.1:8080 auto-generated SSH push/pull 127.0.0.1:8022 auto-generated प्रत्येक tunnel को उपयुक्त tunnel लंबाई और bandwidth के साथ कॉन्फ़िगर करें। सार्वजनिक instances के लिए, 3 hops के साथ प्रति दिशा 4–6 tunnels एक अच्छा प्रारंभिक बिंदु है। परिणामी Base32/Base64 destinations को अपने landing page पर प्रकाशित करें ताकि उपयोगकर्ता client tunnels को कॉन्फ़िगर कर सकें। Destination Enforcement यदि आप HTTP(S) tunnels का उपयोग करते हैं, तो destination enforcement सक्षम करें ताकि केवल निर्दिष्ट hostname ही सेवा तक पहुंच सके। यह tunnel को एक सामान्य proxy के रूप में दुरुपयोग होने से रोकता है।\n6. Maintenance Tips जब भी आप GitLab सेटिंग्स बदलें तो docker exec gitlab gitlab-ctl reconfigure चलाएं। डिस्क उपयोग (/srv/gitlab/data) की निगरानी करें—Git रिपॉजिटरी तेज़ी से बढ़ती हैं। कॉन्फ़िगरेशन और डेटा डायरेक्टरी का नियमित रूप से बैकअप लें। GitLab के backup rake tasks कंटेनर के अंदर काम करते हैं। व्यापक नेटवर्क से सेवा की पहुंच सुनिश्चित करने के लिए client mode में एक बाहरी monitoring tunnel रखने पर विचार करें। 6. रखरखाव सुझाव अपने एप्लिकेशन में I2P एम्बेड करना I2P पर Git (क्लाइंट गाइड) ऑफ़लाइन/धीमे नेटवर्क के लिए Git bundles एक अच्छी तरह से कॉन्फ़िगर किया गया GitLab instance I2P के भीतर पूरी तरह से एक सहयोगात्मक विकास केंद्र प्रदान करता है। router को स्वस्थ रखें, GitLab सुरक्षा अपडेट के साथ अद्यतित रहें, और जैसे-जैसे आपका उपयोगकर्ता आधार बढ़ता है, समुदाय के साथ समन्वय करें।\n","description":"I2P के अंदर Docker और I2P router का उपयोग करके GitLab को deploy करना","id":"0c6aba5984de265324df6360a00204c9","section":"docs","title":"I2P पर GitLab चलाना","url":"/hi/docs/guides/gitlab/"},{"categories":null,"content":"अवलोकन मुख्य बिंदु\nI2P अपनी टनलों के माध्यम से IRC ट्रैफ़िक के लिए end-to-end encryption प्रदान करता है। IRC क्लाइंट में SSL/TLS को निष्क्रिय करें जब तक कि आप clearnet पर outproxy नहीं कर रहे हों। पूर्व-कॉन्फ़िगर किया गया Irc2P क्लाइंट tunnel डिफ़ॉल्ट रूप से 127.0.0.1:6668 पर सुनता है। अपने IRC क्लाइंट को उस एड्रेस और पोर्ट से कनेक्ट करें। \u0026ldquo;router‑provided TLS\u0026rdquo; शब्द का उपयोग न करें। \u0026ldquo;I2P\u0026rsquo;s native encryption\u0026rdquo; या \u0026ldquo;end‑to‑end encryption\u0026rdquo; का उपयोग करें। त्वरित प्रारंभ (Java I2P) Hidden Services Manager को http://127.0.0.1:7657/i2ptunnel/ पर खोलें और सुनिश्चित करें कि Irc2P tunnel चल रहा है। अपने IRC क्लाइंट में, server = 127.0.0.1, port = 6668, SSL/TLS = off सेट करें। कनेक्ट करें और #i2p, #i2p-dev, #i2p-help जैसे चैनल्स में शामिल हों। i2pd उपयोगकर्ताओं (C++ राउटर) के लिए, tunnels.conf में एक क्लाइंट tunnel बनाएं (नीचे दिए गए उदाहरण देखें)।\nनेटवर्क और सर्वर IRC2P (main community network) Federated सर्वर: irc.postman.i2p:6667, irc.echelon.i2p:6667, irc.dg.i2p:6667। Irc2P tunnel 127.0.0.1:6668 पर इनमें से किसी एक से स्वचालित रूप से कनेक्ट होता है। सामान्य चैनल: #i2p, #i2p-chat, #i2p-dev, #i2p-help। Ilita network सर्वर: irc.ilita.i2p:6667, irc.r4sas.i2p:6667, irc.acetone.i2p:6667, rusirc.ilita.i2p:6667। प्राथमिक भाषाएं: रूसी और अंग्रेज़ी। कुछ होस्ट्स पर वेब फ्रंट-एंड उपलब्ध हैं। Client setup Recommended, actively maintained WeeChat (टर्मिनल) — मजबूत SOCKS समर्थन; स्क्रिप्ट करना आसान। Pidgin (डेस्कटॉप) — अभी भी रखरखाव में; Windows/Linux के लिए अच्छी तरह से काम करता है। Thunderbird Chat (डेस्कटॉप) — ESR 128+ में समर्थित। The Lounge (सेल्फ-होस्टेड वेब) — आधुनिक वेब क्लाइंट। IRC2P (मुख्य समुदाय नेटवर्क) LimeChat (मुफ्त, ओपन सोर्स)। Textual (App Store पर सशुल्क; बिल्ड करने के लिए सोर्स उपलब्ध)। Ilita नेटवर्क WeeChat via SOCKS5 /proxy add i2p socks5 127.0.0.1 4447 /set irc.server.i2p.addresses \u0026#34;127.0.0.1/6668\u0026#34; /set irc.server.i2p.proxy \u0026#34;i2p\u0026#34; /connect i2p Pidgin प्रोटोकॉल: IRC सर्वर: 127.0.0.1 पोर्ट: 6668 एन्क्रिप्शन: off यूज़रनेम/निक: कोई भी Thunderbird Chat खाता प्रकार: IRC सर्वर: 127.0.0.1 पोर्ट: 6668 SSL/TLS: बंद वैकल्पिक: कनेक्ट होने पर चैनल्स में स्वतः शामिल हों Dispatch (SAM v3) config.toml डिफ़ॉल्ट उदाहरण:\n[defaults] name = \u0026#34;Irc2P\u0026#34; host = \u0026#34;irc.postman.i2p\u0026#34; port = 6667 channels = [\u0026#34;#i2p\u0026#34;,\u0026#34;#i2p-dev\u0026#34;] ssl = false Tunnel configuration Java I2P defaults Irc2P क्लाइंट टनल: 127.0.0.1:6668 → अपस्ट्रीम सर्वर port 6667 पर। Hidden Services Manager: http://127.0.0.1:7657/i2ptunnel/। अनुशंसित, सक्रिय रूप से रखरखाव किया गया ~/.i2pd/tunnels.conf:\n[IRC-IRC2P] type = client address = 127.0.0.1 port = 6668 destination = irc.postman.i2p destinationport = 6667 keys = irc-keys.dat Ilita के लिए अलग tunnel (उदाहरण):\n[IRC-ILITA] type = client address = 127.0.0.1 port = 6669 destination = irc.ilita.i2p destinationport = 6667 keys = irc-ilita-keys.dat macOS विकल्प SAM सक्षम करें Java I2P में (डिफ़ॉल्ट रूप से बंद) /configclients या clients.config पर। डिफ़ॉल्ट: 127.0.0.1:7656/TCP और 127.0.0.1:7655/UDP। अनुशंसित क्रिप्टो: SIGNATURE_TYPE=7 (Ed25519) और i2cp.leaseSetEncType=4,0 (ECIES‑X25519 with ElGamal fallback) या केवल 4 आधुनिक-मात्र के लिए। उदाहरण विन्यास Java I2P डिफ़ॉल्ट: 2 inbound / 2 outbound। i2pd डिफ़ॉल्ट: 5 inbound / 5 outbound। IRC के लिए: 2–3 प्रत्येक पर्याप्त है; routers में सुसंगत व्यवहार के लिए स्पष्ट रूप से सेट करें। क्लाइंट सेटअप आंतरिक I2P IRC कनेक्शन के लिए SSL/TLS सक्षम न करें। I2P पहले से ही end‑to‑end एन्क्रिप्शन प्रदान करता है। अतिरिक्त TLS ओवरहेड जोड़ता है बिना गुमनामी लाभ के। स्थिर पहचान के लिए persistent keys का उपयोग करें; परीक्षण के अलावा हर रीस्टार्ट पर keys को पुनः उत्पन्न करने से बचें। यदि कई ऐप्स IRC का उपयोग करते हैं, तो क्रॉस-सर्विस सहसंबंध को कम करने के लिए अलग tunnels (गैर-साझा) को प्राथमिकता दें। यदि आपको रिमोट कंट्रोल (SAM/I2CP) की अनुमति देनी आवश्यक है, तो localhost पर bind करें और SSH tunnels या प्रमाणित reverse proxies के साथ एक्सेस को सुरक्षित करें। Alternative connection method: SOCKS5 कुछ क्लाइंट I2P के SOCKS5 proxy के माध्यम से कनेक्ट हो सकते हैं: 127.0.0.1:4447। सर्वोत्तम परिणामों के लिए, 6668 पर एक समर्पित IRC क्लाइंट tunnel को प्राथमिकता दें; SOCKS एप्लिकेशन‑लेयर आइडेंटिफायर्स को sanitize नहीं कर सकता और यदि क्लाइंट anonymity के लिए डिज़ाइन नहीं किया गया है तो जानकारी लीक हो सकती है।\nTroubleshooting कनेक्ट नहीं हो पा रहा — सुनिश्चित करें कि Irc2P tunnel चल रहा है और router पूरी तरह से bootstrapped है। Resolve/join पर रुक जाता है — दोबारा जांचें कि SSL disabled है और client 127.0.0.1:6668 की ओर point कर रहा है। High latency — I2P डिज़ाइन से ही higher-latency है। Tunnel quantities को मध्यम (2–3) रखें और rapid reconnect loops से बचें। SAM apps का उपयोग करते समय — पुष्टि करें कि SAM enabled है (Java) या firewalled नहीं है (i2pd)। Long‑lived sessions की सिफारिश की जाती है। Appendix: Ports and naming सामान्य IRC टनल पोर्ट: 6668 (Irc2P डिफ़ॉल्ट), 6667 और 6669 वैकल्पिक के रूप में। .b32.i2p होस्टनेम: 52-अक्षर का मानक रूप; LS2/उन्नत सर्टिफिकेट के लिए विस्तारित 56+ अक्षर के रूप मौजूद हैं। .i2p होस्टनेम का उपयोग करें जब तक कि आपको स्पष्ट रूप से b32 एड्रेस की आवश्यकता न हो। ","description":"I2P IRC नेटवर्क, क्लाइंट, टनल, और सर्वर सेटअप के लिए संपूर्ण गाइड (2025 में अपडेट किया गया)","id":"f8c49a6509b36124b90dbaa1d0fbbc4b","section":"docs","title":"I2P पर IRC","url":"/hi/docs/applications/irc/"},{"categories":null,"content":"उद्देश्य: I2P तकनीकी प्रलेखन में निरंतरता, सटीकता, और सुलभता बनाए रखना\nमूलभूत सिद्धांत 1. सब कुछ सत्यापित करें कभी मानकर न चलें या अनुमान न लगाएँ। सभी तकनीकी कथनों को निम्न के विरुद्ध सत्यापित किया जाना चाहिए: - वर्तमान I2P स्रोत कोड (https://i2pgit.org/I2P_Developers/i2p.i2p/src/branch/master ) - आधिकारिक API दस्तावेज़ीकरण (https://i2p.github.io/i2p.i2p/ - कॉन्फ़िगरेशन विनिर्देश /docs/specs/ - हालिया रिलीज़ नोट्स /releases/ उचित सत्यापन का उदाहरण:\n❌ BAD: \u0026#34;The ClientApp interface probably requires three constructor parameters.\u0026#34; ✅ GOOD: \u0026#34;The ClientApp interface requires this constructor signature: public MyClientApp(I2PAppContext context, ClientAppManager manager, String[] args)\u0026#34; 2. संक्षिप्तता पर स्पष्टता ऐसे डेवलपर्स के लिए लिखें जो पहली बार I2P से परिचित हो रहे हों। पूर्व-ज्ञान मानने के बजाय अवधारणाओं को पूरी तरह समझाएँ।\nउदाहरण:\n❌ BAD: \u0026#34;Use the port mapper for service discovery.\u0026#34; ✅ GOOD: \u0026#34;The port mapper offers a simple directory for internal TCP services. Register loopback ports so other applications can discover your service without hardcoded addresses.\u0026#34; 3. सुलभता पहले भले ही I2P एक network overlay (मौजूदा नेटवर्क के ऊपर काम करने वाली परत) है, दस्तावेज़ीकरण clearnet (सामान्य इंटरनेट) पर डेवलपर्स के लिए सुलभ होना चाहिए। I2P-आंतरिक संसाधनों के लिए हमेशा clearnet पर सुलभ वैकल्पिक साधन प्रदान करें।\nतकनीकी सटीकता API और इंटरफ़ेस प्रलेखन हमेशा शामिल करें: 1. पहली बार उल्लेख पर पूर्ण पैकेज नाम: net.i2p.app.ClientApp 2. रिटर्न टाइप सहित पूर्ण मेथड सिग्नेचर 3. पैरामीटर के नाम और प्रकार 4. आवश्यक बनाम वैकल्पिक पैरामीटर\nउदाहरण:\nThe `startup()` method has signature `void startup() throws IOException` and must execute without blocking. The method must call `ClientAppManager.notify()` at least once to transition from INITIALIZED state. विन्यास गुणधर्म कॉन्फ़िगरेशन फ़ाइलों का दस्तावेज़ीकरण करते समय: 1. सटीक प्रॉपर्टी नाम दिखाएँ 2. फ़ाइल एन्कोडिंग निर्दिष्ट करें (I2P कॉन्फ़िग फ़ाइलों के लिए UTF-8) 3. पूर्ण उदाहरण प्रदान करें 4. डिफ़ॉल्ट मानों का दस्तावेज़ करें 5. वह संस्करण उल्लेख करें जब प्रॉपर्टीज़ जोड़ी/बदली गईं\nउदाहरण:\n### clients.config Properties **Required:** - `clientApp.N.main` - Full class name (no default) **Optional:** - `clientApp.N.delay` - Seconds before starting (default: 120) - `clientApp.N.onBoot` - Forces delay=0 if true (default: false, added in 0.9.4) स्थिरांक और Enumerations (एनम प्रकार) कॉन्स्टेंट्स का दस्तावेज़ीकरण करते समय, वास्तविक कोड नामों का उपयोग करें:\n❌ BAD: \u0026#34;Common registrations include console, i2ptunnel, Jetty, sam, and bob\u0026#34; ✅ GOOD: \u0026#34;Common port mapper service constants from `net.i2p.util.PortMapper`: - `SVC_CONSOLE` - Router console (default port 7657) - `SVC_HTTP_PROXY` - HTTP proxy (default port 4444) - `SVC_SAM` - SAM bridge (default port 7656)\u0026#34; समान अवधारणाओं के बीच अंतर करें I2P में कई परस्पर-अतिव्यापी प्रणालियाँ हैं। आप किस प्रणाली का दस्तावेज़ बना रहे हैं, इसे हमेशा स्पष्ट करें:\nउदाहरण:\nNote that client registry and port mapper are separate systems: - **ClientAppManager registry** enables inter-application communication by name lookup - **PortMapper** maps service names to host:port combinations for service discovery - **i2ptunnel tunnel types** are configuration values (tunnel.N.type), not service registrations प्रलेखन URLs और संदर्भ URL अभिगम्यता नियम प्राथमिक संदर्भ को clearnet (सार्वजनिक इंटरनेट) पर सुलभ URLs का उपयोग करना चाहिए I2P-आंतरिक URLs (.i2p डोमेन्स) में पहुँच-संबंधी नोट्स शामिल होने चाहिए हमेशा विकल्प प्रदान करें जब I2P-आंतरिक संसाधनों से लिंक करें I2P-आंतरिक URLs के लिए टेम्पलेट:\n\u0026gt; **Note:** The I2P network hosts comprehensive documentation at http://idk.i2p/javadoc-i2p/ \u0026gt; which requires an I2P router for access. For clearnet access, use the GitHub Pages \u0026gt; mirror at https://eyedeekay.github.io/javadoc-i2p/ अनुशंसित I2P संदर्भ URLs आधिकारिक विनिर्देश: - विन्यास - प्लगइन - दस्तावेज़ सूचकांक API प्रलेखन (सबसे नवीनतम चुनें): - सबसे नवीनतम: https://i2p.github.io/i2p.i2p/ (API 0.9.66, I2P 2.10.0 तक) - Clearnet मिरर: https://eyedeekay.github.io/javadoc-i2p/ स्रोत कोड: - GitLab (आधिकारिक): https://i2pgit.org/I2P_Developers/i2p.i2p/src/branch/master - GitHub mirror (प्रतिलिपि): https://github.com/i2p/i2p.i2p लिंक फ़ॉर्मेट मानक ✅ GOOD: [ClientApp Javadoc](https://i2p.github.io/i2p.i2p/net/i2p/app/ClientApp.html) ✅ GOOD: [Configuration Specification](https://geti2p.net/spec/configuration) ❌ BAD: See the ClientApp docs at http://idk.i2p/... ❌ BAD: [link](url) with no descriptive text संस्करण ट्रैकिंग दस्तावेज़ मेटाडेटा प्रत्येक तकनीकी दस्तावेज़ में फ्रंटमैटर (दस्तावेज़ के आरंभ का मेटाडेटा खंड) में संस्करण मेटाडेटा शामिल होना चाहिए:\n--- title: \u0026#34;Document Title\u0026#34; description: \u0026#34;Brief description\u0026#34; slug: \u0026#34;url-slug\u0026#34; lastUpdated: \u0026#34;2025-10\u0026#34; accurateFor: \u0026#34;2.10.0\u0026#34; reviewStatus: \u0026#34;verified\u0026#34; --- फ़ील्ड परिभाषाएँ: - lastUpdated: वर्ष-माह जब दस्तावेज़ की अंतिम बार समीक्षा/अद्यतन किया गया - accurateFor: वह I2P संस्करण जिसके विरुद्ध इस दस्तावेज़ का सत्यापन किया गया था - reviewStatus: इनमें से एक: \u0026ldquo;draft\u0026rdquo;, \u0026ldquo;needs-review\u0026rdquo;, \u0026ldquo;verified\u0026rdquo;, \u0026ldquo;outdated\u0026rdquo;\nसामग्री में संस्करण संदर्भ संस्करणों का उल्लेख करते समय: 1. वर्तमान संस्करण के लिए गाढ़ा का उपयोग करें: \u0026ldquo;संस्करण 2.10.0 (सितंबर 2025)\u0026rdquo; 2. ऐतिहासिक संदर्भों के लिए संस्करण संख्या और तारीख दोनों निर्दिष्ट करें 3. जहाँ प्रासंगिक हो, API (एप्लिकेशन प्रोग्रामिंग इंटरफ़ेस) संस्करण को I2P संस्करण से अलग उल्लेख करें\nउदाहरण:\nManaged clients were introduced in **version 0.9.4** (December 17, 2012) and remain the recommended architecture as of **version 2.10.0** (September 9, 2025). The current API version is **0.9.66**. समय के साथ बदलावों का दस्तावेज़ीकरण विकसित हुई विशेषताओं के लिए:\n**Version history:** - **0.9.4 (December 2012)** - Managed clients introduced - **0.9.42 (2019)** - clients.config.d/ directory structure added - **1.7.0 (2021)** - ShellService added for external program tracking - **2.10.0 (September 2025)** - Current release, no API changes to managed clients अप्रचलन सूचनाएँ यदि अप्रचलित विशेषताओं का प्रलेखन कर रहे हैं:\n\u0026gt; **Deprecated:** This feature was deprecated in version X.Y.Z and will be removed \u0026gt; in version A.B.C. Use [alternative feature](link) instead. शब्दावली मानक आधिकारिक I2P शब्दावली इन सटीक शब्दों का एकसमान रूप से उपयोग करें:\nCorrect Term Avoid I2P router I2P node, I2P client (ambiguous) eepsite I2P website, hidden service (Tor term) tunnel connection, circuit (Tor term) netDb network database, DHT lease set destination info destination address, endpoint base64 destination I2P address, .i2p address ### प्रबंधित क्लाइंट शब्दावली प्रबंधित क्लाइंट्स का दस्तावेज़ीकरण करते समय:\nUse This Not This managed client managed application unmanaged client legacy client, static client ClientAppManager application manager, client manager lifecycle methods state methods, control methods client registry application registry, name service port mapper port registry, service directory ### कॉन्फ़िगरेशन शब्दावली Correct Incorrect clients.config clients.cfg, client.config clients.config.d/ clients.d/, config.d/ router.config router.cfg i2ptunnel.config tunnel.config ### पैकेज और क्लास के नाम पहली बार उल्लेख करते समय हमेशा पूर्ण रूप से योग्य नामों का उपयोग करें, उसके बाद छोटे नाम:\nThe `net.i2p.app.ClientApp` interface requires implementation of three lifecycle methods. When a ClientApp starts, the manager calls `startup()`... कोड उदाहरण और स्वरूपण Java कोड के उदाहरण उचित सिंटैक्स हाइलाइटिंग और पूर्ण उदाहरणों का उपयोग करें:\n### Example: Registering with Port Mapper \\`\\`\\`java // Register HTTP proxy service context.portMapper().register( PortMapper.SVC_HTTP_PROXY, \u0026#34;127.0.0.1\u0026#34;, 4444 ); // Later, retrieve the port int port = context.portMapper().getPort(PortMapper.SVC_HTTP_PROXY); if (port == -1) { // Service not registered } \\`\\`\\` कोड उदाहरण आवश्यकताएँ: 1. महत्वपूर्ण पंक्तियों को समझाने वाली टिप्पणियाँ शामिल करें 2. जहाँ उपयुक्त हो वहाँ त्रुटि हैंडलिंग दिखाएँ 3. यथार्थपरक चर नामों का उपयोग करें 4. I2P कोडिंग परंपराओं से मेल खाएँ (4-space इंडेंट) 5. यदि संदर्भ से स्पष्ट न हो तो imports दिखाएँ\nकॉन्फ़िगरेशन उदाहरण पूर्ण और मान्य कॉन्फ़िगरेशन के उदाहरण दिखाएँ:\n### Example: clients.config.d/ Entry File: `clients.config.d/00-console.config` \\`\\`\\`properties # Router console configuration clientApp.0.main=net.i2p.router.web.RouterConsoleRunner clientApp.0.name=Router Console clientApp.0.args=7657 ::1,127.0.0.1 ./webapps/ clientApp.0.delay=0 clientApp.0.onBoot=true \\`\\`\\` कमांड लाइन के उदाहरण उपयोगकर्ता कमांड के लिए $ का उपयोग करें, root के लिए #:\n\\`\\`\\`bash # Install I2P on Debian/Ubuntu $ sudo apt-get install i2p # Start the router $ i2prouter start \\`\\`\\` इनलाइन कोड इनके लिए बैकटिक्स का उपयोग करें: - मेथड नाम: startup() - क्लास नाम: ClientApp - प्रॉपर्टी नाम: clientApp.0.main - फ़ाइल नाम: clients.config - कॉन्स्टेंट्स: SVC_HTTP_PROXY - पैकेज नाम: net.i2p.app\nलहजा और स्वर पेशेवर लेकिन सुलभ तकनीकी पाठकों के लिए बिना उपेक्षापूर्ण लहजा अपनाए लिखें:\n❌ BAD: \u0026#34;Obviously, you should implement the startup() method.\u0026#34; ✅ GOOD: \u0026#34;Managed clients must implement the startup() method to initialize resources.\u0026#34; ❌ BAD: \u0026#34;Even a junior dev knows you need to call notify().\u0026#34; ✅ GOOD: \u0026#34;The manager requires at least one notify() call during startup to track state transitions.\u0026#34; कर्तृवाच्य स्पष्टता के लिए सक्रिय वाच्य का उपयोग करें:\n❌ PASSIVE: \u0026#34;The ClientAppManager is notified by the client when state changes.\u0026#34; ✅ ACTIVE: \u0026#34;The client notifies ClientAppManager when state changes.\u0026#34; निर्देशों के लिए अनिवार्यताएँ प्रक्रियात्मक सामग्री में प्रत्यक्ष आज्ञार्थक वाक्यों का उपयोग करें:\n✅ \u0026#34;Implement these three lifecycle methods:\u0026#34; ✅ \u0026#34;Call manager.notify() after changing state.\u0026#34; ✅ \u0026#34;Register services using context.portMapper().register()\u0026#34; अनावश्यक जटिल शब्दावली से बचें पहली बार उपयोग होने पर शब्दों की व्याख्या करें:\n✅ GOOD: \u0026#34;The netDb (network database) stores information about I2P routers and destinations.\u0026#34; ❌ BAD: \u0026#34;Query the netDb for peer info.\u0026#34; (no explanation) विराम चिह्न दिशानिर्देश दस्तावेज़ संरचना मानक अनुभाग क्रम API प्रलेखन के लिए:\nअवलोकन - यह फ़ीचर क्या करता है, यह क्यों मौजूद है कार्यान्वयन - इसे कैसे कार्यान्वित/उपयोग करें विन्यास - इसे कैसे विन्यस्त करें API संदर्भ - विधियों/गुणों के विस्तृत विवरण उदाहरण - पूर्णतः कार्यशील उदाहरण श्रेष्ठ प्रथाएँ - युक्तियाँ और अनुशंसाएँ संस्करण इतिहास - कब प्रस्तुत किया गया, समय के साथ हुए परिवर्तन संदर्भ - संबंधित दस्तावेज़ों के लिंक शीर्षक पदानुक्रम सार्थक हेडिंग स्तरों का उपयोग करें:\n# Document Title (h1 - only one per document) ## Major Section (h2) ### Subsection (h3) #### Detail Section (h4) **Bold text for emphasis within sections** सूचना बॉक्स विशेष सूचनाओं के लिए blockquotes (उद्धरण-ब्लॉक) का उपयोग करें:\n\u0026gt; **Note:** Additional information that clarifies the main content. \u0026gt; **Warning:** Important information about potential issues or breaking changes. \u0026gt; **Deprecated:** This feature is deprecated and will be removed in version X.Y.Z. \u0026gt; **Status:** Current implementation status or version information. सूचियाँ और संगठन अनुक्रम-रहित सूचियाँ गैर-अनुक्रमिक मदों के लिए:\n- First item - Second item - Third item क्रमांकित सूचियाँ क्रमिक चरणों के लिए:\n1. First step 2. Second step 3. Third step परिभाषा सूचियाँ शब्दों की व्याख्या के लिए:\n**Term One** : Explanation of term one **Term Two** : Explanation of term two बचने योग्य सामान्य गलतियाँ 1. समान प्रणालियों को लेकर भ्रम इनमें भ्रम न करें: - ClientAppManager रजिस्ट्री बनाम PortMapper - i2ptunnel tunnel प्रकार बनाम port mapper service constants - ClientApp बनाम RouterApp (अलग संदर्भ) - प्रबंधित बनाम अप्रबंधित क्लाइंट्स\nहमेशा यह स्पष्ट करें कि कौन-सा सिस्टम जिसके बारे में आप चर्चा कर रहे हैं:\n✅ \u0026#34;Register with ClientAppManager using manager.register(this) for name-based lookup.\u0026#34; ✅ \u0026#34;Register with PortMapper using context.portMapper().register() for port discovery.\u0026#34; 2. पुराने संस्करण के संदर्भ न करें: - पुराने संस्करणों को \u0026ldquo;current\u0026rdquo; के रूप में संदर्भित करें - अप्रचलित API दस्तावेज़ीकरण से लिंक करें - उदाहरणों में deprecated method signatures (अप्रचलित मेथड सिग्नेचर) का उपयोग करें\nकरें: - प्रकाशित करने से पहले रिलीज़ नोट्स की जांच करें - यह सुनिश्चित करें कि API दस्तावेज़ीकरण वर्तमान संस्करण से मेल खाता हो - उदाहरणों को अद्यतन करें ताकि वे वर्तमान सर्वोत्तम प्रथाओं का उपयोग करें\n3. अप्राप्य URLs ऐसा न करें: - केवल .i2p डोमेन (जिनके clearnet (खुला सार्वजनिक इंटरनेट) विकल्प न हों) से लिंक न करें - टूटी या पुरानी दस्तावेज़ीकरण URLs का उपयोग न करें - स्थानीय file:// paths से लिंक न करें\nकरें: - सभी I2P-आंतरिक लिंक के लिए clearnet (सार्वजनिक इंटरनेट) विकल्प प्रदान करें - प्रकाशन से पहले यह सत्यापित करें कि URLs सुलभ हैं - स्थायी URLs का उपयोग करें (geti2p.net, अस्थायी होस्टिंग नहीं)\n4. अपूर्ण कोड उदाहरण ऐसा न करें: - संदर्भ के बिना अंश न दिखाएँ - त्रुटि प्रबंधन न छोड़ें - अपरिभाषित वेरिएबल्स का उपयोग न करें - जहाँ स्पष्ट न हो वहाँ इम्पोर्ट स्टेटमेंट्स न छोड़ें\nकरें: - पूर्ण, संकलनीय उदाहरण दिखाएँ - आवश्यक त्रुटि प्रबंधन शामिल करें - प्रत्येक महत्वपूर्ण पंक्ति क्या करती है, समझाएँ - प्रकाशित करने से पहले उदाहरणों का परीक्षण करें\n5. द्व्यर्थक वक्तव्य ❌ \u0026#34;Some applications register services.\u0026#34; ✅ \u0026#34;Applications implementing ClientApp may register with ClientAppManager using manager.register(this) to enable name-based lookup.\u0026#34; ❌ \u0026#34;Configuration files go in the config directory.\u0026#34; ✅ \u0026#34;Modern I2P installations store client configurations in $I2P/clients.config.d/ as individual files.\u0026#34; Markdown परंपराएँ फ़ाइल नामकरण फ़ाइल नामों के लिए kebab-case (शब्दों को हाइफ़न से जोड़ने की शैली) का उपयोग करें: - managed-clients.md - port-mapper-guide.md - configuration-reference.md\nफ्रंटमैटर प्रारूप हमेशा YAML frontmatter (YAML फ़ाइल के शीर्ष पर मेटाडेटा ब्लॉक) शामिल करें:\n--- title: \u0026#34;Document Title\u0026#34; description: \u0026#34;Brief description under 160 characters\u0026#34; slug: \u0026#34;url-slug\u0026#34; lastUpdated: \u0026#34;2025-10\u0026#34; accurateFor: \u0026#34;2.10.0\u0026#34; reviewStatus: \u0026#34;verified\u0026#34; --- लिंक स्वरूपण आंतरिक लिंक (दस्तावेज़ीकरण के भीतर):\nSee [clients.config specification](https://geti2p.net/spec/configuration#clients-config) बाहरी लिंक (अन्य संसाधनों के लिए):\nFor more details, see [ClientApp Javadoc](https://i2p.github.io/i2p.i2p/net/i2p/app/ClientApp.html) कोड रिपॉज़िटरी लिंक:\nView source: [ClientApp.java](https://i2pgit.org/I2P_Developers/i2p.i2p/src/branch/master/core/java/src/net/i2p/app/ClientApp.java) तालिका स्वरूपण GitHub-flavored Markdown (GitHub शैली वाला Markdown) तालिकाओं का उपयोग करें:\n| Property | Type | Default | Description | |----------|------|---------|-------------| | `main` | String | (required) | Full class name | | `delay` | Integer | 120 | Seconds before start | | `onBoot` | Boolean | false | Force immediate start | कोड ब्लॉक भाषा टैग्स सिंटैक्स हाइलाइटिंग के लिए हमेशा भाषा निर्दिष्ट करें:\n\\`\\`\\`java // Java code \\`\\`\\` \\`\\`\\`bash # Shell commands \\`\\`\\` \\`\\`\\`properties # Configuration files \\`\\`\\` \\`\\`\\`xml \u0026lt;!-- XML files --\u0026gt; \\`\\`\\` समीक्षा जाँच-सूची प्रलेखन प्रकाशित करने से पहले, जाँच करें:\nप्रतिक्रिया: यदि आपको इन दिशानिर्देशों में समस्याएँ मिलती हैं या आपके पास सुझाव हैं, तो कृपया उन्हें आधिकारिक I2P विकास चैनलों के माध्यम से प्रस्तुत करें।\n","description":"I2P तकनीकी दस्तावेज़ीकरण में सुसंगतता, सटीकता और सुगम्यता बनाए रखें","id":"797e1cb5256ec022a3d99eefd7eda1f4","section":"docs","title":"I2P प्रलेखन लेखन दिशानिर्देश","url":"/hi/docs/writing-guidelines/"},{"categories":null,"content":"अवलोकन आज कई प्रमुख गोपनीयता और गुमनामी नेटवर्क मौजूद हैं, जिनमें से प्रत्येक के अलग-अलग डिज़ाइन लक्ष्य और खतरे के मॉडल हैं। जबकि Tor, Lokinet, GNUnet, और Freenet सभी गोपनीयता-संरक्षित संचार के लिए मूल्यवान दृष्टिकोण प्रदान करते हैं, I2P एकमात्र उत्पादन-तैयार, packet-switched नेटवर्क के रूप में अलग खड़ा है जो पूरी तरह से in-network hidden services और peer-to-peer अनुप्रयोगों के लिए अनुकूलित है।\nनीचे दी गई तालिका 2025 तक इन नेटवर्क्स में प्रमुख वास्तुशिल्प और संचालनात्मक अंतरों को सारांशित करती है।\nगोपनीयता नेटवर्क तुलना (2025) Feature / Network I2P Tor Lokinet Freenet (Hyphanet) GNUnet Primary Focus Hidden services, P2P applications Clearnet anonymity via exits Hybrid VPN + hidden services Distributed storage \u0026 publishing Research framework, F2F privacy Architecture Fully distributed, packet-switched Centralized directory, circuit-switched Packet-switched LLARP with blockchain coordination DHT-based content routing DHT \u0026 F2F topology (R5N) Routing Model Unidirectional tunnels (inbound/outbound) Bidirectional circuits (3 hops) Packet-switched over staked nodes Key-based routing Random walk + DHT hybrid Directory / Peer Discovery Distributed Kademlia netDB with floodfills 9 hardcoded directory authorities Blockchain + Oxen staking Heuristic routing Distributed hash routing (R5N) Encryption ECIES-X25519-AEAD-Ratchet (ChaCha20/Poly1305) AES + RSA/ECDH Curve25519/ChaCha20 Custom symmetric encryption Ed25519/Curve25519 Participation Model All routers route traffic (democratic) Small relay subset, majority are clients Only staked nodes User-selectable trust mesh Optional F2F restriction Traffic Handling Packet-switched, multi-path, load-balanced Circuit-switched, fixed path per circuit Packet-switched, incentivized File chunk propagation Message batching and proof-of-work Garlic Routing ✅ Yes (message bundling \u0026 tagging) ❌ No Partial (message batches) ❌ No ❌ No Exit to Clearnet Limited (discouraged) Core design goal Supported (VPN-style exits) Not applicable Not applicable Built-In Apps I2PSnark, I2PTunnel, SusiMail, I2PBote Tor Browser, OnionShare Lokinet GUI, SNApps Freenet UI GNUnet CLI tools Performance Optimized for internal services, 1–3s RTT Optimized for exits, ~200–500ms RTT Low latency, staked node QoS High latency (minutes) Experimental, inconsistent Anonymity Set Size ~55,000 active routers Millions of daily users \u0026lt;1,000 service nodes Thousands (small core) Hundreds (research only) Scalability Horizontal via floodfill rotation Centralized bottleneck (directory) Dependent on token economics Limited by routing heuristics Research-scale only Funding Model Volunteer-driven nonprofit Major institutional grants Crypto-incentivized (OXEN) Volunteer community Academic research License / Codebase Open source (Java/C++/Go) Open source (C) Open source (C++) Open source (Java) Open source (C) --- I2P गोपनीयता-प्रथम डिज़ाइन में क्यों अग्रणी है 1. Packet Switching \u0026gt; Circuit Switching Tor का circuit-switched मॉडल ट्रैफ़िक को निश्चित three-hop पथों से जोड़ता है—ब्राउज़िंग के लिए कुशल, लेकिन लंबे समय तक चलने वाली आंतरिक सेवाओं के लिए नाजुक। I2P के packet-switched tunnels कई समवर्ती पथों के माध्यम से संदेश भेजते हैं, बेहतर अपटाइम और लोड वितरण के लिए भीड़ या विफलता के आसपास स्वचालित रूप से रूटिंग करते हैं।\n2. Unidirectional Tunnels I2P इनबाउंड और आउटबाउंड ट्रैफ़िक को अलग करता है। इसका मतलब है कि प्रत्येक प्रतिभागी केवल संचार प्रवाह का आधा हिस्सा ही देखता है, जिससे टाइमिंग सहसंबंध हमले काफी कठिन हो जाते हैं। Tor, Lokinet और अन्य द्विदिशात्मक सर्किट का उपयोग करते हैं जहाँ अनुरोध और प्रतिक्रियाएँ एक ही पथ साझा करती हैं—सरल, लेकिन अधिक ट्रेस करने योग्य।\n3. Fully Distributed netDB Tor के नौ directory authorities इसकी नेटवर्क टोपोलॉजी को परिभाषित करते हैं। I2P एक स्व-संगठित Kademlia DHT का उपयोग करता है जो rotating floodfill routers द्वारा बनाए रखा जाता है, जिससे किसी भी केंद्रीय नियंत्रण बिंदु या समन्वय सर्वर की आवश्यकता समाप्त हो जाती है।\n1. पैकेट स्विचिंग \u0026gt; सर्किट स्विचिंग I2P, onion routing को garlic routing के साथ विस्तारित करता है, जो कई encrypted संदेशों को एक container में बंडल करता है। यह metadata leakage और bandwidth overhead को कम करता है जबकि acknowledgment, data, और control messages के लिए दक्षता में सुधार करता है।\n2. एकदिशात्मक टनल प्रत्येक I2P router दूसरों के लिए routing करता है। कोई समर्पित relay संचालक या विशेषाधिकार प्राप्त नोड नहीं हैं—bandwidth और विश्वसनीयता स्वचालित रूप से निर्धारित करती है कि एक नोड कितनी routing में योगदान देता है। यह लोकतांत्रिक दृष्टिकोण लचीलापन बनाता है और नेटवर्क के बढ़ने के साथ स्वाभाविक रूप से विस्तारित होता है।\n3. पूर्णतः वितरित netDB I2P का 12-hop राउंड-ट्रिप (6 इनबाउंड + 6 आउटबाउंड) Tor के 6-hop हिडन सर्विस सर्किट की तुलना में अधिक मजबूत अनलिंकेबिलिटी (unlinkability - कनेक्शन को जोड़कर पहचानने में असमर्थता) प्रदान करता है। क्योंकि दोनों पक्ष आंतरिक हैं, कनेक्शन exit की बाधा से पूरी तरह बच जाते हैं, जो तेज़ आंतरिक होस्टिंग और मूल एप्लिकेशन एकीकरण (I2PSnark, I2PTunnel, I2PBote) प्रदान करता है।\nArchitectural Takeaways Design Principle I2P Advantage Decentralization No trusted authorities; netDB managed by floodfill peers Traffic Separation Unidirectional tunnels prevent request/response correlation Adaptability Packet-switching allows per-message load balancing Efficiency Garlic routing reduces metadata and increases throughput Inclusiveness All peers route traffic, strengthening anonymity set Focus Built specifically for hidden services and in-network communication --- When to Use Each Network Use Case Recommended Network Anonymous web browsing (clearnet access) I2P Anonymous hosting, P2P, or DApps I2P Anonymous file publishing and storage Freenet (Hyphanet) VPN-style private routing with staking Lokinet Academic experimentation and research GNUnet --- Summary I2P की वास्तुकला विशिष्ट रूप से गोपनीयता-प्रथम है—कोई directory servers नहीं, कोई blockchain निर्भरताएं नहीं, कोई केंद्रीकृत विश्वास नहीं। इसका unidirectional tunnels, packet-switched routing, garlic message bundling, और distributed peer discovery का संयोजन इसे आज anonymous होस्टिंग और peer-to-peer संचार के लिए तकनीकी रूप से सबसे उन्नत प्रणाली बनाता है।\nI2P \u0026ldquo;Tor का विकल्प\u0026rdquo; नहीं है। यह एक अलग श्रेणी का नेटवर्क है—जो गोपनीयता नेटवर्क के अंदर होने वाली गतिविधियों के लिए बनाया गया है, न कि इसके बाहर की गतिविधियों के लिए।\n","description":"एक आधुनिक तकनीकी और दार्शनिक तुलना जो I2P के अद्वितीय डिज़ाइन लाभों को उजागर करती है","id":"bc3abab13910824c59b1550aa1ce69df","section":"docs","title":"I2P बनाम अन्य गोपनीयता नेटवर्क","url":"/hi/docs/overview/comparison/"},{"categories":null,"content":"Reseed होस्ट I2P नेटवर्क के लिए महत्वपूर्ण इंफ्रास्ट्रक्चर हैं, जो bootstrap प्रक्रिया के दौरान नए routers को नोड्स के प्रारंभिक समूह प्रदान करते हैं। यह गाइड आपको अपना स्वयं का reseed सर्वर सेटअप करने और चलाने की प्रक्रिया से परिचित कराएगी।\nI2P Reseed सर्वर क्या है? एक I2P reseed सर्वर नए routers को I2P नेटवर्क में एकीकृत करने में मदद करता है:\nप्रारंभिक पीयर डिस्कवरी प्रदान करना: नए routers को कनेक्ट करने के लिए नेटवर्क नोड्स का एक प्रारंभिक सेट प्राप्त होता है Bootstrap रिकवरी: उन routers की मदद करना जो कनेक्शन बनाए रखने में कठिनाई का सामना कर रहे हैं सुरक्षित वितरण: Reseeding प्रक्रिया एन्क्रिप्टेड और डिजिटली साइन की गई है ताकि नेटवर्क सुरक्षा सुनिश्चित हो सके जब एक नया I2P router पहली बार शुरू होता है (या अपने सभी peer connections खो देता है), तो यह reseed servers से संपर्क करता है ताकि router information का एक प्रारंभिक सेट डाउनलोड कर सके। इससे नए router को अपना network database बनाना और tunnels स्थापित करना शुरू करने में मदद मिलती है।\nपूर्वापेक्षाएँ शुरू करने से पहले, आपको यह चाहिए होगा:\nरूट एक्सेस के साथ एक Linux सर्वर (Debian/Ubuntu अनुशंसित) आपके सर्वर की ओर इशारा करता एक डोमेन नाम कम से कम 1GB RAM और 10GB डिस्क स्पेस netDb को पॉप्युलेट करने के लिए सर्वर पर एक चालू I2P router Linux सिस्टम एडमिनिस्ट्रेशन से बुनियादी परिचय सर्वर तैयार करना Step 1: Update System and Install Dependencies पहले, अपने सिस्टम को अपडेट करें और आवश्यक पैकेजों को इंस्टॉल करें:\nsudo apt update \u0026amp;\u0026amp; sudo apt upgrade -y \u0026amp;\u0026amp; sudo apt-get install golang-go git make docker.io docker-compose -y यह इंस्टॉल करता है: - golang-go: Go प्रोग्रामिंग भाषा रनटाइम - git: वर्जन कंट्रोल सिस्टम - make: बिल्ड ऑटोमेशन टूल - docker.io \u0026amp; docker-compose: Nginx Proxy Manager चलाने के लिए कंटेनर प्लेटफॉर्म\nStep 2: Clone and Build Reseed Tools reseed-tools रिपॉजिटरी को क्लोन करें और एप्लिकेशन को बिल्ड करें:\ncd /home/i2p git clone https://i2pgit.org/idk/reseed-tools cd reseed-tools make build sudo make install reseed-tools पैकेज reseed सर्वर चलाने के लिए मुख्य कार्यक्षमता प्रदान करता है। यह निम्नलिखित को संभालता है: - आपके स्थानीय network database से router जानकारी एकत्र करना - router info को signed SU3 फाइलों में पैकेज करना - इन फाइलों को HTTPS के माध्यम से serve करना\nStep 3: Generate SSL Certificate अपने reseed server का SSL certificate और private key जनरेट करें:\nsu - i2p -c \u0026#39;reseed-tools reseed --signer=admin@stormycloud.org --netdb=/home/i2p/.i2p/netDb --port=8443 --ip=127.0.0.1 --trustProxy\u0026#39; महत्वपूर्ण पैरामीटर: - --signer: आपका ईमेल पता (admin@stormycloud.org को अपने ईमेल से बदलें) - --netdb: आपके I2P router के network database का पथ - --port: आंतरिक पोर्ट (8443 अनुशंसित है) - --ip: localhost से बाइंड करें (हम सार्वजनिक पहुँच के लिए reverse proxy का उपयोग करेंगे) - --trustProxy: reverse proxy से X-Forwarded-For headers पर भरोसा करें\nयह कमांड निम्नलिखित जेनरेट करेगा: - SU3 फाइलों पर हस्ताक्षर करने के लिए एक प्राइवेट की - सुरक्षित HTTPS कनेक्शन के लिए एक SSL सर्टिफिकेट\nचरण 1: सिस्टम अपडेट करें और डिपेंडेंसी इंस्टॉल करें महत्वपूर्ण: /home/i2p/.reseed/ में स्थित उत्पन्न keys का सुरक्षित रूप से backup लें:\nsudo tar -czf reseed-keys-backup.tar.gz /home/i2p/.reseed/ इस बैकअप को सीमित पहुंच वाले सुरक्षित, एन्क्रिप्टेड स्थान पर संग्रहीत करें। ये keys आपके reseed server के संचालन के लिए आवश्यक हैं और इन्हें सावधानीपूर्वक सुरक्षित रखा जाना चाहिए।\nConfiguring the Service चरण 2: Reseed Tools को Clone और Build करें systemd सर्विस बनाएं ताकि reseed सर्वर स्वचालित रूप से चले:\nsudo tee /etc/systemd/system/reseed.service \u0026lt;\u0026lt;EOF [Unit] Description=Reseed Service After=network.target [Service] User=i2p WorkingDirectory=/home/i2p ExecStart=/bin/bash -c \u0026#39;reseed-tools reseed --signer=admin@stormycloud.org --netdb=/home/i2p/.i2p/netDb --port=8443 --ip=127.0.0.1 --trustProxy\u0026#39; Restart=always RestartSec=10 [Install] WantedBy=multi-user.target EOF याद रखें कि admin@stormycloud.org को अपने स्वयं के ईमेल पते से बदलें।\nअब सेवा को सक्षम और प्रारंभ करें:\nsudo systemctl daemon-reload sudo systemctl enable reseed sudo systemctl start reseed जांचें कि सेवा चल रही है:\nsudo systemctl status reseed चरण 3: SSL प्रमाणपत्र जनरेट करें इष्टतम प्रदर्शन के लिए, आप router जानकारी को ताज़ा करने के लिए reseed service को समय-समय पर पुनः आरंभ करना चाह सकते हैं:\nsudo crontab -e हर 3 घंटे में सेवा को पुनः आरंभ करने के लिए यह लाइन जोड़ें:\n0 */3 * * * systemctl restart reseed Setting Up Reverse Proxy reseed सर्वर localhost:8443 पर चलता है और सार्वजनिक HTTPS ट्रैफ़िक को संभालने के लिए एक reverse proxy की आवश्यकता होती है। हम इसकी उपयोग में आसानी के लिए Nginx Proxy Manager की अनुशंसा करते हैं।\nचरण 4: अपनी Keys का बैकअप लें Docker का उपयोग करके Nginx Proxy Manager को Deploy करें:\ndocker run -d \\ --name nginx-proxy-manager \\ -p 80:80 \\ -p 81:81 \\ -p 443:443 \\ -v $(pwd)/data:/data \\ -v $(pwd)/letsencrypt:/etc/letsencrypt \\ --restart unless-stopped \\ jc21/nginx-proxy-manager:latest यह निम्नलिखित को एक्सपोज़ करता है: - Port 80: HTTP traffic - Port 81: Admin interface - Port 443: HTTPS traffic\nConfigure Proxy Manager एडमिन इंटरफेस को http://your-server-ip:81 पर एक्सेस करें\nडिफ़ॉल्ट क्रेडेंशियल्स से लॉगिन करें:\nईमेल: admin@example.com पासवर्ड: changeme महत्वपूर्ण: पहली लॉगिन के तुरंत बाद इन क्रेडेंशियल्स को बदलें!\nProxy Hosts पर जाएं और Add Proxy Host पर क्लिक करें प्रॉक्सी होस्ट को कॉन्फ़िगर करें: Domain Name: आपका reseed डोमेन (उदाहरण के लिए, reseed.example.com) Scheme: https Forward Hostname / IP: 127.0.0.1 Forward Port: 8443 Cache Assets को सक्षम करें Block Common Exploits को सक्षम करें Websockets Support को सक्षम करें SSL टैब में: Request a new SSL Certificate (Let\u0026rsquo;s Encrypt) चुनें Force SSL सक्षम करें HTTP/2 Support सक्षम करें Let\u0026rsquo;s Encrypt Terms of Service से सहमत हों Save पर क्लिक करें आपका reseed server अब https://reseed.example.com पर accessible होना चाहिए\nRegistering Your Reseed Server एक बार जब आपका reseed सर्वर operational हो जाए, तो I2P डेवलपर्स से संपर्क करें ताकि इसे आधिकारिक reseed सर्वर सूची में जोड़ा जा सके।\nचरण 5: Systemd सेवा बनाएं zzz (I2P lead developer) को निम्नलिखित जानकारी के साथ ईमेल करें:\nI2P ईमेल: zzz@mail.i2p Clearnet ईमेल: zzz@i2pmail.org चरण 6: वैकल्पिक - आवधिक पुनरारंभ कॉन्फ़िगर करें अपने ईमेल में शामिल करें:\nReseed सर्वर URL: पूर्ण HTTPS URL (उदाहरण के लिए, https://reseed.example.com) सार्वजनिक reseed प्रमाणपत्र: /home/i2p/.reseed/ पर स्थित (.crt फ़ाइल संलग्न करें) संपर्क ईमेल: सर्वर रखरखाव सूचनाओं के लिए आपकी पसंदीदा संपर्क विधि सर्वर स्थान: वैकल्पिक लेकिन सहायक (देश/क्षेत्र) अपेक्षित अपटाइम: सर्वर को बनाए रखने के लिए आपकी प्रतिबद्धता Verification I2P डेवलपर्स यह सत्यापित करेंगे कि आपका reseed सर्वर: - उचित रूप से कॉन्फ़िगर किया गया है और router जानकारी प्रदान कर रहा है - वैध SSL सर्टिफिकेट्स का उपयोग कर रहा है - सही ढंग से साइन की गई SU3 फ़ाइलें प्रदान कर रहा है - सुलभ और उत्तरदायी है\nएक बार स्वीकृत होने के बाद, आपका reseed server I2P routers के साथ वितरित की जाने वाली सूची में जोड़ दिया जाएगा, जिससे नए उपयोगकर्ताओं को नेटवर्क से जुड़ने में मदद मिलेगी!\nMonitoring and Maintenance Nginx Proxy Manager इंस्टॉल करें अपनी reseed सेवा की निगरानी करें:\nsudo systemctl status reseed sudo journalctl -u reseed -f प्रॉक्सी मैनेजर को कॉन्फ़िगर करें सिस्टम संसाधनों पर नज़र रखें:\nhtop df -h Update Reseed Tools नवीनतम सुधार प्राप्त करने के लिए reseed-tools को समय-समय पर अपडेट करें:\ncd /home/i2p/reseed-tools git pull make build sudo make install sudo systemctl restart reseed संपर्क जानकारी यदि Nginx Proxy Manager के माध्यम से Let\u0026rsquo;s Encrypt का उपयोग कर रहे हैं, तो प्रमाणपत्र स्वतः नवीनीकृत हो जाएंगे। नवीनीकरण कार्य कर रहा है इसकी पुष्टि करें:\ndocker logs nginx-proxy-manager | grep -i certificate सेवा को कॉन्फ़िगर करना आवश्यक जानकारी त्रुटियों के लिए लॉग जांचें:\nsudo journalctl -u reseed -n 50 सामान्य समस्याएं: - I2P router चालू नहीं है या network database खाली है - Port 8443 पहले से उपयोग में है - /home/i2p/.reseed/ directory के साथ अनुमति संबंधी समस्याएं\nसत्यापन सुनिश्चित करें कि आपका I2P router चल रहा है और उसने अपना network database populate कर लिया है:\nls -lh /home/i2p/.i2p/netDb/ आपको कई .dat फ़ाइलें दिखाई देनी चाहिए। यदि खाली है, तो अपने I2P router को peers खोजने के लिए प्रतीक्षा करें।\nSSL Certificate Errors अपने प्रमाणपत्रों को मान्य होने की पुष्टि करें:\nopenssl s_client -connect reseed.example.com:443 -servername reseed.example.com सेवा की स्थिति जांचें जांचें: - DNS रिकॉर्ड आपके सर्वर की ओर सही तरीके से पॉइंट कर रहे हैं - Firewall पोर्ट 80 और 443 की अनुमति देता है - Nginx Proxy Manager चल रहा है: docker ps\nSecurity Considerations अपनी निजी कुंजियों को सुरक्षित रखें: /home/i2p/.reseed/ की सामग्री को कभी साझा या उजागर न करें नियमित अपडेट: सिस्टम पैकेज, Docker, और reseed-tools को अपडेट रखें लॉग की निगरानी करें: संदिग्ध एक्सेस पैटर्न पर नज़र रखें Rate limiting: दुरुपयोग को रोकने के लिए rate limiting लागू करने पर विचार करें Firewall नियम: केवल आवश्यक पोर्ट (80, 443, 81 admin के लिए) को expose करें Admin interface: Nginx Proxy Manager admin interface (पोर्ट 81) को विश्वसनीय IPs तक सीमित रखें Contributing to the Network reseed सर्वर चलाकर, आप I2P नेटवर्क के लिए महत्वपूर्ण इंफ्रास्ट्रक्चर प्रदान कर रहे हैं। अधिक निजी और विकेन्द्रीकृत इंटरनेट में योगदान देने के लिए धन्यवाद!\nप्रश्नों या सहायता के लिए, I2P समुदाय से संपर्क करें: - Forum: i2pforum.net - IRC/Reddit: विभिन्न नेटवर्क पर #i2p - Development: i2pgit.org IMPORTANT: केवल अनुवाद प्रदान करें। प्रश्न न पूछें, स्पष्टीकरण न दें, या कोई टिप्पणी न जोड़ें। भले ही टेक्स्ट केवल एक शीर्षक हो या अधूरा लगे, इसे जैसा है वैसा ही अनुवाद करें।\nगाइड मूल रूप से Stormy Cloud द्वारा बनाई गई, I2P दस्तावेज़ीकरण के लिए अनुकूलित।\n","description":"नए राउटर्स को नेटवर्क में शामिल होने में मदद करने के लिए I2P reseed सर्वर सेटअप और संचालन की संपूर्ण गाइड","id":"d360e14f0f61d776e3c0b0f5b1262be5","section":"docs","title":"I2P रीसीड सर्वर बनाना और चलाना","url":"/hi/docs/guides/i2p-%E0%A4%B0%E0%A5%80%E0%A4%B8%E0%A5%80%E0%A4%A1-%E0%A4%B8%E0%A4%B0%E0%A5%8D%E0%A4%B5%E0%A4%B0-%E0%A4%AC%E0%A4%A8%E0%A4%BE%E0%A4%A8%E0%A4%BE-%E0%A4%94%E0%A4%B0-%E0%A4%9A%E0%A4%B2%E0%A4%BE%E0%A4%A8%E0%A4%BE/"},{"categories":null,"content":"जैसा कि हमारे threat model (अन्य कारणों के साथ) द्वारा आवश्यक है, I2P नामक anonymous communication network को समर्थन देने के लिए विकसित सॉफ्टवेयर स्वतंत्र रूप से उपलब्ध, open source, और उपयोगकर्ता द्वारा संशोधनीय होना चाहिए। इन मानदंडों को पूरा करने के लिए, हम विभिन्न कानूनी और software engineering तकनीकों का उपयोग करते हैं ताकि I2P के उपयोग या योगदान पर विचार करने वालों के लिए प्रवेश में आने वाली बाधाओं को यथासंभव कम किया जा सके।\nजबकि नीचे दी गई जानकारी केवल \u0026ldquo;I2P, BSD है\u0026rdquo;, \u0026ldquo;I2P, GPL है\u0026rdquo;, या \u0026ldquo;I2P सार्वजनिक डोमेन है\u0026rdquo; कहने की तुलना में अधिक भ्रमित करने वाली हो सकती है, \u0026ldquo;I2P को कैसे लाइसेंस दिया गया है?\u0026rdquo; इस प्रश्न का संक्षिप्त उत्तर यह है:\nI2P वितरण में बंडल किए गए सभी सॉफ़्टवेयर निम्नलिखित की अनुमति देंगे: बिना शुल्क के उपयोग कैसे, कब, कहाँ, क्यों, या किसके द्वारा चलाया जा रहा है, इस पर बिना किसी प्रतिबंध के उपयोग बिना शुल्क के source code तक पहुँच source में संशोधन अधिकांश सॉफ्टवेयर इससे कहीं अधिक की गारंटी देते हैं - किसी भी व्यक्ति की संशोधित स्रोत कोड को अपनी इच्छानुसार वितरित करने की क्षमता। हालांकि, बंडल किए गए सभी सॉफ्टवेयर यह स्वतंत्रता प्रदान नहीं करते - GPL उन डेवलपर्स की क्षमता को प्रतिबंधित करता है जो I2P को अपने स्वयं के अनुप्रयोगों के साथ एकीकृत करना चाहते हैं जो स्वयं open source अनुप्रयोग नहीं हैं। जबकि हम सामान्य संसाधनों को बढ़ाने के महान लक्ष्यों की सराहना करते हैं, I2P की सबसे अच्छी सेवा इसकी स्वीकृति के रास्ते में आने वाली किसी भी बाधा को हटाने से होती है - यदि कोई डेवलपर यह विचार कर रहा है कि क्या वे I2P को अपने अनुप्रयोग के साथ एकीकृत कर सकते हैं, और उन्हें रुककर अपने वकील से जांच करनी पड़े, या यह सुनिश्चित करने के लिए कोड ऑडिट करना पड़े कि उनका अपना स्रोत कोड GPL-संगत के रूप में जारी किया जा सकता है, तो हम इसे खो देते हैं।\nघटक लाइसेंस I2P वितरण में कई संसाधन शामिल हैं, जो स्रोत कोड को घटकों में विभाजन को दर्शाते हैं। प्रत्येक घटक का अपना लाइसेंस होता है, जिससे उसमें योगदान करने वाले सभी डेवलपर्स सहमत होते हैं - या तो उस घटक के साथ संगत लाइसेंस के तहत प्रतिबद्ध कोड की रिलीज़ को स्पष्ट रूप से घोषित करके, या घटक के प्राथमिक लाइसेंस के तहत प्रतिबद्ध कोड को अप्रत्यक्ष रूप से जारी करके। इन घटकों में से प्रत्येक का एक प्रमुख डेवलपर होता है जिसका अंतिम निर्णय होता है कि कौन सा लाइसेंस घटक के प्राथमिक लाइसेंस के साथ संगत है, और I2P परियोजना प्रबंधक का अंतिम निर्णय होता है कि कौन से लाइसेंस I2P वितरण में शामिल करने के लिए उपरोक्त चार गारंटियों को पूरा करते हैं।\nComponent Source path Resource Primary license Alternate licenses Lead developer I2P SDK core i2p.jar Public domain BSD, Cryptix, MIT zzz I2P Router router router.jar Public domain BSD, Cryptix, MIT zzz Ministreaming apps/ministreaming mstreaming.jar BSD Public domain, Cryptix, MIT zzz Streaming apps/streaming streaming.jar Public domain BSD, Cryptix, MIT zzz I2PTunnel apps/i2ptunnel i2ptunnel.jar GPL + exception Public domain, BSD, Cryptix, MIT zzz Routerconsole apps/routerconsole routerconsole.war Public domain — zzz Address Book apps/addressbook addressbook.war MIT Public domain, Cryptix, BSD — Susidns apps/susidns susidns.war GPL + exception — — Susimail apps/susimail susimail.war GPL + exception — — I2PSnark apps/i2psnark i2psnark.jar GPL + exception — zzz [BOB](/docs/legacy/bob/) Bridge apps/BOB BOB.jar WTFPL — sponge [SAM](/docs/api/samv3/) Bridge apps/sam sam.jar Public domain Cryptix, BSD, MIT zzz [SAM v1](/docs/legacy/sam/) Perl library apps/sam/perl SAM.pm GPL Public domain, Cryptix, BSD, MIT BrianR [SAM v1](/docs/legacy/sam/) C library apps/sam/c libSAM BSD Public domain, Cryptix, MIT Nightblade [SAM v1](/docs/legacy/sam/) Python library apps/sam/python i2p.py Public domain BSD, Cryptix, MIT Connelly [SAM v1](/docs/legacy/sam/) C# library apps/sam/csharp/ n/a Public domain BSD, Cryptix, MIT smeghead Other apps not mentioned apps/ ... Probably Public domain but check the source — — Installer installer install.jar, guiinstall.jar Public domain GPL + exception, BSD, Cryptix, MIT — GPL अपवाद हालांकि यह अनावश्यक हो सकता है, लेकिन स्पष्टता के लिए I2PTunnel और अन्य ऐप्स में शामिल GPL\u0026rsquo;ed कोड को GPL के तहत जारी किया जाना चाहिए, जिसमें Java की मानक लाइब्रेरी के उपयोग को स्पष्ट रूप से अधिकृत करने वाला एक अतिरिक्त \u0026ldquo;अपवाद\u0026rdquo; होना चाहिए:\nIn addition, as a special exception, XXXX gives permission to link the code of this program with the proprietary Java implementation provided by Sun (or other vendors as well), and distribute linked combinations including the two. You must obey the GNU General Public License in all respects for all of the code used other than the proprietary Java implementation. If you modify this file, you may extend this exception to your version of the file, but you are not obligated to do so. If you do not wish to do so, delete this exception statement from your version. प्रत्येक घटक के अंतर्गत सभी स्रोत कोड डिफ़ॉल्ट रूप से प्राथमिक लाइसेंस के तहत लाइसेंस प्राप्त होगा, जब तक कि कोड में अन्यथा चिह्नित न किया गया हो। उपरोक्त सभी लाइसेंस शर्तों का सारांश है - कृपया आधिकारिक शर्तों के लिए संबंधित घटक या स्रोत कोड का विशिष्ट लाइसेंस देखें। यदि रिपॉजिटरी को पुनर्गठित किया जाता है तो घटक स्रोत स्थान और संसाधन पैकेजिंग को बदला जा सकता है।\nवेबसाइट लाइसेंस जहाँ अन्यथा उल्लेख न किया गया हो, इस साइट पर सामग्री Creative Commons Attribution-ShareAlike 4.0 International License के तहत लाइसेंस प्राप्त है।\nकमिट एक्सेस डेवलपर्स वितरित git रिपॉजिटरी में परिवर्तन push कर सकते हैं यदि आपको उस रिपॉजिटरी को चलाने वाले व्यक्ति से अनुमति मिलती है। विवरण के लिए New Developer Guide देखें।\nहालांकि, किसी रिलीज़ में बदलावों को शामिल करने के लिए, डेवलपर्स को रिलीज़ मैनेजर (वर्तमान में zzz) द्वारा विश्वसनीय होना चाहिए। इसके अलावा, उन्हें विश्वसनीय होने के लिए उपरोक्त शर्तों से स्पष्ट रूप से सहमत होना चाहिए। इसका मतलब है कि उन्हें रिलीज़ मैनेजर्स में से किसी एक को एक हस्ताक्षरित संदेश भेजना होगा जिसमें यह पुष्टि हो कि:\nजब तक अन्यथा चिह्नित न हो, मेरे द्वारा commit किया गया सभी कोड स्वतः घटक के प्राथमिक लाइसेंस के तहत लाइसेंस प्राप्त है यदि स्रोत में निर्दिष्ट है, तो कोड स्पष्ट रूप से घटक के वैकल्पिक लाइसेंसों में से किसी एक के तहत लाइसेंस प्राप्त हो सकता है मुझे अपने द्वारा commit किए गए कोड को उन शर्तों के तहत जारी करने का अधिकार है जिनके तहत मैं इसे commit कर रहा हूं यदि किसी को ऐसी कोई स्थिति के बारे में जानकारी है जहाँ उपरोक्त शर्तें पूरी नहीं होती हैं, तो कृपया अधिक जानकारी के साथ component lead और/या I2P release manager से संपर्क करें।\n","description":"I2P के साथ बंडल किए गए सॉफ़्टवेयर के लिए लाइसेंस नीति और घटक लाइसेंस","id":"74bb6af167b1176b4058e46e5f8ca568","section":"docs","title":"I2P सॉफ़्टवेयर लाइसेंस","url":"/hi/docs/develop/licenses/"},{"categories":null,"content":"परिचय I2P एक स्केलेबल, स्व-संगठित, लचीली पैकेट-स्विच्ड गुमनाम नेटवर्क परत है, जिस पर कई अलग-अलग गुमनामी या सुरक्षा-जागरूक एप्लिकेशन संचालित हो सकते हैं। इनमें से प्रत्येक एप्लिकेशन free route mixnet के उचित कार्यान्वयन की चिंता किए बिना अपनी गुमनामी, विलंबता और थ्रूपुट के बीच समझौता कर सकता है, जिससे वे अपनी गतिविधि को I2P पर पहले से चल रहे उपयोगकर्ताओं के बड़े गुमनामी समूह के साथ मिला सकते हैं।\nपहले से उपलब्ध एप्लिकेशन इंटरनेट गतिविधियों की पूरी श्रृंखला प्रदान करते हैं — गुमनाम वेब ब्राउज़िंग, वेब होस्टिंग, चैट, फ़ाइल शेयरिंग, ई-मेल, ब्लॉगिंग, और कंटेंट सिंडिकेशन, साथ ही विकास के अधीन कई अन्य एप्लिकेशन।\nवेब ब्राउज़िंग: किसी भी मौजूदा ब्राउज़र का उपयोग करके जो proxy का समर्थन करता है चैट: IRC और अन्य प्रोटोकॉल फ़ाइल शेयरिंग: I2PSnark और अन्य एप्लिकेशन ई-मेल: Susimail और अन्य एप्लिकेशन ब्लॉग: किसी भी स्थानीय वेब सर्वर का उपयोग करके, या उपलब्ध प्लगइन्स Freenet या GNUnet जैसे content distribution networks में होस्ट की गई वेबसाइटों के विपरीत, I2P पर होस्ट की गई सेवाएं पूरी तरह से इंटरैक्टिव हैं — यहाँ पारंपरिक वेब-शैली के search engines, bulletin boards, ऐसे blogs जिन पर आप comment कर सकते हैं, database-driven साइटें, और Freenet जैसे static systems को query करने के लिए bridges उपलब्ध हैं बिना उन्हें locally install किए।\nइन सभी गोपनीयता-सक्षम अनुप्रयोगों के साथ, I2P संदेश-उन्मुख मिडलवेयर के रूप में कार्य करता है — अनुप्रयोग एक क्रिप्टोग्राफ़िक पहचानकर्ता (एक \u0026ldquo;destination\u0026rdquo;) को भेजने के लिए डेटा निर्दिष्ट करते हैं, और I2P यह सुनिश्चित करता है कि यह सुरक्षित और गुमनाम रूप से पहुंचे। I2P में एक सरल streaming library भी शामिल है जो I2P के गुमनाम बेस्ट-एफर्ट संदेशों को विश्वसनीय, क्रमबद्ध स्ट्रीम के रूप में स्थानांतरित करने की अनुमति देती है, जो नेटवर्क के उच्च बैंडविड्थ-विलंब उत्पाद के लिए समायोजित TCP-आधारित कंजेशन नियंत्रण प्रदान करती है।\nजबकि मौजूदा एप्लिकेशन को कनेक्ट करने के लिए सरल SOCKS proxies विकसित किए गए हैं, उनका मूल्य सीमित है क्योंकि अधिकांश एप्लिकेशन गुमनाम संदर्भ में संवेदनशील जानकारी लीक करते हैं। सबसे सुरक्षित दृष्टिकोण है एप्लिकेशन को ऑडिट और अनुकूलित करना ताकि वह सीधे I2P के APIs का उपयोग कर सके।\nI2P कोई शोध परियोजना नहीं है — न तो शैक्षणिक, न व्यावसायिक, और न ही सरकारी — बल्कि यह एक इंजीनियरिंग प्रयास है जिसका उद्देश्य उपयोगी गुमनामी प्रदान करना है। यह 2003 की शुरुआत से विश्वभर में वितरित योगदानकर्ताओं के एक समूह द्वारा निरंतर विकास में है। सभी I2P कार्य आधिकारिक वेबसाइट पर ओपन सोर्स है, मुख्य रूप से सार्वजनिक डोमेन में जारी किया गया है, कुछ घटकों के साथ अनुमोदक BSD-शैली के लाइसेंस के तहत। कई GPL-लाइसेंस प्राप्त क्लाइंट एप्लिकेशन उपलब्ध हैं, जैसे I2PTunnel , Susimail , और I2PSnark । फंडिंग केवल उपयोगकर्ता दान से आती है।\nसंचालन Overview I2P स्पष्ट रूप से routers (नेटवर्क में भाग लेने वाले nodes) और destinations (एप्लिकेशन के लिए गुमनाम endpoints) के बीच अंतर करता है। I2P को चलाना स्वयं गुप्त नहीं है; जो छिपा हुआ है वह यह है कि उपयोगकर्ता क्या कर रहा है और उनके destinations कौन से router का उपयोग करते हैं। अंतिम उपयोगकर्ता आमतौर पर कई destinations चलाते हैं (जैसे, एक वेब ब्राउज़िंग के लिए, दूसरा होस्टिंग के लिए, तीसरा IRC के लिए)।\nI2P में एक मुख्य अवधारणा tunnel है — यह routers की श्रृंखला के माध्यम से एक एकदिशीय एन्क्रिप्टेड पथ होता है। प्रत्येक router केवल एक परत को डिक्रिप्ट करता है और केवल अगले hop के बारे में जानता है। Tunnels हर 10 मिनट में समाप्त हो जाती हैं और उन्हें पुनर्निर्मित करना आवश्यक होता है।\nचित्र 1: दो प्रकार के tunnel मौजूद हैं — इनबाउंड और आउटबाउंड।\nOutbound tunnels निर्माता से दूर संदेश भेजते हैं। Inbound tunnels निर्माता के पास वापस संदेश लाते हैं। इन्हें मिलाने से दो-तरफ़ा संचार संभव होता है। उदाहरण के लिए, \u0026ldquo;Alice\u0026rdquo; एक outbound tunnel का उपयोग करके \u0026ldquo;Bob\u0026rsquo;s\u0026rdquo; inbound tunnel को भेजती है। Alice अपने संदेश को Bob\u0026rsquo;s inbound gateway के लिए routing निर्देशों के साथ एन्क्रिप्ट करती है।\nएक अन्य महत्वपूर्ण अवधारणा network database या netDb है, जो routers और destinations के बारे में metadata वितरित करता है:\nRouterInfo: router संपर्क और key material शामिल होता है। LeaseSet: किसी destination से संपर्क करने के लिए आवश्यक जानकारी शामिल होती है (tunnel gateways, समाप्ति समय, encryption keys)। राउटर अपनी RouterInfo सीधे netDb में प्रकाशित करते हैं; गुमनामी के लिए LeaseSets को आउटबाउंड tunnels के माध्यम से भेजा जाता है।\nटनल बनाने के लिए, Alice पीयर चुनने के लिए netDb से RouterInfo प्रविष्टियों को क्वेरी करती है, और टनल पूर्ण होने तक एन्क्रिप्टेड टनल बिल्ड संदेशों को hop-by-hop भेजती है।\nचित्र 2: टनल बनाने के लिए राउटर जानकारी का उपयोग किया जाता है।\nबॉब को भेजने के लिए, एलिस बॉब के LeaseSet को देखती है और अपनी outbound tunnels में से एक का उपयोग करके बॉब के inbound tunnel gateway के माध्यम से डेटा भेजती है।\nचित्र 3: LeaseSets outbound और inbound tunnels को जोड़ते हैं।\nक्योंकि I2P संदेश-आधारित है, यह संदेशों को outbound endpoint या inbound gateway से भी सुरक्षित रखने के लिए एंड-टू-एंड garlic encryption जोड़ता है। एक garlic संदेश कई एन्क्रिप्टेड \u0026ldquo;cloves\u0026rdquo; (संदेशों) को लपेटता है ताकि metadata को छिपाया जा सके और गुमनामी में सुधार हो सके।\nएप्लिकेशन या तो सीधे मैसेज इंटरफेस का उपयोग कर सकते हैं या विश्वसनीय कनेक्शन के लिए streaming library पर निर्भर रह सकते हैं।\nTunnels इनबाउंड और आउटबाउंड दोनों tunnels लेयर्ड एन्क्रिप्शन का उपयोग करते हैं, लेकिन निर्माण में भिन्न होते हैं:\ninbound tunnels में, creator (endpoint) सभी layers को decrypt करता है। outbound tunnels में, creator (gateway) endpoint पर स्पष्टता सुनिश्चित करने के लिए layers को पहले से decrypt करता है। I2P peers को अप्रत्यक्ष मेट्रिक्स जैसे लेटेंसी और विश्वसनीयता के माध्यम से प्रोफाइल करता है, बिना सीधे जांच किए। इन प्रोफाइल के आधार पर, peers को गतिशील रूप से चार श्रेणियों में समूहीकृत किया जाता है:\nतेज़ और उच्च क्षमता उच्च क्षमता विफल नहीं हो रहा विफल हो रहा टनल पीयर चयन आमतौर पर उच्च-क्षमता वाले पीयर्स को प्राथमिकता देता है, जिन्हें गुमनामी और प्रदर्शन को संतुलित करने के लिए यादृच्छिक रूप से चुना जाता है, साथ ही पूर्ववर्ती हमलों और netDb हार्वेस्टिंग को कम करने के लिए अतिरिक्त XOR-आधारित क्रमबद्धता रणनीतियों का उपयोग किया जाता है।\nअधिक विस्तृत जानकारी के लिए, Tunnel Specification देखें।\nअवलोकन floodfill distributed hash table (DHT) में भाग लेने वाले routers LeaseSet lookups को संग्रहीत करते हैं और उनका जवाब देते हैं। DHT Kademlia के एक variant का उपयोग करता है। Floodfill routers को स्वचालित रूप से चुना जाता है यदि उनके पास पर्याप्त क्षमता और स्थिरता है, या उन्हें मैन्युअल रूप से कॉन्फ़िगर किया जा सकता है।\nRouterInfo: एक router की क्षमताओं और transports का वर्णन करता है। LeaseSet: एक destination के tunnels और एन्क्रिप्शन keys का वर्णन करता है। netDb में सभी डेटा प्रकाशक द्वारा हस्ताक्षरित और टाइमस्टैम्प किया जाता है ताकि replay या stale entry हमलों को रोका जा सके। टाइमिंग सिंक्रनाइज़ेशन SNTP और ट्रांसपोर्ट-लेयर skew डिटेक्शन के माध्यम से बनाए रखा जाता है।\nAdditional concepts अप्रकाशित और एन्क्रिप्टेड LeaseSets:\nएक destination निजी रह सकता है अपने LeaseSet को प्रकाशित न करके, इसे केवल विश्वसनीय peers के साथ साझा करके। पहुंच के लिए उपयुक्त decryption key की आवश्यकता होती है।\nBootstrapping (reseeding):\nनेटवर्क में शामिल होने के लिए, एक नया router विश्वसनीय HTTPS reseed servers से हस्ताक्षरित RouterInfo फाइलें प्राप्त करता है।\nलुकअप स्केलेबिलिटी:\nI2P DHT स्केलेबिलिटी और सुरक्षा में सुधार के लिए पुनरावर्ती के बजाय पुनरावृत्त लुकअप का उपयोग करता है।\nTunnels आधुनिक I2P संचार दो पूर्णतः एन्क्रिप्टेड transports का उपयोग करता है:\nNTCP2 : एन्क्रिप्टेड TCP-आधारित प्रोटोकॉल SSU2 : एन्क्रिप्टेड UDP-आधारित प्रोटोकॉल दोनों आधुनिक Noise Protocol Framework पर निर्मित हैं, जो मजबूत प्रमाणीकरण और ट्रैफ़िक फ़िंगरप्रिंटिंग के प्रति प्रतिरोध प्रदान करते हैं। इन्होंने लीगेसी NTCP और SSU protocols को प्रतिस्थापित किया (2023 से पूर्णतः सेवानिवृत्त)।\nNTCP2 TCP पर एन्क्रिप्टेड, कुशल स्ट्रीमिंग प्रदान करता है।\nSSU2 UDP-आधारित विश्वसनीयता, NAT ट्रैवर्सल, और वैकल्पिक होल पंचिंग प्रदान करता है। SSU2 अवधारणात्मक रूप से WireGuard या QUIC के समान है, जो विश्वसनीयता और गुमनामी को संतुलित करता है।\nराउटर IPv4 और IPv6 दोनों का समर्थन कर सकते हैं, netDb में अपने ट्रांसपोर्ट पते और लागत प्रकाशित करते हैं। कनेक्शन का ट्रांसपोर्ट एक बिडिंग सिस्टम द्वारा गतिशील रूप से चुना जाता है जो परिस्थितियों और मौजूदा लिंक के लिए अनुकूलित होता है।\nनेटवर्क डेटाबेस (netDb) I2P सभी घटकों के लिए स्तरित क्रिप्टोग्राफी का उपयोग करता है: transports, tunnels, garlic messages, और network database।\nवर्तमान primitives में शामिल हैं:\nX25519 कुंजी विनिमय के लिए EdDSA (Ed25519) हस्ताक्षर के लिए ChaCha20-Poly1305 प्रमाणित एन्क्रिप्शन के लिए SHA-256 हैशिंग के लिए AES256 tunnel परत एन्क्रिप्शन के लिए लीगेसी एल्गोरिदम (ElGamal, DSA-SHA1, ECDSA) पश्चगामी संगतता (backward compatibility) के लिए बने हुए हैं।\nI2P वर्तमान में हाइब्रिड पोस्ट-क्वांटम (PQ) क्रिप्टोग्राफिक योजनाएं पेश कर रहा है जो X25519 को ML-KEM के साथ जोड़ती हैं ताकि \u0026ldquo;अभी संग्रहीत करो, बाद में डिक्रिप्ट करो\u0026rdquo; हमलों का प्रतिरोध किया जा सके।\nGarlic Messages Garlic संदेश onion routing को विस्तारित करते हैं, जिसमें स्वतंत्र वितरण निर्देशों के साथ कई एन्क्रिप्टेड \u0026ldquo;cloves\u0026rdquo; को समूहित किया जाता है। ये संदेश-स्तरीय रूटिंग लचीलापन और समान ट्रैफ़िक पैडिंग की अनुमति देते हैं।\nSession Tags एंड-टू-एंड एन्क्रिप्शन के लिए दो क्रिप्टोग्राफ़िक सिस्टम समर्थित हैं:\nElGamal/AES+SessionTags (लेगेसी):\nपूर्व-वितरित session tags को 32-बाइट nonces के रूप में उपयोग करता है। अब अक्षमता के कारण deprecated है।\nECIES-X25519-AEAD-Ratchet (वर्तमान):\nChaCha20-Poly1305 और समन्वयित HKDF-आधारित PRNGs का उपयोग करके अस्थायी सत्र कुंजियों और 8-बाइट टैग को गतिशील रूप से उत्पन्न करता है, जो CPU, मेमोरी और बैंडविड्थ ओवरहेड को कम करते हुए forward secrecy बनाए रखता है।\nFuture of the Protocol मुख्य अनुसंधान क्षेत्र राज्य-स्तरीय विरोधियों के खिलाफ सुरक्षा बनाए रखने और post-quantum सुरक्षा उपायों को शामिल करने पर केंद्रित हैं। दो प्रारंभिक डिज़ाइन अवधारणाएं — restricted routes और variable latency — आधुनिक विकास द्वारा प्रतिस्थापित कर दी गई हैं।\nRestricted Route Operation मूल प्रतिबंधित रूटिंग अवधारणाओं का उद्देश्य IP पतों को छिपाना था। यह आवश्यकता काफी हद तक कम हो गई है:\nस्वचालित पोर्ट फ़ॉरवर्डिंग के लिए UPnP SSU2 में मजबूत NAT traversal IPv6 समर्थन सहयोगी introducers और NAT hole-punching वैकल्पिक overlay (जैसे, Yggdrasil) कनेक्टिविटी इस प्रकार, आधुनिक I2P जटिल प्रतिबंधित routing के बिना अधिक व्यावहारिक तरीके से समान लक्ष्यों को प्राप्त करता है।\nSimilar Systems I2P, message-oriented middleware, DHTs, और mixnets की अवधारणाओं को एकीकृत करता है। इसकी नवीनता इन्हें एक उपयोगी, स्व-संगठित गुमनामी प्लेटफ़ॉर्म में संयोजित करने में निहित है।\nट्रांसपोर्ट प्रोटोकॉल वेबसाइट Tor और I2P लक्ष्य साझा करते हैं लेकिन वास्तुकला में भिन्न हैं:\nTor: सर्किट-स्विच्ड; विश्वसनीय डायरेक्टरी अथॉरिटीज पर निर्भर। (~10k रिले) I2P: पैकेट-स्विच्ड; पूरी तरह से वितरित DHT-संचालित नेटवर्क। (~50k routers) I2P की एकदिशीय tunnels कम metadata को उजागर करती हैं और लचीले routing paths की अनुमति देती हैं, जबकि Tor गुमनाम इंटरनेट एक्सेस (outproxying) पर केंद्रित है। I2P इसके बजाय गुमनाम in-network hosting का समर्थन करता है।\nक्रिप्टोग्राफी वेबसाइट Freenet गुमनाम, स्थायी फ़ाइल प्रकाशन और पुनर्प्राप्ति पर केंद्रित है। इसके विपरीत, I2P इंटरैक्टिव उपयोग (वेब, चैट, टॉरेंट) के लिए एक रीयल-टाइम संचार परत प्रदान करता है। साथ में, दोनों सिस्टम एक-दूसरे के पूरक हैं — Freenet सेंसरशिप-प्रतिरोधी स्टोरेज प्रदान करता है; I2P परिवहन गुमनामी प्रदान करता है।\nOther Networks Lokinet: प्रोत्साहित सेवा नोड्स का उपयोग करने वाला IP-आधारित ओवरले। Nym: उच्च विलंबता पर कवर ट्रैफ़िक के साथ मेटाडेटा सुरक्षा पर जोर देने वाला नई पीढ़ी का mixnet। Appendix A: Application Layer I2P स्वयं केवल संदेश परिवहन को संभालता है। एप्लिकेशन-लेयर कार्यक्षमता को APIs और लाइब्रेरीज के माध्यम से बाहरी रूप से लागू किया जाता है।\nStreaming Library स्ट्रीमिंग लाइब्रेरी I2P के TCP समकक्ष के रूप में कार्य करती है, जिसमें स्लाइडिंग विंडो प्रोटोकॉल और कंजेशन कंट्रोल शामिल हैं जो उच्च-विलंबता वाले अनाम परिवहन के लिए अनुकूलित हैं।\nसामान्य HTTP अनुरोध/प्रतिक्रिया पैटर्न अक्सर संदेश बंडलिंग अनुकूलन के कारण एकल राउंड-ट्रिप में पूरे हो सकते हैं।\nNaming Library and Address Book विकसित: mihi, Ragnarok द्वारा नामकरण और पता पुस्तिका पृष्ठ देखें।\nI2P की नामकरण प्रणाली स्थानीय और विकेंद्रीकृत है, जो DNS-शैली के वैश्विक नामों से बचती है। प्रत्येक router मानव-पठनीय नामों से destinations तक का स्थानीय मानचित्रण बनाए रखता है। वैकल्पिक web-of-trust-आधारित पता पुस्तिकाएं साझा की जा सकती हैं या विश्वसनीय साथियों से आयात की जा सकती हैं।\nयह दृष्टिकोण केंद्रीकृत प्राधिकरणों से बचता है और वैश्विक या मतदान-शैली की नामकरण प्रणालियों में निहित Sybil कमजोरियों को दरकिनार करता है।\nप्रतिबंधित मार्ग संचालन विकसित: mihi\nI2PTunnel मुख्य client layer इंटरफ़ेस है जो गुमनाम TCP proxying को सक्षम बनाता है। यह समर्थन करता है:\nClient tunnels (I2P गंतव्यों की ओर आउटबाउंड) HTTP client (eepproxy) \u0026ldquo;.i2p\u0026rdquo; डोमेन के लिए Server tunnels (I2P से स्थानीय सेवा की ओर इनबाउंड) HTTP server tunnels (वेब सेवाओं को सुरक्षित रूप से प्रॉक्सी करें) Outproxying (नियमित इंटरनेट तक पहुंच) वैकल्पिक है, जो स्वयंसेवकों द्वारा संचालित \u0026ldquo;server\u0026rdquo; tunnels के माध्यम से लागू किया जाता है।\nI2PSnark विकसित: jrandom, et al — Snark से पोर्ट किया गया\nI2P के साथ बंडल किया गया, I2PSnark एक गुमनाम मल्टी-टॉरेंट BitTorrent क्लाइंट है जिसमें DHT और UDP सपोर्ट है, जो वेब इंटरफ़ेस के माध्यम से उपलब्ध है।\nTor विकसित किया: postman, susi23, mastiejaner द्वारा\nI2Pmail I2PTunnel कनेक्शनों के माध्यम से गुमनाम ईमेल प्रदान करता है। Susimail एक वेब-आधारित क्लाइंट है जो विशेष रूप से पारंपरिक ईमेल क्लाइंटों में आम सूचना रिसाव को रोकने के लिए बनाया गया है। mail.i2p सेवा में अतिरिक्त सुरक्षा के लिए वायरस फ़िल्टरिंग, hashcash कोटा, और outproxy पृथक्करण की सुविधा है।\n","description":"I2P आर्किटेक्चर और संचालन का तकनीकी परिचय","id":"75218044125880755dabbc53c9ce4b06","section":"docs","title":"I2P: गुमनाम संचार के लिए एक स्केलेबल फ्रेमवर्क","url":"/hi/docs/overview/tech-intro/"},{"categories":null,"content":"I2PControl API दस्तावेज़ीकरण I2PControl एक JSON-RPC 2.0 API है जो I2P router के साथ बंडल आता है (संस्करण 0.9.39 से)। यह संरचित JSON अनुरोधों के माध्यम से router की प्रमाणित निगरानी और नियंत्रण को सक्षम बनाता है।\nडिफ़ॉल्ट पासवर्ड: itoopie — यह फ़ैक्टरी डिफ़ॉल्ट है और सुरक्षा के लिए इसे तुरंत बदला जाना चाहिए।\n1. सामान्य परिचय और पहुंच Implementation Default Endpoint Protocol Enabled by Default Notes Java I2P (2.10.0+) http://127.0.0.1:7657/jsonrpc/ HTTP ❌ Must be enabled via WebApps (Router Console) Bundled webapp i2pd (C++ implementation) https://127.0.0.1:7650/ HTTPS ✅ Enabled by default Legacy plugin behavior Java I2P के मामले में, आपको **Router Console → WebApps → I2PControl** पर जाना होगा और इसे सक्षम करना होगा (स्वचालित रूप से शुरू होने के लिए सेट करें)। एक बार सक्रिय होने के बाद, सभी methods के लिए आवश्यक है कि आप पहले प्रमाणित करें और एक session token प्राप्त करें। 2. JSON-RPC प्रारूप सभी अनुरोध JSON-RPC 2.0 संरचना का पालन करते हैं:\n{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;MethodName\u0026#34;, \u0026#34;params\u0026#34;: { /* named parameters */ } } एक सफल प्रतिक्रिया में result फ़ील्ड शामिल होता है; विफलता पर, एक error ऑब्जेक्ट लौटाया जाता है:\n{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;result\u0026#34;: { /* data */ } } या\n{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;error\u0026#34;: { \u0026#34;code\u0026#34;: -32001, \u0026#34;message\u0026#34;: \u0026#34;Invalid password\u0026#34; } } 3. प्रमाणीकरण प्रवाह अनुरोध (प्रमाणीकरण) curl -s -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;Authenticate\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;API\u0026#34;: 1, \u0026#34;Password\u0026#34;: \u0026#34;itoopie\u0026#34; } }\u0026#39; \\ http://127.0.0.1:7657/jsonrpc/ सफल प्रतिक्रिया { \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;result\u0026#34;: { \u0026#34;Token\u0026#34;: \u0026#34;a1b2c3d4e5\u0026#34;, \u0026#34;API\u0026#34;: 1 } } आपको उस Token को सभी बाद के अनुरोधों में params में शामिल करना होगा।\n4. विधियाँ और एंडपॉइंट्स 4.1 RouterInfo राउटर के बारे में मुख्य टेलीमेट्री (telemetry) जानकारी प्राप्त करता है।\nअनुरोध उदाहरण\ncurl -s -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;2\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;RouterInfo\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;Token\u0026#34;: \u0026#34;a1b2c3d4e5\u0026#34;, \u0026#34;i2p.router.version\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;i2p.router.status\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;i2p.router.net.status\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;i2p.router.net.tunnels.participating\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;i2p.router.net.bw.inbound.1s\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;i2p.router.net.bw.outbound.1s\u0026#34;: \u0026#34;\u0026#34; } }\u0026#39; \\ http://127.0.0.1:7657/jsonrpc/ Response Fields (result) आधिकारिक दस्तावेज़ों (GetI2P) के अनुसार: - i2p.router.status (String) — मानव-पठनीय स्थिति - i2p.router.uptime (long) — मिलीसेकंड में (या पुराने i2pd के लिए string) :contentReference[oaicite:0]{index=0} - i2p.router.version (String) — संस्करण string :contentReference[oaicite:1]{index=1} - i2p.router.net.bw.inbound.1s, i2p.router.net.bw.inbound.15s (double) — इनबाउंड बैंडविड्थ B/s में :contentReference[oaicite:2]{index=2} - i2p.router.net.bw.outbound.1s, i2p.router.net.bw.outbound.15s (double) — आउटबाउंड बैंडविड्थ B/s में :contentReference[oaicite:3]{index=3} - i2p.router.net.status (long) — संख्यात्मक स्थिति कोड (नीचे enum देखें) :contentReference[oaicite:4]{index=4} - i2p.router.net.tunnels.participating (long) — participating tunnels की संख्या :contentReference[oaicite:5]{index=5} - i2p.router.netdb.activepeers, fastpeers, highcapacitypeers (long) — netDB पीयर सांख्यिकी :contentReference[oaicite:6]{index=6} - i2p.router.netdb.isreseeding (boolean) — क्या reseed सक्रिय है :contentReference[oaicite:7]{index=7} - i2p.router.netdb.knownpeers (long) — कुल ज्ञात पीयर :contentReference[oaicite:8]{index=8}\nस्टेटस कोड Enum (i2p.router.net.status) Code Meaning 0 OK 1 TESTING 2 FIREWALLED 3 HIDDEN 4 WARN_FIREWALLED_AND_FAST 5 WARN_FIREWALLED_AND_FLOODFILL 6 WARN_FIREWALLED_WITH_INBOUND_TCP 7 WARN_FIREWALLED_WITH_UDP_DISABLED 8 ERROR_I2CP 9 ERROR_CLOCK_SKEW 10 ERROR_PRIVATE_TCP_ADDRESS 11 ERROR_SYMMETRIC_NAT 12 ERROR_UDP_PORT_IN_USE 13 ERROR_NO_ACTIVE_PEERS_CHECK_CONNECTION_AND_FIREWALL 14 ERROR_UDP_DISABLED_AND_TCP_UNSET --- 4.2 GetRate दिए गए समय अंतराल में दर मेट्रिक्स (जैसे bandwidth, tunnel success) प्राप्त करने के लिए उपयोग किया जाता है।\nअनुरोध उदाहरण\ncurl -s -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;3\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;GetRate\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;Token\u0026#34;: \u0026#34;a1b2c3d4e5\u0026#34;, \u0026#34;Stat\u0026#34;: \u0026#34;bw.combined\u0026#34;, \u0026#34;Period\u0026#34;: 60000 } }\u0026#39; \\ http://127.0.0.1:7657/jsonrpc/ नमूना प्रतिक्रिया\n{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;3\u0026#34;, \u0026#34;result\u0026#34;: { \u0026#34;Rate\u0026#34;: 12345.67 } } 4.3 RouterManager प्रशासनिक कार्य करें।\nअनुमत पैरामीटर / विधियाँ - Restart, RestartGraceful - Shutdown, ShutdownGraceful - Reseed, FindUpdates, Update :contentReference[oaicite:10]{index=10}\nअनुरोध उदाहरण\ncurl -s -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;4\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;RouterManager\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;Token\u0026#34;: \u0026#34;a1b2c3d4e5\u0026#34;, \u0026#34;Restart\u0026#34;: true } }\u0026#39; \\ http://127.0.0.1:7657/jsonrpc/ सफल प्रतिक्रिया\n{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;4\u0026#34;, \u0026#34;result\u0026#34;: { \u0026#34;Restart\u0026#34;: null } } 4.4 नेटवर्क सेटिंग नेटवर्क कॉन्फ़िगरेशन पैरामीटर प्राप्त करें या सेट करें (ports, upnp, bandwidth share, आदि)\nअनुरोध उदाहरण (वर्तमान मान प्राप्त करें)\ncurl -s -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;5\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;NetworkSetting\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;Token\u0026#34;: \u0026#34;a1b2c3d4e5\u0026#34;, \u0026#34;i2p.router.net.ntcp.port\u0026#34;: null, \u0026#34;i2p.router.net.ssu.port\u0026#34;: null, \u0026#34;i2p.router.net.bw.share\u0026#34;: null, \u0026#34;i2p.router.net.upnp\u0026#34;: null } }\u0026#39; \\ http://127.0.0.1:7657/jsonrpc/ नमूना प्रतिक्रिया\n{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;5\u0026#34;, \u0026#34;result\u0026#34;: { \u0026#34;i2p.router.net.ntcp.port\u0026#34;: \u0026#34;1234\u0026#34;, \u0026#34;i2p.router.net.ssu.port\u0026#34;: \u0026#34;5678\u0026#34;, \u0026#34;i2p.router.net.bw.share\u0026#34;: \u0026#34;50\u0026#34;, \u0026#34;i2p.router.net.upnp\u0026#34;: \u0026#34;true\u0026#34;, \u0026#34;SettingsSaved\u0026#34;: true, \u0026#34;RestartNeeded\u0026#34;: false } } नोट: 2.41 से पहले के i2pd संस्करण स्ट्रिंग्स के बजाय न्यूमेरिक प्रकार लौटा सकते हैं — क्लाइंट्स को दोनों को हैंडल करना चाहिए। :contentReference[oaicite:11]{index=11}\n4.5 उन्नत सेटिंग्स आंतरिक राउटर पैरामीटर्स में बदलाव करने की अनुमति देता है।\nअनुरोध उदाहरण\ncurl -s -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;6\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;AdvancedSettings\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;Token\u0026#34;: \u0026#34;a1b2c3d4e5\u0026#34;, \u0026#34;Set\u0026#34;: { \u0026#34;router.sharePercentage\u0026#34;: \u0026#34;75\u0026#34;, \u0026#34;i2np.flushInterval\u0026#34;: \u0026#34;6000\u0026#34; } } }\u0026#39; \\ http://127.0.0.1:7657/jsonrpc/ प्रतिक्रिया उदाहरण\n{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;6\u0026#34;, \u0026#34;result\u0026#34;: { \u0026#34;Set\u0026#34;: { \u0026#34;router.sharePercentage\u0026#34;: \u0026#34;75\u0026#34;, \u0026#34;i2np.flushInterval\u0026#34;: \u0026#34;6000\u0026#34; } } } 5. त्रुटि कोड मानक JSON-RPC त्रुटियों (-32700, -32600, आदि) के अलावा, I2PControl परिभाषित करता है:\nCode Meaning -32001 Invalid password -32002 Missing token -32003 Token does not exist -32004 Token expired -32005 API version missing -32006 API version unsupported --- 6. उपयोग और सर्वोत्तम प्रथाएं हमेशा Token पैरामीटर शामिल करें (प्रमाणीकरण के समय को छोड़कर)। पहली बार उपयोग करते समय डिफ़ॉल्ट पासवर्ड (itoopie) बदलें। Java I2P के लिए, सुनिश्चित करें कि I2PControl webapp, WebApps के माध्यम से सक्षम है। थोड़े बदलावों के लिए तैयार रहें: कुछ फ़ील्ड संख्याएँ या स्ट्रिंग हो सकती हैं, I2P संस्करण पर निर्भर करते हुए। प्रदर्शन-अनुकूल आउटपुट के लिए लंबी स्टेटस स्ट्रिंग को व्रैप करें। ","description":"I2PControl वेबऐप के माध्यम से रिमोट राउटर प्रबंधन API","id":"f0e7aa57ce714931128f06f6bdb94db3","section":"docs","title":"I2PControl JSON-RPC","url":"/hi/docs/api/i2pcontrol/"},{"categories":null,"content":"अवलोकन I2PTunnel एक मुख्य I2P घटक है जो I2P नेटवर्क पर इंटरफेसिंग और सेवाएं प्रदान करने के लिए है। यह tunnel abstraction के माध्यम से TCP-आधारित और मीडिया स्ट्रीमिंग अनुप्रयोगों को गुमनाम रूप से संचालित करने में सक्षम बनाता है। एक tunnel का गंतव्य hostname , Base32 , या एक पूर्ण destination key द्वारा परिभाषित किया जा सकता है।\nप्रत्येक स्थापित tunnel स्थानीय रूप से सुनता है (जैसे, localhost:port) और आंतरिक रूप से I2P destinations से जुड़ता है। एक सेवा होस्ट करने के लिए, वांछित IP और port की ओर इंगित करने वाला एक tunnel बनाएं। एक संबंधित I2P destination key उत्पन्न की जाती है, जो सेवा को I2P network के भीतर विश्व स्तर पर पहुंच योग्य बनाती है। I2PTunnel वेब इंटरफ़ेस I2P Router Tunnel Manager पर उपलब्ध है।\nडिफ़ॉल्ट सेवाएं सर्वर tunnel I2P Webserver – I2P पर आसान होस्टिंग के लिए localhost:7658 पर एक Jetty webserver के लिए tunnel। Unix: $HOME/.i2p/eepsite/docroot Windows: %LOCALAPPDATA%\\I2P\\I2P Site\\docroot → C:\\Users\\\u0026lt;username\u0026gt;\\AppData\\Local\\I2P\\I2P Site\\docroot क्लाइंट टनल I2P HTTP Proxy – localhost:4444 – I2P और outproxies के माध्यम से इंटरनेट ब्राउज़ करने के लिए उपयोग किया जाता है। I2P HTTPS Proxy – localhost:4445 – HTTP proxy का सुरक्षित संस्करण। Irc2P – localhost:6668 – डिफ़ॉल्ट अनाम IRC नेटवर्क tunnel। Git SSH (gitssh.idk.i2p) – localhost:7670 – रिपॉज़िटरी SSH एक्सेस के लिए क्लाइंट tunnel। Postman SMTP – localhost:7659 – आउटगोइंग मेल के लिए क्लाइंट tunnel। Postman POP3 – localhost:7660 – इनकमिंग मेल के लिए क्लाइंट tunnel। नोट: केवल I2P Webserver एक डिफ़ॉल्ट server tunnel है; अन्य सभी client tunnels हैं जो बाहरी I2P सेवाओं से कनेक्ट होते हैं।\nकॉन्फ़िगरेशन I2PTunnel कॉन्फ़िगरेशन विनिर्देश /spec/configuration पर प्रलेखित है।\nक्लाइंट मोड मानक एक स्थानीय TCP पोर्ट खोलता है जो I2P destination पर किसी सेवा से कनेक्ट होता है। redundancy के लिए अल्पविराम से अलग किए गए एकाधिक destination entries का समर्थन करता है।\nHTTP HTTP/HTTPS अनुरोधों के लिए एक प्रॉक्सी tunnel। स्थानीय और दूरस्थ outproxies, हेडर स्ट्रिपिंग, कैशिंग, प्रमाणीकरण, और पारदर्शी संपीड़न का समर्थन करता है।\nगोपनीयता सुरक्षा: - headers को हटाता है: Accept-*, Referer, Via, From - host headers को Base32 destinations के साथ प्रतिस्थापित करता है - RFC-अनुरूप hop-by-hop stripping को लागू करता है - पारदर्शी decompression के लिए समर्थन जोड़ता है - आंतरिक error pages और स्थानीयकृत responses प्रदान करता है\nकम्प्रेशन व्यवहार: - अनुरोध कस्टम हेडर X-Accept-Encoding: x-i2p-gzip का उपयोग कर सकते हैं - Content-Encoding: x-i2p-gzip वाली प्रतिक्रियाएं स्वचालित रूप से डीकम्प्रेस की जाती हैं - दक्षता के लिए MIME प्रकार और प्रतिक्रिया लंबाई के आधार पर कम्प्रेशन का मूल्यांकन किया जाता है\nस्थायित्व (2.5.0 के बाद से नया): HTTP Keepalive और persistent connections अब Hidden Services Manager के माध्यम से I2P-होस्टेड सेवाओं के लिए समर्थित हैं। यह विलंबता और कनेक्शन ओवरहेड को कम करता है लेकिन अभी तक सभी hops में पूर्ण RFC 2616-अनुरूप persistent sockets को सक्षम नहीं करता है।\nपाइपलाइनिंग: असमर्थित और अनावश्यक बनी हुई है; आधुनिक ब्राउज़रों ने इसे पदावनत कर दिया है।\nUser-Agent व्यवहार: - Outproxy: वर्तमान Firefox ESR User-Agent का उपयोग करता है। - Internal: गुमनामी स्थिरता के लिए MYOB/6.66 (AN/ON)।\nIRC क्लाइंट I2P-आधारित IRC सर्वरों से कनेक्ट करता है। गोपनीयता के लिए पहचानकर्ताओं को फ़िल्टर करते हुए कमांड के सुरक्षित सबसेट की अनुमति देता है।\nSOCKS 4/4a/5 TCP कनेक्शन के लिए SOCKS proxy क्षमता प्रदान करता है। UDP अभी तक Java I2P में लागू नहीं किया गया है (केवल i2pd में उपलब्ध है)।\nCONNECT SSL/TLS कनेक्शनों के लिए HTTP CONNECT टनलिंग को लागू करता है।\nStreamr TCP-आधारित encapsulation के माध्यम से UDP-शैली स्ट्रीमिंग सक्षम करता है। संबंधित Streamr सर्वर tunnel के साथ जोड़े जाने पर मीडिया स्ट्रीमिंग का समर्थन करता है।\nसर्वर मोड मानक सर्वर एक TCP गंतव्य बनाता है जो स्थानीय IP:port से मैप होता है।\nHTTP सर्वर एक destination बनाता है जो स्थानीय वेब सर्वर के साथ इंटरफेस करता है। कम्प्रेशन (x-i2p-gzip), हेडर स्ट्रिपिंग, और DDoS सुरक्षा का समर्थन करता है। अब persistent connection support (v2.5.0+) और thread pooling optimization (v2.7.0–2.9.0) से लाभान्वित होता है।\nHTTP द्विदिशात्मक पदावनत – अभी भी कार्यात्मक है लेकिन हतोत्साहित। बिना outproxying के HTTP सर्वर और क्लाइंट दोनों के रूप में कार्य करता है। मुख्य रूप से डायग्नोस्टिक loopback परीक्षणों के लिए उपयोग किया जाता है।\nIRC सर्वर IRC सेवाओं के लिए एक फ़िल्टर किया गया destination बनाता है, जो client destination keys को hostnames के रूप में पास करता है।\nStreamr सर्वर I2P के माध्यम से UDP-शैली के डेटा स्ट्रीम को संभालने के लिए Streamr client tunnel के साथ युग्मित।\nनई सुविधाएँ (2.4.0–2.10.0) Feature Introduced Summary Keepalive/Persistent Connections 2.5.0 HTTP tunnels now support persistent sockets for I2P-hosted services, improving performance. Thread Pooling Optimization 2.7.0-2.9.0 Reduced CPU overhead and latency by improving thread management. Post-Quantum Encryption (ML-KEM) 2.10.0 Optional hybrid X25519+ML-KEM encryption to resist future quantum attacks. NetDB Segmentation 2.4.0 Isolates I2PTunnel contexts for improved security and privacy. SSU1 Removal / SSU2 Adoption 2.4.0-2.6.0 Upgraded transport layer; transparent to users. I2P-over-Tor Blocking 2.6.0 Prevents inefficient and unstable I2P-over-Tor routing. Browser Proxy (Proposal 166) 2.7.0 Introduced identity-aware proxy mode; details pending confirmation. Java 17 Requirement (upcoming) 2.11.0 Future release will require Java 17+. --- सुरक्षा सुविधाएँ गुमनामी के लिए Header stripping (Accept, Referer, From, Via) in/outproxy के आधार पर User-Agent randomization POST rate limiting और Slowloris protection streaming subsystems में Connection throttling tunnel layer पर Network congestion handling क्रॉस-एप्लिकेशन लीक को रोकने वाला NetDB isolation तकनीकी विवरण डिफ़ॉल्ट destination key का आकार: 516 बाइट्स (विस्तारित LS2 प्रमाणपत्रों के लिए अधिक हो सकता है) Base32 पते: {52–56+ chars}.b32.i2p Server tunnels Java I2P और i2pd दोनों के साथ संगत रहते हैं पदावनत सुविधा: केवल httpbidirserver; 0.9.59 के बाद से कोई हटाव नहीं सभी प्लेटफ़ॉर्म के लिए सही डिफ़ॉल्ट पोर्ट और document roots की पुष्टि की गई सारांश I2PTunnel, I2P के साथ एप्लिकेशन एकीकरण की रीढ़ बना हुआ है। 0.9.59 और 2.10.0 के बीच, इसमें स्थायी कनेक्शन समर्थन, post-quantum encryption, और थ्रेडिंग में बड़े सुधार जोड़े गए। अधिकांश कॉन्फ़िगरेशन संगत रहते हैं, लेकिन डेवलपर्स को अपने सेटअप की जांच करनी चाहिए ताकि यह सुनिश्चित हो सके कि वे आधुनिक ट्रांसपोर्ट और सुरक्षा डिफ़ॉल्ट के अनुरूप हैं।\n","description":"I2P पर इंटरफेस करने और सेवाएं प्रदान करने के लिए उपकरण","id":"7e5d426e3eead28c1767764107b1f3d1","section":"docs","title":"I2PTunnel","url":"/hi/docs/api/i2ptunnel/"},{"categories":null,"content":"आपको क्या चाहिए होगा macOS 10.14 (Mojave) या बाद के संस्करण वाला Mac एप्लिकेशन इंस्टॉल करने के लिए Administrator एक्सेस लगभग 15-20 मिनट का समय इंस्टॉलर डाउनलोड करने के लिए इंटरनेट कनेक्शन सामान्य विवरण इस इंस्टॉलेशन प्रक्रिया में चार मुख्य चरण हैं:\nJava इंस्टॉल करें - Oracle Java Runtime Environment डाउनलोड और इंस्टॉल करें I2P इंस्टॉल करें - I2P installer डाउनलोड और चलाएं I2P App कॉन्फ़िगर करें - launcher सेट अप करें और अपने dock में जोड़ें I2P Bandwidth कॉन्फ़िगर करें - अपने कनेक्शन को ऑप्टिमाइज़ करने के लिए setup wizard चलाएं भाग एक: Java इंस्टॉल करें I2P को चलाने के लिए Java की आवश्यकता होती है। यदि आपके पास पहले से Java 8 या बाद का संस्करण इंस्टॉल है, तो आप भाग दो पर जा सकते हैं ।\nStep 1: Download Java Oracle Java डाउनलोड पेज पर जाएं और Java 8 या बाद के संस्करण के लिए macOS installer डाउनलोड करें।\nStep 2: Run the Installer अपने Downloads फ़ोल्डर में डाउनलोड की गई .dmg फ़ाइल को ढूंढें और इसे खोलने के लिए डबल-क्लिक करें।\nStep 3: Allow Installation macOS एक सुरक्षा प्रॉम्प्ट प्रदर्शित कर सकता है क्योंकि इंस्टॉलर एक पहचाने गए डेवलपर से है। आगे बढ़ने के लिए Open पर क्लिक करें।\nचरण 1: Java डाउनलोड करें Java इंस्टॉलेशन प्रक्रिया शुरू करने के लिए Install पर क्लिक करें।\nचरण 2: इंस्टॉलर चलाएं इंस्टॉलर आपके सिस्टम पर फ़ाइलें कॉपी करेगा और Java को कॉन्फ़िगर करेगा। इसमें आमतौर पर 1-2 मिनट लगते हैं।\nचरण 3: इंस्टॉलेशन की अनुमति दें जब आप सफलता संदेश देखें, तो Java इंस्टॉल हो गया है! समाप्त करने के लिए Close पर क्लिक करें।\nPart Two: Download and Install I2P अब जब Java इंस्टॉल हो गया है, आप I2P router इंस्टॉल कर सकते हैं।\nचरण 4: Java इंस्टॉल करें Downloads पेज पर जाएं और I2P for Unix/Linux/BSD/Solaris installer (.jar फ़ाइल) डाउनलोड करें।\nचरण 5: इंस्टॉलेशन का इंतजार करें डाउनलोड की गई i2pinstall_X.X.X.jar फ़ाइल पर डबल-क्लिक करें। इंस्टॉलर लॉन्च होगा और आपसे अपनी पसंदीदा भाषा चुनने के लिए कहेगा।\nचरण 6: स्थापना पूर्ण स्वागत संदेश पढ़ें और जारी रखने के लिए Next पर क्लिक करें।\nStep 4: Important Notice इंस्टॉलर अपडेट के बारे में एक महत्वपूर्ण सूचना प्रदर्शित करेगा। I2P अपडेट end-to-end signed और सत्यापित हैं, भले ही यह इंस्टॉलर स्वयं unsigned है। Next पर क्लिक करें।\nचरण 1: I2P डाउनलोड करें I2P लाइसेंस समझौता (BSD-शैली लाइसेंस) पढ़ें। स्वीकार करने के लिए Next पर क्लिक करें।\nचरण 2: इंस्टॉलर चलाएं I2P को कहाँ इंस्टॉल करना है, चुनें। डिफ़ॉल्ट लोकेशन (/Applications/i2p) की सिफारिश की जाती है। Next पर क्लिक करें।\nचरण 3: स्वागत स्क्रीन सभी घटकों को पूर्ण इंस्टॉलेशन के लिए चयनित छोड़ दें। Next पर क्लिक करें।\nचरण 4: महत्वपूर्ण सूचना अपनी पसंद की समीक्षा करें और I2P इंस्टॉल करना शुरू करने के लिए Next पर क्लिक करें।\nचरण 5: लाइसेंस समझौता इंस्टॉलर आपके सिस्टम में I2P फाइलें कॉपी करेगा। इसमें लगभग 1-2 मिनट लगते हैं।\nचरण 6: इंस्टॉलेशन डायरेक्टरी चुनें इंस्टॉलर I2P को शुरू करने के लिए लॉन्च स्क्रिप्ट बनाता है।\nचरण 7: घटक चुनें इंस्टॉलर डेस्कटॉप शॉर्टकट और मेनू एंट्रीज़ बनाने का विकल्प देता है। अपना चयन करें और Next पर क्लिक करें।\nचरण 8: इंस्टॉलेशन शुरू करें सफलता! I2P अब इंस्टॉल हो गया है। समाप्त करने के लिए Done पर क्लिक करें।\nPart Three: Configure I2P App अब आइए I2P को अपने Applications फ़ोल्डर और Dock में जोड़कर इसे आसानी से लॉन्च करने योग्य बनाएं।\nचरण 9: फ़ाइलें इंस्टॉल करना Finder खोलें और अपने Applications फ़ोल्डर पर जाएँ।\nचरण 10: लॉन्च स्क्रिप्ट जेनरेट करें /Applications/i2p/ के अंदर I2P फ़ोल्डर या Start I2P Router एप्लिकेशन को खोजें।\nचरण 11: इंस्टॉलेशन शॉर्टकट्स आसान पहुंच के लिए Start I2P Router एप्लिकेशन को अपने Dock में ड्रैग करें। आप अपने डेस्कटॉप पर एक alias भी बना सकते हैं।\nटिप: Dock में I2P आइकन पर राइट-क्लिक करें और इसे स्थायी बनाने के लिए Options → Keep in Dock चुनें।\nPart Four: Configure I2P Bandwidth जब आप पहली बार I2P लॉन्च करते हैं, तो आप अपनी bandwidth सेटिंग्स को कॉन्फ़िगर करने के लिए एक सेटअप विज़ार्ड से गुज़रेंगे। यह आपके कनेक्शन के लिए I2P के प्रदर्शन को अनुकूलित करने में मदद करता है।\nचरण 12: इंस्टॉलेशन पूर्ण अपने Dock में I2P आइकन पर क्लिक करें (या launcher पर डबल-क्लिक करें)। आपका डिफ़ॉल्ट वेब ब्राउज़र I2P Router Console पर खुल जाएगा।\nStep 2: Welcome Wizard सेटअप विज़ार्ड आपका स्वागत करेगा। I2P को कॉन्फ़िगर करना शुरू करने के लिए Next पर क्लिक करें।\nचरण 1: Applications फ़ोल्डर खोलें अपनी पसंदीदा interface language चुनें और light या dark थीम के बीच चयन करें। Next पर क्लिक करें।\nचरण 2: I2P Launcher खोजें विज़ार्ड बैंडविड्थ टेस्ट की व्याख्या करेगा। यह टेस्ट आपकी इंटरनेट स्पीड को मापने के लिए M-Lab सेवा से कनेक्ट होता है। आगे बढ़ने के लिए Next पर क्लिक करें।\nचरण 3: Dock में जोड़ें Run Test पर क्लिक करें अपनी अपलोड और डाउनलोड स्पीड मापने के लिए। टेस्ट में लगभग 30-60 सेकंड लगते हैं।\nStep 6: Test Results अपने परीक्षण परिणामों की समीक्षा करें। I2P आपकी कनेक्शन गति के आधार पर बैंडविड्थ सेटिंग्स की सिफारिश करेगा।\nचरण 1: I2P लॉन्च करें चुनें कि आप I2P नेटवर्क के साथ कितनी bandwidth साझा करना चाहते हैं:\nस्वचालित (अनुशंसित): I2P आपके उपयोग के आधार पर बैंडविड्थ का प्रबंधन करता है सीमित: विशिष्ट अपलोड/डाउनलोड सीमाएं निर्धारित करें असीमित: जितना संभव हो उतना साझा करें (तेज़ कनेक्शन के लिए) अपनी सेटिंग्स को सेव करने के लिए Next पर क्लिक करें।\nचरण 2: स्वागत विज़ार्ड आपका I2P router अब कॉन्फ़िगर और चालू है! router console आपकी कनेक्शन स्थिति दिखाएगा और आपको I2P साइटों को ब्राउज़ करने की अनुमति देगा।\nGetting Started with I2P अब जब I2P इंस्टॉल और कॉन्फ़िगर हो गया है, तो आप कर सकते हैं:\nI2P साइटों को ब्राउज़ करें: लोकप्रिय I2P सेवाओं के लिंक देखने के लिए I2P होमपेज पर जाएं अपना ब्राउज़र कॉन्फ़िगर करें: .i2p साइटों तक पहुँचने के लिए एक ब्राउज़र प्रोफ़ाइल सेट अप करें सेवाओं का अन्वेषण करें: I2P ईमेल, फ़ोरम, फ़ाइल शेयरिंग, और अधिक देखें अपने router की निगरानी करें: console आपके नेटवर्क की स्थिति और सांख्यिकी दिखाता है चरण 3: भाषा और थीम Router Console: http://127.0.0.1:7657/ कॉन्फ़िगरेशन: http://127.0.0.1:7657/config Address Book: http://127.0.0.1:7657/susidns/addressbook बैंडविड्थ सेटिंग्स: http://127.0.0.1:7657/config Re-running the Setup Wizard यदि आप अपनी bandwidth सेटिंग्स बदलना चाहते हैं या बाद में I2P को फिर से configure करना चाहते हैं, तो आप Router Console से welcome wizard को फिर से चला सकते हैं:\nI2P Setup Wizard पर जाएं wizard के चरणों को फिर से फॉलो करें Troubleshooting चरण 4: बैंडविड्थ परीक्षण जानकारी Java की जाँच करें: Terminal में java -version चलाकर सुनिश्चित करें कि Java इंस्टॉल है अनुमतियों की जाँच करें: सुनिश्चित करें कि I2P फ़ोल्डर में सही अनुमतियाँ हैं लॉग की जाँच करें: त्रुटि संदेशों के लिए ~/.i2p/wrapper.log देखें चरण 5: बैंडविड्थ परीक्षण चलाएं सुनिश्चित करें कि I2P चल रहा है (Router Console जांचें) अपने ब्राउज़र की proxy सेटिंग्स को HTTP proxy 127.0.0.1:4444 उपयोग करने के लिए कॉन्फ़िगर करें नेटवर्क में I2P के एकीकृत होने के लिए शुरू करने के बाद 5-10 मिनट प्रतीक्षा करें चरण 6: परीक्षण परिणाम बैंडविड्थ टेस्ट को फिर से चलाएं और अपनी सेटिंग्स को समायोजित करें सुनिश्चित करें कि आप नेटवर्क के साथ कुछ बैंडविड्थ साझा कर रहे हैं Router Console में अपनी कनेक्शन स्थिति की जांच करें भाग दो: I2P डाउनलोड और इंस्टॉल करें अपने Mac से I2P को हटाने के लिए:\nयदि I2P router चल रहा है तो उसे बंद करें /Applications/i2p फ़ोल्डर को डिलीट करें ~/.i2p फ़ोल्डर को डिलीट करें (आपकी I2P कॉन्फ़िगरेशन और डेटा) अपने Dock से I2P आइकन को हटाएं Next Steps समुदाय से जुड़ें: i2pforum.net पर जाएं या Reddit पर I2P देखें और जानें: नेटवर्क कैसे काम करता है यह समझने के लिए I2P documentation पढ़ें शामिल हों: I2P विकास में योगदान करने या infrastructure चलाने पर विचार करें बधाई हो! अब आप I2P नेटवर्क का हिस्सा हैं। Invisible Internet में आपका स्वागत है!\nमुझे खेद है, लेकिन आपने मुझे अनुवाद करने के लिए कोई टेक्स्ट प्रदान नहीं किया है। कृपया \u0026ldquo;\u0026mdash;\u0026rdquo; के बाद जो टेक्स्ट आप अनुवादित करना चाहते हैं उसे शामिल करें, और मैं आपके लिए उसका अनुवाद कर दूंगा।\n","description":"macOS पर I2P और इसकी dependencies को मैन्युअली इंस्टॉल करने के लिए चरण-दर-चरण गाइड","id":"f88100195c365b18735e1ea12826a97e","section":"docs","title":"macOS पर I2P इंस्टॉल करना (विस्तृत तरीका)","url":"/hi/docs/guides/macos-%E0%A4%AA%E0%A4%B0-i2p-%E0%A4%87%E0%A4%82%E0%A4%B8%E0%A5%8D%E0%A4%9F%E0%A5%89%E0%A4%B2-%E0%A4%95%E0%A4%B0%E0%A4%A8%E0%A4%BE-%E0%A4%B5%E0%A4%BF%E0%A4%B8%E0%A5%8D%E0%A4%A4%E0%A5%83%E0%A4%A4-%E0%A4%A4%E0%A4%B0%E0%A5%80%E0%A4%95%E0%A4%BE/"},{"categories":null,"content":"NTCP बनाम SSU चर्चा (मार्च 2007) NTCP संबंधी प्रश्न zzz और cervantes के बीच हुआ IRC वार्तालाप से अनुकूलित.\nजब NTCP ओवरहेड और विलंब जोड़ता हुआ प्रतीत होता है, तब SSU पर NTCP को प्राथमिकता क्यों दी जाती है?\nNTCP आम तौर पर मूल SSU कार्यान्वयन की तुलना में बेहतर विश्वसनीयता प्रदान करता है। क्या NTCP पर स्ट्रीमिंग क्लासिक TCP-over-TCP collapse (ओवरलैपिंग TCP परतों के कारण प्रदर्शन का पतन) में फँसती है?\nसंभव है, लेकिन SSU को हल्के UDP विकल्प के रूप में डिज़ाइन किया गया था और व्यवहार में यह अत्यंत अविश्वसनीय साबित हुआ। “NTCP को हानिकारक माना जाता है” (zzz, 25 मार्च, 2007) सारांश: NTCP की अधिक विलंबता और ओवरहेड कंजेशन (भीड़भाड़) का कारण बन सकते हैं, फिर भी रूटिंग NTCP को प्राथमिकता देती है क्योंकि इसके बिड स्कोर SSU की तुलना में कम मान पर हार्ड-कोड किए गए हैं। विश्लेषण ने कई बिंदु उठाए:\nNTCP (I2P का TCP-आधारित ट्रांसपोर्ट) वर्तमान में SSU की तुलना में कम बोली लगाता है, इसलिए routers तब तक NTCP को प्राथमिकता देते हैं जब तक कोई SSU सत्र पहले से स्थापित न हो। SSU कड़े सीमाबद्ध timeouts और सांख्यिकी के साथ acknowledgements लागू करता है; NTCP Java NIO TCP पर निर्भर करता है, जिसमें RFC-शैली के timeouts होते हैं जो बहुत लंबे हो सकते हैं। अधिकांश ट्रैफ़िक (HTTP, IRC, BitTorrent) I2P की स्ट्रीमिंग लाइब्रेरी का उपयोग करता है, जो प्रभावी रूप से TCP को NTCP के ऊपर परतबद्ध करता है। जब दोनों परतें पुनःप्रेषण करती हैं, तो पतन (congestion collapse) संभव है। क्लासिक संदर्भों में TCP के ऊपर TCP एक बुरा विचार है शामिल हैं। स्ट्रीमिंग लाइब्रेरी के timeouts रिलीज़ 0.8 में 10 s से बढ़ाकर 45 s कर दिए गए; SSU का अधिकतम timeout 3 s है, जबकि NTCP के timeouts के 60 s (RFC अनुशंसा) तक होने का अनुमान है। NTCP के पैरामीटर को बाहरी रूप से जाँचना कठिन है। 2007 के फील्ड अवलोकनों ने i2psnark अपलोड थ्रूपुट में दोलन दिखाया, जिससे आवधिक जाम-जनित पतन का संकेत मिलता है। दक्षता परीक्षण (SSU को प्राथमिकता देने के लिए बाध्य करके) ने tunnel ओवरहेड अनुपात को लगभग 3.5:1 से 3:1 तक घटाया और स्ट्रीमिंग मेट्रिक्स (window size, RTT, send/ack ratio) में सुधार किया। 2007 के थ्रेड से प्रस्ताव ट्रांसपोर्ट प्राथमिकताएँ उलटें ताकि routers SSU को प्राथमिकता दें (restoring i2np.udp.alwaysPreferred). स्ट्रीमिंग ट्रैफ़िक को टैग करें ताकि SSU केवल टैग किए गए संदेशों के लिए ही कम बोली लगाए, बिना अनामिता से समझौता किए। SSU पुन:प्रेषण सीमाएँ सख्त करें ताकि कोलैप्स के जोखिम को कम किया जा सके। semi-reliable underlays (आंशिक रूप से विश्वसनीय निचली-स्तर की परतें) का अध्ययन करें ताकि यह निर्धारित हो सके कि स्ट्रीमिंग लाइब्रेरी के नीचे किए गए पुन:प्रेषण शुद्ध लाभ हैं या नहीं। प्राथमिकता कतारें और टाइमआउट की समीक्षा करें—उदाहरण के लिए, NTCP के अनुरूप करने के लिए स्ट्रीमिंग टाइमआउट को 45 s से अधिक करना। jrandom द्वारा प्रतिक्रिया (27 मार्च, 2007) मुख्य प्रति-तर्क:\nNTCP इसलिए अस्तित्व में है क्योंकि शुरुआती SSU परिनियोजनों ने congestion collapse (नेटवर्क में अत्यधिक भीड़ के कारण प्रदर्शन का ढह जाना) झेला। प्रति‑हॉप पुनर्प्रेषण की मामूली दरें भी बहु‑हॉप tunnels में विस्फोटक रूप से बढ़ सकती हैं। tunnel‑स्तरीय स्वीकृतियों के बिना, संदेशों का केवल एक हिस्सा ही end‑to‑end डिलिवरी स्थिति प्राप्त करता है; विफलताएँ मौन रह सकती हैं। TCP congestion control में दशकों के अनुकूलन हुए हैं; NTCP उन लाभों का उपयोग परिपक्व TCP स्टैक्स के माध्यम से करता है। SSU को प्राथमिकता देने पर देखे गए दक्षता लाभ, प्रोटोकॉल के अंतर्निहित लाभों के बजाय, संभवतः router के क्यूइंग व्यवहार को दर्शाते हैं। बड़े स्ट्रीमिंग टाइमआउट्स पहले से ही स्थिरता में सुधार कर रहे थे; बड़े बदलावों से पहले अधिक अवलोकन और डेटा को प्रोत्साहित किया गया था। इस बहस ने आगे की ट्रांसपोर्ट ट्यूनिंग को परिष्कृत करने में मदद की, लेकिन यह आधुनिक NTCP2/SSU2 वास्तुकला को प्रतिबिंबित नहीं करती।\n","description":"NTCP और SSU ट्रांसपोर्ट्स की तुलना से संबंधित ऐतिहासिक टिप्पणियाँ और प्रस्तावित ट्यूनिंग विचार","id":"6fe94dc04faadfde27bcfeaaf9da5f71","section":"docs","title":"NTCP चर्चा","url":"/hi/docs/ntcp/"},{"categories":null,"content":"अवलोकन NTCP2 पुराने NTCP ट्रांसपोर्ट को एक Noise‑based handshake (कनेक्शन स्थापित करने की आरंभिक कुंजी-विनिमय प्रक्रिया) से बदलता है, जो traffic fingerprinting (ट्रैफ़िक के पैटर्न से पहचान निकालने की तकनीक) का प्रतिरोध करता है, length fields (डेटा की लंबाई बताने वाले फ़ील्ड) को एन्क्रिप्ट करता है, और आधुनिक cipher suites (एन्क्रिप्शन एल्गोरिद्म के संयोजन) का समर्थन करता है। Routers I2P नेटवर्क में दो अनिवार्य ट्रांसपोर्ट प्रोटोकॉल के रूप में NTCP2 को SSU2 के साथ चला सकते हैं। NTCP (version 1) को 0.9.40 (May 2019) में अप्रचलित घोषित किया गया और 0.9.50 (May 2021) में पूरी तरह हटा दिया गया।\nNoise Protocol Framework (क्रिप्टोग्राफिक हैंडशेक के लिए एक ढांचा) NTCP2, I2P-विशिष्ट विस्तारों के साथ Noise Protocol Framework (क्रिप्टोग्राफ़िक प्रोटोकॉल फ़्रेमवर्क) Revision 33, 2017-10-04 का उपयोग करता है:\nपैटर्न: Noise_XK_25519_ChaChaPoly_SHA256 विस्तारित पहचानकर्ता: Noise_XKaesobfse+hs2+hs3_25519_ChaChaPoly_SHA256 (KDF (Key Derivation Function; कुंजी व्युत्पन्नीकरण फ़ंक्शन) के प्रारंभिककरण हेतु) DH फ़ंक्शन (Diffie-Hellman): X25519 (RFC 7748) - 32-बाइट कुंजियाँ, लिटिल-एंडियन (कम-महत्वपूर्ण-बाइट पहले) एन्कोडिंग साइफ़र: AEAD_CHACHA20_POLY1305 (RFC 7539/RFC 8439) 12-बाइट nonce (एक बार प्रयुक्त मान): पहले 4 बाइट शून्य, आख़िरी 8 बाइट काउंटर (little-endian) अधिकतम nonce मान: 2^64 - 2 (कनेक्शन को 2^64 - 1 तक पहुँचने से पहले समाप्त हो जाना चाहिए) हैश फ़ंक्शन: SHA-256 (32-बाइट आउटपुट) MAC (संदेश प्रमाणीकरण कोड): Poly1305 (16-बाइट प्रमाणीकरण टैग) I2P-विशिष्ट एक्सटेंशन्स हैंडशेक प्रवाह Alice (Initiator) Bob (Responder) SessionRequest ──────────────────────► ◄────────────────────── SessionCreated SessionConfirmed ──────────────────────► तीन-संदेशों वाला हैंडशेक SessionRequest (सत्र अनुरोध संदेश) - Alice की अस्पष्टीकृत अस्थायी कुंजी, विकल्प, पैडिंग संकेत SessionCreated (सत्र-निर्मित संदेश) - Bob की अस्पष्टीकृत अस्थायी कुंजी, कूटबद्ध विकल्प, पैडिंग SessionConfirmed (सत्र-पुष्ट संदेश) - Alice की कूटबद्ध स्थिर कुंजी और RouterInfo (router की जानकारी) (दो AEAD फ़्रेम) Noise संदेश पैटर्न XK(s, rs): Authentication Confidentiality \u0026lt;- s (Bob\u0026#39;s static key known in advance) -\u0026gt; e, es 0 2 \u0026lt;- e, ee 2 1 -\u0026gt; s, se 2 5 \u0026lt;- 2 5 प्रमाणीकरण स्तर: - 0: कोई प्रमाणीकरण नहीं (कोई भी पक्ष इसे भेज सकता था) - 2: प्रेषक प्रमाणीकरण, key-compromise impersonation (कुंजी-समझौता प्रतिरूपण, KCI) के प्रति प्रतिरोधी\nगोपनीयता स्तर: - 1: अस्थायी प्राप्तकर्ता (forward secrecy (भविष्य-गोपनीयता), प्राप्तकर्ता का प्रमाणीकरण नहीं) - 2: ज्ञात प्राप्तकर्ता, केवल प्रेषक के समझौते की स्थिति में forward secrecy - 5: मजबूत forward secrecy (ephemeral-ephemeral + ephemeral-static DH)\nसंदेश विनिर्देश कुंजी संकेतन RH_A = ऐलिस के लिए Router हैश (32 बाइट, SHA-256) RH_B = बॉब के लिए Router हैश (32 बाइट, SHA-256) || = संयोजन ऑपरेटर byte(n) = मान n वाला एकल बाइट सभी बहु-बाइट पूर्णांक, जब तक अन्यथा निर्दिष्ट न हो, big-endian (उच्च-क्रम बाइट पहले) होते हैं X25519 कुंजियाँ little-endian (निम्न-क्रम बाइट पहले) होती हैं (32 बाइट) प्रमाणीकृत एन्क्रिप्शन (ChaCha20-Poly1305) एन्क्रिप्शन फ़ंक्शन:\nAEAD_ChaCha20_Poly1305(key, nonce, associatedData, plaintext) → (ciphertext || MAC) पैरामीटर्स: - key: KDF (कुंजी व्युत्पन्न करने वाला फ़ंक्शन) से प्राप्त 32-बाइट साइफ़र कुंजी - nonce: 12 बाइट (4 शून्य बाइट + 8-बाइट काउंटर, लिटिल-एंडियन) - associatedData: हैंडशेक चरण में 32-बाइट हैश; डेटा चरण में शून्य-लंबाई - plaintext: एन्क्रिप्ट करने हेतु डेटा (0+ बाइट)\nआउटपुट: - Ciphertext (कूट-पाठ): plaintext (स्पष्ट पाठ) जितनी ही लंबाई - MAC (Message Authentication Code, संदेश प्रमाणीकरण कोड): 16 बाइट्स (Poly1305 authentication tag, प्रमाणीकरण टैग)\nNonce (एक-बार-प्रयोग संख्या) प्रबंधन: - काउंटर प्रत्येक cipher instance के लिए 0 से शुरू होता है - उस दिशा में प्रत्येक AEAD (Authenticated Encryption with Associated Data) ऑपरेशन के लिए बढ़ाया जाता है - डेटा चरण में Alice→Bob और Bob→Alice के लिए अलग-अलग काउंटर - काउंटर के 2^64 - 1 तक पहुँचने से पहले कनेक्शन समाप्त करना होगा\nसंदेश 1: SessionRequest (सत्र अनुरोध) एलिस बॉब से कनेक्शन शुरू करती है।\nNoise प्रचालन (क्रिप्टोग्राफ़िक हैंडशेक प्रोटोकॉल): e, es (अस्थायी कुंजी निर्माण और आदान-प्रदान)\nरॉ फ़ॉर्मेट +----+----+----+----+----+----+----+----+ | | + AES-256-CBC Encrypted X (32B) + | Key: RH_B, IV: Bob\u0026#39;s published IV | + + | | +----+----+----+----+----+----+----+----+ | | + ChaChaPoly Frame (48 bytes) + | Plaintext: 32B (X + options) | + k from KDF-1, n=0, ad=h + | | +----+----+----+----+----+----+----+----+ | Cleartext Padding (optional) | + Length specified in options + | 0 to 65535 - 80 bytes | ~ . . . ~ +----+----+----+----+----+----+----+----+ आकार सीमाएँ: - न्यूनतम: 80 बाइट (32 AES + 48 AEAD) - अधिकतम: कुल 65535 बाइट - विशेष मामला: \u0026ldquo;NTCP\u0026rdquo; पतों से जुड़ते समय अधिकतम 287 बाइट (संस्करण पहचान)\nडिक्रिप्ट की गई सामग्री +----+----+----+----+----+----+----+----+ | | + X (Alice ephemeral public key) + | 32 bytes, X25519, little-endian | + + | | +----+----+----+----+----+----+----+----+ | Options Block | + (16 bytes) + | | +----+----+----+----+----+----+----+----+ | Cleartext Padding (optional) | ~ . . . ~ +----+----+----+----+----+----+----+----+ विकल्प ब्लॉक (16 बाइट, big-endian (सबसे महत्त्वपूर्ण बाइट पहले)) +----+----+----+----+----+----+----+----+ | id | ver| padLen | m3p2len | Rsvd(0) | +----+----+----+----+----+----+----+----+ | tsA | Reserved (0) | +----+----+----+----+----+----+----+----+ id : 1 byte - Network ID (2 for mainnet, 16-254 for testnets) ver : 1 byte - Protocol version (currently 2) padLen : 2 bytes - Padding length in this message (0-65455) m3p2len : 2 bytes - Length of SessionConfirmed part 2 frame Rsvd : 2 bytes - Reserved, set to 0 tsA : 4 bytes - Unix timestamp (seconds since epoch) Reserved: 4 bytes - Reserved, set to 0 महत्वपूर्ण फ़ील्ड: - Network ID (नेटवर्क पहचानकर्ता) (since 0.9.42): क्रॉस-नेटवर्क कनेक्शनों का त्वरित अस्वीकार - m3p2len: संदेश 3 भाग 2 का सटीक आकार (भेजते समय मेल खाना चाहिए)\nकुंजी व्युत्पत्ति फ़ंक्शन (KDF-1) प्रोटोकॉल प्रारंभ करें:\nprotocol_name = \u0026#34;Noise_XKaesobfse+hs2+hs3_25519_ChaChaPoly_SHA256\u0026#34; h = SHA256(protocol_name) ck = h // Chaining key initialized to hash MixHash (मिक्सहैश) संचालन:\nh = SHA256(h) // Null prologue h = SHA256(h || rs) // Bob\u0026#39;s static key (known) h = SHA256(h || e.pubkey) // Alice\u0026#39;s ephemeral key X // h is now the associated data for message 1 AEAD MixKey प्रचालन (es पैटर्न):\ndh_result = X25519(Alice.ephemeral_private, Bob.static_public) temp_key = HMAC-SHA256(ck, dh_result) ck = HMAC-SHA256(temp_key, byte(0x01)) k = HMAC-SHA256(temp_key, ck || byte(0x02)) // k is the cipher key for message 1 // ck is retained for message 2 KDF कार्यान्वयन संबंधी टिप्पणियाँ AES अस्पष्टिकरण: केवल DPI (Deep Packet Inspection) प्रतिरोध के लिए प्रयुक्त; Bob के router हैश और IV के साथ कोई भी व्यक्ति X को डिक्रिप्ट कर सकता है रीप्ले रोकथाम: Bob को कम-से-कम 2*D सेकंड तक X मानों (या उनके एन्क्रिप्टेड समकक्ष) को कैश करना चाहिए (D = घड़ी का अधिकतम विचलन) टाइमस्टैम्प सत्यापन: Bob को उन कनेक्शनों को अस्वीकार करना चाहिए जिनमें |tsA - current_time| \u0026gt; D हो (आम तौर पर D = 60 सेकंड) कर्व सत्यापन: Bob को सत्यापित करना चाहिए कि X एक वैध X25519 पॉइंट है त्वरित अस्वीकृति: डिक्रिप्शन से पहले Bob X[31] \u0026amp; 0x80 == 0 की जाँच कर सकता है (वैध X25519 कुंजियों में MSB (सर्वाधिक महत्वपूर्ण बिट) क्लियर होता है) त्रुटि प्रबंधन: किसी भी विफलता पर, Bob यादृच्छिक टाइमआउट और यादृच्छिक बाइट पढ़ने के बाद TCP RST के साथ कनेक्शन बंद करता है बफ़रिंग: दक्षता के लिए Alice को पूरा संदेश (पैडिंग सहित) एक साथ फ्लश करना चाहिए संदेश 2: SessionCreated Bob, Alice को उत्तर देता है।\nNoise ऑपरेशन्स: e, ee (ephemeral-ephemeral DH — दो अस्थायी कुंजियों के बीच Diffie-Hellman)\nरॉ फ़ॉर्मेट +----+----+----+----+----+----+----+----+ | | + AES-256-CBC Encrypted Y (32B) + | Key: RH_B, IV: AES state from msg1 | + + | | +----+----+----+----+----+----+----+----+ | | + ChaChaPoly Frame (48 bytes) + | Plaintext: 32B (Y + options) | + k from KDF-2, n=0, ad=h + | | +----+----+----+----+----+----+----+----+ | Cleartext Padding (optional) | + Length specified in options + | 0 to 65535 - 80 bytes | ~ . . . ~ +----+----+----+----+----+----+----+----+ डिक्रिप्ट की गई सामग्री +----+----+----+----+----+----+----+----+ | | + Y (Bob ephemeral public key) + | 32 bytes, X25519, little-endian | + + | | +----+----+----+----+----+----+----+----+ | Options Block | + (16 bytes) + | | +----+----+----+----+----+----+----+----+ | Cleartext Padding (optional) | ~ . . . ~ +----+----+----+----+----+----+----+----+ विकल्प ब्लॉक (16 बाइट्स, big-endian (सर्वाधिक महत्त्वपूर्ण बाइट पहले)) +----+----+----+----+----+----+----+----+ | Rsvd(0) | padLen | Reserved (0) | +----+----+----+----+----+----+----+----+ | tsB | Reserved (0) | +----+----+----+----+----+----+----+----+ Rsvd : 2 bytes - Reserved, set to 0 padLen : 2 bytes - Padding length in this message Reserved: 10 bytes - Reserved, set to 0 tsB : 4 bytes - Unix timestamp (seconds since epoch) कुंजी व्युत्पत्ति फ़ंक्शन (KDF-2) MixHash ऑपरेशन्स:\nh = SHA256(h || encrypted_payload_msg1) // 32-byte ciphertext if (msg1_padding_length \u0026gt; 0): h = SHA256(h || padding_from_msg1) h = SHA256(h || e.pubkey) // Bob\u0026#39;s ephemeral key Y // h is now the associated data for message 2 AEAD MixKey ऑपरेशन (ee pattern):\ndh_result = X25519(Bob.ephemeral_private, Alice.ephemeral_public) temp_key = HMAC-SHA256(ck, dh_result) ck = HMAC-SHA256(temp_key, byte(0x01)) k = HMAC-SHA256(temp_key, ck || byte(0x02)) // k is the cipher key for message 2 // ck is retained for message 3 KDF मेमोरी साफ़-सफाई:\n// Overwrite ephemeral keys after ee DH Alice.ephemeral_public = zeros(32) Alice.ephemeral_private = zeros(32) // Bob side Bob.received_ephemeral = zeros(32) // Bob side कार्यान्वयन संबंधी टिप्पणियाँ AES चेनिंग: Y एन्क्रिप्शन संदेश 1 से AES-CBC (ब्लॉक-चेनिंग मोड वाला Advanced Encryption Standard) स्टेट का उपयोग करता है (रिसेट नहीं किया जाता) रीप्ले रोकथाम: Alice को Y मानों को कम-से-कम 2*D सेकंड तक कैश करना चाहिए टाइमस्टैम्प सत्यापन: |tsB - current_time| \u0026gt; D होने पर Alice को अस्वीकार करना चाहिए कर्व सत्यापन: Alice को सत्यापित करना चाहिए कि Y एक मान्य X25519 (एलीप्टिक-कर्व की-एक्सचेंज एल्गोरिद्म) बिंदु है त्रुटि प्रबंधन: किसी भी विफलता पर Alice TCP RST (TCP कनेक्शन रीसेट पैकेट) भेजकर कनेक्शन बंद करती है बफ़रिंग: Bob को पूरा संदेश एक साथ flush (आउटपुट बफ़र को तुरंत भेजना) करना चाहिए संदेश 3: SessionConfirmed (सत्र की पुष्टि) Alice सत्र की पुष्टि करती है और RouterInfo भेजती है।\nNoise ऑपरेशन्स: s, se (स्थिर कुंजी प्रकटीकरण और स्थिर-क्षणिक Diffie-Hellman (कुंजी विनिमय))\nद्विभागीय संरचना संदेश 3 दो अलग-अलग AEAD (Authenticated Encryption with Associated Data—संबद्ध डेटा के साथ प्रमाणीकृत एन्क्रिप्शन) फ्रेम से बना है:\nभाग 1: Alice की कूटबद्ध स्थिर कुंजी सहित 48-बाइट का नियत फ्रेम भाग 2: RouterInfo, विकल्प, और पैडिंग सहित चर लंबाई वाला फ्रेम कच्चा प्रारूप +----+----+----+----+----+----+----+----+ | ChaChaPoly Frame 1 (48 bytes) | + Plaintext: Alice static key (32B) + | k from KDF-2, n=1, ad=h | + + | | +----+----+----+----+----+----+----+----+ | | + ChaChaPoly Frame 2 (variable) + | Length specified in msg1.m3p2len | + k from KDF-3, n=0, ad=h + | Plaintext: RouterInfo + padding | + + | | ~ . . . ~ +----+----+----+----+----+----+----+----+ आकार प्रतिबंध: - भाग 1: ठीक 48 बाइट्स (32 सादा पाठ + 16 MAC (Message Authentication Code—संदेश प्रमाणीकरण कोड)) - भाग 2: लंबाई संदेश 1 (m3p2len फील्ड) में निर्दिष्ट - कुल अधिकतम: 65535 बाइट्स (भाग 1 अधिकतम 48, अतः भाग 2 अधिकतम 65487)\nडिक्रिप्ट की गई सामग्री भाग 1:\n+----+----+----+----+----+----+----+----+ | | + S (Alice static public key) + | 32 bytes, X25519, little-endian | + + | | +----+----+----+----+----+----+----+----+ भाग 2:\n+----+----+----+----+----+----+----+----+ | Block: RouterInfo (required) | + Type=2, contains Alice\u0026#39;s RI + | | ~ . . . ~ +----+----+----+----+----+----+----+----+ | Block: Options (optional) | + Type=1, padding parameters + | | +----+----+----+----+----+----+----+----+ | Block: Padding (optional) | + Type=254, random data + | MUST be last block if present | ~ . . . ~ +----+----+----+----+----+----+----+----+ कुंजी व्युत्पत्ति फ़ंक्शन (KDF-3) भाग 1 (s पैटर्न):\nh = SHA256(h || encrypted_payload_msg2) // 32-byte ciphertext if (msg2_padding_length \u0026gt; 0): h = SHA256(h || padding_from_msg2) // Encrypt static key with message 2 cipher key ciphertext = AEAD_ChaCha20_Poly1305(k_msg2, n=1, h, Alice.static_public) h = SHA256(h || ciphertext) // 48 bytes (32 + 16) // h is now the associated data for message 3 part 2 भाग 2 (se पैटर्न):\ndh_result = X25519(Alice.static_private, Bob.ephemeral_public) temp_key = HMAC-SHA256(ck, dh_result) ck = HMAC-SHA256(temp_key, byte(0x01)) k = HMAC-SHA256(temp_key, ck || byte(0x02)) // k is the cipher key for message 3 part 2 // ck is retained for data phase KDF ciphertext = AEAD_ChaCha20_Poly1305(k, n=0, h, payload) h = SHA256(h || ciphertext) // h is retained for SipHash KDF मेमोरी क्लीनअप:\n// Overwrite Bob\u0026#39;s ephemeral key after se DH Alice.received_ephemeral = zeros(32) // Alice side Bob.ephemeral_public = zeros(32) // Bob side Bob.ephemeral_private = zeros(32) // Bob side कार्यान्वयन संबंधी टिप्पणियाँ RouterInfo सत्यापन: Bob को हस्ताक्षर, टाइमस्टैम्प, और कुंजी की सुसंगतता सत्यापित करना चाहिए कुंजी मिलान: Bob को सत्यापित करना चाहिए कि भाग 1 में Alice की स्थिर कुंजी RouterInfo में कुंजी से मेल खाती है स्थिर कुंजी का स्थान: NTCP या NTCP2 के RouterAddress में मिलते-जुलते \u0026ldquo;s\u0026rdquo; पैरामीटर की तलाश करें ब्लॉक क्रम: RouterInfo सबसे पहले होना चाहिए, Options दूसरे स्थान पर (यदि उपस्थित हो), और Padding सबसे अंतिम (यदि उपस्थित हो) लंबाई नियोजन: Alice को सुनिश्चित करना चाहिए कि संदेश 1 में m3p2len ठीक-ठीक भाग 2 की लंबाई से मेल खाए बफरिंग: Alice को दोनों भागों को एक ही TCP send के रूप में साथ में फ्लश करना चाहिए वैकल्पिक चेनिंग: दक्षता के लिए Alice तुरंत data phase frame (डेटा चरण का फ्रेम) जोड़ सकती है डेटा चरण हैंडशेक पूरा होने के बाद, सभी संदेश परिवर्ती-लंबाई AEAD (संबद्ध डेटा के साथ प्रमाणित एन्क्रिप्शन) फ़्रेम का उपयोग करते हैं, जिनमें लंबाई फ़ील्ड को गोपित किया गया होता है।\nकुंजी व्युत्पत्ति फ़ंक्शन (डेटा चरण) Split Function (Noise) (विभाजन फ़ंक्शन, Noise प्रोटोकॉल):\n// Generate transmit and receive keys zerolen = \u0026#34;\u0026#34; // Zero-length byte array temp_key = HMAC-SHA256(ck, zerolen) // Alice transmits to Bob k_ab = HMAC-SHA256(temp_key, byte(0x01)) // Bob transmits to Alice k_ba = HMAC-SHA256(temp_key, k_ab || byte(0x02)) // Cleanup ck = zeros(32) temp_key = zeros(32) SipHash कुंजी व्युत्पत्ति:\n// Generate additional symmetric key for SipHash ask_master = HMAC-SHA256(temp_key, \u0026#34;ask\u0026#34; || byte(0x01)) // \u0026#34;siphash\u0026#34; is 7 bytes US-ASCII temp_key2 = HMAC-SHA256(ask_master, h || \u0026#34;siphash\u0026#34;) sip_master = HMAC-SHA256(temp_key2, byte(0x01)) // Alice to Bob SipHash keys temp_key3 = HMAC-SHA256(sip_master, zerolen) sipkeys_ab = HMAC-SHA256(temp_key3, byte(0x01)) sipk1_ab = sipkeys_ab[0:7] // 8 bytes, little-endian sipk2_ab = sipkeys_ab[8:15] // 8 bytes, little-endian sipiv_ab = sipkeys_ab[16:23] // 8 bytes, IV // Bob to Alice SipHash keys sipkeys_ba = HMAC-SHA256(temp_key3, sipkeys_ab || byte(0x02)) sipk1_ba = sipkeys_ba[0:7] // 8 bytes, little-endian sipk2_ba = sipkeys_ba[8:15] // 8 bytes, little-endian sipiv_ba = sipkeys_ba[16:23] // 8 bytes, IV फ्रेम संरचना +----+----+----+----+----+----+----+----+ |Obfs Len | | +----+----+ ChaChaPoly Frame + | Encrypted Block Data | + k_ab (Alice→Bob) or k_ba (Bob→Alice)| | Nonce starts at 0, increments | + No associated data (empty string) + | | ~ . . . ~ | | +----+----+----+----+----+----+----+----+ | Poly1305 MAC (16 bytes) | +----+----+----+----+----+----+----+----+ फ़्रेम सीमाएँ: - न्यूनतम: 18 बाइट्स (2 obfuscated length (अस्पष्ट की गई लंबाई) + 0 साधारण-पाठ + 16 MAC (Message Authentication Code, संदेश प्रमाणीकरण कोड)) - अधिकतम: 65537 बाइट्स (2 obfuscated length + 65535 फ़्रेम) - अनुशंसित: प्रति फ़्रेम कुछ KB (प्राप्तकर्ता की विलंबता को न्यूनतम रखें)\nSipHash (एक कुंजी-आधारित तेज़ हैश फ़ंक्शन) लंबाई का अस्पष्टकरण उद्देश्य: DPI (Deep Packet Inspection, गहन पैकेट निरीक्षण) द्वारा फ़्रेम सीमाओं की पहचान को रोकना\nएल्गोरिदम:\n// Initialization (per direction) IV[0] = sipiv // From KDF // For each frame: IV[n] = SipHash-2-4(sipk1, sipk2, IV[n-1]) Mask[n] = IV[n][0:1] // First 2 bytes of IV ObfuscatedLength = ActualLength XOR Mask[n] // Send 2-byte ObfuscatedLength, then ActualLength bytes डिकोडिंग:\n// Receiver maintains identical IV chain IV[n] = SipHash-2-4(sipk1, sipk2, IV[n-1]) Mask[n] = IV[n][0:1] ActualLength = ObfuscatedLength XOR Mask[n] // Read ActualLength bytes (includes 16-byte MAC) नोट्स: - प्रत्येक दिशा के लिए अलग-अलग IV (इनिशियलाइज़ेशन वेक्टर) चेन (Alice→Bob और Bob→Alice) - यदि SipHash uint64 लौटाता है, तो मास्क के रूप में सबसे कम महत्वपूर्ण 2 बाइट्स का उपयोग करें - uint64 को little-endian बाइट्स में बदलकर अगले IV के रूप में उपयोग करें\nब्लॉक प्रारूप प्रत्येक फ़्रेम में शून्य या अधिक ब्लॉक होते हैं:\n+----+----+----+----+----+----+----+----+ |Type| Length | Data | +----+----+----+ + | | ~ . . . ~ +----+----+----+----+----+----+----+----+ Type : 1 byte - Block type identifier Length: 2 bytes - Big-endian, data size (0-65516) Data : Variable length payload आकार सीमाएँ: - अधिकतम फ़्रेम: 65535 बाइट्स (MAC सहित) - अधिकतम ब्लॉक स्थान: 65519 बाइट्स (फ़्रेम - 16-बाइट MAC) - अधिकतम एकल ब्लॉक: 65519 बाइट्स (3-बाइट हेडर + 65516 डेटा)\nब्लॉक प्रकार Type Name Description 0DateTimeTime synchronization (4-byte timestamp) 1OptionsPadding parameters, dummy traffic 2RouterInfoRouterInfo delivery/flooding 3I2NPI2NP message with shortened header 4TerminationExplicit connection close 224-253ReservedExperimental features 254PaddingRandom padding (must be last) 255ReservedFuture extensions **ब्लॉक क्रमबद्धता के नियम:** - **संदेश 3 भाग 2**: RouterInfo, Options (वैकल्पिक), Padding (वैकल्पिक) - कोई अन्य प्रकार नहीं - **डेटा चरण**: निम्न अपवादों को छोड़कर किसी भी क्रम में: - Padding उपस्थित होने पर अंतिम ब्लॉक होना चाहिए - Termination उपस्थित होने पर (Padding को छोड़कर) अंतिम ब्लॉक होना चाहिए - प्रति फ्रेम एक से अधिक I2NP ब्लॉकों की अनुमति है - प्रति फ्रेम एक से अधिक Padding ब्लॉकों की अनुमति नहीं है ब्लॉक प्रकार 0: DateTime घड़ी विचलन का पता लगाने के लिए समय समकालिकरण।\n+----+----+----+----+----+----+----+ | 0 | 4 | timestamp | +----+----+----+----+----+----+----+ Type : 0 Length : 4 (big-endian) Timestamp: 4 bytes, Unix seconds (big-endian) कार्यान्वयन: clock bias (घड़ी का ऑफ़सेट) का संचय रोकने हेतु निकटतम सेकंड तक राउंड करें।\nब्लॉक प्रकार 1: विकल्प पैडिंग और traffic shaping (नेटवर्क ट्रैफ़िक को नियंत्रित करने की तकनीक) पैरामीटर।\n+----+----+----+----+----+----+----+----+ | 1 | size |tmin|tmax|rmin|rmax|tdmy| +----+----+----+----+----+----+----+----+ |tdmy| rdmy | tdelay | rdelay | | +----+----+----+----+----+----+----+ + | more_options (TBD) | ~ . . . ~ +----+----+----+----+----+----+----+----+ Type : 1 Length: 12+ bytes (big-endian) पैडिंग अनुपात (4.4 fixed-point float (स्थिर-बिंदु फ्लोट), value/16.0): - tmin: प्रेषण का न्यूनतम पैडिंग अनुपात (0.0 - 15.9375) - tmax: प्रेषण का अधिकतम पैडिंग अनुपात (0.0 - 15.9375) - rmin: प्राप्ति का न्यूनतम पैडिंग अनुपात (0.0 - 15.9375) - rmax: प्राप्ति का अधिकतम पैडिंग अनुपात (0.0 - 15.9375)\nउदाहरण: - 0x00 = 0% पैडिंग - 0x01 = 6.25% पैडिंग - 0x10 = 100% पैडिंग (1:1 अनुपात) - 0x80 = 800% पैडिंग (8:1 अनुपात)\nडमी ट्रैफ़िक: - tdmy: भेजने की अधिकतम स्वीकृत दर (2 बाइट्स, बाइट्स/सेकंड औसत) - rdmy: प्राप्त करने के लिए अनुरोधित दर (2 बाइट्स, बाइट्स/सेकंड औसत)\nविलंब सम्मिलन: - tdelay: सम्मिलित करने हेतु अधिकतम स्वीकार्य (2 बाइट, मिलीसेकंड में औसत) - rdelay: अनुरोधित विलंब (2 बाइट, मिलीसेकंड में औसत)\nदिशानिर्देश: - न्यूनतम मान वांछित ट्रैफ़िक विश्लेषण प्रतिरोध दर्शाते हैं - अधिकतम मान बैंडविड्थ सीमाएँ दर्शाते हैं - प्रेषक को प्राप्तकर्ता की अधिकतम सीमा का सम्मान करना चाहिए - प्रेषक, सीमाओं के भीतर, प्राप्तकर्ता की न्यूनतम सीमा का भी सम्मान कर सकता है - कोई प्रवर्तन तंत्र नहीं है; कार्यान्वयन भिन्न हो सकते हैं\nब्लॉक प्रकार 2: RouterInfo (router की जानकारी) netdb को भरने और फ्लडिंग के लिए RouterInfo का प्रेषण.\n+----+----+----+----+----+----+----+----+ | 2 | size |flg | RouterInfo | +----+----+----+----+ + | | ~ . . . ~ +----+----+----+----+----+----+----+----+ Type : 2 Length: Flag (1 byte) + RouterInfo size Flag : Bit 0 = flood request (1) or local store (0) Bits 1-7 = Reserved, set to 0 उपयोग:\nMessage 3 के भाग 2 में (हैंडशेक): - Alice अपनी RouterInfo (router की जानकारी) Bob को भेजती है - Flood bit आमतौर पर 0 (स्थानीय भंडारण) - RouterInfo gzip से संकुचित नहीं है\nडेटा चरण में: - दोनों पक्षों में से कोई भी अपना अद्यतन RouterInfo भेज सकता है - Flood बिट = 1: floodfill वितरण का अनुरोध (यदि प्राप्तकर्ता floodfill है) - Flood बिट = 0: केवल स्थानीय netdb में भंडारण\nसत्यापन आवश्यकताएँ: 1. सत्यापित करें कि हस्ताक्षर प्रकार समर्थित है 2. RouterInfo हस्ताक्षर सत्यापित करें 3. सत्यापित करें कि टाइमस्टैम्प स्वीकार्य सीमा के भीतर है 4. हैंडशेक के लिए: सत्यापित करें कि स्थिर कुंजी NTCP2 address के \u0026ldquo;s\u0026rdquo; पैरामीटर से मेल खाती है 5. डेटा चरण के लिए: सत्यापित करें कि router hash session peer (सत्र सहकर्मी) से मेल खाता है 6. केवल प्रकाशित पतों वाले RouterInfos को flood (प्रसारित) करें\nनोट्स: - कोई ACK तंत्र नहीं है (आवश्यक होने पर reply token के साथ I2NP DatabaseStore का उपयोग करें) - तृतीय-पक्ष RouterInfos शामिल हो सकते हैं (floodfill का उपयोग) - gzip से संपीड़ित नहीं है (I2NP DatabaseStore के विपरीत)\nब्लॉक प्रकार 3: I2NP संदेश संक्षिप्त 9-बाइट हेडर वाला I2NP संदेश।\n+----+----+----+----+----+----+----+----+ | 3 | size |type| msg_id | +----+----+----+----+----+----+----+----+ | expiration | I2NP payload | +----+----+----+ + | | ~ . . . ~ +----+----+----+----+----+----+----+----+ Type : 3 Length : 9 + payload_size (big-endian) Type : 1 byte, I2NP message type Msg_ID : 4 bytes, big-endian, I2NP message ID Expiration: 4 bytes, big-endian, Unix timestamp (seconds) Payload : I2NP message body (length = size - 9) NTCP1 से अंतर: - समाप्ति समय: 4 बाइट्स (सेकंड) बनाम 8 बाइट्स (मिलीसेकंड) - लंबाई: शामिल नहीं (ब्लॉक की लंबाई से निकाली जा सकती है) - चेकसम: शामिल नहीं (AEAD अखंडता प्रदान करता है) - हेडर: 9 बाइट्स बनाम 16 बाइट्स (44% कमी)\nखंडन: - I2NP संदेशों को ब्लॉकों के पार कदापि खंडित नहीं किया जाना चाहिए - I2NP संदेशों को फ्रेमों के पार कदापि खंडित नहीं किया जाना चाहिए - प्रति फ्रेम एक से अधिक I2NP ब्लॉकों की अनुमति है\nब्लॉक प्रकार 4: समापन कारण कोड सहित स्पष्ट कनेक्शन बंद।\n+----+----+----+----+----+----+----+----+ | 4 | size | valid_frames_recv | +----+----+----+----+----+----+----+----+ | (continued) |rsn | additional_data | +----+----+----+----+ + | | ~ . . . ~ +----+----+----+----+----+----+----+----+ Type : 4 Length : 9+ bytes (big-endian) Valid_Frames_Recv: 8 bytes, big-endian (receive nonce value) 0 if error in handshake phase Reason : 1 byte (see table below) Additional_Data : Optional (format unspecified, for debugging) कारण कोड:\nCode Reason Phase 0Normal close / unspecifiedAny 1Termination receivedData 2Idle timeoutData 3Router shutdownData 4Data phase AEAD failureData 5Incompatible optionsHandshake 6Incompatible signature typeHandshake 7Clock skewHandshake 8Padding violationAny 9AEAD framing errorData 10Payload format errorData 11Message 1 errorHandshake 12Message 2 errorHandshake 13Message 3 errorHandshake 14Intra-frame read timeoutData 15RouterInfo signature verification failHandshake 16Static key parameter mismatchHandshake 17BannedAny **नियम:** - समापन ब्लॉक फ्रेम में अंतिम non-padding ब्लॉक होना अनिवार्य है - प्रति फ्रेम अधिकतम एक समापन ब्लॉक - प्रेषक को भेजने के बाद कनेक्शन बंद कर देना चाहिए - प्राप्तकर्ता को प्राप्त करने के बाद कनेक्शन बंद कर देना चाहिए त्रुटि प्रबंधन: - हैंडशेक त्रुटियाँ: आमतौर पर TCP RST (कनेक्शन रीसेट) के साथ बंद करें (कोई टर्मिनेशन ब्लॉक नहीं) - डेटा चरण AEAD (प्रमाणित एन्क्रिप्शन विद संबद्ध डेटा) त्रुटियाँ: यादृच्छिक टाइमआउट + यादृच्छिक रीड, फिर टर्मिनेशन भेजें - सुरक्षा प्रक्रियाओं के लिए \u0026ldquo;AEAD Error Handling\u0026rdquo; अनुभाग देखें\nब्लॉक प्रकार 254: पैडिंग ट्रैफ़िक विश्लेषण के प्रतिरोध के लिए यादृच्छिक padding (भराव डेटा)।\n+----+----+----+----+----+----+----+----+ |254 | size | random_data | +----+----+----+ + | | ~ . . . ~ +----+----+----+----+----+----+----+----+ Type: 254 Length: 0-65516 bytes (big-endian) Data: Cryptographically random bytes नियम: - यदि मौजूद हो, तो पैडिंग फ़्रेम में अंतिम ब्लॉक होना अनिवार्य है - शून्य-लंबाई पैडिंग की अनुमति है - प्रति फ़्रेम केवल एक पैडिंग ब्लॉक की अनुमति है - केवल पैडिंग वाली फ़्रेमों की अनुमति है - Options block से सहमति से तय किए गए पैरामीटरों का पालन किया जाना चाहिए\nसंदेश 1-2 में पैडिंग: - AEAD (Authenticated Encryption with Associated Data — संबद्ध डेटा सहित प्रमाणीकरणयुक्त एन्क्रिप्शन) फ्रेम के बाहर (स्पष्ट-पाठ) - अगले संदेश की hash chain (हैश शृंखला) में शामिल (प्रमाणित) - छेड़छाड़ का पता तब चलता है जब अगले संदेश की AEAD विफल होती है\nMessage 3+ और डेटा चरण में पैडिंग: - AEAD फ्रेम के अंदर (एन्क्रिप्टेड और प्रमाणित) - ट्रैफ़िक शेपिंग और आकार को अस्पष्ट करने के लिए उपयोग किया जाता है\nAEAD (संबद्ध डेटा सहित प्रमाणित एन्क्रिप्शन) त्रुटि प्रबंधन अत्यावश्यक सुरक्षा आवश्यकताएँ:\nहैंडशेक चरण (संदेश 1-3) ज्ञात संदेश आकार: - संदेश का आकार पूर्वनिर्धारित होता है या पहले से निर्दिष्ट किया जाता है - AEAD (Authenticated Encryption with Associated Data, प्रमाणीकरण-सहित एन्क्रिप्शन व संबद्ध डेटा) प्रमाणीकरण विफलता असंदिग्ध होती है\nMessage 1 विफलता पर Bob की प्रतिक्रिया: 1. यादृच्छिक टाइमआउट सेट करें (सीमा कार्यान्वयन-निर्भर, सुझाव: 100-500ms) 2. बाइट्स की यादृच्छिक संख्या पढ़ें (सीमा कार्यान्वयन-निर्भर, सुझाव: 1KB-64KB) 3. TCP RST के साथ कनेक्शन बंद करें (कोई प्रतिक्रिया नहीं) 4. स्रोत IP को अस्थायी रूप से ब्लैकलिस्ट करें 5. दीर्घकालिक प्रतिबंधों के लिए बारंबार विफलताओं को ट्रैक करें\nAlice की Message 2 विफलता पर प्रतिक्रिया: 1. TCP RST के साथ तुरंत कनेक्शन बंद करें 2. Bob को कोई प्रतिक्रिया नहीं\nMessage 3 की विफलता पर Bob की प्रतिक्रिया: 1. TCP RST (TCP में कनेक्शन रीसेट संकेत) के साथ तुरंत कनेक्शन बंद करें 2. Alice को कोई प्रतिक्रिया नहीं\nडेटा चरण अस्पष्टित संदेश का आकार: - लंबाई फ़ील्ड SipHash (एक कुंजीयुक्त हैश फ़ंक्शन) द्वारा अस्पष्टित है - अमान्य लंबाई या AEAD (संबद्ध डेटा सहित प्रमाणित एन्क्रिप्शन) विफलता यह संकेत कर सकती है: - हमलावर द्वारा जांच-पड़ताल - नेटवर्क में डेटा क्षति - असमन्वित SipHash IV (Initialization Vector—आरंभीकरण वेक्टर) - दुर्भावनापूर्ण पीयर\nAEAD या लंबाई त्रुटि पर प्रतिक्रिया: 1. यादृच्छिक टाइमआउट सेट करें (सुझाव 100-500ms) 2. बाइट्स की यादृच्छिक संख्या पढ़ें (सुझाव 1KB-64KB) 3. कारण कोड 4 (AEAD विफलता) या 9 (फ्रेमिंग त्रुटि) के साथ समापन ब्लॉक भेजें 4. कनेक्शन बंद करें\nDecryption Oracle (त्रुटि/टाइमिंग संकेतों के दुरुपयोग से डिक्रिप्शन-संबंधी जानकारी निकालने वाला हमला) की रोकथाम: - यादृच्छिक टाइमआउट से पहले पीयर को कभी भी त्रुटि प्रकार प्रकट न करें - AEAD (संबद्ध डेटा सहित प्रमाणित एन्क्रिप्शन) जाँच से पहले लंबाई सत्यापन को कभी न छोड़ें - अमान्य लंबाई को AEAD विफलता के समान ही मानें - दोनों त्रुटियों के लिए समान त्रुटि-प्रबंधन पथ का उपयोग करें\nकार्यान्वयन संबंधी विचार: - यदि AEAD त्रुटियाँ दुर्लभ हों, तो कुछ कार्यान्वयन जारी रह सकते हैं - बार-बार त्रुटियों के बाद समाप्त करें (सुझावित सीमा: प्रति घंटे 3-5 त्रुटियाँ) - त्रुटि पुनर्प्राप्ति और सुरक्षा के बीच संतुलन\nप्रकाशित RouterInfo (router संबंधी जानकारी) Router पते का प्रारूप NTCP2 समर्थन को विशिष्ट विकल्पों के साथ प्रकाशित RouterAddress प्रविष्टियों के माध्यम से घोषित किया जाता है।\nट्रांसपोर्ट शैली: - \u0026quot;NTCP2\u0026quot; - इस पोर्ट पर केवल NTCP2 - \u0026quot;NTCP\u0026quot; - इस पोर्ट पर NTCP और NTCP2 दोनों (स्वतः पहचान) - नोट: NTCP (v1) का समर्थन 0.9.50 (मई 2021) में हटाया गया - \u0026ldquo;NTCP\u0026rdquo; शैली अब अप्रचलित है; \u0026ldquo;NTCP2\u0026rdquo; का उपयोग करें\nआवश्यक विकल्प सभी प्रकाशित NTCP2 पते:\nhost - IP पता (IPv4 या IPv6) या होस्टनेम\nप्रारूप: मानक IP संकेतन या डोमेन नाम outbound-only (सिर्फ बाहर जाने वाले कनेक्शनों के लिए) या छिपे हुए routers के लिए इसे छोड़ा जा सकता है port - TCP पोर्ट संख्या\nप्रारूप: पूर्णांक, 1-65535 आउटबाउंड-ओनली या हिडन routers के लिए इसे छोड़ा जा सकता है s - स्थिर सार्वजनिक कुंजी (X25519)\nप्रारूप: Base64-एन्कोडेड, 44 अक्षर एन्कोडिंग: I2P Base64 वर्णमाला स्रोत: 32-बाइट X25519 सार्वजनिक कुंजी, little-endian (लिटल-एंडियन बाइट क्रम) i - AES के लिए Initialization Vector (आरंभिक वेक्टर)\nप्रारूप: Base64-एन्कोडेड, 24 वर्ण एन्कोडिंग: I2P Base64 वर्णमाला स्रोत: 16-बाइट IV, बिग-एंडियन v - प्रोटोकॉल संस्करण\nप्रारूप: पूर्णांक या कॉमा से अलग किए गए पूर्णांक वर्तमान: \u0026quot;2\u0026quot; भविष्य: \u0026quot;2,3\u0026quot; (संख्यात्मक क्रम में होना चाहिए) वैकल्पिक विकल्प:\ncaps - क्षमताएँ (0.9.50 से)\nप्रारूप: क्षमता वर्णों की स्ट्रिंग मान: \u0026quot;4\u0026quot; - IPv4 आउटबाउंड क्षमता \u0026quot;6\u0026quot; - IPv6 आउटबाउंड क्षमता \u0026quot;46\u0026quot; - दोनों IPv4 और IPv6 (अनुशंसित क्रम) यदि host प्रकाशित हो तो आवश्यक नहीं छिपे/फायरवॉल वाले routers के लिए उपयोगी cost - पते की प्राथमिकता\nप्रारूप: पूर्णांक (Integer), 0-255 कम मान = उच्च प्राथमिकता अनुशंसित: सामान्य पते के लिए 5-10 अनुशंसित: अप्रकाशित पते के लिए 14 उदाहरण RouterAddress प्रविष्टियाँ प्रकाशित IPv4 पता:\n\u0026lt;Address cost=\u0026#34;5\u0026#34;\u0026gt; \u0026lt;transport_style\u0026gt;NTCP2\u0026lt;/transport_style\u0026gt; \u0026lt;options\u0026gt; \u0026lt;host\u0026gt;192.0.2.1\u0026lt;/host\u0026gt; \u0026lt;port\u0026gt;8887\u0026lt;/port\u0026gt; \u0026lt;s\u0026gt;9EjeG7BZeznKbL9a2fXx8JBDPgLZbLmKbqY3QrNGJCo=\u0026lt;/s\u0026gt; \u0026lt;i\u0026gt;MDEyMzQ1Njc4OUFCQ0RFRg==\u0026lt;/i\u0026gt; \u0026lt;v\u0026gt;2\u0026lt;/v\u0026gt; \u0026lt;/options\u0026gt; \u0026lt;/Address\u0026gt; छिपा Router (केवल आउटबाउंड):\n\u0026lt;Address cost=\u0026#34;14\u0026#34;\u0026gt; \u0026lt;transport_style\u0026gt;NTCP2\u0026lt;/transport_style\u0026gt; \u0026lt;options\u0026gt; \u0026lt;s\u0026gt;9EjeG7BZeznKbL9a2fXx8JBDPgLZbLmKbqY3QrNGJCo=\u0026lt;/s\u0026gt; \u0026lt;v\u0026gt;2\u0026lt;/v\u0026gt; \u0026lt;caps\u0026gt;4\u0026lt;/caps\u0026gt; \u0026lt;/options\u0026gt; \u0026lt;/Address\u0026gt; डुअल-स्टैक Router:\n\u0026lt;!-- IPv4 Address --\u0026gt; \u0026lt;Address cost=\u0026#34;5\u0026#34;\u0026gt; \u0026lt;transport_style\u0026gt;NTCP2\u0026lt;/transport_style\u0026gt; \u0026lt;options\u0026gt; \u0026lt;host\u0026gt;192.0.2.1\u0026lt;/host\u0026gt; \u0026lt;port\u0026gt;8887\u0026lt;/port\u0026gt; \u0026lt;s\u0026gt;9EjeG7BZeznKbL9a2fXx8JBDPgLZbLmKbqY3QrNGJCo=\u0026lt;/s\u0026gt; \u0026lt;i\u0026gt;MDEyMzQ1Njc4OUFCQ0RFRg==\u0026lt;/i\u0026gt; \u0026lt;v\u0026gt;2\u0026lt;/v\u0026gt; \u0026lt;/options\u0026gt; \u0026lt;/Address\u0026gt; \u0026lt;!-- IPv6 Address (same keys, same port) --\u0026gt; \u0026lt;Address cost=\u0026#34;5\u0026#34;\u0026gt; \u0026lt;transport_style\u0026gt;NTCP2\u0026lt;/transport_style\u0026gt; \u0026lt;options\u0026gt; \u0026lt;host\u0026gt;2001:db8::1\u0026lt;/host\u0026gt; \u0026lt;port\u0026gt;8887\u0026lt;/port\u0026gt; \u0026lt;s\u0026gt;9EjeG7BZeznKbL9a2fXx8JBDPgLZbLmKbqY3QrNGJCo=\u0026lt;/s\u0026gt; \u0026lt;i\u0026gt;MDEyMzQ1Njc4OUFCQ0RFRg==\u0026lt;/i\u0026gt; \u0026lt;v\u0026gt;2\u0026lt;/v\u0026gt; \u0026lt;/options\u0026gt; \u0026lt;/Address\u0026gt; महत्वपूर्ण नियम: - एक ही पोर्ट वाले कई NTCP2 पतों के लिए एक समान s, i, और v मानों का उपयोग करना अनिवार्य है - अलग-अलग पोर्ट अलग कुंजियों का उपयोग कर सकते हैं - डुअल-स्टैक routers को अलग-अलग IPv4 और IPv6 पते प्रकाशित करने चाहिए\nअप्रकाशित NTCP2 पता केवल आउटबाउंड Routers के लिए:\nयदि कोई router आने वाली NTCP2 कनेक्शनों को स्वीकार नहीं करता, लेकिन आउटबाउंड कनेक्शनों को आरंभ करता है, तो उसे फिर भी निम्न के साथ एक RouterAddress प्रकाशित करना अनिवार्य है:\n\u0026lt;Address cost=\u0026#34;14\u0026#34;\u0026gt; \u0026lt;transport_style\u0026gt;NTCP2\u0026lt;/transport_style\u0026gt; \u0026lt;options\u0026gt; \u0026lt;s\u0026gt;9EjeG7BZeznKbL9a2fXx8JBDPgLZbLmKbqY3QrNGJCo=\u0026lt;/s\u0026gt; \u0026lt;v\u0026gt;2\u0026lt;/v\u0026gt; \u0026lt;/options\u0026gt; \u0026lt;/Address\u0026gt; उद्देश्य: - हैंडशेक के दौरान Bob को Alice की स्थिर कुंजी सत्यापित करने की अनुमति देता है - संदेश 3 भाग 2 के RouterInfo सत्यापन के लिए आवश्यक - i, host, या port की आवश्यकता नहीं (केवल आउटबाउंड)\nविकल्प: - पहले से प्रकाशित \u0026ldquo;NTCP\u0026rdquo; या SSU पते में s और v जोड़ें\nसार्वजनिक कुंजी और IV (Initialization Vector, आरंभिक वेक्टर) रोटेशन महत्वपूर्ण सुरक्षा नीति:\nसामान्य नियम: 1. router चल रहा हो तो कभी रोटेट न करें 2. कुंजी और IV (Initialization Vector, आरंभीकरण वैक्टर) को स्थायी रूप से संग्रहीत करें रीस्टार्ट्स के दौरान भी 3. पिछले डाउनटाइम को ट्रैक करें रोटेशन की पात्रता निर्धारित करने के लिए\nरोटेशन से पहले न्यूनतम डाउनटाइम:\nRouter Type Min Downtime Reason Published NTCP2 address1 monthMany routers cache RouterInfo Published SSU only (no NTCP2)1 dayModerate caching No published addresses (hidden)2 hoursMinimal impact **अतिरिक्त ट्रिगर्स:** - स्थानीय IP पता परिवर्तन: डाउनटाइम की परवाह किए बिना बदल सकता है - Router \"rekey\" (नया Router हैश): नई कुंजियाँ उत्पन्न करता है औचित्य: - कुंजी परिवर्तनों के माध्यम से पुनरारंभ समय उजागर होने से रोकता है - कैश की गई RouterInfos (router सूचना रिकॉर्ड) को स्वाभाविक रूप से समाप्त होने देता है - नेटवर्क की स्थिरता बनाए रखता है - असफल कनेक्शन प्रयासों को कम करता है\nकार्यान्वयन: 1. कुंजी, IV, और पिछले शटडाउन का टाइमस्टैम्प स्थायी रूप से संग्रहीत करें 2. स्टार्टअप पर, downtime = current_time - last_shutdown की गणना करें 3. यदि downtime \u0026gt; router प्रकार के लिए न्यूनतम से अधिक है, तो रोटेट किया जा सकता है 4. यदि IP बदल गया है या rekeying (कुंजी पुनर्निर्धारण) किया जा रहा है, तो रोटेट किया जा सकता है 5. अन्यथा, पिछली कुंजी और IV का पुन: उपयोग करें\nIV Rotation (IV रोटेशन): - कुंजी रोटेशन के समान नियम लागू होते हैं - केवल प्रकाशित पतों में मौजूद (छिपे हुए routers में नहीं) - जब भी कुंजी बदले, IV बदलना अनुशंसित है\nसंस्करण पहचान संदर्भ: जब transportStyle=\u0026quot;NTCP\u0026quot; (लेगेसी) हो, Bob एक ही पोर्ट पर NTCP v1 और v2 दोनों का समर्थन करता है और उसे प्रोटोकॉल संस्करण का स्वतः पता लगाना चाहिए।\nडिटेक्शन एल्गोरिदम:\n1. Wait for at least 64 bytes (minimum NTCP2 message 1 size) 2. If received ≥ 288 bytes: → Connection is NTCP version 1 (NTCP1 message 1 is 288 bytes) 3. If received \u0026lt; 288 bytes: Option A (conservative, pre-NTCP2 majority): a. Wait additional short time (e.g., 100-500ms) b. If total received ≥ 288 bytes → NTCP1 c. Otherwise → Attempt NTCP2 decode Option B (aggressive, post-NTCP2 majority): a. Attempt NTCP2 decode immediately: - Decrypt first 32 bytes (X key) with AES-256-CBC - Verify valid X25519 point (X[31] \u0026amp; 0x80 == 0) - Verify AEAD frame b. If decode succeeds → NTCP2 c. If decode fails → Wait for more data or NTCP1 तेज़ MSB (सबसे महत्त्वपूर्ण बिट) जाँच: - AES डिक्रिप्शन से पहले, यह जाँचें: encrypted_X[31] \u0026amp; 0x80 == 0 - मान्य X25519 कुंजियों में उच्च बिट clear (शून्य) होता है - विफलता इंगित करती है कि यह संभवतः NTCP1 (या हमला) है - विफलता पर probing resistance (प्रोबिंग के प्रति प्रतिरोध) लागू करें (random timeout + read)\nकार्यान्वयन आवश्यकताएँ:\nAlice की ज़िम्मेदारी:\n\u0026ldquo;NTCP\u0026rdquo; पते से जुड़ते समय, संदेश 1 को अधिकतम 287 बाइट्स तक सीमित करें पूरे संदेश 1 को बफर करें और एक ही बार में फ्लश करें एकल TCP पैकेट में डिलीवरी की संभावना बढ़ती है Bob की ज़िम्मेदारियाँ:\nसंस्करण तय करने से पहले प्राप्त डेटा को बफर करें उचित timeout (समयसीमा) हैंडलिंग लागू करें तेज़ संस्करण पहचान के लिए TCP_NODELAY का उपयोग करें संस्करण का पता चलने के बाद पूरे संदेश 2 को एक ही बार में बफर करें और फ्लश करें सुरक्षा संबंधी विचार: - सेगमेंटेशन हमले: Bob को TCP segmentation (TCP पैकेटों का खंडन) के प्रति प्रतिरोधी होना चाहिए - प्रोबिंग हमले (जांच-परख आधारित): विफलताओं पर यादृच्छिक विलंब और बाइट-पठन लागू करें - DoS (Denial of Service, सेवा-अस्वीकरण) की रोकथाम: एक साथ लंबित कनेक्शनों की सीमा निर्धारित करें - रीड टाइमआउट्स: प्रति-रीड और कुल दोनों (\u0026ldquo;slowloris\u0026rdquo; (धीमी-कनेक्शन हमला) सुरक्षा)\nClock Skew (सिस्टम घड़ी का अंतर) दिशानिर्देश टाइमस्टैम्प फ़ील्ड: - संदेश 1: tsA (Alice का टाइमस्टैम्प) - संदेश 2: tsB (Bob का टाइमस्टैम्प) - संदेश 3+: वैकल्पिक DateTime ब्लॉक्स\nअधिकतम Skew (विचलन) (D): - सामान्य: ±60 सेकंड - प्रत्येक कार्यान्वयन के अनुसार विन्यास योग्य - Skew \u0026gt; D आमतौर पर घातक होता है\nबॉब की हैंडलिंग (संदेश 1) 1. Receive tsA from Alice 2. skew = tsA - current_time 3. If |skew| \u0026gt; D: a. Still send message 2 (allows Alice to calculate skew) b. Include tsB in message 2 c. Do NOT initiate handshake completion d. Optionally: Temporary ban Alice\u0026#39;s IP e. After message 2 sent, close connection 4. If |skew| ≤ D: a. Continue handshake normally औचित्य: skew (घड़ी का अंतर) होने पर भी संदेश 2 भेजना Alice को घड़ी-संबंधित समस्याओं का निदान करने में सक्षम बनाता है।\nऐलिस की हैंडलिंग (संदेश 2) 1. Receive tsB from Bob 2. RTT = (current_time_now - tsA_sent) 3. adjusted_skew = (tsB - current_time_now) - (RTT / 2) 4. If |adjusted_skew| \u0026gt; D: a. Close connection immediately b. If local clock suspect: Adjust clock or use external time source c. If Bob\u0026#39;s clock suspect: Temporary ban Bob d. Log for operator review 5. If |adjusted_skew| ≤ D: a. Continue handshake normally b. Optionally: Track skew for time synchronization RTT (राउंड-ट्रिप टाइम) समायोजन: - गणना किए गए skew (घड़ी का विचलन) से आधा RTT घटाएँ - नेटवर्क प्रसार विलंब को ध्यान में रखता है - skew का अधिक सटीक आकलन\nबॉब का प्रसंस्करण (संदेश 3) 1. If message 3 received (unlikely if skew exceeded in message 1) 2. Recalculate skew = tsA_received - current_time 3. If |adjusted_skew| \u0026gt; D: a. Send termination block (reason code 7: clock skew) b. Close connection c. Ban Alice for period (e.g., 1-24 hours) समय समकालिकरण DateTime ब्लॉक्स (डेटा चरण): - समय-समय पर DateTime ब्लॉक भेजें (type 0) - प्राप्तकर्ता इसे घड़ी समायोजन के लिए उपयोग कर सकता है - timestamp (समय-मुद्रा) को निकटतम सेकंड तक राउंड करें (बायस से बचें)\nबाहरी समय स्रोत: - NTP (Network Time Protocol) - सिस्टम क्लॉक समकालिकरण - I2P नेटवर्क सर्वसम्मति समय\nघड़ी समायोजन रणनीतियाँ: - यदि स्थानीय घड़ी गलत है: सिस्टम समय समायोजित करें या ऑफ़सेट का उपयोग करें - यदि समकक्षों की घड़ियाँ लगातार गलत हैं: समकक्ष-संबंधी समस्या को चिह्नित करें - नेटवर्क स्वास्थ्य निगरानी के लिए स्क्यू (समय विचलन) आँकड़ों को ट्रैक करें\nसुरक्षा गुणधर्म Forward Secrecy (अग्रसक्रिय गोपनीयता) निम्न के माध्यम से प्राप्त: - Ephemeral Diffie-Hellman key exchange (X25519; अस्थायी Diffie-Hellman कुंजी विनिमय) - तीन DH ऑपरेशन्स: es, ee, se (Noise XK pattern; Noise प्रोटोकॉल का XK हैंडशेक पैटर्न) - हैंडशेक पूरा होने के बाद अस्थायी कुंजियाँ नष्ट कर दी जाती हैं\nगोपनीयता का क्रम: - संदेश 1: स्तर 2 (forward secrecy (कुंजी से समझौता हो जाने के बाद भी पुराने संदेश सुरक्षित रहने का गुण) प्रेषक के समझौते की स्थिति में) - संदेश 2: स्तर 1 (अस्थायी प्राप्तकर्ता) - संदेश 3+: स्तर 5 (मजबूत forward secrecy)\nPerfect Forward Secrecy (पूर्व सत्रों की गोपनीयता सुनिश्चित करने वाला गुण): - दीर्घकालिक स्थिर कुंजियों का समझौता होने पर भी पिछले सत्रों की कुंजियाँ उजागर नहीं होतीं - प्रत्येक सत्र अद्वितीय अस्थायी कुंजियों का उपयोग करता है - अस्थायी निजी कुंजियों का कभी पुनः उपयोग नहीं होता - कुंजी सहमति के बाद मेमोरी की सफ़ाई\nसीमाएँ: - संदेश 1 असुरक्षित है यदि Bob की स्थिर कुंजी से समझौता हो जाए (लेकिन Alice के समझौते के बावजूद forward secrecy (आगे की गोपनीयता) बनी रहती है) - संदेश 1 पर रीप्ले हमले संभव हैं (टाइमस्टैम्प और रीप्ले कैश से शमन किया जाता है)\nप्रमाणीकरण परस्पर प्रमाणीकरण: - Alice का प्रमाणीकरण संदेश 3 में स्थायी कुंजी द्वारा - Bob का प्रमाणीकरण स्थायी निजी कुंजी के स्वामित्व से (सफल हैंडशेक से अप्रत्यक्ष रूप से)\nKey Compromise Impersonation (KCI) प्रतिरोध: - प्रमाणीकरण स्तर 2 (KCI के प्रति प्रतिरोधी) - हमलावर Alice की static private key (स्थायी निजी कुंजी) होने पर भी Alice का प्रतिरूपण नहीं कर सकता (Alice की ephemeral key (अल्पकालिक कुंजी) के बिना) - हमलावर Bob की static private key होने पर भी Bob का प्रतिरूपण नहीं कर सकता (Bob की ephemeral key के बिना)\nस्थिर कुंजी सत्यापन: - Alice को पहले से Bob की स्थिर कुंजी पता होती है (RouterInfo से) - Bob संदेश 3 में यह सत्यापित करता है कि Alice की स्थिर कुंजी RouterInfo से मेल खाती है - मैन-इन-द-मिडल हमलों को रोकता है\nट्रैफ़िक विश्लेषण के प्रति प्रतिरोधक क्षमता DPI (Deep Packet Inspection: गहन पैकेट निरीक्षण) प्रतिरोधक उपाय: 1. AES Obfuscation: अल्पकालिक कुंजियाँ एन्क्रिप्ट की जाती हैं, आउटपुट यादृच्छिक दिखाई देता है 2. SipHash Length Obfuscation: फ्रेम की लंबाइयाँ प्लेनटेक्स्ट में नहीं होतीं 3. Random Padding: संदेश आकार परिवर्तनीय, कोई स्थिर पैटर्न नहीं 4. Encrypted Frames: सारा पेलोड ChaCha20 से एन्क्रिप्ट किया गया है\nरीप्ले हमले की रोकथाम: - टाइमस्टैम्प सत्यापन (±60 सेकंड) - अल्पकालिक कुंजियों का रीप्ले कैश (जीवनकाल 2*D) - Nonce (एक-बार उपयोग संख्या) में वृद्धि सत्र के भीतर पैकेट रीप्ले को रोकती है\nप्रोबिंग प्रतिरोध: - AEAD (Authenticated Encryption with Associated Data - संबद्ध डेटा के साथ प्रमाणित एन्क्रिप्शन) विफलताओं पर यादृच्छिक टाइमआउट - कनेक्शन बंद करने से पहले यादृच्छिक बाइट पढ़ना - हैंडशेक विफलताओं पर कोई प्रतिक्रिया नहीं - बार-बार विफलताओं पर IP ब्लैकलिस्टिंग\nपैडिंग दिशानिर्देश: - संदेश 1-2: क्लियरटेक्स्ट पैडिंग (प्रमाणित) - संदेश 3+: AEAD (प्रमाणीकरणयुक्त संबद्ध डेटा सहित एन्क्रिप्शन) फ़्रेम्स के भीतर एन्क्रिप्टेड पैडिंग - नेगोशिएट किए गए पैडिंग पैरामीटर्स (Options block) - केवल पैडिंग वाले फ़्रेम्स अनुमत हैं\nDenial of Service (सेवा-वंचन) शमन कनेक्शन सीमाएँ: - अधिकतम सक्रिय कनेक्शन (क्रियान्वयन-निर्भर) - अधिकतम लंबित हैंडशेक (उदा., 100-1000) - प्रति-IP कनेक्शन सीमाएँ (उदा., 3-10 एक साथ)\nसंसाधन सुरक्षा: - DH (Diffie-Hellman) संचालन दर-सीमित (गणनात्मक रूप से महँगा) - रीड टाइमआउट प्रति-सॉकेट और कुल - \u0026ldquo;Slowloris\u0026rdquo; (धीमे कनेक्शन-आधारित हमला) से सुरक्षा (कुल समय सीमाएँ) - दुरुपयोग पर IP ब्लैकलिस्टिंग\nत्वरित अस्वीकृति: - Network ID असंगति → तत्काल बंद - अमान्य X25519 बिंदु → डिक्रिप्शन से पहले त्वरित MSB (सबसे महत्वपूर्ण बिट) जाँच - समय-चिह्न सीमा से बाहर → किसी गणना के बिना बंद - AEAD (संबद्ध डेटा सहित प्रमाणित एन्क्रिप्शन) विफलता → कोई प्रतिक्रिया नहीं, यादृच्छिक विलंब\nप्रोबिंग प्रतिरोधक क्षमता: - यादृच्छिक टाइमआउट: 100-500ms (कार्यान्वयन-निर्भर) - यादृच्छिक रीड: 1KB-64KB (कार्यान्वयन-निर्भर) - हमलावर को कोई त्रुटि जानकारी नहीं - TCP RST (तुरंत कनेक्शन रीसेट संकेत) के साथ बंद करें (कोई FIN handshake नहीं)\nक्रिप्टोग्राफिक सुरक्षा एल्गोरिद्म: - X25519: 128-बिट सुरक्षा, दीर्घवृत्तीय वक्र DH (Curve25519) - ChaCha20: 256-बिट कुंजी वाला स्ट्रीम सिफर - Poly1305: सूचना-सैद्धांतिक रूप से सुरक्षित MAC (संदेश प्रमाणीकरण कोड) - SHA-256: 128-बिट टक्कर प्रतिरोध, 256-बिट पूर्व-छवि प्रतिरोध - HMAC-SHA256: कुंजी व्युत्पत्ति हेतु PRF (छद्म‑यादृच्छिक फलन)\nकुंजी आकार: - स्थिर कुंजियाँ: 32 बाइट (256 बिट) - अल्पकालिक कुंजियाँ: 32 बाइट (256 बिट) - कूटलेखन कुंजियाँ: 32 बाइट (256 बिट) - MAC: 16 बाइट (128 बिट)\nज्ञात समस्याएँ: - ChaCha20 nonce (एक-बार-प्रयोग संख्या) का पुनः उपयोग विनाशकारी है (काउंटर बढ़ाकर रोका जाता है) - X25519 में छोटे उपसमूह से संबंधित समस्याएँ हैं (कर्व सत्यापन द्वारा कम की जाती हैं) - SHA-256 सैद्धांतिक रूप से length extension (लंबाई-विस्तार) के प्रति असुरक्षित है (HMAC में शोषण योग्य नहीं)\nकोई ज्ञात कमजोरियाँ नहीं (अक्टूबर 2025 तक): - Noise Protocol Framework (एन्क्रिप्टेड हैंडशेक बनाने के लिए क्रिप्टोग्राफिक ढांचा) का व्यापक विश्लेषण - ChaCha20-Poly1305 (प्रमाणित एन्क्रिप्शन एल्गोरिदम) TLS 1.3 (Transport Layer Security का संस्करण 1.3) में प्रयुक्त - X25519 (कुंजी-विनिमय एलिप्टिक-कर्व एल्गोरिदम) आधुनिक प्रोटोकॉल में मानक - क्रिप्टोग्राफिक निर्माण पर कोई व्यावहारिक हमला नहीं\nसंदर्भ मुख्य विनिर्देश NTCP2 Specification - आधिकारिक I2P विनिर्देश Proposal 111 - औचित्य सहित मूल डिज़ाइन दस्तावेज़ Noise Protocol Framework - संशोधन 33 (2017-10-04) कूटलेखन मानक RFC 7748 - सुरक्षा के लिए अण्डाकार वक्र (X25519) RFC 7539 - IETF प्रोटोकॉलों के लिए ChaCha20 और Poly1305 RFC 8439 - ChaCha20-Poly1305 (RFC 7539 को अप्रचलित करता है) RFC 2104 - HMAC: संदेश प्रमाणीकरण के लिए कुंजी-आधारित हैशिंग SipHash - हैश फ़ंक्शन अनुप्रयोगों के लिए SipHash-2-4 संबंधित I2P विनिर्देश I2NP विनिर्देश - I2P नेटवर्क प्रोटोकॉल संदेश प्रारूप सामान्य संरचनाएँ - RouterInfo (राउटर की जानकारी), RouterAddress (राउटर का पता) के प्रारूप SSU ट्रांसपोर्ट - UDP ट्रांसपोर्ट (मूल, अब SSU2) प्रस्ताव 147 - ट्रांसपोर्ट नेटवर्क ID जाँच (0.9.42) कार्यान्वयन संदर्भ I2P Java - संदर्भ कार्यान्वयन (Java) i2pd - C++ कार्यान्वयन I2P रिलीज़ नोट्स - संस्करण इतिहास और अद्यतन ऐतिहासिक संदर्भ Station-To-Station Protocol (STS) - Noise framework (क्रिप्टोग्राफ़िक हैंडशेक का ढांचा) के लिए प्रेरणा obfs4 - Pluggable transport (अदल-बदल योग्य ट्रैफ़िक-छिपाव माध्यम) (SipHash आधारित लंबाई-छिपाव का पूर्व उदाहरण) कार्यान्वयन दिशानिर्देश अनिवार्य आवश्यकताएँ अनुपालन हेतु:\nपूर्ण हैंडशेक लागू करें:\nसही KDF chains (Key Derivation Function यानी कुंजी व्युत्पत्ति फ़ंक्शन की श्रृंखलाएँ) के साथ सभी तीन संदेशों का समर्थन करें सभी AEAD tags (सम्बद्ध डेटा सहित प्रमाणीकरणयुक्त एन्क्रिप्शन के टैग) को सत्यापित करें सुनिश्चित करें कि X25519 points (एलिप्टिक-कर्व X25519 के बिंदु) वैध हैं डेटा चरण लागू करें:\nSipHash लंबाई अस्पष्टकरण (दोनों दिशाओं में) सभी ब्लॉक प्रकार: 0 (DateTime), 1 (Options), 2 (RouterInfo), 3 (I2NP), 4 (Termination), 254 (Padding) उचित nonce (एक-बार-प्रयोग संख्या) प्रबंधन (अलग-अलग काउंटर) सुरक्षा विशेषताएँ:\nरीप्ले रोकथाम (अल्पकालिक कुंजियों को 2*D के लिए कैश करना) टाइमस्टैम्प सत्यापन (डिफ़ॉल्ट ±60 सेकंड) संदेश 1-2 में यादृच्छिक पैडिंग AEAD (संबद्ध डेटा सहित प्रमाणित एन्क्रिप्शन) त्रुटि प्रबंधन यादृच्छिक टाइमआउट्स के साथ RouterInfo (router की सूचना) प्रकाशन:\nस्थिर कुंजी (\u0026ldquo;s\u0026rdquo;), IV (Initialization Vector—आरंभीकरण वेक्टर) (\u0026ldquo;i\u0026rdquo;), और संस्करण (\u0026ldquo;v\u0026rdquo;) प्रकाशित करें नीति के अनुसार कुंजियों का आवर्तन करें छिपे हुए routers के लिए capabilities फ़ील्ड (\u0026ldquo;caps\u0026rdquo;) का समर्थन करें नेटवर्क संगतता:\nनेटवर्क ID फ़ील्ड का समर्थन करें (वर्तमान में मुख्य नेटवर्क के लिए 2) मौजूदा Java और i2pd कार्यान्वयनों के साथ परस्पर-संचालित हों IPv4 और IPv6 दोनों को संभालें अनुशंसित प्रथाएँ प्रदर्शन अनुकूलन:\nबफ़रिंग रणनीति:\nपूरे संदेशों को एक साथ फ्लश करें (संदेश 1, 2, 3) हैंडशेक संदेशों के लिए TCP_NODELAY का उपयोग करें कई डेटा ब्लॉकों को एकल फ्रेम में बफ़र करें फ्रेम का आकार कुछ KB तक सीमित रखें (प्राप्तकर्ता लेटेंसी को न्यूनतम करें) कनेक्शन प्रबंधन:\nजहाँ संभव हो कनेक्शनों का पुनः उपयोग करें कनेक्शन पूलिंग लागू करें कनेक्शन स्वास्थ्य की निगरानी करें (DateTime blocks (तिथि-समय ब्लॉक्स)) मेमोरी प्रबंधन:\nउपयोग के बाद संवेदनशील डेटा को शून्य करें (ephemeral keys (अस्थायी कुंजियाँ), DH results (Diffie-Hellman के परिणाम)) समवर्ती हैंडशेक की सीमा तय करें (DoS (Denial-of-Service/सेवा-अस्वीकरण) की रोकथाम) बार-बार होने वाले आवंटन के लिए मेमोरी पूल का उपयोग करें सुरक्षा सुदृढ़ीकरण:\nप्रोबिंग प्रतिरोध:\nयादृच्छिक टाइमआउट: 100-500ms यादृच्छिक बाइट रीड्स: 1KB-64KB बार-बार विफलताओं पर IP ब्लैकलिस्टिंग पीयर्स को कोई त्रुटि विवरण नहीं संसाधन सीमाएँ:\nप्रति IP अधिकतम कनेक्शन: 3-10 अधिकतम लंबित हैंडशेक: 100-1000 पठन समयसीमाएँ: प्रति ऑपरेशन 30-60 सेकंड कुल कनेक्शन समयसीमा: हैंडशेक के लिए 5 मिनट कुंजी प्रबंधन:\nस्थिर कुंजी और IV (Initialization Vector—प्रारंभन वेक्टर) का स्थायी भंडारण सुरक्षित यादृच्छिक उत्पत्ति (cryptographic RNG) रोटेशन नीतियों का कड़ाई से पालन करें अस्थायी कुंजियों का कभी पुनः उपयोग न करें निगरानी और निदान:\nमेट्रिक्स:\nहैंडशेक की सफलता/विफलता दरें AEAD (प्रमाणित एन्क्रिप्शन, संबद्ध डेटा सहित) त्रुटि दरें क्लॉक स्क्यू का वितरण कनेक्शन अवधि के आँकड़े लॉगिंग:\nहैंडशेक विफलताओं को कारण कोड सहित लॉग करें क्लॉक स्क्यू घटनाओं को लॉग करें प्रतिबंधित IP पतों को लॉग करें संवेदनशील कुंजी सामग्री को कभी भी लॉग न करें परीक्षण:\nKDF (कुंजी व्युत्पत्ति फ़ंक्शन) श्रृंखलाओं के लिए यूनिट परीक्षण अन्य कार्यान्वयनों के साथ एकीकरण परीक्षण पैकेट हैंडलिंग के लिए Fuzzing (अनियमित इनपुट परीक्षण) DoS (सेवा-अस्वीकरण हमला) प्रतिरोधक क्षमता के लिए लोड परीक्षण आम गलतियाँ बचने योग्य गंभीर त्रुटियाँ:\nNonce (एक बार प्रयुक्त संख्या) का पुन:उपयोग:\nसत्र के दौरान nonce काउंटर को कभी रीसेट न करें प्रत्येक दिशा के लिए अलग-अलग काउंटर का उपयोग करें 2^64 - 1 तक पहुँचने से पहले समाप्त करें कुंजी रोटेशन:\nजब router चल रहा हो, तब कभी कुंजियों को रोटेट न करें विभिन्न सत्रों के बीच अस्थायी (ephemeral) कुंजियों का पुन: उपयोग कभी न करें न्यूनतम डाउनटाइम के नियमों का पालन करें टाइमस्टैम्प प्रबंधन:\nअवधि-समाप्त टाइमस्टैम्प कभी स्वीकार न करें समय विचलन की गणना करते समय RTT (राउंड-ट्रिप टाइम) के अनुसार हमेशा समायोजन करें DateTime टाइमस्टैम्प को सेकंड तक राउंड करें AEAD (Authenticated Encryption with Associated Data - प्रमाणित एन्क्रिप्शन विद एसोसिएटेड डेटा) त्रुटियाँ:\nहमलावर को कभी भी त्रुटि के प्रकार का खुलासा न करें बंद करने से पहले हमेशा एक यादृच्छिक टाइमआउट का उपयोग करें अमान्य लंबाई को AEAD विफलता के समान समझें पैडिंग:\nसहमत सीमाओं के बाहर कभी भी पैडिंग न भेजें पैडिंग ब्लॉक को हमेशा सबसे अंत में रखें प्रति फ़्रेम कभी भी एक से अधिक पैडिंग ब्लॉक न हों RouterInfo:\nहमेशा यह सत्यापित करें कि static key (स्थिर कुंजी) RouterInfo से मेल खाती है प्रकाशित पतों के बिना RouterInfos को कभी भी प्रसारित न करें हमेशा हस्ताक्षरों को सत्यापित करें परीक्षण कार्यप्रणाली यूनिट परीक्षण:\nक्रिप्टोग्राफ़िक प्रिमिटिव्स:\nX25519, ChaCha20, Poly1305, SHA-256 के लिए परीक्षण वेक्टर HMAC-SHA256 के परीक्षण वेक्टर SipHash-2-4 के परीक्षण वेक्टर KDF चेन:\nतीनों संदेशों के लिए ज्ञात-उत्तर परीक्षण चेनिंग कुंजी के प्रसार का सत्यापन करें SipHash IV निर्माण का परीक्षण करें संदेश पार्सिंग:\nमान्य संदेश डिकोडिंग अमान्य संदेश अस्वीकृति सीमा स्थितियाँ (रिक्त, अधिकतम आकार) एकीकरण परीक्षण:\nहैंडशेक:\nसफल तीन-संदेश आदान-प्रदान क्लॉक-स्क्यू के आधार पर अस्वीकृति रीप्ले हमले की पहचान अमान्य कुंजी की अस्वीकृति डेटा चरण:\nI2NP संदेश स्थानांतरण RouterInfo आदान-प्रदान पैडिंग का प्रबंधन समापन संदेश अंतरसंचालनीयता:\nJava I2P के साथ परीक्षण करें i2pd के साथ परीक्षण करें IPv4 और IPv6 का परीक्षण करें प्रकाशित और छिपे हुए routers का परीक्षण करें सुरक्षा परीक्षण:\nनकारात्मक परीक्षण:\nअमान्य AEAD (संबद्ध डेटा सहित प्रमाणित एन्क्रिप्शन) टैग रीप्ले किए गए संदेश क्लॉक स्क्यू हमले गलत-संरूपित फ़्रेम DoS (सेवा-अस्वीकरण) परीक्षण:\nकनेक्शन फ्लडिंग Slowloris हमले (धीमे-कनेक्शन आधारित) CPU पर अत्यधिक भार (अत्यधिक DH (Diffie-Hellman कुंजी-विनिमय)) मेमोरी समाप्ति फज़िंग (Fuzzing):\nयादृच्छिक हैंडशेक संदेश यादृच्छिक डेटा चरण फ्रेम यादृच्छिक ब्लॉक प्रकार और आकार अमान्य क्रिप्टोग्राफिक मान NTCP (ट्रांसपोर्ट प्रोटोकॉल) से माइग्रेशन पुराने NTCP (I2P का TCP-आधारित ट्रांसपोर्ट प्रोटोकॉल) के समर्थन हेतु (अब हटा दिया गया):\nNTCP (version 1) को I2P 0.9.50 (मई 2021) में हटा दिया गया था। सभी वर्तमान कार्यान्वयनों को NTCP2 का समर्थन करना आवश्यक है। ऐतिहासिक टिप्पणियाँ:\nसंक्रमण अवधि (2018-2021):\n0.9.36: NTCP2 पेश किया गया (डिफ़ॉल्ट रूप से निष्क्रिय) 0.9.37: NTCP2 डिफ़ॉल्ट रूप से सक्षम 0.9.40: NTCP अप्रचलित घोषित किया गया 0.9.50: NTCP हटा दिया गया संस्करण पहचान:\n\u0026ldquo;NTCP\u0026rdquo; transportStyle दोनों संस्करणों का समर्थन दर्शाता था \u0026ldquo;NTCP2\u0026rdquo; transportStyle केवल NTCP2 को दर्शाता था संदेश आकार के माध्यम से स्वचालित पहचान (287 बनाम 288 बाइट्स) वर्तमान स्थिति:\nसभी routers को NTCP2 का समर्थन करना अनिवार्य है \u0026ldquo;NTCP\u0026rdquo; transportStyle अब अप्रचलित है केवल \u0026ldquo;NTCP2\u0026rdquo; transportStyle का उपयोग करें परिशिष्ट A: Noise XK Pattern (Noise प्रोटोकॉल फ़्रेमवर्क का XK हैंडशेक पैटर्न) मानक Noise XK पैटर्न:\nXK(s, rs): \u0026lt;- s ... -\u0026gt; e, es \u0026lt;- e, ee -\u0026gt; s, se व्याख्या:\n\u0026lt;- : उत्तरदाता (Bob) से प्रारंभकर्ता (Alice) को संदेश -\u0026gt; : प्रारंभकर्ता (Alice) से उत्तरदाता (Bob) को संदेश s : स्थिर कुंजी (दीर्घकालिक पहचान कुंजी) rs : रिमोट स्थिर कुंजी (पीयर की स्थिर कुंजी, पहले से ज्ञात) e : अस्थायी कुंजी (सत्र-विशिष्ट, आवश्यकतानुसार उत्पन्न) es : अस्थायी-स्थिर DH (डिफी-हेल्मन कुंजी-सहमति) (Alice अस्थायी × Bob स्थिर) ee : अस्थायी-अस्थायी DH (Alice अस्थायी × Bob अस्थायी) se : स्थिर-अस्थायी DH (Alice स्थिर × Bob अस्थायी) कुंजी सहमति क्रम:\nपूर्व-संदेश: Alice को Bob की static public key (स्थैतिक सार्वजनिक कुंजी) ज्ञात है (RouterInfo से) संदेश 1: Alice ephemeral key (क्षणिक कुंजी) भेजती है, es DH निष्पादित करती है संदेश 2: Bob ephemeral key भेजता है, ee DH निष्पादित करता है संदेश 3: Alice static key (स्थैतिक कुंजी) प्रकट करती है, se DH निष्पादित करती है सुरक्षा विशेषताएँ:\nAlice प्रमाणित: हाँ (message 3 द्वारा) Bob प्रमाणित: हाँ (स्थिर निजी कुंजी के पास होने से) Forward secrecy (आगे की गोपनीयता): हाँ (क्षणिक कुंजियाँ नष्ट कर दी जाती हैं) KCI resistance (Known-Compromise Impersonation प्रतिरोध): हाँ (प्रमाणीकरण स्तर 2) परिशिष्ट बी: Base64 Encoding (बाइनरी डेटा को ASCII-पाठ में बदलने की मानक विधि) I2P Base64 (64-आधारित एन्कोडिंग) वर्णमाला:\nABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-~ Standard Base64 से अंतर: - वर्ण 62-63: -~ +/ के बजाय - पैडिंग: समान (=) या संदर्भ के अनुसार छोड़ी जा सकती है\nNTCP2 में उपयोग: - स्थिर कुंजी (\u0026ldquo;s\u0026rdquo;): 32 बाइट्स → 44 अक्षर (बिना पैडिंग) - IV (इनिशियलाइज़ेशन वेक्टर) (\u0026ldquo;i\u0026rdquo;): 16 बाइट्स → 24 अक्षर (बिना पैडिंग)\nएन्कोडिंग उदाहरण:\n# 32-byte static key (hex): # f4489e1bb0597b39ca6cbf5ad9f5f1f09043e02d96cb9aa6a63742b3462429aa # I2P Base64 encoded: # 9EjeG7BZeznKbL9a2fXx8JBDPgLZbLmKbqY3QrNGJCo= परिशिष्ट C: पैकेट कैप्चर विश्लेषण NTCP2 ट्रैफ़िक की पहचान:\nTCP हैंडशेक:\nमानक TCP SYN, SYN-ACK, ACK गंतव्य पोर्ट आमतौर पर 8887 या इसी तरह संदेश 1 (SessionRequest):\nएलिस से पहला एप्लिकेशन डेटा 80-65535 बाइट (आमतौर पर कुछ सौ) यादृच्छिक प्रतीत होता है (AES से एन्क्रिप्ट की गई अस्थायी कुंजी) यदि \u0026ldquo;NTCP\u0026rdquo; पते से कनेक्ट हो रहे हों तो अधिकतम 287 बाइट संदेश 2 (SessionCreated):\nBob से प्रतिक्रिया 80-65535 बाइट (आमतौर पर कुछ सौ) यह भी यादृच्छिक प्रतीत होता है संदेश 3 (SessionConfirmed - सत्र पुष्टि):\nAlice से 48 बाइट + परिवर्ती (RouterInfo का आकार + पैडिंग) आम तौर पर 1-4 KB डेटा चरण:\nपरिवर्ती लंबाई के फ़्रेम लंबाई फ़ील्ड अस्पष्ट किया गया (यादृच्छिक प्रतीत होता है) कूटबद्ध पेलोड पैडिंग आकार को अप्रत्याशित बनाती है DPI (गहन पैकेट निरीक्षण) से बचाव: - कोई सादा-पाठ हेडर नहीं - कोई स्थिर पैटर्न नहीं - लंबाई फ़ील्ड अस्पष्ट किए गए - रैंडम पैडिंग आकार-आधारित heuristics (अनुमान-नियम) को तोड़ती है\nNTCP से तुलना: - NTCP संदेश 1 हमेशा 288 बाइट का होता है (पहचानने योग्य) - NTCP2 संदेश 1 का आकार बदलता रहता है (पहचानने योग्य नहीं) - NTCP में पहचानने योग्य पैटर्न थे - NTCP2 को DPI (डीप पैकेट निरीक्षण) का प्रतिरोध करने के लिए डिज़ाइन किया गया है\nपरिशिष्ट D: संस्करण इतिहास मुख्य मील के पत्थर:\n0.9.36 (अगस्त 23, 2018): NTCP2 का परिचय कराया गया, डिफ़ॉल्ट रूप से निष्क्रिय 0.9.37 (अक्टूबर 4, 2018): NTCP2 डिफ़ॉल्ट रूप से सक्षम 0.9.40 (मई 20, 2019): NTCP को अप्रचलित घोषित किया गया 0.9.42 (अगस्त 27, 2019): Network ID फ़ील्ड जोड़ी गई (प्रस्ताव 147) 0.9.50 (मई 17, 2021): NTCP को हटा दिया गया, क्षमताओं के लिए समर्थन जोड़ा गया 2.10.0 (सितंबर 9, 2025): नवीनतम स्थिर रिलीज़ प्रोटोकॉल स्थिरता: - 0.9.50 से कोई पिछली संगतता तोड़ने वाले परिवर्तन नहीं - प्रोबिंग प्रतिरोध में निरंतर सुधार - प्रदर्शन और विश्वसनीयता पर ध्यान - Post-quantum cryptography (क्वांटम कंप्यूटिंग-प्रतिरोधी कूटलेखन) विकासाधीन (डिफ़ॉल्ट रूप से सक्षम नहीं)\nवर्तमान ट्रांसपोर्ट स्थिति: - NTCP2: अनिवार्य TCP ट्रांसपोर्ट - SSU2: अनिवार्य UDP ट्रांसपोर्ट - NTCP (v1): हटाया गया - SSU (v1): हटाया गया\n","description":"router-से-router लिंक के लिए Noise (क्रिप्टोग्राफ़िक प्रोटोकॉल) आधारित TCP ट्रांसपोर्ट","id":"4882afdd530d8c7e8da14bb97487aecc","section":"docs","title":"NTCP2 ट्रांसपोर्ट","url":"/hi/docs/specs/ntcp2/"},{"categories":null,"content":"अवलोकन यह दस्तावेज़ एक पुनः-यादृच्छीकृत करने योग्य हस्ताक्षर योजना निर्दिष्ट करता है, जो ब्लाइंड किए जा सकने वाले Destinations (I2P में पब्लिक-की आधारित पता/पहचान) बनाने के लिए उपयुक्त है। इसके अतिरिक्त, मौजूदा Ed25519 Destinations को ब्लाइंड करने के लिए भी इसका उपयोग किया जा सकता है, हालांकि प्रभावशीलता में थोड़ी कमी आती है।\nRed25519 I2P routers में संस्करण 0.9.39 (21 मार्च, 2019 को जारी) से पूरी तरह से कार्यशील है। उत्पादन परिनियोजन के 17 महीनों के बाद, इस विनिर्देश को संस्करण 0.9.47 (अगस्त 2020) में अंतिम रूप दिया गया। यह हस्ताक्षर योजना I2P नेटवर्क में हस्ताक्षर प्रकार 11 (RedDSA_SHA512_Ed25519) के रूप में कार्य करती है।\nप्रेरणा प्रस्ताव 123 (New netDB Entries) एक एन्क्रिप्टेड LeaseSet2 प्रारूप परिभाषित करता है जो न्यूनतम अधिकार के सिद्धांत का पालन करता है: प्रत्येक नेटवर्क सहभागी को उसकी भूमिका के लिए आवश्यक जानकारी ही दी जाती है। विशेष रूप से, floodfill पर प्रकाशित एन्क्रिप्टेड LeaseSet2 उस Destination (I2P में गंतव्य पहचान) का खुलासा नहीं करता जिसके लिए वह है, और Leases केवल वही देख सकता है जिसके पास उस Destination का पूर्व ज्ञान हो। हालाँकि, प्रकाशित करते समय floodfills को एन्क्रिप्टेड LeaseSet2s का प्रमाणीकरण करने में सक्षम होना अभी भी आवश्यक है, और क्लाइंट्स को अतिरिक्त रूप से यह सुनिश्चित करना होता है कि यह प्रमाणीकरण स्वयं Destination द्वारा लागू किया गया था।\nप्रस्ताव 123 इसे Destination (I2P में गंतव्य पहचान) की हस्ताक्षर कुंजियों को ब्लाइंड करके प्राप्त करता है। ब्लाइंड की गई कुंजियों का उपयोग ऐसे हस्ताक्षर बनाने में किया जा सकता है जिन्हें floodfills द्वारा सत्यापित किया जा सके, और क्लाइंट यह सुनिश्चित कर सकते हैं कि केवल Destination ही वे हस्ताक्षर बना सकता था। इसलिए, ब्लाइंडिंग के लिए प्रयोज्य एक हस्ताक्षर योजना निर्दिष्ट करना आवश्यक है।\nप्रस्ताव 123 की स्थिति पर नोट: प्रस्ताव 123 के कुछ हिस्से संस्करण 0.9.38 से क्रमिक रूप से लागू और तैनात किए गए हैं, तथा 0.9.39 में Red25519 समर्थन जोड़ा गया। एन्क्रिप्टेड LeaseSet2 कार्यक्षमता उत्पादन के लिए तैयार है और गोपनीयता-वर्धित छिपी सेवाओं के लिए I2P नेटवर्क में सक्रिय रूप से उपयोग की जा रही है।\nडिज़ाइन मुख्य हस्ताक्षर योजना यहाँ निर्दिष्ट हस्ताक्षर योजना, Red25519, Zcash प्रोटोकॉल विनिर्देशन (Sapling और उसके बाद) के अनुभाग 5.4.6 में परिभाषित RedDSA की एक instantiation (विशिष्ट अवतरण) है। RedDSA एक Schnorr-आधारित हस्ताक्षर योजना है जो कुंजी के पुनः-यादृच्छिकीकरण का समर्थन करती है। इसके निम्नलिखित फंक्शन्स हैं:\nGENERATE_PRIVATE() : समान-वितरित यादृच्छिक निजी कुंजी लौटाता है.\nDERIVE_PUBLIC(sk) : दी गई निजी कुंजी के अनुरूप सार्वजनिक कुंजी लौटाता है।\nGENERATE_RANDOM() : एक यादृच्छिक scalar (स्केलर) लौटाता है, जो किसी keypair (कुंजी-युग्म) के पुनः-यादृच्छिकीकरण के लिए उपयुक्त है।\nRANDOMIZE_PRIVATE(sk, alpha) : एक गुप्त स्केलर alpha का उपयोग करके एक निजी कुंजी को पुनः-यादृच्छीकृत करता है।\nRANDOMIZE_PUBLIC(vk, alpha) : एक गोपनीय स्केलर alpha का उपयोग करके सार्वजनिक कुंजी को पुनः यादृच्छिक करता है।\nSIGN(sk, m) : दिए गए संदेश m पर निजी कुंजी sk द्वारा एक हस्ताक्षर लौटाता है.\nVERIFY(vk, m, sig) : सार्वजनिक कुंजी vk और संदेश m के विरुद्ध हस्ताक्षर sig का सत्यापन करता है। यदि हस्ताक्षर मान्य है तो true लौटाता है, अन्यथा false।\nकिसी दिए गए कुंजी-युग्म (sk, vk) के लिए निम्न संबंध सत्य होता है:\nRANDOMIZE_PUBLIC(vk, alpha) == DERIVE_PUBLIC(RANDOMIZE_PRIVATE(sk, alpha)) Ed25519 (एक एलिप्टिक-कर्व डिजिटल हस्ताक्षर स्कीम) कुंजियों को Red25519 (Ed25519 का वैकल्पिक प्रतिनिधित्व) में परिवर्तित करना Ed25519 keys (एक डिजिटल हस्ताक्षर कुंजी प्रकार) को मौजूदा Ed25519 Destinations (I2P की public-key-आधारित पहचान) के पुनः-यादृच्छिकीकरण के समर्थन हेतु अस्थायी रूप से एक-तरफ़ा रूपांतरण द्वारा Red25519 keys (Ed25519 का पुनः-रैंडमाइज़ेबल रूप) में बदला जा सकता है। अन्य sigtypes (हस्ताक्षर प्रकार) संगत नहीं हैं।\nहम निम्नलिखित रूपांतरण फ़ंक्शनों को परिभाषित करते हैं:\nCONVERT_ED25519_PRIVATE(privkey) : दिए गई Ed25519 निजी कुंजी के अनुरूप Red25519 निजी कुंजी लौटाता है।\nCONVERT_ED25519_PUBLIC(pubkey) : दिए गई Ed25519 सार्वजनिक कुंजी के अनुरूप Red25519 सार्वजनिक कुंजी वापस करता है।\nकिसी दिए गए Ed25519 कुंजी-युग्म (privkey, pubkey) के लिए निम्नलिखित संबंध सत्य होता है:\nCONVERT_ED25519_PUBLIC(pubkey) == DERIVE_PUBLIC(CONVERT_ED25519_PRIVATE(privkey)) विनिर्देश परिभाषाएँ B : RFC 8032 में वर्णित Ed25519 का आधार बिंदु।\nL : Ed25519 का order (समूह का क्रम) 2^252 + 27742317777372353535851937790883648493 है, जैसा कि RFC 8032 में दिया गया है।\n[s] B : s द्वारा आधार बिंदु का स्थिर आधार स्केलर गुणन।\n[s] A : A का s द्वारा परिवर्ती-आधार स्केलर गुणन।\nx || y : दो बाइट एरे x और y को जोड़ना।\nRed25519 (क्रिप्टोग्राफी में प्रयुक्त एक हस्ताक्षर एल्गोरिदम का नाम) Red25519 योजना (RedDSA का एक विशिष्ट रूप) RedDSA (डिजिटल हस्ताक्षर योजना) को निम्नलिखित के साथ विशेषीकृत करती है:\nG := Curve25519 के Edwards रूप पर बिंदुओं का समूह। विशेष रूप से, इसका अर्थ है कि Red25519 क्रम L वाले prime-order subgroup (अभाज्य-क्रम वाला उपसमूह) का उपयोग करता है, और cofactor (सहगुणक) h_G का मान 8 है। P_G := Ed25519 का आधार बिंदु B। l_H := 512 H(x) := SHA-512(\u0026ldquo;I2P_Red25519H(x)\u0026rdquo; || x) हैश फ़ंक्शन चयन पर टिप्पणी: Red25519, Zcash RedDSA में उपयोग होने वाले BLAKE2b-512 के बजाय SHA-512 का उपयोग करता है। इस डिज़ाइन विकल्प की भरपाई नीचे वर्णित length-prefixing (संदेश की लंबाई को पहले जोड़ने की तकनीक) सुरक्षा से की जाती है। I2P Proposal 148 भविष्य में Duplicate Message Identification (DMI; दुहराए गए संदेश की पहचान) और Length Extension Attacks (LEA; लंबाई विस्तार हमले) के विरुद्ध उन्नत सुरक्षा तथा बेहतर प्रदर्शन के लिए BLAKE2b-512 पर स्थानांतरण का सुझाव देता है।\nRedDSA यह मानता है कि H(x) को ऐसे क्रिप्टोग्राफ़िक हैश फ़ंक्शन से इंस्टैंशिएट किया गया है जो length extension attacks (ऐसे हमले जिनमें हमलावर हैश के आउटपुट से संदेश की लंबाई बढ़ाकर वैध हैश बना सकता है) के प्रति सुरक्षित है। SHA-512 अपने आप में इस शर्त को पूरा नहीं करता। इसे दूर करने के लिए, हम यह आवश्यक करते हैं कि संदेशों के प्रारंभ में उनकी लंबाई के prefix-free encoding (ऐसी एन्कोडिंग जिसमें कोई भी वैध कोडवर्ड किसी अन्य वैध कोडवर्ड का उपसर्ग न हो) का प्रीफ़िक्स जोड़ा जाए:\nlen_u16(M) || M जहाँ len_u16(M) M की लंबाई का 2-बाइट प्रतिनिधित्व है, लिटल-एंडियन (कम-महत्व वाले बाइट पहले) में, ताकि स्केलर और बिंदुओं की लिटल-एंडियन एन्कोडिंग के साथ सुसंगत रहे।\nसंदेश 65534 बाइट्स से अधिक लंबे नहीं होने चाहिए। 65535 की लंबाई संभावित भविष्य के विस्तारों के लिए आरक्षित है।\nSecurity Note: हैश फ़ंक्शन में पब्लिक की (vk) का समावेश, और हस्ताक्षर में 80 रैंडम बाइट्स के उपयोग का संयोजन, प्रारंभिक RedDSA डिज़ाइनों में खोजी गई SURK-CMA (Strong Unforgeability with Re-randomized Keys under Chosen Message Attack — चुने हुए संदेश हमले के तहत पुनः-रैंडमाइज़्ड कुंजियों के साथ मजबूत नकली-रोधीता) कमजोरियों से सुरक्षा सुनिश्चित करता है। यह इम्प्लीमेंटेशन NCC Group Zcash ऑडिट (Finding NCC-Zcash2018-009) से सुरक्षा सुधारों को सम्मिलित करता है।\nएन्कोडिंग और डिकोडिंग Red25519 निजी कुंजियाँ mod L स्केलर होती हैं, जिन्हें little-endian निरूपण (कम-से-उच्च बाइट क्रम) में एन्कोड किया जाता है। हम DECODE_SCALAR और ENCODE_SCALAR फ़ंक्शनों को परिभाषित करते हैं, जो स्केलर के बाइट ऐरे और पूर्णांक रूपों के बीच रूपांतरण के लिए हैं।\nRed25519 सार्वजनिक कुंजियाँ Curve25519 के एडवर्ड्स रूप पर स्थित बिंदु होती हैं। इनका एन्कोडिंग y-निर्देशांक के 255-बिट little-endian (बाइट क्रम जिसमें सबसे कम महत्त्व वाला बाइट पहले होता है) निरूपण के रूप में किया जाता है, जिसके बाद x-निर्देशांक के चिन्ह (sign) को दर्शाने वाला एक बिट जोड़ा जाता है। यह एन्कोडिंग Ed25519 के समान ही है। हम बिंदु के बाइट ऐरे और निर्देशांक रूपों के बीच रूपांतरण हेतु DECODE_POINT और ENCODE_POINT फ़ंक्शन परिभाषित करते हैं।\nRedDSA (एक क्रिप्टोग्राफ़िक हस्ताक्षर योजना) के फ़ंक्शन्स कार्यान्वयन में सुविधा के लिए, हम नीचे Red25519 के लिए पहले से विशेषीकृत RedDSA (डिजिटल हस्ताक्षर योजना) के फ़ंक्शन (तथा कई सहायक फ़ंक्शन) स्पष्ट रूप से प्रस्तुत करते हैं। RedDSA फ़ंक्शनों के सामान्य विनिर्देशन के लिए, कार्यान्वयनकर्ताओं को Zcash Protocol Specification के अनुभाग 5.4.6 का संदर्भ लेना चाहिए।\nHStar(prefix1, prefix2, m) := h = SHA-512() h.input(\u0026#34;I2P_Red25519H(x)\u0026#34;) h.input(prefix1) h.input(prefix2) h.input(len(m) \u0026amp; 0xff) h.input((len(m) \u0026gt;\u0026gt; 8) \u0026amp; 0xff) h.input(m) s = h.digest() return s mod L GENERATE_PRIVATE := s = 64 random bytes return s mod L DERIVE_PUBLIC(sk) := [sk] B GENERATE_RANDOM := s = 64 random bytes return s mod L RANDOMIZE_PRIVATE(sk, alpha) := (sk + alpha) mod L RANDOMIZE_PUBLIC(vk, alpha) := vk + [alpha] B SIGN(sk, m) := T = 80 random bytes vkBytes = ENCODE_POINT(DERIVE_PUBLIC(sk)) r = HStar(T, vkBytes, m) R = [r] B Rbytes = ENCODE_POINT(R) c = HStar(Rbytes, vkBytes, m) S = (r + (c * sk)) mod L return Rbytes || ENCODE_SCALAR(S) VERIFY(vk, m, sig) := Rbytes = sig[0..32] Sbytes = sig[32..64] R = DECODE_POINT(Rbytes) if R is invalid: return false S = DECODE_SCALAR(Sbytes) if S \u0026gt;= L: return false vkBytes = ENCODE_POINT(vk) c = HStar(Rbytes, vkBytes, m) return ((-[S] B) + R + ([c] vk)).multiplyByCofactor().isIdentity() रूपांतरण फ़ंक्शन्स CONVERT_ED25519_PRIVATE(privkey) := s = SHA-512(privkey)[0..32] s[0] = s[0] \u0026amp; 248 s[31] = (s[31] \u0026amp; 63) | 64 return s CONVERT_ED25519_PUBLIC(pubkey) := pubkey ध्यान दें कि CONVERT_ED25519_PRIVATE का कार्यान्वयन Ed25519 निजी कुंजी से Ed25519 सार्वजनिक कुंजी व्युत्पन्न करते समय गोपनीय स्केलर s की गणना के समकक्ष है, जैसा कि RFC 8032 के अनुभाग 5.1.5 के चरण 1-3 में निर्दिष्ट है।\nसुरक्षा संबंधी निहितार्थ Red25519 Destination (I2P का गंतव्य/पहचान) को पुनः-रैंडमाइज़ करना और फिर उसका उपयोग करके हस्ताक्षर बनाना Destination के बारे में कोई जानकारी लीक नहीं करता, क्योंकि RANDOMIZE_PRIVATE के माध्यम से उत्पन्न Red25519 निजी कुंजियों का वितरण GENERATE_PRIVATE के माध्यम से उत्पन्न निजी कुंजियों के वितरण के समान होता है, और DERIVE_PUBLIC निर्धारक है।\nCONVERT_ED25519_PRIVATE के माध्यम से Ed25519 (एक elliptic-curve आधारित डिजिटल हस्ताक्षर एल्गोरिथ्म) निजी कुंजियों को Red25519 (Ed25519 से व्युत्पन्न कुंजी-रूप) में रूपांतरित करने पर वही वितरण प्राप्त नहीं होता। फिर भी, सुरक्षा में होने वाली कमी को हम निम्नलिखित कारणों से स्वीकार्य मानते हैं:\nEd25519 स्केलरों का समुच्चय, Red25519 स्केलरों के समुच्चय की तुलना में लगभग आधा है (संभव Ed25519 स्केलर 2^251 हैं, और Red25519 के लिए L ~= 2^252 संभावित स्केलर हैं)। इसलिए सुरक्षा में हानि अधिकतम लगभग 2 का गुणांक, या लगभग 1 बिट है (क्योंकि संभव है कि हमने संयोगवश ऐसा Red25519 स्केलर चुना हो जो एक वैध Ed25519 स्केलर भी हो)। मौजूदा Ed25519 डेस्टिनेशन पहले ही ऐतिहासिक रूप से नेटवर्क पर उजागर हो चुके हैं, और यह मानकर चलना चाहिए कि दुर्भावनापूर्ण floodfills ने उन्हें पहले ही सूचीबद्ध कर लिया है। महत्वपूर्ण: जो उपयोगकर्ता इस सुरक्षा में आई कमी को लेकर चिंतित हैं, उन्हें अपने Destinations के लिए sigtype (हस्ताक्षर प्रकार) के रूप में Red25519 (signature type 11) का, Ed25519 (signature type 7) के बजाय, उपयोग करना चाहिए।\nध्यान दें कि ऊपर दिया गया तर्क re-randomization scalar alpha (दोबारा-यादृच्छिकीकरण में प्रयुक्त स्केलर alpha) पर लागू नहीं होता; हर बार एक पक्षपाती alpha चुने जाने पर कुंजी के बारे में जानकारी लीक होती है, क्योंकि additive re-randomization (जोड़ात्मक दोबारा-यादृच्छिकीकरण) एक one-time pad (एक-बार-उपयोग एन्क्रिप्शन योजना) की तरह व्यवहार करता है।\nसुरक्षा ऑडिट की स्थिति महत्वपूर्ण प्रकटीकरण: I2P, जिसमें Red25519 भी शामिल है, ने कभी औपचारिक तृतीय-पक्ष सुरक्षा ऑडिट नहीं कराया है। अंतर्निहित RedDSA डिज़ाइन 2018 में Zcash Sapling प्रोटोकॉल ऑडिट के हिस्से के रूप में NCC Group द्वारा सुरक्षा समीक्षा से गुज़रा, जहाँ सुरक्षा समस्याओं की पहचान की गई और उन्हें ठीक किया गया। हालाँकि, SHA-512 (BLAKE2b-512 के स्थान पर) के साथ I2P के इस विशिष्ट क्रियान्वयन तथा I2P डोमेन पृथक्करण, दोनों का स्वतंत्र रूप से विश्लेषण नहीं किया गया है।\nstr4d द्वारा ed25519-java का संदर्भ क्रियान्वयन का एक स्वतंत्र तृतीय-पक्ष ऑडिट हुआ था; हालांकि यह Red25519 के क्रियान्वयन से पहले था और इसने केवल Ed25519 की कार्यक्षमता को कवर किया, Red25519 के विस्तारों को नहीं।\nRed25519 को परिनियोजित करने वाले उपयोगकर्ताओं को इस सीमा को समझना चाहिए और अपने threat model (खतरा मॉडल) के आधार पर सुरक्षा संबंधी समझौतों का मूल्यांकन करना चाहिए।\nसंगतता I2P के वे संस्करण जो Red25519 (एक हस्ताक्षर एल्गोरिथ्म) का समर्थन करते हैं (संस्करण 0.9.39 और उसके बाद), उससे हस्ताक्षरित नेटवर्क डेटा संरचनाओं का सत्यापन कर सकेंगे। जो I2P संस्करण Red25519 का समर्थन नहीं करते, वे इसे अज्ञात हस्ताक्षर मानेंगे, और उन डेटा संरचनाओं को खारिज भी कर सकते हैं (MAY)।\nपरिनियोजन समयरेखा: - 0.9.39 (मार्च 2019): floodfills में Encrypted LS2 (कूटित leaseSet संस्करण 2) समर्थन के साथ पहला कार्यान्वयन - 0.9.40 (मई 2019): Encrypted LS2 के लिए प्रति‑क्लाइंट प्राधिकरण - 0.9.41 (अगस्त 2019): Meta LS2 तथा ऑफ़लाइन कुंजियों सहित Encrypted LS2 - 0.9.43 (फ़रवरी 2020): Encrypted LS2 के लिए b32 समर्थन - 0.9.47 (अगस्त 2020): विनिर्देश का अंतिमीकरण - 2.10.0 (अक्टूबर 2025): वर्तमान नेटवर्क संस्करण (0.9.67+ के समकक्ष)\nउपयोगकर्ताओं को अपेक्षा करनी चाहिए कि Red25519 से हस्ताक्षरित डेटा संरचनाएँ Encrypted LeaseSet2 उपयोग मामलों के लिए विश्वसनीय होंगी, क्योंकि प्रारंभिक कार्यान्वयन के बाद से नेटवर्क को अपग्रेड करने के लिए छह से अधिक वर्ष मिल चुके हैं। हालांकि, destination (I2P का पता/पहचानकर्ता) के सामान्य उपयोग के अपनाने के आँकड़े सार्वजनिक रूप से उपलब्ध नहीं हैं।\nप्राथमिक उपयोग मामला: Red25519 का उपयोग मुख्यतः एन्क्रिप्टेड LeaseSet2 कार्यात्मकता के लिए किया जाता है, जहाँ key blinding (कुंजी ब्लाइंडिंग) आवश्यक होती है। एन्क्रिप्टेड leaseset आवश्यकताओं के बिना मानक डेस्टिनेशन के लिए, व्यापक अनुकूलता और लंबे समय से सिद्ध ट्रैक रिकॉर्ड के कारण Ed25519 (हस्ताक्षर प्रकार 7) अनुशंसित विकल्प बना रहता है।\nकार्यान्वयन संबंधी टिप्पणियाँ Red25519 को I2P Java router में net.i2p.crypto.eddsa.RedDSAEngine पर लागू किया गया है, और यह str4d (Jack Grigg) द्वारा विकसित ed25519-java लाइब्रेरी का उपयोग Maven निर्भरता net.i2p.crypto:eddsa (संस्करण 0.1.0 से 0.3.0 तक) के रूप में करता है।\ni2pd का C++ कार्यान्वयन कूटबद्ध LeaseSet के प्रकाशन के लिए Red25519 (signaturetype=11) का भी समर्थन करता है।\ni2pd के लिए विन्यास उदाहरण:\nsignaturetype=11 i2cp.leaseSetType=5 Encrypted LeaseSet2 Compatibility: Encrypted LeaseSet विनिर्देश यह निर्धारित करता है कि unblinded destination (ब्लाइंडिंग हटाया गया गंतव्य) में मौजूद हस्ताक्षर हेतु सार्वजनिक कुंजी Ed25519 (हस्ताक्षर प्रकार 7) या Red25519 (हस्ताक्षर प्रकार 11) होनी चाहिए। encrypted leaseset कार्यक्षमता के लिए अन्य किसी हस्ताक्षर प्रकार का समर्थन नहीं है।\nपरीक्षण वेक्टर कार्यान्वयन सत्यापन के लिए निम्नलिखित परीक्षण वेक्टर प्रदान किए गए हैं। प्रत्येक वेक्टर में निम्न शामिल होते हैं:\nedsk: Ed25519 निजी कुंजी (यादृच्छिक) edpk: Ed25519 सार्वजनिक कुंजी जो edsk के अनुरूप है sk: CONVERT_ED25519_PRIVATE(edsk) vk: CONVERT_ED25519_PUBLIC(edpk) msg: हस्ताक्षर हेतु संदेश sig: SIGN(sk, msg) alpha: GENERATE_RANDOM() rsk: RANDOMIZE_PRIVATE(sk, alpha) rvk: RANDOMIZE_PUBLIC(vk, alpha) rsig: SIGN(rsk, msg) कार्यान्वयन संबंधी नोट: इन test vectors (परीक्षण वेक्टर) को निरंतर सत्यापन के लिए स्वचालित unit test suites (इकाई परीक्षण सूट) में एकीकृत किए जाने चाहिए। कार्यान्वयनकर्ता यह सत्यापित करें कि सभी रूपांतरण, हस्ताक्षर, और re-randomization (पुनः-यादृच्छिकीकरण) क्रियाएँ इन अपेक्षित मानों से मेल खाती हैं।\nटेस्ट वेक्टर 1 edsk: 0101010101010101010101010101010101010101010101010101010101010101 edpk: 8a88e3dd7409f195fd52db2d3cba5d72ca6709bf1d94121bf3748801b40f6f5c sk: 58e86efb75fa4e2c410f46e16de9f6acae1a1703528651b69bc176c088bef36e vk: 8a88e3dd7409f195fd52db2d3cba5d72ca6709bf1d94121bf3748801b40f6f5c msg: 0202020202020202020202020202020202020202020202020202020202020202 sig: 61f5527f4d3b46de4b2c234390370bf715ae9098907a0d191ba1b44b23a8ac1a 6a40437a5294e9503faaf9bd2b7f2fe7ba44dec487b3185aba7ff7d7a17cd40f alpha: ae9ba9cbbc047c442448fca7c9f4e288a202ed520bfad0c784b792b7773cee08 rsk: 8bb85f3c7a494a08890d7d142109c1a3501d04565d80227e2079097800fbe107 rvk: 6fe128737b8e76fa66698a748b0dc0a89168dd8a0601c2b1c0b26835d323e9b3 rsig: 533053074d3b44f08723aab988ede9880a001b7a684d4a98f2d1b88fabee07a5 b5c9430c69a690321e0cb8365d7aeb6688bcbad2c0780e0c69e8a1b4a45f3001 परीक्षण वेक्टर 2 edsk: 0202020202020202020202020202020202020202020202020202020202020202 edpk: 8139770ea87d175f56a35466c34c7ecccb8d8a91b4ee37a25df60f5b8fc9b394 sk: a83c626bc9c38c8c201878ebb1d5b0b50ac40e8986c78793db1d4ef369fca14e vk: 8139770ea87d175f56a35466c34c7ecccb8d8a91b4ee37a25df60f5b8fc9b394 msg: 0303030303030303030303030303030303030303030303030303030303030303 sig: 0829e58eb5399870f009bd1f0270264e556424bda7a93fbcec99f6d9d75db46d 5c3cb546d9947ca7c1200876c8775a90c357a2aef3d2f16388242ee1914b1a0a alpha: 98b615d9027e996cc2796c019d9c8beb46aa7d2b6eea2e5d98eb29eb1584c203 rsk: 9fcfaa734852ca40b3810ebef590e138516e8cb4f4b1b6f0730978de7f806402 rvk: 527e121090158419609e4a0d8de6f7d3271b353a8cd0b8172fe41468ea1e9177 rsig: 9a6961f35ed264a946cd6214b2326a6e6caa426c2a61bc14367fd278e0b5fb51 3ac065a69210a457f17d12ba8a496cfd835002691affa8efcdecae48135c090f ध्यान दें: अतिरिक्त test vectors (परीक्षण वेक्टर) 3-10 उसी प्रारूप का पालन करते हैं और संदर्भ कार्यान्वयन में उपलब्ध हैं।\nसंदर्भ प्रस्ताव 123: नई netDB प्रविष्टियाँ - कुछ हिस्से 0.9.38, 0.9.39 और बाद के रिलीज़ में लागू और परिनियोजित किए गए Zcash प्रोटोकॉल विनिर्देशन, अनुभाग 5.4.6: RedDSA, RedJubjub, और RedPallas - RedDSA को Zcash प्रोटोकॉल विनिर्देशन के हिस्से के रूप में परिभाषित किया गया है; NCC Group द्वारा सुरक्षा ऑडिट (जनवरी 2019) RFC 8032: Edwards-Curve डिजिटल हस्ताक्षर एल्गोरिद्म (EdDSA) प्रस्ताव 148: RedDSA-BLAKE2b-Ed25519 - प्रस्तावित, पर अभी लागू नहीं; भविष्य में BLAKE2b-512 पर माइग्रेशन का सुझाव देता है एन्क्रिप्टेड LeaseSet विनिर्देशन निम्न-स्तरीय क्रिप्टोग्राफी विनिर्देशन ","description":"ब्लाइंडेड Destinations (I2P के पते/गंतव्य) बनाने के लिए पुनः-यादृच्छीकरण-योग्य हस्ताक्षर योजना","id":"31b087e2977ad9f01f6b3b93e6af1f20","section":"docs","title":"Red25519 डिजिटल हस्ताक्षर योजना","url":"/hi/docs/specs/red25519-signature-scheme/"},{"categories":null,"content":"Reseed होस्ट्स के बारे में नए routers को I2P नेटवर्क से जुड़ने के लिए कुछ पीयर्स की आवश्यकता होती है। Reseed hosts (reseed: प्रारंभिक पीयर्स का सेट प्राप्त करने की प्रक्रिया) एन्क्रिप्टेड HTTPS डाउनलोड्स के माध्यम से वह प्रारंभिक bootstrap सेट (आरंभिक सेटअप हेतु डेटा) उपलब्ध कराते हैं। प्रत्येक reseed bundle host द्वारा साइन किया जाता है, जिससे अप्रमाणित पक्षों द्वारा छेड़छाड़ रोकी जाती है। स्थापित routers समय-समय पर, यदि उनका पीयर सेट पुराना हो जाए, तो reseed कर सकते हैं।\nनेटवर्क बूटस्ट्रैप प्रक्रिया जब कोई I2P router पहली बार शुरू होता है या लंबे समय तक ऑफ़लाइन रहा होता है, तो नेटवर्क से जुड़ने के लिए उसे RouterInfo डेटा की आवश्यकता होती है। क्योंकि router के पास कोई मौजूदा पीयर्स नहीं होते, वह यह जानकारी I2P नेटवर्क के भीतर से प्राप्त नहीं कर सकता। reseed तंत्र (प्रारंभिक बूटस्ट्रैप प्रक्रिया) विश्वसनीय बाहरी HTTPS सर्वरों से RouterInfo फ़ाइलें प्रदान करके इस बूटस्ट्रैप समस्या का समाधान करता है।\nreseed प्रक्रिया (नए router को नेटवर्क से जोड़ने हेतु शुरुआती डेटा प्राप्त करने की प्रक्रिया) एकल क्रिप्टोग्राफ़िक रूप से हस्ताक्षरित बंडल में 75-100 RouterInfo फ़ाइलें प्रदान करती है। यह सुनिश्चित करता है कि नए router मैन-इन-द-मिडल हमलों के प्रति उजागर हुए बिना शीघ्रता से कनेक्शन स्थापित कर सकें, जो उन्हें अविश्वसनीय, पृथक नेटवर्क विभाजनों में अलग-थलग कर सकते हैं।\nवर्तमान नेटवर्क स्थिति अक्टूबर 2025 तक, I2P नेटवर्क router संस्करण 2.10.0 (API संस्करण 0.9.67) पर संचालित हो रहा है। संस्करण 0.9.14 में पेश किया गया reseed प्रोटोकॉल (नए router को नेटवर्क की प्रारंभिक जानकारी उपलब्ध कराने की प्रक्रिया) अपनी मुख्य कार्यक्षमता में स्थिर है और अपरिवर्तित बना हुआ है। उपलब्धता और सेंसरशिप-प्रतिरोध सुनिश्चित करने के लिए नेटवर्क विश्वभर में वितरित कई स्वतंत्र reseed सर्वर बनाए रखता है।\nसेवा checki2p हर 4 घंटे पर सभी I2P reseed (बूटस्ट्रैप डेटा वितरण) सर्वरों की निगरानी करती है, और reseed अवसंरचना के लिए रीयल-टाइम स्थिति जाँच और उपलब्धता मेट्रिक्स प्रदान करती है।\nSU3 फ़ाइल प्रारूप विनिर्देश SU3 फ़ाइल फ़ॉर्मेट I2P के reseed (नेटवर्क के प्रारंभिक netDb डेटा और संपर्क प्राप्त करने की प्रक्रिया) प्रोटोकॉल का आधार है, जो क्रिप्टोग्राफ़िक रूप से हस्ताक्षरित सामग्री का वितरण प्रदान करता है। इस फ़ॉर्मेट को समझना reseed सर्वर और क्लाइंट्स के कार्यान्वयन के लिए आवश्यक है।\nफ़ाइल संरचना SU3 प्रारूप तीन मुख्य घटकों से बना होता है: हेडर (40+ बाइट्स), सामग्री (परिवर्तनीय लंबाई), और हस्ताक्षर (जिसकी लंबाई हेडर में निर्दिष्ट होती है)।\nहेडर प्रारूप (बाइट्स 0-39 न्यूनतम) Byte Range Field Description 0-5Magic NumberASCII string \"I2Psu3\" (0x493250737533) 6ReservedUnused, must be 0x00 7File Format VersionCurrent version: 0x00 8-9Signature TypeBig-endian 16-bit integer. Type 6 = RSA-4096-SHA512 (reseed standard) 10-11Signature LengthBig-endian 16-bit integer. 512 bytes (0x0200) for RSA-4096 12ReservedUnused, must be 0x00 13Version LengthMinimum 16 bytes (0x10) for compatibility 14ReservedUnused, must be 0x00 15Signer ID LengthLength of UTF-8 signer identifier string 16-23Content LengthBig-endian 64-bit integer, length of content in bytes 24ReservedUnused, must be 0x00 25File Type0x00 = ZIP, 0x01 = XML, 0x02 = HTML, 0x03 = XML.GZ, 0x04 = TXT.GZ, 0x05 = DMG, 0x06 = EXE 26ReservedUnused, must be 0x00 27Content Type0x00 = unknown, 0x01 = router update, 0x02 = plugin, 0x03 = reseed, 0x04 = news, 0x05 = blocklist 28-39PaddingUnused, must be all zeros 40-55Version StringASCII version string, padded with zeros (minimum 16 bytes) 56-...Signer IDUTF-8 encoded signer identifier (e.g., \"user@mail.i2p\") ### Reseed (I2P नेटवर्क की प्रारंभिक बूटस्ट्रैप/सीडिंग प्रक्रिया)-विशिष्ट SU3 (हस्ताक्षरित अपडेट/रीसीड फ़ाइल फ़ॉर्मेट) पैरामीटर रीसीड बंडलों के लिए, SU3 फ़ाइल में निम्नलिखित विशेषताएँ होनी चाहिए:\nफ़ाइल नाम: ठीक-ठीक i2pseeds.su3 होना चाहिए सामग्री प्रकार (बाइट 27): 0x03 (RESEED) फ़ाइल प्रकार (बाइट 25): 0x00 (ZIP) हस्ताक्षर प्रकार (बाइट 8-9): 0x0006 (RSA-4096-SHA512) संस्करण स्ट्रिंग: ASCII में Unix timestamp (epoch (एपोक) के बाद से सेकंड, date +%s फ़ॉर्मेट) हस्ताक्षरकर्ता ID: X.509 प्रमाणपत्र के CN से मेल खाता ईमेल-शैली का पहचानकर्ता नेटवर्क ID क्वेरी पैरामीटर संस्करण 0.9.42 से, routers reseed अनुरोधों (प्रारंभिक नेटवर्क बूटस्ट्रैप हेतु) में ?netid=2 जोड़ते हैं। यह विभिन्न नेटवर्कों के बीच कनेक्शनों को रोकता है, क्योंकि टेस्ट नेटवर्क अलग-अलग नेटवर्क ID का उपयोग करते हैं। वर्तमान I2P प्रोडक्शन नेटवर्क नेटवर्क ID 2 का उपयोग करता है।\nउदाहरण अनुरोध: https://reseed.example.com/i2pseeds.su3?netid=2\nZIP सामग्री संरचना सामग्री अनुभाग (हेडर के बाद, सिग्नेचर से पहले) में निम्नलिखित आवश्यकताओं वाला एक मानक ZIP आर्काइव समाहित होता है:\nसंपीड़न: मानक ZIP संपीड़न (DEFLATE) फ़ाइल संख्या: आम तौर पर 75-100 RouterInfo फ़ाइलें (I2P router की जानकारी वाली फ़ाइलें) डायरेक्टरी संरचना: सभी फ़ाइलें शीर्ष स्तर पर ही होनी चाहिए (कोई उप-डायरेक्टरी नहीं) फ़ाइल नामकरण: routerInfo-{44-character-base64-hash}.dat Base64 वर्णमाला: I2P की परिवर्तित Base64 वर्णमाला का उपयोग अनिवार्य है I2P Base64 वर्णमाला, फ़ाइल सिस्टम और URL संगतता सुनिश्चित करने के लिए + और / की जगह - और ~ का उपयोग करती है, इसलिए यह मानक Base64 से भिन्न है।\nक्रिप्टोग्राफिक हस्ताक्षर हस्ताक्षर बाइट 0 से लेकर सामग्री अनुभाग के अंत तक पूरी फ़ाइल को कवर करता है। स्वयं हस्ताक्षर सामग्री के बाद जोड़ा जाता है।\nहस्ताक्षर एल्गोरिदम (RSA-4096-SHA512) बाइट 0 से सामग्री के अंत तक का SHA-512 हैश निकालें \u0026ldquo;raw\u0026rdquo; RSA का उपयोग करके हैश पर डिजिटल हस्ताक्षर करें (Java की शब्दावली में NONEwithRSA) 512 बाइट तक पहुँचाने के लिए, आवश्यकता होने पर डिजिटल हस्ताक्षर को शुरुआत में शून्य जोड़कर पैड करें 512-बाइट का डिजिटल हस्ताक्षर फ़ाइल के अंत में जोड़ें हस्ताक्षर सत्यापन प्रक्रिया क्लाइंटों को निम्नलिखित करना आवश्यक है:\nहस्ताक्षर के प्रकार और लंबाई निर्धारित करने के लिए बाइट्स 0-11 पढ़ें सामग्री की सीमाएँ पता लगाने के लिए पूरा हेडर पढ़ें SHA-512 हैश की गणना करते हुए सामग्री को स्ट्रीम करें फ़ाइल के अंत से डिजिटल हस्ताक्षर निकालें हस्ताक्षरकर्ता की RSA-4096 सार्वजनिक कुंजी का उपयोग करके डिजिटल हस्ताक्षर सत्यापित करें यदि डिजिटल हस्ताक्षर का सत्यापन विफल हो, तो फ़ाइल को अस्वीकार करें प्रमाणपत्र विश्वास मॉडल Reseed साइनर कुंजियाँ RSA-4096 कुंजियों के साथ स्वहस्ताक्षरित X.509 प्रमाणपत्रों के रूप में वितरित की जाती हैं। ये प्रमाणपत्र I2P router पैकेजों में certificates/reseed/ निर्देशिका में शामिल होते हैं।\nप्रमाणपत्र प्रारूप: - कुंजी प्रकार: RSA-4096 - हस्ताक्षर: स्व-हस्ताक्षरित - Subject CN (सामान्य नाम): SU3 हेडर में Signer ID से मेल खाना चाहिए - वैधता तिथियाँ: क्लाइंट्स को प्रमाणपत्र की वैधता अवधि का अनुपालन सुनिश्चित करना चाहिए\nReseed Host चलाना (I2P नेटवर्क में आरंभिक नेटवर्क डेटा प्रदान करने वाला सर्वर) reseed सेवा (नए routers को प्रारंभिक नेटवर्क समकक्ष उपलब्ध कराने वाली सेवा) का संचालन सुरक्षा, विश्वसनीयता, और नेटवर्क विविधता संबंधी आवश्यकताओं पर सावधानीपूर्वक ध्यान देने की मांग करता है। अधिक स्वतंत्र reseed होस्ट प्रतिरोधक क्षमता बढ़ाते हैं और आक्रमणकारियों या सेंसरों के लिए नए routers के जुड़ने को अवरुद्ध करना अधिक कठिन बना देते हैं।\nतकनीकी आवश्यकताएँ सर्वर विनिर्देश ऑपरेटिंग सिस्टम: Unix/Linux (Ubuntu, Debian, FreeBSD परीक्षित और अनुशंसित) कनेक्टिविटी: स्थिर IPv4 पता आवश्यक, IPv6 अनुशंसित लेकिन वैकल्पिक CPU: न्यूनतम 2 कोर RAM: न्यूनतम 2 GB बैंडविड्थ: प्रति माह लगभग 15 GB अपटाइम: 24/7 संचालन आवश्यक I2P Router: अच्छी तरह से एकीकृत I2P router, जो लगातार चलता रहे सॉफ़्टवेयर आवश्यकताएँ Java: JDK 8 या उससे नया (I2P 2.11.0 से Java 17+ आवश्यक होगा) वेब सर्वर: nginx या Apache, reverse proxy समर्थन के साथ (X-Forwarded-For हेडर की सीमाओं के कारण Lighttpd अब समर्थित नहीं है) TLS/SSL: मान्य TLS प्रमाणपत्र (Let\u0026rsquo;s Encrypt, स्व-हस्ताक्षरित, या व्यावसायिक CA) DDoS सुरक्षा: fail2ban या समकक्ष (अनिवार्य, वैकल्पिक नहीं) Reseed टूल्स: https://i2pgit.org/idk/reseed-tools से आधिकारिक reseed-tools सुरक्षा आवश्यकताएँ HTTPS/TLS कॉन्फ़िगरेशन प्रोटोकॉल: केवल HTTPS, HTTP पर कोई फॉलबैक नहीं TLS संस्करण: न्यूनतम TLS 1.2 साइफ़र सूट: Java 8+ के साथ संगत मज़बूत सिफरों का समर्थन होना चाहिए प्रमाणपत्र CN/SAN (कॉमन नेम/सब्जेक्ट अल्टरनेटिव नेम): सर्व किए जा रहे URL के होस्टनेम से मेल खाना चाहिए प्रमाणपत्र प्रकार: यदि डेव टीम को सूचित किया गया हो तो स्व-हस्ताक्षरित हो सकता है, या मान्यता प्राप्त CA द्वारा जारी प्रमाणपत्र प्रबंधन SU3 हस्ताक्षर प्रमाणपत्र और TLS प्रमाणपत्र अलग उद्देश्यों की पूर्ति करते हैं:\nTLS प्रमाणपत्र (certificates/ssl/): HTTPS ट्रांसपोर्ट को सुरक्षित करता है SU3 (I2P में हस्ताक्षरित अपडेट/रीसीड फाइल का फॉर्मेट) हस्ताक्षर प्रमाणपत्र (certificates/reseed/): रीसीड बंडलों पर हस्ताक्षर करता है router पैकेजों में शामिल करने के लिए दोनों प्रमाणपत्रों को reseed (प्रारंभिक नोड-सूची उपलब्ध कराने की प्रक्रिया) समन्वयक (zzz@mail.i2p ) को प्रदान किया जाना चाहिए।\nDDoS और स्क्रैपिंग सुरक्षा Reseed servers (रीसीड सर्वर—नेटवर्क में नए नोड्स को प्रारंभिक पीयर और नेटवर्क जानकारी प्रदान करने वाले सर्वर) को समय-समय पर त्रुटिपूर्ण कार्यान्वयनों, बॉटनेट्स, और नेटवर्क डेटाबेस को स्क्रैप करने का प्रयास करने वाले दुर्भावनापूर्ण तत्वों से हमलों का सामना करना पड़ता है। सुरक्षा उपायों में शामिल हैं:\nfail2ban: rate limiting (दर-सीमांकन) और हमले के शमन के लिए आवश्यक Bundle Diversity (बंडल विविधता): विभिन्न अनुरोधकर्ताओं को अलग-अलग RouterInfo सेट प्रदान करें Bundle Consistency (बंडल स्थिरता): उसी IP से दोहराए गए अनुरोधों के लिए, कॉन्फ़िगर योग्य समय-विंडो के भीतर वही बंडल प्रदान करें IP लॉगिंग प्रतिबंध: लॉग या IP पतों को सार्वजनिक न करें (गोपनीयता नीति की आवश्यकता) कार्यान्वयन विधियाँ विधि 1: आधिकारिक reseed-tools (अनुशंसित) I2P परियोजना द्वारा देखरेख किया जाने वाला प्रामाणिक कार्यान्वयन। रेपोजिटरी: https://i2pgit.org/idk/reseed-tools स्थापना:\n# Install dependencies sudo apt-get install golang git # Clone repository git clone https://i2pgit.org/idk/reseed-tools.git cd reseed-tools # Build make # Generate keys and start server (first run) ./reseed-tools reseed \\ --signer=your-email@mail.i2p \\ --netdb=/path/to/i2p/netDb \\ --tlsHost=your-domain.tld \\ --port=8443 पहली बार चलाने पर, टूल उत्पन्न करेगा: - your-email@mail.i2p.crt (SU3 साइनिंग प्रमाणपत्र) - your-email@mail.i2p.pem (SU3 साइनिंग निजी कुंजी) - your-email@mail.i2p.crl (प्रमाणपत्र रद्दीकरण सूची) - TLS प्रमाणपत्र और कुंजी फ़ाइलیں\nविशेषताएँ: - स्वचालित SU3 bundle (I2P अपडेट पैकेज फ़ॉर्मैट) जनरेशन (350 विविधताएँ, प्रत्येक में 77 RouterInfos (I2P router की जानकारी रिकॉर्ड)) - बिल्ट-इन HTTPS सर्वर - cron के माध्यम से हर 9 घंटे में कैश का पुनर्निर्माण - X-Forwarded-For हेडर के लिए --trustProxy फ्लैग के साथ समर्थन - reverse proxy कॉन्फ़िगरेशन के साथ संगत\nप्रोडक्शन परिनियोजन:\n# Create systemd service cat \u0026gt; /etc/systemd/system/i2p-reseed.service \u0026lt;\u0026lt; EOF [Unit] Description=I2P Reseed Server After=network.target [Service] Type=simple User=i2p-reseed WorkingDirectory=/opt/i2p-reseed ExecStart=/opt/i2p-reseed/reseed-tools reseed \\ --signer=your-email@mail.i2p \\ --netdb=/var/lib/i2p/netDb \\ --port=8443 \\ --ip=127.0.0.1 \\ --trustProxy Restart=always [Install] WantedBy=multi-user.target EOF systemctl enable i2p-reseed systemctl start i2p-reseed विधि 2: Python कार्यान्वयन (pyseeder) PurpleI2P परियोजना द्वारा वैकल्पिक कार्यान्वयन: https://github.com/PurpleI2P/pyseeder pip install pyseeder # Generate SU3 file echo \u0026#34;your_password\u0026#34; | pyseeder reseed \\ --netdb /path/to/netDb \\ --private-key priv_key.pem \\ --outfile i2pseeds.su3 \\ --signer-id user@mail.i2p # Serve via built-in server pyseeder serve \\ --port 8443 \\ --host 0.0.0.0 \\ --private-key priv_key.pem \\ --cert user_at_mail.i2p.crt \\ --file i2pseeds.su3 विधि 3: Docker परिनियोजन कंटेनरीकृत परिवेशों के लिए, कई Docker के लिए तैयार कार्यान्वयन उपलब्ध हैं:\nDivaExchange i2p-reseed: https://github.com/diva-exchange/i2p-reseed RTradeLtd/i2p-tools-1: Tor onion service (Tor नेटवर्क पर छिपी सेवा) और IPFS (विकेन्द्रीकृत फाइल सिस्टम) का समर्थन जोड़ता है रिवर्स प्रॉक्सी विन्यास nginx कॉन्फ़िगरेशन upstream i2p_reseed { server 127.0.0.1:8443; } server { listen 443 ssl http2; server_name reseed.example.com; ssl_certificate /path/to/tls-cert.crt; ssl_certificate_key /path/to/tls-key.key; ssl_protocols TLSv1.2 TLSv1.3; ssl_ciphers HIGH:!aNULL:!MD5; location / { proxy_pass http://i2p_reseed; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $remote_addr; proxy_set_header Host $host; } } Apache कॉन्फ़िगरेशन \u0026lt;VirtualHost *:443\u0026gt; ServerName reseed.example.com SSLEngine on SSLCertificateFile /path/to/tls-cert.crt SSLCertificateKeyFile /path/to/tls-key.key SSLProtocol all -SSLv2 -SSLv3 -TLSv1 -TLSv1.1 ProxyRequests Off \u0026lt;Proxy *\u0026gt; Order deny,allow Allow from all \u0026lt;/Proxy\u0026gt; ProxyPass / http://127.0.0.1:8443/ ProxyPassReverse / http://127.0.0.1:8443/ \u0026lt;/VirtualHost\u0026gt; पंजीकरण और समन्वय अपने reseed server (I2P में नए इंस्टॉलेशन को प्रारंभिक netDb डेटा देने वाला सर्वर) को आधिकारिक I2P पैकेज में शामिल करने के लिए:\nसेटअप और परीक्षण पूरा करें दोनों प्रमाणपत्र (SU3 signing और TLS) reseed coordinator (रीसीड समन्वयक) को भेजें संपर्क: zzz@mail.i2p या zzz@i2pmail.org अन्य ऑपरेटरों के साथ समन्वय के लिए IRC2P पर #i2p-dev से जुड़ें संचालन संबंधी सर्वोत्तम प्रथाएँ निगरानी और लॉगिंग आँकड़ों के लिए Apache/nginx के combined log format (संयुक्त लॉग फ़ॉर्मेट) को सक्षम करें log rotation (लॉग फ़ाइलों का रोलओवर) लागू करें (लॉग तेज़ी से बढ़ते हैं) बंडल निर्माण की सफलता और पुनर्निर्माण समय की निगरानी करें बैंडविड्थ उपयोग और अनुरोध पैटर्न को ट्रैक करें IP पते या विस्तृत प्रवेश लॉग कभी सार्वजनिक न करें रखरखाव समय-сारणी हर 9 घंटे: SU3 bundle cache (SU3 बंडल कैश) को पुनर्निर्मित करें (cron के माध्यम से स्वचालित) साप्ताहिक: हमलों के पैटर्न के लिए लॉग की समीक्षा करें मासिक: I2P router और reseed-tools (reseed उपकरण) को अपडेट करें आवश्यकतानुसार: TLS प्रमाणपत्र नवीनीकृत करें (Let\u0026rsquo;s Encrypt के साथ स्वचालित करें) पोर्ट चयन डिफ़ॉल्ट: 8443 (अनुशंसित) वैकल्पिक: 1024-49151 के बीच कोई भी पोर्ट पोर्ट 443: root विशेषाधिकार या पोर्ट फ़ॉरवर्डिंग की आवश्यकता होती है (iptables redirect अनुशंसित) पोर्ट फ़ॉरवर्डिंग का उदाहरण:\niptables -A PREROUTING -t nat -p tcp --dport 443 -j REDIRECT --to-port 8443 वैकल्पिक Reseed (I2P नेटवर्क से आरंभिक router जानकारी प्राप्त करने की प्रक्रिया) विधियाँ अन्य bootstrap (प्रारंभिक सेटअप) विकल्प प्रतिबंधात्मक नेटवर्कों के पीछे मौजूद उपयोगकर्ताओं की मदद करते हैं:\nफ़ाइल-आधारित reseed (प्रारंभिक netDb डेटा आयात) संस्करण 0.9.16 में पेश किया गया, फाइल-आधारित reseeding (नेटवर्क से प्रारंभिक peers/जानकारी प्राप्त करने की प्रक्रिया) उपयोगकर्ताओं को RouterInfo (router की जानकारी वाला रिकॉर्ड) बंडलों को मैन्युअल रूप से लोड करने की अनुमति देता है। यह विधि विशेष रूप से उन उपयोगकर्ताओं के लिए उपयोगी है जो सेंसरशिप वाले क्षेत्रों में हैं, जहाँ HTTPS reseed servers अवरुद्ध होते हैं।\nप्रक्रिया: 1. एक विश्वसनीय संपर्क अपने router का उपयोग करके एक SU3 बंडल तैयार करता है 2. बंडल को ईमेल, USB ड्राइव, या किसी अन्य out-of-band channel (मुख्य चैनल से अलग संचार माध्यम) के माध्यम से स्थानांतरित किया जाता है 3. उपयोगकर्ता i2pseeds.su3 को I2P कॉन्फ़िगरेशन डायरेक्टरी में रखता है 4. रीस्टार्ट पर Router स्वचालित रूप से बंडल का पता लगाता है और उसे प्रोसेस करता है\nप्रलेखन: /blog/2020/06/07/help-your-friends-join-i2p-by-sharing-reseed-bundles/\nउपयोग के मामले: - reseed servers (I2P में प्रारंभिक बूटस्ट्रैप/पीयर-खोज सर्वर) को ब्लॉक करने वाले राष्ट्रीय फायरवॉल के पीछे के उपयोगकर्ता - manual bootstrap की आवश्यकता वाले पृथक नेटवर्क - परीक्षण और विकास पर्यावरण\nCloudflare द्वारा प्रॉक्सी किया गया रीसीडिंग (I2P नेटवर्क में प्रारंभिक जुड़ने की प्रक्रिया) Cloudflare के CDN के माध्यम से reseed (नेटवर्क में प्रारम्भिक नोड-सूची प्राप्त करने की प्रक्रिया) ट्रैफ़िक को रूट करना उच्च सेंसरशिप वाले क्षेत्रों में संचालकों के लिए कई लाभ प्रदान करता है।\nलाभ: - क्लाइंट्स से मूल सर्वर का IP पता छिपा रहता है - Cloudflare के बुनियादी ढांचे के माध्यम से DDoS सुरक्षा - edge caching (नेटवर्क के किनारे पर कैशिंग) के माध्यम से भौगोलिक लोड वितरण - वैश्विक क्लाइंट्स के लिए बेहतर प्रदर्शन\nकार्यान्वयन आवश्यकताएँ: - --trustProxy फ्लैग reseed-tools में सक्रिय - DNS रिकॉर्ड के लिए Cloudflare प्रॉक्सी सक्रिय - X-Forwarded-For हेडर का उचित प्रबंधन\nमहत्वपूर्ण विचारणीय बातें: - Cloudflare पोर्ट प्रतिबंध लागू होते हैं (समर्थित पोर्ट का ही उपयोग करना होगा) - समान-क्लाइंट बंडल में संगति बनाए रखने के लिए X-Forwarded-For का समर्थन आवश्यक है - SSL/TLS विन्यास Cloudflare द्वारा प्रबंधित किया जाता है\nप्रलेखन: https://homepage.np-tokumei.net/post/notes-i2p-reseed-over-cloudflare/ सेंसरशिप-प्रतिरोधी रणनीतियाँ Nguyen Phong Hoang (USENIX FOCI 2019) के शोध में सेंसरशुदा नेटवर्क के लिए अतिरिक्त bootstrap methods (नेटवर्क तक प्रारंभिक पहुँच स्थापित करने की विधियाँ) की पहचान की गई है:\nक्लाउड स्टोरेज सेवा प्रदाता Box, Dropbox, Google Drive, OneDrive: सार्वजनिक लिंक पर SU3 फ़ाइलें (I2P पैकेज फ़ाइलें) होस्ट करें फ़ायदा: वैध सेवाओं को बाधित किए बिना इन्हें ब्लॉक करना कठिन है सीमा: उपयोगकर्ताओं को URL मैन्युअल रूप से वितरित करने की आवश्यकता होती है IPFS (एक विकेन्द्रीकृत पीयर-टू-पीयर फ़ाइल प्रणाली) वितरण InterPlanetary File System (IPFS, विकेन्द्रीकृत कंटेंट-ऐड्रेस्ड स्टोरेज नेटवर्क) पर रीसीड बंडल्स होस्ट करें कंटेंट-ऐड्रेस्ड स्टोरेज छेड़छाड़ को रोकता है टेकडाउन प्रयासों के प्रति प्रतिरोधी Tor की ओनियन सेवाएँ Reseed सर्वर (I2P में प्रारंभिक नेटवर्क डेटा उपलब्ध कराने वाले) .onion पतों के माध्यम से सुलभ IP-आधारित ब्लॉकिंग के प्रति प्रतिरोधी उपयोगकर्ता के सिस्टम पर Tor क्लाइंट आवश्यक है शोध प्रलेखन: https://homepage.np-tokumei.net/post/notes-censorship-resistant-i2p-reseeding/ ज्ञात I2P ब्लॉकिंग वाले देश 2025 तक, निम्नलिखित देशों द्वारा I2P reseed servers (I2P नेटवर्क से प्रारंभिक रूप से जुड़ने के लिए आवश्यक डेटा प्रदान करने वाले सर्वर) को अवरुद्ध किए जाने की पुष्टि हुई है:\nचीन ईरान ओमान कतर कुवैत इन क्षेत्रों के उपयोगकर्ताओं को वैकल्पिक bootstrap methods (नेटवर्क से प्रारंभिक कनेक्शन स्थापित करने की विधियाँ) या सेंसरशिप-प्रतिरोधी reseeding रणनीतियाँ (reseeding: netDb के लिए प्रारंभिक नोड/डेटा प्राप्त करने की रणनीतियाँ) का उपयोग करना चाहिए।\nकार्यान्वयनकर्ताओं के लिए प्रोटोकॉल विवरण Reseed (I2P नेटवर्क बूटस्ट्रैप) अनुरोध विनिर्देश क्लाइंट का व्यवहार सर्वर चयन: Router एक हार्डकोडेड reseed (प्रारंभिक नेटवर्क डेटा) URLs की सूची बनाए रखता है यादृच्छिक चयन: क्लाइंट उपलब्ध सूची से सर्वर को यादृच्छिक रूप से चुनता है अनुरोध प्रारूप: GET /i2pseeds.su3?netid=2 HTTP/1.1 User-Agent: सामान्य ब्राउज़रों की नकल करनी चाहिए (उदा., \u0026ldquo;Wget/1.11.4\u0026rdquo;) पुनः प्रयास लॉजिक: यदि SU3 अनुरोध विफल हो, तो इंडेक्स पेज पार्सिंग पर वापस जाएँ प्रमाणपत्र सत्यापन: TLS प्रमाणपत्र को सिस्टम ट्रस्ट स्टोर के साथ सत्यापित करें SU3 हस्ताक्षर सत्यापन: हस्ताक्षर को ज्ञात reseed प्रमाणपत्रों के साथ सत्यापित करें सर्वर का व्यवहार बंडल चयन: netDb से RouterInfos (router की जानकारी रिकॉर्ड) का छद्म-यादृच्छिक उपसमुच्चय चुनें क्लाइंट ट्रैकिंग: स्रोत IP द्वारा अनुरोधों की पहचान करें (X-Forwarded-For को ध्यान में रखते हुए) बंडल स्थिरता: समय-खिड़की के भीतर दोहराए गए अनुरोधों को वही बंडल लौटाएँ (आमतौर पर 8–12 घंटे) बंडल विविधता: नेटवर्क विविधता के लिए अलग-अलग क्लाइंट्स को अलग-अलग बंडल लौटाएँ Content-Type: application/octet-stream या application/x-i2p-reseed RouterInfo फ़ाइल प्रारूप reseed bundle (प्रारंभिक बीज पैकेज) में प्रत्येक .dat फ़ाइल में एक RouterInfo संरचना (router सूचना की संरचना) होती है:\nफ़ाइल नामकरण: routerInfo-{base64-hash}.dat - हैश 44 वर्णों का होता है और I2P base64 वर्णमाला का उपयोग करता है - उदाहरण: routerInfo-ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmn.dat\nफ़ाइल सामग्री: - RouterIdentity (router हैश, एन्क्रिप्शन कुंजी, हस्ताक्षर कुंजी) - प्रकाशन समय-चिह्न - Router पते (IP, पोर्ट, ट्रांसपोर्ट प्रकार) - Router क्षमताएँ और विकल्प - उपर्युक्त सभी डेटा को कवर करने वाला हस्ताक्षर\nनेटवर्क विविधता आवश्यकताएँ नेटवर्क के केंद्रीकरण को रोकने और Sybil attack (कई नकली पहचानें बनाकर किया जाने वाला हमला) का पता लगाने को सक्षम करने के लिए:\nपूर्ण NetDb डंप नहीं: किसी एकल क्लाइंट को सभी RouterInfos कभी न प्रदान करें यादृच्छिक सैंपलिंग: हर बंडल में उपलब्ध पीयर्स का अलग-अलग उपसमुच्चय होता है न्यूनतम बंडल आकार: 75 RouterInfos (राउटर जानकारी रिकॉर्ड) (मूल 50 से बढ़ाया गया) अधिकतम बंडल आकार: 100 RouterInfos नवीनता: RouterInfos हाल के होने चाहिए (उत्पन्न होने के 24 घंटों के भीतर) IPv6 संबंधी विचार वर्तमान स्थिति (2025): - कई reseed सर्वर (आरंभिक पीयर सूची प्रदान करने वाले) IPv6 पर अनुत्तरदायी हैं - क्लाइंट्स को विश्वसनीयता के लिए IPv4 को प्राथमिकता देनी चाहिए या उसे अनिवार्य करना चाहिए - नए परिनियोजन के लिए IPv6 समर्थन की सिफारिश की जाती है, पर यह अत्यावश्यक नहीं है\nकार्यान्वयन टिप्पणी: dual-stack servers (ऐसे सर्वर जो IPv4 और IPv6 दोनों का समर्थन करते हैं) को कॉन्फ़िगर करते समय, यह सुनिश्चित करें कि IPv4 और IPv6 दोनों के लिसन पते सही ढंग से कार्य कर रहे हों, या यदि IPv6 का उचित रूप से समर्थन नहीं किया जा सकता, तो उसे निष्क्रिय कर दें।\nसुरक्षा संबंधी विचार धमकी मॉडल reseed protocol (I2P नेटवर्क में netDb के लिए प्रारंभिक डेटा प्राप्त करने की प्रक्रिया) निम्न से बचाव करता है:\nमैन-इन-द-मिडल हमले: RSA-4096 हस्ताक्षर बंडल से छेड़छाड़ को रोकते हैं नेटवर्क विभाजन: कई स्वतंत्र रीसीड सर्वर एकल नियंत्रण बिंदु बनने से रोकते हैं सिबिल हमले: बंडल की विविधता हमलावर की उपयोगकर्ताओं को अलग-थलग करने की क्षमता को सीमित करती है सेंसरशिप: कई सर्वर और वैकल्पिक विधियाँ अतिरिक्तता प्रदान करते हैं reseed प्रोटोकॉल निम्न के विरुद्ध सुरक्षा प्रदान नहीं करता:\nसमझौता किए गए reseed servers (I2P नेटवर्क में प्रारम्भिक peers की सूची देने वाले सर्वर): यदि हमलावर reseed प्रमाणपत्र की निजी कुंजियों पर नियंत्रण कर ले पूर्ण नेटवर्क ब्लॉकिंग: यदि किसी क्षेत्र में सभी reseed विधियाँ ब्लॉक कर दी जाएँ दीर्घकालिक निगरानी: Reseed अनुरोध I2P में शामिल होने का प्रयास करने वाले IP पते का खुलासा करते हैं प्रमाणपत्र प्रबंधन निजी कुंजी सुरक्षा: - प्रयोग में न होने पर SU3 signing keys (SU3 फ़ाइलों को प्रमाणित करने वाली हस्ताक्षर कुंजियाँ) को ऑफ़लाइन रखें - कुंजी एन्क्रिप्शन के लिए मज़बूत पासवर्ड का उपयोग करें - कुंजियों और प्रमाणपत्रों के सुरक्षित बैकअप बनाए रखें - उच्च-मूल्य परिनियोजन के लिए hardware security modules (HSMs) (हार्डवेयर सुरक्षा मॉड्यूल—विशेषीकृत क्रिप्टोग्राफ़िक डिवाइस) पर विचार करें\nप्रमाणपत्र निरस्तीकरण: - प्रमाणपत्र निरस्तीकरण सूचियाँ (CRLs) समाचार फ़ीड के माध्यम से वितरित की जाती हैं - समझौता-ग्रस्त प्रमाणपत्रों को समन्वयक द्वारा निरस्त किया जा सकता है - Routers सॉफ़्टवेयर अपडेट के साथ CRLs को स्वतः अद्यतन करते हैं\nहमले का शमन DDoS (वितरित सेवा अभाव) सुरक्षा: - अत्यधिक अनुरोधों के लिए fail2ban नियम - वेब सर्वर स्तर पर दर-सीमा निर्धारण - प्रति IP पता कनेक्शन सीमाएँ - एक अतिरिक्त परत के लिए Cloudflare या इसी प्रकार का CDN (सामग्री वितरण नेटवर्क)\nस्क्रैपिंग की रोकथाम: - अनुरोध करने वाले प्रत्येक IP के लिए अलग-अलग बंडल - प्रति IP समय-आधारित बंडल कैशिंग - ऐसे लॉगिंग पैटर्न जो स्क्रैपिंग प्रयासों का संकेत देते हैं - पहचाने गए हमलों पर अन्य ऑपरेटरों के साथ समन्वय\nपरीक्षण और मान्यकरण अपने Reseed Server का परीक्षण विधि 1: Router की नई स्थापना एक साफ सिस्टम पर I2P इंस्टॉल करें कॉन्फ़िगरेशन में अपना reseed URL (I2P में प्रारंभिक peers/नोड्स से जुड़ने हेतु बूटस्ट्रैप URL) जोड़ें अन्य reseed URLs हटाएँ या अक्षम करें router शुरू करें और सफल reseed के लिए लॉग्स की निगरानी करें 5-10 मिनट के भीतर नेटवर्क से कनेक्शन सत्यापित करें अपेक्षित लॉग आउटपुट:\nReseed got 77 router infos from https://your-reseed.example.com/i2pseeds.su3?netid=2 with 0 errors Reseed complete, 77 received विधि 2: हस्तचालित SU3 सत्यापन # Download bundle curl -k -A \u0026#34;Wget/1.11.4\u0026#34; https://your-reseed.example.com/i2pseeds.su3 \u0026gt; test.su3 # Verify it\u0026#39;s a valid SU3 file hexdump -C test.su3 | head -n 3 # Should show: 49 32 50 73 75 33 (I2Psu3) # Extract content (requires su3 tools) java -cp /path/to/i2p.jar net.i2p.crypto.SU3File verify test.su3 your-cert.crt # Unzip content # (Extract content section, skip header+signature, then unzip) विधि 3: checki2p निगरानी https://checki2p.com/reseed पर उपलब्ध सेवा सभी पंजीकृत I2P reseed (I2P में प्रारंभिक बूटस्ट्रैप प्रक्रिया) सर्वरों पर हर 4 घंटे में स्वचालित जाँच करती है। यह प्रदान करती है:\nउपलब्धता निगरानी प्रतिक्रिया समय मेट्रिक्स TLS (ट्रांसपोर्ट लेयर सिक्योरिटी) प्रमाणपत्र सत्यापन SU3 (I2P का पैकेज फ़ॉर्मेट) हस्ताक्षर सत्यापन ऐतिहासिक अपटाइम डेटा जैसे ही आपका reseed (बूटस्ट्रैप सर्वर) I2P प्रोजेक्ट के साथ पंजीकृत हो जाता है, वह 24 घंटे के भीतर checki2p पर स्वतः दिखाई देने लगेगा।\nसामान्य समस्याओं का निवारण समस्या: \u0026ldquo;हस्ताक्षर कुंजी पढ़ने में असमर्थ\u0026rdquo; पहली बार चलाने पर - समाधान: यह अपेक्षित है। नई कुंजियाँ उत्पन्न करने के लिए \u0026lsquo;y\u0026rsquo; दर्ज करें।\nसमस्या: router हस्ताक्षर सत्यापित करने में विफल - कारण: प्रमाणपत्र router के trust store (विश्वसनीय प्रमाणपत्र संग्रह) में नहीं है - समाधान: प्रमाणपत्र को ~/.i2p/certificates/reseed/ निर्देशिका में रखें\nसमस्या: विभिन्न क्लाइंट्स को एक ही बंडल भेजा जा रहा है - कारण: X-Forwarded-For हेडर सही तरीके से फ़ॉरवर्ड नहीं हो रहा है - समाधान: --trustProxy सक्षम करें और रिवर्स प्रॉक्सी हेडर कॉन्फ़िगर करें\nसमस्या: \u0026ldquo;Connection refused\u0026rdquo; त्रुटियाँ - कारण: इंटरनेट से पोर्ट सुलभ नहीं - समाधान: फ़ायरवॉल नियम जाँचें, पोर्ट फ़ॉरवर्डिंग सत्यापित करें\nसमस्या: बंडल पुनर्निर्माण के दौरान उच्च CPU उपयोग - कारण: 350+ SU3 (I2P का साइन किया हुआ अपडेट फ़ाइल फ़ॉर्मेट) विविधताएँ उत्पन्न करते समय यह सामान्य व्यवहार है - समाधान: पर्याप्त CPU संसाधन सुनिश्चित करें, पुनर्निर्माण की आवृत्ति कम करने पर विचार करें\nसंदर्भ जानकारी आधिकारिक दस्तावेज़ीकरण Reseed (I2P नेटवर्क में प्रारंभिक peers उपलब्ध कराने की प्रक्रिया) योगदानकर्ताओं के लिए मार्गदर्शिका: /guides/creating-and-running-an-i2p-reseed-server/ Reseed नीति आवश्यकताएँ: /guides/reseed-policy/ SU3 विनिर्देश: /docs/specs/updates/ Reseed टूल्स रिपॉज़िटरी: https://i2pgit.org/idk/reseed-tools Reseed टूल्स दस्तावेज़ीकरण: https://eyedeekay.github.io/reseed-tools/ वैकल्पिक कार्यान्वयन PurpleI2P pyseeder: https://github.com/PurpleI2P/pyseeder DivaExchange i2p-reseed: https://github.com/diva-exchange/i2p-reseed RTradeLtd i2p-tools-1: https://github.com/RTradeLtd/i2p-tools-1 Python WSGI reseeder (रीसीड सर्वर): https://github.com/torbjo/i2p-reseeder सामुदायिक संसाधन I2P फ़ोरम: https://i2pforum.net/ Gitea रिपॉजिटरी: https://i2pgit.org/I2P_Developers/i2p.i2p IRC: #i2p-dev (IRC2P पर) स्थिति निगरानी: https://checki2p.com/reseed संस्करण इतिहास 0.9.14 (2014): SU3 रीसीड फ़ॉर्मैट पेश किया गया 0.9.16 (2014): फ़ाइल-आधारित रीसीडिंग जोड़ी गई 0.9.42 (2019): Network ID क्वेरी पैरामीटर की आवश्यकता 2.0.0 (2022): SSU2 ट्रांसपोर्ट प्रोटोकॉल पेश किया गया 2.4.0 (2024): NetDB का आइसोलेशन और सुरक्षा में सुधार 2.6.0 (2024): I2P-over-Tor कनेक्शनों को ब्लॉक कर दिए गए 2.10.0 (2025): वर्तमान स्थिर रिलीज़ (सितंबर 2025 तक) हस्ताक्षर प्रकार संदर्भ Type Code Algorithm Key Size Signature Size Hash DSA-SHA10DSA1024-bit40 bytesSHA-1 ECDSA-SHA256-P2561ECDSAP-25664 bytesSHA-256 ECDSA-SHA384-P3842ECDSAP-38496 bytesSHA-384 ECDSA-SHA512-P5213ECDSAP-521132 bytesSHA-512 RSA-SHA256-20484RSA2048-bit256 bytesSHA-256 RSA-SHA384-30725RSA3072-bit384 bytesSHA-384 RSA-SHA512-40966RSA4096-bit512 bytesSHA-512 EdDSA-SHA512-Ed255197EdDSAEd2551964 bytesSHA-512 **रीसीड मानक**: Type 6 (RSA-SHA512-4096) रीसीड बंडलों के लिए आवश्यक है। आभार नेटवर्क को सुलभ और लचीला बनाए रखने के लिए प्रत्येक reseed operator (जो नए router को नेटवर्क से जुड़ने हेतु प्रारंभिक जानकारी/सीड्स प्रदान करता है) को धन्यवाद। निम्नलिखित योगदानकर्ताओं और परियोजनाओं को विशेष सम्मान:\nzzz: लंबे समय से I2P डेवलपर और reseed (I2P नेटवर्क के प्रारम्भिक bootstrap की प्रक्रिया) समन्वयक idk: reseed-tools के वर्तमान मेंटेनर और रिलीज़ प्रबंधक Nguyen Phong Hoang: सेंसरशिप-प्रतिरोधी reseeding रणनीतियों पर शोध PurpleI2P Team: वैकल्पिक I2P कार्यान्वयन और उपकरण checki2p: reseed अवसंरचना के लिए स्वचालित निगरानी सेवा I2P नेटवर्क की विकेन्द्रीकृत reseed (नेटवर्क से पहली बार जुड़ते समय आवश्यक प्रारम्भिक पीअर्स/नोड्स की सूची उपलब्ध कराने की प्रक्रिया) अवसंरचना दुनिया भर के दर्जनों संचालकों के सामूहिक प्रयास का प्रतिनिधित्व करती है, जो यह सुनिश्चित करती है कि स्थानीय सेंसरशिप या तकनीकी बाधाओं के बावजूद नए उपयोगकर्ता हमेशा नेटवर्क से जुड़ने का रास्ता खोज सकें।\n","description":"reseed services (प्रारंभिक साथियों की सूची प्रदान करने वाली सेवाएँ) और alternate bootstrap methods (नेटवर्क से पहली बार जुड़ने के वैकल्पिक तरीके) का संचालन","id":"02dba83ad9e38e1355d624c0d4fa28aa","section":"docs","title":"Reseed (I2P नेटवर्क से पहली बार जुड़ने हेतु शुरुआती डेटा डाउनलोड प्रक्रिया) होस्ट","url":"/hi/docs/misc/reseed/"},{"categories":null,"content":"अवलोकन यह दस्तावेज़ router और विभिन्न अनुप्रयोगों द्वारा उपयोग की जाने वाली I2P कॉन्फ़िगरेशन फ़ाइलों का व्यापक तकनीकी विनिर्देश प्रदान करता है। इसमें फ़ाइल फ़ॉर्मेट विनिर्देश, प्रॉपर्टी परिभाषाएँ, और कार्यान्वयन विवरण शामिल हैं, जिन्हें I2P के सोर्स कोड और आधिकारिक दस्तावेज़ीकरण के साथ मिलान करके सत्यापित किया गया है।\nदायरा Router (राउटर) विन्यास फ़ाइलें और प्रारूप क्लाइंट अनुप्रयोग विन्यास I2PTunnel tunnel (टनल) विन्यास फ़ाइल प्रारूप विनिर्देश और कार्यान्वयन संस्करण-विशिष्ट विशेषताएँ और अप्रचलन कार्यान्वयन संबंधी टिप्पणियाँ कॉन्फ़िगरेशन फ़ाइलें I2P कोर लाइब्रेरी में मौजूद DataHelper.loadProps() और storeProps() मेथड्स का उपयोग करके पढ़ी और लिखी जाती हैं। फ़ाइल फ़ॉर्मेट, I2P प्रोटोकॉल्स में उपयोग किए जाने वाले सीरियलाइज़्ड फ़ॉर्मेट से काफ़ी भिन्न है (देखें Common Structures Specification - Type Mapping ).\nसामान्य कॉन्फ़िगरेशन फ़ाइल प्रारूप I2P कॉन्फ़िगरेशन फ़ाइलें विशिष्ट अपवादों और सीमाओं के साथ संशोधित Java Properties प्रारूप (Java की Properties फ़ाइलों का प्रारूप) का पालन करती हैं।\nप्रारूप विनिर्देश Java Properties पर आधारित, निम्नलिखित महत्वपूर्ण अंतर:\nएन्कोडिंग MUST (अनिवार्य) UTF-8 एन्कोडिंग का उपयोग करें (मानक Java Properties में प्रयुक्त ISO-8859-1 नहीं) कार्यान्वयन: सभी फ़ाइल संचालन के लिए DataHelper.getUTF8() उपयोगिताओं का प्रयोग करता है एस्केप सीक्वेंस कोई भी एस्केप सीक्वेंस पहचाने नहीं जाते (बैकस्लैश \\ सहित) लाइन कंटिन्यूएशन समर्थित नहीं है बैकस्लैश वर्णों को जस का तस माना जाता है टिप्पणी चिह्न # एक पंक्ति में किसी भी स्थान पर टिप्पणी शुरू करता है ; केवल तब टिप्पणी शुरू करता है जब वह स्तंभ 1 में हो ! टिप्पणी नहीं शुरू करता है (Java Properties से भिन्न है) कुंजी-मूल्य विभाजक = एकमात्र वैध कुंजी-मूल्य विभाजक है : को विभाजक के रूप में नहीं पहचाना जाता Whitespace (रिक्त स्थान) को विभाजक के रूप में नहीं पहचाना जाता रिक्त स्थान प्रबंधन कुंजियों (keys) पर आरंभिक और अंतिम रिक्त स्थान नहीं हटाए जाते हैं मानों (values) पर आरंभिक और अंतिम रिक्त स्थान हटाए जाते हैं पंक्ति प्रसंस्करण = के बिना पंक्तियाँ अनदेखी की जाती हैं (उन्हें टिप्पणियाँ या खाली पंक्तियाँ माना जाता है) खाली मान (key=) संस्करण 0.9.10 से समर्थित हैं खाली मान वाली कुंजियाँ सामान्य रूप से संग्रहीत और पुनर्प्राप्त की जाती हैं वर्ण प्रतिबंध कुंजियों में ये नहीं होने चाहिए:\n# (हैश/पाउंड चिह्न) = (बराबर का चिह्न) \\n (न्यूलाइन वर्ण) ; (सेमिकलन) से शुरू नहीं हो सकतीं मानों में निम्न शामिल नहीं हो सकते:\n# (हैश/पाउंड चिन्ह) \\n (नई पंक्ति का वर्ण) \\r (कैरिज रिटर्न) से शुरू या समाप्त नहीं हो सकते रिक्त स्थान से शुरू या समाप्त नहीं हो सकते (आरंभ/अंत का रिक्त स्थान स्वतः हटाया जाता है) फ़ाइल छँटाई कॉन्फ़िगरेशन फ़ाइलों को कुंजी के आधार पर क्रमबद्ध करना आवश्यक नहीं है। हालांकि, अधिकांश I2P एप्लिकेशन कॉन्फ़िगरेशन फ़ाइलें लिखते समय कुंजियों को वर्णानुक्रम में क्रमबद्ध करते हैं, ताकि निम्न कार्य सुगम हों: - मैनुअल संपादन - वर्ज़न कंट्रोल diff (अंतर) संचालन - मानव-पठनीयता\nकार्यान्वयन विवरण कॉन्फ़िगरेशन फ़ाइलें पढ़ना // Method signature from net.i2p.data.DataHelper public static Properties loadProps(File file) व्यवहार: - UTF-8 एन्कोडेड फ़ाइलें पढ़ता है - ऊपर वर्णित सभी प्रारूप नियम लागू करता है - अक्षर प्रतिबंधों का सत्यापन करता है - यदि फ़ाइल मौजूद नहीं है तो खाली Properties ऑब्जेक्ट लौटाता है - पढ़ने में त्रुटि होने पर IOException फेंकता है\nकॉन्फ़िगरेशन फ़ाइलें लिखना // Method signature from net.i2p.data.DataHelper public static void storeProps(Properties props, File file) व्यवहार: - UTF-8 एन्कोडेड फ़ाइलें लिखता है - कुंजियों को वर्णानुक्रम में क्रमबद्ध करता है (यदि OrderedProperties का उपयोग न किया जाए) - संस्करण 0.8.1 से फ़ाइल अनुमतियों को mode 600 पर सेट करता है (केवल उपयोगकर्ता पढ़/लिख सकता है) - कुंजियों या मानों में अमान्य अक्षरों के लिए IllegalArgumentException फेंकता है - लेखन त्रुटियों के लिए IOException फेंकता है\nप्रारूप मान्यकरण कार्यान्वयन कठोर सत्यापन करता है: - कुंजियों और मानों में वर्जित वर्णों की जाँच की जाती है - अवैध प्रविष्टियाँ लिखने के कार्यों के दौरान अपवाद उत्पन्न करती हैं - पढ़ते समय गलत स्वरूप वाली पंक्तियाँ चुपचाप अनदेखी की जाती हैं (जिन पंक्तियों में = नहीं होता)\nप्रारूप के उदाहरण मान्य कॉन्फ़िगरेशन फ़ाइल # This is a comment ; This is also a comment (column 1 only) key.with.dots=value with spaces another_key=value=with=equals empty.value= numeric.value=12345 unicode.value=こんにちは अमान्य विन्यास उदाहरण # INVALID: Key contains equals sign invalid=key=value # INVALID: Key contains hash invalid#key=value # INVALID: Value contains newline (implicit) key=value continues here # INVALID: Semicolon comment not in column 1 (treated as key) ; not.a.comment=value कोर लाइब्रेरी और Router कॉन्फ़िगरेशन क्लाइंट विन्यास (clients.config) स्थान: $I2P_CONFIG_DIR/clients.config (पुराना) या $I2P_CONFIG_DIR/clients.config.d/ (आधुनिक) विन्यास इंटरफ़ेस: Router कंसोल /configclients पर फॉर्मेट परिवर्तन: संस्करण 0.9.42 (अगस्त 2019)\nडायरेक्टरी संरचना (संस्करण 0.9.42+) रिलीज़ 0.9.42 से, डिफ़ॉल्ट clients.config फ़ाइल स्वतः अलग-अलग कॉन्फ़िगरेशन फ़ाइलों में विभाजित कर दी जाती है:\n$I2P_CONFIG_DIR/ ├── clients.config.d/ │ ├── 00-webConsole.config │ ├── 01-i2ptunnel.config │ ├── 02-i2psnark.config │ ├── 03-susidns.config │ └── ... └── clients.config (legacy, auto-migrated) स्थानांतरण व्यवहार: - 0.9.42+ में अपग्रेड के बाद पहली बार चलाने पर, एकल फ़ाइल स्वतः विभाजित हो जाती है - विभाजित फ़ाइलों में प्रॉपर्टीज़ के आगे clientApp.0. जोड़ा जाता है - पिछली संगतता के लिए पुराना फ़ॉर्मेट अभी भी समर्थित है - विभाजित फ़ॉर्मेट मॉड्यूलर पैकेजिंग और प्लगइन प्रबंधन सक्षम करता है\nगुणधर्म प्रारूप पंक्तियाँ clientApp.x.prop=val के रूप में होती हैं, जहाँ x ऐप का नंबर है।\nऐप नंबरिंग आवश्यकताएँ: - 0 से शुरू होना अनिवार्य है - क्रमिक होना अनिवार्य है (कोई अंतराल नहीं) - क्रम स्टार्टअप अनुक्रम निर्धारित करता है\nआवश्यक गुणधर्म मुख्य प्रकार: String (पूर्ण रूप से योग्य क्लास नाम) आवश्यक: हाँ वर्णन: इस क्लास में कंस्ट्रक्टर या main() मेथड को क्लाइंट प्रकार (प्रबंधित बनाम अप्रबंधित) के अनुसार आह्वान किया जाएगा उदाहरण: clientApp.0.main=net.i2p.router.web.RouterConsoleRunner वैकल्पिक गुणधर्म नाम प्रकार: String आवश्यक: नहीं विवरण: router console में दिखाया जाने वाला नाम उदाहरण: clientApp.0.name=Router Console आर्गुमेंट्स प्रकार: String (स्पेस या टैब से अलग किए हुए) आवश्यक: नहीं विवरण: वे आर्ग्युमेंट्स जो main क्लास के कंस्ट्रक्टर या main() मेथड को पास किए जाते हैं कोटिंग: जिन आर्ग्युमेंट्स में स्पेस या टैब हों, उन्हें ' या \u0026quot; से कोट किया जा सकता है उदाहरण: clientApp.0.args=-d $CONFIG/eepsite विलंब प्रकार: पूर्णांक (सेकंड) आवश्यक: नहीं डिफ़ॉल्ट: 120 विवरण: क्लायंट शुरू करने से पहले प्रतीक्षा की जाने वाली अवधि (सेकंड में) अधिलेखन: onBoot=true द्वारा अधिलेखित (विलंब को 0 पर सेट करता है) विशेष मान: \u0026lt; 0: router के RUNNING स्थिति तक पहुँचने की प्रतीक्षा करें, फिर नए थ्रेड में तुरंत प्रारंभ करें = 0: उसी थ्रेड में तुरंत चलाएँ (अपवाद कंसोल तक प्रसारित होते हैं) \u0026gt; 0: विलंब के बाद नए थ्रेड में शुरू करें (अपवाद लॉग किए जाते हैं, प्रसारित नहीं किए जाते) onBoot प्रकार: Boolean आवश्यक: नहीं डिफ़ॉल्ट: false विवरण: 0 का विलंब लागू करता है, स्पष्ट विलंब सेटिंग को ओवरराइड करता है उपयोग परिदृश्य: router बूट पर महत्वपूर्ण सेवाओं को तुरंत शुरू करें startOnLoad प्रकार: Boolean (बूलियन) आवश्यक: नहीं डिफ़ॉल्ट: true विवरण: क्लाइंट को शुरू करना है या नहीं उपयोग परिदृश्य: कॉन्फ़िगरेशन हटाए बिना क्लायंट्स को निष्क्रिय करना प्लगइन-विशिष्ट गुण ये गुण केवल प्लगइन्स द्वारा उपयोग किए जाते हैं (कोर क्लाइंट्स द्वारा नहीं):\nstopargs प्रकार: स्ट्रिंग (स्पेस या टैब से पृथक) विवरण: क्लाइंट को रोकने के लिए दिए गए आर्ग्यूमेंट्स चर प्रतिस्थापन: हाँ (नीचे देखें) uninstallargs प्रकार: स्ट्रिंग (स्पेस या टैब से पृथक) विवरण: क्लाइंट को अनइंस्टॉल करने के लिए दिए गए आर्गुमेंट्स वेरिएबल सब्स्टीट्यूशन: हाँ (नीचे देखें) classpath (जावा में कक्षाओं और लाइब्रेरियों को खोजने का पथ) प्रकार: String (अल्पविराम से अलग किए गए पथों) विवरण: क्लाइंट के लिए अतिरिक्त classpath तत्व चर प्रतिस्थापन: हाँ (नीचे देखें) चर प्रतिस्थापन (केवल प्लगइन्स के लिए) प्लगइन्स के लिए args, stopargs, uninstallargs और classpath में निम्नलिखित वेरिएबल्स प्रतिस्थापित किए जाते हैं:\nVariable Expands To Example $I2P Base I2P installation directory /usr/share/i2p $CONFIG User configuration directory ~/.i2p $PLUGIN Plugin directory ~/.i2p/plugins/foo $OS Operating system name linux $ARCH Architecture name amd64 **नोट**: Variable substitution (चर प्रतिस्थापन) केवल प्लगइन्स के लिए किया जाता है, कोर क्लाइंट्स के लिए नहीं। क्लाइंट प्रकार प्रबंधित क्लाइंट्स कंस्ट्रक्टर को RouterContext और ClientAppManager पैरामीटर के साथ कॉल किया जाता है क्लाइंट को ClientApp इंटरफ़ेस को कार्यान्वित करना चाहिए जीवनचक्र router द्वारा नियंत्रित होता है इसे गतिशील रूप से शुरू, बंद, और पुनरारंभ किया जा सकता है अप्रबंधित क्लाइंट्स main(String[] args) मेथड को कॉल किया जाता है अलग थ्रेड में चलता है जीवनचक्र का प्रबंधन router द्वारा नहीं किया जाता पुराना (legacy) क्लाइंट प्रकार उदाहरण कॉन्फ़िगरेशन # Router Console (core client) clientApp.0.main=net.i2p.router.web.RouterConsoleRunner clientApp.0.name=Router Console clientApp.0.args=-d $CONFIG/eepsite clientApp.0.delay=0 clientApp.0.onBoot=true clientApp.0.startOnLoad=true # I2PTunnel (core client) clientApp.1.main=net.i2p.i2ptunnel.TunnelControllerGroup clientApp.1.name=I2PTunnel clientApp.1.args= clientApp.1.delay=120 clientApp.1.startOnLoad=true # Plugin Example clientApp.2.main=org.example.plugin.PluginMain clientApp.2.name=Example Plugin clientApp.2.args=-config $PLUGIN/config.properties clientApp.2.stopargs=-shutdown clientApp.2.uninstallargs=-remove $PLUGIN clientApp.2.classpath=$PLUGIN/lib/plugin.jar,$PLUGIN/lib/dep.jar clientApp.2.delay=240 clientApp.2.startOnLoad=true लॉगर कॉन्फ़िगरेशन (logger.config) स्थान: $I2P_CONFIG_DIR/logger.config कॉन्फ़िगरेशन इंटरफ़ेस: Router console पर /configlogging\nगुणों का संदर्भ कंसोल बफ़र विन्यास logger.consoleBufferSize प्रकार: पूर्णांक डिफ़ॉल्ट: 20 विवरण: कंसोल में बफर करने के लिए लॉग संदेशों की अधिकतम संख्या रेंज: 1-1000 अनुशंसित दिनांक और समय का स्वरूपण logger.dateFormat प्रकार: String (SimpleDateFormat pattern — तिथि/समय प्रारूप पैटर्न) डिफ़ॉल्ट: सिस्टम लोकैल से उदाहरण: HH:mm:ss.SSS दस्तावेज़ीकरण: Java SimpleDateFormat लॉग स्तर logger.defaultLevel प्रकार: Enum (एनेमरेशन प्रकार) डिफ़ॉल्ट: ERROR मान: CRIT, ERROR, WARN, INFO, DEBUG विवरण: सभी क्लासों के लिए डिफ़ॉल्ट लॉगिंग स्तर logger.minimumOnScreenLevel प्रकार: Enum (सीमित नामित मानों का प्रकार) डिफ़ॉल्ट: CRIT मान: CRIT, ERROR, WARN, INFO, DEBUG विवरण: स्क्रीन पर दिखाए जाने वाले संदेशों के लिए न्यूनतम स्तर logger.record.{class} प्रकार: Enum (एनेमरेशन प्रकार) मान: CRIT, ERROR, WARN, INFO, DEBUG विवरण: प्रति-क्लास लॉगिंग स्तर ओवरराइड उदाहरण: logger.record.net.i2p.router.transport.udp=DEBUG प्रदर्शन विकल्प logger.displayOnScreen प्रकार: बूलियन डिफ़ॉल्ट: true विवरण: कंसोल आउटपुट में लॉग संदेश दिखाए जाएँ या नहीं logger.dropDuplicates प्रकार: Boolean (बूलियन प्रकार; true/false) डिफ़ॉल्ट: true विवरण: लगातार आने वाले डुप्लिकेट लॉग संदेशों को छोड़ें logger.dropOnOverflow प्रकार: Boolean (true/false प्रकार) डिफ़ॉल्ट: false विवरण: जब बफ़र भर जाए तो संदेश छोड़ दें (blocking (रोककर प्रतीक्षा करना) के बजाय) फ्लशिंग व्यवहार logger.flushInterval प्रकार: पूर्णांक (सेकंड) डिफ़ॉल्ट: 29 से: संस्करण 0.9.18 विवरण: लॉग बफ़र को डिस्क पर कितनी बार फ्लश करना है कॉन्फ़िगरेशन प्रारूप logger.format प्रकार: String (अक्षरों का क्रम) विवरण: लॉग संदेश के प्रारूप का टेम्पलेट प्रारूप अक्षर: d = तारीख/समय c = क्लास का नाम t = थ्रेड का नाम p = प्राथमिकता (लॉग स्तर) m = संदेश उदाहरण: dctpm से [टाइमस्टैम्प] [क्लास] [थ्रेड] [स्तर] संदेश प्राप्त होता है संपीड़न (संस्करण 0.9.56+) logger.gzip प्रकार: Boolean (सही/गलत) डिफ़ॉल्ट: false से: संस्करण 0.9.56 विवरण: रोटेट की गई लॉग फ़ाइलों के लिए gzip संपीड़न सक्षम करें logger.minGzipSize प्रकार: पूर्णांक (बाइट्स) डिफ़ॉल्ट: 65536 से: संस्करण 0.9.56 विवरण: संपीड़न सक्रिय करने के लिए न्यूनतम फ़ाइल आकार (डिफ़ॉल्ट 64 KB) फ़ाइल प्रबंधन logger.logBufferSize प्रकार: पूर्णांक (बाइट्स) डिफ़ॉल्ट: 1024 वर्णन: बफर को flush (बफर की सामग्री को लिख/भेज कर खाली करना) करने से पहले बफर में रखे जाने वाले संदेशों की अधिकतम संख्या logger.logFileName प्रकार: String (फ़ाइल पथ) डिफ़ॉल्ट: logs/log-@.txt विवरण: लॉग फ़ाइल नामकरण पैटर्न (@ को रोटेशन संख्या से बदला जाता है) logger.logFilenameOverride प्रकार: String (फ़ाइल पथ) विवरण: लॉग फ़ाइल नाम के लिए ओवरराइड (रोटेशन पैटर्न को निष्क्रिय करता है) logger.logFileSize प्रकार: String (इकाई सहित आकार) डिफ़ॉल्ट: 10M इकाइयाँ: K (किलोबाइट), M (मेगाबाइट), G (गीगाबाइट) उदाहरण: 50M, 1G logger.logRotationLimit Type: पूर्णांक Default: 2 Description: रोटेटेड लॉग फ़ाइल संख्या का अधिकतम मान (log-0.txt से log-N.txt तक) उदाहरण विन्यास # Basic logging configuration logger.consoleBufferSize=50 logger.dateFormat=yyyy-MM-dd HH:mm:ss.SSS logger.defaultLevel=WARN logger.displayOnScreen=true logger.dropDuplicates=true logger.dropOnOverflow=false # Flushing and format logger.flushInterval=30 logger.format=dctpm # File management logger.logBufferSize=2048 logger.logFileName=logs/log-@.txt logger.logFileSize=25M logger.logRotationLimit=5 # Compression (0.9.56+) logger.gzip=true logger.minGzipSize=131072 # On-screen filtering logger.minimumOnScreenLevel=ERROR # Per-class overrides logger.record.net.i2p.router.transport=INFO logger.record.net.i2p.router.tunnel=DEBUG logger.record.net.i2p.crypto=WARN प्लगइन विन्यास व्यक्तिगत प्लगइन कॉन्फ़िगरेशन (plugins/*/plugin.config) स्थान: $I2P_CONFIG_DIR/plugins/{plugin-name}/plugin.config प्रारूप: मानक I2P विन्यास फ़ाइल प्रारूप दस्तावेज़ीकरण: प्लगइन विनिर्देशन अनिवार्य गुणधर्म नाम प्रकार: String आवश्यक: हाँ वर्णन: प्लगइन का प्रदर्शित नाम उदाहरण: name=I2P Plugin Example कुंजी प्रकार: String (public key (सार्वजनिक कुंजी)) आवश्यक: हाँ (SU3 हस्ताक्षरित प्लगइन्स के लिए छोड़ दें) विवरण: सत्यापन के लिए प्लगइन signing key (हस्ताक्षर कुंजी) की public key प्रारूप: Base64-encoded signing key हस्ताक्षरकर्ता प्रकार: String आवश्यक: हाँ विवरण: प्लगइन साइनर की पहचान उदाहरण: signer=user@example.i2p संस्करण प्रकार: String (VersionComparator प्रारूप) आवश्यक: हाँ विवरण: अपडेट जाँच के लिए प्लगइन संस्करण प्रारूप: Semantic versioning (अर्थ-आधारित संस्करणन) या कस्टम तुलनीय प्रारूप उदाहरण: version=1.2.3 प्रदर्शन गुण तारीख प्रकार: Long (Unix टाइमस्टैम्प मिलीसेकंड में) विवरण: प्लगइन जारी करने की तिथि लेखक प्रकार: String विवरण: प्लगइन लेखक का नाम websiteURL प्रकार: String (URL) विवरण: प्लगइन वेबसाइट URL updateURL प्रकार: String (URL) विवरण: प्लगइन के अपडेट की जांच हेतु URL updateURL.su3 प्रकार: स्ट्रिंग (URL) से: संस्करण 0.9.15 विवरण: SU3 फ़ॉर्मेट अपडेट URL (अधिमान्य) विवरण प्रकार: String (टेक्स्ट स्ट्रिंग) विवरण: अंग्रेज़ी में प्लगइन का विवरण description_{language} प्रकार: स्ट्रिंग विवरण: स्थानीयकृत प्लगइन विवरण उदाहरण: description_de=Deutsche Beschreibung लाइसेंस प्रकार: String विवरण: प्लगइन लाइसेंस पहचानकर्ता उदाहरण: license=Apache 2.0 स्थापना गुण स्थापना के समय प्रारंभ न करें प्रकार: Boolean (बूलियन) डिफ़ॉल्ट: false विवरण: स्थापना के बाद स्वतः प्रारंभ को रोकें router-पुनरारंभ-आवश्यक प्रकार: बूलियन डिफ़ॉल्ट: false विवरण: स्थापना के बाद router को पुनरारंभ करना आवश्यक केवल-स्थापना प्रकार: Boolean डिफ़ॉल्ट: false विवरण: केवल एक बार इंस्टॉल करें (कोई अपडेट नहीं) केवल अपडेट प्रकार: बूलियन डिफ़ॉल्ट: false विवरण: केवल मौजूदा स्थापना को अपडेट करें (नया इंस्टॉल नहीं) उदाहरण प्लगइन कॉन्फ़िगरेशन # Required properties name=Example I2P Plugin signer=developer@mail.i2p version=1.5.0 # Display properties author=Plugin Developer websiteURL=http://plugin.example.i2p updateURL=http://plugin.example.i2p/update.xpi2p updateURL.su3=http://plugin.example.i2p/update.su3 description=Example plugin demonstrating configuration description_de=Beispiel-Plugin zur Demonstration der Konfiguration license=MIT # Installation behavior dont-start-at-install=false router-restart-required=false वैश्विक प्लगइन कॉन्फ़िगरेशन (plugins.config) स्थान: $I2P_CONFIG_DIR/plugins.config उद्देश्य: स्थापित प्लगइन्स को वैश्विक रूप से सक्रिय/निष्क्रिय करना\nप्रॉपर्टी प्रारूप plugin.{name}.startOnLoad=true|false {name}: plugin.config से प्लगइन का नाम startOnLoad: router के लॉन्च पर प्लगइन शुरू किया जाए या नहीं उदाहरण plugin.i2psnark.startOnLoad=true plugin.susimail.startOnLoad=true plugin.susidns.startOnLoad=true plugin.i2pbote.startOnLoad=false वेब अनुप्रयोग कॉन्फ़िगरेशन (webapps.config) स्थान: $I2P_CONFIG_DIR/webapps.config उद्देश्य: वेब अनुप्रयोगों को सक्रिय/निष्क्रिय करना और कॉन्फ़िगर करना\nगुणधर्म प्रारूप webapps.{name}.startOnLoad प्रकार: बूलियन विवरण: router लॉन्च पर वेबऐप शुरू करना है या नहीं प्रारूप: webapps.{name}.startOnLoad=true|false webapps.{name}.classpath प्रकार: String (स्पेस या कॉमा से अलग किए गए पथ) विवरण: वेबऐप के लिए अतिरिक्त classpath तत्व प्रारूप: webapps.{name}.classpath=[paths] चर प्रतिस्थापन पथ निम्नलिखित चर प्रतिस्थापनों का समर्थन करते हैं:\nVariable Expands To Context $I2P Base I2P directory Core webapps $CONFIG User config directory All webapps $PLUGIN Plugin directory Plugin webapps #### क्लासपाथ निर्धारण कोर वेबऐप्स: $I2P/lib के सापेक्ष पथ प्लगइन वेबऐप्स: $CONFIG/plugins/{appname}/lib के सापेक्ष पथ उदाहरण कॉन्फ़िगरेशन # Router console webapps.routerconsole.startOnLoad=true webapps.routerconsole.classpath=routerconsole.jar # I2PSnark webapps.i2psnark.startOnLoad=true webapps.i2psnark.classpath=i2psnark.jar # SusiDNS webapps.susidns.startOnLoad=true webapps.susidns.classpath=susidns.jar # Plugin webapp example webapps.exampleplugin.startOnLoad=false webapps.exampleplugin.classpath=$PLUGIN/lib/webapp.jar,$PLUGIN/lib/deps.jar Router कॉन्फ़िगरेशन (router.config) स्थान: $I2P_CONFIG_DIR/router.config कॉन्फ़िगरेशन इंटरफ़ेस: Router कंसोल /configadvanced पर उद्देश्य: मुख्य Router सेटिंग्स और नेटवर्क पैरामीटर\nकॉन्फ़िगरेशन श्रेणियाँ नेटवर्क कॉन्फ़िगरेशन बैंडविड्थ सेटिंग्स:\ni2np.bandwidth.inboundKBytesPerSecond=100 i2np.bandwidth.outboundKBytesPerSecond=50 i2np.bandwidth.share.percentage=80 ट्रांसपोर्ट कॉन्फ़िगरेशन:\n# NTCP (TCP-based transport) i2np.ntcp.port=8887 i2np.ntcp.enable=true i2np.ntcp.autoip=true # SSU (UDP-based transport) i2np.udp.port=8887 i2np.udp.enable=true # UPnP/NAT-PMP i2np.upnp.enable=true Router का व्यवहार # Tunnel participation router.maxParticipatingTunnels=200 router.sharePercentage=80 # Updates router.updatePolicy=notify router.updateURL=http://update.i2p2.i2p/ # Network integration router.hiddenMode=false router.clockSkewOffset=0 कंसोल विन्यास # Language and display routerconsole.lang=en routerconsole.country=US routerconsole.summaryRefresh=60 # Browser routerconsole.browser=default # Security routerconsole.enableCompression=true समय विन्यास # NTP time.disabled=false time.sntpServerList=0.pool.ntp.org,1.pool.ntp.org नोट: Router का कॉन्फ़िगरेशन काफी विस्तृत है। पूर्ण गुण संदर्भ के लिए /configadvanced पर router कंसोल देखें।\nएप्लिकेशन कॉन्फ़िगरेशन फ़ाइलें पता पुस्तिका विन्यास (addressbook/config.txt) स्थान: $I2P_CONFIG_DIR/addressbook/config.txt एप्लिकेशन: SusiDNS उद्देश्य: होस्टनेम रिज़ॉल्यूशन और एड्रेस बुक प्रबंधन\nफ़ाइल स्थान router_addressbook डिफ़ॉल्ट: ../hosts.txt विवरण: मुख्य पता पुस्तिका (सिस्टम-व्यापी होस्टनेम) प्रारूप: मानक hosts फ़ाइल प्रारूप privatehosts.txt स्थान: $I2P_CONFIG_DIR/addressbook/privatehosts.txt विवरण: निजी होस्टनेम मैपिंग्स प्राथमिकता: सर्वोच्च (अन्य सभी स्रोतों को ओवरराइड करता है) userhosts.txt स्थान: $I2P_CONFIG_DIR/addressbook/userhosts.txt विवरण: उपयोगकर्ता द्वारा जोड़े गए होस्टनेम मैपिंग्स प्रबंधन: SusiDNS (I2P की DNS-जैसी सेवा) इंटरफ़ेस के माध्यम से hosts.txt स्थान: $I2P_CONFIG_DIR/addressbook/hosts.txt विवरण: डाउनलोड की गई सार्वजनिक पता पुस्तिका स्रोत: सदस्यता फ़ीड्स नामकरण सेवा BlockfileNamingService (0.8.8 से डिफ़ॉल्ट) स्टोरेज फ़ॉर्मैट: - फ़ाइल: hostsdb.blockfile - स्थान: $I2P_CONFIG_DIR/addressbook/ - प्रदर्शन: hosts.txt की तुलना में ~10x तेज़ लुकअप - फ़ॉर्मैट: बाइनरी डेटाबेस फ़ॉर्मैट\nपुरानी नामकरण सेवा: - प्रारूप: सादा टेक्स्ट hosts.txt - स्थिति: अप्रचलित लेकिन अभी भी समर्थित - उपयोग परिदृश्य: मैनुअल संपादन, संस्करण नियंत्रण\nहोस्टनेम नियम I2P होस्टनेम निम्न के अनुरूप होने चाहिए:\nTLD आवश्यकता: अवश्य .i2p पर समाप्त होना चाहिए अधिकतम लंबाई: कुल 67 अक्षर वर्ण सेट: [a-z], [0-9], . (पूर्णविराम), - (हाइफ़न) केस: केवल छोटे अक्षर प्रारंभिक प्रतिबंध: . या - से शुरू नहीं हो सकता वर्जित पैटर्न: .., .-, या -. शामिल नहीं हो सकते (संस्करण 0.6.1.33 से) आरक्षित: Base32 होस्टनेम *.b32.i2p (base32.b32.i2p के 52 अक्षर) वैध उदाहरण example.i2p my-site.i2p test.example.i2p site123.i2p अमान्य उदाहरण example.com # Wrong TLD -invalid.i2p # Starts with hyphen invalid..i2p # Contains double dot invalid.-.i2p # Contains dot-hyphen UPPERCASE.I2P # Must be lowercase verylonghostnameover67charactersthatexceedsthemaximumlength.i2p # Too long सदस्यता प्रबंधन subscriptions.txt स्थान: $I2P_CONFIG_DIR/addressbook/subscriptions.txt प्रारूप: प्रत्येक पंक्ति में एक URL डिफ़ॉल्ट: http://i2p-projekt.i2p/hosts.txt सब्सक्रिप्शन फ़ीड फ़ॉर्मेट (संस्करण 0.9.26 से) मेटाडेटा सहित उन्नत फ़ीड प्रारूप:\n# # I2P Address Book Subscription Feed # Format: hostname=destination [#property=value ...] # example.i2p=base64destination #added=20250101 #src=manual another.i2p=base64destination #added=20250102 #src=feed1 मेटाडेटा गुण: - added: वह तिथि जब होस्टनेम जोड़ा गया था (YYYYMMDD प्रारूप) - src: स्रोत पहचानकर्ता - sig: वैकल्पिक हस्ताक्षर\nपिछड़ी संगतता: सरल hostname=destination प्रारूप अभी भी समर्थित है।\nउदाहरण विन्यास # Address book locations router_addressbook=../hosts.txt privatehosts.txt=$CONFIG/addressbook/privatehosts.txt userhosts.txt=$CONFIG/addressbook/userhosts.txt hosts.txt=$CONFIG/addressbook/hosts.txt # Naming service naming.service=BlockfileNamingService naming.service.blockfile.location=$CONFIG/addressbook/hostsdb.blockfile # Subscriptions subscriptions.txt=$CONFIG/addressbook/subscriptions.txt subscriptions.schedule=daily subscriptions.proxy=false I2PSnark कॉन्फ़िगरेशन (i2psnark.config.d/i2psnark.config) स्थान: $I2P_CONFIG_DIR/i2psnark.config.d/i2psnark.config एप्लिकेशन: I2PSnark BitTorrent क्लाइंट कॉन्फ़िगरेशन इंटरफ़ेस: http://127.0.0.1:7657/i2psnark पर वेब GUI\nडायरेक्टरी संरचना $I2P_CONFIG_DIR/i2psnark.config.d/ ├── i2psnark.config ├── [torrent-hash-1]/ │ └── *.config ├── [torrent-hash-2]/ │ └── *.config └── ... मुख्य कॉन्फ़िगरेशन (i2psnark.config) न्यूनतम डिफ़ॉल्ट कॉन्फ़िगरेशन:\ni2psnark.dir=i2psnark वेब इंटरफ़ेस के माध्यम से प्रबंधित अतिरिक्त गुण:\n# Basic settings i2psnark.dir=i2psnark i2psnark.autoStart=false i2psnark.openTrackers=true # Network settings i2psnark.uploaders=8 i2psnark.upBW=40 i2psnark.seedPct=100 # I2CP settings i2psnark.i2cpHost=127.0.0.1 i2psnark.i2cpPort=7654 व्यक्तिगत टॉरेंट कॉन्फ़िगरेशन स्थान: $I2P_CONFIG_DIR/i2psnark.config.d/[torrent-hash]/*.config स्वरूप: प्रति-टोरेंट सेटिंग्स प्रबंधन: स्वचालित (वेब GUI के माध्यम से)\nगुणों में शामिल हैं: - टोरेंट-विशिष्ट अपलोड/डाउनलोड सेटिंग्स - फ़ाइल प्राथमिकताएँ - ट्रैकर जानकारी - पीयर सीमाएँ\nनोट: टॉरेंट कॉन्फ़िगरेशन मुख्यतः वेब इंटरफ़ेस के माध्यम से प्रबंधित किए जाते हैं। मैन्युअल संपादन की अनुशंसा नहीं की जाती है।\nटोरेंट डेटा का संगठन डेटा भंडारण कॉन्फ़िगरेशन से अलग है:\n$I2P_CONFIG_DIR/i2psnark/ # Data directory ├── *.torrent # Torrent metadata files ├── *.torrent.downloaded/ # Downloaded file directories ├── file1.dat # Direct file downloads └── ... $I2P_CONFIG_DIR/i2psnark.config.d/ # Configuration directory ├── i2psnark.config # Main config └── [hashes]/ # Per-torrent configs I2PTunnel कॉन्फ़िगरेशन (i2ptunnel.config) स्थान: $I2P_CONFIG_DIR/i2ptunnel.config (पुराना) या $I2P_CONFIG_DIR/i2ptunnel.config.d/ (आधुनिक) कॉन्फ़िगरेशन इंटरफ़ेस: Router कंसोल /i2ptunnel पर प्रारूप परिवर्तन: संस्करण 0.9.42 (अगस्त 2019)\nडायरेक्टरी संरचना (संस्करण 0.9.42+) रिलीज़ 0.9.42 से, डिफ़ॉल्ट i2ptunnel.config फ़ाइल स्वतः विभाजित की जाती है:\n$I2P_CONFIG_DIR/ ├── i2ptunnel.config.d/ │ ├── http-proxy/ │ │ └── tunnel.config │ ├── irc-proxy/ │ │ └── tunnel.config │ ├── ssh-service/ │ │ └── tunnel.config │ └── ... └── i2ptunnel.config (legacy, auto-migrated) महत्वपूर्ण फ़ॉर्मैट भिन्नता: - मोनोलिथिक फ़ॉर्मैट: प्रॉपर्टीज़ के आगे tunnel.N. प्रिफ़िक्स होता है - विभाजित फ़ॉर्मैट: प्रॉपर्टीज़ पर कोई प्रिफ़िक्स नहीं होता (उदा., description=, न कि tunnel.0.description=)\nमाइग्रेशन व्यवहार 0.9.42 में अपग्रेड के बाद पहली बार चलाने पर: 1. मौजूदा i2ptunnel.config फ़ाइल पढ़ी जाती है 2. अलग-अलग tunnel कॉन्फ़िग्स i2ptunnel.config.d/ में बनाई जाती हैं 3. विभाजित फ़ाइलों में गुणों से उपसर्ग हटाए जाते हैं 4. मूल फ़ाइल का बैकअप लिया जाता है 5. पिछड़ी संगतता के लिए लेगसी फ़ॉर्मैट अभी भी समर्थित है\nकॉन्फ़िगरेशन अनुभाग I2PTunnel कॉन्फ़िगरेशन का विस्तृत वर्णन नीचे दिए गए I2PTunnel कॉन्फ़िगरेशन संदर्भ अनुभाग में है। प्रॉपर्टी विवरण एकीकृत (tunnel.N.property) और विभाजित (property) दोनों प्रारूपों पर लागू होते हैं।\nI2PTunnel कॉन्फ़िगरेशन संदर्भ यह अनुभाग सभी I2PTunnel कॉन्फ़िगरेशन प्रॉपर्टीज़ के लिए विस्तृत तकनीकी संदर्भ प्रदान करता है। प्रॉपर्टीज़ को विभाजित फ़ॉर्मेट में दिखाया गया है (tunnel.N. प्रिफ़िक्स के बिना)। एकात्मक फ़ॉर्मेट के लिए, सभी प्रॉपर्टीज़ के आगे tunnel.N. प्रिफ़िक्स लगाएँ, जहाँ N tunnel संख्या है।\nमहत्वपूर्ण: जिन गुणों का वर्णन tunnel.N.option.i2cp.* के रूप में किया गया है, वे I2PTunnel में कार्यान्वित हैं और I2CP प्रोटोकॉल या SAM API जैसे अन्य इंटरफेस के माध्यम से नहीं समर्थित हैं।\nमूलभूत विशेषताएँ tunnel.N.description (विवरण) प्रकार: String संदर्भ: सभी tunnels विवरण: UI प्रदर्शन हेतु मानव-पठनीय tunnel विवरण उदाहरण: description=HTTP Proxy for outproxy access tunnel.N.name (नाम) प्रकार: स्ट्रिंग संदर्भ: सभी tunnels आवश्यक: हाँ विवरण: अद्वितीय tunnel पहचानकर्ता और प्रदर्शित नाम उदाहरण: name=I2P HTTP Proxy tunnel.N.type (प्रकार) प्रकार: Enum (सूचीबद्ध प्रकार) प्रसंग: सभी tunnels आवश्यक: हाँ मान: client - सामान्य क्लाइंट tunnel httpclient - HTTP प्रॉक्सी क्लाइंट ircclient - IRC क्लाइंट tunnel socksirctunnel - SOCKS IRC प्रॉक्सी sockstunnel - SOCKS प्रॉक्सी (संस्करण 4, 4a, 5) connectclient - CONNECT प्रॉक्सी क्लाइंट streamrclient - Streamr क्लाइंट server - सामान्य सर्वर tunnel httpserver - HTTP सर्वर tunnel ircserver - IRC सर्वर tunnel httpbidirserver - द्विदिश HTTP सर्वर streamrserver - Streamr सर्वर tunnel.N.interface (इंटरफ़ेस) प्रकार: स्ट्रिंग (IP address या hostname) संदर्भ: केवल क्लाइंट tunnels डिफ़ॉल्ट: 127.0.0.1 विवरण: आने वाले कनेक्शनों के लिए बाइंड करने हेतु स्थानीय इंटरफेस सुरक्षा नोट: 0.0.0.0 पर बाइंड करना रिमोट कनेक्शनों की अनुमति देता है उदाहरण: interface=127.0.0.1 tunnel.N.listenPort (listenPort) प्रकार: पूर्णांक संदर्भ: केवल क्लाइंट tunnels सीमा: 1-65535 विवरण: क्लाइंट कनेक्शनों के लिए सुनने हेतु स्थानीय पोर्ट उदाहरण: listenPort=4444 tunnel.N.targetHost (targetHost) Type: स्ट्रिंग (IP पता या होस्टनेम) Context: केवल सर्वर tunnels Description: कनेक्शनों को अग्रेषित करने के लिए स्थानीय सर्वर Example: targetHost=127.0.0.1 tunnel.N.targetPort (targetPort) प्रकार: पूर्णांक संदर्भ: केवल सर्वर tunnels सीमा: 1-65535 विवरण: targetHost पर कनेक्ट करने हेतु पोर्ट उदाहरण: targetPort=80 tunnel.N.targetDestination (targetDestination) प्रकार: String (कॉमा या स्पेस से अलग किए गए गंतव्य) संदर्भ: केवल क्लाइंट tunnels (I2P में डेटा रूटिंग मार्ग) प्रारूप: destination[:port][,destination[:port]] विवरण: जिन I2P गंतव्य(ओं) से कनेक्ट करना है उदाहरण: targetDestination=example.i2p targetDestination=example.i2p:8080 targetDestination=site1.i2p,site2.i2p:8080 tunnel.N.i2cpHost (i2cpHost) प्रकार: स्ट्रिंग (IP पता या होस्टनेम) डिफ़ॉल्ट: 127.0.0.1 विवरण: I2P router के I2CP इंटरफ़ेस का पता नोट: router संदर्भ में चलने पर इसे अनदेखा किया जाता है उदाहरण: i2cpHost=127.0.0.1 tunnel.N.i2cpPort (i2cpPort) प्रकार: पूर्णांक डिफ़ॉल्ट: 7654 सीमा: 1-65535 विवरण: I2P router का I2CP पोर्ट टिप्पणी: router संदर्भ में चलने पर इसे अनदेखा किया जाता है उदाहरण: i2cpPort=7654 tunnel.N.startOnLoad (startOnLoad) प्रकार: Boolean (सच/झूठ वाला डेटा प्रकार) डिफ़ॉल्ट: true विवरण: I2PTunnel लोड होने पर tunnel शुरू किया जाए या नहीं उदाहरण: startOnLoad=true प्रॉक्सी कॉन्फ़िगरेशन tunnel.N.proxyList (proxyList) प्रकार: String (कॉमा या स्पेस से अलग किए गए होस्टनेम) संदर्भ: केवल HTTP और SOCKS प्रॉक्सी विवरण: outproxy होस्टों की सूची (I2P से बाहरी इंटरनेट के लिए प्रॉक्सी) उदाहरण: proxyList=outproxy.example.i2p,backup.example.i2p सर्वर विन्यास tunnel.N.privKeyFile (privKeyFile) प्रकार: String (फ़ाइल पथ) प्रसंग: सर्वर और स्थायी क्लाइंट tunnels विवरण: फ़ाइल जिसमें स्थायी गंतव्य की निजी कुंजियाँ होती हैं पथ: पूर्ण (absolute) या I2P कॉन्फ़िग डायरेक्टरी के सापेक्ष (relative) उदाहरण: privKeyFile=eepsite/eepPriv.dat tunnel.N.spoofedHost (spoofedHost) प्रकार: String (होस्टनेम) प्रसंग: केवल HTTP सर्वरों के लिए डिफ़ॉल्ट: गंतव्य का Base32 होस्टनेम विवरण: स्थानीय सर्वर को पास किया जाने वाला Host हेडर मान उदाहरण: spoofedHost=example.i2p tunnel.N.spoofedHost.NNNN (spoofedHost.NNNN) Type: String (होस्टनेम) Context: केवल HTTP सर्वरों के लिए Description: विशिष्ट इनकमिंग पोर्ट के लिए वर्चुअल होस्ट ओवरराइड Use Case: अलग-अलग पोर्ट पर कई साइटें होस्ट करना Example: spoofedHost.8080=site1.example.i2p क्लाइंट-विशिष्ट विकल्प tunnel.N.sharedClient (sharedClient) प्रकार: Boolean संदर्भ: केवल क्लाइंट tunnels डिफ़ॉल्ट: false विवरण: क्या कई क्लाइंट इस tunnel को साझा कर सकते हैं उदाहरण: sharedClient=false tunnel.N.option.persistentClientKey (persistentClientKey) प्रकार: Boolean संदर्भ: केवल client tunnels डिफ़ॉल्ट: false विवरण: पुनरारंभों के बीच destination keys (गंतव्य कुंजियाँ) को संग्रहीत करें और पुनः उपयोग करें टकराव: i2cp.newDestOnResume=true के साथ परस्पर बहिष्कृत उदाहरण: option.persistentClientKey=true I2CP विकल्प (I2PTunnel कार्यान्वयन) महत्वपूर्ण: ये प्रॉपर्टीज़ option.i2cp. से शुरू होती हैं, लेकिन I2PTunnel में लागू हैं, I2CP प्रोटोकॉल लेयर में नहीं। ये I2CP या SAM APIs के माध्यम से उपलब्ध नहीं हैं।\ntunnel.N.option.i2cp.delayOpen (option.i2cp.delayOpen) प्रकार: Boolean संदर्भ: केवल Client tunnels के लिए डिफ़ॉल्ट: false विवरण: पहले कनेक्शन तक tunnel निर्माण में विलंब करें उपयोग मामला: कम-उपयोग होने वाले tunnels के लिए संसाधन बचाएँ उदाहरण: option.i2cp.delayOpen=false tunnel.N.option.i2cp.newDestOnResume (option.i2cp.newDestOnResume) प्रकार: Boolean (बूलियन) संदर्भ: केवल क्लाइंट tunnels डिफ़ॉल्ट: false आवश्यक: i2cp.closeOnIdle=true संघर्ष: persistentClientKey=true के साथ परस्पर अनन्य विवरण: निष्क्रियता समयसीमा के बाद नया गंतव्य बनाएँ उदाहरण: option.i2cp.newDestOnResume=false tunnel.N.option.i2cp.leaseSetPrivateKey (option.i2cp.leaseSetPrivateKey) प्रकार: स्ट्रिंग (base64-एन्कोडेड कुंजी) संदर्भ: केवल सर्वर tunnels विवरण: स्थायी निजी leaseset (I2P में सेवा की पहुँच जानकारी का सेट) एन्क्रिप्शन कुंजी उपयोग परिदृश्य: रीस्टार्ट्स के दौरान एन्क्रिप्टेड leaseset को सुसंगत बनाए रखना उदाहरण: option.i2cp.leaseSetPrivateKey=AAAA...base64... tunnel.N.option.i2cp.leaseSetSigningPrivateKey (option.i2cp.leaseSetSigningPrivateKey) प्रकार: String (sigtype:base64) प्रसंग: केवल सर्वर tunnels स्वरूप: sigtype:base64key विवरण: स्थायी leaseset पर हस्ताक्षर करने की निजी कुंजी उदाहरण: option.i2cp.leaseSetSigningPrivateKey=7:AAAA...base64... सर्वर-विशिष्ट विकल्प tunnel.N.option.enableUniqueLocal (option.enableUniqueLocal) प्रकार: Boolean संदर्भ: केवल सर्वर tunnels डिफ़ॉल्ट: false विवरण: प्रत्येक दूरस्थ I2P destination के लिए अद्वितीय स्थानीय IP का उपयोग करें उपयोग मामला: सर्वर लॉग्स में क्लाइंट IP पतों को ट्रैक करें सुरक्षा नोट: गुमनामी कम हो सकती है उदाहरण: option.enableUniqueLocal=false tunnel.N.option.targetForPort.NNNN (option.targetForPort.NNNN) प्रकार: String (hostname:port) संदर्भ: केवल सर्वर tunnels के लिए वर्णन: आगत पोर्ट NNNN के लिए targetHost/targetPort को ओवरराइड करें उपयोग मामला: विभिन्न स्थानीय सेवाओं के लिए पोर्ट-आधारित मार्ग निर्धारण उदाहरण: option.targetForPort.8080=localhost:8080 थ्रेड पूल कॉन्फ़िगरेशन tunnel.N.option.i2ptunnel.usePool (option.i2ptunnel.usePool) प्रकार: Boolean प्रसंग: केवल सर्वर tunnels डिफ़ॉल्ट: true विवरण: कनेक्शन प्रबंधन के लिए थ्रेड पूल का उपयोग करें नोट: मानक सर्वरों के लिए हमेशा false (अनदेखा किया जाता है) उदाहरण: option.i2ptunnel.usePool=true tunnel.N.option.i2ptunnel.blockingHandlerCount (option.i2ptunnel.blockingHandlerCount) प्रकार: पूर्णांक संदर्भ: केवल सर्वर tunnels डिफ़ॉल्ट: 65 वर्णन: अधिकतम थ्रेड पूल आकार नोट: मानक सर्वरों के लिए अनदेखा किया जाता है उदाहरण: option.i2ptunnel.blockingHandlerCount=100 HTTP क्लाइंट विकल्प tunnel.N.option.i2ptunnel.httpclient.allowInternalSSL (option.i2ptunnel.httpclient.allowInternalSSL) प्रकार: बूलियन संदर्भ: केवल HTTP क्लाइंट्स डिफ़ॉल्ट: false विवरण: .i2p पतों के लिए SSL कनेक्शनों की अनुमति दें उदाहरण: option.i2ptunnel.httpclient.allowInternalSSL=false tunnel.N.option.i2ptunnel.httpclient.disableAddressHelper (option.i2ptunnel.httpclient.disableAddressHelper) प्रकार: Boolean संदर्भ: केवल HTTP क्लाइंट्स डिफ़ॉल्ट: false विवरण: प्रॉक्सी प्रतिक्रियाओं में address helper (I2P पतों को साझा कराने वाला) लिंक को अक्षम करें उदाहरण: option.i2ptunnel.httpclient.disableAddressHelper=false tunnel.N.option.i2ptunnel.httpclient.jumpServers (option.i2ptunnel.httpclient.jumpServers) Type: स्ट्रिंग (कॉमा या स्पेस से अलग किए गए URLs) Context: केवल HTTP क्लाइंट्स Description: होस्टनेम रिज़ॉल्यूशन के लिए जंप सर्वर URLs Example: option.i2ptunnel.httpclient.jumpServers=http://jump.i2p/jump,http://stats.i2p/jump tunnel.N.option.i2ptunnel.httpclient.sendAccept (option.i2ptunnel.httpclient.sendAccept) प्रकार: बूलियन संदर्भ: केवल HTTP क्लाइंट्स के लिए डिफ़ॉल्ट: false विवरण: Accept-* हेडर्स पास करें (Accept और Accept-Encoding को छोड़कर) उदाहरण: option.i2ptunnel.httpclient.sendAccept=false tunnel.N.option.i2ptunnel.httpclient.sendReferer (option.i2ptunnel.httpclient.sendReferer) प्रकार: बूलियन प्रसंग: केवल HTTP क्लाइंट्स डिफ़ॉल्ट: false विवरण: Referer हेडर को प्रॉक्सी के माध्यम से भेजें गोपनीयता नोट: जानकारी लीक हो सकती है उदाहरण: option.i2ptunnel.httpclient.sendReferer=false tunnel.N.option.i2ptunnel.httpclient.sendUserAgent (option.i2ptunnel.httpclient.sendUserAgent) प्रकार: बूलियन संदर्भ: केवल HTTP क्लाइंट्स के लिए डिफ़ॉल्ट: false विवरण: प्रॉक्सी के माध्यम से User-Agent (ब्राउज़र पहचान स्ट्रिंग) हेडर पास करें गोपनीयता नोट: इससे ब्राउज़र की जानकारी लीक हो सकती है उदाहरण: option.i2ptunnel.httpclient.sendUserAgent=false tunnel.N.option.i2ptunnel.httpclient.sendVia (option.i2ptunnel.httpclient.sendVia) प्रकार: बूलियन संदर्भ: केवल HTTP क्लाइंट डिफ़ॉल्ट: false विवरण: प्रॉक्सी के माध्यम से Via headers पास करें उदाहरण: option.i2ptunnel.httpclient.sendVia=false tunnel.N.option.i2ptunnel.httpclient.SSLOutproxies (option.i2ptunnel.httpclient.SSLOutproxies) प्रकार: स्ट्रिंग (कॉमा या स्पेस से अलग किए गए destinations (I2P पते)) संदर्भ: केवल HTTP क्लाइंट्स के लिए वर्णन: HTTPS के लिए नेटवर्क के भीतर उपलब्ध SSL outproxies (I2P से बाहरी इंटरनेट तक पहुँच देने वाले प्रॉक्सी) उदाहरण: option.i2ptunnel.httpclient.SSLOutproxies=ssl-outproxy.i2p tunnel.N.option.i2ptunnel.useLocalOutproxy (option.i2ptunnel.useLocalOutproxy) प्रकार: बूलियन संदर्भ: केवल HTTP क्लाइंट्स डिफ़ॉल्ट: true विवरण: पंजीकृत स्थानीय outproxy प्लगइन्स का उपयोग करें उदाहरण: option.i2ptunnel.useLocalOutproxy=true HTTP क्लाइंट प्रमाणीकरण tunnel.N.option.proxyAuth (option.proxyAuth) प्रकार: Enum (सूचीबद्ध प्रकार) संदर्भ: केवल HTTP क्लाइंट्स के लिए डिफ़ॉल्ट: false मान: true, false, basic, digest विवरण: प्रॉक्सी तक पहुँच के लिए स्थानीय प्रमाणीकरण आवश्यक करें नोट: true basic के समतुल्य है उदाहरण: option.proxyAuth=basic tunnel.N.option.proxy.auth.USER.md5 (option.proxy.auth.USER.md5) प्रकार: स्ट्रिंग (32 वर्णों का लोअरकेस हेक्स) संदर्भ: केवल HTTP क्लाइंट्स आवश्यकता: proxyAuth=basic या proxyAuth=digest विवरण: उपयोगकर्ता USER के पासवर्ड का MD5 हैश अप्रचलन: इसके बजाय SHA-256 का उपयोग करें (0.9.56+) उदाहरण: option.proxy.auth.alice.md5=5f4dcc3b5aa765d61d8327deb882cf99 tunnel.N.option.proxy.auth.USER.sha256 (option.proxy.auth.USER.sha256) प्रकार: स्ट्रिंग (64-अक्षरी लोअरकेस हेक्स (हेक्साडेसिमल)) संदर्भ: केवल HTTP क्लाइंट्स आवश्यक: proxyAuth=digest से: संस्करण 0.9.56 मानक: RFC 7616 विवरण: उपयोगकर्ता USER के पासवर्ड का SHA-256 हैश उदाहरण: option.proxy.auth.alice.sha256=5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8 Outproxy (बाहरी प्रॉक्सी) प्रमाणीकरण tunnel.N.option.outproxyAuth (option.outproxyAuth) प्रकार: Boolean संदर्भ: केवल HTTP क्लाइंट्स डिफ़ॉल्ट: false विवरण: outproxy को प्रमाणीकरण भेजें उदाहरण: option.outproxyAuth=false tunnel.N.option.outproxyUsername (option.outproxyUsername) प्रकार: स्ट्रिंग संदर्भ: केवल HTTP क्लाइंट्स आवश्यकता: outproxyAuth=true विवरण: outproxy प्रमाणीकरण (I2P नेटवर्क से सार्वजनिक इंटरनेट तक ट्रैफिक अग्रेषित करने वाला प्रॉक्सी) के लिए उपयोगकर्ता नाम उदाहरण: option.outproxyUsername=user tunnel.N.option.outproxyPassword (option.outproxyPassword) प्रकार: स्ट्रिंग संदर्भ: केवल HTTP क्लाइंट्स आवश्यक: outproxyAuth=true विवरण: आउटप्रॉक्सी प्रमाणीकरण के लिए पासवर्ड सुरक्षा: सादे पाठ में संग्रहीत उदाहरण: option.outproxyPassword=secret SOCKS क्लाइंट विकल्प tunnel.N.option.i2ptunnel.socks.proxy.default (option.i2ptunnel.socks.proxy.default) Type: स्ट्रिंग (अल्पविराम या स्पेस से विभाजित destinations अर्थात I2P गंतव्य पते) Context: केवल SOCKS क्लाइंट्स के लिए Description: नेटवर्क के भीतर outproxies (I2P नेटवर्क से इंटरनेट के लिए प्रॉक्सी सेवाएँ) अनिर्दिष्ट पोर्ट्स के लिए Example: option.i2ptunnel.socks.proxy.default=outproxy.i2p tunnel.N.option.i2ptunnel.socks.proxy.NNNN (option.i2ptunnel.socks.proxy.NNNN) प्रकार: स्ट्रिंग (अल्पविराम या स्पेस से अलग किए गए गंतव्य) संदर्भ: केवल SOCKS क्लाइंट्स के लिए विवरण: विशेष रूप से पोर्ट NNNN के लिए नेटवर्क के भीतर के outproxies (क्लियरनेट तक पहुँच के लिए निकास प्रॉक्सी) उदाहरण: option.i2ptunnel.socks.proxy.443=ssl-outproxy.i2p tunnel.N.option.outproxyType (option.outproxyType) प्रकार: Enum (सीमित मानों का प्रकार) संदर्भ: केवल SOCKS क्लाइंट्स डिफ़ॉल्ट: socks से: संस्करण 0.9.57 मान: socks, connect (HTTPS) विवरण: कॉन्फ़िगर किए गए outproxy (I2P नेटवर्क से इंटरनेट हेतु बाहरी प्रॉक्सी) का प्रकार उदाहरण: option.outproxyType=connect HTTP सर्वर विकल्प tunnel.N.option.maxPosts (option.maxPosts) प्रकार: पूर्णांक प्रसंग: केवल HTTP सर्वरों के लिए डिफ़ॉल्ट: 0 (असीमित) विवरण: प्रति postCheckTime एक गंतव्य से POST अनुरोधों की अधिकतम संख्या उदाहरण: option.maxPosts=10 tunnel.N.option.maxTotalPosts (option.maxTotalPosts) प्रकार: पूर्णांक प्रसंग: केवल HTTP सर्वरों के लिए डिफ़ॉल्ट: 0 (असीमित) विवरण: प्रति postCheckTime सभी destinations से अधिकतम POST अनुरोधों की संख्या उदाहरण: option.maxTotalPosts=50 tunnel.N.option.postCheckTime (option.postCheckTime) प्रकार: पूर्णांक (सेकंड) संदर्भ: केवल HTTP सर्वर डिफ़ॉल्ट: 300 विवरण: POST सीमाओं की जाँच के लिए समय-अंतराल उदाहरण: option.postCheckTime=600 tunnel.N.option.postBanTime (option.postBanTime) प्रकार: पूर्णांक (सेकंड) संदर्भ: केवल HTTP सर्वर डिफ़ॉल्ट: 1800 विवरण: एकल गंतव्य के लिए, maxPosts पार होने के बाद प्रतिबंध की अवधि उदाहरण: option.postBanTime=3600 tunnel.N.option.postTotalBanTime (option.postTotalBanTime) प्रकार: पूर्णांक (सेकंड में) संदर्भ: केवल HTTP सर्वरों के लिए डिफ़ॉल्ट: 600 विवरण: maxTotalPosts पार होने के बाद प्रतिबंध की अवधि उदाहरण: option.postTotalBanTime=1200 HTTP सर्वर सुरक्षा विकल्प tunnel.N.option.rejectInproxy (option.rejectInproxy) प्रकार: बूलियन संदर्भ: केवल HTTP सर्वरों के लिए डिफ़ॉल्ट: false विवरण: ऐसे कनेक्शनों को अस्वीकार करें जो संभवतः किसी inproxy (इन-प्रॉक्सी) के माध्यम से आए हों उदाहरण: option.rejectInproxy=false tunnel.N.option.rejectReferer (option.rejectReferer) प्रकार: बूलियन संदर्भ: केवल HTTP सर्वरों के लिए डिफ़ॉल्ट: false से: संस्करण 0.9.25 विवरण: Referer हेडर वाले कनेक्शनों को अस्वीकार करें उदाहरण: option.rejectReferer=false tunnel.N.option.rejectUserAgents (option.rejectUserAgents) प्रकार: बूलियन संदर्भ: केवल HTTP सर्वर डिफ़ॉल्ट: false से: संस्करण 0.9.25 से आवश्यक: userAgentRejectList प्रॉपर्टी विवरण: मेल खाते User-Agent (HTTP हेडर) वाले कनेक्शनों को अस्वीकार करता है उदाहरण: option.rejectUserAgents=false tunnel.N.option.userAgentRejectList (option.userAgentRejectList) प्रकार: String (कॉमा से अलग किए गए मिलान स्ट्रिंग्स) संदर्भ: केवल HTTP सर्वर कब से: संस्करण 0.9.25 से केस: केस-सेंसिटिव (अक्षर-मात्रा-संवेदी) मिलान विशेष: \u0026ldquo;none\u0026rdquo; (0.9.33 से) खाली User-Agent से मेल खाता है विवरण: अस्वीकार करने के लिए User-Agent पैटर्न की सूची उदाहरण: option.userAgentRejectList=Mozilla,Opera,none IRC सर्वर विकल्प tunnel.N.option.ircserver.fakeHostname (option.ircserver.fakeHostname) प्रकार: स्ट्रिंग (होस्टनेम पैटर्न) संदर्भ: केवल IRC सर्वर डिफ़ॉल्ट: %f.b32.i2p टोकन: %f = पूर्ण base32 डेस्टिनेशन हैश %c = क्लोक्ड डेस्टिनेशन हैश (cloakKey देखें) विवरण: IRC सर्वर को भेजा जाने वाला होस्टनेम फ़ॉर्मेट उदाहरण: option.ircserver.fakeHostname=%c.irc.i2p tunnel.N.option.ircserver.cloakKey (option.ircserver.cloakKey) प्रकार: String (passphrase (गुप्त वाक्यांश)) संदर्भ: केवल IRC सर्वर डिफ़ॉल्ट: प्रत्येक सत्र के लिए यादृच्छिक प्रतिबंध: उद्धरण-चिन्ह या स्पेस नहीं विवरण: सुसंगत hostname cloaking (होस्टनेम छुपाना) के लिए passphrase उपयोग मामला: रीस्टार्ट या सर्वर बदलने पर भी स्थायी उपयोगकर्ता ट्रैकिंग उदाहरण: option.ircserver.cloakKey=mysecretkey tunnel.N.option.ircserver.method (option.ircserver.method) प्रकार: Enum (एनम) संदर्भ: केवल IRC सर्वर के लिए डिफ़ॉल्ट: user मान: user, webirc विवरण: IRC सर्वर के लिए प्रमाणीकरण विधि उदाहरण: option.ircserver.method=webirc tunnel.N.option.ircserver.webircPassword (option.ircserver.webircPassword) Type: String (टेक्स्ट मान, पासवर्ड) Context: केवल IRC सर्वरों के लिए Requires: method=webirc Restrictions: उद्धरण चिह्न या स्पेस नहीं Description: WEBIRC प्रोटोकॉल प्रमाणीकरण के लिए पासवर्ड Example: option.ircserver.webircPassword=webircpass tunnel.N.option.ircserver.webircSpoofIP (option.ircserver.webircSpoofIP) प्रकार: स्ट्रिंग (IP पता) प्रसंग: केवल IRC सर्वरों के लिए आवश्यकता: method=webirc विवरण: WEBIRC प्रोटोकॉल के लिए spoofed (धोखे से प्रस्तुत) IP पता उदाहरण: option.ircserver.webircSpoofIP=10.0.0.1 SSL/TLS विन्यास tunnel.N.option.useSSL (option.useSSL) Type: Boolean (बूलियन) Default: false Context: सभी tunnels Behavior: Servers: स्थानीय सर्वर के साथ कनेक्शनों के लिए SSL का उपयोग करें Clients: स्थानीय क्लाइंट से SSL आवश्यक करें Example: option.useSSL=false tunnel.N.option.keystoreFile (option.keystoreFile) प्रकार: String (फाइल पाथ) संदर्भ: केवल Client tunnels डिफ़ॉल्ट: i2ptunnel-(random).ks पथ: यदि पूर्ण पथ नहीं है तो $(I2P_CONFIG_DIR)/keystore/ के सापेक्ष स्वतः निर्मित: यदि मौजूद नहीं है तो बनाया जाएगा विवरण: SSL निजी कुंजी वाली कीस्टोर फ़ाइल उदाहरण: option.keystoreFile=my-tunnel.ks tunnel.N.option.keystorePassword (option.keystorePassword) Type: String (पासवर्ड) Context: केवल क्लाइंट tunnels Default: changeit Auto-generated: यदि नया keystore (कुंजी-संग्रह) बनाया जाता है तो यादृच्छिक पासवर्ड Description: SSL keystore के लिए पासवर्ड Example: option.keystorePassword=secretpassword tunnel.N.option.keyAlias (option.keyAlias) प्रकार: String (उपनाम) संदर्भ: केवल क्लाइंट tunnel स्वतः-निर्मित: नई कुंजी उत्पन्न होने पर बनाया जाता है विवरण: keystore (कीस्टोर) में प्राइवेट कुंजी का उपनाम उदाहरण: option.keyAlias=mytunnel-key tunnel.N.option.keyPassword (option.keyPassword) प्रकार: String (स्ट्रिंग) (पासवर्ड) संदर्भ: केवल Client tunnels स्वतः-जनित: यदि नई कुंजी बनाई जाए तो यादृच्छिक पासवर्ड विवरण: keystore (कुंजी-संग्रह) में private key (निजी कुंजी) के लिए पासवर्ड उदाहरण: option.keyPassword=keypass123 सामान्य I2CP और स्ट्रीमिंग विकल्प सभी tunnel.N.option.* प्रॉपर्टीज़ (जो ऊपर विशेष रूप से प्रलेखित नहीं हैं) को tunnel.N.option. प्रिफिक्स हटाकर I2CP इंटरफ़ेस और स्ट्रीमिंग लाइब्रेरी तक अग्रेषित किया जाता है।\nमहत्वपूर्ण: ये I2PTunnel-विशिष्ट विकल्पों से अलग हैं। देखें: - I2CP विनिर्देश - स्ट्रीमिंग लाइब्रेरी विनिर्देश स्ट्रीमिंग विकल्पों के उदाहरण:\noption.i2cp.messageReliability=BestEffort option.i2p.streaming.connectDelay=1000 option.i2p.streaming.maxWindowSize=128 पूर्ण Tunnel उदाहरण # HTTP Proxy (split format without tunnel.N. prefix) name=I2P HTTP Proxy description=HTTP proxy for accessing I2P sites and outproxy type=httpclient interface=127.0.0.1 listenPort=4444 targetDestination= sharedClient=true startOnLoad=true # I2CP configuration i2cpHost=127.0.0.1 i2cpPort=7654 # HTTP client options option.i2ptunnel.httpclient.allowInternalSSL=false option.i2ptunnel.httpclient.disableAddressHelper=false option.i2ptunnel.httpclient.jumpServers=http://stats.i2p/cgi-bin/jump.cgi option.i2ptunnel.httpclient.sendAccept=false option.i2ptunnel.httpclient.sendReferer=false option.i2ptunnel.httpclient.sendUserAgent=false # Proxy authentication option.proxyAuth=false # Outproxy configuration option.i2ptunnel.httpclient.SSLOutproxies=false.i2p proxyList=false.i2p # Client behavior option.persistentClientKey=false option.i2cp.delayOpen=false # I2CP tunnel options option.inbound.length=3 option.outbound.length=3 option.inbound.quantity=2 option.outbound.quantity=2 संस्करण इतिहास और विशेषताओं की समयरेखा संस्करण 0.9.10 (2013) Feature: कॉन्फ़िगरेशन फ़ाइलों में खाली मान का समर्थन - खाली मान वाली कुंजियाँ (key=) अब समर्थित हैं - पहले इन्हें अनदेखा किया जाता था या पार्सिंग त्रुटियों का कारण बनती थीं\nसंस्करण 0.9.18 (2015) विशेषता: लॉगर फ्लश अंतराल कॉन्फ़िगरेशन - प्रॉपर्टी: logger.flushInterval (डिफ़ॉल्ट 29 सेकंड) - स्वीकार्य लॉग विलंबता बनाए रखते हुए डिस्क I/O को कम करता है\nसंस्करण 0.9.23 (नवंबर 2015) मुख्य परिवर्तन: Java 7 की न्यूनतम आवश्यकता - Java 6 का समर्थन समाप्त - निरंतर सुरक्षा अद्यतनों के लिए आवश्यक\nसंस्करण 0.9.25 (2015) विशेषताएँ: HTTP सर्वर सुरक्षा विकल्प - tunnel.N.option.rejectReferer - Referer हेडर वाले कनेक्शनों को अस्वीकार करें - tunnel.N.option.rejectUserAgents - विशिष्ट User-Agent हेडरों को अस्वीकार करें - tunnel.N.option.userAgentRejectList - अस्वीकार करने हेतु User-Agent पैटर्न - उपयोग मामला: क्रॉलर और अवांछित क्लाइंट्स को सीमित करना\nसंस्करण 0.9.33 (जनवरी 2018) फ़ीचर: उन्नत User-Agent फ़िल्टरिंग - userAgentRejectList string \u0026ldquo;none\u0026rdquo; खाली User-Agent से मेल खाता है - i2psnark, i2ptunnel, streaming, SusiMail के लिए अतिरिक्त बग फिक्स\nसंस्करण 0.9.41 (2019) अप्रचलन: Android से BOB Protocol (I2P का पुराना क्लाइंट प्रोटोकॉल) हटाया गया है - Android उपयोगकर्ताओं को SAM या I2CP पर स्थानांतरित होना होगा\nसंस्करण 0.9.42 (अगस्त 2019) मुख्य परिवर्तन: कॉन्फ़िगरेशन फ़ाइलों का विभाजन - clients.config को clients.config.d/ डायरेक्टरी संरचना में विभाजित किया गया - i2ptunnel.config को i2ptunnel.config.d/ डायरेक्टरी संरचना में विभाजित किया गया - अपग्रेड के बाद पहली बार चलाने पर स्वचालित migration (स्थानांतरण) - मॉड्यूलर पैकेजिंग और प्लगइन प्रबंधन सक्षम करता है - पुराना मोनोलिथिक प्रारूप अब भी समर्थित है\nअतिरिक्त सुविधाएँ: - SSU प्रदर्शन में सुधार - क्रॉस-नेटवर्क रोकथाम (Proposal 147) - एन्क्रिप्शन प्रकारों के लिए प्रारंभिक समर्थन\nसंस्करण 0.9.56 (2021) विशेषताएँ: सुरक्षा और लॉगिंग में सुधार - logger.gzip - रोटेटेड लॉग्स के लिए Gzip संपीड़न (डिफ़ॉल्ट: false) - logger.minGzipSize - संपीड़न के लिए न्यूनतम आकार (डिफ़ॉल्ट: 65536 बाइट्स) - tunnel.N.option.proxy.auth.USER.sha256 - SHA-256 डायजेस्ट प्रमाणीकरण (RFC 7616) - सुरक्षा: डायजेस्ट प्रमाणीकरण के लिए MD5 की जगह SHA-256\nसंस्करण 0.9.57 (जनवरी 2023) फ़ीचर: SOCKS outproxy (बाहरी प्रॉक्सी) प्रकार कॉन्फ़िगरेशन - tunnel.N.option.outproxyType - outproxy प्रकार चुनें (socks|connect) - डिफ़ॉल्ट: socks - HTTPS outproxies के लिए HTTPS CONNECT समर्थन\nसंस्करण 2.6.0 (जुलाई 2024) ब्रेकिंग चेंज: I2P-over-Tor ब्लॉक किया गया - Tor एग्ज़िट नोड्स के IP पतों से आने वाले कनेक्शन अब अस्वीकार किए जाते हैं - कारण: I2P का प्रदर्शन घटाता है, Tor एग्ज़िट संसाधनों की बर्बादी करता है - प्रभाव: Tor एग्ज़िट नोड्स के माध्यम से I2P तक पहुँचने वाले उपयोगकर्ताओं को ब्लॉक किया जाएगा - गैर-एग्ज़िट रिले और Tor क्लाइंट अप्रभावित\nसंस्करण 2.10.0 (सितंबर 2025 - वर्तमान) मुख्य विशेषताएँ: - Post-quantum cryptography (क्वांटम-कंप्यूटर-रोधी कूटलेखन) उपलब्ध (Hidden Service Manager के माध्यम से opt-in) - UDP ट्रैकर सपोर्ट I2PSnark के लिए, ताकि ट्रैकर लोड कम हो - Hidden Mode स्थिरता में सुधार, ताकि RouterInfo की कमी कम हो - भीड़भाड़ वाले routers के लिए नेटवर्क सुधार - उन्नत UPnP/NAT ट्रैवर्सल - NetDB में सुधार, आक्रामक leaseset हटाने के साथ - router घटनाओं के लिए अवलोकनीयता में कमी\nकॉन्फ़िगरेशन: कोई नई कॉन्फ़िगरेशन प्रॉपर्टीज़ नहीं जोड़ी गईं\nमहत्वपूर्ण आगामी परिवर्तन: अगला रिलीज़ (संभावित रूप से 2.11.0 या 3.0.0) के लिए Java 17 या उससे नए संस्करण की आवश्यकता होगी\nअप्रचलन और असंगत परिवर्तन गंभीर अप्रचलन I2P-over-Tor पहुँच (संस्करण 2.6.0+) स्थिति: जुलाई 2024 से अवरुद्ध प्रभाव: Tor exit node (Tor नेटवर्क का एग्ज़िट नोड) के IP पतों से आने वाले कनेक्शन अस्वीकृत कर दिए जाते हैं कारण: गुमनामी के लाभ दिए बिना I2P नेटवर्क के प्रदर्शन को घटाता है प्रभावित: केवल Tor exit nodes; रिले या सामान्य Tor क्लाइंट नहीं विकल्प: I2P या Tor को अलग-अलग उपयोग करें, संयुक्त रूप से नहीं MD5 डाइजेस्ट प्रमाणीकरण स्थिति: अप्रचलित (SHA-256 का उपयोग करें) प्रॉपर्टी: tunnel.N.option.proxy.auth.USER.md5 कारण: MD5 क्रिप्टोग्राफिक रूप से असुरक्षित है प्रतिस्थापन: tunnel.N.option.proxy.auth.USER.sha256 (संस्करण 0.9.56 से) समयरेखा: MD5 अभी भी समर्थित है, लेकिन अनुशंसित नहीं है कॉन्फ़िगरेशन आर्किटेक्चर में परिवर्तन Monolithic (एक-खंडीय) कॉन्फ़िगरेशन फ़ाइलें (संस्करण 0.9.42+) प्रभावित: clients.config, i2ptunnel.config स्थिति: विभाजित डायरेक्टरी संरचना के पक्ष में अप्रचलित स्थानांतरण: 0.9.42 अपग्रेड के बाद पहली बार चलाने पर स्वतः अनुकूलता: पुराना प्रारूप अभी भी काम करता है (पश्च-संगत) सिफारिश: नई कॉन्फ़िगरेशन के लिए विभाजित प्रारूप का उपयोग करें Java संस्करण आवश्यकताएँ Java 6 समर्थन समाप्त: संस्करण 0.9.23 (नवंबर 2015) न्यूनतम: संस्करण 0.9.23 से Java 7 आवश्यक है Java 17 की आवश्यकता (आगामी) स्थिति: गंभीर आगामी परिवर्तन लक्ष्य: 2.10.0 के बाद अगला प्रमुख रिलीज़ (संभावित: 2.11.0 या 3.0.0) वर्तमान न्यूनतम: Java 8 आवश्यक कार्रवाई: Java 17 पर माइग्रेशन के लिए तैयारी करें समयरेखा: रिलीज़ नोट्स के साथ घोषित की जाएगी हटाई गई विशेषताएँ BOB प्रोटोकॉल (Android) हटाया गया: संस्करण 0.9.41 प्लेटफ़ॉर्म: केवल Android विकल्प: SAM या I2CP प्रोटोकॉल डेस्कटॉप: डेस्कटॉप प्लेटफ़ॉर्म पर BOB अभी भी उपलब्ध है अनुशंसित माइग्रेशन प्रमाणीकरण: MD5 से SHA-256 digest authentication (डाइजेस्ट प्रमाणीकरण) पर माइग्रेट करें कॉन्फ़िगरेशन फ़ॉर्मेट: क्लाइंट्स और tunnels के लिए विभाजित डायरेक्टरी संरचना पर माइग्रेट करें Java रनटाइम: अगली प्रमुख रिलीज़ से पहले Java 17 अपग्रेड की योजना बनाएं Tor एकीकरण: I2P को Tor एग्जिट नोड्स के माध्यम से रूट न करें संदर्भ आधिकारिक प्रलेखन I2P कॉन्फ़िगरेशन विनिर्देश - आधिकारिक कॉन्फ़िगरेशन फ़ाइल फ़ॉर्मेट विनिर्देश I2P प्लगइन विनिर्देश - प्लगइन कॉन्फ़िगरेशन और पैकेजिंग I2P सामान्य संरचनाएँ - टाइप मैपिंग - प्रोटोकॉल डेटा सीरियलाइज़ेशन फ़ॉर्मेट Java Properties फ़ॉर्मेट - आधार फ़ॉर्मेट विनिर्देश स्रोत कोड I2P Java Router रिपॉजिटरी - GitHub मिरर I2P Developers Gitea - आधिकारिक I2P स्रोत रिपॉजिटरी DataHelper.java - कॉन्फ़िगरेशन फ़ाइल I/O का कार्यान्वयन सामुदायिक संसाधन I2P Forum - सक्रिय सामुदायिक चर्चाएँ और सहायता I2P Website - आधिकारिक परियोजना वेबसाइट API दस्तावेज़ीकरण DataHelper JavaDoc - कॉन्फ़िगरेशन फ़ाइल मेथड्स के लिए API प्रलेखन विनिर्देश स्थिति अंतिम विनिर्देशन अद्यतन: जनवरी 2023 (संस्करण 0.9.57) वर्तमान I2P संस्करण: 2.10.0 (सितंबर 2025) तकनीकी सटीकता: विनिर्देशन 2.10.0 तक सटीक बना हुआ है (कोई ब्रेकिंग परिवर्तन नहीं) रखरखाव: कॉन्फ़िगरेशन फ़ॉर्मेट में संशोधन होने पर Living document (लगातार अद्यतन होने वाला दस्तावेज़) को अद्यतन किया जाता है ","description":"I2P routers और क्लाइंट्स के लिए विन्यास विकल्प और प्रारूप","id":"b6b01c53245c0e36ca08c56f843abb7f","section":"docs","title":"Router विन्यास","url":"/hi/docs/specs/configuration/"},{"categories":null,"content":" अप्रचलित: SAM v1 केवल ऐतिहासिक संदर्भ के लिए बरकरार रखा गया है। नए अनुप्रयोगों को SAM v3 या BOB का उपयोग करना चाहिए। मूल ब्रिज केवल DSA-SHA1 destinations (गंतव्य) और सीमित विकल्पों के सेट का समर्थन करता है।\nलाइब्रेरियाँ Java I2P सोर्स ट्री में अभी भी C, C#, Perl और Python के लिए पुरानी बाइंडिंग्स शामिल हैं। उनका अब रखरखाव नहीं किया जाता और इन्हें मुख्यतः आर्काइवल संगतता के लिए वितरित किया जाता है।\nसंस्करण वार्ता क्लाइंट TCP के माध्यम से (डिफ़ॉल्ट 127.0.0.1:7656) जुड़ते हैं और निम्न का आदान-प्रदान करते हैं:\nClient → HELLO VERSION MIN=1 MAX=1 Bridge → HELLO REPLY RESULT=OK VERSION=1.0 Java I2P 0.9.14 से MIN पैरामीटर वैकल्पिक है और अपग्रेड किए गए ब्रिजों के लिए MIN/MAX दोनों एक-अंकीय स्वरूप (\u0026quot;3\u0026quot; आदि) स्वीकार करते हैं।\nसत्र स्थापना SESSION CREATE STYLE={STREAM|DATAGRAM|RAW} DESTINATION={name|TRANSIENT} [DIRECTION={BOTH|RECEIVE|CREATE}] [option=value]* DESTINATION=name sam.keys में एक प्रविष्टि लोड करता है या बनाता है; TRANSIENT हमेशा एक अस्थायी destination (I2P पता) बनाता है। STYLE वर्चुअल स्ट्रीम्स (TCP-जैसी), साइन किए गए डेटाग्राम, या रॉ डेटाग्राम चुनता है। DIRECTION केवल स्ट्रीम सेशंस पर लागू होता है; डिफ़ॉल्ट BOTH है। अतिरिक्त कुंजी/मान युग्मों को I2CP विकल्पों के रूप में अग्रेषित किया जाता है (उदाहरण के लिए, tunnels.quantityInbound=3)। ब्रिज इस प्रकार उत्तर देता है:\nSESSION STATUS RESULT=OK DESTINATION=name विफलता होने पर DUPLICATED_DEST, I2P_ERROR या INVALID_KEY लौटाया जाता है, और साथ में एक वैकल्पिक संदेश भी हो सकता है।\nसंदेश प्रारूप SAM संदेश एक-पंक्ति ASCII होते हैं जिनमें कुंजी/मान युग्म स्पेस द्वारा विभाजित होते हैं। कुंजियाँ UTF‑8 होती हैं; यदि मानों में स्पेस हों तो उन्हें उद्धरण चिन्हों में रखा जा सकता है। किसी प्रकार का escaping (विशेष वर्णों का एस्केप करना) परिभाषित नहीं है।\nसंचार के प्रकार:\nस्ट्रीम्स – I2P स्ट्रीमिंग लाइब्रेरी के माध्यम से प्रॉक्सी किए गए उत्तर-सक्षम डेटाग्राम – हस्ताक्षरित पेलोड (Datagram1) रॉ डेटाग्राम – अहस्ताक्षरित पेलोड (Datagram RAW) 0.9.14 में जोड़े गए विकल्प DEST GENERATE SIGNATURE_TYPE=... को स्वीकार करता है (Ed25519 (एक क्रिप्टोग्राफ़िक हस्ताक्षर एल्गोरिद्म) आदि की अनुमति देता है) HELLO VERSION MIN को वैकल्पिक मानता है और एक-अंकीय संस्करण स्ट्रिंग्स स्वीकार करता है SAM v1 का उपयोग कब करें केवल ऐसे legacy software (पुराने सॉफ़्टवेयर जिन्हें अद्यतन नहीं किया जा सकता) के साथ अंतरसंचालन के लिए। सभी नए विकास के लिए उपयोग करें:\nSAM v3 पूर्ण सुविधाओं वाली stream/datagram पहुंच के लिए BOB destination प्रबंधन के लिए (अभी भी सीमित, लेकिन अधिक आधुनिक सुविधाओं का समर्थन करता है) संदर्भ SAM v2 SAM v3 डेटाग्राम विनिर्देश स्ट्रीमिंग प्रोटोकॉल SAM v1 ने router-निर्पेक्ष अनुप्रयोग विकास की नींव रखी थी, लेकिन पारिस्थितिकी तंत्र आगे बढ़ चुका है। इस दस्तावेज़ को शुरुआती बिंदु की बजाय संगतता सहायता के रूप में लें।\n","description":"पुराना Simple Anonymous Messaging प्रोटोकॉल (अप्रचलित)","id":"d6c20329db11e9b5a1eff3a8709b3294","section":"docs","title":"SAM v1","url":"/hi/docs/legacy/sam/"},{"categories":null,"content":" अप्रचलित: SAM v2 I2P 0.6.1.31 के साथ जारी किया गया था और अब इसका रखरखाव नहीं किया जाता। नए विकास के लिए SAM v3 का उपयोग करें। v2 में v1 की तुलना में केवल एक सुधार था: एकल SAM कनेक्शन पर मल्टीप्लेक्स किए गए कई सॉकेट्स के लिए समर्थन।\nसंस्करण नोट्स रिपोर्ट की गई संस्करण स्ट्रिंग \u0026quot;2.0\u0026quot; ही बनी रहती है. 0.9.14 से HELLO VERSION संदेश एक-अंकीय MIN/MAX मानों को स्वीकार करता है और MIN पैरामीटर वैकल्पिक है. DEST GENERATE SIGNATURE_TYPE का समर्थन करता है, इसलिए Ed25519 डेस्टिनेशन बनाए जा सकते हैं. सत्र की मूल बातें SESSION CREATE STYLE={STREAM|DATAGRAM|RAW} DESTINATION={name|TRANSIENT} [DIRECTION={BOTH|RECEIVE|CREATE}] [option=value] प्रत्येक डेस्टिनेशन के पास केवल एक सक्रिय SAM सत्र हो सकता है (स्ट्रीम्स, डेटाग्राम, या रॉ)। STYLE वर्चुअल स्ट्रीम्स, हस्ताक्षरित डेटाग्राम, या रॉ डेटाग्राम का चयन करता है। अतिरिक्त विकल्प I2CP को पास किए जाते हैं (उदाहरण के लिए, tunnels.quantityInbound=3)। प्रतिक्रियाएँ v1 के अनुरूप हैं: SESSION STATUS RESULT=OK|DUPLICATED_DEST|I2P_ERROR|INVALID_KEY। संदेश एन्कोडिंग लाइन-उन्मुख ASCII जिसमें key=value युग्म स्पेस द्वारा अलग किए गए हों (मान उद्धरण चिह्नों में हो सकते हैं)। संचार प्रकार v1 के समान हैं:\nI2P streaming library के माध्यम से स्ट्रीम्स प्रतिक्रिया-योग्य डेटाग्राम (PROTO_DATAGRAM) रॉ डेटाग्राम (PROTO_DATAGRAM_RAW) कब उपयोग करें केवल उन पुराने क्लाइंट्स के लिए जो माइग्रेट नहीं कर सकते। SAM v3 प्रदान करता है:\nबाइनरी डेस्टिनेशन हस्तांतरण (DEST GENERATE BASE64) Subsessions (उप-सत्र) और DHT (वितरित हैश तालिका) समर्थन (v3.3) बेहतर त्रुटि रिपोर्टिंग और विकल्प नेगोशिएशन देखें:\nSAM v1 SAM v3 डेटाग्राम API स्ट्रीमिंग प्रोटोकॉल ","description":"लीगेसी Simple Anonymous Messaging प्रोटोकॉल","id":"a21e46f2603ba3051f18eff26aa5084d","section":"docs","title":"SAM v2","url":"/hi/docs/legacy/samv2/"},{"categories":null,"content":"SAM v3 (\u0026ldquo;Simple Anonymous Messaging\u0026rdquo;) वर्तमान स्थिर, router agnostic API है जो बाहरी अनुप्रयोगों को I2P नेटवर्क के साथ संचार करने की अनुमति देता है बिना router को स्वयं एम्बेड किए। यह streams, datagrams, और raw messages तक एकीकृत पहुंच प्रदान करता है, और गैर-Java सॉफ़्टवेयर के लिए प्रामाणिक ब्रिज परत बना रहता है।\n1. अवलोकन और उद्देश्य SAM v3 डेवलपर्स को किसी भी भाषा में I2P aware सॉफ़्टवेयर बनाने में सक्षम बनाता है, एक हल्के TCP/UDP प्रोटोकॉल का उपयोग करके। यह router की आंतरिक कार्यप्रणाली को सरल बनाता है, TCP (7656) और UDP (7655) पर न्यूनतम कमांड प्रदान करता है। Java I2P और i2pd दोनों SAM v3 विनिर्देश के उपसमुच्चय को लागू करते हैं, हालांकि i2pd में 2025 तक अभी भी अधिकांश 3.2 और 3.3 एक्सटेंशन की कमी है।\n2. संस्करण इतिहास Version Introduced Key Features 3.00.7.3 (May 2009)Streams + Datagrams; binary destinations; `SESSION CREATE STYLE=` parameter. 3.10.9.14 (Jul 2014)Signature type negotiation via `SIGNATURE_TYPE`; improved `DEST GENERATE`. 3.20.9.24 (Jan 2016)Per session encryption + tunnel options; `STREAM CONNECT ID` support. 3.30.9.25 (Mar 2016)PRIMARY / SUBSESSION architecture; multiplexing; improved datagrams. ### नामकरण नोट Java I2P PRIMARY/SUBSESSION का उपयोग करता है। i2pd और I2P+ backward compatibility के लिए legacy MASTER/SUBSESSION terminology का उपयोग जारी रखते हैं। 3. मुख्य कार्यप्रवाह संस्करण बातचीत HELLO VERSION MIN=3.1 MAX=3.3 HELLO REPLY RESULT=OK VERSION=3.3 गंतव्य निर्माण DEST GENERATE SIGNATURE_TYPE=7 SIGNATURE_TYPE=7 → Ed25519 (EdDSA SHA512)। I2P 0.9.15 के बाद से दृढ़ता से अनुशंसित। सत्र निर्माण SESSION CREATE STYLE=STREAM DESTINATION=NAME OPTION=i2cp.leaseSetEncType=4,0 OPTION=inbound.quantity=3 OPTION=outbound.quantity=3 i2cp.leaseSetEncType=4,0 → 4 X25519 (ECIES X25519 AEAD Ratchet) है और 0 संगतता के लिए ElGamal फ़ॉलबैक है। स्थिरता के लिए स्पष्ट tunnel मात्राएँ: Java I2P डिफ़ॉल्ट 2, i2pd डिफ़ॉल्ट 5। प्रोटोकॉल संचालन STREAM CONNECT ID=1 DESTINATION=b32address.i2p STREAM SEND ID=1 SIZE=128 STREAM CLOSE ID=1 मुख्य संदेश प्रकारों में शामिल हैं: STREAM CONNECT, STREAM ACCEPT, STREAM FORWARD, DATAGRAM SEND, RAW SEND, NAMING LOOKUP, DEST LOOKUP, PING, QUIT।\nसुचारु शटडाउन QUIT 4. कार्यान्वयन अंतर (Java I2P बनाम i2pd) Feature Java I2P 2.10.0 i2pd 2.58.0 (Sept\u0026nbsp;2025) SAM enabled by default❌ Requires manual enable in router console✅ Enabled via `enabled=true` in `i2pd.conf` Default portsTCP 7656 / UDP 7655Same AUTH / USER / PASSWORD✓ Supported✗ Not implemented PING / PONG keepalive✓ Supported✗ Not implemented QUIT / STOP / EXIT commands✓ Supported✗ Not implemented FROM_PORT / TO_PORT / PROTOCOL✓ Supported✗ Not implemented PRIMARY/SUBSESSION support✓ (since 0.9.47)✗ Absent SESSION ADD / REMOVE✓ Supported✗ Not implemented Datagram2 / Datagram3 support✓ (since 2.9.0)✗ Not implemented SSL/TLSOptional✗ None Default tunnel quantitiesInbound/outbound=2Inbound/outbound=5 **सिफारिश:** क्रॉस router संगतता सुनिश्चित करने के लिए हमेशा tunnel की संख्या स्पष्ट रूप से निर्दिष्ट करें। 5. समर्थित लाइब्रेरीज़ (2025 स्नैपशॉट) Library Language SAM Support Maintenance Status (2025) libsam3C3.1Maintained by I2P Project (eyedeekay) i2psamC++3.1Minimal updates since 2019 sam3Go3.3Active; migrated from `eyedeekay/sam3` onrampGo3.3Actively maintained (2025) i2plibPython3.1Modern async replacement for `i2p.socket` i2p.socketPython3.2Abandoned (last release 2017) Py2pPython3.3Unverified/inactive i2p-rsRust3.1Experimental; unstable API @diva.exchange/i2p-samTypeScript / JS3.3Most actively maintained (2024–2025) I2PSharpC#3.3Functional; light maintenance ## 6. आगामी और नई सुविधाएँ (2024–2025) Feature Status Introduced NAMING LOOKUP `OPTIONS=true`✓ Supported2.8.0 Datagram2 / Datagram3 formats✓ (Java only)2.9.0 Post-quantum hybrid crypto (ML KEM)Optional2.10.0 Java 17+ runtime requirementPlanned2.11.0 I2P over Tor blockingActive2.6.0 Improved floodfill selectionActive2.8.0+ ## 7. सुरक्षा और कॉन्फ़िगरेशन नोट्स SAM को केवल 127.0.0.1 पर bind करें। स्थायी सेवाओं के लिए, स्थिर keys के साथ PRIMARY sessions का उपयोग करें। सुविधा समर्थन की जाँच के लिए HELLO VERSION का उपयोग करें। router की सक्रियता सत्यापित करने के लिए PING या NAMING LOOKUP का उपयोग करें। अप्रमाणित रिमोट SAM कनेक्शन से बचें (i2pd में TLS नहीं है)। 8. संदर्भ और विनिर्देश SAM v3 विशिष्टता SAM v2 (लिगेसी) स्ट्रीमिंग विशिष्टता डेटाग्राम दस्तावेज़ीकरण हब i2pd दस्तावेज़ीकरण 9. सारांश SAM v3 सभी गैर-Java I2P अनुप्रयोगों के लिए अनुशंसित ब्रिज प्रोटोकॉल बना हुआ है। यह स्थिरता, क्रॉस लैंग्वेज बाइंडिंग्स, और router प्रकारों में सुसंगत प्रदर्शन प्रदान करता है।\nSAM के साथ विकास करते समय: - Ed25519 signatures और X25519 encryption का उपयोग करें। - HELLO VERSION के माध्यम से सुविधा समर्थन को गतिशील रूप से सत्यापित करें। - संगतता के लिए डिज़ाइन करें, विशेष रूप से जब Java I2P और i2pd routers दोनों का समर्थन कर रहे हों।\n","description":"गैर-Java I2P अनुप्रयोगों के लिए स्थिर ब्रिज प्रोटोकॉल","id":"dd6d27c1d72fe7c4333dc148d132f546","section":"docs","title":"SAM v3","url":"/hi/docs/api/samv3/"},{"categories":null,"content":" सावधानी: SOCKS tunnel एप्लिकेशन payloads को बिना sanitize किए forward करता है। कई protocols IPs, hostnames, या अन्य identifiers leak करते हैं। केवल उस software के साथ SOCKS का उपयोग करें जिसे आपने anonymity के लिए audit किया है।\n1. अवलोकन I2P SOCKS 4, 4a, और 5 proxy समर्थन प्रदान करता है outbound connections के लिए एक I2PTunnel client के माध्यम से। यह मानक applications को I2P destinations तक पहुंचने में सक्षम बनाता है लेकिन clearnet तक पहुंच नहीं सकता। कोई SOCKS outproxy नहीं है, और सभी traffic I2P network के भीतर ही रहता है।\nकार्यान्वयन सारांश Parameter Java I2P i2pd Default Port User-defined 127.0.0.1:4447 Supported SOCKS Versions 4, 4a, 5 4, 4a, 5 UDP Mode Stubbed (non-functional) Stubbed (non-functional) Persistent Keys ✅ Since 0.9.9 ✅ Shared Client Tunnels Supported Supported Outproxy Support ❌ None ❌ None **समर्थित पता प्रकार:** - `.i2p` होस्टनाम (addressbook प्रविष्टियाँ) - Base32 हैश (`.b32.i2p`) - Base64 या clearnet समर्थन नहीं 2. सुरक्षा जोखिम और सीमाएं एप्लिकेशन-लेयर लीकेज SOCKS एप्लिकेशन लेयर के नीचे काम करता है और प्रोटोकॉल को सैनिटाइज नहीं कर सकता। कई क्लाइंट (जैसे, ब्राउज़र, IRC, ईमेल) में मेटाडेटा शामिल होता है जो आपका IP एड्रेस, होस्टनेम, या सिस्टम विवरण प्रकट कर देता है।\nसामान्य लीक में शामिल हैं: - मेल हेडर या IRC CTCP प्रतिक्रियाओं में IP - प्रोटोकॉल पेलोड में वास्तविक नाम/उपयोगकर्ता नाम - OS फिंगरप्रिंट वाले User-agent स्ट्रिंग - बाहरी DNS क्वेरी - WebRTC और ब्राउज़र टेलीमेट्री\nI2P इन लीक को रोक नहीं सकता—ये tunnel परत के ऊपर होते हैं। केवल गुमनामी के लिए डिज़ाइन किए गए ऑडिटेड क्लाइंट के लिए ही SOCKS का उपयोग करें।\nसाझा टनल पहचान यदि कई एप्लिकेशन एक SOCKS tunnel साझा करते हैं, तो वे समान I2P destination identity साझा करते हैं। यह विभिन्न सेवाओं में correlation या fingerprinting को सक्षम बनाता है।\nसमाधान: प्रत्येक एप्लिकेशन के लिए non-shared tunnels का उपयोग करें और रीस्टार्ट के दौरान सुसंगत क्रिप्टोग्राफिक पहचान बनाए रखने के लिए persistent keys को सक्षम करें।\nUDP मोड स्टब्ड आउट SOCKS5 में UDP समर्थन लागू नहीं किया गया है। प्रोटोकॉल UDP क्षमता का विज्ञापन करता है, लेकिन कॉल्स को नजरअंदाज कर दिया जाता है। केवल TCP क्लाइंट्स का उपयोग करें।\nडिज़ाइन के अनुसार कोई Outproxy नहीं Tor के विपरीत, I2P SOCKS-आधारित clearnet outproxies प्रदान नहीं करता है। बाहरी IP तक पहुँचने का प्रयास विफल हो जाएगा या पहचान उजागर कर देगा। यदि outproxying आवश्यक है तो HTTP या HTTPS proxies का उपयोग करें।\n3. ऐतिहासिक संदर्भ डेवलपर्स ने लंबे समय से गुमनाम उपयोग के लिए SOCKS को हतोत्साहित किया है। आंतरिक डेवलपर चर्चाओं और 2004 की Meeting 81 और Meeting 82 से:\n\u0026ldquo;मनमाना ट्रैफ़िक को फ़ॉरवर्ड करना असुरक्षित है, और गुमनामी सॉफ़्टवेयर के डेवलपर्स के रूप में हमारे लिए यह आवश्यक है कि हम अपने अंतिम उपयोगकर्ताओं की सुरक्षा को अपने दिमाग में सर्वोपरि रखें।\u0026rdquo;\nSOCKS समर्थन संगतता के लिए शामिल किया गया था लेकिन उत्पादन वातावरण के लिए अनुशंसित नहीं है। लगभग हर इंटरनेट एप्लिकेशन संवेदनशील मेटाडेटा लीक करता है जो गुमनाम रूटिंग के लिए उपयुक्त नहीं है।\n4. कॉन्फ़िगरेशन Java I2P I2PTunnel Manager खोलें \u0026ldquo;SOCKS 4/4a/5\u0026rdquo; प्रकार की एक नई क्लाइंट tunnel बनाएं विकल्पों को कॉन्फ़िगर करें: लोकल पोर्ट (कोई भी उपलब्ध) शेयर्ड क्लाइंट: प्रत्येक ऐप के लिए अलग पहचान हेतु अक्षम करें पर्सिस्टेंट की: की सहसंबंध को कम करने के लिए सक्षम करें tunnel शुरू करें i2pd i2pd में SOCKS5 समर्थन डिफ़ॉल्ट रूप से 127.0.0.1:4447 पर सक्षम होता है। i2pd.conf में [SOCKSProxy] के अंतर्गत कॉन्फ़िगरेशन आपको पोर्ट, होस्ट और tunnel पैरामीटर समायोजित करने की अनुमति देता है।\n5. विकास समयरेखा Version Change Date 0.7.1 Initial SOCKS 4/4a/5 support 2010 0.9.9 Added persistent keying 2013 1.7.0 BOB API deprecated and removed 2022 2.6.0 I2P-over-Tor blocked to improve network health 2024 2.10.0 Post-quantum hybrid encryption introduced 2025 SOCKS मॉड्यूल में 2013 के बाद से कोई बड़े प्रोटोकॉल अपडेट नहीं हुए हैं, लेकिन इसके आसपास के tunnel stack में प्रदर्शन और क्रिप्टोग्राफिक सुधार हुए हैं। 6. अनुशंसित विकल्प किसी भी production, public-facing, या security-critical एप्लिकेशन के लिए, SOCKS के बजाय आधिकारिक I2P APIs में से किसी एक का उपयोग करें:\nAPI Description Recommended For SAM v3 (3.3) Simple Anonymous Messaging API Cross-language apps needing socket-like I/O Streaming Library TCP-like sockets for Java Native Java integrations I2CP Low-level router communication Custom protocols, router-level integration BOB Deprecated (removed 2022) Legacy only; migrate to SAM ये APIs उचित गंतव्य अलगाव, क्रिप्टोग्राफिक पहचान नियंत्रण, और बेहतर routing प्रदर्शन प्रदान करते हैं। 7. OnionCat / GarliCat OnionCat अपने GarliCat मोड (fd60:db4d:ddb5::/48 IPv6 रेंज) के माध्यम से I2P का समर्थन करता है। अभी भी कार्यात्मक है लेकिन 2019 के बाद से सीमित विकास के साथ।\nउपयोग संबंधी सावधानियां: - SusiDNS में मैन्युअल .oc.b32.i2p कॉन्फ़िगरेशन की आवश्यकता होती है - स्थिर IPv6 असाइनमेंट की आवश्यकता होती है - I2P प्रोजेक्ट द्वारा आधिकारिक रूप से समर्थित नहीं\nकेवल उन्नत VPN-over-I2P सेटअप के लिए अनुशंसित।\n8. सर्वोत्तम प्रथाएं यदि आपको SOCKS का उपयोग करना ही है: 1. प्रत्येक एप्लिकेशन के लिए अलग tunnels बनाएं। 2. shared client mode को अक्षम करें। 3. persistent keys को सक्षम करें। 4. SOCKS5 DNS resolution को बाध्य करें। 5. लीक के लिए प्रोटोकॉल व्यवहार की जांच करें। 6. clearnet कनेक्शन से बचें। 7. लीक के लिए नेटवर्क ट्रैफ़िक की निगरानी करें।\n9. तकनीकी सारांश Parameter Value Supported SOCKS Versions 4, 4a, 5 Transport TCP only UDP Support Stubbed (non-functional) Clearnet Access Not supported Default Ports Java I2P: user-set; i2pd: 127.0.0.1:4447 Persistent Keying Supported since 0.9.9 Shared Tunnels Supported (discouraged) --- 10. निष्कर्ष I2P में SOCKS proxy मौजूदा TCP applications के साथ बुनियादी संगतता प्रदान करता है लेकिन यह मजबूत गुमनामी की गारंटी के लिए डिज़ाइन नहीं किया गया है। इसका उपयोग केवल नियंत्रित, ऑडिट किए गए परीक्षण वातावरण के लिए किया जाना चाहिए।\nगंभीर तैनाती के लिए, SAM v3 या Streaming API में माइग्रेट करें। ये API एप्लिकेशन पहचान को अलग करते हैं, आधुनिक क्रिप्टोग्राफी का उपयोग करते हैं, और निरंतर विकास प्राप्त करते हैं।\nअतिरिक्त संसाधन आधिकारिक SOCKS दस्तावेज़ SAM v3 विनिर्देश Streaming Library दस्तावेज़ I2PTunnel संदर्भ I2P डेवलपर दस्तावेज़ समुदाय मंच ","description":"I2P के SOCKS tunnel का सुरक्षित उपयोग (2.10.0 के लिए अद्यतन)","id":"e71093f25f593f15b6820398338abc89","section":"docs","title":"SOCKS प्रॉक्सी","url":"/hi/docs/api/socks/"},{"categories":null,"content":" अप्रचलित: SSU को SSU2 द्वारा प्रतिस्थापित किया गया। समर्थन i2pd 2.44.0 (API 0.9.56, नवंबर 2022) और Java I2P 2.4.0 (API 0.9.61, दिसंबर 2023) से हटा दिया गया।\nSSU ने UDP-आधारित, अर्ध-विश्वसनीय डिलीवरी प्रदान की, जिसमें भीड़-नियंत्रण, NAT traversal (NAT पारगमन), और introducer (परिचयकर्ता) समर्थन शामिल था। यह NTCP का पूरक रहा, NAT/फ़ायरवॉल के पीछे स्थित routers को संभालकर और IP खोज का समन्वय करके।\nपते के घटक transport: SSU caps: क्षमता फ़्लैग (B, C, 4, 6, आदि) host / port: IPv4 या IPv6 लिस्नर (फ़ायरवॉल के पीछे होने पर वैकल्पिक) key: Base64 परिचय कुंजी mtu: वैकल्पिक; डिफ़ॉल्ट 1484 (IPv4) / 1488 (IPv6) ihost/ikey/iport/itag/iexp: जब router फ़ायरवॉल के पीछे हो, तब introducer (परिचयक) प्रविष्टियाँ विशेषताएँ introducers (परिचयकर्ता) का उपयोग करते हुए सहकारी NAT traversal (NAT पारगमन) पीयर परीक्षणों और आवक पैकेटों के निरीक्षण के माध्यम से स्थानीय IP का पता लगाना फ़ायरवॉल स्थिति को स्वचालित रूप से अन्य ट्रांसपोर्ट्स और router कंसोल तक रिले करना अर्ध-विश्वसनीय डिलीवरी: संदेशों को एक सीमा तक पुनःप्रेषित किया जाता है, फिर छोड़ दिया जाता है additive increase / multiplicative decrease (योगात्मक वृद्धि/गुणात्मक कमी) के साथ भीड़ नियंत्रण, और fragment ACK bitfields (खंड ACK बिटफ़ील्ड्स) SSU ने टाइमिंग बीकन (समय संकेत) और MTU (अधिकतम ट्रांसमिशन यूनिट) नेगोशिएशन जैसे मेटाडेटा कार्य भी संभाले थे। अब यह समस्त कार्यक्षमता (आधुनिक क्रिप्टोग्राफी के साथ) SSU2 द्वारा प्रदान की जाती है।\n","description":"मूल सुरक्षित अर्ध-विश्वसनीय UDP ट्रांसपोर्ट","id":"15d4d0ea2bfc8074b5a7981b8673c420","section":"docs","title":"SSU (पुराना)","url":"/hi/docs/legacy/ssu/"},{"categories":null,"content":" अप्रचलित: SSU (सुरक्षित अर्ध-विश्वसनीय UDP) को SSU2 द्वारा प्रतिस्थापित किया गया है। Java I2P ने रिलीज़ 2.4.0 (API 0.9.61) में SSU हटाया और i2pd ने 2.44.0 (API 0.9.56) में इसे हटा दिया। यह दस्तावेज़ केवल ऐतिहासिक संदर्भ के लिए रखा गया है।\nमुख्य विशेषताएँ UDP ट्रांसपोर्ट जो I2NP संदेशों की एन्क्रिप्टेड, प्रमाणित पॉइंट-टू-पॉइंट डिलीवरी प्रदान करता था। 2048-बिट Diffie–Hellman handshake (कुंजी-विनिमय हैंडशेक) पर निर्भर था (ElGamal के समान अभाज्य संख्या)। प्रत्येक datagram (UDP पैकेट) में 16-बाइट HMAC-MD5 (गैर-मानक संक्षिप्त संस्करण) (क्रिप्टोग्राफ़िक MAC/हैश एल्गोरिथ्म) + 16-बाइट IV (Initialization Vector, आरंभिक वेक्टर) होता था, जिसके बाद AES-256-CBC (ब्लॉक-साइफर एन्क्रिप्शन मोड) से एन्क्रिप्टेड पेलोड होता था। रीप्ले रोकथाम और सत्र स्थिति का ट्रैक एन्क्रिप्टेड पेलोड के भीतर रखा जाता था। संदेश शीर्षलेख [16-byte MAC][16-byte IV][encrypted payload] उपयोग की गई MAC (Message Authentication Code — संदेश प्रमाणीकरण कोड) गणना: HMAC-MD5(ciphertext || IV || (len ^ version ^ ((netid-2)\u0026lt;\u0026lt;8))) 32-बाइट की MAC कुंजी के साथ। पेलोड लंबाई बिग-एंडियन 16-बिट में थी, जिसे MAC गणना के भीतर संलग्न किया गया था। प्रोटोकॉल संस्करण का डिफ़ॉल्ट 0 था; netId का डिफ़ॉल्ट 2 (मुख्य नेटवर्क) था।\nसत्र और MAC कुंजियाँ DH साझा रहस्य से व्युत्पन्न:\nसाझा मान को big-endian (सबसे महत्वपूर्ण बाइट पहले) बाइट ऐरे में बदलें (यदि उच्च बिट सेट हो तो शुरुआत में 0x00 जोड़ें)। सत्र कुंजी: पहले 32 बाइट (यदि लंबाई कम हो तो शून्यों से पैड करें)। MAC key (Message Authentication Code के लिए कुंजी): बाइट 33–64; यदि पर्याप्त न हों, तो साझा मान के SHA-256 हैश का उपयोग करें। स्थिति Routers अब SSU पतों की घोषणा नहीं करते। क्लाइंट्स को SSU2 या NTCP2 ट्रांसपोर्ट्स पर स्थानांतरित होना चाहिए। ऐतिहासिक कार्यान्वयन पुराने रिलीज़ों में मिल सकते हैं:\nrouter/transport/udp के अंतर्गत 2.4.0 से पहले का Java स्रोत कोड 2.44.0 से पहले का i2pd स्रोत कोड वर्तमान UDP ट्रांसपोर्ट के व्यवहार के लिए, SSU2 विनिर्देश देखें।\n","description":"SSU2 से पहले प्रयुक्त मूल UDP ट्रांसपोर्ट","id":"1eefecf66e3adc6ea013d5a5e58326da","section":"docs","title":"SSU ट्रांसपोर्ट (अप्रचलित)","url":"/hi/docs/legacy/ssu/"},{"categories":null,"content":"1. अवलोकन SSU2 एक UDP-आधारित ट्रांसपोर्ट-लेयर प्रोटोकॉल है, जिसका उपयोग I2P में सुरक्षित, अर्ध-विश्वसनीय router से router के बीच संचार के लिए किया जाता है। यह सामान्य-उद्देश्य ट्रांसपोर्ट नहीं है, बल्कि I2NP संदेश विनिमय के लिए विशेषीकृत है।\nमुख्य क्षमताएँ Noise XK pattern (Noise प्रोटोकॉल का XK पैटर्न) के माध्यम से प्रमाणित कुंजी विनिमय DPI (डीप पैकेट इंस्पेक्शन) प्रतिरोध के लिए एन्क्रिप्टेड हेडर रिले और hole-punching (NAT के पीछे साथियों के बीच सीधे कनेक्शन स्थापित करने की तकनीक) का उपयोग करके NAT (नेटवर्क एड्रेस ट्रांसलेशन) ट्रैवर्सल कनेक्शन माइग्रेशन और पते का सत्यापन वैकल्पिक पथ सत्यापन Forward secrecy (अग्र-गोपनीयता) और replay protection (रीप्ले हमलों से सुरक्षा) लेगेसी (पुरानी प्रणालियाँ) और संगतता Implementation SSU2 Default SSU1 Removed i2pd2.44.02.44.0 Java I2P0.9.560.9.61 SSU1 अब पूरे सार्वजनिक I2P नेटवर्क में उपयोग में नहीं है। 2. क्रिप्टोग्राफी SSU2 I2P-विशिष्ट एक्सटेंशनों के साथ Noise_XK_25519_ChaChaPoly_SHA256 का उपयोग करता है।\nFunction Algorithm Notes Diffie-HellmanX25519 (RFC 7748)32-byte keys CipherChaCha20/Poly1305 (RFC 7539)AEAD encryption HashSHA-256Used for key derivation and message integrity KDFHKDF-SHA256 (RFC 5869)For session and header keys `mixHash()` के माध्यम से हेडर और पेलोड को क्रिप्टोग्राफिक रूप से बाँधा जाता है. कार्यान्वयन दक्षता के लिए, सभी क्रिप्टोग्राफिक प्रिमिटिव्स (मूलभूत क्रिप्टो घटक) NTCP2 और ECIES के साथ साझा किए जाते हैं. 3. संदेश का अवलोकन 3.1 UDP डेटाग्राम नियम प्रत्येक UDP डेटाग्राम में ठीक एक SSU2 संदेश होता है. Session Confirmed (सेशन पुष्टिकृत) संदेश कई डेटाग्रामों में खंडित किए जा सकते हैं. न्यूनतम आकार: 40 बाइट्स अधिकतम आकार: 1472 बाइट्स (IPv4) / 1452 बाइट्स (IPv6)\n3.2 संदेश प्रकार Type Message Header Description 0Session Request32BHandshake initiation 1Session Created32BHandshake response 2Session Confirmed16BFinal handshake, may be fragmented 6Data16BEncrypted I2NP message blocks 7Peer Test32BNAT reachability testing 9Retry32BToken or rejection notice 10Token Request32BRequest for validation token 11Hole Punch32BNAT traversal signaling --- 4. सत्र स्थापना 4.1 मानक प्रवाह (वैध टोकन) Alice Bob SessionRequest ─────────────\u0026gt; \u0026lt;────────────── SessionCreated SessionConfirmed ────────────\u0026gt; 4.2 टोकन प्राप्ति Alice Bob TokenRequest ───────────────\u0026gt; \u0026lt;────────────── Retry (Token) SessionRequest ─────────────\u0026gt; \u0026lt;────────────── SessionCreated SessionConfirmed ────────────\u0026gt; 4.3 अमान्य टोकन Alice Bob SessionRequest ─────────────\u0026gt; \u0026lt;────────────── Retry (Termination) 5. हेडर संरचनाएँ 5.1 लंबा हेडर (32 बाइट्स) सत्र स्थापना से पहले उपयोग किया जाता है (SessionRequest, Created, Retry, PeerTest, TokenRequest, HolePunch).\nField Size Description Destination Connection ID8Random unique ID Packet Number4Random (ignored during handshake) Type1Message type Version1Always 2 NetID12 = main I2P network Flags1Reserved (0) Source Connection ID8Random ID distinct from destination Token8Token for address validation ### 5.2 संक्षिप्त हेडर (16 बाइट्स) स्थापित सत्रों के दौरान उपयोग किया जाता है (SessionConfirmed, Data).\nField Size Description Destination Connection ID8Stable throughout session Packet Number4Incrementing per message Type1Message type (2 or 6) Flags3ACK/fragment flags --- 6. कूटलेखन 6.1 AEAD (संबद्ध डेटा के साथ प्रमाणित एन्क्रिप्शन) सभी पेलोड ChaCha20/Poly1305 AEAD (संबद्ध डेटा सहित प्रमाणीकरणयुक्त एन्क्रिप्शन) से एन्क्रिप्ट किए जाते हैं:\nciphertext = ChaCha20_Poly1305_Encrypt(key, nonce, plaintext, associated_data) Nonce (एक बार प्रयुक्त मान): 12 बाइट्स (4 शून्य + 8 काउंटर) टैग: 16 बाइट्स संबद्ध डेटा: अखंडता बाइंडिंग के लिए हेडर शामिल करता है 6.2 हेडर सुरक्षा हेडर सत्र हेडर कुंजियों से व्युत्पन्न ChaCha20 keystream (स्ट्रीम सिफर से उत्पन्न कुंजी-धारा) का उपयोग करके मास्क किए जाते हैं। यह सुनिश्चित करता है कि सभी Connection IDs (कनेक्शन पहचानकर्ता) और पैकेट फ़ील्ड यादृच्छिक प्रतीत हों, जिससे DPI (Deep Packet Inspection) के प्रति प्रतिरोधकता मिलती है।\n6.3 कुंजी व्युत्पत्ति Phase Input Output InitialintroKey + salthandshake header key HandshakeDH(X25519)chainKey + AEAD key Data phasechainKeyTX/RX keys Key rotationoldKeynewKey --- 7. सुरक्षा और Replay (दोहराए गए हमले) की रोकथाम टोकन प्रति‑IP जारी किए जाते हैं, जो ~60 सेकंड में समाप्त हो जाते हैं. रीप्ले को प्रति‑सत्र Bloom filters (प्रायिकता-आधारित सदस्यता जाँच संरचना) के माध्यम से रोका जाता है. डुप्लिकेट अल्पकालिक कुंजियाँ अस्वीकृत कर दी जाती हैं. हेडर और पेलोड क्रिप्टोग्राफ़िक रूप से परस्पर जुड़े होते हैं. Routers को AEAD (Authenticated Encryption with Associated Data; संबद्ध डेटा सहित प्रमाणीकृत एन्क्रिप्शन) प्रमाणीकरण में विफल, या अमान्य संस्करण या NetID वाले किसी भी पैकेट को त्याग देना चाहिए।\n8. पैकेट क्रमांकन और सत्र का जीवनकाल प्रत्येक दिशा अपना स्वयं का 32-बिट काउंटर बनाए रखती है। - 0 से शुरू होता है, प्रत्येक पैकेट पर बढ़ता है। - रैप नहीं होना चाहिए; 2³² तक पहुँचने से पहले session rekey (सेशन की बदलना) करें या सत्र समाप्त करें।\nकनेक्शन IDs पूरे सत्र के दौरान अपरिवर्तित रहती हैं, माइग्रेशन के दौरान भी।\n9. डेटा चरण प्रकार = 6 (डेटा) संक्षिप्त हेडर (16 बाइट्स) पेलोड में एक या अधिक एन्क्रिप्टेड ब्लॉक होते हैं: ACK/NACK सूचियाँ I2NP संदेश खंड पैडिंग (0–31 बाइट्स यादृच्छिक) समापन ब्लॉक (वैकल्पिक) चयनात्मक पुनः-प्रेषण (selective retransmission) और क्रम-बाह्य डिलीवरी (out-of-order delivery) समर्थित हैं। विश्वसनीयता “अर्ध-विश्वसनीय” (semi-reliable) बनी रहती है — पुनःप्रयास सीमाएँ पार होने के बाद गुम पैकेटों को चुपचाप त्याग दिया जा सकता है।\n10. रिले और NAT पारगमन Message Type Purpose Peer Test7Determines inbound reachability Retry9Issues new token or rejection Token Request10Requests new address token Hole Punch11Coordinates NAT hole punching रिले routers इन नियंत्रण संदेशों का उपयोग करके प्रतिबंधात्मक NATs के पीछे स्थित पीयर्स की सहायता करते हैं। 11. सत्र समाप्ति किसी भी peer (सहकर्मी नोड) एक Data message (डेटा संदेश) के भीतर Termination block (समापन ब्लॉक) का उपयोग करके सत्र को बंद कर सकता है। प्राप्त होते ही संसाधनों को तुरंत मुक्त कर देना चाहिए। स्वीकृति के बाद दोहराए गए समापन पैकेटों को नज़रअंदाज़ किया जा सकता है।\n12. कार्यान्वयन दिशानिर्देश Routers MUST: - version = 2 और NetID = 2 को सत्यापित करें. - 40 बाइट से छोटे पैकेट या अमान्य AEAD को ड्रॉप करें. - 120s replay cache (रीप्ले कैश) लागू करें. - पुन: उपयोग किए गए टोकन या ephemeral keys (क्षणिक कुंजियाँ) को अस्वीकार करें.\nRouters SHOULD: - 0–31 बाइट की पैडिंग को यादृच्छिक करें. - अनुकूली पुनर्प्रेषण का उपयोग करें (RFC 6298). - स्थानांतरण से पहले प्रति-पीयर पथ सत्यापन लागू करें.\n13. सुरक्षा सारांश Property Achieved By Forward secrecyX25519 ephemeral keys Replay protectionTokens + Bloom filter Authenticated encryptionChaCha20/Poly1305 KCI resistanceNoise XK pattern DPI resistanceEncrypted headers NAT traversalRelay + Hole Punch MigrationStatic connection IDs --- 14. संदर्भ प्रस्ताव 159 – SSU2 Noise प्रोटोकॉल फ्रेमवर्क RFC 9000 – QUIC ट्रांसपोर्ट RFC 9001 – QUIC TLS RFC 7539 – ChaCha20/Poly1305 AEAD (प्रमाणीकृत एन्क्रिप्शन के साथ संबद्ध डेटा) RFC 7748 – X25519 ECDH RFC 5869 – HKDF-SHA256 ","description":"सुरक्षित अर्ध-विश्वसनीय UDP ट्रांसपोर्ट प्रोटोकॉल संस्करण 2","id":"b45756033b706b68daaee09f536f3c91","section":"docs","title":"SSU2 विनिर्देश","url":"/hi/docs/specs/ssu2/"},{"categories":null,"content":" नोट: यह संग्रह I2P 0.9.41 से पहले का अनुमानात्मक डिज़ाइन कार्य समाहित करता है। उत्पादन कार्यान्वयन के लिए, tunnel प्रलेखन देखें।\nविन्यास के विकल्प भविष्य के tunnel knobs (कॉन्फ़िगरेशन विकल्प) के लिए विचार किए गए सुझावों में शामिल थे:\nसंदेश वितरण के लिए आवृत्ति-आधारित नियंत्रण पैडिंग नीतियाँ (जिसमें chaff injection (नकली डेटा सम्मिलन) शामिल है) Tunnel जीवनकाल नियंत्रण पेलोड प्रेषण के लिए बैच और क्यू रणनीतियाँ इनमें से कोई भी विकल्प पुराने कार्यान्वयन के साथ शामिल नहीं था.\nपैडिंग रणनीतियाँ चर्चा किए गए संभावित padding (डेटा भराव) दृष्टिकोण:\nबिल्कुल भी पैडिंग नहीं यादृच्छिक लंबाई की पैडिंग निश्चित लंबाई की पैडिंग निकटतम किलोबाइट तक पैडिंग दो की घातों के अनुसार पैडिंग (2^n बाइट्स) प्रारंभिक माप (रिलीज़ 0.4) के परिणामस्वरूप वर्तमान स्थिर 1024-बाइट tunnel संदेश आकार निर्धारित किया गया। उच्च-स्तरीय garlic messages (I2P में प्रयुक्त बहु-पेलोड संदेश प्रारूप) अपनी स्वयं की पैडिंग जोड़ सकते हैं।\nविखंडन संदेश की लंबाई के माध्यम से होने वाले टैगिंग हमलों को रोकने के लिए, tunnel संदेशों का आकार 1024 बाइट पर स्थिर रखा जाता है। बड़े I2NP पेलोड गेटवे द्वारा खंडित किए जाते हैं; एंडपॉइंट एक छोटे timeout (समयसीमा) के भीतर खंडों को पुनः संयोजित करता है। Routers भेजने से पहले पैकिंग दक्षता को अधिकतम करने के लिए खंडों को पुनर्व्यवस्थित कर सकते हैं।\nअतिरिक्त विकल्प Tunnel प्रोसेसिंग को चलते समय समायोजित करें तीन संभावनाओं की जाँच की गई:\nकिसी मध्यवर्ती hop (नेटवर्क मार्ग का एक चरण) को डिक्रिप्ट किए गए पेलोड तक पहुँच प्रदान करके किसी tunnel को अस्थायी रूप से समाप्त करने की अनुमति दें। सहभागी routers को यह अनुमति दें कि वे संदेशों को “रीमिक्स” करें, यानी अगले hop पर आगे बढ़ने से पहले उन्हें अपनी ही outbound tunnels में से किसी एक के माध्यम से भेजें। tunnel के निर्माता को किसी समकक्ष के अगले hop को गतिशील रूप से पुनर्परिभाषित करने में सक्षम बनाएं। द्विदिशीय Tunnels अलग-अलग इनबाउंड और आउटबाउंड tunnels का उपयोग करने से किसी एक समकक्ष समूह द्वारा देखी जा सकने वाली जानकारी सीमित रहती है (उदाहरण के लिए, एक GET अनुरोध बनाम एक बड़ी प्रतिक्रिया). द्विदिश tunnels समकक्ष प्रबंधन को सरल बनाती हैं, लेकिन दोनों दिशाओं में एक साथ पूरे ट्रैफ़िक पैटर्न उजागर कर देती हैं। इसीलिए एकदिश tunnels को पसंदीदा डिज़ाइन माना गया।\nबैकचैनल और परिवर्ती आकार परिवर्तनीय tunnel संदेश आकारों की अनुमति देने से मिलीभगत करने वाले समकक्षों के बीच covert channels (छिपे हुए संचार चैनल) संभव हो सकते हैं (जैसे, चयनित आकार या आवृत्तियों के माध्यम से डेटा एन्कोड करना)। स्थिर-आकार संदेश इस जोखिम को कम करते हैं, लेकिन इसके बदले अतिरिक्त पैडिंग ओवरहेड की कीमत चुकानी पड़ती है।\nTunnel निर्माण के विकल्प संदर्भ: Hashing it out in Public लेगेसी “Parallel” बिल्ड विधि रिलीज़ 0.6.1.10 से पहले, tunnel निर्माण अनुरोध प्रत्येक प्रतिभागी को समानांतर रूप से भेजे जाते थे। यह विधि पुराना tunnel पृष्ठ पर प्रलेखित है।\nएक-चरणीय टेलीस्कोपिक निर्माण (वर्तमान विधि) आधुनिक तरीका आंशिक रूप से निर्मित tunnel के माध्यम से build messages को hop-by-hop भेजता है। हालांकि यह Tor के telescoping (क्रमिक विस्तार की विधि) के समान है, exploratory tunnels के माध्यम से build messages को मार्गित करना सूचना के रिसाव को कम करता है।\n“इंटरैक्टिव” Telescoping (क्रमिक, नोड-दर-नोड निर्माण की विधि) स्पष्ट राउंड-ट्रिप्स के साथ एक-एक हॉप बनाना समकक्षों को संदेशों की गिनती करने और tunnel में अपनी स्थिति का निष्कर्ष निकालने की अनुमति देता है, इसलिए इस दृष्टिकोण को खारिज कर दिया गया।\nअन्वेषण-रहित प्रबंधन Tunnels बिल्ड ट्रैफ़िक के लिए प्रबंधन tunnels का एक अलग पूल बनाए रखने का एक प्रस्ताव था। हालांकि यह विभाजित routers की मदद कर सकता था, लेकिन पर्याप्त नेटवर्क एकीकरण के साथ इसे अनावश्यक माना गया।\nअन्वेषणात्मक वितरण (लेगेसी) 0.6.1.10 से पहले, अलग-अलग tunnel अनुरोधों को garlic encryption (I2P की बहु-संदेश एन्क्रिप्शन तकनीक) का उपयोग करके एन्क्रिप्ट किया जाता था और उन्हें अन्वेषणात्मक tunnels के माध्यम से प्रेषित किया जाता था, जबकि उनके जवाब अलग से वापस आते थे। इस रणनीति को वर्तमान one-shot telescoping विधि (एक ही प्रयास में क्रमिक विस्तार करने की पद्धति) से बदल दिया गया।\nमुख्य निष्कर्ष नियत आकार वाले tunnel संदेश, अतिरिक्त पैडिंग लागत के बावजूद, आकार-आधारित टैगिंग और गुप्त चैनलों के विरुद्ध सुरक्षा प्रदान करते हैं। वैकल्पिक पैडिंग, fragmentation (खंडन), और बिल्ड रणनीतियों का अन्वेषण किया गया, परंतु अज्ञातता से जुड़े समझौतों के संदर्भ में तौलने पर उन्हें अपनाया नहीं गया। tunnel डिज़ाइन दक्षता, अवलोकनीयता, और पूर्ववर्ती तथा भीड़भाड़-आधारित आक्रमणों के विरुद्ध प्रतिरोधक क्षमता के बीच संतुलन बनाए रखता है। ","description":"tunnel पैडिंग (भराव), फ्रैगमेंटेशन (खंडन), और निर्माण रणनीतियों का ऐतिहासिक अन्वेषण","id":"e5773155afe129d73b1384e5c116ec56","section":"docs","title":"Tunnel पर चर्चा","url":"/hi/docs/legacy/tunnel/"},{"categories":null,"content":" दायरा: यह मार्गदर्शिका tunnel कार्यान्वयन, संदेश प्रारूप, और दोनों tunnel निर्माण विनिर्देशों (ECIES (एन्क्रिप्शन योजना) और पुरानी ElGamal) को एकीकृत करती है। मौजूदा डीप लिंक ऊपर दिए गए उपनामों के माध्यम से काम करते रहेंगे।\nTunnel मॉडल I2P पेलोड्स को एकदिशीय tunnels के माध्यम से अग्रेषित करता है: ऐसे router के क्रमबद्ध समूह जो ट्रैफिक को एक ही दिशा में ले जाते हैं। दो गंतव्यों के बीच एक पूर्ण राउंड-ट्रिप के लिए चार tunnels आवश्यक होते हैं (दो आउटबाउंड, दो इनबाउंड)।\nशब्दावली के लिए Tunnel अवलोकन से शुरू करें, फिर संचालन संबंधी विवरण के लिए इस मार्गदर्शिका का उपयोग करें।\nसंदेश जीवनचक्र tunnel गेटवे एक या अधिक I2NP संदेशों को समूहित करता है, उन्हें खंडित करता है, और वितरण निर्देश लिखता है। गेटवे पेलोड को निश्चित आकार (1024 B) के tunnel संदेश में संकुलित करता है, आवश्यकता होने पर पैडिंग जोड़ता है। प्रत्येक प्रतिभागी पिछले हॉप का सत्यापन करता है, अपना एन्क्रिप्शन लेयर लागू करता है, और {nextTunnelId, nextIV, encryptedPayload} को अगले हॉप को अग्रेषित करता है। tunnel एंडपॉइंट अंतिम लेयर हटाता है, वितरण निर्देशों को प्रक्रिया करता है, खंडों को पुनः संयोजित करता है, और पुनर्निर्मित I2NP संदेशों को प्रेषित करता है। डुप्लिकेट पहचान IV (Initialization Vector, आरंभन सदिश) और पहले कूट-खंड के XOR (exclusive OR) के आधार पर कुंजीकृत एक क्षयशील Bloom filter (प्रायिक सदस्यता फिल्टर) का उपयोग करती है, ताकि IV की अदला-बदली पर आधारित टैगिंग हमलों को रोका जा सके।\nभूमिकाएँ एक नज़र में Role Pre-processing Crypto Operation Post-processing Outbound gateway (creator) Fragment, batch, pad Iteratively decrypt using every hop’s keys (so downstream peers encrypt) Forward to first hop Participant — Encrypt IV and payload with hop keys Forward to next hop Outbound endpoint — Encrypt once more to reveal plaintext payload Deliver to target tunnel/destination Inbound gateway Fragment, batch, pad Encrypt with local keys Forward to next hop Inbound endpoint (creator) — Iteratively decrypt using stored hop keys Reassemble and deliver locally ### एन्क्रिप्शन कार्यप्रवाह {#encryption-workflow} इनबाउंड tunnels: गेटवे अपनी लेयर कुंजी से एक बार एन्क्रिप्ट करता है; डाउनस्ट्रीम प्रतिभागी एन्क्रिप्ट करते रहते हैं जब तक कि निर्माता अंतिम पेलोड को डिक्रिप्ट नहीं कर देता। आउटबाउंड tunnels: गेटवे प्रत्येक hop (मध्यवर्ती नोड) के एन्क्रिप्शन का इनवर्स पहले से लागू कर देता है, ताकि प्रत्येक प्रतिभागी एन्क्रिप्ट करे। जब एंडपॉइंट एन्क्रिप्ट करता है, तो गेटवे का मूल प्लेनटेक्स्ट प्रकट हो जाता है। दोनों दिशाएँ {tunnelId, IV, encryptedPayload} को next hop (नेटवर्क में अगला नोड) तक अग्रेषित करती हैं।\nTunnel संदेश प्रारूप Tunnel गेटवे I2NP संदेशों को निश्चित आकार के लिफ़ाफ़ों में खंडित करते हैं ताकि पेलोड की लंबाई छिपाई जा सके और प्रति-हॉप प्रसंस्करण सरल बनाया जा सके।\nएन्क्रिप्टेड लेआउट +----------------+----------------+-------------------+ | Tunnel ID (4B) | IV (16B) | Encrypted payload | +----------------+----------------+-------------------+ Tunnel ID – अगले हॉप के लिए 32-बिट पहचानकर्ता (शून्य से भिन्न, प्रत्येक बिल्ड चक्र में बदलता है). IV – प्रत्येक संदेश के लिए चुना गया 16-बाइट AES IV. Encrypted payload – AES-256-CBC ciphertext (कूटपाठ) के 1008 बाइट्स. कुल आकार: 1028 बाइट्स.\nडिक्रिप्टेड लेआउट जब कोई हॉप अपनी एन्क्रिप्शन परत हटा देता है:\n[Checksum (4B)][Padding ... 0x00 terminator] [Delivery Instructions 1][I2NP fragment 1] [Delivery Instructions 2][I2NP fragment 2] ... चेकसम डिक्रिप्ट किए गए ब्लॉक को सत्यापित करता है। पैडिंग यादृच्छिक गैर-शून्य बाइट्स होती हैं, जो एक शून्य बाइट पर समाप्त होती हैं। डिलीवरी निर्देश एंडपॉइंट को बताते हैं कि प्रत्येक फ्रैगमेंट को कैसे संभालना है (स्थानीय रूप से डिलीवर करना, किसी अन्य tunnel को अग्रेषित करना, आदि)। फ्रैगमेंट अंतर्निहित I2NP संदेश वहन करते हैं; एंडपॉइंट उन्हें उच्चतर परतों को भेजने से पहले पुनः संयोजित करता है। प्रसंस्करण चरण गेटवे I2NP संदेशों को खंडित कर कतार में डालते हैं, और पुनर्संयोजन के लिए आंशिक खंडों को थोड़े समय तक सुरक्षित रखते हैं। गेटवे उपयुक्त लेयर कुंजियों से पेलोड को एन्क्रिप्ट करता है और tunnel ID तथा IV (Initialization Vector - आरंभिक वैक्टर) सेट करता है। प्रत्येक प्रतिभागी IV (AES-256/ECB) और फिर पेलोड (AES-256/CBC) को एन्क्रिप्ट करता है, उसके बाद IV को पुनः एन्क्रिप्ट करके संदेश अग्रेषित करता है। एंडपॉइंट उल्टे क्रम में डिक्रिप्ट करता है, चेकसम सत्यापित करता है, डिलिवरी निर्देशों को निष्पादित करता है, और खंडों का पुनर्संयोजन करता है। Tunnel निर्माण (ECIES-X25519) आधुनिक routers ECIES-X25519 कुंजियों के साथ tunnels बनाते हैं, जिससे बिल्ड संदेश छोटे हो जाते हैं और forward secrecy (लंबी-अवधि कुंजी लीक होने पर भी पुराने संदेश सुरक्षित रहना) सक्षम होती है।\nBuild message: एक एकल TunnelBuild (या VariableTunnelBuild) I2NP संदेश 1–8 एन्क्रिप्टेड बिल्ड रिकॉर्ड वहन करता है, प्रत्येक हॉप पर एक। Layer keys: निर्माता प्रति-हॉप लेयर, IV (Initialization Vector—प्रारंभिक वेक्टर), और उत्तर कुंजियाँ HKDF (HMAC-based Key Derivation Function—HMAC-आधारित कुंजी व्युत्पत्ति फ़ंक्शन) के माध्यम से, हॉप की स्थिर X25519 (Curve25519 आधारित Diffie–Hellman) पहचान और निर्माता की अल्पकालिक कुंजी का उपयोग करके व्युत्पन्न करते हैं। Processing: प्रत्येक हॉप अपना रिकॉर्ड डिक्रिप्ट करता है, रिक्वेस्ट फ्लैग्स को मान्य करता है, रिप्लाई ब्लॉक (सफलता या विस्तृत विफलता कोड) लिखता है, शेष रिकॉर्ड्स को पुनः एन्क्रिप्ट करता है, और संदेश को अग्रेषित करता है। Replies: निर्माता को garlic encryption से लिपटा हुआ रिप्लाई संदेश प्राप्त होता है। असफल के रूप में चिह्नित रिकॉर्ड में एक गंभीरता कोड शामिल होता है ताकि router पीयर की प्रोफाइलिंग कर सके। Compatibility: routers अभी भी पिछड़ी संगतता के लिए legacy ElGamal (पारंपरिक सार्वजनिक-कुंजी एन्क्रिप्शन योजना) बिल्ड्स स्वीकार कर सकते हैं, लेकिन नई tunnels डिफ़ॉल्ट रूप से ECIES (Elliptic Curve Integrated Encryption Scheme—एलिप्टिक कर्व आधारित एकीकृत एन्क्रिप्शन योजना) का उपयोग करती हैं। फ़ील्ड-दर-फ़ील्ड स्थिरांकों और कुंजी-व्युत्पत्ति टिप्पणियों के लिए, ECIES (Elliptic Curve Integrated Encryption Scheme—दीर्घवृत्तीय वक्र एकीकृत एन्क्रिप्शन योजना) प्रस्ताव इतिहास और router स्रोत देखें; यह गाइड परिचालन प्रवाह को कवर करता है।\nपुराने Tunnel का निर्माण (ElGamal-2048) मूल tunnel निर्माण प्रारूप में ElGamal सार्वजनिक कुंजियों का उपयोग किया जाता था। आधुनिक routers पिछली संगतता के लिए सीमित समर्थन बनाए रखते हैं।\nस्थिति: अप्रचलित। इसे ऐतिहासिक संदर्भ के लिए और उन सभी के लिए, जो legacy-compatible tooling (पुराने संस्करणों के साथ संगत टूलिंग) का रखरखाव कर रहे हैं, यहाँ रखा गया है।\nNon-interactive telescoping: (बिना अंतःक्रिया वाला क्रमिक-विस्तार) एक ही build संदेश पूरे पथ से होकर गुजरता है। प्रत्येक हॉप अपने 528-बाइट रिकॉर्ड को डिक्रिप्ट करता है, संदेश को अद्यतन करता है, और उसे आगे अग्रेषित करता है। परिवर्ती लंबाई: Variable Tunnel Build Message (VTBM, चर लंबाई वाला Tunnel निर्माण संदेश) ने 1–8 रिकॉर्ड की अनुमति दी। पहले वाला स्थिर संदेश हमेशा आठ रिकॉर्ड शामिल करता था ताकि tunnel की लंबाई छिपी रहे। अनुरोध रिकॉर्ड विन्यास: Bytes 0–3 : Tunnel ID (receiving ID) Bytes 4–35 : Current hop router hash Bytes 36–39 : Next tunnel ID Bytes 40–71 : Next hop router hash Bytes 72–103 : AES-256 layer key Bytes 104–135: AES-256 IV key Bytes 136–167: AES-256 reply key Bytes 168–183: AES-256 reply IV Byte 184 : Flags (bit7=IBGW, bit6=OBEP) Bytes 185–188: Request time (hours since epoch) Bytes 189–192: Next message ID Bytes 193–221: Padding फ्लैग्स: बिट 7 एक इनबाउंड गेटवे (IBGW) को दर्शाता है; बिट 6 एक आउटबाउंड एंडपॉइंट (OBEP) को चिह्नित करता है। ये परस्पर अनन्य होते हैं. एन्क्रिप्शन: प्रत्येक रिकॉर्ड को hop (रिले चरण) की सार्वजनिक कुंजी का उपयोग करते हुए ElGamal-2048 से एन्क्रिप्ट किया जाता है। सममित AES-256-CBC लेयरिंग यह सुनिश्चित करती है कि केवल इच्छित hop ही अपना रिकॉर्ड पढ़ सके. मुख्य तथ्य: tunnel IDs गैर-शून्य 32-बिट मान होते हैं; निर्माता वास्तविक tunnel की लंबाई छिपाने के लिए डमी रिकॉर्ड सम्मिलित कर सकते हैं; विश्वसनीयता असफल बिल्ड्स को पुनः प्रयास करने पर निर्भर करती है. Tunnel पूल और जीवनचक्र Routers अन्वेषण ट्रैफ़िक के लिए और प्रत्येक I2CP सत्र के लिए स्वतंत्र इनबाउंड और आउटबाउंड tunnel पूल बनाए रखते हैं।\nPeer selection: अन्वेषणात्मक tunnels विविधता बढ़ाने के लिए “active, not failing” पीयर बकेट से चुनती हैं; क्लाइंट tunnels तेज, उच्च-क्षमता वाले पीयर्स को प्राथमिकता देती हैं। Deterministic ordering: पीयर्स को SHA256(peerHash || poolKey) और पूल की यादृच्छिक कुंजी के बीच XOR दूरी के आधार पर क्रमबद्ध किया जाता है। रीस्टार्ट पर कुंजी रोटेट होती है, जिससे एक रन के भीतर स्थिरता मिलती है, जबकि रनों के पार predecessor attacks (पूर्ववर्ती हमले) को कठिन बनाती है। Lifecycle: routers {mode, direction, length, variance} ट्यूपल प्रति ऐतिहासिक बिल्ड समय को ट्रैक करते हैं। tunnels की अवधि समाप्ति के पास पहुँचने पर, प्रतिस्थापन जल्दी शुरू हो जाते हैं; विफलताएँ होने पर router समानांतर बिल्ड्स बढ़ाता है, और लंबित प्रयासों पर सीमा लगाता है। Configuration knobs: सक्रिय/बैकअप tunnels की संख्या, हॉप लंबाई और वैरिएंस, ज़ीरो-हॉप अनुमतियाँ, और बिल्ड दर सीमाएँ — ये सभी प्रति पूल ट्यून किए जा सकते हैं। भीड़भाड़ और विश्वसनीयता यद्यपि tunnels सर्किट जैसे लगते हैं, routers उन्हें संदेश कतारों की तरह मानते हैं। विलंबता को सीमित रखने के लिए Weighted Random Early Discard (WRED) (भार-आधारित यादृच्छिक प्रारंभिक त्याग नीति) का उपयोग किया जाता है:\nजैसे-जैसे उपयोग कॉन्फ़िगर की गई सीमाओं के करीब आता है, ड्रॉप होने की संभावना बढ़ती है। प्रतिभागी निश्चित आकार के फ्रैगमेंट को आधार मानते हैं; गेटवे/एंडपॉइंट्स संयुक्त फ्रैगमेंट आकार के आधार पर ड्रॉप करते हैं, सबसे पहले बड़े पेलोड को दंडित करते हुए। आउटबाउंड एंडपॉइंट्स अन्य भूमिकाओं से पहले ड्रॉप करते हैं ताकि नेटवर्क संसाधनों का न्यूनतम अपव्यय हो। गारंटीकृत वितरण को स्ट्रीमिंग लाइब्रेरी जैसी उच्चतर परतों पर छोड़ दिया जाता है। जिन अनुप्रयोगों को विश्वसनीयता चाहिए, उन्हें पुनःप्रेषण और स्वीकृतियों को स्वयं संभालना होगा।\nअधिक पठन पीयर चयन Tunnel का अवलोकन पुराना Tunnel कार्यान्वयन ","description":"I2P tunnels के निर्माण, तथा उनके माध्यम से ट्रैफ़िक के एन्क्रिप्शन और परिवहन के लिए एक एकीकृत विनिर्देश।","id":"6fb0b76b8bc10fa3e571b748f502baaa","section":"docs","title":"Tunnel संचालन मार्गदर्शिका","url":"/hi/docs/specs/implementation/"},{"categories":null,"content":"अवलोकन यह विनिर्देश I2P में UDP BitTorrent announce (ट्रैकर को सूचित करने वाला अनुरोध) के लिए प्रोटोकॉल का दस्तावेजीकरण करता है। I2P में BitTorrent के समग्र विनिर्देश के लिए, I2P पर BitTorrent का प्रलेखन देखें। इस विनिर्देश के विकास की पृष्ठभूमि और अतिरिक्त जानकारी के लिए, प्रस्ताव 160 देखें।\nइस प्रोटोकॉल को 24 जून, 2025 को औपचारिक रूप से अनुमोदित किया गया और I2P संस्करण 2.10.0 (API 0.9.67) में कार्यान्वित किया गया, जो 8 सितंबर, 2025 को जारी किया गया। UDP ट्रैकर समर्थन वर्तमान में I2P नेटवर्क पर सक्रिय है, कई उत्पादन-स्तरीय ट्रैकर्स और i2psnark क्लाइंट के लिए पूर्ण समर्थन के साथ।\nडिज़ाइन यह विनिर्देश I2P Datagram Specification में परिभाषित उत्तर-सक्षम datagram2, उत्तर-सक्षम datagram3, और रॉ डेटाग्राम का उपयोग करता है। Datagram2 और Datagram3, Proposal 163 में परिभाषित उत्तर-सक्षम डेटाग्राम के रूपांतर हैं। Datagram2 रीप्ले-प्रतिरोध और ऑफलाइन हस्ताक्षर समर्थन जोड़ता है। Datagram3 पुराने डेटाग्राम प्रारूप से छोटा है, लेकिन इसमें प्रमाणीकरण नहीं है।\nBEP 15 संदर्भ के लिए, BEP 15 में परिभाषित संदेश प्रवाह इस प्रकार है:\nClient Tracker Connect Req. -------------\u0026gt; \u0026lt;-------------- Connect Resp. Announce Req. -------------\u0026gt; \u0026lt;-------------- Announce Resp. Announce Req. -------------\u0026gt; \u0026lt;-------------- Announce Resp. IP address spoofing को रोकने के लिए connect चरण आवश्यक है। ट्रैकर एक connection ID लौटाता है, जिसे क्लाइंट आगामी announce अनुरोधों में उपयोग करता है। यह connection ID डिफ़ॉल्ट रूप से क्लाइंट पर एक मिनट में और ट्रैकर पर दो मिनट में समाप्त हो जाता है।\nI2P BEP 15 के समान संदेश प्रवाह का उपयोग करता है, मौजूदा UDP-सक्षम क्लाइंट कोडबेस में अपनाने में आसानी के लिए, दक्षता के लिए, और नीचे चर्चा किए गए सुरक्षा कारणों के लिए:\nClient Tracker Connect Req. -------------\u0026gt; (Repliable Datagram2) \u0026lt;-------------- Connect Resp. (Raw) Announce Req. -------------\u0026gt; (Repliable Datagram3) \u0026lt;-------------- Announce Resp. (Raw) Announce Req. -------------\u0026gt; (Repliable Datagram3) \u0026lt;-------------- Announce Resp. (Raw) ... यह संभावित रूप से streaming (TCP) announces की तुलना में बड़ी बैंडविड्थ बचत प्रदान करता है। जहां Datagram2 का आकार एक streaming SYN (TCP हैंडशेक की शुरुआत करने वाला पैकेट) के लगभग बराबर होता है, वहीं raw response (बिना अतिरिक्त ओवरहेड/प्रसंस्करण का कच्चा उत्तर) streaming SYN ACK (SYN के प्रत्युत्तर वाला ACK) की तुलना में काफी छोटा होता है। बाद के अनुरोध Datagram3 का उपयोग करते हैं, और बाद के उत्तर raw होते हैं।\nannounce (घोषणा) अनुरोध Datagram3 (डैटाग्राम प्रकार 3) में होते हैं, ताकि ट्रैकर को कनेक्शन आईडी को announce गंतव्य या हैश से जोड़ने वाली बड़ी मैपिंग तालिका बनाए रखने की आवश्यकता न पड़े। इसके बजाय, ट्रैकर सेंडर हैश, वर्तमान टाइमस्टैम्प (किसी अंतराल पर आधारित) और एक गोपनीय मान से कनेक्शन आईडी को क्रिप्टोग्राफ़िक रूप से उत्पन्न कर सकता है। जब कोई announce अनुरोध प्राप्त होता है, तो ट्रैकर कनेक्शन आईडी को सत्यापित करता है, और फिर भेजने के लक्ष्य के रूप में Datagram3 सेंडर हैश का उपयोग करता है।\nकनेक्शन का जीवनकाल BEP 15 यह निर्दिष्ट करता है कि connection ID (कनेक्शन की पहचान) client पर एक मिनट में और tracker (टॉरेंट ट्रैकर सर्वर) पर दो मिनट में समाप्त हो जाती है। यह कॉन्फ़िगर करने योग्य नहीं है। इससे संभावित दक्षता लाभ सीमित हो जाते हैं, जब तक कि क्लाइंट्स सभी announces (ट्रैकर को स्थिति बताने वाले अनुरोध) को एक मिनट की विंडो के भीतर बैच करके न भेजें। वर्तमान में i2psnark announces को बैच नहीं करता; ट्रैफिक में अचानक उछाल से बचने के लिए वह उन्हें फैला देता है। रिपोर्ट है कि power users एक साथ हज़ारों टॉरेंट्स चलाते हैं, और इतनी सारी announces को एक ही मिनट में समेट देना यथार्थवादी नहीं है।\nयहाँ, हम connect प्रतिक्रिया का विस्तार कर एक वैकल्पिक कनेक्शन अवधि फ़ील्ड जोड़ने का प्रस्ताव रखते हैं। यदि यह मौजूद न हो, तो डिफ़ॉल्ट एक मिनट है। अन्यथा, सेकंड में निर्दिष्ट अवधि का उपयोग क्लाइंट करेगा, और ट्रैकर कनेक्शन ID को एक मिनट और बनाए रखेगा।\nBEP 15 के साथ संगतता यह डिज़ाइन मौजूदा क्लाइंटों और ट्रैकर्स में आवश्यक परिवर्तनों को सीमित करने के लिए, संभव हद तक BEP 15 के साथ अनुकूलता बनाए रखता है।\nएकमात्र आवश्यक परिवर्तन announce प्रतिक्रिया में पीयर जानकारी के प्रारूप का है। connect प्रतिक्रिया में lifetime फ़ील्ड जोड़ना आवश्यक नहीं है, लेकिन दक्षता के लिए इसे दृढ़ता से अनुशंसित किया जाता है, जैसा कि ऊपर समझाया गया है।\nसुरक्षा विश्लेषण UDP announce प्रोटोकॉल का एक महत्वपूर्ण लक्ष्य पते की जालसाजी को रोकना है। क्लाइंट का वास्तव में अस्तित्व होना चाहिए और उसे एक वास्तविक leaseSet शामिल करना चाहिए। उसे Connect Response प्राप्त करने के लिए इनबाउंड tunnels होने चाहिए। ये tunnels zero-hop (शून्य-हॉप) हो सकती हैं और तुरंत बनाई जा सकती हैं, लेकिन यह निर्माता को उजागर कर देगा। यह प्रोटोकॉल उस लक्ष्य को पूरा करता है।\nसमस्याएँ यह प्रोटोकॉल blinded destinations (पहचान छिपाने हेतु \u0026lsquo;ब्लाइंड\u0026rsquo; किए गए गंतव्य पते) का समर्थन नहीं करता, लेकिन ऐसा करने के लिए इसे विस्तारित किया जा सकता है। नीचे देखें।\nविनिर्देश प्रोटोकॉल और पोर्ट उत्तर‑सक्षम Datagram2 I2CP प्रोटोकॉल 19 का उपयोग करता है; उत्तर‑सक्षम Datagram3 I2CP प्रोटोकॉल 20 का उपयोग करता है; raw (कच्चा) डेटाग्राम I2CP प्रोटोकॉल 18 का उपयोग करते हैं। अनुरोध Datagram2 या Datagram3 हो सकते हैं। प्रतिक्रियाएँ हमेशा raw होती हैं। I2CP प्रोटोकॉल 17 का उपयोग करने वाला पुराना उत्तर‑सक्षम डेटाग्राम (\u0026ldquo;Datagram1\u0026rdquo;) फ़ॉर्मैट का उपयोग अनुरोधों या उत्तरों के लिए कदापि नहीं किया जाना चाहिए; यदि ये रिक्वेस्ट/रिप्लाई पोर्ट्स पर प्राप्त हों, तो इन्हें ड्रॉप करना अनिवार्य है। ध्यान दें कि Datagram1 प्रोटोकॉल 17 अभी भी DHT प्रोटोकॉल के लिए उपयोग किया जाता है।\nअनुरोध announce URL में दिए गए I2CP \u0026ldquo;to port\u0026rdquo; का उपयोग करते हैं; नीचे देखें। अनुरोध का \u0026ldquo;from port\u0026rdquo; क्लाइंट द्वारा चुना जाता है, लेकिन यह शून्य से भिन्न होना चाहिए, और DHT (डिस्ट्रिब्यूटेड हैश टेबल) द्वारा उपयोग किए जाने वाले पोर्टों से अलग होना चाहिए, ताकि प्रतिक्रियाओं को आसानी से वर्गीकृत किया जा सके। ट्रैकर्स को गलत पोर्ट पर प्राप्त अनुरोधों को अस्वीकार करना चाहिए।\nप्रतिक्रियाएँ अनुरोध में दिए गए I2CP \u0026ldquo;to port\u0026rdquo; का उपयोग करती हैं। प्रतिक्रिया का \u0026ldquo;from port\u0026rdquo; अनुरोध के \u0026ldquo;to port\u0026rdquo; के समान होता है।\nघोषणा URL BEP 15 में announce URL का फ़ॉर्मेट निर्दिष्ट नहीं है, लेकिन clearnet (सार्वजनिक इंटरनेट) की तरह, UDP announce URLs \u0026ldquo;udp://host:port/path\u0026rdquo; के रूप में होते हैं। पाथ को अनदेखा किया जाता है और वह खाली भी हो सकता है, लेकिन clearnet पर यह आमतौर पर \u0026ldquo;/announce\u0026rdquo; होता है। :port भाग हमेशा मौजूद होना चाहिए; हालांकि, यदि \u0026ldquo;:port\u0026rdquo; भाग छोड़ा गया हो, तो 6969 का डिफ़ॉल्ट I2CP पोर्ट उपयोग करें, क्योंकि clearnet पर यही सामान्य पोर्ट है। अंत में CGI पैरामीटर जैसे \u0026amp;a=b\u0026amp;c=d भी जोड़े जा सकते हैं; इन्हें संसाधित करके announce अनुरोध में प्रदान किया जा सकता है, देखें BEP 41 । यदि कोई पैरामीटर या पाथ न हों, तो अंतिम / भी छोड़ा जा सकता है, जैसा कि BEP 41 में निहित है।\nडेटाग्राम प्रारूप सभी मान नेटवर्क बाइट क्रम (big endian, जिसमें सबसे महत्वपूर्ण बाइट पहले होती है) में भेजे जाते हैं। यह न मानें कि पैकेट हमेशा किसी निश्चित आकार के होंगे। भविष्य के विस्तार पैकेटों का आकार बढ़ा सकते हैं।\nकनेक्शन अनुरोध क्लाइंट से ट्रैकर को। 16 बाइट। उत्तर देने योग्य Datagram2 (डेटाग्राम का संस्करण 2) होना आवश्यक है। BEP 15 में जैसा है, वही। कोई परिवर्तन नहीं।\nOffset Size Name Value 0 64-bit integer protocol_id 0x41727101980 // magic constant 8 32-bit integer action 0 // connect 12 32-bit integer transaction_id कनेक्ट प्रतिक्रिया ट्रैकर से क्लाइंट तक। 16 या 18 बाइट्स। रॉ (कच्चे रूप में) होना चाहिए। नीचे बताए गए अपवादों को छोड़कर BEP 15 में जैसा है वैसा ही।\nOffset Size Name Value 0 32-bit integer action 0 // connect 4 32-bit integer transaction_id 8 64-bit integer connection_id 16 16-bit integer lifetime optional // Change from BEP 15 प्रतिक्रिया को अनिवार्य रूप से उस I2CP \u0026ldquo;to port\u0026rdquo; पर भेजा जाना चाहिए जो अनुरोध के \u0026ldquo;from port\u0026rdquo; के रूप में प्राप्त हुआ था।\nlifetime फ़ील्ड वैकल्पिक है और सेकंड में connection_id के लिए क्लाइंट का जीवनकाल दर्शाता है। डिफ़ॉल्ट 60 है, और यदि निर्दिष्ट किया गया हो तो न्यूनतम 60 है। अधिकतम 65535 है, अर्थात लगभग 18 घंटे। ट्रैकर को क्लाइंट के जीवनकाल से 60 सेकंड अधिक समय तक connection_id बनाए रखना चाहिए।\nघोषणा अनुरोध क्लाइंट से ट्रैकर। न्यूनतम 98 बाइट। यह उत्तरयोग्य Datagram3 (I2P का Datagram संस्करण 3) होना आवश्यक है। नीचे उल्लिखित अपवादों को छोड़कर, यह BEP 15 के समान है।\nconnection_id वैसा ही है जैसा कि connect response में प्राप्त हुआ है।\nOffset Size Name Value 0 64-bit integer connection_id 8 32-bit integer action 1 // announce 12 32-bit integer transaction_id 16 20-byte string info_hash 36 20-byte string peer_id 56 64-bit integer downloaded 64 64-bit integer left 72 64-bit integer uploaded 80 32-bit integer event 0 // 0: none; 1: completed; 2: started; 3: stopped 84 32-bit integer IP address 0 // default, unused in I2P 88 32-bit integer key 92 32-bit integer num_want -1 // default 96 16-bit integer port // must be same as I2CP from port 98 varies options optional // As specified in BEP 41 BEP 15 से परिवर्तन:\nkey को अनदेखा किया जाता है IP पता प्रयुक्त नहीं होता है पोर्ट संभवतः अनदेखा किया जाता है, लेकिन I2CP from port के समान होना चाहिए विकल्प अनुभाग, यदि मौजूद हो, वैसा है जैसा BEP 41 में परिभाषित है प्रतिक्रिया अनिवार्य रूप से उसी I2CP \u0026ldquo;to port\u0026rdquo; पर भेजी जानी चाहिए, जिसे अनुरोध के \u0026ldquo;from port\u0026rdquo; के रूप में प्राप्त किया गया था। announce request से प्राप्त पोर्ट का उपयोग न करें।\nघोषणा प्रतिक्रिया ट्रैकर से क्लाइंट को। कम से कम 20 बाइट। raw (कच्चा) होना चाहिए। नीचे बताई गई बातों को छोड़कर यह BEP 15 जैसा ही है।\nOffset Size Name Value 0 32-bit integer action 1 // announce 4 32-bit integer transaction_id 8 32-bit integer interval 12 32-bit integer leechers 16 32-bit integer seeders 20 32 * n 32-byte hash binary hashes // Change from BEP 15 ... // Change from BEP 15 BEP 15 से हुए परिवर्तन:\n6-बाइट IPv4+पोर्ट या 18-बाइट IPv6+पोर्ट के बजाय, हम SHA-256 बाइनरी पीयर हैशेज के साथ 32-बाइट \u0026ldquo;कॉम्पैक्ट प्रतिक्रियाओं\u0026rdquo; के गुणज लौटाते हैं। TCP कॉम्पैक्ट प्रतिक्रियाओं की तरह, हम कोई पोर्ट शामिल नहीं करते। प्रतिक्रिया अनिवार्य रूप से उस I2CP \u0026ldquo;to port\u0026rdquo; पर भेजी जानी चाहिए, जो अनुरोध के \u0026ldquo;from port\u0026rdquo; के रूप में प्राप्त हुआ था। announce request (घोषणा अनुरोध) से प्राप्त पोर्ट का उपयोग न करें।\nI2P डेटाग्राम का अधिकतम आकार लगभग 64 KB तक बहुत बड़ा होता है; हालांकि, विश्वसनीय डिलीवरी के लिए 4 KB से बड़े डेटाग्राम से बचना चाहिए। बैंडविड्थ दक्षता के लिए, ट्रैकर्स को संभवतः अधिकतम समकक्षों की संख्या लगभग 50 तक सीमित करनी चाहिए, जो विभिन्न परतों पर ओवरहेड से पहले लगभग 1600 बाइट के पैकेट के अनुरूप है, और फ्रैगमेंटेशन के बाद यह दो tunnel संदेश पेलोड सीमा के भीतर होना चाहिए।\nBEP 15 की तरह, आगे कितने पीयर पते होंगे (BEP 15 के लिए IP/port, यहाँ hashes) इसका कोई अलग काउंट शामिल नहीं है। हालाँकि BEP 15 में यह परिकल्पित नहीं है, सभी शून्यों वाला end-of-peers marker (पीयर-समाप्ति संकेतक) परिभाषित किया जा सकता है, जो यह दर्शाए कि पीयर जानकारी पूर्ण है और आगे कुछ एक्सटेंशन डेटा आता है।\nभविष्य में ऐसे विस्तार की संभावना बनाए रखने के लिए, क्लाइंट्स को 32-बाइट का सभी-शून्य hash (हैश — क्रिप्टोग्राफिक सारांश) और उसके बाद आने वाले किसी भी डेटा को नज़रअंदाज़ करना चाहिए। ट्रैकर्स को सभी-शून्य hash से किए गए announce अनुरोधों को अस्वीकार करना चाहिए, हालाँकि वह hash पहले से ही Java routers द्वारा प्रतिबंधित है।\nस्क्रैप BEP 15 का scrape अनुरोध/प्रतिक्रिया इस विनिर्देश द्वारा आवश्यक नहीं है, लेकिन यदि चाहें तो इसे लागू किया जा सकता है; किसी परिवर्तन की आवश्यकता नहीं। क्लाइंट को पहले कनेक्शन ID प्राप्त करनी होगी। scrape अनुरोध हमेशा repliable Datagram3 होता है। scrape प्रतिक्रिया हमेशा raw होती है।\nत्रुटि प्रतिक्रिया ट्रैकर से क्लाइंट को। संदेश खाली होने पर न्यूनतम 8 बाइट। raw (कच्चा/अनप्रोसेस्ड) होना आवश्यक है। BEP 15 के समान। कोई परिवर्तन नहीं।\nOffset Size Name Value 0 32-bit integer action 3 // error 4 32-bit integer transaction_id 8 string message विस्तार एक्सटेंशन बिट्स या वर्ज़न फ़ील्ड शामिल नहीं हैं। क्लाइंट और ट्रैकर को यह नहीं मानना चाहिए कि पैकेट किसी निश्चित आकार के हैं। इस तरह, संगतता बिगाड़े बिना अतिरिक्त फ़ील्ड जोड़े जा सकते हैं। आवश्यक होने पर BEP 41 में परिभाषित एक्सटेंशन फ़ॉर्मेट की अनुशंसा की जाती है।\nकनेक्ट प्रतिक्रिया में वैकल्पिक कनेक्शन ID जीवनकाल जोड़ने के लिए संशोधन किया गया है।\nयदि blinded destination (क्रिप्टोग्राफ़िक रूप से छिपाया गया destination) समर्थन आवश्यक हो, तो हम या तो blinded 35-बाइट address को announce request (घोषणा अनुरोध) के अंत में जोड़ सकते हैं, या प्रतिक्रियाओं में blinded hashes का अनुरोध कर सकते हैं, BEP 41 प्रारूप का उपयोग करते हुए (parameters TBD)। blinded 35-बाइट peer addresses का सेट, सभी-शून्य 32-बाइट हैश के बाद, announce reply (घोषणा उत्तर) के अंत में जोड़ा जा सकता है।\nकार्यान्वयन दिशानिर्देश गैर-एकीकृत, I2CP का उपयोग न करने वाले क्लाइंट्स और ट्रैकर्स के सामने आने वाली चुनौतियों पर चर्चा के लिए ऊपर दिए गए डिज़ाइन अनुभाग को देखें।\nक्लाइंट्स किसी दिए गए tracker hostname के लिए, क्लाइंट को HTTP URLs की अपेक्षा UDP को प्राथमिकता देनी चाहिए, और दोनों पर announce (टॉरेंट क्लाइंट द्वारा ट्रैकर को स्थिति/पीयर जानकारी बताने वाला अनुरोध) नहीं करना चाहिए।\nमौजूदा BEP 15 (बिटटोरेंट सुधार प्रस्ताव 15) समर्थन वाले क्लाइंट्स को केवल छोटे संशोधनों की आवश्यकता होनी चाहिए।\nयदि कोई क्लाइंट DHT (वितरित हैश तालिका) या अन्य डेटाग्राम प्रोटोकॉल का समर्थन करता है, तो उसे अनुरोध के \u0026ldquo;from port\u0026rdquo; के रूप में कोई अलग पोर्ट चुनना चाहिए ताकि उत्तर उसी पोर्ट पर वापस आएँ और DHT संदेशों के साथ न मिलें। क्लाइंट को उत्तर के रूप में केवल रॉ डेटाग्राम प्राप्त होते हैं। ट्रैकर्स क्लाइंट को कभी भी repliable datagram2 (उत्तर-सक्षम डेटाग्राम का v2) नहीं भेजेंगे।\nजिन क्लाइंट्स के पास opentrackers की डिफ़ॉल्ट सूची है, उन्हें, जब यह पुष्टि हो जाए कि ज्ञात opentrackers UDP को सपोर्ट करते हैं, तब UDP URLs जोड़ने के लिए सूची को अपडेट करना चाहिए।\nक्लाइंट अनुरोधों का पुनर्प्रेषण लागू कर भी सकते हैं या नहीं भी कर सकते हैं। यदि पुनर्प्रेषण लागू किया गया हो, तो कम से कम 15 सेकंड का प्रारंभिक timeout (समय-सीमा) उपयोग करना चाहिए, और प्रत्येक पुनर्प्रेषण के लिए timeout को दोगुना करना चाहिए (exponential backoff - घातांकीय विलंब-वृद्धि)।\nत्रुटि प्रतिक्रिया प्राप्त होने के बाद क्लाइंट को बैक-ऑफ (दर घटाकर थोड़ी देर प्रतीक्षा करना) करना चाहिए।\nट्रैकर मौजूदा BEP 15 समर्थन वाले ट्रैकर्स को केवल छोटे संशोधनों की आवश्यकता होनी चाहिए। यह विनिर्देश 2014 के प्रस्ताव से इस मायने में भिन्न है कि ट्रैकर को एक ही पोर्ट पर उत्तर-सक्षम datagram2 (डेटाग्राम संस्करण 2) और datagram3 (डेटाग्राम संस्करण 3) की प्राप्ति का समर्थन करना होगा।\nट्रैकर की संसाधन आवश्यकताओं को न्यूनतम करने के लिए, यह प्रोटोकॉल इस तरह डिज़ाइन किया गया है कि बाद में सत्यापन हेतु ट्रैकर को क्लाइंट हैश से कनेक्शन IDs तक मैपिंग संग्रहीत करने की कोई आवश्यकता न रहे। यह संभव है क्योंकि announce अनुरोध पैकेट एक उत्तर देने योग्य Datagram3 पैकेट (Datagram3 प्रकार) है, इसलिए इसमें प्रेषक का हैश शामिल होता है।\nएक अनुशंसित कार्यान्वयन यह है:\nवर्तमान epoch (समय-युग) को कनेक्शन के जीवनकाल के रिज़ॉल्यूशन में वर्तमान समय के रूप में परिभाषित करें, epoch = now / lifetime. एक क्रिप्टोग्राफ़िक हैश फ़ंक्शन H(secret, clienthash, epoch) परिभाषित करें जो 8 बाइट का आउटपुट उत्पन्न करता है. सभी कनेक्शनों के लिए प्रयुक्त यादृच्छिक स्थिर secret उत्पन्न करें. कनेक्ट प्रतिक्रियाओं के लिए, connection_id = H(secret, clienthash, epoch) उत्पन्न करें अनाउंस अनुरोधों के लिए, वर्तमान epoch में प्राप्त कनेक्शन ID को यह सत्यापित करके वैध करें कि connection_id == H(secret, clienthash, epoch) || connection_id == H(secret, clienthash, epoch - 1) परिनियोजन स्थिति इस प्रोटोकॉल को 24 जून 2025 को अनुमोदित किया गया था और यह सितंबर 2025 से I2P नेटवर्क पर पूरी तरह से परिचालन में है।\nवर्तमान कार्यान्वयन i2psnark: पूर्ण UDP ट्रैकर समर्थन I2P संस्करण 2.10.0 (API 0.9.67) में जोड़ा गया है, जो 8 सितंबर, 2025 को जारी किया गया था। इस संस्करण से आगे की सभी I2P स्थापनाओं में डिफ़ॉल्ट रूप से UDP ट्रैकर क्षमता शामिल है।\nzzzot tracker: संस्करण 0.20.0-beta2 और उसके बाद के संस्करण UDP घोषणाओं का समर्थन करते हैं। अक्टूबर 2025 तक, निम्नलिखित उत्पादन-स्तरीय ट्रैकर्स सक्रिय हैं: - opentracker.dg2.i2p - opentracker.simp.i2p - opentracker.skank.i2p\nक्लाइंट संगतता संबंधी नोट्स SAM v3.3 की सीमाएँ: SAM (Simple Anonymous Messaging) का उपयोग करने वाले बाहरी BitTorrent क्लाइंट्स को Datagram2/3 (SAM के datagram प्रोटोकॉल के संस्करण 2/3) के लिए SAM v3.3 का समर्थन चाहिए। यह Java I2P में उपलब्ध है, लेकिन वर्तमान में i2pd (C++ I2P का कार्यान्वयन) द्वारा समर्थित नहीं है, जिससे qBittorrent जैसे libtorrent-आधारित क्लाइंट्स में अपनाने पर सीमाएँ आ सकती हैं।\nI2CP क्लाइंट: I2CP का सीधे उपयोग करने वाले क्लाइंट (जैसे BiglyBT) SAM की सीमाओं के बिना UDP ट्रैकर समर्थन लागू कर सकते हैं।\nसंदर्भ [BEP15]: BitTorrent UDP ट्रैकर प्रोटोकॉल [BEP41]: UDP ट्रैकर प्रोटोकॉल विस्तार [DATAGRAMS]: I2P डेटाग्राम्स विनिर्देश [Prop160]: UDP ट्रैकर्स प्रस्ताव [Prop163]: Datagram2 प्रस्ताव [SPEC]: I2P पर BitTorrent ","description":"I2P में UDP-आधारित BitTorrent ट्रैकर announce के लिए प्रोटोकॉल विनिर्देश","id":"2413d642663e185a8a31352c9a9e8f28","section":"docs","title":"UDP BitTorrent घोषणाएँ","url":"/hi/docs/specs/udp-bittorrent-announces/"},{"categories":null,"content":" स्थिति: यह v3dgsend उपयोगिता के लिए एक संक्षिप्त संदर्भ है। यह Datagram API और SAM v3 दस्तावेज़ों का पूरक है।\nअवलोकन v3dgsend SAM v3 इंटरफ़ेस का उपयोग करके I2P datagrams भेजने के लिए एक command-line सहायक उपकरण है। यह datagram वितरण का परीक्षण करने, सेवाओं के प्रोटोटाइप बनाने और पूर्ण client लिखे बिना end-to-end व्यवहार की पुष्टि करने के लिए उपयोगी है।\nसामान्य उपयोग में शामिल हैं:\nकिसी गंतव्य (Destination) तक डेटाग्राम पहुंच की स्मोक-टेस्टिंग फ़ायरवॉल और एड्रेस बुक कॉन्फ़िगरेशन की पुष्टि करना रॉ बनाम साइन्ड (जवाब देने योग्य) डेटाग्राम के साथ प्रयोग करना उपयोग बेसिक इनवोकेशन प्लेटफॉर्म और पैकेजिंग के अनुसार भिन्न होता है। सामान्य विकल्पों में शामिल हैं:\nDestination: base64 Destination या .i2p नाम Protocol: raw (PROTOCOL 18) या signed (PROTOCOL 17) Payload: inline स्ट्रिंग या फ़ाइल इनपुट सटीक flags के लिए अपने distribution की packaging या --help output देखें।\nयह भी देखें Datagram API SAM v3 Streaming Library (datagrams का विकल्प) ","description":"SAM v3 के माध्यम से I2P डेटाग्राम भेजने के लिए CLI उपयोगिता","id":"3fe6f64806c4c692f530bf7fa6eb9c45","section":"docs","title":"v3dgsend","url":"/hi/docs/api/v3dgsend/"},{"categories":null,"content":"I2P Router सहायता I2P किन सिस्टम पर चलेगा? I2P को Java प्रोग्रामिंग भाषा में लिखा गया है। इसका परीक्षण Windows, Linux, FreeBSD और OSX पर किया गया है। एक Android पोर्ट भी उपलब्ध है।\nमेमोरी उपयोग के संदर्भ में, I2P डिफ़ॉल्ट रूप से 128 MB RAM उपयोग करने के लिए कॉन्फ़िगर किया गया है। यह ब्राउज़िंग और IRC उपयोग के लिए पर्याप्त है। हालांकि, अन्य गतिविधियों के लिए अधिक मेमोरी आवंटन की आवश्यकता हो सकती है। उदाहरण के लिए, यदि कोई high-bandwidth router चलाना चाहता है, I2P torrents में भाग लेना चाहता है या high-traffic hidden services प्रदान करना चाहता है, तो अधिक मात्रा में मेमोरी की आवश्यकता होती है।\nCPU उपयोग के संदर्भ में, I2P को Raspberry Pi श्रृंखला के single-board computers जैसे मामूली सिस्टम पर चलाने के लिए परीक्षण किया गया है। चूंकि I2P क्रिप्टोग्राफिक तकनीकों का भारी उपयोग करता है, एक मजबूत CPU, I2P द्वारा उत्पन्न workload के साथ-साथ सिस्टम के अन्य कार्यों (जैसे Operating System, GUI, अन्य प्रक्रियाएं जैसे Web Browsing) को संभालने के लिए बेहतर रूप से उपयुक्त होगा।\nSun/Oracle Java या OpenJDK का उपयोग करने की सिफारिश की जाती है।\nक्या I2P का उपयोग करने के लिए Java इंस्टॉल करना आवश्यक है? हाँ, I2P Core का उपयोग करने के लिए Java आवश्यक है। हम Windows, Mac OSX, और Linux के लिए अपने easy-installers में Java शामिल करते हैं। यदि आप I2P Android app चला रहे हैं तो अधिकांश मामलों में आपको Dalvik या ART जैसे Java runtime की भी आवश्यकता होगी।\n\u0026ldquo;I2P Site\u0026rdquo; क्या है और मैं अपने ब्राउज़र को कैसे कॉन्फ़िगर करूं ताकि मैं उन्हें उपयोग कर सकूं? एक I2P Site एक सामान्य वेबसाइट है सिवाय इसके कि यह I2P के अंदर होस्ट की जाती है। I2P sites के पते सामान्य इंटरनेट पतों की तरह दिखते हैं, जो लोगों की सुविधा के लिए मानव-पठनीय, गैर-क्रिप्टोग्राफिक तरीके से \u0026ldquo;.i2p\u0026rdquo; में समाप्त होते हैं। वास्तव में एक I2P Site से कनेक्ट होने के लिए क्रिप्टोग्राफी की आवश्यकता होती है, जिसका अर्थ है कि I2P Site के पते लंबे \u0026ldquo;Base64\u0026rdquo; Destinations और छोटे \u0026ldquo;B32\u0026rdquo; पते भी होते हैं। सही तरीके से ब्राउज़ करने के लिए आपको अतिरिक्त कॉन्फ़िगरेशन करने की आवश्यकता हो सकती है। I2P Sites को ब्राउज़ करने के लिए आपकी I2P इंस्टॉलेशन में HTTP Proxy को सक्रिय करना और फिर इसका उपयोग करने के लिए अपने ब्राउज़र को कॉन्फ़िगर करना आवश्यक होगा। अधिक जानकारी के लिए, नीचे \u0026ldquo;Browsers\u0026rdquo; अनुभाग या \u0026ldquo;Browser Configuration\u0026rdquo; गाइड देखें।\nराउटर कंसोल में Active x/y संख्याओं का क्या अर्थ है? आपके router console के Peers पेज पर, आपको दो संख्याएं दिखाई दे सकती हैं - Active x/y। पहली संख्या उन peers की संख्या है जिन्हें आपने पिछले कुछ मिनटों में संदेश भेजा है या जिनसे संदेश प्राप्त किया है। दूसरी संख्या हाल ही में देखे गए peers की संख्या है, यह हमेशा पहली संख्या से बड़ी या बराबर होगी।\nमेरे router में बहुत कम सक्रिय peers हैं, क्या यह ठीक है? हां, यह सामान्य हो सकता है, खासकर जब router अभी-अभी शुरू किया गया हो। नए routers को शुरू होने और नेटवर्क के बाकी हिस्सों से जुड़ने में समय लगेगा। नेटवर्क एकीकरण, अपटाइम और प्रदर्शन में सुधार करने में मदद के लिए, इन सेटिंग्स की समीक्षा करें:\nबैंडविड्थ साझा करें - यदि कोई router बैंडविड्थ साझा करने के लिए कॉन्फ़िगर किया गया है, तो यह अन्य routers के लिए अधिक ट्रैफ़िक रूट करेगा जो इसे नेटवर्क के बाकी हिस्सों के साथ एकीकृत करने में मदद करता है, साथ ही किसी के स्थानीय कनेक्शन के प्रदर्शन में सुधार करता है। इसे http://localhost:7657/config पेज पर कॉन्फ़िगर किया जा सकता है। नेटवर्क इंटरफ़ेस - सुनिश्चित करें कि http://localhost:7657/confignet पेज पर कोई इंटरफ़ेस निर्दिष्ट नहीं है। यह प्रदर्शन को कम कर सकता है जब तक कि आपका कंप्यूटर कई बाहरी IP पतों के साथ मल्टी-होम्ड न हो। I2NP protocol - सुनिश्चित करें कि router होस्ट के ऑपरेटिंग सिस्टम और खाली नेटवर्क(एडवांस्ड) सेटिंग्स के लिए एक मान्य प्रोटोकॉल पर कनेक्शन की अपेक्षा करने के लिए कॉन्फ़िगर किया गया है। नेटवर्क कॉन्फ़िगरेशन पेज में \u0026lsquo;Hostname\u0026rsquo; फ़ील्ड में कोई IP पता दर्ज न करें। यहाँ आप जो I2NP Protocol चुनते हैं वह केवल तभी उपयोग किया जाएगा जब आपके पास पहले से पहुंचने योग्य पता न हो। उदाहरण के लिए, संयुक्त राज्य अमेरिका में अधिकांश Verizon 4G और 5G वायरलेस कनेक्शन, UDP को ब्लॉक करते हैं और उस पर पहुंचा नहीं जा सकता। अन्य UDP का उपयोग बलपूर्वक करेंगे भले ही यह उनके लिए उपलब्ध हो। सूचीबद्ध I2NP Protocols से एक उचित सेटिंग चुनें। मैं कुछ प्रकार की सामग्री का विरोधी हूँ। मैं उन्हें वितरित करने, संग्रहीत करने या एक्सेस करने से कैसे बचूँ? डिफ़ॉल्ट रूप से इनमें से कोई भी सामग्री इंस्टॉल नहीं की गई है। हालांकि, चूंकि I2P एक peer-to-peer नेटवर्क है, इसलिए संभव है कि आप गलती से प्रतिबंधित सामग्री का सामना कर सकें। यहां एक सारांश है कि I2P कैसे आपको आपकी मान्यताओं के उल्लंघन में अनावश्यक रूप से शामिल होने से रोकता है।\nवितरण - ट्रैफ़िक I2P नेटवर्क के भीतर आंतरिक है, आप एक exit node नहीं हैं (हमारे दस्तावेज़ीकरण में इसे outproxy कहा जाता है)। संग्रहण - I2P नेटवर्क सामग्री का वितरित संग्रहण नहीं करता है, इसे उपयोगकर्ता द्वारा विशेष रूप से इंस्टॉल और कॉन्फ़िगर करना होता है (उदाहरण के लिए, Tahoe-LAFS के साथ)। यह एक अलग अनाम नेटवर्क, Freenet की विशेषता है। I2P router चलाने से, आप किसी के लिए सामग्री संग्रहीत नहीं कर रहे हैं। पहुंच - आपका router आपके विशिष्ट निर्देश के बिना कोई सामग्री अनुरोध नहीं करेगा। क्या I2P को ब्लॉक करना संभव है? हां, अब तक सबसे आसान और सबसे आम तरीका bootstrap, या \u0026ldquo;Reseed\u0026rdquo; सर्वर को ब्लॉक करना है। सभी obfuscated ट्रैफ़िक को पूरी तरह से ब्लॉक करना भी काम करेगा (हालांकि यह कई अन्य चीजों को तोड़ देगा जो I2P नहीं हैं और अधिकांश लोग इतनी दूर तक जाने को तैयार नहीं हैं)। reseed ब्लॉकिंग के मामले में, Github पर एक reseed bundle है, इसे ब्लॉक करने से Github भी ब्लॉक हो जाएगा। आप प्रॉक्सी के माध्यम से reseed कर सकते हैं (यदि आप Tor का उपयोग नहीं करना चाहते हैं तो इंटरनेट पर कई मिल सकते हैं) या ऑफ़लाइन friend-to-friend आधार पर reseed bundles साझा कर सकते हैं।\nwrapper.log में मुझे एक त्रुटि दिखाई देती है जो Router Console लोड करते समय \u0026ldquo;Protocol family unavailable\u0026rdquo; बताती है अक्सर यह त्रुटि कुछ सिस्टम पर किसी भी नेटवर्क सक्षम java सॉफ़्टवेयर के साथ होती है जो डिफ़ॉल्ट रूप से IPv6 का उपयोग करने के लिए कॉन्फ़िगर किए गए हैं। इसे हल करने के कुछ तरीके हैं:\nLinux आधारित सिस्टम पर, आप echo 0 \u0026gt; /proc/sys/net/ipv6/bindv6only चला सकते हैं wrapper.config में निम्नलिखित पंक्तियों को खोजें: #wrapper.java.additional.5=-Djava.net.preferIPv4Stack=true #wrapper.java.additional.6=-Djava.net.preferIPv6Addresses=false यदि ये पंक्तियाँ मौजूद हैं, तो \u0026ldquo;#\u0026rdquo; हटाकर उन्हें अनकमेंट करें। यदि ये पंक्तियाँ मौजूद नहीं हैं, तो उन्हें \u0026ldquo;#\u0026rdquo; के बिना जोड़ें। एक अन्य विकल्प ~/.i2p/clients.config से ::1 को हटाना होगा\nचेतावनी: wrapper.config में किए गए किसी भी बदलाव को लागू करने के लिए, आपको router और wrapper को पूरी तरह से बंद करना होगा। अपने router console पर Restart क्लिक करने से यह फ़ाइल दोबारा नहीं पढ़ी जाएगी! आपको Shutdown क्लिक करना होगा, 11 मिनट प्रतीक्षा करनी होगी, फिर I2P को शुरू करना होगा।\nI2P के भीतर अधिकांश I2P Sites बंद हैं? यदि आप हर I2P Site को देखें जो कभी बनाई गई है, तो हां, उनमें से अधिकांश बंद हैं। लोग और I2P Sites आते-जाते रहते हैं। I2P में शुरुआत करने का एक अच्छा तरीका यह है कि उन I2P Sites की सूची देखें जो वर्तमान में चालू हैं। identiguy.i2p सक्रिय I2P Sites को ट्रैक करता है।\nI2P पोर्ट 32000 पर क्यों सुन रहा है? हम जो Tanuki java service wrapper उपयोग करते हैं वह इस पोर्ट को खोलता है — localhost से बाइंड — ताकि JVM के अंदर चल रहे सॉफ़्टवेयर के साथ संचार कर सके। जब JVM लॉन्च होता है तो उसे एक key दी जाती है ताकि वह wrapper से कनेक्ट हो सके। JVM द्वारा wrapper से अपना कनेक्शन स्थापित करने के बाद, wrapper किसी भी अतिरिक्त कनेक्शन को अस्वीकार कर देता है।\nअधिक जानकारी wrapper दस्तावेज़ीकरण में पाई जा सकती है।\nमैं अपने ब्राउज़र को कैसे कॉन्फ़िगर करूं? विभिन्न ब्राउज़रों के लिए proxy कॉन्फ़िगरेशन स्क्रीनशॉट के साथ एक अलग पेज पर है। बाहरी टूल्स के साथ अधिक उन्नत कॉन्फ़िगरेशन, जैसे कि ब्राउज़र प्लग-इन FoxyProxy या proxy सर्वर Privoxy, संभव हैं लेकिन आपके सेटअप में लीक पैदा कर सकते हैं।\nI2P के भीतर IRC से कैसे कनेक्ट करें? I2P के भीतर मुख्य IRC सर्वर, Irc2P, के लिए एक tunnel तब बनाया जाता है जब I2P इंस्टॉल किया जाता है (I2PTunnel कॉन्फ़िगरेशन पेज देखें), और I2P router के शुरू होने पर यह स्वचालित रूप से शुरू हो जाता है। इससे कनेक्ट करने के लिए, अपने IRC क्लाइंट को localhost 6668 से कनेक्ट करने के लिए कहें। HexChat-जैसे क्लाइंट उपयोगकर्ता सर्वर localhost/6668 के साथ एक नया नेटवर्क बना सकते हैं (यदि आपके पास प्रॉक्सी सर्वर कॉन्फ़िगर है तो \u0026ldquo;Bypass proxy server\u0026rdquo; को टिक करना याद रखें)। Weechat उपयोगकर्ता एक नया नेटवर्क जोड़ने के लिए निम्नलिखित कमांड का उपयोग कर सकते हैं:\n/server add irc2p localhost/6668 मैं अपनी खुद की I2P Site कैसे सेटअप करूं? सबसे आसान तरीका है router console में i2ptunnel लिंक पर क्लिक करना और एक नया \u0026lsquo;Server Tunnel\u0026rsquo; बनाना। आप tunnel destination को किसी मौजूदा webserver के port पर सेट करके dynamic content परोस सकते हैं, जैसे Tomcat या Jetty। आप static content भी परोस सकते हैं। इसके लिए, tunnel destination को इस पर सेट करें: 0.0.0.0 port 7659 और content को ~/.i2p/eepsite/docroot/ directory में रखें। (गैर-Linux सिस्टम पर, यह किसी अलग स्थान पर हो सकता है। router console जांचें।) \u0026rsquo;eepsite\u0026rsquo; सॉफ्टवेयर I2P इंस्टॉलेशन पैकेज के हिस्से के रूप में आता है और I2P शुरू होने पर स्वचालित रूप से शुरू होने के लिए सेट है। इसके द्वारा बनाई गई डिफ़ॉल्ट साइट को http://127.0.0.1:7658 पर एक्सेस किया जा सकता है। हालांकि, आपकी \u0026rsquo;eepsite\u0026rsquo; दूसरों के लिए भी आपकी eepsite key file के माध्यम से सुलभ है, जो यहाँ स्थित है: ~/.i2p/eepsite/i2p/eepsite.keys। अधिक जानने के लिए, readme file पढ़ें: ~/.i2p/eepsite/README.txt।\nयदि मैं घर पर I2P पर एक वेबसाइट होस्ट करूं, जिसमें केवल HTML और CSS हो, तो क्या यह खतरनाक है? यह आपके विरोधी और आपके खतरे के मॉडल पर निर्भर करता है। यदि आप केवल कॉर्पोरेट \u0026ldquo;गोपनीयता\u0026rdquo; उल्लंघनों, सामान्य अपराधियों और सेंसरशिप के बारे में चिंतित हैं, तो यह वास्तव में खतरनाक नहीं है। कानून प्रवर्तन संभवतः आपको वैसे भी ढूंढ लेगा यदि वे वास्तव में चाहते हैं। केवल तभी होस्टिंग करना जब आपके पास एक सामान्य (इंटरनेट) होम यूज़र ब्राउज़र चल रहा हो, यह जानना वास्तव में कठिन बना देगा कि उस हिस्से को कौन होस्ट कर रहा है। कृपया अपनी I2P साइट की होस्टिंग को किसी अन्य सेवा की होस्टिंग की तरह ही समझें - यह उतना ही खतरनाक - या सुरक्षित - है जितना आप इसे स्वयं कॉन्फ़िगर और प्रबंधित करते हैं।\nनोट: i2p सेवा (destination) को i2p router से अलग होस्ट करने का पहले से ही एक तरीका है। यदि आप समझते हैं कि यह कैसे काम करता है, तो आप वेबसाइट (या सेवा) के लिए एक अलग मशीन को सर्वर के रूप में सेटअप कर सकते हैं जो सार्वजनिक रूप से उपलब्ध होगी और उसे एक [बहुत] सुरक्षित SSH tunnel के माध्यम से webserver पर forward कर सकते हैं या एक सुरक्षित, साझा, filesystem का उपयोग कर सकते हैं।\nI2P \u0026ldquo;.i2p\u0026rdquo; वेबसाइटों को कैसे खोजता है? I2P Address Book एप्लिकेशन मानव-पठनीय नामों को दीर्घकालिक destinations से मैप करता है, जो सेवाओं से जुड़े होते हैं, जिससे यह नेटवर्क डेटाबेस या DNS सेवा की तुलना में hosts फ़ाइल या संपर्क सूची की तरह अधिक काम करता है। यह स्थानीय-प्रथम (local-first) भी है - कोई मान्यता प्राप्त वैश्विक namespace नहीं है, आप तय करते हैं कि कोई भी .i2p डोमेन अंततः किससे मैप होगा। बीच का रास्ता कुछ ऐसा है जिसे \u0026ldquo;Jump Service\u0026rdquo; कहा जाता है जो एक मानव-पठनीय नाम प्रदान करता है और आपको एक पृष्ठ पर पुनर्निर्देशित करता है जहाँ आपसे पूछा जाएगा \u0026ldquo;क्या आप I2P router को $SITE_CRYPTO_KEY को $SITE_NAME.i2p नाम देने की अनुमति देते हैं\u0026rdquo; या कुछ इस प्रकार की बात। एक बार जब यह आपकी address book में हो जाता है, तो आप साइट को दूसरों के साथ साझा करने में मदद के लिए अपने स्वयं के jump URL उत्पन्न कर सकते हैं।\nAddress Book में पते कैसे जोड़ें? आप किसी साइट का बेस32 या बेस64 जाने बिना पता नहीं जोड़ सकते जिसे आप देखना चाहते हैं। \u0026ldquo;होस्टनेम\u0026rdquo; जो मानव-पठनीय है, केवल क्रिप्टोग्राफिक पते के लिए एक उपनाम है, जो बेस32 या बेस64 से मेल खाता है। क्रिप्टोग्राफिक पते के बिना, I2P Site तक पहुंचने का कोई तरीका नहीं है, यह डिज़ाइन द्वारा है। उन लोगों को पता वितरित करना जो इसे अभी तक नहीं जानते हैं आमतौर पर Jump सेवा प्रदाता की जिम्मेदारी है। किसी अज्ञात I2P Site पर जाने से Jump सेवा का उपयोग ट्रिगर होगा। stats.i2p सबसे विश्वसनीय Jump सेवा है।\nयदि आप i2ptunnel के माध्यम से एक साइट होस्ट कर रहे हैं, तो अभी तक इसका jump service के साथ पंजीकरण नहीं होगा। इसे स्थानीय रूप से एक URL देने के लिए, कॉन्फ़िगरेशन पेज पर जाएं और \u0026ldquo;Add to Local Address Book\u0026rdquo; वाले बटन पर क्लिक करें। फिर addresshelper URL को देखने और साझा करने के लिए http://127.0.0.1:7657/dns पर जाएं।\nI2P कौन से पोर्ट उपयोग करता है? I2P द्वारा उपयोग किए जाने वाले ports को 2 भागों में विभाजित किया जा सकता है:\nइंटरनेट-फेसिंग पोर्ट, जो अन्य I2P routers के साथ संचार के लिए उपयोग किए जाते हैं लोकल पोर्ट, स्थानीय कनेक्शन के लिए इनका विस्तृत विवरण नीचे दिया गया है।\n1. इंटरनेट-फेसिंग पोर्ट नोट: रिलीज़ 0.7.8 के बाद से, नए इंस्टॉल पोर्ट 8887 का उपयोग नहीं करते हैं; जब प्रोग्राम पहली बार चलाया जाता है तो 9000 और 31000 के बीच एक रैंडम पोर्ट चुना जाता है। चुने गए पोर्ट को router configuration page पर दिखाया जाता है।\nआउटबाउंड\nकॉन्फ़िगरेशन पेज पर सूचीबद्ध रैंडम पोर्ट से मनमाने रिमोट UDP पोर्ट्स तक UDP, जवाबों की अनुमति देता है रैंडम हाई पोर्ट्स से मनमाने रिमोट TCP पोर्ट्स तक TCP पोर्ट 123 पर आउटबाउंड UDP, जवाबों की अनुमति देता है। यह I2P के आंतरिक समय सिंक के लिए आवश्यक है (SNTP के माध्यम से - pool.ntp.org में एक रैंडम SNTP होस्ट या आपके द्वारा निर्दिष्ट किसी अन्य सर्वर से क्वेरी करना) INBOUND\n(वैकल्पिक, अनुशंसित) configuration page पर उल्लिखित पोर्ट पर किसी भी स्थान से UDP (वैकल्पिक, अनुशंसित) configuration page पर उल्लिखित पोर्ट पर किसी भी स्थान से TCP Inbound TCP को configuration page पर अक्षम किया जा सकता है 2. स्थानीय I2P पोर्ट स्थानीय I2P पोर्ट डिफ़ॉल्ट रूप से केवल स्थानीय कनेक्शनों को सुनते हैं, सिवाय जहाँ उल्लेख किया गया हो:\nPORT PURPOSE DESCRIPTION 1900 UPnP SSDP UDP multicast listener Cannot be changed. Binds to all interfaces. May be disabled on confignet. 2827 BOB bridge A higher level socket API for clients. Disabled by default. May be enabled/disabled on configclients. May be changed in the bob.config file. 4444 HTTP proxy Configured on configclients, go to the page i2ptunnel to start/stop it and on the page I2P HTTP Proxy to configure it. Include in your browser's proxy configuration for HTTP 4445 HTTPS proxy Configured on configclients, go to the page i2ptunnel to start/stop it and on the page I2P HTTPS Proxy to configure it. Include in your browser's proxy configuration for HTTPS 6668 IRC proxy A tunnel to the inside-the-I2P IRC network. Disabled by default. Configured on the page irc.postman.i2p (IRC proxy) and may be enabled/disabled on the page i2ptunnel 7654 I2CP (client protocol) port For advanced client usage. Do not expose to an external network. 7656 SAM bridge A socket API for clients. Disabled by default. May be enabled/disabled on configclients and configured on sam. 7657 (or 7658 via SSL) Router console The router console provides valuable information about your router and the network, in addition to giving you access to configure your router and its associated applications. 7659 'eepsite' - an example webserver (Jetty) Included in the i2pinstall and i2pupdate packages - may be disabled if another webserver is available. May be configured on the page eepsite and disabled on the page i2ptunnel 7660 I2PTunnel UDP port for SSH Required for Grizzled's/novg's UDP support. Instances disabled by default. May be enabled/disabled and configured to use a different port on the page i2ptunnel. 123 NTP Port Used by NTP Time Sync. May be disabled/changed. ### मेरी एड्रेस बुक में बहुत सारे होस्ट मिसिंग हैं। कुछ अच्छे सब्सक्रिप्शन लिंक कौन से हैं? {#subscriptions} एड्रेस बुक http://localhost:7657/dns पर स्थित है जहाँ अधिक जानकारी मिल सकती है।\nकुछ अच्छे address book subscription लिंक कौन से हैं?\nआप निम्नलिखित प्रयास कर सकते हैं:\nhttp://stats.i2p/cgi-bin/newhosts.txt http://identiguy.i2p/hosts.txt मैं अपनी अन्य मशीनों से वेब कंसोल को कैसे एक्सेस कर सकता हूं या इसे पासवर्ड प्रोटेक्ट कैसे कर सकता हूं? सुरक्षा उद्देश्यों के लिए, router का admin console डिफ़ॉल्ट रूप से केवल स्थानीय इंटरफ़ेस पर कनेक्शन के लिए सुनता है।\nकंसोल को दूर से एक्सेस करने के दो तरीके हैं:\nSSH Tunnel अपने console को एक Public IP address पर उपलब्ध कराने के लिए username और password के साथ configure करना इन्हें नीचे विस्तार से बताया गया है:\nविधि 1: SSH Tunnel\nयदि आप यूनिक्स-जैसा ऑपरेटिंग सिस्टम चला रहे हैं, तो यह आपके I2P console को दूर से एक्सेस करने का सबसे आसान तरीका है। (नोट: SSH सर्वर सॉफ़्टवेयर Windows चलाने वाले सिस्टम के लिए भी उपलब्ध है, उदाहरण के लिए https://github.com/PowerShell/Win32-OpenSSH )\nएक बार जब आप अपने सिस्टम पर SSH एक्सेस कॉन्फ़िगर कर लेते हैं, तो \u0026lsquo;-L\u0026rsquo; फ्लैग को उचित आर्गुमेंट्स के साथ SSH को पास किया जाता है - उदाहरण के लिए:\nssh -L 7657:localhost:7657 (System_IP) जहाँ \u0026lsquo;(System_IP)\u0026rsquo; को आपके सिस्टम के IP address से बदला जाता है। यह command port 7657 (पहले colon से पहले वाली संख्या) को remote system के (जो पहले और दूसरे colon के बीच \u0026rsquo;localhost\u0026rsquo; string द्वारा निर्दिष्ट है) port 7657 (दूसरे colon के बाद वाली संख्या) पर forward करता है। आपका remote I2P console अब आपके local system पर \u0026lsquo;http://localhost:7657\u0026rsquo; के रूप में उपलब्ध होगा और जब तक आपका SSH session सक्रिय रहेगा तब तक उपलब्ध रहेगा।\nयदि आप रिमोट सिस्टम पर शेल शुरू किए बिना एक SSH सत्र शुरू करना चाहते हैं, तो आप \u0026lsquo;-N\u0026rsquo; फ्लैग जोड़ सकते हैं:\nssh -NL 7657:localhost:7657 (System_IP) विधि 2: अपने console को उपयोगकर्ता नाम और पासवर्ड के साथ सार्वजनिक IP पते पर उपलब्ध कराने के लिए कॉन्फ़िगर करना\n~/.i2p/clients.config खोलें और बदलें:\nclientApp.0.args=7657 ::1,127.0.0.1 ./webapps/ इसके साथ:\nclientApp.0.args=7657 ::1,127.0.0.1,(System_IP) ./webapps/ जहाँ आप (System_IP) को अपने सिस्टम के public IP address से बदलें\nhttp://localhost:7657/configui पर जाएं और यदि चाहें तो console के लिए username और password जोड़ें - अपने I2P console को छेड़छाड़ से सुरक्षित रखने के लिए username और password जोड़ना अत्यधिक अनुशंसित है, जिससे de-anonymization हो सकता है।\nhttp://localhost:7657/index पर जाएं और \u0026ldquo;Graceful restart\u0026rdquo; पर क्लिक करें, जो JVM को पुनः आरंभ करता है और client applications को फिर से लोड करता है\nउसके शुरू होने के बाद, अब आप अपने console को दूर से एक्सेस कर सकेंगे। router console को http://(System_IP):7657 पर लोड करें और यदि आपका ब्राउज़र authentication popup को सपोर्ट करता है तो आपसे ऊपर चरण 2 में निर्दिष्ट username और password मांगा जाएगा।\nनोट: आप उपरोक्त कॉन्फ़िगरेशन में 0.0.0.0 निर्दिष्ट कर सकते हैं। यह एक इंटरफ़ेस को निर्दिष्ट करता है, न कि नेटवर्क या netmask को। 0.0.0.0 का अर्थ है \u0026ldquo;सभी इंटरफ़ेस से bind करें\u0026rdquo;, इसलिए यह 127.0.0.1:7657 के साथ-साथ किसी भी LAN/WAN IP पर भी पहुँच योग्य हो सकता है। इस विकल्प का उपयोग करते समय सावधान रहें क्योंकि console आपके सिस्टम पर कॉन्फ़िगर किए गए सभी addresses पर उपलब्ध होगा।\nमैं अपनी अन्य मशीनों से एप्लिकेशन कैसे उपयोग कर सकता हूँ? SSH Port Forwarding का उपयोग करने के निर्देशों के लिए कृपया पिछला उत्तर देखें, और अपने console में यह पेज भी देखें: http://localhost:7657/configi2cp क्या I2P को SOCKS proxy के रूप में उपयोग करना संभव है? SOCKS proxy रिलीज़ 0.7.1 से कार्यशील है। SOCKS 4/4a/5 समर्थित हैं। I2P के पास SOCKS outproxy नहीं है इसलिए यह केवल I2P के भीतर उपयोग तक सीमित है।\nकई एप्लिकेशन संवेदनशील जानकारी लीक करते हैं जो इंटरनेट पर आपकी पहचान कर सकती है और यह एक जोखिम है जिसके बारे में I2P SOCKS proxy का उपयोग करते समय आपको जागरूक होना चाहिए। I2P केवल कनेक्शन डेटा को फ़िल्टर करता है, लेकिन यदि आप जिस प्रोग्राम को चलाना चाहते हैं वह इस जानकारी को सामग्री के रूप में भेजता है, तो I2P के पास आपकी गुमनामी की रक्षा करने का कोई तरीका नहीं है। उदाहरण के लिए, कुछ मेल एप्लिकेशन मेल सर्वर को उस मशीन का IP पता भेज देंगे जिस पर वे चल रहे हैं। हम I2P-विशिष्ट टूल या एप्लिकेशन (जैसे torrents के लिए I2PSnark ) की सिफारिश करते हैं, या ऐसे एप्लिकेशन जो I2P के साथ उपयोग करने के लिए सुरक्षित माने जाते हैं जिनमें Firefox पर पाए जाने वाले लोकप्रिय प्लगइन शामिल हैं।\nमैं नियमित इंटरनेट पर IRC, BitTorrent, या अन्य सेवाओं को कैसे एक्सेस करूं? Outproxies नामक सेवाएं हैं जो I2P और इंटरनेट के बीच पुल का काम करती हैं, जैसे Tor Exit Nodes। HTTP और HTTPS के लिए डिफ़ॉल्ट outproxy कार्यक्षमता exit.stormycloud.i2p द्वारा प्रदान की जाती है और इसे StormyCloud Inc द्वारा चलाया जाता है। यह HTTP Proxy में कॉन्फ़िगर किया गया है। इसके अतिरिक्त, गुमनामी की सुरक्षा में मदद के लिए, I2P आपको डिफ़ॉल्ट रूप से नियमित इंटरनेट से अनाम कनेक्शन बनाने की अनुमति नहीं देता है। अधिक जानकारी के लिए कृपया Socks Outproxy पृष्ठ देखें।\nरीसीड्स मेरा router कई मिनटों से चालू है और इसमें शून्य या बहुत कम कनेक्शन हैं सबसे पहले Router Console में http://127.0.0.1:7657/netdb पेज देखें – आपका network database। यदि आप I2P के भीतर से एक भी router सूचीबद्ध नहीं देखते हैं लेकिन console कहता है कि आप firewalled होना चाहिए, तो संभवतः आप reseed servers से कनेक्ट नहीं हो सकते। यदि आप अन्य I2P routers सूचीबद्ध देखते हैं तो http://127.0.0.1:7657/config में अधिकतम connections की संख्या कम करने का प्रयास करें, हो सकता है कि आपका router कई connections को संभाल नहीं सकता।\nमैं मैन्युअल रूप से रीसीड कैसे करूं? सामान्य परिस्थितियों में, I2P आपको हमारे bootstrap लिंक का उपयोग करके स्वचालित रूप से नेटवर्क से कनेक्ट कर देगा। यदि बाधित इंटरनेट reseed सर्वर से bootstrapping विफल कर देता है, तो bootstrap करने का एक आसान तरीका Tor ब्राउज़र का उपयोग करना है (डिफ़ॉल्ट रूप से यह localhost खोलता है), जो http://127.0.0.1:7657/configreseed के साथ बहुत अच्छी तरह से काम करता है। I2P router को मैन्युअल रूप से reseed करना भी संभव है।\nTor ब्राउज़र का उपयोग करके reseed करते समय आप एक साथ कई URLs चुन सकते हैं और आगे बढ़ सकते हैं। हालांकि डिफ़ॉल्ट मान जो 2 है (कई urls में से) वह भी काम करेगा लेकिन यह धीमा होगा।\nगोपनीयता-सुरक्षा क्या मेरा router एक \u0026ldquo;exit node\u0026rdquo;(outproxy) है जो नियमित इंटरनेट से जुड़ता है? मैं नहीं चाहता कि यह हो। नहीं, आपका router i2p network के माध्यम से encrypted e2e ट्रैफ़िक को एक यादृच्छिक tunnel endpoint तक पहुंचाने में भाग लेता है, जो आमतौर पर outproxy नहीं होता, लेकिन transport layer पर आपके router और इंटरनेट के बीच कोई ट्रैफ़िक पास नहीं होता है। एक अंतिम उपयोगकर्ता के रूप में, यदि आप सिस्टम और नेटवर्क प्रशासन में कुशल नहीं हैं तो आपको outproxy नहीं चलाना चाहिए।\nक्या नेटवर्क ट्रैफ़िक का विश्लेषण करके I2P के उपयोग का पता लगाना आसान है? I2P ट्रैफ़िक आमतौर पर UDP ट्रैफ़िक जैसा दिखता है, और इससे ज़्यादा कुछ नहीं - और इसे उससे ज़्यादा कुछ न दिखाना एक लक्ष्य है। यह TCP का भी समर्थन करता है। कुछ प्रयास के साथ, निष्क्रिय ट्रैफ़िक विश्लेषण (passive traffic analysis) इस ट्रैफ़िक को \u0026ldquo;I2P\u0026rdquo; के रूप में वर्गीकृत करने में सक्षम हो सकता है, लेकिन हमें उम्मीद है कि traffic obfuscation के निरंतर विकास से यह और कम हो जाएगा। यहां तक कि obfs4 जैसी एक काफी सरल protocol obfuscation परत भी सेंसर को I2P को ब्लॉक करने से रोकेगी (यह एक लक्ष्य है जिसे I2P तैनात करता है)।\nक्या I2P का उपयोग सुरक्षित है? यह आपके व्यक्तिगत खतरे के मॉडल पर निर्भर करता है। अधिकांश लोगों के लिए, I2P बिना किसी सुरक्षा के उपयोग की तुलना में बहुत सुरक्षित है। कुछ अन्य नेटवर्क (जैसे Tor, mixminion/mixmaster), संभवतः कुछ विशेष विरोधियों के खिलाफ अधिक सुरक्षित हैं। उदाहरण के लिए, I2P ट्रैफ़िक TLS/SSL का उपयोग नहीं करता है, इसलिए इसमें \u0026ldquo;सबसे कमजोर कड़ी\u0026rdquo; की समस्याएं नहीं हैं जो Tor में होती हैं। \u0026ldquo;अरब स्प्रिंग\u0026rdquo; के दौरान सीरिया में बहुत से लोगों ने I2P का उपयोग किया था, और हाल ही में परियोजना ने निकट और मध्य पूर्व में I2P की छोटी भाषाई स्थापनाओं में बड़ी वृद्धि देखी है। यहां ध्यान देने वाली सबसे महत्वपूर्ण बात यह है कि I2P एक तकनीक है और इंटरनेट पर आपकी गोपनीयता/गुमनामी बढ़ाने के लिए आपको एक how-to/गाइड की आवश्यकता है। साथ ही अपने ब्राउज़र की जांच करें या fingerprint हमलों को ब्लॉक करने के लिए fingerprint-search-engine को इम्पोर्ट करें जिसमें बहुत बड़े (अर्थात: विशिष्ट लंबी पूंछ / बहुत सटीक विविध डेटा संरचना) वातावरण संबंधी चीजों के बारे में डेटासेट हो और VPN का उपयोग न करें ताकि इससे आने वाले सभी जोखिमों को कम किया जा सके जैसे स्वयं का TLS cache व्यवहार और प्रदाता व्यवसाय की तकनीकी संरचना जिसे अपने डेस्कटॉप सिस्टम की तुलना में आसानी से हैक किया जा सकता है। सार्वजनिक नेटवर्क और शीर्ष व्यक्तिगत जोखिम मॉडल में एक isolated tor V-Browser का उपयोग इसके बेहतरीन anti-fingerprint सुरक्षा के साथ और केवल आवश्यक सिस्टम संचार की अनुमति के साथ एक समग्र appguard-livetime-protection और anti-spy disable scripts और live-cd के साथ अंतिम स्थायी vm-use का उपयोग किसी भी \u0026ldquo;लगभग स्थायी संभावित जोखिम\u0026rdquo; को हटाने और घटती संभावना द्वारा सभी जोखिमों को कम करने के लिए एक अच्छा विकल्प हो सकता है और i2p उपयोग के लिए इस लक्ष्य के साथ आप जो सबसे अच्छा कर सकते हैं वह यह हो सकता है।\nमैं router console में अन्य सभी I2P nodes के IP addresses देख सकता हूं। क्या इसका मतलब है कि मेरा IP address दूसरों को दिखाई दे रहा है? हां, अन्य I2P nodes के लिए जो आपके router के बारे में जानते हैं। हम इसका उपयोग शेष I2P नेटवर्क से कनेक्ट करने के लिए करते हैं। पते भौतिक रूप से \u0026ldquo;routerInfos (key,value) objects\u0026rdquo; में स्थित होते हैं, जो या तो दूरस्थ रूप से प्राप्त किए जाते हैं या peer से प्राप्त होते हैं। \u0026ldquo;routerInfos\u0026rdquo; में router के बारे में कुछ जानकारी (कुछ वैकल्पिक अवसरवादी जोड़ी गई) होती है, जो \u0026ldquo;peer द्वारा प्रकाशित\u0026rdquo; होती है, bootstrapping के लिए। इस object में clients के बारे में कोई डेटा नहीं है। हुड के नीचे करीब से देखने पर आपको पता चलेगा कि हर किसी की गिनती ids बनाने के नवीनतम प्रकार से की गई है जिसे \u0026ldquo;SHA-256 Hashes (low=Positive hash(-key), high=Negative hash(+key))\u0026rdquo; कहा जाता है। I2P नेटवर्क के पास upload और indexing के दौरान बनाए गए routerInfos का अपना database डेटा है, लेकिन यह key/value tables और नेटवर्क topology और state-of-load / state-of-bandwidth और DB components में storages के लिए routing संभावनाओं की प्राप्ति में गहराई से निर्भर करता है।\nक्या outproxy का उपयोग करना सुरक्षित है? यह इस बात पर निर्भर करता है कि \u0026ldquo;सुरक्षित\u0026rdquo; की आपकी परिभाषा क्या है। Outproxies बहुत अच्छे होते हैं जब वे काम करते हैं, लेकिन दुर्भाग्य से वे स्वेच्छा से उन लोगों द्वारा चलाए जाते हैं जो रुचि खो सकते हैं या जिनके पास उन्हें 24/7 बनाए रखने के लिए संसाधन नहीं हो सकते हैं – कृपया जागरूक रहें कि आप ऐसे समय का अनुभव कर सकते हैं जिसके दौरान सेवाएं अनुपलब्ध, बाधित या अविश्वसनीय हो सकती हैं, और हम इस सेवा से संबद्ध नहीं हैं और इस पर हमारा कोई प्रभाव नहीं है।\noutproxy स्वयं आपके ट्रैफ़िक को आते-जाते देख सकते हैं, end-to-end एन्क्रिप्टेड HTTPS/SSL डेटा के अपवाद के साथ, ठीक उसी तरह जैसे आपका ISP आपके कंप्यूटर से आने-जाने वाले ट्रैफ़िक को देख सकता है। यदि आप अपने ISP के साथ सहज हैं, तो outproxy के साथ यह इससे बुरा नहीं होगा।\n\u0026ldquo;डी-एनोनिमाइज़िंग\u0026rdquo; हमलों के बारे में क्या? बहुत विस्तृत व्याख्या के लिए, हमारे Threat Model के बारे में लेख पढ़ें। सामान्यतः, de-anonymizing तुच्छ नहीं है, लेकिन यदि आप पर्याप्त सावधान नहीं हैं तो संभव है।\nइंटरनेट एक्सेस/प्रदर्शन मैं I2P के माध्यम से सामान्य इंटरनेट साइटों तक नहीं पहुँच सकता। इंटरनेट साइटों के लिए प्रॉक्सी करना (eepsites जो इंटरनेट से बाहर हैं) गैर-ब्लॉक प्रदाताओं द्वारा I2P उपयोगकर्ताओं को एक सेवा के रूप में प्रदान की जाती है। यह सेवा I2P विकास का मुख्य फोकस नहीं है, और स्वैच्छिक आधार पर प्रदान की जाती है। I2P पर होस्ट की गई Eepsites को हमेशा बिना outproxy के काम करना चाहिए। Outproxies एक सुविधा हैं लेकिन वे डिज़ाइन के अनुसार न तो पूर्ण हैं और न ही परियोजना का एक बड़ा हिस्सा। जागरूक रहें कि वे I2P की अन्य सेवाओं द्वारा प्रदान की जाने वाली उच्च-गुणवत्ता सेवा प्रदान करने में सक्षम नहीं हो सकती हैं।\nमैं I2P के माध्यम से https:// या ftp:// साइटों तक नहीं पहुँच सकता। डिफ़ॉल्ट HTTP प्रॉक्सी केवल HTTP और HTTPS outproxying का समर्थन करता है।\nमेरा router बहुत अधिक CPU का उपयोग क्यों कर रहा है? सबसे पहले, सुनिश्चित करें कि आपके पास I2P से संबंधित हर भाग का नवीनतम संस्करण है – पुराने संस्करणों में कोड में अनावश्यक CPU-खपत करने वाले खंड थे। एक performance Log भी है जो समय के साथ I2P प्रदर्शन में हुए कुछ सुधारों को दस्तावेज़ित करता है।\nमेरे सक्रिय peers / ज्ञात peers / भाग लेने वाली tunnels / कनेक्शन / बैंडविड्थ समय के साथ नाटकीय रूप से बदलते रहते हैं! क्या कुछ गलत है? I2P नेटवर्क की सामान्य स्थिरता अनुसंधान का एक सतत क्षेत्र है। उस अनुसंधान का एक विशेष भाग इस बात पर केंद्रित है कि कॉन्फ़िगरेशन सेटिंग्स में छोटे बदलाव router के व्यवहार को कैसे बदलते हैं। चूंकि I2P एक peer-to-peer नेटवर्क है, अन्य peers द्वारा की गई कार्रवाइयों का आपके router के प्रदर्शन पर प्रभाव पड़ेगा।\nI2P पर डाउनलोड, torrents, वेब ब्राउज़िंग और अन्य सभी चीजें नियमित इंटरनेट की तुलना में धीमी क्यों होती हैं? I2P में विभिन्न सुरक्षा उपाय हैं जो अतिरिक्त routing और encryption की अतिरिक्त परतें जोड़ते हैं। यह अन्य peers (Tunnels) के माध्यम से ट्रैफ़िक को भी bounce करता है जिनकी अपनी गति और गुणवत्ता होती है, कुछ धीमे होते हैं, कुछ तेज़। इससे विभिन्न दिशाओं में अलग-अलग गति पर बहुत अधिक overhead और ट्रैफ़िक जुड़ जाता है। डिज़ाइन के अनुसार ये सभी चीजें इसे इंटरनेट पर सीधे कनेक्शन की तुलना में धीमा बना देंगी, लेकिन बहुत अधिक गुमनाम और फिर भी अधिकांश चीजों के लिए पर्याप्त तेज़।\nनीचे एक उदाहरण दिया गया है जिसमें I2P का उपयोग करते समय विलंबता (latency) और बैंडविड्थ संबंधी विचारों को समझने में मदद के लिए स्पष्टीकरण प्रस्तुत किया गया है।\nनीचे दिए गए चित्र पर विचार करें। यह I2P के माध्यम से अनुरोध करने वाले एक client, I2P के माध्यम से अनुरोध प्राप्त करने वाले एक server और फिर I2P के माध्यम से वापस प्रतिक्रिया देने के बीच संबंध को दर्शाता है। जिस circuit पर अनुरोध यात्रा करता है, उसे भी दर्शाया गया है।\nआरेख से, मान लीजिए कि \u0026lsquo;P\u0026rsquo;, \u0026lsquo;Q\u0026rsquo; और \u0026lsquo;R\u0026rsquo; लेबल वाले बॉक्स \u0026lsquo;A\u0026rsquo; के लिए एक outbound tunnel को दर्शाते हैं और \u0026lsquo;X\u0026rsquo;, \u0026lsquo;Y\u0026rsquo; और \u0026lsquo;Z\u0026rsquo; लेबल वाले बॉक्स \u0026lsquo;B\u0026rsquo; के लिए एक outbound tunnel को दर्शाते हैं। इसी तरह, \u0026lsquo;X\u0026rsquo;, \u0026lsquo;Y\u0026rsquo; और \u0026lsquo;Z\u0026rsquo; लेबल वाले बॉक्स \u0026lsquo;B\u0026rsquo; के लिए एक inbound tunnel को दर्शाते हैं जबकि \u0026lsquo;P_1\u0026rsquo;, \u0026lsquo;Q_1\u0026rsquo; और \u0026lsquo;R_1\u0026rsquo; लेबल वाले बॉक्स \u0026lsquo;A\u0026rsquo; के लिए एक inbound tunnel को दर्शाते हैं। बॉक्स के बीच के तीर ट्रैफ़िक की दिशा दिखाते हैं। तीरों के ऊपर और नीचे का टेक्स्ट हॉप की एक जोड़ी के बीच कुछ उदाहरण बैंडविड्थ के साथ-साथ उदाहरण लेटेंसी का विवरण देता है।\nजब client और server दोनों पूरे समय 3-hop tunnels का उपयोग कर रहे हों, तो कुल 12 अन्य I2P routers ट्रैफ़िक को relay करने में शामिल होते हैं। 6 peers, client से server तक ट्रैफ़िक को relay करते हैं जो \u0026lsquo;A\u0026rsquo; से एक 3-hop outbound tunnel (\u0026lsquo;P\u0026rsquo;, \u0026lsquo;Q\u0026rsquo;, \u0026lsquo;R\u0026rsquo;) और \u0026lsquo;B\u0026rsquo; तक एक 3-hop inbound tunnel (\u0026lsquo;X\u0026rsquo;, \u0026lsquo;Y\u0026rsquo;, \u0026lsquo;Z\u0026rsquo;) में विभाजित होता है। इसी तरह, 6 peers server से वापस client तक ट्रैफ़िक को relay करते हैं।\nसबसे पहले, हम latency पर विचार कर सकते हैं - वह समय जो एक client के अनुरोध को I2P network को पार करने, server तक पहुंचने और वापस client तक आने में लगता है। सभी latencies को जोड़ने पर हम देखते हैं कि:\n40 + 100 + 20 + 60 + 80 + 10 + 30 ms (client to server) + 60 + 40 + 80 + 60 + 100 + 20 + 40 ms (server to client) ----------------------------------- TOTAL: 740 ms हमारे उदाहरण में कुल round-trip time 740 ms तक जोड़ता है - निश्चित रूप से नियमित इंटरनेट वेबसाइटों को ब्राउज़ करते समय सामान्य रूप से देखे जाने वाले समय से बहुत अधिक।\nदूसरा, हम उपलब्ध bandwidth पर विचार कर सकते हैं। यह client और server के बीच hops के बीच सबसे धीमी link के साथ-साथ जब server द्वारा client को traffic भेजा जा रहा हो, के माध्यम से निर्धारित होता है। client से server की ओर जाने वाले traffic के लिए, हम देखते हैं कि हमारे उदाहरण में hops \u0026lsquo;R\u0026rsquo; और \u0026lsquo;X\u0026rsquo; के साथ-साथ hops \u0026lsquo;X\u0026rsquo; और \u0026lsquo;Y\u0026rsquo; के बीच उपलब्ध bandwidth 32 KB/s है। अन्य hops के बीच अधिक उपलब्ध bandwidth के बावजूद, ये hops एक bottleneck के रूप में कार्य करेंगे और \u0026lsquo;A\u0026rsquo; से \u0026lsquo;B\u0026rsquo; तक traffic के लिए अधिकतम उपलब्ध bandwidth को 32 KB/s पर सीमित कर देंगे। इसी तरह, server से client तक के path को trace करने पर पता चलता है कि 64 KB/s की अधिकतम bandwidth है - hops \u0026lsquo;Z_1\u0026rsquo; और \u0026lsquo;Y_1\u0026rsquo;, \u0026lsquo;Y_1\u0026rsquo; और \u0026lsquo;X_1\u0026rsquo; तथा \u0026lsquo;Q_1\u0026rsquo; और \u0026lsquo;P_1\u0026rsquo; के बीच।\nहम आपकी bandwidth सीमाओं को बढ़ाने की अनुशंसा करते हैं। यह उपलब्ध bandwidth की मात्रा बढ़ाकर नेटवर्क में मदद करता है जो बदले में आपके I2P अनुभव को बेहतर बनाएगा। Bandwidth सेटिंग्स http://localhost:7657/config पृष्ठ पर स्थित हैं। कृपया अपने ISP द्वारा निर्धारित अपने इंटरनेट कनेक्शन की सीमाओं के बारे में जागरूक रहें, और अपनी सेटिंग्स को तदनुसार समायोजित करें।\nहम पर्याप्त मात्रा में shared bandwidth सेट करने की भी सिफारिश करते हैं - यह participating tunnels को आपके I2P router के माध्यम से route किए जाने की अनुमति देता है। participating traffic की अनुमति देने से आपका router नेटवर्क में अच्छी तरह से एकीकृत रहता है और आपकी transfer speeds में सुधार होता है।\nI2P एक चल रहा काम है। बहुत सारे सुधार और फिक्सेस लागू किए जा रहे हैं, और सामान्य तौर पर, नवीनतम रिलीज़ चलाने से आपके प्रदर्शन में मदद मिलेगी। यदि आपने नहीं किया है, तो नवीनतम रिलीज़ इंस्टॉल करें।\nमुझे लगता है कि मुझे एक बग मिला है, मैं इसे कहाँ रिपोर्ट कर सकता हूँ? आप हमारे bugtracker पर किसी भी bug/issue की रिपोर्ट कर सकते हैं, जो non-private internet और I2P दोनों पर उपलब्ध है। हमारे पास एक discussion forum भी है, जो I2P और non-private internet दोनों पर उपलब्ध है। आप हमारे IRC channel से भी जुड़ सकते हैं: या तो हमारे IRC network, IRC2P के माध्यम से, या Freenode पर।\nहमारा Bugtracker: Non-private internet: https://i2pgit.org/I2P_Developers/i2p.i2p/issues I2P पर: http://git.idk.i2p/I2P_Developers/i2p.i2p/issues हमारे फोरम: i2pforum.i2p लॉग पेस्ट करें: आप किसी भी महत्वपूर्ण लॉग को किसी पेस्ट सेवा में पेस्ट कर सकते हैं जैसे कि PrivateBin Wiki पर सूचीबद्ध non-private internet सेवाएं, या I2P पेस्ट सेवा जैसे कि यह PrivateBin instance या यह Javascript-free पेस्ट सेवा और #i2p में IRC पर फॉलो अप करें IRC: #i2p-dev में शामिल हों - IRC पर डेवलपर्स के साथ चर्चा करें कृपया router logs पेज से प्रासंगिक जानकारी शामिल करें जो यहाँ उपलब्ध है: http://127.0.0.1:7657/logs । हम अनुरोध करते हैं कि आप \u0026lsquo;I2P Version and Running Environment\u0026rsquo; सेक्शन के अंतर्गत सभी टेक्स्ट के साथ-साथ पेज पर प्रदर्शित विभिन्न logs में दिखाई देने वाली किसी भी त्रुटि या चेतावनी को साझा करें।\nमेरा एक सवाल है! बढ़िया! हमें IRC पर खोजें:\nirc.freenode.net पर चैनल #i2p IRC2P पर चैनल #i2p या फोरम पर पोस्ट करें और हम इसे यहाँ पोस्ट करेंगे (उम्मीद है कि उत्तर के साथ)।\n","description":"व्यापक I2P FAQ: router सहायता, कॉन्फ़िगरेशन, reseeds, गोपनीयता/सुरक्षा, प्रदर्शन, और समस्या निवारण","id":"b0f8e4ee3509d229b406a0b0bb933ca4","section":"docs","title":"अक्सर पूछे जाने वाले प्रश्न","url":"/hi/docs/overview/faq/"},{"categories":null,"content":"अपने एप्लिकेशन के साथ I2P को बंडल करना उपयोगकर्ताओं को जोड़ने का एक शक्तिशाली तरीका है—लेकिन केवल तभी जब router को जिम्मेदारी से कॉन्फ़िगर किया गया हो।\n1. Router टीमों के साथ समन्वय करें बंडलिंग से पहले Java I2P और i2pd के मेंटेनर्स से संपर्क करें। वे आपके डिफ़ॉल्ट्स की समीक्षा कर सकते हैं और संगतता संबंधी चिंताओं को उजागर कर सकते हैं। अपने स्टैक के अनुसार router implementation चुनें: Java/Scala → Java I2P C/C++ → i2pd अन्य भाषाएं → एक router बंडल करें और SAM v3 या I2CP का उपयोग करके इंटीग्रेट करें router बाइनरीज़ और डिपेंडेंसीज़ (Java runtime, ICU, आदि) के लिए पुनर्वितरण शर्तों की पुष्टि करें। 2. अनुशंसित कॉन्फ़िगरेशन डिफ़ॉल्ट \u0026ldquo;आप जितना उपभोग करते हैं उससे अधिक योगदान करें\u0026rdquo; का लक्ष्य रखें। आधुनिक डिफ़ॉल्ट सेटिंग्स नेटवर्क के स्वास्थ्य और स्थिरता को प्राथमिकता देती हैं।\nSetting Recommended Default (2025) Bandwidth share 80% for participating tunnels Tunnel quantities i2pd: 3 inbound / 3 outbound; Java I2P: 2 inbound / 2 outbound. Signature \u0026amp; encryption Use Ed25519 (SIGNATURE_TYPE=7) and advertise ECIES-X25519 + ElGamal (i2cp.leaseSetEncType=4,0). Client protocols Use SAM v3 or I2CP. API listeners Bind SAM/I2CP to 127.0.0.1 only. Disable if not needed. UI toggles Expose bandwidth controls, logs, and an opt-in checkbox for participating tunnels. ### भाग लेने वाली Tunnels आवश्यक बनी रहती हैं भाग लेने वाली tunnels को बंद न करें।\nजो राउटर रिले नहीं करते वे स्वयं खराब प्रदर्शन करते हैं। नेटवर्क स्वैच्छिक क्षमता साझाकरण पर निर्भर करता है। कवर ट्रैफिक (रिले किया गया ट्रैफिक) गुमनामी में सुधार करता है। आधिकारिक न्यूनतम: - साझा बैंडविड्थ: ≥ 12 KB/s - Floodfill स्वतः ऑप्ट-इन: ≥ 128 KB/s - अनुशंसित: 2 inbound / 2 outbound tunnels (Java I2P डिफ़ॉल्ट)\n3. स्थिरता और रीसीडिंग स्थायी स्टेट डायरेक्टरियाँ (netDb/, प्रोफाइल, सर्टिफिकेट्स) को रन्स के बीच संरक्षित रखा जाना चाहिए।\npersistence के बिना, आपके उपयोगकर्ता हर स्टार्टअप पर reseed ट्रिगर करेंगे—जिससे प्रदर्शन खराब होगा और reseed सर्वर पर लोड बढ़ेगा।\nयदि persistence (स्थायी भंडारण) संभव नहीं है (उदाहरण के लिए, containers या अस्थायी इंस्टॉल):\nइंस्टॉलर में 1,000–2,000 router infos बंडल करें। सार्वजनिक सर्वरों पर भार कम करने के लिए एक या अधिक कस्टम reseed सर्वर संचालित करें। कॉन्फ़िगरेशन वेरिएबल: - बेस डायरेक्टरी: i2p.dir.base - कॉन्फ़िग डायरेक्टरी: i2p.dir.config - reseeding के लिए certificates/ शामिल करें।\n4. सुरक्षा और एक्सपोज़र Router console (127.0.0.1:7657) को केवल स्थानीय रखें। UI को बाहरी रूप से उजागर करते समय HTTPS का उपयोग करें। जब तक आवश्यक न हो, बाहरी SAM/I2CP को अक्षम करें। शामिल plugins की समीक्षा करें—केवल वही भेजें जो आपका ऐप समर्थन करता है। रिमोट console एक्सेस के लिए हमेशा प्रमाणीकरण शामिल करें। 2.5.0 के बाद से शामिल की गई सुरक्षा सुविधाएं: - एप्लिकेशन के बीच NetDB अलगाव (2.4.0+) - DoS शमन और Tor ब्लॉकलिस्ट (2.5.1) - NTCP2 प्रोबिंग प्रतिरोध (2.9.0) - Floodfill router चयन में सुधार (2.6.0+)\n5. समर्थित APIs (2025) API Status Notes SAM v3 (3.3) ✅ Active Recommended bridge for non-Java apps. I2CP ✅ Active Stable protocol core, used internally by Java I2P. I2PControl ✅ Active JSON-RPC API; plugin maintained. BOB ⚠️ Deprecated Removed from Java I2P since 1.7.0; use SAM v3 instead. सभी आधिकारिक दस्तावेज़ `/docs/api/` के अंतर्गत स्थित हैं — पुराना `/spec/samv3/` पथ मौजूद **नहीं** है। 6. नेटवर्किंग और पोर्ट्स विशिष्ट डिफ़ॉल्ट पोर्ट: - 4444 – HTTP प्रॉक्सी - 4445 – HTTPS प्रॉक्सी - 7654 – I2CP - 7656 – SAM Bridge - 7657 – Router Console - 7658 – लोकल I2P साइट - 6668 – IRC प्रॉक्सी - 9000–31000 – रैंडम router पोर्ट (UDP/TCP इनबाउंड)\nराउटर पहली बार चलने पर एक यादृच्छिक इनबाउंड पोर्ट चुनते हैं। फ़ॉरवर्डिंग प्रदर्शन में सुधार करती है, लेकिन UPnP इसे स्वचालित रूप से संभाल सकता है।\n7. आधुनिक परिवर्तन (2024–2025) Change Status Details SSU1 Transport Removed SSU2 is now the exclusive UDP transport. I2P-over-Tor Blocked Since 2.6.0 (July 2024). Datagram2/3 Added Authenticated, repliable datagram formats (2.9.0). LeaseSet service records Added Enables service discovery (Proposal 167). Tunnel build parameters Improved Adaptive congestion handling (2.9.0+). Post-quantum crypto Introduced (beta) ML-KEM hybrid ratchet, opt-in from 2.10.0. Java 17 requirement Announced Becomes mandatory in 2.11.0 (early 2026). ## 8. उपयोगकर्ता अनुभव और परीक्षण I2P क्या करता है और बैंडविड्थ क्यों साझा की जाती है, यह संप्रेषित करें। router डायग्नोस्टिक्स प्रदान करें (बैंडविड्थ, tunnels, reseed स्थिति)। Windows, macOS, और Linux पर बंडल्स का परीक्षण करें (कम-RAM शामिल)। Java I2P और i2pd peers दोनों के साथ इंटरऑप की पुष्टि करें। नेटवर्क ड्रॉप्स और ungraceful exits से रिकवरी का परीक्षण करें। 9. समुदाय संसाधन फोरम: i2pforum.net या I2P के अंदर http://i2pforum.i2p। कोड: i2pgit.org/I2P_Developers/i2p.i2p । IRC (Irc2P नेटवर्क): #i2p-dev, #i2pd। #i2papps अप्रमाणित; हो सकता है कि मौजूद न हो। स्पष्ट करें कि कौन सा नेटवर्क (Irc2P बनाम ilita.i2p) आपके चैनल को होस्ट करता है। जिम्मेदारी से एम्बेड करने का मतलब है उपयोगकर्ता अनुभव, प्रदर्शन और नेटवर्क योगदान के बीच संतुलन बनाना। इन डिफॉल्ट्स का उपयोग करें, router रखरखावकर्ताओं के साथ समन्वय बनाए रखें, और रिलीज़ से पहले वास्तविक-विश्व लोड के तहत परीक्षण करें।\n","description":"अपने ऐप के साथ I2P router को जिम्मेदारी से बंडल करने के लिए अपडेट की गई व्यावहारिक मार्गदर्शिका","id":"f67f27efbc9bb7bff8d34001c14105ff","section":"docs","title":"अपने एप्लिकेशन में I2P एम्बेड करना","url":"/hi/docs/applications/embedding/"},{"categories":null,"content":" ऐतिहासिक सूचना: यह पृष्ठ संदर्भ के लिए “Unidirectional Tunnels” पर पुरानी चर्चा संरक्षित रखता है। वर्तमान व्यवहार के लिए सक्रिय tunnel कार्यान्वयन प्रलेखन देखें।\nअवलोकन I2P एक-दिशीय tunnels बनाता है: एक tunnel निर्गामी ट्रैफिक ले जाता है और एक अलग tunnel आगत उत्तर ले जाती है। यह संरचना नेटवर्क के प्रारंभिक डिजाइनों से चली आ रही है और Tor जैसी द्विदिश सर्किट प्रणालियों से इसे अलग करने वाली एक प्रमुख विशेषता बनी हुई है। शब्दावली और कार्यान्वयन विवरण के लिए, tunnel का अवलोकन और tunnel विनिर्देश देखें।\nसमीक्षा एक-दिशीय tunnels अनुरोध और प्रतिक्रिया ट्रैफिक को अलग रखते हैं, इसलिए सांठगांठ करने वाले पीयर्स का कोई एक समूह राउंड-ट्रिप (अनुरोध-प्रतिक्रिया का पूरा चक्र) का केवल आधा हिस्सा ही देख पाता है। टाइमिंग हमलों को एकल सर्किट का विश्लेषण करने के बजाय दो tunnel pools (outbound और inbound) का प्रतिच्छेद करना पड़ता है, जिससे सहसंबंध करना और कठिन हो जाता है। स्वतंत्र inbound और outbound pools, routers को प्रत्येक दिशा के लिए विलंबता, क्षमता, और विफलता-प्रबंधन विशेषताएँ समायोजित करने की अनुमति देते हैं। नुकसानों में पीयर प्रबंधन की बढ़ी हुई जटिलता, और विश्वसनीय सेवा डिलीवरी के लिए अनेक tunnel sets को बनाए रखने की आवश्यकता शामिल है। गुमनामी Hermann और Grothoff के शोध-पत्र, I2P is Slow… and What to Do About It , एकदिश tunnels के विरुद्ध predecessor attacks (पूर्ववर्ती हमले) का विश्लेषण करता है, और संकेत देता है कि दृढ़-संकल्पित विरोधी अंततः दीर्घजीवी पीयर्स की पुष्टि कर सकते हैं। समुदाय की प्रतिक्रिया बताती है कि यह अध्ययन विरोधी के धैर्य और कानूनी अधिकारों के बारे में विशिष्ट मान्यताओं पर निर्भर करता है, और उन टाइमिंग हमलों के संदर्भ में इस दृष्टिकोण का मूल्यांकन नहीं करता जो द्विदिश डिज़ाइनों को प्रभावित करते हैं। निरंतर शोध और व्यावहारिक अनुभव लगातार यह पुष्ट करते हैं कि एकदिश tunnels किसी चूक का परिणाम नहीं, बल्कि अनामता के लिए एक सोचा-समझा विकल्प हैं।\n","description":"I2P के एक-दिशात्मक tunnel डिज़ाइन का ऐतिहासिक सारांश।","id":"37ac13877a690f9c4635959a57451755","section":"docs","title":"एकदिशीय Tunnels","url":"/hi/docs/legacy/unidirectional/"},{"categories":null,"content":"अवलोकन यह दस्तावेज़ एन्क्रिप्टेड LeaseSet2 (LS2) के लिए blinding (पहचान/कुंजी छिपाने हेतु यादृच्छिक ढंकना), एन्क्रिप्शन और डीक्रिप्शन को निर्दिष्ट करता है। एन्क्रिप्टेड LeaseSets, I2P नेटवर्क डेटाबेस में छिपी सेवा की जानकारी के पहुँच-नियंत्रित प्रकाशन की सुविधा प्रदान करते हैं।\nमुख्य विशेषताएँ: - forward secrecy (पुराने सत्रों की गोपनीयता सुरक्षित रखने हेतु) के लिए दैनिक कुंजी परिवर्तन - दो-स्तरीय क्लाइंट प्राधिकरण (DH-based और PSK-based; क्रमशः Diffie–Hellman और pre-shared key पर आधारित) - AES हार्डवेयर के बिना उपकरणों पर बेहतर प्रदर्शन के लिए ChaCha20 एन्क्रिप्शन - key blinding (कुंजी-ब्लाइंडिंग) के साथ Red25519 हस्ताक्षर - गोपनीयता-संरक्षित क्लाइंट सदस्यता\nसंबंधित प्रलेखन: - सामान्य संरचनाओं की विशिष्टता - एन्क्रिप्टेड LeaseSet संरचना - प्रस्ताव 123: नई netDB प्रविष्टियाँ - एन्क्रिप्टेड LeaseSets पर पृष्ठभूमि - नेटवर्क डेटाबेस प्रलेखन - NetDB उपयोग\nसंस्करण इतिहास और कार्यान्वयन स्थिति प्रोटोकॉल विकास समयरेखा संस्करण क्रमांकन पर महत्वपूर्ण नोट: I2P दो अलग-अलग संस्करण क्रमांकन प्रणालियों का उपयोग करता है: - API/Router संस्करण: 0.9.x श्रृंखला (तकनीकी विनिर्देशों में प्रयुक्त) - उत्पाद रिलीज़ संस्करण: 2.x.x श्रृंखला (सार्वजनिक रिलीज़ के लिए प्रयुक्त)\nतकनीकी विनिर्देश API संस्करणों का उल्लेख करते हैं (उदा., 0.9.41), जबकि अंतिम उपयोगकर्ता उत्पाद संस्करण देखते हैं (उदा., 2.10.0)।\nकार्यान्वयन मील के पत्थर Version Release Date Features 0.9.38January 2019Floodfill support for standard LS2, offline keys 0.9.39March 2019Full encrypted LS2 support, Red25519 (sig type\u0026nbsp;11) 0.9.40May 2019Per-client authorization, encrypted LS2 with offline keys, B32 support 0.9.41June 2019Protocol finalized as stable 2.10.0September 2025Latest Java implementation (API version 0.9.61) i2pd 2.58.0September 2025Full C++ implementation compatibility ### वर्तमान स्थिति ✅ प्रोटोकॉल स्थिति: जून 2019 से स्थिर और अपरिवर्तित ✅ Java I2P: संस्करण 0.9.40+ में पूर्णतः कार्यान्वित ✅ i2pd (C++): संस्करण 2.58.0+ में पूर्णतः कार्यान्वित ✅ अंतरसंचालनीयता: कार्यान्वयनों के बीच पूर्ण ✅ नेटवर्क परिनियोजन: 6+ वर्षों के परिचालन अनुभव के साथ उत्पादन-तैयार क्रिप्टोग्राफिक परिभाषाएँ संकेतन और परंपराएँ || संयोजन को दर्शाता है mod L Ed25519 के order के अनुसार मॉड्यूलर अपचयन को दर्शाता है अन्यथा निर्दिष्ट न होने पर सभी बाइट ऐरे नेटवर्क बाइट क्रम (big-endian — उच्च-क्रम बाइट पहले) में होते हैं Little-endian (निम्न-क्रम बाइट पहले) मान स्पष्ट रूप से दर्शाए जाते हैं CSRNG(n) क्रिप्टोग्राफिक रूप से सुरक्षित यादृच्छिक संख्या जनरेटर\nकुंजी सामग्री के निर्माण के लिए उपयुक्त, क्रिप्टोग्राफ़िक रूप से सुरक्षित यादृच्छिक डेटा के n बाइट्स उत्पन्न करता है।\nसुरक्षा आवश्यकताएँ: - क्रिप्टोग्राफिक रूप से सुरक्षित होना चाहिए (कुंजी उत्पन्न करने के लिए उपयुक्त) - जब सन्निहित बाइट अनुक्रम नेटवर्क पर उजागर हों, तब सुरक्षित होना चाहिए - कार्यान्वयन को संभावित रूप से अविश्वसनीय स्रोतों से प्राप्त आउटपुट को हैश करना चाहिए\nसंदर्भ: - PRNG सुरक्षा संबंधी विचार - Tor डेवलपर चर्चा H(p, d) व्यक्तिकरण के साथ SHA-256 हैश\nडोमेन-पृथक्करण वाला हैश फ़ंक्शन, जो लेता है: - p: पर्सनलाइज़ेशन स्ट्रिंग (डोमेन पृथक्करण प्रदान करती है) - d: हैश करने हेतु डेटा\nकार्यान्वयन:\nH(p, d) := SHA-256(p || d) उपयोग: विभिन्न प्रोटोकॉल में SHA-256 के उपयोगों के बीच टकराव हमलों को रोकने के लिए क्रिप्टोग्राफिक डोमेन पृथक्करण प्रदान करता है।\nस्ट्रीम: ChaCha20 स्ट्रीम सिफर: ChaCha20 जैसा कि RFC 7539 के अनुभाग 2.4 में निर्दिष्ट है\nपैरामीटर: - S_KEY_LEN = 32 (256-बिट कुंजी) - S_IV_LEN = 12 (96-बिट nonce, एक-बार-प्रयुक्त संख्या) - प्रारंभिक काउंटर: 1 (RFC 7539 0 या 1 की अनुमति देता है; AEAD संदर्भों के लिए 1 अनुशंसित है)\nENCRYPT(k, iv, plaintext)\nनिम्न का उपयोग करके plaintext (साधारण पाठ) को एन्क्रिप्ट करता है: - k: 32-बाइट cipher key (कूट-कुंजी) - iv: 12-बाइट nonce (एक बार उपयोग होने वाला यादृच्छिक मान; प्रत्येक कुंजी के लिए अद्वितीय होना अनिवार्य है) - plaintext के समान आकार का ciphertext (एन्क्रिप्टेड आउटपुट/सांकेतिक पाठ) लौटाता है\nसुरक्षा गुणधर्म: यदि कुंजी गोपनीय है, तो पूरा ciphertext (एन्क्रिप्टेड डेटा) यादृच्छिक डेटा से अलग से पहचाना न जा सके।\nDECRYPT(k, iv, ciphertext)\nसिफरटेक्स्ट को डिक्रिप्ट करता है, उपयोग करते हुए: - k: 32-बाइट साइफ़र कुंजी - iv: 12-बाइट नॉनस (एक बार प्रयुक्त मान) - प्लेनटेक्स्ट (साधारण पाठ) लौटाता है\nडिज़ाइन तर्क: AES की तुलना में ChaCha20 को चुना गया क्योंकि: - हार्डवेयर-त्वरण के बिना उपकरणों पर AES की तुलना में 2.5-3x तेज - स्थिर-समय (constant-time) कार्यान्वयन हासिल करना आसान - AES-NI उपलब्ध होने पर सुरक्षा और गति तुलनीय\nसंदर्भ: - RFC 7539 - IETF प्रोटोकॉल्स के लिए ChaCha20 (स्ट्रीम साइफर) और Poly1305 (संदेश प्रमाणीकरण कोड (MAC) एल्गोरिथ्म)\nहस्ताक्षर: Red25519 हस्ताक्षर योजना: Red25519 (SigType 11) के साथ Key Blinding (कुंजी को छिपाने की तकनीक)\nRed25519, Ed25519 वक्र पर किए गए Ed25519 हस्ताक्षरों पर आधारित है, हैशिंग के लिए SHA-512 का उपयोग करता है, और ZCash RedDSA में निर्दिष्ट key blinding (कुंजी-ब्लाइंडिंग—कुंजी को छिपाने/मास्क करने की तकनीक) का समर्थन करता है।\nफ़ंक्शन्स:\nDERIVE_PUBLIC(privkey) दी गई निजी कुंजी के अनुरूप सार्वजनिक कुंजी लौटाता है। - मानक Ed25519 (एक एलिप्टिक-कर्व हस्ताक्षर योजना) आधार बिंदु पर स्केलर गुणन का उपयोग करता है\nSIGN(privkey, m) निजी कुंजी privkey से संदेश m पर किया गया हस्ताक्षर लौटाता है।\nRed25519 में Ed25519 की तुलना में हस्ताक्षर संबंधी अंतर: 1. Random Nonce (एक-बार-प्रयुक्त यादृच्छिक संख्या): अतिरिक्त 80 बाइट यादृच्छिक डेटा का उपयोग करता है\nT = CSRNG(80) // 80 random bytes r = H*(T || publickey || message) यह Red25519 (एक क्रिप्टोग्राफ़िक हस्ताक्षर योजना) के प्रत्येक हस्ताक्षर को अद्वितीय बनाता है, भले ही संदेश और कुंजी वही हों।\nनिजी कुंजी निर्माण: Red25519 की निजी कुंजियाँ यादृच्छिक संख्याओं से उत्पन्न की जाती हैं और mod L में घटाई जाती हैं, Ed25519 की bit-clamping (बिटों को निश्चित पैटर्न में बाध्य करना) पद्धति के उपयोग के बजाय। VERIFY(pubkey, m, sig) हस्ताक्षर sig को सार्वजनिक कुंजी pubkey और संदेश m के विरुद्ध सत्यापित करता है। - अगर हस्ताक्षर वैध है तो true लौटाता है, अन्यथा false - सत्यापन Ed25519 के समान है\nकुंजी ब्लाइंडिंग क्रियाएँ:\nGENERATE_ALPHA(data, secret) key blinding (कुंजी-अंधीकरण) के लिए alpha उत्पन्न करता है. - data: सामान्यतः इसमें signing public key (हस्ताक्षर सार्वजनिक कुंजी) और signature types (हस्ताक्षर प्रकार) होते हैं - secret: वैकल्पिक अतिरिक्त secret (रहस्य; यदि उपयोग न हो तो शून्य लंबाई) - परिणाम Ed25519 निजी कुंजियों के समान वितरण का होता है (mod L reduction के बाद)\nBLIND_PRIVKEY(privkey, alpha) गुप्त alpha का उपयोग करके निजी कुंजी को ब्लाइंड (blinding, छिपाने की तकनीक) करता है। - कार्यान्वयन: blinded_privkey = (privkey + alpha) mod L - फील्ड (बीजीय क्षेत्र) में स्केलर अंकगणित का उपयोग करता है\nBLIND_PUBKEY(pubkey, alpha) Secret alpha का उपयोग करके एक सार्वजनिक कुंजी को blind (क्रिप्टोग्राफ़िक छुपाव) करता है. - कार्यान्वयन: blinded_pubkey = pubkey + DERIVE_PUBLIC(alpha) - वक्र पर group element (point) addition का उपयोग करता है\nमहत्वपूर्ण विशेषता:\nBLIND_PUBKEY(pubkey, alpha) == DERIVE_PUBLIC(BLIND_PRIVKEY(privkey, alpha)) सुरक्षा संबंधी विचार:\nZCash प्रोटोकॉल स्पेसिफिकेशन अनुभाग 5.4.6.1 से: सुरक्षा के लिए, alpha का वितरण ठीक वैसा ही होना चाहिए जैसा ब्लाइंडिंग हटाई गईं निजी कुंजियों का होता है। यह सुनिश्चित करता है कि \u0026ldquo;पुनः यादृच्छीकृत सार्वजनिक कुंजी और उस कुंजी के अंतर्गत हस्ताक्षर(ों) का संयोजन उस कुंजी को प्रकट नहीं करता जिससे इसे पुनः यादृच्छीकृत किया गया था।\u0026rdquo;\nसमर्थित हस्ताक्षर प्रकार: - Type 7 (Ed25519): मौजूदा destinations (डेस्टिनेशन) के लिए समर्थित (पिछली संगतता) - Type 11 (Red25519): एन्क्रिप्शन का उपयोग करने वाले नए destinations के लिए अनुशंसित - Blinded keys (ब्लाइंडेड कुंजियाँ): हमेशा Type 11 (Red25519) का उपयोग करें\nसंदर्भ: - ZCash प्रोटोकॉल विनिर्देश - अनुभाग 5.4.6 RedDSA - I2P Red25519 विनिर्देश DH (Diffie-Hellman कुंजी विनिमय): X25519 Elliptic Curve Diffie-Hellman (अण्डाकार वक्र आधारित Diffie-Hellman कुंजी सहमति): X25519\nCurve25519 पर आधारित सार्वजनिक-कुंजी सहमति प्रणाली।\nपैरामीटर्स: - निजी कुंजियाँ: 32 बाइट्स - सार्वजनिक कुंजियाँ: 32 बाइट्स - साझा रहस्य आउटपुट: 32 बाइट्स\nफ़ंक्शंस:\nGENERATE_PRIVATE() CSRNG (Cryptographically Secure Random Number Generator—क्रिप्टोग्राफ़िक रूप से सुरक्षित रैंडम नंबर जनरेटर) का उपयोग करके एक नई 32-बाइट निजी कुंजी उत्पन्न करता है।\nDERIVE_PUBLIC(privkey) दी गई निजी कुंजी से 32-बाइट सार्वजनिक कुंजी व्युत्पन्न करता है. - Curve25519 पर स्केलर गुणन (scalar multiplication) का उपयोग करता है\nDH(privkey, pubkey) Diffie-Hellman कुंजी समझौता निष्पादित करता है। - privkey: स्थानीय 32-बाइट निजी कुंजी - pubkey: दूरस्थ 32-बाइट सार्वजनिक कुंजी - रिटर्न: 32-बाइट साझा रहस्य\nसुरक्षा विशेषताएँ: - Curve25519 पर गणनात्मक Diffie-Hellman मान्यता - जब क्षणिक कुंजियाँ उपयोग की जाती हैं तो Forward secrecy (पिछला संचार सुरक्षित रहता है) - टाइमिंग हमलों को रोकने के लिए समय-स्थिर कार्यान्वयन आवश्यक है\nसंदर्भ: - RFC 7748 - सुरक्षा के लिए दीर्घवृत्तीय वक्र\nHKDF (HMAC-आधारित कुंजी व्युत्पत्ति फ़ंक्शन) HMAC-आधारित कुंजी व्युत्पत्ति फ़ंक्शन\nइनपुट कुंजी सामग्री से कुंजी सामग्री का निष्कर्षण और विस्तार करता है।\nपैरामीटर्स: - salt: अधिकतम 32 बाइट्स (आम तौर पर SHA-256 के लिए 32 बाइट्स) - ikm: इनपुट कुंजी-सामग्री (किसी भी लंबाई की, अच्छी एंट्रॉपी होनी चाहिए) - info: संदर्भ-विशिष्ट जानकारी (डोमेन पृथक्करण) - n: आउटपुट की लंबाई बाइट्स में\nकार्यान्वयन:\nRFC 5869 में निर्दिष्ट अनुसार HKDF का उपयोग किया जाता है, निम्न के साथ: - हैश फ़ंक्शन: SHA-256 - HMAC: RFC 2104 में निर्दिष्ट अनुसार - सॉल्ट की लंबाई: अधिकतम 32 बाइट (SHA-256 के लिए HashLen (हैश लंबाई))\nउपयोग पैटर्न:\nkeys = HKDF(salt, ikm, info, n) डोमेन पृथक्करण: info पैरामीटर प्रोटोकॉल में HKDF (HMAC-आधारित कुंजी व्युत्पन्न फ़ंक्शन) के विभिन्न उपयोगों के बीच क्रिप्टोग्राफिक डोमेन पृथक्करण प्रदान करता है।\nसत्यापित जानकारी मान: - \u0026quot;ELS2_L1K\u0026quot; - लेयर 1 (बाहरी) एन्क्रिप्शन - \u0026quot;ELS2_L2K\u0026quot; - लेयर 2 (आंतरिक) एन्क्रिप्शन - \u0026quot;ELS2_XCA\u0026quot; - DH क्लाइंट प्राधिकरण - \u0026quot;ELS2PSKA\u0026quot; - PSK क्लाइंट प्राधिकरण - \u0026quot;i2pblinding1\u0026quot; - अल्फ़ा निर्माण\nसंदर्भ: - RFC 5869 - HKDF विनिर्देश - RFC 2104 - HMAC विनिर्देश\nप्रारूप विनिर्देश कूटबद्ध LS2 तीन घोंसलेदार परतों से बना होता है:\nलेयर 0 (बाहरी): भंडारण और पुनर्प्राप्ति के लिए सादा पाठ जानकारी लेयर 1 (मध्य): क्लाइंट प्रमाणीकरण डेटा (कूटबद्ध) लेयर 2 (आंतरिक): वास्तविक LeaseSet2 डेटा (कूटबद्ध) समग्र संरचना:\nLayer 0 data + Enc(layer 1 data + Enc(layer 2 data)) + Signature महत्वपूर्ण: एन्क्रिप्टेड LS2 blinded keys (गोपनीयता हेतु छिपाई गई कुंजियाँ) का उपयोग करता है. Destination (गंतव्य पहचान) हैडर में शामिल नहीं होता. DHT का भंडारण स्थान SHA-256(sig type || blinded public key) है, जिसे प्रतिदिन बदला जाता है.\nस्तर 0 (बाहरी) - सादा पाठ Layer 0 मानक LS2 header का उपयोग नहीं करता है। इसमें blinded keys (ब्लाइंडिंग तकनीक से छिपाई गई कुंजियाँ) के लिए अनुकूलित एक कस्टम प्रारूप है।\nसंरचना:\nField Size Description Type1 byteNot in header, from DatabaseStore message field Blinded Public Key Sig Type2 bytesBig endian, always 0x000b (Red25519 type 11) Blinded Public Key32 bytesRed25519 blinded public key Published Timestamp4 bytesBig endian, seconds since epoch (rolls over in 2106) Expires2 bytesBig endian, offset from published in seconds (max 65,535 \u0026asymp; 18.2 hours) Flags2 bytesBit flags (see below) [Optional] Transient Key DataVariablePresent if flag bit\u0026nbsp;0 is set lenOuterCiphertext2 bytesBig endian, length of outer ciphertext outerCiphertextlenOuterCiphertextEncrypted Layer\u0026nbsp;1 data Signature64 bytesRed25519 signature over all preceding data **फ्लैग्स फ़ील्ड (2 बाइट, बिट 15-0):** - **बिट 0:** ऑफ़लाइन कुंजियों का संकेतक - `0` = कोई ऑफ़लाइन कुंजियाँ नहीं - `1` = ऑफ़लाइन कुंजियाँ मौजूद हैं (अस्थायी कुंजी डेटा आगे आता है) - **बिट्स 1-15:** आरक्षित, भविष्य की संगतता के लिए 0 होना चाहिए अस्थायी कुंजी डेटा (यदि फ़्लैग बिट 0 = 1 हो तो):\nField Size Description Expires Timestamp4 bytesBig endian, seconds since epoch Transient Sig Type2 bytesBig endian, signature type Transient Signing Public KeyVariableLength implied by signature type Signature64 bytesSigned by blinded public key; covers expires timestamp, transient sig type, and transient public key **हस्ताक्षर सत्यापन:** - **ऑफ़लाइन कुंजियों के बिना:** ब्लाइंडेड सार्वजनिक कुंजी के साथ सत्यापित करें - **ऑफ़लाइन कुंजियों के साथ:** अस्थायी सार्वजनिक कुंजी के साथ सत्यापित करें हस्ताक्षर Type से लेकर outerCiphertext तक (दोनों सहित) सभी डेटा को शामिल करता है।\nपरत 1 (मध्य) - क्लाइंट प्राधिकरण डिक्रिप्शन: लेयर 1 एन्क्रिप्शन अनुभाग देखें।\nसंरचना:\nField Size Description Flags1 byteAuthorization flags (see below) [Optional] Auth DataVariablePresent based on flags innerCiphertextVariableEncrypted Layer\u0026nbsp;2 data (remainder) **फ्लैग्स फ़ील्ड (1 बाइट, बिट्स 7-0):** - **बिट 0:** प्राधिकरण मोड - `0` = प्रति-क्लाइंट प्राधिकरण नहीं (सभी) - `1` = प्रति-क्लाइंट प्राधिकरण (प्रमाणीकरण अनुभाग आगे आता है) - **बिट्स 3-1:** प्रमाणीकरण स्कीम (केवल तब जब बिट 0 = 1) - `000` = DH क्लाइंट प्रमाणीकरण - `001` = PSK क्लाइंट प्रमाणीकरण - अन्य आरक्षित - **बिट्स 7-4:** अप्रयुक्त, 0 होना आवश्यक है DH क्लाइंट प्राधिकरण डेटा (फ्लैग्स = 0x01, बिट्स 3-1 = 000):\nField Size Description ephemeralPublicKey32 bytesServer's ephemeral X25519 public key clients2 bytesBig endian, number of client entries authClient[]40 bytes eachArray of client authorization entries **authClient प्रविष्टि (40 बाइट):** - `clientID_i`: 8 बाइट - `clientCookie_i`: 32 बाइट (कूटबद्ध authCookie) PSK क्लाइंट प्राधिकरण डेटा (flags = 0x03, bits 3-1 = 001):\nField Size Description authSalt32 bytesSalt for PSK key derivation clients2 bytesBig endian, number of client entries authClient[]40 bytes eachArray of client authorization entries **authClient एंट्री (40 बाइट्स):** - `clientID_i`: 8 बाइट्स - `clientCookie_i`: 32 बाइट्स (एन्क्रिप्टेड authCookie) परत 2 (आंतरिक) - LeaseSet डेटा डिक्रिप्शन: लेयर 2 एन्क्रिप्शन अनुभाग देखें।\nसंरचना:\nField Size Description Type1 byte3 (LS2) or 7 (Meta LS2) DataVariableComplete LeaseSet2 or MetaLeaseSet2 आंतरिक परत में LeaseSet2 की पूर्ण संरचना शामिल है, जिसमें: - LS2 header - Lease संबंधी जानकारी - LS2 signature सत्यापन आवश्यकताएँ: डिक्रिप्शन के बाद, इम्प्लीमेंटेशन को निम्नलिखित का सत्यापन करना चाहिए: 1. आंतरिक टाइमस्टैम्प बाहरी प्रकाशित टाइमस्टैम्प से मेल खाता हो 2. आंतरिक समाप्ति बाहरी समाप्ति से मेल खाती हो 3. LS2 का डिजिटल हस्ताक्षर मान्य हो 4. Lease (I2P में LeaseSet का एक प्रविष्टि) डेटा सुव्यवस्थित हो\nसंदर्भ: - सामान्य संरचनाओं का विनिर्देश - LeaseSet2 स्वरूप विवरण\nBlinding (छिपाने की तकनीक) कुंजी व्युत्पत्ति अवलोकन I2P, Ed25519 और ZCash RedDSA पर आधारित एक additive key blinding scheme (जोड़-आधारित कुंजी ब्लाइंडिंग योजना) का उपयोग करता है। forward secrecy (आगे की गोपनीयता) के लिए ब्लाइंडेड कुंजियाँ प्रतिदिन (UTC मध्यरात्रि) बदली जाती हैं।\nडिज़ाइन का औचित्य:\nI2P ने स्पष्ट रूप से Tor के rend-spec-v3.txt के परिशिष्ट A.2 में वर्णित दृष्टिकोण का उपयोग न करने का निर्णय लिया। विनिर्देशन के अनुसार:\n\u0026ldquo;हम Tor के rend-spec-v3.txt के परिशिष्ट A.2 का उपयोग नहीं करते, जिसके डिज़ाइन लक्ष्य समान हैं, क्योंकि उसकी ब्लाइंडेड सार्वजनिक कुंजियाँ prime-order subgroup (अभाज्य-आदेश उपसमूह) से बाहर हो सकती हैं, और इसके सुरक्षा निहितार्थ अज्ञात हैं.\u0026rdquo;\nI2P की additive blinding (योगात्मक ब्लाइंडिंग) यह गारंटी देती है कि ब्लाइंडेड कुंजियाँ Ed25519 curve के अभाज्य-क्रम उपसमूह में बनी रहें।\nगणितीय परिभाषाएँ Ed25519 पैरामीटर्स: - B: Ed25519 आधार बिंदु (generator, जनक) = 2^255 - 19 - L: Ed25519 order (क्रम) = 2^252 + 27742317777372353535851937790883648493\nमुख्य चर: - A: Unblinded (ब्लाइंडिंग रहित) 32-बाइट हस्ताक्षर हेतु सार्वजनिक कुंजी (in Destination) - a: Unblinded 32-बाइट हस्ताक्षर हेतु निजी कुंजी - A': Blinded (ब्लाइंडिंग लागू) 32-बाइट हस्ताक्षर हेतु सार्वजनिक कुंजी (एन्क्रिप्टेड LeaseSet में प्रयुक्त) - a': Blinded 32-बाइट हस्ताक्षर हेतु निजी कुंजी - alpha: 32-बाइट blinding factor (ब्लाइंडिंग गुणांक) (गोपनीय)\nसहायक फ़ंक्शंस:\nLEOS2IP(x) \u0026ldquo;Little-Endian (सबसे कम महत्त्वपूर्ण बाइट पहले) Octet String (8-बिट की स्ट्रिंग) का पूर्णांक में रूपांतरण\u0026rdquo;\nकिसी बाइट ऐरे को little-endian (जहाँ सबसे कम महत्त्वपूर्ण बाइट पहले आती है) क्रम से पूर्णांक निरूपण में परिवर्तित करता है।\nH*(x) \u0026ldquo;हैश और रिड्यूस\u0026rdquo;\nH*(x) = (LEOS2IP(SHA512(x))) mod L Ed25519 (एक एलिप्टिक-कर्व हस्ताक्षर एल्गोरिथ्म) की कुंजी निर्माण में जैसा ऑपरेशन होता है, वैसा ही।\nअल्फ़ा पीढ़ी दैनिक रोटेशन: प्रत्येक दिन UTC मध्यरात्रि (00:00:00 UTC) पर नई alpha (एक आंतरिक क्रिप्टोग्राफ़िक पैरामीटर) और blinded keys (ब्लाइंडिंग की गई कुंजियाँ) अनिवार्य रूप से उत्पन्न की जानी चाहिए।\nGENERATE_ALPHA(destination, date, secret) एल्गोरिद्म:\n# Input parameters A = destination\u0026#39;s signing public key (32 bytes) stA = signature type of A (2 bytes, big endian) # 0x0007 for Ed25519 or 0x000b for Red25519 stA\u0026#39; = signature type of blinded key A\u0026#39; (2 bytes, big endian) # Always 0x000b (Red25519) datestring = \u0026#34;YYYYMMDD\u0026#34; (8 bytes ASCII from current UTC date) secret = optional UTF-8 encoded string (zero-length if not used) # Computation keydata = A || stA || stA\u0026#39; # 36 bytes total seed = HKDF( salt=H(\u0026#34;I2PGenerateAlpha\u0026#34;, keydata), ikm=datestring || secret, info=\u0026#34;i2pblinding1\u0026#34;, n=64 ) # Treat seed as 64-byte little-endian integer and reduce alpha = seed mod L सत्यापित पैरामीटर: - Salt personalization (व्यक्तिकरण): \u0026quot;I2PGenerateAlpha\u0026quot; - HKDF info (जानकारी): \u0026quot;i2pblinding1\u0026quot; - आउटपुट: रिडक्शन से पहले 64 बाइट्स - अल्फ़ा वितरण: mod L के बाद Ed25519 निजी कुंजियों की तरह समान वितरण\nनिजी कुंजी ब्लाइंडिंग BLIND_PRIVKEY(a, alpha) एल्गोरिथ्म:\nएन्क्रिप्टेड LeaseSet प्रकाशित करने वाले destination (I2P गंतव्य/पहचान) के मालिक के लिए:\n# For Ed25519 private key (type 7) if sigtype == 7: seed = destination\u0026#39;s signing private key (32 bytes) a = left_half(SHA512(seed)) # 32 bytes a = clamp(a) # Ed25519 clamping # For Red25519 private key (type 11) elif sigtype == 11: a = destination\u0026#39;s signing private key (32 bytes) # No clamping for Red25519 # Additive blinding using scalar arithmetic blinded_privkey = a\u0026#39; = (a + alpha) mod L # Derive blinded public key blinded_pubkey = A\u0026#39; = DERIVE_PUBLIC(a\u0026#39;) महत्वपूर्ण: mod L रिडक्शन निजी और सार्वजनिक कुंजियों के बीच सही बीजगणितीय संबंध बनाए रखने के लिए अत्यावश्यक है।\nPublic Key Blinding (क्रिप्टोग्राफी में वह तकनीक जिसमें सार्वजनिक कुंजी का प्रयोग कर इनपुट/हस्ताक्षर को पहले से छिपा दिया जाता है) BLIND_PUBKEY(A, alpha) एल्गोरिथ्म:\nएन्क्रिप्टेड LeaseSet को प्राप्त करने और सत्यापित करने वाले क्लाइंट्स के लिए:\nalpha = GENERATE_ALPHA(destination, date, secret) A = destination\u0026#39;s signing public key (32 bytes) # Additive blinding using group elements (curve points) blinded_pubkey = A\u0026#39; = A + DERIVE_PUBLIC(alpha) गणितीय समकक्षता:\nदोनों विधियाँ समान परिणाम देती हैं:\nBLIND_PUBKEY(A, alpha) == DERIVE_PUBLIC(BLIND_PRIVKEY(a, alpha)) ऐसा इसलिए है:\nA\u0026#39; = A + [alpha]B = [a]B + [alpha]B = [a + alpha]B (group operation) = DERIVE_PUBLIC(a + alpha mod L) Blinded Keys (ब्लाइंड की गई कुंजियाँ) के साथ हस्ताक्षर बिना ब्लाइंडिंग के LeaseSet हस्ताक्षर:\nunblinded (ब्लाइंडिंग हटाया हुआ) LeaseSet (जो सीधे प्रमाणीकृत क्लाइंट्स को भेजा जाता है) पर हस्ताक्षर इनका उपयोग करके किया जाता है: - मानक Ed25519 (type 7) या Red25519 (type 11) हस्ताक्षर - Unblinded हस्ताक्षर करने की निजी कुंजी - unblinded सार्वजनिक कुंजी से सत्यापित\nऑफलाइन कुंजियों के साथ: - unblinded transient (जिसमें blinding नहीं होता, अस्थायी) निजी कुंजी से हस्ताक्षरित - unblinded transient सार्वजनिक कुंजी से सत्यापित - दोनों का प्रकार 7 या 11 होना चाहिए\nएन्क्रिप्टेड LeaseSet हस्ताक्षर:\nएन्क्रिप्टेड LeaseSet का बाहरी भाग blinded keys (ब्लाइंडेड कुंजियाँ) के साथ Red25519 हस्ताक्षरों का उपयोग करता है।\nRed25519 हस्ताक्षर एल्गोरिदम:\n# Generate per-signature random nonce T = CSRNG(80) # 80 random bytes # Calculate r (differs from Ed25519) r = H*(T || blinded_pubkey || message) # Rest is same as Ed25519 R = [r]B S = (r + H(R || A\u0026#39; || message) * a\u0026#39;) mod L signature = R || S # 64 bytes total Ed25519 से मुख्य अंतर: 1. 80 बाइट के यादृच्छिक डेटा T का उपयोग करता है (न कि निजी कुंजी का हैश) 2. सार्वजनिक कुंजी के मान का सीधे उपयोग करता है (न कि निजी कुंजी का हैश) 3. हर हस्ताक्षर अद्वितीय होता है, भले ही संदेश और कुंजी वही हों\nसत्यापन:\nEd25519 के समान:\n# Parse signature R = signature[0:32] S = signature[32:64] # Verify equation: [S]B = R + [H(R || A\u0026#39; || message)]A\u0026#39; return [S]B == R + [H(R || A\u0026#39; || message)]A\u0026#39; सुरक्षा संबंधी विचार अल्फा वितरण:\nसुरक्षा के लिए, alpha का वितरण unblinded (ब्लाइंडिंग हटाए गए) निजी कुंजियों के समान होना चाहिए। जब Ed25519 (type 7) को Red25519 (type 11) में ब्लाइंडिंग किया जाता है, तो वितरणों में थोड़ा अंतर रहता है।\nसिफारिश: ZCash की आवश्यकताओं को पूरा करने के लिए अनब्लाइंडेड और ब्लाइंडेड दोनों प्रकार की कुंजियों के लिए Red25519 (type 11) का उपयोग करें: \u0026ldquo;पुनः-यादृच्छीकृत सार्वजनिक कुंजी और उसी कुंजी के अंतर्गत हस्ताक्षर(ों) का संयोजन उस मूल कुंजी का खुलासा नहीं करता जिससे उसे पुनः-यादृच्छीकृत किया गया था।\u0026rdquo;\nप्रकार 7 समर्थन: Ed25519 (एक एलिप्टिक-कर्व डिजिटल हस्ताक्षर एल्गोरिथ्म) मौजूदा गंतव्यों के साथ बैकवर्ड संगतता के लिए समर्थित है, लेकिन नए एन्क्रिप्टेड गंतव्यों के लिए प्रकार 11 की अनुशंसा की जाती है।\nदैनिक रोटेशन के लाभ: - Forward secrecy: आज की blinded key से समझौता हो जाए तो भी बीते दिन की कुंजी उजागर नहीं होती - Unlinkability (संबंध न जोड़ा जा सकना): दैनिक रोटेशन DHT (वितरित हैश तालिका) के माध्यम से दीर्घकालिक ट्रैकिंग को रोकता है - कुंजी पृथक्करण: विभिन्न समय अवधियों के लिए अलग-अलग कुंजियाँ\nसंदर्भ: - ZCash प्रोटोकॉल विनिर्देश - अनुभाग 5.4.6.1 - Tor Key Blinding (कुंजी-ब्लाइंडिंग) पर चर्चा - Tor टिकट #8106 कूटलेखन और प्रसंस्करण Subcredential (उप-प्रमाण-पत्र) की व्युत्पत्ति एन्क्रिप्शन से पहले, हम एक क्रेडेंशियल और एक उप-क्रेडेंशियल व्युत्पन्न करते हैं, ताकि एन्क्रिप्टेड परतों को Destination (I2P में एंडपॉइंट/गंतव्य पहचान) की हस्ताक्षर सार्वजनिक कुंजी के ज्ञान से संबद्ध किया जा सके।\nलक्ष्य: यह सुनिश्चित करना कि केवल वे लोग जो Destination की हस्ताक्षर करने वाली सार्वजनिक कुंजी जानते हों, एन्क्रिप्टेड LeaseSet को डिक्रिप्ट कर सकें। पूरा Destination आवश्यक नहीं है।\nप्रमाण-पत्र की गणना A = destination\u0026#39;s signing public key (32 bytes) stA = signature type of A (2 bytes big endian) # 0x0007 for Ed25519 or 0x000b for Red25519 stA\u0026#39; = signature type of blinded key A\u0026#39; (2 bytes big endian) # Always 0x000b (Red25519) keydata = A || stA || stA\u0026#39; # 36 bytes credential = H(\u0026#34;credential\u0026#34;, keydata) # 32 bytes डोमेन पृथक्करण: पर्सनलाइज़ेशन स्ट्रिंग \u0026quot;credential\u0026quot; सुनिश्चित करती है कि यह हैश किसी भी DHT (वितरित हैश तालिका) लुकअप कुंजियों या प्रोटोकॉल में अन्य उपयोगों से टकराव न हो।\nSubcredential (उप-प्रमाण-पत्र) की गणना blindedPublicKey = A\u0026#39; (32 bytes, from blinding process) subcredential = H(\u0026#34;subcredential\u0026#34;, credential || blindedPublicKey) # 32 bytes उद्देश्य: subcredential (उप-क्रेडेंशियल) एन्क्रिप्टेड LeaseSet को इनसे जोड़ता है: 1. विशिष्ट Destination (गंतव्य) (credential के माध्यम से) 2. विशिष्ट blinded key (ब्लाइंडेड कुंजी) (blindedPublicKey के माध्यम से) 3. विशिष्ट दिन (blindedPublicKey के दैनिक रोटेशन के माध्यम से)\nयह रीप्ले हमलों और cross-day linking (अलग-अलग दिनों में गतिविधियों को जोड़कर संबंध निकालना) को रोकता है।\nलेयर 1 एन्क्रिप्शन संदर्भ: लेयर 1 में क्लाइंट प्राधिकरण डेटा शामिल होता है और इसे subcredential (उप-प्रमाणपत्र) से व्युत्पन्न कुंजी से एन्क्रिप्ट किया गया है।\nएन्क्रिप्शन एल्गोरिदम # Prepare input outerInput = subcredential || publishedTimestamp # publishedTimestamp: 4 bytes from Layer 0 # Generate random salt outerSalt = CSRNG(32) # 32 bytes # Derive encryption key and IV keys = HKDF( salt=outerSalt, ikm=outerInput, info=\u0026#34;ELS2_L1K\u0026#34;, # Domain separation n=44 # 32 bytes key + 12 bytes IV ) outerKey = keys[0:31] # 32 bytes (indices 0-31 inclusive) outerIV = keys[32:43] # 12 bytes (indices 32-43 inclusive) # Encrypt and prepend salt outerPlaintext = [Layer 1 data] outerCiphertext = outerSalt || ENCRYPT(outerKey, outerIV, outerPlaintext) आउटपुट: outerCiphertext की लंबाई 32 + len(outerPlaintext) बाइट्स है।\nसुरक्षा गुण: - सॉल्ट समान subcredential (उप-प्रमाण-पत्र) होने पर भी अद्वितीय कुंजी/IV जोड़े सुनिश्चित करता है - संदर्भ स्ट्रिंग \u0026quot;ELS2_L1K\u0026quot; डोमेन पृथक्करण प्रदान करती है - ChaCha20 semantic security (सिफरटेक्स्ट यादृच्छिक से अविभेद्य) प्रदान करता है\nडिक्रिप्शन एल्गोरिदम # Parse salt from ciphertext outerSalt = outerCiphertext[0:31] # First 32 bytes # Derive decryption key and IV (same process as encryption) outerInput = subcredential || publishedTimestamp keys = HKDF( salt=outerSalt, ikm=outerInput, info=\u0026#34;ELS2_L1K\u0026#34;, n=44 ) outerKey = keys[0:31] # 32 bytes outerIV = keys[32:43] # 12 bytes # Decrypt (skip salt bytes) outerPlaintext = DECRYPT(outerKey, outerIV, outerCiphertext[32:end]) सत्यापन: डिक्रिप्शन के बाद, लेयर 2 पर आगे बढ़ने से पहले यह जांचें कि लेयर 1 की संरचना सही ढंग से निर्मित है।\nलेयर 2 एन्क्रिप्शन संदर्भ: लेयर 2 में वास्तविक LeaseSet2 डेटा होता है और इसे ऐसी कुंजी से एन्क्रिप्ट किया जाता है जो authCookie से (यदि प्रति-क्लाइंट प्रमाणीकरण सक्षम है) या रिक्त स्ट्रिंग से (यदि नहीं) व्युत्पन्न होती है।\nएन्क्रिप्शन एल्गोरिथ्म # Determine authCookie based on authorization mode if per_client_auth_enabled: authCookie = [32-byte cookie from client authorization process] else: authCookie = b\u0026#39;\u0026#39; # Zero-length byte array # Prepare input innerInput = authCookie || subcredential || publishedTimestamp # Generate random salt innerSalt = CSRNG(32) # 32 bytes # Derive encryption key and IV keys = HKDF( salt=innerSalt, ikm=innerInput, info=\u0026#34;ELS2_L2K\u0026#34;, # Domain separation n=44 # 32 bytes key + 12 bytes IV ) innerKey = keys[0:31] # 32 bytes innerIV = keys[32:43] # 12 bytes # Encrypt and prepend salt innerPlaintext = [Layer 2 data: LS2 type byte + LeaseSet2 data] innerCiphertext = innerSalt || ENCRYPT(innerKey, innerIV, innerPlaintext) आउटपुट: innerCiphertext की लंबाई 32 + len(innerPlaintext) बाइट्स है।\nKey Binding (कुंजी-संबंधन): - यदि क्लाइंट प्रमाणीकरण नहीं है: केवल subcredential (उप-क्रेडेंशियल) और टाइमस्टैम्प से बंधा होता है - यदि क्लाइंट प्रमाणीकरण सक्षम है: अतिरिक्त रूप से authCookie से भी बंधा होता है (प्रत्येक अधिकृत क्लाइंट के लिए अलग)\nडिक्रिप्शन एल्गोरिथ्म # Determine authCookie (same as encryption) if per_client_auth_enabled: authCookie = [32-byte cookie from client authorization process] else: authCookie = b\u0026#39;\u0026#39; # Zero-length byte array # Parse salt from ciphertext innerSalt = innerCiphertext[0:31] # First 32 bytes # Derive decryption key and IV innerInput = authCookie || subcredential || publishedTimestamp keys = HKDF( salt=innerSalt, ikm=innerInput, info=\u0026#34;ELS2_L2K\u0026#34;, n=44 ) innerKey = keys[0:31] # 32 bytes innerIV = keys[32:43] # 12 bytes # Decrypt (skip salt bytes) innerPlaintext = DECRYPT(innerKey, innerIV, innerCiphertext[32:end]) सत्यापन: डिक्रिप्शन के बाद: 1. सत्यापित करें कि LS2 का टाइप बाइट मान्य है (3 या 7) 2. LeaseSet2 संरचना को पार्स करें 3. सत्यापित करें कि आंतरिक टाइमस्टैम्प बाहरी प्रकाशित टाइमस्टैम्प से मेल खाता है 4. सत्यापित करें कि आंतरिक समाप्ति बाहरी समाप्ति से मेल खाती है 5. LeaseSet2 के हस्ताक्षर का सत्यापन करें\nएन्क्रिप्शन परत का सारांश ┌─────────────────────────────────────────────────┐ │ Layer 0 (Plaintext) │ │ - Blinded public key │ │ - Timestamps │ │ - Signature │ │ │ │ ┌─────────────────────────────────────────┐ │ │ │ Layer 1 (Encrypted with subcredential) │ │ │ │ - Authorization flags │ │ │ │ - Client auth data (if enabled) │ │ │ │ │ │ │ │ ┌────────────────────────────────┐ │ │ │ │ │ Layer 2 (Encrypted with │ │ │ │ │ │ authCookie + subcred) │ │ │ │ │ │ - LeaseSet2 type │ │ │ │ │ │ - LeaseSet2 data │ │ │ │ │ │ - Leases │ │ │ │ │ │ - LS2 signature │ │ │ │ │ └────────────────────────────────┘ │ │ │ └─────────────────────────────────────────┘ │ └─────────────────────────────────────────────────┘ डिक्रिप्शन प्रक्रिया: 1. लेयर 0 के हस्ताक्षर को blinded public key (ब्लाइंडेड पब्लिक की) से सत्यापित करें 2. subcredential (उप-क्रेडेंशियल) का उपयोग करके लेयर 1 को डिक्रिप्ट करें 3. authCookie प्राप्त करने के लिए प्राधिकरण डेटा (यदि उपस्थित हो) को प्रोसेस करें 4. authCookie और subcredential का उपयोग करके लेयर 2 को डिक्रिप्ट करें 5. LeaseSet2 को सत्यापित करें और पार्स करें\nप्रति-क्लाइंट अधिकार-प्रदान अवलोकन जब प्रति-क्लाइंट प्राधिकरण सक्षम होता है, तो सर्वर अधिकृत क्लाइंटों की सूची बनाए रखता है। प्रत्येक क्लाइंट के पास key material (कुंजी-सामग्री) होता है, जिसे सुरक्षित रूप से out-of-band (मुख्य चैनल से अलग माध्यम) प्रेषित किया जाना चाहिए।\nदो प्राधिकरण तंत्र: 1. DH (Diffie-Hellman) क्लाइंट प्राधिकरण: अधिक सुरक्षित, X25519 key agreement का उपयोग करता है 2. PSK (Pre-Shared Key — पूर्व-साझा कुंजी) प्राधिकरण: सरल, सममित कुंजियों का उपयोग करता है\nसामान्य सुरक्षा गुणधर्म: - क्लाइंट सदस्यता गोपनीयता: पर्यवेक्षक क्लाइंटों की संख्या देख सकते हैं लेकिन विशिष्ट क्लाइंटों की पहचान नहीं कर सकते - गुमनाम क्लाइंट जोड़/निरसन: यह ट्रैक नहीं किया जा सकता कि विशिष्ट क्लाइंट कब जोड़े या हटाए गए हैं - 8-बाइट क्लाइंट पहचानकर्ता टकराव की संभावना: ~18 क्विंटिलियन में 1 (नगण्य)\nDH (डिफ़ी-हेलमैन) क्लाइंट प्राधिकरण सारांश: प्रत्येक क्लाइंट एक X25519 कुंजी-युग्म उत्पन्न करता है और अपनी सार्वजनिक कुंजी को एक सुरक्षित आउट-ऑफ-बैंड चैनल के माध्यम से सर्वर को भेजता है। सर्वर अस्थायी DH का उपयोग करके प्रत्येक क्लाइंट के लिए एक अद्वितीय authCookie को कूटबद्ध करता है।\nक्लाइंट कुंजी सृजन # Client generates keypair csk_i = GENERATE_PRIVATE() # 32-byte X25519 private key cpk_i = DERIVE_PUBLIC(csk_i) # 32-byte X25519 public key # Client sends cpk_i to server via secure out-of-band channel # Client KEEPS csk_i secret (never transmitted) सुरक्षा लाभ: क्लाइंट की निजी कुंजी कभी उनके डिवाइस से बाहर नहीं जाती। out-of-band transmission (मुख्य संचार चैनल से अलग माध्यम द्वारा प्रेषण) को अवरोधित करने वाला विरोधी X25519 DH को तोड़े बिना भविष्य के एन्क्रिप्टेड LeaseSets को डिक्रिप्ट नहीं कर सकता।\nसर्वर प्रसंस्करण # Server generates new auth cookie and ephemeral keypair authCookie = CSRNG(32) # 32-byte cookie esk = GENERATE_PRIVATE() # 32-byte ephemeral private key epk = DERIVE_PUBLIC(esk) # 32-byte ephemeral public key # For each authorized client i for cpk_i in authorized_clients: # Perform DH key agreement sharedSecret = DH(esk, cpk_i) # 32 bytes # Derive client-specific encryption key authInput = sharedSecret || cpk_i || subcredential || publishedTimestamp okm = HKDF( salt=epk, # Ephemeral public key as salt ikm=authInput, info=\u0026#34;ELS2_XCA\u0026#34;, # Domain separation n=52 # 32 key + 12 IV + 8 ID ) # Extract components clientKey_i = okm[0:31] # 32 bytes clientIV_i = okm[32:43] # 12 bytes clientID_i = okm[44:51] # 8 bytes # Encrypt authCookie for this client clientCookie_i = ENCRYPT(clientKey_i, clientIV_i, authCookie) # Store [clientID_i, clientCookie_i] entry in Layer 1 लेयर 1 डेटा संरचना:\nephemeralPublicKey (32 bytes) clients (2 bytes) = N [clientID_1 (8 bytes) || clientCookie_1 (32 bytes)] [clientID_2 (8 bytes) || clientCookie_2 (32 bytes)] ... [clientID_N (8 bytes) || clientCookie_N (32 bytes)] सर्वर अनुशंसाएँ: - प्रत्येक प्रकाशित एन्क्रिप्टेड LeaseSet के लिए नया अस्थायी कुंजी-युग्म उत्पन्न करें - स्थिति-आधारित ट्रैकिंग रोकने के लिए क्लाइंट क्रम को यादृच्छिक करें - वास्तविक क्लाइंट संख्या छिपाने के लिए डमी प्रविष्टियाँ जोड़ने पर विचार करें\nक्लाइंट प्रसंस्करण # Client has: csk_i (their private key), destination, date, secret # Client receives: encrypted LeaseSet with epk in Layer 1 # Perform DH key agreement with server\u0026#39;s ephemeral public key sharedSecret = DH(csk_i, epk) # 32 bytes # Derive expected client identifier and decryption key cpk_i = DERIVE_PUBLIC(csk_i) # Client\u0026#39;s own public key authInput = sharedSecret || cpk_i || subcredential || publishedTimestamp okm = HKDF( salt=epk, ikm=authInput, info=\u0026#34;ELS2_XCA\u0026#34;, n=52 ) clientKey_i = okm[0:31] # 32 bytes clientIV_i = okm[32:43] # 12 bytes clientID_i = okm[44:51] # 8 bytes # Search Layer 1 authorization data for clientID_i for (clientID, clientCookie) in layer1_auth_entries: if clientID == clientID_i: # Found matching entry, decrypt authCookie authCookie = DECRYPT(clientKey_i, clientIV_i, clientCookie) # Use authCookie to decrypt Layer 2 break else: # No matching entry - client not authorized or revoked raise AuthorizationError(\u0026#34;Client not authorized\u0026#34;) क्लाइंट त्रुटि प्रबंधन: - यदि clientID_i नहीं मिला: क्लाइंट रद्द कर दिया गया है या कभी अधिकृत नहीं किया गया - यदि डिक्रिप्शन विफल हो: डेटा भ्रष्ट है या कुंजियाँ गलत हैं (अत्यंत दुर्लभ) - रद्दीकरण का पता लगाने के लिए क्लाइंट्स को नियमित रूप से पुनः फ़ेच करना चाहिए\nPSK (पूर्व-साझा कुंजी) क्लाइंट प्राधिकरण अवलोकन: प्रत्येक क्लाइंट के पास एक पूर्व-साझा 32-बाइट सममित कुंजी होती है। सर्वर प्रत्येक क्लाइंट की PSK (पूर्व-साझा कुंजी) का उपयोग करके उसी authCookie को एन्क्रिप्ट करता है।\nकुंजी निर्माण # Option 1: Client generates key psk_i = CSRNG(32) # 32-byte pre-shared key # Client sends psk_i to server via secure out-of-band channel # Option 2: Server generates key psk_i = CSRNG(32) # 32-byte pre-shared key # Server sends psk_i to one or more clients via secure out-of-band channel सुरक्षा नोट: आवश्यकता होने पर एक ही PSK (pre-shared key, पूर्व-साझा कुंजी) को कई क्लाइंट्स के बीच साझा किया जा सकता है (जिससे \u0026ldquo;समूह\u0026rdquo; प्राधिकरण बनता है)।\nसर्वर प्रसंस्करण # Server generates new auth cookie and salt authCookie = CSRNG(32) # 32-byte cookie authSalt = CSRNG(32) # 32-byte salt # For each authorized client i for psk_i in authorized_clients: # Derive client-specific encryption key authInput = psk_i || subcredential || publishedTimestamp okm = HKDF( salt=authSalt, ikm=authInput, info=\u0026#34;ELS2PSKA\u0026#34;, # Domain separation n=52 # 32 key + 12 IV + 8 ID ) # Extract components clientKey_i = okm[0:31] # 32 bytes clientIV_i = okm[32:43] # 12 bytes clientID_i = okm[44:51] # 8 bytes # Encrypt authCookie for this client clientCookie_i = ENCRYPT(clientKey_i, clientIV_i, authCookie) # Store [clientID_i, clientCookie_i] entry in Layer 1 लेयर 1 डेटा संरचना:\nauthSalt (32 bytes) clients (2 bytes) = N [clientID_1 (8 bytes) || clientCookie_1 (32 bytes)] [clientID_2 (8 bytes) || clientCookie_2 (32 bytes)] ... [clientID_N (8 bytes) || clientCookie_N (32 bytes)] क्लाइंट प्रसंस्करण # Client has: psk_i (their pre-shared key), destination, date, secret # Client receives: encrypted LeaseSet with authSalt in Layer 1 # Derive expected client identifier and decryption key authInput = psk_i || subcredential || publishedTimestamp okm = HKDF( salt=authSalt, ikm=authInput, info=\u0026#34;ELS2PSKA\u0026#34;, n=52 ) clientKey_i = okm[0:31] # 32 bytes clientIV_i = okm[32:43] # 12 bytes clientID_i = okm[44:51] # 8 bytes # Search Layer 1 authorization data for clientID_i for (clientID, clientCookie) in layer1_auth_entries: if clientID == clientID_i: # Found matching entry, decrypt authCookie authCookie = DECRYPT(clientKey_i, clientIV_i, clientCookie) # Use authCookie to decrypt Layer 2 break else: # No matching entry - client not authorized or revoked raise AuthorizationError(\u0026#34;Client not authorized\u0026#34;) तुलना और अनुशंसाएँ Feature DH Authorization PSK Authorization Key ExchangeAsymmetric (X25519)Symmetric (shared secret) SecurityHigher (forward secrecy)Lower (depends on PSK secrecy) Client PrivacyPrivate key never transmittedPSK must be transmitted securely PerformanceN+1 DH operationsNo DH operations Key SharingOne key per clientCan share key among multiple clients Revocation DetectionAdversary cannot tell when revokedAdversary can track revocation if PSK intercepted Use CaseHigh security requirementsPerformance-critical or group access **अनुशंसा:** - **DH प्राधिकरण का उपयोग करें** उच्च-सुरक्षा अनुप्रयोगों के लिए, जहाँ forward secrecy (आगे की गोपनीयता) महत्वपूर्ण हो - **PSK (pre-shared key, पहले से साझा कुंजी) प्राधिकरण का उपयोग करें** जब प्रदर्शन अत्यंत महत्वपूर्ण हो या क्लाइंट समूहों का प्रबंधन करना हो - **PSK को कभी भी पुनः उपयोग न करें** अलग-अलग सेवाओं या समयावधियों में - **हमेशा सुरक्षित चैनलों का उपयोग करें** कुंजी वितरण के लिए (उदा., Signal, OTR, PGP) सुरक्षा संबंधी विचार क्लाइंट सदस्यता गोपनीयता:\nदोनों तंत्र क्लाइंट सदस्यता की गोपनीयता इन माध्यमों से प्रदान करते हैं: 1. एन्क्रिप्टेड क्लाइंट पहचानकर्ता: HKDF आउटपुट से व्युत्पन्न 8-बाइट clientID 2. अविभेद्य कुकीज़: सभी 32-बाइट clientCookie मान यादृच्छिक प्रतीत होते हैं 3. क्लाइंट-विशिष्ट मेटाडेटा नहीं: किस प्रविष्टि का संबंध किस क्लाइंट से है, यह पहचानने का कोई तरीका नहीं\nएक पर्यवेक्षक देख सकता है: - अधिकृत क्लाइंट्स की संख्या (clients फ़ील्ड से) - समय के साथ क्लाइंट संख्या में परिवर्तन\nएक पर्यवेक्षक यह नहीं देख सकता: - कौन से विशिष्ट क्लाइंट अधिकृत हैं - कब विशिष्ट क्लाइंट जोड़े या हटाए जाते हैं (यदि गिनती समान रहती है) - क्लाइंट की पहचान बताने वाली कोई भी जानकारी\nयादृच्छिकरण संबंधी सिफारिशें:\nसर्वरों को हर बार जब वे एक एन्क्रिप्टेड LeaseSet उत्पन्न करते हैं, क्लाइंट क्रम को यादृच्छिक करना चाहिए:\nimport random # Before serializing auth_entries = [(clientID_i, clientCookie_i) for each client] random.shuffle(auth_entries) # Now serialize in randomized order लाभ: - क्लाइंट्स को सूची में अपनी स्थिति जानने से रोकता है - स्थिति परिवर्तन के आधार पर होने वाले inference attacks (अनुमान-आधारित हमले) को रोकता है - क्लाइंट जोड़/निरस्तीकरण को अप्रभेद्य बनाता है\nक्लाइंट की संख्या छिपाना:\nसर्वर यादृच्छिक डमी प्रविष्टियाँ जोड़ सकते हैं:\n# Add dummy entries num_dummies = random.randint(0, max_dummies) for _ in range(num_dummies): dummy_id = CSRNG(8) dummy_cookie = CSRNG(32) auth_entries.append((dummy_id, dummy_cookie)) # Randomize all entries (real + dummy) random.shuffle(auth_entries) लागत: डमी प्रविष्टियाँ एन्क्रिप्टेड LeaseSet का आकार बढ़ाती हैं (प्रत्येक 40 बाइट).\nAuthCookie (प्रमाणीकरण कुकी) का रोटेशन:\nसर्वरों को एक नया authCookie उत्पन्न करना चाहिए: - जब भी एक एन्क्रिप्टेड LeaseSet प्रकाशित किया जाए (आम तौर पर हर कुछ घंटों में) - किसी क्लाइंट को रद्द करने के तुरंत बाद - नियमित अनुसूची पर (उदा., प्रतिदिन), भले ही किसी क्लाइंट में कोई बदलाव न हो\nलाभ: - यदि authCookie से समझौता हो जाए, तो उजागर होने को सीमित करता है - रद्द किए गए क्लाइंट्स की पहुँच जल्दी समाप्त हो जाए, यह सुनिश्चित करता है - Layer 2 के लिए forward secrecy (आगे की गोपनीयता) प्रदान करता है\nएन्क्रिप्टेड LeaseSets के लिए Base32 एड्रेसिंग अवलोकन पारंपरिक I2P base32 पते में केवल Destination (I2P में सेवा/एंडपॉइंट की क्रिप्टोग्राफिक पहचान) का हैश शामिल होता है (32 बाइट → 52 अक्षर)। यह एन्क्रिप्टेड LeaseSets के लिए अपर्याप्त है क्योंकि:\nक्लाइंट को ब्लाइंडेड सार्वजनिक कुंजी व्युत्पन्न करने के लिए अनब्लाइंडेड सार्वजनिक कुंजी की आवश्यकता होती है क्लाइंट को उचित कुंजी व्युत्पत्ति के लिए हस्ताक्षर प्रकार (अनब्लाइंडेड और ब्लाइंडेड) की आवश्यकता होती है सिर्फ हैश से यह जानकारी उपलब्ध नहीं होती समाधान: एक नया base32 (32-आधारित एन्कोडिंग) प्रारूप जिसमें सार्वजनिक कुंजी और हस्ताक्षर प्रकार शामिल हैं।\nपता प्रारूप विनिर्देश डिकोड की गई संरचना (35 बाइट्स):\n┌─────────────────────────────────────────────────────┐ │ Byte 0 │ Byte 1 │ Byte 2 │ Bytes 3-34 │ │ Flags │ Unblind │ Blinded │ Public Key │ │ (XOR) │ SigType │ SigType │ (32 bytes) │ │ │ (XOR) │ (XOR) │ │ └─────────────────────────────────────────────────────┘ पहले 3 बाइट्स (Checksum के साथ XOR):\nपहले 3 बाइट्स में ऐसा मेटाडाटा होता है जिसे CRC-32 चेकसम के कुछ हिस्सों के साथ XOR किया गया है:\n# Data structure before XOR flags = 0x00 # 1 byte (reserved for future use) unblinded_sigtype = 0x07 or 0x0b # 1 byte (7 or 11) blinded_sigtype = 0x0b # 1 byte (always 11) # Compute CRC-32 checksum of public key checksum = crc32(pubkey) # 4-byte CRC-32 of bytes 3-34 # XOR first 3 bytes with parts of checksum data[0] = flags XOR (checksum \u0026gt;\u0026gt; 24) \u0026amp; 0xFF data[1] = unblinded_sigtype XOR (checksum \u0026gt;\u0026gt; 16) \u0026amp; 0xFF data[2] = blinded_sigtype XOR (checksum \u0026gt;\u0026gt; 8) \u0026amp; 0xFF # Bytes 3-34 contain the unmodified 32-byte public key data[3:34] = pubkey चेकसम के गुण: - मानक CRC-32 बहुपद का उपयोग करता है - गलत-नकारात्मक दर: ~16 मिलियन में 1 - पते में टाइपिंग गलतियों के लिए त्रुटि पहचान प्रदान करता है - प्रमाणीकरण के लिए उपयोग नहीं किया जा सकता (क्रिप्टोग्राफ़िक रूप से सुरक्षित नहीं)\nकूटबद्ध प्रारूप:\nBase32Encode(35 bytes) || \u0026#34;.b32.i2p\u0026#34; विशेषताएँ: - कुल अक्षर: 56 (35 बाइट्स × 8 बिट्स ÷ 5 बिट्स प्रति अक्षर) - प्रत्यय: \u0026ldquo;.b32.i2p\u0026rdquo; (पारंपरिक base32 के समान) - कुल लंबाई: 56 + 8 = 64 अक्षर (null terminator (स्ट्रिंग के अंत का NULL वर्ण) को छोड़कर)\nBase32 एन्कोडिंग: - वर्णमाला: abcdefghijklmnopqrstuvwxyz234567 (मानक RFC 4648) - अंत में 5 अप्रयुक्त बिट 0 होने ही चाहिए - केस-असंवेदनशील (प्रचलनानुसार छोटे अक्षरों में)\nपता निर्माण import struct from zlib import crc32 import base64 def generate_encrypted_b32_address(pubkey, unblinded_sigtype, blinded_sigtype): \u0026#34;\u0026#34;\u0026#34; Generate base32 address for encrypted LeaseSet. Args: pubkey: 32-byte public key (bytes) unblinded_sigtype: Unblinded signature type (7 or 11) blinded_sigtype: Blinded signature type (always 11) Returns: String address ending in .b32.i2p \u0026#34;\u0026#34;\u0026#34; # Verify inputs assert len(pubkey) == 32, \u0026#34;Public key must be 32 bytes\u0026#34; assert unblinded_sigtype in [7, 11], \u0026#34;Unblinded sigtype must be 7 or 11\u0026#34; assert blinded_sigtype == 11, \u0026#34;Blinded sigtype must be 11\u0026#34; # Compute CRC-32 of public key checksum = crc32(pubkey) \u0026amp; 0xFFFFFFFF # Ensure 32-bit unsigned # Prepare metadata bytes flags = 0x00 # XOR metadata with checksum parts byte0 = flags ^ ((checksum \u0026gt;\u0026gt; 24) \u0026amp; 0xFF) byte1 = unblinded_sigtype ^ ((checksum \u0026gt;\u0026gt; 16) \u0026amp; 0xFF) byte2 = blinded_sigtype ^ ((checksum \u0026gt;\u0026gt; 8) \u0026amp; 0xFF) # Construct 35-byte data data = bytes([byte0, byte1, byte2]) + pubkey # Base32 encode (standard alphabet) # Python\u0026#39;s base64 module uses uppercase by default b32 = base64.b32encode(data).decode(\u0026#39;ascii\u0026#39;).lower().rstrip(\u0026#39;=\u0026#39;) # Construct full address address = b32 + \u0026#34;.b32.i2p\u0026#34; return address पते का विश्लेषण import struct from zlib import crc32 import base64 def parse_encrypted_b32_address(address): \u0026#34;\u0026#34;\u0026#34; Parse base32 address for encrypted LeaseSet. Args: address: String address ending in .b32.i2p Returns: Tuple of (pubkey, unblinded_sigtype, blinded_sigtype) Raises: ValueError: If address is invalid or checksum fails \u0026#34;\u0026#34;\u0026#34; # Remove suffix if not address.endswith(\u0026#39;.b32.i2p\u0026#39;): raise ValueError(\u0026#34;Invalid address suffix\u0026#34;) b32 = address[:-8] # Remove \u0026#34;.b32.i2p\u0026#34; # Verify length (56 characters for 35 bytes) if len(b32) != 56: raise ValueError(f\u0026#34;Invalid length: {len(b32)} (expected 56)\u0026#34;) # Base32 decode # Add padding if needed padding_needed = (8 - (len(b32) % 8)) % 8 b32_padded = b32.upper() + \u0026#39;=\u0026#39; * padding_needed try: data = base64.b32decode(b32_padded) except Exception as e: raise ValueError(f\u0026#34;Invalid base32 encoding: {e}\u0026#34;) # Verify decoded length if len(data) != 35: raise ValueError(f\u0026#34;Invalid decoded length: {len(data)} (expected 35)\u0026#34;) # Extract public key pubkey = data[3:35] # Compute CRC-32 for verification checksum = crc32(pubkey) \u0026amp; 0xFFFFFFFF # Un-XOR metadata bytes flags = data[0] ^ ((checksum \u0026gt;\u0026gt; 24) \u0026amp; 0xFF) unblinded_sigtype = data[1] ^ ((checksum \u0026gt;\u0026gt; 16) \u0026amp; 0xFF) blinded_sigtype = data[2] ^ ((checksum \u0026gt;\u0026gt; 8) \u0026amp; 0xFF) # Verify expected values if flags != 0x00: raise ValueError(f\u0026#34;Invalid flags: {flags:#x} (expected 0x00)\u0026#34;) if unblinded_sigtype not in [7, 11]: raise ValueError(f\u0026#34;Invalid unblinded sigtype: {unblinded_sigtype} (expected 7 or 11)\u0026#34;) if blinded_sigtype != 11: raise ValueError(f\u0026#34;Invalid blinded sigtype: {blinded_sigtype} (expected 11)\u0026#34;) return pubkey, unblinded_sigtype, blinded_sigtype पारंपरिक Base32 (बेस 32 एन्कोडिंग) से तुलना Feature Traditional B32 Encrypted LS2 B32 ContentSHA-256 hash of DestinationPublic key + signature types Decoded Size32 bytes35 bytes Encoded Length52 characters56 characters Suffix.b32.i2p.b32.i2p Total Length60 chars64 chars ChecksumNoneCRC-32 (XOR'd into first 3 bytes) Use CaseRegular destinationsEncrypted LeaseSet destinations ### उपयोग संबंधी प्रतिबंध BitTorrent असंगतता:\nएन्क्रिप्टेड LS2 (leaseSet का नया संस्करण) पते BitTorrent के compact announce replies (ट्रैकर के उत्तर का संक्षिप्त प्रारूप) के साथ उपयोग नहीं किए जा सकते:\nCompact announce reply format: ┌────────────────────────────┐ │ 32-byte destination hash │ ← Only hash, no signature types │ 2-byte port │ └────────────────────────────┘ समस्या: संक्षिप्त फ़ॉर्मैट में केवल हैश (32 bytes) शामिल होता है, जिसमें हस्ताक्षर प्रकारों या सार्वजनिक कुंजी की जानकारी के लिए कोई स्थान नहीं है।\nसमाधान: पूर्ण announce replies (ट्रैकर के \u0026lsquo;announce\u0026rsquo; अनुरोध के उत्तर) का उपयोग करें या ऐसे HTTP-आधारित ट्रैकर उपयोग करें जो पूर्ण पतों का समर्थन करते हों।\nएड्रेस बुक एकीकरण यदि किसी क्लाइंट की पता पुस्तिका में पूर्ण Destination (गंतव्य पहचान) हो:\nपूर्ण Destination (I2P की गंतव्य पहचान) संग्रहीत करें (इसमें सार्वजनिक कुंजी शामिल है) हैश के आधार पर रिवर्स लुकअप का समर्थन करें जब एन्क्रिप्टेड LS2 मिले, तो पता पुस्तिका से सार्वजनिक कुंजी प्राप्त करें यदि पूर्ण Destination पहले से ज्ञात है तो नए base32 प्रारूप की आवश्यकता नहीं एड्रेस बुक के वे प्रारूप जो एन्क्रिप्टेड LS2 (LeaseSet का संस्करण 2) का समर्थन करते हैं: - hosts.txt जिसमें पूर्ण destination strings हों - SQLite डेटाबेस जिनमें destination कॉलम हो - JSON/XML प्रारूप जिनमें पूर्ण destination डेटा हो\nकार्यान्वयन के उदाहरण उदाहरण 1: पता उत्पन्न करें\n# Ed25519 destination example pubkey = bytes.fromhex(\u0026#39;a\u0026#39; * 64) # 32-byte public key unblinded_type = 7 # Ed25519 blinded_type = 11 # Red25519 (always) address = generate_encrypted_b32_address(pubkey, unblinded_type, blinded_type) print(f\u0026#34;Address: {address}\u0026#34;) # Output: 56 base32 characters + .b32.i2p उदाहरण 2: पार्स करें और सत्यापित करें\naddress = \u0026#34;abc...xyz.b32.i2p\u0026#34; # 56 chars + suffix try: pubkey, unblinded, blinded = parse_encrypted_b32_address(address) print(f\u0026#34;Public Key: {pubkey.hex()}\u0026#34;) print(f\u0026#34;Unblinded SigType: {unblinded}\u0026#34;) print(f\u0026#34;Blinded SigType: {blinded}\u0026#34;) except ValueError as e: print(f\u0026#34;Invalid address: {e}\u0026#34;) उदाहरण 3: Destination से रूपांतरण\ndef destination_to_encrypted_b32(destination): \u0026#34;\u0026#34;\u0026#34; Convert full Destination to encrypted LS2 base32 address. Args: destination: I2P Destination object Returns: Base32 address string \u0026#34;\u0026#34;\u0026#34; # Extract public key and signature type from destination pubkey = destination.signing_public_key # 32 bytes sigtype = destination.sig_type # 7 or 11 # Blinded type is always 11 (Red25519) blinded_type = 11 # Generate address return generate_encrypted_b32_address(pubkey, sigtype, blinded_type) सुरक्षा संबंधी विचार गोपनीयता: - Base32 पता सार्वजनिक कुंजी को प्रकट करता है - यह जानबूझकर किया गया है और प्रोटोकॉल के लिए आवश्यक है - न तो निजी कुंजी का खुलासा करता है और न ही सुरक्षा से समझौता करता है - सार्वजनिक कुंजियाँ डिज़ाइन के अनुसार सार्वजनिक जानकारी होती हैं\nटकराव प्रतिरोध: - CRC-32 केवल 32 बिट का टकराव प्रतिरोध प्रदान करता है - क्रिप्टोग्राफ़िक रूप से सुरक्षित नहीं है (केवल त्रुटि पहचान के लिए उपयोग करें) - प्रमाणीकरण के लिए चेकसम पर निर्भर न रहें - पूर्ण गंतव्य सत्यापन अभी भी आवश्यक है\nपता सत्यापन: - उपयोग से पहले हमेशा checksum (चेकसम) का सत्यापन करें - अमान्य signature types (हस्ताक्षर प्रकार) वाले पतों को अस्वीकार करें - यह सत्यापित करें कि public key (सार्वजनिक कुंजी) on the curve (elliptic curve पर वैध बिंदु) है (कार्यान्वयन-विशिष्ट)\nसंदर्भ: - प्रस्ताव 149: एन्क्रिप्टेड LS2 के लिए B32 - B32 एड्रेसिंग विनिर्देश - I2P नामकरण विनिर्देश ऑफ़लाइन कुंजियों का समर्थन अवलोकन ऑफ़लाइन कुंजियाँ मुख्य हस्ताक्षर कुंजी को ऑफ़लाइन (कोल्ड स्टोरेज) रखने की अनुमति देती हैं, जबकि दैनिक संचालन के लिए एक अस्थायी हस्ताक्षर कुंजी का उपयोग किया जाता है। यह उच्च-सुरक्षा सेवाओं के लिए अत्यंत महत्वपूर्ण है।\nएन्क्रिप्टेड LS2 की विशिष्ट आवश्यकताएँ: - अस्थायी कुंजियाँ ऑफलाइन उत्पन्न की जानी चाहिएँ - Blinded private keys (ब्लाइंडिंग: निजी कुंजी को ऐसा रूप देना कि उसे मूल से जोड़ा न जा सके) पूर्व-उत्पन्न होनी चाहिएँ (प्रति दिन एक) - अस्थायी और Blinded कुंजियाँ दोनों बैचों में प्रदान की जानी चाहिएँ - मानकीकृत फ़ाइल प्रारूप अभी परिभाषित नहीं किया गया है (विशिष्टता में TODO)\nऑफ़लाइन कुंजी संरचना लेयर 0 अस्थायी कुंजी डेटा (जब फ्लैग बिट 0 = 1 हो):\n┌───────────────────────────────────────────────────┐ │ Expires Timestamp │ 4 bytes (seconds) │ │ Transient Sig Type │ 2 bytes (big endian) │ │ Transient Signing Pubkey│ Variable (sigtype len) │ │ Signature (by blinded) │ 64 bytes (Red25519) │ └───────────────────────────────────────────────────┘ हस्ताक्षर कवरेज: ऑफ़लाइन कुंजी ब्लॉक में मौजूद हस्ताक्षर निम्नलिखित को आवृत करता है: - समाप्ति टाइमस्टैम्प (4 बाइट्स) - अस्थायी हस्ताक्षर प्रकार (2 बाइट्स) - अस्थायी हस्ताक्षर हेतु सार्वजनिक कुंजी (परिवर्ती)\nइस हस्ताक्षर का सत्यापन blinded public key (blinded यानी मास्क/छिपाई गई public key) का उपयोग करके किया जाता है, जिससे सिद्ध होता है कि blinded private key (blinded यानी मास्क/छिपाई गई private key) रखने वाली इकाई ने इस अस्थायी कुंजी को अधिकृत किया है।\nकुंजी उत्पन्न करने की प्रक्रिया Offline Keys के साथ कूटबद्ध LeaseSet के लिए:\nअस्थायी कुंजी-युग्म उत्पन्न करें (ऑफ़लाइन, कोल्ड स्टोरेज में):\n# For each day in future for date in future_dates: # Generate daily transient keypair transient_privkey = generate_red25519_privkey() # Type 11 transient_pubkey = derive_public(transient_privkey) # Store for later delivery keys[date] = (transient_privkey, transient_pubkey) Generate daily blinded keypairs (offline, in cold storage):\nप्रत्येक दिन के लिए for date in future_dates: # Derive alpha for this date datestring = date.strftime(\u0026quot;%Y%m%d\u0026quot;) # \u0026quot;YYYYMMDD\u0026quot; alpha = GENERATE_ALPHA(destination, datestring, secret) # Blind the signing private key a = destination_signing_privkey # Type 7 or 11 blinded_privkey = BLIND_PRIVKEY(a, alpha) # Result is type 11 blinded_pubkey = DERIVE_PUBLIC(blinded_privkey) # Store for later delivery blinded_keys[date] = (blinded_privkey, blinded_pubkey) 3. **Sign transient keys with blinded keys** (offline): ```python for date in future_dates: transient_pubkey = keys[date][1] blinded_privkey = blinded_keys[date][0] # Create signature data expires = int((date + timedelta(days=1)).timestamp()) sig_data = struct.pack(\u0026#39;\u0026gt;I\u0026#39;, expires) # 4 bytes sig_data += struct.pack(\u0026#39;\u0026gt;H\u0026#39;, 11) # Transient type (Red25519) sig_data += transient_pubkey # 32 bytes # Sign with blinded private key signature = RED25519_SIGN(blinded_privkey, sig_data) # Package for delivery offline_sig_blocks[date] = { \u0026#39;expires\u0026#39;: expires, \u0026#39;transient_type\u0026#39;: 11, \u0026#39;transient_pubkey\u0026#39;: transient_pubkey, \u0026#39;signature\u0026#39;: signature } Package for delivery to router: प्रत्येक तिथि के लिए delivery_package[date] = { 'transient_privkey': keys[date][0], 'transient_pubkey': keys[date][1], 'blinded_privkey': blinded_keys[date][0], 'blinded_pubkey': blinded_keys[date][1], 'offline_sig_block': offline_sig_blocks[date] }\n### Router Usage **Daily Key Loading:** ```python # UTC के अनुसार मध्यरात्रि पर (या प्रकाशन से पहले) date = datetime.utcnow().date() # आज के लिए कुंजियाँ लोड करें today_keys = load_delivery_package(date) transient_privkey = today_keys[\u0026#39;transient_privkey\u0026#39;] transient_pubkey = today_keys[\u0026#39;transient_pubkey\u0026#39;] blinded_privkey = today_keys[\u0026#39;blinded_privkey\u0026#39;] blinded_pubkey = today_keys[\u0026#39;blinded_pubkey\u0026#39;] offline_sig_block = today_keys[\u0026#39;offline_sig_block\u0026#39;] # आज के एन्क्रिप्टेड LeaseSet के लिए इन कुंजियों का उपयोग करें Publishing Process:\n# 1. आंतरिक LeaseSet2 बनाएँ inner_ls2 = create_leaseset2( destinations, leases, expires, signing_key=transient_privkey # Use transient key ) # 2. लेयर 2 को एन्क्रिप्ट करें layer2_ciphertext = encrypt_layer2(inner_ls2, authCookie, subcredential, timestamp) # 3. प्राधिकरण डेटा के साथ लेयर 1 बनाएँ layer1_plaintext = create_layer1(authorization_data, layer2_ciphertext) # 4. लेयर 1 को एन्क्रिप्ट करें layer1_ciphertext = encrypt_layer1(layer1_plaintext, subcredential, timestamp) # 5. ऑफ़लाइन हस्ताक्षर ब्लॉक के साथ Layer 0 (परत 0) बनाएँ layer0 = create_layer0( blinded_pubkey, timestamp, expires, flags=0x0001, # Bit 0 set (offline keys present) offline_sig_block=offline_sig_block, layer1_ciphertext=layer1_ciphertext ) # 6. लेयर 0 पर अस्थायी निजी कुंजी से हस्ताक्षर करें signature = RED25519_SIGN(transient_privkey, layer0) # 7. हस्ताक्षर संलग्न करें और प्रकाशित करें encrypted_leaseset = layer0 + signature publish_to_netdb(encrypted_leaseset) Security Considerations Tracking via Offline Signature Block:\nThe offline signature block is in plaintext (Layer 0). An adversary scraping floodfills could:\nTrack the same encrypted LeaseSet across multiple days Correlate encrypted LeaseSets even though blinded keys change daily Mitigation: Generate new transient keys daily (in addition to blinded keys):\n# हर दिन नई अस्थायी और नई blinded keys (ब्लाइंडेड कुंजियाँ) दोनों उत्पन्न करें for date in future_dates: # New transient keypair for this day transient_privkey = generate_red25519_privkey() transient_pubkey = derive_public(transient_privkey) # New blinded keypair for this day alpha = GENERATE_ALPHA(destination, datestring, secret) blinded_privkey = BLIND_PRIVKEY(signing_privkey, alpha) blinded_pubkey = DERIVE_PUBLIC(blinded_privkey) # Sign new transient key with new blinded key sig = RED25519_SIGN(blinded_privkey, transient_pubkey || metadata) # Now offline sig block changes daily Benefits:\nPrevents tracking across days via offline signature block Provides same security as encrypted LS2 without offline keys Each day appears completely independent Cost:\nMore keys to generate and store More complex key management File Format (TODO) Current Status: No standardized file format defined for batch key delivery.\nRequirements for Future Format:\nMust support multiple dates:\nBatch delivery of 30+ days worth of keys Clear date association for each key set Must include all necessary data:\nTransient private key Transient public key Blinded private key Blinded public key Pre-computed offline signature block Expiration timestamps Should be tamper-evident:\nChecksums or signatures over entire file Integrity verification before loading Should be encrypted:\nKeys are sensitive material Encrypt file with router\u0026rsquo;s key or passphrase Proposed Format Example (JSON, encrypted):\n{ \u0026#34;version\u0026#34;: 1, \u0026#34;destination_hash\u0026#34;: \u0026#34;base64...\u0026#34;, \u0026#34;keys\u0026#34;: [ { \u0026#34;date\u0026#34;: \u0026#34;2025-10-15\u0026#34;, \u0026#34;transient\u0026#34;: { \u0026#34;type\u0026#34;: 11, \u0026#34;privkey\u0026#34;: \u0026#34;base64...\u0026#34;, \u0026#34;pubkey\u0026#34;: \u0026#34;base64...\u0026#34; }, \u0026#34;blinded\u0026#34;: { \u0026#34;privkey\u0026#34;: \u0026#34;base64...\u0026#34;, \u0026#34;pubkey\u0026#34;: \u0026#34;base64...\u0026#34; }, \u0026#34;offline_sig_block\u0026#34;: { \u0026#34;expires\u0026#34;: 1729123200, \u0026#34;signature\u0026#34;: \u0026#34;base64...\u0026#34; } } ], \u0026#34;signature\u0026#34;: \u0026#34;base64...\u0026#34; // Signature over entire structure } I2CP Protocol Enhancement (TODO) Current Status: No I2CP protocol enhancement defined for offline keys with encrypted LeaseSet.\nRequirements:\nKey delivery mechanism:\nUpload batch of keys from client to router Acknowledgment of successful key loading Key expiration notification:\nRouter notifies client when keys running low Client can generate and upload new batch Key revocation:\nEmergency revocation of future keys if compromise suspected Proposed I2CP Messages:\nUPLOAD_OFFLINE_KEYS - एन्क्रिप्टेड कुंजी सामग्री का बैच - कवर की गई तिथि सीमा OFFLINE_KEY_STATUS - शेष दिनों की संख्या - अगली कुंजी की समाप्ति तिथि REVOKE_OFFLINE_KEYS - रद्द करने हेतु तिथि सीमा - प्रतिस्थापन के लिए नई कुंजियाँ (वैकल्पिक) Implementation Status Java I2P:\n✅ Offline keys for standard LS2: Fully supported (since 0.9.38) ⚠️ Offline keys for encrypted LS2: Implemented (since 0.9.40) ❌ File format: Not standardized ❌ I2CP protocol: Not enhanced i2pd (C++):\n✅ Offline keys for standard LS2: Fully supported ✅ Offline keys for encrypted LS2: Fully supported (since 2.58.0) ❌ File format: Not standardized ❌ I2CP protocol: Not enhanced References:\nOffline Signatures Proposal I2CP Specification Security Considerations Cryptographic Security Algorithm Selection:\nAll cryptographic primitives are based on well-studied algorithms:\nChaCha20: Modern stream cipher, constant-time, no timing attacks SHA-256: NIST-approved hash, 128-bit security level HKDF: RFC 5869 standard, proven security bounds Ed25519/Red25519: Curve25519-based, ~128-bit security level X25519: Diffie-Hellman over Curve25519, ~128-bit security level Key Sizes:\nAll symmetric keys: 256 bits (32 bytes) All public/private keys: 256 bits (32 bytes) All nonces/IVs: 96 bits (12 bytes) All signatures: 512 bits (64 bytes) These sizes provide adequate security margins against current and near-future attacks.\nForward Secrecy Daily Key Rotation:\nEncrypted LeaseSets rotate keys daily (UTC midnight):\nNew blinded public/private key pair New storage location in DHT New encryption keys for both layers Benefits:\nCompromising today\u0026rsquo;s blinded key doesn\u0026rsquo;t reveal yesterday\u0026rsquo;s Limits exposure window to 24 hours Prevents long-term tracking via DHT Enhanced with Ephemeral Keys:\nDH client authorization uses ephemeral keys:\nServer generates new ephemeral DH keypair for each publication Compromising ephemeral key only affects that publication True forward secrecy even if long-term keys compromised Privacy Properties Destination Blinding:\nThe blinded public key:\nIs unlinkable to the original destination (without knowing the secret) Changes daily, preventing long-term correlation Cannot be reversed to find the original public key Client Membership Privacy:\nPer-client authorization provides:\nAnonymity: No way to identify which clients are authorized Untraceability: Cannot track when specific clients added/revoked Size obfuscation: Can add dummy entries to hide true count DHT Privacy:\nStorage location rotates daily:\nlocation = SHA-256(sig_type || blinded_public_key) This prevents:\nCorrelation across days via DHT lookups Long-term monitoring of service availability Traffic analysis of DHT queries Threat Model Adversary Capabilities:\nNetwork Adversary:\nCan monitor all DHT traffic Can observe encrypted LeaseSet publications Cannot decrypt without proper keys Floodfill Adversary:\nCan store and analyze all encrypted LeaseSets Can track publication patterns over time Cannot decrypt Layer 1 or Layer 2 Can see client count (but not identities) Authorized Client Adversary:\nCan decrypt specific encrypted LeaseSets Can access inner LeaseSet2 data Cannot determine other clients\u0026rsquo; identities Cannot decrypt past LeaseSets (with ephemeral keys) Out of Scope:\nMalicious router implementations Compromised router host systems Side-channel attacks (timing, power analysis) Physical access to keys Social engineering attacks Attack Scenarios 1. Offline Keys Tracking Attack:\nAttack: Adversary tracks encrypted LeaseSets via unchanging offline signature block.\nMitigation: Generate new transient keys daily (in addition to blinded keys).\nStatus: Documented recommendation, implementation-specific.\n2. Client Position Inference Attack:\nAttack: If client order is static, clients can infer their position and detect when other clients added/removed.\nMitigation: Randomize client order in authorization list for each publication.\nStatus: Documented recommendation in specification.\n3. Client Count Analysis Attack:\nAttack: Adversary monitors client count changes over time to infer service popularity or client churn.\nMitigation: Add random dummy entries to authorization list.\nStatus: Optional feature, deployment-specific trade-off (size vs. privacy).\n4. PSK Interception Attack:\nAttack: Adversary intercepts PSK during out-of-band exchange and can decrypt all future encrypted LeaseSets.\nMitigation: Use DH client authorization instead, or ensure secure key exchange (Signal, OTR, PGP).\nStatus: Known limitation of PSK approach, documented in specification.\n5. Timing Correlation Attack:\nAttack: Adversary correlates publication times across days to link encrypted LeaseSets.\nMitigation: Randomize publication times, use delayed publishing.\nStatus: Implementation-specific, not addressed in core specification.\n6. Long-term Secret Compromise:\nAttack: Adversary compromises the blinding secret and can compute all past and future blinded keys.\nMitigation:\nUse optional secret parameter (not empty) Rotate secret periodically Use different secrets for different services Status: Secret parameter is optional; using it is highly recommended.\nOperational Security Key Management:\nSigning Private Key:\nStore offline in cold storage Use only for generating blinded keys (batch process) Never expose to online router Blinded Private Keys:\nGenerate offline, deliver in batches Rotate daily automatically Delete after use (forward secrecy) Transient Private Keys (with offline keys):\nGenerate offline, deliver in batches Can be longer-lived (days/weeks) Rotate regularly for enhanced privacy Client Authorization Keys:\nDH: Client private keys never leave client device PSK: Use unique keys per client, secure exchange Revoke immediately upon client removal Secret Management:\nThe optional secret parameter in GENERATE_ALPHA:\nSHOULD be used for high-security services MUST be transmitted securely to authorized clients SHOULD be rotated periodically (e.g., monthly) CAN be different for different client groups Monitoring and Auditing:\nPublication Monitoring:\nVerify encrypted LeaseSets published successfully Monitor floodfill acceptance rates Alert on publication failures Client Access Monitoring:\nLog client authorization attempts (without identifying clients) Monitor for unusual patterns Detect potential attacks early Key Rotation Auditing:\nVerify daily key rotation occurs Check blinded key changes daily Ensure old keys are deleted Implementation Security Constant-Time Operations:\nImplementations MUST use constant-time operations for:\nAll scalar arithmetic (mod L operations) Private key comparisons Signature verification DH key agreement Memory Security:\nZero sensitive key material after use Use secure memory allocation for keys Prevent keys from being paged to disk Clear stack variables containing key material Random Number Generation:\nUse cryptographically secure RNG (CSRNG) Properly seed RNG from OS entropy source Do not use predictable RNGs for key material Verify RNG output quality periodically Input Validation:\nValidate all public keys are on the curve Check all signature types are supported Verify all lengths before parsing Reject malformed encrypted LeaseSets early Error Handling:\nDo not leak information via error messages Use constant-time comparison for authentication Do not expose timing differences in decryption Log security-relevant events properly Recommendations For Service Operators:\n✅ Use Red25519 (type 11) for new destinations ✅ Use DH client authorization for high-security services ✅ Generate new transient keys daily when using offline keys ✅ Use the optional secret parameter in GENERATE_ALPHA ✅ Randomize client order in authorization lists ✅ Monitor publication success and investigate failures ⚠️ Consider dummy entries to hide client count (size trade-off) For Client Implementers:\n✅ Validate blinded public keys are on prime-order subgroup ✅ Verify all signatures before trusting data ✅ Use constant-time operations for cryptographic primitives ✅ Zero key material immediately after use ✅ Implement proper error handling without information leaks ✅ Support both Ed25519 and Red25519 destination types For Network Operators:\n✅ Accept encrypted LeaseSets in floodfill routers ✅ Enforce reasonable size limits to prevent abuse ✅ Monitor for anomalous patterns (extremely large, frequent updates) ⚠️ Consider rate limiting encrypted LeaseSet publications Implementation Notes Java I2P Implementation Repository: https://github.com/i2p/i2p.i2p Key Classes:\nnet.i2p.data.LeaseSet2 - LeaseSet2 structure net.i2p.data.EncryptedLeaseSet - Encrypted LS2 implementation net.i2p.crypto.eddsa.EdDSAEngine - Ed25519/Red25519 signatures net.i2p.crypto.HKDF - HKDF implementation net.i2p.crypto.ChaCha20 - ChaCha20 cipher Configuration:\nEnable encrypted LeaseSet in clients.config:\n# एन्क्रिप्टेड LeaseSet सक्षम करें i2cp.encryptLeaseSet=true # वैकल्पिक: क्लाइंट प्राधिकरण सक्षम करें i2cp.enableAccessList=true # वैकल्पिक: DH authorization (Diffie-Hellman आधारित प्राधिकरण) का उपयोग करें (डिफ़ॉल्ट PSK (pre-shared key/पूर्व-साझा कुंजी) है) i2cp.accessListType=0 # वैकल्पिक: Blinding secret (ब्लाइंडिंग हेतु गुप्त कुंजी) (अत्यधिक अनुशंसित) i2cp.blindingSecret=अपना-सीक्रेट-यहाँ API Usage Example:\n// एन्क्रिप्टेड LeaseSet बनाएँ EncryptedLeaseSet els = new EncryptedLeaseSet(); // गंतव्य सेट करें els.setDestination(destination); // प्रत्येक क्लाइंट के लिए प्राधिकरण सक्षम करें els.setAuthorizationEnabled(true); els.setAuthType(EncryptedLeaseSet.AUTH_DH); // अधिकृत क्लाइंट जोड़ें (DH सार्वजनिक कुंजियाँ) for (byte[] clientPubKey : authorizedClients) { els.addClient(clientPubKey); } // ब्लाइंडिंग पैरामीटर सेट करें els.setBlindingSecret(\u0026#34;your-secret\u0026#34;); // हस्ताक्षर करें और प्रकाशित करें els.sign(signingPrivateKey); netDb.publish(els); i2pd (C++) Implementation Repository: https://github.com/PurpleI2P/i2pd Key Files:\nlibi2pd/LeaseSet.h/cpp - LeaseSet implementations libi2pd/Crypto.h/cpp - Cryptographic primitives libi2pd/Ed25519.h/cpp - Ed25519/Red25519 signatures libi2pd/ChaCha20.h/cpp - ChaCha20 cipher Configuration:\nEnable in tunnel configuration (tunnels.conf):\n[my-hidden-service] type = http host = 127.0.0.1 port = 8080 keys = my-service-keys.dat # एन्क्रिप्टेड LeaseSet सक्षम करें encryptleaseset = true # वैकल्पिक: क्लाइंट प्राधिकरण प्रकार (0=DH (डिफी-हेल्मन), 1=PSK (पूर्व-साझा कुंजी)) authtype = 0 # वैकल्पिक: Blinding secret (ब्लाइंडिंग हेतु गोपनीय मान) secret = अपना-सीक्रेट-यहाँ # वैकल्पिक: अधिकृत क्लाइंट्स (प्रत्येक पंक्ति में एक, base64 में एन्कोड की गई सार्वजनिक कुंजियाँ) client.1 = base64-encoded-client-pubkey-1 client.2 = base64-encoded-client-pubkey-2 API Usage Example:\n// एन्क्रिप्टेड LeaseSet बनाएँ auto encryptedLS = std::make_shared\u0026lt;i2p::data::EncryptedLeaseSet\u0026gt;( destination, blindingSecret ); // प्रति-क्लाइंट प्राधिकरण सक्षम करें encryptedLS-\u0026gt;SetAuthType(i2p::data::AUTH_TYPE_DH); // अधिकृत क्लाइंट जोड़ें for (const auto\u0026amp; clientPubKey : authorizedClients) { encryptedLS-\u0026gt;AddClient(clientPubKey); } // हस्ताक्षर करें और प्रकाशित करें encryptedLS-\u0026gt;Sign(signingPrivKey); netdb.Publish(encryptedLS); Testing and Debugging Test Vectors:\nGenerate test vectors for implementation verification:\n# टेस्ट वेक्टर 1: Key blinding (कुंजी को गोपनीय बनाने की तकनीक) destination_pubkey = bytes.fromhex(\u0026#39;a\u0026#39; * 64) sigtype = 7 blinded_sigtype = 11 date = \u0026#34;20251015\u0026#34; secret = \u0026#34;\u0026#34; alpha = generate_alpha(destination_pubkey, sigtype, blinded_sigtype, date, secret) print(f\u0026#34;Alpha: {alpha.hex()}\u0026#34;) # अपेक्षित: (संदर्भ कार्यान्वयन से मिलान कर सत्यापित करें) Unit Tests:\nKey areas to test:\nHKDF derivation with various inputs ChaCha20 encryption/decryption Red25519 signature generation and verification Key blinding (private and public) Layer 1/2 encryption/decryption Client authorization (DH and PSK) Base32 address generation and parsing Integration Tests:\nPublish encrypted LeaseSet to test network Retrieve and decrypt from client Verify daily key rotation Test client authorization (add/remove clients) Test offline keys (if supported) Common Implementation Errors:\nIncorrect mod L reduction: Must use proper modular arithmetic Endianness errors: Most fields are big-endian, but some crypto uses little-endian Off-by-one in array slicing: Verify indices are inclusive/exclusive as needed Missing constant-time comparisons: Use constant-time for all sensitive comparisons Not zeroing key material: Always zero keys after use Performance Considerations Computational Costs:\nOperation Cost Notes Key blinding (server)1 scalar multPer publication Key blinding (client)1 point add + 1 scalar multPer retrieval Layer 1 encryption1 HKDF + 1 ChaCha20Fast Layer 2 encryption1 HKDF + 1 ChaCha20Fast DH client auth (server)N+1 X25519 opsN = number of clients DH client auth (client)1 X25519 opPer retrieval PSK client auth0 DH opsOnly HKDF + ChaCha20 Signature (Red25519)1 signature opSimilar cost to Ed25519 Size Overhead:\nComponent Size Frequency Blinded public key32 bytesPer LeaseSet Layer 1 encryption overhead32 bytes (salt)Per LeaseSet Layer 2 encryption overhead32 bytes (salt)Per LeaseSet DH auth per client40 bytesPer client per LeaseSet DH ephemeral pubkey32 bytesPer LeaseSet (if DH auth) PSK auth per client40 bytesPer client per LeaseSet PSK salt32 bytesPer LeaseSet (if PSK auth) Signature64 bytesPer LeaseSet Offline sig block≈100 bytesPer LeaseSet (if offline keys) Typical Sizes:\nNo client auth: ~200 bytes overhead With 10 DH clients: ~600 bytes overhead With 100 DH clients: ~4200 bytes overhead Optimization Tips:\nBatch key generation: Generate blinded keys for multiple days in advance Cache subcredentials: Compute once per day, reuse for all publications Reuse ephemeral keys: Can reuse ephemeral DH key for short period (minutes) Parallel client encryption: Encrypt client cookies in parallel Fast path for no auth: Skip authorization layer entirely when disabled Compatibility Backward Compatibility:\nEd25519 (type 7) destinations supported for unblinded keys Red25519 (type 11) required for blinded keys Traditional LeaseSets still fully supported Encrypted LeaseSets do not break existing network Forward Compatibility:\nReserved flag bits for future features Extensible authorization scheme (3 bits allow 8 types) Version field in various structures Interoperability:\nJava I2P and i2pd fully interoperable since: Java I2P 0.9.40 (May 2019) i2pd 2.58.0 (September 2025) Encrypted LeaseSets work across implementations Client authorization works across implementations References IETF RFCs RFC 2104 - HMAC: Keyed-Hashing for Message Authentication (February 1997) RFC 5869 - HMAC-based Extract-and-Expand Key Derivation Function (HKDF) (May 2010) RFC 7539 - ChaCha20 and Poly1305 for IETF Protocols (May 2015) RFC 7748 - Elliptic Curves for Security (January 2016) I2P Specifications Common Structures Specification - LeaseSet2 and EncryptedLeaseSet structures Proposal 123: New netDB Entries - Background and design of LeaseSet2 Proposal 146: Red25519 - Red25519 signature scheme specification Proposal 149: B32 for Encrypted LS2 - Base32 addressing for encrypted LeaseSets Red25519 Specification - Detailed Red25519 implementation B32 Addressing Specification - Base32 address format Network Database Documentation - NetDB usage and operations I2CP Specification - I2P Client Protocol Cryptographic References Ed25519 Paper - \u0026ldquo;High-speed high-security signatures\u0026rdquo; by Bernstein et al. ZCash Protocol Specification - Section 5.4.6: RedDSA signature scheme Tor Rendezvous Specification v3 - Tor\u0026rsquo;s onion service specification (for comparison) Security References Key Blinding Security Discussion - Tor Project mailing list discussion Tor Ticket #8106 - Key blinding implementation discussion PRNG Security - Random number generator security considerations Tor PRNG Discussion - Discussion of PRNG usage in Tor Implementation References Java I2P Repository - Official Java implementation i2pd Repository - C++ implementation I2P Website - Official I2P project website I2P Specifications - Complete specification index Version History I2P Release Notes - Official release announcements Java I2P Releases - GitHub release history i2pd Releases - GitHub release history Appendix A: Cryptographic Constants Ed25519 / Red25519 Constants # Ed25519 आधार बिंदु (जनित्र) B = 2**255 - 19 # Ed25519 का क्रम (स्केलर क्षेत्र का आकार) L = 2**252 + 27742317777372353535851937790883648493 # हस्ताक्षर प्रकार के मान SIGTYPE_ED25519 = 7 # 0x0007 SIGTYPE_RED25519 = 11 # 0x000b # कुंजी आकार PRIVKEY_SIZE = 32 # bytes PUBKEY_SIZE = 32 # bytes SIGNATURE_SIZE = 64 # bytes ChaCha20 Constants # ChaCha20 (एक स्ट्रीम सिफर एल्गोरिदम) पैरामीटर CHACHA20_KEY_SIZE = 32 # बाइट्स (256 बिट्स) CHACHA20_NONCE_SIZE = 12 # बाइट्स (96 बिट्स) CHACHA20_INITIAL_COUNTER = 1 # RFC 7539 0 या 1 की अनुमति देता है HKDF Constants # HKDF (HMAC-आधारित कुंजी व्युत्पत्ति फ़ंक्शन) के पैरामीटर HKDF_HASH = \u0026#34;SHA-256\u0026#34; HKDF_SALT_MAX = 32 # बाइट (HashLen) # HKDF (HMAC-आधारित कुंजी व्युत्पत्ति फ़ंक्शन) सूचना स्ट्रिंग्स (डोमेन पृथक्करण) HKDF_INFO_ALPHA = b\u0026#34;i2pblinding1\u0026#34; HKDF_INFO_LAYER1 = b\u0026#34;ELS2_L1K\u0026#34; HKDF_INFO_LAYER2 = b\u0026#34;ELS2_L2K\u0026#34; HKDF_INFO_DH_AUTH = b\u0026#34;ELS2_XCA\u0026#34; HKDF_INFO_PSK_AUTH = b\u0026#34;ELS2PSKA\u0026#34; Hash Personalization Strings # SHA-256 personalization strings (व्यक्तिकरण स्ट्रिंग्स) HASH_PERS_ALPHA = b\u0026#34;I2PGenerateAlpha\u0026#34; HASH_PERS_RED25519 = b\u0026#34;I2P_Red25519H(x)\u0026#34; HASH_PERS_CREDENTIAL = b\u0026#34;credential\u0026#34; HASH_PERS_SUBCREDENTIAL = b\u0026#34;subcredential\u0026#34; Structure Sizes # लेयर 0 (बाहरी) के आकार BLINDED_SIGTYPE_SIZE = 2 # बाइट्स BLINDED_PUBKEY_SIZE = 32 # बाइट्स (Red25519 के लिए) PUBLISHED_TS_SIZE = 4 # बाइट्स EXPIRES_SIZE = 2 # बाइट्स FLAGS_SIZE = 2 # बाइट्स LEN_OUTER_CIPHER_SIZE = 2 # बाइट्स SIGNATURE_SIZE = 64 # बाइट्स (Red25519) # ऑफलाइन कुंजी ब्लॉक आकार OFFLINE_EXPIRES_SIZE = 4 # बाइट्स OFFLINE_SIGTYPE_SIZE = 2 # बाइट्स OFFLINE_SIGNATURE_SIZE = 64 # बाइट्स # परत 1 (मध्य) के आकार AUTH_FLAGS_SIZE = 1 # बाइट EPHEMERAL_PUBKEY_SIZE = 32 # बाइट्स (DH auth) AUTH_SALT_SIZE = 32 # बाइट्स (PSK auth) NUM_CLIENTS_SIZE = 2 # बाइट्स CLIENT_ID_SIZE = 8 # बाइट्स CLIENT_COOKIE_SIZE = 32 # बाइट्स AUTH_CLIENT_ENTRY_SIZE = 40 # बाइट्स (CLIENT_ID + CLIENT_COOKIE) # एन्क्रिप्शन का अतिरिक्त भार SALT_SIZE = 32 # बाइट (प्रत्येक एन्क्रिप्टेड लेयर की शुरुआत में जोड़ा जाता है) # Base32 पता B32_ENCRYPTED_DECODED_SIZE = 35 # बाइट्स B32_ENCRYPTED_ENCODED_LEN = 56 # अक्षर B32_SUFFIX = \u0026#34;.b32.i2p\u0026#34; Appendix B: Test Vectors Test Vector 1: Alpha Generation Input:\n# गंतव्य सार्वजनिक कुंजी (Ed25519) A = bytes.fromhex(\u0026#39;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\u0026#39;) stA = 0x0007 # Ed25519 stA_prime = 0x000b # Red25519 date = \u0026#34;20251015\u0026#34; secret = \u0026#34;\u0026#34; # खाली गोपनीय मान Computation:\nkeydata = A || bytes([0x00, 0x07]) || bytes([0x00, 0x0b]) # keydata = 36 बाइट्स salt = SHA256(b\u0026#34;I2PGenerateAlpha\u0026#34; + keydata) ikm = b\u0026#34;20251015\u0026#34; info = b\u0026#34;i2pblinding1\u0026#34; seed = HKDF(salt, ikm, info, 64) alpha = LEOS2IP(seed) mod L Expected Output:\n(संदर्भ कार्यान्वयन के साथ मिलान कर सत्यापित करें) alpha = [64-बाइट हेक्साडेसिमल मान] Test Vector 2: ChaCha20 Encryption Input:\nkey = bytes([i for i in range(32)]) # 0x00..0x1f nonce = bytes([i for i in range(12)]) # 0x00..0x0b plaintext = b\u0026#34;Hello, I2P!\u0026#34; Computation:\nciphertext = ChaCha20_Encrypt(key, nonce, plaintext, counter=1) Expected Output:\nciphertext = [RFC 7539 परीक्षण वेक्टरों के साथ सत्यापित करें] Test Vector 3: HKDF Input:\nsalt = bytes(32) # सभी शून्य ikm = b\u0026#34;test input keying material\u0026#34; info = b\u0026#34;ELS2_L1K\u0026#34; n = 44 Computation:\nkeys = HKDF(salt, ikm, info, n) Expected Output:\nkeys = [44-बाइट हेक्स मान] Test Vector 4: Base32 Address Input:\npubkey = bytes.fromhex(\u0026#39;bbbb\u0026#39; + \u0026#39;bb\u0026#39; * 30) # 32 बाइट unblinded_sigtype = 11 # Red25519 blinded_sigtype = 11 # Red25519 Computation:\naddress = generate_encrypted_b32_address(pubkey, unblinded_sigtype, blinded_sigtype) Expected Output:\naddress = [56 base32 अक्षर].b32.i2p # पुष्टि करें कि checksum (डेटा अखंडता जाँच मान) का सत्यापन सही ढंग से होता है Appendix C: Glossary Alpha (α): The secret blinding factor used to blind public and private keys. Generated from the destination, date, and optional secret.\nAuthCookie: A 32-byte random value encrypted for each authorized client, used as input to Layer 2 encryption.\nB (Base Point): The generator point for the Ed25519 elliptic curve.\nBlinded Key: A public or private key that has been transformed using the alpha blinding factor. Blinded keys cannot be linked to the original keys without knowing alpha.\nChaCha20: A stream cipher providing fast, secure encryption without requiring AES hardware support.\nClientID: An 8-byte identifier derived from HKDF output, used to identify authorization entries for clients.\nClientCookie: A 32-byte encrypted value containing the authCookie for a specific client.\nCredential: A 32-byte value derived from the destination\u0026rsquo;s public key and signature types, binding encryption to knowledge of the destination.\nCSRNG: Cryptographically Secure Random Number Generator. Must provide unpredictable output suitable for key generation.\nDH (Diffie-Hellman): A cryptographic protocol for securely establishing shared secrets. I2P uses X25519.\nEd25519: An elliptic curve signature scheme providing fast signatures with 128-bit security level.\nEphemeral Key: A short-lived cryptographic key, typically used once and then discarded.\nFloodfill: I2P routers that store and serve network database entries, including encrypted LeaseSets.\nHKDF: HMAC-based Key Derivation Function, used to derive multiple cryptographic keys from a single source.\nL (Order): The order of the Ed25519 scalar field (approximately 2^252).\nLayer 0 (Outer): The plaintext portion of an encrypted LeaseSet, containing blinded key and metadata.\nLayer 1 (Middle): The first encrypted layer, containing client authorization data.\nLayer 2 (Inner): The innermost encrypted layer, containing the actual LeaseSet2 data.\nLeaseSet2 (LS2): Second version of I2P\u0026rsquo;s network database entry format, introducing encrypted variants.\nNetDB: The I2P network database, a distributed hash table storing router and destination information.\nOffline Keys: A feature allowing the main signing key to remain in cold storage while a transient key handles daily operations.\nPSK (Pre-Shared Key): A symmetric key shared in advance between two parties, used for PSK client authorization.\nRed25519: An Ed25519-based signature scheme with key blinding support, based on ZCash RedDSA.\nSalt: Random data used as input to key derivation functions to ensure unique outputs.\nSigType: A numeric identifier for signature algorithms (e.g., 7 = Ed25519, 11 = Red25519).\nSubcredential: A 32-byte value derived from the credential and blinded public key, binding encryption to a specific encrypted LeaseSet.\nTransient Key: A temporary signing key used with offline keys, with a limited validity period.\nX25519: An elliptic curve Diffie-Hellman protocol over Curve25519, providing key agreement.\nDocument Information Status: This document represents the current stable encrypted LeaseSet specification as implemented in I2P since June 2019. The protocol is mature and widely deployed.\nContributing: For corrections or improvements to this documentation, please submit issues or pull requests to the I2P specifications repository.\nSupport: For questions about implementing encrypted LeaseSets:\nI2P Forum: https://i2pforum.net/ IRC: #i2p-dev on OFTC Matrix: #i2p-dev:matrix.org Acknowledgments: This specification builds on work by the I2P development team, ZCash cryptography research, and Tor Project\u0026rsquo;s key blinding research.\n","description":"निजी Destinations (गंतव्य) के लिए अभिगम-नियंत्रित LeaseSet प्रारूप","id":"14f2a4c0bb3f459df8db8dbce45508ff","section":"docs","title":"एन्क्रिप्टेड LeaseSet","url":"/hi/docs/specs/encryptedleaseset/"},{"categories":null,"content":"अवलोकन Standard Base 32 (\u0026ldquo;b32\u0026rdquo;) पतों में गंतव्य का हैश होता है। यह एन्क्रिप्टेड LS2 (LeaseSet2, I2P का नया leaseSet प्रारूप; प्रस्ताव 123) के लिए काम नहीं करेगा।\nहम एन्क्रिप्टेड LS2 (proposal 123) के लिए पारंपरिक base 32 पता उपयोग नहीं कर सकते, क्योंकि इसमें destination का केवल हैश होता है। यह ब्लाइंड न की गई सार्वजनिक कुंजी प्रदान नहीं करता। क्लाइंट्स को leaseset को प्राप्त कर डिक्रिप्ट करने के लिए destination (I2P में गंतव्य पहचान) की सार्वजनिक कुंजी, हस्ताक्षर प्रकार, ब्लाइंडेड हस्ताक्षर प्रकार, और एक वैकल्पिक रहस्य या निजी कुंजी पता होना चाहिए। इसलिए, केवल base 32 पता पर्याप्त नहीं है। क्लाइंट को या तो पूरा destination (जिसमें सार्वजनिक कुंजी होती है) चाहिए, या फिर केवल सार्वजनिक कुंजी ही। यदि क्लाइंट के पास किसी पता पुस्तिका में पूरा destination है, और वह पता पुस्तिका हैश के आधार पर रिवर्स लुकअप का समर्थन करती है, तो सार्वजनिक कुंजी प्राप्त की जा सकती है।\nयह प्रारूप base32 पते में हैश के बजाय सार्वजनिक कुंजी रखता है। इस प्रारूप में सार्वजनिक कुंजी के हस्ताक्षर प्रकार और ब्लाइंडिंग योजना के हस्ताक्षर प्रकार का भी समावेश होना आवश्यक है।\nयह दस्तावेज़ इन पतों के लिए b32 प्रारूप निर्दिष्ट करता है। जबकि हमने चर्चाओं के दौरान इस नए प्रारूप को \u0026ldquo;b33\u0026rdquo; पता कहा है, वास्तविक नया प्रारूप सामान्य \u0026ldquo;.b32.i2p\u0026rdquo; प्रत्यय को बरकरार रखता है।\nकार्यान्वयन स्थिति प्रस्ताव 123 (New netDB Entries) का पूर्ण कार्यान्वयन संस्करण 0.9.43 (अक्टूबर 2019) में किया गया। एन्क्रिप्टेड LS2 फीचर सेट संस्करण 2.10.0 (सितंबर 2025) तक स्थिर रहा है, और पता निर्धारण प्रारूप या क्रिप्टोग्राफिक विनिर्देशों में कोई पीछे-संगतता तोड़ने वाले परिवर्तन नहीं हुए।\nमुख्य कार्यान्वयन मील के पत्थर: - 0.9.38: मानक LS2 (LeaseSet2, लीज़सेट का नया प्रारूप) के लिए Floodfill समर्थन ऑफ़लाइन कुंजियों के साथ - 0.9.39: RedDSA हस्ताक्षर प्रकार 11 और मूलभूत एन्क्रिप्शन/डिक्रिप्शन - 0.9.40: पूर्ण B32 एड्रेसिंग समर्थन (प्रस्ताव 149) - 0.9.41: X25519-आधारित प्रति-क्लाइंट प्रमाणीकरण - 0.9.42: सभी ब्लाइंडिंग सुविधाएँ कार्यरत - 0.9.43: पूर्ण कार्यान्वयन घोषित (अक्टूबर 2019)\nडिज़ाइन नया प्रारूप unblinded (जिस पर ब्लाइंडिंग लागू नहीं है) सार्वजनिक कुंजी, unblinded हस्ताक्षर प्रकार, और blinded (ब्लाइंडिंग लागू) हस्ताक्षर प्रकार को शामिल करता है। वैकल्पिक रूप से निजी लिंक के लिए गुप्त और/या निजी कुंजी आवश्यकताओं को संकेत करता है। मौजूदा \u0026ldquo;.b32.i2p\u0026rdquo; प्रत्यय का उपयोग करता है, लेकिन अधिक लंबाई के साथ। त्रुटि पहचान के लिए एक चेकसम शामिल करता है। एन्क्रिप्टेड leasesets के पते 56 या अधिक एन्कोडेड अक्षरों (35 या अधिक डिकोडेड बाइट्स) द्वारा पहचाने जाते हैं, जबकि पारंपरिक बेस 32 पतों के लिए यह 52 अक्षर (32 बाइट्स) है। विनिर्देश निर्माण और एन्कोडिंग निम्नलिखित स्वरूप का {56+ अक्षर}.b32.i2p (बाइनरी में 35+ अक्षर) होस्टनेम बनाएँ:\nflag (1 byte) bit 0: 0 for one-byte sigtypes, 1 for two-byte sigtypes bit 1: 0 for no secret, 1 if secret is required bit 2: 0 for no per-client auth, 1 if client private key is required bits 7-3: Unused, set to 0 public key sigtype (1 or 2 bytes as indicated in flags) If 1 byte, the upper byte is assumed zero blinded key sigtype (1 or 2 bytes as indicated in flags) If 1 byte, the upper byte is assumed zero public key Number of bytes as implied by sigtype पोस्ट-प्रोसेसिंग और चेकसम:\nConstruct the binary data as above. Treat checksum as little-endian. Calculate checksum = CRC-32(data[3:end]) data[0] ^= (byte) checksum data[1] ^= (byte) (checksum \u0026gt;\u0026gt; 8) data[2] ^= (byte) (checksum \u0026gt;\u0026gt; 16) hostname = Base32.encode(data) || \u0026#34;.b32.i2p\u0026#34; b32 के अंत में किसी भी अनुपयोगी बिट का मान 0 होना चाहिए। मानक 56 अक्षर (35 बाइट) के पते में कोई अनुपयोगी बिट नहीं होती।\nडिकोडिंग और सत्यापन strip the \u0026#34;.b32.i2p\u0026#34; from the hostname data = Base32.decode(hostname) Calculate checksum = CRC-32(data[3:end]) Treat checksum as little-endian. flags = data[0] ^ (byte) checksum if 1 byte sigtypes: pubkey sigtype = data[1] ^ (byte) (checksum \u0026gt;\u0026gt; 8) blinded sigtype = data[2] ^ (byte) (checksum \u0026gt;\u0026gt; 16) else (2 byte sigtypes): pubkey sigtype = data[1] ^ ((byte) (checksum \u0026gt;\u0026gt; 8)) || data[2] ^ ((byte) (checksum \u0026gt;\u0026gt; 16)) blinded sigtype = data[3] || data[4] parse the remainder based on the flags to get the public key गोपनीय और निजी कुंजी बिट्स सीक्रेट और निजी कुंजी बिट्स का उपयोग क्लाइंट, प्रॉक्सी, या अन्य क्लाइंट-साइड कोड को यह संकेत देने के लिए किया जाता है कि leaseset को डिक्रिप्ट करने के लिए सीक्रेट और/या निजी कुंजी आवश्यक होगी। कुछ विशिष्ट कार्यान्वयन उपयोगकर्ता से आवश्यक डेटा उपलब्ध कराने के लिए प्रॉम्प्ट कर सकते हैं, या यदि आवश्यक डेटा अनुपस्थित हो तो कनेक्शन प्रयासों को अस्वीकार कर सकते हैं।\nये बिट्स केवल संकेतकों के रूप में कार्य करते हैं। गुप्त या निजी कुंजी को कभी भी B32 address (Base32-एन्कोडेड पता) में शामिल नहीं किया जाना चाहिए, क्योंकि इससे सुरक्षा से समझौता हो जाएगा।\nक्रिप्टोग्राफ़िक विवरण Blinding Scheme (ब्लाइंडिंग योजना) यह ब्लाइंडिंग योजना Ed25519 (Ed25519—एक एलिप्टिक-कर्व) और ZCash (ZCash—गोपनीयता-केंद्रित क्रिप्टोकरेंसी) के डिज़ाइन पर आधारित RedDSA (RedDSA—Ed25519 पर आधारित डिजिटल सिग्नेचर स्कीम) का उपयोग करती है, जो SHA-512 (SHA-512—क्रिप्टोग्राफिक हैश फ़ंक्शन) का उपयोग करके Ed25519 कर्व पर Red25519 (Red25519—Ed25519 कर्व पर RedDSA हस्ताक्षर प्रारूप) हस्ताक्षर उत्पन्न करती है। यह तरीका सुनिश्चित करता है कि ब्लाइंड किए गए पब्लिक की prime-order subgroup (prime-order subgroup—प्राइम-ऑर्डर उपसमूह) में ही रहें, जिससे कुछ वैकल्पिक डिज़ाइनों में मौजूद सुरक्षा चिंताओं से बचा जा सके।\nBlinded keys (ब्लाइंडेड कुंजियाँ—क्रिप्टोग्राफ़ी में छिपाई गई कुंजियाँ) UTC तारीख के आधार पर प्रतिदिन बदली जाती हैं, इस सूत्र का उपयोग करते हुए:\nblinded_key = BLIND(unblinded_key, date, optional_secret) DHT (वितरित हैश तालिका) के भंडारण स्थान की गणना इस प्रकार की जाती है:\nSHA256(type_byte || blinded_public_key) एन्क्रिप्शन एन्क्रिप्टेड leaseSet एन्क्रिप्शन के लिए ChaCha20 stream cipher (धारा-आधारित कूटलेखन) का उपयोग करता है, जिसे AES हार्डवेयर त्वरण न होने वाले उपकरणों पर श्रेष्ठ प्रदर्शन के कारण चुना गया है। विनिर्देश कुंजी व्युत्पत्ति के लिए HKDF (HMAC-आधारित कुंजी व्युत्पत्ति फ़ंक्शन) और Diffie-Hellman क्रियाओं के लिए X25519 का उपयोग करता है।\nएन्क्रिप्टेड leasesets की तीन-स्तरीय संरचना होती है: - बाहरी परत: सादा-पाठ मेटाडेटा - मध्य परत: क्लाइंट प्रमाणीकरण (DH (Diffie-Hellman, कुंजी-विनिमय) या PSK (Pre-Shared Key, पूर्व-साझा कुंजी) विधियाँ) - आंतरिक परत: लीज़ जानकारी के साथ वास्तविक LS2 डेटा\nप्रमाणीकरण विधियाँ प्रति-क्लाइंट प्रमाणीकरण दो तरीकों का समर्थन करता है:\nDH प्रमाणीकरण: X25519 कुंजी समझौते का उपयोग करता है। प्रत्येक अधिकृत क्लाइंट अपनी सार्वजनिक कुंजी सर्वर को प्रदान करता है, और सर्वर ECDH (Elliptic-Curve Diffie-Hellman) से व्युत्पन्न एक साझा रहस्य का उपयोग करके मध्य परत को एन्क्रिप्ट करता है।\nPSK प्रमाणीकरण: कूटलेखन के लिए पूर्व-साझा कुंजियों का सीधे उपयोग करता है।\nB32 पते में फ्लैग बिट 2 यह संकेत करता है कि प्रति-क्लाइंट प्रमाणीकरण आवश्यक है या नहीं।\nकैशिंग यद्यपि यह इस विनिर्देश के दायरे से बाहर है, routers और क्लाइंट्स को सार्वजनिक कुंजी और डेस्टिनेशन (गंतव्य) के बीच के मानचित्रण को याद रखना और उसे कैश करना (स्थायी कैश रखना अनुशंसित है), तथा इसके विपरीत भी, आवश्यक है।\nblockfile naming service (ब्लॉकफाइल नामकरण सेवा), जो संस्करण 0.9.8 से I2P की डिफ़ॉल्ट address book प्रणाली है, कई address books बनाए रखती है और एक समर्पित reverse-lookup map (उल्टा खोज मानचित्र) के जरिए hash के आधार पर तेज़ लुकअप प्रदान करती है। जब प्रारंभ में केवल hash ही ज्ञात हो, तब एन्क्रिप्टेड leaseSet के रिज़ॉल्यूशन के लिए यह क्षमता अत्यंत महत्वपूर्ण होती है।\nहस्ताक्षर प्रकार I2P संस्करण 2.10.0 के अनुसार, 0 से 11 तक के हस्ताक्षर प्रकार परिभाषित हैं। एक-बाइट एन्कोडिंग मानक बनी हुई है, जबकि दो-बाइट एन्कोडिंग उपलब्ध तो है, पर व्यवहार में उपयोग नहीं होती।\nसामान्यतः प्रयुक्त प्रकार: - Type 0 (DSA_SHA1): routers के लिए अप्रचलित, destinations (गंतव्य) के लिए समर्थित - Type 7 (EdDSA_SHA512_Ed25519): router पहचान और destinations के लिए वर्तमान मानक - Type 11 (RedDSA_SHA512_Ed25519): ब्लाइंडिंग समर्थन वाले एन्क्रिप्टेड LS2 leasesets के लिए विशेष रूप से\nमहत्वपूर्ण नोट: केवल Ed25519 (type 7) और Red25519 (type 11) ही एन्क्रिप्टेड leasesets के लिए आवश्यक blinding (क्रिप्टोग्राफ़िक रूप से पहचान छिपाने की प्रक्रिया) का समर्थन करते हैं। अन्य हस्ताक्षर प्रकार इस विशेषता के साथ उपयोग नहीं किए जा सकते।\nप्रकार 9-10 (GOST algorithms, रूसी मानक क्रिप्टोग्राफ़िक एल्गोरिद्म) अभी भी आरक्षित हैं, लेकिन लागू नहीं किए गए हैं। प्रकार 4-6 और 8 को ऑफ़लाइन साइनिंग कुंजियों के लिए \u0026ldquo;offline only\u0026rdquo; के रूप में चिह्नित किया गया है।\nटिप्पणियाँ लंबाई के आधार पर पुराने और नए वेरिएंट अलग करें। पुराने b32 पते हमेशा {52 chars}.b32.i2p होते हैं। नए वाले {56+ chars}.b32.i2p होते हैं base32 एन्कोडिंग RFC 4648 मानकों का पालन करती है, जिसमें case-insensitive डिकोडिंग और lowercase आउटपुट को प्राथमिकता दी जाती है जब बड़े सार्वजनिक कुंजियों वाले हस्ताक्षर प्रकार उपयोग होते हैं (उदा., ECDSA P521 के साथ 132-बाइट कुंजियाँ), तो पते 200 अक्षरों से अधिक हो सकते हैं नया फ़ॉर्मेट jump links (जंप लिंक—एड्रेस लुकअप/रिज़ॉल्यूशन हेतु लिंक) में भी उपयोग किया जा सकता है (और jump servers द्वारा उपलब्ध कराया जा सकता है), बिल्कुल मानक b32 की तरह, यदि चाहें Blinded keys (ब्लाइंडेड कुंजियाँ—गोपनीयता बढ़ाने हेतु ब्लाइंडिंग लागू की गई कुंजियाँ) गोपनीयता बढ़ाने के लिए UTC तिथि के आधार पर प्रतिदिन रोटेट होती हैं यह फ़ॉर्मेट Tor के rend-spec-v3.txt के appendix A.2 वाले दृष्टिकोण से भिन्न है, जिसमें off-curve blinded public keys के साथ संभावित सुरक्षा निहितार्थ हो सकते हैं संस्करण संगतता यह विनिर्देश I2P संस्करण 0.9.47 (अगस्त 2020) से लेकर संस्करण 2.10.0 (सितंबर 2025) तक के लिए सटीक है। इस अवधि में B32 addressing format (Base32 आधारित पता प्रारूप), encrypted LS2 structure (एन्क्रिप्टेड LeaseSet संस्करण 2 संरचना), या क्रिप्टोग्राफिक कार्यान्वयन में कोई संगतता-तोड़ने वाला परिवर्तन नहीं हुआ है। 0.9.47 से बनाए गए सभी पते वर्तमान संस्करणों के साथ पूर्णतः संगत बने रहते हैं।\nसंदर्भ CRC-32 - CRC-32 (विकिपीडिया) - RFC 3309: स्ट्रीम कंट्रोल ट्रांसमिशन प्रोटोकॉल चेकसम I2P विनिर्देश - एन्क्रिप्टेड LeaseSet (I2P में गंतव्य के tunnel leases का रिकॉर्ड) विनिर्देश - प्रस्ताव 123: नए netDB प्रविष्टियाँ - प्रस्ताव 149: एन्क्रिप्टेड LS2 के लिए B32 - सामान्य संरचनाओं का विनिर्देश - नामकरण और पता पुस्तिका Tor तुलना - Tor चर्चा थ्रेड (डिज़ाइन संदर्भ) अतिरिक्त संसाधन - I2P परियोजना - I2P फ़ोरम - Java API प्रलेखन ","description":"एन्क्रिप्टेड LS2 leasesets के लिए Base 32 पते का प्रारूप","id":"cac162c86c1b599cb6bab03e6270c404","section":"docs","title":"एन्क्रिप्टेड Leasesets के लिए B32","url":"/hi/docs/specs/b32-for-encrypted-leasesets/"},{"categories":null,"content":"I2P-विशिष्ट कोड क्यों लिखें? I2P में एप्लिकेशन का उपयोग करने के कई तरीके हैं। I2PTunnel का उपयोग करके, आप सामान्य एप्लिकेशन का उपयोग बिना स्पष्ट I2P समर्थन को प्रोग्राम किए कर सकते हैं। यह क्लाइंट-सर्वर परिदृश्यों के लिए बहुत प्रभावी है, जहां आपको किसी एकल वेबसाइट से कनेक्ट करने की आवश्यकता होती है। आप उस वेबसाइट से कनेक्ट करने के लिए I2PTunnel का उपयोग करके एक tunnel बना सकते हैं, जैसा कि चित्र 1 में दिखाया गया है।\nयदि आपका एप्लिकेशन वितरित है, तो इसे बड़ी संख्या में peers से कनेक्शन की आवश्यकता होगी। I2PTunnel का उपयोग करते हुए, आपको प्रत्येक peer के लिए एक नई tunnel बनानी होगी जिससे आप संपर्क करना चाहते हैं, जैसा कि चित्र 2 में दिखाया गया है। इस प्रक्रिया को निश्चित रूप से स्वचालित किया जा सकता है, लेकिन बहुत सारे I2PTunnel instances चलाने से बड़ी मात्रा में ओवरहेड उत्पन्न होता है। इसके अलावा, कई प्रोटोकॉल के साथ आपको सभी को सभी peers के लिए पोर्ट्स के एक ही सेट का उपयोग करने के लिए बाध्य करना होगा — उदाहरण के लिए यदि आप विश्वसनीय रूप से DCC चैट चलाना चाहते हैं, तो सभी को सहमत होना होगा कि पोर्ट 10001 Alice है, पोर्ट 10002 Bob है, पोर्ट 10003 Charlie है, और इसी तरह, क्योंकि प्रोटोकॉल में TCP/IP विशिष्ट जानकारी (होस्ट और पोर्ट) शामिल होती है।\nसामान्य नेटवर्क एप्लिकेशन अक्सर बहुत सारा अतिरिक्त डेटा भेजते हैं जिसका उपयोग उपयोगकर्ताओं की पहचान करने के लिए किया जा सकता है। होस्टनेम, पोर्ट नंबर, टाइम ज़ोन, कैरेक्टर सेट आदि अक्सर उपयोगकर्ता को सूचित किए बिना भेजे जाते हैं। इस प्रकार, नेटवर्क प्रोटोकॉल को विशेष रूप से गुमनामी को ध्यान में रखते हुए डिज़ाइन करने से उपयोगकर्ता की पहचान से समझौता करने से बचा जा सकता है।\nI2P के ऊपर इंटरैक्ट करने के तरीके को निर्धारित करते समय दक्षता संबंधी विचारों की समीक्षा करना भी आवश्यक है। streaming library और उसके ऊपर बनाई गई चीजें TCP के समान handshakes के साथ काम करती हैं, जबकि मुख्य I2P protocols (I2NP और I2CP) पूरी तरह से message आधारित हैं (UDP की तरह या कुछ मामलों में raw IP की तरह)। महत्वपूर्ण अंतर यह है कि I2P के साथ, संचार एक long fat network पर काम कर रहा है — प्रत्येक end to end message में महत्वपूर्ण विलंबताएं होंगी, लेकिन इसमें कई KB तक के payloads हो सकते हैं। एक ऐसे application को जिसे एक सरल request और response की आवश्यकता है, वह किसी भी state से छुटकारा पा सकता है और (best effort) datagrams का उपयोग करके startup और teardown handshakes द्वारा होने वाली विलंबता को कम कर सकता है, बिना MTU detection या messages के fragmentation की चिंता किए।\nFigure 1: Creating a server-client connection using I2PTunnel only requires creating a single tunnel. Figure 2: Setting up connections for a peer-to-peer applications requires a very large amount of tunnels. संक्षेप में, I2P-विशिष्ट कोड लिखने के कई कारण: बड़ी संख्या में I2PTunnel instances बनाने से संसाधनों की काफी खपत होती है, जो वितरित अनुप्रयोगों के लिए समस्याग्रस्त है (प्रत्येक peer के लिए एक नई tunnel की आवश्यकता होती है)। सामान्य नेटवर्क प्रोटोकॉल अक्सर बहुत अधिक अतिरिक्त डेटा भेजते हैं जिसका उपयोग उपयोगकर्ताओं की पहचान करने के लिए किया जा सकता है। I2P के लिए विशेष रूप से प्रोग्रामिंग करने से एक ऐसा नेटवर्क प्रोटोकॉल बनाया जा सकता है जो ऐसी जानकारी को लीक नहीं करता, उपयोगकर्ताओं को गुमनाम और सुरक्षित रखता है। नियमित इंटरनेट पर उपयोग के लिए डिज़ाइन किए गए नेटवर्क प्रोटोकॉल I2P पर अकुशल हो सकते हैं, जो कि बहुत अधिक latency वाला नेटवर्क है। I2P डेवलपर्स के लिए एक मानक plugins इंटरफ़ेस का समर्थन करता है ताकि एप्लिकेशन को आसानी से एकीकृत और वितरित किया जा सके।\nJava में लिखे गए और मानक webapps/app.war के माध्यम से HTML इंटरफ़ेस का उपयोग करके सुलभ/चलाने योग्य एप्लिकेशन को I2P वितरण में शामिल करने के लिए विचार किया जा सकता है।\nमहत्वपूर्ण अवधारणाएं I2P का उपयोग करते समय कुछ बदलाव हैं जिनके लिए समायोजन की आवश्यकता होती है:\nगंतव्य I2P पर चलने वाला एक एप्लिकेशन एक अद्वितीय क्रिप्टोग्राफिक रूप से सुरक्षित अंतिम बिंदु — एक \u0026ldquo;destination\u0026rdquo; से संदेश भेजता है और प्राप्त करता है। TCP या UDP के संदर्भ में, एक destination को (मुख्यतः) hostname और port number की जोड़ी के समकक्ष माना जा सकता है, हालांकि कुछ अंतर हैं।\nएक I2P destination स्वयं एक क्रिप्टोग्राफिक संरचना है — इसे भेजा गया सभी डेटा एन्क्रिप्टेड होता है मानो IPsec की सार्वभौमिक तैनाती हो, जिसमें अंतिम बिंदु का (गुमनाम) स्थान हस्ताक्षरित होता है मानो DNSSEC की सार्वभौमिक तैनाती हो। I2P destinations मोबाइल पहचानकर्ता हैं — इन्हें एक I2P router से दूसरे में स्थानांतरित किया जा सकता है (या यह \u0026ldquo;मल्टीहोम\u0026rdquo; भी हो सकता है — एक साथ कई routers पर संचालित हो सकता है)। यह TCP या UDP की दुनिया से काफी अलग है जहां एक एकल अंतिम बिंदु (पोर्ट) को एक ही होस्ट पर रहना होता है। I2P destinations भद्दे और बड़े होते हैं — पर्दे के पीछे, इनमें एन्क्रिप्शन के लिए एक 2048 बिट ElGamal सार्वजनिक कुंजी, हस्ताक्षर के लिए एक 1024 बिट DSA सार्वजनिक कुंजी, और एक परिवर्तनशील आकार का प्रमाणपत्र होता है, जिसमें proof of work या ब्लाइंडेड डेटा हो सकता है। इन बड़े और जटिल destinations को छोटे और सुंदर नामों (जैसे \u0026ldquo;irc.duck.i2p\u0026rdquo;) से संदर्भित करने के मौजूदा तरीके हैं, लेकिन वे तकनीकें वैश्विक रूप से विशिष्टता की गारंटी नहीं देती हैं (क्योंकि वे प्रत्येक व्यक्ति की मशीन पर स्थानीय रूप से एक डेटाबेस में संग्रहीत होते हैं) और वर्तमान तंत्र विशेष रूप से स्केलेबल या सुरक्षित नहीं है (होस्ट सूची के अपडेट को नामकरण सेवाओं की \u0026ldquo;सदस्यताओं\u0026rdquo; का उपयोग करके प्रबंधित किया जाता है)। भविष्य में कोई सुरक्षित, मानव-पठनीय, स्केलेबल और वैश्विक रूप से विशिष्ट नामकरण प्रणाली हो सकती है, लेकिन अनुप्रयोगों को इसके लागू होने पर निर्भर नहीं होना चाहिए। नामकरण प्रणाली पर अधिक जानकारी उपलब्ध है।\nजबकि अधिकांश एप्लिकेशन को प्रोटोकॉल और पोर्ट्स में अंतर करने की आवश्यकता नहीं होती है, I2P इन्हें समर्थन करता है। जटिल एप्लिकेशन प्रति-संदेश के आधार पर एक प्रोटोकॉल, from port, और to port निर्दिष्ट कर सकते हैं, ताकि एकल destination पर ट्रैफ़िक को multiplex किया जा सके। विवरण के लिए datagram page देखें। सरल एप्लिकेशन एक destination के \u0026ldquo;सभी प्रोटोकॉल\u0026rdquo; पर \u0026ldquo;सभी पोर्ट्स\u0026rdquo; को सुनकर काम करते हैं।\nगुमनामी और गोपनीयता I2P में नेटवर्क पर भेजे गए सभी डेटा के लिए पारदर्शी एंड-टू-एंड एन्क्रिप्शन और प्रमाणीकरण है — यदि Bob, Alice के destination को भेजता है, तो केवल Alice का destination ही इसे प्राप्त कर सकता है, और यदि Bob datagrams या streaming लाइब्रेरी का उपयोग कर रहा है, तो Alice निश्चित रूप से जानती है कि Bob का destination ही वह है जिसने डेटा भेजा है।\nनिःसंदेह, I2P एलिस और बॉब के बीच भेजे गए डेटा को पारदर्शी रूप से गुमनाम बनाता है, लेकिन यह उनके द्वारा भेजी गई सामग्री को गुमनाम बनाने के लिए कुछ नहीं करता। उदाहरण के लिए, यदि एलिस बॉब को अपने पूरे नाम, सरकारी पहचान पत्र और क्रेडिट कार्ड नंबर वाला एक फॉर्म भेजती है, तो I2P कुछ नहीं कर सकता। इस प्रकार, प्रोटोकॉल और एप्लिकेशन को यह ध्यान में रखना चाहिए कि वे किस जानकारी को सुरक्षित करने का प्रयास कर रहे हैं और किस जानकारी को उजागर करने के लिए तैयार हैं।\nI2P डेटाग्राम कई KB तक हो सकते हैं I2P datagrams का उपयोग करने वाले एप्लिकेशन (चाहे raw हों या repliable) को मूल रूप से UDP के संदर्भ में समझा जा सकता है — datagrams अव्यवस्थित, सर्वोत्तम प्रयास, और connectionless होते हैं — लेकिन UDP के विपरीत, एप्लिकेशन को MTU detection की चिंता करने की आवश्यकता नहीं है और वे बड़े datagrams को सीधे भेज सकते हैं। जबकि ऊपरी सीमा नाममात्र रूप से 32 KB है, संदेश को परिवहन के लिए खंडित किया जाता है, इस प्रकार संपूर्ण की विश्वसनीयता कम हो जाती है। वर्तमान में लगभग 10 KB से अधिक के datagrams की अनुशंसा नहीं की जाती है। विवरण के लिए datagram page देखें। कई एप्लिकेशन के लिए, 10 KB डेटा एक संपूर्ण अनुरोध या प्रतिक्रिया के लिए पर्याप्त है, जो उन्हें I2P में UDP-जैसे एप्लिकेशन के रूप में पारदर्शी रूप से संचालित करने की अनुमति देता है बिना fragmentation, resends, आदि लिखने की आवश्यकता के।\nविकास विकल्प I2P पर डेटा भेजने के कई तरीके हैं, प्रत्येक के अपने फायदे और नुकसान हैं। streaming lib अनुशंसित इंटरफ़ेस है, जिसका उपयोग अधिकांश I2P अनुप्रयोगों द्वारा किया जाता है।\nस्ट्रीमिंग लाइब पूर्ण streaming लाइब्रेरी अब मानक इंटरफ़ेस है। यह TCP-जैसे सockets का उपयोग करके प्रोग्रामिंग की अनुमति देता है, जैसा कि Streaming विकास गाइड में समझाया गया है।\nBOB BOB Basic Open Bridge है, जो किसी भी भाषा में एप्लिकेशन को I2P से और I2P की ओर streaming connections बनाने की अनुमति देता है। इस समय इसमें UDP समर्थन की कमी है, लेकिन निकट भविष्य में UDP समर्थन की योजना है। BOB में कई उपकरण भी शामिल हैं, जैसे destination key generation, और यह सत्यापन कि कोई address I2P specifications के अनुरूप है। अद्यतन जानकारी और BOB का उपयोग करने वाले एप्लिकेशन इस I2P Site पर मिल सकते हैं।\nSAM, SAM V2, SAM V3 SAM अनुशंसित नहीं है। SAM V2 ठीक है, SAM V3 अनुशंसित है।\nSAM Simple Anonymous Messaging प्रोटोकॉल है, जो किसी भी भाषा में लिखे गए एप्लिकेशन को एक सामान्य TCP सॉकेट के माध्यम से SAM bridge से संवाद करने की अनुमति देता है और वह bridge इसके सभी I2P ट्रैफ़िक को multiplex करता है, encryption/decryption और event आधारित handling को पारदर्शी रूप से समन्वयित करता है। SAM तीन प्रकार के संचालन का समर्थन करता है:\nstreams, जब Alice और Bob एक-दूसरे को विश्वसनीय रूप से और क्रम में डेटा भेजना चाहते हैं repliable datagrams, जब Alice Bob को एक संदेश भेजना चाहती है जिसका Bob जवाब दे सके raw datagrams, जब Alice अधिकतम बैंडविड्थ और प्रदर्शन प्राप्त करना चाहती है, और Bob को इस बात की परवाह नहीं है कि डेटा का प्रेषक प्रमाणित है या नहीं (जैसे स्थानांतरित डेटा स्वयं-प्रमाणित है) SAM V3 का लक्ष्य SAM और SAM V2 के समान है, लेकिन इसमें multiplexing/demultiplexing की आवश्यकता नहीं होती है। प्रत्येक I2P stream को एप्लिकेशन और SAM bridge के बीच अपने स्वयं के socket द्वारा संभाला जाता है। इसके अलावा, SAM bridge के साथ datagram संचार के माध्यम से एप्लिकेशन द्वारा datagram भेजे और प्राप्त किए जा सकते हैं।\nSAM V2 एक नया संस्करण है जिसका उपयोग imule द्वारा किया जाता है और जो SAM की कुछ समस्याओं को ठीक करता है।\nSAM V3 का उपयोग imule द्वारा संस्करण 1.4.0 से किया जाता है।\nI2PTunnel I2PTunnel एप्लिकेशन अनुप्रयोगों को विशिष्ट TCP-जैसी tunnels बनाने की अनुमति देता है जो peers से जुड़ती हैं, या तो I2PTunnel \u0026lsquo;client\u0026rsquo; एप्लिकेशन बनाकर (जो एक विशिष्ट पोर्ट पर सुनते हैं और जब भी उस पोर्ट पर कोई सॉकेट खुलता है तो एक विशिष्ट I2P destination से कनेक्ट होते हैं) या I2PTunnel \u0026lsquo;server\u0026rsquo; एप्लिकेशन बनाकर (जो एक विशिष्ट I2P destination को सुनते हैं और जब भी उसे नया I2P कनेक्शन मिलता है तो यह एक विशिष्ट TCP host/port पर outproxy करता है)। ये streams 8-bit clean हैं, और उसी streaming library के माध्यम से प्रमाणित और सुरक्षित हैं जिसका SAM उपयोग करता है, लेकिन कई अद्वितीय I2PTunnel instances बनाने में एक महत्वपूर्ण ओवरहेड शामिल है, क्योंकि प्रत्येक का अपना अद्वितीय I2P destination और अपना tunnels, keys आदि का सेट होता है।\nSOCKS I2P एक SOCKS V4 और V5 proxy का समर्थन करता है। आउटबाउंड कनेक्शन अच्छी तरह से काम करते हैं। इनबाउंड (server) और UDP कार्यक्षमता अधूरी और परीक्षण रहित हो सकती है।\nMinistreaming हटाया गया\nपहले एक सरल \u0026ldquo;ministreaming\u0026rdquo; library थी, लेकिन अब ministreaming.jar में केवल पूर्ण streaming library के लिए interfaces हैं।\nडेटाग्राम UDP-जैसे अनुप्रयोगों के लिए अनुशंसित\nDatagram library UDP-जैसे पैकेट भेजने की अनुमति देता है। इसका उपयोग करना संभव है:\nउत्तर देने योग्य डेटाग्राम कच्चे डेटाग्राम I2CP अनुशंसित नहीं\nI2CP स्वयं एक भाषा स्वतंत्र प्रोटोकॉल है, लेकिन Java के अलावा किसी अन्य भाषा में I2CP लाइब्रेरी को लागू करने के लिए काफी मात्रा में कोड लिखना पड़ता है (encryption रूटीन, object marshalling, asynchronous message handling, आदि)। हालांकि कोई व्यक्ति C या किसी अन्य भाषा में I2CP लाइब्रेरी लिख सकता है, फिर भी इसके बजाय C SAM लाइब्रेरी का उपयोग करना अधिक उपयोगी होगा।\nवेब अनुप्रयोग I2P, Jetty webserver के साथ आता है, और इसके बजाय Apache server का उपयोग करने के लिए कॉन्फ़िगर करना सरल है। कोई भी मानक वेब ऐप तकनीक काम करनी चाहिए।\nविकास शुरू करें — एक सरल मार्गदर्शिका I2P का उपयोग करके विकास करने के लिए एक कार्यशील I2P इंस्टॉलेशन और आपकी अपनी पसंद का एक विकास वातावरण आवश्यक है। यदि आप Java का उपयोग कर रहे हैं, तो आप streaming library या datagram library के साथ विकास शुरू कर सकते हैं। किसी अन्य प्रोग्रामिंग भाषा का उपयोग करते समय, SAM या BOB का उपयोग किया जा सकता है।\nस्ट्रीमिंग लाइब्रेरी के साथ विकास करना नीचे मूल पृष्ठ में दिए गए उदाहरण का एक संक्षिप्त और आधुनिक संस्करण है। पूर्ण उदाहरण के लिए, legacy पृष्ठ या codebase में हमारे Java उदाहरण देखें।\n// Server example (excerpt) I2PSocketManager manager = I2PSocketManagerFactory.createManager(); I2PServerSocket server = manager.getServerSocket(); I2PSocket socket = server.accept(); BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream())); String s; while ((s = br.readLine()) != null) { System.out.println(\u0026#34;Received: \u0026#34; + s); } कोड उदाहरण: डेटा प्राप्त करने वाला बुनियादी सर्वर।\n// Client example (excerpt) I2PSocketManager manager = I2PSocketManagerFactory.createManager(); Destination dest = new Destination(serverDestBase64); I2PSocket socket = manager.connect(dest); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream())); bw.write(\u0026#34;Hello I2P!\\n\u0026#34;); bw.flush(); कोड उदाहरण: क्लाइंट कनेक्ट करना और एक लाइन भेजना।\n","description":"I2P-विशिष्ट ऐप्स क्यों लिखें, मुख्य अवधारणाएं, विकास विकल्प, और एक सरल शुरुआती गाइड","id":"d137fc4f3bedf693b877aa1ba9bde3eb","section":"docs","title":"एप्लिकेशन विकास","url":"/hi/docs/develop/applications/"},{"categories":null,"content":"I2P का प्लगइन फ्रेमवर्क आपको कोर इंस्टॉलेशन को छुए बिना router को विस्तारित करने की अनुमति देता है। उपलब्ध प्लगइन में मेल, ब्लॉग, IRC, स्टोरेज, विकी, मॉनिटरिंग टूल्स और बहुत कुछ शामिल है।\nसुरक्षा नोट: प्लगइन्स राउटर के समान अनुमतियों के साथ चलते हैं। तृतीय-पक्ष डाउनलोड को उसी तरह से ट्रीट करें जैसे आप किसी signed सॉफ़्टवेयर अपडेट को करते हैं—इंस्टॉल करने से पहले स्रोत को सत्यापित करें।\n1. प्लगइन इंस्टॉल करें प्रोजेक्ट पेज से plugin का download URL कॉपी करें।\nrouter console का Plugin Configuration page खोलें।\nURL को install फील्ड में पेस्ट करें और Install Plugin पर क्लिक करें।\nराउटर हस्ताक्षरित आर्काइव को फेच करता है, हस्ताक्षर को सत्यापित करता है, और प्लगइन को तुरंत सक्रिय कर देता है। अधिकांश प्लगइन्स राउटर रीस्टार्ट की आवश्यकता के बिना कंसोल लिंक या बैकग्राउंड सेवाएं जोड़ते हैं।\n2. प्लगइन्स क्यों महत्वपूर्ण हैं अंतिम उपयोगकर्ताओं के लिए वन-क्लिक वितरण—wrapper.config या clients.config में कोई मैन्युअल संपादन की आवश्यकता नहीं मुख्य i2pupdate.su3 बंडल को छोटा रखता है जबकि मांग पर बड़ी या विशिष्ट सुविधाएं प्रदान करता है वैकल्पिक प्रति-plugin JVMs आवश्यकता पड़ने पर प्रोसेस आइसोलेशन प्रदान करते हैं router संस्करण, Java runtime, और Jetty के विरुद्ध स्वचालित संगतता जांच अपडेट तंत्र router को प्रतिबिंबित करता है: हस्ताक्षरित पैकेज और वृद्धिशील डाउनलोड Console इंटीग्रेशन, भाषा पैक, UI थीम, और गैर-Java ऐप्स (स्क्रिप्ट के माध्यम से) सभी समर्थित हैं क्यूरेटेड \u0026ldquo;app store\u0026rdquo; निर्देशिकाओं जैसे plugins.i2p को सक्षम बनाता है 3. इंस्टॉल किए गए प्लगइन्स को प्रबंधित करें I2P Router Plugin\u0026rsquo;s पर नियंत्रणों का उपयोग करके:\nएक प्लगइन को अपडेट के लिए जांचें सभी प्लगइन को एक साथ जांचें (router अपग्रेड के बाद स्वचालित रूप से सक्रिय होता है) एक क्लिक से उपलब्ध अपडेट इंस्टॉल करें\nसेवाएं रजिस्टर करने वाले प्लगइन के लिए autostart सक्षम/अक्षम करें प्लगइन को साफ तरीके से uninstall करें 4. अपना स्वयं का प्लगइन बनाएं पैकेजिंग, साइनिंग, और मेटाडेटा आवश्यकताओं के लिए plugin specification की समीक्षा करें। मौजूदा बाइनरी या webapp को इंस्टॉल करने योग्य आर्काइव में लपेटने के लिए makeplugin.sh का उपयोग करें। इंस्टॉल और अपडेट दोनों URLs प्रकाशित करें ताकि router पहली बार की इंस्टॉल को इंक्रीमेंटल अपग्रेड से अलग कर सके। प्रामाणिकता सत्यापित करने में उपयोगकर्ताओं की मदद के लिए अपने प्रोजेक्ट पेज पर checksums और signing keys को प्रमुखता से प्रदान करें। उदाहरण खोज रहे हैं? plugins.i2p पर community plugins के source को देखें (उदाहरण के लिए, snowman sample)।\n5. ज्ञात सीमाएं एक प्लगइन को अपडेट करने के लिए जो सादा JAR फ़ाइलें प्रदान करता है, राउटर को पुनः आरंभ करने की आवश्यकता हो सकती है क्योंकि Java class loader कक्षाओं को कैश करता है। कंसोल एक Stop बटन प्रदर्शित कर सकता है भले ही प्लगइन की कोई सक्रिय प्रक्रिया न हो। अलग JVM में लॉन्च किए गए प्लगइन वर्तमान कार्यशील निर्देशिका में एक logs/ डायरेक्टरी बनाते हैं। पहली बार जब एक signer key दिखाई देती है तो उस पर स्वचालित रूप से भरोसा किया जाता है; कोई केंद्रीय हस्ताक्षर प्राधिकरण नहीं है। Windows कभी-कभी प्लगइन को अनइंस्टॉल करने के बाद खाली डायरेक्टरी छोड़ देता है। Java 5 JVM पर Java 6–केवल प्लगइन इंस्टॉल करना Pack200 कम्प्रेशन के कारण \u0026ldquo;plugin is corrupt\u0026rdquo; रिपोर्ट करता है। थीम और अनुवाद प्लगइन काफी हद तक अपरीक्षित रहते हैं। अप्रबंधित प्लगइन के लिए autostart फ्लैग हमेशा बने नहीं रहते। 6. आवश्यकताएं और सर्वोत्तम प्रथाएं प्लगइन सपोर्ट I2P 0.7.12 और नए वर्जन में उपलब्ध है। सुरक्षा सुधार प्राप्त करने के लिए अपने router और प्लगइन को अप टू डेट रखें। संक्षिप्त रिलीज नोट्स शामिल करें ताकि उपयोगकर्ता समझ सकें कि वर्जन के बीच क्या बदलाव हुए हैं। जब संभव हो, I2P के अंदर HTTPS पर प्लगइन आर्काइव होस्ट करें ताकि clear-net मेटाडेटा एक्सपोजर को न्यूनतम किया जा सके। 7. अतिरिक्त पठन सामग्री प्लगइन विशिष्टता क्लाइंट एप्लिकेशन फ्रेमवर्क पैकेजिंग उपयोगिताओं के लिए I2P scripts रिपॉजिटरी ","description":"राउटर प्लगइन्स को इंस्टॉल, अपडेट और डेवलप करना","id":"f8687b90431c32a8ee7e10be9f7c44e0","section":"docs","title":"कस्टम प्लगइन्स इंस्टॉल करना","url":"/hi/docs/guides/plugins/"},{"categories":null,"content":" 1. अवलोकन Garlic routing I2P की मुख्य नवाचारों में से एक है, जो स्तरित एन्क्रिप्शन, संदेश बंडलिंग और एकदिशात्मक tunnels को संयोजित करती है। हालांकि अवधारणात्मक रूप से onion routing के समान, यह मॉडल को विस्तारित करती है और एकल लिफाफे (\u0026ldquo;garlic\u0026rdquo;) में कई एन्क्रिप्टेड संदेशों (\u0026ldquo;cloves\u0026rdquo;) को बंडल करती है, जिससे दक्षता और गुमनामी में सुधार होता है।\ngarlic routing शब्द को Michael J. Freedman द्वारा Roger Dingledine\u0026rsquo;s Free Haven Master\u0026rsquo;s Thesis (जून 2000, §8.1.1) में गढ़ा गया था। I2P डेवलपर्स ने 2000 के दशक की शुरुआत में इस शब्द को अपनाया ताकि इसके बंडलिंग संवर्द्धन और एकदिशात्मक परिवहन मॉडल को दर्शाया जा सके, जो इसे Tor के circuit‑switched डिज़ाइन से अलग करता है।\nसारांश: Garlic routing = स्तरित एन्क्रिप्शन + संदेश बंडलिंग + एकदिशीय tunnels के माध्यम से गुमनाम वितरण।\n2. \u0026ldquo;Garlic\u0026rdquo; शब्दावली ऐतिहासिक रूप से, I2P के भीतर garlic शब्द का उपयोग तीन अलग-अलग संदर्भों में किया गया है:\nस्तरित एन्क्रिप्शन – tunnel-स्तरीय onion-शैली सुरक्षा एकाधिक संदेशों को बंडल करना – एक \u0026ldquo;garlic message\u0026rdquo; के अंदर कई \u0026ldquo;cloves\u0026rdquo; End-to-end एन्क्रिप्शन – पूर्व में ElGamal/AES+SessionTags, अब ECIES‑X25519‑AEAD‑Ratchet जबकि आर्किटेक्चर बरकरार है, एन्क्रिप्शन योजना को पूरी तरह से आधुनिक बनाया गया है।\n3. स्तरित एन्क्रिप्शन Garlic routing अपने मूलभूत सिद्धांत को onion routing के साथ साझा करता है: प्रत्येक router केवल एन्क्रिप्शन की एक परत को डिक्रिप्ट करता है, केवल अगले hop को जानता है और पूर्ण पथ को नहीं।\nहालांकि, I2P unidirectional tunnels (एकदिशीय सुरंगों) को लागू करता है, bidirectional circuits नहीं:\nOutbound tunnel: निर्माता से संदेश भेजता है Inbound tunnel: निर्माता को वापस संदेश लाता है एक पूर्ण राउंड ट्रिप (Alice ↔ Bob) चार tunnels का उपयोग करती है: Alice की outbound → Bob की inbound, फिर Bob की outbound → Alice की inbound। यह डिज़ाइन द्विदिशात्मक सर्किट की तुलना में सहसंबंध डेटा एक्सपोज़र को आधा कर देता है।\nटनल कार्यान्वयन विवरण के लिए, Tunnel Specification और Tunnel Creation (ECIES) स्पेसिफिकेशन देखें।\n4. एकाधिक संदेशों को बंडल करना (\u0026ldquo;Cloves\u0026rdquo;) Freedman की मूल garlic routing ने एक संदेश के भीतर कई एन्क्रिप्टेड \u0026ldquo;bulbs\u0026rdquo; को बंडल करने की कल्पना की थी। I2P इसे garlic message के अंदर cloves के रूप में लागू करता है — प्रत्येक clove के पास अपने स्वयं के एन्क्रिप्टेड डिलीवरी निर्देश और लक्ष्य (router, destination, या tunnel) होते हैं।\nGarlic bundling I2P को निम्नलिखित करने की अनुमति देता है:\nडेटा संदेशों के साथ पावतियों और मेटाडेटा को संयोजित करें दिखाई देने वाले ट्रैफ़िक पैटर्न को कम करें अतिरिक्त कनेक्शन के बिना जटिल संदेश संरचनाओं का समर्थन करें चित्र 1: एक Garlic Message जिसमें कई cloves हैं, प्रत्येक के अपने delivery instructions के साथ।\nविशिष्ट लौंग में शामिल हैं:\nडिलीवरी स्टेटस मैसेज — डिलीवरी की सफलता या विफलता की पुष्टि करने वाली acknowledgments।\nइन्हें गोपनीयता बनाए रखने के लिए अपनी garlic परत में लपेटा जाता है। डेटाबेस स्टोर मैसेज — स्वचालित रूप से बंडल किए गए LeaseSets ताकि peers बिना netDb को फिर से क्वेरी किए जवाब दे सकें। लौंग को बंडल किया जाता है जब:\nएक नया LeaseSet प्रकाशित किया जाना चाहिए नए session tags वितरित किए जाते हैं हाल ही में कोई बंडल नहीं हुआ है (~1 मिनट डिफ़ॉल्ट रूप से) Garlic messages एक ही पैकेट में कई एन्क्रिप्टेड घटकों की कुशल एंड-टू-एंड डिलीवरी प्राप्त करते हैं।\n5. एन्क्रिप्शन का विकास 5.1 Historical Context प्रारंभिक दस्तावेज़ीकरण (≤ v0.9.12) में ElGamal/AES+SessionTags एन्क्रिप्शन का वर्णन किया गया था: - ElGamal 2048‑bit ने AES session keys को लपेटा - AES‑256/CBC पेलोड एन्क्रिप्शन के लिए - 32‑बाइट session tags प्रति संदेश एक बार उपयोग किए गए\nवह क्रिप्टोसिस्टम पुराना हो चुका है।\n5.2 ECIES‑X25519‑AEAD‑Ratchet (Current Standard) 2019 और 2023 के बीच, I2P पूरी तरह से ECIES‑X25519‑AEAD‑Ratchet में स्थानांतरित हो गया। आधुनिक स्टैक निम्नलिखित घटकों को मानकीकृत करता है:\nLayer ECIES Primitive or Concept Transport Layer (NTCP2, SSU2) Noise_NX → X25519, ChaCha20/Poly1305, BLAKE2s I2NP Delivery ECIES‑X25519‑AEAD (ChaCha20/Poly1305) Session Management Ratchet with rekey records, per-clove key material Offline Authentication EdDSA (Ed25519) with LeaseSet2/MetaLeaseSet chains ECIES माइग्रेशन के लाभ: Forward secrecy प्रति-संदेश ratcheting keys के माध्यम से ElGamal की तुलना में कम payload size क्रिप्टोएनालिटिक प्रगति के खिलाफ लचीलापन भविष्य के post-quantum hybrids के साथ संगतता (Proposal 169 देखें) अतिरिक्त विवरण: ECIES विशिष्टता और EncryptedLeaseSet विशिष्टता देखें।\n6. LeaseSets and Garlic Bundling Garlic envelopes में अक्सर गंतव्य की पहुँच को प्रकाशित या अपडेट करने के लिए LeaseSets शामिल होते हैं।\nVersion Type Key Capabilities Distribution Notes 1 LeaseSet (legacy) Single encryption/signature pair Accepted for backward compatibility 3 LeaseSet2 Multiple crypto suites, offline signing keys Default for modern routers 5 EncryptedLeaseSet Access-controlled, destination hidden from floodfill Requires shared decryption key 7 MetaLeaseSet Aggregates multiple destinations or multi-homed services Extends LeaseSet2 fields recursively सभी LeaseSets विशेष routers द्वारा बनाए रखे गए *floodfill DHT* के माध्यम से वितरित किए जाते हैं। प्रकाशनों को सत्यापित, टाइमस्टैम्प और दर-सीमित किया जाता है ताकि मेटाडेटा सहसंबंध को कम किया जा सके। विवरण के लिए Network Database दस्तावेज़ देखें।\n7. Modern “Garlic” Applications within I2P I2P प्रोटोकॉल स्टैक में garlic-based एन्क्रिप्शन और मैसेज बंडलिंग का उपयोग किया जाता है:\nTunnel निर्माण और उपयोग — प्रत्येक hop के लिए स्तरित एन्क्रिप्शन End-to-end संदेश वितरण — cloned-acknowledgment और LeaseSet cloves के साथ बंडल किए गए garlic messages Network Database प्रकाशन — गोपनीयता के लिए garlic envelopes में लिपटे LeaseSets SSU2 और NTCP2 transports — Noise फ्रेमवर्क और X25519/ChaCha20 primitives का उपयोग करके underlay एन्क्रिप्शन Garlic routing इस प्रकार एक एन्क्रिप्शन लेयरिंग की विधि और एक नेटवर्क मैसेजिंग मॉडल दोनों है।\n6. LeaseSets और Garlic Bundling I2P का दस्तावेज़ीकरण केंद्र यहाँ उपलब्ध है , जिसे निरंतर बनाए रखा जाता है। प्रासंगिक सक्रिय विनिर्देशों में शामिल हैं:\nECIES Specification — ECIES‑X25519‑AEAD‑Ratchet Tunnel Creation (ECIES) — आधुनिक tunnel निर्माण प्रोटोकॉल I2NP Specification — I2NP संदेश प्रारूप SSU2 Specification — SSU2 UDP परिवहन Common Structures — netDb और floodfill व्यवहार शैक्षणिक सत्यापन: Hoang et al. (IMC 2018, USENIX FOCI 2019) और Muntaka et al. (2025) I2P की डिज़ाइन की संरचनात्मक स्थिरता और परिचालन लचीलापन की पुष्टि करते हैं।\n7. I2P के भीतर आधुनिक \u0026ldquo;Garlic\u0026rdquo; अनुप्रयोग चल रहे प्रस्ताव:\nप्रस्ताव 169: हाइब्रिड पोस्ट-क्वांटम (ML-KEM 512/768/1024 + X25519) प्रस्ताव 168: Transport बैंडविड्थ अनुकूलन डेटाग्राम और स्ट्रीमिंग अपडेट: उन्नत कंजेशन प्रबंधन भविष्य के अनुकूलन में अतिरिक्त संदेश विलंब रणनीतियाँ या garlic-message स्तर पर बहु-tunnel अतिरेक शामिल हो सकते हैं, जो Freedman द्वारा मूल रूप से वर्णित अप्रयुक्त डिलीवरी विकल्पों पर आधारित होंगे।\n8. वर्तमान दस्तावेज़ीकरण और संदर्भ Freedman, M. J. \u0026amp; Dingledine, R. (2000). Free Haven Master\u0026rsquo;s Thesis, § 8.1.1. Free Haven Papers Onion Router Publications Garlic Routing (Wikipedia) Tor Project Free Haven Anonbib Goldschlag, D. M., Reed, M. G., Syverson, P. F. (1996). Hiding Routing Information. NRL Publication. ","description":"I2P में garlic routing शब्दावली, आर्किटेक्चर, और आधुनिक कार्यान्वयन को समझना","id":"ba07d93d883918641f4a69832e497bb8","section":"docs","title":"गार्लिक रूटिंग (Garlic Routing)","url":"/hi/docs/overview/garlic-routing/"},{"categories":null,"content":"अवलोकन I2P अस्थायी, एकदिशात्मक tunnels बनाता है — routers का क्रमबद्ध अनुक्रम जो एन्क्रिप्टेड ट्रैफ़िक को अग्रेषित करते हैं। Tunnels को inbound (संदेश निर्माता की ओर प्रवाहित होते हैं) या outbound (संदेश निर्माता से दूर प्रवाहित होते हैं) के रूप में वर्गीकृत किया जाता है।\nएक सामान्य आदान-प्रदान में Alice का संदेश उसकी किसी एक outbound tunnel के माध्यम से बाहर भेजा जाता है, outbound endpoint को निर्देश दिया जाता है कि वह इसे Bob की किसी एक inbound tunnel के gateway को अग्रेषित करे, और फिर Bob इसे अपने inbound endpoint पर प्राप्त करता है।\nA: Outbound Gateway (Alice) B: Outbound Participant C: Outbound Endpoint D: Inbound Gateway E: Inbound Participant F: Inbound Endpoint (Bob) टनल का निश्चित जीवनकाल 10 मिनट होता है और ये 1024 बाइट्स के निश्चित आकार के संदेश वहन करती हैं (tunnel header सहित 1028 बाइट्स), ताकि संदेश के आकार या समय पैटर्न के आधार पर ट्रैफिक विश्लेषण को रोका जा सके।\nटनल शब्दावली Tunnel gateway: tunnel में पहला router। Inbound tunnels के लिए, इस router की पहचान प्रकाशित LeaseSet में दिखाई देती है। Outbound tunnels के लिए, gateway मूल router है (ऊपर A और D)। Tunnel endpoint: tunnel में अंतिम router (ऊपर C और F)। Tunnel participant: tunnel में मध्यवर्ती router (ऊपर B और E)। Participants अपनी स्थिति या tunnel की दिशा निर्धारित नहीं कर सकते। n-hop tunnel: inter-router hops की संख्या। 0-hop: Gateway और endpoint एक ही router हैं – न्यूनतम गुमनामी। 1-hop: Gateway सीधे endpoint से जुड़ता है – कम विलंबता, कम गुमनामी। 2-hop: Exploratory tunnels के लिए डिफ़ॉल्ट; संतुलित सुरक्षा/प्रदर्शन। 3-hop: मजबूत गुमनामी की आवश्यकता वाले अनुप्रयोगों के लिए अनुशंसित। Tunnel ID: 4-byte integer जो प्रत्येक router और प्रत्येक hop के लिए अद्वितीय है, निर्माता द्वारा यादृच्छिक रूप से चुना गया। प्रत्येक hop विभिन्न IDs पर प्राप्त और forward करता है। टनल निर्माण जानकारी gateway, participant, और endpoint भूमिकाओं को भरने वाले Routers, Tunnel Build Message के भीतर विभिन्न रिकॉर्ड प्राप्त करते हैं। आधुनिक I2P दो तरीकों का समर्थन करता है:\nElGamal (लीगेसी, 528-बाइट रिकॉर्ड) ECIES-X25519 (वर्तमान, 218-बाइट रिकॉर्ड Short Tunnel Build Message – STBM के माध्यम से) Information Distributed to Participants Gateway प्राप्त करता है: - Tunnel layer key (AES-256 या ChaCha20 key, tunnel प्रकार के आधार पर) - Tunnel IV key (initialization vectors को encrypt करने के लिए) - Reply key और reply IV (build reply encryption के लिए) - Tunnel ID (केवल inbound gateways) - Next hop identity hash और tunnel ID (यदि non-terminal हो)\nमध्यवर्ती प्रतिभागी प्राप्त करते हैं: - अपने hop के लिए Tunnel layer key और IV key - Tunnel ID और अगले hop की जानकारी - build response एन्क्रिप्शन के लिए Reply key और IV\nEndpoints प्राप्त करते हैं: - Tunnel layer और IV keys - Reply router और tunnel ID (केवल outbound endpoints) - Reply key और IV (केवल outbound endpoints)\nपूरी जानकारी के लिए देखें Tunnel Creation Specification और ECIES Tunnel Creation Specification ।\nTunnel Pooling राउटर अतिरेक (redundancy) और लोड वितरण के लिए टनल को tunnel pools में समूहित करते हैं। प्रत्येक पूल कई समानांतर टनल बनाए रखता है, जो एक के विफल होने पर failover की अनुमति देता है। आंतरिक रूप से उपयोग किए जाने वाले पूल exploratory tunnels हैं, जबकि एप्लिकेशन-विशिष्ट पूल client tunnels हैं।\nप्रत्येक destination अलग-अलग inbound और outbound pools को बनाए रखता है जो I2CP विकल्पों द्वारा कॉन्फ़िगर किए जाते हैं (tunnel संख्या, backup संख्या, लंबाई, और QoS पैरामीटर)। Routers tunnel स्वास्थ्य की निगरानी करते हैं, आवधिक परीक्षण चलाते हैं, और pool का आकार बनाए रखने के लिए विफल tunnels को स्वचालित रूप से पुनर्निर्माण करते हैं।\nटनल पूलिंग 0-hop Tunnels: केवल संभावित इनकार (plausible deniability) प्रदान करती हैं। ट्रैफ़िक हमेशा एक ही router से उत्पन्न होता है और समाप्त होता है — किसी भी अनाम उपयोग के लिए हतोत्साहित।\n1-hop Tunnels: निष्क्रिय पर्यवेक्षकों के विरुद्ध बुनियादी गुमनामी प्रदान करते हैं लेकिन यदि कोई विरोधी उस एकल hop को नियंत्रित करता है तो असुरक्षित हैं।\n2-hop Tunnels : दो दूरस्थ राउटर शामिल करती हैं और हमले की लागत को काफी बढ़ाती हैं। खोजपूर्ण पूल के लिए डिफ़ॉल्ट।\n3-hop Tunnels: मजबूत गुमनामी सुरक्षा की आवश्यकता वाले अनुप्रयोगों के लिए अनुशंसित। अतिरिक्त hops बिना किसी सार्थक सुरक्षा लाभ के विलंबता बढ़ाते हैं।\nडिफ़ॉल्ट : Router 2-hop exploratory tunnel और एप्लिकेशन-विशिष्ट 2 या 3 hop client tunnel का उपयोग करते हैं, जो प्रदर्शन और गुमनामी को संतुलित करते हैं।\nटनल की लंबाई राउटर समय-समय पर एक आउटबाउंड टनल के माध्यम से एक इनबाउंड टनल में DeliveryStatusMessage भेजकर टनल का परीक्षण करते हैं। यदि परीक्षण विफल होता है, तो दोनों टनल को नकारात्मक प्रोफ़ाइल भार मिलता है। लगातार विफलताएं एक टनल को अनुपयोगी चिह्नित करती हैं; फिर राउटर एक प्रतिस्थापन का पुनर्निर्माण करता है और एक नया LeaseSet प्रकाशित करता है। परिणाम पीयर क्षमता मेट्रिक्स में शामिल होते हैं जो peer selection system द्वारा उपयोग किए जाते हैं।\nटनल परीक्षण Router एक गैर-इंटरैक्टिव telescoping विधि का उपयोग करके tunnel निर्माण करते हैं: एक एकल Tunnel Build Message hop-by-hop प्रसारित होता है। प्रत्येक hop अपने रिकॉर्ड को डिक्रिप्ट करता है, अपना उत्तर जोड़ता है, और संदेश को आगे भेजता है। अंतिम hop एक अलग पथ के माध्यम से समग्र बिल्ड उत्तर लौटाता है, जो सहसंबंध को रोकता है। आधुनिक कार्यान्वयन ECIES के लिए Short Tunnel Build Messages (STBM) और पुराने पथों के लिए Variable Tunnel Build Messages (VTBM) का उपयोग करते हैं। प्रत्येक रिकॉर्ड को ElGamal या ECIES-X25519 का उपयोग करके per-hop एन्क्रिप्ट किया जाता है।\nटनल निर्माण टनल ट्रैफ़िक बहु-स्तरीय एन्क्रिप्शन का उपयोग करता है। जब संदेश tunnel से गुजरते हैं तो प्रत्येक hop एन्क्रिप्शन की एक परत जोड़ता या हटाता है।\nElGamal tunnels: PKCS#5 padding के साथ payloads के लिए AES-256/CBC। ECIES tunnels: authenticated encryption के लिए ChaCha20 या ChaCha20-Poly1305। प्रत्येक hop में दो keys होती हैं: एक layer key और एक IV key। Routers IV को decrypt करते हैं, इसका उपयोग payload को process करने के लिए करते हैं, फिर forward करने से पहले IV को फिर से encrypt करते हैं। यह double IV scheme message tagging को रोकती है।\nआउटबाउंड गेटवे सभी परतों को पहले से डिक्रिप्ट करते हैं ताकि सभी प्रतिभागियों द्वारा एन्क्रिप्शन जोड़े जाने के बाद एंडपॉइंट को प्लेनटेक्स्ट प्राप्त हो। इनबाउंड tunnel विपरीत दिशा में एन्क्रिप्ट करते हैं। प्रतिभागी tunnel की दिशा या लंबाई निर्धारित नहीं कर सकते।\nटनल एन्क्रिप्शन नेटवर्क लोड संतुलन के लिए डायनामिक tunnel जीवनकाल और अनुकूली पूल आकार वैकल्पिक tunnel परीक्षण रणनीतियाँ और व्यक्तिगत हॉप निदान वैकल्पिक proof-of-work या bandwidth प्रमाणपत्र सत्यापन (API 0.9.65+ में लागू) endpoint मिश्रण के लिए ट्रैफ़िक शेपिंग और chaff सम्मिलन अनुसंधान ElGamal की निरंतर सेवानिवृत्ति और ECIES-X25519 में माइग्रेशन चल रहा विकास Tunnel Implementation Specification Tunnel Creation Specification (ElGamal) Tunnel Creation Specification (ECIES-X25519) Tunnel Message Specification Garlic Routing I2P Network Database Peer Profiling and Selection I2P Threat Model ElGamal/AES + SessionTag Encryption I2CP Options ","description":"I2P टनल शब्दावली, निर्माण और जीवनचक्र का अवलोकन","id":"d2bb4d16ccaaecd4bfaae8d5b1356800","section":"docs","title":"टनल रूटिंग","url":"/hi/docs/overview/tunnel-routing/"},{"categories":null,"content":"सारांश Datagrams, I2CP के ऊपर और streaming library के समानांतर संदेश-उन्मुख संचार प्रदान करते हैं। ये connection-oriented streams की आवश्यकता के बिना repliable, authenticated, या raw पैकेट सक्षम करते हैं। Routers, datagrams को I2NP messages और tunnel messages में समाहित करते हैं, चाहे NTCP2 या SSU2 ट्रैफ़िक को वहन करे।\nमुख्य उद्देश्य एप्लिकेशनों (जैसे trackers, DNS resolvers, या गेम) को स्व-निहित पैकेट भेजने की अनुमति देना है जो अपने प्रेषक की पहचान करते हैं।\n2025 में नया: I2P Project ने Datagram2 (protocol 19) और Datagram3 (protocol 20) को स्वीकृत किया, जो एक दशक में पहली बार replay protection और कम-ओवरहेड repliable messaging जोड़ता है।\n1. प्रोटोकॉल स्थिरांक Protocol Value Description Introduced PROTO_DATAGRAM 17 Signed (repliable) datagram – “Datagram1” Original PROTO_DATAGRAM_RAW 18 Unsigned (raw) datagram – no sender info Original PROTO_DATAGRAM2 19 Signed + replay-protected datagram API 0.9.66 (2025) PROTO_DATAGRAM3 20 Repliable (no signature, hash only) API 0.9.66 (2025) प्रोटोकॉल 19 और 20 को **प्रस्ताव 163 (अप्रैल 2025)** में औपचारिक रूप दिया गया था। ये पश्च संगतता (backward compatibility) के लिए Datagram1 / RAW के साथ सह-अस्तित्व में हैं। 2. डेटाग्राम प्रकार Type Protocol Repliable Authenticated Replay Protection Min Overhead Notes Raw 18 No No No 0 Minimal size; spoofable. Datagram1 17 Yes Yes No ≈ 427 Full Destination + signature. Datagram2 19 Yes Yes Yes ≈ 457 Replay prevention + offline signatures; PQ-ready. Datagram3 20 Yes No No ≈ 34 Sender hash only; low overhead. ### विशिष्ट डिज़ाइन पैटर्न Request → Response: एक signed Datagram2 (request + nonce) भेजें, एक raw या Datagram3 reply (echo nonce) प्राप्त करें। High-frequency/low-overhead: Datagram3 या RAW को प्राथमिकता दें। Authenticated control messages: Datagram2। Legacy compatibility: Datagram1 अभी भी पूरी तरह से supported है। 3. Datagram2 और Datagram3 विवरण (2025) Datagram2 (प्रोटोकॉल 19) Datagram1 के लिए उन्नत प्रतिस्थापन। विशेषताएं: - रीप्ले रोकथाम: 4-बाइट एंटी-रीप्ले टोकन। - ऑफ़लाइन हस्ताक्षर समर्थन: ऑफ़लाइन-हस्ताक्षरित Destinations द्वारा उपयोग सक्षम करता है। - विस्तारित हस्ताक्षर कवरेज: destination hash, flags, options, offline sig block, payload शामिल हैं। - पोस्ट-क्वांटम तैयार: भविष्य के ML-KEM हाइब्रिड के साथ संगत। - ओवरहेड: ≈ 457 बाइट्स (X25519 keys)।\nDatagram3 (प्रोटोकॉल 20) कच्चे और हस्ताक्षरित प्रकारों के बीच अंतर को पाटता है। विशेषताएं: - बिना हस्ताक्षर के उत्तर योग्य: प्रेषक के 32-बाइट हैश + 2-बाइट फ्लैग्स शामिल हैं। - न्यूनतम ओवरहेड: ≈ 34 बाइट्स। - कोई रीप्ले सुरक्षा नहीं — एप्लिकेशन को लागू करना होगा।\nदोनों protocols API 0.9.66 की सुविधाएं हैं और Java router में Release 2.9.0 से लागू हैं; अभी तक कोई i2pd या Go implementations नहीं हैं (अक्टूबर 2025)।\n4. आकार और विखंडन सीमाएं Tunnel संदेश का आकार: 1 028 बाइट्स (4 B Tunnel ID + 16 B IV + 1 008 B payload)। प्रारंभिक खंड: 956 B (सामान्य TUNNEL डिलीवरी)। अनुवर्ती खंड: 996 B। अधिकतम खंड: 63–64। व्यावहारिक सीमा: ≈ 62 708 B (~61 KB)। अनुशंसित सीमा: विश्वसनीय डिलीवरी के लिए ≤ 10 KB (इससे अधिक होने पर ड्रॉप्स तेजी से बढ़ते हैं)। ओवरहेड सारांश: - Datagram1 ≈ 427 B (न्यूनतम)। - Datagram2 ≈ 457 B। - Datagram3 ≈ 34 B। - अतिरिक्त परतें (I2CP gzip header, I2NP, Garlic, Tunnel): + ~5.5 KB सबसे खराब स्थिति में।\n5. I2CP / I2NP एकीकरण संदेश पथ: 1. एप्लिकेशन डेटाग्राम बनाता है (I2P API या SAM के माध्यम से)। 2. I2CP gzip हेडर (0x1F 0x8B 0x08, RFC 1952) और CRC-32 checksum के साथ लपेटता है। 3. प्रोटोकॉल + पोर्ट नंबर gzip हेडर फ़ील्ड में संग्रहीत किए जाते हैं। 4. Router इसे I2NP संदेश के रूप में समाहित करता है → Garlic clove → 1 KB tunnel fragments। 5. Fragments outbound से होते हुए → नेटवर्क → inbound tunnel से गुजरते हैं। 6. पुनः जोड़ा गया डेटाग्राम प्रोटोकॉल नंबर के आधार पर एप्लिकेशन हैंडलर को वितरित किया जाता है।\nअखंडता: CRC-32 (I2CP से) + वैकल्पिक क्रिप्टोग्राफिक हस्ताक्षर (Datagram1/2)। डेटाग्राम के भीतर कोई अलग चेकसम फ़ील्ड नहीं है।\n6. प्रोग्रामिंग इंटरफेस Java API पैकेज net.i2p.client.datagram में शामिल हैं: - I2PDatagramMaker – हस्ताक्षरित datagrams बनाता है। - I2PDatagramDissector – सत्यापित करता है और प्रेषक की जानकारी निकालता है। - I2PInvalidDatagramException – सत्यापन विफल होने पर फेंका जाता है।\nI2PSessionMuxedImpl (net.i2p.client.impl.I2PSessionMuxedImpl) एक Destination साझा करने वाले ऐप्स के लिए प्रोटोकॉल और पोर्ट मल्टीप्लेक्सिंग का प्रबंधन करता है।\nJavadoc पहुंच: - idk.i2p Javadoc (केवल I2P नेटवर्क) - Javadoc Mirror (clearnet मिरर) - Official Javadocs (आधिकारिक दस्तावेज़)\nSAM v3 समर्थन SAM 3.2 (2016): PORT और PROTOCOL पैरामीटर जोड़े गए। SAM 3.3 (2016): PRIMARY/subsession मॉडल पेश किया गया; एक Destination पर streams + datagrams की अनुमति देता है। Datagram2 / 3 session styles के लिए समर्थन spec 2025 में जोड़ा गया (कार्यान्वयन लंबित)। आधिकारिक विनिर्देश: SAM v3 Specification i2ptunnel मॉड्यूल udpTunnel: I2P UDP ऐप्स के लिए पूरी तरह कार्यात्मक आधार (net.i2p.i2ptunnel.udpTunnel)। streamr: A/V स्ट्रीमिंग के लिए परिचालनात्मक (net.i2p.i2ptunnel.streamr)। SOCKS UDP: 2.10.0 तक कार्यात्मक नहीं (केवल UDP स्टब)। सामान्य-उद्देश्य UDP के लिए, Datagram API या udpTunnel का सीधे उपयोग करें—SOCKS UDP पर निर्भर न रहें।\n7. पारिस्थितिकी तंत्र और भाषा समर्थन (2025) Language Library / Package SAM Version Status Javacore API (net.i2p.client.datagram)3.3✓ full support C++i2pd / libsam33.2 partialLimited Gogo-i2p / sam33.1–3.2Active Pythoni2plib, i2p.socket, txi2p3.2Active Rusti2p-rs, i2p_client3.3Active C#I2PSharp3.3Active JS/TSnode-i2p, i2p-sam3.2Active Haskellnetwork-anonymous-i2p3.2Experimental Luamooni2p3.2Experimental Java I2P इस समय एकमात्र router है जो पूर्ण SAM 3.3 subsessions और Datagram2 API का समर्थन करता है। 8. उदाहरण उपयोग – UDP Tracker (I2PSnark 2.10.0) Datagram2/3 का पहला वास्तविक अनुप्रयोग:\nOperation Datagram Type Purpose Announce RequestDatagram3Repliable but low-overhead update ResponseRaw DatagramMinimal payload return पैटर्न सुरक्षा और प्रदर्शन को संतुलित करने के लिए प्रमाणित और हल्के डेटाग्राम के मिश्रित उपयोग को प्रदर्शित करता है। 9. सुरक्षा और सर्वोत्तम प्रथाएं प्रमाणित आदान-प्रदान के लिए या जब replay attacks महत्वपूर्ण हों तो Datagram2 का उपयोग करें। मध्यम विश्वास के साथ तेज़ उत्तर देने योग्य प्रतिक्रियाओं के लिए Datagram3 को प्राथमिकता दें। सार्वजनिक प्रसारण या गुमनाम डेटा के लिए RAW का उपयोग करें। विश्वसनीय वितरण के लिए payloads को ≤ 10 KB रखें। ध्यान रखें कि SOCKS UDP अभी भी कार्यरत नहीं है। प्राप्ति पर हमेशा gzip CRC और digital signatures को सत्यापित करें। 10. तकनीकी विनिर्देश यह खंड निम्न-स्तरीय डेटाग्राम प्रारूपों, एनकैप्सुलेशन, और प्रोटोकॉल विवरणों को कवर करता है।\n10.1 प्रोटोकॉल पहचान Datagram प्रारूपों में एक सामान्य हैडर नहीं होता है। Router केवल payload बाइट्स से प्रकार का अनुमान नहीं लगा सकते।\nजब कई डेटाग्राम प्रकारों को मिलाते हैं—या जब स्ट्रीमिंग के साथ डेटाग्राम को संयोजित करते हैं—तो स्पष्ट रूप से सेट करें: - प्रोटोकॉल नंबर (I2CP या SAM के माध्यम से) - वैकल्पिक रूप से पोर्ट नंबर, यदि आपका एप्लिकेशन सेवाओं को मल्टीप्लेक्स करता है\nप्रोटोकॉल को अनसेट (0 या PROTO_ANY) छोड़ना अनुचित है और इससे रूटिंग या डिलीवरी त्रुटियां हो सकती हैं।\n10.2 रॉ डेटाग्राम नॉन-रिप्लायएबल डेटाग्राम में कोई प्रेषक या प्रमाणीकरण डेटा नहीं होता है। ये अपारदर्शी पेलोड हैं, जो उच्च-स्तरीय डेटाग्राम API के बाहर संभाले जाते हैं लेकिन SAM और I2PTunnel के माध्यम से समर्थित हैं।\nप्रोटोकॉल: 18 (PROTO_DATAGRAM_RAW)\nप्रारूप:\n+----+----+----+----+----// | payload... +----+----+----+----+----// पेलोड की लंबाई ट्रांसपोर्ट सीमाओं द्वारा सीमित है (≈32 KB व्यावहारिक अधिकतम, अक्सर इससे बहुत कम)।\n10.3 डेटाग्राम1 (उत्तर देने योग्य डेटाग्राम) प्रेषक का Destination और प्रमाणीकरण तथा उत्तर पते के लिए एक Signature एम्बेड करता है।\nप्रोटोकॉल: 17 (PROTO_DATAGRAM)\nओवरहेड: ≥427 बाइट्स पेलोड: लगभग ~31.5 KB तक (ट्रांसपोर्ट द्वारा सीमित)\nप्रारूप:\n+----+----+----+----+----+----+----+----+ | from | + + | | ~ Destination bytes ~ | | +----+----+----+----+----+----+----+----+ | signature | + + | | +----+----+----+----+----+----+----+----+ | payload... +----+----+----+----// from: एक Destination (387+ बाइट्स) signature: key type से मेल खाने वाला एक Signature DSA_SHA1 के लिए: payload के SHA-256 hash का Signature अन्य key types के लिए: payload पर सीधे Signature नोट्स: - गैर-DSA प्रकारों के लिए हस्ताक्षर I2P 0.9.14 में मानकीकृत किए गए थे। - LS2 (Proposal 123) ऑफ़लाइन हस्ताक्षर वर्तमान में Datagram1 में समर्थित नहीं हैं।\n10.4 Datagram2 प्रारूप एक बेहतर repliable datagram जो replay resistance (पुनः प्रयोग प्रतिरोध) जोड़ता है जैसा कि Proposal 163 में परिभाषित है।\nप्रोटोकॉल: 19 (PROTO_DATAGRAM2)\nकार्यान्वयन जारी है। अनुप्रयोगों में अतिरेक (redundancy) के लिए nonce या timestamp जांच शामिल होनी चाहिए।\n10.5 Datagram3 प्रारूप उत्तर देने योग्य लेकिन असत्यापित डेटाग्राम प्रदान करता है। एम्बेडेड गंतव्य और हस्ताक्षर के बजाय router द्वारा रखरखाव किए गए सत्र प्रमाणीकरण पर निर्भर करता है।\nप्रोटोकॉल: 20 (PROTO_DATAGRAM3) स्थिति: 0.9.66 से विकास के अधीन\nउपयोगी जब: - Destinations बड़े हों (जैसे, post-quantum keys) - Authentication किसी अन्य layer पर होता हो - Bandwidth efficiency महत्वपूर्ण हो\n10.6 डेटा अखंडता डेटाग्राम की अखंडता I2CP परत में gzip CRC-32 checksum द्वारा सुरक्षित की जाती है। डेटाग्राम पेलोड प्रारूप के भीतर कोई स्पष्ट checksum फ़ील्ड मौजूद नहीं है।\n10.7 पैकेट एनकैप्सुलेशन प्रत्येक डेटाग्राम को एकल I2NP संदेश के रूप में या Garlic Message में एक व्यक्तिगत clove के रूप में एन्कैप्सुलेट किया जाता है। I2CP, I2NP, और tunnel परतें लंबाई और फ्रेमिंग को संभालती हैं — datagram प्रोटोकॉल में कोई आंतरिक सीमांकक या लंबाई फ़ील्ड नहीं है।\n10.8 पोस्ट-क्वांटम (PQ) विचार यदि Proposal 169 (ML-DSA signatures) लागू किया जाता है, तो signature और destination के आकार नाटकीय रूप से बढ़ जाएंगे — ~455 bytes से ≥3739 bytes तक। यह परिवर्तन datagram overhead को काफी बढ़ा देगा और प्रभावी payload क्षमता को कम कर देगा।\nDatagram3, जो सत्र-स्तरीय प्रमाणीकरण (एम्बेडेड हस्ताक्षरों पर नहीं) पर निर्भर करता है, संभवतः पोस्ट-क्वांटम I2P वातावरण में पसंदीदा डिज़ाइन बन जाएगा।\n11. संदर्भ Proposal 163 – Datagram2 और Datagram3 Proposal 160 – UDP Tracker Integration Proposal 144 – Streaming MTU Calculations Proposal 169 – Post-Quantum Signatures I2CP Specification I2NP Specification Tunnel Message Specification SAM v3 Specification i2ptunnel Documentation 12. परिवर्तन लॉग मुख्य बिंदु (2019 – 2025) Year Release Change 20190.9.43Datagram API stabilization 20210.9.50Protocol port handling reworked 20222.0.0SSU2 adoption completed 20242.6.0Legacy transport removal simplified UDP code 20252.9.0Datagram2/3 support added (Java API) 20252.10.0UDP Tracker implementation released --- 13. सारांश डेटाग्राम सबसिस्टम अब चार प्रोटोकॉल वेरिएंट का समर्थन करता है जो पूर्ण-प्रमाणित से लेकर हल्के कच्चे ट्रांसमिशन तक का स्पेक्ट्रम प्रदान करते हैं। डेवलपर्स को सुरक्षा-संवेदनशील उपयोग के मामलों के लिए Datagram2 और कुशल उत्तर योग्य ट्रैफ़िक के लिए Datagram3 की ओर स्थानांतरित होना चाहिए। सभी पुराने प्रकार दीर्घकालिक इंटरऑपरेबिलिटी सुनिश्चित करने के लिए संगत बने रहते हैं।\n","description":"I2CP के ऊपर प्रमाणित, उत्तर देने योग्य, और कच्चे संदेश प्रारूप","id":"b3c644204c779b5d6fc6a41438a3eb1b","section":"docs","title":"डेटाग्राम","url":"/hi/docs/api/datagrams/"},{"categories":null,"content":"I2P प्रोजेक्ट Debian, Ubuntu, और उनके व्युत्पन्न वितरणों के लिए आधिकारिक पैकेज बनाए रखता है। यह गाइड हमारे आधिकारिक रिपॉजिटरी का उपयोग करके I2P इंस्टॉल करने के लिए व्यापक निर्देश प्रदान करती है।\nमुझे खेद है, लेकिन आपने अनुवाद के लिए कोई पाठ प्रदान नहीं किया है। कृपया \u0026ldquo;\u0026mdash;\u0026rdquo; के बाद अनुवाद के लिए अंग्रेजी पाठ प्रदान करें।\n🚀 Beta: स्वचालित इंस्टॉलेशन (प्रयोगात्मक) उन्नत उपयोगकर्ताओं के लिए जो त्वरित स्वचालित इंस्टॉलेशन चाहते हैं:\nयह वन-लाइनर स्वचालित रूप से आपके डिस्ट्रीब्यूशन का पता लगाएगा और I2P इंस्टॉल करेगा। सावधानी के साथ उपयोग करें - चलाने से पहले installation script की समीक्षा करें।\ncurl -fsSL https://i2p.net/installlinux.sh | sudo bash यह क्या करता है: - आपके Linux वितरण (Ubuntu/Debian) का पता लगाता है - उपयुक्त I2P repository जोड़ता है - GPG keys और आवश्यक packages इंस्टॉल करता है - I2P को स्वचालित रूप से इंस्टॉल करता है\n⚠️ यह एक बीटा फीचर है। यदि आप मैन्युअल इंस्टॉलेशन को प्राथमिकता देते हैं या प्रत्येक चरण को समझना चाहते हैं, तो नीचे दिए गए मैन्युअल इंस्टॉलेशन तरीकों का उपयोग करें।\nIMPORTANT: केवल अनुवाद प्रदान करें। प्रश्न न पूछें, स्पष्टीकरण प्रदान न करें, या कोई टिप्पणी न जोड़ें। भले ही पाठ केवल एक शीर्षक हो या अधूरा लगे, इसे जैसा है वैसा ही अनुवाद करें।\nDebian Installation Debian और इसके downstream distributions (LMDE, Kali Linux, ParrotOS, Knoppix, आदि) को deb.i2p.net पर आधिकारिक I2P Debian repository का उपयोग करना चाहिए।\nImportant Notice deb.i2p2.de और deb.i2p2.no पर हमारे पुराने repositories का जीवनकाल समाप्त हो चुका है। यदि आप इन legacy repositories का उपयोग कर रहे हैं, तो कृपया deb.i2p.net पर नए repository में माइग्रेट करने के लिए नीचे दिए गए निर्देशों का पालन करें।\nPrerequisites नीचे दिए गए सभी चरणों के लिए root एक्सेस की आवश्यकता है। या तो su के साथ root उपयोगकर्ता पर स्विच करें, या प्रत्येक कमांड के साथ sudo उपसर्ग (prefix) लगाएं।\nविधि 1: कमांड लाइन इंस्टॉलेशन (अनुशंसित) चरण 1: आवश्यक पैकेज इंस्टॉल करें\nसुनिश्चित करें कि आपके पास आवश्यक टूल इंस्टॉल हैं:\nsudo apt-get update sudo apt-get install apt-transport-https lsb-release curl ये पैकेज सुरक्षित HTTPS रिपॉजिटरी एक्सेस, डिस्ट्रिब्यूशन डिटेक्शन और फ़ाइल डाउनलोड को सक्षम करते हैं।\nचरण 2: I2P रिपॉजिटरी जोड़ें\nआपके द्वारा उपयोग किया जाने वाला command आपके Debian संस्करण पर निर्भर करता है। सबसे पहले, यह निर्धारित करें कि आप कौन सा संस्करण चला रहे हैं:\ncat /etc/debian_version इसे Debian release information के साथ cross-reference करें ताकि आपके distribution codename (जैसे, Bookworm, Bullseye, Buster) की पहचान की जा सके।\nडेबियन बुल्सआई (11) या नए संस्करण के लिए:\necho \u0026#34;deb [signed-by=/usr/share/keyrings/i2p-archive-keyring.gpg] https://deb.i2p.net/ $(lsb_release -sc) main\u0026#34; \\ | sudo tee /etc/apt/sources.list.d/i2p.list Debian व्युत्पन्न (LMDE, Kali, ParrotOS, इत्यादि) के लिए Bullseye-समतुल्य या नए संस्करण पर:\necho \u0026#34;deb [signed-by=/usr/share/keyrings/i2p-archive-keyring.gpg] https://deb.i2p.net/ $(dpkg --status tzdata | grep Provides | cut -f2 -d\u0026#39;-\u0026#39;) main\u0026#34; \\ | sudo tee /etc/apt/sources.list.d/i2p.list Debian Buster (10) या पुराने संस्करणों के लिए:\necho \u0026#34;deb https://deb.i2p.net/ $(lsb_release -sc) main\u0026#34; \\ | sudo tee /etc/apt/sources.list.d/i2p.list Buster-समकक्ष या पुराने पर Debian व्युत्पन्न के लिए:\necho \u0026#34;deb https://deb.i2p.net/ $(dpkg --status tzdata | grep Provides | cut -f2 -d\u0026#39;-\u0026#39;) main\u0026#34; \\ | sudo tee /etc/apt/sources.list.d/i2p.list चरण 3: रिपॉजिटरी साइनिंग की डाउनलोड करें\ncurl -o i2p-archive-keyring.gpg https://geti2p.net/_static/i2p-archive-keyring.gpg चरण 4: कुंजी फिंगरप्रिंट सत्यापित करें\nकुंजी पर भरोसा करने से पहले, सत्यापित करें कि इसका फिंगरप्रिंट आधिकारिक I2P साइनिंग कुंजी से मेल खाता है:\ngpg --keyid-format long --import --import-options show-only --with-fingerprint i2p-archive-keyring.gpg सत्यापित करें कि आउटपुट में यह फ़िंगरप्रिंट दिखाई दे रहा है:\n7840 E761 0F28 B904 7535 49D7 67EC E560 5BCF 1346 ⚠️ यदि फ़िंगरप्रिंट मेल नहीं खाता है तो आगे न बढ़ें। यह एक समझौता किए गए डाउनलोड का संकेत हो सकता है।\nचरण 5: रिपॉजिटरी की इंस्टॉल करें\nसत्यापित keyring को सिस्टम keyrings डायरेक्टरी में कॉपी करें:\nsudo cp i2p-archive-keyring.gpg /usr/share/keyrings केवल Debian Buster या पुराने संस्करणों के लिए, आपको एक symlink भी बनाना होगा:\nsudo ln -sf /usr/share/keyrings/i2p-archive-keyring.gpg /etc/apt/trusted.gpg.d/i2p-archive-keyring.gpg चरण 6: पैकेज सूचियों को अपडेट करें\nअपने सिस्टम के पैकेज डेटाबेस को I2P रिपॉजिटरी को शामिल करने के लिए रिफ्रेश करें:\nsudo apt-get update चरण 7: I2P इंस्टॉल करें\nI2P router और keyring package दोनों को इंस्टॉल करें (जो सुनिश्चित करता है कि आपको भविष्य में key updates प्राप्त हों):\nsudo apt-get install i2p i2p-keyring बढ़िया! I2P अब इंस्टॉल हो गया है। Post-Installation Configuration सेक्शन पर जारी रखें।\nमुझे खेद है, लेकिन आपने अनुवाद करने के लिए कोई पाठ प्रदान नहीं किया है। केवल \u0026ldquo;\u0026mdash;\u0026rdquo; (विभाजक रेखाएं) हैं। कृपया अनुवाद करने के लिए वास्तविक अंग्रेजी पाठ प्रदान करें।\nPost-Installation Configuration I2P इंस्टॉल करने के बाद, आपको router शुरू करना होगा और कुछ प्रारंभिक कॉन्फ़िगरेशन करना होगा।\nविधि 2: Software Center GUI का उपयोग करना I2P पैकेज I2P राउटर चलाने के तीन तरीके प्रदान करते हैं:\nOption 1: On-Demand (Basic) जरूरत पड़ने पर i2prouter स्क्रिप्ट का उपयोग करके I2P को मैन्युअली शुरू करें:\ni2prouter start महत्वपूर्ण: sudo का उपयोग न करें या इसे root के रूप में न चलाएं! I2P को आपके सामान्य उपयोगकर्ता के रूप में चलना चाहिए।\nI2P को रोकने के लिए:\ni2prouter stop Option 2: On-Demand (Without Java Service Wrapper) यदि आप एक non-x86 सिस्टम पर हैं या Java Service Wrapper आपके प्लेटफ़ॉर्म पर काम नहीं करता है, तो उपयोग करें:\ni2prouter-nowrapper फिर से, sudo का उपयोग न करें या root के रूप में न चलाएं।\nOption 3: System Service (Recommended) सर्वोत्तम अनुभव के लिए, I2P को अपने सिस्टम के बूट होने पर स्वचालित रूप से शुरू होने के लिए कॉन्फ़िगर करें, लॉगिन से पहले भी:\nsudo dpkg-reconfigure i2p यह एक कॉन्फ़िगरेशन डायलॉग खोलता है। I2P को सिस्टम सर्विस के रूप में सक्षम करने के लिए \u0026ldquo;Yes\u0026rdquo; चुनें।\nयह अनुशंसित विधि है क्योंकि: - I2P बूट पर स्वचालित रूप से शुरू होता है - आपका router बेहतर नेटवर्क एकीकरण बनाए रखता है - आप नेटवर्क स्थिरता में योगदान करते हैं - I2P तुरंत उपलब्ध होता है जब आपको इसकी आवश्यकता हो\nInitial Router Configuration पहली बार I2P शुरू करने के बाद, नेटवर्क में एकीकृत होने में कई मिनट लगेंगे। इस बीच, इन आवश्यक सेटिंग्स को कॉन्फ़िगर करें:\n1. Configure NAT/Firewall इष्टतम प्रदर्शन और नेटवर्क भागीदारी के लिए, अपने NAT/firewall के माध्यम से I2P ports को forward करें:\nI2P Router Console खोलें Network Configuration page पर जाएं सूचीबद्ध पोर्ट नंबरों को नोट करें (आमतौर पर 9000-31000 के बीच यादृच्छिक पोर्ट) अपने router/firewall में इन UDP और TCP पोर्ट्स को forward करें यदि आपको port forwarding में सहायता की आवश्यकता है, तो portforward.com राउटर-विशिष्ट गाइड प्रदान करता है।\n2. Adjust Bandwidth Settings डिफ़ॉल्ट बैंडविड्थ सेटिंग्स रूढ़िवादी हैं। अपने इंटरनेट कनेक्शन के आधार पर उन्हें समायोजित करें:\nConfiguration page पर जाएं bandwidth settings अनुभाग खोजें डिफ़ॉल्ट सेटिंग्स 96 KB/s download / 40 KB/s upload हैं यदि आपके पास तेज़ इंटरनेट है तो इन्हें बढ़ाएं (उदाहरण के लिए, सामान्य ब्रॉडबैंड कनेक्शन के लिए 250 KB/s down / 100 KB/s up) नोट: अधिक लिमिट सेट करने से नेटवर्क को मदद मिलती है और आपकी अपनी परफॉर्मेंस में सुधार होता है।\n3. Configure Your Browser I2P साइट्स (eepsites) और सेवाओं तक पहुँचने के लिए, अपने ब्राउज़र को I2P के HTTP proxy का उपयोग करने के लिए कॉन्फ़िगर करें:\nFirefox, Chrome और अन्य ब्राउज़रों के लिए विस्तृत सेटअप निर्देशों के लिए हमारी Browser Configuration Guide देखें।\nमुझे खेद है, लेकिन आपने अनुवाद के लिए कोई पाठ प्रदान नहीं किया है। कृपया \u0026ldquo;\u0026mdash;\u0026rdquo; चिह्नों के बाद अंग्रेजी पाठ शामिल करें ताकि मैं इसे हिंदी में अनुवाद कर सकूं।\nDebian इंस्टॉलेशन महत्वपूर्ण सूचना सुनिश्चित करें कि आप I2P को root के रूप में नहीं चला रहे हैं: ps aux | grep i2p लॉग्स जाँचें: tail -f ~/.i2p/wrapper.log सत्यापित करें कि Java इंस्टॉल है: java -version पूर्वापेक्षाएँ यदि इंस्टॉलेशन के दौरान आपको GPG key की त्रुटियां मिलती हैं:\nकुंजी फ़िंगरप्रिंट को पुनः डाउनलोड और सत्यापित करें (ऊपर चरण 3-4) सुनिश्चित करें कि keyring फ़ाइल में सही अनुमतियाँ हैं: sudo chmod 644 /usr/share/keyrings/i2p-archive-keyring.gpg स्थापना चरण यदि I2P अपडेट प्राप्त नहीं कर रहा है:\nरिपॉजिटरी कॉन्फ़िगर होने की पुष्टि करें: cat /etc/apt/sources.list.d/i2p.list पैकेज लिस्ट अपडेट करें: sudo apt-get update I2P अपडेट्स की जांच करें: sudo apt-get upgrade Migrating from old repositories यदि आप पुराने deb.i2p2.de या deb.i2p2.no repositories का उपयोग कर रहे हैं:\nपुराने रिपॉजिटरी को हटाएं: sudo rm /etc/apt/sources.list.d/i2p.list ऊपर दिए गए Debian Installation चरणों का पालन करें अपडेट करें: sudo apt-get update \u0026amp;\u0026amp; sudo apt-get install i2p i2p-keyring Next Steps अब जब I2P इंस्टॉल और चालू है:\nI2P साइटों तक पहुँचने के लिए अपने ब्राउज़र को कॉन्फ़िगर करें अपने router की निगरानी के लिए I2P router console देखें जानें कि आप कौन से I2P applications उपयोग कर सकते हैं नेटवर्क को समझने के लिए I2P कैसे काम करता है के बारे में पढ़ें अदृश्य इंटरनेट में आपका स्वागत है!\n","description":"डेबियन, उबंटू, और उनके डेरिवेटिव्स पर आधिकारिक रिपॉजिटरीज का उपयोग करके I2P इंस्टॉल करने की संपूर्ण गाइड","id":"88fb5f6d2f5129ce7be2a42b1e9fb9af","section":"docs","title":"डेबियन और उबंटू पर I2P इंस्टॉल करना","url":"/hi/docs/guides/%E0%A4%A1%E0%A5%87%E0%A4%AC%E0%A4%BF%E0%A4%AF%E0%A4%A8-%E0%A4%94%E0%A4%B0-%E0%A4%89%E0%A4%AC%E0%A4%82%E0%A4%9F%E0%A5%82-%E0%A4%AA%E0%A4%B0-i2p-%E0%A4%87%E0%A4%82%E0%A4%B8%E0%A5%8D%E0%A4%9F%E0%A5%89%E0%A4%B2-%E0%A4%95%E0%A4%B0%E0%A4%A8%E0%A4%BE/"},{"categories":null,"content":"पहले New Developers Guide पढ़ें।\nबुनियादी दिशानिर्देश और कोडिंग शैली निम्नलिखित में से अधिकांश बातें किसी भी व्यक्ति के लिए सामान्य ज्ञान होनी चाहिए जिसने open source पर काम किया है या व्यावसायिक programming environment में काम किया है। निम्नलिखित मुख्य रूप से main development branch i2p.i2p पर लागू होता है। अन्य branches, plugins, और external apps के लिए दिशानिर्देश काफी भिन्न हो सकते हैं; मार्गदर्शन के लिए उपयुक्त developer से संपर्क करें।\nसमुदाय कृपया केवल कोड न लिखें। यदि आप कर सकते हैं, तो अन्य विकास गतिविधियों में भाग लें, जिनमें शामिल हैं: IRC और i2pforum.i2p पर विकास चर्चा और समर्थन; परीक्षण; बग रिपोर्टिंग और प्रतिक्रियाएं; दस्तावेज़ीकरण; कोड समीक्षा; आदि। सक्रिय डेवलपर्स को समय-समय पर IRC #i2p-dev पर उपलब्ध रहना चाहिए। वर्तमान रिलीज़ साइकिल से अवगत रहें। रिलीज़ के लिए फीचर फ्रीज, टैग फ्रीज और चेक-इन डेडलाइन जैसे रिलीज़ मील के पत्थर का पालन करें। रिलीज़ चक्र सामान्य रिलीज़ चक्र 10–16 सप्ताह का होता है, वर्ष में चार रिलीज़। एक विशिष्ट 13-सप्ताह के चक्र में अनुमानित समय सीमाएँ निम्नलिखित हैं। प्रत्येक रिलीज़ के लिए वास्तविक समय सीमाएँ रिलीज़ प्रबंधक द्वारा पूरी टीम से परामर्श के बाद निर्धारित की जाती हैं।\nपिछली रिलीज़ के 1-2 दिन बाद: trunk में Check-ins की अनुमति है। पिछली रिलीज़ के 2-3 सप्ताह बाद: अन्य branches से trunk में बड़े बदलाव propagate करने की अंतिम तिथि। रिलीज़ से 4-5 सप्ताह पहले: नए home page links के अनुरोध की अंतिम तिथि। रिलीज़ से 3-4 सप्ताह पहले: Feature freeze। प्रमुख नई सुविधाओं की अंतिम तिथि। रिलीज़ से 2-3 सप्ताह पहले: नए home page link अनुरोधों की समीक्षा के लिए प्रोजेक्ट मीटिंग आयोजित करें, यदि कोई हो। रिलीज़ से 10-14 दिन पहले: String freeze। अनुवादित (tagged) strings में कोई और बदलाव नहीं। Transifex पर strings push करें, Transifex पर अनुवाद की अंतिम तिथि की घोषणा करें। रिलीज़ से 10-14 दिन पहले: Feature अंतिम तिथि। इस समय के बाद केवल bug fixes। अब और कोई features, refactoring या cleanup नहीं। रिलीज़ से 3-4 दिन पहले: अनुवाद की अंतिम तिथि। Transifex से अनुवाद pull करें और check in करें। रिलीज़ से 3-4 दिन पहले: Check-in अंतिम तिथि। इस समय के बाद release builder की अनुमति के बिना कोई check-ins नहीं। रिलीज़ से कुछ घंटे पहले: Code review अंतिम तिथि। Git वितरित स्रोत नियंत्रण प्रणालियों की बुनियादी समझ रखें, भले ही आपने पहले git का उपयोग न किया हो। यदि आपको आवश्यकता हो तो सहायता मांगें। एक बार push करने के बाद, check-in हमेशा के लिए होते हैं; कोई undo नहीं है। कृपया सावधान रहें। यदि आपने पहले git का उपयोग नहीं किया है, तो छोटे कदमों से शुरुआत करें। कुछ छोटे बदलाव check in करें और देखें कि यह कैसे चलता है। अपने बदलावों को check in करने से पहले परीक्षण करें। यदि आप check-in-before-test विकास मॉडल पसंद करते हैं, तो अपने खाते में अपनी स्वयं की development branch का उपयोग करें, और काम पूरा होने के बाद एक MR बनाएं। build को न तोड़ें। regressions न करें। यदि आप ऐसा करते हैं (यह होता है), तो कृपया अपने बदलाव को push करने के बाद लंबे समय तक गायब न हों। यदि आपका बदलाव गैर-तुच्छ है, या आप चाहते हैं कि लोग इसका परीक्षण करें और आपको यह जानने के लिए अच्छी test reports चाहिए कि आपके बदलाव का परीक्षण किया गया था या नहीं, तो history.txt में एक check-in comment जोड़ें और RouterVersion.java में build revision बढ़ाएं। release cycle के अंत में मुख्य i2p.i2p branch में बड़े बदलाव check in न करें। यदि किसी प्रोजेक्ट में आपको कुछ दिनों से अधिक समय लगेगा, तो git में अपने खाते में अपनी branch बनाएं, और वहां विकास करें ताकि आप releases को block न करें। बड़े बदलावों के लिए (आम तौर पर, 100 से अधिक पंक्तियां, या तीन से अधिक फाइलों को छूना), इसे अपने GitLab खाते पर एक नई branch में check in करें, एक MR बनाएं, और एक reviewer नियुक्त करें। MR को स्वयं को assign करें। एक बार reviewer इसे approve कर दे, तो MR को स्वयं merge करें। मुख्य I2P_Developers खाते में WIP branches न बनाएं (i2p.www के अलावा)। WIP आपके अपने खाते में होनी चाहिए। जब काम पूरा हो जाए, तो एक MR बनाएं। मुख्य खाते में केवल सच्चे forks के लिए branches होनी चाहिए, जैसे कि एक point release। पारदर्शी तरीके से और समुदाय को ध्यान में रखते हुए विकास करें। अक्सर check in करें। उपरोक्त दिशानिर्देशों को देखते हुए, जितनी बार संभव हो मुख्य branch में check in या merge करें। यदि आप अपनी branch/खाते में किसी बड़े प्रोजेक्ट पर काम कर रहे हैं, तो लोगों को बताएं ताकि वे साथ चल सकें और review/test/comment कर सकें। कोडिंग शैली अधिकांश कोड में coding style इंडेंटेशन के लिए 4 spaces है। tabs का उपयोग न करें। कोड को reformat न करें। यदि आपका IDE या editor सब कुछ reformat करना चाहता है, तो इसे नियंत्रित करें। कुछ जगहों पर, coding style अलग है। सामान्य समझ का उपयोग करें। जिस फ़ाइल को आप संशोधित कर रहे हैं उसमें style का अनुकरण करें। सभी नए public और package-private classes और methods के लिए Javadocs की आवश्यकता है। @since release-number जोड़ें। नए private methods के लिए Javadocs वांछनीय हैं। जोड़े गए किसी भी Javadocs के लिए, कोई doclint errors या warnings नहीं होनी चाहिए। जांच करने के लिए Oracle Java 14 या उच्चतर के साथ ant javadoc चलाएं। सभी params में @param lines होनी चाहिए, सभी non-void methods में @return lines होनी चाहिए, सभी declared thrown exceptions में @throws lines होनी चाहिए, और कोई HTML errors नहीं होनी चाहिए। core/ (i2p.jar) में classes और i2ptunnel के हिस्से हमारे आधिकारिक API का हिस्सा हैं। कई out-of-tree plugins और अन्य applications हैं जो इस API पर निर्भर हैं। compatibility को तोड़ने वाले कोई भी परिवर्तन न करने में सावधानी बरतें। API में methods तब तक न जोड़ें जब तक कि वे सामान्य उपयोगिता के न हों। API methods के लिए Javadocs स्पष्ट और पूर्ण होने चाहिए। यदि आप API जोड़ते या बदलते हैं, तो website पर documentation को भी अपडेट करें (i2p.www branch)। translation के लिए strings को उपयुक्त रूप से tag करें, जो सभी UI strings के लिए सही है। मौजूदा tagged strings को तब तक न बदलें जब तक वास्तव में आवश्यक न हो, क्योंकि यह मौजूदा translations को तोड़ देगा। release cycle में tag freeze के बाद tagged strings को add या change न करें ताकि translators को release से पहले अपडेट करने का मौका मिल सके। जहां संभव हो generics और concurrent classes का उपयोग करें। I2P एक अत्यधिक multi-threaded application है। सामान्य Java pitfalls से परिचित रहें जो FindBugs/SpotBugs द्वारा पकड़े जाते हैं। अधिक जानने के लिए ant findbugs चलाएं। release 0.9.47 के अनुसार I2P को build और run करने के लिए Java 8 आवश्यक है। embedded subsystems में Java 7 या 8 classes या methods का उपयोग न करें: addressbook, core, i2ptunnel.jar (non‑UI), mstreaming, router, routerconsole (केवल news), streaming। ये subsystems Android और embedded applications द्वारा उपयोग किए जाते हैं जिन्हें केवल Java 6 की आवश्यकता होती है। सभी classes Android API 14 में उपलब्ध होनी चाहिए। इन subsystems में Java 7 language features स्वीकार्य हैं यदि Android SDK के वर्तमान संस्करण द्वारा समर्थित हैं और वे Java 6‑compatible code में compile होते हैं। Try‑with‑resources का उपयोग embedded subsystems में नहीं किया जा सकता क्योंकि इसके लिए runtime में java.lang.AutoCloseable की आवश्यकता होती है, और यह Android API 19 (KitKat 4.4) तक उपलब्ध नहीं है। java.nio.file package का उपयोग embedded subsystems में नहीं किया जा सकता क्योंकि यह Android API 26 (Oreo 8) तक उपलब्ध नहीं है। उपरोक्त सीमाओं के अलावा, Java 8 classes, methods, और constructs का उपयोग केवल निम्नलिखित subsystems में किया जा सकता है: BOB, desktopgui, i2psnark, i2ptunnel.war (UI), jetty‑i2p.jar, jsonrpc, routerconsole (news को छोड़कर), SAM, susidns, susimail, systray। Plugin authors plugin.config फ़ाइल के माध्यम से कोई भी minimum Java version की आवश्यकता कर सकते हैं। Primitive types और classes के बीच स्पष्ट रूप से convert करें; autoboxing/unboxing पर निर्भर न रहें। URL का उपयोग न करें। URI का उपयोग करें। Exception को catch न करें। RuntimeException और checked exceptions को व्यक्तिगत रूप से catch करें। UTF‑8 charset argument के बिना String.getBytes() का उपयोग न करें। आप DataHelper.getUTF8() या DataHelper.getASCII() का भी उपयोग कर सकते हैं। फ़ाइलें read या write करते समय हमेशा UTF‑8 charset निर्दिष्ट करें। DataHelper utilities सहायक हो सकती हैं। String.toLowerCase() या String.toUpperCase() का उपयोग करते समय हमेशा locale (उदाहरण के लिए Locale.US) निर्दिष्ट करें। String.equalsIgnoreCase() का उपयोग न करें, क्योंकि locale निर्दिष्ट नहीं किया जा सकता। String.split() का उपयोग न करें। DataHelper.split() का उपयोग करें। तारीखों और समय को format करने के लिए code न जोड़ें। DataHelper.formatDate() और DataHelper.formatTime() का उपयोग करें। सुनिश्चित करें कि InputStreams और OutputStreams को finally blocks में बंद किया गया है। सभी for और while blocks के लिए {} का उपयोग करें, भले ही केवल एक line हो। यदि आप if, else, या if-else block में से किसी के लिए {} का उपयोग करते हैं, तो सभी blocks के लिए इसका उपयोग करें। } else { को एक single line पर रखें। जहां भी संभव हो fields को final के रूप में निर्दिष्ट करें। I2PAppContext, RouterContext, Log, या router या context items के किसी अन्य references को static fields में store न करें। Constructors में threads start न करें। Thread के बजाय I2PAppThread का उपयोग करें। लॉगिंग निम्नलिखित दिशानिर्देश router, webapps और सभी plugins पर लागू होते हैं।\nजो भी संदेश डिफ़ॉल्ट लॉग स्तर (WARN, INFO, और DEBUG) पर प्रदर्शित नहीं होते हैं, उनके लिए, जब तक कि संदेश एक स्थिर स्ट्रिंग न हो (बिना concatenation के), हमेशा लॉग कॉल से पहले log.shouldWarn(), log.shouldInfo(), या log.shouldDebug() का उपयोग करें ताकि अनावश्यक ऑब्जेक्ट churn से बचा जा सके। लॉग संदेश जो डिफ़ॉल्ट लॉग स्तर (ERROR, CRIT, और logAlways()) पर प्रदर्शित हो सकते हैं, वे संक्षिप्त, स्पष्ट और एक गैर-तकनीकी उपयोगकर्ता के लिए समझने योग्य होने चाहिए। इसमें exception कारण टेक्स्ट भी शामिल है जो प्रदर्शित हो सकता है। यदि त्रुटि होने की संभावना है (उदाहरण के लिए, फ़ॉर्म सबमिशन त्रुटियों पर) तो अनुवाद पर विचार करें। अन्यथा, अनुवाद आवश्यक नहीं है, लेकिन कहीं और पहले से अनुवाद के लिए टैग की गई स्ट्रिंग को खोजना और पुन: उपयोग करना सहायक हो सकता है। लॉग संदेश जो डिफ़ॉल्ट लॉग स्तर (WARN, INFO, और DEBUG) पर प्रदर्शित नहीं होते हैं, वे डेवलपर उपयोग के लिए अभिप्रेत हैं, और उनमें उपरोक्त आवश्यकताएं नहीं हैं। हालांकि, WARN संदेश Android लॉग टैब में उपलब्ध हैं, और समस्याओं को डिबग करने वाले उपयोगकर्ताओं के लिए सहायक हो सकते हैं, इसलिए WARN संदेशों के साथ भी कुछ सावधानी बरतें। INFO और DEBUG लॉग संदेशों का उपयोग संयम से किया जाना चाहिए, विशेष रूप से hot code paths में। विकास के दौरान उपयोगी होने के बावजूद, परीक्षण पूर्ण होने के बाद उन्हें हटाने या comment out करने पर विचार करें। stdout या stderr (wrapper log) पर लॉग न करें। लाइसेंस केवल वह कोड चेक इन करें जो आपने स्वयं लिखा है। अन्य स्रोतों से किसी भी कोड या लाइब्रेरी JARs को चेक इन करने से पहले, यह औचित्य सिद्ध करें कि यह क्यों आवश्यक है, लाइसेंस की संगतता को सत्यापित करें, और रिलीज़ मैनेजर से अनुमोदन प्राप्त करें। यदि आप बाहरी कोड या JARs जोड़ने के लिए अनुमोदन प्राप्त करते हैं, और बाइनरीज़ किसी भी Debian या Ubuntu पैकेज में उपलब्ध हैं, तो आपको बाहरी पैकेज का उपयोग करने के लिए बिल्ड और पैकेजिंग विकल्प लागू करने होंगे। संशोधित करने के लिए फ़ाइलों की चेकलिस्ट: build.properties, build.xml, debian/control, debian/i2p-router.install, debian/i2p-router.links, debian/rules, sub-build.xml। बाहरी स्रोतों से चेक इन की गई किसी भी इमेज के लिए, लाइसेंस की संगतता को पहले सत्यापित करना आपकी जिम्मेदारी है। चेक-इन टिप्पणी में लाइसेंस और स्रोत जानकारी शामिल करें। बग्स समस्याओं का प्रबंधन सभी की जिम्मेदारी है; कृपया मदद करें। GitLab पर उन समस्याओं की निगरानी करें जिनमें आप मदद कर सकते हैं। यदि संभव हो तो समस्याओं पर टिप्पणी करें, उन्हें ठीक करें और बंद करें। नए डेवलपर्स को समस्याओं को ठीक करने से शुरुआत करनी चाहिए। जब आपके पास कोई समाधान हो, तो अपना patch समस्या से संलग्न करें और review-needed keyword जोड़ें। समस्या को तब तक बंद न करें जब तक इसकी सफलतापूर्वक समीक्षा न हो जाए और आप अपने परिवर्तनों की जांच न कर लें। एक बार जब आप कुछ tickets के लिए यह सुचारू रूप से कर लें, तो आप ऊपर दी गई सामान्य प्रक्रिया का पालन कर सकते हैं। जब आपको लगे कि आपने समस्या को ठीक कर दिया है तो उसे बंद कर दें। हमारे पास tickets को सत्यापित और बंद करने के लिए कोई परीक्षण विभाग नहीं है। यदि आप सुनिश्चित नहीं हैं कि आपने इसे ठीक किया है, तो इसे बंद कर दें और एक नोट जोड़ें जिसमें लिखा हो \u0026ldquo;मुझे लगता है कि मैंने इसे ठीक कर दिया है, कृपया परीक्षण करें और यदि यह अभी भी खराब है तो फिर से खोलें\u0026rdquo;। dev build नंबर या revision के साथ एक टिप्पणी जोड़ें और milestone को अगली रिलीज़ पर सेट करें। ","description":"I2P में योगदान के लिए संपूर्ण दिशानिर्देश: कार्यप्रवाह, रिलीज चक्र, कोडिंग शैली, लॉगिंग, लाइसेंसिंग, और समस्या प्रबंधन","id":"6c8fe691caf216ba9024152afc39c5c6","section":"docs","title":"डेवलपर दिशानिर्देश और कोडिंग शैली","url":"/hi/docs/develop/dev-guidelines/"},{"categories":null,"content":"SSH tunnel एक सुरक्षित, एन्क्रिप्टेड कनेक्शन प्रदान करता है जिससे आप अपने रिमोट I2P router के console या अन्य सेवाओं तक पहुंच सकते हैं। यह गाइड आपको Windows, Linux, और Mac सिस्टम पर SSH tunnels बनाने का तरीका दिखाता है।\nSSH टनल क्या है? SSH tunnel एक ऐसी विधि है जो SSH एन्क्रिप्टेड कनेक्शन के माध्यम से डेटा और जानकारी को सुरक्षित रूप से रूट करती है। इसे इंटरनेट के माध्यम से एक सुरक्षित \u0026ldquo;पाइपलाइन\u0026rdquo; बनाने के रूप में समझें - आपका डेटा इस एन्क्रिप्टेड tunnel से होकर यात्रा करता है, जो किसी को भी रास्ते में इसे इंटरसेप्ट करने या पढ़ने से रोकता है।\nSSH टनलिंग विशेष रूप से इन कार्यों के लिए उपयोगी है:\nदूरस्थ I2P routers तक पहुंच: दूरस्थ सर्वर पर चल रहे अपने I2P console से कनेक्ट करें सुरक्षित कनेक्शन: सभी ट्रैफ़िक end-to-end एन्क्रिप्टेड है प्रतिबंधों को दरकिनार करना: दूरस्थ सिस्टम पर सेवाओं को ऐसे एक्सेस करें जैसे वे स्थानीय हों Port forwarding: स्थानीय पोर्ट को दूरस्थ सेवा से मैप करें I2P के संदर्भ में, आप अपने I2P router console (आमतौर पर पोर्ट 7657 पर) को एक रिमोट सर्वर पर एक्सेस करने के लिए SSH tunnel का उपयोग कर सकते हैं, इसे अपने कंप्यूटर पर एक लोकल पोर्ट पर forward करके।\nपूर्वापेक्षाएँ SSH टनल बनाने से पहले, आपको इनकी आवश्यकता होगी:\nSSH क्लाइंट: Windows: PuTTY (मुफ्त डाउनलोड) Linux/Mac: बिल्ट-इन SSH क्लाइंट (Terminal के माध्यम से) रिमोट सर्वर एक्सेस: रिमोट सर्वर के लिए यूजरनेम रिमोट सर्वर का IP एड्रेस या होस्टनेम SSH पासवर्ड या key-based authentication उपलब्ध लोकल पोर्ट: 1-65535 के बीच कोई अप्रयुक्त पोर्ट चुनें (I2P के लिए 7657 आमतौर पर उपयोग किया जाता है) टनल कमांड को समझना SSH टनल कमांड इस पैटर्न का अनुसरण करती है:\nssh -L [local_port]:[destination_ip]:[destination_port] [username]@[remote_server] पैरामीटर्स की व्याख्या: - local_port: आपकी लोकल मशीन पर पोर्ट (उदाहरण के लिए, 7657) - destination_ip: आमतौर पर 127.0.0.1 (रिमोट सर्वर पर localhost) - destination_port: रिमोट सर्वर पर सेवा का पोर्ट (उदाहरण के लिए, I2P के लिए 7657) - username: रिमोट सर्वर पर आपका यूज़रनेम - remote_server: रिमोट सर्वर का IP एड्रेस या होस्टनेम\nउदाहरण: ssh -L 7657:127.0.0.1:7657 i2p@20.228.143.58\nयह एक tunnel बनाता है जहाँ: - आपकी मशीन पर स्थानीय पोर्ट 7657 forward होता है\u0026hellip; - रिमोट सर्वर के localhost पर पोर्ट 7657 तक (जहाँ I2P चल रहा है) - सर्वर 20.228.143.58 पर यूज़र i2p के रूप में कनेक्ट करते हुए\nWindows पर SSH टनल बनाना Windows उपयोगकर्ता PuTTY का उपयोग करके SSH tunnels बना सकते हैं, जो एक निःशुल्क SSH क्लाइंट है।\nStep 1: Download and Install PuTTY putty.org से PuTTY डाउनलोड करें और इसे अपने Windows सिस्टम पर इंस्टॉल करें।\nStep 2: Configure the SSH Connection PuTTY खोलें और अपने कनेक्शन को कॉन्फ़िगर करें:\nSession श्रेणी में: Host Name फ़ील्ड में अपने रिमोट सर्वर का IP एड्रेस या hostname दर्ज करें सुनिश्चित करें कि Port 22 पर सेट है (डिफ़ॉल्ट SSH पोर्ट) Connection type SSH होना चाहिए Step 3: Configure the Tunnel बाएं साइडबार में Connection → SSH → Tunnels पर जाएं:\nSource port: वह लोकल पोर्ट दर्ज करें जिसे आप उपयोग करना चाहते हैं (जैसे, 7657) Destination: 127.0.0.1:7657 दर्ज करें (रिमोट सर्वर पर localhost:port) tunnel जोड़ने के लिए Add पर क्लिक करें tunnel \u0026ldquo;Forwarded ports\u0026rdquo; सूची में दिखाई देनी चाहिए Step 4: Connect कनेक्शन शुरू करने के लिए Open पर क्लिक करें यदि आप पहली बार कनेक्ट कर रहे हैं, तो आपको एक सुरक्षा चेतावनी दिखाई देगी - सर्वर पर भरोसा करने के लिए Yes पर क्लिक करें संकेत मिलने पर अपना username दर्ज करें संकेत मिलने पर अपना password दर्ज करें एक बार कनेक्ट हो जाने के बाद, आप ब्राउज़र खोलकर और http://127.0.0.1:7657 पर नेविगेट करके अपने रिमोट I2P console तक पहुँच सकते हैं\nचरण 1: PuTTY डाउनलोड और इंस्टॉल करें हर बार पुनः कॉन्फ़िगर करने से बचने के लिए:\nSession श्रेणी पर वापस जाएं Saved Sessions में एक नाम दर्ज करें (जैसे, \u0026ldquo;I2P Tunnel\u0026rdquo;) Save पर क्लिक करें अगली बार, बस इस session को load करें और Open पर क्लिक करें Creating SSH Tunnels on Linux Linux सिस्टम में टर्मिनल में SSH बिल्ट-इन होता है, जो tunnel निर्माण को त्वरित और सरल बनाता है।\nचरण 2: SSH कनेक्शन को कॉन्फ़िगर करें एक टर्मिनल खोलें और SSH tunnel कमांड चलाएं:\nssh -L 7657:127.0.0.1:7657 i2p@20.228.143.58 बदलें: - 7657 (पहली बार आना): आपका वांछित स्थानीय पोर्ट - 127.0.0.1:7657: रिमोट सर्वर पर गंतव्य पता और पोर्ट - i2p: रिमोट सर्वर पर आपका उपयोगकर्ता नाम - 20.228.143.58: आपके रिमोट सर्वर का IP पता\nजब प्रॉम्प्ट किया जाए, तो अपना पासवर्ड दर्ज करें। एक बार कनेक्ट हो जाने पर, tunnel सक्रिय हो जाता है।\nअपने ब्राउज़र में http://127.0.0.1:7657 पर अपने रिमोट I2P कंसोल को एक्सेस करें।\nचरण 3: टनल को कॉन्फ़िगर करें टनल तब तक सक्रिय रहती है जब तक SSH सेशन चल रहा है। इसे बैकग्राउंड में चलाते रहने के लिए:\nssh -f -N -L 7657:127.0.0.1:7657 i2p@20.228.143.58 अतिरिक्त फ्लैग: - -f: SSH को बैकग्राउंड में चलाता है - -N: रिमोट कमांड एक्जीक्यूट न करें (केवल tunnel)\nपृष्ठभूमि टनल को बंद करने के लिए, SSH प्रोसेस को ढूंढें और समाप्त करें:\nps aux | grep ssh kill [process_id] चरण 4: कनेक्ट करें बेहतर सुरक्षा और सुविधा के लिए, SSH key authentication का उपयोग करें:\nएक SSH की पेअर जेनरेट करें (यदि आपके पास पहले से नहीं है):\nssh-keygen -t ed25519 -C \u0026#34;your_email@example.com\u0026#34; अपनी सार्वजनिक कुंजी को रिमोट सर्वर पर कॉपी करें:\nssh-copy-id i2p@20.228.143.58 अब आप बिना पासवर्ड के कनेक्ट कर सकते हैं:\nssh -L 7657:127.0.0.1:7657 i2p@20.228.143.58 Creating SSH Tunnels on Mac Mac सिस्टम Linux के समान SSH क्लाइंट का उपयोग करते हैं, इसलिए प्रक्रिया समान है।\nवैकल्पिक: अपना सेशन सहेजें टर्मिनल खोलें (Applications → Utilities → Terminal) और चलाएं:\nssh -L 7657:127.0.0.1:7657 i2p@20.228.143.58 बदलें: - 7657 (पहली बार आना): आपका वांछित स्थानीय पोर्ट - 127.0.0.1:7657: रिमोट सर्वर पर गंतव्य पता और पोर्ट - i2p: रिमोट सर्वर पर आपका उपयोगकर्ता नाम - 20.228.143.58: आपके रिमोट सर्वर का IP पता\nजब पूछा जाए तो अपना पासवर्ड दर्ज करें। कनेक्ट होने के बाद, अपने रिमोट I2P console को http://127.0.0.1:7657 पर एक्सेस करें\nBackground Tunnels on Mac लिनक्स की तरह, आप टनल को बैकग्राउंड में चला सकते हैं:\nssh -f -N -L 7657:127.0.0.1:7657 i2p@20.228.143.58 टर्मिनल का उपयोग करना Mac SSH key सेटअप Linux के समान है:\n# Generate key (if needed) ssh-keygen -t ed25519 -C \u0026#34;your_email@example.com\u0026#34; # Copy to remote server ssh-copy-id i2p@20.228.143.58 Common Use Cases सुरंग को सक्रिय रखना सबसे सामान्य उपयोग केस - अपने रिमोट I2P router कंसोल तक पहुँच:\nssh -L 7657:127.0.0.1:7657 user@remote-server फिर अपने ब्राउज़र में http://127.0.0.1:7657 खोलें।\nSSH कुंजियों का उपयोग (अनुशंसित) एक साथ कई पोर्ट फॉरवर्ड करें:\nssh -L 7657:127.0.0.1:7657 -L 7658:127.0.0.1:7658 user@remote-server यह पोर्ट 7657 (I2P console) और 7658 (एक अन्य सेवा) दोनों को फॉरवर्ड करता है।\nCustom Local Port यदि 7657 पहले से उपयोग में है तो एक अलग लोकल पोर्ट का उपयोग करें:\nssh -L 8080:127.0.0.1:7657 user@remote-server I2P कंसोल को http://127.0.0.1:8080 पर एक्सेस करें।\nTroubleshooting टर्मिनल का उपयोग त्रुटि: \u0026ldquo;bind: Address already in use\u0026rdquo;\nसमाधान: एक अलग लोकल पोर्ट चुनें या उस पोर्ट का उपयोग करने वाली प्रोसेस को बंद करें:\n# Linux/Mac - find process on port 7657 lsof -i :7657 # Kill the process kill [process_id] मैक पर बैकग्राउंड Tunnels Error: \u0026ldquo;Connection refused\u0026rdquo; या \u0026ldquo;channel 2: open failed\u0026rdquo;\nसंभावित कारण: - रिमोट सेवा नहीं चल रही है (जांचें कि रिमोट सर्वर पर I2P router चल रहा है या नहीं) - फ़ायरवॉल कनेक्शन को ब्लॉक कर रहा है - गलत डेस्टिनेशन पोर्ट\nसमाधान: सत्यापित करें कि रिमोट सर्वर पर I2P router चल रहा है:\nssh user@remote-server \u0026#34;systemctl status i2p\u0026#34; Mac पर SSH Key सेटअप त्रुटि: \u0026ldquo;Permission denied\u0026rdquo; या \u0026ldquo;Authentication failed\u0026rdquo;\nसंभावित कारण: - गलत उपयोगकर्ता नाम या पासवर्ड - SSH key उचित तरीके से कॉन्फ़िगर नहीं की गई - रिमोट सर्वर पर SSH एक्सेस अक्षम है\nसमाधान: क्रेडेंशियल्स को सत्यापित करें और सुनिश्चित करें कि रिमोट सर्वर पर SSH एक्सेस सक्षम है।\nTunnel Drops Connection त्रुटि: निष्क्रियता की अवधि के बाद कनेक्शन डिस्कनेक्ट हो जाता है\nसमाधान: अपनी SSH config (~/.ssh/config) में keep-alive सेटिंग्स जोड़ें:\nHost remote-server ServerAliveInterval 60 ServerAliveCountMax 3 Security Best Practices SSH keys का उपयोग करें: पासवर्ड की तुलना में अधिक सुरक्षित, समझौता करना कठिन पासवर्ड प्रमाणीकरण अक्षम करें: एक बार SSH keys सेट हो जाने पर, सर्वर पर पासवर्ड लॉगिन अक्षम कर दें मजबूत पासवर्ड उपयोग करें: यदि पासवर्ड प्रमाणीकरण का उपयोग कर रहे हैं, तो एक मजबूत, अद्वितीय पासवर्ड का उपयोग करें SSH एक्सेस सीमित करें: विश्वसनीय IPs तक SSH एक्सेस सीमित करने के लिए फ़ायरवॉल नियम कॉन्फ़िगर करें SSH को अपडेट रखें: अपने SSH client और server सॉफ़्टवेयर को नियमित रूप से अपडेट करें लॉग मॉनिटर करें: संदिग्ध गतिविधि के लिए सर्वर पर SSH लॉग जांचें गैर-मानक SSH ports का उपयोग करें: स्वचालित हमलों को कम करने के लिए डिफ़ॉल्ट SSH port (22) बदलें Linux पर SSH Tunnels बनाना I2P Console तक पहुंच स्वचालित रूप से टनल स्थापित करने के लिए एक स्क्रिप्ट बनाएं:\n#!/bin/bash # i2p-tunnel.sh ssh -f -N -L 7657:127.0.0.1:7657 i2p@20.228.143.58 echo \u0026#34;I2P tunnel established\u0026#34; इसे निष्पादन योग्य बनाएं:\nchmod +x i2p-tunnel.sh ./i2p-tunnel.sh मल्टिपल टनल्स स्वचालित टनल निर्माण के लिए एक systemd सेवा बनाएं:\nsudo nano /etc/systemd/system/i2p-tunnel.service जोड़ें:\n[Unit] Description=I2P SSH Tunnel After=network.target [Service] ExecStart=/usr/bin/ssh -NT -o ServerAliveInterval=60 -o ExitOnForwardFailure=yes -L 7657:127.0.0.1:7657 i2p@20.228.143.58 Restart=always RestartSec=10 User=your-username [Install] WantedBy=multi-user.target सक्षम करें और शुरू करें:\nsudo systemctl enable i2p-tunnel sudo systemctl start i2p-tunnel Advanced Tunneling कस्टम लोकल पोर्ट डायनामिक फ़ॉरवर्डिंग के लिए एक SOCKS प्रॉक्सी बनाएं:\nssh -D 8080 user@remote-server अपने ब्राउज़र को SOCKS5 प्रॉक्सी के रूप में 127.0.0.1:8080 उपयोग करने के लिए कॉन्फ़िगर करें।\nReverse Tunneling रिमोट सर्वर को अपनी लोकल मशीन पर सेवाओं तक पहुंचने की अनुमति दें:\nssh -R 7657:127.0.0.1:7657 user@remote-server पोर्ट पहले से उपयोग में है एक मध्यवर्ती सर्वर के माध्यम से Tunnel:\nssh -J jumphost.example.com -L 7657:127.0.0.1:7657 user@final-server Conclusion SSH tunneling एक शक्तिशाली उपकरण है जो दूरस्थ I2P routers और अन्य सेवाओं तक सुरक्षित रूप से पहुँचने के लिए उपयोग किया जाता है। चाहे आप Windows, Linux, या Mac उपयोग कर रहे हों, यह प्रक्रिया सीधी है और आपके कनेक्शन के लिए मजबूत एन्क्रिप्शन प्रदान करती है।\nअतिरिक्त सहायता या प्रश्नों के लिए, I2P समुदाय पर जाएं: - फोरम: i2pforum.net - IRC: विभिन्न नेटवर्क पर #i2p - दस्तावेज़ीकरण: I2P Docs मार्गदर्शिका मूल रूप से Stormy Cloud द्वारा बनाई गई, I2P दस्तावेज़ीकरण के लिए अनुकूलित।\n","description":"अपने दूरस्थ I2P router तक पहुँचने के लिए Windows, Linux, और Mac पर सुरक्षित SSH tunnels बनाना सीखें","id":"7d461aaa86788adfcb07bfb98f6e4965","section":"docs","title":"दूरस्थ रूप से I2P तक पहुँच के लिए SSH Tunnel बनाना","url":"/hi/docs/guides/%E0%A4%A6%E0%A5%82%E0%A4%B0%E0%A4%B8%E0%A5%8D%E0%A4%A5-%E0%A4%B0%E0%A5%82%E0%A4%AA-%E0%A4%B8%E0%A5%87-i2p-%E0%A4%A4%E0%A4%95-%E0%A4%AA%E0%A4%B9%E0%A5%81%E0%A4%81%E0%A4%9A-%E0%A4%95%E0%A5%87-%E0%A4%B2%E0%A4%BF%E0%A4%8F-ssh-tunnel-%E0%A4%AC%E0%A4%A8%E0%A4%BE%E0%A4%A8%E0%A4%BE/"},{"categories":null,"content":"क्या आप I2P को दुनिया भर में अधिक लोगों के लिए सुलभ बनाने में मदद करना चाहते हैं? अनुवाद परियोजना में आपके द्वारा दिए जाने वाले सबसे मूल्यवान योगदानों में से एक है। यह गाइड आपको router console का अनुवाद करने की प्रक्रिया से परिचित कराएगी।\nअनुवाद विधियाँ अनुवाद में योगदान करने के दो तरीके हैं:\nविधि 1: Transifex (अनुशंसित) यह I2P का अनुवाद करने का सबसे आसान तरीका है। Transifex एक वेब-आधारित इंटरफ़ेस प्रदान करता है जो अनुवाद को सरल और सुलभ बनाता है।\nTransifex पर साइन अप करें I2P अनुवाद टीम में शामिल होने का अनुरोध करें अपने ब्राउज़र में सीधे अनुवाद करना शुरू करें तकनीकी ज्ञान की आवश्यकता नहीं - बस साइन अप करें और अनुवाद शुरू करें!\nविधि 2: मैनुअल अनुवाद उन अनुवादकों के लिए जो git और स्थानीय फ़ाइलों के साथ काम करना पसंद करते हैं, या उन भाषाओं के लिए जो अभी तक Transifex पर सेट नहीं की गई हैं।\nआवश्यकताएं: - git version control से परिचित होना - टेक्स्ट एडिटर या अनुवाद उपकरण (POEdit अनुशंसित) - Command-line tools: git, gettext\nसेटअप: 1. IRC पर #i2p-dev में शामिल हों और अपना परिचय दें 2. wiki पर अनुवाद स्थिति को अपडेट करें (पहुंच के लिए IRC में पूछें) 3. उपयुक्त repository को clone करें (नीचे दिए गए अनुभाग देखें)\nराउटर कंसोल अनुवाद राउटर कंसोल वह वेब इंटरफेस है जो आप I2P चलाते समय देखते हैं। इसका अनुवाद उन उपयोगकर्ताओं की मदद करता है जो अंग्रेजी में सहज नहीं हैं।\nTransifex का उपयोग करना (अनुशंसित) I2P on Transifex पर जाएं router console प्रोजेक्ट चुनें अपनी भाषा चुनें अनुवाद शुरू करें मैनुअल राउटर कंसोल अनुवाद पूर्वापेक्षाएँ: - वेबसाइट अनुवाद के समान (git, gettext) - GPG key (commit access के लिए) - हस्ताक्षरित developer agreement\nमुख्य I2P रिपॉजिटरी को क्लोन करें:\ngit clone https://i2pgit.org/I2P_Developers/i2p.i2p.git cd i2p.i2p अनुवाद के लिए फ़ाइलें:\nराउटर कंसोल में अनुमानतः 15 फाइलें हैं जिन्हें अनुवाद की आवश्यकता है:\nमुख्य इंटरफ़ेस फ़ाइलें:\napps/routerconsole/locale/messages_*.po - मुख्य कंसोल संदेश apps/routerconsole/locale-news/messages_*.po - समाचार संदेश प्रॉक्सी फ़ाइलें:\napps/i2ptunnel/locale/messages_*.po - Tunnel कॉन्फ़िगरेशन इंटरफ़ेस एप्लिकेशन locales:\napps/susidns/locale/messages_*.po - पता पुस्तिका इंटरफ़ेस apps/susimail/locale/messages_*.po - ईमेल इंटरफ़ेस अन्य app-विशिष्ट locale निर्देशिकाएं दस्तावेज़ फाइलें:\ninstaller/resources/readme/readme_*.html - इंस्टॉलेशन readme विभिन्न ऐप्स में सहायता फाइलें अनुवाद कार्यप्रवाह:\n# Update .po files from source ant extractMessages # Edit .po files with POEdit or text editor poedit apps/routerconsole/locale/messages_es.po # Build and test ant updaters # Install the update and check translations in the console अपना काम जमा करें: - GitLab पर merge request बनाएं - या IRC पर विकास टीम के साथ फाइलें साझा करें\nअनुवाद उपकरण POEdit (अत्यधिक अनुशंसित) POEdit .po अनुवाद फ़ाइलों के लिए एक विशेष संपादक है।\nविशेषताएं: - अनुवाद कार्य के लिए दृश्य इंटरफ़ेस - अनुवाद संदर्भ दिखाता है - स्वचालित सत्यापन - Windows, macOS, और Linux के लिए उपलब्ध\nटेक्स्ट एडिटर आप किसी भी टेक्स्ट एडिटर का भी उपयोग कर सकते हैं: - VS Code (i18n extensions के साथ) - Sublime Text - vim/emacs (टर्मिनल उपयोगकर्ताओं के लिए)\nगुणवत्ता जांच सबमिट करने से पहले: 1. फ़ॉर्मेटिंग की जाँच करें: सुनिश्चित करें कि %s और {0} जैसे प्लेसहोल्डर अपरिवर्तित रहें 2. अपने अनुवादों का परीक्षण करें: I2P को इंस्टॉल और चलाएँ ताकि देख सकें कि वे कैसे दिखते हैं 3. संगति: फ़ाइलों में शब्दावली को सुसंगत रखें 4. लंबाई: कुछ स्ट्रिंग्स में UI में स्थान की सीमाएँ हैं\nअनुवादकों के लिए सुझाव सामान्य दिशानिर्देश संगति बनाए रखें: सामान्य शब्दों के लिए पूरे दस्तावेज़ में समान अनुवाद का उपयोग करें स्वरूपण बनाए रखें: HTML टैग, प्लेसहोल्डर (%s, {0}), और लाइन ब्रेक को संरक्षित रखें संदर्भ महत्वपूर्ण है: संदर्भ को समझने के लिए स्रोत अंग्रेजी को ध्यान से पढ़ें प्रश्न पूछें: यदि कुछ अस्पष्ट है तो IRC या फ़ोरम का उपयोग करें सामान्य I2P शब्दावली कुछ शब्दों को अंग्रेजी में रखा जाना चाहिए या सावधानीपूर्वक लिप्यंतरण किया जाना चाहिए:\nI2P - Keep as is eepsite - I2P website (I2P वेबसाइट) tunnel - कनेक्शन पथ (Tor की शब्दावली \u0026ldquo;circuit\u0026rdquo; से बचें) netDb - नेटवर्क डेटाबेस floodfill - router का प्रकार destination - I2P पता एंडपॉइंट अपने अनुवादों का परीक्षण करना अपने अनुवादों के साथ I2P बनाएं router console सेटिंग्स में भाषा बदलें जांचने के लिए सभी पृष्ठों पर नेविगेट करें: टेक्स्ट UI तत्वों में फिट होता है कोई विकृत अक्षर नहीं (एन्कोडिंग समस्याएं) अनुवाद संदर्भ में समझ में आते हैं अक्सर पूछे जाने वाले प्रश्न अनुवाद प्रक्रिया इतनी जटिल क्यों है? यह प्रक्रिया version control (git) और मानक अनुवाद उपकरणों (.po files) का उपयोग करती है क्योंकि:\nजवाबदेही: ट्रैक करें कि किसने क्या और कब बदला गुणवत्ता: लाइव होने से पहले परिवर्तनों की समीक्षा करें निरंतरता: उचित फ़ाइल स्वरूपण और संरचना बनाए रखें स्केलेबिलिटी: कई भाषाओं में अनुवाद को कुशलतापूर्वक प्रबंधित करें सहयोग: कई अनुवादक एक ही भाषा पर काम कर सकते हैं क्या मुझे प्रोग्रामिंग कौशल की आवश्यकता है? नहीं! यदि आप Transifex का उपयोग करते हैं, तो आपको केवल चाहिए: - अंग्रेजी और आपकी लक्षित भाषा दोनों में प्रवाहिता - एक वेब ब्राउज़र - बुनियादी कंप्यूटर कौशल\nमैनुअल अनुवाद के लिए, आपको बुनियादी command-line ज्ञान की आवश्यकता होगी, लेकिन किसी कोडिंग की आवश्यकता नहीं है।\nइसमें कितना समय लगता है? Router console: सभी फ़ाइलों के लिए लगभग 15-20 घंटे रखरखाव: नई स्ट्रिंग्स को अपडेट करने के लिए प्रति माह कुछ घंटे क्या कई लोग एक भाषा पर काम कर सकते हैं? हाँ! समन्वय महत्वपूर्ण है: - स्वचालित समन्वय के लिए Transifex का उपयोग करें - मैन्युअल काम के लिए, #i2p-dev IRC चैनल में संवाद करें - कार्य को अनुभागों या फ़ाइलों द्वारा विभाजित करें\nयदि मेरी भाषा सूचीबद्ध नहीं है तो क्या करें? इसे Transifex पर अनुरोध करें या IRC पर टीम से संपर्क करें। विकास टीम जल्दी से एक नई भाषा सेट कर सकती है।\nसबमिट करने से पहले मैं अपने अनुवादों का परीक्षण कैसे करूं? अपने अनुवादों के साथ स्रोत से I2P बनाएं इसे स्थानीय रूप से इंस्टॉल करें और चलाएं console सेटिंग्स में भाषा बदलें सहायता प्राप्त करना IRC सहायता तकनीकी सहायता के लिए IRC पर #i2p-dev से जुड़ें: - अनुवाद उपकरणों के साथ तकनीकी सहायता - I2P शब्दावली के बारे में प्रश्न - अन्य अनुवादकों के साथ समन्वय - डेवलपर्स से सीधी सहायता\nफ़ोरम I2P Forums पर अनुवाद चर्चाएँ Inside I2P: zzz.i2p पर अनुवाद फोरम (I2P router की आवश्यकता है) दस्तावेज़ीकरण Transifex प्रलेखन POEdit प्रलेखन gettext मैनुअल मान्यता सभी अनुवादकों को श्रेय दिया जाता है: - I2P router कंसोल में (About पेज) - वेबसाइट क्रेडिट्स पेज - Git कमिट हिस्ट्री - रिलीज़ घोषणाओं में\nआपका कार्य दुनिया भर के लोगों को I2P का सुरक्षित और निजी तरीके से उपयोग करने में सीधे मदद करता है। योगदान देने के लिए धन्यवाद!\nअगले कदम अनुवाद शुरू करने के लिए तैयार हैं?\nअपनी विधि चुनें:\nत्वरित शुरुआत: Transifex पर साइन अप करें मैनुअल दृष्टिकोण: IRC पर #i2p-dev से जुड़ें छोटे से शुरू करें: प्रक्रिया से परिचित होने के लिए कुछ स्ट्रिंग्स का अनुवाद करें\nसहायता माँगें: IRC या फोरम पर संपर्क करने में संकोच न करें\nI2P को सभी के लिए सुलभ बनाने में मदद करने के लिए धन्यवाद!\n","description":"Transifex या मैनुअल तरीकों का उपयोग करके I2P वेबसाइट और router console में अनुवाद कैसे योगदान करें","id":"a436f7ab16669c43b076458496d70009","section":"docs","title":"नए अनुवादक की गाइड","url":"/hi/docs/develop/new-translators/"},{"categories":null,"content":"तो आप I2P पर काम शुरू करना चाहते हैं? बहुत बढ़िया! यहाँ वेबसाइट या सॉफ़्टवेयर में योगदान करने, विकास करने, या अनुवाद बनाने के लिए शुरुआत करने की एक त्वरित मार्गदर्शिका है।\nकोडिंग के लिए पूरी तरह तैयार नहीं हैं? पहले शामिल होने का प्रयास करें।\nजावा को जानें I2P router और इसके embedded applications मुख्य development भाषा के रूप में Java का उपयोग करते हैं। यदि आपके पास Java का अनुभव नहीं है, तो आप हमेशा Thinking in Java देख सकते हैं\nपरिचय कैसे, अन्य \u0026ldquo;कैसे\u0026rdquo; दस्तावेज़, तकनीकी परिचय, और संबंधित दस्तावेज़ों का अध्ययन करें:\nपरिचय कैसे: I2P का परिचय दस्तावेज़ीकरण केंद्र: दस्तावेज़ीकरण तकनीकी परिचय: तकनीकी परिचय ये आपको I2P की संरचना और यह विभिन्न कार्य कैसे करता है, इसका एक अच्छा अवलोकन देंगे।\nI2P कोड प्राप्त करना I2P router या एम्बेडेड एप्लिकेशन पर विकास के लिए, आपको सोर्स कोड प्राप्त करना होगा।\nहमारा वर्तमान तरीका: Git I2P के पास आधिकारिक Git सेवाएं हैं और हमारे अपने GitLab पर Git के माध्यम से योगदान स्वीकार करता है:\nI2P के अंदर: http://git.idk.i2p I2P के बाहर: https://i2pgit.org मुख्य रिपॉजिटरी को क्लोन करें:\ngit clone https://i2pgit.org/I2P_Developers/i2p.i2p.git GitHub पर एक रीड-ओनली मिरर भी उपलब्ध है:\nGitHub mirror: github.com/i2p/i2p.i2p git clone https://github.com/i2p/i2p.i2p.git I2P बनाना कोड को कंपाइल करने के लिए, आपको Sun/Oracle Java Development Kit 6 या उच्चतर, या समकक्ष JDK (Sun/Oracle JDK 6 की दृढ़ता से अनुशंसा की जाती है) और Apache Ant संस्करण 1.7.0 या उच्चतर की आवश्यकता होगी। यदि आप मुख्य I2P कोड पर काम कर रहे हैं, तो i2p.i2p डायरेक्टरी में जाएं और बिल्ड विकल्पों को देखने के लिए ant चलाएं।\nconsole अनुवाद बनाने या उस पर काम करने के लिए, आपको GNU gettext पैकेज से xgettext, msgfmt, और msgmerge टूल्स की आवश्यकता होगी।\nनए एप्लिकेशन के विकास के लिए, एप्लिकेशन डेवलपमेंट गाइड देखें।\nविकास विचार परियोजना की TODO सूची या GitLab पर issue सूची देखें विचारों के लिए:\nGitLab issues: i2pgit.org/I2P_Developers/i2p.i2p/issues परिणाम उपलब्ध कराना लाइसेंस पृष्ठ के नीचे commit विशेषाधिकार आवश्यकताओं को देखें। i2p.i2p में कोड डालने के लिए आपको इनकी आवश्यकता है (वेबसाइट के लिए आवश्यक नहीं!)।\nलाइसेंस पेज हमसे मिलें! डेवलपर्स IRC पर उपलब्ध रहते हैं। उन्हें विभिन्न नेटवर्क और I2P आंतरिक नेटवर्क पर संपर्क किया जा सकता है। देखने के लिए सामान्य स्थान #i2p-dev है। चैनल में शामिल हों और नमस्ते कहें! हमारे पास नियमित डेवलपर्स के लिए अतिरिक्त दिशानिर्देश भी हैं।\nवेबसाइट और router console अनुवादकों के लिए: अगले चरणों के लिए नए अनुवादक की मार्गदर्शिका देखें।\nउपकरण I2P एक ओपन सोर्स सॉफ्टवेयर है जिसे मुख्य रूप से ओपन-सोर्स टूलकिट का उपयोग करके विकसित किया जाता है। I2P परियोजना ने हाल ही में YourKit Java Profiler के लिए लाइसेंस प्राप्त किया है। ओपन सोर्स परियोजनाएं मुफ्त लाइसेंस प्राप्त करने के लिए पात्र हैं बशर्ते कि परियोजना की वेबसाइट पर YourKit का संदर्भ दिया गया हो। यदि आप I2P कोडबेस को प्रोफाइल करने में रुचि रखते हैं तो कृपया संपर्क करें।\nYourKit अपने पूर्ण-सुविधा वाले profilers के साथ ओपन सोर्स परियोजनाओं का समर्थन कर रहा है। YourKit, LLC, Java और .NET एप्लिकेशन के लिए profiling के लिए नवीन और बुद्धिमान उपकरणों का निर्माता है। YourKit के अग्रणी सॉफ्टवेयर उत्पादों पर एक नज़र डालें:\nYourKit Java Profiler YourKit .NET Profiler ","description":"I2P में योगदान कैसे शुरू करें: अध्ययन सामग्री, सोर्स कोड, बिल्डिंग, विचार, प्रकाशन, समुदाय, अनुवाद, और उपकरण","id":"e74ff72be9767cc925c6712e11e5e1c5","section":"docs","title":"नए डेवलपर्स के लिए गाइड","url":"/hi/docs/develop/new-developers/"},{"categories":null,"content":"I2P पते लंबी क्रिप्टोग्राफिक कुंजियाँ हैं। नामकरण प्रणाली उन कुंजियों के ऊपर एक अधिक सुविधाजनक परत प्रदान करती है बिना किसी केंद्रीय प्राधिकरण को शामिल किए। सभी नाम स्थानीय हैं—प्रत्येक router स्वतंत्र रूप से निर्णय लेता है कि कोई होस्टनाम किस गंतव्य को संदर्भित करता है।\nपृष्ठभूमि चाहिए? naming चर्चा मूल डिज़ाइन बहसों, वैकल्पिक प्रस्तावों, और I2P के विकेंद्रीकृत naming के पीछे के दार्शनिक आधारों को दस्तावेज़ित करती है।\n1. घटक I2P की नामकरण परत कई स्वतंत्र लेकिन सहयोगी उप-प्रणालियों से बनी है:\nNaming service – hostnames को destinations में resolve करती है और Base32 hostnames को संभालती है। HTTP proxy – .i2p lookups को router तक पहुंचाता है और जब नाम अज्ञात हो तो jump services सुझाता है। Host-add services – CGI-style forms जो स्थानीय address book में नई entries जोड़ते हैं। Jump services – दूरस्थ सहायक जो दिए गए hostname के लिए destination लौटाते हैं। Address book – स्थानीय रूप से विश्वसनीय \u0026ldquo;web of trust\u0026rdquo; का उपयोग करके समय-समय पर दूरस्थ host lists को fetch और merge करती है। SusiDNS – address books, subscriptions, और स्थानीय overrides को प्रबंधित करने के लिए एक web-based UI। यह मॉड्यूलर डिज़ाइन उपयोगकर्ताओं को अपनी स्वयं की विश्वास सीमाएं परिभाषित करने और नामकरण प्रक्रिया को अपनी पसंद के अनुसार अधिक या कम स्वचालित करने की अनुमति देता है।\n2. नामकरण सेवाएं router की naming API (net.i2p.client.naming) configurable property i2p.naming.impl=\u0026lt;class\u0026gt; के माध्यम से कई backends का समर्थन करती है। प्रत्येक implementation विभिन्न lookup strategies प्रदान कर सकता है, लेकिन सभी समान trust और resolution model साझा करते हैं।\n2.1 Hosts.txt (legacy format) विरासत मॉडल में तीन plain-text फ़ाइलों का उपयोग क्रम में जांच के लिए किया जाता था:\nprivatehosts.txt userhosts.txt hosts.txt प्रत्येक पंक्ति एक hostname=base64-destination मैपिंग को संग्रहीत करती है। यह सरल टेक्स्ट फॉर्मेट import/export के लिए पूरी तरह से समर्थित है, लेकिन यह अब डिफ़ॉल्ट नहीं है क्योंकि जब होस्ट सूची कुछ हज़ार entries से अधिक हो जाती है तो इसका प्रदर्शन खराब हो जाता है।\n2.2 Blockfile Naming Service (default backend) रिलीज़ 0.8.8 में पेश की गई, Blockfile Naming Service अब डिफ़ॉल्ट बैकएंड है। यह फ्लैट फाइलों को एक उच्च-प्रदर्शन skiplist-आधारित ऑन-डिस्क key/value स्टोर (hostsdb.blockfile) से बदल देती है जो लगभग 10× तेज़ lookups प्रदान करती है।\nमुख्य विशेषताएं: - एक बाइनरी डेटाबेस में कई तार्किक एड्रेस बुक्स (प्राइवेट, यूज़र, और होस्ट्स) को स्टोर करता है। - लीगेसी hosts.txt इम्पोर्ट/एक्सपोर्ट के साथ संगतता बनाए रखता है। - रिवर्स लुकअप, मेटाडेटा (जोड़ी गई तारीख, स्रोत, टिप्पणियां), और कुशल कैशिंग का समर्थन करता है। - समान तीन-स्तरीय खोज क्रम का उपयोग करता है: private → user → hosts।\nयह दृष्टिकोण पुरानी संगतता (backwards compatibility) को बनाए रखते हुए resolution की गति और scalability में नाटकीय सुधार करता है।\n2.1 Hosts.txt (पुराना प्रारूप) डेवलपर्स कस्टम backends को लागू कर सकते हैं जैसे: - Meta – कई naming systems को एकत्रित करता है। - PetName – petnames.txt में संग्रहीत petnames का समर्थन करता है। - AddressDB, Exec, Eepget, और Dummy – बाहरी या fallback resolution के लिए।\nblockfile कार्यान्वयन प्रदर्शन और विश्वसनीयता के कारण सामान्य उपयोग के लिए अनुशंसित बैकएंड बना हुआ है।\n3. Base32 Hostnames Base32 होस्टनेम (*.b32.i2p) Tor के .onion पतों की तरह ही काम करते हैं। जब आप किसी .b32.i2p पते को एक्सेस करते हैं:\nrouter Base32 पेलोड को डिकोड करता है। यह की से सीधे गंतव्य का पुनर्निर्माण करता है—कोई address-book लुकअप आवश्यक नहीं। यह मानव-पठनीय होस्टनाम न होने पर भी पहुंच सुनिश्चित करता है। रिलीज़ 0.9.40 में पेश किए गए विस्तारित Base32 नाम LeaseSet2 और एन्क्रिप्टेड destinations का समर्थन करते हैं।\n4. Address Book \u0026amp; Subscriptions एड्रेस बुक एप्लिकेशन HTTP के माध्यम से रिमोट होस्ट सूचियों को प्राप्त करती है और उपयोगकर्ता द्वारा कॉन्फ़िगर किए गए विश्वास नियमों के अनुसार उन्हें स्थानीय रूप से मर्ज करती है।\n2.2 ब्लॉकफ़ाइल नेमिंग सर्विस (डिफ़ॉल्ट बैकएंड) सब्सक्रिप्शन मानक .i2p URLs हैं जो hosts.txt या इंक्रीमेंटल अपडेट फीड्स की ओर इशारा करते हैं। अपडेट्स को नियमित रूप से (डिफ़ॉल्ट रूप से प्रति घंटे) फेच किया जाता है और मर्ज करने से पहले सत्यापित किया जाता है। विरोधों को फर्स्ट-कम, फर्स्ट-सर्व्ड के आधार पर हल किया जाता है, प्राथमिकता क्रम का पालन करते हुए:\nprivatehosts.txt → userhosts.txt → hosts.txt। Default Providers I2P 2.3.0 (जून 2023) के बाद से, दो डिफ़ॉल्ट सब्सक्रिप्शन प्रोवाइडर शामिल हैं: - http://i2p-projekt.i2p/hosts.txt - http://notbob.i2p/hosts.txt\nयह रिडंडेंसी (अतिरिक्तता) विश्वसनीयता में सुधार करती है जबकि स्थानीय ट्रस्ट मॉडल को संरक्षित रखती है। उपयोगकर्ता SusiDNS के माध्यम से सब्सक्रिप्शन जोड़ या हटा सकते हैं।\nIncremental Updates वृद्धिशील अपडेट newhosts.txt के माध्यम से प्राप्त किए जाते हैं (recenthosts.cgi की पुरानी अवधारणा को प्रतिस्थापित करते हुए)। यह endpoint कुशल, ETag-आधारित डेल्टा अपडेट प्रदान करता है—पिछले अनुरोध के बाद से केवल नई प्रविष्टियाँ लौटाता है या अपरिवर्तित होने पर 304 Not Modified लौटाता है।\n2.3 वैकल्पिक बैकएंड और प्लग-इन Host-add services (add*.cgi) नाम-से-destination मैपिंग की मैनुअल सबमिशन की अनुमति देती हैं। स्वीकार करने से पहले हमेशा destination को सत्यापित करें। Jump services उपयुक्त key के साथ प्रतिक्रिया देती हैं और HTTP proxy के माध्यम से ?i2paddresshelper= पैरामीटर के साथ रीडायरेक्ट कर सकती हैं। सामान्य उदाहरण: stats.i2p, identiguy.i2p, और notbob.i2p। ये सेवाएं विश्वसनीय प्राधिकरण नहीं हैं—उपयोगकर्ताओं को यह तय करना होगा कि किसका उपयोग करना है। 5. Managing Entries Locally (SusiDNS) SusiDNS यहाँ उपलब्ध है: http://127.0.0.1:7657/susidns/\nआप कर सकते हैं: - स्थानीय पता पुस्तिकाएँ देखें और संपादित करें। - सदस्यताओं को प्रबंधित और प्राथमिकता दें। - होस्ट सूचियाँ आयात/निर्यात करें। - फ़ेच शेड्यूल कॉन्फ़िगर करें।\nI2P 2.8.1 में नया (मार्च 2025): - \u0026ldquo;नवीनतम के अनुसार क्रमबद्ध करें\u0026rdquo; सुविधा जोड़ी गई। - सदस्यता प्रबंधन में सुधार (ETag असंगतताओं के लिए सुधार)।\nसभी परिवर्तन स्थानीय रहते हैं—प्रत्येक router का address book अद्वितीय होता है।\n3. Base32 होस्टनेम्स RFC 9476 का पालन करते हुए, I2P ने मार्च 2025 (I2P 2.8.1) तक GNUnet Assigned Numbers Authority (GANA) के साथ .i2p.alt पंजीकृत किया।\nउद्देश्य: गलत कॉन्फ़िगर किए गए सॉफ़्टवेयर से आकस्मिक DNS लीक को रोकना।\nRFC 9476-अनुरूप DNS रिज़ॉल्वर .alt डोमेन को सार्वजनिक DNS को फ़ॉरवर्ड नहीं करेंगे। I2P सॉफ़्टवेयर .i2p.alt को .i2p के समतुल्य मानता है, रिज़ॉल्यूशन के दौरान .alt प्रत्यय को हटा देता है। .i2p.alt का उद्देश्य .i2p को बदलना नहीं है; यह एक तकनीकी सुरक्षा उपाय है, पुनर्ब्रांडिंग नहीं। 4. पता पुस्तिका और सब्सक्रिप्शन Destination keys: 516–616 बाइट्स (Base64) Hostnames: अधिकतम 67 वर्ण (.i2p सहित) अनुमत वर्ण: a–z, 0–9, -, . (डबल डॉट्स नहीं, अपरकेस नहीं) आरक्षित: *.b32.i2p ETag और Last-Modified: बैंडविड्थ को न्यूनतम करने के लिए सक्रिय रूप से उपयोग किया जाता है औसत hosts.txt आकार: ~800 hosts के लिए ~400 KB (उदाहरण आंकड़ा) बैंडविड्थ उपयोग: ~10 बाइट्स/सेकंड यदि हर 12 घंटे में फ़ेच किया जाए 8. Security Model and Philosophy I2P जानबूझकर विकेंद्रीकरण और सुरक्षा के बदले वैश्विक विशिष्टता का त्याग करता है—यह Zooko\u0026rsquo;s Triangle का प्रत्यक्ष अनुप्रयोग है।\nमुख्य सिद्धांत: - कोई केंद्रीय प्राधिकरण नहीं: सभी lookup स्थानीय हैं। - DNS hijacking के प्रति प्रतिरोध: queries को destination public keys में एन्क्रिप्ट किया जाता है। - Sybil-attack रोकथाम: कोई voting या consensus-based naming नहीं। - अपरिवर्तनीय mappings: एक बार स्थानीय association मौजूद हो जाने पर, इसे दूर से override नहीं किया जा सकता।\nब्लॉकचेन-आधारित नामकरण प्रणालियों (जैसे, Namecoin, ENS) ने Zooko के त्रिभुज के तीनों पक्षों को हल करने का प्रयास किया है, लेकिन I2P जानबूझकर उनसे बचता है क्योंकि इनमें विलंबता (latency), जटिलता, और इसके स्थानीय विश्वास मॉडल के साथ दार्शनिक असंगति होती है।\n9. Compatibility and Stability 2023–2025 के बीच कोई भी naming सुविधाओं को बंद नहीं किया गया है। Hosts.txt प्रारूप, jump सेवाएं, subscriptions, और सभी naming API कार्यान्वयन कार्यशील बने हुए हैं। I2P Project सख्त पिछड़ी संगतता (backwards compatibility) बनाए रखता है जबकि प्रदर्शन और सुरक्षा सुधार (NetDB isolation, Sub-DB separation, आदि) पेश करता है। 10. Best Practices केवल विश्वसनीय सब्सक्रिप्शन रखें; बड़ी, अज्ञात होस्ट सूचियों से बचें। अपग्रेड या पुनः इंस्टॉल करने से पहले hostsdb.blockfile और privatehosts.txt का बैकअप लें। नियमित रूप से jump services की समीक्षा करें और जिन पर अब आप भरोसा नहीं करते उन्हें अक्षम करें। याद रखें: आपकी एड्रेस बुक I2P दुनिया के आपके संस्करण को परिभाषित करती है—प्रत्येक होस्टनेम स्थानीय है। Further Reading नामकरण चर्चा Blockfile विशिष्टता कॉन्फ़िगरेशन फ़ाइल प्रारूप Naming Service Javadoc ","description":"I2P कैसे मानव-पठनीय होस्टनेम को destinations में मैप करता है","id":"fc2ecb5df890709d0740d866d03a6250","section":"docs","title":"नामकरण और पता पुस्तिका","url":"/hi/docs/overview/naming/"},{"categories":null,"content":" संदर्भ: यह पृष्ठ I2P के प्रारम्भिक डिज़ाइन युग की दीर्घकालिक बहसों का संग्रह है। यह बताता है कि परियोजना ने DNS-शैली लुकअप या बहुमत-मत रजिस्ट्रियों की तुलना में स्थानीय रूप से विश्वसनीय पता पुस्तिकाओं को क्यों प्राथमिकता दी। वर्तमान उपयोग संबंधी मार्गदर्शन के लिए, नामकरण दस्तावेज़ीकरण देखें।\nत्यागे गए विकल्प I2P के सुरक्षा उद्देश्यों के चलते पारंपरिक नामकरण योजनाएँ संभव नहीं हैं:\nDNS-शैली का रिज़ॉल्यूशन. लुकअप पथ पर कोई भी resolver (नाम-सुलझाने वाला सर्वर) जवाबों को स्पूफ कर सकता है या सेंसर कर सकता है। DNSSEC होने पर भी, समझौता किए गए registrars (डोमेन पंजीकरण प्रदाता) या certificate authorities (प्रमाणपत्र प्राधिकरण) अब भी एक single point of failure (एकल विफलता बिंदु) बने रहते हैं। I2P में, destinations ही public keys (सार्वजनिक कुंजियाँ) होते हैं—किसी लुकअप का हाइजैक पूरी तरह पहचान से समझौता कर देगा। वोटिंग-आधारित नेमिंग. कोई हमलावर असीमित पहचानें गढ़ सकता है (Sybil attack — सिबिल हमला) और लोकप्रिय नामों के लिए वोट “जीत” सकता है। Proof-of-work (कार्य का प्रमाण) आधारित उपाय लागत बढ़ाते हैं, लेकिन भारी समन्वय बोझ भी ले आते हैं। इसके बजाय, I2P जानबूझकर नामकरण को ट्रांसपोर्ट लेयर के ऊपर रखता है। बंडल की गई नामकरण लाइब्रेरी एक service-provider interface (सेवा-प्रदाता इंटरफेस) प्रदान करती है ताकि वैकल्पिक योजनाएँ सह-अस्तित्व में रह सकें—उपयोगकर्ता तय करते हैं कि वे किन पता पुस्तिकाओं या जंप सेवाओं पर भरोसा करते हैं।\nस्थानीय बनाम वैश्विक नाम (jrandom, 2005) I2P में नाम स्थानीय रूप से अद्वितीय, पर मानव-पठनीय होते हैं। आपका boss.i2p किसी और के boss.i2p से मेल न भी खाए, और यह डिज़ाइन के अनुसार है। यदि कोई दुर्भावनापूर्ण हमलावर आपको किसी नाम के पीछे का destination (I2P का \u0026lsquo;Destination\u0026rsquo;, यानी सार्वजनिक-कुंजी-आधारित पता) बदलने के लिए बहला दे, तो वह प्रभावी रूप से किसी सेवा को हाइजैक कर देगा। वैश्विक अद्वितीयता से इंकार करना उस तरह के हमले को रोकता है। नामों को बुकमार्क या IM उपनामों की तरह समझें—आप किन destinations पर भरोसा करते हैं, यह विशिष्ट पता-पुस्तिकाओं की सदस्यता लेकर या कुंजियाँ मैन्युअल रूप से जोड़कर तय करते हैं। सामान्य आपत्तियाँ और उत्तर (zzz) Concern Response “Downloading hosts.txt is inefficient.” At ~400\u0026nbsp;KB for ~800 hosts the bandwidth impact is minor (~10\u0026nbsp;B/s if refreshed twice daily). ETags already avoid unnecessary transfers. Alternate formats (for example recenthosts.cgi) can deliver only new entries. “It won’t scale.” A hosts.txt entry is ~500\u0026nbsp;bytes; storing thousands locally is practical. Real-time lookups would dramatically slow browsing. “Requires trust and manual setup.” True—and intentional. Users must choose address book providers they trust. Trust is not binary; forcing configuration encourages users to think about it. “Why not just use DNS?” DNS depends on short TTLs and can be hijacked mid-path. I2P destinations are immutable public keys, so DNS semantics map poorly. “Subscriptions rely on specific servers.” Subscriptions are decentralised—you can add multiple providers or run your own. Completely decentralised systems struggle with conflict resolution and hijacking. “Jump services and hosts.txt feel awkward.” They are pragmatic trade-offs. Jump services provide just-in-time lookups; subscriptions keep a local cache for performance. ## दक्षता संबंधी विचारों पर चर्चा क्रमिक अद्यतन प्रदान करें (केवल वे destinations (I2P पते/पहचान) जो पिछली बार प्राप्ति के बाद जोड़े गए हों). पूर्ण hosts फ़ाइलों के साथ-साथ पूरक फ़ीड्स (recenthosts.cgi) उपलब्ध कराएं. स्क्रिप्टेबल टूलिंग (उदाहरण के लिए, i2host.i2p) का अन्वेषण करें ताकि फ़ीडों को एकीकृत किया जा सके या विश्वास स्तरों के आधार पर फ़िल्टर किया जा सके. मुख्य निष्कर्ष सुरक्षा को वैश्विक सहमति पर वरीयता दी जाती है: स्थानीय रूप से संजोई गई पता-पुस्तिकाएँ हाइजैकिंग के जोखिम को कम करती हैं। कई नामकरण पद्धतियाँ naming API (नामकरण हेतु एप्लिकेशन प्रोग्रामिंग इंटरफ़ेस) के माध्यम से सह-अस्तित्व में रह सकती हैं—किस पर भरोसा करना है, यह उपयोगकर्ता तय करते हैं। पूर्णतः विकेन्द्रीकृत वैश्विक नामकरण अभी भी एक खुली शोध समस्या बना हुआ है; सुरक्षा, मानवीय स्मरण-योग्यता और वैश्विक अद्वितीयता के बीच होने वाले समझौते अब भी Zooko’s triangle का प्रतिबिंब हैं। संदर्भ नामकरण प्रलेखन ज़ूको का “नाम: विकेन्द्रीकृत, सुरक्षित, मानव-अर्थपूर्ण: दो चुनें” उदाहरण क्रमिक फ़ीड: stats.i2p/cgi-bin/newhosts.txt ","description":"I2P के नामकरण मॉडल पर ऐतिहासिक बहस और यह कि वैश्विक DNS (डोमेन नेम सिस्टम)-शैली की प्रणालियों को क्यों अस्वीकार किया गया","id":"952b10ba82200ff92e5ddeed512d6afb","section":"docs","title":"नामकरण पर चर्चा","url":"/hi/docs/legacy/naming/"},{"categories":null,"content":" स्थिति: यह पृष्ठ पुराने \u0026ldquo;लो-लेवल क्रिप्टोग्राफी विनिर्देश\u0026rdquo; का संक्षेप प्रस्तुत करता है। आधुनिक I2P रिलीज़ (2.10.0, अक्टूबर 2025) ने नए क्रिप्टोग्राफ़िक प्रिमिटिव्स पर माइग्रेशन पूरा कर लिया है। कार्यान्वयन विवरण के लिए ECIES , Encrypted LeaseSets , NTCP2 , Red25519 , SSU2 , तथा Tunnel Creation (ECIES) जैसी विशेषीकृत विनिर्देशों का उपयोग करें।\nविकास का स्नैपशॉट Functional Area Legacy Primitive Current / Planned Primitive Migration Status Transport key exchange Diffie–Hellman over 2048-bit prime (NTCP / SSU) X25519 (NTCP2 / SSU2) Completed (NTCP2 and SSU2 fully deployed) End-to-end encryption ElGamal/AES+SessionTags ECIES-X25519-AEAD-Ratchet Completed (2.4.0+) Symmetric cipher AES-256/CBC + HMAC-MD5 ChaCha20/Poly1305 (AEAD) Active (tunnel layer remains AES-256) Default signatures DSA-SHA1 (1024-bit) EdDSA/RedDSA on Ed25519 Fully migrated Experimental / future — Hybrid post-quantum encryption (opt-in) In testing (2.10.0) ## असममित एन्क्रिप्शन X25519 (Curve25519 पर आधारित एलिप्टिक-वक्र Diffie–Hellman (ECDH) कुंजी-विनिमय योजना) NTCP2, ECIES-X25519-AEAD-Ratchet, SSU2, और X25519-आधारित tunnel निर्माण के लिए उपयोग किया जाता है. कॉम्पैक्ट कुंजियाँ, स्थिर-समय संचालन, और Noise प्रोटोकॉल फ़्रेमवर्क के माध्यम से फॉरवर्ड सीक्रेसी (पूर्व सत्रों की गोपनीयता बरकरार रहती है) प्रदान करता है. 32-बाइट कुंजियों और कुशल कुंजी आदान-प्रदान के साथ 128-बिट सुरक्षा प्रदान करता है. ElGamal (पुराना) पुराने routers के साथ बैकवर्ड संगतता के लिए बनाए रखा गया है। 2048-बिट Oakley Group 14 prime (RFC 3526) पर generator 2 के साथ संचालित होता है। AES सेशन कीज़ तथा IVs (Initialization Vectors) को 514-बाइट साइफ़रटेक्स्ट्स में एन्क्रिप्ट करता है। प्रमाणीकृत एन्क्रिप्शन और forward secrecy (भविष्य-गोपनीयता) का अभाव है; सभी आधुनिक एंडपॉइंट्स ECIES पर स्थानांतरित हो चुके हैं। सममित कूटलेखन ChaCha20/Poly1305 (एन्क्रिप्शन और प्रमाणीकरण के लिए AEAD एल्गोरिद्म संयोजन) NTCP2, SSU2, और ECIES में प्रयुक्त डिफ़ॉल्ट प्रमाणित एन्क्रिप्शन प्रिमिटिव। AES हार्डवेयर समर्थन के बिना AEAD (संबद्ध डेटा सहित प्रमाणित एन्क्रिप्शन) सुरक्षा और उच्च प्रदर्शन प्रदान करता है। RFC 7539 के अनुरूप लागू किया गया है (256‑बिट कुंजी, 96‑बिट नॉन्स, 128‑बिट टैग). AES‑256/CBC (पुराना) अब भी tunnel परत एन्क्रिप्शन में उपयोग होता है, जहाँ इसकी block‑cipher (ब्लॉक‑आधारित कूटलेखन) संरचना I2P के स्तरीय एन्क्रिप्शन मॉडल में फिट बैठती है. PKCS#5 पैडिंग और प्रत्येक‑हॉप IV (Initialization Vector, आरंभिक वेक्टर) रूपांतरणों का उपयोग करता है. दीर्घकालिक समीक्षा के लिए निर्धारित है, परंतु क्रिप्टोग्राफ़िक रूप से सुदृढ़ बनी हुई है. हस्ताक्षर Signature Type Usage Notes Status DSA‑SHA1 (1024‑bit) Original default; still accepted for legacy Destinations. Deprecated ECDSA‑SHA256/384/512 Used during 2014–2015 transition. Supported EdDSA‑SHA512‑Ed25519 Default for Router and Destination identities (since 0.9.15). Default RedDSA‑SHA512‑Ed25519 Used for encrypted LeaseSet signatures (0.9.39+). Specialized RSA‑SHA512‑4096 For out‑of‑band signing (su3 updates, reseeds, plugins). Application‑layer ## हैश और कुंजी व्युत्पत्ति SHA‑256: DHT (वितरित हैश तालिका) कुंजियों, HKDF, और पुराने प्रकार के हस्ताक्षरों के लिए उपयोग किया जाता है. SHA‑512: EdDSA/RedDSA द्वारा, तथा Noise HKDF व्युत्पत्तियों में उपयोग किया जाता है. HKDF‑SHA256: ECIES, NTCP2, और SSU2 में सत्र कुंजियाँ व्युत्पन्न करता है. प्रतिदिन बदलती SHA‑256 व्युत्पत्तियाँ netDb में RouterInfo और LeaseSet के भंडारण स्थानों को सुरक्षित करती हैं. ट्रांसपोर्ट लेयर सारांश Transport Key Exchange Encryption Authentication Status NTCP2 X25519 ChaCha20/Poly1305 AEAD Default TCP transport SSU2 X25519 ChaCha20/Poly1305 AEAD Default UDP transport SSU (Legacy) DH‑2048 AES‑256/CBC + HMAC‑MD5 Legacy Removed (2.4.0) दोनों ट्रांसपोर्ट प्रोटोकॉल, Noise_XK हैंडशेक पैटर्न का उपयोग करते हुए, लिंक‑स्तरीय forward secrecy (जिसमें दीर्घकालीन कुंजी के उजागर होने पर भी सेशन कुंजियाँ सुरक्षित रहती हैं) और रीप्ले सुरक्षा प्रदान करते हैं। Tunnel परत कूटलेखन प्रति‑हॉप स्तरीकृत एन्क्रिप्शन के लिए AES‑256/CBC का उपयोग जारी है. आउटबाउंड गेटवे क्रमिक AES डिक्रिप्शन करते हैं; प्रत्येक हॉप अपनी लेयर कुंजी और IV (initialization vector, आरंभन सदिश) कुंजी का उपयोग करके पुनः एन्क्रिप्ट करता है. डबल‑IV एन्क्रिप्शन सहसंबंध और पुष्टि हमलों को कम करता है. AEAD (Authenticated Encryption with Associated Data, संबद्ध डेटा सहित प्रमाणित एन्क्रिप्शन) में स्थानांतरण अध्ययनाधीन है, परंतु फिलहाल इसकी योजना नहीं है. पोस्ट‑क्वांटम क्रिप्टोग्राफी I2P 2.10.0 में प्रायोगिक हाइब्रिड पोस्ट‑क्वांटम एन्क्रिप्शन पेश किया गया है। परीक्षण के लिए Hidden Service Manager (हिडन सर्विस मैनेजर) के माध्यम से मैन्युअल रूप से सक्षम किया जा सकता है। X25519 को एक क्वांटम‑प्रतिरोधी KEM (कुंजी एनकैप्सुलेशन मेकैनिज़्म) के साथ जोड़ता है (हाइब्रिड मोड)। डिफ़ॉल्ट नहीं; शोध और प्रदर्शन मूल्यांकन के लिए अभिप्रेत। विस्तारयोग्यता फ्रेमवर्क एन्क्रिप्शन और सिग्नेचर प्रकार पहचानकर्ता अनेक क्रिप्टोग्राफ़िक प्रिमिटिव्स (आधारभूत तत्त्व) के समानांतर समर्थन की अनुमति देते हैं. वर्तमान मैपिंग में शामिल हैं: एन्क्रिप्शन प्रकार: 0 = ElGamal/AES+SessionTags, 4 = ECIES‑X25519‑AEAD‑Ratchet. सिग्नेचर प्रकार: 0 = DSA‑SHA1, 7 = EdDSA‑SHA512‑Ed25519, 11 = RedDSA‑SHA512‑Ed25519. यह फ़्रेमवर्क भविष्य के उन्नयन सक्षम करता है, जिनमें post‑quantum (क्वांटम‑प्रतिरोधी) योजनाएँ शामिल हैं, बिना नेटवर्क विभाजनों के. क्रिप्टोग्राफिक संयोजन ट्रांसपोर्ट लेयर: X25519 + ChaCha20/Poly1305 (Noise फ्रेमवर्क). Tunnel लेयर: अनामिकता के लिए AES‑256/CBC परतदार एन्क्रिप्शन। एंड‑टू‑एंड: गोपनीयता और फॉरवर्ड सीक्रेसी (आगे की गोपनीयता) के लिए ECIES‑X25519‑AEAD‑Ratchet। डेटाबेस लेयर: प्रामाणिकता के लिए EdDSA/RedDSA हस्ताक्षर। ये परतें मिलकर बहु‑स्तरीय सुरक्षा प्रदान करती हैं: यदि किसी एक परत से समझौता हो भी जाए, तब भी अन्य परतें गोपनीयता और unlinkability (विभिन्न गतिविधियों/संदेशों/पहचानकर्ताओं को आपस में जोड़कर पहचान न किया जा सकना) बनाए रखती हैं।\nसारांश I2P 2.10.0 का क्रिप्टोग्राफिक स्टैक मुख्य रूप से इन पर केंद्रित है:\nCurve25519 (X25519) कुंजी विनिमय के लिए ChaCha20/Poly1305 सममित एन्क्रिप्शन के लिए EdDSA / RedDSA हस्ताक्षरों के लिए SHA‑256 / SHA‑512 हैशिंग और व्युत्पत्ति के लिए प्रायोगिक क्वांटम‑पश्चात हाइब्रिड मोड आगे की अनुकूलता के लिए पुराने ElGamal, AES‑CBC, और DSA backward compatibility के लिए बने हुए हैं, लेकिन अब सक्रिय ट्रांसपोर्ट्स या एन्क्रिप्शन पथों में उपयोग नहीं होते।\n","description":"I2P में प्रयुक्त सममित, असममित, और हस्ताक्षर primitives (मूलभूत क्रिप्टोग्राफिक विधियाँ) का सारांश","id":"f5b93f818161e04d49735c3df52fcbdc","section":"docs","title":"निम्न-स्तरीय क्रिप्टोग्राफी","url":"/hi/docs/specs/cryptography/"},{"categories":null,"content":" 1. सारांश netDb एक विशेषीकृत वितरित डेटाबेस है, जिसमें केवल दो प्रकार के डेटा होते हैं:\nRouterInfos – router संपर्क जानकारी LeaseSets – गंतव्य संपर्क जानकारी सारा डेटा क्रिप्टोग्राफ़िक रूप से हस्ताक्षरित और सत्यापन योग्य है। प्रत्येक प्रविष्टि में liveliness information (सक्रियता/उपलब्धता संबंधी जानकारी) शामिल होती है, जो अप्रचलित प्रविष्टियों को हटाने और पुरानी प्रविष्टियों को बदलने में सहायक होती है, और कुछ श्रेणियों के हमलों के विरुद्ध सुरक्षा प्रदान करती है।\nवितरण में floodfill तंत्र का उपयोग किया जाता है, जहाँ routers का एक उपसमूह वितरित डेटाबेस को बनाए रखता है।\n2. RouterInfo (router की जानकारी) जब routers को अन्य routers से संपर्क करना होता है, तो वे RouterInfo (router से संबंधित जानकारी) बंडलों का आदान-प्रदान करते हैं, जिनमें शामिल हैं:\nRouter की पहचान – एन्क्रिप्शन कुंजी, साइनिंग कुंजी, प्रमाणपत्र संपर्क पते – router तक कैसे पहुँचा जाए प्रकाशन समय-चिह्न – यह जानकारी कब प्रकाशित की गई थी मनमाने पाठ विकल्प – क्षमता फ्लैग्स (संकेत-चिह्न) और सेटिंग्स क्रिप्टोग्राफिक हस्ताक्षर – प्रामाणिकता सिद्ध करता है 2.1 क्षमता फ्लैग्स Routers अपनी RouterInfo में अक्षरीय कोडों के जरिए अपनी क्षमताएँ घोषित करते हैं:\nFlag Meaning f Floodfill participation R Reachable U Unreachable D, E, G, H Various capability indicators ### 2.2 बैंडविड्थ श्रेणियाँ Code Bandwidth K Under 12 KBps L 12–48 KBps (default) M 48–64 KBps N 64–128 KBps O 128–256 KBps P 256–2000 KBps X Over 2000 KBps ### 2.3 नेटवर्क आईडी मान Value Purpose 0 Reserved 1 Current Network (default) 2 Reserved for Future Networks 3–15 Forks and Test Networks 16–254 Reserved 255 Reserved ### 2.4 RouterInfo (I2P router की जानकारी) आँकड़े Routers नेटवर्क विश्लेषण के लिए वैकल्पिक स्वास्थ्य आँकड़े प्रकाशित करते हैं: - Exploratory tunnel (अन्वेषणात्मक tunnel) निर्माण सफलता/अस्वीकृति/समय-सीमा समाप्ति दरें - 1-घंटे का औसत भाग लेने वाले tunnel की संख्या\nआँकड़े stat_(statname).(statperiod) प्रारूप का पालन करते हैं, जिसमें मान सेमीकोलन से अलग किए गए होते हैं।\nउदाहरण आँकड़े:\nstat_tunnel.buildExploratoryExpire.60m = 0;0;0;53.14 stat_tunnel.buildExploratoryReject.60m = 0;0;0;15.51 stat_tunnel.buildExploratorySuccess.60m = 0;0;0;31.35 stat_tunnel.participatingTunnels.60m = 289.20 Floodfill routers भी प्रकाशित कर सकते हैं: netdb.knownLeaseSets और netdb.knownRouters\n2.5 Family (परिवार) विकल्प रिलीज़ 0.9.24 से, routers अपनी परिवार सदस्यता (एक ही ऑपरेटर) घोषित कर सकते हैं:\nfamily: परिवार का नाम family.key: हस्ताक्षर प्रकार कोड, base64-एन्कोडेड हस्ताक्षर हेतु सार्वजनिक कुंजी के साथ संयोजित family.sig: परिवार के नाम और 32-बाइट router हैश का हस्ताक्षर एक ही tunnel में, एक ही family के एक से अधिक routers इस्तेमाल नहीं किए जाएंगे।\n2.6 RouterInfo की समाप्ति अपटाइम के पहले घंटे के दौरान कोई समाप्ति नहीं संग्रहीत RouterInfos की संख्या 25 या कम होने पर कोई समाप्ति नहीं स्थानीय गणना बढ़ने पर समाप्ति अवधि घटती है (\u0026lt;120 routers पर 72 घंटे; 300 routers पर ~30 घंटे) SSU introducers (परिचायक नोड) ~1 घंटे में समाप्त हो जाते हैं Floodfills सभी स्थानीय RouterInfos के लिए 1 घंटे की समाप्ति का उपयोग करते हैं 3. LeaseSet LeaseSets विशिष्ट गंतव्यों के लिए tunnel प्रवेश बिंदुओं का दस्तावेज़ित करते हैं, और निम्नलिखित निर्दिष्ट करते हैं:\nTunnel गेटवे router की पहचान 4-बाइट tunnel ID Tunnel समाप्ति समय LeaseSets में शामिल हैं: - Destination – एन्क्रिप्शन कुंजी, साइनिंग कुंजी, प्रमाणपत्र - अतिरिक्त एन्क्रिप्शन सार्वजनिक कुंजी – एंड-टू-एंड garlic encryption के लिए - अतिरिक्त साइनिंग सार्वजनिक कुंजी – निरस्तीकरण के लिए (वर्तमान में अप्रयुक्त) - क्रिप्टोग्राफिक हस्ताक्षर\n3.1 LeaseSet के प्रकार Type Description Unpublished Destinations used only for outgoing connections aren't published to floodfill routers Revoked Published with zero leases, signed by additional signing key (not fully implemented) LeaseSet2 (LS2) As of 0.9.38, supports new encryption types, multiple encryption types, options, offline signing keys ([Proposal 123](/proposals/123-new-netdb-entries/)) Meta LeaseSet Tree-like DHT structure for multihomed services, supporting hundreds/thousands of destinations with long expirations (up to 18.2 hours) Encrypted LeaseSet (LS1) All leases encrypted with separate key; only those with the key can decode and contact the destination Encrypted LeaseSet (LS2) As of 0.9.38, destination hidden with only blinded public key and expiration visible to floodfill ### 3.2 LeaseSet समाप्ति सामान्य LeaseSets अपनी सबसे अंतिम लीज़ की समाप्ति पर समाप्त हो जाते हैं। LeaseSet2 की समाप्ति शीर्षलेख में निर्दिष्ट होती है। EncryptedLeaseSet और MetaLeaseSet की समाप्ति भिन्न हो सकती है, और उन पर संभावित अधिकतम सीमा लागू की जा सकती है।\n4. बूटस्ट्रैपिंग विकेंद्रीकृत netDb के साथ एकीकृत होने के लिए कम से कम एक पीयर संदर्भ आवश्यक होता है। Reseeding (नेटवर्क के लिए प्रारंभिक RouterInfo प्राप्त करने की प्रक्रिया) स्वयंसेवकों की netDb डायरेक्टरीज़ से RouterInfo फाइलें (routerInfo-$hash.dat) प्राप्त करता है। पहले स्टार्टअप पर यह स्वतः ही यादृच्छिक रूप से चुने गए हार्डकोड किए गए URLs से उन्हें प्राप्त करता है।\n5. Floodfill तंत्र (I2P में netDb के वितरित सूचीकरण और वितरण की व्यवस्था) floodfill netDb सरल वितरित भंडारण का उपयोग करता है: डेटा को सबसे निकट floodfill पीयर को भेजता है। जब गैर‑floodfill पीयर स्टोर संदेश भेजते हैं, तो floodfill उन्हें विशिष्ट कुंजी के सबसे निकट स्थित floodfill पीयर के एक उपसमुच्चय को अग्रेषित करते हैं।\nFloodfill भागीदारी RouterInfo में एक क्षमता फ़्लैग (f) के रूप में दर्शाई जाती है।\n5.1 Floodfill Opt-In आवश्यकताएँ Tor के हार्डकोड किए गए विश्वसनीय डायरेक्टरी सर्वरों के विपरीत, I2P का floodfill समूह अविश्वसनीय है और समय के साथ बदलता रहता है।\nFloodfill स्वतः केवल उन उच्च बैंडविड्थ वाले routers पर सक्षम होता है जो इन आवश्यकताओं को पूरा करते हैं: - न्यूनतम 128 KBytes/sec साझा बैंडविड्थ (मैन्युअल रूप से कॉन्फ़िगर की गई) - अतिरिक्त स्वास्थ्य परीक्षण पास करने चाहिए (outbound message queue time, job lag)\nवर्तमान स्वचालित opt-in (सहमति देकर शामिल होना) के परिणामस्वरूप लगभग 6% नेटवर्क floodfill भागीदारी होती है।\nमैन्युअल रूप से कॉन्फ़िगर किए गए floodfills, स्वचालित स्वयंसेवकों के साथ मौजूद रहते हैं। जब floodfill की संख्या सीमा से नीचे गिरती है, तो उच्च-बैंडविड्थ routers स्वचालित रूप से स्वयंसेवा के लिए आगे आते हैं। जब बहुत अधिक floodfills मौजूद होते हैं, तो वे स्वयं un-floodfill हो जाते हैं (यानी floodfill मोड से बाहर हो जाते हैं)।\n5.2 Floodfill भूमिकाएँ netDb स्टोर्स स्वीकार करने और क्वेरियों का जवाब देने के अलावा, floodfills मानक router कार्य करते हैं। उनकी अधिक बैंडविड्थ आमतौर पर अधिक tunnel भागीदारी का मतलब होती है, लेकिन इसका डेटाबेस सेवाओं से सीधा संबंध नहीं है।\n6. Kademlia (वितरित हैश तालिका प्रोटोकॉल) निकटता मेट्रिक netDb XOR-आधारित Kademlia-शैली (Kademlia: एक वितरित हैश-टेबल एल्गोरिथ्म) दूरी मापन का उपयोग करता है। RouterIdentity या Destination का SHA256 हैश Kademlia कुंजी बनाता है (LS2 Encrypted LeaseSets को छोड़कर, जो type byte 3 तथा blinded public key (ब्लाइंडेड सार्वजनिक कुंजी) के SHA256 का उपयोग करते हैं)।\n6.1 कुंजी-स्थान रोटेशन Sybil attack (सिबिल हमला) की लागत बढ़ाने के लिए, SHA256(key) का उपयोग करने के बजाय, सिस्टम उपयोग करता है:\nSHA256(key + yyyyMMdd) जहाँ तिथि 8-बाइट ASCII UTC तिथि होती है। यह routing key (रूटिंग कुंजी) बनाता है, जो प्रतिदिन UTC मध्यरात्रि पर बदलती है—इसे keyspace rotation (कीस्पेस रोटेशन, यानी कुंजी-स्थान का दैनिक परिवर्तन) कहा जाता है।\nरूटिंग कुंजियाँ कभी भी I2NP संदेशों में प्रेषित नहीं की जातीं; उनका उपयोग केवल स्थानीय दूरी निर्धारण के लिए किया जाता है।\n7. नेटवर्क डेटाबेस (netDb) विभाजन परंपरागत Kademlia DHTs संग्रहीत जानकारी की unlinkability (जोड़े न जा सकने की क्षमता) को बरकरार नहीं रखते। I2P विभाजन लागू करके उन हमलों को रोकता है जो client tunnels को routers से संबद्ध करते हैं।\n7.1 विभाजन रणनीति Routers ट्रैक करते हैं: - क्या प्रविष्टियाँ client tunnels के माध्यम से पहुँचीं या सीधे - यदि tunnel के माध्यम से, तो कौन-सा client tunnel/destination (गंतव्य) - एकाधिक tunnel आगमन ट्रैक किए जाते हैं - संग्रहण बनाम लुकअप प्रतिक्रियाओं में अंतर किया जाता है\nJava और C++ दोनों कार्यान्वयन निम्न का उपयोग करते हैं: - एक \u0026ldquo;Main\u0026rdquo; netDb जो router संदर्भ में प्रत्यक्ष lookups/floodfill operations के लिए होता है - \u0026ldquo;Client Network Databases\u0026rdquo; या \u0026ldquo;Sub-Databases\u0026rdquo; client संदर्भों में, जहाँ client tunnels को भेजी गई प्रविष्टियाँ कैप्चर की जाती हैं\nक्लाइंट netDbs केवल क्लाइंट के जीवनकाल तक ही अस्तित्व में रहते हैं और इनमें केवल क्लाइंट tunnel प्रविष्टियाँ होती हैं। क्लाइंट tunnels की प्रविष्टियाँ प्रत्यक्ष आगमन के साथ ओवरलैप नहीं कर सकतीं।\nप्रत्येक netDb यह ट्रैक करता है कि प्रविष्टियाँ \u0026lsquo;stores\u0026rsquo; के रूप में आई हैं (लुकअप अनुरोधों का उत्तर देने के लिए) या \u0026rsquo;lookup replies\u0026rsquo; के रूप में (केवल तभी उत्तर देती हैं जब पहले से उसी डेस्टिनेशन (गंतव्य पता) पर संग्रहीत हों)। क्लाइंट कभी भी Main netDb प्रविष्टियों का उपयोग करके क्वेरियों का उत्तर नहीं देते; वे केवल क्लाइंट नेटवर्क डेटाबेस प्रविष्टियों से उत्तर देते हैं।\nसंयुक्त रणनीतियाँ क्लाइंट-router संबद्धता हमलों के विरुद्ध netDb को विभाजित करती हैं।\n8. भंडारण, सत्यापन, और खोज 8.1 पीयर्स को RouterInfo का भंडारण I2NP DatabaseStoreMessage जो NTCP या SSU ट्रांसपोर्ट कनेक्शन आरंभीकरण के दौरान स्थानीय RouterInfo के आदान-प्रदान को शामिल करता है।\n8.2 पीयर्स पर LeaseSet भंडारण I2NP DatabaseStoreMessage, जिसमें स्थानीय LeaseSet शामिल होता है, को समय-समय पर Destination (I2P में endpoint/पता) ट्रैफ़िक के साथ बंडल किए गए, garlic encryption से एन्क्रिप्ट किए गए संदेशों के जरिए अदला-बदली किया जाता है, जिससे LeaseSet लुकअप के बिना प्रतिक्रियाएँ संभव हो जाती हैं।\n8.3 Floodfill चयन DatabaseStoreMessage वर्तमान रूटिंग कुंजी के सबसे नज़दीकी floodfill को भेजा जाता है। सबसे नज़दीकी floodfill स्थानीय डेटाबेस खोज के जरिए पाया जाता है। भले ही वह वास्तव में सबसे नज़दीकी न हो, फ्लडिंग (एक साथ कई नोड्स को प्रसारण करने की प्रक्रिया) कई floodfills को भेजकर इसे \u0026ldquo;और नज़दीक\u0026rdquo; तक फैला देती है।\nपारंपरिक Kademlia (एक वितरित हैश तालिका प्रोटोकॉल) सम्मिलन से पहले \u0026ldquo;find-closest\u0026rdquo; खोज (यानी \u0026ldquo;सबसे निकट\u0026rdquo; खोज) का उपयोग करती है। हालाँकि I2NP में ऐसे संदेश नहीं होते, routers वास्तविक निकटतम समकक्ष की खोज सुनिश्चित करने के लिए सबसे कम महत्वपूर्ण बिट को उलटकर (key ^ 0x01) आवर्ती खोज कर सकते हैं।\n8.4 Floodfills पर RouterInfo (राउटर जानकारी) का भंडारण routers एक floodfill से सीधे कनेक्ट करके RouterInfo प्रकाशित करते हैं, और शून्य से भिन्न Reply Token के साथ I2NP DatabaseStoreMessage भेजते हैं. संदेश end-to-end garlic encryption से एन्क्रिप्टेड नहीं होता (सीधा कनेक्शन, कोई मध्यस्थ नहीं). floodfill DeliveryStatusMessage के साथ उत्तर देता है, जहाँ Reply Token को Message ID के रूप में उपयोग किया जाता है.\nRouters exploratory tunnel (कनेक्शन सीमाएँ, असंगतता, IP छुपाना) के माध्यम से भी RouterInfo (राउटर के बारे में वर्णन-सूचना) भेज सकते हैं। Floodfills अधिभार के दौरान ऐसे संग्रह अनुरोधों को अस्वीकार कर सकते हैं।\n8.5 LeaseSet का Floodfills में संग्रहण LeaseSet (I2P में किसी गंतव्य की कनेक्टिविटी जानकारी) का भंडारण, RouterInfo (router के बारे में जानकारी) की तुलना में अधिक संवेदनशील है। Routers को अपने साथ LeaseSet की संबद्धता को रोकना चाहिए।\nRouters आउटबाउंड क्लाइंट tunnel के माध्यम से गैर-शून्य Reply Token के साथ DatabaseStoreMessage भेज कर LeaseSet प्रकाशित करते हैं। संदेश Destination (I2P में गंतव्य पहचान) के Session Key Manager का उपयोग कर end-to-end garlic encryption से सुरक्षित है, जिससे tunnel के आउटबाउंड endpoint से यह छिपा रहता है। Floodfill DeliveryStatusMessage के साथ उत्तर देता है, जो इनबाउंड tunnel के माध्यम से लौटाया जाता है।\n8.6 Flooding (नेटवर्क में संदेश/डेटा को सभी नोड्स/पीयर्स तक व्यापक रूप से प्रसारित करने की विधि) प्रक्रिया Floodfills स्थानीय रूप से संग्रहीत करने से पहले RouterInfo/LeaseSet का सत्यापन करते हैं; इसके लिए वे लोड, netdb के आकार, और अन्य कारकों पर निर्भर अनुकूली मानदंड अपनाते हैं।\nमान्य नया डेटा प्राप्त करने के बाद, floodfills इसे \u0026ldquo;flood\u0026rdquo; करते हैं, routing key (रूटिंग कुंजी) के 3 सबसे नज़दीकी floodfill routers को ढूँढकर। प्रत्यक्ष कनेक्शन I2NP DatabaseStoreMessage शून्य Reply Token (जवाबी टोकन) के साथ भेजते हैं। अन्य routers न तो जवाब देते हैं और न ही दोबारा \u0026ldquo;flood\u0026rdquo; करते हैं।\nमहत्वपूर्ण प्रतिबंध: - Floodfills को tunnels के माध्यम से प्रसारित नहीं करना चाहिए; केवल प्रत्यक्ष कनेक्शन - Floodfills कभी भी अवधि-समाप्त LeaseSet या एक घंटे से अधिक पहले प्रकाशित RouterInfo को प्रसारित नहीं करते\n8.7 RouterInfo और LeaseSet लुकअप I2NP DatabaseLookupMessage floodfill routers से netdb प्रविष्टियाँ अनुरोध करता है। लुकअप्स आउटबाउंड अन्वेषणात्मक tunnel के माध्यम से भेजे जाते हैं; उत्तर वापसी के लिए किस इनबाउंड अन्वेषणात्मक tunnel का उपयोग करना है, यह निर्दिष्ट करते हैं।\nलुकअप अनुरोध सामान्यतः अनुरोधित कुंजी के सबसे निकट वाले दो \u0026ldquo;good\u0026rdquo; floodfill routers को समानांतर रूप से भेजे जाते हैं।\nस्थानीय मिलान: I2NP DatabaseStoreMessage प्रतिक्रिया प्राप्त करता है कोई स्थानीय मिलान नहीं: कुंजी के निकट अन्य floodfill router संदर्भों के साथ I2NP DatabaseSearchReplyMessage प्राप्त करता है LeaseSet लुकअप end-to-end garlic encryption का उपयोग करते हैं (0.9.5 से)। ElGamal की लागत के कारण RouterInfo (router की जानकारी) लुकअप एन्क्रिप्ट नहीं होते, जिससे वे आउटबाउंड एंडपॉइंट पर निगरानी के प्रति असुरक्षित हो जाते हैं।\nसंस्करण 0.9.7 से, लुकअप उत्तरों में सेशन कुंजी और टैग शामिल होते हैं, जिससे उत्तर इनबाउंड गेटवे से छिपे रहते हैं।\n8.8 इटरेटिव लुकअप्स 0.8.9 से पहले: recursive (रिकर्सिव) या iterative (इटरेटिव) रूटिंग के बिना दो समानांतर रिडंडेंट लुकअप।\nसंस्करण 0.8.9 से: Iterative lookups (क्रमिक लुकअप प्रक्रिया) बिना अतिरिक्तता के लागू—अधिक कुशल, विश्वसनीय, और अपूर्ण floodfill ज्ञान के लिए उपयुक्त। जैसे-जैसे नेटवर्क बढ़ते हैं और routers कम floodfills जानते हैं, lookups O(log n) जटिलता के निकट पहुँचते हैं।\nइटरेटिव लुकअप निकटतर पीयर संदर्भ न होने पर भी जारी रहते हैं, जिससे दुर्भावनापूर्ण black-holing (जानबूझकर ट्रैफ़िक को निगल कर रोक देना) रोकी जाती है। वर्तमान अधिकतम क्वेरी संख्या और टाइमआउट लागू हैं।\n8.9 सत्यापन RouterInfo सत्यापन: 0.9.7.1 से निष्क्रिय किया गया ताकि \u0026ldquo;Practical Attacks Against the I2P Network\u0026rdquo; शोधपत्र में वर्णित हमलों को रोका जा सके।\nLeaseSet सत्यापन: Routers ~10 सेकंड प्रतीक्षा करते हैं, फिर outbound client tunnel के माध्यम से किसी अलग floodfill से लुकअप करते हैं। एंड-टू-एंड garlic encryption इसे outbound endpoint से छुपाती है। प्रत्युत्तर inbound tunnels के माध्यम से वापस आते हैं।\nसंस्करण 0.9.7 से, उत्तर इस प्रकार एन्क्रिप्ट किए जाते हैं कि सेशन कुंजी/टैग इनबाउंड गेटवे से छिपे रहें।\n8.10 अन्वेषण अन्वेषण में नए routers के बारे में जानने के लिए यादृच्छिक कुंजियों के साथ netdb लुकअप शामिल होता है। Floodfills DatabaseSearchReplyMessage के साथ उत्तर देते हैं, जिसमें अनुरोधित कुंजी के निकट non-floodfill router हैश शामिल होते हैं। अन्वेषण क्वेरियाँ DatabaseLookupMessage में एक विशेष फ़्लैग सेट करती हैं।\n9. MultiHoming (एकाधिक नेटवर्क कनेक्शनों के जरिए एक ही सिस्टम/सेवा को जोड़ने की व्यवस्था) समान निजी/सार्वजनिक कुंजियों (परंपरागत eepPriv.dat) का उपयोग करने वाले Destinations (I2P पते/पहचान) एक साथ कई routers पर होस्ट कर सकते हैं। प्रत्येक इंस्टेंस समय-समय पर हस्ताक्षरित LeaseSets प्रकाशित करता है; सबसे हाल में प्रकाशित LeaseSet ही लुकअप अनुरोधकर्ताओं को वापस मिलता है। जब LeaseSet की अधिकतम आयु 10 मिनट होती है, तो आउटेज अधिकतम लगभग 10 मिनट तक ही रहते हैं।\nसंस्करण 0.9.38 से, Meta LeaseSets अलग-अलग Destinations (I2P गंतव्य/पता) का उपयोग कर सामान्य सेवाएँ प्रदान करने वाली बड़ी multihomed (कई नेटवर्क इंटरफ़ेस/कनेक्शनों वाली) सेवाओं का समर्थन करती हैं। Meta LeaseSet प्रविष्टियाँ Destinations या अन्य Meta LeaseSets होती हैं, जिनका समाप्ति समय अधिकतम 18.2 घंटे तक होता है, जिससे सामान्य सेवाएँ होस्ट करने वाले सैकड़ों/हज़ारों Destinations सक्षम होते हैं।\n10. खतरा विश्लेषण वर्तमान में लगभग 1700 floodfill routers (विशेष routers जो netDb में डेटा वितरित और संग्रहित करते हैं) कार्यरत हैं। नेटवर्क का विस्तार अधिकांश हमलों को अधिक कठिन या कम प्रभावशाली बना देता है।\n10.1 सामान्य शमन उपाय वृद्धि: अधिक floodfills हमलों को कठिन या कम असरदार बना देते हैं अतिरिक्तता: सभी netdb प्रविष्टियाँ फ्लडिंग के माध्यम से कुंजी के सबसे निकट 3 floodfill routers पर संग्रहीत की जाती हैं हस्ताक्षर: सभी प्रविष्टियाँ निर्माता द्वारा हस्ताक्षरित होती हैं; जालसाज़ी असंभव है 10.2 धीमे या अनुत्तरदायी Routers Routers floodfills के लिए विस्तारित पीयर प्रोफ़ाइल आँकड़े बनाए रखते हैं: - औसत प्रतिक्रिया समय - क्वेरी उत्तर प्रतिशत - स्टोर सत्यापन सफलता प्रतिशत - अंतिम सफल स्टोर - अंतिम सफल लुकअप - अंतिम प्रतिक्रिया\nसबसे निकटतम floodfill के चयन हेतु \u0026ldquo;goodness\u0026rdquo; (उपयुक्तता सूचक) निर्धारित करते समय routers इन मापदंडों का उपयोग करते हैं। जो routers बिल्कुल भी प्रतिक्रिया नहीं देते, उन्हें शीघ्र पहचाना और टाला जाता है; आंशिक रूप से दुर्भावनापूर्ण routers अधिक चुनौती पेश करते हैं।\n10.3 Sybil हमला (पूर्ण Keyspace (कुंजी-स्थान)) हमलावर एक प्रभावी DoS हमले के तौर पर पूरे keyspace (कुंजी-परास) में बिखरे हुए अनेक floodfill routers बना सकते हैं।\nयदि \u0026ldquo;bad\u0026rdquo; के रूप में नामित करने लायक पर्याप्त गलत व्यवहार नहीं है, तो संभावित प्रतिक्रियाएँ शामिल हैं: - कंसोल समाचार, वेबसाइट, फ़ोरम के माध्यम से घोषित खराब router हैश/IP सूचियों का संकलन - नेटवर्क-व्यापी floodfill सक्रियकरण (\u0026ldquo;अधिक Sybil के साथ Sybil से लड़ना\u0026rdquo;) - हार्डकोडेड \u0026ldquo;bad\u0026rdquo; सूचियों वाले नए सॉफ़्टवेयर संस्करण - स्वचालित पहचान के लिए बेहतर पीयर प्रोफ़ाइल मीट्रिक्स और सीमांत मान - एक ही IP ब्लॉक में अनेक floodfills को अयोग्य ठहराने वाला IP ब्लॉक योग्यता निर्धारण - स्वचालित सदस्यता-आधारित ब्लैकलिस्ट (Tor consensus के समान)\nबड़े नेटवर्क इसे और कठिन बना देते हैं।\n10.4 सिबिल आक्रमण (आंशिक Keyspace (कुंजी-क्षेत्र)) हमलावर 8–15 floodfill routers बना सकते हैं, जिन्हें keyspace (कुंजी स्थान) में आपस में बहुत पास-पास क्लस्टर किया गया हो। उस keyspace के लिए सभी lookups/stores हमलावर के routers की ओर निर्देशित हो जाते हैं, जिससे विशिष्ट I2P साइटों पर DOS (सेवा-वंचन हमला) संभव हो जाता है।\nचूंकि keyspace क्रिप्टोग्राफ़िक SHA256 हैश का अनुक्रमण करता है, हमलावरों को पर्याप्त निकटता वाले routers उत्पन्न करने के लिए brute-force (संपूर्ण-परीक्षण) की आवश्यकता होती है।\nरक्षा: Kademlia निकटता एल्गोरिद्म समय के साथ SHA256(key + YYYYMMDD) का उपयोग करके बदलता रहता है, जो हर दिन UTC मध्यरात्रि पर बदल जाता है. यह keyspace rotation (कुंजी-स्थान का परिवर्तन) हमले के दैनिक पुनर्जनन को बाध्य करता है.\nNote: हालिया शोध से पता चलता है कि keyspace (कुंजी स्थान) रोटेशन विशेष रूप से प्रभावी नहीं है—हमलावर router हैशों की पूर्व-गणना कर सकते हैं, और रोटेशन के बाद आधे घंटे के भीतर keyspace के कुछ हिस्सों को अलग-थलग करने के लिए केवल कुछ routers की आवश्यकता होती है।\nदैनिक रोटेशन का परिणाम: रोटेशन के बाद कुछ मिनटों तक वितरित netdb अविश्वसनीय हो जाती है—नए सबसे निकट router को stores (store संदेश) प्राप्त होने से पहले lookups (खोज अनुरोध) विफल हो जाते हैं।\n10.5 बूटस्ट्रैप हमले हमलावर reseed websites (I2P में नेटवर्क से पहली बार जुड़ने के लिए आवश्यक seed जानकारी देने वाली वेबसाइटें) पर कब्जा कर सकते हैं या डेवलपरों को धोखा देकर दुर्भावनापूर्ण reseed websites जोड़वा सकते हैं, जिससे नए routers अलग-थलग/बहुसंख्यक-नियंत्रित नेटवर्कों में बूट हो जाएँ।\nलागू किए गए बचाव उपाय: - एकल साइट के बजाय कई reseed (नेटवर्क में शामिल होने के लिए शुरुआती सीड/बूटस्ट्रैप सेवा) साइटों से RouterInfo (router की जानकारी का रिकॉर्ड) के उपसमुच्चय प्राप्त करना - नेटवर्क के बाहर reseed मॉनिटरिंग, जो साइटों को नियमित रूप से पोल करती है - संस्करण 0.9.14 से, reseed डेटा बंडल हस्ताक्षरित zip फ़ाइलों के रूप में होते हैं, जिनके लिए डाउनलोड किए गए हस्ताक्षर का सत्यापन किया जाता है (देखें su3 विनिर्देश )\n10.6 क्वेरी कैप्चर Floodfill routers लौटाए गए संदर्भों के माध्यम से समकक्षों को हमलावर-नियंत्रित routers की ओर \u0026ldquo;मार्गित\u0026rdquo; कर सकते हैं।\nकम आवृत्ति के कारण अन्वेषण के जरिए होने की संभावना कम है; routers मुख्यतः सामान्य tunnel निर्माण के माध्यम से पीयर संदर्भ प्राप्त करते हैं।\nसंस्करण 0.8.9 से, पुनरावृत्त खोजें लागू की गई हैं। DatabaseSearchReplyMessage के floodfill रेफ़रेंस, यदि वे खोज कुंजी के अधिक निकट हों, तो उनका अनुसरण किया जाता है। अनुरोध करने वाले routers रेफ़रेंस की निकटता पर भरोसा नहीं करते। अधिक निकट कुंजियाँ न होने पर भी, टाइमआउट/अधिकतम क्वेरी तक खोज जारी रहती है, जिससे दुर्भावनापूर्ण black-holing (अनुरोधों को जानबूझकर गायब करना) को रोका जाता है।\n10.7 सूचना का रिसाव I2P में DHT (वितरित हैश तालिका) की सूचना-लीक पर और जांच की आवश्यकता है। Floodfill routers क्वेरियों का अवलोकन करके जानकारी एकत्र करते हैं। जब दुर्भावनापूर्ण नोड्स 20% तक हों, तो पहले वर्णित Sybil (बहु-पहचान) खतरे कई कारणों से समस्याग्रस्त हो जाते हैं।\n11. भविष्य का कार्य अतिरिक्त netDb लुकअप और प्रतिक्रियाओं के लिए एंड-टू-एंड एन्क्रिप्शन बेहतर लुकअप प्रतिक्रिया ट्रैकिंग विधियाँ keyspace rotation (कुंजी-स्थान घुमाव) से जुड़ी विश्वसनीयता संबंधी समस्याओं के लिए शमन विधियाँ 12. संदर्भ सामान्य संरचनाओं का विनिर्देश – RouterInfo और LeaseSet संरचनाएँ I2NP विनिर्देश – डेटाबेस संदेश प्रकार प्रस्ताव 123: नई netDb प्रविष्टियाँ – LeaseSet2 विनिर्देश ऐतिहासिक netDb चर्चा – विकास इतिहास और संग्रहीत चर्चाएँ ","description":"I2P के वितरित नेटवर्क डेटाबेस (netDb) को समझना - router संपर्क जानकारी और गंतव्य खोज के लिए एक विशेषीकृत वितरित हैश तालिका (DHT)","id":"ef0a5e8bee4372a50a7f4562af717b0c","section":"docs","title":"नेटवर्क डेटाबेस","url":"/hi/docs/overview/network-database/"},{"categories":null,"content":" ध्यान दें: यह अभिलेखीय चर्चा नेटवर्क डेटाबेस (netDb) के ऐतिहासिक दृष्टिकोणों की रूपरेखा प्रस्तुत करती है। वर्तमान व्यवहार और मार्गदर्शन के लिए मुख्य netDb प्रलेखन देखें।\nइतिहास I2P के netDb को एक सरल floodfill एल्गोरिथ्म का उपयोग करके वितरित किया जाता है। प्रारंभिक रिलीज़ों में बैकअप के रूप में Kademlia DHT (वितरित हैश तालिका) का क्रियान्वयन भी रखा गया था, लेकिन यह अविश्वसनीय साबित हुआ और संस्करण 0.6.1.20 में पूरी तरह निष्क्रिय कर दिया गया। floodfill डिज़ाइन प्रकाशित प्रविष्टि को किसी प्रतिभागी router तक अग्रेषित करता है, पुष्टि की प्रतीक्षा करता है, और आवश्यकता होने पर अन्य floodfill समकक्षों के साथ पुनः प्रयास करता है। Floodfill समकक्ष गैर-floodfill routers से आने वाले stores (डेटाबेस स्टोर संदेश) को हर अन्य floodfill प्रतिभागी तक प्रसारित करते हैं।\n2009 के उत्तरार्ध में Kademlia (एक वितरित हैश टेबल (DHT) प्रोटोकॉल) लुकअप्स को आंशिक रूप से पुनः लागू किया गया ताकि व्यक्तिगत floodfill routers पर भंडारण का भार कम किया जा सके।\nFloodfill का परिचय Floodfill पहली बार रिलीज़ 0.6.0.4 में आया, जबकि Kademlia (एक वितरित हैश तालिका, DHT) बैकअप के रूप में उपलब्ध रहा। उस समय, भारी पैकेट लॉस और प्रतिबंधित मार्गों के कारण चार सबसे निकट पीयर्स से पुष्टिकरण प्राप्त करना कठिन था, और अक्सर पुष्टिकरण पाने के लिए दर्जनों बार अनावश्यक रूप से store करने के प्रयास करने पड़ते थे। बाहरी रूप से पहुँच योग्य routers के floodfill उपसमूह पर स्थानांतरित होना एक व्यावहारिक अल्पकालिक समाधान साबित हुआ।\nKademlia पर पुनर्विचार विचार किए गए कुछ विकल्पों में शामिल थे:\nnetDb को Kademlia DHT (वितरित हैश तालिका) के रूप में चलाना, जिसे उन सुलभ routers तक सीमित किया गया है जो भागीदारी के लिए स्वेच्छा से शामिल हों floodfill model को बरकरार रखते हुए, भागीदारी को सक्षम routers तक सीमित करना और यादृच्छिक जाँचों द्वारा वितरण का सत्यापन करना floodfill दृष्टिकोण इसलिए अपनाया गया क्योंकि इसे परिनियोजित करना आसान था और netDb में केवल मेटाडेटा रहता है; इसमें user payloads (वास्तविक उपयोगकर्ता डेटा) नहीं होते। अधिकांश गंतव्य कभी भी LeaseSet प्रकाशित नहीं करते क्योंकि प्रेषक आमतौर पर अपने LeaseSet को garlic संदेशों में बंडल कर देता है।\nवर्तमान स्थिति (ऐतिहासिक परिप्रेक्ष्य) netDb (नेटवर्क डेटाबेस) एल्गोरिद्म नेटवर्क की आवश्यकताओं के अनुरूप अनुकूलित हैं और ऐतिहासिक रूप से इन एल्गोरिद्मों ने कुछ सौ routers (I2P नोड्स) को आसानी से संभाला है। प्रारंभिक आकलनों से संकेत मिला कि 3–5 floodfill (विशेष netDb इंडेक्सिंग भूमिका) routers लगभग 10,000 नोड्स का समर्थन कर सकते थे।\nअद्यतन गणनाएँ (मार्च 2008) recvKBps = N * (L + 1) * (1 + F) * (1 + R) * S / T जहाँ:\nN: नेटवर्क में Routers की संख्या L: प्रति router औसत क्लाइंट गंतव्यों की संख्या (साथ में RouterInfo के लिए एक अतिरिक्त) F: Tunnel (I2P में गोपनीय मार्ग) विफलता प्रतिशत R: Tunnel पुनर्निर्माण अवधि, Tunnel जीवनकाल के एक अंश के रूप में S: औसत netDb (I2P का वितरित डेटाबेस) प्रविष्टि आकार T: Tunnel जीवनकाल 2008 के दौर के मानों (N = 700, L = 0.5, F = 0.33, R = 0.5, S = 4 KB, T = 10 minutes) का उपयोग करने पर प्राप्त होता है:\nrecvKBps ≈ 700 * (0.5 + 1) * (1 + 0.33) * (1 + 0.5) * 4 KB / 10m ≈ 28 KBps क्या Kademlia (एक वितरित हैश तालिका—DHT—प्रोटोकॉल) लौटेगा? डेवलपर्स ने लगभग 2007 की शुरुआत में Kademlia (एक वितरित हैश टेबल एल्गोरिदम) को फिर से शामिल करने पर चर्चा की। सहमति यह बनी कि floodfill क्षमता को आवश्यकतानुसार क्रमिक रूप से बढ़ाया जा सकता है, जबकि Kademlia मूलभूत router आबादी के लिए काफी अधिक जटिलता और संसाधन आवश्यकताएँ जोड़ देता है। जब तक floodfill क्षमता अपर्याप्त नहीं हो जाती, वैकल्पिक व्यवस्था सुप्त रहती है।\nFloodfill क्षमता नियोजन बैंडविड्थ-वर्ग O के routers को floodfill में स्वतः शामिल करना, भले ही आकर्षक लगे, शत्रुतापूर्ण नोड्स के शामिल होने पर denial-of-service (सेवा-अस्वीकरण) परिदृश्यों का जोखिम पैदा करता है। ऐतिहासिक विश्लेषण ने संकेत दिया कि floodfill पूल को सीमित रखना (उदाहरण के लिए, 3–5 पीयर्स द्वारा ~10K routers संभालना) अधिक सुरक्षित था। उचित किंतु नियंत्रित floodfill सेट बनाए रखने के लिए विश्वसनीय ऑपरेटरों या स्वचालित अनुमानी विधियों का उपयोग किया गया है।\nFloodfill TODO (ऐतिहासिक) यह अनुभाग अभिलेख हेतु सुरक्षित रखा गया है। मुख्य netDb पृष्ठ वर्तमान रोडमैप और डिज़ाइन संबंधी विचारों को ट्रैक करता है।\nसंचालन संबंधी घटनाएँ, जैसे 13 मार्च, 2008 की वह अवधि जब केवल एक उपलब्ध floodfill router (netDb प्रविष्टियाँ वितरित करने वाला विशेष router) था, ने कई सुधारों को प्रेरित किया जो 0.6.1.33 से 0.7.x तक की रिलीज़ों में उपलब्ध कराए गए, जिनमें शामिल हैं:\nखोजों के लिए floodfill चयन को यादृच्छिक बनाना और प्रतिक्रियाशील पीयर को प्राथमिकता देना router कंसोल के \u0026ldquo;Profiles\u0026rdquo; पृष्ठ पर अतिरिक्त floodfill मेट्रिक्स प्रदर्शित करना floodfill बैंडविड्थ उपयोग घटाने के लिए netDb प्रविष्टि आकार में क्रमिक कमी प्रोफ़ाइल डेटा के माध्यम से एकत्रित प्रदर्शन के आधार पर class O routers के एक उपसमूह के लिए स्वचालित opt-in (सक्रिय सम्मिलन) उन्नत blocklisting (ब्लॉक-सूचीकरण), floodfill पीयर चयन, और exploration heuristics (अनुमान-आधारित विधियाँ) उस अवधि के शेष विचारों में शामिल थे:\ndbHistory आँकड़ों का उपयोग करके floodfill समकक्षों का बेहतर मूल्यांकन और चयन करना बार-बार असफल हो रहे समकक्षों से संपर्क से बचने हेतु पुनःप्रयास व्यवहार में सुधार करना चयन में विलंबता मेट्रिक्स और एकीकरण स्कोर का लाभ उठाना असफल हो रहे floodfill routers का अधिक तेजी से पता लगाना और उस पर प्रतिक्रिया देना उच्च-बैंडविड्थ और floodfill नोड्स पर संसाधन मांग को लगातार कम करना इन नोट्स के समय तक भी, नेटवर्क को लचीला माना जाता था, और शत्रुतापूर्ण floodfills या floodfill को लक्ष्य बनाकर किए गए सेवा-निषेध हमलों पर शीघ्र प्रतिक्रिया देने के लिए बुनियादी ढांचा मौजूद था।\nअतिरिक्त टिप्पणियाँ router कंसोल काफी समय से उन्नत प्रोफ़ाइल डेटा प्रदर्शित कर रहा है, ताकि floodfill (I2P नेटवर्क डेटाबेस के प्रसार/रूटिंग की पद्धति) की विश्वसनीयता का विश्लेषण करने में मदद मिल सके। जबकि ऐतिहासिक टिप्पणियों में Kademlia या वैकल्पिक DHT (वितरित हैश तालिका) योजनाओं पर कयास लगाए गए, floodfill उत्पादन-स्तरीय नेटवर्कों में प्रमुख एल्गोरिद्म बना रहा है। दूरंदेशी शोध का ध्यान floodfill में प्रवेश को अनुकूली बनाने पर रहा है, साथ ही दुरुपयोग के अवसरों को सीमित करने पर। ","description":"floodfill, Kademlia (वितरित हैश तालिका एल्गोरिथ्म) प्रयोग, और netDb के लिए भविष्य की ट्यूनिंग पर ऐतिहासिक टिप्पणियाँ","id":"0ddefeec5b7108b36649c4d989bf474e","section":"docs","title":"नेटवर्क डेटाबेस पर चर्चा","url":"/hi/docs/netdb/"},{"categories":null,"content":"अवलोकन यह विनिर्देश पता सदस्यता फ़ीड को आदेशों के साथ विस्तारित करता है, जिससे नेम सर्वर होस्टनेम धारकों से प्रविष्टि अपडेट प्रसारित कर सकें। मूल रूप से Proposal 112 (सितंबर 2014) में प्रस्तावित, संस्करण 0.9.26 (जून 2016) में लागू किया गया, और नेटवर्क-व्यापी स्थिति CLOSED के साथ परिनियोजित।\nयह प्रणाली अपने प्रारंभिक कार्यान्वयन से स्थिर और अपरिवर्तित बनी हुई है, और I2P 2.10.0 (Router API 0.9.65, सितंबर 2025) में भी समान रूप से संचालित होती रही है।\nप्रेरणा पहले, hosts.txt सदस्यता सर्वर केवल साधारण hosts.txt फ़ॉर्मेट में ही डेटा भेजते थे:\nexample.i2p=b64destination इस बुनियादी प्रारूप ने कई समस्याएँ पैदा कीं:\nHostname धारक अपने होस्टनेम से संबद्ध Destination (I2P में गंतव्य पहचान) को अद्यतन नहीं कर सकते (उदाहरण के लिए, साइनिंग कुंजी को अधिक मज़बूत क्रिप्टोग्राफिक प्रकार में उन्नत करने के लिए)। Hostname धारक अपने होस्टनेम मनमाने ढंग से त्याग नहीं सकते। उन्हें संबंधित Destination की निजी कुंजियाँ सीधे नए धारक को देनी होंगी। यह प्रमाणित करने का कोई तरीका नहीं है कि कोई उपडोमेन संबंधित आधार होस्टनेम द्वारा नियंत्रित है। वर्तमान में इसे केवल कुछ नेम सर्वर व्यक्तिगत रूप से लागू करते हैं। डिज़ाइन यह विनिर्देश hosts.txt प्रारूप में कमांड पंक्तियाँ जोड़ता है। इन कमांड की मदद से, नेम सर्वर अपनी सेवाओं का विस्तार करके अतिरिक्त सुविधाएँ प्रदान कर सकते हैं। जो क्लाइंट इस विनिर्देश को लागू करते हैं, वे नियमित सदस्यता प्रक्रिया के माध्यम से इन सुविधाओं का पता लगा सकते हैं।\nसभी कमांड पंक्तियाँ संबंधित Destination (I2P में किसी सेवा का क्रिप्टोग्राफिक पहचानकर्ता) द्वारा हस्ताक्षरित होनी चाहिए। इससे सुनिश्चित होता है कि परिवर्तन केवल होस्टनेम धारक के अनुरोध पर ही किए जाएँ।\nसुरक्षा संबंधी निहितार्थ यह विनिर्देश गुमनामी को प्रभावित नहीं करता।\nDestination key पर नियंत्रण खो देने से जुड़े जोखिम में वृद्धि होती है, क्योंकि जिसे भी यह मिल जाए, वह इन कमांड्स का उपयोग करके संबद्ध किसी भी होस्टनेम में परिवर्तन कर सकता है। हालाँकि, यह वर्तमान स्थिति से अधिक समस्या नहीं है, जहाँ कोई भी Destination (I2P में किसी सेवा/साइट की सार्वजनिक पहचान) प्राप्त कर लेने पर किसी होस्टनेम का प्रतिरूपण कर सकता है और उसके ट्रैफ़िक पर (आंशिक रूप से) नियंत्रण कर सकता है। यह बढ़ा हुआ जोखिम इस बात से संतुलित होता है कि होस्टनेम धारकों को, यदि उन्हें लगता है कि Destination से समझौता हो गया है, तो उस होस्टनेम से संबद्ध Destination बदलने की क्षमता मिलती है। यह वर्तमान प्रणाली में असंभव है।\nविनिर्देश लाइन के नए प्रकार दो नए प्रकार की लाइनें हैं:\nAdd और Change कमांड्स: example.i2p=b64destination#!key1=val1#key2=val2... कमांड्स हटाएँ: #!key1=val1#key2=val2... क्रम एक फीड जरूरी नहीं कि क्रमबद्ध हो या पूरी हो। उदाहरण के लिए, change कमांड किसी पंक्ति में add कमांड से पहले दिखाई दे सकती है, या add कमांड के बिना भी आ सकती है।\nकुंजियाँ किसी भी क्रम में हो सकती हैं। डुप्लिकेट कुंजियाँ अनुमत नहीं हैं। सभी कुंजियाँ और मान case-sensitive (बड़े-छोटे अक्षरों के भेद पर निर्भर) हैं।\nसामान्य कुंजियाँ सभी कमांड्स में अनिवार्य:\nsig : Base64 में हस्ताक्षर, Destination (गंतव्य) की साइनिंग कुंजी का उपयोग करते हुए\nदूसरे होस्टनेम और/या गंतव्य के संदर्भ:\noldname : दूसरा hostname (होस्ट का नाम) (नया या बदला हुआ)\nolddest : दूसरा Base64 डेस्टिनेशन (नया या बदला हुआ)\noldsig : एक दूसरा Base64 हस्ताक्षर, olddest की हस्ताक्षर कुंजी का उपयोग करते हुए\nअन्य सामान्य कुंजियाँ:\naction : एक कमांड\nname : होस्टनेम, केवल तभी मौजूद होगा जब इसके पहले example.i2p=b64dest न हो\ndest : Base64 (एन्कोडिंग फ़ॉर्मैट) में एन्कोड किया गया गंतव्य, केवल तब मौजूद होगा जब इससे पहले example.i2p=b64dest न हो\ndate : epoch (यूनिक्स समय की शुरुआत) से बीते सेकंडों में\nexpires : epoch (कंप्यूटिंग में संदर्भ प्रारंभ समय, सामान्यतः Unix epoch) से बीते सेकंड में\nआदेश \u0026ldquo;Add\u0026rdquo; कमांड को छोड़कर सभी कमांड्स में action=command कुंजी/मान युग्म होना चाहिए।\nपुराने क्लाइंट्स के साथ संगतता हेतु, अधिकांश आदेशों के आगे, जैसा कि नीचे उल्लेखित है, example.i2p=b64dest जोड़ा जाता है। परिवर्तनों के लिए, यहाँ दिए गए मान हमेशा नए होते हैं। कोई भी पुराने मान कुंजी/मान अनुभाग में शामिल हैं।\nसूचीबद्ध कुंजियाँ आवश्यक हैं। सभी कमांड में यहाँ परिभाषित नहीं की गई अतिरिक्त कुंजी/मान प्रविष्टियाँ हो सकती हैं।\nहोस्टनेम जोड़ें example.i2p=b64dest से पूर्व : हाँ, यह नया होस्टनेम और गंतव्य है।\nक्रिया : शामिल नहीं है, यह निहित है।\nsig : हस्ताक्षर\nउदाहरण:\nexample.i2p=b64dest#!sig=b64sig होस्टनेम बदलें example.i2p=b64dest से पूर्व : हाँ, यह नया hostname (होस्टनेम) और पुराना destination (गंतव्य) है.\nक्रिया : changename\noldname : पुराना होस्टनेम, जिसे प्रतिस्थापित किया जाना है\nsig : हस्ताक्षर\nउदाहरण:\nexample.i2p=b64dest#!action=changename#oldname=oldhostname#sig=b64sig गंतव्य बदलें example.i2p=b64dest से पहले : हाँ, यह पुराना होस्टनेम और नया गंतव्य है.\naction : changedest\nolddest : पुराना गंतव्य, जिसे प्रतिस्थापित किया जाना है\noldsig : olddest का उपयोग करते हुए हस्ताक्षर\nsig : हस्ताक्षर\nउदाहरण:\nexample.i2p=b64dest#!action=changedest#olddest=oldb64dest#oldsig=b64sig#sig=b64sig होस्टनेम उपनाम जोड़ें example.i2p=b64dest से पहले लिखा हो : हाँ, यह नया (उपनाम) होस्टनेम और पुराना destination (I2P गंतव्य पता) है।\nक्रिया : addname\noldname : पुराना होस्टनेम\nsig : हस्ताक्षर\nउदाहरण:\nexample.i2p=b64dest#!action=addname#oldname=oldhostname#sig=b64sig गंतव्य उपनाम जोड़ें (कूटलेखन उन्नयन के लिए उपयोग किया जाता है)\nexample.i2p=b64dest से पहले : हाँ, यह पुराना होस्टनेम और नया (वैकल्पिक) गंतव्य है।\nक्रिया : adddest\nolddest : पुराना गंतव्य\noldsig : olddest का उपयोग करके हस्ताक्षर\nsig : dest का उपयोग करके हस्ताक्षर\nउदाहरण:\nexample.i2p=b64dest#!action=adddest#olddest=oldb64dest#oldsig=b64sig#sig=b64sig सबडोमेन जोड़ें subdomain.example.i2p=b64dest से पहले : हाँ, यह नया सबडोमेन नाम और गंतव्य है।\naction : addsubdomain\noldname : उच्च-स्तरीय होस्टनेम (example.i2p)\nolddest : उच्च-स्तरीय गंतव्य (उदाहरण के लिए example.i2p)\noldsig : olddest का उपयोग करते हुए हस्ताक्षर\nsig : dest का उपयोग करके हस्ताक्षर\nउदाहरण:\nsubdomain.example.i2p=b64dest#!action=addsubdomain#oldname=example.i2p#olddest=oldb64dest#oldsig=b64sig#sig=b64sig मेटाडेटा अपडेट करें example.i2p=b64dest से पहले : हाँ, यह पुराना होस्टनेम और गंतव्य है.\nक्रिया : अद्यतन\nsig : डिजिटल हस्ताक्षर\n(यहाँ कोई भी अद्यतन कुंजियाँ जोड़ें)\nउदाहरण:\nexample.i2p=b64dest#!action=update#k1=v1#k2=v2#sig=b64sig होस्टनेम हटाएँ example.i2p=b64dest उपसर्ग के साथ : नहीं, ये विकल्पों में निर्दिष्ट किए जाते हैं\nक्रिया : हटाना\nname : होस्टनेम\ndest : गंतव्य\nsig : डिजिटल हस्ताक्षर\nउदाहरण:\n#!action=remove#name=example.i2p#dest=b64dest#sig=b64sig इस गंतव्य से संबंधित सभी हटाएँ example.i2p=b64dest से पहले : नहीं, ये विकल्पों में निर्दिष्ट किए जाते हैं\naction : removeall\ndest : गंतव्य\nsig : हस्ताक्षर\nउदाहरण:\n#!action=removeall#dest=b64dest#sig=b64sig हस्ताक्षर सभी कमांडों को संबंधित Destination (I2P में गंतव्य पहचानकर्ता) द्वारा हस्ताक्षरित होना चाहिए। जिन कमांडों में दो destinations हों, उन्हें दो हस्ताक्षरों की आवश्यकता हो सकती है।\noldsig हमेशा \u0026ldquo;भीतरी\u0026rdquo; हस्ताक्षर होता है। oldsig या sig कुंजियाँ मौजूद न हों तो हस्ताक्षर करें और सत्यापित करें। sig हमेशा \u0026ldquo;बाहरी\u0026rdquo; हस्ताक्षर होता है। oldsig कुंजी मौजूद हो लेकिन sig कुंजी न हो, तब हस्ताक्षर करें और सत्यापित करें।\nहस्ताक्षरों के लिए इनपुट हस्ताक्षर बनाने या सत्यापित करने के लिए बाइट स्ट्रीम उत्पन्न करने हेतु, निम्नानुसार सीरियलाइज़ करें:\nsig कुंजी हटाएँ यदि oldsig के साथ सत्यापन कर रहे हैं, तो oldsig कुंजी भी हटाएँ केवल Add या Change कमांड्स के लिए, example.i2p=b64dest आउटपुट करें यदि कोई कुंजियाँ शेष रहें, तो #! आउटपुट करें विकल्पों को UTF-8 (यूनिकोड टेक्स्ट एन्कोडिंग) कुंजी के अनुसार क्रमबद्ध करें, और यदि डुप्लिकेट कुंजियाँ हों तो विफल करें प्रत्येक कुंजी/मान के लिए, key=value आउटपुट करें, और इसके बाद (यदि यह अंतिम कुंजी/मान नहीं है) एक # टिप्पणियाँ\nनई पंक्ति आउटपुट न करें आउटपुट एन्कोडिंग UTF-8 है सभी डेस्टिनेशन और हस्ताक्षर का एन्कोडिंग I2P alphabet (I2P का वर्णमाला सेट) का उपयोग करते हुए Base 64 में होता है कुंजियाँ और मान केस-सेंसिटिव होते हैं होस्टनेम छोटे अक्षरों में होने चाहिए वर्तमान हस्ताक्षर प्रकार I2P 2.10.0 से, destinations (I2P में सार्वजनिक-कुंजी-आधारित पते) के लिए निम्नलिखित हस्ताक्षर प्रकार समर्थित हैं:\nEdDSA_SHA512_Ed25519 (Type 7): 0.9.15 से destinations (I2P में \u0026ldquo;destination\u0026rdquo; यानी सेवा/पता) के लिए सबसे सामान्य। 32-बाइट सार्वजनिक कुंजी और 64-बाइट हस्ताक्षर का उपयोग करता है। यह नए destinations के लिए अनुशंसित हस्ताक्षर प्रकार है। RedDSA_SHA512_Ed25519 (Type 13): केवल destinations और एन्क्रिप्टेड leasesets के लिए उपलब्ध (0.9.39 से)। पुराने प्रकार (DSA_SHA1, ECDSA variants): अब भी समर्थित हैं, लेकिन 0.9.58 से नए Router Identities (router की पहचानें) के लिए अप्रचलित हैं। नोट: Post-quantum (क्वांटम-पश्चात) क्रिप्टोग्राफिक विकल्प I2P 2.10.0 से उपलब्ध हैं, लेकिन अभी तक डिफ़ॉल्ट हस्ताक्षर प्रकार नहीं हैं।\nसंगतता hosts.txt स्वरूप में सभी नई पंक्तियाँ आरंभिक टिप्पणी वर्णों (#!) का उपयोग करके लागू की गई हैं, इसलिए I2P के सभी पुराने संस्करण नए आदेशों को टिप्पणियों के रूप में समझेंगे और उन्हें बिना किसी समस्या के अनदेखा कर देंगे।\nजब I2P routers नए विनिर्देशन के अनुरूप अद्यतन करेंगे, तो वे पुरानी टिप्पणियों की पुनर्व्याख्या नहीं करेंगे, बल्कि अपनी सदस्यता फ़ीड की आगामी प्राप्तियों में नई कमांडों का प्रसंस्करण शुरू कर देंगे। इसलिए नेम सर्वरों के लिए यह महत्वपूर्ण है कि वे किसी न किसी तरीके से कमांड प्रविष्टियों को स्थायी रूप से बनाए रखें, या ETag support (ETag—HTTP एंटिटी टैग जो संसाधन के संस्करण की पहचान करता है) सक्षम करें ताकि routers सभी पूर्ववर्ती कमांड प्राप्त कर सकें।\nकार्यान्वयन की स्थिति प्रारंभिक परिनियोजन: संस्करण 0.9.26 (7 जून, 2016)\nवर्तमान स्थिति: I2P 2.10.0 तक स्थिर और अपरिवर्तित (Router API 0.9.65, सितंबर 2025)\nप्रस्ताव की स्थिति: बंद (सफलतापूर्वक नेटवर्क-व्यापी परिनियोजित)\nकार्यान्वयन स्थान: apps/addressbook/java/src/net/i2p/addressbook/ I2P Java router में\nमुख्य कक्षाएँ: - SubscriptionList.java: सदस्यता (subscription) प्रसंस्करण का प्रबंधन करता है - Subscription.java: व्यक्तिगत सदस्यता फ़ीड (feed) को संभालता है - AddressBook.java: एड्रेसबुक (addressbook) की मुख्य कार्यक्षमता - Daemon.java: एड्रेसबुक पृष्ठभूमि सेवा\nपूर्वनिर्धारित सदस्यता URL: http://i2p-projekt.i2p/hosts.txt\nपरिवहन विवरण सदस्यताएँ conditional GET समर्थन के साथ HTTP का उपयोग करती हैं:\nETag header: परिवर्तनों का कुशलतापूर्वक पता लगाने का समर्थन करता है Last-Modified header: सदस्यता के अद्यतन समय को ट्रैक करता है 304 Not Modified: जब सामग्री में परिवर्तन न हुआ हो, तो सर्वरों को यह लौटाना चाहिए Content-Length: सभी प्रतिक्रियाओं के लिए इसे दृढ़ता से अनुशंसित किया जाता है I2P router मानक HTTP क्लाइंट व्यवहार का उपयोग करता है, जिसमें उचित कैशिंग समर्थन शामिल है।\nसंस्करण संदर्भ I2P संस्करणकरण नोट: लगभग संस्करण 1.5.0 (अगस्त 2021) से, I2P ने 0.9.x संस्करणकरण से semantic versioning (1.x, 2.x, आदि) (अर्थ-आधारित संस्करणकरण) पर बदलाव किया। हालांकि, आंतरिक Router API संस्करण backward compatibility (पिछड़ी संगतता) के लिए 0.9.x क्रमांकन का उपयोग जारी रखता है। अक्टूबर 2025 तक, वर्तमान रिलीज़ I2P 2.10.0 है, जिसके साथ Router API संस्करण 0.9.65 है।\nयह विनिर्देश दस्तावेज़ मूल रूप से संस्करण 0.9.49 (फ़रवरी 2021) के लिए लिखा गया था और वर्तमान संस्करण 0.9.65 (I2P 2.10.0) के लिए भी पूरी तरह सटीक बना हुआ है, क्योंकि 0.9.26 में इसके मूल कार्यान्वयन के बाद से सब्सक्रिप्शन फ़ीड सिस्टम में कोई बदलाव नहीं हुआ है।\nसंदर्भ प्रस्ताव 112 (मूल) आधिकारिक विनिर्देश I2P नामकरण प्रलेखन सामान्य संरचनाओं का विनिर्देश I2P स्रोत रिपॉजिटरी I2P Gitea रिपॉजिटरी संबंधित विकास हालाँकि सब्सक्रिप्शन फ़ीड प्रणाली स्वयं नहीं बदली है, I2P की नामकरण अवसंरचना में निम्न संबंधित विकास रुचिकर हो सकते हैं:\nविस्तारित Base32 नाम (0.9.40+): एन्क्रिप्टेड leasesets के लिए 56+ वर्णों वाले base32 पते का समर्थन। सदस्यता फ़ीड के प्रारूप को प्रभावित नहीं करता। .i2p.alt TLD पंजीकरण (RFC 9476, 2023 के अंत में): .i2p.alt का GANA द्वारा वैकल्पिक शीर्ष-स्तरीय डोमेन (TLD) के रूप में आधिकारिक पंजीकरण। आगामी router अपडेट .alt प्रत्यय को हटा सकती हैं, लेकिन सदस्यता कमांड में किसी बदलाव की आवश्यकता नहीं है। पोस्ट-क्वांटम क्रिप्टोग्राफी (2.10.0+): उपलब्ध है, पर डिफ़ॉल्ट नहीं है। सदस्यता फ़ीडों में हस्ताक्षर एल्गोरिदम के लिए भविष्य में विचार किया जा सकता है। ","description":"पता सदस्यता फ़ीड्स के लिए एक विस्तार, जो hostname (होस्ट का नाम) धारकों को अपनी प्रविष्टियों को अद्यतन और प्रबंधित करने में सक्षम बनाता है","id":"fa3cedda5fbeac90d0dcf029a44ee945","section":"docs","title":"पता सदस्यता फ़ीड कमांड्स","url":"/hi/docs/specs/subscription/"},{"categories":null,"content":" 1. अवलोकन I2P में ट्रांसपोर्ट routers के बीच प्रत्यक्ष, बिंदु-से-बिंदु संचार की एक विधि है। ये तंत्र router प्रमाणीकरण का सत्यापन करते हुए गोपनीयता और अखंडता सुनिश्चित करते हैं।\nप्रत्येक ट्रांसपोर्ट ऐसे कनेक्शन प्रतिमानों का उपयोग करके संचालित होता है, जिनमें प्रमाणीकरण, प्रवाह नियंत्रण, पुष्टिकरण, और पुनःप्रेषण क्षमताएँ शामिल होती हैं।\n2. वर्तमान ट्रांसपोर्ट्स I2P वर्तमान में दो प्रमुख transports (परिवहन प्रोटोकॉल) का समर्थन करता है:\nTransport Protocol Description NTCP2 TCP Noise-based TCP transport with modern encryption (as of 0.9.36) SSU2 UDP Secure Semireliable UDP with modern encryption (as of 0.9.56) ### 2.1 लेगेसी ट्रांसपोर्ट (अप्रचलित) Transport Protocol Status NTCP TCP Replaced by NTCP2; removed in 0.9.62 SSU UDP Replaced by SSU2; removed in 0.9.62 --- 3. ट्रांसपोर्ट सेवाएँ परिवहन उप-प्रणाली निम्नलिखित सेवाएँ प्रदान करती है:\n3.1 संदेश वितरण विश्वसनीय I2NP संदेश वितरण (ट्रांसपोर्ट्स I2NP मैसेजिंग को विशेष रूप से संभालते हैं) क्रमानुसार वितरण सार्वभौमिक रूप से सुनिश्चित नहीं है प्राथमिकता-आधारित संदेश कतारबद्धता 3.2 कनेक्शन प्रबंधन कनेक्शन की स्थापना और समापन थ्रेशहोल्ड प्रवर्तन के साथ कनेक्शन सीमा प्रबंधन प्रति-पीयर स्थिति ट्रैकिंग स्वचालित और मैनुअल पीयर बैन सूची का प्रवर्तन 3.3 नेटवर्क कॉन्फ़िगरेशन प्रति ट्रांसपोर्ट कई router पते (v0.9.8 से IPv4 और IPv6 का समर्थन) UPnP फ़ायरवॉल पोर्ट खोलना NAT/फ़ायरवॉल traversal (मार्ग-पारगमन) समर्थन कई तरीकों के माध्यम से स्थानीय IP का पता लगाना 3.4 सुरक्षा बिंदु-से-बिंदु आदान-प्रदान के लिए एन्क्रिप्शन स्थानीय नियमों के अनुसार IP पता सत्यापन घड़ी सहमति निर्धारण (NTP बैकअप) 3.5 बैंडविड्थ प्रबंधन इनबाउंड और आउटबाउंड बैंडविड्थ सीमाएँ आउटगोइंग संदेशों के लिए इष्टतम ट्रांसपोर्ट चयन 4. ट्रांसपोर्ट पते उपप्रणाली router संपर्क बिंदुओं की सूची बनाए रखती है:\nट्रांसपोर्ट विधि (NTCP2, SSU2) IP पता पोर्ट नंबर वैकल्पिक पैरामीटर प्रति ट्रांसपोर्ट विधि कई पते संभव हैं।\n4.1 सामान्य पता विन्यास Configuration Description Hidden Routers with no published addresses Firewalled Routers publishing SSU2 addresses with \"introducer\" peer lists for NAT traversal Unrestricted Routers advertising both NTCP2 and SSU2 addresses on IPv4 and/or IPv6 --- 5. ट्रांसपोर्ट चयन सिस्टम I2NP संदेश के लिए transports (परिवहन प्रोटोकॉल) का चयन उच्च-स्तरीय प्रोटोकॉलों से स्वतंत्र रूप से करता है। चयन एक बोली प्रणाली का उपयोग करता है, जहाँ प्रत्येक transport बोलियाँ प्रस्तुत करता है, और सबसे कम मूल्य वाली बोली जीतती है।\n5.1 बोली निर्धारण के कारक ट्रांसपोर्ट वरीयता सेटिंग्स मौजूदा पीयर कनेक्शन वर्तमान बनाम सीमा कनेक्शन संख्या हालिया कनेक्शन प्रयास इतिहास संदेश आकार प्रतिबंध पीयर RouterInfo (राउटर की जानकारी) की ट्रांसपोर्ट क्षमताएँ कनेक्शन की प्रत्यक्षता (प्रत्यक्ष बनाम introducer (परिचयक) पर निर्भर) पीयर द्वारा घोषित ट्रांसपोर्ट वरीयताएँ आम तौर पर, दो routers एक साथ एकल ट्रांसपोर्ट कनेक्शन बनाए रखते हैं, हालाँकि एक साथ बहु-ट्रांसपोर्ट कनेक्शन भी संभव हैं।\n6. NTCP2 NTCP2 (New Transport Protocol 2) I2P के लिए आधुनिक TCP-आधारित ट्रांसपोर्ट है, जिसे संस्करण 0.9.36 में पेश किया गया था।\n6.1 मुख्य विशेषताएँ Noise Protocol Framework (क्रिप्टोग्राफ़िक हैंडशेक फ्रेमवर्क) (Noise_XK pattern) पर आधारित कुंजी विनिमय के लिए X25519 (एलिप्टिक-कर्व एल्गोरिद्म) का उपयोग करता है प्रमाणित कूटलेखन के लिए ChaCha20/Poly1305 (AEAD योजना) का उपयोग करता है हैशिंग के लिए BLAKE2s (हैश फ़ंक्शन) का उपयोग करता है DPI (Deep Packet Inspection, गहरी पैकेट जाँच) का प्रतिरोध करने के लिए प्रोटोकॉल obfuscation (अस्पष्टकरण) ट्रैफ़िक विश्लेषण प्रतिरोध के लिए वैकल्पिक padding (भरण) 6.2 कनेक्शन स्थापना सत्र अनुरोध (Alice → Bob): अस्थायी X25519 कुंजी + एन्क्रिप्टेड पेलोड सत्र बनाया गया (Bob → Alice): अस्थायी कुंजी + एन्क्रिप्टेड पुष्टिकरण सत्र की पुष्टि (Alice → Bob): RouterInfo (router की जानकारी) के साथ अंतिम हैंडशेक इसके बाद का सारा डेटा हैंडशेक से व्युत्पन्न सेशन कुंजियों से एन्क्रिप्ट किया जाता है।\nपूर्ण विवरण के लिए NTCP2 विनिर्देश देखें।\n7. SSU2 SSU2 (Secure Semireliable UDP 2) I2P के लिए आधुनिक UDP-आधारित ट्रांसपोर्ट है, जिसका परिचय संस्करण 0.9.56 में कराया गया था।\n7.1 मुख्य विशेषताएँ Noise Protocol Framework (Noise_XK pattern) पर आधारित कुंजी विनिमय के लिए X25519 का उपयोग करता है प्रमाणित एन्क्रिप्शन के लिए ChaCha20/Poly1305 का उपयोग करता है selective acknowledgments (चयनात्मक स्वीकृतियाँ) के साथ आंशिक रूप से विश्वसनीय वितरण hole punching और relay/introduction के माध्यम से NAT traversal (NAT पारगमन) कनेक्शन माइग्रेशन का समर्थन Path MTU discovery (पथ MTU खोज) 7.2 SSU (पुराना) पर लाभ Feature SSU (Legacy) SSU2 Encryption ElGamal + AES X25519 + ChaCha20/Poly1305 Header encryption Partial Full (ChaCha20) Connection ID Fixed Encrypted, rotatable NAT traversal Basic introduction Enhanced hole punching + relay Obfuscation Minimal Improved (variable padding) विस्तृत जानकारी के लिए [SSU2 Specification](/docs/specs/ssu2/) देखें। 8. NAT Traversal (NAT के पीछे स्थित डिवाइस/सेवा तक पहुँचने की तकनीक) दोनों ट्रांसपोर्ट्स NAT traversal (NAT के पार संचार स्थापित करने की तकनीक) का समर्थन करते हैं, ताकि फायरवॉल के पीछे मौजूद routers नेटवर्क में भाग ले सकें।\n8.1 SSU2 परिचय जब कोई router सीधे इनबाउंड कनेक्शनों को प्राप्त नहीं कर सकता:\nRouter अपने RouterInfo में introducer (संपर्क-मध्यस्थ) पते प्रकाशित करता है कनेक्ट होने वाला पीयर introducer को एक परिचय अनुरोध भेजता है Introducer फ़ायरवॉल के पीछे वाले router को कनेक्शन जानकारी अग्रेषित करता है फ़ायरवॉल के पीछे वाला router आउटबाउंड कनेक्शन आरंभ करता है (hole punch — NAT के जरिए रास्ता बनाना) प्रत्यक्ष संचार स्थापित हो जाता है 8.2 NTCP2 और फ़ायरवॉल NTCP2 को इनबाउंड TCP कनेक्टिविटी की आवश्यकता होती है। NAT (नेटवर्क एड्रेस ट्रांसलेशन) के पीछे के router यह कर सकते हैं:\nपोर्ट्स को स्वचालित रूप से खोलने के लिए UPnP का उपयोग करें पोर्ट फ़ॉरवर्डिंग को मैन्युअल रूप से कॉन्फ़िगर करें आने वाले कनेक्शनों के लिए SSU2 पर निर्भर करें, जबकि जाने वाले कनेक्शनों के लिए NTCP2 का उपयोग करें 9. प्रोटोकॉल अस्पष्टिकरण दोनों आधुनिक ट्रांसपोर्ट्स में obfuscation (ट्रैफ़िक को पहचानना कठिन बनाने की तकनीक) विशेषताएँ शामिल हैं:\nयादृच्छिक पैडिंग हैंडशेक संदेशों में एन्क्रिप्टेड हेडर जो प्रोटोकॉल सिग्नेचर उजागर नहीं करते परिवर्तनीय-लंबाई संदेश ट्रैफ़िक विश्लेषण का प्रतिरोध करने के लिए कोई स्थिर पैटर्न नहीं कनेक्शन स्थापना में नोट: Transport-layer obfuscation (परिवहन-स्तर पर अस्पष्टता) I2P के tunnel आर्किटेक्चर द्वारा प्रदान की गई गुमनामी का पूरक है, लेकिन उसका प्रतिस्थापन नहीं है।\n10. भविष्य का विकास योजनाबद्ध अनुसंधान और सुधारों में शामिल हैं:\nPluggable transports (प्लग-इन आधारित ट्रांसपोर्ट तकनीक) – Tor-संगत ट्रैफिक-छलावरण प्लगइन्स QUIC-based transport – QUIC प्रोटोकॉल के लाभों की जांच Connection limit optimization – इष्टतम पीयर कनेक्शन सीमाओं पर शोध Enhanced padding strategies – ट्रैफिक विश्लेषण के प्रति प्रतिरोध में सुधार 11. संदर्भ NTCP2 विनिर्देश – Noise-आधारित TCP परिवहन SSU2 विनिर्देश – सुरक्षित अर्ध-विश्वसनीय UDP 2 I2NP विनिर्देश – I2P नेटवर्क प्रोटोकॉल संदेश सामान्य संरचनाएँ – RouterInfo और पते की संरचनाएँ ऐतिहासिक NTCP चर्चा – लेगेसी परिवहन के विकास का इतिहास लेगेसी SSU प्रलेखन – मूल SSU विनिर्देश (अप्रचलित) ","description":"I2P की परिवहन परत को समझना - routers के बीच बिंदु-से-बिंदु संचार के तरीके, NTCP2 और SSU2 सहित","id":"5fbac972dc212081634c49c5e6ac0004","section":"docs","title":"परिवहन परत","url":"/hi/docs/overview/transport/"},{"categories":null,"content":"एक्सेस फ़िल्टर I2PTunnel सर्वर ऑपरेटरों को स्रोत Destination (I2P की पहचान) और हाल की कनेक्शन दर के आधार पर आने वाले कनेक्शनों को अनुमति देने, अस्वीकार करने, या गति-सीमित करने में सक्षम बनाते हैं। फ़िल्टर नियमों की एक सादा-पाठ फ़ाइल है। फ़ाइल को ऊपर से नीचे तक पढ़ा जाता है और पहला मेल खाने वाला नियम लागू होता है।\nफ़िल्टर की परिभाषा में परिवर्तन tunnel को पुनः आरंभ करने पर प्रभावी होते हैं। कुछ बिल्ड रनटाइम के दौरान फ़ाइल-आधारित सूचियों को दोबारा पढ़ सकते हैं, लेकिन परिवर्तनों के लागू होने की गारंटी के लिए पुनः आरंभ की योजना रखें।\nफ़ाइल प्रारूप प्रत्येक पंक्ति में एक नियम। रिक्त पंक्तियों को अनदेखा किया जाता है। # एक टिप्पणी शुरू करता है, जो पंक्ति के अंत तक चलती है। नियम क्रम में मूल्यांकित किए जाते हैं; पहला मिलान ही लागू होता है। सीमा मान एक सीमा यह निर्धारित करती है कि स्लाइडिंग समय-विंडो में किसी एक Destination (I2P में विशिष्ट एंडपॉइंट पहचानकर्ता) से कितने कनेक्शन प्रयासों की अनुमति है।\nसंख्यात्मक: N/S का अर्थ है प्रति S सेकंड N कनेक्शन की अनुमति देना। उदाहरण: 15/5 हर 5 सेकंड में अधिकतम 15 कनेक्शन की अनुमति देता है। window (समय-खिड़की) के भीतर N+1वाँ प्रयास अस्वीकार कर दिया जाता है। कुंजीशब्द: allow का अर्थ है कोई सीमा नहीं। deny का अर्थ है हमेशा अस्वीकार करना। नियम सिंटैक्स नियम निम्नलिखित रूप लेते हैं:\n\u0026lt;threshold\u0026gt; \u0026lt;scope\u0026gt; \u0026lt;target\u0026gt; जहाँ:\n\u0026lt;threshold\u0026gt; N/S, allow या deny है \u0026lt;scope\u0026gt; default, explicit, file, या record में से एक है (नीचे देखें) \u0026lt;target\u0026gt; स्कोप पर निर्भर करता है डिफ़ॉल्ट नियम यह तब लागू होता है जब कोई अन्य नियम मेल नहीं खाता। केवल एक डिफ़ॉल्ट नियम की अनुमति है। यदि इसे निर्दिष्ट न किया जाए, तो अज्ञात Destinations (I2P में गंतव्य पहचान) बिना किसी प्रतिबंध के अनुमत हैं।\n15/5 default allow default deny default स्पष्ट नियम Base32 पता (उदाहरण के लिए example1.b32.i2p) या पूर्ण कुंजी के माध्यम से किसी विशिष्ट Destination (I2P में गंतव्य पहचान) को लक्षित करता है।\n15/5 explicit example1.b32.i2p deny explicit example2.b32.i2p allow explicit example3.b32.i2p फ़ाइल-आधारित नियम एक बाहरी फ़ाइल में सूचीबद्ध सभी Destinations (I2P पता/एंडपॉइंट) को लक्षित करता है। प्रत्येक पंक्ति में एक Destination होता है; # टिप्पणियाँ और खाली पंक्तियाँ अनुमत हैं।\n15/5 file /var/i2p/throttled.txt deny file /var/i2p/blocked.txt allow file /var/i2p/trusted.txt संचालन संबंधी नोट: कुछ कार्यान्वयन समय-समय पर फाइल सूचियों को फिर से पढ़ते हैं। यदि आप tunnel के चलने के दौरान किसी सूची को संपादित करते हैं, तो बदलावों का पता चलने से पहले थोड़ी देरी की अपेक्षा करें। तुरंत लागू करने के लिए पुनः आरंभ करें।\nरिकॉर्डर (प्रगतिशील नियंत्रण) एक रिकॉर्डर कनेक्शन प्रयासों की निगरानी करता है और जो Destinations (I2P का पता/पहचान) किसी सीमा का उल्लंघन करते हैं, उन्हें एक फ़ाइल में लिखता है। इसके बाद आप उस फ़ाइल को file नियम में संदर्भित करके भविष्य के प्रयासों पर गति-सीमाएँ या ब्लॉक लागू कर सकते हैं।\n# Start permissive allow default # Record Destinations exceeding 30 connections in 5 seconds 30/5 record /var/i2p/aggressive.txt # Apply throttling to recorded Destinations 15/5 file /var/i2p/aggressive.txt उस पर निर्भर होने से पहले अपने बिल्ड में recorder (रिकॉर्डर) समर्थन की पुष्टि करें। सुनिश्चित व्यवहार के लिए file सूचियों का उपयोग करें।\nमूल्यांकन क्रम विशिष्ट नियम पहले रखें, फिर सामान्य नियम। एक सामान्य पैटर्न:\nविश्वसनीय पीयर्स के लिए स्पष्ट अनुमति ज्ञात दुरुपयोगकर्ताओं के लिए स्पष्ट निषेध फ़ाइल-आधारित अनुमति/अस्वीकृति सूचियाँ प्रगतिशील थ्रॉटलिंग हेतु रिकॉर्डर डिफ़ॉल्ट नियम एक सर्वग्राही के रूप में पूर्ण उदाहरण # Moderate limits by default 30/10 default # Always allow trusted peers allow explicit friend1.b32.i2p allow explicit friend2.b32.i2p # Block known bad actors deny file /var/i2p/blocklist.txt # Throttle aggressive sources 15/5 file /var/i2p/throttle.txt # Automatically populate the throttle list 60/5 record /var/i2p/throttle.txt कार्यान्वयन संबंधी नोट्स एक्सेस फ़िल्टर tunnel लेयर (I2P में डेटा मार्ग) पर, एप्लिकेशन हैंडलिंग से पहले कार्य करता है, ताकि दुरुपयोगी ट्रैफ़िक को शुरुआती चरण में ही अस्वीकार किया जा सके। फ़िल्टर फ़ाइल को अपनी I2PTunnel (I2P का tunnel प्रबंधन टूल) कॉन्फ़िगरेशन डायरेक्टरी में रखें और परिवर्तन लागू करने के लिए tunnel को पुनः आरंभ करें। यदि आप सेवाओं में एकसमान नीति चाहते हैं, तो कई tunnels में फ़ाइल-आधारित सूचियों को साझा करें। ","description":"tunnel access-control फ़िल्टर फ़ाइलों का वाक्यविन्यास","id":"d8b5745531fca07ea47765403a9a4d0c","section":"docs","title":"पहुँच फ़िल्टर प्रारूप","url":"/hi/docs/specs/filter-format/"},{"categories":null,"content":" लेगेसी स्थिति: यह सामग्री केवल ऐतिहासिक संदर्भ के लिए संरक्षित है। यह I2P 0.6.1.10 से पहले जारी किए गए tunnel प्रणाली का दस्तावेज़ीकरण करती है और इसे आधुनिक विकास के लिए उपयोग नहीं किया जाना चाहिए। उत्पादन संबंधी मार्गदर्शन के लिए वर्तमान कार्यान्वयन देखें।\nमूल tunnel सबसिस्टम ने भी एकदिशीय tunnels का उपयोग किया, लेकिन संदेश लेआउट, डुप्लिकेट का पता लगाने, और बिल्ड रणनीति में भिन्न था। नीचे के कई अनुभाग तुलना में सहायता के लिए अप्रचलित दस्तावेज़ की संरचना को प्रतिबिंबित करते हैं।\n1. Tunnel का अवलोकन Tunnels निर्माता द्वारा चुने गए समकक्षों के क्रमबद्ध अनुक्रम के रूप में बनाए जाते थे। Tunnel की लंबाई 0–7 hops (मध्यवर्ती नोड्स की संख्या) के बीच होती थी, और padding, throttling, तथा chaff generation (भ्रामक ट्रैफिक उत्पन्न करना) के लिए कई नियंत्रण विकल्प उपलब्ध थे। Inbound tunnels अविश्वसनीय गेटवे से संदेशों को निर्माता (endpoint) तक पहुँचाते थे; outbound tunnels डेटा को निर्माता से दूर भेजते थे। Tunnel का जीवनकाल 10 मिनट था, जिसके बाद नए tunnels बनाए जाते थे (अक्सर वही समकक्ष उपयोग किए जाते थे, पर अलग tunnel IDs)। 2. पुराने डिज़ाइन में संचालन 2.1 संदेश पूर्वप्रसंस्करण गेटवे ने ≤32 KB का I2NP पेलोड एकत्र किया, पैडिंग चुनी, और ऐसा पेलोड तैयार किया जिसमें शामिल था:\nदो-बाइट का पैडिंग-लंबाई फ़ील्ड और उतने ही यादृच्छिक बाइट्स डिलीवरी लक्ष्यों, fragmentation (खंडन), और वैकल्पिक विलंबों का वर्णन करने वाले {instructions, I2NP message} युग्मों का एक अनुक्रम पूर्ण I2NP संदेश 16-बाइट सीमा तक पैड किए गए डिलीवरी निर्देश रूटिंग जानकारी को बिट फ़ील्ड्स में पैक करते थे (डिलीवरी प्रकार, डिले फ़्लैग, फ्रैगमेंटेशन फ़्लैग, और वैकल्पिक एक्सटेंशन्स)। खंडित संदेशों में 4-बाइट का संदेश ID और एक इंडेक्स/लास्ट-फ्रैगमेंट फ़्लैग होता था।\n2.2 गेटवे एन्क्रिप्शन पुराने डिज़ाइन ने एन्क्रिप्शन चरण के लिए tunnel की लंबाई आठ hops (मध्यवर्ती नोड) पर निश्चित कर दी थी। गेटवे ने AES-256/CBC के साथ checksum ब्लॉक्स की परतें जोड़ीं, ताकि प्रत्येक hop payload (संदेश का वास्तविक डेटा) को घटाए बिना अखंडता सत्यापित कर सके। स्वयं checksum संदेश के भीतर समाहित एक SHA-256 से व्युत्पन्न ब्लॉक था।\n2.3 प्रतिभागियों का व्यवहार प्रतिभागियों ने इनबाउंड tunnel आईडी पर नज़र रखी, आरंभ में ही अखंडता सत्यापित की, और अग्रेषित करने से पहले डुप्लिकेट को त्याग दिया। क्योंकि पैडिंग और सत्यापन ब्लॉक एंबेड किए गए थे, हॉप संख्या की परवाह किए बिना संदेश का आकार स्थिर रहा।\n2.4 एंडपॉइंट प्रसंस्करण एंडपॉइंट्स ने परतदार ब्लॉक्स को क्रमवार डिक्रिप्ट किया, चेकसम सत्यापित किए, और payload (डेटा का मुख्य भाग) को दोबारा एन्कोडेड निर्देशों तथा I2NP संदेशों में विभाजित किया ताकि आगे प्रेषण किया जा सके।\n3. Tunnel निर्माण (अप्रचलित प्रक्रिया) पीयर चयन: पीयर स्थानीय रूप से अनुरक्षित प्रोफाइल (अन्वेषणात्मक बनाम क्लाइंट) से चुने गए। मूल दस्तावेज़ ने प्रति tunnel पूल क्रमबद्ध पीयर सूचियों का पुन: उपयोग करके predecessor attack के शमन पर पहले ही जोर दिया था। अनुरोध वितरण: बिल्ड संदेशों को हॉप-बाय-हॉप (प्रत्येक हॉप पर) अग्रेषित किया जाता था, जिनमें प्रत्येक पीयर के लिए कूटबद्ध खंड होते थे। वैकल्पिक विचार, जैसे टेलिस्कोपिक एक्सटेंशन (क्रमिक विस्तार), मिडस्ट्रीम रीरूटिंग (बीच के मार्ग में पुनः मार्ग निर्धारण), या चेकसम ब्लॉक्स हटाना, प्रयोग रूप में चर्चा किए गए थे, पर कभी अपनाए नहीं गए। पूलिंग: प्रत्येक स्थानीय डेस्टिनेशन के पास अलग-अलग इनबाउंड और आउटबाउंड पूल थे। सेटिंग्स में वांछित मात्रा, backup tunnels, लंबाई में परिवर्तनशीलता, थ्रॉटलिंग, और पैडिंग नीतियाँ शामिल थीं। 4. थ्रॉटलिंग और मिक्सिंग की अवधारणाएँ पुराने लेख ने कई रणनीतियाँ प्रस्तावित कीं, जिन्होंने बाद की रिलीज़ों को मार्गदर्शन दिया:\nभीड़ नियंत्रण के लिए Weighted Random Early Discard (WRED) हाल के उपयोग के चल औसत के आधार पर प्रति-tunnel दर-सीमाएँ वैकल्पिक chaff (आवरण ट्रैफ़िक) और बैचिंग नियंत्रण (पूरी तरह लागू नहीं) 5. संग्रहीत विकल्प मूल दस्तावेज़ के कुछ अनुभागों ने उन विचारों का अन्वेषण किया जो कभी कार्यान्वित नहीं किए गए:\nप्रति-हॉप प्रसंस्करण घटाने के लिए checksum blocks हटाना पीयर संरचना बदलने हेतु मध्य-पथ में telescoping (क्रमिक-विस्तार) tunnels करना द्विदिश tunnels पर स्विच करना (आखिरकार अस्वीकार किया गया) छोटे हैश या अलग padding विधियों का उपयोग करना ये विचार ऐतिहासिक संदर्भ के रूप में अब भी मूल्यवान हैं, लेकिन आधुनिक कोडबेस को प्रतिबिंबित नहीं करते।\nसंदर्भ मूल लेगेसी दस्तावेज़ अभिलेखागार (0.6.1.10 से पहले) Tunnel अवलोकन वर्तमान शब्दावली के लिए पीयर प्रोफाइलिंग और चयन आधुनिक ह्यूरिस्टिक्स (अनुभवजन्य नियम) के लिए ","description":"I2P 0.6.1.10 से पहले उपयोग किए जाने वाले tunnel डिज़ाइन का संग्रहीत विवरण।","id":"0970f5387a965fe6857e4afbb03bdc8f","section":"docs","title":"पुराना Tunnel कार्यान्वयन (लेगेसी)","url":"/hi/docs/legacy/old-implementation/"},{"categories":null,"content":" स्थिति: I2P 2.10.0 (अक्टूबर 2025) तक अपडेट किया गया। यह सूची I2P Java Router, i2pd, और संबंधित प्लगइन्स द्वारा उपयोग किए जाने वाले सभी सक्रिय, पदावनत, और आरक्षित पोर्ट्स को समेकित करती है। स्थिरता के लिए सभी पोर्ट्स संख्यात्मक क्रम में सूचीबद्ध हैं।\nPort Service / Component Description Notes 123SNTPNetwork time synchronizationUses external NTP servers; required for accurate LeaseSet timestamps. 2827BOB interfaceLegacy client API bridgeDeprecated; disabled by default. 4444HTTP ProxyStandard web proxy for eepsite browsingDefault for both HTTP and HTTPS browser traffic. 4445HTTPS ProxyDedicated SSL/TLS proxyOptional; often redundant with 4444. 6667–6669IRC ProxyAccess to I2P IRC networksDefault = 6668; alternate ports avoid conflicts. 7650I2PControl PluginJSON‑RPC management APIAuth required; default password itoopie. 7652UPnP HTTP eventsUPnP control interfaceSupports automatic port forwarding. 7653UPnP SSDP responsesUPnP discoveryUDP response listener for device search. 7654I2CPCore application APIUsed by Java apps and i2pd for router integration. 7655SAM DatagramUDP bridge for SAM APISAM v3 support for real‑time apps. 7656SAM StreamTCP bridge for SAM APIPrimary non‑Java application interface. 7657Router Console (HTTP)Web admin interfaceLoopback‑only by default (127.0.0.1). 7658EepsiteDefault web server for I2PTunnelUsed for locally hosted services. 7659SMTP ProxyOutgoing mail via I2P‑BoteBridges standard email clients. 7660POP3 ProxyIncoming mail via I2P‑BoteServerless email retrieval. 7661I2PBote SMTP / Pebble BlogPlugin dual‑use portRarely conflicts since plugins don’t co‑install. 7662I2PBote IMAP / Zzzot TrackerPlugin dual‑use portUsed by Zzzot for BitTorrent tracking. 7663—Reserved for future pluginsUnused as of 2.10.0. 7664JAMWiki PluginWiki platform for I2P sitesOptional plugin. 7667Router Console (HTTPS)Secure web admin interfaceSelf‑signed cert by default. 7672Railroad PluginPlugin port reservationLast documented plugin port in series. 7644Browser Mode ProxyHTTP proxy for I2P Browser BundleUsed when running Browser mode alongside router. 7647Browser Mode ConsoleRouter console for I2P Browser BundleAvoids conflict with 7657. 8002I2PSnark Web UI (HTTP)BitTorrent client UIIntegrated in router console. 8003I2PSnark Web UI (HTTPS)BitTorrent client UI (SSL)Optional secure mode. 8887Router Network Port (Legacy)Old default for peer connectionsReplaced by randomized 9151–30777 range. 8118Privoxy (Reserved)External web proxy integrationNot part of core I2P; reserved for compatibility. 8123Polipo (Reserved)Alternate proxy integrationLegacy Tor proxy compatibility. 8888Freenet (Reserved)Anonymous network portPrevents conflicts on privacy nodes. 9050–9053Tor SOCKS (Reserved)Tor proxy range for co‑installationAvoids conflicts with I2P. 9150–9153Tor Browser SOCKS (Reserved)Tor Browser integrationReserved for cross‑tool coexistence. 9151–30777Router Network Port (Random)Active TCP/UDP transport portRandomized per install for anti‑fingerprinting. 1488 / 1776XD BitTorrent ClientStandalone I2P torrent clientAlternate to I2PSnark. 31000–32000Java Service WrapperRouter process managementHandles service control and restart. 3456 / 3458 / 3459Tahoe‑LAFS PluginDecentralized file storageOptional third‑party plugin. 4691 / 8997–8999Monotone Version ControlDistributed VCS supportHistorical usage for developer tools. 7070i2pd ConsoleWeb console for C++ implementationEquivalent to Java router console. 767xPlugin Range (General)Recommended port block for pluginsDevelopers start from 7672 upward. 11371SKS/GPG Key Server (Reserved)Key distribution serviceUsed for PGP/GPG over I2P. ## कार्यान्वयन नोट्स सुरक्षा के लिए 9000 से नीचे के सभी ports (8887 को छोड़कर) डिफ़ॉल्ट रूप से 127.0.0.1 से bind होते हैं। पूर्ण भागीदारी के लिए router network port (9151–30777) इंटरनेट के लिए खुला होना चाहिए। i2pd संगतता के लिए ज्यादातर समान असाइनमेंट का उपयोग करता है (7070 console, 7654 I2CP, 7656/7655 SAM)। Plugin developers को टकराव से बचने के लिए I2P community के माध्यम से नए असाइनमेंट का समन्वय करना चाहिए। ","description":"I2P पोर्ट असाइनमेंट, प्लगइन पोर्ट्स और आरक्षित रेंज का व्यापक संदर्भ।","id":"69ea4623f7bc59ab65ef7ea636966780","section":"docs","title":"पोर्ट असाइनमेंट","url":"/hi/docs/overview/ports/"},{"categories":null,"content":"I2P नेटवर्क प्रदर्शन: गति, कनेक्शन और संसाधन प्रबंधन I2P नेटवर्क पूरी तरह से गतिशील है। प्रत्येक क्लाइंट अन्य नोड्स के लिए जाना जाता है और स्थानीय रूप से ज्ञात नोड्स की पहुंच और क्षमता का परीक्षण करता है। केवल पहुंच योग्य और सक्षम नोड्स को स्थानीय NetDB में सहेजा जाता है। tunnel निर्माण प्रक्रिया के दौरान, इस पूल से सर्वोत्तम संसाधनों का चयन tunnels बनाने के लिए किया जाता है। क्योंकि परीक्षण लगातार होता रहता है, नोड्स का पूल बदलता रहता है। प्रत्येक I2P नोड NetDB के एक अलग हिस्से को जानता है, जिसका अर्थ है कि प्रत्येक router के पास tunnels के लिए उपयोग किए जाने वाले I2P नोड्स का एक अलग सेट होता है। भले ही दो routers के पास ज्ञात नोड्स का एक ही सबसेट हो, पहुंच और क्षमता के परीक्षण संभवतः अलग-अलग परिणाम दिखाएंगे, क्योंकि जब एक router परीक्षण कर रहा हो तो अन्य routers लोड के अधीन हो सकते हैं, लेकिन जब दूसरा router परीक्षण करे तो वे मुक्त हो सकते हैं।\nयह वर्णन करता है कि प्रत्येक I2P नोड के पास tunnels बनाने के लिए अलग-अलग नोड क्यों होते हैं। क्योंकि हर I2P नोड की latency और bandwidth अलग होती है, tunnels (जो उन नोड्स के माध्यम से बनाए जाते हैं) की latency और bandwidth values अलग-अलग होती हैं। और क्योंकि हर I2P नोड के पास अलग-अलग tunnels बनाए जाते हैं, किन्हीं भी दो I2P नोड्स के पास समान tunnel sets नहीं होते हैं।\nएक सर्वर/क्लाइंट को \u0026ldquo;destination\u0026rdquo; के रूप में जाना जाता है और प्रत्येक destination में कम से कम एक inbound और एक outbound tunnel होता है। डिफ़ॉल्ट रूप से प्रति tunnel 3 hops होते हैं। यह एक पूर्ण राउंड ट्रिप client → server → client के लिए कुल 12 hops (12 विभिन्न I2P nodes) बनता है।\nप्रत्येक डेटा पैकेज को 6 अन्य I2P nodes के माध्यम से भेजा जाता है जब तक कि वह सर्वर तक नहीं पहुँच जाता:\nclient - hop1 - hop2 - hop3 - hopa1 - hopa2 - hopa3 - server\nऔर वापसी के रास्ते में 6 अलग-अलग I2P nodes:\nserver - hopb1 - hopb2 - hopb3 - hopc1 - hopc2 - hopc3 - client\nनेटवर्क पर ट्रैफिक को नया डेटा भेजने से पहले ACK की आवश्यकता होती है; इसे तब तक इंतजार करना पड़ता है जब तक सर्वर से ACK वापस नहीं आता: डेटा भेजें, ACK का इंतजार करें, अधिक डेटा भेजें, ACK का इंतजार करें। चूंकि RTT (Round Trip Time) प्रत्येक व्यक्तिगत I2P node की latency और इस round trip पर प्रत्येक connection से जुड़ता है, इसलिए आमतौर पर client को ACK वापस आने में 1–3 सेकंड का समय लगता है। TCP और I2P transport डिज़ाइन के कारण, एक data package का आकार सीमित होता है। साथ में ये स्थितियाँ प्रति tunnel अधिकतम bandwidth की सीमा लगभग 20–50 kB/s निर्धारित करती हैं। हालाँकि, यदि tunnel में केवल एक hop के पास खर्च करने के लिए केवल 5 kB/s bandwidth है, तो पूरी tunnel 5 kB/s तक सीमित है, latency और अन्य सीमाओं से स्वतंत्र।\nएन्क्रिप्शन, लेटेंसी, और tunnel कैसे बनाया जाता है, यह CPU time के लिहाज से काफी महंगा होता है। इसीलिए एक destination को डेटा ट्रांसपोर्ट करने के लिए अधिकतम 6 inbound और 6 outbound tunnels रखने की अनुमति है। प्रति tunnel अधिकतम 50 kB/s की रफ़्तार से, एक destination लगभग 300 kB/s ट्रैफ़िक (संयुक्त रूप से) उपयोग कर सकता है (वास्तव में यह अधिक हो सकता है यदि कम या बिना anonymity के छोटे tunnels उपयोग किए जाएं)। उपयोग किए गए tunnels हर 10 मिनट में discard कर दिए जाते हैं और नए बनाए जाते हैं। tunnels का यह बदलाव, और कभी-कभी clients जो shutdown हो जाते हैं या network से अपना connection खो देते हैं, कभी-कभी tunnels और connections को तोड़ देंगे। इसका एक उदाहरण IRC2P Network पर connection के नुकसान (ping timeout) में या eepget उपयोग करते समय देखा जा सकता है।\nसीमित गंतव्यों के एक सेट और प्रति गंतव्य सीमित tunnels के साथ, एक I2P नोड केवल अन्य I2P नोड्स के पार tunnels के एक सीमित सेट का उपयोग करता है। उदाहरण के लिए, यदि कोई I2P नोड उपरोक्त छोटे उदाहरण में \u0026ldquo;hop1\u0026rdquo; है, तो यह केवल क्लाइंट से उत्पन्न होने वाली एक participating tunnel देखता है। यदि हम पूरे I2P नेटवर्क का योग करें, तो केवल सीमित मात्रा में bandwidth के साथ एक सीमित संख्या में participating tunnels बनाई जा सकती हैं। यदि कोई इन सीमित संख्याओं को I2P नोड्स की संख्या में वितरित करता है, तो उपयोग के लिए केवल उपलब्ध bandwidth/क्षमता का एक अंश उपलब्ध होता है।\nगुमनाम बने रहने के लिए, पूरे नेटवर्क द्वारा tunnels बनाने के लिए एक router का उपयोग नहीं किया जाना चाहिए। यदि एक router सभी I2P nodes के लिए tunnel router के रूप में कार्य करता है, तो यह विफलता का एक वास्तविक केंद्रीय बिंदु बन जाता है और साथ ही clients से IPs और data एकत्र करने का एक केंद्रीय बिंदु भी बन जाता है। यही कारण है कि नेटवर्क tunnel building प्रक्रिया में nodes के बीच ट्रैफिक वितरित करता है।\nप्रदर्शन के लिए एक और विचार वह तरीका है जिससे I2P mesh networking को संभालता है। प्रत्येक कनेक्शन hop-to-hop I2P nodes पर एक TCP या UDP कनेक्शन का उपयोग करता है। 1000 कनेक्शन के साथ, कोई 1000 TCP कनेक्शन देखता है। यह काफी अधिक है, और कुछ घरेलू और छोटे कार्यालय के routers केवल सीमित संख्या में कनेक्शन की अनुमति देते हैं। I2P इन कनेक्शन को प्रति UDP और प्रति TCP प्रकार 1500 से कम रखने का प्रयास करता है। यह एक I2P node के माध्यम से route किए जाने वाले ट्रैफ़िक की मात्रा को भी सीमित करता है।\nयदि कोई नोड reachable है, और उसकी bandwidth सेटिंग \u0026gt;128 kB/s shared है और वह 24/7 reachable है, तो कुछ समय बाद उसे participating traffic के लिए उपयोग किया जाना चाहिए। यदि बीच में यह down हो जाता है, तो अन्य नोड्स द्वारा किए गए I2P नोड की testing उन्हें बता देगी कि यह reachable नहीं है। यह अन्य नोड्स पर कम से कम 24 घंटों के लिए एक नोड को block कर देता है। इसलिए, वे अन्य नोड्स जिन्होंने उस नोड को down के रूप में test किया था, वे 24 घंटों तक tunnels बनाने के लिए उस नोड का उपयोग नहीं करेंगे। यही कारण है कि आपके I2P router के restart/shutdown के बाद कम से कम 24 घंटों के लिए आपका traffic कम हो जाता है।\nइसके अतिरिक्त, अन्य I2P nodes को किसी I2P router को reachability और capacity के लिए परीक्षण करने के लिए उसे जानना आवश्यक है। यह प्रक्रिया तेज हो सकती है जब आप network के साथ interact करते हैं, उदाहरण के लिए applications का उपयोग करके या I2P sites पर जाकर, जिसके परिणामस्वरूप अधिक tunnel building होगी और इसलिए network पर nodes द्वारा परीक्षण के लिए अधिक activity और reachability होगी।\nप्रदर्शन इतिहास (चयनित) वर्षों में, I2P में कई उल्लेखनीय प्रदर्शन सुधार देखे गए हैं:\nNative math GNU MP लाइब्रेरी (GMP) के JNI बाइंडिंग्स के माध्यम से लागू किया गया है ताकि BigInteger modPow को तेज़ किया जा सके, जो पहले CPU समय पर हावी था। प्रारंभिक परिणामों ने public‑key cryptography में नाटकीय गति वृद्धि दिखाई। देखें: /misc/jbigi/\nGarlic wrapping a \u0026ldquo;reply\u0026rdquo; LeaseSet (tuned) पहले, जवाबों में अक्सर प्रेषक के LeaseSet के लिए network database lookup की आवश्यकता होती थी। प्रारंभिक garlic में प्रेषक के LeaseSet को बंडल करने से जवाब की latency में सुधार होता है। अब यह चयनात्मक रूप से किया जाता है (कनेक्शन की शुरुआत में या जब LeaseSet बदलता है) ताकि overhead को कम किया जा सके।\nनेटिव गणित ट्रांसपोर्ट हैंडशेक में कुछ सत्यापन चरणों को पहले स्थानांतरित किया गया है ताकि खराब peers को जल्द अस्वीकार किया जा सके (गलत clocks, खराब NAT/firewall, असंगत संस्करण), जिससे CPU और bandwidth की बचत होती है।\nगार्लिक रैपिंग एक \u0026ldquo;reply\u0026rdquo; LeaseSet (tuned) संदर्भ-जागरूक टनल परीक्षण का उपयोग करें: उन tunnels का परीक्षण करने से बचें जो पहले से ही डेटा पास कर रहे हैं; निष्क्रिय होने पर परीक्षण को प्राथमिकता दें। यह ओवरहेड को कम करता है और विफल tunnels का पता लगाने में तेजी लाता है।\nअधिक कुशल TCP अस्वीकरण किसी दिए गए कनेक्शन के लिए चयनों को बनाए रखना out-of-order delivery को कम करता है और streaming library को window sizes बढ़ाने की अनुमति देता है, जिससे throughput में सुधार होता है।\nटनल परीक्षण समायोजन GZip या समान तकनीक verbose structures (जैसे, RouterInfo options) के लिए bandwidth को कम करती है जहाँ उपयुक्त हो।\nस्थायी टनल/lease चयन सरलीकृत \u0026ldquo;ministreaming\u0026rdquo; प्रोटोकॉल का प्रतिस्थापन। आधुनिक streaming में चयनात्मक ACKs और I2P के अनाम, संदेश-उन्मुख सब्सट्रेट के लिए अनुकूलित congestion control शामिल है। देखें: /docs/api/streaming/\nFuture Performance Improvements (historical ideas) नीचे दिए गए विचार ऐतिहासिक रूप से संभावित सुधारों के रूप में प्रलेखित किए गए हैं। कई पुराने हो चुके हैं, लागू किए जा चुके हैं, या आर्किटेक्चरल परिवर्तनों द्वारा प्रतिस्थापित किए जा चुके हैं।\nचयनित डेटा संरचनाओं को संपीड़ित करें टनल निर्माण के लिए राउटर किस प्रकार peers का चुनाव करते हैं, इसमें सुधार करें ताकि धीमे या अधिक भार वाले peers से बचा जा सके, जबकि शक्तिशाली विरोधियों द्वारा Sybil attacks के प्रति प्रतिरोधी बने रहें।\nपूर्ण स्ट्रीमिंग प्रोटोकॉल जब keyspace स्थिर हो तो अनावश्यक exploration को कम करें; lookups में कितने peers return किए जाते हैं और कितनी concurrent searches की जाती हैं, इसे tune करें।\nSession Tag tuning and improvements (legacy) लीगेसी ElGamal/AES+SessionTag स्कीम के लिए, स्मार्ट एक्सपायरेशन और रिप्लेनिशमेंट स्ट्रैटेजी ElGamal फॉलबैक और बर्बाद टैग्स को कम करती हैं।\nबेहतर पीयर प्रोफाइलिंग और चयन नए सेशन स्थापना के दौरान सीडेड सिंक्रोनाइज़्ड PRNG से टैग जेनरेट करें, जो पहले से डिलीवर किए गए टैग से प्रति‑संदेश ओवरहेड को कम करता है।\nनेटवर्क डेटाबेस ट्यूनिंग लंबे tunnel लाइफटाइम को healing के साथ मिलाने से rebuild ओवरहेड कम हो सकते हैं; इसे anonymity और reliability के साथ संतुलित करें।\nसत्र टैग ट्यूनिंग और सुधार (लीगेसी) अमान्य peers को पहले अस्वीकार करें और tunnel परीक्षणों को अधिक context‑aware बनाएं ताकि contention और latency कम हो सके।\nSessionTag को synchronized PRNG में माइग्रेट करें (legacy) Selective LeaseSet bundling, compressed RouterInfo विकल्प, और पूर्ण streaming प्रोटोकॉल को अपनाने से बेहतर अनुभूत प्रदर्शन में योगदान मिलता है।\nमानक I2P टनल का उपयोग करते हुए IRC\nयह गाइड बताती है कि कैसे standard I2P tunnels का उपयोग करके IRC से कनेक्ट करें।\nआवश्यकताएं एक चालू I2P router एक IRC client (जैसे HexChat, Irssi, WeeChat) सेटअप अपना I2P router शुरू करें और सुनिश्चित करें कि यह चल रहा है I2P router console में जाएं (आमतौर पर http://127.0.0.1:7657) \u0026ldquo;I2PTunnel\u0026rdquo; section में जाएं पहले से configured IRC tunnels की तलाश करें या एक नया बनाएं IRC tunnel बनाना यदि आपके पास पहले से IRC tunnel नहीं है:\nI2PTunnel configuration page में \u0026ldquo;Add New Client Tunnel\u0026rdquo; पर क्लिक करें Tunnel type के रूप में \u0026ldquo;IRC Client\u0026rdquo; चुनें आवश्यक जानकारी भरें: Tunnel name (उदाहरण: \u0026ldquo;IRC\u0026rdquo;) Local port (उदाहरण: 6668) Destination (I2P IRC server का पता) Tunnel को save और start करें अपने IRC client को configure करना अपने IRC client में:\nएक नया server connection बनाएं Server address को 127.0.0.1 पर सेट करें Port को उस port पर सेट करें जो आपने I2PTunnel में configure किया है (उदाहरण: 6668) SSL/TLS को disable करें (I2P tunnel पहले से ही encrypted है) Server से कनेक्ट करें सामान्य I2P IRC servers irc.echelon.i2p - मुख्य I2P IRC network irc.dg.i2p - वैकल्पिक I2P IRC network नोट: ये .i2p addresses हैं जिन्हें आपको I2PTunnel configuration में destination के रूप में उपयोग करना चाहिए।\nसमस्या निवारण यदि आप कनेक्ट नहीं कर पा रहे हैं:\nजांचें कि आपका I2P router चल रहा है और shared clients को स्वीकार कर रहा है सत्यापित करें कि I2PTunnel चल रहा है और active है सुनिश्चित करें कि आप अपने IRC client में सही port का उपयोग कर रहे हैं I2P router logs में errors की जांच करें सुनिश्चित करें कि destination address सही है और server ऑनलाइन है यह भी देखें:\nTunnel Routing Peer Selection Transports SSU2 विनिर्देश और NTCP2 विनिर्देश ","description":"I2P नेटवर्क प्रदर्शन: आज यह कैसे व्यवहार करता है, ऐतिहासिक सुधार, और भविष्य की ट्यूनिंग के लिए विचार","id":"eb296d22dd7b2414170601d7c73a1613","section":"docs","title":"प्रदर्शन","url":"/hi/docs/overview/performance/"},{"categories":null,"content":"1. अवलोकन clients.config में एंट्रीज़ राउटर को बताती हैं कि स्टार्टअप पर कौन से एप्लिकेशन लॉन्च करने हैं। प्रत्येक एंट्री managed क्लाइंट (अधिमानित) या unmanaged क्लाइंट के रूप में चल सकती है। Managed क्लाइंट ClientAppManager के साथ सहयोग करते हैं, जो:\nएप्लिकेशन को इंस्टैंशिएट करता है और राउटर कंसोल के लिए लाइफसाइकल स्टेट को ट्रैक करता है उपयोगकर्ता को स्टार्ट/स्टॉप नियंत्रण प्रदान करता है और राउटर एग्जिट पर क्लीन शटडाउन लागू करता है एक हल्का क्लाइंट रजिस्ट्री और पोर्ट मैपर होस्ट करता है ताकि एप्लिकेशन एक-दूसरे की सेवाओं को खोज सकें Unmanaged clients बस एक main() method को invoke करते हैं; इनका उपयोग केवल legacy code के लिए करें जिसे modernize नहीं किया जा सकता।\n2. एक Managed Client को लागू करना प्रबंधित clients को या तो net.i2p.app.ClientApp (user-facing apps के लिए) या net.i2p.router.app.RouterApp (router extensions के लिए) implement करना होगा। नीचे दिए गए constructors में से एक प्रदान करें ताकि manager context और configuration arguments supply कर सके:\npublic MyClientApp(I2PAppContext context, ClientAppManager manager, String[] args) public MyRouterApp(RouterContext context, ClientAppManager manager, String[] args) args array में clients.config या clients.config.d/ में व्यक्तिगत फ़ाइलों में configured किए गए values होते हैं। default lifecycle wiring को inherit करने के लिए जब भी संभव हो ClientApp / RouterApp helper classes को extend करें।\n2.1 Lifecycle Methods प्रबंधित क्लाइंट्स से अपेक्षा की जाती है कि वे निम्नलिखित को लागू करें:\nstartup() - प्रारंभिकरण करें और तुरंत वापस लौटें। INITIALIZED स्थिति से संक्रमण के लिए कम से कम एक बार manager.notify() को कॉल करना आवश्यक है। shutdown(String[] args) - संसाधनों को मुक्त करें और बैकग्राउंड थ्रेड्स को बंद करें। स्थिति को STOPPING या STOPPED में बदलने के लिए कम से कम एक बार manager.notify() को कॉल करना आवश्यक है। getState() - कंसोल को सूचित करें कि ऐप चल रहा है, शुरू हो रहा है, बंद हो रहा है, या विफल हो गया है जब उपयोगकर्ता कंसोल के साथ इंटरैक्ट करते हैं तो manager इन methods को कॉल करता है।\n2.2 Advantages राउटर कंसोल में सटीक स्थिति रिपोर्टिंग थ्रेड्स या स्टैटिक संदर्भों को लीक किए बिना साफ पुनरारंभ एप्लिकेशन बंद होने के बाद कम मेमोरी फुटप्रिंट इंजेक्ट किए गए कॉन्टेक्स्ट के माध्यम से केंद्रीकृत लॉगिंग और त्रुटि रिपोर्टिंग 3. Unmanaged Clients (Fallback Mode) यदि कॉन्फ़िगर की गई class एक managed interface को implement नहीं करती है, तो router इसे main(String[] args) को invoke करके launch करता है और परिणामी process को track नहीं कर सकता। console सीमित जानकारी दिखाता है और shutdown hooks शायद run न हों। इस mode को उन scripts या one-off utilities के लिए आरक्षित रखें जो managed APIs को adopt नहीं कर सकतीं।\n4. Client Registry प्रबंधित और अप्रबंधित clients स्वयं को manager के साथ register कर सकते हैं ताकि अन्य components नाम से reference प्राप्त कर सकें:\nmanager.register(this); रजिस्ट्रेशन क्लाइंट के getName() रिटर्न वैल्यू को रजिस्ट्री की के रूप में उपयोग करता है। ज्ञात रजिस्ट्रेशन में console, i2ptunnel, Jetty, outproxy, और update शामिल हैं। फीचर्स को समन्वित करने के लिए ClientAppManager.getRegisteredApp(String name) के साथ एक क्लाइंट को पुनः प्राप्त करें (उदाहरण के लिए, console द्वारा Jetty से स्टेटस विवरण के लिए क्वेरी करना)।\nध्यान दें कि client registry और port mapper अलग-अलग सिस्टम हैं। client registry नाम लुकअप द्वारा इंटर-एप्लिकेशन संचार को सक्षम बनाता है, जबकि port mapper सेवा खोज के लिए सेवा नामों को host:port संयोजनों से मैप करता है।\n3. अप्रबंधित क्लाइंट्स (Fallback मोड) पोर्ट मैपर आंतरिक TCP सेवाओं के लिए एक सरल डायरेक्टरी प्रदान करता है। लूपबैक पोर्ट्स को रजिस्टर करें ताकि सहयोगी हार्डकोडेड एड्रेस से बच सकें:\ncontext.portMapper().register(PortMapper.SVC_HTTPS_PROXY, 4445); या स्पष्ट host विनिर्देश के साथ:\ncontext.portMapper().register(PortMapper.SVC_HTTP_PROXY, \u0026#34;127.0.0.1\u0026#34;, 4444); PortMapper.getPort(String name) का उपयोग करके सेवाओं को खोजें (यदि नहीं मिला तो -1 रिटर्न करता है) या getPort(String name, int defaultPort) (यदि नहीं मिला तो डिफ़ॉल्ट रिटर्न करता है)। isRegistered(String name) के साथ रजिस्ट्रेशन स्टेटस चेक करें और getActualHost(String name) के साथ रजिस्टर्ड होस्ट को रिट्रीव करें।\nnet.i2p.util.PortMapper से सामान्य पोर्ट मैपर सेवा स्थिरांक:\nSVC_CONSOLE - Router console (डिफ़ॉल्ट पोर्ट 7657) SVC_HTTP_PROXY - HTTP proxy (डिफ़ॉल्ट पोर्ट 4444) SVC_HTTPS_PROXY - HTTPS proxy (डिफ़ॉल्ट पोर्ट 4445) SVC_I2PTUNNEL - I2PTunnel मैनेजर SVC_SAM - SAM bridge (डिफ़ॉल्ट पोर्ट 7656) SVC_SAM_SSL - SAM bridge SSL SVC_SAM_UDP - SAM UDP SVC_BOB - BOB bridge (डिफ़ॉल्ट पोर्ट 2827) SVC_EEPSITE - मानक eepsite (डिफ़ॉल्ट पोर्ट 7658) SVC_HTTPS_EEPSITE - HTTPS eepsite SVC_IRC - IRC tunnel (डिफ़ॉल्ट पोर्ट 6668) SVC_SUSIDNS - SusiDNS नोट: httpclient, httpsclient, और httpbidirclient i2ptunnel tunnel प्रकार हैं (tunnel.N.type configuration में उपयोग किए जाते हैं), port mapper service constants नहीं।\n4. क्लाइंट रजिस्ट्री 2.1 लाइफसाइकिल मेथड्स संस्करण 0.9.42 से, router clients.config.d/ डायरेक्टरी के भीतर अलग-अलग फ़ाइलों में कॉन्फ़िगरेशन को विभाजित करने का समर्थन करता है। प्रत्येक फ़ाइल में एकल client के लिए properties होती हैं जिनमें सभी properties clientApp.0. के साथ prefixed होती हैं:\nclientApp.0.main=net.i2p.router.web.RouterConsoleRunner clientApp.0.name=Router Console clientApp.0.args=7657 ::1,127.0.0.1 ./webapps/ clientApp.0.delay=0 clientApp.0.onBoot=true यह नई स्थापनाओं और प्लगइन्स के लिए अनुशंसित दृष्टिकोण है।\n2.2 फायदे पिछड़े संगतता के लिए, पारंपरिक प्रारूप क्रमिक संख्यांकन का उपयोग करता है:\nclientApp.0.main=net.i2p.router.web.RouterConsoleRunner clientApp.0.name=Router Console clientApp.0.args=7657 ::1,127.0.0.1 ./webapps/ clientApp.1.main=net.i2p.apps.systray.UrlLauncher clientApp.1.name=URL Launcher clientApp.1.delay=5 6.3 Configuration Properties आवश्यक: - main - ClientApp या RouterApp को implement करने वाला पूर्ण class नाम, या static main(String[] args) युक्त\nवैकल्पिक: - name - router console के लिए प्रदर्शन नाम (class name को डिफ़ॉल्ट मानता है) - args - स्पेस या टैब से अलग किए गए तर्क (quoted strings का समर्थन करता है) - delay - शुरू होने से पहले सेकंड (डिफ़ॉल्ट 120) - onBoot - यदि true है तो delay=0 को बाध्य करता है - startOnLoad - client को सक्षम/अक्षम करता है (डिफ़ॉल्ट true)\nप्लगइन-विशिष्ट: - stopargs - शटडाउन के दौरान पास किए गए आर्गुमेंट्स - uninstallargs - प्लगइन अनइंस्टॉल के दौरान पास किए गए आर्गुमेंट्स - classpath - कॉमा से अलग किए गए अतिरिक्त classpath एंट्रीज़\nप्लगइन्स के लिए वेरिएबल प्रतिस्थापन: - $I2P - I2P बेस डायरेक्टरी - $CONFIG - यूज़र कॉन्फ़िगरेशन डायरेक्टरी (उदाहरण के लिए, ~/.i2p) - $PLUGIN - प्लगइन डायरेक्टरी - $OS - ऑपरेटिंग सिस्टम का नाम - $ARCH - आर्किटेक्चर का नाम\n5. पोर्ट मैपर प्रबंधित क्लाइंट को प्राथमिकता दें; केवल तभी अप्रबंधित का उपयोग करें जब बिल्कुल आवश्यक हो। initialization और shutdown को हल्का रखें ताकि console संचालन responsive बना रहे। वर्णनात्मक registry और port नामों का उपयोग करें ताकि diagnostic टूल (और अंतिम उपयोगकर्ता) समझ सकें कि सेवा क्या करती है। static singletons से बचें - संसाधनों को साझा करने के लिए injected context और manager पर निर्भर रहें। सटीक console स्थिति बनाए रखने के लिए सभी state transitions पर manager.notify() को कॉल करें। यदि आपको अलग JVM में चलाना आवश्यक हो, तो दस्तावेज़ीकरण करें कि logs और diagnostics को main console में कैसे प्रदर्शित किया जाता है। बाहरी प्रोग्राम के लिए, प्रबंधित क्लाइंट लाभ प्राप्त करने के लिए ShellService (संस्करण 1.7.0 में जोड़ा गया) का उपयोग करने पर विचार करें। 6. कॉन्फ़िगरेशन फॉर्मेट प्रबंधित क्लाइंट्स को संस्करण 0.9.4 (17 दिसंबर, 2012) में पेश किया गया था और संस्करण 2.10.0 (9 सितंबर, 2025) तक अनुशंसित आर्किटेक्चर बने हुए हैं। मुख्य APIs इस अवधि में शून्य ब्रेकिंग परिवर्तनों के साथ स्थिर रहे हैं:\nकंस्ट्रक्टर सिग्नेचर अपरिवर्तित लाइफसाइकल मेथड (startup, shutdown, getState) अपरिवर्तित ClientAppManager पंजीकरण मेथड अपरिवर्तित PortMapper पंजीकरण और लुकअप मेथड अपरिवर्तित उल्लेखनीय सुधार: - 0.9.42 (2019) - व्यक्तिगत कॉन्फ़िगरेशन फ़ाइलों के लिए clients.config.d/ डायरेक्टरी संरचना - 1.7.0 (2021) - बाहरी प्रोग्राम स्थिति ट्रैकिंग के लिए ShellService जोड़ा गया - 2.10.0 (2025) - वर्तमान रिलीज़ जिसमें कोई managed client API परिवर्तन नहीं\nअगले प्रमुख रिलीज़ के लिए न्यूनतम Java 17+ की आवश्यकता होगी (infrastructure requirement, API परिवर्तन नहीं)।\nReferences clients.config विनिर्देश कॉन्फ़िगरेशन फ़ाइल विनिर्देश I2P तकनीकी दस्तावेज़ सूची ClientAppManager Javadoc (API 0.9.66) PortMapper Javadoc (API 0.9.66) ClientApp interface (API 0.9.66) RouterApp interface (API 0.9.66) वैकल्पिक Javadoc (स्थिर) वैकल्पिक Javadoc (clearnet मिरर) नोट: I2P नेटवर्क http://idk.i 2p/javadoc-i2p/ पर व्यापक प्रलेखन होस्ट करता है जिसके लिए I2P router की आवश्यकता होती है। clearnet एक्सेस के लिए, ऊपर दिए गए GitHub Pages mirror का उपयोग करें।\n","description":"राउटर-प्रबंधित एप्लिकेशन ClientAppManager और पोर्ट मैपर के साथ कैसे एकीकृत होते हैं","id":"f9e2324a49e9ed9bf413b4c636d5d1b6","section":"docs","title":"प्रबंधित क्लाइंट्स (Managed Clients)","url":"/hi/docs/applications/managed-clients/"},{"categories":null,"content":"अवलोकन I2P प्लगइन्स हस्ताक्षरित आर्काइव होते हैं जो router की कार्यक्षमता का विस्तार करते हैं। ये .xpi2p या .su3 फ़ाइलों के रूप में उपलब्ध होते हैं, ~/.i2p/plugins/\u0026lt;name\u0026gt;/ (या Windows पर %APPDIR%\\I2P\\plugins\\\u0026lt;name\u0026gt;\\) में इंस्टॉल होते हैं, और sandboxing (पृथक नियंत्रित परिवेश) के बिना पूर्ण router अनुमतियों के साथ चलते हैं।\nसमर्थित प्लगइन प्रकार कंसोल वेबऐप्स नए eepsites जिनमें cgi-bin, वेबऐप्स हों कंसोल थीम्स कंसोल अनुवाद Java प्रोग्राम (इन-प्रोसेस या अलग JVM) शेल स्क्रिप्ट्स और नेटिव बाइनरीज़ सुरक्षा मॉडल गंभीर: प्लगइन्स उसी JVM (Java Virtual Machine, जावा वर्चुअल मशीन) में I2P router के समान अनुमतियों के साथ चलते हैं। उन्हें बिना किसी प्रतिबंध के इन तक पहुँच होती है:\nफ़ाइल सिस्टम (पढ़ना और लिखना) Router APIs और आंतरिक स्थिति नेटवर्क कनेक्शन्स बाहरी प्रोग्राम का निष्पादन प्लगइन्स को पूर्णतः विश्वसनीय कोड के रूप में मानना चाहिए। उपयोगकर्ताओं को स्थापना से पहले प्लगइन के स्रोतों और डिजिटल हस्ताक्षरों का सत्यापन करना अनिवार्य है।\nफ़ाइल प्रारूप SU3 प्रारूप (प्रबल रूप से अनुशंसित) स्थिति: सक्रिय, I2P 0.9.15 (सितंबर 2014) से पसंदीदा प्रारूप\n.su3 फ़ॉर्मेट निम्न प्रदान करता है: - RSA-4096 हस्ताक्षर कुंजियाँ (xpi2p में DSA-1024 की तुलना में) - हस्ताक्षर फ़ाइल हेडर में संग्रहीत होता है - मैजिक नंबर: I2Psu3 - बेहतर भविष्य-संगतता\nसंरचना:\n[SU3 Header with RSA-4096 signature] [ZIP Archive] ├── plugin.config (required) ├── console/ ├── lib/ ├── webapps/ └── [other plugin files] XPI2P प्रारूप (पुराना, अप्रचलित) स्थिति: बैकवर्ड संगतता के लिए समर्थित, नए प्लगइन्स के लिए अनुशंसित नहीं\n.xpi2p फ़ॉर्मैट पुराने क्रिप्टोग्राफिक हस्ताक्षरों का उपयोग करता है: - DSA-1024 हस्ताक्षर (NIST-800-57 के अनुसार अप्रचलित) - ZIP के आरंभ में 40-बाइट DSA हस्ताक्षर जोड़ा जाता है - plugin.config में key फ़ील्ड आवश्यक है\nसंरचना:\n[40-byte DSA signature] [16-byte version string (UTF-8, zero-padded)] [ZIP Archive] माइग्रेशन मार्ग: xpi2p से su3 में स्थानांतरण करते समय, संक्रमण के दौरान updateURL और updateURL.su3 दोनों प्रदान करें। आधुनिक routers (0.9.15+) स्वतः SU3 को प्राथमिकता देते हैं।\nआर्काइव लेआउट और plugin.config आवश्यक फ़ाइलें plugin.config - कुंजी-मूल्य युग्मों वाली मानक I2P कॉन्फ़िगरेशन फ़ाइल\nआवश्यक गुणधर्म Property Description Format nameInstallation directory name, must match for updatesAlphanumeric, no spaces signerDeveloper contact informationuser@mail.i2p format recommended versionPlugin version for update comparisonMax 16 bytes, parsed by VersionComparator keyDSA public key (172 B64 chars ending with '=')Omit for SU3 format **संस्करण फ़ॉर्मैट के उदाहरण:** - `1.2.3` - `1.2.3-4` - `2.0.0-beta.1` वैध विभाजक: . (डॉट), - (डैश), _ (अंडरस्कोर)\nवैकल्पिक मेटाडेटा गुण जानकारी प्रदर्शित करें date - जारी करने की तिथि (Java long टाइमस्टैम्प) author - डेवलपर का नाम (user@mail.i2p अनुशंसित) description - अंग्रेज़ी विवरण description_xx - स्थानीयकृत विवरण (xx = भाषा कोड) websiteURL - प्लगइन मुखपृष्ठ (http://foo.i2p/) license - लाइसेंस पहचानकर्ता (उदा., \u0026ldquo;Apache-2.0\u0026rdquo;, \u0026ldquo;GPL-3.0\u0026rdquo;) कॉन्फ़िगरेशन अद्यतन updateURL - XPI2P अपडेट स्थान (पुराना) updateURL.su3 - SU3 अपडेट स्थान (अधिमान्य) min-i2p-version - आवश्यक न्यूनतम I2P संस्करण max-i2p-version - अधिकतम संगत I2P संस्करण min-java-version - न्यूनतम Java संस्करण (उदा., 1.7, 17) min-jetty-version - न्यूनतम Jetty संस्करण (Jetty 6+ के लिए 6 उपयोग करें) max-jetty-version - अधिकतम Jetty संस्करण (Jetty 5 के लिए 5.99999 उपयोग करें) स्थापना संबंधी व्यवहार dont-start-at-install - डिफ़ॉल्ट false. यदि true है, तो मैन्युअल रूप से शुरू करना आवश्यक है router-restart-required - डिफ़ॉल्ट false. उपयोगकर्ता को सूचित करता है कि अपडेट के बाद रीस्टार्ट आवश्यक है update-only - डिफ़ॉल्ट false. यदि प्लगइन पहले से इंस्टॉल नहीं है तो विफल होता है install-only - डिफ़ॉल्ट false. यदि प्लगइन पहले से मौजूद है तो विफल होता है min-installed-version - अपडेट के लिए आवश्यक न्यूनतम संस्करण max-installed-version - अपडेट किए जा सकने वाला अधिकतम संस्करण disableStop - डिफ़ॉल्ट false. यदि true है, तो Stop बटन छुपाता है कंसोल एकीकरण consoleLinkName - कंसोल सारांश पट्टी के लिंक के लिए पाठ consoleLinkName_xx - स्थानीयकृत लिंक पाठ (xx = भाषा कोड) consoleLinkURL - लिंक का गंतव्य (उदा., /appname/index.jsp) consoleLinkTooltip - होवर टेक्स्ट (0.7.12-6 से समर्थित) consoleLinkTooltip_xx - स्थानीयकृत टूलटिप console-icon - 32x32 आइकन का पथ (0.9.20 से समर्थित) icon-code - वेब संसाधन रहित प्लगइन्स के लिए Base64-एन्कोडेड 32x32 PNG (0.9.25 से) प्लैटफ़ॉर्म आवश्यकताएँ (केवल दिखाने हेतु) required-platform-OS - ऑपरेटिंग सिस्टम की आवश्यकता (लागू नहीं किया जाता) other-requirements - अतिरिक्त आवश्यकताएँ (उदा., \u0026ldquo;Python 3.8+\u0026rdquo;) निर्भरता प्रबंधन (अभी कार्यान्वित नहीं) depends - अल्पविराम से अलग की गई प्लगइन निर्भरताएँ depends-version - निर्भरताओं के लिए संस्करण आवश्यकताएँ langs - भाषा पैक की सामग्री type - प्लगइन का प्रकार (app/theme/locale/webapp) अपडेट URL में वेरिएबल प्रतिस्थापन फ़ीचर स्थिति: I2P 1.7.0 (0.9.53) से उपलब्ध\nदोनों updateURL और updateURL.su3 प्लेटफ़ॉर्म-विशिष्ट वेरिएबल्स का समर्थन करते हैं:\nवेरिएबल्स: - $OS - ऑपरेटिंग सिस्टम: windows, linux, mac - $ARCH - आर्किटेक्चर: 386, amd64, arm64\nउदाहरण:\nupdateURL.su3=http://foo.i2p/downloads/foo-$OS-$ARCH.su3 Windows AMD64 पर परिणाम:\nhttp://foo.i2p/downloads/foo-windows-amd64.su3 यह प्लेटफ़ॉर्म-विशिष्ट बिल्ड्स के लिए एक ही plugin.config फ़ाइल का उपयोग सक्षम करता है।\nनिर्देशिका संरचना मानक लेआउट plugins/ └── pluginname/ ├── plugin.config (required) ├── console/ │ ├── locale/ # Translation JARs │ ├── themes/ # Console themes │ ├── webapps/ # Web applications │ └── webapps.config # Webapp configuration ├── eepsite/ │ ├── cgi-bin/ │ ├── docroot/ │ ├── logs/ │ ├── webapps/ │ └── jetty.xml ├── lib/ │ └── *.jar # Plugin libraries └── clients.config # Client startup configuration निर्देशिकाओं के उद्देश्य console/locale/ - I2P के आधारभूत अनुवादों के लिए संसाधन बंडल वाली JAR फ़ाइलें - प्लगइन-विशिष्ट अनुवाद console/webapps/*.war या lib/*.jar में होने चाहिए\nconsole/themes/ - प्रत्येक उपनिर्देशिका में एक पूर्ण कंसोल थीम होती है - थीम खोज पथ में स्वतः जोड़ा जाता है\nconsole/webapps/ - कंसोल एकीकरण के लिए .war फ़ाइलें - यदि webapps.config में अक्षम न किया गया हो तो स्वतः प्रारंभ हो जाती हैं - WAR का नाम प्लगइन के नाम से मेल खाना आवश्यक नहीं है\neepsite/ - अपनी स्वयं की Jetty इंस्टेंस सहित संपूर्ण eepsite - jetty.xml कॉन्फ़िगरेशन में variable substitution (चर प्रतिस्थापन) आवश्यक है - zzzot और pebble प्लगइन के उदाहरण देखें\nlib/ - प्लगइन JAR लाइब्रेरीज़ - classpath में clients.config या webapps.config के माध्यम से निर्दिष्ट करें\nवेबऐप कॉन्फ़िगरेशन webapps.config का प्रारूप मानक I2P कॉन्फ़िगरेशन फ़ाइल जो वेबऐप के व्यवहार को नियंत्रित करती है।\nसिंटैक्स:\n# Disable autostart webapps.warname.startOnLoad=false # Add classpath JARs (as of API 0.9.53, works for any warname) webapps.warname.classpath=$PLUGIN/lib/foo.jar,$I2P/lib/bar.jar महत्वपूर्ण नोट्स: - router 0.7.12-9 से पहले, अनुकूलता के लिए plugin.warname.startOnLoad का उपयोग करें - API 0.9.53 से पहले, classpath (जावा में क्लास-लोडिंग का पथ) केवल तब काम करता था जब warname, प्लगइन नाम से मेल खाता था - 0.9.53+ से, classpath किसी भी webapp (वेब अनुप्रयोग) नाम के लिए काम करता है\nवेब ऐप के लिए सर्वोत्तम प्रथाएँ ServletContextListener का कार्यान्वयन\nक्लीनअप के लिए javax.servlet.ServletContextListener को implement करें या servlet में destroy() को override करें अपडेट के दौरान और router रुकने पर सही तरीके से बंद होना सुनिश्चित करता है लाइब्रेरी प्रबंधन\nसाझा JARs को lib/ में रखें, WAR (Web Application Archive—वेब ऐप्लिकेशन आर्काइव) के अंदर नहीं webapps.config classpath (क्लासपाथ) के माध्यम से संदर्भ दें अलग से इंस्टॉल/अपडेट प्लगइन्स की सुविधा देता है परस्पर-विरोधी लाइब्रेरीज़ से बचें\nJetty, Tomcat, या servlet JARs (Java Archive फ़ाइलें) को कभी बंडल न करें मानक I2P स्थापना से JARs को कभी बंडल न करें मानक लाइब्रेरीज़ के लिए classpath (क्लास-लोडिंग पथ) सेक्शन की जाँच करें संकलन आवश्यकताएँ\n.java या .jsp स्रोत फ़ाइलें शामिल न करें स्टार्टअप विलंब से बचने के लिए सभी JSPs को पूर्व-संकलित करें Java/JSP कम्पाइलर की उपलब्धता मानकर न चलें Servlet API अनुकूलता\nI2P Servlet 3.0 का समर्थन करता है (0.9.30 से) एनोटेशन स्कैनिंग समर्थित नहीं है (@WebContent) पारंपरिक web.xml deployment descriptor (परिनियोजन विवरणक) प्रदान करना आवश्यक है Jetty संस्करण\nवर्तमान: Jetty 9 (I2P 0.9.30+) एब्स्ट्रैक्शन (अमूर्तता) के लिए net.i2p.jetty.JettyStart का उपयोग करें Jetty API में बदलावों से सुरक्षा करता है क्लाइंट कॉन्फ़िगरेशन clients.config प्रारूप प्लगइन द्वारा आरंभ किए गए क्लाइंट (सेवाएँ) को परिभाषित करता है।\nमूलभूत क्लाइंट:\nclientApp.0.main=com.example.PluginMain clientApp.0.name=Example Plugin Service clientApp.0.delay=30 clientApp.0.args=arg1 arg2 $PLUGIN/config.properties Stop/Uninstall के साथ क्लाइंट:\nclientApp.0.stopargs=stop clientApp.0.uninstallargs=uninstall clientApp.0.classpath=$PLUGIN/lib/plugin.jar,$I2P/lib/i2p.jar प्रॉपर्टी संदर्भ Property Description mainFully qualified class name implementing ClientApp interface nameDisplay name for user interface delayStartup delay in seconds (default: 0) argsSpace-separated arguments passed to constructor stopargsArguments for shutdown (must handle gracefully) uninstallargsArguments called before plugin deletion classpathComma-separated JAR paths ### चर प्रतिस्थापन निम्नलिखित चर args, stopargs, uninstallargs, और classpath में प्रतिस्थापित किए जाते हैं:\nVariable Replacement $I2PI2P base installation directory $CONFIGI2P configuration directory (typically ~/.i2p) $PLUGINThis plugin's directory ($CONFIG/plugins/name) $OSOperating system: windows, linux, mac $ARCHArchitecture: 386, amd64, arm64 ### प्रबंधित बनाम अप्रबंधित क्लाइंट्स प्रबंधित क्लाइंट्स (अनुशंसित, 0.9.4 से): - ClientAppManager द्वारा इंस्टैंशिएट किया जाता है - रेफरेंस और स्टेट ट्रैकिंग बनाए रखता है - लाइफसाइकल प्रबंधन अधिक सरल - बेहतर मेमोरी प्रबंधन\nअप्रबंधित क्लाइंट्स: - router द्वारा शुरू किए जाते हैं, स्थिति का ट्रैक नहीं रखा जाता - कई प्रारंभ/रोक कॉल्स को सुचारू रूप से संभालना चाहिए - समन्वय के लिए स्थैतिक स्थिति या PID फ़ाइलें (प्रक्रिया आईडी फ़ाइलें) उपयोग करें - router के शटडाउन पर कॉल किया जाता है (संस्करण 0.7.12-3 से)\nShellService (0.9.53 / 1.7.0 से) बाहरी प्रोग्राम चलाने के लिए स्वचालित state (स्थिति) ट्रैकिंग के साथ एक सामान्यीकृत समाधान।\nविशेषताएँ: - प्रक्रिया के जीवनचक्र को संभालता है - ClientAppManager के साथ संचार करता है - स्वचालित PID प्रबंधन - क्रॉस-प्लेटफ़ॉर्म समर्थन\nउपयोग:\nclientApp.0.main=net.i2p.apps.ShellService clientApp.0.args=$PLUGIN/bin/myservice.sh प्लेटफ़ॉर्म-विशिष्ट स्क्रिप्ट्स के लिए:\nclientApp.0.args=$PLUGIN/bin/myservice-$OS.$ARCH वैकल्पिक (लेगेसी): OS प्रकार की जाँच करने वाला Java रैपर लिखें, उपयुक्त .bat या .sh फ़ाइल के साथ ShellCommand को कॉल करें।\nस्थापना प्रक्रिया उपयोगकर्ता स्थापना प्रक्रिया उपयोगकर्ता Router Console Plugin Configuration Page (/configplugins) पर प्लगइन URL पेस्ट करता है Router प्लगइन फ़ाइल डाउनलोड करता है हस्ताक्षर सत्यापन (यदि कुंजी अज्ञात हो और strict mode (कड़ा मोड) सक्षम हो, तो विफल) ZIP अखंडता जाँच plugin.config को निकालना और पार्स करना संस्करण संगतता सत्यापन (min-i2p-version, min-java-version, आदि) webapp (वेब अनुप्रयोग) नाम टकराव का पता लगाना अपडेट होने पर मौजूदा प्लगइन को रोकना डायरेक्टरी सत्यापन (यह plugins/ के अधीन होना चाहिए) सभी फ़ाइलें प्लगइन डायरेक्टरी में निकालना plugins.config को अद्यतन करना प्लगइन प्रारंभ करना (जब तक dont-start-at-install=true न हो) सुरक्षा और विश्वास कुंजी प्रबंधन: - नए हस्ताक्षरकर्ताओं के लिए First-key-seen trust model (पहली बार देखी गई कुंजी पर आधारित भरोसे का मॉडल) - केवल jrandom और zzz कुंजियाँ पूर्व-पैकेज्ड हैं - 0.9.14.1 से, अज्ञात कुंजियाँ डिफ़ॉल्ट रूप से अस्वीकार की जाती हैं - Advanced property (उन्नत सेटिंग) विकास के लिए ओवरराइड कर सकती है\nस्थापना प्रतिबंध: - आर्काइव्स को केवल प्लगइन निर्देशिका में ही अनपैक होना चाहिए - इंस्टॉलर plugins/ के बाहर के पथों को अस्वीकार करता है - स्थापना के बाद प्लगइन्स अन्य स्थानों पर फ़ाइलों तक पहुँच सकते हैं - कोई sandboxing (सीमित, नियंत्रित वातावरण में चलाना) या विशेषाधिकार पृथक्करण नहीं\nअद्यतन तंत्र अपडेट जांच प्रक्रिया Router plugin.config से updateURL.su3 (प्राथमिक) या updateURL पढ़ता है बाइट्स 41-56 प्राप्त करने के लिए HTTP HEAD या आंशिक GET अनुरोध रिमोट फ़ाइल से संस्करण स्ट्रिंग निकालें VersionComparator का उपयोग करके इंस्टॉल किए गए संस्करण से तुलना करें यदि नया हो, तो उपयोगकर्ता को प्रॉम्प्ट करें या ऑटो-डाउनलोड करें (सेटिंग्स के आधार पर) प्लगइन बंद करें अपडेट इंस्टॉल करें प्लगइन शुरू करें (जब तक उपयोगकर्ता की प्राथमिकता बदली न हो) संस्करणों की तुलना संस्करणों को डॉट/डैश/अंडरस्कोर से अलग घटकों के रूप में पार्स किया जाता है: - 1.2.3 \u0026lt; 1.2.4 - 1.2.3 \u0026lt; 1.2.3-1 - 2.0.0 \u0026gt; 1.9.9\nअधिकतम लंबाई: 16 बाइट (SUD/SU3 हेडर से मेल खाना चाहिए)\nअपडेट करने की सर्वोत्तम प्रथाएँ रिलीज़ के लिए हमेशा संस्करण बढ़ाएँ पिछले संस्करण से अपडेट पथ का परीक्षण करें बड़े बदलावों के लिए router-restart-required पर विचार करें माइग्रेशन (स्थानांतरण) के दौरान updateURL और updateURL.su3 दोनों प्रदान करें परीक्षण के लिए बिल्ड नंबर प्रत्यय का उपयोग करें (1.2.3-456) Classpath (क्लास फ़ाइलों के खोज-पथ) और मानक लाइब्रेरियाँ Classpath (Java में कक्षाओं और संसाधनों का खोज-पथ) में हमेशा उपलब्ध $I2P/lib की निम्नलिखित JAR फ़ाइलें I2P 0.9.30+ के लिए हमेशा classpath (क्लासपाथ) में होती हैं:\nJAR Contents Plugin Usage i2p.jarCore APIRequired for all plugins mstreaming.jarStreaming APIMost plugins need streaming.jarStreaming implementationMost plugins need i2ptunnel.jarI2PTunnelHTTP/server plugins router.jarRouter internalsRarely needed, avoid if possible javax.servlet.jarServlet 3.1, JSP 2.3 APIPlugins with servlets/JSPs jasper-runtime.jarJasper compiler/runtimePlugins with JSPs commons-el.jarEL 3.0 APIJSPs using expression language jetty-i2p.jarJetty utilitiesPlugins starting Jetty org.mortbay.jetty.jarJetty 9 baseCustom Jetty instances sam.jarSAM APIRarely needed addressbook.jarSubscription/blockfileUse NamingService instead routerconsole.jarConsole librariesNot public API, avoid jbigi.jarNative cryptoPlugins should not need systray.jarURL launcherRarely needed wrapper.jarService wrapperPlugins should not need ### विशेष टिप्पणियाँ commons-logging.jar: - 0.9.30 से खाली - 0.9.30 से पहले: Apache Tomcat JULI - 0.9.24 से पहले: Commons Logging + JULI - 0.9 से पहले: केवल Commons Logging\njasper-compiler.jar: - Jetty 6 (0.9) से खाली\nsystray4j.jar: - 0.9.26 में हटाया गया\nClasspath में नहीं है (निर्दिष्ट करना आवश्यक है) JAR Contents Usage jstl.jarStandard TaglibJSP tag libraries standard.jarStandard TaglibJSP tag libraries ### क्लासपाथ विनिर्देश clients.config में:\nclientApp.0.classpath=$PLUGIN/lib/mylib.jar,$I2P/lib/i2p.jar webapps.config में:\nwebapps.mywebapp.classpath=$PLUGIN/lib/mylib.jar,$I2P/lib/jstl.jar महत्वपूर्ण: संस्करण 0.7.13-3 से, classpaths (क्लास खोज पथ) थ्रेड-विशिष्ट हैं, JVM-व्यापी नहीं। प्रत्येक क्लाइंट के लिए पूर्ण classpath निर्दिष्ट करें।\nजावा संस्करण आवश्यकताएँ वर्तमान आवश्यकताएँ (अक्टूबर 2025) I2P 2.10.0 और उससे पहले: - न्यूनतम: Java 7 (0.9.24 से आवश्यक, जनवरी 2016) - अनुशंसित: Java 8 या उससे अधिक\nI2P 2.11.0 और उसके बाद (आगामी): - न्यूनतम: Java 17+ (2.9.0 रिलीज़ नोट्स में घोषित) - दो रिलीज़ पहले चेतावनी दी गई (2.9.0 → 2.10.0 → 2.11.0)\nप्लगइन अनुकूलता रणनीति अधिकतम संगतता के लिए (I2P 2.10.x तक):\n\u0026lt;javac source=\u0026#34;1.7\u0026#34; target=\u0026#34;1.7\u0026#34; /\u0026gt; min-java-version=1.7 Java 8+ विशेषताओं के लिए:\n\u0026lt;javac source=\u0026#34;1.8\u0026#34; target=\u0026#34;1.8\u0026#34; /\u0026gt; min-java-version=1.8 Java 11+ विशेषताओं के लिए:\n\u0026lt;javac source=\u0026#34;11\u0026#34; target=\u0026#34;11\u0026#34; /\u0026gt; min-java-version=11 2.11.0+ के लिए तैयारी:\n\u0026lt;javac source=\u0026#34;17\u0026#34; target=\u0026#34;17\u0026#34; /\u0026gt; min-java-version=17 min-i2p-version=2.11.0 संकलन के लिए सर्वोत्तम प्रथाएँ नए JDK का उपयोग करते हुए पुराने टार्गेट के लिए कम्पाइल करते समय:\n\u0026lt;javac source=\u0026#34;1.7\u0026#34; target=\u0026#34;1.7\u0026#34; bootclasspath=\u0026#34;${java7.home}/jre/lib/rt.jar\u0026#34; includeantruntime=\u0026#34;false\u0026#34; /\u0026gt; यह उन APIs के उपयोग को रोकता है जो लक्षित Java संस्करण में उपलब्ध नहीं हैं।\nPack200 संपीड़न - अप्रचलित महत्वपूर्ण अद्यतन: Pack200 (Java का JAR पैकिंग/संपीड़न प्रारूप) का उपयोग न करें स्थिति: अप्रचलित और हटा दिया गया\nमूल विनिर्देश ने 60-65% आकार में कमी के लिए Pack200 compression (Pack200 संपीड़न फ़ॉर्मेट) की दृढ़ता से अनुशंसा की थी। यह अब मान्य नहीं है।\nसमयरेखा: - JEP 336: Pack200 को Java 11 में deprecated (अप्रचलित) घोषित किया गया (सितंबर 2018) - JEP 367: Pack200 को Java 14 में हटा दिया गया (मार्च 2020)\nआधिकारिक I2P अपडेट्स स्पेसिफिकेशन में कहा गया है: \u0026gt; \u0026ldquo;zip में मौजूद Jar और war फ़ाइलें अब pack200 से संपीड़ित नहीं की जातीं, जैसा कि ऊपर \u0026lsquo;su2\u0026rsquo; फ़ाइलों के लिए प्रलेखित है, क्योंकि हाल के Java रनटाइम्स अब इसका समर्थन नहीं करते।\u0026rdquo;\nक्या करें:\nबिल्ड प्रक्रियाओं से pack200 को तुरंत हटाएँ मानक ZIP संपीड़न का उपयोग करें विकल्पों पर विचार करें: कोड को छोटा करने के लिए ProGuard/R8 नेटिव बाइनरी के लिए UPX यदि कस्टम अनपैकर उपलब्ध कराया जाए तो आधुनिक संपीड़न एल्गोरिदम (zstd, brotli) मौजूदा प्लगइन्स के लिए: - पुराने routers (0.7.11-5 से लेकर Java 10 तक) अभी भी pack200 अनपैक कर सकते हैं - नए routers (Java 11+) pack200 को अनपैक नहीं कर सकते - pack200 compression के बिना प्लगइन्स को पुनः जारी करें\nहस्ताक्षर कुंजियाँ और सुरक्षा कुंजी निर्माण (SU3 फॉर्मेट) i2p.scripts रिपॉजिटरी से makeplugin.sh स्क्रिप्ट का उपयोग करें:\n# Generate new signing key ./makeplugin.sh keygen # Keys stored in ~/.i2p-plugin-keys/ मुख्य विवरण: - एल्गोरिदम: RSA_SHA512_4096 - प्रारूप: X.509 प्रमाणपत्र - संग्रहण: Java keystore प्रारूप\nप्लगइन्स पर हस्ताक्षर # Create signed su3 file ./makeplugin.sh sign myplugin.zip myplugin.su3 keyname # Verify signature ./makeplugin.sh verify myplugin.su3 कुंजी प्रबंधन की सर्वोत्तम प्रथाएँ एक बार उत्पन्न करें, सदा सुरक्षित रखें\nRouters भिन्न कुंजियों के साथ डुप्लिकेट कुंजी-नामों को अस्वीकार करते हैं Routers भिन्न कुंजी-नामों के साथ डुप्लिकेट कुंजियों को अस्वीकार करते हैं कुंजी/नाम मेल न खाने पर अपडेट अस्वीकार किए जाते हैं सुरक्षित संग्रहण\nkeystore (कुंजी-संग्रह) का सुरक्षित बैकअप लें मजबूत पासफ़्रेज़ का उपयोग करें कभी भी version control में commit न करें कुंजी रोटेशन\nवर्तमान आर्किटेक्चर में समर्थित नहीं दीर्घकालिक कुंजी उपयोग की योजना बनाएँ टीम विकास के लिए multi-signature (बहु-हस्ताक्षर) योजनाओं पर विचार करें विरासत DSA हस्ताक्षर (XPI2P) स्थिति: कार्यक्षम लेकिन अप्रचलित\nxpi2p फ़ॉर्मेट द्वारा उपयोग किए गए DSA-1024 हस्ताक्षर: - 40-बाइट हस्ताक्षर - 172 base64 वर्णों वाली सार्वजनिक कुंजी - NIST-800-57 न्यूनतम (L=2048, N=224) की अनुशंसा करता है - I2P इससे कमजोर (L=1024, N=160) का उपयोग करता है\nअनुशंसा: इसके बजाय SU3 (साइन किया हुआ पैकेज फ़ॉर्मेट) को RSA-4096 (4096-बिट RSA) के साथ उपयोग करें।\nप्लगइन विकास दिशानिर्देश आवश्यक सर्वोत्तम प्रथाएँ दस्तावेज़ीकरण\nस्थापना निर्देशों के साथ स्पष्ट README प्रदान करें कॉन्फ़िगरेशन विकल्पों और डिफ़ॉल्ट मानों का दस्तावेज़ीकरण करें प्रत्येक रिलीज़ के साथ changelog (परिवर्तन लॉग) शामिल करें आवश्यक I2P/Java संस्करण निर्दिष्ट करें आकार अनुकूलन\nसिर्फ़ आवश्यक फ़ाइलें शामिल करें router JARs को कभी बंडल न करें इंस्टॉल बनाम अपडेट पैकेज अलग रखें (लाइब्रेरियाँ lib/ में) Pack200 compression (Java का Pack200 संपीड़न फ़ॉर्मैट) का उपयोग करें अप्रचलित - मानक ZIP का उपयोग करें कॉन्फ़िगरेशन\nरनटाइम के दौरान plugin.config को कभी संशोधित न करें रनटाइम सेटिंग्स के लिए अलग कॉन्फ़िगरेशन फ़ाइल का उपयोग करें आवश्यक router सेटिंग्स का प्रलेखन करें (SAM पोर्ट्स, tunnels, आदि) उपयोगकर्ता की मौजूदा कॉन्फ़िगरेशन का सम्मान करें संसाधनों का उपयोग\nडिफ़ॉल्ट बैंडविड्थ की आक्रामक खपत से बचें CPU उपयोग की उचित सीमाएँ लागू करें शटडाउन के समय संसाधनों को मुक्त करें जहाँ उपयुक्त हो, daemon threads (बैकग्राउंड थ्रेड, जो प्रक्रिया के बंद होते ही स्वतः समाप्त हो जाते हैं) का उपयोग करें परीक्षण\nसभी प्लेटफ़ॉर्म्स पर इंस्टॉल/अपग्रेड/अनइंस्टॉल का परीक्षण करें पिछले संस्करण से अपडेट्स का परीक्षण करें अपडेट्स के दौरान वेबऐप का रुकना/पुनरारंभ सत्यापित करें न्यूनतम समर्थित I2P संस्करण के साथ परीक्षण करें फ़ाइल सिस्टम\nकभी भी $I2P में न लिखें (यह केवल-पढ़ने योग्य हो सकता है) रनटाइम डेटा $PLUGIN या $CONFIG में लिखें डायरेक्टरी खोज के लिए I2PAppContext का उपयोग करें $CWD के स्थान के बारे में कोई अनुमान न लगाएँ संगतता\nमानक I2P क्लासों को डुप्लिकेट न करें आवश्यक होने पर क्लासों का विस्तार करें, प्रतिस्थापित न करें plugin.config में min-i2p-version, min-jetty-version जाँचें यदि आप उनका समर्थन करते हैं, तो पुराने I2P संस्करणों के साथ परीक्षण करें शटडाउन हैंडलिंग\nclients.config में उचित stopargs लागू करें शटडाउन हुक्स पंजीकृत करें: I2PAppContext.addShutdownTask() कई start/stop कॉलों को सुगमता से संभालें सभी थ्रेड्स को daemon mode (बैकग्राउंड मोड; ऐसे थ्रेड जो JVM को बंद होने से नहीं रोकते) में सेट करें सुरक्षा\nसभी बाहरी इनपुट का सत्यापन करें System.exit() को कभी कॉल न करें उपयोगकर्ता की गोपनीयता का सम्मान करें सुरक्षित कोडिंग प्रथाओं का पालन करें लाइसेंसिंग\nप्लगइन लाइसेंस को स्पष्ट रूप से निर्दिष्ट करें बंडल की गई लाइब्रेरियों के लाइसेंस का सम्मान करें आवश्यक श्रेय शामिल करें आवश्यक होने पर स्रोत कोड तक पहुँच उपलब्ध कराएँ उन्नत विचारणाएँ समय-क्षेत्र प्रबंधन: - Router JVM का समय-क्षेत्र UTC पर सेट करता है - उपयोगकर्ता का वास्तविक समय-क्षेत्र: I2PAppContext प्रॉपर्टी i2p.systemTimeZone\nनिर्देशिका खोज:\n// Plugin directory String pluginDir = I2PAppContext.getGlobalContext() .getAppDir().getAbsolutePath() + \u0026#34;/plugins/\u0026#34; + pluginName; // Or use $PLUGIN variable in clients.config args संस्करण क्रमांकन: - semantic versioning (अर्थ-आधारित संस्करण निर्धारण) का उपयोग करें (major.minor.patch) - परीक्षण के लिए build number जोड़ें (1.2.3-456) - अपडेट्स के लिए monotonic (केवल बढ़ती/गैर-घटती) वृद्धि सुनिश्चित करें\nRouter क्लास एक्सेस:\nसामान्यतः router.jar पर निर्भरता से बचें इसके बजाय i2p.jar में मौजूद public APIs का उपयोग करें भविष्य में I2P संभवतः router क्लास एक्सेस को सीमित कर सकता है JVM क्रैश रोकथाम (ऐतिहासिक): - 0.7.13-3 में ठीक किया गया - class loaders (क्लास लोडर्स) का सही उपयोग करें - चल रहे प्लगइन में JARs (JAR फ़ाइलें) को अपडेट करने से बचें - आवश्यकता होने पर restart-on-update (अपडेट पर पुनरारंभ) के लिए डिज़ाइन करें\nEepsite प्लगइन्स अवलोकन प्लगइन्स अपने Jetty (Java वेब सर्वर) और I2PTunnel इंस्टेंस के साथ पूर्ण eepsites प्रदान कर सकते हैं।\nवास्तुकला इनका प्रयास न करें: - मौजूदा eepsite में स्थापित करना - router के डिफ़ॉल्ट eepsite के साथ मर्ज करना - केवल एक eepsite उपलब्ध मान लेना\nइसके बजाय: - नया I2PTunnel इंस्टेंस प्रारंभ करें (CLI (कमांड-लाइन इंटरफेस) के माध्यम से) - नया Jetty इंस्टेंस प्रारंभ करें - clients.config में दोनों को कॉन्फ़िगर करें\nउदाहरण संरचना plugins/myeepsite/ ├── plugin.config ├── clients.config # Starts Jetty + I2PTunnel ├── eepsite/ │ ├── jetty.xml # Requires variable substitution │ ├── docroot/ │ ├── webapps/ │ └── logs/ └── lib/ └── [dependencies] jetty.xml में वेरिएबल प्रतिस्थापन पथों के लिए $PLUGIN चर का उपयोग करें:\n\u0026lt;Set name=\u0026#34;resourceBase\u0026#34;\u0026gt;$PLUGIN/eepsite/docroot\u0026lt;/Set\u0026gt; Router प्लगइन के प्रारंभ के दौरान प्रतिस्थापन करता है.\nउदाहरण संदर्भ कार्यान्वयन: - zzzot प्लगइन - टॉरेंट ट्रैकर - pebble प्लगइन - ब्लॉग प्लेटफ़ॉर्म\nदोनों zzz के प्लगइन पृष्ठ (I2P-internal) पर उपलब्ध हैं।\nकंसोल एकीकरण सारांश पट्टी के लिंक router कंसोल सारांश पट्टी में क्लिक करने योग्य लिंक जोड़ें:\nconsoleLinkName=My Plugin consoleLinkURL=/myplugin/ consoleLinkTooltip=Open My Plugin Interface स्थानीयकृत संस्करण:\nconsoleLinkName_de=Mein Plugin consoleLinkTooltip_de=Öffne Mein Plugin Schnittstelle कंसोल आइकन इमेज फ़ाइल (0.9.20 से):\nconsole-icon=/myicon.png यदि निर्दिष्ट किया गया हो तो consoleLinkURL के सापेक्ष पथ (0.9.53 से), अन्यथा वेबऐप नाम के सापेक्ष।\nएम्बेडेड आइकन (0.9.25 से):\nicon-code=iVBORw0KGgoAAAANSUhEUgAAA...Base64EncodedPNG... इससे जनरेट करें:\nbase64 -w 0 icon-32x32.png या Java:\njava -cp i2p.jar net.i2p.data.Base64 encode icon.png आवश्यकताएँ:\n32x32 पिक्सेल PNG प्रारूप Base64 एन्कोडेड (कोई लाइन ब्रेक नहीं) अंतर्राष्ट्रीयकरण अनुवाद पैकेज I2P बेस अनुवादों के लिए: - JAR फ़ाइलें console/locale/ में रखें - मौजूदा I2P एप्स के लिए resource bundles (संसाधन बंडल) शामिल हों - नामकरण: messages_xx.properties (xx = भाषा कोड)\nप्लगइन-विशिष्ट अनुवादों के लिए: - console/webapps/*.war में शामिल करें - या lib/*.jar में शामिल करें - मानक Java ResourceBundle पद्धति का उपयोग करें\nplugin.config में स्थानीयकृत स्ट्रिंग्स description=My awesome plugin description_de=Mein tolles Plugin description_fr=Mon plugin génial description_es=Mi plugin increíble समर्थित फ़ील्ड: - description_xx - consoleLinkName_xx - consoleLinkTooltip_xx\nकंसोल थीम अनुवाद console/themes/ में मौजूद थीमें स्वतः थीम खोज पथ में जोड़ दी जाती हैं.\nप्लेटफ़ॉर्म-विशिष्ट प्लगइन्स पृथक पैकेज दृष्टिकोण प्रत्येक प्लेटफ़ॉर्म के लिए अलग-अलग प्लगइन नाम उपयोग करें:\n# Windows package name=myplugin-windows # Linux package name=myplugin-linux # macOS package name=myplugin-mac चर प्रतिस्थापन दृष्टिकोण प्लेटफ़ॉर्म वेरिएबल्स के साथ एक plugin.config:\nname=myplugin updateURL.su3=http://myplugin.i2p/downloads/myplugin-$OS-$ARCH.su3 clients.config में:\nclientApp.0.main=net.i2p.apps.ShellService clientApp.0.args=$PLUGIN/bin/myapp-$OS-$ARCH रनटाइम पर OS की पहचान शर्त-आधारित निष्पादन के लिए Java का दृष्टिकोण:\nString os = System.getProperty(\u0026#34;os.name\u0026#34;).toLowerCase(); if (os.contains(\u0026#34;win\u0026#34;)) { // Windows-specific code } else if (os.contains(\u0026#34;nix\u0026#34;) || os.contains(\u0026#34;nux\u0026#34;)) { // Linux-specific code } else if (os.contains(\u0026#34;mac\u0026#34;)) { // macOS-specific code } समस्या निवारण सामान्य समस्याएँ प्लगइन शुरू नहीं हो रहा: 1. I2P संस्करण संगतता जाँचें (min-i2p-version) 2. Java संस्करण सत्यापित करें (min-java-version) 3. त्रुटियों के लिए router लॉग जाँचें 4. classpath (Java का क्लास-पाथ) में सभी आवश्यक JAR फ़ाइलें मौजूद हैं, यह सत्यापित करें\nवेबऐप सुलभ नहीं: 1. पुष्टि करें कि webapps.config इसे निष्क्रिय नहीं कर रहा है 2. Jetty संस्करण संगतता (min-jetty-version) जांचें 3. सुनिश्चित करें कि web.xml मौजूद है (annotation scanning (एनोटेशन स्कैनिंग) समर्थित नहीं है) 4. परस्पर-विरोधी वेबऐप नामों की जांच करें\nअपडेट विफल: 1. सत्यापित करें कि संस्करण स्ट्रिंग बढ़ाई गई है 2. जाँचें कि हस्ताक्षर हस्ताक्षर कुंजी से मेल खाता है 3. सुनिश्चित करें कि प्लगइन नाम स्थापित संस्करण से मेल खाता है 4. update-only/install-only सेटिंग्स की समीक्षा करें\nबाहरी प्रोग्राम बंद नहीं हो रहा है: 1. स्वचालित जीवनचक्र के लिए ShellService का उपयोग करें 2. उचित stopargs प्रबंधन लागू करें 3. PID फ़ाइल की सफाई की जाँच करें 4. प्रक्रिया के समाप्त होने की पुष्टि करें\nडिबग लॉगिंग router में डिबग लॉगिंग सक्षम करें:\nlogger.record.net.i2p.router.web.ConfigPluginsHandler=DEBUG लॉग्स जांचें:\n~/.i2p/logs/log-router-0.txt संदर्भ जानकारी आधिकारिक विनिर्देश प्लगइन विनिर्देश विन्यास प्रारूप अद्यतन विनिर्देश क्रिप्टोग्राफी I2P संस्करण इतिहास वर्तमान रिलीज़: - I2P 2.10.0 (8 सितंबर 2025)\n0.9.53 के बाद के प्रमुख रिलीज़: - 2.10.0 (सितंबर 2025) - Java 17+ की घोषणा - 2.9.0 (जून 2025) - Java 17+ चेतावनी - 2.8.0 (अक्टूबर 2024) - पोस्ट-क्वांटम क्रिप्टोग्राफी परीक्षण - 2.6.0 (मई 2024) - I2P-over-Tor ब्लॉकिंग - 2.4.0 (दिसंबर 2023) - NetDB सुरक्षा सुधार - 2.2.0 (मार्च 2023) - भीड़ नियंत्रण - 2.1.0 (जनवरी 2023) - नेटवर्क सुधार - 2.0.0 (नवंबर 2022) - SSU2 ट्रांसपोर्ट प्रोटोकॉल - 1.7.0/0.9.53 (फरवरी 2022) - ShellService, वेरिएबल प्रतिस्थापन - 0.9.15 (सितंबर 2014) - SU3 फ़ॉर्मेट पेश किया गया\nसंस्करण क्रमांकन: - 0.9.x श्रृंखला: संस्करण 0.9.53 तक - 2.x श्रृंखला: 2.0.0 से शुरू (SSU2 परिचय)\nडेवलपर संसाधन स्रोत कोड: - मुख्य रिपॉजिटरी: https://i2pgit.org/I2P_Developers/i2p.i2p - GitHub मिरर: https://github.com/i2p/i2p.i2p प्लगइन उदाहरण: - zzzot (BitTorrent ट्रैकर) - pebble (ब्लॉग प्लेटफ़ॉर्म) - i2p-bote (सर्वर-रहित ईमेल) - orchid (Tor क्लाइंट) - seedless (पीयर एक्सचेंज)\nबिल्ड टूल्स: - makeplugin.sh - कुंजी निर्माण और डिजिटल हस्ताक्षर - i2p.scripts रिपॉज़िटरी में उपलब्ध - su3 निर्माण और सत्यापन को स्वचालित करता है\nसामुदायिक सहायता फोरम: - I2P Forum - zzz.i2p (I2P-आंतरिक)\nIRC/चैट: - OFTC पर #i2p-dev - I2P नेटवर्क के भीतर IRC\nपरिशिष्ट A: पूर्ण plugin.config उदाहरण # Required fields name=example-plugin signer=developer@mail.i2p version=1.2.3 # Update configuration updateURL.su3=http://example.i2p/plugins/example-$OS-$ARCH.su3 min-i2p-version=2.0.0 min-java-version=17 # Display information date=1698796800000 author=Example Developer \u0026lt;developer@mail.i2p\u0026gt; websiteURL=http://example.i2p/ license=Apache-2.0 description=An example I2P plugin demonstrating best practices description_de=Ein Beispiel-I2P-Plugin zur Demonstration bewährter Praktiken description_es=Un plugin I2P de ejemplo que demuestra las mejores prácticas # Console integration consoleLinkName=Example Plugin consoleLinkName_de=Beispiel-Plugin consoleLinkURL=/example/ consoleLinkTooltip=Open the Example Plugin control panel consoleLinkTooltip_de=Öffne das Beispiel-Plugin-Kontrollfeld console-icon=/icon.png # Installation behavior dont-start-at-install=false router-restart-required=false # Platform requirements (informational) required-platform-OS=All platforms supported other-requirements=Requires 512MB free disk space परिशिष्ट B: clients.config का पूर्ण उदाहरण # Main service client (managed) clientApp.0.main=com.example.plugin.MainService clientApp.0.name=Example Plugin Main Service clientApp.0.delay=30 clientApp.0.args=$PLUGIN/config.properties --port=7656 clientApp.0.stopargs=shutdown clientApp.0.uninstallargs=cleanup clientApp.0.classpath=$PLUGIN/lib/example.jar,$I2P/lib/i2p.jar,$I2P/lib/mstreaming.jar # External program via ShellService clientApp.1.main=net.i2p.apps.ShellService clientApp.1.name=Example Native Helper clientApp.1.delay=35 clientApp.1.args=$PLUGIN/bin/helper-$OS-$ARCH --config $PLUGIN/helper.conf clientApp.1.classpath=$I2P/lib/i2p.jar # Jetty eepsite clientApp.2.main=net.i2p.jetty.JettyStart clientApp.2.name=Example Eepsite clientApp.2.delay=40 clientApp.2.args=$PLUGIN/eepsite/jetty.xml clientApp.2.stopargs=$PLUGIN/eepsite/jetty.xml stop clientApp.2.classpath=$PLUGIN/lib/example-web.jar,$I2P/lib/i2p.jar # I2PTunnel for eepsite clientApp.3.main=net.i2p.i2ptunnel.TunnelControllerGroup clientApp.3.name=Example Eepsite Tunnel clientApp.3.delay=45 clientApp.3.args=$PLUGIN/eepsite/i2ptunnel.config परिशिष्ट C: पूर्ण webapps.config उदाहरण # Disable autostart for admin webapp webapps.example-admin.startOnLoad=false # Main webapp with classpath webapps.example.startOnLoad=true webapps.example.classpath=$PLUGIN/lib/example-core.jar,$PLUGIN/lib/commons-utils.jar,$I2P/lib/jstl.jar,$I2P/lib/standard.jar # Legacy support (pre-0.7.12-9) plugin.example.startOnLoad=true परिशिष्ट D: माइग्रेशन जाँच-सूची (0.9.53 से 2.10.0) आवश्यक परिवर्तन बिल्ड प्रक्रिया से Pack200 (Java JAR संपीड़न प्रारूप) को हटाएँ\nAnt/Maven/Gradle स्क्रिप्ट्स से pack200 कार्य हटाएँ pack200 के बिना मौजूदा प्लगइन्स को पुनः जारी करें Java संस्करण आवश्यकताओं की समीक्षा करें\nनई सुविधाओं के लिए Java 11+ आवश्यक करने पर विचार करें I2P 2.11.0 में Java 17+ की आवश्यकता की योजना बनाएं plugin.config में min-java-version को अपडेट करें दस्तावेज़ीकरण अपडेट करें\nPack200 संदर्भ हटाएँ Java संस्करण आवश्यकताओं को अपडेट करें I2P संस्करण संदर्भ अपडेट करें (0.9.x → 2.x) अनुशंसित परिवर्तन क्रिप्टोग्राफ़िक हस्ताक्षरों को सुदृढ़ करें\nयदि अभी तक नहीं किया गया है, तो XPI2P से SU3 पर माइग्रेट करें नए प्लगइनों के लिए RSA-4096 कुंजियों का उपयोग करें नई सुविधाओं का लाभ उठाएँ (यदि 0.9.53+ का उपयोग कर रहे हैं)\nप्लेटफ़ॉर्म-विशिष्ट अपडेट के लिए $OS / $ARCH वेरिएबल्स का उपयोग करें बाहरी प्रोग्रामों के लिए ShellService (शेल सेवा) का उपयोग करें बेहतर वेबऐप क्लासपाथ का उपयोग करें (किसी भी WAR नाम के साथ काम करता है) संगतता परीक्षण\nI2P 2.10.0 पर परीक्षण करें Java 8, 11, 17 के साथ सत्यापित करें Windows, Linux, macOS पर जाँच करें वैकल्पिक संवर्द्धन उचित ServletContextListener (एप्लिकेशन जीवनचक्र श्रोता) लागू करें स्थानीयकृत विवरण जोड़ें कंसोल आइकन प्रदान करें शटडाउन हैंडलिंग में सुधार करें व्यापक लॉगिंग जोड़ें स्वचालित परीक्षण लिखें ","description":"I2P प्लगइन्स के लिए .xpi2p / .su3 पैकेजिंग नियम","id":"b25aafc3542216f9bbc2f124d1943fbc","section":"docs","title":"प्लगइन पैकेज प्रारूप","url":"/hi/docs/specs/plugin/"},{"categories":null,"content":" अप्रचलित: ministreaming लाइब्रेरी आज की स्ट्रीमिंग लाइब्रेरी से पुरानी है। आधुनिक अनुप्रयोगों को पूर्ण स्ट्रीमिंग API या SAM v3 (I2P से जोड़ने के लिए प्रोटोकॉल) का उपयोग करना चाहिए। नीचे दी गई जानकारी उन डेवलपर्स के लिए रखी गई है जो ministreaming.jar के साथ भेजे गए लेगेसी स्रोत कोड की समीक्षा कर रहे हैं।\nअवलोकन Ministreaming (हल्का-फुल्का स्ट्रीमिंग प्रोटोकॉल) I2CP के ऊपर कार्य करता है, ताकि I2P की संदेश परत पर विश्वसनीय, क्रमानुसार डिलीवरी प्रदान की जा सके—कुछ वैसे ही जैसे IP पर TCP। इसे मूल रूप से शुरुआती I2PTunnel एप्लिकेशन (BSD लाइसेंस प्राप्त) से अलग करके निकाला गया था ताकि वैकल्पिक transports (परिवहन प्रोटोकॉल) स्वतंत्र रूप से विकसित हो सकें।\nमुख्य डिज़ाइन सीमाएँ:\nपारंपरिक दो-चरणीय (SYN/ACK/FIN) कनेक्शन स्थापना, TCP से उधार ली गई स्थिर विंडो आकार: 1 पैकेट प्रति-पैकेट ID नहीं, न ही चयनात्मक स्वीकृतियाँ इन विकल्पों ने कार्यान्वयन को छोटा रखा, लेकिन थ्रूपुट को सीमित कर दिया—अगला पैकेट भेजे जाने से पहले प्रत्येक पैकेट को आमतौर पर लगभग दो RTT (राउंड-ट्रिप समय) तक प्रतीक्षा करनी पड़ती है। दीर्घकालिक स्ट्रीम्स के लिए यह दुष्प्रभाव स्वीकार्य है, लेकिन छोटे HTTP-शैली के आदान-प्रदान पर इसका स्पष्ट असर पड़ता है।\nStreaming Library के साथ संबंध वर्तमान streaming लाइब्रेरी उसी Java पैकेज (net.i2p.client.streaming) का विस्तार करती है। Deprecated क्लासेस और मेथड्स Javadocs में बने रहते हैं और स्पष्ट रूप से चिह्नित हैं, ताकि डेवलपर्स ministreaming (एक पुरानी streaming लाइब्रेरी) युग के APIs की पहचान कर सकें। जब streaming लाइब्रेरी ने ministreaming को प्रतिस्थापित किया, तब इसमें जोड़ा गया:\nकम राउंड-ट्रिप्स के साथ अधिक स्मार्ट कनेक्शन सेटअप अनुकूली congestion windows (नेटवर्क भीड़भाड़ नियंत्रित करने की विंडो) और retransmission logic (दोबारा भेजने का तर्क) पैकेट-हानि वाले tunnels पर बेहतर प्रदर्शन Ministreaming (हल्का स्ट्रीमिंग उपतंत्र) कब उपयोगी था? अपनी सीमाओं के बावजूद, ministreaming (लघु स्ट्रीमिंग इंजन) ने शुरुआती परिनियोजनों में विश्वसनीय ट्रांसपोर्ट प्रदान किया। API को जानबूझकर छोटा और भविष्य-सुरक्षित रखा गया ताकि वैकल्पिक स्ट्रीमिंग इंजन कॉल करने वाले अनुप्रयोगों को तोड़े बिना बदले जा सकें। Java अनुप्रयोगों ने इसे सीधे लिंक किया; गैर‑Java क्लाइंट्स ने स्ट्रीमिंग सत्रों के लिए SAM समर्थन के माध्यम से वही कार्यक्षमता एक्सेस की।\nवर्तमान में, ministreaming.jar को केवल एक compatibility layer (अनुकूलता परत) के रूप में मानें। नए विकास को चाहिए:\nपूर्ण स्ट्रीमिंग लाइब्रेरी (Java) को लक्षित करें या SAM v3 (STREAM style) का उपयोग करें कोड का आधुनिकीकरण करते समय किसी भी बचे हुए फिक्स्ड-विंडो धारणाओं को हटा दें विलंब-संवेदी कार्यभार में सुधार हेतु बड़े विंडो आकार और अनुकूलित कनेक्ट हैंडशेक को प्राथमिकता दें संदर्भ स्ट्रीमिंग लाइब्रेरी दस्तावेज़ीकरण स्ट्रीमिंग Javadoc – अप्रचलित मिनीस्ट्रीमिंग कक्षाएँ शामिल हैं SAM v3 विशिष्टता – non-Java अनुप्रयोगों के लिए स्ट्रीमिंग समर्थन यदि आपको ऐसा कोड मिले जो अभी भी ministreaming (स्ट्रीमिंग का पुराना, हल्का उप-प्रोटोकॉल) पर निर्भर है, तो उसे आधुनिक स्ट्रीमिंग API पर पोर्ट करने की योजना बनाएं—नेटवर्क और उसकी टूलिंग नए व्यवहार की अपेक्षा करते हैं।\n","description":"I2P की पहली TCP जैसी ट्रांसपोर्ट लेयर पर ऐतिहासिक टिप्पणियाँ","id":"3a258127f502d1974fadc514a60bf831","section":"docs","title":"मिनीस्ट्रिमिंग लाइब्रेरी","url":"/hi/docs/legacy/ministreaming/"},{"categories":null,"content":"यह गाइड I2P Router Console और इसके कॉन्फ़िगरेशन पेजों का एक अवलोकन प्रदान करता है। प्रत्येक सेक्शन यह बताता है कि पेज क्या करता है और यह किसके लिए है, जो आपको अपने I2P router को मॉनिटर और कॉन्फ़िगर करने का तरीका समझने में मदद करता है।\nराउटर कंसोल एक्सेस करना I2P Router Console आपके I2P router को प्रबंधित और मॉनिटर करने के लिए केंद्रीय केंद्र है। डिफ़ॉल्ट रूप से, इसे I2P Router Console पर एक्सेस किया जा सकता है जब आपका I2P router चल रहा हो।\nहोम पेज कई प्रमुख अनुभाग प्रदर्शित करता है:\nएप्लिकेशन - अंतर्निहित I2P एप्लिकेशन जैसे ईमेल, टोरेंट, Hidden Services Manager, और वेब सर्वर तक त्वरित पहुंच I2P कम्युनिटी साइट्स - महत्वपूर्ण कम्युनिटी संसाधनों के लिंक जिनमें फ़ोरम, दस्तावेज़ीकरण, और प्रोजेक्ट वेबसाइट शामिल हैं कॉन्फ़िगरेशन और सहायता - बैंडविड्थ सेटिंग्स को कॉन्फ़िगर करने, प्लगइन्स प्रबंधित करने, और सहायता संसाधनों तक पहुंचने के लिए उपकरण नेटवर्क और डेवलपर जानकारी - ग्राफ़, लॉग, तकनीकी दस्तावेज़ीकरण, और नेटवर्क आंकड़ों तक पहुंच पता पुस्तिका URL: Address Book I2P Address Book clearnet पर DNS के समान कार्य करती है, जो आपको I2P destinations (eepsites) के लिए मानव-पठनीय नामों को प्रबंधित करने की अनुमति देती है। यहां आप अपनी व्यक्तिगत address book में I2P पते देख और जोड़ सकते हैं।\nपता पुस्तिका प्रणाली कई स्तरों के माध्यम से काम करती है:\nLocal Records - आपकी व्यक्तिगत address books जो केवल आपके router पर संग्रहीत होती हैं\nLocal Addressbook - वे hosts जिन्हें आप मैन्युअल रूप से जोड़ते हैं या अपने उपयोग के लिए सहेजते हैं Private Addressbook - वे addresses जिन्हें आप दूसरों के साथ साझा नहीं करना चाहते; कभी भी सार्वजनिक रूप से वितरित नहीं की जातीं सब्सक्रिप्शन - रिमोट एड्रेस बुक स्रोत (जैसे http://i2p-projekt.i2p/hosts.txt) जो आपके router के एड्रेस बुक को ज्ञात I2P साइटों के साथ स्वचालित रूप से अपडेट करते हैं\nराउटर एड्रेसबुक - आपके स्थानीय रिकॉर्ड और सब्सक्रिप्शन का मर्ज किया गया परिणाम, जो आपके router पर सभी I2P एप्लिकेशन द्वारा खोजा जा सकता है\nप्रकाशित एड्रेसबुक - अपनी एड्रेस बुक को सार्वजनिक रूप से साझा करने का वैकल्पिक विकल्प ताकि अन्य इसे सब्सक्रिप्शन स्रोत के रूप में उपयोग कर सकें (यदि आप कोई I2P साइट चला रहे हैं तो उपयोगी)\nएड्रेस बुक नियमित रूप से आपकी सब्सक्रिप्शन को पोल करती है और कंटेंट को आपके राउटर एड्रेस बुक में मर्ज करती है, जिससे आपकी hosts.txt फ़ाइल I2P नेटवर्क के साथ अप टू डेट रहती है।\nकॉन्फ़िगरेशन URL: उन्नत कॉन्फ़िगरेशन कॉन्फ़िगरेशन सेक्शन कई विशेष टैब के माध्यम से सभी router सेटिंग्स तक पहुंच प्रदान करता है।\nAdvanced उन्नत कॉन्फ़िगरेशन पेज निम्न-स्तरीय router सेटिंग्स तक पहुंच प्रदान करता है जो सामान्य संचालन के लिए आमतौर पर आवश्यक नहीं होती हैं। अधिकांश उपयोगकर्ताओं को इन सेटिंग्स को तब तक संशोधित नहीं करना चाहिए जब तक कि वे विशिष्ट कॉन्फ़िगरेशन विकल्प और router के व्यवहार पर इसके प्रभाव को समझ न लें।\nमुख्य विशेषताएं:\nFloodfill कॉन्फ़िगरेशन - नियंत्रित करें कि आपका router floodfill peer के रूप में भाग लेता है या नहीं, जो network database जानकारी को स्टोर और वितरित करके नेटवर्क की मदद करता है। इससे अधिक सिस्टम संसाधन उपयोग हो सकते हैं लेकिन I2P नेटवर्क मजबूत होता है।\nउन्नत I2P कॉन्फ़िगरेशन - router.config फ़ाइल तक सीधी पहुंच, सभी उन्नत कॉन्फ़िगरेशन पैरामीटर प्रदर्शित करते हुए जिनमें शामिल हैं:\nबैंडविड्थ सीमाएं और बर्स्ट सेटिंग्स ट्रांसपोर्ट सेटिंग्स (NTCP2, SSU2, UDP पोर्ट्स और keys) Router पहचान और संस्करण जानकारी कंसोल प्राथमिकताएं और अपडेट सेटिंग्स अधिकांश उन्नत कॉन्फ़िगरेशन विकल्प यूज़र इंटरफ़ेस में दिखाई नहीं देते क्योंकि उनकी शायद ही कभी आवश्यकता होती है। इन सेटिंग्स को संपादित करने में सक्षम बनाने के लिए, आपको अपनी router.config फ़ाइल में मैन्युअली routerconsole.advanced=true जोड़ना होगा।\nचेतावनी: उन्नत सेटिंग्स को गलत तरीके से संशोधित करने से आपके router की performance या connectivity पर नकारात्मक प्रभाव पड़ सकता है। इन सेटिंग्स को केवल तभी बदलें जब आप जानते हों कि आप क्या कर रहे हैं।\nBandwidth URL: बैंडविड्थ कॉन्फ़िगरेशन बैंडविड्थ कॉन्फ़िगरेशन पेज आपको यह नियंत्रित करने की अनुमति देता है कि आपका router I2P नेटवर्क में कितनी बैंडविड्थ योगदान करता है। I2P सबसे अच्छा काम करता है जब आप अपनी दरों को अपने इंटरनेट कनेक्शन की गति से मेल खाने के लिए कॉन्फ़िगर करते हैं।\nप्रमुख सेटिंग्स:\nKBps In - आपका राउटर जो अधिकतम इनबाउंड bandwidth स्वीकार करेगा (डाउनलोड स्पीड) KBps Out - आपका राउटर जो अधिकतम आउटबाउंड bandwidth उपयोग करेगा (अपलोड स्पीड) Share - आपकी आउटबाउंड bandwidth का प्रतिशत जो participating traffic के लिए समर्पित है (दूसरों के लिए traffic route करने में मदद करना) महत्वपूर्ण नोट्स:\nसभी मान बाइट प्रति सेकंड (KBps) में हैं, बिट प्रति सेकंड में नहीं जितनी अधिक bandwidth आप उपलब्ध कराते हैं, उतना ही आप नेटवर्क की मदद करते हैं और अपनी गुमनामी में सुधार करते हैं आपकी upstream share राशि (KBps Out) नेटवर्क में आपके समग्र योगदान को निर्धारित करती है यदि आप अपने नेटवर्क की गति के बारे में सुनिश्चित नहीं हैं, तो इसे मापने के लिए Bandwidth Test का उपयोग करें उच्च share bandwidth आपकी गुमनामी और I2P नेटवर्क को मजबूत बनाने दोनों में सुधार करती है कॉन्फ़िगरेशन पेज आपकी सेटिंग्स के आधार पर अनुमानित मासिक डेटा ट्रांसफर दिखाता है, जो आपको अपनी इंटरनेट योजना की सीमाओं के अनुसार बैंडविड्थ आवंटन की योजना बनाने में मदद करता है।\nClient Configuration URL: क्लाइंट कॉन्फ़िगरेशन क्लाइंट कॉन्फ़िगरेशन पेज आपको यह नियंत्रित करने की अनुमति देता है कि स्टार्टअप पर कौन से I2P एप्लिकेशन और सेवाएं चलती हैं। यहाँ आप बिल्ट-इन I2P क्लाइंट्स को अनइंस्टॉल किए बिना सक्षम या अक्षम कर सकते हैं।\nमहत्वपूर्ण चेतावनी: यहां सेटिंग्स बदलते समय सावधान रहें। I2P के अधिकांश उपयोगों के लिए router console और application tunnels आवश्यक हैं। केवल उन्नत उपयोगकर्ताओं को ही इन सेटिंग्स को संशोधित करना चाहिए।\nउपलब्ध क्लाइंट:\nएप्लिकेशन tunnels - I2PTunnel सिस्टम जो क्लाइंट और सर्वर tunnels को प्रबंधित करता है (HTTP प्रॉक्सी, IRC, आदि) I2P Router Console - वेब-आधारित प्रशासन इंटरफ़ेस जिसे आप वर्तमान में उपयोग कर रहे हैं I2P webserver (eepsite) - अपनी खुद की I2P वेबसाइट होस्ट करने के लिए अंतर्निर्मित Jetty webserver स्टार्टअप पर वेब ब्राउज़र में Router Console खोलें - स्वचालित रूप से आपके ब्राउज़र को console होमपेज पर लॉन्च करता है SAM application bridge - तृतीय-पक्ष एप्लिकेशनों को I2P से कनेक्ट करने के लिए API bridge प्रत्येक client दिखाता है: - स्टार्टअप पर चलाएं? - ऑटो-स्टार्ट को सक्षम/अक्षम करने के लिए चेकबॉक्स - नियंत्रण - तत्काल नियंत्रण के लिए Start/Stop बटन - Class और arguments - client को कैसे लॉन्च किया जाता है, इसके बारे में तकनीकी विवरण\n\u0026ldquo;Run at Startup?\u0026rdquo; सेटिंग में परिवर्तन को प्रभावी करने के लिए router को पुनः आरंभ करना आवश्यक है। सभी संशोधन /var/lib/i2p/i2p-config/clients.config.d/ में सहेजे जाते हैं।\nउन्नत URL: I2CP Configuration I2CP (I2P Client Protocol) कॉन्फ़िगरेशन पेज आपको यह कॉन्फ़िगर करने की अनुमति देता है कि बाहरी एप्लिकेशन आपके I2P router से कैसे कनेक्ट होते हैं। I2CP वह प्रोटोकॉल है जिसका उपयोग एप्लिकेशन router के साथ संचार करने, tunnel बनाने और I2P पर डेटा भेजने/प्राप्त करने के लिए करते हैं।\nमहत्वपूर्ण: डिफ़ॉल्ट सेटिंग्स अधिकांश लोगों के लिए काम करेंगी। यहाँ किए गए किसी भी बदलाव को बाहरी क्लाइंट एप्लिकेशन में भी कॉन्फ़िगर करना होगा। कई क्लाइंट SSL या authorization को सपोर्ट नहीं करते हैं। सभी बदलावों को प्रभावी होने के लिए रीस्टार्ट की आवश्यकता है।\nकॉन्फ़िगरेशन विकल्प:\nबाहरी I2CP इंटरफ़ेस कॉन्फ़िगरेशन\nSSL के बिना सक्षम - मानक I2CP एक्सेस (डिफ़ॉल्ट और सबसे अधिक संगत) SSL आवश्यक के साथ सक्षम - केवल एन्क्रिप्टेड I2CP कनेक्शन अक्षम - बाहरी क्लाइंट्स को I2CP के माध्यम से कनेक्ट होने से रोकता है I2CP इंटरफ़ेस - सुनने के लिए नेटवर्क इंटरफ़ेस (डिफ़ॉल्ट: केवल localhost के लिए 127.0.0.1)\nI2CP पोर्ट - I2CP कनेक्शन के लिए पोर्ट नंबर (डिफ़ॉल्ट: 7654)\nप्राधिकरण (Authorization)\nउपयोगकर्ता नाम और पासवर्ड आवश्यक करें - I2CP कनेक्शन के लिए प्रमाणीकरण सक्षम करें उपयोगकर्ता नाम - I2CP एक्सेस के लिए आवश्यक उपयोगकर्ता नाम सेट करें पासवर्ड - I2CP एक्सेस के लिए आवश्यक पासवर्ड सेट करें सुरक्षा नोट: यदि आप केवल उसी मशीन पर एप्लिकेशन चला रहे हैं जिस पर आपका I2P router है, तो इंटरफ़ेस को 127.0.0.1 पर सेट रखें ताकि रिमोट एक्सेस को रोका जा सके। इन सेटिंग्स को केवल तभी बदलें जब आपको अन्य डिवाइसों से I2P एप्लिकेशन को अपने router से कनेक्ट करने की अनुमति देनी हो।\nबैंडविड्थ URL: नेटवर्क कॉन्फ़िगरेशन नेटवर्क कॉन्फ़िगरेशन पेज आपको यह कॉन्फ़िगर करने की अनुमति देता है कि आपका I2P router इंटरनेट से कैसे कनेक्ट होता है, जिसमें IP एड्रेस डिटेक्शन, IPv4/IPv6 प्राथमिकताएं, और UDP और TCP transports दोनों के लिए पोर्ट सेटिंग्स शामिल हैं।\nबाहरी रूप से पहुँच योग्य IP Address:\nसभी ऑटो-डिटेक्ट तरीकों का उपयोग करें - कई तरीकों का उपयोग करके आपके पब्लिक IP को स्वचालित रूप से पहचानता है (अनुशंसित) UPnP IP एड्रेस डिटेक्शन को अक्षम करें - आपके IP को खोजने के लिए UPnP का उपयोग करने से रोकता है लोकल इंटरफ़ेस IP एड्रेस को अनदेखा करें - आपके लोकल नेटवर्क IP का उपयोग न करें केवल SSU IP एड्रेस डिटेक्शन का उपयोग करें - IP डिटेक्शन के लिए केवल SSU2 ट्रांसपोर्ट का उपयोग करें हिडन मोड - IP प्रकाशित न करें - नेटवर्क ट्रैफ़िक में भाग लेने से रोकता है (गुमनामी कम करता है) होस्टनेम या IP निर्दिष्ट करें - अपना पब्लिक IP या होस्टनेम मैन्युअल रूप से सेट करें IPv4 कॉन्फ़िगरेशन:\nइनबाउंड अक्षम करें (Firewalled) - यदि आप फ़ायरवॉल, होम नेटवर्क, ISP, DS-Lite, या carrier-grade NAT के पीछे हैं जो inbound कनेक्शन को ब्लॉक करता है, तो इसे चेक करें IPv6 कॉन्फ़िगरेशन:\nIPv4 को IPv6 से प्राथमिकता दें - IPv4 कनेक्शन को प्राथमिकता देता है IPv6 को IPv4 से प्राथमिकता दें - IPv6 कनेक्शन को प्राथमिकता देता है (dual-stack नेटवर्क के लिए डिफ़ॉल्ट) IPv6 सक्षम करें - IPv6 कनेक्शन की अनुमति देता है IPv6 अक्षम करें - सभी IPv6 कनेक्टिविटी को अक्षम करता है केवल IPv6 उपयोग करें (IPv4 अक्षम करें) - प्रायोगिक IPv6-only मोड इनबाउंड अक्षम करें (Firewalled) - जाँचें कि क्या आपका IPv6 firewalled है IP बदलने पर कार्रवाई:\nलैपटॉप मोड - प्रायोगिक सुविधा जो बढ़ी हुई गुमनामी के लिए आपके IP बदलने पर router पहचान और UDP पोर्ट को बदल देती है UDP कॉन्फ़िगरेशन:\nपोर्ट निर्दिष्ट करें - SSU2 ट्रांसपोर्ट के लिए एक विशिष्ट UDP पोर्ट सेट करें (आपके firewall में खोला जाना आवश्यक है) पूरी तरह से अक्षम करें - केवल तभी चुनें यदि आप ऐसे firewall के पीछे हैं जो सभी outbound UDP को ब्लॉक करता है TCP कॉन्फ़िगरेशन:\nपोर्ट निर्दिष्ट करें - NTCP2 ट्रांसपोर्ट के लिए एक विशिष्ट TCP पोर्ट सेट करें (आपके फ़ायरवॉल में खोला जाना आवश्यक है) UDP के लिए कॉन्फ़िगर किए गए समान पोर्ट का उपयोग करें - दोनों ट्रांसपोर्ट के लिए एक पोर्ट का उपयोग करके कॉन्फ़िगरेशन को सरल बनाता है स्वतः-पहचाने गए IP address का उपयोग करें - स्वचालित रूप से आपके सार्वजनिक IP का पता लगाता है (यदि अभी तक पहचाना नहीं गया है या फ़ायरवॉल द्वारा अवरुद्ध है तो \u0026ldquo;currently unknown\u0026rdquo; दिखाता है) हमेशा स्वतः-पहचाने गए IP address का उपयोग करें (Firewalled नहीं) - सीधे इंटरनेट एक्सेस वाले routers के लिए सर्वोत्तम इनबाउंड अक्षम करें (Firewalled) - जांचें कि क्या TCP कनेक्शन आपके फ़ायरवॉल द्वारा अवरुद्ध हैं पूरी तरह से अक्षम करें - केवल तभी चुनें जब ऐसे फ़ायरवॉल के पीछे हों जो आउटबाउंड TCP को थ्रॉटल या ब्लॉक करता है होस्टनाम या IP निर्दिष्ट करें - अपने बाह्य रूप से पहुंच योग्य पते को मैन्युअल रूप से कॉन्फ़िगर करें महत्वपूर्ण: नेटवर्क सेटिंग्स में बदलाव को पूरी तरह प्रभावी होने के लिए router को पुनः आरंभ करने की आवश्यकता हो सकती है। उचित पोर्ट फॉरवर्डिंग कॉन्फ़िगरेशन आपके router के प्रदर्शन में महत्वपूर्ण सुधार करता है और I2P नेटवर्क की मदद करता है।\nक्लाइंट कॉन्फ़िगरेशन URL: पीयर कॉन्फ़िगरेशन पीयर कॉन्फ़िगरेशन पेज I2P नेटवर्क पर व्यक्तिगत peers को प्रबंधित करने के लिए मैनुअल नियंत्रण प्रदान करता है। यह एक उन्नत सुविधा है जो आमतौर पर केवल समस्याग्रस्त peers की समस्या निवारण के लिए उपयोग की जाती है।\nमैनुअल पीयर नियंत्रण:\nराउटर हैश - उस पीयर का 44-अक्षर वाला base64 राउटर हैश दर्ज करें जिसे आप प्रबंधित करना चाहते हैं मैन्युअल रूप से एक Peer को Ban / Unban करें:\nकिसी peer को ban करने से उन्हें आपके द्वारा बनाई गई किसी भी tunnel में भाग लेने से रोका जा सकता है। यह क्रिया: - peer को आपके client या exploratory tunnels में उपयोग होने से रोकती है - बिना restart की आवश्यकता के तुरंत प्रभावी होती है - तब तक बनी रहती है जब तक आप मैन्युअली peer को unban नहीं करते या अपने router को restart नहीं करते - Ban peer until restart - अस्थायी रूप से peer को ब्लॉक करता है - Unban peer - पहले ब्लॉक किए गए peer से ban हटाता है\nप्रोफाइल बोनस समायोजित करें:\nप्रोफाइल बोनस इस बात को प्रभावित करते हैं कि tunnel भागीदारी के लिए peers का चयन कैसे किया जाता है। बोनस सकारात्मक या नकारात्मक हो सकते हैं: - Fast peers - उच्च गति की आवश्यकता वाले client tunnels के लिए उपयोग किए जाते हैं - High Capacity peers - कुछ exploratory tunnels के लिए उपयोग किए जाते हैं जिन्हें विश्वसनीय routing की आवश्यकता होती है - वर्तमान बोनस profiles पेज पर प्रदर्शित होते हैं\nकॉन्फ़िगरेशन: - स्पीड - इस peer के लिए स्पीड बोनस समायोजित करें (0 = न्यूट्रल) - कैपेसिटी - इस peer के लिए कैपेसिटी बोनस समायोजित करें (0 = न्यूट्रल) - Peer बोनस समायोजित करें - बोनस सेटिंग्स लागू करें\nउपयोग के मामले: - एक peer को ban करें जो लगातार connection समस्याएं पैदा करता है - एक peer को अस्थायी रूप से बाहर करें जिस पर आपको malicious होने का संदेह है - कम प्रदर्शन वाले peers को deprioritize करने के लिए bonuses को समायोजित करें - विशिष्ट peers को बाहर करके tunnel building समस्याओं को debug करें\nनोट: अधिकांश उपयोगकर्ताओं को इस सुविधा का उपयोग करने की कभी आवश्यकता नहीं होगी। I2P router स्वचालित रूप से प्रदर्शन मेट्रिक्स के आधार पर peer चयन और profiling का प्रबंधन करता है।\nI2CP कॉन्फ़िगरेशन URL: Reseed Configuration Reseed Configuration पेज आपको अपने router को मैन्युअली reseed करने की अनुमति देता है यदि स्वचालित reseeding विफल हो जाती है। Reseeding वह bootstrapping प्रक्रिया है जिसका उपयोग अन्य routers को खोजने के लिए किया जाता है जब आप पहली बार I2P इंस्टॉल करते हैं, या जब आपके router के पास बहुत कम router references शेष रह जाते हैं।\nमैनुअल Reseed का उपयोग कब करें:\nयदि रीसीडिंग विफल हो गई है, तो आपको सबसे पहले अपने नेटवर्क कनेक्शन की जांच करनी चाहिए\nयदि कोई फ़ायरवॉल reseed होस्ट से आपके कनेक्शन को ब्लॉक कर रहा है, तो हो सकता है आपके पास प्रॉक्सी की सुविधा हो:\nप्रॉक्सी एक रिमोट पब्लिक प्रॉक्सी हो सकती है, या आपके कंप्यूटर पर चल रही हो सकती है (localhost) प्रॉक्सी का उपयोग करने के लिए, Reseeding Configuration सेक्शन में टाइप, होस्ट और पोर्ट को कॉन्फ़िगर करें यदि आप Tor Browser चला रहे हैं, तो SOCKS 5, localhost, port 9150 कॉन्फ़िगर करके इसके माध्यम से reseed करें यदि आप कमांड-लाइन Tor चला रहे हैं, तो SOCKS 5, localhost, port 9050 कॉन्फ़िगर करके इसके माध्यम से reseed करें यदि आपके पास कुछ peers हैं लेकिन और अधिक की आवश्यकता है, तो आप I2P Outproxy विकल्प आज़मा सकते हैं। होस्ट और पोर्ट को खाली छोड़ दें। यह शुरुआती reseed के लिए काम नहीं करेगा जब आपके पास बिल्कुल भी peers नहीं हैं फिर, \u0026ldquo;Save changes and reseed now\u0026rdquo; पर क्लिक करें डिफ़ॉल्ट सेटिंग्स अधिकांश लोगों के लिए काम करेंगी। इन्हें केवल तभी बदलें जब HTTPS एक प्रतिबंधात्मक फ़ायरवॉल द्वारा ब्लॉक किया गया हो और reseed विफल हो गया हो यदि आप किसी ऐसे व्यक्ति को जानते और विश्वास करते हैं जो I2P चलाता है, तो उनसे अपने router console पर इस पेज का उपयोग करके generate किया गया reseed file भेजने के लिए कहें। फिर, आपको प्राप्त फ़ाइल के साथ reseed करने के लिए इस पेज का उपयोग करें। पहले, नीचे फ़ाइल का चयन करें। फिर, \u0026ldquo;Reseed from file\u0026rdquo; पर क्लिक करें\nयदि आप किसी ऐसे व्यक्ति को जानते और विश्वास करते हैं जो reseed फ़ाइलें प्रकाशित करता है, तो उनसे URL मांगें। फिर, आपको प्राप्त URL के साथ reseed करने के लिए इस पृष्ठ का उपयोग करें। पहले, नीचे URL दर्ज करें। फिर, \u0026ldquo;Reseed from URL\u0026rdquo; पर क्लिक करें\nमैन्युअल रूप से रीसीडिंग के निर्देशों के लिए FAQ देखें\nमैनुअल Reseed विकल्प:\nURL से रीसीड करें - किसी विश्वसनीय स्रोत से zip या su3 URL दर्ज करें और \u0026ldquo;Reseed from URL\u0026rdquo; पर क्लिक करें\nsu3 फ़ॉर्मेट को प्राथमिकता दी जाती है, क्योंकि इसे किसी विश्वसनीय स्रोत द्वारा हस्ताक्षरित के रूप में सत्यापित किया जाएगा zip फ़ॉर्मेट अहस्ताक्षरित है; zip फ़ाइल का उपयोग केवल उसी स्रोत से करें जिस पर आप भरोसा करते हैं फ़ाइल से Reseed करें - एक लोकल zip या su3 फ़ाइल ब्राउज़ करें और चुनें, फिर \u0026ldquo;Reseed from file\u0026rdquo; पर क्लिक करें\nआप reseed फ़ाइलें checki2p.com/reseed पर पा सकते हैं रीसीड फ़ाइल बनाएं - एक नई रीसीड zip फ़ाइल जेनरेट करें जिसे आप दूसरों के साथ मैन्युअल रीसीडिंग के लिए शेयर कर सकते हैं\nइस फ़ाइल में कभी भी आपके अपने router की identity या IP शामिल नहीं होगी रीसीडिंग कॉन्फ़िगरेशन:\nडिफ़ॉल्ट सेटिंग्स अधिकांश लोगों के लिए काम करेंगी। इन्हें केवल तभी बदलें जब HTTPS प्रतिबंधात्मक फ़ायरवॉल द्वारा अवरुद्ध हो और reseed विफल हो गया हो।\nReseed URLs - Reseed सर्वर्स के HTTPS URLs की सूची (डिफ़ॉल्ट सूची बिल्ट-इन है और नियमित रूप से अपडेट की जाती है) Proxy Configuration - यदि आपको proxy के माध्यम से reseed सर्वर्स तक पहुंचने की आवश्यकता है तो HTTP/HTTPS/SOCKS proxy कॉन्फ़िगर करें Reset URL list - डिफ़ॉल्ट reseed सर्वर सूची को पुनर्स्थापित करें महत्वपूर्ण: मैनुअल रीसीडिंग केवल उन दुर्लभ मामलों में आवश्यक होनी चाहिए जहां ऑटोमैटिक रीसीडिंग बार-बार विफल हो जाती है। अधिकांश उपयोगकर्ताओं को इस पृष्ठ का उपयोग करने की कभी आवश्यकता नहीं होगी।\nनेटवर्क कॉन्फ़िगरेशन URL: Router Family Configuration राउटर फैमिली कॉन्फ़िगरेशन पेज आपको राउटर फैमिली को प्रबंधित करने की अनुमति देता है। एक ही फैमिली में राउटर एक फैमिली की (family key) साझा करते हैं, जो उन्हें एक ही व्यक्ति या संगठन द्वारा संचालित होने के रूप में पहचानती है। यह आपके द्वारा नियंत्रित कई राउटर को एक ही tunnel के लिए चुने जाने से रोकता है, जिससे गुमनामी कम हो सकती है।\nRouter Family क्या है?\nजब आप एकाधिक I2P routers संचालित करते हैं, तो आपको उन्हें एक ही परिवार (family) का हिस्सा बनाने के लिए कॉन्फ़िगर करना चाहिए। यह सुनिश्चित करता है: - आपके routers एक साथ एक ही tunnel पथ में उपयोग नहीं किए जाएंगे - अन्य उपयोगकर्ता उचित गुमनामी बनाए रखते हैं जब उनके tunnels आपके routers का उपयोग करते हैं - नेटवर्क tunnel भागीदारी को ठीक से वितरित कर सकता है\nवर्तमान परिवार:\nयह पृष्ठ आपके वर्तमान router family नाम को प्रदर्शित करता है। यदि आप किसी family का हिस्सा नहीं हैं, तो यह खाली होगा।\nफैमिली की (Family Key) निर्यात करें:\nअपने नियंत्रण वाले अन्य routers में import करने के लिए secret family key को export करें अपनी family key file डाउनलोड करने के लिए \u0026ldquo;Export Family Key\u0026rdquo; पर क्लिक करें समान family में जोड़ने के लिए इस key को अपने अन्य routers पर import करें Router Family छोड़ें:\nअब परिवार का सदस्य नहीं रहें इस राउटर को उसके वर्तमान परिवार से हटाने के लिए \u0026ldquo;Leave Family\u0026rdquo; पर क्लिक करें यह क्रिया परिवार की कुंजी को पुनः आयात किए बिना पूर्ववत नहीं की जा सकती महत्वपूर्ण विचार:\nसार्वजनिक पंजीकरण आवश्यक: आपके family को नेटवर्क-व्यापी रूप से पहचाने जाने के लिए, आपकी family key को विकास टीम द्वारा I2P codebase में जोड़ा जाना चाहिए। यह सुनिश्चित करता है कि नेटवर्क पर सभी routers को आपके family के बारे में पता हो। यदि आप कई सार्वजनिक routers संचालित करते हैं तो अपनी family key पंजीकृत करने के लिए I2P टीम से संपर्क करें केवल एक router चलाने वाले अधिकांश उपयोगकर्ताओं को इस सुविधा का उपयोग करने की कभी आवश्यकता नहीं होगी Family configuration मुख्य रूप से कई सार्वजनिक routers के संचालकों या इंफ्रास्ट्रक्चर प्रदाताओं द्वारा उपयोग किया जाता है उपयोग के मामले:\nरिडंडेंसी के लिए कई I2P राउटर चलाना कई मशीनों पर reseed सर्वर या outproxy जैसे इंफ्रास्ट्रक्चर चलाना किसी संगठन के लिए I2P राउटरों का नेटवर्क प्रबंधित करना पीयर कॉन्फ़िगरेशन URL: Tunnel Configuration टनल कॉन्फ़िगरेशन पेज आपको exploratory tunnels (router संचार के लिए उपयोग किए जाने वाले) और client tunnels (अनुप्रयोगों द्वारा उपयोग किए जाने वाले) दोनों के लिए डिफ़ॉल्ट टनल सेटिंग्स समायोजित करने की अनुमति देता है। डिफ़ॉल्ट सेटिंग्स अधिकांश लोगों के लिए काम करती हैं और केवल तभी बदली जानी चाहिए जब आप ट्रेडऑफ़ को समझते हों।\nमहत्वपूर्ण चेतावनियाँ:\n⚠️ गुमनामी बनाम प्रदर्शन का समझौता: गुमनामी और प्रदर्शन के बीच एक मौलिक समझौता है। 3 hops से अधिक लंबी tunnels (उदाहरण के लिए 2 hops + 0-2 hops, 3 hops + 0-1 hops, 3 hops + 0-2 hops), या उच्च quantity + backup quantity, प्रदर्शन या विश्वसनीयता को गंभीर रूप से कम कर सकती हैं। उच्च CPU और/या उच्च outbound bandwidth उपयोग का परिणाम हो सकता है। इन सेटिंग्स को सावधानी से बदलें, और यदि आपको समस्याएं हैं तो इन्हें समायोजित करें।\n⚠️ स्थायित्व: खोजपूर्ण tunnel सेटिंग परिवर्तन router.config फ़ाइल में संग्रहीत किए जाते हैं। Client tunnel परिवर्तन अस्थायी होते हैं और सहेजे नहीं जाते हैं। स्थायी client tunnel परिवर्तन करने के लिए, I2PTunnel पेज देखें।\nएक्सप्लोरेटरी टनल:\nएक्सप्लोरेटरी टनल आपके राउटर द्वारा नेटवर्क डेटाबेस के साथ संचार करने और I2P नेटवर्क में भाग लेने के लिए उपयोग की जाती हैं।\nInbound और Outbound दोनों के लिए कॉन्फ़िगरेशन विकल्प: - Length - tunnel में hops की संख्या (डिफ़ॉल्ट: 2-3 hops) - Randomization - tunnel की लंबाई में यादृच्छिक भिन्नता (डिफ़ॉल्ट: 0-1 hops) - Quantity - सक्रिय tunnels की संख्या (डिफ़ॉल्ट: 2 tunnels) - Backup quantity - सक्रिय करने के लिए तैयार बैकअप tunnels की संख्या (डिफ़ॉल्ट: 0 tunnels)\nI2P वेबसर्वर के लिए क्लाइंट टनल:\nये सेटिंग्स बिल्ट-इन I2P वेबसर्वर (eepsite) के लिए tunnel को नियंत्रित करती हैं।\n⚠️ गुमनामी चेतावनी - सेटिंग्स में 1-hop tunnels शामिल हैं। ⚠️ प्रदर्शन चेतावनी - सेटिंग्स में उच्च tunnel मात्राएं शामिल हैं।\nInbound और Outbound दोनों के लिए कॉन्फ़िगरेशन विकल्प: - Length - Tunnel की लंबाई (डिफ़ॉल्ट: वेबसर्वर के लिए 1 hop) - Randomization - Tunnel की लंबाई में रैंडम भिन्नता - Quantity - सक्रिय tunnels की संख्या - Backup quantity - बैकअप tunnels की संख्या\nसाझा क्लाइंट के लिए क्लाइंट Tunnel:\nये सेटिंग्स shared client applications (HTTP proxy, IRC, आदि) पर लागू होती हैं।\nइनबाउंड और आउटबाउंड दोनों के लिए कॉन्फ़िगरेशन विकल्प: - Length - Tunnel की लंबाई (डिफ़ॉल्ट: 3 hops) - Randomization - Tunnel की लंबाई में यादृच्छिक भिन्नता - Quantity - सक्रिय tunnels की संख्या - Backup quantity - बैकअप tunnels की संख्या\nटनल पैरामीटर्स को समझना:\nलंबाई: लंबी टनलें अधिक गुमनामी प्रदान करती हैं लेकिन प्रदर्शन और विश्वसनीयता को कम करती हैं यादृच्छिकीकरण: tunnel पथों में अप्रत्याशितता जोड़ता है, सुरक्षा में सुधार करता है मात्रा: अधिक tunnels विश्वसनीयता और लोड वितरण में सुधार करती हैं लेकिन संसाधन उपयोग बढ़ाती हैं बैकअप मात्रा: विफल tunnels को बदलने के लिए पहले से निर्मित tunnels तैयार रहती हैं, लचीलापन में सुधार करती हैं सर्वोत्तम प्रथाएं:\nडिफ़ॉल्ट सेटिंग्स को बनाए रखें जब तक कि आपकी विशिष्ट आवश्यकताएं न हों tunnel की लंबाई केवल तभी बढ़ाएं जब गुमनामी महत्वपूर्ण हो और आप धीमी परफ़ॉर्मेंस स्वीकार कर सकें quantity/backup केवल तभी बढ़ाएं जब बार-बार tunnel विफलताओं का अनुभव हो रहा हो परिवर्तन करने के बाद router परफ़ॉर्मेंस की निगरानी करें संशोधनों को लागू करने के लिए \u0026ldquo;Save changes\u0026rdquo; पर क्लिक करें रीसीड कॉन्फ़िगरेशन URL: UI Configuration UI Configuration पृष्ठ आपको अपने राउटर कंसोल की उपस्थिति और पहुंच को अनुकूलित करने की अनुमति देता है, जिसमें थीम चयन, भाषा प्राथमिकताएं और पासवर्ड सुरक्षा शामिल हैं।\nराउटर कंसोल थीम:\nराउटर कंसोल इंटरफ़ेस के लिए डार्क और लाइट थीम के बीच चुनें: - Dark - डार्क मोड थीम (कम रोशनी वाले वातावरण में आंखों के लिए आसान) - Light - लाइट मोड थीम (पारंपरिक रूप)\nअतिरिक्त थीम विकल्प: - सभी ऐप्स में सार्वभौमिक रूप से थीम सेट करें - चयनित थीम को केवल router console पर ही नहीं, बल्कि सभी I2P एप्लिकेशन पर लागू करें - मोबाइल console को उपयोग करने के लिए बाध्य करें - डेस्कटॉप ब्राउज़र पर भी मोबाइल-अनुकूलित इंटरफ़ेस का उपयोग करें - Email और Torrent एप्लिकेशन को console में एम्बेड करें - Susimail और I2PSnark को अलग टैब में खोलने के बजाय सीधे console इंटरफ़ेस में एकीकृत करें\nराउटर कंसोल भाषा:\nड्रॉपडाउन मेनू से router console इंटरफेस के लिए अपनी पसंदीदा भाषा चुनें। I2P कई भाषाओं का समर्थन करता है जिनमें अंग्रेजी, जर्मन, फ्रेंच, स्पेनिश, रूसी, चीनी, जापानी और अन्य शामिल हैं।\nअनुवाद योगदान का स्वागत है: यदि आप अधूरे या गलत अनुवाद देखते हैं, तो आप अनुवाद परियोजना में योगदान करके I2P को बेहतर बनाने में मदद कर सकते हैं। IRC पर #i2p-dev में developers से संपर्क करें या अनुवाद स्थिति रिपोर्ट देखें (पृष्ठ पर लिंक किया गया है)।\nराउटर कंसोल पासवर्ड:\nअपने राउटर कंसोल तक पहुंच को सुरक्षित करने के लिए उपयोगकर्ता नाम और पासवर्ड प्रमाणीकरण जोड़ें:\nउपयोगकर्ता नाम - कंसोल एक्सेस के लिए उपयोगकर्ता नाम दर्ज करें पासवर्ड - कंसोल एक्सेस के लिए पासवर्ड दर्ज करें उपयोगकर्ता जोड़ें - निर्दिष्ट क्रेडेंशियल्स के साथ एक नया उपयोगकर्ता बनाएं चयनित को हटाएं - मौजूदा उपयोगकर्ता खाते हटाएं पासवर्ड क्यों जोड़ें?\nआपके राउटर कंसोल तक अनधिकृत स्थानीय पहुंच को रोकता है यदि कई लोग आपके कंप्यूटर का उपयोग करते हैं तो आवश्यक है यदि आपका राउटर कंसोल आपके स्थानीय नेटवर्क पर सुलभ है तो अनुशंसित है आपके I2P कॉन्फ़िगरेशन और गोपनीयता सेटिंग्स को छेड़छाड़ से सुरक्षित रखता है सुरक्षा नोट: पासवर्ड सुरक्षा केवल I2P Router Console पर router console वेब इंटरफ़ेस तक पहुँच को प्रभावित करती है। यह I2P ट्रैफ़िक को एन्क्रिप्ट नहीं करती है या एप्लिकेशन को I2P का उपयोग करने से नहीं रोकती है। यदि आप अपने कंप्यूटर के एकमात्र उपयोगकर्ता हैं और router console केवल localhost पर सुनता है (डिफ़ॉल्ट), तो पासवर्ड की आवश्यकता नहीं हो सकती है।\nराउटर फैमिली कॉन्फ़िगरेशन URL: WebApp Configuration WebApp Configuration पेज आपको उन Java वेब एप्लिकेशन को प्रबंधित करने की अनुमति देता है जो आपके I2P router के भीतर चलते हैं। ये एप्लिकेशन webConsole client द्वारा शुरू किए जाते हैं और router के समान JVM में चलते हैं, जो router console के माध्यम से एकीकृत कार्यक्षमता प्रदान करते हैं।\nWebApps क्या हैं?\nWebApps जावा-आधारित एप्लिकेशन हैं जो हो सकते हैं: - पूर्ण एप्लिकेशन (जैसे टोरेंट के लिए I2PSnark) - अन्य क्लाइंट के लिए फ्रंट-एंड जिन्हें अलग से सक्षम करना होता है (जैसे Susidns, I2PTunnel) - बिना वेब इंटरफ़ेस वाले वेब एप्लिकेशन (जैसे address book)\nमहत्वपूर्ण नोट्स:\nएक webapp को पूरी तरह से disabled किया जा सकता है, या इसे केवल startup पर चलने से disabled किया जा सकता है webapps directory से war file को हटाने से webapp पूरी तरह से disabled हो जाता है हालांकि, .war file और webapp directory फिर से दिखाई देगी जब आप अपने router को नए version में update करेंगे एक webapp को स्थायी रूप से disable करने के लिए: इसे यहाँ disable करें, जो कि पसंदीदा तरीका है उपलब्ध WebApps:\nWebApp Description i2psnark Torrents - Built-in BitTorrent client for I2P i2ptunnel Hidden Services Manager - Configure client and server tunnels imagegen Identification Image Generator - Creates unique identicons jsonrpc jsonrpc.war - JSON-RPC API interface (disabled by default) routerconsole I2P Router Console - The main administrative interface susidns Address Book - Manage I2P addresses and subscriptions susimail Email - Web-based email client for I2P नियंत्रण: प्रत्येक webapp के लिए: - Startup पर चलाएं? - स्वचालित startup को सक्षम/अक्षम करने के लिए Checkbox - Control - तत्काल नियंत्रण के लिए Start/Stop बटन - Stop - वर्तमान में चल रहे webapp को रोकता है - Start - रुके हुए webapp को शुरू करता है\nकॉन्फ़िगरेशन बटन:\nरद्द करें - परिवर्तनों को छोड़ें और पिछले पेज पर वापस जाएं WebApp कॉन्फ़िगरेशन सहेजें - अपने परिवर्तनों को सहेजें और लागू करें उपयोग के मामले:\nयदि आप टॉरेंट का उपयोग नहीं करते हैं तो संसाधन बचाने के लिए I2PSnark बंद करें यदि आपको API एक्सेस की आवश्यकता नहीं है तो jsonrpc निष्क्रिय करें यदि आप बाहरी ईमेल क्लाइंट का उपयोग करते हैं तो Susimail बंद करें मेमोरी खाली करने या समस्याओं का निवारण करने के लिए अस्थायी रूप से webapps बंद करें प्रदर्शन सुझाव: अप्रयुक्त webapps को निष्क्रिय करने से मेमोरी उपयोग कम हो सकता है और router प्रदर्शन में सुधार हो सकता है, विशेष रूप से कम-संसाधन वाले सिस्टम पर।\nHelp URL: सहायता Help पेज व्यापक दस्तावेज़ीकरण और संसाधन प्रदान करता है जो आपको I2P को प्रभावी ढंग से समझने और उपयोग करने में मदद करते हैं। यह समस्या निवारण, सीखने और सहायता प्राप्त करने के लिए एक केंद्रीय केंद्र के रूप में कार्य करता है।\nआप क्या पाएंगे:\nत्वरित प्रारंभ गाइड - I2P के साथ शुरुआत करने वाले नए उपयोगकर्ताओं के लिए आवश्यक जानकारी अक्सर पूछे जाने वाले प्रश्न (FAQ) - I2P इंस्टॉलेशन, कॉन्फ़िगरेशन और उपयोग के बारे में सामान्य प्रश्नों के उत्तर समस्या निवारण - सामान्य समस्याओं और कनेक्टिविटी मुद्दों के समाधान तकनीकी प्रलेखन - I2P प्रोटोकॉल, आर्किटेक्चर और विशिष्टताओं के बारे में विस्तृत जानकारी एप्लिकेशन गाइड - I2P एप्लिकेशन जैसे टोरेंट, ईमेल और हिडन सर्विसेज का उपयोग करने के लिए निर्देश नेटवर्क जानकारी - I2P कैसे काम करता है और क्या इसे सुरक्षित बनाता है, इसे समझना सहायता संसाधन - फ़ोरम, IRC चैनल और कम्युनिटी सहायता के लिंक सहायता प्राप्त करना:\nयदि आप I2P के साथ समस्याओं का सामना कर रहे हैं: 1. सामान्य प्रश्नों और उत्तरों के लिए FAQ जांचें 2. अपनी विशिष्ट समस्या के लिए troubleshooting अनुभाग देखें 3. I2P forum पर i2pforum.i2p या i2pforum.net पर जाएं 4. वास्तविक समय में समुदाय सहायता के लिए IRC channel #i2p से जुड़ें 5. विस्तृत तकनीकी जानकारी के लिए documentation में खोजें\nटिप: हेल्प पेज राउटर कंसोल साइडबार से हमेशा सुलभ रहता है, जिससे जब भी आपको सहायता की आवश्यकता हो, इसे आसानी से ढूंढा जा सकता है।\nPerformance Graphs URL: Performance Graphs परफॉर्मेंस ग्राफ्स पेज आपके I2P router के performance और network activity की real-time visual monitoring प्रदान करता है। ये ग्राफ्स आपको bandwidth उपयोग, peer connections, memory खपत, और समग्र router health को समझने में मदद करते हैं।\nउपलब्ध ग्राफ:\nबैंडविड्थ उपयोग\nLow-level send rate (bytes/sec) - आउटबाउंड ट्रैफ़िक दर Low-level receive rate (bytes/sec) - इनबाउंड ट्रैफ़िक दर वर्तमान, औसत, और अधिकतम बैंडविड्थ उपयोग दिखाता है यह निगरानी करने में मदद करता है कि आप अपनी कॉन्फ़िगर की गई बैंडविड्थ सीमा के पास पहुँच रहे हैं या नहीं सक्रिय पीयर्स\nrouter.activePeers 60 सेकंड के लिए औसत - उन peers की संख्या जिनके साथ आप सक्रिय रूप से संचार कर रहे हैं आपकी नेटवर्क कनेक्टिविटी की स्थिति दिखाता है अधिक सक्रिय peers का आमतौर पर मतलब है बेहतर tunnel निर्माण और नेटवर्क भागीदारी राउटर मेमोरी उपयोग\nrouter.memoryUsed averaged for 60 sec - JVM मेमोरी खपत वर्तमान, औसत, और अधिकतम मेमोरी उपयोग MB में दिखाता है मेमोरी लीक की पहचान करने या यह निर्धारित करने के लिए उपयोगी कि क्या आपको Java heap size बढ़ाने की आवश्यकता है ग्राफ़ प्रदर्शन कॉन्फ़िगर करें:\nग्राफ़ को कैसे प्रदर्शित और रिफ्रेश किया जाए, इसे अनुकूलित करें:\nग्राफ़ का आकार - चौड़ाई (डिफ़ॉल्ट: 400 पिक्सेल) और ऊँचाई (डिफ़ॉल्ट: 100 पिक्सेल) सेट करें प्रदर्शन अवधि - प्रदर्शित करने के लिए समय सीमा (डिफ़ॉल्ट: 60 मिनट) रिफ्रेश विलंब - ग्राफ़ कितनी बार अपडेट होते हैं (डिफ़ॉल्ट: 5 मिनट) प्लॉट प्रकार - Averages या Events प्रदर्शन के बीच चुनें लीजेंड छिपाएँ - स्थान बचाने के लिए ग्राफ़ से लीजेंड हटाएँ UTC - ग्राफ़ पर स्थानीय समय के बजाय UTC समय का उपयोग करें स्थायित्व - ऐतिहासिक विश्लेषण के लिए ग्राफ़ डेटा को डिस्क पर संग्रहीत करें उन्नत विकल्प:\n[Select Stats] पर क्लिक करें यह चुनने के लिए कि कौन से आँकड़े ग्राफ़ में दिखाए जाएँ: - Tunnel मेट्रिक्स (build success rate, tunnel count, आदि) - Network database आँकड़े - Transport आँकड़े (NTCP2, SSU2) - Client tunnel प्रदर्शन - और कई अन्य विस्तृत मेट्रिक्स\nउपयोग के मामले:\nयह सुनिश्चित करने के लिए बैंडविड्थ की निगरानी करें कि आप अपनी कॉन्फ़िगर की गई सीमाओं से अधिक नहीं हो रहे हैं नेटवर्क समस्याओं का निवारण करते समय पीयर कनेक्टिविटी की जांच करें Java heap सेटिंग्स को अनुकूलित करने के लिए मेमोरी उपयोग को ट्रैक करें समय के साथ परफॉर्मेंस पैटर्न की पहचान करें ग्राफ़ को सहसंबंधित करके tunnel निर्माण समस्याओं का निदान करें सुझाव: परिवर्तन करने के बाद अपनी कॉन्फ़िगरेशन लागू करने के लिए \u0026ldquo;Save settings and redraw graphs\u0026rdquo; पर क्लिक करें। ग्राफ़ आपकी रिफ्रेश देरी सेटिंग के आधार पर स्वचालित रूप से रिफ्रेश हो जाएंगे।\n","description":"I2P राउटर कंसोल को समझने और कॉन्फ़िगर करने के लिए एक व्यापक गाइड","id":"c46f1b6edeab9b686fd57cf9b311df1c","section":"docs","title":"राउटर कंसोल कॉन्फ़िगरेशन गाइड","url":"/hi/docs/guides/router-console-config/"},{"categories":null,"content":" रिलीज़ 0.9.57 और आगे की सभी रिलीज़ idk द्वारा साइन की गई हैं। उनकी वर्तमान public key है: PGP public key डाउनलोड करें रिलीज़ 0.7.6 और 0.9.56 zzz द्वारा हस्ताक्षरित हैं। उनकी वर्तमान सार्वजनिक कुंजी है: PGP सार्वजनिक कुंजी डाउनलोड करें -----BEGIN PGP SIGNED MESSAGE----- Hash: SHA1 मैंने नई GPG keys और subkeys बनाई हैं और पुरानी key से नई keys को sign किया है।\nपुरानी कुंजियाँ:\npub 1024D/A76E0BED 2005-12-16 Key fingerprint = 4456 EBBE C805 63FE 57E6 B310 4155 76BA A76E 0BED uid zzz (zzz) \u0026lt;zzz@mail.i2p\u0026gt; sub 2048g/74C8122D 2005-12-16 नई कुंजियाँ:\npub 4096R/EE7256A8 2014-05-08 [expires: 2024-05-05] Key fingerprint = 2D3D 2D03 910C 6504 C121 0C65 EE60 C0C8 EE72 56A8 uid zzz on i2p (key signing) \u0026lt;zzz@mail.i2p\u0026gt; uid zzz on i2p (key signing) \u0026lt;zzz@i2pmail.org\u0026gt; sub 4096R/1AE988AB 2014-05-08 [expires: 2019-05-07] sub 4096R/01B5610C 2014-05-08 [expires: 2019-05-07] sub 4096R/59683006 2014-05-08 [expires: 2019-05-07] मैं नई keys का उपयोग निम्नानुसार करूंगा:\nEE7256A8: key signing 1AE988AB: email signing 01B5610C email encryption 59683006 release signing रिलीज़ साइनिंग की (release signing key) का उपयोग 0.9.13 रिलीज़ से शुरू किया जाएगा। यह संदेश मेरी पुरानी की (key) के साथ साइन किया गया है।\nzzz 25 मई, 2014\nनई कुंजियाँ इस प्रकार हैं:\n\u0026mdash;\u0026ndash;BEGIN PGP PUBLIC KEY BLOCK\u0026mdash;\u0026ndash; Version: GnuPG v1.4.14 (GNU/Linux)\nmQINBFNrjZsBEADMHWiucM8ES5VDfq6n4M9DJhMyG5jVoakzSFHfzVOEpHeDYR1E eaEIFt5CEx0mbpXWy6UBoj0E7o3se5RvF81VQQ4xO0MyHZLkpotGffZo7D34uKTd 1SFbirosXwnsOxjPGLF+PuwifV+mzSoE66XRmg5UJbOJj0ZitYBn4lDKMxU1Rext WX7D79qnJW2GXv/HuzTwZ/KV3fOVB782+fNdFBDZt4XHSM32ideXedTtTJ+FXjBv 1/eQ/Ls8PMYKaYUm/j0oTI2A5aNP+6BH8/NrVvF8xQWCibrOILASWFRJE7insciJ m9eeEPPOp1D4fRDWFyjABcn00fv7T7RDBgIdpuj3gBDvGXgx8SRiWxe9CwV9TcJl WNPTAKd9XGHT13XWwc1myO/yg+yQoJB6HO1jGjqxQuu3aHCw2i4gTHflq4qZoSDV oxJWeh+mNsfx4DgmoT1UeEmh2Uq64czMGh8wJC0FqSa+FmgCKa1FxcTnYlfIjR79 qwbEKK3JZ5PPkiK5Lh4hNvkXKLrUXpG1KHm6yNVPNIWCOMd7VCDziEhsbeNPCzQc 6af8dkyI9BUeQD3fGjeHCh/QHLju9Lde77GDddYaShXVI/Wiy4AWgN0KVUk8CnEZ Uu2JbazpJBLGGiB2CujP44eJzm9VPoBx8Xc9/Pk2RFbz2bN4uQtSD6lAjQARAQAB tCd6enogb24gaTJwIChrZXkgc2lnbmluZykgPHp6ekBtYWlsLmkycD6JAj4EEwEC ACgFAlNrjyYCGwMFCRLMAwAGCwkIBwMCBhUIAgkKCwQWAgMBAh4BAheAAAoJEO5g wMjuclaoxkEP/RQRz7kWfCWcDWtKSxq1zA3HEUKUHLxhBIl1C+tmMtJypyWwiP8Y hrO/Tuk8nsnVOl9wMMtz2ZxMpUS2gTsuquZ6pIUCNtEP+IAuKsZlCcsNB+yOoi2T i71cXLBPcN/rbxyoOUMpk+fJgdsustUnSMbXJQ2sLjieurD/YpUMJZw6KoNVrhU1 1nDaJqAq/zouhSvNMvx5+GBodQ41gvtb984xbrNc8B24upCBHSF1olczWYPUtaAi oMlZTNr5XFS//Q8X3sEKAoRMbAX6UvZVdtgqQajGilMg+HM3HnbPqsHoyPWx4f8O n134ITgrVwL24y+m9XHfY+JPjcBgg9uGLuLJqMrrjYfz7jVdUJQUsy/R2+yzg1Bm Ruf3SBhHpG2dSBOTxi9GD4aL/7wXuXj9uIuFtX80EwsT4XifnIaHTdtNNzVO+obF dJyiIpF1IFmFOTgJ3ba9gcILQIWXGIp1e5C8g2MtuYO/6/jZK1lhFCLbvhpA9C4q uUp6/WXnavd3beKltkzL1v2dOjC1EkjrsFF50olV4f3d56JdS7JEnFzx7gVeSQfF uLR/t22CluxzubcYoAk/hdIWM2Ufi6v6ONVWc7D5nYBW9onNRKEquA/qOHZr3C/M QbRxTYyhaMW4Nrwck9jmpcQBE1EzscX3DAr+3W+rnKDCZL5QuI2Yq5gkiEYEEBEC AAYFAlNrl+YACgkQQVV2uqduC+1XMwCcC24MIzSxDOEpX7c/ecTKm18bOQkAmwU9 WqqUgT37bQ+U9ME322JPrBsitCp6enogb24gaTJwIChrZXkgc2lnbmluZykgPHp6 ekBpMnBtYWlsLm9yZz6JAj4EEwECACgFAlNrjZsCGwMFCRLMAwAGCwkIBwMCBhUI AgkKCwQWAgMBAh4BAheAAAoJEO5gwMjuclaobxQP/0oU+/nhTx7NRUZ3Ay/LzD7v DHqX+A1iPos1Xzmz+vq9a7z/mjjiQn0wfFiMctFc5dRf+hSM+W7BUfcG5rML+416 rEgtCDsQ0KfaFYUPRObxxNRdDv4N0j6uw2hFmAZ+KkOxKf5Z5CV7A2dwpjsO+PSc Ed0BM1iAjzNbod5b5uAn6r/Z43GSH2omRdhE8Ne5UrH58kLFSg8+iAfnnV5SSEKo bkP0f5m91esbh+vAgq0nFRsB8PeBYklw20wnAkIy6rmKJngBpiF0KfC/V6NY3g63 NDqf4wbSO8WqnrS9QWqYFzJfDsARQvx3jBqLTcQ4SlpIVWKNeogkeSeuqCVKRgvN jWBHdfABkf+DHrzlf072PK8RtDZn6wn1D91MeFCvg+Ss6XV2d0JEd+bxdK6Aj1RR X4XGv0jcH1Ftm9JRNjzXsALzndvwvEKU2xgDA2LATA7ikKbIq19VoTf90uc7i1Os 6cOXZkezZatyuJzJITGeq4llek+PVFxU/5LnRLr6h6K5D0/5F9KlgtPJKgSDOipp TN1Vof8f+v1/zWmyxpw9jtkNjM9chtOY7xhQfNxQLZuHXjQtDT3+JGo6/gTqj105 Yg+HNTJjkDYl2Y5AHb0WFHUFSn2GiBtot4V/g2ojMeQIiw2a8v17H6HUZSKYBjgR L7ln7O4oBduvaSSyZE2jiEYEEBECAAYFAlNrl+YACgkQQVV2uqduC+3d7ACgpRpk 13FSAhz/RpPnqYwRSFUiQTsAoIewgMNIxgbPQGUVDO3FpzChAfUruQINBFNrj7YB EAC8GDV5JcAcktMYnUbPxpydlWSDzzBaDUvbOAtWbrmkwQUXyij0O4ZW1W81e0R+ APT26TLuqc6Q+v6b0rWlVoZkSKYaqzm0S3mtLWUvEgPjHfYXT7VaHtzu6QUPwmVa w+o8dxkbajl5C1i9CZyr8ACziD23FSPA5nd/WQ18EAbnIjnT4cV9dP7lLqZAWtzE Cp3ze4ZHt6kg5i6rhJBJWbycHAZK2SMclC37S6MtZAwW0pJJwn/qdj7UvmL72QoV qXNHe8dfKfnxzo0/HoCKn4rlIW0W3xHgqy6VQUnyigL0blrVmxzcH5bgttXr94yh MVV1Kg9ie1GfhPf1ui86NnGHczbZB2TmTc/d2Nl1/L3TwxiWX2fv9BF+mVczRiXc 9FZRTF5JsBN0BAyxIE9vDXK/yygiWRSD1ND/0eTmKJRqOplpXoCBSDCsfvFN6/63 mx70wP92bNMmDZ/zbjFApmbMCjf+0wCZljiBtkNgT4k2nOYjb6Kt+vOeEg1XBTqo WREHEUA23xsu2DMH5Ra0OA0NwA9jrp1dg4t7fKIkSlBLNlIsZ73lNV21uuA8lVFR KHRX7y394c5/T9c8zPtJSmIZnAY52KXBFfsM3h+ExaQIWclyU375kYi0IBE9tCfF 7VuX1JgvA/9SjjtgfEWWLkhkPUAUl82e8SYQRx5Ki3RIvQARAQABiQREBBgBAgAP BQJTa4+2AhsCBQkJZgGAAikJEO5gwMjuclaowV0gBBkBAgAGBQJTa4+2AAoJEA6+ gRoa6YirbtsQAKheBU6M3oAfyAJ7i13mPEY2EvZFXdY41ct89ebdLCe4revG5Tao Fj/OmD0W+eBvRbJvOglw+0wYjpjAsnl95kYCBRL/BAr9xWt/g9SCcQqxOaYI9gM0 pFAcPjicEF44xdSMDSWGpN0PT5M6omlz5EObxuU3vaZ8y2XWYdvW8p1AwST66y/M AoACZqJUsIo7HIsz607XzNa3evIkCuGGNbTrD0OCTNUxOhwtqMIt3bHE2h4I8Hwp hptTf2eDf2z587/32gs3yp/VAeP6dCeQF3+Wduc41aRsCru7HnE2w/BiW1nzePyK 6b3RA56bZcbANIS8k/+EVOakS4uRDnweqkwBVgkWsCk17+XNeIaRaY0pWJaFs+hO f7cdp/XK+z2eFO1brEJa3BmnHHMx/lUv5YS8MgD+CcdvHvb2dirthzvyb6yDKFNn ZkMz3/Z1wnlDkMp/fjJAwXfmKT7IOqPVN5fpLcXp27Jh2BSrafvLupkIzZhrGL7R hTg8X83rLuQ0ZSn8k9cFju1pECI1atXC/kPMlSC4VffoViqwSZDLFsniFSNTaBOw EfKCLxv4s0BNovaUQfY2DUkL2BHrU18HbpGkaD3Gmb6TnzBYRTWSz15/9w8cjOc9 rr9d5SZaUeMZkGmlUdEG5q43b0MwQxYSA4Y3ZZGMgbjzEa83YN2njV7U07MP/1C2 D/tpWM2SliCGQ9ioPZVnwB43sme7J0GWjLRR085Q8+4V3/buWNG0UBc+l3MNlO0m N/zPp8ZqKCe6tLIXiExgiMSfcv9/7G3AgKxfzY+t3wFC6ISZiG5JFQIx/NI6zR+F RPUXUf8ZWH+i49p3UY564wULQMLobMuxhO2+BkjZKPkHAiXB0FTdP9WW/Gt2vWgZ L6ogdmo2bo2BQCU0VOOlCp8MxL9MlQ0FGURT/2kGoFzNFUo63UGvJc2iFmICI//9 OGBkpEMuPGrZI9W/4NTh+yMYj1b176IssWU2PWvhpempaXbcgXnlZQ5x6qcszzrw m403O814RLkIljRdtjHWOJKygXpjj8qTbDFfLXWDZ6MTtZOgFOPHFpc+Drbyzgu0 Z3dpXBeoyXQaZGOtClVJTCUYMjE6AaWZrnvsjT2TSxK+oy4XXzI4vVvDMJh2Ibfs YKiRahGQnBiYEMIrefoj/wu2GaZ71y8P6tCfdvlv9DikIVTHajdG4G2K7Sr4glgk cB9M2IsSy7bw2OGrGFvkpqriL1aYvIF5Wf4KIsxpMZ2FIUeGP4YfT3ec7zfSC5bp /yBP8J/XXaCV8NkhLF4bD9tU+XRRK54LZkoDrJwmTreHknluF6hFuJl8d0+oHyjp kHp\niEYEARECAAYFAlOB3xkACgkQQVV2uqduC+3+UgCfYZiUtx7FDGdQDhdVP8MyRf0D ANIAn2YHOQh4yv84u2Kuars1gC0j3Nr2 =Zu9F \u0026mdash;\u0026ndash;END PGP SIGNATURE\u0026mdash;\u0026ndash; 0.9.9 से जारी किए गए संस्करणों पर str4d द्वारा हस्ताक्षर किए जा सकते थे। उनकी वर्तमान सार्वजनिक कुंजी है: -----BEGIN PGP SIGNED MESSAGE----- Hash: SHA512 मेरी वर्तमान सार्वजनिक कुंजियाँ निम्नलिखित हैं:\npub 4096R/0EC51FCDA94FB53E 2014-03-11 [समाप्त होता है: 2019-03-10] uid [ पूर्ण ] str4d (http://str4d.i 2p) str4d@mail.i2p uid [ पूर्ण ] str4d str4d@i2pmail.org sub 4096R/1CC61D9B33C3241B 2014-03-11 [समाप्त हो गया: 2015-03-11] sub 4096R/803DEE491A3473E7 2014-03-12 [समाप्त हो गया: 2015-03-12] sub 4096R/A1B84C9B733AAC82 2015-04-05 [समाप्त होता है: 2016-04-04] sub 4096R/13B5EE58C09FB3E0 2015-04-05 [समाप्त होता है: 2016-04-04]\nमैं वर्तमान में keys का उपयोग निम्नानुसार करता हूं:\nA94FB53E: key signing 733AAC82: email encryption C09FB3E0: email and release signing मैं प्रतिवर्ष नई encryption और signing subkeys उत्पन्न करता हूं। मेरे द्वारा हस्ताक्षरित कोई भी I2P release हमेशा रिलीज़ के समय नवीनतम signing subkey के साथ हस्ताक्षरित होगा।\nstr4d Nov 20, 2015\nवर्तमान keys (उपरोक्त तारीख के अनुसार) निम्नलिखित हैं:\n\u0026mdash;\u0026ndash;BEGIN PGP PUBLIC KEY BLOCK\u0026mdash;\u0026ndash; mQINBFMfofkBEADlyw6v1hGBtnIISujt/18RJcVTLAxYtfe3DsGhWqYZN3iKGGWb NJ5vZcV65FVH/70NFnmKlvYp+tVNJcoRtEYpfwiNG7nIyOC4GgaSLwkNVgLcFZhV mNj2RIJphjN5qsWm6ut9p9CyhWkVNJYDP65gqwShZQ2lPboo9s0XjUF78SrSshy2 iVij0xu6oqdjwqn1B7L3lXVYCwxReCvSdFnBMpjGUEgGnbt7euhrViFk8FrUkAje 2tZA5FAUA/t2Mnc9JREe6WlbZ44mLApOjFdw0g415FdcnS2GGaYuXNG1lJ1yOA33 n9JXT7A31wPyiw5yz7fxgl7ZNYZr2TsRjBlqEhf2SCPfqU9UlhJ9NqApaPyCEr+8 oZQfZ9r6stc98MlnmdQ7p4SmKRwCLiBtgmrB8mbgYV+iOwaKztqEoma3FoO2EJ+j Gx+UrJ0bIFVr6sL0ulfneYlY76wWWRpB/pLLgIMmZw83uB+JDBQyZFXcAHj9jMQ7 ZNn0MNQ/I+qcmX+CRAyl2+cQHUVbbQWDjB3crZlpK5TGw/x7w0YxBYAH8Us5JqJH QOsact8ADnE4IiKm5gVefFmNX6vsljkNESdpAMxnB7Ckl2XV/r5sKwrdxxUbFSxp IKGx2uKGUs4oUffOzpKULhGBWypN+3fVwvP+q896Il9hgyx6SCQ8AgPHRwARAQAB tClzdHI0ZCAoaHR0cDovL3N0cjRkLmkycCkgPHN0cjRkQG1haWwuaTJwPokCQAQT AQoAKgIbAwUJCWYBgAULCgkIBwYVCgkIAwIEFgMCAQIeAQIXgAUCUx/ZQgIZAQAK CRAOxR/NqU+1Pk9EEADHdpsmrA6ZKU4EmBZNbw62D7tAo00Fh25m8OuIkXtOqEbF /guTZiZM4nbhZpPFG9sCN1bXS8VslA7isOedbznkKnSK0BJcrzldwKzW25cwptoQ CCqTUarYbhcIzEOKNetYqICWrVTy2Yuc37maA66PnRLphV7pP3Fj7eN6aMtqwtpJ YukIU4LAjKOMJ6gwy7tjsZYbAqgSE8wRJm7i1MfO1W864a1l2a68Gooz03NC6mfY J8aW0y1F87xMJIgZeN7OyHf2AC4/Tp/cL+Gd3HcUuoRjmWBgaxH8tVNgfxSIUMNH 5pTdDs5VlRolwlOEcTW5VxOSu5C7ZbuKyFmbI0DSevDVGS0rxSSizjlyGmnxkLU1 ozpeIwTbwTUzvd26+k8cidGodKqoNoyAXzjaiBXYKgIrVeXBMHxCGeQtGeEhQR+L OXs8cEX6xpt9g7nKbNki0Cfv/lx9Byn+0v9RvMJKDa1mOSKbNOx3NJ8+ewdTVkTs iYFTZwpJexbfovPYqTdisiO7dv0i5teE8sEj25icdPtKYvn/55JCT67E8MVZaeyU YOaMPtgsiOX0v68NtrC1L37UuBykQlm7FdobN4Sg5FnLTt4IWktf0/vsaLdhRozD KsbTmsumCrScAwZfa0H3S8WqK6yCEKjPi+J4xG1OZP1WptlV41wLnFKkeFaZRIkB HAQTAQoABgUCUx/Y+AAKCRDV3jiWlKRlsmU0B/96eiPHIIvapoXKoZSt23OFjXG+ 3xp/Zzf2Ug0384FYZJ1eX/R2IWsh64CVvOR0LMFvHvPU7SCMu2OreNHfPx/B/kn8 MmusGy6JHP25A4BWzs1eeyKgYQTFz7vSCeAnytmcdBot1s099upIRw4usCLhdxzv Qyx6TogAacGC3YFj7o0agz+ApPnCQZ68kZpDOCDrtOe/DRted1LLXM661Cp15d5R d+91ZSKfQ9xjK1d2k8iMYJqWYll50DalGtzPGDB335gX7agliI5dYiu2XSLyynhw /7f8d0Bz8KVj7pgCroAVjTSdHvZfVcZJU4HST/jHx5hilVUzkr9NK5YONJ8SiQQc BBABCgAGBQJTKlm2AAoJEPvivaOtdGgqmGAgALl0eAcUSF7IuloPT4VyJeNGMuOb 7aN4yYrGBM+y7Ij/dTWSS1yjlcixsqd+s0dqGse6RtJkyhkisEmNdS7Sf62okGDl ZbmhjvMQteUO1zw+CREdfx5oMpW/eCHq/Pzw8KRdp6qY0wBRj10GFMAaMX8XCNOh 6B6Ti0AQ/424yEvcPpA0zXwvLGylFozRxjK6qWEHEmW/+knxYYN/W+8TERuwVJSN F3jBYl73DTVBZ4bzpu5jMSydhRD02nV2LbnolhbCzGllLkhQw6iFW36br8600Tba loQhcJU+cmuCId/B6xXcF+fyWqmMmm+b0UFoHGRBnXCf4gBcjCK0UwJ1lUOTY5qg IYJTrBpCrGAoGTd9s+1CtnnZFlIcwFJB7NwMZEsTWvOvO6sZPYP33ktcUwWAKqNj 3sSjy43kdfUeVip0jzV0K5uStC+DiVq8VwH7uNIH2UbkQZato67WgShUCCaSvf2p HapSRdrmwIaoANQuEluhytdafX7yqJXGkhYI0Ylh2FH3oZyTnz1XoB5y5T1OpFpi I7CgjRO677aieRsf6HACHPX5mWcq8zJQ8fuxoHZ5GJ8FEyk6ULUgFJ3u9SgG5k5I vP4pK8+lP/d90Zf98Uaq4aMgAoIlrtwz68Bv/KUlpwVWhiIgo89C5UwcTUNQOmi3 0PxCpamM81NwGPxjZAqr/+0YP3NBtJOITL0oqRCxcHCJ9N8gmqUmUEgEffP+glsJ p/mQeJEacmR9loz6WAB6GT9mu5TvX6bZ5EawnluQ1mI6Tn+v6ltjhKzPzaVhOo6d iKriQFZhcelX1qDnE3zs7driBeacuKGt4URV8A+UDGJBeIAEfrlszor3FQ0qOUPs plbcbB4YudUOhlH1REtGx7zWVFefuy80ZC7abHsPhWkJow2axWlvPqjSsd/KgpjG IAHIZxiYAozNJqDNluGx1+qa1d7/YINthZKefhkG3XDLuhgxvD8rAovyAFW/8Vy0 S+GpzUVtC8HY9FZf2gRkVtZQGboZck2uFyIaU/Ni4ahX8Z9IvtsU9JPLzp0HRgAv 9kz9EyRZt1viueeIVcmadHirUe1IKqndeslcXOX4dUF0nrqP1+shYhebgq93rMPR yH3EsoXtAP1KCN8tWPdnlDnMY0Zpy32mfCL0hMMnH+CY5rARssSbiFP9HeWk/CN+ yES7FY705QmV/2SV4rEngqnIcrcqEJFp49JPihC1pSikHCItzSVFaODbUl4qhTjn Tjtl0pdFQc9ksA/6IEOH/bufDwtxCLwAjUpqyNGEH/8FnxtwotsTmhmTWMe9vxYe YStdTLkAvJFMVEU0W+H2ZZG481P5/8tqFS9cHEU++3VvuYxfipwjpIQhm5WJARwE EAEKAAYFAlMuEVwACgkQq+DDGd8KChpPGwf/QL66k12OzqI40KQL+UbzW25vxbmE OyZ1MT9SuUVt6Th9zdoNm9Cosi9kOiq+DPLFFT751Lmm1hcM0rDDNeN+l8wpLwX9 EifD/bQ7Q5esM8NJmGVyhA/Cd3wkp5yYNdZPOu9/0xpe/Px4YgficRErhgyVh2Vs svQRQ0WcTYbgbmQFpOUsjNVOchJMFERSJaQxWgN3olYd5DTDxPDLztt3vdBCIkz0 4OAotZqbqdnmvlkjKjzrJylfCkyo9bOU471v6Hs3mfUQXo9nXC9zGETFWsvB4WCC QdWEyj+2K+PcdZU0FEPonfTouVcsR9oTqQqqfg21M7HUHSmlrOyCLqNnZ4kCHAQQ AQIABgUCU2vk5AAKCRDuYMDI7nJWqGIzD/9vdI3uUUYGCaURAprGEo4kk6JP2TcS AmyO9Pr8bBdpmt/DVFK0zWllQ+69QAWLFoCmgjOgWUPRNWA+ldG5lzExjuuP38P1 4HupPMh0yOd+QUod4Gdi+hqPCuFT4/oErWZcOGGXAw4ZcvdEGKY9E975D+3yd7sG HGskvGB/UmLIBQ2XfQOoqk0A9eXz55wLN1ia1imHd/0NkPkQOHkjTdOtHhcBhuoc ttex9HcmYy2g5oorG+7wx0EtHxIhuCcRq1wQgXm2JtbiFHXiH0MpLfBr29kpzH7y 8jompGgAJsK8uRwTC8UFWHnx0VxnFQ+4vinqlgj7/O+WMZ/siDlOZDo2RC3ts+Ct 91kYNFHsycrkJYuoPzNcMy7mmixQFj5L2VIG1Ne3OTdEPVWE5jIQ/w5IX0aYxNt4 ANIZJA/r1AqDqDEhto6gdnkrVZSJN+Mvd7yj7XTbrErpTmQeNkGgb9ult4XaEOdm bjAjE6rTQqFD3Tn8SeXNgkJFr0Zb8lZypmOL6cxU4vTG66blJPLZGuaH3yCrtA1i ynZPrV2TYiET+fhg2TBEXbjLkWHQnA+7sFFOTgK5WOqc6vK29h5ssEQKIFodDh4a e88tiGLW9lSc+YWRpKHgEc8QDXIuBrV18hZEvbITvLZnnf5uIFXJV5ZCHG+o6I+Y jQrPY4oC2HGrMIkBIgQQAQoADAUCVRRYygWDB4YfgAAKCRCFZ1M6Yr7+XbxwB/42 Kbk6DpZueEK0qtdoLUh7H+dWfwA0Gsh/vCoS6RM9iXjKPBoQGlbCBpsBpqCJkGd/ iXH+tnkU2dq4BvGc/igSHadNYmYq077l1vu3pJjDjxfQ2qZSF9D27EUzlXLd4Q6s hysZ18HoTehxr3AG33N1tEm9kBUfZjeMZxk7zbty3Lo7tK/UYN+4mIgYqLc97XIe 40Z\niQIcBAEBCgAGBQJWT6iBAAoJEBO17ljAn7PgnxIP/RevbXaCm2Q3ildI0YLjQFDr vSIGKsCjD9nZY3ETk+CNFGOL4aYWp96HWuQoMq7B6qlb/sLejN/Ssu3M0sxf2hNK pCIagZClqRchSBK+0UpAEIs98sf0sPakqKg0FlOJhuCsKHMUOxpQJ4qCDh6f24b2 cqKR8GjyUAgSeiiyN+DkDyqRYingQGAU5vzKepYzX+DMHC/izqQhrwQLVImv20wr 5pKZJDjfOpYUZRTuScV5Qwcgc0JYcMOjfgA93ZUA2zDrGIpw3dcCSMrpNQcvM6Cg 1mfiLZzkvPH3UkUOWhHCn/N2XaAF58joCaS+/bVUaXx02IbxJ1TTjqtCiH9491mE aaHeRCFYbkKCXWjuxCx1+VZN2yRk24rSkis/+LFgZm850fXgYfrqiyPRDlCMApdo 5JDUBTioyZz24vhqWpe0OZueu11DXtpU1G0BiheGrweXAAx0Yki8dRiPTXkavAMj oMBND9G7a1564KOe+t6V2qUyH50+3NaANvIiDJZbspX7yl8eVzPbwcGvtHzmHdnV pDh+38XUQEID5YJ/mdZh6evzmmTnQR1HVqPVrzs8SwIDO++tqj8DXTjID47c3VIl YhCMNlucciFxVn/sYI5qiJzCEMLMbvG+EhnoLNU4JGjfzo6I0RCpPfbrDfOsWJNi zYMz9htqusCQsGwUZSTZ =XBC5 \u0026mdash;\u0026ndash;END PGP SIGNATURE\u0026mdash;\u0026ndash; str4d ने निम्नलिखित रिलीज़ पर हस्ताक्षर किए हैं: 0.9.23 रिलीज़ 0.7.6 से 0.9.12 तक zzz द्वारा निम्नलिखित कुंजी के साथ हस्ताक्षरित किए गए थे: -----BEGIN PGP PUBLIC KEY BLOCK----- Version: GnuPG v1.4.6 (GNU/Linux) mQGiBEOjTnURBADegKKrIP6pz4+n57dqo3l9QrKhIklCtIxgJkL06ZJq5fKAnMLv GPaGXmn5vRrbo6QzHs/lGLG+ySWFWr9SsVstNKrwk+F1yGIERutl0BqMwX1esfN2 ugiZ3wB1yRu0PIrkm5cuDAFASFE+2lBjr1lfOrhw/dV+lLTcWx4NzkMzlwCgxgIk 4cqQMGaVkmtuICQdYmmMicUD/AmNSVJEm2XUvaS5fYWsHJG3+oNkdNGcx5SOMUdk PFwcSozqvT9FeIP76OVHAshQKeftE3utOFANQ/YomXEnypmwMxLLR+GPw5pMbKlK 6p+87aJZz+SA95E3ekmh7MmndvRd5RJDboUZy2H0FKX+FgaBlpsLl0uhT6uDuM/s 7nb0A/9nEAgICOU5SeXtO3jKY+RQvKyE0AblK7xVaU+Sn8ly0zauOJD13rycVGhu vLcAUVR3FKEjxafpvZ0ZPBo7AACjSDqAoCw/s/vt9gmrhHKiqN31PhYYLhKdfKTs 4LzWKTWKIAOwErkbYsMAXWKFT3LXsrEYvxq5j5m/6zMOwz2N7rQYenp6ICh6enpA IDx6enpAbWFpbC5pMnA+iF8EExECAB8FAkOjTnUCGwMGCwkIBwMCBBUCCAMDFgIB Ah4BAheAAAoJEEFVdrqnbgvtxGsAn39SvQ3+ey87WDDG+TWArN6oU8gnAJ4zeAsA LUK37WZIt8OImZSxk37uQbkCDQRDo06VEAgAy2UeqsM5a+U6ZOWS9NQiILb3KbTL FeeAd2rn9oLSLpn5gDWycwUS0Q62JmbSMWy6m9aczpnxvwaBYXz6aCIvZmTNtaU6 vyR/6wfJDyiUWSHtCyjpyFFYJimANd8Y8dDCimvceI/ihEDVyBX0kkgUGRAn8t3e unaLXqhbfiLiFw/GG1MNxUMzHt55/+9AqLOfRZg0riZvDoV79K+1sYSs8n1WeaVc T3wTb+Cb7fKNN7GT1MUhcXIoYYY6FGwsy5EWFsxYBRervqHtBJog2SoNUa/6BFGr zX+LDjK9L3xMTr3+fHIt4gPR/Lt4nnfEzL+rjClz/Fazmv38BRwPuKahFwADBQgA nD/AvZCnbWSB6khAVMqva5ROaD0gV0/UejCelZdYfgfHeCmrcMNQ+wCyww2NPsih 9vB1w+AUE0pdH37k65VZN+2falUdzN+PFugJGuH2pmlVOprH2SuC5gKpGRvzUqV5 U0nJmT2okDpW/52asUDJJLu1g//A3qBP83WGvSKUZg/ZisZA0qTiHH4QpjklopXi sSxR2hT8Fr9gF9WmDa09wbxE2xh/EL7gvVg/vk0gwOJcsFd67bNC+KUMOnjhOP0T K0/Ah4TEEs/hHNe9RsyyWlMoIUsF8AhG71ISOrJ5lLSXNe151XEb5FzZRM8sD9Zq 0E3PjmLbdVhanYvsPnWK6YhJBBgRAgAJBQJDo06VAhsMAAoJEEFVdrqnbgvtXTwA njMu9ueCFbsjme7nwsz96PdazJcHAKCce17hGI25QNXDZyHohrjha6IxDg== =fAfi \u0026mdash;\u0026ndash;END PGP PUBLIC KEY BLOCK\u0026mdash;\u0026ndash;\nरिलीज़ 0.6.1.31 से 0.7.5 तक Complication द्वारा हस्ताक्षरित किए गए थे। उनकी सार्वजनिक कुंजी है: \u0026mdash;\u0026ndash;BEGIN PGP SIGNED MESSAGE\u0026mdash;\u0026ndash; Hash: SHA1\nनमस्ते,\nमैं प्रमाणित करता हूं कि नीचे मेरी नई सार्वजनिक कुंजी है, जो 2007-11-24 को जारी की गई है, 2009-11-23 तक वैध है, और इसका कुंजी फिंगरप्रिंट है:\n73CF 2862 87A7 E7D2 19FF DB66 FA1D FC6B 79FC CE33\nयदि आपके पास मेरी पुरानी सार्वजनिक कुंजी है, और इसे सत्यापित करने के लिए इसका उपयोग करते हैं, तो आप देखेंगे कि मेरी पुरानी कुंजी 2007-11-15 को समाप्त हो गई थी। इस अपडेट में देरी के लिए क्षमा चाहता हूँ।\nजो लोग इस संदेश से सीधे key को कॉपी करना चाहते हैं, लेकिन इसे e-mail प्रोग्राम का उपयोग करके नहीं पढ़ रहे हैं, कृपया याद रखें कि public key block के शुरुआत और अंत marker से \u0026ldquo;- \u0026quot; escape sequences को हटा दें। अन्यथा इसे पहचाना नहीं जाएगा।\nजटिलता।\n\u0026mdash;\u0026ndash;BEGIN PGP PUBLIC KEY BLOCK\u0026mdash;\u0026ndash; Version: GnuPG v1.4.7 (GNU/Linux)\nmQGiBEdH5SYRBACzCum9jIjq+/G7ckuZ/TcFmaVYeBRE6OXPQozyrmTYtoCM2qGj DmvMJvKYiNiQVM42KiwlnqvaNtlgnXIZ6rcyLyn+bCI5cdX1SD5Rr5tgsgcXYA6Z l7usiFv1bTjD67piBehF130o+LZAJnVzI7JdpbA9SBY0mUwgKXLi0DAo8wCgiKOV UXC8+9X9vU1Mh/GyIrD4c3kD/iQOkYH4ajNaehTHNB31K+61ltpK9tMmcWtUY30A Z3q38jg/nmqqup/MYCtkvOqY4X9kujKzu01eSWSNZIE+BQSSd1cSsVD17OY3TL6B EvE+UFxh8OnDKs3tzJ0COnT/2zbgTavbWwqovoUE0P0PSYOFm2Co0BEQiCt9Tabc CxU3BACRWDvq7LFMRnHT+/OOJS6M442CYzy3+tIuc3ZAmZ8QwGsh4r1kd+5P1JTN YJCun6MPQEllJbRyHRBby76vFkWearRgnkpAmk2l1T2SXw3lip/SdmI0GgIzPSfQ 8WyNbMjQXyH8/3k2Y9rgrC0DttrJPYOcTFMNKPpeTR+HN3ZnibQ+Q29tcGxpY2F0 aW9uIChodHRwOi8vY29tcGxpY2F0aW9uLmkycCkgPGNvbXBsaWNhdGlvbkBtYWls LmkycD6IZQQTEQIAJQUCR0flJgIbAwUJA8JnAAYLCQgHAwIEFQIIAwMWAgECHgEC F4AACgkQ+h38a3n8zjP1yACfWkF1zjmlD0EzLaJRnefW5OHr10MAn0fgMyElK6ee AoPl2mTfxQQYOophuQQNBEdH5SYQEACTcoMJQBhyrr+EunLmEGNMO7D6RSBAtEKZ i5ctmhr/TCXMV9qjXkWISLZ9AS6z88rKozeOOK+QPBnc2FcEf77N04O5hwSdAyPH Qt7+umhiNQFQpZycJ5W87Y0ryERJygA5XyU47g7CGvuuOLgKGk0dDGCNFZGSblwI xtSh1CsrjWp23grFiBS0xvlU2VyuYUyrBuH5ip04pxmOyeRcaelkQerFhEXSRIR7 XFxl6JpfqWt2oWHmYbYD3RT6WHU+rpSF1Hyey+zoF2zXfRb+JD90MpBL1xIkpieQ Y69Cj5U5VRjEppJJowSmwgz+UyMnT2KLl45vJesPrMUaSgduHiIQo4LM5BcbbV+2 SC5i9xqbSJ+rc19Ftt9IEUZVMLole9PJC5Ff/h1qsabyueFuMIQkbiaUiNLOKl31 I+JAiDt0Xku2PEVCERg7Jq5AsTLB9D+zKqxbvFu+JvqSdlaCvlas2BYU5rBosszH TStK2XW/+poTKnjnbJl6nGC06BNQPhRFAwuXboyUC5fyiuG1HohvPmPIi6IejLUY G8A5nZ+7um/XpKlt2i5rdVRfN1BX3+aKHQeLmrc+EIORZUU32TrP4ceLtSDf+JOW 8N3vwzqKIPu42Y5KB8vnXEFSOkyt36OfEd6CcPKmncDyA4wJmfC+X3eoKcj+Yrh7 UMr0elyw4wADBg/9F7g+bTpT4wPXj5ax1i+4BdedjVlO3YBdhc4LP6MXipNU6yLl l63TJ8q/l8pvSkUWZXrO3a7OibM/MHp0Te/7sTmKib2/3MFwHTrtjgcZBF6wx8LD T3oa6O0IK8IRnRwNqeu83SxojvVY0wLz/hpUbnIrOcHMZjWLMJEfHkNBHn+1HhT5 tk9LRGu3j1oTpGh+DpdoPF5fggNu48YJ6n7etJJGW2MXQ++33aKeQSFrx+KlMtFW DSzg3KKSroB8Ex9wiKKWybagaed0YoP9BW3vIAaOeDpqK92UuTFz1Bte1DYiYU1e Rqq1xoBVhJXE5xzGmvS4/PIZMOL/bpKcuNxAgmwOVoaYoWZuIgePUaBbNvNg84HE RBjFMyfpzRCdPlWPZ18KcLUki3T58KzXEZ7WS5hC5lezwC6ET+wJusAt0A+Ik146 igayKfVnvhedQdqufWhQWNr+hDc5Fb/az8nTyNOflAhD3yHldjxgkCOV8wjqyS+4 iO33P5wW7o2QkZNWq8pyjsKRRJCtZ/PJ7FRGkUOjoC/gwhnGvBi0KoDcyBmfnPXp 3MAgrzk9LwiA7PlS7PyhyMx5mYpa90xlXzszweCIXzGfbm6ciCUAM3G3Qb+qa2dW 0u1X5L6bVtHVpYnr+5JOxCS4qwQvoK0QnHu6ezu4+rFutUJN35z6rFquejiITwQY EQIADwUCR0flJgIbDAUJA8JnAAAKCRD6HfxrefzOMzSZAJ9PmYNkW4Ia1qPqowg9 z4Ja+hJ3dgCeL3mqvOEHG7AcUQrSlc6xlC1vbNY= =rGxK - \u0026mdash;\u0026ndash;END PGP PUBLIC KEY BLOCK\u0026mdash;\u0026ndash; \u0026mdash;\u0026ndash;BEGIN PGP SIGNATURE\u0026mdash;\u0026ndash; Version: GnuPG v1.4.7 (GNU/Linux)\niD8DBQFHR/zm4tLxqYRsGn0RAtCfAJ9rz+tsyEbeUAHcogdzgSPfuiWOAwCfWaVn Aiib6V5wOPbYTy13ADmxhfE= =mPFq \u0026mdash;\u0026ndash;END PGP SIGNATURE\u0026mdash;\u0026ndash; ","description":"I2P रिलीज़ को साइन करने के लिए उपयोग की जाने वाली PGP कुंजियाँ और उन्हें कहाँ से प्राप्त करें","id":"ae494d28c5c0216d277398ccdcc21df5","section":"docs","title":"रिलीज़ साइनिंग की (Release Signing Key)","url":"/hi/docs/develop/release-signing-key/"},{"categories":null,"content":"यह गाइड दर्शाती है कि सामान्य ब्राउज़रों को I2P के built‑in HTTP proxy के माध्यम से ट्रैफ़िक भेजने के लिए कैसे कॉन्फ़िगर करें। इसमें Safari, Firefox, और Chrome/Chromium ब्राउज़रों के लिए विस्तृत चरण-दर-चरण निर्देश शामिल हैं।\nमहत्वपूर्ण नोट्स:\nI2P का डिफ़ॉल्ट HTTP प्रॉक्सी 127.0.0.1:4444 पर सुनता है। I2P, I2P नेटवर्क के अंदर ट्रैफ़िक की सुरक्षा करता है (.i2p साइट्स)। अपने ब्राउज़र को कॉन्फ़िगर करने से पहले सुनिश्चित करें कि आपका I2P router चल रहा है। Safari (macOS) Safari macOS पर सिस्टम-वाइड प्रॉक्सी सेटिंग्स का उपयोग करता है।\nStep 1: Open Network Settings Safari खोलें और Safari → Settings (या Preferences) पर जाएं Advanced टैब पर क्लिक करें Proxies सेक्शन में, Change Settings\u0026hellip; पर क्लिक करें यह आपके Mac की System Network Settings को खोलेगा।\nचरण 1: नेटवर्क सेटिंग्स खोलें नेटवर्क सेटिंग्स में, Web Proxy (HTTP) के लिए चेकबॉक्स पर टिक करें निम्नलिखित दर्ज करें: Web Proxy Server: 127.0.0.1 Port: 4444 अपनी सेटिंग्स सहेजने के लिए OK पर क्लिक करें अब आप Safari में .i2p साइट्स ब्राउज़ कर सकते हैं!\nनोट: ये प्रॉक्सी सेटिंग्स उन सभी एप्लिकेशन को प्रभावित करेंगी जो macOS सिस्टम प्रॉक्सी का उपयोग करते हैं। यदि आप I2P ब्राउज़िंग को अलग रखना चाहते हैं तो एक अलग यूज़र अकाउंट बनाने या केवल I2P के लिए एक अलग ब्राउज़र का उपयोग करने पर विचार करें।\nFirefox (Desktop) Firefox के पास सिस्टम से स्वतंत्र अपनी स्वयं की प्रॉक्सी सेटिंग्स हैं, जो इसे समर्पित I2P ब्राउज़िंग के लिए आदर्श बनाती हैं।\nचरण 2: HTTP प्रॉक्सी कॉन्फ़िगर करें ऊपरी दाएं कोने में मेनू बटन (☰) पर क्लिक करें Settings चुनें Step 2: Find Proxy Settings सेटिंग्स सर्च बॉक्स में, \u0026ldquo;proxy\u0026rdquo; टाइप करें Network Settings तक स्क्रॉल करें Settings\u0026hellip; बटन पर क्लिक करें चरण 1: सेटिंग्स खोलें Manual proxy configuration चुनें निम्नलिखित दर्ज करें: HTTP Proxy: 127.0.0.1 Port: 4444 SOCKS Host को खाली छोड़ें (जब तक कि आपको विशेष रूप से SOCKS proxy की आवश्यकता न हो) Proxy DNS when using SOCKS को केवल तभी चेक करें जब SOCKS proxy का उपयोग कर रहे हों सहेजने के लिए OK पर क्लिक करें आप अब Firefox में .i2p साइटें ब्राउज़ कर सकते हैं!\nसुझाव: I2P ब्राउज़िंग के लिए समर्पित एक अलग Firefox प्रोफ़ाइल बनाने पर विचार करें। इससे आपकी I2P ब्राउज़िंग नियमित ब्राउज़िंग से अलग रहती है। प्रोफ़ाइल बनाने के लिए, Firefox एड्रेस बार में about:profiles टाइप करें।\nChrome / Chromium (Desktop) Chrome और Chromium-आधारित ब्राउज़र (Brave, Edge, आदि) आमतौर पर Windows और macOS पर सिस्टम प्रॉक्सी सेटिंग्स का उपयोग करते हैं। यह गाइड Windows कॉन्फ़िगरेशन दिखाता है।\nचरण 2: प्रॉक्सी सेटिंग्स खोजें ऊपर दाईं ओर तीन बिंदु मेनू (⋮) पर क्लिक करें Settings चुनें चरण 3: मैन्युअल प्रॉक्सी कॉन्फ़िगर करें Settings सर्च बॉक्स में, \u0026ldquo;proxy\u0026rdquo; टाइप करें Open your computer\u0026rsquo;s proxy settings पर क्लिक करें Step 3: Open Manual Proxy Setup यह Windows Network \u0026amp; Internet सेटिंग्स को खोलेगा।\nManual proxy setup तक स्क्रॉल करें Set up पर क्लिक करें चरण 1: Chrome सेटिंग्स खोलें Use a proxy server को On पर टॉगल करें निम्नलिखित दर्ज करें: Proxy IP address: 127.0.0.1 Port: 4444 वैकल्पिक रूप से, \u0026ldquo;Don\u0026rsquo;t use the proxy server for addresses beginning with\u0026rdquo; में अपवाद जोड़ें (जैसे, localhost;127.*) Save पर क्लिक करें अब आप Chrome में .i2p साइटों को ब्राउज़ कर सकते हैं!\nनोट: ये सेटिंग्स Windows पर सभी Chromium-आधारित ब्राउज़रों और कुछ अन्य एप्लिकेशनों को प्रभावित करती हैं। इससे बचने के लिए, एक समर्पित I2P प्रोफ़ाइल के साथ Firefox का उपयोग करने पर विचार करें।\nचरण 2: प्रॉक्सी सेटिंग्स खोलें Linux पर, आप सिस्टम सेटिंग्स बदलने से बचने के लिए proxy flags के साथ Chrome/Chromium को launch कर सकते हैं:\nchromium \\ --proxy-server=\u0026#34;http=127.0.0.1:4444 \\ --proxy-bypass-list=\u0026#34;\u0026lt;-loopback\u0026gt;\u0026#34; या एक डेस्कटॉप लॉन्चर स्क्रिप्ट बनाएं:\n#!/bin/bash chromium --proxy-server=\u0026#34;http=127.0.0.1:4444\u0026#34; --user-data-dir=\u0026#34;$HOME/.config/chromium-i2p\u0026#34; --user-data-dir फ्लैग I2P ब्राउज़िंग के लिए एक अलग Chrome प्रोफाइल बनाता है।\nFirefox (डेस्कटॉप) आधुनिक \u0026ldquo;Fenix\u0026rdquo; Firefox बिल्ड डिफ़ॉल्ट रूप से about:config और एक्सटेंशन को सीमित करते हैं। IceRaven एक Firefox फोर्क है जो एक्सटेंशन के एक चयनित सेट को सक्षम करता है, जिससे प्रॉक्सी सेटअप सरल हो जाता है।\nएक्सटेंशन-आधारित कॉन्फ़िगरेशन (IceRaven):\nयदि आप पहले से IceRaven का उपयोग करते हैं, तो पहले ब्राउज़िंग इतिहास साफ़ करने पर विचार करें (Menu → History → Delete History)। 2) Menu → Add‑Ons → Add‑Ons Manager खोलें। 3) \u0026ldquo;I2P Proxy for Android and Other Systems\u0026rdquo; एक्सटेंशन इंस्टॉल करें। 4) ब्राउज़र अब I2P के माध्यम से proxy करेगा। यह एक्सटेंशन pre-Fenix Firefox-आधारित ब्राउज़रों पर भी काम करता है यदि AMO से इंस्टॉल किया जाए।\nFirefox Nightly में व्यापक एक्सटेंशन समर्थन सक्षम करने के लिए एक अलग प्रक्रिया की आवश्यकता होती है जो Mozilla द्वारा दस्तावेजीकृत है ।\nInternet Explorer / Windows System Proxy Windows पर, सिस्टम प्रॉक्सी डायलॉग IE पर लागू होता है और Chromium‑आधारित ब्राउज़र द्वारा उपयोग किया जा सकता है जब वे सिस्टम सेटिंग्स को इनहेरिट करते हैं।\n\u0026ldquo;Network and Internet Settings\u0026rdquo; → \u0026ldquo;Proxy\u0026rdquo; खोलें। 2) \u0026ldquo;Use a proxy server for your LAN\u0026rdquo; सक्षम करें। 3) HTTP के लिए address 127.0.0.1, port 4444 सेट करें। 4) वैकल्पिक रूप से \u0026ldquo;Bypass proxy server for local addresses\u0026rdquo; चेक करें। ","description":"लोकप्रिय ब्राउज़रों को डेस्कटॉप और Android पर I2P के HTTP/HTTPS प्रॉक्सी का उपयोग करने के लिए कॉन्फ़िगर करें","id":"a40410c542dc82558c1c1a8be78d2e62","section":"docs","title":"वेब ब्राउज़र कॉन्फ़िगरेशन","url":"/hi/docs/guides/browser-config/"},{"categories":null,"content":"मुख्य I2P क्लाइंट कार्यान्वयन Java का उपयोग करता है। यदि आप किसी विशेष सिस्टम पर Java का उपयोग नहीं कर सकते हैं या नहीं करना चाहते हैं, तो समुदाय के सदस्यों द्वारा विकसित और रखरखाव किए गए वैकल्पिक I2P क्लाइंट कार्यान्वयन उपलब्ध हैं। ये प्रोग्राम विभिन्न प्रोग्रामिंग भाषाओं या दृष्टिकोणों का उपयोग करके समान मुख्य कार्यक्षमता प्रदान करते हैं।\nतुलना तालिका Client Language Maturity Actively Maintained Suitable For Notes Java I2P Java Stable ✅ Yes (official) General users Standard full router; includes console, plugins, and tools i2pd C++ Stable ✅ Yes Low-resource systems, servers Lightweight, fully compatible with Java I2P, includes web console Go-I2P Go Experimental ⚙️ In development Developers, testing Early-stage Go implementation; not yet production ready I2P+ Java Stable (fork) ✅ Yes Advanced users Enhanced Java I2P fork with UI and performance improvements --- i2pd (C++) वेबसाइट: https://i2pd.website विवरण: i2pd (I2P Daemon) एक पूर्ण-विशेषताओं वाला I2P client है जो C++ में कार्यान्वित है। यह कई वर्षों से उत्पादन उपयोग के लिए स्थिर रहा है (लगभग 2016 से) और समुदाय द्वारा सक्रिय रूप से रखरखाव किया जाता है। i2pd पूरी तरह से I2P network protocols और APIs को लागू करता है, जो इसे Java I2P network के साथ पूरी तरह से संगत बनाता है। यह C++ router अक्सर उन प्रणालियों पर हल्के विकल्प के रूप में उपयोग किया जाता है जहाँ Java runtime अनुपलब्ध या अवांछित है। i2pd में कॉन्फ़िगरेशन और निगरानी के लिए एक अंतर्निहित वेब-आधारित console शामिल है। यह cross-platform है और कई packaging formats में उपलब्ध है — i2pd का एक Android संस्करण भी उपलब्ध है (उदाहरण के लिए, F-Droid के माध्यम से)।\nGo-I2P (Go) रिपॉजिटरी: https://github.com/go-i2p/go-i2p विवरण: Go-I2P एक I2P client है जो Go प्रोग्रामिंग भाषा में लिखा गया है। यह I2P router का एक स्वतंत्र कार्यान्वयन है, जो Go की दक्षता और पोर्टेबिलिटी का लाभ उठाने का लक्ष्य रखता है। यह परियोजना सक्रिय विकास में है, लेकिन यह अभी भी प्रारंभिक चरण में है और अभी तक पूर्ण रूप से सुविधा-संपन्न नहीं है। 2025 तक, Go-I2P को प्रायोगिक माना जाता है — यह समुदाय के डेवलपर्स द्वारा सक्रिय रूप से विकसित किया जा रहा है, लेकिन जब तक यह और अधिक परिपक्व नहीं हो जाता, तब तक इसे उत्पादन उपयोग के लिए अनुशंसित नहीं किया जाता है। Go-I2P का लक्ष्य एक आधुनिक, हल्के I2P router प्रदान करना है जो विकास पूर्ण होने के बाद I2P नेटवर्क के साथ पूर्ण संगतता रखे।\nI2P+ (Java fork) वेबसाइट: https://i2pplus.github.io विवरण: I2P+ मानक Java I2P क्लाइंट का एक समुदाय-संचालित fork है। यह किसी नई भाषा में पुनर्कार्यान्वयन नहीं है, बल्कि अतिरिक्त सुविधाओं और अनुकूलन के साथ Java router का एक उन्नत संस्करण है। I2P+ आधिकारिक I2P नेटवर्क के साथ पूर्णतः संगत रहते हुए बेहतर उपयोगकर्ता अनुभव और उत्तम प्रदर्शन प्रदान करने पर केंद्रित है। यह एक नवीनीकृत वेब कंसोल इंटरफ़ेस, अधिक उपयोगकर्ता-अनुकूल कॉन्फ़िगरेशन विकल्प, और विभिन्न अनुकूलन प्रस्तुत करता है (उदाहरण के लिए, बेहतर टोरेंट प्रदर्शन और नेटवर्क peers की बेहतर हैंडलिंग, विशेष रूप से फ़ायरवॉल के पीछे के routers के लिए)। I2P+ को आधिकारिक I2P सॉफ़्टवेयर की तरह ही Java वातावरण की आवश्यकता होती है, इसलिए यह गैर-Java वातावरणों के लिए समाधान नहीं है। हालांकि, जिन उपयोगकर्ताओं के पास Java है और जो अतिरिक्त क्षमताओं वाला वैकल्पिक बिल्ड चाहते हैं, उनके लिए I2P+ एक आकर्षक विकल्प प्रदान करता है। इस fork को upstream I2P रिलीज़ के साथ अद्यतन रखा जाता है (इसकी संस्करण संख्या में \u0026ldquo;+\u0026rdquo; जोड़ा जाता है) और इसे परियोजना की वेबसाइट से प्राप्त किया जा सकता है।\n","description":"समुदाय द्वारा रखरखाव किए जाने वाले I2P क्लाइंट कार्यान्वयन (2025 के लिए अपडेट किया गया)","id":"fdcfc5a7a482cf9fe8fe449e9198b146","section":"docs","title":"वैकल्पिक I2P क्लाइंट","url":"/hi/docs/overview/alternative-clients/"},{"categories":null,"content":"यह शब्दावली I2P दस्तावेज़ीकरण और चर्चाओं में उपयोग किए जाने वाले सामान्य शब्दों को परिभाषित करती है।\nB Blockchain एक वितरित खाता-बही जो कई पक्षों के बीच लेनदेन को कुशलता से और सत्यापन योग्य तथा स्थायी तरीके से रिकॉर्ड कर सकता है।\nD Decentralization नेटवर्क आर्किटेक्चर जो किसी एक पक्ष पर निर्भरता से बचता है। इसमें peer-to-peer, blockchain, federated, और distributed तकनीकें शामिल हैं।\nDestination I2P नेटवर्क के भीतर क्लाइंट और सर्वर की पहचान। ये tunnel की क्रिप्टोग्राफिक पहचान होती हैं।\nDHT (Distributed Hash Table) कुछ परियोजनाओं में पीयर्स को एक-दूसरे से जोड़ने के लिए उपयोग किया जाता है, जो वितरित तरीके से की-वैल्यू पेयर्स के रूप में जानकारी संग्रहीत करता है।\nडिस्ट्रिब्यूटेड सिस्टम्स (Distributed Systems) कंप्यूटर साइंस के अंतर्गत एक अकादमिक विषय जो नेटवर्क पर जुड़े कई व्यक्तिगत कंप्यूटरों से मिलकर बने कंप्यूटर सिस्टम्स के डिज़ाइन से संबंधित है।\nF Federated Federation अलग-अलग सेवा परिनियोजनों (deployments) को एक सामान्य प्रोटोकॉल के माध्यम से एक दूसरे के साथ संचार करने की अनुमति देता है।\nH Hash एक संख्या, जो आमतौर पर अक्षरों और संख्याओं की एक स्ट्रिंग के रूप में प्रदर्शित होती है। यह डेटा की विशिष्ट पहचान करने वाले \u0026ldquo;फिंगरप्रिंट\u0026rdquo; के रूप में काम कर सकती है।\nI I2P Invisible Internet Project: एक परियोजना जो गुमनामी की परत प्रदान करने के लिए बनाई गई है, ताकि उपयोगकर्ता विभिन्न अनुप्रयोगों का उपयोग करके गुमनाम रूप से संचार कर सकें।\nIP Address एक कंप्यूटर या नेटवर्क की संख्या जो अद्वितीय होती है और इस प्रकार इसे संबोधित करने के लिए उपयोग की जा सकती है।\nL LeaseSet किसी विशेष Destination पर क्लाइंट या सर्वर के साथ संचार करने के लिए आवश्यक जानकारी का संग्रह।\nP Peer-to-Peer (P2P) Peers अपने संसाधनों का एक हिस्सा सीधे अन्य नेटवर्क प्रतिभागियों को उपलब्ध कराते हैं, बिना servers या स्थिर hosts द्वारा केंद्रीय समन्वय की आवश्यकता के।\nR Router मुख्य I2P सॉफ़्टवेयर, जो I2P नेटवर्क पर एन्क्रिप्टेड पैकेट्स को route करता है।\nRouterIdentity एक router के साथ सीधे संचार करने के लिए आवश्यक जानकारी का संग्रह।\nT TCP/UDP इंटरनेट पर उपयोग किए जाने वाले दो मूलभूत ट्रांसपोर्ट प्रोटोकॉल।\nTunnel एक गुमनाम संचार मार्ग जो क्लाइंट या सर्वर और I2P नेटवर्क के बीच होता है।\nU UX User experience (उपयोगकर्ता अनुभव), किसी उत्पाद या सेवा का उपयोग करने वाले व्यक्ति का समग्र अनुभव।\nW WebRTC एक प्रोटोकॉल स्टैंडर्ड है जो वेब ब्राउज़र में कनेक्शन स्थापित करने के लिए होता है जहाँ डेटा सीधे यूज़र्स के बीच पास होता है।\n","description":"I2P दस्तावेज़ीकरण में उपयोग किए जाने वाले सामान्य शब्द और परिभाषाएँ","id":"2235ec8f316773700ef08dd43b19a1c0","section":"docs","title":"शब्दावली","url":"/hi/docs/overview/%E0%A4%B6%E0%A4%AC%E0%A5%8D%E0%A4%A6%E0%A4%BE%E0%A4%B5%E0%A4%B2%E0%A5%80/"},{"categories":null,"content":"I2P का यह कार्यान्वयन (इस साइट पर वितरित Java कार्यान्वयन) में एक \u0026ldquo;Strict Countries List\u0026rdquo; शामिल है जिसका उपयोग उन क्षेत्रों में router व्यवहार को समायोजित करने के लिए किया जाता है जहां दूसरों के लिए routing में भाग लेना कानून द्वारा प्रतिबंधित हो सकता है। हालांकि हमें ऐसे किसी क्षेत्राधिकार की जानकारी नहीं है जो I2P का उपयोग करने पर रोक लगाता हो, कई देशों में ट्रैफिक relay करने पर व्यापक प्रतिबंध हैं। जो routers \u0026ldquo;strict\u0026rdquo; देशों में स्थित प्रतीत होते हैं, उन्हें स्वचालित रूप से Hidden mode में रखा जाता है।\nयह प्रोजेक्ट इन निर्णयों को लेते समय नागरिक और डिजिटल अधिकार संगठनों के शोध का संदर्भ लेता है। विशेष रूप से, Freedom House द्वारा किया जा रहा शोध हमारे चुनावों को सूचित करता है। सामान्य मार्गदर्शन यह है कि उन देशों को शामिल किया जाए जिनका Civil Liberties (CL) स्कोर 16 या उससे कम है, या Internet Freedom स्कोर 39 या उससे कम है (मुक्त नहीं)।\nहिडन मोड सारांश जब एक router को Hidden मोड में रखा जाता है, तो इसके व्यवहार में तीन मुख्य बातें बदलती हैं:\nयह netDb में RouterInfo प्रकाशित नहीं करता है। यह भाग लेने वाली tunnels को स्वीकार नहीं करता है। यह उसी देश के routers से सीधे कनेक्शन को अस्वीकार करता है। ये सुरक्षा उपाय राउटर्स को विश्वसनीय तरीके से गिनना अधिक कठिन बना देते हैं, और दूसरों के लिए ट्रैफिक रिले करने पर स्थानीय प्रतिबंधों के उल्लंघन के जोखिम को कम करते हैं।\nसख्त देशों की सूची (2024 तक) /* Afghanistan */ \u0026#34;AF\u0026#34;, /* Azerbaijan */ \u0026#34;AZ\u0026#34;, /* Bahrain */ \u0026#34;BH\u0026#34;, /* Belarus */ \u0026#34;BY\u0026#34;, /* Brunei */ \u0026#34;BN\u0026#34;, /* Burundi */ \u0026#34;BI\u0026#34;, /* Cameroon */ \u0026#34;CM\u0026#34;, /* Central African Republic */ \u0026#34;CF\u0026#34;, /* Chad */ \u0026#34;TD\u0026#34;, /* China */ \u0026#34;CN\u0026#34;, /* Cuba */ \u0026#34;CU\u0026#34;, /* Democratic Republic of the Congo */ \u0026#34;CD\u0026#34;, /* Egypt */ \u0026#34;EG\u0026#34;, /* Equatorial Guinea */ \u0026#34;GQ\u0026#34;, /* Eritrea */ \u0026#34;ER\u0026#34;, /* Ethiopia */ \u0026#34;ET\u0026#34;, /* Iran */ \u0026#34;IR\u0026#34;, /* Iraq */ \u0026#34;IQ\u0026#34;, /* Kazakhstan */ \u0026#34;KZ\u0026#34;, /* Laos */ \u0026#34;LA\u0026#34;, /* Libya */ \u0026#34;LY\u0026#34;, /* Myanmar */ \u0026#34;MM\u0026#34;, /* North Korea */ \u0026#34;KP\u0026#34;, /* Palestinian Territories */ \u0026#34;PS\u0026#34;, /* Pakistan */ \u0026#34;PK\u0026#34;, /* Rwanda */ \u0026#34;RW\u0026#34;, /* Saudi Arabia */ \u0026#34;SA\u0026#34;, /* Somalia */ \u0026#34;SO\u0026#34;, /* South Sudan */ \u0026#34;SS\u0026#34;, /* Sudan */ \u0026#34;SD\u0026#34;, /* Eswatini (Swaziland) */ \u0026#34;SZ\u0026#34;, /* Syria */ \u0026#34;SY\u0026#34;, /* Tajikistan */ \u0026#34;TJ\u0026#34;, /* Thailand */ \u0026#34;TH\u0026#34;, /* Turkey */ \u0026#34;TR\u0026#34;, /* Turkmenistan */ \u0026#34;TM\u0026#34;, /* Venezuela */ \u0026#34;VE\u0026#34;, /* United Arab Emirates */ \u0026#34;AE\u0026#34;, /* Uzbekistan */ \u0026#34;UZ\u0026#34;, /* Vietnam */ \u0026#34;VN\u0026#34;, /* Western Sahara */ \u0026#34;EH\u0026#34;, /* Yemen */ \u0026#34;YE\u0026#34; यदि आपको लगता है कि किसी देश को strict list में जोड़ा जाना चाहिए या हटाया जाना चाहिए, तो कृपया एक issue खोलें: https://i2pgit.org/i2p/i2p.i2p/ संदर्भ: Freedom House – https://freedomhouse.org/ ","description":"जिन क्षेत्राधिकारों में routing या anonymity tools पर प्रतिबंध हैं वहां I2P कैसे व्यवहार करता है (Hidden Mode और strict list)","id":"483dc8380c381981cff8df178412f086","section":"docs","title":"सख्त/प्रतिबंधित देश","url":"/hi/docs/overview/restrictive-countries/"},{"categories":null,"content":"अवलोकन यह दस्तावेज़ सभी I2P प्रोटोकॉल में प्रयुक्त मूलभूत डेटा संरचनाएँ निर्दिष्ट करता है, जिनमें I2NP , I2CP , SSU2 , NTCP2 आदि शामिल हैं। ये सामान्य संरचनाएँ विभिन्न I2P कार्यान्वयनों और प्रोटोकॉल परतों के बीच अंतरसंचालनीयता सुनिश्चित करती हैं।\n0.9.58 के बाद के प्रमुख बदलाव Router Identities के लिए ElGamal और DSA-SHA1 अप्रचलित (X25519 + EdDSA का उपयोग करें) पोस्ट-क्वांटम ML-KEM समर्थन बीटा परीक्षण में (2.10.0 से opt-in (स्वैच्छिक सक्रियण)) Service record विकल्पों का मानकीकरण किया गया (Proposal 167 , 0.9.66 में लागू) संपीड़नयोग्य पैडिंग विनिर्देशों को अंतिम रूप दिया गया (Proposal 161 , 0.9.57 में लागू) सामान्य प्रकार विनिर्देश पूर्णांक विवरण: नेटवर्क बाइट क्रम (big-endian) में एक अऋणात्मक पूर्णांक को निरूपित करता है।\nसामग्री: 1 से 8 बाइट्स, जो एक unsigned integer (बिना चिन्ह वाला पूर्णांक) का प्रतिनिधित्व करते हैं।\nउपयोग: I2P प्रोटोकॉलों में सर्वत्र फील्ड की लंबाइयाँ, गिनतियाँ, प्रकार पहचानकर्ता, और संख्यात्मक मान।\nदिनांक विवरण: Unix epoch (1 जनवरी 1970 00:00:00 GMT) से बीते मिलीसेकंड का प्रतिनिधित्व करने वाला टाइमस्टैम्प।\nसामग्री: 8-बाइट पूर्णांक (unsigned long, बिना चिह्न वाला long प्रकार का पूर्णांक)\nविशेष मान: - 0 = अपरिभाषित या null (रिक्त) तिथि - अधिकतम मान: 0xFFFFFFFFFFFFFFFF (वर्ष 584,942,417,355)\nकार्यान्वयन संबंधी टिप्पणियाँ: - हमेशा UTC/GMT समय क्षेत्र - मिलीसेकंड-स्तरीय परिशुद्धता आवश्यक - लीज़ की समाप्ति, RouterInfo प्रकाशन, और टाइमस्टैम्प सत्यापन के लिए उपयोग किया जाता है\nअक्षर शृंखला विवरण: लंबाई प्रीफिक्स के साथ UTF-8 एन्कोडेड स्ट्रिंग.\nप्रारूप:\n+----+----+----+----+----+----+ |len | UTF-8 encoded data... | +----+----+----+----+----+----+ len :: Integer (1 byte) Value: 0-255 (string length in bytes, NOT characters) data :: UTF-8 encoded bytes Length: 0-255 bytes सीमाएँ: - अधिकतम लंबाई: 255 बाइट्स (अक्षर नहीं - बहु-बाइट UTF-8 अनुक्रम कई बाइट्स के रूप में गिने जाते हैं) - लंबाई शून्य हो सकती है (खाली स्ट्रिंग) - Null terminator शामिल नहीं है - स्ट्रिंग null-terminated नहीं है\nमहत्वपूर्ण: UTF-8 अनुक्रम प्रत्येक वर्ण के लिए कई बाइट का उपयोग कर सकते हैं। 100 वर्णों वाली string (टेक्स्ट डेटा का अनुक्रम) यदि मल्टी-बाइट वर्णों का उपयोग करती है, तो 255-बाइट सीमा से अधिक हो सकती है।\nक्रिप्टोग्राफिक कुंजी संरचनाएँ सार्वजनिक कुंजी विवरण: असममित एन्क्रिप्शन के लिए सार्वजनिक कुंजी। कुंजी का प्रकार और लंबाई संदर्भ-निर्भर होते हैं या उन्हें Key Certificate (कुंजी प्रमाणपत्र) में निर्दिष्ट किया जाता है।\nडिफ़ॉल्ट प्रकार: ElGamal (0.9.58 से Router पहचानों के लिए अप्रचलित)\nसमर्थित प्रकार:\nType Code Length (bytes) Since Endianness Usage Status ElGamal0256-BigDestinations only (unused field)Deprecated for RIs P256164TBDBigReservedSee Proposal 145 P384296TBDBigReservedSee Proposal 145 P5213132TBDBigReservedSee Proposal 145 X255194320.9.38LittleCurrent standardRecommended MLKEM512_X255195320.9.67MixedHybrid PQ, LeaseSets onlyBeta MLKEM768_X255196320.9.67MixedHybrid PQ, LeaseSets onlyBeta MLKEM1024_X255197320.9.67MixedHybrid PQ, LeaseSets onlyBeta MLKEM512-8000.9.67TBDHandshakes onlyBeta MLKEM768-11840.9.67TBDHandshakes onlyBeta MLKEM1024-15680.9.67TBDHandshakes onlyBeta MLKEM512_CT-7680.9.67TBDHandshakes onlyBeta MLKEM768_CT-10880.9.67TBDHandshakes onlyBeta MLKEM1024_CT-15680.9.67TBDHandshakes onlyBeta **कार्यान्वयन आवश्यकताएँ:** X25519 (Type 4) - वर्तमान मानक:\nECIES-X25519-AEAD-Ratchet एन्क्रिप्शन के लिए उपयोग होता है 0.9.48 से Router Identities (राउटर पहचानें) के लिए अनिवार्य लिटिल-एंडियन एन्कोडिंग (अन्य प्रकारों के विपरीत) देखें ECIES और ECIES-ROUTERS ElGamal (Type 0) - लेगेसी:\nसंस्करण 0.9.58 से Router पहचान के लिए अप्रचलित Destinations (I2P में गंतव्य पहचान) के लिए अभी भी मान्य (यह फ़ील्ड 0.6/2005 से अप्रयुक्त) ElGamal विनिर्देशन में परिभाषित स्थिर अभाज्य संख्याओं का उपयोग करता है पिछड़ी संगतता (backward compatibility) के लिए समर्थन बनाए रखा गया है MLKEM (क्वांटम-पश्चात) - बीटा:\nहाइब्रिड दृष्टिकोण ML-KEM को X25519 के साथ संयोजित करता है 2.10.0 में डिफ़ॉल्ट रूप से सक्षम नहीं है Hidden Service Manager (छिपी सेवा प्रबंधक) के माध्यम से मैनुअल सक्रियण आवश्यक है देखें ECIES-HYBRID और Proposal 169 टाइप कोड और विनिर्देश परिवर्तन के अधीन हैं JavaDoc: PublicKey निजी कुंजी विवरण: असममित डिक्रिप्शन (asymmetric decryption) के लिए निजी कुंजी, जो PublicKey प्रकारों के अनुरूप है।\nभंडारण: प्रकार और लंबाई संदर्भ से अनुमानित, या डेटा संरचनाओं/कुंजी फ़ाइलों में अलग से संग्रहीत।\nसमर्थित प्रकार:\nType Code Length (bytes) Since Endianness Usage Status ElGamal0256-BigDestinations onlyDeprecated for RIs P256132TBDBigReservedSee Proposal 145 P384248TBDBigReservedSee Proposal 145 P521366TBDBigReservedSee Proposal 145 X255194320.9.38LittleCurrent standardRecommended MLKEM512_X255195320.9.67MixedHybrid PQ, LeaseSets onlyBeta MLKEM768_X255196320.9.67MixedHybrid PQ, LeaseSets onlyBeta MLKEM1024_X255197320.9.67MixedHybrid PQ, LeaseSets onlyBeta MLKEM512-16320.9.67TBDHandshakes onlyBeta MLKEM768-24000.9.67TBDHandshakes onlyBeta MLKEM1024-31680.9.67TBDHandshakes onlyBeta **सुरक्षा नोट्स:** - निजी कुंजियाँ क्रिप्टोग्राफ़िक रूप से सुरक्षित यादृच्छिक संख्या जेनरेटर का उपयोग करके अवश्य उत्पन्न की जानी चाहिए - X25519 निजी कुंजियाँ RFC 7748 में परिभाषित scalar clamping (स्केलर क्लैम्पिंग: निजी-कुंजी स्केलर के कुछ बिटों को मास्क/निश्चित करके सुरक्षित सीमा में बाँधने की प्रक्रिया) का उपयोग करती हैं - जब कुंजी-सामग्री की आवश्यकता न रहे, तो उसे मेमोरी से सुरक्षित रूप से अवश्य मिटा दिया जाना चाहिए JavaDoc (Java का डॉक्यूमेंटेशन उपकरण): PrivateKey सेशन कुंजी Description: I2P के tunnel और garlic encryption में AES-256 एन्क्रिप्शन और डिक्रिप्शन के लिए सममित कुंजी।\nसामग्री: 32 बाइट (256 बिट)\nउपयोग: - tunnel लेयर एन्क्रिप्शन (AES-256/CBC with IV) - garlic संदेश एन्क्रिप्शन (I2P की \u0026lsquo;garlic encryption\u0026rsquo; तकनीक, जिसमें समूहित संदेशों का एन्क्रिप्शन होता है) - एंड-टू-एंड सेशन एन्क्रिप्शन\nजनरेशन: क्रिप्टोग्राफ़िक रूप से सुरक्षित यादृच्छिक संख्या जनरेटर का उपयोग करना अनिवार्य है।\nJavaDoc: SessionKey SigningPublicKey विवरण: हस्ताक्षर सत्यापन के लिए सार्वजनिक कुंजी। प्रकार और लंबाई Key Certificate of Destination में निर्दिष्ट होती है या संदर्भ से अनुमानित की जाती है।\nडिफ़ॉल्ट प्रकार: DSA_SHA1 (0.9.58 से अप्रचलित)\nसमर्थित प्रकार:\nType Code Length (bytes) Since Endianness Usage Status DSA_SHA10128-BigLegacy onlyDeprecated ECDSA_SHA256_P2561640.9.12BigOlder DestinationsDeprecated ECDSA_SHA384_P3842960.9.12BigRareDeprecated ECDSA_SHA512_P52131320.9.12BigRareDeprecated RSA_SHA256_204842560.9.12BigOffline signing onlyDeprecated RSA_SHA384_307253840.9.12BigOffline signing onlyDeprecated RSA_SHA512_409665120.9.12BigOffline signing onlyRecommended for SU3 EdDSA_SHA512_Ed255197320.9.15LittleCurrent standardRecommended EdDSA_SHA512_Ed25519ph8320.9.25LittleOffline signing onlyRare RedDSA_SHA512_Ed2551911320.9.39LittleEncrypted leasesets onlySpecialized Reserved (GOST)964-BigReservedProposal 134 Reserved (GOST)10128-BigReservedProposal 134 Reserved (MLDSA)12-20TBD-TBDReservedProposal 169 Experimental65280-65534Varies-VariesTesting onlyNever production Reserved65535---Future expansion- **कार्यान्वयन आवश्यकताएँ:** EdDSA_SHA512_Ed25519 (Type 7) - वर्तमान मानक:\n2015 के उत्तरार्ध से सभी नए Router Identities और Destinations के लिए डिफ़ॉल्ट SHA-512 हैशिंग के साथ Ed25519 कर्व का उपयोग करता है 32-बाइट सार्वजनिक कुंजियाँ, 64-बाइट हस्ताक्षर Little-endian (सबसे कम महत्वपूर्ण बाइट पहले) एन्कोडिंग (अधिकांश अन्य प्रकारों के विपरीत) उच्च प्रदर्शन और सुरक्षा RedDSA_SHA512_Ed25519 (Type 11) - विशेषीकृत:\nकेवल एन्क्रिप्टेड leasesets और blinding (छिपाकर गणना) के लिए ही उपयोग होता है Router पहचानें या मानक Destinations के लिए कभी उपयोग नहीं होता EdDSA से प्रमुख अंतर: निजी कुंजियाँ modular reduction (मॉड्यूलो-आधारित घटाव) के जरिए; clamping (बिट सीमाबद्ध करना) नहीं हस्ताक्षरों में 80 बाइट्स का यादृच्छिक डेटा शामिल होता है निजी कुंजियों के हैश की बजाय सार्वजनिक कुंजियों का सीधे उपयोग करता है देखें [Red25519 specification](//docs/specs/red25519-signature-scheme/ DSA_SHA1 (Type 0) - लेगेसी:\n0.9.58 से Router पहचानों के लिए अप्रचलित नई Destinations (गंतव्य) के लिए हतोत्साहित 1024-बिट DSA, SHA-1 के साथ (ज्ञात कमजोरियाँ) केवल संगतता के लिए समर्थन बनाए रखा गया है बहु-घटक कुंजियाँ:\nजब यह दो घटकों से मिलकर बना हो (उदा., ECDSA (एलिप्टिक कर्व डिजिटल सिग्नेचर एल्गोरिदम) के बिंदु X,Y) प्रत्येक घटक को प्रारंभिक शून्यों के साथ लंबाई/2 तक पैड किया जाता है उदाहरण: 64-बाइट ECDSA कुंजी = 32-बाइट X + 32-बाइट Y जावाडॉक: SigningPublicKey SigningPrivateKey विवरण: हस्ताक्षर बनाने के लिए निजी कुंजी, जो SigningPublicKey प्रकारों के अनुरूप है।\nस्टोरेज: निर्माण के समय प्रकार और लंबाई निर्दिष्ट की जाती है।\nसमर्थित प्रकार:\nType Code Length (bytes) Since Endianness Usage Status DSA_SHA1020-BigLegacy onlyDeprecated ECDSA_SHA256_P2561320.9.12BigOlder DestinationsDeprecated ECDSA_SHA384_P3842480.9.12BigRareDeprecated ECDSA_SHA512_P5213660.9.12BigRareDeprecated RSA_SHA256_204845120.9.12BigOffline signing onlyDeprecated RSA_SHA384_307257680.9.12BigOffline signing onlyDeprecated RSA_SHA512_4096610240.9.12BigOffline signing onlyRecommended for SU3 EdDSA_SHA512_Ed255197320.9.15LittleCurrent standardRecommended EdDSA_SHA512_Ed25519ph8320.9.25LittleOffline signing onlyRare RedDSA_SHA512_Ed2551911320.9.39LittleEncrypted leasesets onlySpecialized **सुरक्षा आवश्यकताएँ:** - क्रिप्टोग्राफ़िक रूप से सुरक्षित यादृच्छिक स्रोत का उपयोग करके उत्पन्न करें - उचित अभिगम नियंत्रणों के साथ सुरक्षित रखें - कार्य पूर्ण होने पर मेमोरी से सुरक्षित रूप से मिटाएँ - EdDSA (एक क्रिप्टोग्राफ़िक डिजिटल हस्ताक्षर एल्गोरिद्म) के लिए: 32-बाइट सीड को SHA-512 (क्रिप्टोग्राफ़िक हैश फ़ंक्शन) से हैश किया जाता है, पहले 32 बाइट्स से स्केलर बनता है (क्लैम्प्ड) - RedDSA (EdDSA का एक प्रकार) के लिए: कुंजी-निर्माण भिन्न है (क्लैम्पिंग की बजाय मॉड्यूलर रिडक्शन) JavaDoc: SigningPrivateKey हस्ताक्षर विवरण: डेटा पर क्रिप्टोग्राफिक हस्ताक्षर, जो SigningPrivateKey प्रकार के अनुरूप हस्ताक्षर एल्गोरिदम का उपयोग करके उत्पन्न किया गया है।\nप्रकार और लंबाई: हस्ताक्षर के लिए उपयोग किए गए कुंजी प्रकार से निर्धारित।\nसमर्थित प्रकार:\nType Code Length (bytes) Since Endianness Usage Status DSA_SHA1040-BigLegacy onlyDeprecated ECDSA_SHA256_P2561640.9.12BigOlder DestinationsDeprecated ECDSA_SHA384_P3842960.9.12BigRareDeprecated ECDSA_SHA512_P52131320.9.12BigRareDeprecated RSA_SHA256_204842560.9.12BigOffline signing onlyDeprecated RSA_SHA384_307253840.9.12BigOffline signing onlyDeprecated RSA_SHA512_409665120.9.12BigOffline signing onlyCurrent for SU3 EdDSA_SHA512_Ed255197640.9.15LittleCurrent standardRecommended EdDSA_SHA512_Ed25519ph8640.9.25LittleOffline signing onlyRare RedDSA_SHA512_Ed2551911640.9.39LittleEncrypted leasesets onlySpecialized **प्रारूप नोट्स:** - बहु-घटक हस्ताक्षर (उदा., ECDSA R,S मान) को प्रति तत्व लंबाई/2 तक अग्रणी शून्यों से पैड किया जाता है - EdDSA और RedDSA little-endian encoding (कम-महत्वपूर्ण-बाइट पहले क्रम) का उपयोग करते हैं - अन्य सभी प्रकार big-endian encoding (अधिक-महत्वपूर्ण-बाइट पहले क्रम) का उपयोग करते हैं सत्यापन: - संबंधित SigningPublicKey (हस्ताक्षर सार्वजनिक कुंजी) का उपयोग करें - कुंजी प्रकार के लिए हस्ताक्षर एल्गोरिथ्म के विनिर्देशों का पालन करें - जाँचें कि हस्ताक्षर की लंबाई कुंजी प्रकार के लिए अपेक्षित लंबाई से मेल खाती है\nजावाडॉक: Signature हैश विवरण: डेटा का SHA-256 हैश, I2P भर में अखंडता सत्यापन और पहचान के लिए उपयोग किया जाता है।\nसामग्री: 32 बाइट (256 बिट)\nउपयोग: - Router पहचान हैश (नेटवर्क डेटाबेस कुंजियाँ) - Destination (गंतव्य) हैश (नेटवर्क डेटाबेस कुंजियाँ) - Leases (लीज़) में Tunnel गेटवे की पहचान - डेटा अखंडता सत्यापन - Tunnel ID का निर्माण\nएल्गोरिथ्म: SHA-256 जैसा कि FIPS 180-4 में परिभाषित है\nJavaDoc: Hash सत्र टैग विवरण: सत्र की पहचान और टैग-आधारित एन्क्रिप्शन के लिए उपयोग की जाने वाली यादृच्छिक संख्या।\nमहत्वपूर्ण: Session Tag (सेशन टैग—अस्थायी पहचान टैग) का आकार एन्क्रिप्शन प्रकार के अनुसार बदलता है: - ElGamal/AES+SessionTag: 32 बाइट (पुराना) - ECIES-X25519: 8 बाइट (वर्तमान मानक)\nवर्तमान मानक (ECIES - एलिप्टिक कर्व इंटीग्रेटेड एन्क्रिप्शन स्कीम):\nContents: 8 bytes Usage: Ratchet-based encryption for Destinations and Routers विस्तृत विनिर्देशों के लिए ECIES और ECIES-ROUTERS देखें।\nलेगेसी (ElGamal/AES):\nContents: 32 bytes Usage: Deprecated encryption scheme उत्पादन: cryptographically secure random number generator (कूटलेखी रूप से सुरक्षित यादृच्छिक संख्या जनक) का उपयोग अनिवार्य है।\nJavaDoc: SessionTag TunnelId विवरण: tunnel में router की स्थिति का एक अद्वितीय पहचानकर्ता। tunnel में प्रत्येक हॉप का अपना अलग TunnelId (टनल में हॉप की पहचान/ID) होता है।\nप्रारूप:\nContents: 4-byte Integer (unsigned 32-bit) Range: Generally \u0026gt; 0 (zero reserved for special cases) उपयोग: - प्रत्येक router पर आने/जाने वाली tunnel कनेक्शनों की पहचान करता है - tunnel श्रृंखला के प्रत्येक हॉप पर अलग TunnelId - गेटवे tunnel की पहचान करने के लिए Lease संरचनाओं में उपयोग किया जाता है\nविशेष मान: - 0 = विशेष प्रोटोकॉल उपयोगों के लिए आरक्षित (सामान्य संचालन में बचें) - TunnelIds प्रत्येक router के लिए केवल स्थानीय रूप से अर्थपूर्ण होते हैं\nJavaDoc: TunnelId प्रमाणपत्र विनिर्देश प्रमाणपत्र विवरण: पूरे I2P में प्रयुक्त रसीदें, proof-of-work (कार्य का प्रमाण—गणनात्मक प्रयास-आधारित सत्यापन), या क्रिप्टोग्राफिक मेटाडेटा के लिए कंटेनर।\nप्रारूप:\n+----+----+----+----+----+----+-// |type| length | payload +----+----+----+----+----+----+-// type :: Integer (1 byte) Values: 0-5 (see types below) length :: Integer (2 bytes, big-endian) Size of payload in bytes payload :: data length -\u0026gt; $length bytes कुल आकार: 3 बाइट न्यूनतम (NULL प्रमाणपत्र), अधिकतम 65538 बाइट\nप्रमाणपत्र के प्रकार Type Code Payload Length Total Size Status Usage NULL003CurrentDefault/empty certificate HASHCASH1VariesVariesDeprecatedUnused (was for proof-of-work) HIDDEN203DeprecatedUnused (hidden routers don't advertise) SIGNED340 or 7243 or 75DeprecatedUnused (DSA signature ± destination hash) MULTIPLE4VariesVariesDeprecatedUnused (multiple certificates) KEY54+7+CurrentSpecifies key types (see below) ### कुंजी प्रमाणपत्र (प्रकार 5) परिचय: संस्करण 0.9.12 (दिसंबर 2013)\nउद्देश्य: गैर-डिफ़ॉल्ट कुंजी प्रकार निर्दिष्ट करता है और मानक 384-बाइट KeysAndCert संरचना से परे अतिरिक्त कुंजी डेटा संग्रहीत करता है।\nपेलोड संरचना:\n+----+----+----+----+----+----+----+----+-// |SPKtype|CPKtype| Excess SPK data | +----+----+----+----+----+----+----+----+-// | Excess CPK data... | +----+----+----+----+----+----+----+----+ SPKtype :: Signing Public Key Type (2 bytes) See SigningPublicKey table above CPKtype :: Crypto Public Key Type (2 bytes) See PublicKey table above Excess SPK data :: Signing key bytes beyond 128 bytes Length: 0 to 65531 bytes Excess CPK data :: Crypto key bytes beyond 256 bytes Length: 0 to remaining space महत्वपूर्ण कार्यान्वयन संबंधी टिप्पणियाँ:\nकुंजी प्रकार का क्रम:\nचेतावनी: हस्ताक्षर कुंजी प्रकार, क्रिप्टो कुंजी प्रकार से पहले आता है यह सहज-बोध के विपरीत है, लेकिन संगतता बनाए रखने के लिए ऐसा रखा गया है क्रम: SPKtype, CPKtype (CPKtype, SPKtype नहीं) KeysAndCert (Keys और Certificate की संरचना) में कुंजी डेटा का विन्यास:\n[Crypto Public Key (partial/complete)] [Padding (if total key lengths \u0026lt; 384)] [Signing Public Key (partial/complete)] [Certificate Header (3 bytes)] [Key Certificate (4+ bytes)] [Excess Signing Key Data] [Excess Crypto Key Data] अतिरिक्त कुंजी डेटा की गणना:\nIf Crypto Key \u0026gt; 256 बाइट्स: Excess = (Crypto Length - 256) If Signing Key \u0026gt; 128 बाइट्स: Excess = (Signing Length - 128) Padding = max(0, 384 - Crypto Length - Signing Length) उदाहरण (ElGamal क्रिप्टो कुंजी):\nSigning Key Type Total SPK Length Padding Excess in Cert Total Structure Size DSA_SHA112800387 + 7 = 394 ECDSA_P25664640387 + 7 = 394 ECDSA_P38496320387 + 7 = 394 ECDSA_P52113204387 + 11 = 398 RSA_20482560128387 + 135 = 522 RSA_40965120384387 + 391 = 778 EdDSA32960387 + 7 = 394 **Router पहचान आवश्यकताएँ:** - NULL certificate (रिक्त प्रमाणपत्र) का उपयोग संस्करण 0.9.15 तक किया गया - गैर-डिफ़ॉल्ट कुंजी प्रकारों के लिए 0.9.16 से Key Certificate (कुंजी प्रमाणपत्र) आवश्यक - X25519 encryption keys (एन्क्रिप्शन कुंजियाँ) 0.9.48 से समर्थित गंतव्य आवश्यकताएँ: - NULL certificate (रिक्त प्रमाणपत्र) या Key Certificate (कुंजी प्रमाणपत्र) (आवश्यकतानुसार) - 0.9.12 से गैर-डिफ़ॉल्ट हस्ताक्षर कुंजी प्रकारों के लिए Key Certificate आवश्यक है - क्रिप्टो सार्वजनिक कुंजी फ़ील्ड 0.6 (2005) से उपयोग में नहीं है, लेकिन फिर भी मौजूद होना आवश्यक है\nमहत्वपूर्ण चेतावनियाँ:\nNULL बनाम KEY Certificate:\ntypes (0,0) वाला KEY certificate (KEY प्रमाणपत्र), जो ElGamal+DSA_SHA1 (क्रिप्टोग्राफ़िक कुंजी/हस्ताक्षर एल्गोरिद्म संयोजन) निर्दिष्ट करता है, अनुमत है, लेकिन अनुशंसित नहीं है ElGamal+DSA_SHA1 के लिए हमेशा NULL certificate (NULL प्रमाणपत्र) का उपयोग करें (canonical representation—कैनोनिकल/मानक रूप) (0,0) वाला KEY certificate 4 बाइट लंबा होता है और संगतता संबंधी समस्याएँ पैदा कर सकता है कुछ कार्यान्वयन संभवतः (0,0) KEY certificates को सही ढंग से संभाल नहीं पाएँगे अतिरिक्त डेटा सत्यापन:\nकार्यान्वयन को यह सत्यापित करना अनिवार्य है कि प्रमाणपत्र की लंबाई कुंजी प्रकारों के लिए अपेक्षित लंबाई से मेल खाती हो ऐसे प्रमाणपत्रों को अस्वीकार करें जिनमें अतिरिक्त डेटा हो जो कुंजी प्रकारों से मेल नहीं खाता वैध प्रमाणपत्र संरचना के बाद आने वाले किसी भी अनुगामी कचरा डेटा को प्रतिबंधित करें JavaDoc: प्रमाणपत्र मैपिंग विवरण: कॉन्फ़िगरेशन और मेटाडेटा के लिए प्रयुक्त कुंजी-मूल्य गुणों का संग्रह।\nप्रारूप:\n+----+----+----+----+----+----+----+----+ | size | key_string (len + data)| = | +----+----+----+----+----+----+----+----+ | val_string (len + data) | ; | ... +----+----+----+----+----+----+----+ size :: Integer (2 bytes, big-endian) Total number of bytes that follow (not including size field) Range: 0 to 65535 key_string :: String Format: 1-byte length + UTF-8 data Length: 0-255 bytes = :: Single byte (0x3D, \u0026#39;=\u0026#39; character) val_string :: String Format: 1-byte length + UTF-8 data Length: 0-255 bytes ; :: Single byte (0x3B, \u0026#39;;\u0026#39; character) [Repeat key_string = val_string ; for additional entries] आकार सीमाएँ: - कुंजी लंबाई: 0-255 बाइट्स (+ 1 लंबाई बाइट) - मान लंबाई: 0-255 बाइट्स (+ 1 लंबाई बाइट) - कुल मैपिंग आकार: 0-65535 बाइट्स (+ 2 आकार फ़ील्ड बाइट्स) - अधिकतम संरचना आकार: 65537 बाइट्स\nमहत्वपूर्ण छँटाई संबंधी आवश्यकता:\nजब मैपिंग्स हस्ताक्षरित संरचनाओं (RouterInfo, RouterAddress, Destination properties, I2CP SessionConfig) में दिखाई देती हैं, तो हस्ताक्षर की अपरिवर्तनीयता सुनिश्चित करने के लिए प्रविष्टियाँ कुंजी के अनुसार अनिवार्य रूप से क्रमबद्ध होनी चाहिए:\nसॉर्ट विधि: यूनिकोड कोड पॉइंट मानों का उपयोग करके शब्दकोशीय क्रम (Java String.compareTo() के समकक्ष) केस सेंसिटिविटी: कुंजियाँ और मान सामान्यतः केस-सेंसिटिव होते हैं (एप्लिकेशन पर निर्भर) डुप्लिकेट कुंजियाँ: हस्ताक्षरित संरचनाओं में अनुमत नहीं (इससे हस्ताक्षर सत्यापन विफल होगा) वर्ण एन्कोडिंग: UTF-8 बाइट-स्तरीय तुलना छँटाई क्यों महत्वपूर्ण है: - हस्ताक्षर बाइट प्रतिनिधित्व पर गणना किए जाते हैं - अलग-अलग कुंजी क्रम अलग-अलग हस्ताक्षर उत्पन्न करते हैं - अहस्ताक्षरित मैपिंग्स में छँटाई की आवश्यकता नहीं होती लेकिन वही परंपरा का पालन करना चाहिए\nकार्यान्वयन संबंधी टिप्पणियाँ:\nएन्कोडिंग में अतिरिक्तता:\n= और ; दोनों विभाजक तथा स्ट्रिंग-लंबाई बाइट्स मौजूद हैं यह अकार्यक्षम है, पर संगतता के लिए बनाए रखा गया है लंबाई बाइट्स को प्रामाणिक माना जाता है; विभाजक आवश्यक तो हैं, पर अतिरिक्त हैं अक्षर समर्थन:\nदस्तावेज़ के बावजूद, स्ट्रिंग्स के भीतर = और ; वास्तव में समर्थित हैं (लंबाई बाइट्स इसे संभालती हैं) UTF-8 एन्कोडिंग पूर्ण यूनिकोड का समर्थन करती है चेतावनी: I2CP UTF-8 का उपयोग करता है, लेकिन I2NP ऐतिहासिक रूप से UTF-8 को सही ढंग से संभाल नहीं पाता था अधिकतम अनुकूलता के लिए, संभव हो तो I2NP मैपिंग के लिए ASCII का उपयोग करें विशेष संदर्भ:\nRouterInfo/RouterAddress: अनिवार्य रूप से क्रमबद्ध हों, डुप्लिकेट न हों I2CP SessionConfig: अनिवार्य रूप से क्रमबद्ध हों, डुप्लिकेट न हों एप्लिकेशन मैपिंग्स: क्रमबद्ध करना अनुशंसित है, पर हमेशा आवश्यक नहीं उदाहरण (RouterInfo विकल्प):\nMapping size: 45 bytes Sorted entries: caps=L (capabilities) netId=2 (network ID) router.version=0.9.67 जावाडॉक: DataHelper सामान्य संरचना विनिर्देश कुंजियाँ और प्रमाणपत्र विवरण: एन्क्रिप्शन कुंजी, साइनिंग कुंजी, और प्रमाणपत्र को जोड़ने वाली मूलभूत संरचना। RouterIdentity (Router की पहचान) और Destination (गंतव्य) दोनों के रूप में उपयोग किया जाता है।\nसंरचना:\n+----+----+----+----+----+----+----+----+ | public_key | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | padding (optional) | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | signing_key | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | certificate | +----+----+----+-// public_key :: PublicKey (partial or full) Default: 256 bytes (ElGamal) Other sizes: As specified in Key Certificate padding :: Random data Length: 0 bytes or as needed CONSTRAINT: public_key + padding + signing_key = 384 bytes signing_key :: SigningPublicKey (partial or full) Default: 128 bytes (DSA_SHA1) Other sizes: As specified in Key Certificate certificate :: Certificate Minimum: 3 bytes (NULL certificate) Common: 7 bytes (Key Certificate with default keys) TOTAL LENGTH: 387+ bytes (never assume exactly 387!) कुंजी संरेखण: - क्रिप्टोग्राफ़िक सार्वजनिक कुंजी: आरंभ पर संरेखित (बाइट 0) - पैडिंग: बीच में (यदि आवश्यक हो) - हस्ताक्षर सार्वजनिक कुंजी: अंत पर संरेखित (बाइट 256 से बाइट 383) - प्रमाणपत्र: बाइट 384 से शुरू होता है\nआकार की गणना:\nTotal size = 384 + 3 + key_certificate_length For NULL certificate (ElGamal + DSA_SHA1): Total = 384 + 3 = 387 bytes For Key Certificate (EdDSA + X25519): Total = 384 + 3 + 4 = 391 bytes For larger keys (e.g., RSA_4096): Total = 384 + 3 + 4 + excess_key_data_length पैडिंग जनरेशन दिशानिर्देश (प्रस्ताव 161 ) कार्यान्वयन संस्करण: 0.9.57 (जनवरी 2023, रिलीज़ 2.1.0)\nपृष्ठभूमि: - गैर-ElGamal+DSA कुंजियों के लिए, 384-बाइट की स्थिर संरचना में पैडिंग मौजूद है - Destinations (I2P में गंतव्य) के लिए, 256-बाइट का पब्लिक की फ़ील्ड संस्करण 0.6 (2005) से अप्रयुक्त है - पैडिंग इस तरह उत्पन्न की जानी चाहिए कि वह सुरक्षित रहते हुए संपीड़नीय भी हो\nआवश्यकताएँ:\nन्यूनतम यादृच्छिक डेटा:\nकम से कम 32 बाइट क्रिप्टोग्राफ़िक रूप से सुरक्षित यादृच्छिक डेटा का उपयोग करें यह सुरक्षा के लिए पर्याप्त एंट्रॉपी प्रदान करता है संपीड़न रणनीति:\nपूरे padding/public key फ़ील्ड में वही 32 बाइट्स दोहराएँ I2NP Database Store, Streaming SYN, SSU2 handshake जैसी प्रोटोकॉल्स संपीड़न का उपयोग करती हैं सुरक्षा से समझौता किए बिना उल्लेखनीय बैंडविड्थ बचत होती है उदाहरण:\nRouter की पहचान (X25519 + EdDSA):\nStructure: - 32 bytes X25519 public key - 320 bytes padding (10 copies of 32-byte random data) - 32 bytes EdDSA public key - 7 bytes Key Certificate Compression savings: ~288 bytes when compressed गंतव्य (ElGamal-unused + EdDSA):\nStructure: - 256 bytes unused ElGamal field (11 copies of 32-byte random data, truncated to 256) - 96 bytes padding (3 copies of 32-byte random data) - 32 bytes EdDSA public key - 7 bytes Key Certificate Compression savings: ~320 bytes when compressed यह क्यों काम करता है:\nपूर्ण संरचना का SHA-256 हैश अब भी सारी एंट्रॉपी (यादृच्छिकता) शामिल करता है नेटवर्क डेटाबेस DHT (वितरित हैश तालिका) का वितरण केवल हैश पर निर्भर करता है साइनिंग कुंजी (32 बाइट EdDSA/X25519) 256 बिट एंट्रॉपी प्रदान करती है अतिरिक्त 32 बाइट के दोहराए गए यादृच्छिक डेटा = कुल 512 बिट एंट्रॉपी क्रिप्टोग्राफ़िक मज़बूती के लिए पर्याप्त से अधिक कार्यान्वयन नोट्स:\nअनिवार्य है कि पूरी 387+ बाइट संरचना को संग्रहीत किया जाए और प्रेषित किया जाए पूर्ण असंपीड़ित संरचना पर SHA-256 हैश की गणना की जाती है संपीड़न प्रोटोकॉल स्तर पर लागू किया जाता है (I2NP, Streaming, SSU2) 0.6 (2005) से सभी संस्करणों के साथ पिछड़ा-संगत JavaDoc (Java दस्तावेज़ीकरण): KeysAndCert RouterIdentity (router की पहचान) विवरण: I2P नेटवर्क में किसी router की अद्वितीय पहचान करता है। इसकी संरचना KeysAndCert (कुंजियों और प्रमाणपत्र की एकीकृत संरचना) के समान है।\nप्रारूप: ऊपर दिए गए KeysAndCert संरचना को देखें\nवर्तमान आवश्यकताएँ (0.9.58 तक):\nअनिवार्य कुंजी प्रकार:\nएन्क्रिप्शन: X25519 (प्रकार 4, 32 बाइट) हस्ताक्षर: EdDSA_SHA512_Ed25519 (प्रकार 7, 32 बाइट) प्रमाणपत्र: कुंजी प्रमाणपत्र (प्रकार 5) अप्रचलित कुंजी प्रकार:\nElGamal (प्रकार 0) 0.9.58 से Router Identities (पहचानें) के लिए अप्रचलित है DSA_SHA1 (प्रकार 0) 0.9.58 से Router Identities के लिए अप्रचलित है इनका नए routers के लिए उपयोग नहीं किया जाना चाहिए सामान्य आकार:\nX25519 + EdDSA कुंजी प्रमाणपत्र के साथ = 391 बाइट्स 32 बाइट्स X25519 सार्वजनिक कुंजी 320 बाइट्स पैडिंग (Proposal 161 के अनुसार संपीडनीय) 32 बाइट्स EdDSA सार्वजनिक कुंजी 7 बाइट्स प्रमाणपत्र (3-बाइट हेडर + 4-बाइट कुंजी प्रकार) ऐतिहासिक विकास: - 0.9.16-पूर्व: हमेशा NULL प्रमाणपत्र (ElGamal + DSA_SHA1) - 0.9.16-0.9.47: Key Certificate (कुंजी प्रमाणपत्र) समर्थन जोड़ा गया - 0.9.48+: X25519 एन्क्रिप्शन कुंजियों का समर्थन जोड़ा गया - 0.9.58+: ElGamal और DSA_SHA1 अप्रचलित कर दिए गए\nनेटवर्क डेटाबेस कुंजी: - RouterInfo (राउटर की जानकारी) की कुंजी पूर्ण RouterIdentity (राउटर की पहचान) के SHA-256 हैश पर आधारित है - हैश 391+ बाइट की संपूर्ण संरचना (padding (पैडिंग) सहित) पर गणना किया जाता है\nयह भी देखें: - पैडिंग उत्पन्न करने के दिशानिर्देश (प्रस्ताव 161 ) - ऊपर दिया गया कुंजी प्रमाणपत्र विनिर्देश\nJavaDoc: RouterIdentity गंतव्य विवरण: सुरक्षित संदेश प्रेषण हेतु Endpoint (एंडपॉइंट, अर्थात संचार का अंतिम बिंदु) पहचानकर्ता। संरचनात्मक रूप से KeysAndCert के समान, लेकिन उपयोग के अर्थगत पहलू भिन्न हैं।\nप्रारूप: ऊपर दी गई KeysAndCert संरचना देखें\nRouterIdentity से महत्वपूर्ण अंतर: - पब्लिक की फ़ील्ड उपयोग में नहीं है और इसमें यादृच्छिक डेटा हो सकता है - यह फ़ील्ड संस्करण 0.6 (2005) से उपयोग में नहीं है - मूल रूप से पुराने I2CP-to-I2CP एन्क्रिप्शन के लिए था (निष्क्रिय) - वर्तमान में केवल अप्रचलित LeaseSet एन्क्रिप्शन के लिए IV (Initialization Vector—प्रारंभिक वेक्टर) के रूप में उपयोग होता है\nवर्तमान अनुशंसाएँ:\nहस्ताक्षर कुंजी:\nअनुशंसित: EdDSA_SHA512_Ed25519 (प्रकार 7, 32 बाइट) विकल्प: ECDSA प्रकार (Elliptic Curve Digital Signature Algorithm - दीर्घवृत्त वक्र डिजिटल हस्ताक्षर एल्गोरिथम) पुराने संस्करणों के साथ संगतता हेतु इससे बचें: DSA_SHA1 (अप्रचलित, अनुशंसित नहीं) एन्क्रिप्शन कुंजी:\nयह फ़ील्ड प्रयुक्त नहीं है, पर उपस्थित होना अनिवार्य है अनुशंसित: Proposal 161 के अनुसार यादृच्छिक डेटा से भरें (संपीड़नीय) आकार: हमेशा 256 बाइट्स (ElGamal (एक सार्वजनिक-कुंजी एन्क्रिप्शन योजना) स्लॉट, भले ही ElGamal के लिए उपयोग नहीं होता) प्रमाणपत्र:\nElGamal + DSA_SHA1 के लिए NULL प्रमाणपत्र (केवल लेगेसी के लिए) अन्य सभी हस्ताक्षर कुंजी प्रकारों के लिए कुंजी प्रमाणपत्र सामान्य आधुनिक गंतव्य:\nStructure: - 256 bytes unused field (random data, compressible) - 96 bytes padding (random data, compressible) - 32 bytes EdDSA signing public key - 7 bytes Key Certificate Total: 391 bytes Compression savings: ~320 bytes वास्तविक एन्क्रिप्शन कुंजी: - Destination (I2P गंतव्य पता) के लिए एन्क्रिप्शन कुंजी LeaseSet में होती है, Destination में नहीं - LeaseSet वर्तमान एन्क्रिप्शन सार्वजनिक कुंजी(यों) को रखता है - एन्क्रिप्शन कुंजी के प्रबंधन के लिए LeaseSet2 विनिर्देश देखें\nनेटवर्क डेटाबेस कुंजी: - LeaseSet की कुंजी पूर्ण Destination (I2P में गंतव्य पहचान) के SHA-256 हैश पर आधारित होती है - हैश पूर्ण 387+ बाइट संरचना पर गणना किया जाता है\nJavaDoc: Destination (गंतव्य) नेटवर्क डेटाबेस संरचनाएँ Lease (लीज़—I2P में एक प्रविष्टि जो inbound tunnel के अंत-बिंदु और समाप्ति को बताती है) विवरण: किसी विशिष्ट tunnel को किसी Destination (I2P में गंतव्य पहचान) के लिए संदेश प्राप्त करने की अनुमति देता है। मूल LeaseSet प्रारूप (type 1) का हिस्सा है।\nप्रारूप:\n+----+----+----+----+----+----+----+----+ | tunnel_gw | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ | tunnel_id | end_date +----+----+----+----+----+----+----+----+ | +----+----+----+----+ tunnel_gw :: Hash (32 bytes) SHA-256 hash of the gateway RouterIdentity tunnel_id :: TunnelId (4 bytes) Tunnel identifier at the gateway router end_date :: Date (8 bytes) Expiration timestamp in milliseconds since epoch कुल आकार: 44 बाइट्स\nउपयोग: - केवल मूल LeaseSet में उपयोग किया जाता है (प्रकार 1, अप्रचलित) - LeaseSet2 और बाद के रूपांतरों के लिए, इसके बजाय Lease2 का उपयोग करें\nJavaDoc: Lease LeaseSet (प्रकार 1) विवरण: मूल LeaseSet प्रारूप. किसी Destination (गंतव्य) के लिए अधिकृत tunnels और कुंजियाँ शामिल करता है. नेटवर्क डेटाबेस में संग्रहीत. स्थिति: अप्रचलित (इसके बजाय LeaseSet2 का उपयोग करें).\nसंरचना:\n+----+----+----+----+----+----+----+----+ | destination | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | encryption_key | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | signing_key | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | num| Lease 0 | +----+ + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | Lease 1 | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | Lease ($num-1) | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | signature | + + | | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ destination :: Destination Length: 387+ bytes encryption_key :: PublicKey (256 bytes, ElGamal) Used for end-to-end ElGamal/AES+SessionTag encryption Generated anew at each router startup (not persistent) signing_key :: SigningPublicKey (128+ bytes) Same type as Destination signing key Used for LeaseSet revocation (unimplemented) Generated anew at each router startup (not persistent) num :: Integer (1 byte) Number of Leases to follow Range: 0-16 leases :: Array of Lease structures Length: $num × 44 bytes Each Lease is 44 bytes signature :: Signature (40+ bytes) Length determined by Destination signing key type Signed by Destination\u0026#39;s SigningPrivateKey डेटाबेस संग्रहण: - डेटाबेस प्रकार: 1 - कुंजी: Destination (गंतव्य) का SHA-256 हैश - मान: पूर्ण LeaseSet संरचना\nमहत्वपूर्ण नोट्स:\nDestination (गंतव्य) सार्वजनिक कुंजी अप्रयुक्त:\nDestination में एन्क्रिप्शन सार्वजनिक कुंजी फ़ील्ड अप्रयुक्त है LeaseSet में एन्क्रिप्शन कुंजी ही वास्तविक एन्क्रिप्शन कुंजी है अस्थायी कुंजियाँ:\nencryption_key अस्थायी है (router के प्रारंभ पर पुनः उत्पन्न होता है) signing_key अस्थायी है (router के प्रारंभ पर पुनः उत्पन्न होता है) रीस्टार्ट के बाद कोई भी कुंजी स्थायी नहीं रहती निरस्तीकरण (कार्यान्वित नहीं किया गया):\nsigning_key का उद्देश्य LeaseSet के निरस्तीकरण के लिए था निरस्तीकरण तंत्र कभी कार्यान्वित नहीं किया गया शून्य-लीज़ LeaseSet निरस्तीकरण के लिए अभिप्रेत था, लेकिन अप्रयुक्त है वर्ज़निंग/टाइमस्टैम्प:\nLeaseSet में published टाइमस्टैम्प फ़ील्ड स्पष्ट रूप से मौजूद नहीं है वर्ज़न सभी लीज़ (lease—टनेल तक पहुँच का अस्थायी रिकॉर्ड) में सबसे पहले होने वाली समाप्ति तिथि होता है स्वीकार किए जाने के लिए नए LeaseSet में लीज़ की समाप्ति तिथि और भी पहले की होनी चाहिए लीज़ समाप्ति का प्रकाशन:\nPre-0.9.7: सभी लीज़ एक ही समाप्ति समय (सबसे प्रारंभिक) के साथ प्रकाशित की जाती थीं 0.9.7+: प्रत्येक लीज़ की वास्तविक, व्यक्तिगत समाप्ति समय प्रकाशित होते हैं यह कार्यान्वयन का विवरण है, विशिष्टता का हिस्सा नहीं है शून्य Lease (लीज़):\nLeaseSet में शून्य Lease तकनीकी रूप से अनुमत है निरसन के लिए अभिप्रेत (लागू नहीं किया गया) व्यवहार में अप्रयुक्त LeaseSet2 रूपांतरों को कम-से-कम एक Lease की आवश्यकता होती है अप्रचलन: LeaseSet प्रकार 1 अप्रचलित है। नए कार्यान्वयनों को LeaseSet2 (प्रकार 3) का उपयोग करना चाहिए, जो प्रदान करता है: - प्रकाशित टाइमस्टैम्प फ़ील्ड (बेहतर संस्करण निर्धारण) - कई एन्क्रिप्शन कुंजियों का समर्थन - ऑफ़लाइन हस्ताक्षर क्षमता - 4-byte लीज़ समाप्ति (8-byte की तुलना में) - अधिक लचीले विकल्प\nजावाडॉक: LeaseSet LeaseSet (I2P में गंतव्य तक पहुँच हेतु प्रकाशित रिकॉर्ड) के प्रकार Lease2 (I2P में Lease का नया संस्करण) विवरण: 4-बाइट समाप्ति के साथ उन्नत लीज़ फ़ॉर्मेट। LeaseSet2 (प्रकार 3) और MetaLeaseSet (प्रकार 7) में प्रयुक्त।\nपरिचय: संस्करण 0.9.38 (देखें प्रस्ताव 123 )\nप्रारूप:\n+----+----+----+----+----+----+----+----+ | tunnel_gw | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ | tunnel_id | end_date | +----+----+----+----+----+----+----+----+ tunnel_gw :: Hash (32 bytes) SHA-256 hash of gateway RouterIdentity tunnel_id :: TunnelId (4 bytes) Tunnel identifier at gateway end_date :: 4-byte timestamp (seconds since epoch) Rolls over in year 2106 कुल आकार: 40 बाइट्स (मूल Lease (I2P में LeaseSet की एक प्रविष्टि) की तुलना में 4 बाइट्स छोटा)\nमूल Lease (I2P में इनबाउंड टनल की प्रविष्टि और उसकी समाप्ति समय का रिकॉर्ड) से तुलना:\nFeature Lease (Type\u0026nbsp;1) Lease2 (Type\u0026nbsp;3+) Size44 bytes40 bytes Expiration Size8 bytes (ms)4 bytes (seconds) PrecisionMillisecondSecond RolloverYear\u0026nbsp;292,277,026,596Year\u0026nbsp;2106 Used InLeaseSet (deprecated)LeaseSet2, MetaLeaseSet **जावाडॉक:** [Lease2](http://docs.i2p-projekt.de/javadoc/net/i2p/data/Lease2.html) ऑफ़लाइन हस्ताक्षर Description: पूर्व-हस्ताक्षरित अस्थायी कुंजियों के लिए वैकल्पिक संरचना, जो LeaseSet के प्रकाशन की अनुमति देती है, Destination (I2P में गंतव्य पहचान) की निजी हस्ताक्षर कुंजी तक ऑनलाइन पहुँच के बिना।\nपरिचय: संस्करण 0.9.38 (देखें प्रस्ताव 123 )\nप्रारूप:\n+----+----+----+----+----+----+----+----+ | expires | sigtype | | +----+----+----+----+----+----+ + | transient_public_key | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | signature | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ expires :: 4-byte timestamp (seconds since epoch) Expiration of transient key validity Rolls over in year 2106 sigtype :: 2-byte signature type Type of transient_public_key (see SigningPublicKey types) transient_public_key :: SigningPublicKey Length determined by sigtype Temporary signing key for LeaseSet signature :: Signature Length determined by Destination\u0026#39;s signing key type Signature of (expires || sigtype || transient_public_key) Signed by Destination\u0026#39;s permanent SigningPrivateKey उद्देश्य: - ऑफ़लाइन LeaseSet निर्माण को सक्षम बनाता है - Destination (I2P में पहचान/पता) की मास्टर कुंजी को ऑनलाइन उजागर होने से सुरक्षित रखता है - अस्थायी कुंजी को ऑफ़लाइन हस्ताक्षर के बिना नया LeaseSet प्रकाशित करके निरस्त किया जा सकता है\nउपयोग परिदृश्य:\nउच्च-सुरक्षा गंतव्य:\nमास्टर हस्ताक्षर कुंजी ऑफ़लाइन संग्रहीत (HSM, कोल्ड स्टोरेज) अस्थायी कुंजियाँ सीमित समय अवधियों के लिए ऑफ़लाइन उत्पन्न की जाती हैं समझौता हुई अस्थायी कुंजी मास्टर कुंजी को उजागर नहीं करती एन्क्रिप्टेड LeaseSet प्रकाशन:\nEncryptedLeaseSet में ऑफ़लाइन हस्ताक्षर शामिल हो सकता है ब्लाइंडेड सार्वजनिक कुंजी + ऑफ़लाइन हस्ताक्षर अतिरिक्त सुरक्षा प्रदान करते हैं सुरक्षा संबंधी विचार:\nसमाप्ति प्रबंधन:\nउचित समाप्ति अवधि निर्धारित करें (दिनों से सप्ताह तक, वर्षों नहीं) समाप्ति से पहले नई अस्थायी कुंजियाँ उत्पन्न करें कम समाप्ति अवधि = बेहतर सुरक्षा, अधिक रखरखाव कुंजी निर्माण:\nसुरक्षित परिवेश में ऑफ़लाइन अस्थायी कुंजियाँ उत्पन्न करें ऑफ़लाइन मास्टर कुंजी से हस्ताक्षर करें केवल हस्ताक्षरित अस्थायी कुंजी + हस्ताक्षर को ऑनलाइन router पर स्थानांतरित करें रद्दीकरण:\nअप्रत्यक्ष रूप से रद्द करने के लिए ऑफ़लाइन हस्ताक्षर के बिना नया LeaseSet प्रकाशित करें या अलग transient key (अस्थायी कुंजी) के साथ नया LeaseSet प्रकाशित करें हस्ताक्षर सत्यापन:\nData to sign: expires (4 bytes) || sigtype (2 bytes) || transient_public_key Verification: 1. Extract Destination from LeaseSet 2. Get Destination\u0026#39;s SigningPublicKey 3. Verify signature over (expires || sigtype || transient_public_key) 4. Check that current time \u0026lt; expires 5. If valid, use transient_public_key to verify LeaseSet signature कार्यान्वयन संबंधी नोट्स: - कुल आकार sigtype (हस्ताक्षर प्रकार) और Destination (I2P गंतव्य/पहचान) की साइनिंग कुंजी के प्रकार पर निर्भर करता है - न्यूनतम आकार: 4 + 2 + 32 (EdDSA कुंजी) + 64 (EdDSA हस्ताक्षर) = 102 बाइट्स - अधिकतम व्यावहारिक आकार: ~600 बाइट्स (RSA-4096 अस्थायी कुंजी + RSA-4096 हस्ताक्षर)\nके साथ संगत: - LeaseSet2 (प्रकार 3) - EncryptedLeaseSet (प्रकार 5) - MetaLeaseSet (प्रकार 7)\nयह भी देखें: प्रस्ताव 123 ऑफ़लाइन हस्ताक्षर प्रोटोकॉल के विस्तृत विवरण के लिए।\nLeaseSet2Header (LeaseSet2 का हेडर; I2P में किसी डेस्टिनेशन तक रूटिंग/पहुँच से संबंधित मेटाडेटा का भाग) विवरण: LeaseSet2 (प्रकार 3) और MetaLeaseSet (प्रकार 7) के लिए साझा हेडर संरचना।\nपरिचय: संस्करण 0.9.38 (देखें प्रस्ताव 123 )\nप्रारूप:\n+----+----+----+----+----+----+----+----+ | destination | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | published | expires | flags | +----+----+----+----+----+----+----+----+ | offline_signature (optional) | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ destination :: Destination Length: 387+ bytes published :: 4-byte timestamp (seconds since epoch) Publication time of this LeaseSet Rolls over in year 2106 expires :: 2-byte offset (seconds) Offset from published timestamp Maximum: 65535 seconds (18.2 hours) flags :: 2 bytes (bit flags) See flag definitions below offline_signature :: OfflineSignature (optional) Present only if flags bit 0 is set Variable length न्यूनतम कुल आकार: 395 बाइट्स (ऑफ़लाइन हस्ताक्षर के बिना)\nफ्लैग परिभाषाएँ (बिट क्रम: 15 14 \u0026hellip; 3 2 1 0):\nBit Name Description 0Offline Keys0 = No offline keys, 1 = Offline signature present 1Unpublished0 = Standard published, 1 = Unpublished (client-side only) 2Blinded0 = Standard, 1 = Will be blinded when published 3-15ReservedMust be 0 for compatibility **फ्लैग विवरण:** बिट 0 - ऑफ़लाइन कुंजियाँ: - 0: कोई ऑफ़लाइन हस्ताक्षर नहीं, LeaseSet हस्ताक्षर को सत्यापित करने के लिए Destination (गंतव्य पहचान) की साइनिंग कुंजी का उपयोग करें - 1: OfflineSignature संरचना फ्लैग्स फ़ील्ड के बाद आती है\nबिट 1 - अप्रकाशित: - 0: मानक प्रकाशित LeaseSet, जिसे floodfills तक प्रसारित किया जाना चाहिए - 1: अप्रकाशित LeaseSet (केवल क्लाइंट-साइड) - इसे प्रसारित, प्रकाशित, या क्वेरी के जवाब में भेजा नहीं जाना चाहिए - यदि अवधि समाप्त हो जाए, तो प्रतिस्थापन के लिए netdb से क्वेरी न करें (जब तक बिट 2 भी सेट न हो) - स्थानीय tunnels या परीक्षण के लिए उपयोग किया जाता है\nबिट 2 - ब्लाइंडेड (0.9.42 से): - 0: मानक LeaseSet - 1: यह अनएन्क्रिप्टेड LeaseSet प्रकाशित होने पर ब्लाइंड किया जाएगा और एन्क्रिप्ट किया जाएगा - प्रकाशित संस्करण EncryptedLeaseSet (type 5) होगा - यदि समाप्त हो गया हो, तो प्रतिस्थापन के लिए netdb में ब्लाइंडेड लोकेशन को क्वेरी करें - बिट 1 को भी 1 पर सेट करना आवश्यक है (अप्रकाशित + ब्लाइंडेड) - एन्क्रिप्टेड हिडन सर्विसेज के लिए उपयोग किया जाता है\nसमाप्ति सीमाएँ:\nLeaseSet Type Maximum Expires Value Maximum Actual Time LeaseSet2 (type 3)≈660 seconds≈11 minutes MetaLeaseSet (type 7)65,535 seconds≈18.2 hours **प्रकाशित टाइमस्टैम्प की आवश्यकताएँ:** LeaseSet (प्रकार 1) में published फ़ील्ड नहीं था, इसलिए संस्करण निर्धारण के लिए सबसे शुरुआती लीज़-समाप्ति की खोज करनी पड़ती थी। LeaseSet2 1-सेकंड के रिज़ॉल्यूशन वाला स्पष्ट published टाइमस्टैम्प (समय-मुहर) जोड़ता है।\nमहत्वपूर्ण कार्यान्वयन नोट: - Routers को प्रति Destination (I2P गंतव्य पहचानकर्ता) प्रति सेकंड एक बार से भी काफी धीमी दर पर LeaseSet प्रकाशन को दर-सीमित करना अनिवार्य है - यदि उससे तेज़ प्रकाशित कर रहे हों, तो सुनिश्चित करें कि हर नए LeaseSet का published समय कम-से-कम 1 सेकंड बाद हो - यदि published समय वर्तमान संस्करण से नया नहीं है, तो Floodfills LeaseSet को अस्वीकार कर देंगे - सुझाया गया न्यूनतम अंतराल: प्रकाशनों के बीच 10-60 सेकंड\nगणना के उदाहरण:\nLeaseSet2 (अधिकतम 11 मिनट):\npublished = 1704067200 (2024-01-01 00:00:00 UTC) expires = 660 (seconds) Actual expiration = 1704067200 + 660 = 1704067860 (2024-01-01 00:11:00 UTC) MetaLeaseSet (अधिकतम 18.2 घंटे):\npublished = 1704067200 (2024-01-01 00:00:00 UTC) expires = 65535 (seconds) Actual expiration = 1704067200 + 65535 = 1704132735 (2024-01-01 18:12:15 UTC) संस्करण प्रबंधन: - यदि published टाइमस्टैम्प बड़ा हो तो LeaseSet को \u0026ldquo;नया\u0026rdquo; माना जाता है - Floodfills केवल सबसे नए संस्करण को संग्रहीत करते हैं और प्रसारित करते हैं - सावधानी रखें जब सबसे पुराना Lease (LeaseSet के भीतर की एक प्रविष्टि) पिछले LeaseSet के सबसे पुराने Lease से मेल खाता हो\nLeaseSet2 (प्रकार 3) विवरण: कई एन्क्रिप्शन कुंजियों, ऑफ़लाइन हस्ताक्षरों और सेवा रिकॉर्ड्स के साथ आधुनिक LeaseSet प्रारूप। I2P की छिपी सेवाओं के लिए वर्तमान मानक।\nपरिचय: संस्करण 0.9.38 (देखें प्रस्ताव 123 )\nसंरचना:\n+----+----+----+----+----+----+----+----+ | ls2_header | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | options | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ |numk| keytype0| keylen0 | | +----+----+----+----+----+ + | encryption_key_0 | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | keytypen| keylenn | | +----+----+----+----+ + | encryption_key_n | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | num| Lease2 0 | +----+ + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | Lease2($num-1) | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | signature | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ ls2header :: LeaseSet2Header Length: 395+ bytes (varies with offline signature) options :: Mapping Key-value pairs for service records and metadata Length: 2+ bytes (size field + data) numk :: Integer (1 byte) Number of encryption keys Range: 1 to (implementation-defined maximum, typically 8) keytype :: 2-byte encryption type See PublicKey type table keylen :: 2-byte key length Must match keytype specification encryption_key :: PublicKey Length: keylen bytes Type: keytype [Repeat keytype/keylen/encryption_key for each key] num :: Integer (1 byte) Number of Lease2s Range: 1-16 (at least one required) leases :: Array of Lease2 structures Length: $num × 40 bytes signature :: Signature Length determined by signing key type Signed over entire structure including database type prefix डेटाबेस भंडारण: - डेटाबेस प्रकार: 3 - कुंजी: Destination (I2P में पते/पहचान की इकाई) का SHA-256 हैश - मान: पूर्ण LeaseSet2 संरचना\nहस्ताक्षर गणना:\nData to sign: database_type (1 byte, value=3) || complete LeaseSet2 data Verification: 1. Prepend database type byte (0x03) to LeaseSet2 data 2. If offline signature present: - Verify offline signature against Destination key - Verify LeaseSet2 signature against transient key 3. Else: - Verify LeaseSet2 signature against Destination key एन्क्रिप्शन कुंजी प्राथमिकता क्रम प्रकाशित (सर्वर) LeaseSet के लिए: - कुंजियाँ सर्वर की प्राथमिकता के क्रम में सूचीबद्ध हैं (सबसे अधिक प्राथमिकता पहले) - एकाधिक प्रकारों का समर्थन करने वाले क्लाइंट्स को सर्वर की प्राथमिकता का सम्मान करना चाहिए - सूची में से पहले समर्थित प्रकार का चयन करें - आम तौर पर, उच्च नंबर वाले (नवीन) कुंजी प्रकार अधिक सुरक्षित/कुशल होते हैं - अनुशंसित क्रम: कुंजियों को टाइप कोड के उल्टे क्रम में सूचीबद्ध करें (नवीनतम पहले)\nउदाहरण सर्वर वरीयता:\nnumk = 2 Key 0: X25519 (type 4, 32 bytes) [Most preferred] Key 1: ElGamal (type 0, 256 bytes) [Legacy compatibility] अप्रकाशित (क्लाइंट) LeaseSet के लिए: - कुंजी क्रम व्यावहारिक रूप से मायने नहीं रखता (क्लाइंट की ओर कनेक्शन का प्रयास शायद ही कभी किया जाता है) - संगति के लिए उसी परंपरा का पालन करें\nक्लाइंट कुंजी चयन: - सर्वर की वरीयता का सम्मान करें (पहला समर्थित प्रकार चुनें) - या कार्यान्वयन-परिभाषित वरीयता का उपयोग करें - या दोनों क्षमताओं के आधार पर संयुक्त वरीयता निर्धारित करें\nविकल्प मैपिंग आवश्यकताएँ: - विकल्पों को कुंजी के आधार पर (lexicographic, UTF-8 byte order) अनिवार्य रूप से क्रमबद्ध किया जाना चाहिए - क्रमबद्धता से हस्ताक्षर की अपरिवर्तनशीलता सुनिश्चित होती है - डुप्लिकेट कुंजियाँ अनुमत नहीं हैं\nमानक प्रारूप (प्रस्ताव 167 ):\nAPI 0.9.66 (जून 2025, रिलीज़ 2.9.0) से, सेवा रिकॉर्ड विकल्प एक मानकीकृत प्रारूप का पालन करते हैं। पूर्ण विनिर्देश के लिए प्रस्ताव 167 देखें।\nसेवा रिकॉर्ड विकल्प प्रारूप:\nKey: _service._proto Value: record_type ttl [priority weight] port target [appoptions] service :: Symbolic name of service (lowercase, [a-z0-9-]) Examples: smtp, http, irc, mumble Use standard identifiers from IANA Service Name Registry or Linux /etc/services when available proto :: Transport protocol (lowercase, [a-z0-9-]) \u0026#34;tcp\u0026#34; = streaming protocol \u0026#34;udp\u0026#34; = repliable datagrams Protocol indicators for raw datagrams may be defined later record_type :: \u0026#34;0\u0026#34; (self-reference) or \u0026#34;1\u0026#34; (SRV record) ttl :: Time to live in seconds (positive integer) Recommended minimum: 86400 (one day) Prevents frequent re-queries For record_type = 0 (self-reference): port :: I2CP port number (non-negative integer) appoptions :: Optional application-specific data (no spaces or commas) For record_type = 1 (SRV record): priority :: Lower value = more preferred (non-negative integer) weight :: Relative weight for same priority, higher = more likely (non-negative) port :: I2CP port number (non-negative integer) target :: Hostname or b32 of destination (lowercase) Format: \u0026#34;example.i2p\u0026#34; or \u0026#34;aaaaa...aaaa.b32.i2p\u0026#34; Recommend b32 unless hostname is \u0026#34;well known\u0026#34; appoptions :: Optional application-specific data (no spaces or commas) उदाहरण सेवा रिकॉर्ड्स:\n1. स्व-संदर्भित SMTP सर्वर:\nDestination: aaaa...aaaa.b32.i2p (this LeaseSet) Option: \u0026#34;_smtp._tcp\u0026#34; = \u0026#34;0 999999 25\u0026#34; Meaning: This destination provides SMTP service on I2CP port 25 2. एकल बाहरी SMTP सर्वर:\nDestination: aaaa...aaaa.b32.i2p (this LeaseSet) Option: \u0026#34;_smtp._tcp\u0026#34; = \u0026#34;1 86400 0 0 25 bbbb...bbbb.b32.i2p\u0026#34; Meaning: SMTP service provided by bbbb...bbbb on port 25 TTL = 1 day, single server (priority=0, weight=0) 3. एकाधिक SMTP सर्वर (लोड बैलेंसिंग):\nDestination: aaaa...aaaa.b32.i2p (this LeaseSet) Option: \u0026#34;_smtp._tcp\u0026#34; = \u0026#34;1 86400 0 0 25 bbbb...bbbb.b32.i2p,1 86400 1 0 25 cccc...cccc.b32.i2p\u0026#34; Meaning: Two SMTP servers bbbb...bbbb (priority=0, preferred) cccc...cccc (priority=1, backup) 4. ऐप विकल्पों के साथ HTTP सेवा:\nOption: \u0026#34;_http._tcp\u0026#34; = \u0026#34;0 86400 80 tls=1.3;cert=ed25519\u0026#34; Meaning: HTTP on port 80 with TLS 1.3 and EdDSA certificates TTL (टाइम-टू-लाइव) सिफारिशें: - न्यूनतम: 86400 सेकंड (1 दिन) - लंबी TTL netdb क्वेरी लोड को कम करती है - क्वेरी में कमी और सेवा अपडेट के प्रसार के बीच संतुलन - स्थिर सेवाओं के लिए: 604800 (7 दिन) या उससे अधिक\nकार्यान्वयन संबंधी टिप्पणियाँ:\nएन्क्रिप्शन कुंजियाँ (संस्करण 0.9.44 तक):\nElGamal (प्रकार 0, 256 बाइट): लेगेसी संगतता X25519 (प्रकार 4, 32 बाइट): वर्तमान मानक MLKEM वेरिएंट: Post-quantum (क्वांटम-उपरांत; बीटा, अभी अंतिम रूप नहीं दिया गया) कुंजी लंबाई सत्यापन:\nFloodfills और क्लाइंट्स को अज्ञात कुंजी प्रकारों को पार्स करने में अनिवार्य रूप से सक्षम होना चाहिए अज्ञात कुंजियों को छोड़ने के लिए keylen फ़ील्ड का उपयोग करें यदि कुंजी प्रकार अज्ञात हो, तो पार्सिंग विफल न करें प्रकाशित टाइमस्टैम्प:\nरेट-लिमिटिंग के बारे में LeaseSet2Header नोट्स देखें प्रकाशनों के बीच न्यूनतम 1-सेकंड का अंतराल अनुशंसित: प्रकाशनों के बीच 10-60 सेकंड का अंतराल एन्क्रिप्शन प्रकार माइग्रेशन:\nएकाधिक कुंजियाँ क्रमिक माइग्रेशन का समर्थन करती हैं संक्रमण अवधि के दौरान पुरानी और नई दोनों कुंजियों को सूचीबद्ध करें पर्याप्त क्लाइंट उन्नयन अवधि के बाद पुरानी कुंजी हटा दें JavaDoc: LeaseSet2 MetaLease (मेटालीज़) विवरण: MetaLeaseSet के लिए Lease संरचना, जो tunnels की बजाय अन्य LeaseSets को संदर्भित कर सकती है। लोड बैलेंसिंग और अतिरिक्तता के लिए उपयोग किया जाता है।\nपरिचय: संस्करण 0.9.38, 0.9.40 के लिए निर्धारित कार्यान्वयन (देखें प्रस्ताव 123 )\nप्रारूप:\n+----+----+----+----+----+----+----+----+ | tunnel_gw | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ | flags |cost| end_date | +----+----+----+----+----+----+----+----+ tunnel_gw :: Hash (32 bytes) SHA-256 hash of: - Gateway RouterIdentity (for type 1), OR - Another MetaLeaseSet destination (for type 3/5/7) flags :: 3 bytes Bit order: 23 22 ... 3 2 1 0 Bits 3-0: Entry type (see table below) Bits 23-4: Reserved (must be 0) cost :: 1 byte (0-255) Lower value = higher priority Used for load balancing end_date :: 4-byte timestamp (seconds since epoch) Expiration time Rolls over in year 2106 कुल आकार: 40 बाइट्स\nप्रविष्टि प्रकार (फ्लैग्स के बिट 3-0):\nType Code Description Unknown0Unknown/invalid entry LeaseSet1Points to LeaseSet (type 1, deprecated) LeaseSet23Points to LeaseSet2 (type 3) EncryptedLeaseSet5Points to EncryptedLeaseSet (type 5) MetaLeaseSet7Points to another MetaLeaseSet (type 7) **उपयोग परिदृश्य:** लोड बैलेंसिंग:\nकई MetaLease प्रविष्टियों वाला MetaLeaseSet प्रत्येक प्रविष्टि अलग-अलग LeaseSet2 की ओर संकेत करती है क्लाइंट लागत फ़ील्ड के आधार पर चयन करते हैं अतिरिक्तता:\nबैकअप LeaseSets की ओर इंगित करने वाली कई प्रविष्टियाँ यदि प्राथमिक LeaseSet उपलब्ध न हो तो वैकल्पिक उपाय सेवा स्थानांतरण:\nMetaLeaseSet नए LeaseSet की ओर संकेत करता है Destinations (I2P के गंतव्य) के बीच सुगम संक्रमण की अनुमति देता है कॉस्ट फ़ील्ड का उपयोग: - कम कॉस्ट = अधिक प्राथमिकता - कॉस्ट 0 = सर्वोच्च प्राथमिकता - कॉस्ट 255 = न्यूनतम प्राथमिकता - क्लाइंट्स को कम कॉस्ट वाली प्रविष्टियों को प्राथमिकता देनी चाहिए (SHOULD) - समान कॉस्ट वाली प्रविष्टियों का लोड-बैलेंस यादृच्छिक रूप से किया जा सकता है\nLease2 के साथ तुलना:\nFeature Lease2 MetaLease Size40 bytes40 bytes Tunnel ID4 bytesReplaced by flags (3 bytes) + cost (1 byte) Points ToSpecific tunnelLeaseSet or MetaLeaseSet UsageDirect tunnel referenceIndirection/load balancing **जावाडॉक:** [MetaLease](http://docs.i2p-projekt.de/javadoc/net/i2p/data/MetaLease.html) MetaLeaseSet (प्रकार 7) विवरण: MetaLease प्रविष्टियाँ रखने वाला LeaseSet का प्रकार, जो अन्य LeaseSets के लिए अप्रत्यक्ष संदर्भ प्रदान करता है। load balancing (ट्रैफ़िक का संतुलित वितरण), redundancy (विश्वसनीयता हेतु अतिरिक्त व्यवस्था), और service migration (सेवा को दूसरे स्थान/इंस्टेंस पर स्थानांतरित करना) के लिए उपयोग किया जाता है।\nपरिचय: 0.9.38 में परिभाषित, 0.9.40 में कार्यरत होने के लिए निर्धारित (देखें प्रस्ताव 123 )\nस्थिति: विनिर्देश पूर्ण है। उत्पादन परिनियोजन की स्थिति को वर्तमान I2P रिलीज़ के साथ सत्यापित किया जाना चाहिए।\nसंरचना:\n+----+----+----+----+----+----+----+----+ | ls2_header | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | options | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | num| MetaLease 0 | +----+ + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | MetaLease($num-1) | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ |numr| | +----+ + | revocation_0 | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | revocation_n | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | signature | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ ls2header :: LeaseSet2Header Length: 395+ bytes options :: Mapping Length: 2+ bytes (size + data) MUST be sorted by key num :: Integer (1 byte) Number of MetaLease entries Range: 1 to (implementation-defined, recommend 1-16) metaleases :: Array of MetaLease structures Length: $num × 40 bytes numr :: Integer (1 byte) Number of revocation hashes Range: 0 to (implementation-defined, recommend 0-16) revocations :: Array of Hash structures Length: $numr × 32 bytes SHA-256 hashes of revoked LeaseSet Destinations डेटाबेस भंडारण: - डेटाबेस प्रकार: 7 - कुंजी: Destination (I2P में गंतव्य पहचानकर्ता) का SHA-256 हैश - मान: पूर्ण MetaLeaseSet संरचना\nहस्ताक्षर की गणना:\nData to sign: database_type (1 byte, value=7) || complete MetaLeaseSet data Verification: 1. Prepend database type byte (0x07) to MetaLeaseSet data 2. If offline signature present in header: - Verify offline signature against Destination key - Verify MetaLeaseSet signature against transient key 3. Else: - Verify MetaLeaseSet signature against Destination key उपयोग परिदृश्य:\n1. लोड बैलेंसिंग:\nMetaLeaseSet for primary.i2p: MetaLease 0: cost=0, points to server1.i2p LeaseSet2 MetaLease 1: cost=0, points to server2.i2p LeaseSet2 MetaLease 2: cost=0, points to server3.i2p LeaseSet2 Clients randomly select among equal-cost entries 2. Failover (विफलता की स्थिति में स्वचालित रूप से बैकअप सिस्टम पर स्विच):\nMetaLeaseSet for service.i2p: MetaLease 0: cost=0, points to primary.i2p LeaseSet2 MetaLease 1: cost=100, points to backup.i2p LeaseSet2 Clients prefer cost=0 (primary), fall back to cost=100 (backup) 3. सेवा स्थानांतरण:\nMetaLeaseSet for old-domain.i2p: MetaLease 0: cost=0, points to new-domain.i2p LeaseSet2 Transparently redirects clients from old to new destination 4. बहु-स्तरीय आर्किटेक्चर:\nMetaLeaseSet for service.i2p: MetaLease 0: cost=0, points to region1-meta.i2p (another MetaLeaseSet) MetaLease 1: cost=0, points to region2-meta.i2p (another MetaLeaseSet) Each region MetaLeaseSet points to regional servers Allows hierarchical load balancing रद्दीकरण सूची:\nनिरसन सूची MetaLeaseSet को पहले से प्रकाशित LeaseSets को स्पष्ट रूप से निरस्त करने की अनुमति देती है:\nउद्देश्य: विशिष्ट Destinations (I2P में गंतव्य/पता) को अब वैध नहीं के रूप में चिह्नित करना सामग्री: निरस्त Destination संरचनाओं के SHA-256 hashes उपयोग: क्लाइंट्स को उन LeaseSets का उपयोग बिल्कुल नहीं करना चाहिए जिनका Destination hash निरस्तीकरण सूची में आता है प्रचलित मान: अधिकांश परिनियोजनों में खाली (numr=0) रद्दीकरण का उदाहरण:\nService migrates from dest-v1.i2p to dest-v2.i2p: MetaLease 0: points to dest-v2.i2p Revocations: [hash(dest-v1.i2p)] Clients will use v2 and ignore v1 even if cached समाप्ति प्रबंधन:\nMetaLeaseSet (I2P में LeaseSet का मेटा-रूप) अधिकतम expires=65535 सेकंड (~18.2 घंटे) के साथ LeaseSet2Header (LeaseSet v2 का हेडर) का उपयोग करता है:\nLeaseSet2 (अधिकतम ~11 मिनट) की तुलना में काफी लंबा तुलनात्मक रूप से स्थिर अप्रत्यक्षता के लिए उपयुक्त संदर्भित LeaseSets की समाप्ति अवधि छोटी हो सकती है क्लाइंट्स को MetaLeaseSet तथा संदर्भित LeaseSets दोनों की समाप्ति की जाँच करनी चाहिए विकल्प मैपिंग:\nLeaseSet2 विकल्पों जैसा ही प्रारूप उपयोग करें सेवा रिकॉर्ड (Proposal 167 ) शामिल कर सकते हैं कुंजी के अनुसार क्रमबद्ध होना अनिवार्य है सेवा रिकॉर्ड आमतौर पर अंतिम सेवा का वर्णन करते हैं, न कि अप्रत्यक्षता संरचना का क्लाइंट कार्यान्वयन नोट्स:\nरिज़ॉल्यूशन प्रक्रिया:\n1. Query netdb for MetaLeaseSet using SHA-256(Destination) 2. Parse MetaLeaseSet, extract MetaLease entries 3. Sort entries by cost (lower = better) 4. For each entry in cost order: a. Extract LeaseSet hash from tunnel_gw field b. Determine entry type from flags c. Query netdb for referenced LeaseSet (may be another MetaLeaseSet) d. Check revocation list e. Check expiration f. If valid, use the LeaseSet; else try next entry कैशिंग:\nMetaLeaseSet (ऐसी संरचना जो कई LeaseSets का संदर्भ देती है) और संदर्भित LeaseSets दोनों को कैश करें दोनों स्तरों की समाप्ति की जाँच करें अद्यतन MetaLeaseSet प्रकाशन के लिए निगरानी करें फेलओवर:\nयदि पसंदीदा एंट्री विफल हो, तो अगली सबसे कम लागत वाली को आज़माएँ असफल एंट्रियों को अस्थायी रूप से अनुपलब्ध के रूप में चिह्नित करने पर विचार करें पुनर्प्राप्ति के लिए समय-समय पर फिर से जाँचें कार्यान्वयन स्थिति:\nJavaDoc: MetaLeaseSet EncryptedLeaseSet (प्रकार 5) विवरण: बेहतर गोपनीयता के लिए एन्क्रिप्टेड और ब्लाइंडेड LeaseSet। केवल ब्लाइंडेड सार्वजनिक कुंजी और मेटाडेटा दिखाई देते हैं; वास्तविक leases (I2P में टनल एक्सेस रिकॉर्ड) और एन्क्रिप्शन कुंजियाँ एन्क्रिप्ट की गई होती हैं।\nपरिचय: 0.9.38 में परिभाषित, 0.9.39 में कार्यरत (देखें प्रस्ताव 123 )\nसंरचना:\n+----+----+----+----+----+----+----+----+ | sigtype | | +----+----+ + | blinded_public_key | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | published | expires | flags | +----+----+----+----+----+----+----+----+ | offline_signature (optional) | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | len | | +----+----+ + | encrypted_data | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | signature | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ sigtype :: 2-byte signature type Type of blinded_public_key MUST be RedDSA_SHA512_Ed25519 (type 11) blinded_public_key :: SigningPublicKey (32 bytes for RedDSA) Blinded version of Destination signing key Used to verify signature on EncryptedLeaseSet published :: 4-byte timestamp (seconds since epoch) Publication time Rolls over in year 2106 expires :: 2-byte offset (seconds) Offset from published Maximum: 65535 seconds (18.2 hours) Practical maximum for LeaseSet data: ~660 seconds (~11 min) flags :: 2 bytes Bit 0: Offline signature present (0=no, 1=yes) Bit 1: Unpublished (0=published, 1=client-side only) Bits 15-2: Reserved (must be 0) offline_signature :: OfflineSignature (optional) Present only if flags bit 0 = 1 Variable length len :: 2-byte integer Length of encrypted_data Range: 1 to 65535 encrypted_data :: Encrypted payload Length: len bytes Contains encrypted LeaseSet2 or MetaLeaseSet signature :: Signature (64 bytes for RedDSA) Length determined by sigtype Signed by blinded_public_key or transient key डेटाबेस स्टोरेज: - डेटाबेस प्रकार: 5 - कुंजी: blinded Destination (I2P गंतव्य/पहचान) का SHA-256 हैश (मूल Destination नहीं) - मान: पूर्ण EncryptedLeaseSet (एन्क्रिप्टेड leaseSet) संरचना\nLeaseSet2 की तुलना में महत्वपूर्ण अंतर:\nLeaseSet2Header संरचना का उपयोग नहीं करता (फ़ील्ड मिलते-जुलते हैं, लेकिन लेआउट अलग है) पूर्ण Destination (I2P गंतव्य पहचान) के बजाय ब्लाइंडेड सार्वजनिक कुंजी सादा-पाठ लीज़ और कुंजियों के बजाय एन्क्रिप्टेड पेलोड डेटाबेस कुंजी ब्लाइंडेड Destination का हैश है, मूल Destination नहीं हस्ताक्षर की गणना:\nData to sign: database_type (1 byte, value=5) || complete EncryptedLeaseSet data Verification: 1. Prepend database type byte (0x05) to EncryptedLeaseSet data 2. If offline signature present (flags bit 0 = 1): - Verify offline signature against blinded public key - Verify EncryptedLeaseSet signature against transient key 3. Else: - Verify EncryptedLeaseSet signature against blinded public key हस्ताक्षर प्रकार की आवश्यकता:\nRedDSA_SHA512_Ed25519 (type 11) का उपयोग अनिवार्य है: - 32-बाइट blinded सार्वजनिक कुंजियाँ - 64-बाइट हस्ताक्षर - blinding (हस्ताक्षर करते समय संदेश को हस्ताक्षरकर्ता से छुपाने की तकनीक) सुरक्षा गुणों के लिए आवश्यक - देखें [Red25519 विशिष्टता](//docs/specs/red25519-signature-scheme/\nEdDSA से प्रमुख अंतर: - निजी कुंजियाँ modular reduction (मॉड्यूलो में घटाव; clamping नहीं) द्वारा - हस्ताक्षरों में 80 बाइट यादृच्छिक डेटा शामिल होता है - सार्वजनिक कुंजियों का सीधे उपयोग करता है (हैश नहीं) - सुरक्षित blinding ऑपरेशन सक्षम करता है (ब्लाइंडिंग: हस्ताक्षर करने से पहले संदेश/कुंजी को यादृच्छिकता से छुपाने की प्रक्रिया)\nBlinding (क्रिप्टोग्राफ़िक छिपाव) और कूटलेखन:\nविस्तृत जानकारी के लिए EncryptedLeaseSet विनिर्देशन देखें:\n1. Key Blinding (कुंजी को ब्लाइंड/छिपाने की तकनीक):\nBlinding process (daily rotation): secret = HKDF(original_signing_private_key, date_string, \u0026#34;i2pblinding1\u0026#34;) alpha = SHA-256(secret) mod L (where L is Ed25519 group order) blinded_private_key = alpha * original_private_key blinded_public_key = alpha * original_public_key 2. डेटाबेस स्थान:\nClient publishes to: Key = SHA-256(blinded_destination) Where blinded_destination uses: - Blinded public key (signing key) - Same unused public key field (random) - Same certificate structure 3. एन्क्रिप्शन परतें (तीन-स्तरीय):\nलेयर 1 - ऑथेंटिकेशन लेयर (क्लाइंट एक्सेस): - एन्क्रिप्शन: ChaCha20 स्ट्रीम साइफर - की डेरिवेशन: HKDF, प्रत्येक क्लाइंट के लिए अलग सीक्रेट्स के साथ - प्रमाणित क्लाइंट बाहरी लेयर को डिक्रिप्ट कर सकते हैं\nपरत 2 - एन्क्रिप्शन परत: - एन्क्रिप्शन: ChaCha20 - कुंजी: क्लाइंट और सर्वर के बीच DH (Diffie-Hellman कुंजी-विनिमय) से व्युत्पन्न - इसमें वास्तविक LeaseSet2 या MetaLeaseSet शामिल है\nपरत 3 - आंतरिक LeaseSet: - पूर्ण LeaseSet2 या MetaLeaseSet - सभी tunnels, एन्क्रिप्शन कुंजियाँ, विकल्प शामिल - केवल सफल डिक्रिप्शन के बाद सुलभ\nएन्क्रिप्शन कुंजी व्युत्पत्ति:\nClient has: ephemeral_client_private_key Server has: ephemeral_server_public_key (in encrypted_data) Shared secret = X25519(client_private, server_public) Encryption key = HKDF(shared_secret, context_info, \u0026#34;i2pblinding2\u0026#34;) खोज प्रक्रिया:\nअधिकृत क्लाइंट्स के लिए:\n1. Client knows original Destination 2. Client computes current blinded Destination (based on current date) 3. Client computes database key: SHA-256(blinded_destination) 4. Client queries netdb for EncryptedLeaseSet using blinded key 5. Client decrypts layer 1 using authorization credentials 6. Client decrypts layer 2 using DH shared secret 7. Client extracts inner LeaseSet2/MetaLeaseSet 8. Client uses tunnels from inner LeaseSet for communication अनधिकृत क्लाइंट्स के लिए: - डिक्रिप्ट नहीं कर सकते, भले ही उन्हें EncryptedLeaseSet (एन्क्रिप्टेड leaseSet) मिल जाए - ब्लाइंडेड संस्करण से मूल Destination (I2P का गंतव्य पता) निर्धारित नहीं कर सकते - विभिन्न blinding periods (ब्लाइंडिंग अवधि; दैनिक रोटेशन) के बीच EncryptedLeaseSets को आपस में लिंक नहीं कर सकते\nसमाप्ति समय:\nContent Type Maximum Expires Notes EncryptedLeaseSet (outer)65,535 sec (≈18.2 hr)Full 2-byte expires field Inner LeaseSet2≈660 sec (≈11 min)Actual lease data practical maximum Inner MetaLeaseSet65,535 sec (≈18.2 hr)Indirection can be longer-lived **प्रकाशित टाइमस्टैम्प:** LeaseSet2Header (I2P में LeaseSet v2 का हेडर) के समान आवश्यकताएँ: - प्रकाशनों के बीच समय में कम-से-कम 1 सेकंड की वृद्धि होनी चाहिए - यदि वर्तमान संस्करण से नया नहीं है तो Floodfills (I2P के netDb के विशेष नोड जो डेटा संग्रहित/वितरित करते हैं) अस्वीकार कर देंगे - अनुशंसित: प्रकाशनों के बीच 10-60 सेकंड\nएन्क्रिप्टेड LeaseSets (I2P में leaseSet: सेवा तक पहुँच के लिए उपयोग होने वाले इनबाउंड tunnel विवरणों का सेट) के साथ ऑफ़लाइन हस्ताक्षर:\nऑफ़लाइन हस्ताक्षरों का उपयोग करते समय विशेष ध्यान देने योग्य बातें: - Blinded public key (ब्लाइंडेड सार्वजनिक कुंजी) प्रतिदिन बदलती है - ऑफ़लाइन हस्ताक्षर को नई blinded key के साथ प्रतिदिन पुनः उत्पन्न करना होगा - या अंदरूनी LeaseSet पर ऑफ़लाइन हस्ताक्षर का उपयोग करें, बाहरी EncryptedLeaseSet पर नहीं - नोट्स के लिए Proposal 123 देखें\nकार्यान्वयन संबंधी टिप्पणियाँ:\nक्लाइंट प्राधिकरण:\nकई क्लाइंट को अलग-अलग कुंजियों के साथ अधिकृत किया जा सकता है प्रत्येक अधिकृत क्लाइंट के पास अद्वितीय डिक्रिप्शन प्रमाण-पत्र होते हैं प्राधिकरण कुंजियाँ बदलकर क्लाइंट का प्राधिकरण रद्द करें दैनिक कुंजी रोटेशन:\nBlinded keys (ब्लाइंडेड कीज़—गोपनीयता हेतु छिपाई गई कुंजियाँ) UTC मध्यरात्रि पर बदलती हैं क्लाइंट को प्रतिदिन blinded Destination (I2P में Destination—गंतव्य पहचान—का ब्लाइंडेड रूप) की पुनर्गणना करनी होती है पुराने EncryptedLeaseSets रोटेशन के बाद खोज योग्य नहीं हो जाते गोपनीयता गुणधर्म:\nFloodfills मूल Destination (I2P का गंतव्य-पहचान ऑब्जेक्ट) का पता नहीं लगा सकते अनधिकृत क्लाइंट सेवा तक पहुँच नहीं कर सकते अलग-अलग blinding (पहचान छिपाने की तकनीक) अवधियों को आपस में जोड़ा नहीं जा सकता समाप्ति समय से आगे कोई स्पष्ट-पाठ मेटाडेटा नहीं होता प्रदर्शन:\nक्लाइंट को दैनिक blinding (ब्लाइंडिंग) गणना करना आवश्यक है त्रि-स्तरीय एन्क्रिप्शन गणनात्मक ओवरहेड बढ़ाता है डिक्रिप्टेड आंतरिक LeaseSet को कैश करने पर विचार करें सुरक्षा संबंधी विचार:\nप्राधिकरण कुंजी प्रबंधन:\nक्लाइंट प्राधिकरण प्रमाण-पत्रों को सुरक्षित रूप से वितरित करें सूक्ष्म-स्तरीय रद्दीकरण के लिए प्रति क्लाइंट अद्वितीय प्रमाण-पत्रों का उपयोग करें प्राधिकरण कुंजियों को नियमित अंतराल पर बदलें घड़ी समकालन:\nदैनिक blinding (गोपनीयता हेतु क्रिप्टोग्राफ़िक तकनीक) समकालित UTC तिथियों पर निर्भर करती है घड़ी के समय में अंतर लुकअप विफलताओं का कारण बन सकता है सहनशीलता के लिए पिछले/अगले दिन की blinding का समर्थन करने पर विचार करें मेटाडेटा का रिसाव:\nPublished और expires फ़ील्ड स्पष्ट-पाठ में होते हैं पैटर्न विश्लेषण सेवा की विशेषताओं का खुलासा कर सकता है यदि चिंता हो तो प्रकाशन अंतराल को यादृच्छिक बनाएं JavaDoc प्रलेखन: EncryptedLeaseSet Router संरचनाएँ RouterAddress (I2P router का transport पता, जिस पर अन्य routers उससे कनेक्ट होते हैं) विवरण: एक विशिष्ट ट्रांसपोर्ट प्रोटोकॉल के माध्यम से किसी router के लिए कनेक्शन संबंधी जानकारी को परिभाषित करता है।\nप्रारूप:\n+----+----+----+----+----+----+----+----+ |cost| expiration +----+----+----+----+----+----+----+----+ | transport_style | +----+----+----+----+-//-+----+----+----+ | | + + | options | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ cost :: Integer (1 byte) Relative cost, 0=free, 255=expensive Typical values: 5-6: SSU2 10-11: NTCP2 expiration :: Date (8 bytes) MUST BE ALL ZEROS (see critical note below) transport_style :: String (1-256 bytes) Transport protocol name Current values: \u0026#34;SSU2\u0026#34;, \u0026#34;NTCP2\u0026#34; Legacy: \u0026#34;SSU\u0026#34;, \u0026#34;NTCP\u0026#34; (removed) options :: Mapping Transport-specific configuration Common options: \u0026#34;host\u0026#34;, \u0026#34;port\u0026#34; Transport-specific options vary गंभीर - समाप्ति फ़ील्ड:\n⚠️ समाप्ति फ़ील्ड को अनिवार्य रूप से सभी शून्य (8 शून्य बाइट्स) पर सेट किया जाना चाहिए।\nकारण: रिलीज़ 0.9.3 से, गैर-शून्य Expiration (समाप्ति) के कारण हस्ताक्षर सत्यापन विफल हो जाता है इतिहास: Expiration मूल रूप से उपयोग में नहीं था, हमेशा null रहता था वर्तमान स्थिति: फ़ील्ड को 0.9.12 से फिर से पहचाना गया है, लेकिन नेटवर्क अपग्रेड का इंतज़ार करना होगा कार्यान्वयन: हमेशा 0x0000000000000000 पर सेट करें किसी भी गैर-शून्य समाप्ति समय से RouterInfo के हस्ताक्षर का सत्यापन विफल हो जाएगा।\nपरिवहन प्रोटोकॉल वर्तमान प्रोटोकॉल (2.10.0 तक):\nProtocol Status Introduced Removed Notes SSU2Current0.9.54 (May 2022)-Default since 0.9.56 NTCP2Current0.9.36 (Aug 2018)-Active NTCPRemoved-0.9.50 (May 2021)Use NTCP2 SSURemoved-2.4.0 (Dec 2023)Use SSU2 **ट्रांसपोर्ट शैली मान:** - `\"SSU2\"`: वर्तमान UDP-आधारित ट्रांसपोर्ट - `\"NTCP2\"`: वर्तमान TCP-आधारित ट्रांसपोर्ट - `\"NTCP\"`: पुराना, हटाया गया (उपयोग न करें) - `\"SSU\"`: पुराना, हटाया गया (उपयोग न करें) सामान्य विकल्प आमतौर पर सभी transports (ट्रांसपोर्ट प्रोटोकॉल) में निम्नलिखित शामिल होते हैं:\n\u0026#34;host\u0026#34; = IPv4 or IPv6 address or hostname \u0026#34;port\u0026#34; = Port number (1-65535) SSU2-विशिष्ट विकल्प पूर्ण विवरण के लिए SSU2 विनिर्देश देखें।\nआवश्यक विकल्प:\n\u0026#34;host\u0026#34; = IP address (IPv4 or IPv6) \u0026#34;port\u0026#34; = UDP port number \u0026#34;s\u0026#34; = Static X25519 public key (Base64, 44 characters = 32 bytes) \u0026#34;i\u0026#34; = Introduction key X25519 (Base64, 44 characters = 32 bytes) \u0026#34;v\u0026#34; = \u0026#34;2\u0026#34; (protocol version) वैकल्पिक विकल्प:\n\u0026#34;caps\u0026#34; = Capability string (e.g., \u0026#34;B\u0026#34; for bandwidth tier) \u0026#34;ihost0\u0026#34;, \u0026#34;ihost1\u0026#34;, ... = Introducer IP addresses \u0026#34;iport0\u0026#34;, \u0026#34;iport1\u0026#34;, ... = Introducer ports \u0026#34;ikey0\u0026#34;, \u0026#34;ikey1\u0026#34;, ... = Introducer static keys (Base64, 44 chars) \u0026#34;itag0\u0026#34;, \u0026#34;itag1\u0026#34;, ... = Introducer relay tags \u0026#34;iexp0\u0026#34;, \u0026#34;iexp1\u0026#34;, ... = Introducer expiration timestamps \u0026#34;mtu\u0026#34; = Maximum transmission unit (default 1500, min 1280) \u0026#34;mtu6\u0026#34; = IPv6 MTU (if different from IPv4) उदाहरण SSU2 RouterAddress:\ncost: 5 expiration: 0x0000000000000000 transport_style: \u0026#34;SSU2\u0026#34; options: host=198.51.100.42 port=12345 s=SGVsbG8gV29ybGQhIFRoaXMgaXMgYSBzYW1wbGUga2V5IQ== i=QW5vdGhlciBTYW1wbGUgS2V5IGZvciBJbnRyb2R1Y3Rpb24= v=2 caps=BC mtu=1472 NTCP2-विशिष्ट विकल्प पूर्ण विवरण के लिए NTCP2 विनिर्देश देखें।\nआवश्यक विकल्प:\n\u0026#34;host\u0026#34; = IP address (IPv4 or IPv6) \u0026#34;port\u0026#34; = TCP port number \u0026#34;s\u0026#34; = Static X25519 public key (Base64, 44 characters = 32 bytes) \u0026#34;i\u0026#34; = Initialization vector (Base64, 24 characters = 16 bytes) \u0026#34;v\u0026#34; = \u0026#34;2\u0026#34; (protocol version) वैकल्पिक विकल्प (0.9.50 से):\n\u0026#34;caps\u0026#34; = Capability string उदाहरण NTCP2 RouterAddress (router का पता):\ncost: 10 expiration: 0x0000000000000000 transport_style: \u0026#34;NTCP2\u0026#34; options: host=198.51.100.42 port=23456 s=SGVsbG8gV29ybGQhIFRoaXMgaXMgYSBzYW1wbGUga2V5IQ== i=U2FtcGxlIElWIGhlcmU= v=2 कार्यान्वयन संबंधी टिप्पणियाँ लागत मान:\nUDP (SSU2) दक्षता के कारण आम तौर पर कम लागत (5-6) TCP (NTCP2) ओवरहेड के कारण आम तौर पर अधिक लागत (10-11) कम लागत = वरीय ट्रांसपोर्ट कई पते:\nRouters कई RouterAddress प्रविष्टियाँ प्रकाशित कर सकते हैं विभिन्न transports (परिवहन प्रोटोकॉल) (SSU2 और NTCP2) विभिन्न IP संस्करण (IPv4 और IPv6) क्लाइंट लागत और क्षमताओं के आधार पर चयन करते हैं Hostname बनाम IP:\nप्रदर्शन के लिए IP पते को प्राथमिकता दें होस्टनेम समर्थित हैं, लेकिन DNS लुकअप का अतिरिक्त ओवरहेड जोड़ते हैं प्रकाशित RouterInfos के लिए IP का उपयोग करने पर विचार करें Base64 एन्कोडिंग:\nसभी कुंजियाँ और बाइनरी डेटा Base64 में एन्कोड किए गए हैं मानक Base64 (RFC 4648) padding (अतिरिक्त भराव) नहीं, और कोई गैर-मानक अक्षर नहीं JavaDoc (जावा दस्तावेज़ीकरण): RouterAddress RouterInfo विवरण: नेटवर्क डेटाबेस में संग्रहीत, किसी router के बारे में प्रकाशित संपूर्ण जानकारी। इसमें पहचान, पते और क्षमताएँ शामिल होती हैं।\nप्रारूप:\n+----+----+----+----+----+----+----+----+ | router_ident | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | published | +----+----+----+----+----+----+----+----+ |size| RouterAddress 0 | +----+ + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | RouterAddress 1 | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | RouterAddress ($size-1) | + + | | ~ ~ ~ ~ | | +----+----+----+----+-//-+----+----+----+ |psiz| options | +----+----+----+----+-//-+----+----+----+ | signature | + + | | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ router_ident :: RouterIdentity Length: 387+ bytes (typically 391 for X25519+EdDSA) published :: Date (8 bytes) Publication timestamp (milliseconds since epoch) size :: Integer (1 byte) Number of RouterAddress entries Range: 0-255 addresses :: Array of RouterAddress Variable length Each RouterAddress has variable size peer_size :: Integer (1 byte) Number of peer hashes (ALWAYS 0) Historical, unused feature options :: Mapping Router capabilities and metadata MUST be sorted by key signature :: Signature Length determined by router_ident signing key type Typically 64 bytes (EdDSA) Signed by router_ident\u0026#39;s SigningPrivateKey डेटाबेस स्टोरेज: - डेटाबेस प्रकार: 0 - कुंजी: RouterIdentity (राउटर पहचान) का SHA-256 हैश - मान: पूर्ण RouterInfo (राउटर जानकारी) संरचना\nप्रकाशित टाइमस्टैम्प: - 8-बाइट दिनांक (epoch से मिलीसेकंड) - RouterInfo वर्ज़निंग के लिए उपयोग होता है - Routers समय-समय पर नया RouterInfo प्रकाशित करते हैं - Floodfills प्रकाशित टाइमस्टैम्प के आधार पर नवीनतम संस्करण बनाए रखते हैं\nपता क्रमबद्धता: - ऐतिहासिक: बहुत पुराने routers में उनके डेटा के SHA-256 के अनुसार पते क्रमबद्ध होना आवश्यक था - वर्तमान: क्रमबद्धता आवश्यक नहीं है, अनुकूलता के लिए इसे लागू करना सार्थक नहीं है - पते किसी भी क्रम में हो सकते हैं\nपीयर आकार फ़ील्ड (ऐतिहासिक): - आधुनिक I2P में हमेशा 0 - प्रतिबंधित मार्गों के लिए अभिप्रेत था (लागू नहीं किया गया) - लागू किया जाता, तो उसके बाद उतने Router Hashes आते - कुछ पुराने कार्यान्वयनों में क्रमबद्ध पीयर सूची की आवश्यकता हो सकती थी\nविकल्प मैपिंग:\nविकल्पों को कुंजी के अनुसार अनिवार्य रूप से क्रमबद्ध होना चाहिए। मानक विकल्पों में शामिल हैं:\nक्षमता विकल्प:\n\u0026#34;caps\u0026#34; = Capability string Common values: f = Floodfill (network database) L or M or N or O = Bandwidth tier (L=lowest, O=highest) R = Reachable U = Unreachable/firewalled Example: \u0026#34;fLRU\u0026#34; = Floodfill, Low bandwidth, Reachable, Unreachable नेटवर्क विकल्प:\n\u0026#34;netId\u0026#34; = Network ID (default \u0026#34;2\u0026#34; for main I2P network) Different values for test networks \u0026#34;router.version\u0026#34; = I2P version string Example: \u0026#34;0.9.67\u0026#34; or \u0026#34;2.10.0\u0026#34; सांख्यिकीय विकल्प:\n\u0026#34;stat_uptime\u0026#34; = Uptime in milliseconds \u0026#34;coreVersion\u0026#34; = Core I2P version \u0026#34;router.version\u0026#34; = Full router version string मानक विकल्पों की पूरी सूची के लिए Network Database RouterInfo दस्तावेज़ देखें।\nहस्ताक्षर की गणना:\nData to sign: Complete RouterInfo structure from router_ident through options Verification: 1. Extract RouterIdentity from RouterInfo 2. Get SigningPublicKey from RouterIdentity (type determines algorithm) 3. Verify signature over all data preceding signature field 4. Signature must match signing key type and length सामान्य आधुनिक RouterInfo (Router की जानकारी):\nRouterIdentity: 391 bytes (X25519+EdDSA with Key Certificate) Published: 8 bytes Size: 1 byte (typically 1-4 addresses) RouterAddress × N: Variable (typically 200-500 bytes each) Peer Size: 1 byte (value=0) Options: Variable (typically 50-200 bytes) Signature: 64 bytes (EdDSA) Total: ~1000-2500 bytes typical कार्यान्वयन संबंधी टिप्पणियाँ:\nएकाधिक पते:\nRouters आमतौर पर 1-4 पते प्रकाशित करते हैं IPv4 और IPv6 रूपांतर SSU2 और/या NTCP2 ट्रांसपोर्ट प्रत्येक पता स्वतंत्र होता है संस्करण-प्रबंधन:\nनवीनतर RouterInfo में published टाइमस्टैम्प अधिक हाल का होता है Routers लगभग हर ~2 घंटे में या जब पते बदलते हैं, पुनर्प्रकाशित करते हैं Floodfills केवल नवीनतम संस्करण को संग्रहीत करते हैं और उसी को प्रसारित करते हैं सत्यापन:\nRouterInfo (राउटर की जानकारी रिकॉर्ड) को स्वीकार करने से पहले हस्ताक्षर सत्यापित करें प्रत्येक RouterAddress (राउटर पता) में समाप्ति फ़ील्ड सभी शून्य है, यह जाँचें सत्यापित करें कि विकल्प मैपिंग कुंजी के अनुसार क्रमबद्ध है जाँचें कि प्रमाणपत्र और कुंजी प्रकार ज्ञात/समर्थित हैं नेटवर्क डेटाबेस:\nFloodfills (विशेष routers जो नेटवर्क डेटाबेस प्रविष्टियों का संग्रह/वितरण करते हैं) Hash(RouterIdentity) द्वारा अनुक्रमित RouterInfo संग्रहीत करते हैं अंतिम प्रकाशन के बाद ~2 दिनों तक संग्रहीत रहता है Routers अन्य routers को खोजने के लिए floodfills से क्वेरी करते हैं JavaDoc: RouterInfo कार्यान्वयन संबंधी टिप्पणियाँ बाइट क्रम (Endianness—मेमोरी में बाइट्स की व्यवस्था) डिफ़ॉल्ट: Big-Endian (नेटवर्क बाइट ऑर्डर)\nअधिकांश I2P संरचनाएँ big-endian (जहाँ सबसे महत्वपूर्ण बाइट पहले आती है) बाइट क्रम का उपयोग करती हैं: - सभी पूर्णांक प्रकार (1-8 बाइट्स) - दिनांक टाइमस्टैम्प - TunnelId - स्ट्रिंग लंबाई प्रीफ़िक्स - प्रमाणपत्र प्रकार और लंबाइयाँ - कुंजी प्रकार कोड - मैपिंग आकार फ़ील्ड्स\nअपवाद: Little-Endian (कम-महत्त्व वाला बाइट पहले वाला बाइट क्रम)\nनिम्नलिखित कुंजी प्रकार little-endian (कम-महत्त्वपूर्ण-बाइट-प्रथम क्रम) एन्कोडिंग का उपयोग करते हैं:\nX25519 एन्क्रिप्शन कुंजियाँ (प्रकार 4) EdDSA_SHA512_Ed25519 हस्ताक्षर कुंजियाँ (प्रकार 7) EdDSA_SHA512_Ed25519ph हस्ताक्षर कुंजियाँ (प्रकार 8) RedDSA_SHA512_Ed25519 हस्ताक्षर कुंजियाँ (प्रकार 11) कार्यान्वयन:\n// Big-endian (most structures) int value = ((bytes[0] \u0026amp; 0xFF) \u0026lt;\u0026lt; 24) | ((bytes[1] \u0026amp; 0xFF) \u0026lt;\u0026lt; 16) | ((bytes[2] \u0026amp; 0xFF) \u0026lt;\u0026lt; 8) | (bytes[3] \u0026amp; 0xFF); // Little-endian (X25519, EdDSA, RedDSA) int value = (bytes[0] \u0026amp; 0xFF) | ((bytes[1] \u0026amp; 0xFF) \u0026lt;\u0026lt; 8) | ((bytes[2] \u0026amp; 0xFF) \u0026lt;\u0026lt; 16) | ((bytes[3] \u0026amp; 0xFF) \u0026lt;\u0026lt; 24); संरचना का संस्करण निर्धारण कभी भी स्थिर आकार मानकर न चलें:\nकई संरचनाओं की लंबाई परिवर्तनीय होती है: - RouterIdentity (राउटर की पहचान): 387+ बाइट्स (हमेशा 387 नहीं) - Destination (गंतव्य): 387+ बाइट्स (हमेशा 387 नहीं) - LeaseSet2 (LeaseSet का दूसरा संस्करण): लंबाई में काफी भिन्नता होती है - Certificate (प्रमाणपत्र): 3+ बाइट्स\nहमेशा आकार फ़ील्ड पढ़ें: - प्रमाणपत्र की लंबाई बाइट्स 1-2 पर - शुरुआत में मैपिंग का आकार - KeysAndCert का मान हमेशा 384 + 3 + certificate_length के रूप में गणना करें\nअतिरिक्त डेटा की जाँच करें: - मान्य संरचनाओं के बाद आने वाले अनावश्यक डेटा को रोकें - सत्यापित करें कि प्रमाणपत्रों की लंबाई कुंजी प्रकारों से मेल खाती है - स्थिर आकार के प्रकारों के लिए अपेक्षित सटीक लंबाइयों को अनिवार्य करें\nवर्तमान अनुशंसाएँ (अक्टूबर 2025) नई Router पहचानों के लिए:\nEncryption: X25519 (type 4, 32 bytes) Signing: EdDSA_SHA512_Ed25519 (type 7, 32 bytes) Certificate: Key Certificate (type 5) Total Size: 391 bytes Padding: Compressible per [Proposal 161](/hi/proposals/161-ri-dest-padding/) नए गंतव्यों के लिए:\nUnused Public Key Field: 256 bytes random (compressible) Signing: EdDSA_SHA512_Ed25519 (type 7, 32 bytes) Certificate: Key Certificate (type 5) Total Size: 391 bytes Padding: Compressible per [Proposal 161](/hi/proposals/161-ri-dest-padding/) नए LeaseSets के लिए:\nType: LeaseSet2 (type 3) Encryption Keys: X25519 (type 4, 32 bytes) Leases: At least 1, typically 3-5 Options: Include service records per [Proposal 167](/proposals/167-service-records/) Signature: EdDSA (64 bytes) एन्क्रिप्टेड सेवाओं के लिए:\nType: EncryptedLeaseSet (type 5) Blinding: RedDSA_SHA512_Ed25519 (type 11) Inner LeaseSet: LeaseSet2 (type 3) Rotation: Daily blinding key rotation Authorization: Per-client encryption keys अप्रचलित विशेषताएँ - उपयोग न करें अप्रचलित एन्क्रिप्शन: - ElGamal (प्रकार 0) Router पहचानों के लिए (0.9.58 में अप्रचलित) - ElGamal/AES+SessionTag एन्क्रिप्शन (ECIES-X25519 का उपयोग करें)\nअप्रचलित साइनिंग: - DSA_SHA1 (प्रकार 0) Router पहचानें के लिए (0.9.58 से अप्रचलित) - ECDSA वैरिएंट (प्रकार 1-3) नए कार्यान्वयनों के लिए - RSA वैरिएंट (प्रकार 4-6) SU3 फ़ाइलों को छोड़कर\nअप्रचलित नेटवर्क फ़ॉर्मेट: - LeaseSet प्रकार 1 (LeaseSet2 का उपयोग करें) - Lease (I2P रिकॉर्ड, 44 बाइट्स, Lease2 का उपयोग करें) - मूल Lease की समाप्ति का फ़ॉर्मेट\nअप्रचलित ट्रांसपोर्ट्स: - NTCP (0.9.50 में हटाया गया) - SSU (2.4.0 में हटाया गया)\nअप्रचलित प्रमाणपत्र: - HASHCASH (प्रकार 1) - HIDDEN (प्रकार 2) - SIGNED (प्रकार 3) - MULTIPLE (прकार 4)\nसुरक्षा संबंधी विचार कुंजी निर्माण: - हमेशा क्रिप्टोग्राफ़िक रूप से सुरक्षित यादृच्छिक संख्या जनरेटर का उपयोग करें - विभिन्न संदर्भों में कुंजियों का पुन: उपयोग कभी न करें - उपयुक्त अभिगम नियंत्रणों के साथ निजी कुंजियों की सुरक्षा करें - समाप्त होने पर मेमोरी से कुंजी सामग्री को सुरक्षित रूप से मिटा दें\nहस्ताक्षर सत्यापन: - डेटा पर भरोसा करने से पहले हमेशा हस्ताक्षरों को सत्यापित करें - जांचें कि हस्ताक्षर की लंबाई कुंजी प्रकार से मेल खाती है - सुनिश्चित करें कि हस्ताक्षरित डेटा में अपेक्षित फ़ील्ड शामिल हैं - क्रमबद्ध mappings (मैपिंग्स) के लिए, हस्ताक्षर करने/सत्यापित करने से पहले छँटाई क्रम सत्यापित करें\nटाइमस्टैम्प सत्यापन: - यह जाँचें कि प्रकाशित समय उचित हैं (बहुत दूर भविष्य में नहीं) - यह सत्यापित करें कि लीज़ की समाप्ति तिथियाँ अभी समाप्त नहीं हुई हैं - घड़ी के विचलन की सहिष्णुता पर विचार करें (±30 सेकंड सामान्य)\nनेटवर्क डेटाबेस: - संग्रहित करने से पहले सभी संरचनाओं को सत्यापित करें - DoS रोकने के लिए आकार सीमाएँ लागू करें - क्वेरियों और प्रकाशनों पर दर-सीमा लागू करें - सत्यापित करें कि डेटाबेस कुंजियाँ संरचना हैश से मेल खाती हैं\nसंगतता नोट्स पिछली संगतता: - पुराने routers के लिए ElGamal और DSA_SHA1 अब भी समर्थित हैं - अप्रचलित कुंजी प्रकार कार्यशील तो हैं, लेकिन अनुशंसित नहीं हैं - कंप्रेस करने योग्य पैडिंग (प्रस्ताव 161 ) 0.6 तक पिछली संगतता रखती है\nForward Compatibility (भविष्य संस्करणों के साथ संगतता): - अज्ञात कुंजी प्रकारों को लंबाई फ़ील्ड्स का उपयोग करके पार्स किया जा सकता है - अज्ञात प्रमाणपत्र प्रकारों को लंबाई का उपयोग करके छोड़ा जा सकता है - अज्ञात हस्ताक्षर प्रकारों को सुगमता से संभाला जाना चाहिए - कार्यान्वयन को अज्ञात वैकल्पिक विशेषताओं पर विफल नहीं होना चाहिए\nमाइग्रेशन रणनीतियाँ: - संक्रमण के दौरान पुराने और नए दोनों कुंजी प्रकारों का समर्थन - LeaseSet2 कई एन्क्रिप्शन कुंजियों की सूची दे सकता है - ऑफ़लाइन हस्ताक्षर सुरक्षित कुंजी रोटेशन सक्षम करते हैं - MetaLeaseSet (पारदर्शी सेवा माइग्रेशन के लिए संरचना) सेवा माइग्रेशन को पारदर्शी बनाता है\nपरीक्षण और सत्यापन संरचना सत्यापन: - सत्यापित करें कि सभी लंबाई फ़ील्ड अपेक्षित सीमाओं के भीतर हैं - जाँचें कि चर-लंबाई वाली संरचनाएँ सही ढंग से पार्स होती हैं - सुनिश्चित करें कि हस्ताक्षरों का सत्यापन सफल है - न्यूनतम और अधिकतम आकार वाली संरचनाओं दोनों के साथ परीक्षण करें\nसीमांत मामले: - शून्य-लंबाई स्ट्रिंग्स - खाली मैपिंग्स - lease (I2P में रूटिंग रिकॉर्ड) की न्यूनतम और अधिकतम संख्या - शून्य-लंबाई पेलोड वाला प्रमाणपत्र - बहुत बड़ी संरचनाएँ (अधिकतम आकार के निकट)\nअंतरसंचालनीयता: - आधिकारिक Java I2P कार्यान्वयन के विरुद्ध परीक्षण करें - i2pd के साथ अनुकूलता की जाँच करें - विभिन्न नेटवर्क डेटाबेस सामग्री के साथ परीक्षण करें - ज्ञात-सही परीक्षण वेक्टरों के साथ सत्यापन करें\nसंदर्भ विनिर्देश I2NP प्रोटोकॉल I2CP प्रोटोकॉल SSU2 ट्रांसपोर्ट NTCP2 ट्रांसपोर्ट Tunnel प्रोटोकॉल डेटाग्राम प्रोटोकॉल कूटलेखन क्रिप्टोग्राफ़ी का अवलोकन ElGamal/AES एन्क्रिप्शन ECIES-X25519 एन्क्रिप्शन (ECIES: एलिप्टिक कर्व एकीकृत एन्क्रिप्शन स्कीम) Routers के लिए ECIES ECIES हाइब्रिड (पोस्ट-क्वांटम) Red25519 हस्ताक्षर एन्क्रिप्टेड LeaseSet प्रस्ताव प्रस्ताव 123: netDB में नई प्रविष्टियाँ प्रस्ताव 134: GOST हस्ताक्षर प्रकार प्रस्ताव 136: प्रायोगिक हस्ताक्षर प्रकार प्रस्ताव 145: ECIES-P256 प्रस्ताव 156: ECIES Routers प्रस्ताव 161: Padding (पैडिंग/भराई) निर्माण प्रस्ताव 167: सेवा रिकॉर्ड प्रस्ताव 169: पोस्ट-क्वांटम क्रिप्टोग्राफी सभी प्रस्तावों की सूची नेटवर्क डेटाबेस नेटवर्क डेटाबेस का अवलोकन RouterInfo मानक विकल्प JavaDoc API संदर्भ कोर डेटा पैकेज PublicKey PrivateKey SessionKey SigningPublicKey SigningPrivateKey Signature Hash SessionTag TunnelId Certificate DataHelper KeysAndCert RouterIdentity Destination Lease LeaseSet Lease2 LeaseSet2 MetaLease MetaLeaseSet EncryptedLeaseSet RouterAddress RouterInfo बाहरी मानक RFC 7748 (X25519): सुरक्षा के लिए एलिप्टिक कर्व्स RFC 7539 (ChaCha20): IETF प्रोटोकॉल्स के लिए ChaCha20 और Poly1305 RFC 4648 (Base64): Base16, Base32, और Base64 डेटा एन्कोडिंग्स FIPS 180-4 (SHA-256): सुरक्षित हैश मानक FIPS 204 (ML-DSA): Module-Lattice-Based Digital Signature Standard (मॉड्यूल-लैटिस-आधारित डिजिटल हस्ताक्षर मानक) IANA सेवा रजिस्ट्री सामुदायिक संसाधन I2P वेबसाइट I2P फ़ोरम I2P GitLab I2P GitHub मिरर तकनीकी प्रलेखन सूचकांक रिलीज़ जानकारी I2P 2.10.0 रिलीज़ रिलीज़ इतिहास चेंजलॉग परिशिष्ट: त्वरित संदर्भ तालिकाएँ कुंजी प्रकार त्वरित संदर्भ वर्तमान मानक (सभी नए कार्यान्वयनों के लिए अनुशंसित): - एन्क्रिप्शन: X25519 (प्रकार 4, 32 बाइट, लिटिल-एंडियन) - हस्ताक्षर: EdDSA_SHA512_Ed25519 (प्रकार 7, 32 बाइट, लिटिल-एंडियन)\nलेगेसी (समर्थित लेकिन अप्रचलित): - एन्क्रिप्शन: ElGamal (type 0, 256 बाइट्स, big-endian (सबसे महत्त्वपूर्ण बाइट पहले वाला क्रम)) - साइनिंग: DSA_SHA1 (type 0, 20-बाइट निजी / 128-बाइट सार्वजनिक, big-endian)\nविशेषीकृत: - हस्ताक्षर (एन्क्रिप्टेड LeaseSet): RedDSA_SHA512_Ed25519 (प्रकार 11, 32 बाइट, little-endian (कम-महत्वपूर्ण बाइट पहले))\nपोस्ट-क्वांटम (बीटा, अंतिम रूप नहीं दिया गया): - हाइब्रिड एन्क्रिप्शन: MLKEM_X25519 वेरिएंट्स (प्रकार 5-7) - शुद्ध PQ (पोस्ट-क्वांटम) एन्क्रिप्शन: MLKEM वेरिएंट्स (अभी प्रकार कोड आवंटित नहीं किए गए हैं)\nसंरचना आकार त्वरित संदर्भ Structure Minimum Size Typical Size Maximum Size Integer1 byteVaries8 bytes Date8 bytes8 bytes8 bytes String1 byteVaries256 bytes SessionKey32 bytes32 bytes32 bytes Hash32 bytes32 bytes32 bytes TunnelId4 bytes4 bytes4 bytes Certificate3 bytes7 bytes65,538 bytes KeysAndCert387 bytes391 bytes≈1000+ bytes RouterIdentity387 bytes391 bytes≈1000+ bytes Destination387 bytes391 bytes≈1000+ bytes Lease44 bytes44 bytes44 bytes Lease240 bytes40 bytes40 bytes LeaseSet≈1000 bytes≈1200 bytes≈2000+ bytes LeaseSet2≈500 bytes≈800 bytes≈2000+ bytes EncryptedLeaseSet≈600 bytes≈1000 bytes≈3000+ bytes RouterAddress≈150 bytes≈300 bytes≈600 bytes RouterInfo≈1000 bytes≈1500 bytes≈3000+ bytes ### डेटाबेस प्रकार त्वरित संदर्भ Type Structure Status Notes 0RouterInfoCurrentStored under Hash(RouterIdentity) 1LeaseSetDeprecatedUse LeaseSet2 instead 3LeaseSet2CurrentStored under Hash(Destination) 5EncryptedLeaseSetCurrentStored under Hash(Blinded Destination) 7MetaLeaseSetDefinedVerify production status ### ट्रांसपोर्ट प्रोटोकॉल त्वरित संदर्भ Protocol Status Port Type Since Notes SSU2CurrentUDP0.9.54Default since 0.9.56 NTCP2CurrentTCP0.9.36Active SSURemovedUDP-Removed in 2.4.0 NTCPRemovedTCP-Removed in 0.9.50 ### संस्करण माइलस्टोन त्वरित संदर्भ Version API Date Key Changes 0.60.6.x2005Destination encryption disabled 0.9.120.9.12Dec 2013Key Certificates introduced 0.9.150.9.15Sep 2015EdDSA support added 0.9.160.9.16Nov 2015Router Key Certificates 0.9.360.9.36Aug 2018NTCP2 introduced 0.9.380.9.38Nov 2018LeaseSet2, X25519 for Destinations 0.9.390.9.39Dec 2018EncryptedLeaseSet working 0.9.480.9.48Jul 2020X25519 for Router Identities 0.9.500.9.50May 2021NTCP removed 0.9.540.9.54May 2022SSU2 testing 0.9.570.9.57Jan 2023[Proposal 161](/hi/proposals/161-ri-dest-padding/) padding (release 2.1.0) 0.9.580.9.58Mar 2023ElGamal/DSA deprecated for RIs (2.2.0) 0.9.660.9.66Jun 2025[Proposal 167](/proposals/167-service-records/) service records (2.9.0) 0.9.670.9.67Sep 2025ML-KEM beta support (2.10.0) --- ","description":"विभिन्न I2P विनिर्देशों में प्रयुक्त साझा डेटा प्रकार और सीरियलाइज़ेशन प्रारूप","id":"178a1cfe9e5d2970a6e9f8d07c374b78","section":"docs","title":"सामान्य संरचनाएँ","url":"/hi/docs/specs/common-structures/"},{"categories":null,"content":"सुरक्षा संपर्क सुरक्षा कमजोरियों या संवेदनशील सुरक्षा मुद्दों की रिपोर्ट करने के लिए, कृपया I2P Security Team से security@i2p.net पर संपर्क करें\nसुरक्षित संचार के लिए, कृपया नीचे दी गई हमारी PGP key का उपयोग करें।\nPGP कुंजी जानकारी Email: security@i2p.net Key ID: 176E1941 Fingerprint: 40DF FE20 7D79 9BEC 3AE8 7DEA 5F98 BE91 176E 1941 Key Type: RSA 4096-bit बनाया गया: 2025-10-19 समाप्त होता है: 2030-11-19 UID: I2P Security \u0026lt;security@i2p.net\u0026gt; सार्वजनिक कुंजी I2P सुरक्षा टीम की GPG सार्वजनिक कुंजी निम्नलिखित है: \u0026mdash;\u0026ndash;BEGIN PGP PUBLIC KEY BLOCK\u0026mdash;\u0026ndash;\nmQINBGj1TtUBEADKsCC54egdJgxMs4HWcsYlr4GbrevM5gjZ+QZYEDGjaz44duOc E9W+a/NNA8PsryCql893odYdqGrFX+WTUT3UuN7DbbS7qSDs7jWZzjj0lr4/pbzJ B28lC0aIx6SQTEbzsGr2hOlFq/+JD9x/fMFrHFX81cJdIz9yabcH1vg9wPuhwkUS 5v2GFtvODCmSxQEJHSWvL2PkGiYEEZMKVXF5msdqJZK5/Dwp3UgVNeAkUYEHU6px Vu/YUpGo07/LNW5FfGDGf0pWYQ/9Tu5ykno3q3EA7TwWoVwbDK0hh9mpbZYiWSoy PSbIWNpwVMwGri4+KFjCEyG8DLzDlM4UMrK3PnrPh4M4+4a+flR+CMNeM1lyioC3 +jJf3TEOjvUsMzbwoDEE6O0wxBtfFC0xzzDDCAVrPvEZ3lt0do3kVHLbYS6ZXHkX ZwZWNBDWr2mSG9GU4oWizPIlq7MIhRYKA+ADqNxznxm9rtdfidk1tcLdyNUDjOwC jk/vQ8PCORbUYfytMhHzlRk7zieK6wBwr3aFFVgE8HxhgIZkAaUEbeej+dNADo6Z IFY+OF8mjpErcfJscCNgPSDbNid87dA78qRrqL6HLU2sek9g72EFpx2OVV7drkEp +Zy9kuiML4wWfOpC+kQa1Ka66E520U8Hs++cpf1LUOUmn1ajQDSfGoJMMwARAQAB tB9JMlAgU2VjdXJpdHkgPHNlY3VyaXR5QGkycC5uZXQ+iQJXBBMBCABBFiEEQN/+ IH15m+w66H3qX5i+kRduGUEFAmj1TtUCGwMFCQmQP4EFCwkIBwICIgIGFQoJCAsC BBYCAwECHgMCF4AACgkQX5i+kRduGUEEJhAAuZECNIWnC2UbrW/AXF8nPvFjpvLe kK7VQmMgno6iHRB1HAMh5hk3ZOYSRcjghcOHRpMFT64Uuc5vc9eBoegi5TDxYDkF Y9/ciEG5j2TXk93R/rY14UiH/kjFIhBAmc2t6Fs9R1m1vHHJtgY+KLqRF9fh2hc9 43odXnCrn5nhONtW+nb086eJEnJ4vsG/yR4EGzbu+fbrMJlycA/gZS63Q0rIcEJ2 VbZPCEXAf8LmebwxPxlboEuhXJSjCt1gWZwoKZlELaWdHliL3fUrMd3ojM5y66q3 ClO+7nWuwzKxKtZGKzxvF78o0O+HR4BbC16oQGpkT0yAij7ps/3KD2FJVQ/GQLef mpNQABfdVCPgcDS1p9/hjUoVHlRSC4gyehKX/C+H8Qvem92tzmJZy8PvcXaCsK/u wRxRwkoGhv0H5rsMOxfnB06dvT1Mo+KHED5j4y8C5DOnNpzHqwxJh1nQlJvLUvh8 LWIxiiE4+CeQ5V5YH7KfJmGq5ho93GgFmOXJvAuoFCoOLwXbQt9rMpq8iXM1RHRG E1AbB+KA3zcvAdzbgPtXlrOMkIfYO9xCyc8M0sfHB8b4RgrUs2tFz1fw3g4yE7ax 5ljquRefDmqBjtvu15FcZ4CA+I8FyVnrEb9jDTXyW7DiyM2kB7ZFeLpYytShbPq3 oJQMJYaGMoxDk025Ag0EaPVO1QEQAOuZtLOlab2EnuR5St05MXBpwtQUSWJzRckf w3NpnOl55+BavqsPl63rZYiO2lH9rAkZvfcL7auddQZSjDdsuPbUpsrQgsi2P9ig a3QiJOwSZzJ1qNb4VZSXrq2AqkBhCdw9rjpXGFfPNlClgVRbWpsGaQ5KtflnOA+I RfymidNXH0mDROBQuRh+2lkEYfANshjFjIqbI05tDic0KOab46R5MRVF7cihaMWp qPdxeYmvFWZ9lAnx5lMGwDdnGgfWFkU57lAd3NuHUnYIr/ExB/YgMdDeie5lQHKu svbcws9tIucUME9n8lGY77+1HlmNOCU4V12i4ZURJ4TwjHpScMOovkumtO4nXGRq GS8j1zeG7V9+yvdkSrclHJC33Mu6SPFC5SJBqU1G39/VpTD6CZPSPowZ0RlH2AVh D77Snrn53R3gziv5uxq+LpSJoafAx5tgIrg7HB+iJYRB1YVwIIHoT4YrBF01YyH6 cclkf3TNBjKgmtsynVw/TGy56nvR5lmt2uMq0Wwl4ZEwYPp+8ZmFuLbEHsI9RSdD iAdHoK9pEsTSxvzpcDTcG0CLZ4By/4oIKra6KuLr7XcB5eBmgXxrFBw4kveNWGW0 iEdg0xUVp8dxNjdZucB8m9qXQUUSmUxVjFYu4ee8tpo8iEVzu4wm4kOiOBKlwCn2 nOI72oGxABEBAAGJAjwEGAEIACYWIQRA3/4gfXmb7DrofepfmL6RF24ZQQUCaPVO 1QIbDAUJCZA/gQAKCRBfmL6RF24ZQShLD/9BlA+nLmJvwL3FYXm8JOqN07gPKlyQ +gWdV8p22Gawoq6dJLJanWURjn5Kfy30x2CSX6QwiaQG5aHHudNBF2h4Z/qEMcO5 ml5Dq7BP9R5VKmG4vwrL5ccNwuey1/d9Rtjt1zsd+52+x6dfjFv95o9j8jviIEoS HhhbO9ujmx3QLRNlg0SkG6ZlTALGp3EcKNdrV1vpF6ccgt3pdWYFB62N7q8zObHf bfOFMITJIXJJVKICCxzw3xOW2fMashjqf4Ic2UTFsAG3Hqqf5ASGbu4TyjFS3VXV JSzvdhGnxb7qJUzBImK9mGPRXYSV5d4g7kCFfgUg6KSFxbfYreEjCZXWJyqCr/VB eLpIhUWce/AiDPD8lGVD6sNevsNw4HhO6IyQu0pqbRAo+fJZNi+wcqOUqYlMczNw tUKw73QmFj0IqvyBr8Rfq9JC9O6ipyzalwK8uO0gmqOiK79zfnNIJaZ1+LM3Gh6n 3yluwq1df40lEU171i70IbSON6ekGNLTrvhTlDg6vHCMRfQR2UjA5FYBAtFXqQNG c4IYbu2UQm/191P77oI0vBEh3YnrD9eXtdYxgyT+Lj8RBJ+aM+IykK7c2mgOmlqb vYv+KkVFCpOyXrvSwId+3jHiGP6jis7vuzTwiG0S9EyOjxf9XIDowULuY28ntBB0 hOLK7ID/AeaOxA== =39fn \u0026mdash;\u0026ndash;END PGP PUBLIC KEY BLOCK\u0026mdash;\u0026ndash; ","description":"I2P सुरक्षा टीम से संपर्क करने के लिए GPG सार्वजनिक कुंजी","id":"c65864821d13039a727e933e7e6e2891","section":"docs","title":"सुरक्षा GPG कुंजी","url":"/hi/docs/develop/security-key/"},{"categories":null,"content":"अवलोकन Routers I2P network के माध्यम से वितरित एक हस्ताक्षरित समाचार फ़ीड को polling (नियमित अंतराल पर पूछताछ) करके स्वतः अपडेट की जाँच करते हैं। जब कोई नया संस्करण घोषित किया जाता है, तो router क्रिप्टोग्राफ़िक रूप से हस्ताक्षरित अपडेट आर्काइव (.su3) डाउनलोड करता है और उसे इंस्टॉलेशन के लिए तैयार करता है। यह प्रणाली आधिकारिक रिलीज़ों के प्रमाणित, छेड़छाड़-प्रतिरोधी, और मल्टी-चैनल वितरण को सुनिश्चित करती है।\nI2P 2.10.0 से, अपडेट प्रणाली निम्न का उपयोग करती है: - RSA-4096 / SHA-512 हस्ताक्षर - SU3 कंटेनर फ़ॉर्मेट (पुराने SUD/SU2 को प्रतिस्थापित करता है) - रेडंडेंट मिरर: इन-नेटवर्क HTTP, क्लियरनेट HTTPS, और BitTorrent\n1. समाचार फ़ीड Routers नए संस्करणों और सुरक्षा परामर्शों का पता लगाने के लिए हर कुछ घंटों में हस्ताक्षरित Atom फ़ीड की जाँच करते हैं. यह फ़ीड हस्ताक्षरित होती है और .su3 फ़ाइल के रूप में वितरित की जाती है, जिसमें निम्न शामिल हो सकते हैं:\n\u0026lt;i2p:version\u0026gt; — नया संस्करण संख्या \u0026lt;i2p:minVersion\u0026gt; — समर्थित न्यूनतम router संस्करण \u0026lt;i2p:minJavaVersion\u0026gt; — आवश्यक न्यूनतम Java रनटाइम \u0026lt;i2p:update\u0026gt; — कई डाउनलोड मिरर (I2P, HTTPS, torrent) सूचीबद्ध करता है \u0026lt;i2p:revocations\u0026gt; — प्रमाणपत्र निरस्तीकरण डेटा \u0026lt;i2p:blocklist\u0026gt; — समझौता किए गए समकक्षों के लिए नेटवर्क-स्तरीय ब्लॉकलिस्ट फ़ीड वितरण Channel Description Usage I2P HTTP (eepsite) Primary update source Private, resilient Clearnet HTTPS Fallback mirror Public fallback BitTorrent magnet Distributed channel Reduces mirror load router I2P फीड को प्राथमिकता देते हैं, लेकिन आवश्यकता पड़ने पर clearnet या torrent वितरण पर लौट सकते हैं। 2. फ़ाइल प्रारूप SU3 (वर्तमान मानक) संस्करण 0.9.9 में पेश किए जाने पर, SU3 ने पुराने SUD और SU2 फ़ॉर्मैट्स को प्रतिस्थापित कर दिया। प्रत्येक फ़ाइल में एक हेडर, पेलोड और ट्रेलिंग सिग्नेचर शामिल होता है।\nहेडर संरचना \u0026lt;tr\u0026gt; \u0026lt;th style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem; text-align:left; background:var(--color-bg-secondary);\u0026quot;\u0026gt;Field\u0026lt;/th\u0026gt; \u0026lt;th style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem; text-align:left; background:var(--color-bg-secondary);\u0026quot;\u0026gt;Description\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Magic\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;\u0026lt;code\u0026gt;\u0026quot;I2Psu3\u0026quot;\u0026lt;/code\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Format Version\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;\u0026lt;code\u0026gt;0\u0026lt;/code\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Signature Type\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;e.g., \u0026lt;code\u0026gt;0x000B\u0026lt;/code\u0026gt; (RSA-SHA512-4096)\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Signature Length\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;\u0026lt;code\u0026gt;512 bytes\u0026lt;/code\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Version String\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Router version\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Signer ID\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Certificate name\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Content Type\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;1 = router update, 3 = reseed, 4 = news feed\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; हस्ताक्षर सत्यापन के चरण 1. हेडर पार्स करें और हस्ताक्षर एल्गोरिथम की पहचान करें। 2. संग्रहीत हस्ताक्षरकर्ता प्रमाणपत्र का उपयोग करके हैश और हस्ताक्षर सत्यापित करें। 3. सुनिश्चित करें कि हस्ताक्षरकर्ता निरस्त नहीं है। 4. एम्बेडेड संस्करण स्ट्रिंग की तुलना पेलोड मेटाडेटा से करें।\nRouters विश्वसनीय हस्ताक्षरकर्ता प्रमाणपत्रों के साथ आते हैं (वर्तमान में zzz और str4d), और किसी भी बिना हस्ताक्षरित या निरस्त स्रोतों को अस्वीकार करते हैं।\nSU2 (अप्रचलित) Pack200 (Java का एक संपीड़न फ़ॉर्मैट) से संपीड़ित JARs के साथ .su2 एक्सटेंशन का उपयोग किया गया। Java 14 में Pack200 (JEP 367) को अप्रचलित घोषित किए जाने के बाद इसे हटा दिया गया। I2P 0.9.48+ में अक्षम; अब इसे पूरी तरह ZIP compression से प्रतिस्थापित किया गया है। SUD (पुराना) प्रारंभिक DSA-SHA1 (Digital Signature Algorithm + SHA-1 हैश) से हस्ताक्षरित ZIP फ़ॉर्मेट (pre-0.9.9). signer ID या हेडर नहीं, अखंडता सीमित। कमजोर क्रिप्टोग्राफी और संस्करण प्रवर्तन की कमी के कारण प्रतिस्थापित किया गया। 3. अद्यतन कार्यप्रवाह 3.1 हेडर सत्यापन Routers केवल SU3 header प्राप्त करते हैं ताकि पूरी फ़ाइलें डाउनलोड करने से पहले संस्करण स्ट्रिंग का सत्यापन किया जा सके। यह पुराने मिरर या पुराने संस्करणों पर बैंडविड्थ की बर्बादी को रोकता है।\n3.2 पूर्ण डाउनलोड हेडर का सत्यापन करने के बाद, router पूरी .su3 फ़ाइल यहाँ से डाउनलोड करता है: - नेटवर्क के भीतर eepsite मिरर (पसंदीदा) - HTTPS clearnet (सामान्य इंटरनेट) मिरर (फॉलबैक) - BitTorrent (वैकल्पिक पीयर-सहायता प्राप्त वितरण)\nडाउनलोड में मानक I2PTunnel HTTP क्लाइंट का उपयोग होता है, जिसमें पुनः प्रयास, समय-सीमा प्रबंधन, और mirror fallback (ज़रूरत पड़ने पर वैकल्पिक मिरर पर स्वचालित स्विच) शामिल हैं।\n3.3 हस्ताक्षर सत्यापन प्रत्येक डाउनलोड की गई फ़ाइल इन जाँचों से गुज़रती है: - हस्ताक्षर जाँच: RSA-4096/SHA512 सत्यापन - संस्करण मिलान: हेडर बनाम पेलोड संस्करण जाँच - डाउनग्रेड रोकथाम: सुनिश्चित करता है कि अपडेट स्थापित संस्करण से नया हो\nअमान्य या मेल न खाने वाली फ़ाइलें तुरंत खारिज कर दी जाती हैं।\n3.4 इंस्टॉलेशन स्टेजिंग सत्यापन के बाद: 1. ZIP की सामग्री अस्थायी निर्देशिका में निकालें 2. deletelist.txt में सूचीबद्ध फ़ाइलें हटाएँ 3. यदि lib/jbigi.jar शामिल है तो नेटिव लाइब्रेरियों को प्रतिस्थापित करें 4. हस्ताक्षरकर्ता प्रमाणपत्रों को ~/.i2p/certificates/ में कॉपी करें 5. अगले पुनरारंभ पर लागू करने के लिए अपडेट को i2pupdate.zip में स्थानांतरित करें\nअपडेट अगले स्टार्टअप पर अपने आप इंस्टॉल हो जाएगा, या जब “Install update now” को मैन्युअल रूप से ट्रिगर किया जाए।\n4. फ़ाइल प्रबंधन deletelist.txt नई सामग्री को अनपैक करने से पहले हटाई जाने वाली अप्रचलित फ़ाइलों की एक सादा पाठ सूची।\nनियम: - प्रत्येक पंक्ति में एक पथ (केवल सापेक्ष पथ) - # से शुरू होने वाली पंक्तियाँ अनदेखी की जाएँगी - .. और पूर्ण पथ अस्वीकृत किए जाएँगे\nनेटिव लाइब्रेरीज़ पुरानी या असंगत नेटिव बाइनरीज़ को रोकने के लिए: - यदि lib/jbigi.jar मौजूद है, तो पुरानी .so या .dll फ़ाइलें हटा दी जाती हैं - सुनिश्चित करता है कि प्लेटफ़ॉर्म-विशिष्ट लाइब्रेरियाँ नए सिरे से निकाली जाती हैं\n5. प्रमाणपत्र प्रबंधन Routers अपडेट्स या समाचार फ़ीड में प्रकाशित रद्दीकरणों के माध्यम से नए साइनर प्रमाणपत्र प्राप्त कर सकते हैं।\nनई .crt फ़ाइलें प्रमाणपत्र निर्देशिका में कॉपी की जाती हैं। भविष्य के सत्यापनों से पहले रद्द किए गए प्रमाणपत्र हटा दिए जाते हैं। बिना किसी मैनुअल उपयोगकर्ता हस्तक्षेप की आवश्यकता के key rotation (कुंजियों को समय-समय पर बदलना) का समर्थन करता है। सभी अपडेट ऑफलाइन air-gapped signing systems (इंटरनेट/नेटवर्क से पूरी तरह अलग हस्ताक्षर प्रणाली) का उपयोग करके साइन किए जाते हैं। प्राइवेट कीज़ कभी भी बिल्ड सर्वरों पर संग्रहीत नहीं की जातीं।\n6. डेवलपर दिशानिर्देश Topic Details Signing Use RSA-4096 (SHA-512) via apps/jetty/news SU3 tooling. Mirror Policy I2P eepsite preferred, clearnet HTTPS fallback, torrent optional. Testing Validate updates from prior releases, across all OS platforms. Version Enforcement minVersion prevents incompatible upgrades. Certificate Rotation Distribute new certs in updates and revocation lists. आगामी रिलीज़ में पोस्ट-क्वांटम हस्ताक्षर एकीकरण (देखें Proposal 169) और पुनरुत्पादन योग्य बिल্ড्स का अन्वेषण किया जाएगा। 7. सुरक्षा अवलोकन Threat Mitigation Tampering Cryptographic signature (RSA-4096/SHA512) Key Compromise Feed-based certificate revocation Downgrade Attack Version comparison enforcement Mirror Hijack Signature verification, multiple mirrors DoS Fallback to alternate mirrors/torrents MITM HTTPS transport + signature-level integrity --- 8. संस्करणीकरण Router: 2.10.0 (API 0.9.67) सेमांटिक वर्शनिंग (अर्थ-आधारित संस्करण निर्धारण) Major.Minor.Patch के साथ। न्यूनतम संस्करण प्रवर्तन असुरक्षित अपग्रेड को रोकता है। समर्थित Java: Java 8–17। भविष्य में 2.11.0+ के लिए Java 17+ आवश्यक होगा। ","description":"I2P routers के लिए सुरक्षित हस्ताक्षरित अपडेट तंत्र और फ़ीड संरचना","id":"aea843f73d809c9546b3d675324af161","section":"docs","title":"सॉफ़्टवेयर अद्यतन विनिर्देश","url":"/hi/docs/specs/updates/"},{"categories":null,"content":"अवलोकन I2P Streaming Library I2P की message layer पर विश्वसनीय, क्रमबद्ध, प्रमाणित परिवहन प्रदान करती है, जो IP पर TCP के समान है। यह I2CP protocol के ऊपर स्थित है और लगभग सभी इंटरैक्टिव I2P अनुप्रयोगों द्वारा उपयोग की जाती है, जिनमें HTTP proxies, IRC, BitTorrent और email शामिल हैं।\nमुख्य विशेषताएं SYN, ACK, और FIN flags का उपयोग करके एक-चरणीय कनेक्शन सेटअप जो राउंड-ट्रिप्स को कम करने के लिए पेलोड डेटा के साथ बंडल किया जा सकता है। Sliding-window congestion control, slow start और congestion avoidance के साथ जो I2P के उच्च-विलंबता वातावरण के लिए अनुकूलित है। पैकेट संपीड़न (डिफ़ॉल्ट 4KB संपीड़ित सेगमेंट) जो पुनः संचरण लागत और विखंडन विलंबता को संतुलित करता है। I2P destinations के बीच पूर्णतः प्रमाणित, एन्क्रिप्टेड, और विश्वसनीय चैनल एब्सट्रैक्शन। यह डिज़ाइन छोटे HTTP अनुरोधों और प्रतिक्रियाओं को एकल राउंड-ट्रिप में पूर्ण होने में सक्षम बनाता है। एक SYN पैकेट अनुरोध पेलोड ले जा सकता है, जबकि प्रतिक्रियाकर्ता का SYN/ACK/FIN पूर्ण प्रतिक्रिया बॉडी शामिल कर सकता है।\nAPI मूल बातें Java स्ट्रीमिंग API मानक Java सॉकेट प्रोग्रामिंग को दर्शाता है:\nI2PSocketManager mgr = I2PSocketManagerFactory.createManager(host, port, options); I2PSocket socket = mgr.connect(destination); I2PServerSocket server = mgr.getServerSocket(); I2PSocketManagerFactory I2CP के माध्यम से एक router सत्र को negotiate करता है या पुनः उपयोग करता है। यदि कोई key प्रदान नहीं की गई है, तो एक नया destination स्वचालित रूप से उत्पन्न हो जाता है। डेवलपर्स options map के माध्यम से I2CP विकल्प (जैसे कि tunnel लंबाई, एन्क्रिप्शन प्रकार, या कनेक्शन सेटिंग्स) पास कर सकते हैं। I2PSocket और I2PServerSocket मानक Java Socket इंटरफेस को प्रतिबिंबित करते हैं, जिससे माइग्रेशन सरल हो जाता है। पूर्ण Javadocs I2P router console से या यहाँ उपलब्ध हैं।\nकॉन्फ़िगरेशन और ट्यूनिंग सॉकेट मैनेजर बनाते समय आप कॉन्फ़िगरेशन प्रॉपर्टीज़ को इस तरह पास कर सकते हैं:\nI2PSocketManagerFactory.createManager(host, port, properties); मुख्य विकल्प Option Description Default i2p.streaming.maxWindowSize Maximum send window (bytes) 128 KB i2p.streaming.initialRTO Initial retransmission timeout 9s i2p.streaming.inactivityTimeout Timeout before connection close 90s i2p.streaming.enforceProtocol Enforce protocol ID (prevents confusion) true i2p.streaming.congestionAlgorithm Congestion control method Default (AIMD TCP-like) i2p.streaming.disableRejectLogging Disable logging rejected packets false ### कार्यभार के अनुसार व्यवहार Workload Recommended Settings HTTP-like Default parameters are ideal. Bulk Transfer Increase window size to 256 KB or 512 KB; lengthen timeouts. Real-time Streaming Lower tunnel length to 1-2 hops; adjust RTO downwards. संस्करण 0.9.4 के बाद से नई सुविधाओं में reject log suppression, DSA सूची समर्थन (0.9.21), और अनिवार्य प्रोटोकॉल प्रवर्तन (0.9.36) शामिल हैं। 2.10.0 के बाद से routers में transport layer पर post-quantum hybrid encryption (ML-KEM + X25519) शामिल है। प्रोटोकॉल विवरण प्रत्येक stream को एक Stream ID द्वारा पहचाना जाता है। Packets TCP के समान control flags ले जाते हैं: SYNCHRONIZE, ACK, FIN, और RESET। Packets में एक साथ data और control flags दोनों हो सकते हैं, जो अल्पकालिक connections के लिए दक्षता में सुधार करता है।\nकनेक्शन जीवनचक्र SYN भेजा गया — प्रारंभकर्ता वैकल्पिक डेटा शामिल करता है। SYN/ACK प्रतिक्रिया — उत्तरदाता वैकल्पिक डेटा शामिल करता है। ACK अंतिमीकरण — विश्वसनीयता और सत्र स्थिति स्थापित करता है। FIN/RESET — व्यवस्थित बंद करने या अचानक समाप्ति के लिए उपयोग किया जाता है। विखंडन और पुनर्व्यवस्था क्योंकि I2P tunnel विलंबता और संदेश पुनर्क्रम का परिचय देते हैं, लाइब्रेरी अज्ञात या जल्दी आने वाली streams से पैकेट को बफर करती है। बफर किए गए संदेशों को तब तक संग्रहीत किया जाता है जब तक समन्वयन पूर्ण नहीं हो जाता, जिससे पूर्ण, क्रम में डिलीवरी सुनिश्चित होती है।\nप्रोटोकॉल प्रवर्तन विकल्प i2p.streaming.enforceProtocol=true (0.9.36 से डिफ़ॉल्ट) यह सुनिश्चित करता है कि कनेक्शन सही I2CP प्रोटोकॉल नंबर का उपयोग करें, जिससे एक destination को साझा करने वाले कई subsystems के बीच संघर्ष को रोका जा सके।\nइंटरऑपरेबिलिटी और सर्वोत्तम प्रथाएं स्ट्रीमिंग प्रोटोकॉल Datagram API के साथ सह-अस्तित्व में है, जो डेवलपर्स को कनेक्शन-उन्मुख और कनेक्शन-रहित ट्रांसपोर्ट के बीच चयन करने का विकल्प देता है।\nUse Case Recommended Transport Reliable, ordered data (HTTP, IRC, FTP) Streaming Connectionless or lossy data (DNS, telemetry) Datagram ### साझा क्लाइंट एप्लिकेशन shared clients के रूप में चलकर मौजूदा tunnels का पुनः उपयोग कर सकते हैं, जिससे कई सेवाएं एक ही destination को साझा कर सकती हैं। हालांकि यह overhead को कम करता है, यह cross-service correlation जोखिम को बढ़ाता है—सावधानी से उपयोग करें।\nभीड़ नियंत्रण स्ट्रीमिंग लेयर RTT-आधारित फीडबैक के माध्यम से नेटवर्क लेटेंसी और थ्रूपुट को लगातार अनुकूलित करती है। जब routers योगदान देने वाले पीयर होते हैं (participating tunnels सक्षम) तो एप्लिकेशन सर्वोत्तम प्रदर्शन करते हैं। TCP-जैसे कंजेशन कंट्रोल मैकेनिज्म धीमे पीयर्स को ओवरलोड होने से रोकते हैं और tunnels में बैंडविड्थ उपयोग को संतुलित करने में मदद करते हैं। विलंबता संबंधी विचार चूंकि I2P कई सौ मिलीसेकंड की बेस लेटेंसी जोड़ता है, एप्लिकेशन को राउंड-ट्रिप्स को कम करना चाहिए। जहां संभव हो कनेक्शन सेटअप के साथ डेटा बंडल करें (जैसे, SYN में HTTP अनुरोध)। कई छोटे क्रमिक आदान-प्रदान पर निर्भर डिज़ाइन से बचें।\nपरीक्षण और संगतता पूर्ण संगतता सुनिश्चित करने के लिए हमेशा Java I2P और i2pd दोनों के विरुद्ध परीक्षण करें। यद्यपि प्रोटोकॉल मानकीकृत है, कार्यान्वयन में मामूली अंतर हो सकते हैं। पुराने routers को सहजता से संभालें—कई peers अभी भी 2.0 से पूर्व के संस्करण चलाते हैं। RTT और retransmission मेट्रिक्स पढ़ने के लिए I2PSocket.getOptions() और getSession() का उपयोग करके कनेक्शन आँकड़ों की निगरानी करें। प्रदर्शन tunnel कॉन्फ़िगरेशन पर बहुत अधिक निर्भर करता है: - छोटी tunnels (1–2 hops) → कम latency, कम anonymity। - लंबी tunnels (3+ hops) → अधिक anonymity, बढ़ी हुई RTT।\nमुख्य सुधार (2.0.0–2.10.0) Feature Introduced Description Persistent ACK Bundling 2.0.0 Optimized round-trip reduction for HTTP workloads. Adaptive Window Scaling 2.3.0 Improved large file transfer stability. Thread Pooling and Socket Reuse 2.5.0 Reduced per-connection overhead. Protocol Enforcement Default 0.9.36 Ensures correct stream usage. Hybrid ML-KEM Ratchet 2.10.0 Adds post-quantum hybrid encryption layer. i2pd Streaming API Compatibility Fixes 2.9.0 Full parity with Java I2P library behavior. --- सारांश I2P Streaming Library I2P के भीतर सभी विश्वसनीय संचार की रीढ़ है। यह क्रम में, प्रमाणित, एन्क्रिप्टेड संदेश वितरण सुनिश्चित करती है और अनाम वातावरण में TCP के लिए लगभग प्रत्यक्ष प्रतिस्थापन प्रदान करती है।\nइष्टतम प्रदर्शन प्राप्त करने के लिए: - SYN+payload bundling के साथ round-trips को न्यूनतम करें। - अपने workload के लिए window और timeout parameters को tune करें। - latency-sensitive applications के लिए छोटे tunnels को प्राथमिकता दें। - peers को overload होने से बचाने के लिए congestion-friendly designs का उपयोग करें।\n","description":"अधिकांश I2P अनुप्रयोगों द्वारा उपयोग किया जाने वाला TCP-जैसा ट्रांसपोर्ट","id":"d5eaf45dea26928a910e0f2b8a0e1037","section":"docs","title":"स्ट्रीमिंग प्रोटोकॉल","url":"/hi/docs/api/streaming/"},{"categories":null,"content":"अवलोकन I2P Streaming Library, I2P की अविश्वसनीय संदेश परत के ऊपर विश्वसनीय, क्रमानुसार और प्रमाणीकृत डेटा आपूर्ति प्रदान करती है — IP पर TCP के समान। यह वेब ब्राउज़िंग, IRC, ईमेल और फ़ाइल साझाकरण जैसे लगभग सभी इंटरैक्टिव I2P अनुप्रयोगों द्वारा उपयोग की जाती है।\nयह I2P के उच्च-विलंबता वाले गुमनाम tunnels के पार विश्वसनीय प्रसारण, भीड़ नियंत्रण, पुनःप्रेषण, और प्रवाह नियंत्रण सुनिश्चित करता है। प्रत्येक स्ट्रीम destinations (गंतव्य) के बीच एंड-टू-एंड पूरी तरह एन्क्रिप्टेड होती है।\nमूलभूत डिज़ाइन सिद्धांत स्ट्रीमिंग लाइब्रेरी एक एक-चरणीय कनेक्शन सेटअप लागू करती है, जिसमें SYN, ACK और FIN फ़्लैग उसी संदेश में डेटा पेलोड वहन कर सकते हैं। यह उच्च-विलंबता वाले परिवेशों में round-trips (आवागमन चक्र) को न्यूनतम करता है — एक छोटा HTTP ट्रांज़ैक्शन एक ही round-trip में पूरा हो सकता है।\nभीड़ नियंत्रण और पुनर्प्रेषण TCP पर आधारित है, लेकिन I2P के परिवेश के लिए अनुकूलित किया गया है। विंडो आकार संदेश-आधारित हैं, बाइट-आधारित नहीं, और tunnel की विलंबता तथा ओवरहेड के अनुरूप ट्यून किए गए हैं। प्रोटोकॉल TCP के AIMD एल्गोरिदम (Additive Increase Multiplicative Decrease—योगात्मक वृद्धि, गुणात्मक कमी) के समान slow start (धीमी शुरुआत), congestion avoidance (भीड़ से बचाव), और exponential backoff (घातीय बैकऑफ) का समर्थन करता है।\nआर्किटेक्चर स्ट्रीमिंग लाइब्रेरी एप्लिकेशनों और I2CP इंटरफ़ेस के बीच संचालित होती है।\nLayer Responsibility Application Standard I2PSocket and I2PServerSocket usage Streaming Library Connection setup, sequencing, retransmission, and flow control I2CP Tunnel creation, routing, and message handling I2NP / Router Layer Transport through tunnels अधिकांश उपयोगकर्ता इसे I2PSocketManager, I2PTunnel, या SAMv3 के माध्यम से एक्सेस करते हैं। लाइब्रेरी destination (गंतव्य) प्रबंधन, tunnel का उपयोग, और पुनःप्रेषण को पारदर्शी रूप से संभालती है। पैकेट प्रारूप +-----------------------------------------------+ | Send Stream ID (4B) | Receive Stream ID (4B) | +-----------------------------------------------+ | Sequence Number (4B) | Ack Through (4B) | +-----------------------------------------------+ | NACK Count (1B) | optional NACK list (4B each) +-----------------------------------------------+ | Flags (1B) | Option Size (1B) | Options ... | +-----------------------------------------------+ | Payload ... | हेडर विवरण Stream IDs: 32-बिट मान जो स्थानीय और रिमोट स्ट्रीम्स की अद्वितीय पहचान करते हैं। Sequence Number: SYN के लिए 0 से शुरू होता है, प्रत्येक संदेश के साथ बढ़ता है। Ack Through: N तक के सभी संदेशों की पुष्टि करता है, NACK सूची में मौजूद संदेशों को छोड़कर। Flags: अवस्था और व्यवहार को नियंत्रित करने वाला बिटमास्क। Options: RTT, MTU, और प्रोटोकॉल negotiation के लिए परिवर्तनशील लंबाई की सूची। कुंजी फ़्लैग्स Flag Purpose SYN Connection initiation ACK Acknowledge received packets FIN Graceful close RST Reset connection FROM_INCLUDED Sender’s destination included SIGNATURE_INCLUDED Message signed by sender ECHO / ECHO_REPLY Ping/Pong keepalive --- प्रवाह नियंत्रण और विश्वसनीयता Streaming संदेश-आधारित विंडोइंग का उपयोग करता है, TCP के बाइट-आधारित तरीके के विपरीत। एक समय में प्रेषणाधीन बिना पुष्टि वाले पैकेटों की संख्या वर्तमान विंडो आकार (डिफ़ॉल्ट 128) के बराबर होती है।\nयंत्रणाएँ भीड़ नियंत्रण: Slow start (धीमी शुरुआत) और AIMD (Additive Increase/Multiplicative Decrease—योगात्मक वृद्धि/गुणात्मक कमी) आधारित बचाव। Choke/Unchoke (रोक/मुक्त): बफ़र के भरण-स्तर के आधार पर प्रवाह-नियंत्रण संकेत। पुनर्प्रेषण: RFC 6298 आधारित RTO (Retransmission Timeout—पुनर्प्रेषण समय-सीमा) गणना, exponential backoff (घातीय बैकऑफ़) सहित। डुप्लिकेट फ़िल्टरिंग: संभावित रूप से क्रम-परिवर्तित संदेशों के बावजूद विश्वसनीयता सुनिश्चित करती है। सामान्य कॉन्फ़िगरेशन मान:\nParameter Default Description maxWindowSize 128 Max unacknowledged messages maxMessageSize 1730 Maximum payload bytes per message initialRTO 9000 ms Initial retransmission timeout inactivityTimeout 90000 ms Idle connection timeout connectTimeout 300000 ms Connection establishment timeout --- कनेक्शन स्थापना प्रारंभकर्ता एक SYN भेजता है (वैकल्पिक रूप से पेलोड और FROM_INCLUDED के साथ)। उत्तरदाता SYN+ACK के साथ उत्तर देता है (पेलोड शामिल हो सकता है)। प्रारंभकर्ता स्थापना की पुष्टि करते हुए अंतिम ACK भेजता है। वैकल्पिक प्रारंभिक पेलोड पूर्ण handshake (कनेक्शन स्थापित करने की प्रारंभिक प्रक्रिया) के पूरा होने से पहले डेटा संचरण की अनुमति देते हैं।\nकार्यान्वयन विवरण पुनःप्रेषण और Timeout (समय-समाप्ति) पुनःप्रेषण एल्गोरिदम RFC 6298 का पालन करता है। - प्रारंभिक RTO: 9s - न्यूनतम RTO: 100ms - अधिकतम RTO: 45s - अल्फा: 0.125 - बीटा: 0.25\nनियंत्रण ब्लॉक साझा करना उसी पीयर के साथ हाल की कनेक्शन्स तेज़ रैंप‑अप के लिए पिछले RTT (राउंड‑ट्रिप समय) और window data (कंजेशन विंडो से संबंधित डेटा) का पुनः उपयोग करती हैं, जिससे “कोल्ड स्टार्ट” विलंबता से बचा जा सके। कंट्रोल ब्लॉक्स कुछ मिनटों के बाद समाप्त हो जाते हैं।\nMTU (अधिकतम संचरण इकाई) और खंडन डिफ़ॉल्ट MTU: 1730 बाइट्स (दो I2NP संदेश फिट होते हैं)। ECIES (Elliptic Curve Integrated Encryption Scheme—एलिप्टिक कर्व आधारित संयोजित एन्क्रिप्शन योजना) गंतव्य: 1812 बाइट्स (कम ओवरहेड)। न्यूनतम समर्थित MTU: 512 बाइट्स। पेलोड का आकार 22-बाइट के न्यूनतम streaming header (डेटा स्ट्रीम का हेडर) को शामिल नहीं करता है।\nसंस्करण इतिहास Router Version Feature 0.7.1 Protocol numbers defined in I2CP 0.9.11 Variable-length signatures 0.9.12 ECDSA signature support 0.9.15 Ed25519 signature support 0.9.18 Ping/Pong payloads 0.9.20 FROM_INCLUDED not required in RESET 0.9.36 Protocol enforcement enabled by default 0.9.39 OFFLINE_SIGNATURE support 0.9.58 Bob’s hash added to NACK field in SYN 2.10.0 Post-Quantum hybrid encryption (experimental) --- एप्लिकेशन-स्तरीय उपयोग जावा उदाहरण Properties props = new Properties(); props.setProperty(\u0026#34;i2p.streaming.maxWindowSize\u0026#34;, \u0026#34;512\u0026#34;); I2PSocketManager mgr = I2PSocketManagerFactory.createManager(props); I2PSocket socket = mgr.connect(destination); InputStream in = socket.getInputStream(); OutputStream out = socket.getOutputStream(); SAMv3 और i2pd समर्थन SAMv3: गैर-Java क्लाइंट्स के लिए STREAM (स्ट्रीम) और DATAGRAM (डेटाग्राम) मोड प्रदान करता है. i2pd: कॉन्फ़िगरेशन फ़ाइल विकल्पों के माध्यम से समान स्ट्रीमिंग पैरामीटर उपलब्ध कराता है (उदा. i2p.streaming.maxWindowSize, profile, आदि). Streaming और Datagrams के बीच चयन Use Case Recommended Transport Reason HTTP, IRC, Email Streaming Requires reliability DNS Repliable Datagram Single request/response Telemetry, Logging Raw Datagram Best-effort acceptable P2P DHT Datagram High connection churn --- सुरक्षा और पोस्ट‑क्वांटम भविष्य स्ट्रीमिंग सत्र I2CP लेयर पर एंड-टू-एंड एन्क्रिप्टेड होते हैं। Post-quantum hybrid encryption (यानी ऐसा हाइब्रिड एन्क्रिप्शन जो क्वांटम-कंप्यूटिंग आधारित हमलों के विरुद्ध सुरक्षा के लिए बनाया गया है) (ML-KEM + X25519) का 2.10.0 में प्रायोगिक समर्थन है, लेकिन यह डिफ़ॉल्ट रूप से निष्क्रिय रहता है।\nसंदर्भ स्ट्रीमिंग API अवलोकन स्ट्रीमिंग प्रोटोकॉल विनिर्देश I2CP विनिर्देश प्रस्ताव 144: स्ट्रीमिंग MTU गणनाएँ I2P 2.10.0 रिलीज़ नोट्स ","description":"अधिकांश I2P अनुप्रयोगों में प्रयुक्त विश्वसनीय, TCP जैसा ट्रांसपोर्ट","id":"100837c91cc0808ee048c86902b36251","section":"docs","title":"स्ट्रीमिंग प्रोटोकॉल","url":"/hi/docs/specs/streaming/"}]
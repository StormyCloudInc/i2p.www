<!DOCTYPE html>
<html lang="en" data-theme="light">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

    <title>SSU2 | I2P - The Invisible Internet Project</title>

    <meta name="description" content="The Invisible Internet Project - A privacy-focused, anonymous network layer">
    <meta name="keywords" content="i2p, privacy, anonymity, dark net, encryption, security">

    
    <meta property="og:title" content="SSU2 | I2P - The Invisible Internet Project">
    <meta property="og:description" content="The Invisible Internet Project - A privacy-focused, anonymous network layer">
    <meta property="og:type" content="website">
    <meta property="og:url" content="/en/proposals/159-ssu2/">

    
    <link rel="icon" type="image/svg+xml" href="../../../images/favicon.svg">
    <link rel="icon" type="image/png" href="../../../images/i2plogo.png" sizes="32x32">

    
    
    
    
    <link rel="stylesheet" href="../../../css/main.min.be6880f32f5ff44e57579da7b11513b973319944ebe38748e3ac7f3268662d18.css" integrity="sha256-vmiA8y9f9E5XV52nsRUTuXMxmUTr44dI46x/MmhmLRg=">
    


    
</head>

<body>
    
    <input type="checkbox" id="theme-toggle-checkbox" class="theme-checkbox" aria-hidden="true">

    
<div class="site-banner" id="site-banner" data-banner-id="banner-3" role="alert" aria-live="polite">
    <div class="container">
        <div class="banner-content">
            <span class="banner-message">I2P Beta Site Now Live E-Mail issues to stormycloud@mail.i2p</span>
            
        </div>
        
        <form method="GET" action="../../../api/banner/dismiss" style="display: inline;">
            <input type="hidden" name="id" value="banner-3">
            <button type="submit" class="banner-close" aria-label="Close banner" title="Close banner">
                <span aria-hidden="true">&times;</span>
            </button>
        </form>
        
    </div>
</div>


    <header class="site-header">
    <div class="container">
        <nav class="main-nav">
            <div class="nav-brand">
                <a href="../../../en/" class="logo-link">
                    <img src="../../../images/i2plogo_lightmode.svg" alt="I2P Logo" class="logo logo-light">
                    <img src="../../../images/i2plogo_darkmode.svg" alt="I2P Logo" class="logo logo-dark">
                </a>
            </div>

            
            <input type="checkbox" id="mobile-menu-checkbox" class="mobile-menu-checkbox"
                aria-label="Toggle navigation menu">
            <label for="mobile-menu-checkbox" class="mobile-menu-toggle" aria-label="Toggle navigation menu">
                <span class="hamburger"></span>
            </label>

            <div class="nav-menu">
                <ul class="nav-links">
                    <li class="nav-dropdown">
                        <a href="../../../en/about/" class="">About</a>
                        <ul class="dropdown-menu">
                            <li><a href="../../../en/about/">Overview</a></li>
                            <li><a href="../../../en/papers/">Research Papers</a></li>
                            <li><a href="../../../en/about/media/">Press</a></li>
                            <li><a href="../../../en/contact/">Contact Us</a></li>
                        </ul>
                    </li>
                    <li><a href="../../../en/docs/" class="">Docs</a></li>
                    <li><a href="../../../en/downloads/" class="">Downloads</a></li>
                    <li><a href="../../../en/blog/" class="">Blog</a></li>
                    <li class="nav-dropdown">
                        <a href="../../../en/get-involved/" class="">Get Involved</a>
                        <ul class="dropdown-menu">
                            <li><a href="../../../en/get-involved/">Overview</a></li>
                            <li><a href="../../../en/feedback/">Feature Suggestions</a></li>
                        </ul>
                    </li>
                </ul>

                <div class="nav-actions">
                    
                    <div class="language-selector">
                        <button class="language-toggle" aria-label="Select language" title="Language">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none"
                                xmlns="http://www.w3.org/2000/svg">
                                <circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="2" />
                                <path
                                    d="M2 12h20M12 2a15.3 15.3 0 014 10 15.3 15.3 0 01-4 10 15.3 15.3 0 01-4-10 15.3 15.3 0 014-10z"
                                    stroke="currentColor" stroke-width="2" />
                            </svg>
                            <span class="current-lang">en</span>
                        </button>
                        <div class="language-dropdown">
                            
                            
                            
                            
                            
                            
                            
                            
                            
                            <a href="../../../en/proposals/159-ssu2/"
                                class="lang-option active">English</a>
                            
                            
                            
                            
                            
                            
                            
                            
                            <a href="../../../es/proposals/159-ssu2/"
                                class="lang-option">Spanish</a>
                            
                            
                            
                            
                            
                            
                            
                            
                            <a href="../../../ko/proposals/159-ssu2/"
                                class="lang-option">Korean</a>
                            
                            
                            
                            
                            
                            
                            
                            
                            <a href="../../../zh/proposals/159-ssu2/"
                                class="lang-option">Chinese</a>
                            
                            
                            
                            
                            
                            
                            
                            
                            <a href="../../../ru/proposals/159-ssu2/"
                                class="lang-option">Russian</a>
                            
                            
                            
                            
                            
                            
                            
                            
                            <a href="../../../cs/proposals/159-ssu2/"
                                class="lang-option">Czech</a>
                            
                            
                            
                            
                            
                            
                            
                            
                            <a href="../../../de/proposals/159-ssu2/"
                                class="lang-option">German</a>
                            
                            
                            
                            
                            
                            
                            
                            
                            <a href="../../../fr/proposals/159-ssu2/"
                                class="lang-option">French</a>
                            
                            
                            
                            
                            
                            
                            
                            
                            <a href="../../../tr/proposals/159-ssu2/"
                                class="lang-option">Turkish</a>
                            
                            
                            
                            
                            
                            
                            
                            
                            <a href="../../../vi/proposals/159-ssu2/"
                                class="lang-option">Vietnamese</a>
                            
                            
                            
                            
                            
                            
                            
                            
                            <a href="../../../hi/proposals/159-ssu2/"
                                class="lang-option">Hindi</a>
                            
                            
                            
                            
                            
                            
                            
                            
                            <a href="../../../ar/proposals/159-ssu2/"
                                class="lang-option">Arabic</a>
                            
                            
                            
                            
                            
                            
                            
                            
                            <a href="../../../pt/proposals/159-ssu2/"
                                class="lang-option">Portuguese</a>
                            
                            
                        </div>
                    </div>

                    
                    <label for="theme-toggle-checkbox" class="theme-toggle" aria-label="Toggle dark mode"
                        title="Toggle theme">
                        <svg class="sun-icon" width="20" height="20" viewBox="0 0 20 20" fill="none"
                            xmlns="http://www.w3.org/2000/svg">
                            <circle cx="10" cy="10" r="4" stroke="currentColor" stroke-width="2" />
                            <path
                                d="M10 2V4M10 16V18M18 10H16M4 10H2M15.657 4.343L14.243 5.757M5.757 14.243L4.343 15.657M15.657 15.657L14.243 14.243M5.757 5.757L4.343 4.343"
                                stroke="currentColor" stroke-width="2" stroke-linecap="round" />
                        </svg>
                        <svg class="moon-icon" width="20" height="20" viewBox="0 0 20 20" fill="none"
                            xmlns="http://www.w3.org/2000/svg">
                            <path d="M17.293 13.293A8 8 0 016.707 2.707a8.001 8.001 0 1010.586 10.586z"
                                stroke="currentColor" stroke-width="2" stroke-linejoin="round" />
                        </svg>
                    </label>

                    
                    <a href="../../../en/financial-support/" class="btn btn-primary" id="donate-btn">Donate</a>

                    
                    <a href="../../../en/downloads/" class="btn btn-primary">Get I2P</a>
                </div>
            </div>
        </nav>
    </div>
</header>

    <main id="main-content">
        



<div class="proposals-page">
    <div class="container">
        
        <nav class="breadcrumbs">
            <a href="../../../en/">Home</a>
            <span class="separator">/</span>
            <a href="../../../en/proposals/">Proposals</a>
            <span class="separator">/</span>
            <span class="current">SSU2</span>
        </nav>

        


        
        <header class="proposal-header">
            <div class="proposal-title-section">
                <h1 class="proposal-title">SSU2</h1>
                <div class="proposal-number">Proposal 159</div>
            </div>

            
            <div class="proposal-meta-box">
                <div class="proposal-status status-closed">
                    Closed
                </div>

                
                <div class="proposal-info-grid">
                    
                    <div class="info-item">
                        <span class="info-label">Author</span>
                        <span class="info-value">eyedeekay, orignal, zlatinb, zzz</span>
                    </div>
                    

                    
                    <div class="info-item">
                        <span class="info-label">Created</span>
                        <span class="info-value">2021-09-12</span>
                    </div>
                    

                    
                    <div class="info-item">
                        <span class="info-label">Last Updated</span>
                        <span class="info-value">2025-03-05</span>
                    </div>
                    

                    
                    <div class="info-item">
                        <span class="info-label">Target Version</span>
                        <span class="info-value">0.9.56</span>
                    </div>
                    

                    
                </div>

                
                
            </div>
        </header>

        
        <div class="proposal-layout proposal-layout--with-toc">
            
            
            <aside class="proposal-toc-sidebar">
                <nav class="toc-nav">
                    <div class="toc-header">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none">
                            <path d="M4 6h16M4 12h16M4 18h16" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                        </svg>
                        On This Page
                    </div>
                    <div class="toc-content">
                        <nav id="TableOfContents">
  <ul>
    <li><a href="#status">Status</a></li>
    <li><a href="#overview">Overview</a></li>
    <li><a href="#motivation">Motivation</a></li>
    <li><a href="#design-goals">Design Goals</a>
      <ul>
        <li><a href="#non-goals">Non-Goals</a></li>
      </ul>
    </li>
    <li><a href="#security-goals">Security Goals</a>
      <ul>
        <li><a href="#additional-dpi-discussion">Additional DPI Discussion</a></li>
        <li><a href="#address-validation">Address Validation</a></li>
        <li><a href="#connection-migration">Connection Migration</a></li>
        <li><a href="#security-considerations">Security Considerations</a></li>
        <li><a href="#relay-security">Relay Security</a></li>
        <li><a href="#peer-test-security">Peer Test Security</a></li>
        <li><a href="#relay-and-peer-test-design-goals">Relay and Peer Test Design Goals</a></li>
      </ul>
    </li>
    <li><a href="#design-overview">Design Overview</a>
      <ul>
        <li><a href="#summary">Summary</a></li>
        <li><a href="#delivery-guarantees">Delivery Guarantees</a></li>
        <li><a href="#noise-protocol-framework">Noise Protocol Framework</a></li>
        <li><a href="#additions-to-the-framework">Additions to the Framework</a></li>
        <li><a href="#processing-overhead-estimate">Processing overhead estimate</a></li>
      </ul>
    </li>
    <li><a href="#definitions">Definitions</a></li>
    <li><a href="#messages">Messages</a>
      <ul>
        <li><a href="#session-establishment">Session Establishment</a></li>
        <li><a href="#packet-header">Packet Header</a></li>
        <li><a href="#packet-integrity">Packet Integrity</a></li>
        <li><a href="#authenticated-encryption">Authenticated Encryption</a></li>
        <li><a href="#kdf-for-session-request">KDF for Session Request</a></li>
        <li><a href="#sessionrequest-type-0">SessionRequest (Type 0)</a></li>
        <li><a href="#kdf-for-session-created-and-session-confirmed-part-1">KDF for Session Created and Session Confirmed part 1</a></li>
        <li><a href="#sessioncreated-type-1">SessionCreated (Type 1)</a></li>
        <li><a href="#kdf-for-session-confirmed-part-1-using-session-created-kdf">KDF for Session Confirmed part 1, using Session Created KDF</a></li>
        <li><a href="#kdf-for-session-confirmed-part-2">KDF for Session Confirmed part 2</a></li>
        <li><a href="#sessionconfirmed-type-2">SessionConfirmed (Type 2)</a></li>
        <li><a href="#kdf-for-data-phase">KDF for data phase</a></li>
        <li><a href="#data-message-type-6">Data Message (Type 6)</a></li>
        <li><a href="#kdf-for-peer-test">KDF for Peer Test</a></li>
        <li><a href="#peer-test-type-7">Peer Test (Type 7)</a></li>
        <li><a href="#kdf-for-retry">KDF for Retry</a></li>
        <li><a href="#retry-type-9">Retry (Type 9)</a></li>
        <li><a href="#kdf-for-token-request">KDF for Token Request</a></li>
        <li><a href="#token-request-type-10">Token Request (Type 10)</a></li>
        <li><a href="#kdf-for-hole-punch">KDF for Hole Punch</a></li>
        <li><a href="#hole-punch-type-11">Hole Punch (Type 11)</a></li>
      </ul>
    </li>
    <li><a href="#noise-payload">Noise Payload</a>
      <ul>
        <li><a href="#payload-format">Payload Format</a></li>
        <li><a href="#block-ordering-rules">Block Ordering Rules</a></li>
        <li><a href="#block-specifications">Block Specifications</a></li>
      </ul>
    </li>
    <li><a href="#replay-prevention">Replay Prevention</a></li>
    <li><a href="#handshake-retransmission">Handshake Retransmission</a>
      <ul>
        <li><a href="#session-request">Session Request</a></li>
        <li><a href="#session-created">Session Created</a></li>
        <li><a href="#session-confirmed">Session Confirmed</a></li>
        <li><a href="#token-request">Token Request</a></li>
        <li><a href="#retry">Retry</a></li>
        <li><a href="#total-timeout">Total Timeout</a></li>
        <li><a href="#duplicates-and-error-handling">Duplicates and Error Handling</a></li>
      </ul>
    </li>
    <li><a href="#tokens">Tokens</a></li>
    <li><a href="#i2np-message-fragmentation">I2NP Message Fragmentation</a></li>
    <li><a href="#i2np-message-duplication">I2NP Message Duplication</a></li>
    <li><a href="#congestion-control">Congestion Control</a>
      <ul>
        <li><a href="#packet-numbers">Packet Numbers</a></li>
        <li><a href="#session-confirmed-ack">Session Confirmed ACK</a></li>
        <li><a href="#generating-acks">Generating ACKs</a></li>
        <li><a href="#handshake-acks">Handshake ACKs</a></li>
        <li><a href="#sending-ack-blocks">Sending ACK Blocks</a></li>
        <li><a href="#ack-frequency">ACK Frequency</a></li>
        <li><a href="#immediate-ack-flag">Immediate ACK Flag</a></li>
        <li><a href="#ack-block-size">ACK Block Size</a></li>
        <li><a href="#limiting-ranges-by-tracking-ack-blocks">Limiting Ranges by Tracking ACK Blocks</a></li>
        <li><a href="#congestion-1">Congestion</a></li>
        <li><a href="#retransmission">Retransmission</a></li>
        <li><a href="#window">Window</a></li>
      </ul>
    </li>
    <li><a href="#connection-migration-2">Connection Migration</a>
      <ul>
        <li><a href="#threat-model">Threat Model</a></li>
        <li><a href="#initiating-path-validation-1">Initiating Path Validation</a></li>
        <li><a href="#message-contents">Message Contents</a></li>
        <li><a href="#routing-during-path-validation">Routing during Path Validation</a></li>
        <li><a href="#responding-to-path-challenge">Responding to Path Challenge</a></li>
        <li><a href="#successful-path-validation-1">Successful Path Validation</a></li>
        <li><a href="#cancelling-path-validation">Cancelling Path Validation</a></li>
        <li><a href="#failed-path-validation-1">Failed Path Validation</a></li>
        <li><a href="#validation-after-local-change">Validation After Local Change</a></li>
        <li><a href="#use-as-pingpong">Use as Ping/Pong</a></li>
      </ul>
    </li>
    <li><a href="#multiple-sessions">Multiple Sessions</a></li>
    <li><a href="#session-termination">Session Termination</a>
      <ul>
        <li><a href="#handshake-phase">Handshake phase</a></li>
        <li><a href="#data-phase">Data phase</a></li>
        <li><a href="#cleanup">Cleanup</a></li>
      </ul>
    </li>
    <li><a href="#mtu">MTU</a>
      <ul>
        <li><a href="#ssu-address">SSU Address</a></li>
        <li><a href="#ssu2-address">SSU2 Address</a></li>
        <li><a href="#pmtu-discovery">PMTU Discovery</a></li>
        <li><a href="#handshake-min-size">Handshake Min Size</a></li>
        <li><a href="#path-message-min-size">Path Message Min Size</a></li>
        <li><a href="#max-i2np-message-size">Max I2NP Message Size</a></li>
      </ul>
    </li>
    <li><a href="#peer-test-process">Peer Test Process</a>
      <ul>
        <li><a href="#versions">Versions</a></li>
        <li><a href="#retransmissions">Retransmissions</a></li>
        <li><a href="#ipv6-notes">IPv6 Notes</a></li>
        <li><a href="#processing-by-bob">Processing by Bob</a></li>
      </ul>
    </li>
    <li><a href="#relay-process">Relay Process</a>
      <ul>
        <li><a href="#retransmissions-1">Retransmissions</a></li>
        <li><a href="#ipv4v6">IPv4/v6</a></li>
        <li><a href="#processing-by-alice">Processing by Alice</a></li>
        <li><a href="#tag-requests-by-bob">Tag Requests by Bob</a></li>
      </ul>
    </li>
    <li><a href="#published-router-info">Published Router Info</a>
      <ul>
        <li><a href="#address-properties">Address Properties</a></li>
        <li><a href="#published-addresses">Published Addresses</a></li>
        <li><a href="#unpublished-ssu2-address">Unpublished SSU2 Address</a></li>
        <li><a href="#public-key-and-iv-rotation">Public Key and IV Rotation</a></li>
      </ul>
    </li>
    <li><a href="#packet-guidelines">Packet Guidelines</a>
      <ul>
        <li><a href="#outbound-packet-creation">Outbound Packet Creation</a></li>
        <li><a href="#inbound-packet-handling">Inbound Packet Handling</a></li>
        <li><a href="#notes-8">Notes</a></li>
        <li><a href="#version-detection">Version Detection</a></li>
      </ul>
    </li>
    <li><a href="#recommended-constants">Recommended Constants</a></li>
    <li><a href="#variants-fallbacks-and-general-issues">Variants, Fallbacks, and General Issues</a></li>
    <li><a href="#packet-overhead-analysis">Packet Overhead Analysis</a></li>
    <li><a href="#references">References</a></li>
  </ul>
</nav>
                    </div>
                </nav>
            </aside>
            

            
            <div class="proposal-main">
                <article class="proposal-content">
                    <h2 id="status">Status</h2>
<p>Rollout plan:</p>
<table>
  <thead>
      <tr>
          <th>Feature</th>
          <th>Testing (not default)</th>
          <th>Enabled by default</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Local test code</td>
          <td>2022-02</td>
          <td></td>
      </tr>
      <tr>
          <td>Joint test code</td>
          <td>2022-03</td>
          <td></td>
      </tr>
      <tr>
          <td>Joint test in-net</td>
          <td>0.9.54  2022-05</td>
          <td></td>
      </tr>
      <tr>
          <td>Freeze basic protocol</td>
          <td>0.9.54  2022-05</td>
          <td></td>
      </tr>
      <tr>
          <td>Basic Session</td>
          <td>0.9.55  2022-08</td>
          <td>0.9.56  2022-11</td>
      </tr>
      <tr>
          <td>Address Validation (Retry)</td>
          <td>0.9.55  2022-08</td>
          <td>0.9.56  2022-11</td>
      </tr>
      <tr>
          <td>Fragmented RI in handshake</td>
          <td>0.9.55  2022-08</td>
          <td>0.9.56  2022-11</td>
      </tr>
      <tr>
          <td>New Token</td>
          <td>0.9.55  2022-08</td>
          <td>0.9.57  2022-11</td>
      </tr>
      <tr>
          <td>Freeze extended protocol</td>
          <td>0.9.55  2022-08</td>
          <td></td>
      </tr>
      <tr>
          <td>Relay</td>
          <td>0.9.55  2022-08</td>
          <td>0.9.56  2022-11</td>
      </tr>
      <tr>
          <td>Peer Test</td>
          <td>0.9.55  2022-08</td>
          <td>0.9.56  2022-11</td>
      </tr>
      <tr>
          <td>Enable for random 2%</td>
          <td>0.9.55  2022-08</td>
          <td></td>
      </tr>
      <tr>
          <td>Path Validation</td>
          <td>0.9.55+ dev</td>
          <td>0.9.56  2022-11</td>
      </tr>
      <tr>
          <td>Connection Migration</td>
          <td>0.9.55+ dev</td>
          <td>0.9.56  2022-11</td>
      </tr>
      <tr>
          <td>Immediate ACK flag</td>
          <td>0.9.55+ dev</td>
          <td>0.9.56  2022-11</td>
      </tr>
      <tr>
          <td>Key Rotation</td>
          <td>0.9.57  2023-02</td>
          <td>0.9.58  2023-05</td>
      </tr>
      <tr>
          <td>Disable SSU 1 (i2pd)</td>
          <td>0.9.56  2022-11</td>
          <td></td>
      </tr>
      <tr>
          <td>Disable SSU 1 (Java I2P)</td>
          <td>0.9.58  2023-05</td>
          <td>0.9.61  2023-12</td>
      </tr>
  </tbody>
</table>
<p>Basic Session includes the handshake and data phase.
Extended protocol includes relay and peer test.</p>
<h2 id="overview">Overview</h2>
<p>This proposal describes an authenticated key agreement protocol to improve the
resistance of <a href="../../../en/docs/specs/ssu2/">SSU</a>
 to various forms of automated identification and attacks.</p>
<p>The proposal is organized as follows: the security goals are presented,
followed by a discussion of the basic protocol. Next, a complete specification
of all protocol messages is given. Finally, router addresses and version
identification are discussed.</p>
<p>As with other I2P transports, SSU2 is defined
for point-to-point (router-to-router) transport of I2NP messages.
It is not a general-purpose data pipe.
Like <a href="../../../en/docs/specs/ssu2/">SSU</a>
, it also provides two additional services:
Relaying for NAT traversal, and Peer Testing for determination of inbound reachability.
It also provides a third service, not in SSU, for connection migration
when a peer changes IP or port.</p>
<h2 id="motivation">Motivation</h2>
<p>SSU is the only remaining protocol layer that requires ElGamal, which is very slow.
The flow control for SSU is complex and does not work well.
Portions of SSU are vulnerable to address spoofing attacks.
The handshake does not use Noise.</p>
<h2 id="design-goals">Design Goals</h2>
<ul>
<li>
<p>Reduce CPU usage by eliminating ElGamal. Use X25519 for the DH.</p>
</li>
<li>
<p>Maintain the Peer Test and Relay functions, and increase security for them.</p>
</li>
<li>
<p>Make implementation easier by allowing for standard flow control
algorithms.</p>
</li>
<li>
<p>Reduce setup latency.
Median setup time is currently about 135 ms for NTCP2 and 187 ms for SSU,
even though NTCP2 has an additional round trip; replacing ElGamal in
SSU2 should reduce it, but other changes may also help.</p>
</li>
<li>
<p>Maintain or increase maximum throughput compared to SSU 1,
as measured over a range of simulated latencies and packet drop percentages on a testnet.</p>
</li>
<li>
<p>Prevent traffic amplification and misrouting attacks from spoofed source addresses
via &ldquo;address validation&rdquo;.</p>
</li>
<li>
<p>Make packet identification easier, to reduce reliance on fallbacks and
heuristics that make the code overly complex.</p>
</li>
<li>
<p>Formalize and improve connection migration when the peer&rsquo;s IP or port changes.
Do not migrate connections until address validation is complete, to prevent attacks.
Some SSU 1 implementations use expensive heuristics to handle port changes
due to NAT rebinding. No known SSU 1 implementations can handle IP changes at all.</p>
</li>
<li>
<p>Support SSU 1 and 2 on a single port, auto-detect, and published as a single
&ldquo;transport&rdquo; (i.e. RouterAddress) in the <a href="../../../en/docs/overview/network-database/">NetDB</a>
.</p>
</li>
<li>
<p>Publish support for version 1 only, 2 only, or 1+2 in the NetDB in a separate
field, and default to version 1 only (don&rsquo;t bind version support to a
particular router version)</p>
</li>
<li>
<p>Ensure that all implementations (Java/i2pd/Go) can add version 2
support (or not) on their own schedules</p>
</li>
<li>
<p>Add random padding to all messages including handshake and data messages.
All padding must be covered by the MAC, unlike the end-of-packet padding in SSU 1.
Provide options mechanism for both sides to request min and max padding
and/or padding distribution. Specifics of the padding distribution are
implementation-dependent and may or may not be specified in the protocol
itself.</p>
</li>
<li>
<p>Obfuscate the headers and contents of messages that aren&rsquo;t fully encrypted
sufficiently that DPI boxes and AV signatures can&rsquo;t easily classify them.
Also ensure that the messages going to a single peer or set of peers do not
have a similar pattern of bits.</p>
</li>
<li>
<p>Fix loss of bits in DH due to Java format <a href="https://trac.i2p2.i2p/ticket/1112">Ticket1112</a>
, and speed up the DH
by switching to X25519.</p>
</li>
<li>
<p>Switch to a real key derivation function (KDF) rather than using the DH
result as-is</p>
</li>
<li>
<p>Add &ldquo;probing resistance&rdquo; (as Tor calls it); this includes replay resistance.</p>
</li>
<li>
<p>Maintain 2-way authenticated key exchange (2W-AKE). 1W-AKE is not sufficient
for our application.</p>
</li>
<li>
<p>Rely on the static public key published in the RouterInfo as another part of
authentication.</p>
</li>
<li>
<p>Add options/version in handshake for future extensibility.</p>
</li>
<li>
<p>Don&rsquo;t add significantly to CPU required for connection setup; if possible,
reduce it significantly.</p>
</li>
<li>
<p>Remove requirement for padding to a multiple of 16 bytes
imposed by AES encryption in SSU 1.</p>
</li>
<li>
<p>Use standard ChaCha/Poly1305 for encryption and MAC,
replacing AES encryption and the nonstandard HMAC-MD5-128 MAC used in SSU 1.</p>
</li>
<li>
<p>Use separate encryption keys for send and receive, instead
of the common keys for both directions used in SSU 1.</p>
</li>
<li>
<p>Use a 3-message, one-round-trip handshake, as in <a href="../../../en/docs/specs/ntcp2/">NTCP2</a>
.
Remove the delay waiting for data messages that makes
<a href="../../../en/docs/specs/ssu2/">SSU</a>
 effectively a two-round-trip handshake.</p>
</li>
<li>
<p>Dramatically improve efficiency of ACKs and NACKs,
which is horrible in SSU 1. Reduce the bandwidth required
for ACKs and NACKs, and increase packet size available for data.
Efficiently encode NACKs for a burst of missing messages,
which is common over WiFi.</p>
</li>
<li>
<p>Reduce the complexity required to implement I2NP message fragmentation.
Bypass fragmentation mechanisms and encoding for complete I2NP messages.</p>
</li>
<li>
<p>Minimize protocol overhead before padding, especially for ACKs.
While padding will be added,
overhead before padding is still overhead.
Low-bandwidth nodes must be able to use SSU2.</p>
</li>
<li>
<p>Maintain timestamps for replay and skew detection.</p>
</li>
<li>
<p>Avoid any year 2038 issues in timestamps, must work until at least 2106.</p>
</li>
<li>
<p>Increase minimum MTU from 620 to 1280 for efficiency, ease of implementation,
and increasing the maximum I2NP message size.
Fragmentation and reassembly is quite costly.
By providing room for 1028 byte tunnel messages, a large majority of I2NP
messages will not require fragmentation.</p>
</li>
<li>
<p>Increase maximum MTU from 1488 (1484 for IPv6) to 1500 for efficiency.
Remove requirement that the MTU be a multiple of 16.</p>
</li>
<li>
<p>Increase the maximum I2NP message size from approximately 32K in SSU 1
to approximately 64 KB as in NTCP2.</p>
</li>
<li>
<p>Remove the signature of IP and port fields from the handshake,
so that routers that don&rsquo;t know
their external IP and port will be able to connect.</p>
</li>
<li>
<p>Retain the IP/port discovery mechanism from SSU 1 in the handshake,
so that routers may learn their external IP and port.</p>
</li>
<li>
<p>Include representatives of Java, C++, and Go router developers in the design.</p>
</li>
</ul>
<h3 id="non-goals">Non-Goals</h3>
<ul>
<li>
<p>Bullet-proof DPI resistance&hellip; that would be pluggable transports,
<a href="../../../en/proposals/109-pt-transport/">Proposal 109</a>
.</p>
</li>
<li>
<p>A TLS-based (or HTTPS-lookalike) transport&hellip; that would be <a href="../../../en/proposals/104-tls-transport/">Proposal 104</a>
.</p>
</li>
<li>
<p>Timing-based DPI resistance (inter-message timing/delays can be
implementation-dependent; intra-message delays can be introduced at any
point, including before sending the random padding, for example). Artificial
delays (what obfs4 calls IAT or inter-arrival time) are independent of the
protocol itself.</p>
</li>
<li>
<p>Deniability of participating in a session (there&rsquo;s signatures in there).</p>
</li>
</ul>
<p>Non-goals that may be partially reconsidered or discussed:</p>
<ul>
<li>
<p>The degree of protection against Deep Packet Inspection (DPI)</p>
</li>
<li>
<p>Post-Quantum (PQ) security</p>
</li>
<li>
<p>Deniability</p>
</li>
</ul>
<h2 id="security-goals">Security Goals</h2>
<p>We consider three parties:</p>
<ul>
<li>Alice, who wishes to establish a new session.</li>
<li>Bob, with whom Alice wishes to establish a session.</li>
<li>Mallory, the &ldquo;man in the middle&rdquo; between Alice and Bob.</li>
</ul>
<p>At most two participants can engage in active attacks.</p>
<p>Alice and Bob are both in possession of a static key pair, which is contained
in their RouterIdentity.</p>
<p>The proposed protocol attempts to allow Alice and Bob to agree on a shared
secret key (K) under the following requirements:</p>
<ol>
<li>
<p>Private key security: neither Bob nor Mallory learns anything about Alice&rsquo;s
static private key. Symmetrically, Alice does not learn anything about Bob&rsquo;s
static private key.</p>
</li>
<li>
<p>The session key K is only known by Alice and Bob.</p>
</li>
<li>
<p>Perfect forward secrecy: the agreed upon session key remains secret in the
future, even when the static private keys of Alice and/or Bob are revealed
after the key has been agreed upon.</p>
</li>
<li>
<p>Two-way authentication: Alice is certain that she has established a session
with Bob, and vice versa.</p>
</li>
<li>
<p>Protection against online DPI: Ensure that it is not trivial to detect that
Alice and Bob are engaged in the protocol using only straightforward deep
packet inspection (DPI) techniques. See below.</p>
</li>
<li>
<p>Limited deniability: neither Alice nor Bob can deny participation in the
protocol, but if either leaks the shared key the other party can deny the
authenticity of the contents of the transmitted data.</p>
</li>
</ol>
<p>The present proposal attempts to provide all five requirements based on the
Station-To-Station (STS) protocol Station-To-Station (STS) protocol. Note that this protocol is also the
basis for the <a href="../../../en/docs/specs/ssu2/">SSU</a>
 protocol.</p>
<h3 id="additional-dpi-discussion">Additional DPI Discussion</h3>
<p>We assume two DPI components:</p>
<h4 id="online-dpi">Online DPI</h4>
<p>Online DPI inspecting all flows in real-time. Connections may be blocked or
otherwise tampered with. Connection data or metadata may be identified and
stored for offline analysis.  The online DPI does not have access to the I2P
network database.  The online DPI has only limited real-time computational
capability, including length calculation, field inspection, and simple
calculations such as XOR.  The online DPI does have the capability of fast
real-time cryptographic functions such as ChaCha20, AEAD, and hashing, but these
would be too expensive to apply to most or all flows. Any application of these
cryptographic operations would apply only to flows on IP/Port combinations
previously identified by offline analysis.  The online DPI does not have the
capability of high-overhead cryptographic functions such as DH or elligator2.
The online DPI is not designed specifically to detect I2P, although it may have
limited classification rules for that purpose.</p>
<p>It is a goal to prevent protocol identification by an online DPI.</p>
<p>The notion of online or &ldquo;straightforward&rdquo; DPI is here taken to include the
following adversary capabilities:</p>
<ol>
<li>
<p>The ability to inspect all data sent or received by the target.</p>
</li>
<li>
<p>The ability to perform operations on the observed data, such as
applying block ciphers or hash functions.</p>
</li>
<li>
<p>The ability to store and compare with previously sent messages.</p>
</li>
<li>
<p>The ability to modify, delay or fragment packets.</p>
</li>
</ol>
<p>However, the online DPI is assumed to have the following restrictions:</p>
<ol start="5">
<li>
<p>The inability to map IP addresses to router hashes. While this is trivial
with real-time access to the network database,
it would require a DPI system specifically designed to target I2P.</p>
</li>
<li>
<p>The inability to use timing information to detect the protocol.</p>
</li>
<li>
<p>Generally speaking, the online DPI toolbox does not contain any built-in
tools that are specifically designed for I2P detection. This includes
creating &ldquo;honeypots&rdquo;, which would for example include nonrandom padding in
their messages. Note that this does not exclude machine learning systems or
highly configurable DPI tools as long as they meet the other requirements.</p>
</li>
</ol>
<p>To counter payload analysis, it is ensured that all messages are
indistinguishable from random. This also requires their length to be random,
which is more complicated than just adding random padding. In fact, in Appendix
A, the authors argue that a naive (i.e. uniform) padding scheme does not
resolve the problem. Appendix A therefore proposes to include either random
delays or to develop an alternate padding scheme that can provide reasonable
protection for the proposed attack.</p>
<p>To protect against the sixth entry above, implementations should include random
delays in the protocol. Such techniques are not covered by this proposal, but
they could also resolve the padding length issues. In summary, the proposal
provides good protection against payload analysis (when the considerations in
Appendix A are taken into account), but only limited protection against flow
analysis.</p>
<h4 id="offline-dpi">Offline DPI</h4>
<p>Offline DPI inspecting data stored by the online DPI for later analysis.
The offline DPI may be designed specifically to detect I2P.
The offline DPI does have real-time access to the I2P network database.
The offline DPI does have access to this and other I2P specifications.
The offline DPI has unlimited computational capability, including
all cryptographic functions defined in this specification.</p>
<p>The offline DPI does not have the ability to block existing connections.  The
offline DPI does have the capability to do near-realtime (within minutes of
setup) sending to host/port of parties by packet injection.  The offline DPI
does have the capability to do near-realtime (within minutes of setup) replay
of previous messages (modified or not) for &ldquo;probing&rdquo; or other reasons.</p>
<p>It is not a goal to prevent protocol identification by an offline DPI.
All decoding of obfuscated data in the first two messages, which
is implemented by I2P routers, may also be implemented by the offline DPI.</p>
<p>It is a goal to reject attempted connections using replay of previous messages.</p>
<h3 id="address-validation">Address Validation</h3>
<p>Following is copied from QUIC <a href="https://datatracker.ietf.org/doc/html/rfc9000">RFC 9000</a>
.
For each section, review and edit.</p>
<p>Address validation ensures that an endpoint cannot be used for a
traffic amplification attack.  In such an attack, a packet is sent to
a server with spoofed source address information that identifies a
victim.  If a server generates more or larger packets in response to
that packet, the attacker can use the server to send more data toward
the victim than it would be able to send on its own.</p>
<p>The primary defense against amplification attacks is verifying that a
peer is able to receive packets at the transport address that it
claims.  Therefore, after receiving packets from an address that is
not yet validated, an endpoint MUST limit the amount of data it sends
to the unvalidated address to three times the amount of data received
from that address.  This limit on the size of responses is known as
the anti-amplification limit.</p>
<p>Address validation is performed both during connection establishment
(see Section 8.1) and during connection migration (see Section 8.2).</p>
<h4 id="address-validation-during-connection-establishment">Address Validation during Connection Establishment</h4>
<p>Connection establishment implicitly provides address validation for
both endpoints.  In particular, receipt of a packet protected with
Handshake keys confirms that the peer successfully processed an
Initial packet.  Once an endpoint has successfully processed a
Handshake packet from the peer, it can consider the peer address to
have been validated.</p>
<p>Additionally, an endpoint MAY consider the peer address validated if
the peer uses a connection ID chosen by the endpoint and the
connection ID contains at least 64 bits of entropy.</p>
<p>For the client, the value of the Destination Connection ID field in
its first Initial packet allows it to validate the server address as
a part of successfully processing any packet.  Initial packets from
the server are protected with keys that are derived from this value
(see Section 5.2 of <a href="https://datatracker.ietf.org/doc/html/rfc9001">QUIC-TLS</a>
).  Alternatively, the value is echoed
by the server in Version Negotiation packets (Section 6) or included
in the Integrity Tag in Retry packets (Section 5.8 of <a href="https://datatracker.ietf.org/doc/html/rfc9001">QUIC-TLS</a>
).</p>
<p>Prior to validating the client address, servers MUST NOT send more
than three times as many bytes as the number of bytes they have
received.  This limits the magnitude of any amplification attack that
can be mounted using spoofed source addresses.  For the purposes of
avoiding amplification prior to address validation, servers MUST
count all of the payload bytes received in datagrams that are
uniquely attributed to a single connection.  This includes datagrams
that contain packets that are successfully processed and datagrams
that contain packets that are all discarded.</p>
<p>Clients MUST ensure that UDP datagrams containing Initial packets
have UDP payloads of at least 1200 bytes, adding PADDING frames as
necessary.  A client that sends padded datagrams allows the server to
send more data prior to completing address validation.</p>
<p>Loss of an Initial or Handshake packet from the server can cause a
deadlock if the client does not send additional Initial or Handshake
packets.  A deadlock could occur when the server reaches its anti-
amplification limit and the client has received acknowledgments for
all the data it has sent.  In this case, when the client has no
reason to send additional packets, the server will be unable to send
more data because it has not validated the client&rsquo;s address.  To
prevent this deadlock, clients MUST send a packet on a Probe Timeout
(PTO); see Section 6.2 of <a href="https://datatracker.ietf.org/doc/html/rfc9002">QUIC-RECOVERY</a>
.  Specifically, the client
MUST send an Initial packet in a UDP datagram that contains at least
1200 bytes if it does not have Handshake keys, and otherwise send a
Handshake packet.</p>
<p>A server might wish to validate the client address before starting
the cryptographic handshake.  QUIC uses a token in the Initial packet
to provide address validation prior to completing the handshake.
This token is delivered to the client during connection establishment
with a Retry packet (see Section 8.1.2) or in a previous connection
using the NEW_TOKEN frame (see Section 8.1.3).</p>
<p>In addition to sending limits imposed prior to address validation,
servers are also constrained in what they can send by the limits set
by the congestion controller.  Clients are only constrained by the
congestion controller.</p>
<h4 id="token-construction">Token Construction</h4>
<p>A token sent in a NEW_TOKEN frame or a Retry packet MUST be
constructed in a way that allows the server to identify how it was
provided to a client.  These tokens are carried in the same field but
require different handling from servers.</p>
<h4 id="address-validation-using-retry-packets">Address Validation Using Retry Packets</h4>
<p>Upon receiving the client&rsquo;s Initial packet, the server can request
address validation by sending a Retry packet (Section 17.2.5)
containing a token.  This token MUST be repeated by the client in all
Initial packets it sends for that connection after it receives the
Retry packet.</p>
<p>In response to processing an Initial packet containing a token that
was provided in a Retry packet, a server cannot send another Retry
packet; it can only refuse the connection or permit it to proceed.</p>
<p>As long as it is not possible for an attacker to generate a valid
token for its own address (see Section 8.1.4) and the client is able
to return that token, it proves to the server that it received the
token.</p>
<p>A server can also use a Retry packet to defer the state and
processing costs of connection establishment.  Requiring the server
to provide a different connection ID, along with the
original_destination_connection_id transport parameter defined in
Section 18.2, forces the server to demonstrate that it, or an entity
it cooperates with, received the original Initial packet from the
client.  Providing a different connection ID also grants a server
some control over how subsequent packets are routed.  This can be
used to direct connections to a different server instance.</p>
<p>If a server receives a client Initial that contains an invalid Retry
token but is otherwise valid, it knows the client will not accept
another Retry token.  The server can discard such a packet and allow
the client to time out to detect handshake failure, but that could
impose a significant latency penalty on the client.  Instead, the
server SHOULD immediately close (Section 10.2) the connection with an
INVALID_TOKEN error.  Note that a server has not established any
state for the connection at this point and so does not enter the
closing period.</p>
<p>A flow showing the use of a Retry packet is shown in Figure 9.</p>
<pre tabindex="0"><code>Client                                                  Server

Initial[0]: CRYPTO[CH] -&gt;

                                                &lt;- Retry+Token

Initial+Token[1]: CRYPTO[CH] -&gt;

                                 Initial[0]: CRYPTO[SH] ACK[1]
                       Handshake[0]: CRYPTO[EE, CERT, CV, FIN]
                                 &lt;- 1-RTT[0]: STREAM[1, &#34;...&#34;]

                Figure 9: Example Handshake with Retry
</code></pre><h4 id="address-validation-for-future-connections">Address Validation for Future Connections</h4>
<p>A server MAY provide clients with an address validation token during
one connection that can be used on a subsequent connection.  Address
validation is especially important with 0-RTT because a server
potentially sends a significant amount of data to a client in
response to 0-RTT data.</p>
<p>The server uses the NEW_TOKEN frame (Section 19.7) to provide the
client with an address validation token that can be used to validate
future connections.  In a future connection, the client includes this
token in Initial packets to provide address validation.  The client
MUST include the token in all Initial packets it sends, unless a
Retry replaces the token with a newer one.  The client MUST NOT use
the token provided in a Retry for future connections.  Servers MAY
discard any Initial packet that does not carry the expected token.</p>
<p>Unlike the token that is created for a Retry packet, which is used
immediately, the token sent in the NEW_TOKEN frame can be used after
some period of time has passed.  Thus, a token SHOULD have an
expiration time, which could be either an explicit expiration time or
an issued timestamp that can be used to dynamically calculate the
expiration time.  A server can store the expiration time or include
it in an encrypted form in the token.</p>
<p>A token issued with NEW_TOKEN MUST NOT include information that would
allow values to be linked by an observer to the connection on which
it was issued.  For example, it cannot include the previous
connection ID or addressing information, unless the values are
encrypted.  A server MUST ensure that every NEW_TOKEN frame it sends
is unique across all clients, with the exception of those sent to
repair losses of previously sent NEW_TOKEN frames.  Information that
allows the server to distinguish between tokens from Retry and
NEW_TOKEN MAY be accessible to entities other than the server.</p>
<p>It is unlikely that the client port number is the same on two
different connections; validating the port is therefore unlikely to
be successful.</p>
<p>A token received in a NEW_TOKEN frame is applicable to any server
that the connection is considered authoritative for (e.g., server
names included in the certificate).  When connecting to a server for
which the client retains an applicable and unused token, it SHOULD
include that token in the Token field of its Initial packet.
Including a token might allow the server to validate the client
address without an additional round trip.  A client MUST NOT include
a token that is not applicable to the server that it is connecting
to, unless the client has the knowledge that the server that issued
the token and the server the client is connecting to are jointly
managing the tokens.  A client MAY use a token from any previous
connection to that server.</p>
<p>A token allows a server to correlate activity between the connection
where the token was issued and any connection where it is used.
Clients that want to break continuity of identity with a server can
discard tokens provided using the NEW_TOKEN frame.  In comparison, a
token obtained in a Retry packet MUST be used immediately during the
connection attempt and cannot be used in subsequent connection
attempts.</p>
<p>A client SHOULD NOT reuse a token from a NEW_TOKEN frame for
different connection attempts.  Reusing a token allows connections to
be linked by entities on the network path; see Section 9.5.</p>
<p>Clients might receive multiple tokens on a single connection.  Aside
from preventing linkability, any token can be used in any connection
attempt.  Servers can send additional tokens to either enable address
validation for multiple connection attempts or replace older tokens
that might become invalid.  For a client, this ambiguity means that
sending the most recent unused token is most likely to be effective.
Though saving and using older tokens have no negative consequences,
clients can regard older tokens as being less likely to be useful to
the server for address validation.</p>
<p>When a server receives an Initial packet with an address validation
token, it MUST attempt to validate the token, unless it has already
completed address validation.  If the token is invalid, then the
server SHOULD proceed as if the client did not have a validated
address, including potentially sending a Retry packet.  Tokens
provided with NEW_TOKEN frames and Retry packets can be distinguished
by servers (see Section 8.1.1), and the latter can be validated more
strictly.  If the validation succeeds, the server SHOULD then allow
the handshake to proceed.</p>
<p>Note: The rationale for treating the client as unvalidated
rather than discarding the packet is that the client might have
received the token in a previous connection using the NEW_TOKEN
frame, and if the server has lost state, it might be unable to
validate the token at all, leading to connection failure if the
packet is discarded.</p>
<p>In a stateless design, a server can use encrypted and authenticated
tokens to pass information to clients that the server can later
recover and use to validate a client address.  Tokens are not
integrated into the cryptographic handshake, and so they are not
authenticated.  For instance, a client might be able to reuse a
token.  To avoid attacks that exploit this property, a server can
limit its use of tokens to only the information needed to validate
client addresses.</p>
<p>Clients MAY use tokens obtained on one connection for any connection
attempt using the same version.  When selecting a token to use,
clients do not need to consider other properties of the connection
that is being attempted, including the choice of possible application
protocols, session tickets, or other connection properties.</p>
<h4 id="address-validation-token-integrity">Address Validation Token Integrity</h4>
<p>An address validation token MUST be difficult to guess.  Including a
random value with at least 128 bits of entropy in the token would be
sufficient, but this depends on the server remembering the value it
sends to clients.</p>
<p>A token-based scheme allows the server to offload any state
associated with validation to the client.  For this design to work,
the token MUST be covered by integrity protection against
modification or falsification by clients.  Without integrity
protection, malicious clients could generate or guess values for
tokens that would be accepted by the server.  Only the server
requires access to the integrity protection key for tokens.</p>
<p>There is no need for a single well-defined format for the token
because the server that generates the token also consumes it.  Tokens
sent in Retry packets SHOULD include information that allows the
server to verify that the source IP address and port in client
packets remain constant.</p>
<p>Tokens sent in NEW_TOKEN frames MUST include information that allows
the server to verify that the client IP address has not changed from
when the token was issued.  Servers can use tokens from NEW_TOKEN
frames in deciding not to send a Retry packet, even if the client
address has changed.  If the client IP address has changed, the
server MUST adhere to the anti-amplification limit; see Section 8.
Note that in the presence of NAT, this requirement might be
insufficient to protect other hosts that share the NAT from
amplification attacks.</p>
<p>Attackers could replay tokens to use servers as amplifiers in DDoS
attacks.  To protect against such attacks, servers MUST ensure that
replay of tokens is prevented or limited.  Servers SHOULD ensure that
tokens sent in Retry packets are only accepted for a short time, as
they are returned immediately by clients.  Tokens that are provided
in NEW_TOKEN frames (Section 19.7) need to be valid for longer but
SHOULD NOT be accepted multiple times.  Servers are encouraged to
allow tokens to be used only once, if possible; tokens MAY include
additional information about clients to further narrow applicability
or reuse.</p>
<h4 id="path-validation">Path Validation</h4>
<p>Path validation is used by both peers during connection migration
(see Section 9) to verify reachability after a change of address.  In
path validation, endpoints test reachability between a specific local
address and a specific peer address, where an address is the 2-tuple
of IP address and port.</p>
<p>Path validation tests that packets sent on a path to a peer are
received by that peer.  Path validation is used to ensure that
packets received from a migrating peer do not carry a spoofed source
address.</p>
<p>Path validation does not validate that a peer can send in the return
direction.  Acknowledgments cannot be used for return path validation
because they contain insufficient entropy and might be spoofed.
Endpoints independently determine reachability on each direction of a
path, and therefore return reachability can only be established by
the peer.</p>
<p>Path validation can be used at any time by either endpoint.  For
instance, an endpoint might check that a peer is still in possession
of its address after a period of quiescence.</p>
<p>Path validation is not designed as a NAT traversal mechanism.  Though
the mechanism described here might be effective for the creation of
NAT bindings that support NAT traversal, the expectation is that one
endpoint is able to receive packets without first having sent a
packet on that path.  Effective NAT traversal needs additional
synchronization mechanisms that are not provided here.</p>
<p>An endpoint MAY include other frames with the PATH_CHALLENGE and
PATH_RESPONSE frames used for path validation.  In particular, an
endpoint can include PADDING frames with a PATH_CHALLENGE frame for
Path Maximum Transmission Unit Discovery (PMTUD); see Section 14.2.1.
An endpoint can also include its own PATH_CHALLENGE frame when
sending a PATH_RESPONSE frame.</p>
<p>An endpoint uses a new connection ID for probes sent from a new local
address; see Section 9.5.  When probing a new path, an endpoint can
ensure that its peer has an unused connection ID available for
responses.  Sending NEW_CONNECTION_ID and PATH_CHALLENGE frames in
the same packet, if the peer&rsquo;s active_connection_id_limit permits,
ensures that an unused connection ID will be available to the peer
when sending a response.</p>
<p>An endpoint can choose to simultaneously probe multiple paths.  The
number of simultaneous paths used for probes is limited by the number
of extra connection IDs its peer has previously supplied, since each
new local address used for a probe requires a previously unused
connection ID.</p>
<h4 id="initiating-path-validation">Initiating Path Validation</h4>
<p>To initiate path validation, an endpoint sends a PATH_CHALLENGE frame
containing an unpredictable payload on the path to be validated.</p>
<p>An endpoint MAY send multiple PATH_CHALLENGE frames to guard against
packet loss.  However, an endpoint SHOULD NOT send multiple
PATH_CHALLENGE frames in a single packet.</p>
<p>An endpoint SHOULD NOT probe a new path with packets containing a
PATH_CHALLENGE frame more frequently than it would send an Initial
packet.  This ensures that connection migration is no more load on a
new path than establishing a new connection.</p>
<p>The endpoint MUST use unpredictable data in every PATH_CHALLENGE
frame so that it can associate the peer&rsquo;s response with the
corresponding PATH_CHALLENGE.</p>
<p>An endpoint MUST expand datagrams that contain a PATH_CHALLENGE frame
to at least the smallest allowed maximum datagram size of 1200 bytes,
unless the anti-amplification limit for the path does not permit
sending a datagram of this size.  Sending UDP datagrams of this size
ensures that the network path from the endpoint to the peer can be
used for QUIC; see Section 14.</p>
<p>When an endpoint is unable to expand the datagram size to 1200 bytes
due to the anti-amplification limit, the path MTU will not be
validated.  To ensure that the path MTU is large enough, the endpoint
MUST perform a second path validation by sending a PATH_CHALLENGE
frame in a datagram of at least 1200 bytes.  This additional
validation can be performed after a PATH_RESPONSE is successfully
received or when enough bytes have been received on the path that
sending the larger datagram will not result in exceeding the anti-
amplification limit.</p>
<p>Unlike other cases where datagrams are expanded, endpoints MUST NOT
discard datagrams that appear to be too small when they contain
PATH_CHALLENGE or PATH_RESPONSE.</p>
<h4 id="path-validation-responses">Path Validation Responses</h4>
<p>On receiving a PATH_CHALLENGE frame, an endpoint MUST respond by
echoing the data contained in the PATH_CHALLENGE frame in a
PATH_RESPONSE frame.  An endpoint MUST NOT delay transmission of a
packet containing a PATH_RESPONSE frame unless constrained by
congestion control.</p>
<p>A PATH_RESPONSE frame MUST be sent on the network path where the
PATH_CHALLENGE frame was received.  This ensures that path validation
by a peer only succeeds if the path is functional in both directions.
This requirement MUST NOT be enforced by the endpoint that initiates
path validation, as that would enable an attack on migration; see
Section 9.3.3.</p>
<p>An endpoint MUST expand datagrams that contain a PATH_RESPONSE frame
to at least the smallest allowed maximum datagram size of 1200 bytes.
This verifies that the path is able to carry datagrams of this size
in both directions.  However, an endpoint MUST NOT expand the
datagram containing the PATH_RESPONSE if the resulting data exceeds
the anti-amplification limit.  This is expected to only occur if the
received PATH_CHALLENGE was not sent in an expanded datagram.</p>
<p>An endpoint MUST NOT send more than one PATH_RESPONSE frame in
response to one PATH_CHALLENGE frame; see Section 13.3.  The peer is
expected to send more PATH_CHALLENGE frames as necessary to evoke
additional PATH_RESPONSE frames.</p>
<h4 id="successful-path-validation">Successful Path Validation</h4>
<p>Path validation succeeds when a PATH_RESPONSE frame is received that
contains the data that was sent in a previous PATH_CHALLENGE frame.
A PATH_RESPONSE frame received on any network path validates the path
on which the PATH_CHALLENGE was sent.</p>
<p>If an endpoint sends a PATH_CHALLENGE frame in a datagram that is not
expanded to at least 1200 bytes and if the response to it validates
the peer address, the path is validated but not the path MTU.  As a
result, the endpoint can now send more than three times the amount of
data that has been received.  However, the endpoint MUST initiate
another path validation with an expanded datagram to verify that the
path supports the required MTU.</p>
<p>Receipt of an acknowledgment for a packet containing a PATH_CHALLENGE
frame is not adequate validation, since the acknowledgment can be
spoofed by a malicious peer.</p>
<h4 id="failed-path-validation">Failed Path Validation</h4>
<p>Path validation only fails when the endpoint attempting to validate
the path abandons its attempt to validate the path.</p>
<p>Endpoints SHOULD abandon path validation based on a timer.  When
setting this timer, implementations are cautioned that the new path
could have a longer round-trip time than the original.  A value of
three times the larger of the current PTO or the PTO for the new path
(using kInitialRtt, as defined in <a href="https://datatracker.ietf.org/doc/html/rfc9002">QUIC-RECOVERY</a>
) is RECOMMENDED.</p>
<p>This timeout allows for multiple PTOs to expire prior to failing path
validation, so that loss of a single PATH_CHALLENGE or PATH_RESPONSE
frame does not cause path validation failure.</p>
<p>Note that the endpoint might receive packets containing other frames
on the new path, but a PATH_RESPONSE frame with appropriate data is
required for path validation to succeed.</p>
<p>When an endpoint abandons path validation, it determines that the
path is unusable.  This does not necessarily imply a failure of the
connection &ndash; endpoints can continue sending packets over other paths
as appropriate.  If no paths are available, an endpoint can wait for
a new path to become available or close the connection.  An endpoint
that has no valid network path to its peer MAY signal this using the
NO_VIABLE_PATH connection error, noting that this is only possible if
the network path exists but does not support the required MTU
(Section 14).</p>
<p>A path validation might be abandoned for other reasons besides
failure.  Primarily, this happens if a connection migration to a new
path is initiated while a path validation on the old path is in
progress.</p>
<h3 id="connection-migration">Connection Migration</h3>
<p>Following is copied from QUIC <a href="https://datatracker.ietf.org/doc/html/rfc9000">RFC 9000</a>
.
For each section, review and edit.</p>
<p>The use of a connection ID allows connections to survive changes to
endpoint addresses (IP address and port), such as those caused by an
endpoint migrating to a new network.  This section describes the
process by which an endpoint migrates to a new address.</p>
<p>The design of QUIC relies on endpoints retaining a stable address for
the duration of the handshake.  An endpoint MUST NOT initiate
connection migration before the handshake is confirmed, as defined in
Section 4.1.2 of <a href="https://datatracker.ietf.org/doc/html/rfc9001">QUIC-TLS</a>
.</p>
<p>If the peer sent the disable_active_migration transport parameter, an
endpoint also MUST NOT send packets (including probing packets; see
Section 9.1) from a different local address to the address the peer
used during the handshake, unless the endpoint has acted on a
preferred_address transport parameter from the peer.  If the peer
violates this requirement, the endpoint MUST either drop the incoming
packets on that path without generating a Stateless Reset or proceed
with path validation and allow the peer to migrate.  Generating a
Stateless Reset or closing the connection would allow third parties
in the network to cause connections to close by spoofing or otherwise
manipulating observed traffic.</p>
<p>Not all changes of peer address are intentional, or active,
migrations.  The peer could experience NAT rebinding: a change of
address due to a middlebox, usually a NAT, allocating a new outgoing
port or even a new outgoing IP address for a flow.  An endpoint MUST
perform path validation (Section 8.2) if it detects any change to a
peer&rsquo;s address, unless it has previously validated that address.</p>
<p>When an endpoint has no validated path on which to send packets, it
MAY discard connection state.  An endpoint capable of connection
migration MAY wait for a new path to become available before
discarding connection state.</p>
<p>This document limits migration of connections to new client
addresses, except as described in Section 9.6.  Clients are
responsible for initiating all migrations.  Servers do not send non-
probing packets (see Section 9.1) toward a client address until they
see a non-probing packet from that address.  If a client receives
packets from an unknown server address, the client MUST discard these
packets.</p>
<h4 id="probing-a-new-path">Probing a New Path</h4>
<p>An endpoint MAY probe for peer reachability from a new local address
using path validation (Section 8.2) prior to migrating the connection
to the new local address.  Failure of path validation simply means
that the new path is not usable for this connection.  Failure to
validate a path does not cause the connection to end unless there are
no valid alternative paths available.</p>
<p>PATH_CHALLENGE, PATH_RESPONSE, NEW_CONNECTION_ID, and PADDING frames
are &ldquo;probing frames&rdquo;, and all other frames are &ldquo;non-probing frames&rdquo;.
A packet containing only probing frames is a &ldquo;probing packet&rdquo;, and a
packet containing any other frame is a &ldquo;non-probing packet&rdquo;.</p>
<h4 id="initiating-connection-migration">Initiating Connection Migration</h4>
<p>An endpoint can migrate a connection to a new local address by
sending packets containing non-probing frames from that address.</p>
<p>Each endpoint validates its peer&rsquo;s address during connection
establishment.  Therefore, a migrating endpoint can send to its peer
knowing that the peer is willing to receive at the peer&rsquo;s current
address.  Thus, an endpoint can migrate to a new local address
without first validating the peer&rsquo;s address.</p>
<p>To establish reachability on the new path, an endpoint initiates path
validation (Section 8.2) on the new path.  An endpoint MAY defer path
validation until after a peer sends the next non-probing frame to its
new address.</p>
<p>When migrating, the new path might not support the endpoint&rsquo;s current
sending rate.  Therefore, the endpoint resets its congestion
controller and RTT estimate, as described in Section 9.4.</p>
<p>The new path might not have the same ECN capability.  Therefore, the
endpoint validates ECN capability as described in Section 13.4.</p>
<h4 id="responding-to-connection-migration">Responding to Connection Migration</h4>
<p>Receiving a packet from a new peer address containing a non-probing
frame indicates that the peer has migrated to that address.</p>
<p>If the recipient permits the migration, it MUST send subsequent
packets to the new peer address and MUST initiate path validation
(Section 8.2) to verify the peer&rsquo;s ownership of the address if
validation is not already underway.  If the recipient has no unused
connection IDs from the peer, it will not be able to send anything on
the new path until the peer provides one; see Section 9.5.</p>
<p>An endpoint only changes the address to which it sends packets in
response to the highest-numbered non-probing packet.  This ensures
that an endpoint does not send packets to an old peer address in the
case that it receives reordered packets.</p>
<p>An endpoint MAY send data to an unvalidated peer address, but it MUST
protect against potential attacks as described in Sections 9.3.1 and
9.3.2.  An endpoint MAY skip validation of a peer address if that
address has been seen recently.  In particular, if an endpoint
returns to a previously validated path after detecting some form of
spurious migration, skipping address validation and restoring loss
detection and congestion state can reduce the performance impact of
the attack.</p>
<p>After changing the address to which it sends non-probing packets, an
endpoint can abandon any path validation for other addresses.</p>
<p>Receiving a packet from a new peer address could be the result of a
NAT rebinding at the peer.</p>
<p>After verifying a new client address, the server SHOULD send new
address validation tokens (Section 8) to the client.</p>
<h4 id="peer-address-spoofing">Peer Address Spoofing</h4>
<p>It is possible that a peer is spoofing its source address to cause an
endpoint to send excessive amounts of data to an unwilling host.  If
the endpoint sends significantly more data than the spoofing peer,
connection migration might be used to amplify the volume of data that
an attacker can generate toward a victim.</p>
<p>As described in Section 9.3, an endpoint is required to validate a
peer&rsquo;s new address to confirm the peer&rsquo;s possession of the new
address.  Until a peer&rsquo;s address is deemed valid, an endpoint limits
the amount of data it sends to that address; see Section 8.  In the
absence of this limit, an endpoint risks being used for a denial-of-
service attack against an unsuspecting victim.</p>
<p>If an endpoint skips validation of a peer address as described above,
it does not need to limit its sending rate.</p>
<h4 id="on-path-address-spoofing">On-Path Address Spoofing</h4>
<p>An on-path attacker could cause a spurious connection migration by
copying and forwarding a packet with a spoofed address such that it
arrives before the original packet.  The packet with the spoofed
address will be seen to come from a migrating connection, and the
original packet will be seen as a duplicate and dropped.  After a
spurious migration, validation of the source address will fail
because the entity at the source address does not have the necessary
cryptographic keys to read or respond to the PATH_CHALLENGE frame
that is sent to it even if it wanted to.</p>
<p>To protect the connection from failing due to such a spurious
migration, an endpoint MUST revert to using the last validated peer
address when validation of a new peer address fails.  Additionally,
receipt of packets with higher packet numbers from the legitimate
peer address will trigger another connection migration.  This will
cause the validation of the address of the spurious migration to be
abandoned, thus containing migrations initiated by the attacker
injecting a single packet.</p>
<p>If an endpoint has no state about the last validated peer address, it
MUST close the connection silently by discarding all connection
state.  This results in new packets on the connection being handled
generically.  For instance, an endpoint MAY send a Stateless Reset in
response to any further incoming packets.</p>
<h4 id="off-path-packet-forwarding">Off-Path Packet Forwarding</h4>
<p>An off-path attacker that can observe packets might forward copies of
genuine packets to endpoints.  If the copied packet arrives before
the genuine packet, this will appear as a NAT rebinding.  Any genuine
packet will be discarded as a duplicate.  If the attacker is able to
continue forwarding packets, it might be able to cause migration to a
path via the attacker.  This places the attacker on-path, giving it
the ability to observe or drop all subsequent packets.</p>
<p>This style of attack relies on the attacker using a path that has
approximately the same characteristics as the direct path between
endpoints.  The attack is more reliable if relatively few packets are
sent or if packet loss coincides with the attempted attack.</p>
<p>A non-probing packet received on the original path that increases the
maximum received packet number will cause the endpoint to move back
to that path.  Eliciting packets on this path increases the
likelihood that the attack is unsuccessful.  Therefore, mitigation of
this attack relies on triggering the exchange of packets.</p>
<p>In response to an apparent migration, endpoints MUST validate the
previously active path using a PATH_CHALLENGE frame.  This induces
the sending of new packets on that path.  If the path is no longer
viable, the validation attempt will time out and fail; if the path is
viable but no longer desired, the validation will succeed but only
results in probing packets being sent on the path.</p>
<p>An endpoint that receives a PATH_CHALLENGE on an active path SHOULD
send a non-probing packet in response.  If the non-probing packet
arrives before any copy made by an attacker, this results in the
connection being migrated back to the original path.  Any subsequent
migration to another path restarts this entire process.</p>
<p>This defense is imperfect, but this is not considered a serious
problem.  If the path via the attack is reliably faster than the
original path despite multiple attempts to use that original path, it
is not possible to distinguish between an attack and an improvement
in routing.</p>
<p>An endpoint could also use heuristics to improve detection of this
style of attack.  For instance, NAT rebinding is improbable if
packets were recently received on the old path; similarly, rebinding
is rare on IPv6 paths.  Endpoints can also look for duplicated
packets.  Conversely, a change in connection ID is more likely to
indicate an intentional migration rather than an attack.</p>
<h4 id="loss-detection-and-congestion-control">Loss Detection and Congestion Control</h4>
<p>The capacity available on the new path might not be the same as the
old path.  Packets sent on the old path MUST NOT contribute to
congestion control or RTT estimation for the new path.</p>
<p>On confirming a peer&rsquo;s ownership of its new address, an endpoint MUST
immediately reset the congestion controller and round-trip time
estimator for the new path to initial values (see Appendices A.3 and
B.3 of <a href="https://datatracker.ietf.org/doc/html/rfc9002">QUIC-RECOVERY</a>
) unless the only change in the peer&rsquo;s address
is its port number.  Because port-only changes are commonly the
result of NAT rebinding or other middlebox activity, the endpoint MAY
instead retain its congestion control state and round-trip estimate
in those cases instead of reverting to initial values.  In cases
where congestion control state retained from an old path is used on a
new path with substantially different characteristics, a sender could
transmit too aggressively until the congestion controller and the RTT
estimator have adapted.  Generally, implementations are advised to be
cautious when using previous values on a new path.</p>
<p>There could be apparent reordering at the receiver when an endpoint
sends data and probes from/to multiple addresses during the migration
period, since the two resulting paths could have different round-trip
times.  A receiver of packets on multiple paths will still send ACK
frames covering all received packets.</p>
<p>While multiple paths might be used during connection migration, a
single congestion control context and a single loss recovery context
(as described in <a href="https://datatracker.ietf.org/doc/html/rfc9002">QUIC-RECOVERY</a>
) could be adequate.  For instance,
an endpoint might delay switching to a new congestion control context
until it is confirmed that an old path is no longer needed (such as
the case described in Section 9.3.3).</p>
<p>A sender can make exceptions for probe packets so that their loss
detection is independent and does not unduly cause the congestion
controller to reduce its sending rate.  An endpoint might set a
separate timer when a PATH_CHALLENGE is sent, which is canceled if
the corresponding PATH_RESPONSE is received.  If the timer fires
before the PATH_RESPONSE is received, the endpoint might send a new
PATH_CHALLENGE and restart the timer for a longer period of time.
This timer SHOULD be set as described in Section 6.2.1 of
<a href="https://datatracker.ietf.org/doc/html/rfc9002">QUIC-RECOVERY</a>
 and MUST NOT be more aggressive.</p>
<h4 id="privacy-implications-of-connection-migration">Privacy Implications of Connection Migration</h4>
<p>Using a stable connection ID on multiple network paths would allow a
passive observer to correlate activity between those paths.  An
endpoint that moves between networks might not wish to have their
activity correlated by any entity other than their peer, so different
connection IDs are used when sending from different local addresses,
as discussed in Section 5.1.  For this to be effective, endpoints
need to ensure that connection IDs they provide cannot be linked by
any other entity.</p>
<p>At any time, endpoints MAY change the Destination Connection ID they
transmit with to a value that has not been used on another path.</p>
<p>An endpoint MUST NOT reuse a connection ID when sending from more
than one local address &ndash; for example, when initiating connection
migration as described in Section 9.2 or when probing a new network
path as described in Section 9.1.</p>
<p>Similarly, an endpoint MUST NOT reuse a connection ID when sending to
more than one destination address.  Due to network changes outside
the control of its peer, an endpoint might receive packets from a new
source address with the same Destination Connection ID field value,
in which case it MAY continue to use the current connection ID with
the new remote address while still sending from the same local
address.</p>
<p>These requirements regarding connection ID reuse apply only to the
sending of packets, as unintentional changes in path without a change
in connection ID are possible.  For example, after a period of
network inactivity, NAT rebinding might cause packets to be sent on a
new path when the client resumes sending.  An endpoint responds to
such an event as described in Section 9.3.</p>
<p>Using different connection IDs for packets sent in both directions on
each new network path eliminates the use of the connection ID for
linking packets from the same connection across different network
paths.  Header protection ensures that packet numbers cannot be used
to correlate activity.  This does not prevent other properties of
packets, such as timing and size, from being used to correlate
activity.</p>
<p>An endpoint SHOULD NOT initiate migration with a peer that has
requested a zero-length connection ID, because traffic over the new
path might be trivially linkable to traffic over the old one.  If the
server is able to associate packets with a zero-length connection ID
to the right connection, it means that the server is using other
information to demultiplex packets.  For example, a server might
provide a unique address to every client &ndash; for instance, using HTTP
alternative services <a href="https://datatracker.ietf.org/doc/html/rfc7838">ALTSVC</a>
.  Information that might allow correct
routing of packets across multiple network paths will also allow
activity on those paths to be linked by entities other than the peer.</p>
<p>A client might wish to reduce linkability by switching to a new
connection ID, source UDP port, or IP address (see <a href="https://datatracker.ietf.org/doc/html/rfc8981">RFC8981</a>
) when
sending traffic after a period of inactivity.  Changing the address
from which it sends packets at the same time might cause the server
to detect a connection migration.  This ensures that the mechanisms
that support migration are exercised even for clients that do not
experience NAT rebindings or genuine migrations.  Changing address
can cause a peer to reset its congestion control state (see
Section 9.4), so addresses SHOULD only be changed infrequently.</p>
<p>An endpoint that exhausts available connection IDs cannot probe new
paths or initiate migration, nor can it respond to probes or attempts
by its peer to migrate.  To ensure that migration is possible and
packets sent on different paths cannot be correlated, endpoints
SHOULD provide new connection IDs before peers migrate; see
Section 5.1.1.  If a peer might have exhausted available connection
IDs, a migrating endpoint could include a NEW_CONNECTION_ID frame in
all packets sent on a new network path.</p>
<h4 id="servers-preferred-address">Server&rsquo;s Preferred Address</h4>
<p>QUIC allows servers to accept connections on one IP address and
attempt to transfer these connections to a more preferred address
shortly after the handshake.  This is particularly useful when
clients initially connect to an address shared by multiple servers
but would prefer to use a unicast address to ensure connection
stability.  This section describes the protocol for migrating a
connection to a preferred server address.</p>
<p>Migrating a connection to a new server address mid-connection is not
supported by the version of QUIC specified in this document.  If a
client receives packets from a new server address when the client has
not initiated a migration to that address, the client SHOULD discard
these packets.</p>
<h4 id="communicating-a-preferred-address">Communicating a Preferred Address</h4>
<p>A server conveys a preferred address by including the
preferred_address transport parameter in the TLS handshake.</p>
<p>Servers MAY communicate a preferred address of each address family
(IPv4 and IPv6) to allow clients to pick the one most suited to their
network attachment.</p>
<p>Once the handshake is confirmed, the client SHOULD select one of the
two addresses provided by the server and initiate path validation
(see Section 8.2).  A client constructs packets using any previously
unused active connection ID, taken from either the preferred_address
transport parameter or a NEW_CONNECTION_ID frame.</p>
<p>As soon as path validation succeeds, the client SHOULD begin sending
all future packets to the new server address using the new connection
ID and discontinue use of the old server address.  If path validation
fails, the client MUST continue sending all future packets to the
server&rsquo;s original IP address.</p>
<h4 id="migration-to-a-preferred-address">Migration to a Preferred Address</h4>
<p>A client that migrates to a preferred address MUST validate the
address it chooses before migrating; see Section 21.5.3.</p>
<p>A server might receive a packet addressed to its preferred IP address
at any time after it accepts a connection.  If this packet contains a
PATH_CHALLENGE frame, the server sends a packet containing a
PATH_RESPONSE frame as per Section 8.2.  The server MUST send non-
probing packets from its original address until it receives a non-
probing packet from the client at its preferred address and until the
server has validated the new path.</p>
<p>The server MUST probe on the path toward the client from its
preferred address.  This helps to guard against spurious migration
initiated by an attacker.</p>
<p>Once the server has completed its path validation and has received a
non-probing packet with a new largest packet number on its preferred
address, the server begins sending non-probing packets to the client
exclusively from its preferred IP address.  The server SHOULD drop
newer packets for this connection that are received on the old IP
address.  The server MAY continue to process delayed packets that are
received on the old IP address.</p>
<p>The addresses that a server provides in the preferred_address
transport parameter are only valid for the connection in which they
are provided.  A client MUST NOT use these for other connections,
including connections that are resumed from the current connection.</p>
<h4 id="interaction-of-client-migration-and-preferred-address">Interaction of Client Migration and Preferred Address</h4>
<p>A client might need to perform a connection migration before it has
migrated to the server&rsquo;s preferred address.  In this case, the client
SHOULD perform path validation to both the original and preferred
server address from the client&rsquo;s new address concurrently.</p>
<p>If path validation of the server&rsquo;s preferred address succeeds, the
client MUST abandon validation of the original address and migrate to
using the server&rsquo;s preferred address.  If path validation of the
server&rsquo;s preferred address fails but validation of the server&rsquo;s
original address succeeds, the client MAY migrate to its new address
and continue sending to the server&rsquo;s original address.</p>
<p>If packets received at the server&rsquo;s preferred address have a
different source address than observed from the client during the
handshake, the server MUST protect against potential attacks as
described in Sections 9.3.1 and 9.3.2.  In addition to intentional
simultaneous migration, this might also occur because the client&rsquo;s
access network used a different NAT binding for the server&rsquo;s
preferred address.</p>
<p>Servers SHOULD initiate path validation to the client&rsquo;s new address
upon receiving a probe packet from a different address; see
Section 8.</p>
<p>A client that migrates to a new address SHOULD use a preferred
address from the same address family for the server.</p>
<p>The connection ID provided in the preferred_address transport
parameter is not specific to the addresses that are provided.  This
connection ID is provided to ensure that the client has a connection
ID available for migration, but the client MAY use this connection ID
on any path.</p>
<h4 id="use-of-ipv6-flow-label-and-migration">Use of IPv6 Flow Label and Migration</h4>
<p>QUIC recommends endpoints that send data using IPv6 SHOULD apply an IPv6 flow label
in compliance with <a href="https://tools.ietf.org/html/rfc6437">RFC 6437</a>
, unless the local API does not allow
setting IPv6 flow labels.</p>
<p>Unfortunately, the Java API does not allow setting IPv6 flow labels.</p>
<h3 id="security-considerations">Security Considerations</h3>
<p>Following is copied from QUIC <a href="https://datatracker.ietf.org/doc/html/rfc9000">RFC 9000</a>
.
For each section, review and edit.</p>
<p>The goal of QUIC is to provide a secure transport connection.
Section 21.1 provides an overview of those properties; subsequent
sections discuss constraints and caveats regarding these properties,
including descriptions of known attacks and countermeasures.</p>
<h4 id="overview-of-security-properties">Overview of Security Properties</h4>
<p>A complete security analysis of QUIC is outside the scope of this
document.  This section provides an informal description of the
desired security properties as an aid to implementers and to help
guide protocol analysis.</p>
<p>QUIC assumes the threat model described in <a href="https://datatracker.ietf.org/doc/html/rfc9000#section-21">SEC-CONS</a>
 and provides
protections against many of the attacks that arise from that model.</p>
<p>For this purpose, attacks are divided into passive and active
attacks.  Passive attackers have the ability to read packets from the
network, while active attackers also have the ability to write
packets into the network.  However, a passive attack could involve an
attacker with the ability to cause a routing change or other
modification in the path taken by packets that comprise a connection.</p>
<p>Attackers are additionally categorized as either on-path attackers or
off-path attackers.  An on-path attacker can read, modify, or remove
any packet it observes such that the packet no longer reaches its
destination, while an off-path attacker observes the packets but
cannot prevent the original packet from reaching its intended
destination.  Both types of attackers can also transmit arbitrary
packets.  This definition differs from that of Section 3.5 of
<a href="https://datatracker.ietf.org/doc/html/rfc9000#section-21">SEC-CONS</a>
 in that an off-path attacker is able to observe packets.</p>
<p>Properties of the handshake, protected packets, and connection
migration are considered separately.</p>
<h4 id="handshake">Handshake</h4>
<p>The QUIC handshake incorporates the TLS 1.3 handshake and inherits
the cryptographic properties described in Appendix E.1 of <a href="https://datatracker.ietf.org/doc/html/rfc8446">TLS13</a>
.
Many of the security properties of QUIC depend on the TLS handshake
providing these properties.  Any attack on the TLS handshake could
affect QUIC.</p>
<p>Any attack on the TLS handshake that compromises the secrecy or
uniqueness of session keys, or the authentication of the
participating peers, affects other security guarantees provided by
QUIC that depend on those keys.  For instance, migration (Section 9)
depends on the efficacy of confidentiality protections, both for the
negotiation of keys using the TLS handshake and for QUIC packet
protection, to avoid linkability across network paths.</p>
<p>An attack on the integrity of the TLS handshake might allow an
attacker to affect the selection of application protocol or QUIC
version.</p>
<p>In addition to the properties provided by TLS, the QUIC handshake
provides some defense against DoS attacks on the handshake.</p>
<h4 id="anti-amplification">Anti-Amplification</h4>
<p>Address validation (Section 8) is used to verify that an entity that
claims a given address is able to receive packets at that address.
Address validation limits amplification attack targets to addresses
for which an attacker can observe packets.</p>
<p>Prior to address validation, endpoints are limited in what they are
able to send.  Endpoints cannot send data toward an unvalidated
address in excess of three times the data received from that address.</p>
<p>Note: The anti-amplification limit only applies when an
endpoint responds to packets received from an unvalidated
address.  The anti-amplification limit does not apply to
clients when establishing a new connection or when initiating
connection migration.</p>
<h4 id="server-side-dos">Server-Side DoS</h4>
<p>Computing the server&rsquo;s first flight for a full handshake is
potentially expensive, requiring both a signature and a key exchange
computation.  In order to prevent computational DoS attacks, the
Retry packet provides a cheap token exchange mechanism that allows
servers to validate a client&rsquo;s IP address prior to doing any
expensive computations at the cost of a single round trip.  After a
successful handshake, servers can issue new tokens to a client, which
will allow new connection establishment without incurring this cost.</p>
<h4 id="on-path-handshake-termination">On-Path Handshake Termination</h4>
<p>An on-path or off-path attacker can force a handshake to fail by
replacing or racing Initial packets.  Once valid Initial packets have
been exchanged, subsequent Handshake packets are protected with the
Handshake keys, and an on-path attacker cannot force handshake
failure other than by dropping packets to cause endpoints to abandon
the attempt.</p>
<p>An on-path attacker can also replace the addresses of packets on
either side and therefore cause the client or server to have an
incorrect view of the remote addresses.  Such an attack is
indistinguishable from the functions performed by a NAT.</p>
<h4 id="parameter-negotiation">Parameter Negotiation</h4>
<p>The entire handshake is cryptographically protected, with the Initial
packets being encrypted with per-version keys and the Handshake and
later packets being encrypted with keys derived from the TLS key
exchange.  Further, parameter negotiation is folded into the TLS
transcript and thus provides the same integrity guarantees as
ordinary TLS negotiation.  An attacker can observe the client&rsquo;s
transport parameters (as long as it knows the version-specific salt)
but cannot observe the server&rsquo;s transport parameters and cannot
influence parameter negotiation.</p>
<p>Connection IDs are unencrypted but integrity protected in all
packets.</p>
<p>This version of QUIC does not incorporate a version negotiation
mechanism; implementations of incompatible versions will simply fail
to establish a connection.</p>
<h4 id="protected-packets">Protected Packets</h4>
<p>Packet protection (Section 12.1) applies authenticated encryption to
all packets except Version Negotiation packets, though Initial and
Retry packets have limited protection due to the use of version-
specific keying material; see <a href="https://datatracker.ietf.org/doc/html/rfc9001">QUIC-TLS</a>
 for more details.  This
section considers passive and active attacks against protected
packets.</p>
<p>Both on-path and off-path attackers can mount a passive attack in
which they save observed packets for an offline attack against packet
protection at a future time; this is true for any observer of any
packet on any network.</p>
<p>An attacker that injects packets without being able to observe valid
packets for a connection is unlikely to be successful, since packet
protection ensures that valid packets are only generated by endpoints
that possess the key material established during the handshake; see
Sections 7 and 21.1.1.  Similarly, any active attacker that observes
packets and attempts to insert new data or modify existing data in
those packets should not be able to generate packets deemed valid by
the receiving endpoint, other than Initial packets.</p>
<p>A spoofing attack, in which an active attacker rewrites unprotected
parts of a packet that it forwards or injects, such as the source or
destination address, is only effective if the attacker can forward
packets to the original endpoint.  Packet protection ensures that the
packet payloads can only be processed by the endpoints that completed
the handshake, and invalid packets are ignored by those endpoints.</p>
<p>An attacker can also modify the boundaries between packets and UDP
datagrams, causing multiple packets to be coalesced into a single
datagram or splitting coalesced packets into multiple datagrams.
Aside from datagrams containing Initial packets, which require
padding, modification of how packets are arranged in datagrams has no
functional effect on a connection, although it might change some
performance characteristics.</p>
<h4 id="connection-migration-1">Connection Migration</h4>
<p>Connection migration (Section 9) provides endpoints with the ability
to transition between IP addresses and ports on multiple paths, using
one path at a time for transmission and receipt of non-probing
frames.  Path validation (Section 8.2) establishes that a peer is
both willing and able to receive packets sent on a particular path.
This helps reduce the effects of address spoofing by limiting the
number of packets sent to a spoofed address.</p>
<p>This section describes the intended security properties of connection
migration under various types of DoS attacks.</p>
<h4 id="on-path-active-attacks">On-Path Active Attacks</h4>
<p>An attacker that can cause a packet it observes to no longer reach
its intended destination is considered an on-path attacker.  When an
attacker is present between a client and server, endpoints are
required to send packets through the attacker to establish
connectivity on a given path.</p>
<p>An on-path attacker can:</p>
<ul>
<li>
<p>Inspect packets</p>
</li>
<li>
<p>Modify IP and UDP packet headers</p>
</li>
<li>
<p>Inject new packets</p>
</li>
<li>
<p>Delay packets</p>
</li>
<li>
<p>Reorder packets</p>
</li>
<li>
<p>Drop packets</p>
</li>
<li>
<p>Split and merge datagrams along packet boundaries</p>
</li>
</ul>
<p>An on-path attacker cannot:</p>
<ul>
<li>Modify an authenticated portion of a packet and cause the
recipient to accept that packet</li>
</ul>
<p>An on-path attacker has the opportunity to modify the packets that it
observes; however, any modifications to an authenticated portion of a
packet will cause it to be dropped by the receiving endpoint as
invalid, as packet payloads are both authenticated and encrypted.</p>
<p>QUIC aims to constrain the capabilities of an on-path attacker as
follows:</p>
<ol>
<li>
<p>An on-path attacker can prevent the use of a path for a
connection, causing the connection to fail if it cannot use a
different path that does not contain the attacker.  This can be
achieved by dropping all packets, modifying them so that they
fail to decrypt, or other methods.</p>
</li>
<li>
<p>An on-path attacker can prevent migration to a new path for which
the attacker is also on-path by causing path validation to fail
on the new path.</p>
</li>
<li>
<p>An on-path attacker cannot prevent a client from migrating to a
path for which the attacker is not on-path.</p>
</li>
<li>
<p>An on-path attacker can reduce the throughput of a connection by
delaying packets or dropping them.</p>
</li>
<li>
<p>An on-path attacker cannot cause an endpoint to accept a packet
for which it has modified an authenticated portion of that
packet.</p>
</li>
</ol>
<h4 id="off-path-active-attacks">Off-Path Active Attacks</h4>
<p>An off-path attacker is not directly on the path between a client and
server but could be able to obtain copies of some or all packets sent
between the client and the server.  It is also able to send copies of
those packets to either endpoint.</p>
<p>An off-path attacker can:</p>
<ul>
<li>
<p>Inspect packets</p>
</li>
<li>
<p>Inject new packets</p>
</li>
<li>
<p>Reorder injected packets</p>
</li>
</ul>
<p>An off-path attacker cannot:</p>
<ul>
<li>
<p>Modify packets sent by endpoints</p>
</li>
<li>
<p>Delay packets</p>
</li>
<li>
<p>Drop packets</p>
</li>
<li>
<p>Reorder original packets</p>
</li>
</ul>
<p>An off-path attacker can create modified copies of packets that it
has observed and inject those copies into the network, potentially
with spoofed source and destination addresses.</p>
<p>For the purposes of this discussion, it is assumed that an off-path
attacker has the ability to inject a modified copy of a packet into
the network that will reach the destination endpoint prior to the
arrival of the original packet observed by the attacker.  In other
words, an attacker has the ability to consistently &ldquo;win&rdquo; a race with
the legitimate packets between the endpoints, potentially causing the
original packet to be ignored by the recipient.</p>
<p>It is also assumed that an attacker has the resources necessary to
affect NAT state.  In particular, an attacker can cause an endpoint
to lose its NAT binding and then obtain the same port for use with
its own traffic.</p>
<p>QUIC aims to constrain the capabilities of an off-path attacker as
follows:</p>
<ol>
<li>
<p>An off-path attacker can race packets and attempt to become a
&ldquo;limited&rdquo; on-path attacker.</p>
</li>
<li>
<p>An off-path attacker can cause path validation to succeed for
forwarded packets with the source address listed as the off-path
attacker as long as it can provide improved connectivity between
the client and the server.</p>
</li>
<li>
<p>An off-path attacker cannot cause a connection to close once the
handshake has completed.</p>
</li>
<li>
<p>An off-path attacker cannot cause migration to a new path to fail
if it cannot observe the new path.</p>
</li>
<li>
<p>An off-path attacker can become a limited on-path attacker during
migration to a new path for which it is also an off-path
attacker.</p>
</li>
<li>
<p>An off-path attacker can become a limited on-path attacker by
affecting shared NAT state such that it sends packets to the
server from the same IP address and port that the client
originally used.</p>
</li>
</ol>
<h4 id="limited-on-path-active-attacks">Limited On-Path Active Attacks</h4>
<p>A limited on-path attacker is an off-path attacker that has offered
improved routing of packets by duplicating and forwarding original
packets between the server and the client, causing those packets to
arrive before the original copies such that the original packets are
dropped by the destination endpoint.</p>
<p>A limited on-path attacker differs from an on-path attacker in that
it is not on the original path between endpoints, and therefore the
original packets sent by an endpoint are still reaching their
destination.  This means that a future failure to route copied
packets to the destination faster than their original path will not
prevent the original packets from reaching the destination.</p>
<p>A limited on-path attacker can:</p>
<ul>
<li>
<p>Inspect packets</p>
</li>
<li>
<p>Inject new packets</p>
</li>
<li>
<p>Modify unencrypted packet headers</p>
</li>
<li>
<p>Reorder packets</p>
</li>
</ul>
<p>A limited on-path attacker cannot:</p>
<ul>
<li>
<p>Delay packets so that they arrive later than packets sent on the
original path</p>
</li>
<li>
<p>Drop packets</p>
</li>
<li>
<p>Modify the authenticated and encrypted portion of a packet and
cause the recipient to accept that packet</p>
</li>
</ul>
<p>A limited on-path attacker can only delay packets up to the point
that the original packets arrive before the duplicate packets,
meaning that it cannot offer routing with worse latency than the
original path.  If a limited on-path attacker drops packets, the
original copy will still arrive at the destination endpoint.</p>
<p>QUIC aims to constrain the capabilities of a limited off-path
attacker as follows:</p>
<ol>
<li>
<p>A limited on-path attacker cannot cause a connection to close
once the handshake has completed.</p>
</li>
<li>
<p>A limited on-path attacker cannot cause an idle connection to
close if the client is first to resume activity.</p>
</li>
<li>
<p>A limited on-path attacker can cause an idle connection to be
deemed lost if the server is the first to resume activity.</p>
</li>
</ol>
<p>Note that these guarantees are the same guarantees provided for any
NAT, for the same reasons.</p>
<h4 id="handshake-denial-of-service">Handshake Denial of Service</h4>
<p>As an encrypted and authenticated transport, QUIC provides a range of
protections against denial of service.  Once the cryptographic
handshake is complete, QUIC endpoints discard most packets that are
not authenticated, greatly limiting the ability of an attacker to
interfere with existing connections.</p>
<p>Once a connection is established, QUIC endpoints might accept some
unauthenticated ICMP packets (see Section 14.2.1), but the use of
these packets is extremely limited.  The only other type of packet
that an endpoint might accept is a stateless reset (Section 10.3),
which relies on the token being kept secret until it is used.</p>
<p>During the creation of a connection, QUIC only provides protection
against attacks from off the network path.  All QUIC packets contain
proof that the recipient saw a preceding packet from its peer.</p>
<p>Addresses cannot change during the handshake, so endpoints can
discard packets that are received on a different network path.</p>
<p>The Source and Destination Connection ID fields are the primary means
of protection against an off-path attack during the handshake; see
Section 8.1.  These are required to match those set by a peer.
Except for Initial and Stateless Resets, an endpoint only accepts
packets that include a Destination Connection ID field that matches a
value the endpoint previously chose.  This is the only protection
offered for Version Negotiation packets.</p>
<p>The Destination Connection ID field in an Initial packet is selected
by a client to be unpredictable, which serves an additional purpose.
The packets that carry the cryptographic handshake are protected with
a key that is derived from this connection ID and a salt specific to
the QUIC version.  This allows endpoints to use the same process for
authenticating packets that they receive as they use after the
cryptographic handshake completes.  Packets that cannot be
authenticated are discarded.  Protecting packets in this fashion
provides a strong assurance that the sender of the packet saw the
Initial packet and understood it.</p>
<p>These protections are not intended to be effective against an
attacker that is able to receive QUIC packets prior to the connection
being established.  Such an attacker can potentially send packets
that will be accepted by QUIC endpoints.  This version of QUIC
attempts to detect this sort of attack, but it expects that endpoints
will fail to establish a connection rather than recovering.  For the
most part, the cryptographic handshake protocol <a href="https://datatracker.ietf.org/doc/html/rfc9001">QUIC-TLS</a>
 is
responsible for detecting tampering during the handshake.</p>
<p>Endpoints are permitted to use other methods to detect and attempt to
recover from interference with the handshake.  Invalid packets can be
identified and discarded using other methods, but no specific method
is mandated in this document.</p>
<h4 id="amplification-attack">Amplification Attack</h4>
<p>An attacker might be able to receive an address validation token
(Section 8) from a server and then release the IP address it used to
acquire that token.  At a later time, the attacker can initiate a
0-RTT connection with a server by spoofing this same address, which
might now address a different (victim) endpoint.  The attacker can
thus potentially cause the server to send an initial congestion
window&rsquo;s worth of data towards the victim.</p>
<p>Servers SHOULD provide mitigations for this attack by limiting the
usage and lifetime of address validation tokens; see Section 8.1.3.</p>
<h4 id="optimistic-ack-attack">Optimistic ACK Attack</h4>
<p>An endpoint that acknowledges packets it has not received might cause
a congestion controller to permit sending at rates beyond what the
network supports.  An endpoint MAY skip packet numbers when sending
packets to detect this behavior.  An endpoint can then immediately
close the connection with a connection error of type
PROTOCOL_VIOLATION; see Section 10.2.</p>
<h4 id="request-forgery-attacks">Request Forgery Attacks</h4>
<p>A request forgery attack occurs where an endpoint causes its peer to
issue a request towards a victim, with the request controlled by the
endpoint.  Request forgery attacks aim to provide an attacker with
access to capabilities of its peer that might otherwise be
unavailable to the attacker.  For a networking protocol, a request
forgery attack is often used to exploit any implicit authorization
conferred on the peer by the victim due to the peer&rsquo;s location in the
network.</p>
<p>For request forgery to be effective, an attacker needs to be able to
influence what packets the peer sends and where these packets are
sent.  If an attacker can target a vulnerable service with a
controlled payload, that service might perform actions that are
attributed to the attacker&rsquo;s peer but are decided by the attacker.</p>
<p>For example, cross-site request forgery <a href="https://owasp.org/www-community/attacks/csrf">CSRF</a>
 exploits on the Web
cause a client to issue requests that include authorization cookies
<a href="https://datatracker.ietf.org/doc/html/rfc6265">COOKIE</a>
, allowing one site access to information and actions that
are intended to be restricted to a different site.</p>
<p>As QUIC runs over UDP, the primary attack modality of concern is one
where an attacker can select the address to which its peer sends UDP
datagrams and can control some of the unprotected content of those
packets.  As much of the data sent by QUIC endpoints is protected,
this includes control over ciphertext.  An attack is successful if an
attacker can cause a peer to send a UDP datagram to a host that will
perform some action based on content in the datagram.</p>
<p>This section discusses ways in which QUIC might be used for request
forgery attacks.</p>
<p>This section also describes limited countermeasures that can be
implemented by QUIC endpoints.  These mitigations can be employed
unilaterally by a QUIC implementation or deployment, without
potential targets for request forgery attacks taking action.
However, these countermeasures could be insufficient if UDP-based
services do not properly authorize requests.</p>
<p>Because the migration attack described in Section 21.5.4 is quite
powerful and does not have adequate countermeasures, QUIC server
implementations should assume that attackers can cause them to
generate arbitrary UDP payloads to arbitrary destinations.  QUIC
servers SHOULD NOT be deployed in networks that do not deploy ingress
filtering <a href="https://datatracker.ietf.org/doc/html/rfc2827">BCP38</a>
 and also have inadequately secured UDP endpoints.</p>
<p>Although it is not generally possible to ensure that clients are not
co-located with vulnerable endpoints, this version of QUIC does not
allow servers to migrate, thus preventing spoofed migration attacks
on clients.  Any future extension that allows server migration MUST
also define countermeasures for forgery attacks.</p>
<h4 id="control-options-for-endpoints">Control Options for Endpoints</h4>
<p>QUIC offers some opportunities for an attacker to influence or
control where its peer sends UDP datagrams:</p>
<ul>
<li>
<p>initial connection establishment (Section 7), where a server is
able to choose where a client sends datagrams &ndash; for example, by
populating DNS records;</p>
</li>
<li>
<p>preferred addresses (Section 9.6), where a server is able to
choose where a client sends datagrams;</p>
</li>
<li>
<p>spoofed connection migrations (Section 9.3.1), where a client is
able to use source address spoofing to select where a server sends
subsequent datagrams; and</p>
</li>
<li>
<p>spoofed packets that cause a server to send a Version Negotiation
packet (Section 21.5.5).</p>
</li>
</ul>
<p>In all cases, the attacker can cause its peer to send datagrams to a
victim that might not understand QUIC.  That is, these packets are
sent by the peer prior to address validation; see Section 8.</p>
<p>Outside of the encrypted portion of packets, QUIC offers an endpoint
several options for controlling the content of UDP datagrams that its
peer sends.  The Destination Connection ID field offers direct
control over bytes that appear early in packets sent by the peer; see
Section 5.1.  The Token field in Initial packets offers a server
control over other bytes of Initial packets; see Section 17.2.2.</p>
<p>There are no measures in this version of QUIC to prevent indirect
control over the encrypted portions of packets.  It is necessary to
assume that endpoints are able to control the contents of frames that
a peer sends, especially those frames that convey application data,
such as STREAM frames.  Though this depends to some degree on details
of the application protocol, some control is possible in many
protocol usage contexts.  As the attacker has access to packet
protection keys, they are likely to be capable of predicting how a
peer will encrypt future packets.  Successful control over datagram
content then only requires that the attacker be able to predict the
packet number and placement of frames in packets with some amount of
reliability.</p>
<p>This section assumes that limiting control over datagram content is
not feasible.  The focus of the mitigations in subsequent sections is
on limiting the ways in which datagrams that are sent prior to
address validation can be used for request forgery.</p>
<h4 id="request-forgery-with-client-initial-packets">Request Forgery with Client Initial Packets</h4>
<p>An attacker acting as a server can choose the IP address and port on
which it advertises its availability, so Initial packets from clients
are assumed to be available for use in this sort of attack.  The
address validation implicit in the handshake ensures that &ndash; for a
new connection &ndash; a client will not send other types of packets to a
destination that does not understand QUIC or is not willing to accept
a QUIC connection.</p>
<p>Initial packet protection (Section 5.2 of <a href="https://datatracker.ietf.org/doc/html/rfc9001">QUIC-TLS</a>
) makes it
difficult for servers to control the content of Initial packets sent
by clients.  A client choosing an unpredictable Destination
Connection ID ensures that servers are unable to control any of the
encrypted portion of Initial packets from clients.</p>
<p>However, the Token field is open to server control and does allow a
server to use clients to mount request forgery attacks.  The use of
tokens provided with the NEW_TOKEN frame (Section 8.1.3) offers the
only option for request forgery during connection establishment.</p>
<p>Clients, however, are not obligated to use the NEW_TOKEN frame.
Request forgery attacks that rely on the Token field can be avoided
if clients send an empty Token field when the server address has
changed from when the NEW_TOKEN frame was received.</p>
<p>Clients could avoid using NEW_TOKEN if the server address changes.
However, not including a Token field could adversely affect
performance.  Servers could rely on NEW_TOKEN to enable the sending
of data in excess of the three-times limit on sending data; see
Section 8.1.  In particular, this affects cases where clients use
0-RTT to request data from servers.</p>
<p>Sending a Retry packet (Section 17.2.5) offers a server the option to
change the Token field.  After sending a Retry, the server can also
control the Destination Connection ID field of subsequent Initial
packets from the client.  This also might allow indirect control over
the encrypted content of Initial packets.  However, the exchange of a
Retry packet validates the server&rsquo;s address, thereby preventing the
use of subsequent Initial packets for request forgery.</p>
<h4 id="request-forgery-with-preferred-addresses">Request Forgery with Preferred Addresses</h4>
<p>Servers can specify a preferred address, which clients then migrate
to after confirming the handshake; see Section 9.6.  The Destination
Connection ID field of packets that the client sends to a preferred
address can be used for request forgery.</p>
<p>A client MUST NOT send non-probing frames to a preferred address
prior to validating that address; see Section 8.  This greatly
reduces the options that a server has to control the encrypted
portion of datagrams.</p>
<p>This document does not offer any additional countermeasures that are
specific to the use of preferred addresses and can be implemented by
endpoints.  The generic measures described in Section 21.5.6 could be
used as further mitigation.</p>
<h4 id="request-forgery-with-spoofed-migration">Request Forgery with Spoofed Migration</h4>
<p>Clients are able to present a spoofed source address as part of an
apparent connection migration to cause a server to send datagrams to
that address.</p>
<p>The Destination Connection ID field in any packets that a server
subsequently sends to this spoofed address can be used for request
forgery.  A client might also be able to influence the ciphertext.</p>
<p>A server that only sends probing packets (Section 9.1) to an address
prior to address validation provides an attacker with only limited
control over the encrypted portion of datagrams.  However,
particularly for NAT rebinding, this can adversely affect
performance.  If the server sends frames carrying application data,
an attacker might be able to control most of the content of
datagrams.</p>
<p>This document does not offer specific countermeasures that can be
implemented by endpoints, aside from the generic measures described
in Section 21.5.6.  However, countermeasures for address spoofing at
the network level &ndash; in particular, ingress filtering <a href="https://datatracker.ietf.org/doc/html/rfc2827">BCP38</a>
 &ndash; are
especially effective against attacks that use spoofing and originate
from an external network.</p>
<h4 id="request-forgery-with-version-negotiation">Request Forgery with Version Negotiation</h4>
<p>Clients that are able to present a spoofed source address on a packet
can cause a server to send a Version Negotiation packet
(Section 17.2.1) to that address.</p>
<p>The absence of size restrictions on the connection ID fields for
packets of an unknown version increases the amount of data that the
client controls from the resulting datagram.  The first byte of this
packet is not under client control and the next four bytes are zero,
but the client is able to control up to 512 bytes starting from the
fifth byte.</p>
<p>No specific countermeasures are provided for this attack, though
generic protections (Section 21.5.6) could apply.  In this case,
ingress filtering <a href="https://datatracker.ietf.org/doc/html/rfc2827">BCP38</a>
 is also effective.</p>
<h4 id="generic-request-forgery-countermeasures">Generic Request Forgery Countermeasures</h4>
<p>The most effective defense against request forgery attacks is to
modify vulnerable services to use strong authentication.  However,
this is not always something that is within the control of a QUIC
deployment.  This section outlines some other steps that QUIC
endpoints could take unilaterally.  These additional steps are all
discretionary because, depending on circumstances, they could
interfere with or prevent legitimate uses.</p>
<p>Services offered over loopback interfaces often lack proper
authentication.  Endpoints MAY prevent connection attempts or
migration to a loopback address.  Endpoints SHOULD NOT allow
connections or migration to a loopback address if the same service
was previously available at a different interface or if the address
was provided by a service at a non-loopback address.  Endpoints that
depend on these capabilities could offer an option to disable these
protections.</p>
<p>Similarly, endpoints could regard a change in address to a link-local
address <a href="https://datatracker.ietf.org/doc/html/rfc4291">RFC4291</a>
 or an address in a private-use range <a href="https://datatracker.ietf.org/doc/html/rfc1918">RFC1918</a>
 from
a global, unique-local <a href="https://datatracker.ietf.org/doc/html/rfc4193">RFC4193</a>
, or non-private address as a
potential attempt at request forgery.  Endpoints could refuse to use
these addresses entirely, but that carries a significant risk of
interfering with legitimate uses.  Endpoints SHOULD NOT refuse to use
an address unless they have specific knowledge about the network
indicating that sending datagrams to unvalidated addresses in a given
range is not safe.</p>
<p>Endpoints MAY choose to reduce the risk of request forgery by not
including values from NEW_TOKEN frames in Initial packets or by only
sending probing frames in packets prior to completing address
validation.  Note that this does not prevent an attacker from using
the Destination Connection ID field for an attack.</p>
<p>Endpoints are not expected to have specific information about the
location of servers that could be vulnerable targets of a request
forgery attack.  However, it might be possible over time to identify
specific UDP ports that are common targets of attacks or particular
patterns in datagrams that are used for attacks.  Endpoints MAY
choose to avoid sending datagrams to these ports or not send
datagrams that match these patterns prior to validating the
destination address.  Endpoints MAY retire connection IDs containing
patterns known to be problematic without using them.</p>
<p>Note: Modifying endpoints to apply these protections is more
efficient than deploying network-based protections, as
endpoints do not need to perform any additional processing when
sending to an address that has been validated.</p>
<h4 id="slowloris-attacks">Slowloris Attacks</h4>
<p>The attacks commonly known as Slowloris <a href="https://owasp.org/www-community/attacks/Slowloris_Attack">SLOWLORIS</a>
 try to keep many
connections to the target endpoint open and hold them open as long as
possible.  These attacks can be executed against a QUIC endpoint by
generating the minimum amount of activity necessary to avoid being
closed for inactivity.  This might involve sending small amounts of
data, gradually opening flow control windows in order to control the
sender rate, or manufacturing ACK frames that simulate a high loss
rate.</p>
<p>QUIC deployments SHOULD provide mitigations for the Slowloris
attacks, such as increasing the maximum number of clients the server
will allow, limiting the number of connections a single IP address is
allowed to make, imposing restrictions on the minimum transfer speed
a connection is allowed to have, and restricting the length of time
an endpoint is allowed to stay connected.</p>
<h4 id="stream-fragmentation-and-reassembly-attacks">Stream Fragmentation and Reassembly Attacks</h4>
<p>An adversarial sender might intentionally not send portions of the
stream data, causing the receiver to commit resources for the unsent
data.  This could cause a disproportionate receive buffer memory
commitment and/or the creation of a large and inefficient data
structure at the receiver.</p>
<p>An adversarial receiver might intentionally not acknowledge packets
containing stream data in an attempt to force the sender to store the
unacknowledged stream data for retransmission.</p>
<p>The attack on receivers is mitigated if flow control windows
correspond to available memory.  However, some receivers will
overcommit memory and advertise flow control offsets in the aggregate
that exceed actual available memory.  The overcommitment strategy can
lead to better performance when endpoints are well behaved, but
renders endpoints vulnerable to the stream fragmentation attack.</p>
<p>QUIC deployments SHOULD provide mitigations for stream fragmentation
attacks.  Mitigations could consist of avoiding overcommitting
memory, limiting the size of tracking data structures, delaying
reassembly of STREAM frames, implementing heuristics based on the age
and duration of reassembly holes, or some combination of these.</p>
<h4 id="stream-commitment-attack">Stream Commitment Attack</h4>
<p>An adversarial endpoint can open a large number of streams,
exhausting state on an endpoint.  The adversarial endpoint could
repeat the process on a large number of connections, in a manner
similar to SYN flooding attacks in TCP.</p>
<p>Normally, clients will open streams sequentially, as explained in
Section 2.1.  However, when several streams are initiated at short
intervals, loss or reordering can cause STREAM frames that open
streams to be received out of sequence.  On receiving a higher-
numbered stream ID, a receiver is required to open all intervening
streams of the same type; see Section 3.2.  Thus, on a new
connection, opening stream 4000000 opens 1 million and 1 client-
initiated bidirectional streams.</p>
<p>The number of active streams is limited by the
initial_max_streams_bidi and initial_max_streams_uni transport
parameters as updated by any received MAX_STREAMS frames, as
explained in Section 4.6.  If chosen judiciously, these limits
mitigate the effect of the stream commitment attack.  However,
setting the limit too low could affect performance when applications
expect to open a large number of streams.</p>
<h4 id="peer-denial-of-service">Peer Denial of Service</h4>
<p>QUIC and TLS both contain frames or messages that have legitimate
uses in some contexts, but these frames or messages can be abused to
cause a peer to expend processing resources without having any
observable impact on the state of the connection.</p>
<p>Messages can also be used to change and revert state in small or
inconsequential ways, such as by sending small increments to flow
control limits.</p>
<p>If processing costs are disproportionately large in comparison to
bandwidth consumption or effect on state, then this could allow a
malicious peer to exhaust processing capacity.</p>
<p>While there are legitimate uses for all messages, implementations
SHOULD track cost of processing relative to progress and treat
excessive quantities of any non-productive packets as indicative of
an attack.  Endpoints MAY respond to this condition with a connection
error or by dropping packets.</p>
<h4 id="explicit-congestion-notification-attacks">Explicit Congestion Notification Attacks</h4>
<p>An on-path attacker could manipulate the value of ECN fields in the
IP header to influence the sender&rsquo;s rate.  <a href="https://datatracker.ietf.org/doc/html/rfc3168">RFC3168</a>
 discusses
manipulations and their effects in more detail.</p>
<p>A limited on-path attacker can duplicate and send packets with
modified ECN fields to affect the sender&rsquo;s rate.  If duplicate
packets are discarded by a receiver, an attacker will need to race
the duplicate packet against the original to be successful in this
attack.  Therefore, QUIC endpoints ignore the ECN field in an IP
packet unless at least one QUIC packet in that IP packet is
successfully processed; see Section 13.4.</p>
<h4 id="stateless-reset-oracle">Stateless Reset Oracle</h4>
<p>Stateless resets create a possible denial-of-service attack analogous
to a TCP reset injection.  This attack is possible if an attacker is
able to cause a stateless reset token to be generated for a
connection with a selected connection ID.  An attacker that can cause
this token to be generated can reset an active connection with the
same connection ID.</p>
<p>If a packet can be routed to different instances that share a static
key &ndash; for example, by changing an IP address or port &ndash; then an
attacker can cause the server to send a stateless reset.  To defend
against this style of denial of service, endpoints that share a
static key for stateless resets (see Section 10.3.2) MUST be arranged
so that packets with a given connection ID always arrive at an
instance that has connection state, unless that connection is no
longer active.</p>
<p>More generally, servers MUST NOT generate a stateless reset if a
connection with the corresponding connection ID could be active on
any endpoint using the same static key.</p>
<p>In the case of a cluster that uses dynamic load balancing, it is
possible that a change in load-balancer configuration could occur
while an active instance retains connection state.  Even if an
instance retains connection state, the change in routing and
resulting stateless reset will result in the connection being
terminated.  If there is no chance of the packet being routed to the
correct instance, it is better to send a stateless reset than wait
for the connection to time out.  However, this is acceptable only if
the routing cannot be influenced by an attacker.</p>
<h4 id="version-downgrade">Version Downgrade</h4>
<p>This document defines QUIC Version Negotiation packets (Section 6),
which can be used to negotiate the QUIC version used between two
endpoints.  However, this document does not specify how this
negotiation will be performed between this version and subsequent
future versions.  In particular, Version Negotiation packets do not
contain any mechanism to prevent version downgrade attacks.  Future
versions of QUIC that use Version Negotiation packets MUST define a
mechanism that is robust against version downgrade attacks.</p>
<h4 id="targeted-attacks-by-routing">Targeted Attacks by Routing</h4>
<p>Deployments should limit the ability of an attacker to target a new
connection to a particular server instance.  Ideally, routing
decisions are made independently of client-selected values, including
addresses.  Once an instance is selected, a connection ID can be
selected so that later packets are routed to the same instance.</p>
<h4 id="traffic-analysis">Traffic Analysis</h4>
<p>The length of QUIC packets can reveal information about the length of
the content of those packets.  The PADDING frame is provided so that
endpoints have some ability to obscure the length of packet content;
see Section 19.1.</p>
<p>Defeating traffic analysis is challenging and the subject of active
research.  Length is not the only way that information might leak.
Endpoints might also reveal sensitive information through other side
channels, such as the timing of packets.</p>
<h3 id="relay-security">Relay Security</h3>
<p>Following is an analysis of Relay Request, Relay Response, Relay Intro, and Hole Punch in SSU1.</p>
<p>Constraints: It is important that Relays be fast.
Round trips should be minimized.
Bandwidth and CPU are not as important.</p>
<p>SSU 1:
Alice first connects to introducer Bob, who relays the request to Charlie (who is firewalled).
After the hole punch, the session is established between Alice and Charlie as in a direct establishment.</p>
<pre tabindex="0"><code>Alice                         Bob                  Charlie
1. RelayRequest ----------------------&gt;
2.      &lt;-------------- RelayResponse    RelayIntro -----------&gt;
3.      &lt;-------------------------------------------- HolePunch
4. SessionRequest --------------------------------------------&gt;
5.      &lt;-------------------------------------------- SessionCreated
6. SessionConfirmed ------------------------------------------&gt;
</code></pre><p>Authentication: Relay Request and Relay Response are not securely unauthenticated,
as Alice and Bob usually do not have an existing session;
these messages use published intro keys.
In-session Relay Request/Response is allowed and preferred if a session does exist.</p>
<p>Relay Intro from Bob to Charlie is required to be in an existing session,
so it is presumed secure.</p>
<p>Bob may spoof Relay Intros or change IP/port from the Relay Request.
There are no mechanisms to cryptographically bind requests to intros or
otherwise prevent or detect malicious Bobs.</p>
<p>Bob&rsquo;s router hash is not currently published in Charlie&rsquo;s Router Info, so
that must be added if we want the Alice-Bob messages to be authenticated.
Additionally, other SSU2 parameters would have to be published in Charlie&rsquo;s Router Info,
or Alice would have to lookup Bob&rsquo;s Router Info in the network database,
adding additional delay.
Authentication would add a round-trip between Alice and Bob.</p>
<p>By forwarding Alice&rsquo;s router hash to Charlie, Charlie could more easily
determine if he wishes to receive a connection from Alice,
by checking a local ban list.
There is no mechanism for Charlie to reject the relay by sending
a rejection through Bob to Alice.
There is no mechanism for Charlie to accept the relay by sending
an acceptance through Bob to Alice. Alice must wait for the HolePunch,
or simply send the SessionRequest blindly. The HolePunch may come from
a different port than Alice was expecting, due to NAT, which
may make it harder to recognize what router the HolePunch came from.</p>
<p>Alice could send her full Router Info in the Relay Request to Bob,
and forwarded to Charlie in the Relay Intro.</p>
<p>The Relay Request does not contain a timestamp, so it has no replay prevention.
The source IP can be spoofed, to cause Charlie to send a Hole Punch to any IP/port.
The Relay Request is not signed, and even if signed and timestamped,
Charlie does not have the full Router Identity to be able to verify the signature.</p>
<p>The protocol defines a challenge field of variable length 0-255 bytes.
The challenge in the Relay Request is passed to Charlie in the Relay Intro.
However, the protocol does not specify how to create, use, or verify the challenge,
and it is unimplemented.
If the HolePunch contained the challenge, Alice would be able to easily
correlate the HolePunch with Charlie.</p>
<p>Four byte nonce may need to be replaced or supplemented by
8-byte connection ID.</p>
<p>The empty Hole Punch message is unique and may be used
by on-path observers to identify the protocol, this should be
changed.</p>
<h3 id="peer-test-security">Peer Test Security</h3>
<p>Following is an analysis of Peer Test in SSU1.</p>
<p>Constraints: It is not particularly important that Peer Tests be fast,
or low-bandwidth, or low-CPU, except perhaps at router startup,
where we prefer that the router discovers its reachability fairly quickly.</p>
<p>SSU 1:</p>
<pre tabindex="0"><code>Alice                     Bob                  Charlie
1. PeerTest -------------------&gt;
2.                          PeerTest--------------------&gt;
3.                             &lt;-------------------PeerTest
4.      &lt;-------------------PeerTest

5.      &lt;------------------------------------------PeerTest
6. PeerTest------------------------------------------&gt;
7.      &lt;------------------------------------------PeerTest
</code></pre><p>Because the SSU1 specification is difficult to follow, we
document the message contents below.</p>
<table>
  <thead>
      <tr>
          <th>Message</th>
          <th>Path</th>
          <th>Alice IP incl?</th>
          <th>Intro Key</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>1</td>
          <td>A-&gt;B session</td>
          <td>no</td>
          <td>Alice</td>
      </tr>
      <tr>
          <td>2</td>
          <td>B-&gt;C session</td>
          <td>yes</td>
          <td>Alice</td>
      </tr>
      <tr>
          <td>3</td>
          <td>C-&gt;B session</td>
          <td>yes</td>
          <td>Charlie</td>
      </tr>
      <tr>
          <td>4</td>
          <td>B-&gt;A session</td>
          <td>yes</td>
          <td>Charlie</td>
      </tr>
      <tr>
          <td>5</td>
          <td>C-&gt;A</td>
          <td>yes</td>
          <td>Charlie</td>
      </tr>
      <tr>
          <td>6</td>
          <td>A-&gt;C</td>
          <td>no</td>
          <td>Alice</td>
      </tr>
      <tr>
          <td>7</td>
          <td>C-&gt;A</td>
          <td>yes</td>
          <td>Charlie</td>
      </tr>
  </tbody>
</table>
<p>Authentication:
Alice will always choose a Bob with an existing session.
Bob will reject PeerTests from peers without an established session.
Message 1 is sent in-session. Therefore, message 1 is secure and authenticated.</p>
<p>Bob selects a Charlie with whom he has an existing session.
Messages 2 and 3 are sent in-session. Therefore, messages 2 and 3 are secure and authenticated.</p>
<p>Message 4 should be sent in-session; however, the SSU 1 specification previously said that it is sent
with Alice&rsquo;s published intro key, which means not in-session.
Prior to 0.9.52, Java I2P did send with the intro key.
As of 0.9.52, the specification states that the session key should be used,
and Java I2P sends the message in-session as of 0.9.52.</p>
<p>Alice must not have an existing session with Charlie for the test to proceed;
Alice aborts the test if Bob picks a Charlie that has a session with Alice.
Therefore, messages 5-7 are not secure and authenticated.</p>
<p>All Peer Test messages contain a 4-byte nonce that is chosen by Alice.
This nonce is not used cryptographically.</p>
<p>Attacks possible on messages 5-7: to be researched.</p>
<p>Alice&rsquo;s router hash is not known to Charlie.
Charlie&rsquo;s router hash is not known to Alice.
Those must be added to the protocol if we want the Alice-Charlie messages to be authenticated.
Additionally, other SSU2 parameters would have to be provided in the Peer Test messages,
or Charlie would have to lookup Alice&rsquo;s Router Info in the network database,
adding additional delay.
Authentication would add a round-trip between Charlie and Alice.</p>
<p>By forwarding Alice&rsquo;s router hash to Charlie, Charlie could more easily
determine if he wishes to participate in a Peer Test with Alice,
by checking a local ban list.</p>
<p>Four byte nonce may need to be replaced or supplemented by
8-byte connection ID.</p>
<h3 id="relay-and-peer-test-design-goals">Relay and Peer Test Design Goals</h3>
<p>Relay and Peer Test have similar constructions.
In both cases, Alice requests Bob to forward a service request to Charlie,
and Charlie then acts on that request.</p>
<p>Current SSU1 Peer Test issues:</p>
<ul>
<li>Peer Test has no protections against a malicious Bob</li>
<li>Peer Test has no way for Bob or Charlie to reject a request</li>
<li>Peer Test has no way for Alice to know Charlie&rsquo;s identity
or for Alice to reject a Charlie</li>
<li>Peer Test has no way for Charlie to know Alice&rsquo;s identity
or for Charlie to reject an Alice</li>
<li>Peer Test has its own ad-hoc retransmission scheme</li>
<li>Peer Test requires a complex state machine to know
what message is for what state</li>
<li>Without knowing that Charlie has rejected her,
Alice will treat the test as a failure.</li>
</ul>
<p>Current SSU1 Relay issues:</p>
<p>Most of the Peer Test issues listed above also apply to Peer Test.</p>
<p>We have the following goals in improving the security of Relay and Peer Test:</p>
<ul>
<li>
<p>Charlie should publish enough information about his introducers (Bobs)
in the netdb for Alice to be able to validate the information if necessary.
For example, publishing a router hash for each introducer would
enable Alice, time permitting, to fetch the router info from the netdb.</p>
</li>
<li>
<p>Protect against address spoofing or on-path threats that may
spoof, alter, forge, or replay requests from Alice to Bob.
Bob must ensure that Alice is an actual I2P router and that the
request and test address presented are valid.</p>
</li>
<li>
<p>Protect against malicious Bobs that may spoof, alter, forge, or replay
requests forwarded to Charlie.
Charlie must ensure that both Alice and Bob are actual I2P routers and that the
request and test address presented are valid.</p>
</li>
<li>
<p>Bob must receive enough information from Alice to be able to validate
the request and then accept or decline it.
Bob must have a mechanism to send the acceptance or rejection back
to Alice.
Bob must never be required to perform the requested action.</p>
</li>
<li>
<p>Charlie must receive enough information from Bob to be able to validate
the request and then accept or decline it.
Charlie must have a mechanism to send the acceptance or rejection back
to Bob, to be forwarded to Alice.
Charlie must never be required to perform the requested action.</p>
</li>
<li>
<p>Alice must be able to validate that the response forwarded via Bob
actually originated from Charlie.</p>
</li>
<li>
<p>Alice and Charlie must be able to validate that their subsequent direct
messages (not relayed via Bob) are from the expected source
and are actual I2P routers.</p>
</li>
</ul>
<p>The following mechanisms may assist in achieving these goals:</p>
<ul>
<li>
<p>Timestamps</p>
</li>
<li>
<p>Signatures using the router signing key</p>
</li>
<li>
<p>Using challenge data included in the request</p>
</li>
<li>
<p>Encryption using the router encryption key</p>
</li>
<li>
<p>Sending router hashes, Router Identities, or Router Infos,
not just IPs and ports.</p>
</li>
<li>
<p>Validation of router information by querying the network database</p>
</li>
<li>
<p>Checking router information, IPs, and ports against banlists</p>
</li>
<li>
<p>Rate limiting</p>
</li>
<li>
<p>Requiring session establishment</p>
</li>
</ul>
<p>These possible mechanisms may increase the processing time and latency of
the Relay or Peer Test functions. All effects must be evaluated.</p>
<p>Cross-version relaying and peer testing should also be supported if possible.
This will facilitate a gradual transition from SSU 1 to SSU 2.
The possible version combinations are:</p>
<table>
  <thead>
      <tr>
          <th>Alice/Bob</th>
          <th>Bob/Charlie</th>
          <th>Alice/Charlie</th>
          <th>Supported</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>1</td>
          <td>1</td>
          <td>1</td>
          <td>SSU 1</td>
      </tr>
      <tr>
          <td>1</td>
          <td>1</td>
          <td>2</td>
          <td>no, use 1/1/1</td>
      </tr>
      <tr>
          <td>1</td>
          <td>2</td>
          <td>1</td>
          <td>Relay: yes? Peer Test: no</td>
      </tr>
      <tr>
          <td>1</td>
          <td>2</td>
          <td>2</td>
          <td>no, use 1/2/1</td>
      </tr>
      <tr>
          <td>2</td>
          <td>1</td>
          <td>1</td>
          <td>Relay: yes? Peer Test: no</td>
      </tr>
      <tr>
          <td>2</td>
          <td>1</td>
          <td>2</td>
          <td>Relay: yes? Peer Test: no</td>
      </tr>
      <tr>
          <td>2</td>
          <td>2</td>
          <td>1</td>
          <td>no, use 2/2/2</td>
      </tr>
      <tr>
          <td>2</td>
          <td>2</td>
          <td>2</td>
          <td>yes</td>
      </tr>
  </tbody>
</table>
<h2 id="design-overview">Design Overview</h2>
<h3 id="summary">Summary</h3>
<p>We rely on several existing protocols, both within I2P and outside standards,
for inspiration, guidance, and code reuse:</p>
<ul>
<li>
<p>Threat models: From NTCP2 <a href="../../../en/docs/specs/ntcp2/">NTCP2</a>
, with significant additional threats
relevant to UDP transport as analyzed by QUIC <a href="https://datatracker.ietf.org/doc/html/rfc9000">RFC 9000</a>
 <a href="https://datatracker.ietf.org/doc/html/rfc9001">RFC 9001</a>
.</p>
</li>
<li>
<p>Cryptographic choices: From <a href="../../../en/docs/specs/ntcp2/">NTCP2</a>
.</p>
</li>
<li>
<p>Handshake: Noise XK from <a href="../../../en/docs/specs/ntcp2/">NTCP2</a>
 and <a href="https://noiseprotocol.org/noise.html">NOISE</a>
. Significant simplifications
to NTCP2 are possible due to the encapsulation (inherent message boundaries)
provided by UDP.</p>
</li>
<li>
<p>Handshake ephemeral key obfuscation: Adapted from <a href="../../../en/docs/specs/ntcp2/">NTCP2</a>

but using ChaCha20 from <a href="../../../en/docs/specs/ecies/">ECIES</a>
 instead of AES.</p>
</li>
<li>
<p>Packet headers: Adapted from WireGuard <a href="https://www.wireguard.com/protocol/">WireGuard</a>
 and QUIC <a href="https://datatracker.ietf.org/doc/html/rfc9000">RFC 9000</a>
 <a href="https://datatracker.ietf.org/doc/html/rfc9001">RFC 9001</a>
.</p>
</li>
<li>
<p>Packet header obfuscation: Adapted from <a href="../../../en/docs/specs/ntcp2/">NTCP2</a>

but using ChaCha20 from <a href="../../../en/docs/specs/ecies/">ECIES</a>
 instead of AES.</p>
</li>
<li>
<p>Packet header protection: Adapted from QUIC <a href="https://datatracker.ietf.org/doc/html/rfc9001">RFC 9001</a>
 and <a href="https://eprint.iacr.org/2019/624.pdf">Nonces</a>
</p>
</li>
<li>
<p>Headers used as AEAD associated data as in <a href="../../../en/docs/specs/ecies/">ECIES</a>
.</p>
</li>
<li>
<p>Packet numbering: Adapted from WireGuard <a href="https://www.wireguard.com/protocol/">WireGuard</a>
 and QUIC <a href="https://datatracker.ietf.org/doc/html/rfc9000">RFC 9000</a>
 <a href="https://datatracker.ietf.org/doc/html/rfc9001">RFC 9001</a>
.</p>
</li>
<li>
<p>Messages: Adapted from <a href="../../../en/docs/specs/ssu2/">SSU</a>
</p>
</li>
<li>
<p>I2NP Fragmentation: Adapted from <a href="../../../en/docs/specs/ssu2/">SSU</a>
</p>
</li>
<li>
<p>Relay and Peer Testing: Adapted from <a href="../../../en/docs/specs/ssu2/">SSU</a>
</p>
</li>
<li>
<p>Signatures of Relay and Peer Test data: From the common structures spec <a href="../../../en/docs/specs/common-structures/">Common</a>
</p>
</li>
<li>
<p>Block format: From <a href="../../../en/docs/specs/ntcp2/">NTCP2</a>
 and <a href="../../../en/docs/specs/ecies/">ECIES</a>
.</p>
</li>
<li>
<p>Padding and options: From <a href="../../../en/docs/specs/ntcp2/">NTCP2</a>
 and <a href="../../../en/docs/specs/ecies/">ECIES</a>
.</p>
</li>
<li>
<p>Acks, nacks: Adapted from QUIC <a href="https://datatracker.ietf.org/doc/html/rfc9000">RFC 9000</a>
.</p>
</li>
<li>
<p>Flow control: TBD</p>
</li>
</ul>
<p>There are no new cryptographic primitives that have not been used in I2P before.</p>
<h3 id="delivery-guarantees">Delivery Guarantees</h3>
<p>As with other I2P transports NTCP, NTCP2, and SSU 1, this transport is not a general-purpose
facility for delivery of an in-order stream of bytes. It is designed for
transport of I2NP messages. There is no &ldquo;stream&rdquo; abstraction provided.</p>
<p>In addition, as for SSU, it contains additional facilities for peer-facilitated NAT traversal
and testing of reachability (inbound connections).</p>
<p>As for SSU 1, it does NOT provide in-order delivery of I2NP messages.
Nor does it provide guaranteed delivery of I2NP messages.
For efficiency, or because of out-of order delivery of UDP datagrams
or loss of those datagrams, I2NP messages may be delivered to the
far-end out-of-order, or may not be delivered at all.
An I2NP message may be retransmitted multiple times if necessary,
but delivery may eventually fail without causing the full connection to be
disconnected. Also, new I2NP messages may continue to be sent even
while retransmission (loss recovery) is occurring for other I2NP messages.</p>
<p>This protocol does NOT completely prevent duplicate delivery of I2NP messages.
The router should enforce I2NP expiration and use a Bloom filter or other
mechanism based on the I2NP message ID.
See the I2NP Message Duplication section below.</p>
<h3 id="noise-protocol-framework">Noise Protocol Framework</h3>
<p>This proposal provides the requirements based on the Noise Protocol Framework
<a href="https://noiseprotocol.org/noise.html">NOISE</a>
 (Revision 33, 2017-10-04).
Noise has similar properties to the Station-To-Station protocol
Station-To-Station (STS) protocol, which is the basis for the <a href="../../../en/docs/specs/ssu2/">SSU</a>
 protocol.  In Noise parlance, Alice
is the initiator, and Bob is the responder.</p>
<p>SSU2 is based on the Noise protocol Noise_XK_25519_ChaChaPoly_SHA256.
(The actual identifier for the initial key derivation function
is &ldquo;Noise_XKchaobfse+hs1+hs2+hs3_25519_ChaChaPoly_SHA256&rdquo;
to indicate I2P extensions - see KDF 1 section below)</p>
<p>NOTE: This identifier is different than that used for NTCP2, because
all three handshake messages use the header as associated data.</p>
<p>This Noise protocol uses the following primitives:</p>
<ul>
<li>
<p>Handshake Pattern: XK
Alice transmits her key to Bob (X)
Alice knows Bob&rsquo;s static key already (K)</p>
</li>
<li>
<p>DH Function: X25519
X25519 DH with a key length of 32 bytes as specified in <a href="https://tools.ietf.org/html/rfc7748">RFC 7748</a>
.</p>
</li>
<li>
<p>Cipher Function: ChaChaPoly
AEAD_CHACHA20_POLY1305 as specified in <a href="https://tools.ietf.org/html/rfc7539">RFC 7539</a>
 section 2.8.
12 byte nonce, with the first 4 bytes set to zero.</p>
</li>
<li>
<p>Hash Function: SHA256
Standard 32-byte hash, already used extensively in I2P.</p>
</li>
</ul>
<h3 id="additions-to-the-framework">Additions to the Framework</h3>
<p>This proposal defines the following enhancements to
Noise_XK_25519_ChaChaPoly_SHA256.  These generally follow the guidelines in
<a href="https://noiseprotocol.org/noise.html">NOISE</a>
 section 13.</p>
<ol>
<li>
<p>Handshake messages (Session Request, Created, Confirmed) include
a 16 or 32 byte header.</p>
</li>
<li>
<p>The headers for the handshake messages (Session Request, Created, Confirmed)
are used as input to mixHash() before encryption/decryption
to bind the headers to the message.</p>
</li>
<li>
<p>Headers are encrypted and protected.</p>
</li>
<li>
<p>Cleartext ephemeral keys are obfuscated with ChaCha20 encryption using a known
key and IV.  This is quicker than elligator2.</p>
</li>
<li>
<p>The payload format is defined for messages 1, 2, and the data phase.
Of course, this is not defined in Noise.</p>
</li>
</ol>
<p>The data phase uses encryption similar to, but not compatible with, the Noise data phase.</p>
<h3 id="processing-overhead-estimate">Processing overhead estimate</h3>
<p>TBD</p>
<h2 id="definitions">Definitions</h2>
<p>We define the following functions corresponding to the cryptographic building blocks used.</p>
<p>ZEROLEN
zero-length byte array</p>
<p>H(p, d)
SHA-256 hash function that takes a personalization string p and data d, and
produces an output of length 32 bytes.
As defined in <a href="https://noiseprotocol.org/noise.html">NOISE</a>
.
|| below means append.</p>
<pre><code>Use SHA-256 as follows::

    H(p, d) := SHA-256(p || d)
</code></pre>
<p>MixHash(d)
SHA-256 hash function that takes a previous hash h and new data d,
and produces an output of length 32 bytes.
|| below means append.</p>
<pre><code>Use SHA-256 as follows::

    MixHash(d) := h = SHA-256(h || d)
</code></pre>
<p>STREAM
The ChaCha20/Poly1305 AEAD as specified in <a href="https://tools.ietf.org/html/rfc7539">RFC 7539</a>
.
S_KEY_LEN = 32 and S_IV_LEN = 12.</p>
<pre><code>ENCRYPT(k, n, plaintext, ad)
    Encrypts plaintext using the cipher key k, and nonce n which MUST be unique for
    the key k.
    Associated data ad is optional.
    Returns a ciphertext that is the size of the plaintext + 16 bytes for the HMAC.

    The entire ciphertext must be indistinguishable from random if the key is secret.

DECRYPT(k, n, ciphertext, ad)
    Decrypts ciphertext using the cipher key k, and nonce n.
    Associated data ad is optional.
    Returns the plaintext.
</code></pre>
<p>DH
X25519 public key agreement system. Private keys of 32 bytes, public keys of 32
bytes, produces outputs of 32 bytes. It has the following
functions:</p>
<pre><code>GENERATE_PRIVATE()
    Generates a new private key.

DERIVE_PUBLIC(privkey)
    Returns the public key corresponding to the given private key.

DH(privkey, pubkey)
    Generates a shared secret from the given private and public keys.
</code></pre>
<p>HKDF(salt, ikm, info, n)
A cryptographic key derivation function which takes some input key material ikm (which
should have good entropy but is not required to be a uniformly random string), a salt
of length 32 bytes, and a context-specific &lsquo;info&rsquo; value, and produces an output
of n bytes suitable for use as key material.</p>
<pre><code>Use HKDF as specified in [RFC 5869](https://tools.ietf.org/html/rfc5869), using the HMAC hash function SHA-256
as specified in [RFC 2104](https://tools.ietf.org/html/rfc2104). This means that SALT_LEN is 32 bytes max.
</code></pre>
<p>MixKey(d)
Use HKDF() with a previous chainKey and new data d, and
sets the new chainKey and k.
As defined in <a href="https://noiseprotocol.org/noise.html">NOISE</a>
.</p>
<pre><code>Use HKDF as follows::

    MixKey(d) := output = HKDF(chainKey, d, &quot;&quot;, 64)
                 chainKey = output[0:31]
                 k = output[32:63]
</code></pre>
<h2 id="messages">Messages</h2>
<p>Each UDP datagram contains exactly one message.
The length of the datagram (after the IP and UDP headers) is the length of the message.
Padding, if any, is contained in a padding block inside the message.
In this document, we use the terms &ldquo;datagram&rdquo; and &ldquo;packet&rdquo; mostly interchangeably.
Each datagram (or packet) contains a single message (unlike QUIC, where
a datagram may contain multiple QUIC packets).
The &ldquo;packet header&rdquo; is the part after the IP/UDP header.</p>
<p>Exception:
The Session Confirmed message is unique in that it may be fragmented across multiple packets.
See the Session Confirmed Fragmentation section below for more information.</p>
<p>All SSU2 messages are at least 40 bytes in length.
Any message of length 1-39 bytes is invalid.
All SSU2 messages are less than or equal to 1472 (IPv4) or 1452 (IPv6) bytes in length. The message
format is based on Noise messages, with modifications for framing and indistinguishability.
Implementations using standard Noise libraries must pre-process received
messages to the standard Noise message format. All encrypted fields are AEAD
ciphertexts.</p>
<p>The following messages are defined:</p>
<table>
  <thead>
      <tr>
          <th>Type</th>
          <th>Message</th>
          <th>Header Length</th>
          <th>Header Encr. Length</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>0</td>
          <td>SessionRequest</td>
          <td>32</td>
          <td>64</td>
      </tr>
      <tr>
          <td>1</td>
          <td>SessionCreated</td>
          <td>32</td>
          <td>64</td>
      </tr>
      <tr>
          <td>2</td>
          <td>SessionConfirmed</td>
          <td>16</td>
          <td>16</td>
      </tr>
      <tr>
          <td>6</td>
          <td>Data</td>
          <td>16</td>
          <td>16</td>
      </tr>
      <tr>
          <td>7</td>
          <td>PeerTest</td>
          <td>32</td>
          <td>32</td>
      </tr>
      <tr>
          <td>9</td>
          <td>Retry</td>
          <td>32</td>
          <td>32</td>
      </tr>
      <tr>
          <td>10</td>
          <td>Token Request</td>
          <td>32</td>
          <td>32</td>
      </tr>
      <tr>
          <td>11</td>
          <td>HolePunch</td>
          <td>32</td>
          <td>32</td>
      </tr>
  </tbody>
</table>
<h3 id="session-establishment">Session Establishment</h3>
<p>The standard establishment sequence, when Alice has a valid token previously received from Bob, is as follows:</p>
<pre tabindex="0"><code>Alice                           Bob

SessionRequest -------------------&gt;
&lt;------------------- SessionCreated
SessionConfirmed -----------------&gt;
</code></pre><p>When Alice does not have a valid token, the establishment sequence is as follows:</p>
<pre tabindex="0"><code>Alice                           Bob

TokenRequest ---------------------&gt;
&lt;---------------------------  Retry
SessionRequest -------------------&gt;
&lt;------------------- SessionCreated
SessionConfirmed -----------------&gt;
</code></pre><p>When Alice thinks she has a valid token,
but Bob rejects it (perhaps because Bob restarted),
the establishment sequence is as follows:</p>
<pre tabindex="0"><code>Alice                           Bob

SessionRequest -------------------&gt;
&lt;---------------------------  Retry
SessionRequest -------------------&gt;
&lt;------------------- SessionCreated
SessionConfirmed -----------------&gt;
</code></pre><p>Bob may reject a Session or Token Request by replying with a Retry message
containing a Termination block with a reason code.
Based on the reason code, Alice should not attempt another
request for some period of time:</p>
<pre tabindex="0"><code>Alice                           Bob

SessionRequest -------------------&gt;
&lt;---------------------------  Retry containing a Termination block

or

TokenRequest ---------------------&gt;
&lt;---------------------------  Retry containing a Termination block
</code></pre><p>Using Noise terminology, the establishment and data sequence is as follows:
(Payload Security Properties)</p>
<pre tabindex="0"><code>XK(s, rs):           Authentication   Confidentiality
    &lt;- s
    ...
    -&gt; e, es                  0                2
    &lt;- e, ee                  2                1
    -&gt; s, se                  2                5
    &lt;-                        2                5
</code></pre><p>Once a session has been established, Alice and Bob can exchange Data messages.</p>
<h3 id="packet-header">Packet Header</h3>
<p>All packets start with an obfuscated (encrypted) header.
There are two header types, long and short.
Note that the first 13 bytes (Destination Connection ID, packet number, and type)
are the same for all headers.</p>
<h4 id="long-header">Long Header</h4>
<p>The long header is 32 bytes. It is used before a session is created, for Token Request, SessionRequest, SessionCreated, and Retry.
It is also used for out-of-session Peer Test and Hole Punch messages.</p>
<p>Before header encryption:</p>
<pre tabindex="0"><code>
+----+----+----+----+----+----+----+----+
  |      Destination Connection ID        |
  +----+----+----+----+----+----+----+----+
  |   Packet Number   |type| ver| id |flag|
  +----+----+----+----+----+----+----+----+
  |        Source Connection ID           |
  +----+----+----+----+----+----+----+----+
  |                 Token                 |
  +----+----+----+----+----+----+----+----+

  Destination Connection ID :: 8 bytes, unsigned big endian integer

  Packet Number :: 4 bytes, unsigned big endian integer

  type :: The message type = 0, 1, 7, 9, 10, or 11

  ver :: The protocol version, equal to 2

  id :: 1 byte, the network ID (currently 2, except for test networks)

  flag :: 1 byte, unused, set to 0 for future compatibility

  Source Connection ID :: 8 bytes, unsigned big endian integer

  Token :: 8 bytes, unsigned big endian integer
</code></pre><h4 id="short-header">Short Header</h4>
<p>The short header is 16 bytes. It is used for Session Created and for Data messages.
Unauthenticated messages such as Session Request, Retry, and Peer Test will
always use the long header.</p>
<p>16 bytes is required, because
the receiver must decrypt the first 16 bytes to get the message type,
and then must decrypt an additional 16 bytes if it&rsquo;s actually a long header,
as indicated by the message type.</p>
<p>For Session Confirmed, before header encryption:</p>
<pre tabindex="0"><code>
+----+----+----+----+----+----+----+----+
  |      Destination Connection ID        |
  +----+----+----+----+----+----+----+----+
  |   Packet Number   |type|frag|  flags  |
  +----+----+----+----+----+----+----+----+

  Destination Connection ID :: 8 bytes, unsigned big endian integer

  Packet Number :: 4 bytes, all zeros

  type :: The message type = 2

  frag :: 1 byte fragment info:
         bit order: 76543210 (bit 7 is MSB)
         bits 7-4: fragment number 0-14, big endian
         bits 3-0: total fragments 1-15, big endian

  flags :: 2 bytes, unused, set to 0 for future compatibility
</code></pre><p>See the Session Confirmed Fragmentation section below for more information
about the frag field.</p>
<p>For Data messages, before header encryption:</p>
<pre tabindex="0"><code>
+----+----+----+----+----+----+----+----+
  |      Destination Connection ID        |
  +----+----+----+----+----+----+----+----+
  |   Packet Number   |type|flag|moreflags|
  +----+----+----+----+----+----+----+----+

  Destination Connection ID :: 8 bytes, unsigned big endian integer

  Packet Number :: 4 bytes, unsigned big endian integer

  type :: The message type = 6

  flag :: 1 byte flags:
         bit order: 76543210 (bit 7 is MSB)
         bits 7-1: unused, set to 0 for future compatibility
         bits 0: when set to 1, immediate ack requested

  moreflags :: 2 bytes, unused, set to 0 for future compatibility
</code></pre><h4 id="connection-id-numbering">Connection ID Numbering</h4>
<p>Connection IDs must be randomly generated.
Source and Destination IDs must NOT be identical,
so that an on-path attacker cannot capture and send a packet
back to the originator that looks valid.
Do NOT use a counter to generate connection IDs, so that an on-path
attacker cannot generate a packet that looks valid.</p>
<p>Unlike in QUIC, we do not change the connection IDs during or after the handshake,
even after a Retry message. The IDs remain constant from the first message
(Token Request or Session Request) to the last message (Data with Termination).
Additionally, connection IDs do not change during or after
path challenge or connection migration.</p>
<p>Also different than QUIC is that connection IDs in the headers
are always header-encrypted. See below.</p>
<h4 id="packet-numbering">Packet Numbering</h4>
<p>If no First Packet Number block is sent in the handshake,
packets are numbered within a single session, for each direction, starting from 0, to a max of (2**32 -1).
A session must be terminated, and a new session created, well before the max
number of packets is sent.</p>
<p>If a First Packet Number block is sent in the handshake,
packets are numbered within a single session, for that direction, starting from that packet number.
The packet number may wrap around during the session.
When a max of 2**32 packets have been sent, wrapping the packet number back
to the first packet number, that session is no longer valid.
A session must be terminated, and a new session created, well before the max
number of packets is sent.</p>
<p>TODO key rotation, reduce max packet number?</p>
<p>Handshake packets that are determined to be lost are retransmitted
whole, with the identical header including packet number.
The handshake messages Session Request, Session Created, and Session Confirmed
MUST be retransmitted with the same packet number and identical encrypted contents,
so that the same chained hash will be used to encrypt the response.
The Retry message is never transmitted.</p>
<p>Data phase packets that are determined to be lost are never retransmitted
whole (except termination, see below).  The same applies to the blocks that are contained within lost
packets.  Instead, the information that might be carried in blocks is
sent again in new packets as needed.
Data Packets are never retransmitted with the same packet number.
Any retransmission of packet contents (whether or not the contents remain the same)
must use the next unused packet number.</p>
<p>Retransmitting an unchanged whole packet as-is, with the same packet number,
is not allowed for several reasons. For background see QUIC <a href="https://datatracker.ietf.org/doc/html/rfc9000">RFC 9000</a>
 section 12.3.</p>
<ul>
<li>It&rsquo;s inefficient to store packets for retransmission</li>
<li>A new packet data looks different to an on-path observer, can&rsquo;t tell it&rsquo;s retransmitted</li>
<li>A new packet gets an updated ack block sent with it, not the old ack block</li>
<li>You only retransmit what&rsquo;s necessary. some fragments could have been already retransmitted once and been acked</li>
<li>You can fit as much as you need into each retransmitted packet if more is pending</li>
<li>Endpoints that track all individual packets for the purposes of
detecting duplicates are at risk of accumulating excessive state.
The data required for detecting duplicates can be limited by
maintaining a minimum packet number below which all packets are
immediately dropped.</li>
<li>This scheme is much more flexible</li>
</ul>
<p>New packets are used to carry information that is
determined to have been lost.  In general, information is sent again
when a packet containing that information is determined to be lost,
and sending ceases when a packet containing that information is remain the same)
acknowledged.</p>
<p>Exception: A data phase packet containing a Termination block may,
but is not required to be, retransmitted whole, as-is.
See the Session Termination section below.</p>
<p>The following packets contain a random packet number that is ignored:</p>
<ul>
<li>Session Request</li>
<li>Session Created</li>
<li>Token Request</li>
<li>Retry</li>
<li>Peer Test</li>
<li>Hole Punch</li>
</ul>
<p>For Alice, outbound packet numbering starts at 0 with Session Confirmed.
For Bob, outbound packet numbering starts at 0 with first Data packet,
which should be an ACK of the Session Confirmed.
The packet numbers
in an example standard handshake will be:</p>
<pre tabindex="0"><code>Alice                           Bob

SessionRequest (r)    ------------&gt;
&lt;-------------   SessionCreated (r)
SessionConfirmed (0)  ------------&gt;
&lt;-------------             Data (0) (Ack-only)
Data (1)              ------------&gt; (May be sent before Ack is received)
&lt;-------------             Data (1)
Data (2)              ------------&gt;
Data (3)              ------------&gt;
Data (4)              ------------&gt;
&lt;-------------             Data (2)

r = random packet number (ignored)
Token Request, Retry, and Peer Test
also have random packet numbers.
</code></pre><p>Any retransmission of handshake messages
(SessionRequest, SessionCreated, or SessionConfirmed)
must be resent unchanged, with the same packet number.
Do not use different ephemeral keys or change the payload
when retransmitting these messages.</p>
<h4 id="header-binding">Header Binding</h4>
<p>The header (before obfuscation and protection) is always included in the associated
data for the AEAD function, to cryptographically bind the header to the data.</p>
<h4 id="header-encryption">Header Encryption</h4>
<p>Header encryption has several goals.
See the &ldquo;Additional DPI Discussion&rdquo; section above for background and assumptions.</p>
<ul>
<li>Prevent online DPI from identifying the protocol</li>
<li>Prevent patterns in a series of messages in the same connection,
except for handshake retransmissions</li>
<li>Prevent patterns in messages of the same type in different connections</li>
<li>Prevent decryption of handshake headers
without knowledge of the introduction key found in the netdb</li>
<li>Prevent identification of X25519 ephemeral keys
without knowledge of the introduction key found in the netdb</li>
<li>Prevent decryption of data phase packet number and type
by any online or offline attacker</li>
<li>Prevent injection of valid handshake packets by an on-path or off-path observer
without knowledge of the introduction key found in the netdb</li>
<li>Prevent injection of valid data packets by an on-path or off-path observer</li>
<li>Allow rapid and efficient classification of incoming packets</li>
<li>Provide &ldquo;probing&rdquo; resistance so that there is no response to a bad
Session Request, or if there is a Retry response,
the response is not identifiable as I2P
without knowledge of the introduction key found in the netdb</li>
<li>The Destination Connection ID is not critical data,
and it&rsquo;s ok if it can be decrypted by an observer
with knowledge of the introduction key found in the netdb</li>
<li>The packet number of a data phase packet is an AEAD nonce and is critical data.
It must not be decryptable by an observer even
with knowledge of the introduction key found in the netdb.
See <a href="https://eprint.iacr.org/2019/624.pdf">Nonces</a>
.</li>
</ul>
<p>Headers are encrypted with known keys published in the network database
or calculated later.
In the handshake phase, this is for DPI resistance only, as the key is public and the
key and nonces are reused, so it is effectively just obfuscation.
Note that the header encryption is also used to obfuscate
the ephemeral keys X (in Session Request) and Y (in Session Created).</p>
<p>See the Inbound Packet Handling section below for additional guidance.</p>
<p>Bytes 0-15 of all headers
are encrypted using a header protection scheme by XORing with data calculated from known keys,
using ChaCha20, similar to QUIC <a href="https://datatracker.ietf.org/doc/html/rfc9001">RFC 9001</a>
 and <a href="https://eprint.iacr.org/2019/624.pdf">Nonces</a>
.
This ensures that the encrypted short header and the first part of the long header
will appear to be random.</p>
<p>For Session Request and Session Created, bytes 16-31 of the long header and the 32-byte Noise ephemeral key
are encrypted using ChaCha20.
The unencrypted data is random, so the encrypted data will appear to be random.</p>
<p>For Retry, bytes 16-31 of the long header
are encrypted using ChaCha20.
The unencrypted data is random, so the encrypted data will appear to be random.</p>
<p>Unlike the QUIC <a href="https://datatracker.ietf.org/doc/html/rfc9001">RFC 9001</a>
 header protection scheme,
ALL parts of all headers, including destination and source connection IDs,
are encrypted.
QUIC <a href="https://datatracker.ietf.org/doc/html/rfc9001">RFC 9001</a>
 and <a href="https://eprint.iacr.org/2019/624.pdf">Nonces</a>
 are primarily focused on encrypting
the &ldquo;critical&rdquo; part of the header, i.e. the packet number (ChaCha20 nonce).
While encrypting the session ID makes incoming packet classification a little more complex,
it makes some attacks more difficult. QUIC defines different connection IDs
for different phases, and for path challenge and connection migration.
Here we use the same connection IDs throughout, as they are encrypted.</p>
<p>There are seven header protection key phases:</p>
<ul>
<li>Session Request and Token Request</li>
<li>Session Created</li>
<li>Retry</li>
<li>Session Confirmed</li>
<li>Data Phase</li>
<li>Peer Test</li>
<li>Hole Punch</li>
</ul>
<table>
  <thead>
      <tr>
          <th>Message</th>
          <th>Key k_header_1</th>
          <th>Key k_header_2</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Token Request</td>
          <td>Bob Intro Key</td>
          <td>Bob Intro Key</td>
      </tr>
      <tr>
          <td>Session Request</td>
          <td>Bob Intro Key</td>
          <td>Bob Intro Key</td>
      </tr>
      <tr>
          <td>Session Created</td>
          <td>Bob Intro Key</td>
          <td>See Session Request K</td>
      </tr>
      <tr>
          <td>Session Confirmed</td>
          <td>Bob Intro Key</td>
          <td>See Session Created K</td>
      </tr>
      <tr>
          <td>Retry</td>
          <td>Bob Intro Key</td>
          <td>Bob Intro Key</td>
      </tr>
      <tr>
          <td>Data</td>
          <td>Alice/Bob Intro Key</td>
          <td>See data phase KDF</td>
      </tr>
      <tr>
          <td>Peer Test 5,7</td>
          <td>Alice Intro Key</td>
          <td>Alice Intro Key</td>
      </tr>
      <tr>
          <td>Peer Test 6</td>
          <td>Charlie Intro Key</td>
          <td>Charlie Intro Key</td>
      </tr>
      <tr>
          <td>Hole Punch</td>
          <td>Alice Intro Key</td>
          <td>Alice Intro Key</td>
      </tr>
  </tbody>
</table>
<p>Header encryption is designed to allow rapid classification of
inbound packets, without complex heuristics or fallbacks.
This is accomplished by using the same k_header_1 key
for almost all inbound messages.
Even when the source IP or port of a connection changes
due to an actual IP change or NAT behavior, the packet may be
rapidly mapped to a session with a single lookup of the connection ID.</p>
<p>Note that Session Created and Retry are the ONLY messages that require fallback processing
for k_header_1 to decrypt the Connection ID, because they use the sender&rsquo;s (Bob&rsquo;s) intro key.
ALL other messages use the receiver&rsquo;s intro key for k_header_1.
The fallback processing need only look up pending outbound connections by
source IP/port.</p>
<p>If the fallback processing by source IP/port fails to find a pending
outbound connection, there could be several causes:</p>
<ul>
<li>Not an SSU2 message</li>
<li>A corrupted SSU2 message</li>
<li>The reply is spoofed or modified by an attacker</li>
<li>Bob has a symmetric NAT</li>
<li>Bob changed IP or port during processing of the message</li>
<li>Bob sent the reply out a different interface</li>
</ul>
<p>While additional fallback processing is possible to attempt to find
the pending outbound connection and decrypt the connection ID
using the k_header_1 for that connection, it is probably not necessary.
If Bob has issues with his NAT or packet routing, it is probably
better to let the connection fail.
This design relies on endpoints retaining a stable address for the duration of the handshake.</p>
<p>See the Inbound Packet Handling sesion below for additional guidelines.</p>
<p>See the individual KDF sections below for the derivation of the header encryption keys for that phase.</p>
<h4 id="header-encryption-kdf">Header Encryption KDF</h4>
<pre tabindex="0"><code>// incoming encrypted packet
  packet = incoming encrypted packet
  len = packet.length

  // take the next-to-last 12 bytes of the packet
  iv = packet[len-24:len-13]
  k_header_1 = header encryption key 1
  data = {0, 0, 0, 0, 0, 0, 0, 0}
  mask = ChaCha20.encrypt(k_header_1, iv, data)

  // encrypt the first part of the header by XORing with the mask
  packet[0:7] ^= mask[0:7]

  // take the last 12 bytes of the packet
  iv = packet[len-12:len-1]
  k_header_2 = header encryption key 2
  data = {0, 0, 0, 0, 0, 0, 0, 0}
  mask = ChaCha20.encrypt(k_header_2, iv, data)

  // encrypt the second part of the header by XORing with the mask
  packet[8:15] ^= mask[0:7]


  // For Session Request and Session Created only:
  iv = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}

  // encrypt the third part of the header and the ephemeral key
  packet[16:63] = ChaCha20.encrypt(k_header_2, iv, packet[16:63])


  // For Retry, Token Request, Peer Test, and Hole Punch only:
  iv = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}

  // encrypt the third part of the header
  packet[16:31] = ChaCha20.encrypt(k_header_2, iv, packet[16:31])
</code></pre><p>This KDF uses the last 24 bytes of the packet as the IV for the two
ChaCha20 operations. As all packets end with a 16 byte MAC,
this requires that all packet payloads are a minimum of 8 bytes.
This requirement is additionally documented in the message sections below.</p>
<h4 id="header-validation">Header Validation</h4>
<p>After decrypting the first 8 bytes of the header,
the receiver will know the Destination Connection ID. From there,
the receiver knows what header encryption key to use for
the remainder of the header, based on the key phase of the session.</p>
<p>Decrypting the next 8 bytes of the header will then reveal the message type and be able to determine
if it is a short or long header.
If it is a long header, the receiver must validate the version and netid fields.
If the version is != 2, or the netid is != the expected value (generally 2, except in test networks),
the receiver should drop the message.</p>
<h3 id="packet-integrity">Packet Integrity</h3>
<p>All message contain either three or four parts:</p>
<ul>
<li>The message header</li>
<li>For Session Request and Session Created only, an ephemeral key</li>
<li>A ChaCha20-encrypted payload</li>
<li>A Poly1305 MAC</li>
</ul>
<p>In all cases, the header (and if present, the ephemeral key) is bound
to the authentication MAC to ensure that the entire message is intact.</p>
<ul>
<li>For handshake messages Session Request, Session Created, and Session Confirmed,
the message header is mixHash()ed before the Noise processing phase</li>
<li>The ephemeral key, if present, is covered by a standard Noise misHash()</li>
<li>For messages outside the Noise handshake, the header is used
as Associated Data for the ChaCha20/Poly1305 encryption.</li>
</ul>
<p>Inbound packet handlers must always decrypt the ChaCha20 payload and validate
the MAC before processing the message, with one exception:
To mitigate DoS attacks from address-spoofed packets containing
apparent Session Request messages with an invalid token, a handler need NOT
attempt to decrypt and validate the full message
(requiring an expensive DH operation in addition to the ChaCha2o/Poly1305 decryption).
The handler may respond with a Retry message using the values found in the header
of the Session Request message.</p>
<h3 id="authenticated-encryption">Authenticated Encryption</h3>
<p>There are three separate authenticated encryption instances (CipherStates).
One during the handshake phase, and two (transmit and receive) for the data phase.
Each has its own key from a KDF.</p>
<p>Encrypted/authenticated data will be represented as</p>
<pre tabindex="0"><code>+----+----+----+----+----+----+----+----+
  |                                       |
  +                                       +
  |   Encrypted and authenticated data    |
  ~               .   .   .               ~
  |                                       |
  +----+----+----+----+----+----+----+----+
</code></pre><h4 id="chacha20poly1305">ChaCha20/Poly1305</h4>
<p>Encrypted and authenticated data format.</p>
<p>Inputs to the encryption/decryption functions:</p>
<pre tabindex="0"><code>
k :: 32 byte cipher key, as generated from KDF

  nonce :: Counter-based nonce, 12 bytes.
           Starts at 0 and incremented for each message.
           First four bytes are always zero.
           Last eight bytes are the counter, little-endian encoded.
           Maximum value is 2**64 - 2.
           Connection must be dropped and restarted after
           it reaches that value.
           The value 2**64 - 1 must never be sent.

  ad :: In handshake phase:
        Associated data, 32 bytes.
        The SHA256 hash of all preceding data.
        In data phase:
        The packet header, 16 bytes.

  data :: Plaintext data, 0 or more bytes
</code></pre><p>Output of the encryption function, input to the decryption function:</p>
<pre tabindex="0"><code>
+----+----+----+----+----+----+----+----+
  |                                       |
  +                                       +
  |       ChaCha20 encrypted data         |
  ~               .   .   .               ~
  |                                       |
  +----+----+----+----+----+----+----+----+
  |  Poly1305 Message Authentication Code |
  +              (MAC)                    +
  |             16 bytes                  |
  +----+----+----+----+----+----+----+----+

  encrypted data :: Same size as plaintext data, 0 - 65519 bytes

  MAC :: Poly1305 message authentication code, 16 bytes
</code></pre><p>For ChaCha20, what is described here corresponds to <a href="https://tools.ietf.org/html/rfc7539">RFC 7539</a>
, which is also
used similarly in TLS <a href="https://tools.ietf.org/html/rfc7905">RFC 7905</a>
.</p>
<h4 id="notes">Notes</h4>
<ul>
<li>
<p>Since ChaCha20 is a stream cipher, plaintexts need not be padded.
Additional keystream bytes are discarded.</p>
</li>
<li>
<p>The key for the cipher (256 bits) is agreed upon by means of the SHA256 KDF.
The details of the KDF for each message are in separate sections below.</p>
</li>
</ul>
<h4 id="aead-error-handling">AEAD Error Handling</h4>
<ul>
<li>
<p>In all messages, the AEAD message size is known in advance.
On an AEAD authentication failure, recipient must halt further message processing and
discard the message.</p>
</li>
<li>
<p>Bob should maintain a blacklist of IPs with
repeated failures.</p>
</li>
</ul>
<h3 id="kdf-for-session-request">KDF for Session Request</h3>
<p>The Key Derivation Function (KDF) generates a handshake phase cipher key k from the DH result,
using HMAC-SHA256(key, data) as defined in <a href="https://tools.ietf.org/html/rfc2104">RFC 2104</a>
.
These are the InitializeSymmetric(), MixHash(), and MixKey() functions,
exactly as defined in the Noise spec.</p>
<h4 id="kdf-for-initial-chainkey">KDF for Initial ChainKey</h4>
<pre tabindex="0"><code>
// Define protocol_name.
  Set protocol_name = &#34;Noise_XKchaobfse+hs1+hs2+hs3_25519_ChaChaPoly_SHA256&#34;
   (52 bytes, US-ASCII encoded, no NULL termination).

  // Define Hash h = 32 bytes
  h = SHA256(protocol_name);

  Define ck = 32 byte chaining key. Copy the h data to ck.
  Set ck = h

  // MixHash(null prologue)
  h = SHA256(h);

  // up until here, can all be precalculated by Alice for all outgoing connections

  // Bob&#39;s X25519 static keys
  // bpk is published in routerinfo
  bsk = GENERATE_PRIVATE()
  bpk = DERIVE_PUBLIC(bsk)

  // Bob static key
  // MixHash(bpk)
  // || below means append
  h = SHA256(h || bpk);

  // Bob introduction key
  // bik is published in routerinfo
  bik = RANDOM(32)

  // up until here, can all be precalculated by Bob for all incoming connections
</code></pre><h4 id="kdf-for-session-request-1">KDF for Session Request</h4>
<pre tabindex="0"><code>
// MixHash(header)
  h = SHA256(h || header)

  This is the &#34;e&#34; message pattern:

  // Alice&#39;s X25519 ephemeral keys
  aesk = GENERATE_PRIVATE()
  aepk = DERIVE_PUBLIC(aesk)

  // Alice ephemeral key X
  // MixHash(aepk)
  h = SHA256(h || aepk);

  // h is used as the associated data for the AEAD in Session Request
  // Retain the Hash h for the Session Created KDF


  End of &#34;e&#34; message pattern.

  This is the &#34;es&#34; message pattern:

  // DH(e, rs) == DH(s, re)
  sharedSecret = DH(aesk, bpk) = DH(bsk, aepk)

  // MixKey(DH())
  //[chainKey, k] = MixKey(sharedSecret)
  // ChaChaPoly parameters to encrypt/decrypt
  keydata = HKDF(chainKey, sharedSecret, &#34;&#34;, 64)
  chainKey = keydata[0:31]

  // AEAD parameters
  k = keydata[32:63]
  n = 0
  ad = h
  ciphertext = ENCRYPT(k, n, payload, ad)

  // retain the chainKey for Session Created KDF


  End of &#34;es&#34; message pattern.

  // Header encryption keys for this message
  // bik = Bob&#39;s intro key
  k_header_1 = bik
  k_header_2 = bik

  // Header encryption keys for next message (Session Created)
  k_header_1 = bik
  k_header_2 = HKDF(chainKey, ZEROLEN, &#34;SessCreateHeader&#34;, 32)

  // Header encryption keys for next message (Retry)
  k_header_1 = bik
  k_header_2 = bik
</code></pre><h3 id="sessionrequest-type-0">SessionRequest (Type 0)</h3>
<p>Alice sends to Bob, either as the first message in the handshake,
or in response to a Retry message.
Bob responds with a Session Created message.
Size: 80 + payload size.
Minimum Size: 88</p>
<p>If Alice does not have a valid token, Alice should send a Token Request  message
instead of a Session Request, to avoid the asymmetric encryption
overhead in generating a Session Request.</p>
<p>Long header.
Noise content: Alice&rsquo;s ephemeral key X
Noise payload: DateTime and other blocks
Max payload size: MTU - 108 (IPv4) or MTU - 128 (IPv6).
For 1280 MTU: Max payload is 1172 (IPv4) or 1152 (IPv6).
For 1500 MTU: Max payload is 1392 (IPv4) or 1372 (IPv6).</p>
<p>Payload Security Properties:</p>
<pre tabindex="0"><code>XK(s, rs):           Authentication   Confidentiality
    -&gt; e, es                  0                2

    Authentication: None (0).
    This payload may have been sent by any party, including an active attacker.

    Confidentiality: 2.
    Encryption to a known recipient, forward secrecy for sender compromise
    only, vulnerable to replay.  This payload is encrypted based only on DHs
    involving the recipient&#39;s static key pair.  If the recipient&#39;s static
    private key is compromised, even at a later date, this payload can be
    decrypted.  This message can also be replayed, since there&#39;s no ephemeral
    contribution from the recipient.

    &#34;e&#34;: Alice generates a new ephemeral key pair and stores it in the e
         variable, writes the ephemeral public key as cleartext into the
         message buffer, and hashes the public key along with the old h to
         derive a new h.

    &#34;es&#34;: A DH is performed between the Alice&#39;s ephemeral key pair and the
          Bob&#39;s static key pair.  The result is hashed along with the old ck to
          derive a new ck and k, and n is set to zero.
</code></pre><p>The X value is encrypted to ensure payload indistinguishably
and uniqueness, which are necessary DPI countermeasures.
We use ChaCha20 encryption to achieve this,
rather than more complex and slower alternatives such as elligator2.
Asymmetric encryption to Bob&rsquo;s router public key would be far too slow.
ChaCha20 encryption uses Bob&rsquo;s intro key as published
in the network database.</p>
<p>ChaCha20 encryption is for DPI resistance only.
Any party knowing Bob&rsquo;s introduction key, which is published in the network database,
may decrypt the header and X value in this message.</p>
<p>Raw contents:</p>
<pre tabindex="0"><code>+----+----+----+----+----+----+----+----+
  |  Long Header bytes 0-15, ChaCha20     |
  +  encrypted with Bob intro key         +
  |    See Header Encryption KDF          |
  +----+----+----+----+----+----+----+----+
  |  Long Header bytes 16-31, ChaCha20    |
  +  encrypted with Bob intro key n=0     +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |                                       |
  +       X, ChaCha20 encrypted           +
  |       with Bob intro key n=0          |
  +              (32 bytes)               +
  |                                       |
  +                                       +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |                                       |
  +                                       +
  |   ChaCha20 encrypted data             |
  +          (length varies)              +
  |  k defined in KDF for Session Request |
  +  n = 0                                +
  |  see KDF for associated data          |
  +----+----+----+----+----+----+----+----+
  |                                       |
  +        Poly1305 MAC (16 bytes)        +
  |                                       |
  +----+----+----+----+----+----+----+----+

  X :: 32 bytes, ChaCha20 encrypted X25519 ephemeral key, little endian
          key: Bob&#39;s intro key
          n: 1
          data: 48 bytes (bytes 16-31 of the header, followed by encrypted X)
</code></pre><p>Unencrypted data (Poly1305 authentication tag not shown):</p>
<pre tabindex="0"><code>+----+----+----+----+----+----+----+----+
  |      Destination Connection ID        |
  +----+----+----+----+----+----+----+----+
  |   Packet Number   |type| ver| id |flag|
  +----+----+----+----+----+----+----+----+
  |        Source Connection ID           |
  +----+----+----+----+----+----+----+----+
  |                 Token                 |
  +----+----+----+----+----+----+----+----+
  |                                       |
  +                                       +
  |                   X                   |
  +              (32 bytes)               +
  |                                       |
  +                                       +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |     Noise payload (block data)        |
  +          (length varies)              +
  |     see below for allowed blocks      |
  +----+----+----+----+----+----+----+----+


  Destination Connection ID :: Randomly generated by Alice

  id :: 1 byte, the network ID (currently 2, except for test networks)

  ver :: 2

  type :: 0

  flag :: 1 byte, unused, set to 0 for future compatibility

  Packet Number :: Random 4 byte number generated by Alice, ignored

  Source Connection ID :: Randomly generated by Alice,
                          must not be equal to Destination Connection ID

  Token :: 0 if not previously received from Bob

  X :: 32 bytes, X25519 ephemeral key, little endian
</code></pre><h4 id="payload">Payload</h4>
<ul>
<li>DateTime block</li>
<li>Options block (optional)</li>
<li>Relay Tag Request block (optional)</li>
<li>Padding block (optional)</li>
</ul>
<p>The minimum payload size is 8 bytes. Since the DateTime block is
only 7 bytes, at least one other block must be present.</p>
<h4 id="notes-1">Notes</h4>
<ul>
<li>
<p>The unique X value in the initial ChaCha20 block ensure that the ciphertext is
different for every session.</p>
</li>
<li>
<p>To provide probing resistance, Bob should not send a Retry message
in response to a Session Request message unless the
message type, protocol version, and network ID fields in the Session Request message
are valid.</p>
</li>
<li>
<p>Bob must reject connections where the timestamp value is too far off from the
current time. Call the maximum delta time &ldquo;D&rdquo;.  Bob must maintain a local
cache of previously-used handshake values and reject duplicates, to prevent
replay attacks. Values in the cache must have a lifetime of at least 2*D.
The cache values are implementation-dependent, however the 32-byte X value
(or its encrypted equivalent) may be used.
Reject by sending a Retry message containing a zero token and a termination block.</p>
</li>
<li>
<p>Diffie-Hellman ephemeral keys may never be reused, to prevent cryptographic attacks,
and reuse will be rejected as a replay attack.</p>
</li>
<li>
<p>The &ldquo;KE&rdquo; and &ldquo;auth&rdquo; options must be compatible, i.e. the shared secret K must
be of the appropriate size. If more &ldquo;auth&rdquo; options are added, this could
implicitly change the meaning of the &ldquo;KE&rdquo; flag to use a different KDF or a
different truncation size.</p>
</li>
<li>
<p>Bob must validate that Alice&rsquo;s ephemeral key is a valid point on the curve
here.</p>
</li>
<li>
<p>Padding should be limited to a reasonable amount.  Bob may reject connections
with excessive padding.  Bob will specify his padding options in Session Created.
Min/max guidelines TBD. Random size from 0 to 31 bytes minimum?
(Distribution to be determined, see Appendix A.)
TODO UNLESS minimum packet size is enforced for PMTU.</p>
</li>
<li>
<p>On most errors, including AEAD, DH, apparent replay, or key
validation failure, Bob should halt further message processing and
drop the message without responding.</p>
</li>
<li>
<p>Bob MAY send a Retry message containing a zero token and a Termination block with a
clock skew reason code if the timestamp in the DateTime block is too
far skewed.</p>
</li>
<li>
<p>DoS Mitigation: DH is a relatively expensive operation. As with the previous NTCP protocol,
routers should take all necessary measures to prevent CPU or connection exhaustion.
Place limits on maximum active connections and maximum connection setups in progress.
Enforce read timeouts (both per-read and total for &ldquo;slowloris&rdquo;).
Limit repeated or simultaneous connections from the same source.
Maintain blacklists for sources that repeatedly fail.
Do not respond to AEAD failure. Alternatively, respond with a Retry message
before the DH operation and AEAD validation.</p>
</li>
<li>
<p>&ldquo;ver&rdquo; field: The overall Noise protocol, extensions, and SSU2 protocol
including payload specifications, indicating SSU2.
This field may be used to indicate support for future changes.</p>
</li>
<li>
<p>The network ID field is used to quickly identify cross-network connections.
If this field is does not match Bob&rsquo;s network ID,
Bob should disconnect and block future connections.</p>
</li>
<li>
<p>Bob must drop the message if the Source Connection ID equals
the Destination Connection ID.</p>
</li>
</ul>
<h3 id="kdf-for-session-created-and-session-confirmed-part-1">KDF for Session Created and Session Confirmed part 1</h3>
<pre tabindex="0"><code>
// take h saved from Session Request KDF
  // MixHash(ciphertext)
  h = SHA256(h || encrypted Noise payload from Session Request)

  // MixHash(header)
  h = SHA256(h || header)

  This is the &#34;e&#34; message pattern:

  // Bob&#39;s X25519 ephemeral keys
  besk = GENERATE_PRIVATE()
  bepk = DERIVE_PUBLIC(besk)

  // h is from KDF for Session Request
  // Bob ephemeral key Y
  // MixHash(bepk)
  h = SHA256(h || bepk);

  // h is used as the associated data for the AEAD in Session Created
  // Retain the Hash h for the Session Confirmed KDF

  End of &#34;e&#34; message pattern.

  This is the &#34;ee&#34; message pattern:

  // MixKey(DH())
  //[chainKey, k] = MixKey(sharedSecret)
  sharedSecret = DH(aesk, bepk) = DH(besk, aepk)
  keydata = HKDF(chainKey, sharedSecret, &#34;&#34;, 64)
  chainKey = keydata[0:31]

  // AEAD parameters
  k = keydata[32:63]
  n = 0
  ad = h
  ciphertext = ENCRYPT(k, n, payload, ad)

  // retain the chaining key ck for Session Confirmed KDF

  End of &#34;ee&#34; message pattern.

  // Header encryption keys for this message
  // bik = Bob&#39;s intro key
  k_header_1 = bik
  k_header_2: See Session Request KDF above

  // Header protection keys for next message (Session Confirmed)
  k_header_1 = bik
  k_header_2 = HKDF(chainKey, ZEROLEN, &#34;SessionConfirmed&#34;, 32)
</code></pre><h3 id="sessioncreated-type-1">SessionCreated (Type 1)</h3>
<p>Bob sends to Alice, in response to a Session Request message.
Alice responds with a Session Confirmed message.
Size: 80 + payload size.
Minimum Size: 88</p>
<p>Noise content: Bob&rsquo;s ephemeral key Y
Noise payload: DateTime, Address, and other blocks
Max payload size: MTU - 108 (IPv4) or MTU - 128 (IPv6).
For 1280 MTU: Max payload is 1172 (IPv4) or 1152 (IPv6).
For 1500 MTU: Max payload is 1392 (IPv4) or 1372 (IPv6).</p>
<p>Payload Security Properties:</p>
<pre tabindex="0"><code>XK(s, rs):           Authentication   Confidentiality
    &lt;- e, ee                  2                1

    Authentication: 2.
    Sender authentication resistant to key-compromise impersonation (KCI).
    The sender authentication is based on an ephemeral-static DH (&#34;es&#34; or &#34;se&#34;)
    between the sender&#39;s static key pair and the recipient&#39;s ephemeral key pair.
    Assuming the corresponding private keys are secure, this authentication cannot be forged.

    Confidentiality: 1.
    Encryption to an ephemeral recipient.
    This payload has forward secrecy, since encryption involves an ephemeral-ephemeral DH (&#34;ee&#34;).
    However, the sender has not authenticated the recipient,
    so this payload might be sent to any party, including an active attacker.


    &#34;e&#34;: Bob generates a new ephemeral key pair and stores it in the e variable,
    writes the ephemeral public key as cleartext into the message buffer,
    and hashes the public key along with the old h to derive a new h.

    &#34;ee&#34;: A DH is performed between the Bob&#39;s ephemeral key pair and the Alice&#39;s ephemeral key pair.
    The result is hashed along with the old ck to derive a new ck and k, and n is set to zero.
</code></pre><p>The Y value is encrypted to ensure payload indistinguishably and uniqueness,
which are necessary DPI countermeasures.  We use ChaCha20 encryption to achieve
this, rather than more complex and slower alternatives such as elligator2.
Asymmetric encryption to Alice&rsquo;s router public key would be far too slow.  ChaCha20
encryption uses Bob&rsquo;s intro key,
as published in the network database.</p>
<p>ChaCha20 encryption is for DPI resistance only.  Any party knowing Bob&rsquo;s intro key,
which is published in the network database, and captured the first 32
bytes of Session Request, may decrypt the Y value in this message.</p>
<p>Raw contents:</p>
<pre tabindex="0"><code>+----+----+----+----+----+----+----+----+
  |  Long Header bytes 0-15, ChaCha20     |
  +  encrypted with Bob intro key and     +
  | derived key, see Header Encryption KDF|
  +----+----+----+----+----+----+----+----+
  |  Long Header bytes 16-31, ChaCha20    |
  +  encrypted with derived key n=0       +
  |  See Header Encryption KDF            |
  +----+----+----+----+----+----+----+----+
  |                                       |
  +       Y, ChaCha20 encrypted           +
  |       with derived key n=0            |
  +              (32 bytes)               +
  |       See Header Encryption KDF       |
  +                                       +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |   ChaCha20 data                       |
  +   Encrypted and authenticated data    +
  |  length varies                        |
  +  k defined in KDF for Session Created +
  |  n = 0; see KDF for associated data   |
  +                                       +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |                                       |
  +        Poly1305 MAC (16 bytes)        +
  |                                       |
  +----+----+----+----+----+----+----+----+

  Y :: 32 bytes, ChaCha20 encrypted X25519 ephemeral key, little endian
          key: Bob&#39;s intro key
          n: 1
          data: 48 bytes (bytes 16-31 of the header, followed by encrypted Y)
</code></pre><p>Unencrypted data (Poly1305 auth tag not shown):</p>
<pre tabindex="0"><code>+----+----+----+----+----+----+----+----+
  |      Destination Connection ID        |
  +----+----+----+----+----+----+----+----+
  |   Packet Number   |type| ver| id |flag|
  +----+----+----+----+----+----+----+----+
  |        Source Connection ID           |
  +----+----+----+----+----+----+----+----+
  |                 Token                 |
  +----+----+----+----+----+----+----+----+
  |                                       |
  +                                       +
  |                  Y                    |
  +              (32 bytes)               +
  |                                       |
  +                                       +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |     Noise payload (block data)        |
  +          (length varies)              +
  |      see below for allowed blocks     |
  +----+----+----+----+----+----+----+----+

  Destination Connection ID :: The Source Connection ID
                               received from Alice in Session Request

  id :: 1 byte, the network ID (currently 2, except for test networks)

  ver :: 2

  type :: 0

  flag :: 1 byte, unused, set to 0 for future compatibility

  Packet Number :: Random 4 byte number generated by Bob, ignored

  Source Connection ID :: The Destination Connection ID
                          received from Alice in Session Request

  Token :: 0 (unused)

  Y :: 32 bytes, X25519 ephemeral key, little endian
</code></pre><h4 id="payload-1">Payload</h4>
<ul>
<li>DateTime block</li>
<li>Address block</li>
<li>Relay Tag block (optional)</li>
<li>New Token block (optional)</li>
<li>First Packet Number block (optional)</li>
<li>Options block (optional)</li>
<li>Termination block (not recommended, send in a retry message instead)</li>
<li>Padding block (optional)</li>
</ul>
<p>The minimum payload size is 8 bytes. Since the DateTime and Address blocks
total more than that, the requirement is met with only those two blocks.</p>
<h4 id="notes-2">Notes</h4>
<ul>
<li>
<p>Alice must validate that Bob&rsquo;s ephemeral key is a valid point on the curve
here.</p>
</li>
<li>
<p>Padding should be limited to a reasonable amount.
Alice may reject connections with excessive padding.
Alice will specify her padding options in Session Confirmed.
Min/max guidelines TBD. Random size from 0 to 31 bytes minimum?
(Distribution to be determined, see Appendix A.)
TODO UNLESS minimum packet size is enforced for PMTU.</p>
</li>
<li>
<p>On any error, including AEAD, DH, timestamp, apparent replay, or key
validation failure, Alice must halt further message processing and close the
connection without responding.</p>
</li>
<li>
<p>Alice must reject connections where the timestamp value is too far off from
the current time. Call the maximum delta time &ldquo;D&rdquo;.  Alice must maintain a
local cache of previously-used handshake values and reject duplicates, to
prevent replay attacks. Values in the cache must have a lifetime of at least
2*D.  The cache values are implementation-dependent, however the 32-byte Y
value (or its encrypted equivalent) may be used.</p>
</li>
<li>
<p>Alice must drop the message if the source IP and port do not match
the destination IP and port of the Session Request.</p>
</li>
<li>
<p>Alice must drop the message if the Destination and Source Connection IDs
do not match the Source and Destination Connection IDs of the Session Request.</p>
</li>
<li>
<p>Bob sends a relay tag block if requested by Alice in the Session Request.</p>
</li>
</ul>
<h4 id="issues">Issues</h4>
<ul>
<li>Include min/max padding options here?</li>
</ul>
<h3 id="kdf-for-session-confirmed-part-1-using-session-created-kdf">KDF for Session Confirmed part 1, using Session Created KDF</h3>
<pre tabindex="0"><code>
// take h saved from Session Created KDF
  // MixHash(ciphertext)
  h = SHA256(h || encrypted Noise payload from Session Created)

  // MixHash(header)
  h = SHA256(h || header)
  // h is used as the associated data for the AEAD in Session Confirmed part 1, below

  This is the &#34;s&#34; message pattern:

  // Alice&#39;s X25519 static keys
  ask = GENERATE_PRIVATE()
  apk = DERIVE_PUBLIC(ask)

  // AEAD parameters
  // k is from Session Request
  n = 1
  ad = h
  ciphertext = ENCRYPT(k, n++, apk, ad)

  // MixHash(ciphertext)
  h = SHA256(h || ciphertext);

  // h is used as the associated data for the AEAD in Session Confirmed part 2

  End of &#34;s&#34; message pattern.

  // Header encryption keys for this message
  See Session Confirmed part 2 below
</code></pre><h3 id="kdf-for-session-confirmed-part-2">KDF for Session Confirmed part 2</h3>
<pre tabindex="0"><code>
This is the &#34;se&#34; message pattern:

  // DH(ask, bepk) == DH(besk, apk)
  sharedSecret = DH(ask, bepk) = DH(besk, apk)

  // MixKey(DH())
  //[chainKey, k] = MixKey(sharedSecret)
  keydata = HKDF(chainKey, sharedSecret, &#34;&#34;, 64)
  chainKey = keydata[0:31]

  // AEAD parameters
  k = keydata[32:63]
  n = 0
  ad = h
  ciphertext = ENCRYPT(k, n, payload, ad)

  // h from Session Confirmed part 1 is used as the associated data for the AEAD in Session Confirmed part 2
  // MixHash(ciphertext)
  h = SHA256(h || ciphertext);

  // retain the chaining key ck for the data phase KDF
  // retain the hash h for the data phase KDF

  End of &#34;se&#34; message pattern.

  // Header encryption keys for this message
  // bik = Bob&#39;s intro key
  k_header_1 = bik
  k_header_2: See Session Created KDF above

  // Header protection keys for data phase
  See data phase KDF below
</code></pre><h3 id="sessionconfirmed-type-2">SessionConfirmed (Type 2)</h3>
<p>Alice sends to Bob, in response to a Session Created message.
Bob responds immediately with a Data message containing an ACK block.
Size: 80 + payload size.
Minimum Size: About 500 (minimum router info block size is about 420 bytes)</p>
<p>Noise content: Alice&rsquo;s static key
Noise payload part 1: None
Noise payload part 2: Alice&rsquo;s RouterInfo, and other blocks
Max payload size: MTU - 108 (IPv4) or MTU - 128 (IPv6).
For 1280 MTU: Max payload is 1172 (IPv4) or 1152 (IPv6).
For 1500 MTU: Max payload is 1392 (IPv4) or 1372 (IPv6).</p>
<p>Payload Security Properties:</p>
<pre tabindex="0"><code>XK(s, rs):           Authentication   Confidentiality
    -&gt; s, se                  2                5

    Authentication: 2.
    Sender authentication resistant to key-compromise impersonation (KCI).  The
    sender authentication is based on an ephemeral-static DH (&#34;es&#34; or &#34;se&#34;)
    between the sender&#39;s static key pair and the recipient&#39;s ephemeral key
    pair.  Assuming the corresponding private keys are secure, this
    authentication cannot be forged.

    Confidentiality: 5.
    Encryption to a known recipient, strong forward secrecy.  This payload is
    encrypted based on an ephemeral-ephemeral DH as well as an ephemeral-static
    DH with the recipient&#39;s static key pair.  Assuming the ephemeral private
    keys are secure, and the recipient is not being actively impersonated by an
    attacker that has stolen its static private key, this payload cannot be
    decrypted.

    &#34;s&#34;: Alice writes her static public key from the s variable into the
    message buffer, encrypting it, and hashes the output along with the old h
    to derive a new h.

    &#34;se&#34;: A DH is performed between the Alice&#39;s static key pair and the Bob&#39;s
    ephemeral key pair.  The result is hashed along with the old ck to derive a
    new ck and k, and n is set to zero.
</code></pre><p>This contains two ChaChaPoly frames.
The first is Alice&rsquo;s encrypted static public key.
The second is the Noise payload: Alice&rsquo;s encrypted RouterInfo, optional
options, and optional padding.  They use different keys, because the MixKey()
function is called in between.</p>
<p>Raw contents:</p>
<pre tabindex="0"><code>+----+----+----+----+----+----+----+----+
  |  Short Header 16 bytes, ChaCha20      |
  +  encrypted with Bob intro key and     +
  | derived key, see Header Encryption KDF|
  +----+----+----+----+----+----+----+----+
  |   ChaCha20 frame (32 bytes)           |
  +   Encrypted and authenticated data    +
  +   Alice static key S                  +
  | k defined in KDF for Session Created  |
  +     n = 1                             +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |                                       |
  +        Poly1305 MAC (16 bytes)        +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |                                       |
  + Length varies (remainder of packet)   +
  |                                       |
  +   ChaChaPoly frame                    +
  |   Encrypted and authenticated         |
  +   see below for allowed blocks        +
  |                                       |
  +     k defined in KDF for              +
  |     Session Confirmed part 2          |
  +     n = 0                             +
  |     see KDF for associated data       |
  ~               .   .   .               ~
  |                                       |
  +----+----+----+----+----+----+----+----+
  |                                       |
  +        Poly1305 MAC (16 bytes)        +
  |                                       |
  +----+----+----+----+----+----+----+----+

  S :: 32 bytes, ChaChaPoly encrypted Alice&#39;s X25519 static key, little endian
       inside 48 byte ChaChaPoly frame
</code></pre><p>Unencrypted data (Poly1305 auth tags not shown):</p>
<pre tabindex="0"><code>+----+----+----+----+----+----+----+----+
  |      Destination Connection ID        |
  +----+----+----+----+----+----+----+----+
  |   Packet Number   |type|frag|  flags  |
  +----+----+----+----+----+----+----+----+
  |                                       |
  +                                       +
  |              S                        |
  +       Alice static key                +
  |          (32 bytes)                   |
  +                                       +
  |                                       |
  +                                       +
  +----+----+----+----+----+----+----+----+
  |                                       |
  +                                       +
  |        Noise Payload                  |
  +        (length varies)                +
  |        see below for allowed blocks   |
  ~               .   .   .               ~
  |                                       |
  +----+----+----+----+----+----+----+----+

  Destination Connection ID :: As sent in Session Request,
                               or one received in Session Confirmed?

  Packet Number :: 0 always, for all fragments, even if retransmitted

  type :: 2

  frag :: 1 byte fragment info:
         bit order: 76543210 (bit 7 is MSB)
         bits 7-4: fragment number 0-14, big endian
         bits 3-0: total fragments 1-15, big endian

  flags :: 2 bytes, unused, set to 0 for future compatibility

  S :: 32 bytes, Alice&#39;s X25519 static key, little endian
</code></pre><h4 id="payload-2">Payload</h4>
<ul>
<li>RouterInfo block (must be the first block)</li>
<li>Options block (optional)</li>
<li>New Token block (optional)</li>
<li>Relay Request block (optional)</li>
<li>Peer Test block (optional)</li>
<li>First Packet Number block (optional)</li>
<li>I2NP, First Fragment, or Follow-on Fragment blocks (optional, but probably no room)</li>
<li>Padding block (optional)</li>
</ul>
<p>The minimum payload size is 8 bytes. Since the RouterInfo block
will be well more than that, the requirement is met with only that block.</p>
<h4 id="notes-3">Notes</h4>
<ul>
<li>
<p>Bob must perform the usual Router Info validation.
Ensure the signature type is supported, verify the signature,
verify the timestamp is within bounds, and any other checks necessary.
See below for notes on handling fragmented Router Infos.</p>
</li>
<li>
<p>Bob must verify that Alice&rsquo;s static key received in the first frame matches
the static key in the Router Info. Bob must first search the Router Info for
a NTCP or SSU2 Router Address with a matching version (v) option.
See Published Router Info and Unpublished Router Info sections below.
See below for notes on handling fragmented Router Infos.</p>
</li>
<li>
<p>If Bob has an older version of Alice&rsquo;s RouterInfo in his netdb, verify
that the static key in the router info is the same in both, if present,
and if the older version is less than XXX old (see key rotate time below)</p>
</li>
<li>
<p>Bob must validate that Alice&rsquo;s static key is a valid point on the curve here.</p>
</li>
<li>
<p>Options should be included, to specify padding parameters.</p>
</li>
<li>
<p>On any error, including AEAD, RI, DH, timestamp, or key validation failure,
Bob must halt further message processing and close the connection without
responding.</p>
</li>
<li>
<p>Message 3 part 2 frame content: This format of this frame is the same as the
format of data phase frames, except that the length of the frame is sent
by Alice in Session Request. See below for the data phase frame format.
The frame must contain 1 to 4 blocks in the following order:</p>
<ol>
<li>Alice&rsquo;s Router Info block (required)</li>
<li>Options block (optional)</li>
<li>I2NP blocks (optional)</li>
<li>Padding block (optional)
This frame must never contain any other block type.
TODO: what about relay and peer test?</li>
</ol>
</li>
<li>
<p>Message 3 part 2 padding block is recommended.</p>
</li>
<li>
<p>There may be no space, or only a small amount of space, available for
I2NP blocks, depending on the MTU and the Router Info size.
Do NOT include I2NP blocks if the Router Info is fragmented.
The simplest implementation may be to never include I2NP blocks in
the Session Confirmed message, and send all I2NP blocks in
subsequent Data messages.
See Router Info block section below for maximum block size.</p>
</li>
</ul>
<h4 id="session-confirmed-fragmentation">Session Confirmed Fragmentation</h4>
<p>The Session Confirmed message must contain the full signed Router Info from Alice so that
Bob may perform several required checks:</p>
<ul>
<li>The static key &ldquo;s&rdquo; in the RI matches the static key in the handshake</li>
<li>The introduction key &ldquo;i&rdquo; in the RI must be extracted and valid, to be used
in the data phase</li>
<li>The RI signature is valid</li>
</ul>
<p>Unfortunately, the Router Info, even when gzip compressed in the RI block, may exceed the MTU.
Therefore, the Session Confirmed may be fragmented across two or more packets.
This is the ONLY case in the SSU2 protocol where an AEAD-protected payload is fragmented
across two or more packets.</p>
<p>The headers for each packet are constructed as follows:</p>
<ul>
<li>ALL headers are short headers with the same packet number 0</li>
<li>ALL headers contain a &ldquo;frag&rdquo; field, with the fragment number and
total number of fragments</li>
<li>The unencrypted header of fragment 0 is the associated data (AD) for the &ldquo;jumbo&rdquo; message</li>
<li>Each header is encrypted using the last 24 bytes of data in THAT packet</li>
</ul>
<p>Construct the series of packets as follows:</p>
<ul>
<li>Create a single RI block (fragment 0 of 1 in the RI block frag field).
We do not use RI block fragmentation, that was for an alternate method
of solving the same problem.</li>
<li>Create a &ldquo;jumbo&rdquo; payload with the RI block and any other blocks to be included</li>
<li>Calculate the total data size (not including the header),
which is the payload size + 64 bytes for the static key and two MACs</li>
<li>Calculate the space available in each packet, which is
the MTU minus the IP header (20 or 40), minus the UDP header (8),
minus the SSU2 short header (16). Total per-packet overhead is
44 (IPv4) or 64 (IPv6).</li>
<li>Calculate the number of packets.</li>
<li>Calculate the size of the data in the last packet. It must be greater than
or equal to 24 bytes, so that header encryption will work.
If it is too small, either add a padding block, OR increase the size of the
padding block if already present, OR reduce the size of one of the other packets
so that the last packet will be big enough.</li>
<li>Create the unencrypted header for the first packet, with the total number of
fragments in the frag field, and encrypt the &ldquo;jumbo&rdquo;
payload with Noise, using the header as AD, as usual.</li>
<li>Split up the encrypted jumbo packet into fragments</li>
<li>Add an unencrypted header for each fragment 1-n</li>
<li>Encrypt the header for each fragment 0-n. Each header uses the SAME
k_header_1 and k_header_2 as defined above in the Session Confirmed KDF.</li>
<li>Transmit all fragments</li>
</ul>
<p>Reassembly process:</p>
<p>When Bob receives any Session Confirmed message, he decrypts the header,
inspects the frag field, and determines that the Session Confirmed is fragmented.
He does not (and cannot) decrypt the message until all fragments are received
and reassembled.</p>
<ul>
<li>Preserve the header for fragment 0, as it is used as the Noise AD</li>
<li>Discard the headers for other fragments before reassembly</li>
<li>Reassemble the &ldquo;jumbo&rdquo; payload, with the header for fragment 0 as AD,
and decrypt with Noise</li>
<li>Validate the RI block as usual</li>
<li>Proceed to the data phase and send ACK 0, as usual</li>
</ul>
<p>There is no mechanism for Bob to ack individual fragments. When Bob receives all
fragments, reassembles, decrypts, and validates the contents, Bob does a split()
as usual, enters the data phase, and sends an ACK of packet number 0.</p>
<p>If Alice does not receive an ACK of packet number 0, she must retransmit all
session confirmed packets as-is.</p>
<p>Examples:</p>
<p>For 1500 MTU over IPv6, max payload is 1372, RI block overhead is 5,
max (gzip compressed) RI data size is 1367 (assuming no other blocks).
With two packets, the overhead of the 2nd packet is 64, so it can hold
another 1436 bytes of payload. So two packets is enough for a compressed
RI up to 2803 bytes.</p>
<p>The largest compressed RI seen in the current network is about 1400 bytes;
therefore, in practice, two fragments should be enough, even with
a minimum 1280 MTU. The protocol allows for 15 fragments max.</p>
<p>Security analysis:</p>
<p>The integrity and security of a fragmented Session Confirmed is the same as that
of an unfragmented one. Any alteration of any fragment will cause the
Noise AEAD to fail after reassembly. The headers of the fragments after fragment
0 are only used to identify the fragment. Even if an on-path attacker had the
k_header_2 key used to encrypt the header (unlikely, derived from the handshake),
this would not allow the attacker to substitute a valid fragment.</p>
<h3 id="kdf-for-data-phase">KDF for data phase</h3>
<p>The data phase uses the header for associated data.</p>
<p>The KDF generates two cipher keys k_ab and k_ba from the chaining key ck,
using HMAC-SHA256(key, data) as defined in <a href="https://tools.ietf.org/html/rfc2104">RFC 2104</a>
.
This is the split() function, exactly as defined in the Noise spec.</p>
<pre tabindex="0"><code>// split()
  // chainKey = from handshake phase
  keydata = HKDF(chainKey, ZEROLEN, &#34;&#34;, 64)
  k_ab = keydata[0:31]
  k_ba = keydata[32:63]

  // key is k_ab for Alice to Bob
  // key is k_ba for Bob to Alice

  keydata = HKDF(key, ZEROLEN, &#34;HKDFSSU2DataKeys&#34;, 64)
  k_data = keydata[0:31]
  k_header_2 = keydata[32:63]


  // AEAD parameters
  k = k_data
  n = 4 byte packet number from header
  ad = 16 byte header, before header encryption
  ciphertext = ENCRYPT(k, n, payload, ad)

  // Header encryption keys for data phase
  // aik = Alice&#39;s intro key
  // bik = Bob&#39;s intro key
  k_header_1 = Receiver&#39;s intro key (aik or bik)
  k_header_2: from above
</code></pre><h3 id="data-message-type-6">Data Message (Type 6)</h3>
<p>Noise payload: All block types are allowed
Max payload size: MTU - 60 (IPv4) or MTU - 80 (IPv6).
For 1500 MTU: Max payload is 1440 (IPv4) or 1420 (IPv6).</p>
<p>Starting with the 2nd part of Session Confirmed, all messages are inside
an authenticated and encrypted ChaChaPoly payload.
All padding is inside the message.
Inside the payload is a standard format with zero or more &ldquo;blocks&rdquo;.
Each block has a one-byte type and a two-byte length.
Types include date/time, I2NP message, options, termination, and padding.</p>
<p>Note: Bob may, but is not required, to send his RouterInfo to Alice as
his first message to Alice in the data phase.</p>
<p>Payload Security Properties:</p>
<pre tabindex="0"><code>XK(s, rs):           Authentication   Confidentiality
    &lt;-                        2                5
    -&gt;                        2                5

    Authentication: 2.
    Sender authentication resistant to key-compromise impersonation (KCI).
    The sender authentication is based on an ephemeral-static DH (&#34;es&#34; or &#34;se&#34;)
    between the sender&#39;s static key pair and the recipient&#39;s ephemeral key pair.
    Assuming the corresponding private keys are secure, this authentication cannot be forged.

    Confidentiality: 5.
    Encryption to a known recipient, strong forward secrecy.
    This payload is encrypted based on an ephemeral-ephemeral DH as well as
    an ephemeral-static DH with the recipient&#39;s static key pair.
    Assuming the ephemeral private keys are secure, and the recipient is not being actively impersonated
    by an attacker that has stolen its static private key, this payload cannot be decrypted.
</code></pre><h4 id="notes-4">Notes</h4>
<ul>
<li>The router must drop a message with an AEAD error.</li>
</ul>
<pre tabindex="0"><code>+----+----+----+----+----+----+----+----+
  |  Short Header 16 bytes, ChaCha20      |
  +  encrypted with intro key and         +
  |  derived key, see Data Phase KDF      |
  +----+----+----+----+----+----+----+----+
  |   ChaCha20 data                       |
  +   Encrypted and authenticated data    +
  |  length varies                        |
  +  k defined in Data Phase KDF          +
  |  n = packet number from header        |
  +                                       +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |                                       |
  +        Poly1305 MAC (16 bytes)        +
  |                                       |
  +----+----+----+----+----+----+----+----+
</code></pre><p>Unencrypted data (Poly1305 auth tag not shown):</p>
<pre tabindex="0"><code>+----+----+----+----+----+----+----+----+
  |      Destination Connection ID        |
  +----+----+----+----+----+----+----+----+
  |   Packet Number   |type|    flags     |
  +----+----+----+----+----+----+----+----+
  |     Noise payload (block data)        |
  +          (length varies)              +
  |                                       |
  +----+----+----+----+----+----+----+----+

  Destination Connection ID :: As specified in session setup

  Packet Number :: 4 byte big endian integer

  type :: 6

  flags :: 3 bytes, unused, set to 0 for future compatibility
</code></pre><h4 id="notes-5">Notes</h4>
<ul>
<li>
<p>The minimum payload size is 8 bytes. This requirement will be met
by any ACK, I2NP, First Fragment, or Follow-on Fragment block.
If the requirement is not met, a Padding block must be included.</p>
</li>
<li>
<p>Each packet number may only be used once.
When retransmitting I2NP messages or fragments,
a new packet number must be used.</p>
</li>
</ul>
<h3 id="kdf-for-peer-test">KDF for Peer Test</h3>
<pre tabindex="0"><code>
// AEAD parameters
  // bik = Bob&#39;s intro key
  k = bik
  n = 4 byte packet number from header
  ad = 32 byte header, before header encryption
  ciphertext = ENCRYPT(k, n, payload, ad)

  // Header encryption keys for this message
  k_header_1 = bik
  k_header_2 = bik
</code></pre><h3 id="peer-test-type-7">Peer Test (Type 7)</h3>
<p>Charlie sends to Alice, and Alice Sends to Charlie,
for Peer Test phases 5-7 only.
Peer Test phases 1-4 must be sent in-session using a Peer Test block in a Data message.
See the Peer Test Block and Peer Test Process sections below for more information.</p>
<p>Size: 48 + payload size.</p>
<p>Noise payload: See below.</p>
<p>Raw contents:</p>
<pre tabindex="0"><code>+----+----+----+----+----+----+----+----+
  |  Long Header bytes 0-15, ChaCha20     |
  +  encrypted with Alice or Charlie      +
  |  intro key                            |
  +----+----+----+----+----+----+----+----+
  |  Long Header bytes 16-31, ChaCha20    |
  +  encrypted with Alice or Charlie      +
  |  intro key                            |
  +----+----+----+----+----+----+----+----+
  |                                       |
  +                                       +
  |   ChaCha20 encrypted data             |
  +          (length varies)              +
  |                                       |
  +  see KDF for key and n                +
  |  see KDF for associated data          |
  +----+----+----+----+----+----+----+----+
  |                                       |
  +        Poly1305 MAC (16 bytes)        +
  |                                       |
  +----+----+----+----+----+----+----+----+
</code></pre><p>Unencrypted data (Poly1305 authentication tag not shown):</p>
<pre tabindex="0"><code>+----+----+----+----+----+----+----+----+
  |      Destination Connection ID        |
  +----+----+----+----+----+----+----+----+
  |   Packet Number   |type| ver| id |flag|
  +----+----+----+----+----+----+----+----+
  |        Source Connection ID           |
  +----+----+----+----+----+----+----+----+
  |                 Token                 |
  +----+----+----+----+----+----+----+----+
  |    ChaCha20 payload (block data)      |
  +          (length varies)              +
  |    see below for allowed blocks       |
  +----+----+----+----+----+----+----+----+


  Destination Connection ID :: See below

  type :: 7

  ver :: 2

  id :: 1 byte, the network ID (currently 2, except for test networks)

  flag :: 1 byte, unused, set to 0 for future compatibility

  Packet Number :: Random number generated by Alice or Charlie

  Source Connection ID :: See below

  Token :: Randomly generated by Alice or Charlie, ignored
</code></pre><h4 id="payload-3">Payload</h4>
<ul>
<li>DateTime block</li>
<li>Address block (required for messages 6 and 7, see note below)</li>
<li>Peer Test block</li>
<li>Padding block (optional)</li>
</ul>
<p>The minimum payload size is 8 bytes. Since the Peer Test block
totals more than that, the requirement is met with only this block.</p>
<p>In messages 5 and 7, the Peer Test block may be identical to
the block from in-session messages 3 and 4,
containing the agreement signed by Charlie,
or it may be regenerated. Signature is optional.</p>
<p>In message 6, the Peer Test block may be identical to
the block from in-session messages 1 and 2,
containing the request signed by Alice,
or it may be regenerated. Signature is optional.</p>
<p>Connection IDs: The two connection IDs are derived from the test nonce.
For messages 5 and 7 sent from Charlie to Alice, the Destination Connection ID
is two copies of the 4-byte big-endian test nonce, i.e. ((nonce &laquo; 32) | nonce).
The Source Connection ID is the inverse of the Destination Connection ID,
i.e. ~((nonce &laquo; 32) | nonce).
For message 6 sent from Alice to Charlie, swap the two connection IDs.</p>
<p>Address block contents:</p>
<ul>
<li>In message 5: Not required.</li>
<li>In message 6: Charlie&rsquo;s IP and port as selected from Charlie&rsquo;s RI.</li>
<li>In message 7: Alice&rsquo;s actual IP and port message 6 was received from.</li>
</ul>
<h3 id="kdf-for-retry">KDF for Retry</h3>
<p>The requirement for the Retry message is that Bob is not required to
decrypt the Session Request message to generate a Retry message in response.
Also, this message must be fast to generate, using symmetric encryption only.</p>
<pre tabindex="0"><code>
// AEAD parameters
  // bik = Bob&#39;s intro key
  k = bik
  n = 4 byte packet number from header
  ad = 32 byte header, before header encryption
  ciphertext = ENCRYPT(k, n, payload, ad)

  // Header encryption keys for this message
  k_header_1 = bik
  k_header_2 = bik
</code></pre><h3 id="retry-type-9">Retry (Type 9)</h3>
<p>Bob sends to Alice, in response to a Session Request or Token Request message.
Alice responds with a new Session Request.
Size: 48 + payload size.</p>
<p>Also serves as a Termination message (i.e., &ldquo;Don&rsquo;t Retry&rdquo;)
if a Termination block is included.</p>
<p>Noise payload: See below.</p>
<p>Raw contents:</p>
<pre tabindex="0"><code>+----+----+----+----+----+----+----+----+
  |  Long Header bytes 0-15, ChaCha20     |
  +  encrypted with Bob intro key         +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |  Long Header bytes 16-31, ChaCha20    |
  +  encrypted with Bob intro key         +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |                                       |
  +                                       +
  |   ChaCha20 encrypted data             |
  +          (length varies)              +
  |                                       |
  +  see KDF for key and n                +
  |  see KDF for associated data          |
  +----+----+----+----+----+----+----+----+
  |                                       |
  +        Poly1305 MAC (16 bytes)        +
  |                                       |
  +----+----+----+----+----+----+----+----+
</code></pre><p>Unencrypted data (Poly1305 authentication tag not shown):</p>
<pre tabindex="0"><code>+----+----+----+----+----+----+----+----+
  |      Destination Connection ID        |
  +----+----+----+----+----+----+----+----+
  |   Packet Number   |type| ver| id |flag|
  +----+----+----+----+----+----+----+----+
  |        Source Connection ID           |
  +----+----+----+----+----+----+----+----+
  |                 Token                 |
  +----+----+----+----+----+----+----+----+
  |    ChaCha20 payload (block data)      |
  +          (length varies)              +
  |    see below for allowed blocks       |
  +----+----+----+----+----+----+----+----+


  Destination Connection ID :: The Source Connection ID
                               received from Alice in Token Request
                               or Session Request

  Packet Number :: Random number generated by Bob

  type :: 9

  ver :: 2

  id :: 1 byte, the network ID (currently 2, except for test networks)

  flag :: 1 byte, unused, set to 0 for future compatibility

  Source Connection ID :: The Destination Connection ID
                          received from Alice in Token Request
                          or Session Request

  Token :: 8 byte unsigned integer, randomly generated by Bob, nonzero,
           or zero if session is rejected and a termination block is included
</code></pre><h4 id="payload-4">Payload</h4>
<ul>
<li>DateTime block</li>
<li>Address block</li>
<li>Options block (optional)</li>
<li>Termination block (optional, if session is rejected)</li>
<li>Padding block (optional)</li>
</ul>
<p>The minimum payload size is 8 bytes. Since the DateTime and Address blocks
total more than that, the requirement is met with only those two blocks.</p>
<h4 id="notes-6">Notes</h4>
<ul>
<li>
<p>To provide probing resistance, a router should not send a Retry message
in response to a Session Request or Token Request message unless the
message type, protocol version, and network ID fields in the Request message
are valid.</p>
</li>
<li>
<p>To limit the magnitude of any amplification attack that can be mounted using spoofed source addresses,
the Retry message must not contain large amounts of padding.
It is recommended that the Retry message be no larger than three times the size
of the message it is responding to.
Alternatively, use a simple method such as adding a random amount of padding
in the range 1-64 bytes.</p>
</li>
</ul>
<h3 id="kdf-for-token-request">KDF for Token Request</h3>
<p>This message must be fast to generate, using symmetric encryption only.</p>
<pre tabindex="0"><code>
// AEAD parameters
  // bik = Bob&#39;s intro key
  k = bik
  n = 4 byte packet number from header
  ad = 32 byte header, before header encryption
  ciphertext = ENCRYPT(k, n, payload, ad)

  // Header encryption keys for this message
  k_header_1 = bik
  k_header_2 = bik
</code></pre><h3 id="token-request-type-10">Token Request (Type 10)</h3>
<p>Alice sends to Bob. Bob response with a Retry message.
Size: 48 + payload size.</p>
<p>If Alice does not have a valid token, Alice should send this message
instead of a Session Request, to avoid the asymmetric encryption
overhead in generating a Session Request.</p>
<p>Noise payload: See below.</p>
<p>Raw contents:</p>
<pre tabindex="0"><code>+----+----+----+----+----+----+----+----+
  |  Long Header bytes 0-15, ChaCha20     |
  +  encrypted with Bob intro key         +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |  Long Header bytes 16-31, ChaCha20    |
  +  encrypted with Bob intro key         +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |                                       |
  +                                       +
  |   ChaCha20 encrypted data             |
  +          (length varies)              +
  |                                       |
  +  see KDF for key and n                +
  |  see KDF for associated data          |
  +----+----+----+----+----+----+----+----+
  |                                       |
  +        Poly1305 MAC (16 bytes)        +
  |                                       |
  +----+----+----+----+----+----+----+----+
</code></pre><p>Unencrypted data (Poly1305 authentication tag not shown):</p>
<pre tabindex="0"><code>+----+----+----+----+----+----+----+----+
  |      Destination Connection ID        |
  +----+----+----+----+----+----+----+----+
  |   Packet Number   |type| ver| id |flag|
  +----+----+----+----+----+----+----+----+
  |        Source Connection ID           |
  +----+----+----+----+----+----+----+----+
  |                 Token                 |
  +----+----+----+----+----+----+----+----+
  |    ChaCha20 payload (block data)      |
  +          (length varies)              +
  |    see below for allowed blocks       |
  +----+----+----+----+----+----+----+----+


  Destination Connection ID :: Randomly generated by Alice

  Packet Number :: Random number generated by Alice

  type :: 10

  ver :: 2

  id :: 1 byte, the network ID (currently 2, except for test networks)

  flag :: 1 byte, unused, set to 0 for future compatibility

  Source Connection ID :: Randomly generated by Alice,
                          must not be equal to Destination Connection ID

  Token :: zero
</code></pre><h4 id="payload-5">Payload</h4>
<ul>
<li>DateTime block</li>
<li>Padding block</li>
</ul>
<p>The minimum payload size is 8 bytes.</p>
<h4 id="notes-7">Notes</h4>
<ul>
<li>
<p>To provide probing resistance, a router should not send a Retry message
in response to a Token Request message unless the
message type, protocol version, and network ID fields in the Token Request message
are valid.</p>
</li>
<li>
<p>This is NOT a standard Noise message and is not part of the handshake.
It is not bound to the Session Request message other than by connection IDs.</p>
</li>
<li>
<p>On most errors, including AEAD, or apparent replay
Bob should halt further message processing and
drop the message without responding.</p>
</li>
<li>
<p>Bob must reject connections where the timestamp value is too far off from the
current time. Call the maximum delta time &ldquo;D&rdquo;.  Bob must maintain a local
cache of previously-used handshake values and reject duplicates, to prevent
replay attacks. Values in the cache must have a lifetime of at least 2*D.
The cache values are implementation-dependent, however the 32-byte X value
(or its encrypted equivalent) may be used.</p>
</li>
<li>
<p>Bob MAY send a Retry message containing a zero token and a Termination block with a
clock skew reason code if the timestamp in the DateTime block is too
far skewed.</p>
</li>
<li>
<p>Minimum size: TBD, same rules as for Session Created?</p>
</li>
</ul>
<h3 id="kdf-for-hole-punch">KDF for Hole Punch</h3>
<p>This message must be fast to generate, using symmetric encryption only.</p>
<pre tabindex="0"><code>
// AEAD parameters
  // aik = Alice&#39;s intro key
  k = aik
  n = 4 byte packet number from header
  ad = 32 byte header, before header encryption
  ciphertext = ENCRYPT(k, n, payload, ad)

  // Header encryption keys for this message
  k_header_1 = aik
  k_header_2 = aik
</code></pre><h3 id="hole-punch-type-11">Hole Punch (Type 11)</h3>
<p>Charlie sends to Alice, in response to a Relay Intro received from Bob.
Alice responds with a new Session Request.
Size: 48 + payload size.</p>
<p>Noise payload: See below.</p>
<p>Raw contents:</p>
<pre tabindex="0"><code>+----+----+----+----+----+----+----+----+
  |  Long Header bytes 0-15, ChaCha20     |
  +  encrypted with Alice intro key       +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |  Long Header bytes 16-31, ChaCha20    |
  +  encrypted with Alice intro key       +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |                                       |
  +                                       +
  |   ChaCha20 encrypted data             |
  +          (length varies)              +
  |                                       |
  +  see KDF for key and n                +
  |  see KDF for associated data          |
  +----+----+----+----+----+----+----+----+
  |                                       |
  +        Poly1305 MAC (16 bytes)        +
  |                                       |
  +----+----+----+----+----+----+----+----+
</code></pre><p>Unencrypted data (Poly1305 authentication tag not shown):</p>
<pre tabindex="0"><code>+----+----+----+----+----+----+----+----+
  |      Destination Connection ID        |
  +----+----+----+----+----+----+----+----+
  |   Packet Number   |type| ver| id |flag|
  +----+----+----+----+----+----+----+----+
  |        Source Connection ID           |
  +----+----+----+----+----+----+----+----+
  |                 Token                 |
  +----+----+----+----+----+----+----+----+
  |    ChaCha20 payload (block data)      |
  +          (length varies)              +
  |    see below for allowed blocks       |
  +----+----+----+----+----+----+----+----+


  Destination Connection ID :: See below

  Packet Number :: Random number generated by Charlie

  type :: 11

  ver :: 2

  id :: 1 byte, the network ID (currently 2, except for test networks)

  flag :: 1 byte, unused, set to 0 for future compatibility

  Source Connection ID :: See below

  Token :: 8 byte unsigned integer, randomly generated by Charlie, nonzero.
</code></pre><h4 id="payload-6">Payload</h4>
<ul>
<li>DateTime block</li>
<li>Address block</li>
<li>Relay Response block</li>
<li>Padding block (optional)</li>
</ul>
<p>The minimum payload size is 8 bytes. Since the DateTime and Address blocks
total more than that, the requirement is met with only those two blocks.</p>
<p>Connection IDs: The two connection IDs are derived from the relay nonce.
The Destination Connection ID
is two copies of the 4-byte big-endian relay nonce, i.e. ((nonce &laquo; 32) | nonce).
The Source Connection ID is the inverse of the Destination Connection ID,
i.e. ~((nonce &laquo; 32) | nonce).</p>
<p>Alice should ignore the token in the header. The token to be used in
the Session Request is in the Relay Response block.</p>
<h2 id="noise-payload">Noise Payload</h2>
<p>Each Noise payload contains zero or more &ldquo;blocks&rdquo;.</p>
<p>This uses the same block format as defined in the <a href="../../../en/docs/specs/ntcp2/">NTCP2</a>
 and <a href="../../../en/docs/specs/ecies/">ECIES</a>
 specifications.
Individual block types are defined differently.
The equivalent term in QUIC <a href="https://datatracker.ietf.org/doc/html/rfc9000">RFC 9000</a>
 is &ldquo;frames&rdquo;.</p>
<p>There are concerns that encouraging implementers to share code
may lead to parsing issues. Implementers should carefully consider
the benefits and risks of sharing code, and ensure that the
ordering and valid block rules are different for the two contexts.</p>
<h3 id="payload-format">Payload Format</h3>
<p>There are one or more blocks in the encrypted payload.
A block is a simple Tag-Length-Value (TLV) format.
Each block contains a one-byte identifier, a two-byte length,
and zero or more bytes of data.
This format is identical to that in <a href="../../../en/docs/specs/ntcp2/">NTCP2</a>
 and <a href="../../../en/docs/specs/ecies/">ECIES</a>
,
however the block definitions are different.</p>
<p>For extensibility, receivers must ignore blocks with unknown identifiers,
and treat them as padding.</p>
<p>(Poly1305 auth tag not shown):</p>
<pre tabindex="0"><code>+----+----+----+----+----+----+----+----+
  |blk |  size   |       data             |
  +----+----+----+                        +
  |                                       |
  ~               .   .   .               ~
  |                                       |
  +----+----+----+----+----+----+----+----+
  |blk |  size   |       data             |
  +----+----+----+                        +
  |                                       |
  ~               .   .   .               ~
  |                                       |
  +----+----+----+----+----+----+----+----+
  ~               .   .   .               ~

  blk :: 1 byte, see below
  size :: 2 bytes, big endian, size of data to follow, 0 - TBD
  data :: the data
</code></pre><p>Header encryption uses the last 24 bytes of the packet as the IV for the two
ChaCha20 operations. As all packets end with a 16 byte MAC,
this requires that all packet payloads are a minimum of 8 bytes.
If a payload would not otherwise meet this requirement,
a Padding block must be included.</p>
<p>Maximum ChaChaPoly payload varies based on message type, MTU,
and IPv4 or IPv6 address type.
Maximum payload is MTU - 60 for IPv4 and MTU - 80 for IPv6.
Maximum payload data is MTU - 63 for IPv4 and MTU - 83 for IPv6.
Upper limit is about 1440 bytes for IPv4, 1500 MTU, Data message.
Maximum total block size is the maximum payload size.
Maximum single block size is the maximum total block size.
Block type is 1 byte.
Block length is 2 bytes.
Maximum single block data size is the maximum single block size minus 3.</p>
<p>Notes:</p>
<ul>
<li>
<p>Implementers must ensure that when reading a block,
malformed or malicious data will not cause reads to
overrun into the next block or beyond the payload boundary.</p>
</li>
<li>
<p>Implementations should ignore unknown block types for
forward compatibility.</p>
</li>
</ul>
<p>Block types:</p>
<table>
  <thead>
      <tr>
          <th>Payload Block Type</th>
          <th>Type Number</th>
          <th>Block Length</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>DateTime</td>
          <td>0</td>
          <td>7</td>
      </tr>
      <tr>
          <td>Options</td>
          <td>1</td>
          <td>15+</td>
      </tr>
      <tr>
          <td>Router Info</td>
          <td>2</td>
          <td>varies</td>
      </tr>
      <tr>
          <td>I2NP Message</td>
          <td>3</td>
          <td>varies</td>
      </tr>
      <tr>
          <td>First Fragment</td>
          <td>4</td>
          <td>varies</td>
      </tr>
      <tr>
          <td>Follow-on Fragment</td>
          <td>5</td>
          <td>varies</td>
      </tr>
      <tr>
          <td>Termination</td>
          <td>6</td>
          <td>9 typ.</td>
      </tr>
      <tr>
          <td>Relay Request</td>
          <td>7</td>
          <td>varies</td>
      </tr>
      <tr>
          <td>Relay Response</td>
          <td>8</td>
          <td>varies</td>
      </tr>
      <tr>
          <td>Relay Intro</td>
          <td>9</td>
          <td>varies</td>
      </tr>
      <tr>
          <td>Peer Test</td>
          <td>10</td>
          <td>varies</td>
      </tr>
      <tr>
          <td>Next Nonce</td>
          <td>11</td>
          <td>TBD</td>
      </tr>
      <tr>
          <td>ACK</td>
          <td>12</td>
          <td>varies</td>
      </tr>
      <tr>
          <td>Address</td>
          <td>13</td>
          <td>9 or 21</td>
      </tr>
      <tr>
          <td>reserved</td>
          <td>14</td>
          <td>&ndash;</td>
      </tr>
      <tr>
          <td>Relay Tag Request</td>
          <td>15</td>
          <td>3</td>
      </tr>
      <tr>
          <td>Relay Tag</td>
          <td>16</td>
          <td>7</td>
      </tr>
      <tr>
          <td>New Token</td>
          <td>17</td>
          <td>15</td>
      </tr>
      <tr>
          <td>Path Challenge</td>
          <td>18</td>
          <td>varies</td>
      </tr>
      <tr>
          <td>Path Response</td>
          <td>19</td>
          <td>varies</td>
      </tr>
      <tr>
          <td>First Packet Number</td>
          <td>20</td>
          <td>7</td>
      </tr>
      <tr>
          <td>Congestion</td>
          <td>21</td>
          <td>4</td>
      </tr>
      <tr>
          <td>reserved for experimental features</td>
          <td>224-253</td>
          <td></td>
      </tr>
      <tr>
          <td>Padding</td>
          <td>254</td>
          <td>varies</td>
      </tr>
      <tr>
          <td>reserved for future extension</td>
          <td>255</td>
          <td></td>
      </tr>
  </tbody>
</table>
<h3 id="block-ordering-rules">Block Ordering Rules</h3>
<p>In the Session Confirmed, Router Info must be the first block.</p>
<p>In all other messages, order is unspecified, except for the
following requirements:
Padding, if present, must be the last block.
Termination, if present, must be the last block except for Padding.
Multiple Padding blocks are not allowed in a single payload.</p>
<h3 id="block-specifications">Block Specifications</h3>
<h4 id="datetime">DateTime</h4>
<p>For time synchronization:</p>
<pre tabindex="0"><code>+----+----+----+----+----+----+----+
  | 0  |    4    |     timestamp     |
  +----+----+----+----+----+----+----+

  blk :: 0
  size :: 2 bytes, big endian, value = 4
  timestamp :: Unix timestamp, unsigned seconds.
               Wraps around in 2106
</code></pre><p>Notes:</p>
<ul>
<li>Unlike in SSU 1, there is no timestamp in the packet header
for the data phase in SSU 2.</li>
<li>Implementations should periodically send DateTime blocks
in the data phase.</li>
<li>Implementations must round to the nearest second to prevent clock bias in the network.</li>
</ul>
<h4 id="options">Options</h4>
<p>Pass updated options.
Options include: Min and max padding.</p>
<p>Options block will be variable length.</p>
<pre tabindex="0"><code>+----+----+----+----+----+----+----+----+
  | 1  |  size   |tmin|tmax|rmin|rmax|tdmy|
  +----+----+----+----+----+----+----+----+
  |tdmy|  rdmy   |  tdelay |  rdelay |    |
  ~----+----+----+----+----+----+----+    ~
  |              more_options             |
  ~               .   .   .               ~
  |                                       |
  +----+----+----+----+----+----+----+----+

  blk :: 1
  size :: 2 bytes, big endian, size of options to follow, 12 bytes minimum

  tmin, tmax, rmin, rmax :: requested padding limits
      tmin and rmin are for desired resistance to traffic analysis.
      tmax and rmax are for bandwidth limits.
      tmin and tmax are the transmit limits for the router sending this options block.
      rmin and rmax are the receive limits for the router sending this options block.
      Each is a 4.4 fixed-point float representing 0 to 15.9375
      (or think of it as an unsigned 8-bit integer divided by 16.0).
      This is the ratio of padding to data. Examples:
      Value of 0x00 means no padding
      Value of 0x01 means add 6 percent padding
      Value of 0x10 means add 100 percent padding
      Value of 0x80 means add 800 percent (8x) padding
      Alice and Bob will negotiate the minimum and maximum in each direction.
      These are guidelines, there is no enforcement.
      Sender should honor receiver&#39;s maximum.
      Sender may or may not honor receiver&#39;s minimum, within bandwidth constraints.

  tdmy: Max dummy traffic willing to send, 2 bytes big endian, bytes/sec average
  rdmy: Requested dummy traffic, 2 bytes big endian, bytes/sec average
  tdelay: Max intra-message delay willing to insert, 2 bytes big endian, msec average
  rdelay: Requested intra-message delay, 2 bytes big endian, msec average

  Padding distribution specified as additional parameters?
  Random delay specified as additional parameters?

  more_options :: Format TBD
</code></pre><p>Options Issues:</p>
<ul>
<li>Options negotiation is TBD.</li>
</ul>
<h4 id="routerinfo">RouterInfo</h4>
<p>Pass Alice&rsquo;s RouterInfo to Bob.
Used in Session Confirmed part 2 payload only.
Not to be used in the data phase; use an
I2NP DatabaseStore Message instead.</p>
<p>Minimum Size: About 420 bytes, unless the router identity and
signature in the router info are compressible, which is unlikely.</p>
<p>NOTE: The Router Info block is never fragmented.
The frag field is always 0/1.
See the Session Confirmed Fragmentation section above for more information.</p>
<pre tabindex="0"><code>+----+----+----+----+----+----+----+----+
  | 2  |  size   |flag|frag|              |
  +----+----+----+----+----+              +
  |                                       |
  +       Router Info fragment            +
  | (Alice RI in Session Confirmed)       |
  + (Alice, Bob, or third-party           +
  |  RI in data phase)                    |
  ~               .   .   .               ~
  |                                       |
  +----+----+----+----+----+----+----+----+

  blk :: 2
  size :: 2 bytes, big endian, 2 + fragment size
  flag :: 1 byte flags
         bit order: 76543210 (bit 7 is MSB)
         bit 0: 0 for local store, 1 for flood request
         bit 1: 0 for uncompressed, 1 for gzip compressed
         bits 7-2: Unused, set to 0 for future compatibility
  frag :: 1 byte fragment info:
         bit order: 76543210 (bit 7 is MSB)
         bits 7-4: fragment number, always 0
         bits 3-0: total fragments, always 1, big endian

  routerinfo :: Alice&#39;s or Bob&#39;s RouterInfo
</code></pre><p>Notes:</p>
<ul>
<li>
<p>The Router Info is optionally compressed with gzip,
as indicated by flag bit 1.
This is different from NTCP2, where it is never compressed,
and from a DatabaseStore Message, where it always is compressed.
Compression is optional because it usually is of little benefit
for small Router Infos, where there is little compressible content,
but is very beneficial for large Router Infos with several
compressible Router Addresses.
Compression is recommended if it allows a Router Info to fit
in a single Session Confirmed packet without fragmentation.</p>
</li>
<li>
<p>Maximum size of first or only fragment in the Session Confirmed message:
MTU - 113 for IPv4 or MTU - 133 for IPv6.
Assuming 1500 byte default MTU, and no other blocks in the message,
1387 for IPv4 or 1367 for IPv6.
97% of current router infos are smaller than 1367 witout gzipping.
99.9% of current router infos are smaller than 1367 when gzipped.
Assuming 1280 byte minimum MTU, and no other blocks in the message,
1167 for IPv4 or 1147 for IPv6.
94% of current router infos are smaller than 1147 witout gzipping.
97% of current router infos are smaller than 1147 when gzipped.</p>
</li>
<li>
<p>The frag byte is now unused, the Router Info block is never fragmented.
The frag byte must be set to fragment 0, total fragments 1.
See the Session Confirmed Fragmentation section above for more information.</p>
</li>
<li>
<p>Flooding must not be requested unless there are published
RouterAddresses in the RouterInfo. The receiving router
must not flood the RouterInfo unless there are published
RouterAddresses in it.</p>
</li>
<li>
<p>This protocol does not provide an acknowledgment that the RouterInfo
was stored or flooded.
If acknowledgment is desired, and the receiver is floodfill,
the sender should instead send a standard I2NP DatabaseStoreMessage
with a reply token.</p>
</li>
</ul>
<h4 id="i2np-message">I2NP Message</h4>
<p>A complete I2NP message with a modified header.</p>
<p>This uses the same 9 bytes for the I2NP header
as in <a href="../../../en/docs/specs/ntcp2/">NTCP2</a>
 (type, message id, short expiration).</p>
<pre tabindex="0"><code>+----+----+----+----+----+----+----+----+
  | 3  |  size   |type|    msg id         |
  +----+----+----+----+----+----+----+----+
  |   short exp       |     message       |
  +----+----+----+----+                   +
  |                                       |
  ~               .   .   .               ~
  |                                       |
  +----+----+----+----+----+----+----+----+

  blk :: 3
  size :: 2 bytes, big endian, size of type + msg id + exp + message to follow
          I2NP message body size is (size - 9).
  type :: 1 byte, I2NP msg type, see I2NP spec
  msg id :: 4 bytes, big endian, I2NP message ID
  short exp :: 4 bytes, big endian, I2NP message expiration, Unix timestamp, unsigned seconds.
               Wraps around in 2106
  message :: I2NP message body
</code></pre><p>Notes:</p>
<ul>
<li>
<p>This is the same 9-byte I2NP header format used in NTCP2.</p>
</li>
<li>
<p>This is exactly the same format as the First Fragment block,
but the block type indicates that this is a complete message.</p>
</li>
<li>
<p>Maximum size including 9-byte I2NP header is MTU - 63 for IPv4 and MTU - 83 for IPv6.</p>
</li>
</ul>
<h4 id="first-fragment">First Fragment</h4>
<p>The first fragment (fragment #0) of an I2NP message with a modified header.</p>
<p>This uses the same 9 bytes for the I2NP header
as in <a href="../../../en/docs/specs/ntcp2/">NTCP2</a>
 (type, message id, short expiration).</p>
<p>Total number of fragments is not specified.</p>
<pre tabindex="0"><code>+----+----+----+----+----+----+----+----+
  | 4  |  size   |type|    msg id         |
  +----+----+----+----+----+----+----+----+
  |   short exp       |                   |
  +----+----+----+----+                   +
  |          partial message              |
  ~               .   .   .               ~
  |                                       |
  +----+----+----+----+----+----+----+----+

  blk :: 4
  size :: 2 bytes, big endian, size of data to follow
          Fragment size is (size - 9).
  type :: 1 byte, I2NP msg type, see I2NP spec
  msg id :: 4 bytes, big endian, I2NP message ID
  short exp :: 4 bytes, big endian, I2NP message expiration, Unix timestamp, unsigned seconds.
               Wraps around in 2106
  message :: Partial I2NP message body, bytes 0 - (size - 10)
</code></pre><p>Notes:</p>
<ul>
<li>
<p>This is the same 9-byte I2NP header format used in NTCP2.</p>
</li>
<li>
<p>This is exactly the same format as the I2NP Message block,
but the block type indicates that this is a the first fragment of a message.</p>
</li>
<li>
<p>Partial message length must be greater than zero.</p>
</li>
<li>
<p>As in SSU 1, it is recommended to send the last fragment first,
so that the receiver knows the total number of fragments and can
efficiently allocate receive buffers.</p>
</li>
<li>
<p>Maximum size including 9-byte I2NP header is MTU - 63 for IPv4 and MTU - 83 for IPv6.</p>
</li>
</ul>
<h4 id="follow-on-fragment">Follow-on Fragment</h4>
<p>An additional fragment (fragment number greater than zero) of an I2NP message.</p>
<pre tabindex="0"><code>+----+----+----+----+----+----+----+----+
  | 5  |  size   |frag|    msg id         |
  +----+----+----+----+----+----+----+----+
  |                                       |
  +                                       +
  |          partial message              |
  ~               .   .   .               ~
  |                                       |
  +----+----+----+----+----+----+----+----+

  blk :: 5
  size :: 2 bytes, big endian, size of data to follow
          Fragment size is (size - 5).
  frag :: Fragment info:
          Bit order: 76543210 (bit 7 is MSB)
          bits 7-1: fragment number 1 - 127 (0 not allowed)
          bit 0: isLast (1 = true)
  msg id :: 4 bytes, big endian, I2NP message ID
  message :: Partial I2NP message body
</code></pre><p>Notes:</p>
<ul>
<li>
<p>Partial message length must be greater than zero.</p>
</li>
<li>
<p>As in SSU 1, it is recommended to send the last fragment first,
so that the receiver knows the total number of fragments and can
efficiently allocate receive buffers.</p>
</li>
<li>
<p>As in SSU 1, the maximum fragment number is 127, but the practical
limit is 63 or less. Implementations may limit the maximum to
what is practical for a maximum I2NP message size of about 64 KB,
which is about 55 fragments with a 1280 minimum MTU.
See the Max I2NP Message Size section below.</p>
</li>
<li>
<p>Maximum partial message size (not including frag and message id) is MTU - 68 for IPv4 and MTU - 88 for IPv6.</p>
</li>
</ul>
<h4 id="termination">Termination</h4>
<p>Drop the connection.
This must be the last non-padding block in the payload.</p>
<pre tabindex="0"><code>+----+----+----+----+----+----+----+----+
  | 6  |  size   |    valid data packets  |
  +----+----+----+----+----+----+----+----+
      received   | rsn|     addl data     |
  +----+----+----+----+                   +
  ~               .   .   .               ~
  +----+----+----+----+----+----+----+----+

  blk :: 6
  size :: 2 bytes, big endian, value = 9 or more
  valid data packets received :: The number of valid packets received
                                (current receive nonce value)
                                0 if error occurs in handshake phase
                                8 bytes, big endian
  rsn :: reason, 1 byte:
         0: normal close or unspecified
         1: termination received
         2: idle timeout
         3: router shutdown
         4: data phase AEAD failure
         5: incompatible options
         6: incompatible signature type
         7: clock skew
         8: padding violation
         9: AEAD framing error
         10: payload format error
         11: Session Request error
         12: Session Created error
         13: Session Confirmed error
         14: Timeout
         15: RI signature verification fail
         16: s parameter missing, invalid, or mismatched in RouterInfo
         17: banned
         18: bad token
         19: connection limits
         20: incompatible version
         21: wrong net ID
         22: replaced by new session
  addl data :: optional, 0 or more bytes, for future expansion, debugging,
               or reason text.
               Format unspecified and may vary based on reason code.
</code></pre><p>Notes:</p>
<ul>
<li>Not all reasons may actually be used, implementation dependent.
Most failures will generally result in the message being dropped, not a termination.
See notes in handshake message sections above.
Additional reasons listed are for consistency, logging, debugging, or if policy changes.</li>
<li>It is recommended that an ACK block be included with the Termination block.</li>
<li>In the data phase, for any reason other than &ldquo;termination received&rdquo;,
the peer should respond with a termination block with the reason &ldquo;termination received&rdquo;.</li>
</ul>
<h4 id="relayrequest">RelayRequest</h4>
<p>Sent in a Data message in-session, from Alice to Bob.
See Relay Process section below.</p>
<pre tabindex="0"><code>+----+----+----+----+----+----+----+----+
  |  7 |  size   |flag|       nonce       |
  +----+----+----+----+----+----+----+----+
  |     relay tag     |     timestamp     |
  +----+----+----+----+----+----+----+----+
  | ver| asz|AlicePort|  Alice IP address |
  +----+----+----+----+----+----+----+----+
  |              signature                |
  +            length varies              +
  |         64 bytes for Ed25519          |
  ~                                       ~
  |                 . . .                 |
  +----+----+----+----+----+----+----+----+

  blk :: 7
  size :: 2 bytes, big endian, size of data to follow
  flag :: 1 byte flags, Unused, set to 0 for future compatibility

  The data below here is covered
  by the signature, and Bob forwards it unmodified.

  nonce :: 4 bytes, randomly generated by Alice
  relay tag :: 4 bytes, the itag from Charlie&#39;s RI
  timestamp :: Unix timestamp, unsigned seconds.
               Wraps around in 2106
  ver ::  1 byte SSU version to be used for the introduction:
         1: SSU 1
         2: SSU 2
  asz :: 1 byte endpoint (port + IP) size (6 or 18)
  AlicePort :: 2 byte Alice&#39;s port number, big endian
  Alice IP :: (asz - 2) byte representation of Alice&#39;s IP address,
              network byte order
  signature :: length varies, 64 bytes for Ed25519.
               Signature of prologue, Bob&#39;s hash,
               and signed data above, as signed by
               Alice.
</code></pre><p>Notes:</p>
<ul>
<li>The IP address is always included (unlike in SSU 1)
and may be different than the IP used for the session.</li>
</ul>
<p>Signature:</p>
<p>Alice signs the request and includes it in this block; Bob forwards it in the Relay Intro block to Charlie.
Signature algorithm: Sign the following data with the Alice&rsquo;s router signing key:</p>
<ul>
<li>prologue: 16 bytes &ldquo;RelayRequestData&rdquo;, not null-terminated (not included in the message)</li>
<li>bhash: Bob&rsquo;s 32-byte router hash (not included in the message)</li>
<li>chash: Charlie&rsquo;s 32-byte router hash (not included in the message)</li>
<li>nonce: 4 byte nonce</li>
<li>relay tag: 4 byte relay tag</li>
<li>timestamp: 4 byte timestamp (seconds)</li>
<li>ver: 1 byte SSU version</li>
<li>asz: 1 byte endpoint (port + IP) size (6 or 18)</li>
<li>AlicePort: 2 byte Alice&rsquo;s port number</li>
<li>Alice IP: (asz - 2) byte Alice IP address</li>
</ul>
<h4 id="relayresponse">RelayResponse</h4>
<p>Sent in a Data message in-session, from Charlie to Bob
or from Bob to Alice, AND in the Hole Punch message
from Charlie to Alice.
See Relay Process section below.</p>
<pre tabindex="0"><code>+----+----+----+----+----+----+----+----+
  |  8 |  size   |flag|code|    nonce
  +----+----+----+----+----+----+----+----+
       |     timestamp     | ver| csz|Char
  +----+----+----+----+----+----+----+----+
   Port|   Charlie IP addr |              |
  +----+----+----+----+----+              +
  |              signature                |
  +            length varies              +
  |         64 bytes for Ed25519          |
  ~                                       ~
  |                 . . .                 |
  +----+----+----+----+----+----+----+----+
  |                 Token                 |
  +----+----+----+----+----+----+----+----+

  blk :: 8
  size :: 2 bytes, 6
  flag :: 1 byte flags, Unused, set to 0 for future compatibility
  code :: 1 byte status code:
         0: accept
         1: rejected by Bob, reason unspecified
         2: rejected by Bob, Charlie is banned
         3: rejected by Bob, limit exceeded
         4: rejected by Bob, signature failure
         5: rejected by Bob, relay tag not found
         6: rejected by Bob, Alice RI not found
         7-63: other rejected by Bob codes TBD
         64: rejected by Charlie, reason unspecified
         65: rejected by Charlie, unsupported address
         66: rejected by Charlie, limit exceeded
         67: rejected by Charlie, signature failure
         68: rejected by Charlie, Alice is already connected
         69: rejected by Charlie, Alice is banned
         70: rejected by Charlie, Alice is unknown
         71-127: other rejected by Charlie codes TBD
         128: reject, source and reason unspecified
         129-255: other reject codes TBD

  The data below is covered by the signature if the code is 0 (accept).
  Bob forwards it unmodified.

  nonce :: 4 bytes, as received from Bob or Alice

  The data below is present only if the code is 0 (accept).

  timestamp :: Unix timestamp, unsigned seconds.
               Wraps around in 2106
  ver ::  1 byte SSU version to be used for the introduction:
         1: SSU 1
         2: SSU 2
  csz :: 1 byte endpoint (port + IP) size (0 or 6 or 18)
         may be 0 for some rejection codes
  CharliePort :: 2 byte Charlie&#39;s port number, big endian
                 not present if csz is 0
  Charlie IP :: (csz - 2) byte representation of Charlie&#39;s IP address,
                network byte order
                not present if csz is 0
  signature :: length varies, 64 bytes for Ed25519.
               Signature of prologue, Bob&#39;s hash,
               and signed data above, as signed by
               Charlie.
               Not present if rejected by Bob.
  token :: Token generated by Charlie for Alice to use
           in the Session Request.
           Only present if code is 0 (accept)
</code></pre><p>Notes:</p>
<p>The token must be used immediately by Alice in the Session Request.</p>
<p>Signature:</p>
<p>If Charlie agrees (response code 0) or rejects (response code 64 or higher),
Charlie signs the response and includes it in this block; Bob forwards it in the Relay Response block to Alice.
Signature algorithm: Sign the following data with the Charlie&rsquo;s router signing key:</p>
<ul>
<li>prologue: 16 bytes &ldquo;RelayAgreementOK&rdquo;, not null-terminated (not included in the message)</li>
<li>bhash: Bob&rsquo;s 32-byte router hash (not included in the message)</li>
<li>nonce: 4 byte nonce</li>
<li>timestamp: 4 byte timestamp (seconds)</li>
<li>ver: 1 byte SSU version</li>
<li>csz: 1 byte endpoint (port + IP) size (0 or 6 or 18)</li>
<li>CharliePort: 2 byte Charlie&rsquo;s port number (not present if csz is 0)</li>
<li>Charlie IP: (csz - 2) byte Charlie IP address (not present if csz is 0)</li>
</ul>
<p>If Bob rejects (response code 1-63),
Bob signs the response and includes it in this block.
Signature algorithm: Sign the following data with the Bob&rsquo;s router signing key:</p>
<ul>
<li>prologue: 16 bytes &ldquo;RelayAgreementOK&rdquo;, not null-terminated (not included in the message)</li>
<li>bhash: Bob&rsquo;s 32-byte router hash (not included in the message)</li>
<li>nonce: 4 byte nonce</li>
<li>timestamp: 4 byte timestamp (seconds)</li>
<li>ver: 1 byte SSU version</li>
<li>csz: 1 byte = 0</li>
</ul>
<h4 id="relayintro">RelayIntro</h4>
<p>Sent in a Data message in-session, from Bob to Charlie.
See Relay Process section below.</p>
<p>Must be preceded by a RouterInfo block, or I2NP DatabaseStore message block (or fragment),
containing Alice&rsquo;s Router Info,
either in the same payload (if there&rsquo;s room), or in a previous message.</p>
<pre tabindex="0"><code>+----+----+----+----+----+----+----+----+
  |  9 |  size   |flag|                   |
  +----+----+----+----+                   +
  |                                       |
  +                                       +
  |         Alice Router Hash             |
  +             32 bytes                  +
  |                                       |
  +                   +----+----+----+----+
  |                   |      nonce        |
  +----+----+----+----+----+----+----+----+
  |     relay tag     |     timestamp     |
  +----+----+----+----+----+----+----+----+
  | ver| asz|AlicePort|  Alice IP address |
  +----+----+----+----+----+----+----+----+
  |              signature                |
  +            length varies              +
  |         64 bytes for Ed25519          |
  ~                                       ~
  |                 . . .                 |
  +----+----+----+----+----+----+----+----+

  blk :: 9
  size :: 2 bytes, big endian, size of data to follow
  flag :: 1 byte flags, Unused, set to 0 for future compatibility
  hash :: Alice&#39;s 32-byte router hash,

  The data below here is covered
  by the signature, as received from Alice in the Relay Request,
  and Bob forwards it unmodified.

  nonce :: 4 bytes, as received from Alice
  relay tag :: 4 bytes, the itag from Charlie&#39;s RI
  timestamp :: Unix timestamp, unsigned seconds.
               Wraps around in 2106
  ver ::  1 byte SSU version to be used for the introduction:
         1: SSU 1
         2: SSU 2
  asz :: 1 byte endpoint (port + IP) size (6 or 18)
  AlicePort :: 2 byte Alice&#39;s port number, big endian
  Alice IP :: (asz - 2) byte representation of Alice&#39;s IP address,
              network byte order
  signature :: length varies, 64 bytes for Ed25519.
               Signature of prologue, Bob&#39;s hash,
               and signed data above, as signed by
               Alice.
</code></pre><p>Notes:</p>
<ul>
<li>
<p>For IPv4, Alice&rsquo;s IP address is always 4 bytes, because Alice is trying to connect to Charlie via IPv4.
IPv6 is supported, and Alice&rsquo;s IP address may be 16 bytes.</p>
</li>
<li>
<p>For IPv4, this message must be sent via an established IPv4 connection,
as that&rsquo;s the only way that Bob knows Charlie&rsquo;s IPv4 address to return to Alice in the RelayResponse_.
IPv6 is supported, and this message may be sent via an established IPv6 connection.</p>
</li>
<li>
<p>Any SSU address published with introducers must contain &ldquo;4&rdquo; or &ldquo;6&rdquo; in the &ldquo;caps&rdquo; option.</p>
</li>
</ul>
<p>Signature:</p>
<p>Alice signs the request and Bob forwards it in this block to Charlie.
Verification algorithm: Verify the following data with the Alice&rsquo;s router signing key:</p>
<ul>
<li>prologue: 16 bytes &ldquo;RelayRequestData&rdquo;, not null-terminated (not included in the message)</li>
<li>bhash: Bob&rsquo;s 32-byte router hash (not included in the message)</li>
<li>chash: Charlie&rsquo;s 32-byte router hash (not included in the message)</li>
<li>nonce: 4 byte nonce</li>
<li>relay tag: 4 byte relay tag</li>
<li>timestamp: 4 byte timestamp (seconds)</li>
<li>ver: 1 byte SSU version</li>
<li>asz: 1 byte endpoint (port + IP) size (6 or 18)</li>
<li>AlicePort: 2 byte Alice&rsquo;s port number</li>
<li>Alice IP: (asz - 2) byte Alice IP address</li>
</ul>
<h4 id="peertest">PeerTest</h4>
<p>Sent either in a Data message in-session,
or a Peer Test message out-of-session.
See Peer Test Process section below.</p>
<p>For message 2,
must be preceded by a RouterInfo block, or I2NP DatabaseStore message block (or fragment),
containing Alice&rsquo;s Router Info,
either in the same payload (if there&rsquo;s room), or in a previous message.</p>
<p>For message 4, if the relay is accepted (reason code 0),
must be preceded by a RouterInfo block, or I2NP DatabaseStore message block (or fragment),
containing Charlie&rsquo;s Router Info,
either in the same payload (if there&rsquo;s room), or in a previous message.</p>
<pre tabindex="0"><code>+----+----+----+----+----+----+----+----+
  | 10 |  size   | msg|code|flag|         |
  +----+----+----+----+----+----+         +
  | Alice router hash (message 2 only)    |
  +             or                        +
  | Charlie router hash (message 4 only)  |
  + or all zeros if rejected by Bob       +
  | Not present in messages 1,3,5,6,7     |
  +                             +----+----+
  |                             | ver|
  +----+----+----+----+----+----+----+----+
     nonce       |     timestamp     | asz|
  +----+----+----+----+----+----+----+----+
  |AlicePort|  Alice IP address |         |
  +----+----+----+----+----+----+         +
  |              signature                |
  +            length varies              +
  |         64 bytes for Ed25519          |
  ~                                       ~
  |                 . . .                 |
  +----+----+----+----+----+----+----+----+

  blk :: 10
  size :: 2 bytes, big endian, size of data to follow
  msg :: 1 byte message number 1-7
  code :: 1 byte status code:
         0: accept
         1: rejected by Bob, reason unspecified
         2: rejected by Bob, no Charlie available
         3: rejected by Bob, limit exceeded
         4: rejected by Bob, signature failure
         5: rejected by Bob, address unsupported
         6-63: other rejected by Bob codes TBD
         64: rejected by Charlie, reason unspecified
         65: rejected by Charlie, unsupported address
         66: rejected by Charlie, limit exceeded
         67: rejected by Charlie, signature failure
         68: rejected by Charlie, Alice is already connected
         69: rejected by Charlie, Alice is banned
         70: rejected by Charlie, Alice is unknown
         70-127: other rejected by Charlie codes TBD
         128: reject, source and reason unspecified
         129-255: other reject codes TBD
         reject codes only allowed in messages 3 and 4
  flag :: 1 byte flags, Unused, set to 0 for future compatibility
  hash :: Alice&#39;s or Charlie&#39;s 32-byte router hash,
          only present in messages 2 and 4.
          All zeros (fake hash) in message 4 if rejected by Bob.

  For messages 1-4, the data below here is covered
  by the signature, if present, and Bob forwards it unmodified.

  ver :: 1 byte SSU version:
         1: SSU 1 (not supported)
         2: SSU 2 (required)
  nonce :: 4 byte test nonce, big endian
  timestamp :: Unix timestamp, unsigned seconds.
               Wraps around in 2106
  asz :: 1 byte endpoint (port + IP) size (6 or 18)
  AlicePort :: 2 byte Alice&#39;s port number, big endian
  Alice IP :: (asz - 2) byte representation of Alice&#39;s IP address,
              network byte order
  signature :: length varies, 64 bytes for Ed25519.
               Signature of prologue, Bob&#39;s hash,
               and signed data above, as signed by
               Alice or Charlie.
               Only present for messages 1-4.
               Optional in message 5-7.
</code></pre><p>Notes:</p>
<ul>
<li>
<p>Unlike in SSU 1, message 1 must include Alice&rsquo;s IP address and port.</p>
</li>
<li>
<p>Testing of IPv6 addresses is supported,
and Alice-Bob and Alice-Charlie communication may be via IPv6,
if Bob and Charlie indicate support with a &lsquo;B&rsquo; capability in their published IPv6 address.
See Proposal 126 for details.</p>
<p>Alice sends the request to Bob using an existing session over the transport (IPv4 or IPv6) that she wishes to test.
When Bob receives a request from Alice via IPv4, Bob must select a Charlie that advertises an IPv4 address.
When Bob receives a request from Alice via IPv6, Bob must select a Charlie that advertises an IPv6 address.
The actual Bob-Charlie communication may be via IPv4 or IPv6 (i.e., independent of Alice&rsquo;s address type).</p>
</li>
<li>
<p>Messages 1-4 must be contained in a Data message in an existing session.</p>
</li>
<li>
<p>Bob must send Alice&rsquo;s RI to Charlie prior to sending message 2.</p>
</li>
<li>
<p>Bob must send Charlie&rsquo;s RI to Alice prior to sending message 4, if accepted (reason code 0).</p>
</li>
<li>
<p>Messages 5-7 must be contained in a Peer Test message out-of-session.</p>
</li>
<li>
<p>Messages 5 and 7 may contain the same signed data as sent in messages 3 and 4, or it may
be regenerated with a new timestamp. Signature is optional.</p>
</li>
<li>
<p>Message 6 may contain the same signed data as sent in messages 1 and 2, or it may
be regenerated with a new timestamp. Signature is optional.</p>
</li>
</ul>
<p>Signatures:</p>
<p>Alice signs the request and includes it in message 1; Bob forwards it in message 2 to Charlie.
Charlie signs the response and includes it in message 3; Bob forwards it in message 4 to Alice.
Signature algorithm: Sign or verify the following data with the Alice&rsquo;s or Charlie&rsquo;s signing key:</p>
<ul>
<li>prologue: 16 bytes &ldquo;PeerTestValidate&rdquo;, not null-terminated (not included in the message)</li>
<li>bhash: Bob&rsquo;s 32-byte router hash (not included in the message)</li>
<li>ahash: Alice&rsquo;s 32-byte router hash
(Only used in the signature for messages 3 and 4; not included in message 3 or 4)</li>
<li>ver: 1 byte SSU version</li>
<li>nonce: 4 byte test nonce</li>
<li>timestamp: 4 byte timestamp (seconds)</li>
<li>asz: 1 byte endpoint (port + IP) size (6 or 18)</li>
<li>AlicePort: 2 byte Alice&rsquo;s port number</li>
<li>Alice IP: (asz - 2) byte Alice IP address</li>
</ul>
<h4 id="nextnonce">NextNonce</h4>
<p>TODO only if we rotate keys</p>
<pre tabindex="0"><code>+----+----+----+----+----+----+----+----+
  | 11 |  size   |      TBD               |
  +----+----+----+                        +
  |                                       |
  ~               .   .   .               ~
  |                                       |
  +----+----+----+----+----+----+----+----+

  blk :: 11
  size :: 2 bytes, big endian, size of data to follow
</code></pre><h4 id="ack">Ack</h4>
<p>4 byte ack through, followed by an ack count
and zero or more nack/ack ranges.</p>
<p>This design is adapted and simplified from QUIC.
The design goals are as follows:</p>
<ul>
<li>We want to efficiently encode a &ldquo;bitfield&rdquo;, which is a
sequence of bits representing acked packets.</li>
<li>The bitfield is mostly 1&rsquo;s. Both the 1&rsquo;s and the 0&rsquo;s
generally come in sequential &ldquo;clumps&rdquo;.</li>
<li>The amount of room in the packet available for acks varies.</li>
<li>The most important bit is the highest numbered one.
Lower numbered ones are less important.
Below a certain distance from the highest bit, the oldest
bits will be &ldquo;forgotten&rdquo; and never sent again.</li>
</ul>
<p>The encoding specified below accomplishes these design goals,
by sending the number of the highest bit that is set to 1,
together with additional consecutive bits lower than that
which are also set to 1.
After that, if there is room, one or more &ldquo;ranges&rdquo; specifying
the number of consectutive 0 bits and consecutive 1 bits
lower than that.
See QUIC <a href="https://datatracker.ietf.org/doc/html/rfc9000">RFC 9000</a>
 section 13.2.3 for more background.</p>
<pre tabindex="0"><code>+----+----+----+----+----+----+----+----+
  | 12 |  size   |    Ack Through    |acnt|
  +----+----+----+----+----+----+----+----+
  |  range  |  range  |     .   .   .     |
  +----+----+----+----+                   +
  ~               .   .   .               ~
  |                                       |
  +----+----+----+----+----+----+----+----+

  blk :: 12
  size :: 2 bytes, big endian, size of data to follow,
          5 minimum
  ack through :: highest packet number acked
  acnt :: number of acks lower than ack through also acked,
          0-255
  range :: If present,
           1 byte nack count followed by 1 byte ack count,
           0-255 each
</code></pre><p>Examples:</p>
<p>We want to ACK packet 10 only:</p>
<ul>
<li>Ack Through: 10</li>
<li>acnt: 0</li>
<li>no ranges are included</li>
</ul>
<p>We want to ACK packets 8-10 only:</p>
<ul>
<li>Ack Through: 10</li>
<li>acnt: 2</li>
<li>no ranges are included</li>
</ul>
<p>We want to ACK 10 9 8 6 5 2 1 0, and NACK 7 4 3.
The encoding of the ACK Block is:</p>
<ul>
<li>Ack Through: 10</li>
<li>acnt: 2 (ack 9 8)</li>
<li>range: 1 2 (nack 7, ack 6 5)</li>
<li>range: 2 3 (nack 4 3, ack 2 1 0)</li>
</ul>
<p>Notes:</p>
<ul>
<li>Ranges may not be present. Max number of ranges is not specified,
may be as many as will fit in the packet.</li>
<li>Range nack may be zero if acking more than 255 consecutive packets.</li>
<li>Range ack may be zero if nacking more than 255 consecutive packets.</li>
<li>Range nack and ack may not both be zero.</li>
<li>After the last range, packets are neither acked nor nacked.
Length of the ack block and how old acks/nacks are handled
is up to the sender of the ack block.
See ack sections below for discussion.</li>
<li>The ack through should be the highest packet number received,
and any packets higher have not been received.
However, in limited situations, it could be lower, such as
acking a single packet that &ldquo;fills in a hole&rdquo;, or a simplified
implementation that does not maintain the state of all received packets.
Above the highest received, packets are neither acked nor nacked,
but after several ack blocks, it may be appropriate to go
into fast retransmit mode.</li>
<li>This format is a simplified version of that in QUIC.
It is designed to efficiently encode a large number of ACKs,
together with bursts of NACKs.</li>
<li>ACK blocks are used to acknowledge data phase packets.
They are only to be included for in-session data phase packets.</li>
</ul>
<h4 id="address">Address</h4>
<p>2 byte port and 4 or 16 byte IP address.
Alice&rsquo;s address, sent to Alice by Bob,
or Bob&rsquo;s address, sent to Bob by Alice.</p>
<pre tabindex="0"><code>+----+----+----+----+----+----+----+----+
  | 13 | 6 or 18 |   Port  | IP Address    
  +----+----+----+----+----+----+----+----+
       |
  +----+

  blk :: 13
  size :: 2 bytes, big endian, 6 or 18
  port :: 2 bytes, big endian
  ip :: 4 byte IPv4 or 16 byte IPv6 address,
        big endian (network byte order)
</code></pre><h4 id="relay-tag-request">Relay Tag Request</h4>
<p>This may be sent by Alice in a Session Request, Session Confirmed, or Data message.
Not supported in the Session Created message, as Bob doesn&rsquo;t have Alice&rsquo;s RI yet,
and doesn&rsquo;t know if Alice supports relay.
Also, if Bob is getting an incoming connection, he probably doesn&rsquo;t need introducers
(except perhaps for the other type ipv4/ipv6).</p>
<p>When sent in the Session Request,
Bob may respond with a Relay Tag in the Session Created message,
or may choose to wait until receiving Alice&rsquo;s RouterInfo in the
Session Confirmed to validate Alice&rsquo;s identity before responding in a Data message.
If Bob does not wish to relay for Alice, he does not send a Relay Tag block.</p>
<pre tabindex="0"><code>+----+----+----+
  | 15 |    0    |
  +----+----+----+

  blk :: 15
  size :: 2 bytes, big endian, value = 0
</code></pre><h4 id="relay-tag">Relay Tag</h4>
<p>This may be sent by Bob in a Session Confirmed or Data message,
in response to a Relay Tag Request from Alice.</p>
<p>When the Relay Tag Request is sent in the Session Request,
Bob may respond with a Relay Tag in the Session Created message,
or may choose to wait until receiving Alice&rsquo;s RouterInfo in the
Session Confirmed to validate Alice&rsquo;s identity before responding in a Data message.
If Bob does not wish to relay for Alice, he does not send a Relay Tag block.</p>
<pre tabindex="0"><code>+----+----+----+----+----+----+----+
  | 16 |    4    |    relay tag      |
  +----+----+----+----+----+----+----+

  blk :: 16
  size :: 2 bytes, big endian, value = 4
  relay tag :: 4 bytes, big endian, nonzero
</code></pre><h4 id="new-token">New Token</h4>
<p>For a subsequent connection.
Generally included in the Session Created and Session Confirmed messages.
May also be sent again in the Data message of a long-lived session
if the previous token expires.</p>
<pre tabindex="0"><code>+----+----+----+----+----+----+----+----+
  | 17 |   12    |     expires       |
  +----+----+----+----+----+----+----+----+
                  token              |
  +----+----+----+----+----+----+----+

  blk :: 17
  size :: 2 bytes, big endian, value = 12
  expires :: Unix timestamp, unsigned seconds.
             Wraps around in 2106
  token :: 8 bytes, big endian
</code></pre><h4 id="path-challenge">Path Challenge</h4>
<p>A Ping with arbitrary data to be returned in a Path Response,
used as a keep-alive or to validate an IP/Port change.</p>
<pre tabindex="0"><code>+----+----+----+----+----+----+----+----+
  | 18 |  size   |    Arbitrary Data      |
  +----+----+----+                        +
  |                                       |
  ~               .   .   .               ~
  |                                       |
  +----+----+----+----+----+----+----+----+

  blk :: 18
  size :: 2 bytes, big endian, size of data to follow
  data :: Arbitrary data to be returned in a Path Response
          length as selected by sender
</code></pre><p>Notes:</p>
<p>A minimum data size of 8 bytes, containing random data,
is recommended but not required.</p>
<h4 id="path-response">Path Response</h4>
<p>A Pong with the data received in the Path Challenge, as reply to the Path Challenge,
used as a keep-alive or to validate an IP/Port change.</p>
<pre tabindex="0"><code>+----+----+----+----+----+----+----+----+
  | 19 |  size   |                        |
  +----+----+----+                        +
  |    Data received in Path Challenge    |
  ~               .   .   .               ~
  |                                       |
  +----+----+----+----+----+----+----+----+

  blk :: 19
  size :: 2 bytes, big endian, size of data to follow
  data :: As received in a Path Challenge
</code></pre><h4 id="first-packet-number">First Packet Number</h4>
<p>Optionally included in the handshake in each direction,
to specify the first packet number that will be sent.
This provides more security for header encryption,
similar to TCP.</p>
<p>Not fully specified, not currently supported.</p>
<pre tabindex="0"><code>+----+----+----+----+----+----+----+
  | 20 |  size   |  First pkt number |
  +----+----+----+----+----+----+----+

  blk :: 20
  size :: 4
  pkt num :: The first packet number to be sent in the data phase
</code></pre><h4 id="congestion">Congestion</h4>
<p>This is block is designed to be an extensible method
to exchange congestion control information.
Congestion control can be complex and may evolve as
we get more experience with the protocol in live testing,
or after full rollout.</p>
<p>This keeps any congestion information out of the high-usage
I2NP, First Fragment, Followon Fragment, and ACK blocks,
where there is no space for flags allocated.
While there are three bytes of unused flags in the Data packet header,
that also provides limited space for extensibility,
and weaker encryption protection.</p>
<p>While it is somewhat wasteful to use a 4-byte block
for two bits of information, by putting this in a separate block,
we can easily extend it with additional data such as
current window sizes, measured RTT, or other flags.
Experience has shown that flag bits alone is often insufficient
and awkward for implementation of advanced congestion control schemes.
Trying to add support for any possible congestion control feature
in, for example, the ACK block, would waste space and add complexity
to the parsing of that block.</p>
<p>Implementations should not assume that the other router supports
any particular flag bit or feature included here,
unless implementation is required by a future version of this specification.</p>
<p>This block should probably be the last non-padding block in the payload.</p>
<pre tabindex="0"><code>+----+----+----+----+
  | 21 |  size   |flag|
  +----+----+----+----+

  blk :: 21
  size :: 1 (or more if extended)
  flag :: 1 byte flags
         bit order: 76543210 (bit 7 is MSB)
         bit 0: 1 to request immediate ack
         bit 1: 1 for explicit congestion notification (ECN)
         bits 7-2: Unused, set to 0 for future compatibility
</code></pre><h4 id="padding">Padding</h4>
<p>This is for padding inside AEAD payloads.
Padding for all messages are inside AEAD payloads.</p>
<p>Padding should roughly adhere to the negotiated parameters.
Bob sent his requested tx/rx min/max parameters in Session Created.
Alice sent her requested tx/rx min/max parameters in Session Confirmed.
Updated options may be sent during the data phase.
See options block information above.</p>
<p>If present, this must be the last block in the payload.</p>
<pre tabindex="0"><code>+----+----+----+----+----+----+----+----+
  |254 |  size   |      padding           |
  +----+----+----+                        +
  |                                       |
  ~               .   .   .               ~
  |                                       |
  +----+----+----+----+----+----+----+----+

  blk :: 254
  size :: 2 bytes, big endian, size of padding to follow
  padding :: random data
</code></pre><p>Notes:</p>
<ul>
<li>
<p>Size = 0 is allowed.</p>
</li>
<li>
<p>Padding strategies TBD.</p>
</li>
<li>
<p>Minimum padding TBD.</p>
</li>
<li>
<p>Padding-only payloads are allowed.</p>
</li>
<li>
<p>Padding defaults TBD.</p>
</li>
<li>
<p>See options block for padding parameter negotiation</p>
</li>
<li>
<p>See options block for min/max padding parameters</p>
</li>
<li>
<p>Do not exceed the MTU. If more padding is necessary, send multiple messages.</p>
</li>
<li>
<p>Router response on violation of negotiated padding is implementation-dependent.</p>
</li>
<li>
<p>The padding length is either to be decided on a per-message basis and
estimates of the length distribution, or random delays should be added.
These countermeasures are to be included to resist DPI, as message sizes
would otherwise reveal that I2P traffic is being carried by the transport
protocol. The exact padding scheme is an area of future work, Appendix A
of <a href="../../../en/docs/specs/ntcp2/">NTCP2</a>
 provides more information on the topic.</p>
</li>
</ul>
<h2 id="replay-prevention">Replay Prevention</h2>
<p>SSU2 is designed to minimize the impact of messages replayed by an attacker.</p>
<p>Token Request, Retry, Session Request, Session Created, Hole Punch,
and out-of-session Peer Test messages must contain DateTime blocks.</p>
<p>Both Alice and Bob validate that the time for these messages is within a valid skew (recommended +/- 2 minutes).
For &ldquo;probing resistance&rdquo;, Bob should not reply to Token Request or Session Request
messages if the skew is invalid, as these messages may be a replay or probing attack.</p>
<p>Bob may choose to reject duplicate Token Request and Retry messages,
even if the skew is valid, via a Bloom filter or other mechanism.
However, the size and CPU cost of replying to these messages is low.
At worst, a replayed Token Request message may invalidate a previously-sent
token.</p>
<p>The token system greatly minimizes the impact of replayed Session Request messages.
Since tokens may only be used once, a replayed Session Request message
will never have a valid token.
Bob may choose to reject duplicate Session Request messages,
even if the skew is valid, via a Bloom filter or other mechanism.
However, the size and CPU cost of replying with a Retry message is low.
At worst, sending a Retry message may invalidate a previously-sent
token.</p>
<p>Duplicate Session Created and Session Confirmed messages will
not validate because the Noise handshake state will not be in the correct state to decrypt them.
At worst, a peer may retransmit a Session Confirmed in response to an apparent
duplicate Session Created.</p>
<p>Replayed Hole Punch and Peer Test messages should have little or no impact.</p>
<p>Routers must use the data message packet number to
detect and drop duplicate data phase messages.
Each packet number should only be used once.
Replayed messages must be ignored.</p>
<h2 id="handshake-retransmission">Handshake Retransmission</h2>
<h3 id="session-request">Session Request</h3>
<p>If no Session Created or Retry is received by Alice:</p>
<p>Maintain same source and connection IDs, ephemeral key, and packet number 0.
Or, just retain and retransmit the same encrypted packet.
Packet number must not be incremented, because that would change
the chained hash value used to encrypt the Session Created message.</p>
<p>Recommended retransmission intervals: 1.25, 2.5, and 5 seconds (1.25, 3.75, and 8.75 seconds after first sent).
Recommended timeout: 15 seconds total</p>
<h3 id="session-created">Session Created</h3>
<p>If no Session Confirmed is received by Bob:</p>
<p>Maintain same source and connection IDs, ephemeral key, and packet number 0.
Or, just retain the encrypted packet.
Packet number must not be incremented, because that would change
the chained hash value used to encrypt the Session Confirmed message.</p>
<p>Recommended retransmission intervals: 1, 2, and 4 seconds (1, 3,  and 7 seconds after first sent).
Recommended timeout: 12 seconds total</p>
<h3 id="session-confirmed">Session Confirmed</h3>
<p>In SSU 1, Alice does not shift to the data phase until the first data packet is
received from Bob. This makes SSU 1 a two-round-trip setup.</p>
<p>For SSU 2,
Recommended Session Confirmed retransmission intervals: 1.25, 2.5, and 5 seconds (1.25, 3.75, and 8.75 seconds after first sent).</p>
<p>There are several alternatives. All are 1 RTT:</p>
<ol>
<li>
<p>Alice assumes Session Confirmed was received, sends data messages immediately,
never retransmit Session Confirmed. Data packets received out-of-order
(before Session Confirmed) will be undecryptable, but will get retransmitted.
If Session Confirmed is lost, all sent data messages will be dropped.</p>
</li>
<li>
<p>As in 1), send data messages immediately, but also retransmit Session Confirmed
until a data message is received.</p>
</li>
<li>
<p>We could use IK instead of XK, as it has only two messages in the handshake, but
it uses an extra DH (4 instead of 3).</p>
</li>
</ol>
<p>The recommeded implementation is option 2).
Alice must retain the information required to retransmit the Session Confirmed message.
Alice should also retransmit all Data messages after the Session Confirmed
message is retransmitted.</p>
<p>When retransmitting Session Confirmed,
maintain same source and connection IDs, ephemeral key, and packet number 1.
Or, just retain the encrypted packet.
Packet number must not be incremented, because that would change
the chained hash value which is an input for the split() function.</p>
<p>Bob may retain (queue) the data messages received before the Session Confirmed message.
Neither the header protection keys nor the decryption keys are available
before the Session Confirmed message is received, so Bob does not know
that they are data messages, but that can be presumed.
After the Session Confirmed message is received, Bob is able to
decrypt and process the queued Data messages.
If this is too complex, Bob may just drop the undecryptable Data messages,
as Alice will retransmit them.</p>
<p>Note: If the session confirmed packets are lost, Bob will retransmit
session created. The session created header will not be decryptable
with Alice&rsquo;s intro key, as it is set with Bob&rsquo;s intro key
(unless fallback decryption is performed with Bob&rsquo;s intro key).
Bob may immediately retransmit the session confirmed packets
if not previously acked, and an undecryptable packet is received.</p>
<h3 id="token-request">Token Request</h3>
<p>If no Retry is received by Alice:</p>
<p>Maintain same source and connection IDs.
An implementation may generate a new random packet number and encrypt a new packet;
Or it may reuse the same packet number or just retain and retransmit the same encrypted packet.
Packet number must not be incremented, because that would change
the chained hash value used to encrypt the Session Created message.</p>
<p>Recommended retransmission intervals: 3 and 6 seconds (3 and 9 seconds after first sent).
Recommended timeout: 15 seconds total</p>
<h3 id="retry">Retry</h3>
<p>If no Session Request is received by Bob:</p>
<p>A Retry message is not retransmitted on timeout, to reduce the impacts
of spoofed source addresses.</p>
<p>However, a Retry message may be retransmitted in response to a repeated
Session Request message being received with the original (invalid) token,
or in response to a repeated Token Request message.
In either case, this indicates that the Retry message was lost.</p>
<p>If a second Session Request message is received with a different
but still-invalid token, drop the pending session and do not respond.</p>
<p>If resending the Retry message:
Maintain same source and connection IDs and token.
An implementation may generate a new random packet number and encrypt a new packet;
Or it may reuse the same packet number or just retain and retransmit the same encrypted packet.</p>
<h3 id="total-timeout">Total Timeout</h3>
<p>Recommended total timeout for the handshake is 20 seconds.</p>
<h3 id="duplicates-and-error-handling">Duplicates and Error Handling</h3>
<p>Duplicates of the three Noise handshake messages
Session Request, Session Created, and Session Confirmed
must be detected before MixHash() of the header.
While the Noise AEAD processing will presumably fail after that,
the handshake hash would already be corrupted.</p>
<p>If any of the three messages is corrupted and fails AEAD,
the handshake cannot subsequently be recovered even with retransmission,
because MixHash() was already called on the corrupted message.</p>
<h2 id="tokens">Tokens</h2>
<p>The Token in the Session Request header is used for DoS mitigation,
to prevent source address spoofing, and as resistance to replay attacks.</p>
<p>If Bob does not accept the token in the Session Request message, Bob does NOT decrypt
the message, as it requires an expensive DH operation.
Bob simply sends a Retry message with a new token.</p>
<p>If a subsequent Session Request message then is received with that token,
Bob proceeds to decrypt that message and proceed with the handshake.</p>
<p>The token must be a randomly-generated 8 byte value, if the generator of the token
stores the values and associated IP and port (in-memory or persistently).
The generator may not generate an opaque value, for example,
using the SipHash (with a secret seed K0, K1) of the IP, port, and current hour or day,
to create tokens that do not need to be saved in-memory,
because this method make it difficult to reject reused tokens and replay attacks.</p>
<p>Tokens may only be used once.
A token sent from Bob to Alice in a Retry message must be used immediately, and expires
in a few seconds.
A token sent in a New Token block in an established session
may be used in a subsequent connection, and it
expires at the time specified in that block.
Expiration is specified by the sender; recommended values are
one hour minimum, several hours maximum.</p>
<p>If a router&rsquo;s IP or port changes, it must delete all saved tokens
(both inbound and outbound) for the old IP or port, as they are no longer valid.
Tokens may optionally be persisted across router restarts, implementation dependent.
Acceptance of an unexpired token is not guaranteed; if Bob has forgotten or deleted
his saved tokens, he will send a Retry to Alice.
A router may choose to limit token storage, and remove the oldest stored tokens
even if they have not expired.</p>
<p>New Token blocks may be sent from Alice to Bob or Bob to Alice.
They would typically be sent once, during or soon after session establishment.
The token may be resent before or after expiration with a new expiration time,
or a new token may be sent.
Routers should assume that only the last token received is valid;
there is no requirement to store multiple inbound or outbound tokens for the same IP/port.</p>
<p>A token is bound to the combination of source IP/port and destination IP/port.
A token received on IPv4 may not be used for IPv6 or vice versa.</p>
<p>If either peer migrates to a new IP or port during the session
(see the Connection Migration section), any previously-exchanged tokens are invalited,
and new tokens must be exchanged.</p>
<p>Implementations may, but are not required to, save tokens on disk and
reload them on restart. If persisted, the implementation must
ensure that the IP and port have not changed since shutdown
before reloading them.</p>
<h2 id="i2np-message-fragmentation">I2NP Message Fragmentation</h2>
<p>Differences from SSU 1</p>
<p>Note: As in SSU 1, the initial fragment does not contain information
on the total number of fragments or the total length.
Follow-on fragments do not contain information on their offset.
This provides the sender the flexibility of fragmenting &ldquo;on the fly&rdquo;
based on available space in the packet.
(Java I2P does not do this; it &ldquo;pre-fragments&rdquo; before the first fragment is sent)
However, it does burden the receiver to store fragments
received out-of-order and delay reassembly until all fragments are received.</p>
<p>As in SSU 1, any retransmission of fragments must preserve the length (and implicit offset)
of the fragment&rsquo;s previous transmission.</p>
<p>SSU 2 does separate the three cases (full message, initial fragment, and follow-on fragment)
into three different block types, to improve processing efficiency.</p>
<h2 id="i2np-message-duplication">I2NP Message Duplication</h2>
<p>This protocol does NOT completely prevent duplicate delivery of I2NP messages.
IP-layer duplicates or replay attacks will be detected at the SSU2 layer,
because each packet number may only be used once.</p>
<p>When I2NP messages or fragments are retransmitted in new packets, however,
this is not detectable at the SSU2 layer.
The router should enforce I2NP expiration (both too old and too far in the future)
and use a Bloom filter or other mechanism based on the I2NP message ID.</p>
<p>Additional mechanisms may be used by the router, or in the SSU2 implementation,
to detect duplicates.
For example, SSU2 could maintain a cache of recently-received message IDs.
This is implementation-dependent.</p>
<h2 id="congestion-control">Congestion Control</h2>
<p>This proposal specifies the protocol for packet numbering and
ACK blocks. This provides sufficient real-time information for a
transmitter to implement an efficient and responsive congestion control algorithm,
while allowing flexibility and innovation in that implementation.
This section discusses implementation goals and provides suggestions.
General guidance may be found in <a href="https://datatracker.ietf.org/doc/html/rfc9002">RFC 9002</a>
.
See also <a href="https://tools.ietf.org/html/rfc6298">RFC 6298</a>
 for guidance on retransmission timers.</p>
<p>ACK-only data packets should not count for bytes or packets in-flight
and are not congestion-controlled.
Unlike in TCP, SSU2 can detect the loss of these packets and
that information may be used to adjust the congestion state.
However, this document does not specify a mechanism for doing so.</p>
<p>Packets containing some other non-data blocks may also be excluded from congestion control
if desired, implementation-dependent. For example:</p>
<ul>
<li>Peer Test</li>
<li>Relay request/intro/response</li>
<li>Path challenge/response</li>
</ul>
<p>It is recommended that the congestion control be based on byte count, not
packet count, following the guidance in TCP RFCs and QUIC <a href="https://datatracker.ietf.org/doc/html/rfc9002">RFC 9002</a>
.
An additional packet count limit may be useful as well to prevent
buffer overflow in the kernel or in middleboxes, implementation dependent,
although this may add significant complexity.
If per-session and/or total packet output is bandwidth-limited and/or paced,
this may mitigate the need for packet count limiting.</p>
<h3 id="packet-numbers">Packet Numbers</h3>
<p>In SSU 1, ACKs and NACKs contained I2NP message numbers and fragment bitmasks.
Transmitters tracked the ACK status of outbound messages (and their fragments)
and retransmitted fragments as required.</p>
<p>In SSU 2, ACKs and NACKs contain packet numbers.
Transmitters must maintain a data structure with a mapping of packet numbers to their contents.
When a packet is ACKed or NACKed, the transmitter must determine what
I2NP messages and fragments were in that packet, to decide what to retransmit.</p>
<h3 id="session-confirmed-ack">Session Confirmed ACK</h3>
<p>Bob sends an ACK of packet 0, which acknowledges the Session Confirmed message and allows
Alice to proceed to the data phase, and discard the large Session Confirmed message
being saved for possible retransmission.
This replaces the DeliveryStatusMessage sent by Bob in SSU 1.</p>
<p>Bob should send an ACK as soon as possible after receiving the Session Confirmed message.
A small delay (no more than 50 ms) is acceptable, since at least one Data message should arrive almost
immediately after the Session Confirmed message, so that the ACK may acknowledge both
the Session Confirmed and the Data message.
This will prevent Bob from having to retransmit the Session Confirmed message.</p>
<h3 id="generating-acks">Generating ACKs</h3>
<p>Definition: Ack-eliciting packets:
Packets that contain ack-eliciting blocks elicit an ACK from the receiver
within the maximum acknowledgment delay and are called ack-eliciting packets.</p>
<p>Routers acknowledge all packets they receive and process.  However,
only ack-eliciting packets cause an ACK block to be sent within the
maximum ack delay.  Packets that are not ack-eliciting are only
acknowledged when an ACK block is sent for other reasons.</p>
<p>When sending a packet for any reason, an endpoint should attempt to
include an ACK block if one has not been sent recently.  Doing so
helps with timely loss detection at the peer.</p>
<p>In general, frequent feedback from a receiver improves loss and
congestion response, but this has to be balanced against excessive
load generated by a receiver that sends an ACK block in response to
every ack-eliciting packet.  The guidance offered below seeks to
strike this balance.</p>
<p>In-session data packets containing any block
EXCEPT for the following are ack-eliciting:</p>
<ul>
<li>ACK block</li>
<li>Address block</li>
<li>DateTime block</li>
<li>Padding block</li>
<li>Termination block</li>
<li>Any blocks in the same packet as a Termination block</li>
<li>Others?</li>
</ul>
<p>Packets containing a Termination block with a reason other than
&ldquo;termination received&rdquo; are acknowledged with a packet containing
a Termination block with &ldquo;termination received&rdquo;.</p>
<p>Out-of session packets, including handshake messages
and peer test messages 5-7, have their own acknowledgement mechanisms.
See below.</p>
<h3 id="handshake-acks">Handshake ACKs</h3>
<p>These are special cases:</p>
<ul>
<li>Token Request is implicitly acked by Retry</li>
<li>Session Request is implicitly acked by Session Created or Retry</li>
<li>Retry is implicitly acked by Session Request</li>
<li>Session Created is implicitly acked by Session Confirmed</li>
<li>Session Confirmed should be acked immediately</li>
</ul>
<h3 id="sending-ack-blocks">Sending ACK Blocks</h3>
<p>ACK blocks are used to acknowledge data phase packets.
They are only to be included for in-session data phase packets.</p>
<p>Every packet should be acknowledged at least once, and ack-eliciting
packets must be acknowledged at least once within a maximum delay.</p>
<p>An endpoint must acknowledge all ack-eliciting handshake
packets immediately
within its maximum delay, with the following exception.
Prior to handshake confirmation, an endpoint might not have packet
header encryption keys for decrypting the packets
when they are received.  It might therefore buffer them and
acknowledge them when the requisite keys become available.</p>
<p>Since packets containing only ACK blocks are not congestion
controlled, an endpoint must not send more than one such packet in
response to receiving an ack-eliciting packet.</p>
<p>An endpoint must not send a non-ack-eliciting packet in response to a
non-ack-eliciting packet, even if there are packet gaps that precede
the received packet.  This avoids an infinite feedback loop of
acknowledgments, which could prevent the connection from ever
becoming idle.  Non-ack-eliciting packets are eventually acknowledged
when the endpoint sends an ACK block in response to other events.</p>
<p>An endpoint that is only sending ACK blocks will not receive
acknowledgments from its peer unless those acknowledgments are
included in packets with ack-eliciting blocks.  An endpoint should
send an ACK block with other blocks when there are new ack-eliciting
packets to acknowledge.  When only non-ack-eliciting packets need to
be acknowledged, an endpoint MAY choose not to send an ACK block with
outgoing blocks until an ack-eliciting packet has been received.</p>
<p>An endpoint that is only sending non-ack-eliciting packets might
choose to occasionally add an ack-eliciting block to those packets to
ensure that it receives an acknowledgment.  In
that case, an endpoint MUST NOT send an ack-eliciting block in all
packets that would otherwise be non-ack-eliciting, to avoid an
infinite feedback loop of acknowledgments.</p>
<p>In order to assist loss detection at the sender, an endpoint should
generate and send an ACK block without delay when it receives an ack-
eliciting packet in any of these cases:</p>
<ul>
<li>
<p>When the received packet has a packet number less than another
ack-eliciting packet that has been received</p>
</li>
<li>
<p>When the packet has a packet number larger than the highest-
numbered ack-eliciting packet that has been received and there are
missing packets between that packet and this packet.</p>
</li>
<li>
<p>When the ack-immediate flag in the packet header is set</p>
</li>
</ul>
<p>The algorithms are expected to be resilient to
receivers that do not follow the guidance offered above.  However, an
implementation should only deviate from these requirements after
careful consideration of the performance implications of a change,
for connections made by the endpoint and for other users of the
network.</p>
<h3 id="ack-frequency">ACK Frequency</h3>
<p>A receiver determines how frequently to send acknowledgments in
response to ack-eliciting packets.  This determination involves a
trade-off.</p>
<p>Endpoints rely on timely acknowledgment to detect loss.
Window-based congestion controllers rely on
acknowledgments to manage their congestion window.  In both cases,
delaying acknowledgments can adversely affect performance.</p>
<p>On the other hand, reducing the frequency of packets that carry only
acknowledgments reduces packet transmission and processing cost at
both endpoints.  It can improve connection throughput on severely
asymmetric links and reduce the volume of acknowledgment traffic
using return path capacity; see Section 3 of <a href="https://tools.ietf.org/html/rfc3449">RFC 3449</a>
.</p>
<p>A receiver should send an ACK block after receiving at least two ack-eliciting packets.
This recommendation is general in nature and
consistent with recommendations for TCP endpoint behavior <a href="https://tools.ietf.org/html/rfc5681">RFC 5681</a>
.
Knowledge of network conditions, knowledge of the peer&rsquo;s congestion
controller, or further research and experimentation might suggest
alternative acknowledgment strategies with better performance
characteristics.</p>
<p>A receiver may process multiple available packets before determining
whether to send an ACK block in response.
In general, the receiver should not delay an ACK by more than RTT / 6,
or 150 ms max.</p>
<p>The ack-immediate flag in the data packet header is a request that
the receiver send an ack soon after reception, probably within
a few ms.
In general, the receiver should not delay an immediate ACK by more than RTT / 16,
or 5 ms max.</p>
<h3 id="immediate-ack-flag">Immediate ACK Flag</h3>
<p>The receiver does not know the sender&rsquo;s send window size,
and so does not know how long to delay before sending an ACK.
The immediate ACK flag in the data packet header is an important way to
maintain maximum throughput by minimizing effective RTT.
The immediate ACK flag is header byte 13, bit 0, i.e. (header[13] &amp; 0x01).
When set, an immediate ACK is requested.
See the short header section above for details.</p>
<p>There are several possible strategies a sender may use to determine
when to set the immediate-ack flag:</p>
<ul>
<li>Set once every N packets, for some small N</li>
<li>Set on the last in a burst of packet</li>
<li>Set whenver the send window is almost full, for example over 2/3 full</li>
<li>Set on all packets with retransmitted fragments</li>
</ul>
<p>Immediate ACK flags should only be necessary on data packets containing
I2NP messages or message fragments.</p>
<h3 id="ack-block-size">ACK Block Size</h3>
<p>When an ACK block is sent, one or more ranges of acknowledged packets
are included.  Including acknowledgments for older packets reduces
the chance of spurious retransmissions caused by losing previously
sent ACK blocks, at the cost of larger ACK blocks.</p>
<p>ACK blocks should always acknowledge the most recently received
packets, and the more out of order the packets are, the more
important it is to send an updated ACK block quickly, to prevent the
peer from declaring a packet as lost and spuriously retransmitting
the blocks it contains.  An ACK block must fit within a
single packet.  If it does not, then older ranges (those with
the smallest packet numbers) are omitted.</p>
<p>A receiver limits the number of ACK ranges it
remembers and sends in ACK blocks, both to limit the size of ACK
blocks and to avoid resource exhaustion.  After receiving
acknowledgments for an ACK block, the receiver should stop tracking
those acknowledged ACK ranges.  Senders can expect acknowledgments
for most packets, but this protocol does not guarantee receipt of an
acknowledgment for every packet that the receiver processes.</p>
<p>It is possible that retaining many ACK ranges could cause an ACK
block to become too large.  A receiver can discard unacknowledged ACK
Ranges to limit ACK block size, at the cost of increased
retransmissions from the sender.  This is necessary if an ACK block
would be too large to fit in a packet.  Receivers may also limit ACK
block size further to preserve space for other blocks or to limit the
bandwidth that acknowledgments consume.</p>
<p>A receiver must retain an ACK range unless it can ensure that it will
not subsequently accept packets with numbers in that range.
Maintaining a minimum packet number that increases as ranges are
discarded is one way to achieve this with minimal state.</p>
<p>Receivers can discard all ACK ranges, but they must retain the
largest packet number that has been successfully processed, as that
is used to recover packet numbers from subsequent packets.</p>
<p>The following section describes an exemplary approach for determining what
packets to acknowledge in each ACK block.  Though the goal of this
algorithm is to generate an acknowledgment for every packet that is
processed, it is still possible for acknowledgments to be lost.</p>
<h3 id="limiting-ranges-by-tracking-ack-blocks">Limiting Ranges by Tracking ACK Blocks</h3>
<p>When a packet containing an ACK block is sent, the Ack Through
field in that block can be saved.  When a packet
containing an ACK block is acknowledged, the receiver can stop
acknowledging packets less than or equal to the Ack Through
field in the sent ACK block.</p>
<p>A receiver that sends only non-ack-eliciting packets, such as ACK
blocks, might not receive an acknowledgment for a long period of
time.  This could cause the receiver to maintain state for a large
number of ACK blocks for a long period of time, and ACK blocks it
sends could be unnecessarily large.  In such a case, a receiver could
send a PING or other small ack-eliciting block occasionally, such as
once per round trip, to elicit an ACK from the peer.</p>
<p>In cases without ACK block loss, this algorithm allows for a minimum
of 1 RTT of reordering.  In cases with ACK block loss and reordering,
this approach does not guarantee that every acknowledgment is seen by
the sender before it is no longer included in the ACK block.  Packets
could be received out of order, and all subsequent ACK blocks
containing them could be lost.  In this case, the loss recovery
algorithm could cause spurious retransmissions, but the sender will
continue making forward progress.</p>
<h3 id="congestion-1">Congestion</h3>
<p>I2P transports do not guarantee in-order delivery of I2NP messages.
Therefore, loss of a Data message containing one or more I2NP messages or fragments
does NOT prevent other I2NP messages from being delivered;
there is no head-of-line blocking.
Implementations should continue to send new messages during the loss recovery
phase if the send window allows it.</p>
<h3 id="retransmission">Retransmission</h3>
<p>A sender should not retain the full contents of a message, to be retransmitted
identically (except for handshake messages, see above).
A sender must assemble messages containing up-to-date information
(ACKs, NACKs, and unacknowledged data) every time it sends a message.
A sender should avoid retransmitting information from messages once they are acknowledged.
This includes messages that are acknowledged after being declared lost,
which can happen in the presence of network reordering.</p>
<h3 id="window">Window</h3>
<p>TBD.
General guidance may be found in <a href="https://datatracker.ietf.org/doc/html/rfc9002">RFC 9002</a>
.</p>
<h2 id="connection-migration-2">Connection Migration</h2>
<p>A peer&rsquo;s IP or port may change during the lifetime of a session.
An IP change may be caused by IPv6 temporary address rotation,
ISP-driven periodic IP change, a mobile client transitioning
between WiFi and cellular IPs, or other local network changes.
A port change may be caused by a NAT rebinding after
the previous binding timed out.</p>
<p>A peer&rsquo;s IP or port may appear to change due to various
on- and off-path attacks, including modifying or injecting
packets.</p>
<p>Connection migration is the process by which a new source endpoint
(IP+port) is validated, while preventing changes that are not validated.
This process is a simplified version of that defined in QUIC <a href="https://datatracker.ietf.org/doc/html/rfc9000">RFC 9000</a>
.
This process is defined only for the data phase of a session.
Migration is not permitted during the handshake. All handshake packets
must be verified to be from the same IP and port as previously
sent and received packets. In other words, a peer&rsquo;s IP and port
must be constant during the handshake.</p>
<h3 id="threat-model">Threat Model</h3>
<p>(Adapted from QUIC <a href="https://datatracker.ietf.org/doc/html/rfc9000">RFC 9000</a>
)</p>
<h4 id="peer-address-spoofing-1">Peer Address Spoofing</h4>
<p>A peer may spoofing its source address to cause an endpoint to send excessive amounts of data to an unwilling host.
If the endpoint sends significantly more data than the spoofing peer,
connection migration might be used to amplify the volume of data that an attacker can generate toward a victim.</p>
<h4 id="on-path-address-spoofing-1">On-Path Address Spoofing</h4>
<p>An on-path attacker could cause a spurious connection migration by copying and forwarding a packet
with a spoofed address such that it arrives before the original packet.
The packet with the spoofed address will be seen to come from a migrating connection,
and the original packet will be seen as a duplicate and dropped.
After a spurious migration, validation of the source address will fail because the entity at the source address
does not have the necessary cryptographic keys to read or respond to the Path Challenge that is sent to it even if it wanted to.</p>
<h4 id="off-path-packet-forwarding-1">Off-Path Packet Forwarding</h4>
<p>An off-path attacker that can observe packets might forward copies of genuine packets to endpoints.
If the copied packet arrives before the genuine packet, this will appear as a NAT rebinding.
Any genuine packet will be discarded as a duplicate.
If the attacker is able to continue forwarding packets, it might be able to cause migration to a path via the attacker.
This places the attacker on-path, giving it the ability to observe or drop all subsequent packets.</p>
<h4 id="privacy-implications">Privacy Implications</h4>
<p>QUIC <a href="https://datatracker.ietf.org/doc/html/rfc9000">RFC 9000</a>
 specified changing connection IDs when changing network paths.
Using a stable connection ID on multiple network paths would allow a passive observer to correlate activity between those paths.
An endpoint that moves between networks might not wish to have their activity correlated by any entity other than their peer.
However, QUIC does not encrypt the connection IDs in the header.
SSU2 does do that, so the privacy leak would require the passive observer to also
have access to the network database to get the introduction key required to decrypt the connection ID.
Even with the introduction key, this is not a strong attack, and we do not
change connection IDs after migration in SSU2, as this would be a significant complication.</p>
<h3 id="initiating-path-validation-1">Initiating Path Validation</h3>
<p>During the data phase, peers must check that the source IP and port
of each received data packet. If the IP or port is different than
previously received, AND the packet is not a duplicate packet number,
AND the packet successfully decrypts, the session enters
the path validation phase.</p>
<p>Additionally, a peer must verify that the new IP and port
are valid according to local validation rules
(not blocked, not illegal ports, etc.).
Peers are NOT required to support migration between IPv4 and IPv6,
and may treat a new IP in the other address family as invalid,
since this is not expected behavior and may add significant implementation complexity.
On receiving a packet from an invalid IP/port, an implementation
may simply drop it, or may initiate a path validation with the old IP/port.</p>
<p>Upon entering the path validation phase, take the following steps:</p>
<ul>
<li>Start a path validation timeout timer of several seconds,
or several times the current RTO (TBD)</li>
<li>Reduce the congestion window to the minimum</li>
<li>Reduce the PMTU to the minimum (1280)</li>
<li>Send a data packet containing a Path Challenge block,
an Address block (containing the new IP/port),
and, typically, an ACK block, to the new IP and port.
This packet uses the same connection ID and encryption keys
as the current session.
The Path Challenge block data must contain sufficient entropy
(at least 8 bytes) so that it cannot be spoofed.</li>
<li>Optionally, also send a Path Challenge to the old IP/port,
with different block data. See below.</li>
<li>Start a Path Response timeout timer based on the current
RTO (typically RTT + a multiple of RTTdev)</li>
</ul>
<p>While in the path validation phase, the session may continue to
process incoming packets. Whether from the old or new IP/port.
The session may also continue to send and acknowledge data packets.
However, the congestion window and PMTU must remain at the minimum
values during the path validation phase, to prevent
being used for deinal of service attacks by
sending large amounts of traffic to a spoofed address.</p>
<p>An implementation may, but is not required, to attempt to validate
multiple paths simultaneously. This is probably not worth the complexity.
It may, but is not required, to
remember a previous IP/port as being already validated, and to
skip path validation if a peer returns to its previous IP/port.</p>
<p>If a Path Response is received, containing the identical data
sent in the Path Challenge, the Path Validation has succeeded.
The source IP/port of the Path Response message is
not required to be the same as the Path Challenge was sent to.</p>
<p>If a Path Response is not received before the Path Response timer
expires, send another Path Challenge and double the Path Response timer.</p>
<p>If a Path Response is not received before the Path Validation timer
expires, the Path Validation has failed.</p>
<h3 id="message-contents">Message Contents</h3>
<p>The Data messages should contain the following blocks.
Order is not specified except that Padding must be last:</p>
<ul>
<li>Path Validation or Path Response block.
Path Validation contains opaque data, recommended 8 bytes minimum.
Path Response contains the data from the Path Validation.</li>
<li>Address block containing the recipient&rsquo;s apparent IP</li>
<li>DateTime block</li>
<li>ACK block</li>
<li>Padding block</li>
</ul>
<p>It is not recommended to include any other blocks
(for example, I2NP) in the message.</p>
<p>It is allowed to include a Path Validation block in the message
containing the Path Response, to initiate a validation
in the other direction.</p>
<p>Path Challenge and Path Response blocks are ACK-eliciting.
The Path Challenge will be ACKed by a Data message containing
the Path Response and ACK blocks.
The Path Response should be ACKed by a Data message containing an ACK block.</p>
<h3 id="routing-during-path-validation">Routing during Path Validation</h3>
<p>The QUIC specification is not clear on where to send data packets
during path validation - to the old or new IP/port?
There is a balance to be struck between rapidly responding to
IP/port changes, and not sending traffic to spoofed addresses.
Also, spoofed packets must not be allowed to substantially impact
an existing session.
Port-only changes are likely to be caused by NAT rebinding after
an idle period; IP changes could happen during high-traffic phases
in one or both directions.</p>
<p>Strategies are subject to research and refinement.
Possibilities include:</p>
<ul>
<li>Not sending data packets to the new IP/port until validated</li>
<li>Continuing to send data packets to the old IP/port until
the new IP/port is validated</li>
<li>Simultaneously revalidating the old IP/port</li>
<li>Not sending any data until either the old or new IP/port is validated</li>
<li>Different strategies for port-only change than for IP change</li>
<li>Different strategies for an IPv6 change in the same /32, likely caused
by temporary address rotation</li>
</ul>
<h3 id="responding-to-path-challenge">Responding to Path Challenge</h3>
<p>Upon receiving a Path Challenge, the peer must respond
with a data packet containing a Path Response, with the data
from the Path Challenge.
TODO Maybe???:
The Path Response must be sent to the IP/port from which the
Path Challenge was received. This is NOT NECESSARILY
the IP/port that was previously established for the peer.
This ensures that path validation by a peer only succeeds if the path is functional in both directions.
See the Validation after Local Change section below.</p>
<p>Unless the IP/port is different from the previously-known IP/port for the peer,
treat a Path Challenge as a simple ping, and simply respond unconditionally with a Path Response.
The receiver does not keep or change any state based on a received Path Challenge.
If the IP/port is different, a peer must verify that the new IP and port
are valid according to local validation rules
(not blocked, not illegal ports, etc.).
Peers are NOT required to support cross-address-family responses between IPv4 and IPv6,
and may treat a new IP in the other address family as invalid,
since this is not expected behavior.</p>
<p>Unless constrained by congestion control, the Path Response should be sent immediately.
Implementations should take measures to rate limit Path Responses or the bandwidth used
if necessary.</p>
<p>A Path Challenge block generally is accompanied by an Address block in the same message.
If the address block contains a new IP/port, a peer may
validate that IP/port and initiate peer testing of that new IP/port, with
the session peer or any other peer.
If the peer thinks it is firewalled, and only the port changed, this change is probably
due to NAT rebinding, and further peer testing is probably not required.</p>
<h3 id="successful-path-validation-1">Successful Path Validation</h3>
<p>On successful path validation, the connection is fully migrated to the new IP/port.
On success:</p>
<ul>
<li>Exit the path validation phase</li>
<li>All packets are sent to the new IP and port.</li>
<li>The restrictions on congestion window and PMTU are removed, and they
are allowed to increase. Do not simply restore them to the
old values, as the new path may have different characteristics.</li>
<li>If the IP changed, set calculated RTT and RTO to initial values.
Because port-only changes are commonly the result of NAT rebinding or other middlebox activity,
the peer may instead retain its congestion control state and round-trip estimate in those cases
instead of reverting to initial values.</li>
<li>Delete (invalidate) any tokens sent or received for the old IP/port (optional)</li>
<li>Send a new token block for the new IP/port (optional)</li>
</ul>
<h3 id="cancelling-path-validation">Cancelling Path Validation</h3>
<p>While in the path validation phase, any valid, non-duplicate packets
that are received from the old IP/port and are successfully decrypted
will cause Path Validation to be cancelled.
It is important that a cancelled path validation, caused by a spoofed packet,
does not cause a valid session to be terminated or significantly disrupted.</p>
<p>On cancelled path validation:</p>
<ul>
<li>Exit the path validation phase</li>
<li>All packets are sent to the old IP and port.</li>
<li>The restrictions on congestion window and PMTU are removed, and they
are allowed to increase, or, optionally, restore the previous values</li>
<li>Retransmit any data packets that were previously sent to the new IP/port
to the old IP/port.</li>
</ul>
<h3 id="failed-path-validation-1">Failed Path Validation</h3>
<p>It is important that a failed path validation, caused by a spoofed packet,
does not cause a valid session to be terminated or significantly disrupted.</p>
<p>On failed path validation:</p>
<ul>
<li>Exit the path validation phase</li>
<li>All packets are sent to the old IP and port.</li>
<li>The restrictions on congestion window and PMTU are removed, and they
are allowed to increase.</li>
<li>Optionally, start a path validation on the old IP and port.
If it fails, terminate the session.</li>
<li>Otherwise, follow standard session timeout and termination rules.</li>
<li>Retransmit any data packets that were previously sent to the new IP/port
to the old IP/port.</li>
</ul>
<h3 id="validation-after-local-change">Validation After Local Change</h3>
<p>The above process is defined for peers who receive a packet from
a changed IP/port. However, it may also be initiated in the other direction,
by a peer who detects that his IP or port have changed.
A peer may be able to detect that his local IP changed; however, it is much less
likely to detect that his port changed because of a NAT rebinding.
Therefore, this is optional.</p>
<p>On receiving a path challenge from a peer whose IP or port has changed,
the other peer should initiate a path challenge in the other direction.</p>
<h3 id="use-as-pingpong">Use as Ping/Pong</h3>
<p>Path Validation and Path Response blocks may be used at any time as Ping/Pong packets.
Reception of a Path Validation block does not change any state at the receiver,
unless received from a different IP/port.</p>
<h2 id="multiple-sessions">Multiple Sessions</h2>
<p>Peers should not establish multiple sessions with the same peer,
whether SSU 1 or 2, or with the same or different IP addresses.
However, this could happen, either due to bugs, or a previous
session termination message being lost, or in a race where the
termination message has not arrived yet.</p>
<p>If Bob has an existing session with Alice,
when Bob receives the Session Confirmed from Alice, completing the
handshake and establishing a new session, Bob should:</p>
<ul>
<li>Migrate any unsent or unacknowledged outbound I2NP messages from the
old session to the new one</li>
<li>Send a termination with reason code 22 on the old session</li>
<li>Remove the old session and replace it with the new one</li>
</ul>
<h2 id="session-termination">Session Termination</h2>
<h3 id="handshake-phase">Handshake phase</h3>
<p>Sessions in the handshake phase are generally terminated simply
by timing out, or not responding further. Optionally, they may be terminated
by including a Termination block in the response, but
most errors are not possible to respond to due to a lack of cryptographic keys.
Even if keys are available for a response including a termination block,
it is usually not worth the CPU to perform the DH for the response.
An exception MAY be a Termination block in a retry message, which
is inexpensive to generate.</p>
<h3 id="data-phase">Data phase</h3>
<p>Sessions in the data phase are terminated by sending a data
message that includes a Termination block.
This message should also include an ACK block.
It may, if the session has been up long enough that a previously
sent token has expired or is about to expire,
a New Token block.
This message is not ack-eliciting.
When receiving a Termination block with any reason except &ldquo;Termination Received&rdquo;,
the peer responds with a data message containing a
Termination block with the reason &ldquo;Termination Received&rdquo;.</p>
<p>After sending or receiving a Termination block,
the session should enter the closing phase for some maximum period of time TBD.
The closing state is necessary to protect against the
packet containing the Termination block being lost,
and packets in-flight in the other direction.
While in the closing phase, there is no requirement to process
any additional received packets.
A session in the closing state sends a packet containing a Termination block in response
to any incoming packet that it attributes to the session.
A sesssion should limit the rate at which it generates packets in
the closing state.  For instance, an session could wait for a
progressively increasing number of received packets or amount of time
before responding to received packets.</p>
<p>To minimize the state that a router
maintains for a closing session, sessions may, but are not required to, send the exact same
packet with the same packet number as-is in response to any received packet.
Note: Allowing retransmission of a termination packet is an
exception to the requirement that a new packet number be used
for each packet. Sending new packet numbers
is primarily of advantage to loss recovery and congestion
control, which are not expected to be relevant for a closed connection.
Retransmitting the final packet requires less state.</p>
<p>After receiving a Termination block with the reason &ldquo;Termination Received&rdquo;,
the session may exit the closing phase.</p>
<h3 id="cleanup">Cleanup</h3>
<p>Upon any normal or abnormal termination, routers should
zero-out any in-memory ephemeral data, including handshake ephemeral keys,
symmetric crypto keys, and related information.</p>
<h2 id="mtu">MTU</h2>
<p>Requirements vary, based on whether the published address is shared with SSU 1.
Current SSU 1 IPv4 minimum is 620, which is definitely too small.</p>
<p>The minimum SSU2 MTU is 1280 for both IPv4 and IPv6,
which is the same as specified in <a href="https://datatracker.ietf.org/doc/html/rfc9000">RFC 9000</a>
.
See below.
By increasing the minimum MTU, 1 KB tunnel messages
and short tunnel build messages will fit in one datagram, greatly reducing the
typical amount of fragmentation. This also allows
an increase in the maximum I2NP message size.
1820-byte streaming messages should fit in two datagrams.</p>
<p>A router must not enable SSU2 or publish an SSU2 address unless
the MTU for that address is at least 1280.</p>
<p>Routers must publish a non-default MTU in each SSU or SSU2 router address.</p>
<h3 id="ssu-address">SSU Address</h3>
<p>Shared address with SSU 1, must follow SSU 1 rules.
IPv4: Default and max is 1484. Min is 1292.
(IPv4 MTU + 4) must be a multiple of 16.
IPv6: Must be published, min is 1280 and the max is 1488.
IPv6 MTU must be a multiple of 16.</p>
<h3 id="ssu2-address">SSU2 Address</h3>
<p>IPv4: Default and max is 1500. Min is 1280.
IPv6: Default and max is 1500. Min is 1280.
No multiple of 16 rules, but should probably be a multiple of 2 at least.</p>
<h3 id="pmtu-discovery">PMTU Discovery</h3>
<p>For SSU 1, current Java I2P performs PMTU discovery by starting with small packets and
gradually increasing the size, or increasing based on received packet size.
This is crude and greatly reduces the efficiency.
Continuing this feature in SSU 2 is TBD.</p>
<p>Recent studies <a href="https://aura.abdn.ac.uk/bitstream/handle/2164/11693/tma2018_paper57.pdf">PMTU</a>
 suggest that a minimum for IPv4 of 1200 or more would work
for more than 99% of connections. QUIC <a href="https://datatracker.ietf.org/doc/html/rfc9000">RFC 9000</a>
 requires a minimum IP
packet size of 1280 bytes.</p>
<p>quote <a href="https://datatracker.ietf.org/doc/html/rfc9000">RFC 9000</a>
:</p>
<p>The maximum datagram size is defined as the largest size of UDP
payload that can be sent across a network path using a single UDP
datagram.  QUIC MUST NOT be used if the network path cannot support a
maximum datagram size of at least 1200 bytes.</p>
<p>QUIC assumes a minimum IP packet size of at least 1280 bytes.  This
is the IPv6 minimum size [IPv6] and is also supported by most modern
IPv4 networks.  Assuming the minimum IP header size of 40 bytes for
IPv6 and 20 bytes for IPv4 and a UDP header size of 8 bytes, this
results in a maximum datagram size of 1232 bytes for IPv6 and 1252
bytes for IPv4.  Thus, modern IPv4 and all IPv6 network paths are
expected to be able to support QUIC.</p>
<p>Note: This requirement to support a UDP payload of 1200 bytes
limits the space available for IPv6 extension headers to 32
bytes or IPv4 options to 52 bytes if the path only supports the
IPv6 minimum MTU of 1280 bytes.  This affects Initial packets
and path validation.</p>
<p>end quote</p>
<h3 id="handshake-min-size">Handshake Min Size</h3>
<p>QUIC requires that Initial datagrams in both directions be at least 1200 bytes,
to prevent amplification attacks. and ensure the PMTU supports it in both directions.</p>
<p>We could require this for Session Request and Session Created,
at substantial cost in bandwidth.
Perhaps we could do this only if we don&rsquo;t have a token,
or after a Retry message is received.
TBD</p>
<p>QUIC requires that Bob send no more than three times the amount of data
received until the client address is validated.
SSU2 meets this requirement inherently, because the Retry message
is about the same size as the Token Request message, and is
smaller than the Session Request message.
Also, the Retry message is only sent once.</p>
<h3 id="path-message-min-size">Path Message Min Size</h3>
<p>QUIC requires that messages containing PATH_CHALLENGE or PATH_RESPONSE blocks be at least 1200 bytes,
to prevent amplification attacks. and ensure the PMTU supports it in both directions.</p>
<p>We could require this as well, at substantial cost in bandwidth.
However, these cases should be rare.
TBD</p>
<h3 id="max-i2np-message-size">Max I2NP Message Size</h3>
<p>IPv4:
No IP fragmentation is assumed.
IP + datagram header is 28 bytes.
This assumes no IPv4 options.
Max message size is MTU - 28.
Data phase header is 16 bytes and MAC is 16 bytes, totaling 32 bytes.
Payload size is MTU - 60.
Max data phase payload is 1440 for a max 1500 MTU.
Max data phase payload is 1220 for a min 1280 MTU.</p>
<p>IPv6:
No IP fragmentation is allowed.
IP + datagram header is 48 bytes.
This assumes no IPv6 extension headers.
Max message size is MTU - 48.
Data phase header is 16 bytes and MAC is 16 bytes, totaling 32 bytes.
Payload size is MTU - 80.
Max data phase payload is 1420 for a max 1500 MTU.
Max data phase payload is 1200 for a min 1280 MTU.</p>
<p>In SSU 1, the guidelines were a strict maximum of about 32 KB for
a I2NP message based on 64 maximum fragments and a 620 minimum MTU.
Due to overhead for bundled LeaseSets and session keys, the practical limit
at the application level was about 6KB lower, or about 26KB.
The SSU 1 protocol allows for 128 fragments but current implementations
limit it to 64 fragments.</p>
<p>By raising the minimum MTU to 1280, with a data phase payload of
approximately 1200, an SSU 2 message of about 76 KB is possible in 64 fragments
and 152 KB in 128 fragments. This easily allows a maximum of 64 KB.</p>
<p>Due to fragmentation in tunnels, and fragmentation in SSU 2,
the chance of message loss increases exponentially with message size.
We continue to recommend a practical limit of about 10 KB at the
application layer for I2NP datagrams.</p>
<h2 id="peer-test-process">Peer Test Process</h2>
<p>See Peer Test Security above for an analysis of SSU1 Peer Test and
the goals for SSU2 Peer Test.</p>
<pre tabindex="0"><code>Alice                     Bob                  Charlie
1. PeerTest -------------------&gt;
                              Alice RI -------------------&gt;
2.                          PeerTest -------------------&gt;
3.                             &lt;------------------ PeerTest
          &lt;---------------- Charlie RI
4.      &lt;------------------ PeerTest

5.      &lt;----------------------------------------- PeerTest
6. PeerTest -----------------------------------------&gt;
7.      &lt;----------------------------------------- PeerTest
</code></pre><p>When rejected by Bob:</p>
<pre tabindex="0"><code>Alice                     Bob                  Charlie
1. PeerTest -------------------&gt;
4.      &lt;------------------ PeerTest (reject)
</code></pre><p>When rejected by Charlie:</p>
<pre tabindex="0"><code>Alice                     Bob                  Charlie
1. PeerTest -------------------&gt;
                              Alice RI -------------------&gt;
2.                          PeerTest -------------------&gt;
3.                             &lt;------------------ PeerTest (reject)
                        (optional: Bob could try another Charlie here)
4.      &lt;------------------ PeerTest (reject)
</code></pre><p>NOTE: RI may be sent either I2NP Database Store messages in I2NP blocks,
or as RI blocks (if small enough). These may be contained in the
same packets as the peer test blocks, if small enough.</p>
<p>Messages 1-4 are in-session using Peer Test blocks in a Data message.
Messages 5-7 are out-of-session using Peer Test blocks in a Peer Test message.</p>
<p>NOTE: As in SSU 1, messages 4 and 5 may arrive in either order.
Message 5 and/or 7 may not be received at all if Alice is firewalled.
When message 5 arrives before message 4,
Alice cannot immediately send message 6, because she does not
yet have Charlie&rsquo;s intro key to encrypt the header.
When message 4 arrives before message 5,
Alice should not immediately send message 6, because she should wait
to see if message 5 arrives without opening the firewall with message 6.</p>
<table>
  <thead>
      <tr>
          <th>Message</th>
          <th>Path</th>
          <th>Intro Key</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>1</td>
          <td>A-&gt;B session</td>
          <td>in-session</td>
      </tr>
      <tr>
          <td>2</td>
          <td>B-&gt;C session</td>
          <td>in-session</td>
      </tr>
      <tr>
          <td>3</td>
          <td>C-&gt;B session</td>
          <td>in-session</td>
      </tr>
      <tr>
          <td>4</td>
          <td>B-&gt;A session</td>
          <td>in-session</td>
      </tr>
      <tr>
          <td>5</td>
          <td>C-&gt;A</td>
          <td>Alice</td>
      </tr>
      <tr>
          <td>6</td>
          <td>A-&gt;C</td>
          <td>Charlie</td>
      </tr>
      <tr>
          <td>7</td>
          <td>C-&gt;A</td>
          <td>Alice</td>
      </tr>
  </tbody>
</table>
<h3 id="versions">Versions</h3>
<p>Cross-version peer testing is not supported.
The only allowed version combination is where all peers are version 2.</p>
<table>
  <thead>
      <tr>
          <th>Alice/Bob</th>
          <th>Bob/Charlie</th>
          <th>Alice/Charlie</th>
          <th>Supported</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>1</td>
          <td>1</td>
          <td>1</td>
          <td>SSU 1</td>
      </tr>
      <tr>
          <td>1</td>
          <td>1</td>
          <td>2</td>
          <td>no, use 1/1/1</td>
      </tr>
      <tr>
          <td>1</td>
          <td>2</td>
          <td>1</td>
          <td>no, Bob must s</td>
      </tr>
      <tr>
          <td>1</td>
          <td>2</td>
          <td>2</td>
          <td>no, Bob must s</td>
      </tr>
      <tr>
          <td>2</td>
          <td>1</td>
          <td>1</td>
          <td>no, Bob must s</td>
      </tr>
      <tr>
          <td>2</td>
          <td>1</td>
          <td>2</td>
          <td>no, Bob must s</td>
      </tr>
      <tr>
          <td>2</td>
          <td>2</td>
          <td>1</td>
          <td>no, use 2/2/2</td>
      </tr>
      <tr>
          <td>2</td>
          <td>2</td>
          <td>2</td>
          <td>yes</td>
      </tr>
  </tbody>
</table>
<h3 id="retransmissions">Retransmissions</h3>
<p>Messages 1-4 are in-session and are covered by the
data phase ACK and retransmission processes.
Peer Test blocks are ack-eliciting.</p>
<p>Messages 5-7 may be retransmitted, unchanged.</p>
<h3 id="ipv6-notes">IPv6 Notes</h3>
<p>As in SSU 1, testing of IPv6 addresses is supported,
and Alice-Bob and Alice-Charlie communication may be via IPv6,
if Bob and Charlie indicate support with a &lsquo;B&rsquo; capability in their published IPv6 address.
See Proposal 126 for details.</p>
<p>As in SSU 1 prior to 0.9.50,
Alice sends the request to Bob using an existing session over the transport (IPv4 or IPv6) that she wishes to test.
When Bob receives a request from Alice via IPv4, Bob must select a Charlie that advertises an IPv4 address.
When Bob receives a request from Alice via IPv6, Bob must select a Charlie that advertises an IPv6 address.
The actual Bob-Charlie communication may be via IPv4 or IPv6 (i.e., independent of Alice&rsquo;s address type).
This is NOT the behavior of SSU 1 as of 0.9.50, where mixed IPv4/v6 requests are allowed.</p>
<h3 id="processing-by-bob">Processing by Bob</h3>
<p>Unlike in SSU 1, Alice specifies the requested test IP and port in message 1.
Bob should validate this IP and port, and reject with code 5 if invalid.
Recommended IP validation is that, for IPv4, it matches Alice&rsquo;s IP,
and for IPv6, at least the first 8 bytes of the IP match.
Port validation should reject privileged ports and ports for well-known protocols.</p>
<h2 id="relay-process">Relay Process</h2>
<p>See Relay Security above for an analysis of SSU1 Relay and
the goals for SSU2 Relay.</p>
<pre tabindex="0"><code>Alice                         Bob                  Charlie
     lookup Bob RI

     SessionRequest --------------------&gt;
          &lt;------------  SessionCreated
     SessionConfirmed  -----------------&gt;

1. RelayRequest ----------------------&gt;
                                           Alice RI  ------------&gt;
2.                                       RelayIntro -----------&gt;
3.                                  &lt;-------------- RelayResponse
4.      &lt;-------------- RelayResponse

5.      &lt;-------------------------------------------- HolePunch
6. SessionRequest --------------------------------------------&gt;
7.      &lt;-------------------------------------------- SessionCreated
8. SessionConfirmed ------------------------------------------&gt;
</code></pre><p>When rejected by Bob:</p>
<pre tabindex="0"><code>Alice                         Bob                  Charlie
     lookup Bob RI

     SessionRequest --------------------&gt;
          &lt;------------  SessionCreated
     SessionConfirmed  -----------------&gt;

1. RelayRequest ----------------------&gt;
4.      &lt;-------------- RelayResponse
</code></pre><p>When rejected by Charlie:</p>
<pre tabindex="0"><code>Alice                         Bob                  Charlie
     lookup Bob RI

     SessionRequest --------------------&gt;
          &lt;------------  SessionCreated
     SessionConfirmed  -----------------&gt;

1. RelayRequest ----------------------&gt;
                                           Alice RI  ------------&gt;
2.                                       RelayIntro -----------&gt;
3.                                  &lt;-------------- RelayResponse
4.      &lt;-------------- RelayResponse
</code></pre><p>NOTE: RI may be sent either I2NP Database Store messages in I2NP blocks,
or as RI blocks (if small enough). These may be contained in the
same packets as the ralay blocks, if small enough.</p>
<p>In SSU 1, Charlie&rsquo;s router info contains the IP, port, intro key, relay tag, and expiration of each introducer.</p>
<p>In SSU 2, Charlie&rsquo;s router info contains the router hash, relay tag, and expiration of each introducer.</p>
<p>Alice should reduce the number of round trips required by first
selecting an introducer (Bob) that she already has a connection to.
Second, if none, select an introducer she already has the router info for.</p>
<p>Cross-version relaying should also be supported if possible.
This will facilitate a gradual transition from SSU 1 to SSU 2.
The allowed version combinations are (TODO):</p>
<table>
  <thead>
      <tr>
          <th>Alice/Bob</th>
          <th>Bob/Charlie</th>
          <th>Alice/Charlie</th>
          <th>Supported</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>1</td>
          <td>1</td>
          <td>1</td>
          <td>SSU 1</td>
      </tr>
      <tr>
          <td>1</td>
          <td>1</td>
          <td>2</td>
          <td>no, use 1/1/1</td>
      </tr>
      <tr>
          <td>1</td>
          <td>2</td>
          <td>1</td>
          <td>yes?</td>
      </tr>
      <tr>
          <td>1</td>
          <td>2</td>
          <td>2</td>
          <td>no, use 1/2/1</td>
      </tr>
      <tr>
          <td>2</td>
          <td>1</td>
          <td>1</td>
          <td>yes?</td>
      </tr>
      <tr>
          <td>2</td>
          <td>1</td>
          <td>2</td>
          <td>yes?</td>
      </tr>
      <tr>
          <td>2</td>
          <td>2</td>
          <td>1</td>
          <td>no, use 2/2/2</td>
      </tr>
      <tr>
          <td>2</td>
          <td>2</td>
          <td>2</td>
          <td>yes</td>
      </tr>
  </tbody>
</table>
<h3 id="retransmissions-1">Retransmissions</h3>
<p>Relay Request, Relay Intro, and Relay Response
are all in-session and are covered by the
data phase ACK and retransmission processes.
Relay Request, Relay Intro, and Relay Response blocks are ack-eliciting.</p>
<p>Hole punch may be retransmitted, as in SSU 1.</p>
<h3 id="ipv4v6">IPv4/v6</h3>
<p>All features of SSU 1 relay are supported, including those documented in
<a href="../../../en/proposals/158-ipv6-transport-enhancements/">Proposal 158</a>
 and supported as of 0.9.50.
IPv4 and IPv6 introductions are supported.
A Relay Request may be sent over an IPv4 session for an IPv6 introduction,
and a Relay Request may be sent over an IPv6 session for an IPv4 introduction.</p>
<h3 id="processing-by-alice">Processing by Alice</h3>
<p>Following are differences from SSU 1 and recommendations for SSU 2 implementation.</p>
<h4 id="introducer-selection">Introducer Selection</h4>
<p>In SSU 1, introduction is relatively inexpensive, and Alice generally sends Relay Requests to all introducers.
In SSU 2, introduction is more expensive, as a connection must first be established with an introducer.
To minimize introduction latency and overhead, the recommended processing steps are as follows:</p>
<ul>
<li>Ignore any introducers that are expired based on the iexp value in the address</li>
<li>If an SSU2 connection is already established to one or more introducers,
pick one and send the Relay Request to that introducer only.</li>
<li>Otherwise, if a Router Info is locally known for one or more introducers,
pick one and connect to that introducer only.</li>
<li>Otherwise, lookup the Router Infos for all introducers,
connect to the introducer whose Router Info is received first.</li>
</ul>
<h4 id="response-handling">Response Handling</h4>
<p>In both SSU 1 and SSU 2,
the Relay Response and Hole Punch may be received in either order,
or may not be received at all.</p>
<p>In SSU 1, Alice usually receives the Relay Response (1 RTT)
before the Hole Punch (1 1/2 RTT).
It may not be well-documented in those specifications, but
Alice must receive the Relay Response from Bob before continuing,
to receive Charlie&rsquo;s IP.
If the Hole Punch is received first, Alice will not recognize it,
because it contains no data and the source IP is not recognized.
After receiving the Relay Response, Alice should wait for
EITHER receiving the Hole Punch from Charlie, OR
a short delay (recommended 500 ms) before initiating the handshake with Charlie.</p>
<p>In SSU 2, Alice will usually receive the Hole Punch (1 1/2 RTT)
before the Relay Response (2 RTT).
The SSU 2 Hole Punch is easier to process than in SSU 1, because it is a full
message with defined connection IDs (derived from the relay nonce) and contents including Charlie&rsquo;s IP.
The Relay Response (Data message) and Hole Punch message contain the identical
signed Relay Response block.
Therefore, Alice may initiate the handshake with Charlie after
EITHER receiving the Hole Punch from Charlie, OR receiving the Relay Response from Bob.</p>
<p>The signature verification of the Hole Punch includes the introducer&rsquo;s (Bob&rsquo;s) router hash.
If Relay Requests have been sent to more than one introducer,
there are several options to validate the signature:</p>
<ul>
<li>Try each hash to which a request was sent</li>
<li>Use different nonces for each introducer, and use that to determine which
introducer this Hole Punch was in response to</li>
<li>Don&rsquo;t re-validate the signature if the contents are identical
to that in the Relay Response, if already received</li>
<li>Don&rsquo;t validate the signature at all</li>
</ul>
<p>If Charlie is behind a symmetric NAT, his reported port in the Relay Response and Hole Punch
may not be accurate. Therefore, Alice should check the UDP source port of the Hole Punch
message, and use that if it is different than the reported port.</p>
<h3 id="tag-requests-by-bob">Tag Requests by Bob</h3>
<p>In SSU 1, only Alice could request a tag, in the Session Request.
Bob could never request a tag, and Alice could not relay for Bob.</p>
<p>In SSU2, Alice generally requests a tag in the Session Request,
but either Alice or Bob may also request a tag in the data phase.
Bob generally is not firewalled after receiving an inbound request,
but it could be after a relay, or Bob&rsquo;s state may change,
or he may request an introducer for the other address type (IPv4/v6).
So, in SSU2, it is possible for both Alice and Bob to simultaneously be relays for the other party.</p>
<h2 id="published-router-info">Published Router Info</h2>
<h3 id="address-properties">Address Properties</h3>
<p>The following address properties may be published, unchanged from SSU 1,
including changes in <a href="../../../en/proposals/158-ipv6-transport-enhancements/">Proposal 158</a>
 supported as of API 0.9.50:</p>
<ul>
<li>
<p>caps: [B,C,4,6] capabilities</p>
</li>
<li>
<p>host: IP (IPv4 or IPv6).
Shortened IPv6 address (with &ldquo;::&rdquo;) is allowed.
May or may not be present if firewalled.
Host names are not allowed.</p>
</li>
<li>
<p>iexp[0-2]: Expiration of this introducer.
ASCII digits, in seconds since the epoch.
Only present if firewalled, and introducers are required.
Optional (even if other properties for this introducer are present).</p>
</li>
<li>
<p>ihost[0-2]: Introducer&rsquo;s IP (IPv4 or IPv6).
Shortened IPv6 address (with &ldquo;::&rdquo;) is allowed.
Only present if firewalled, and introducers are required.
Host names are not allowed.
SSU address only.</p>
</li>
<li>
<p>ikey[0-2]: Introducer&rsquo;s Base 64 introduction key.
Only present if firewalled, and introducers are required.
SSU address only.</p>
</li>
<li>
<p>iport[0-2]: Introducer&rsquo;s port 1024 - 65535.
Only present if firewalled, and introducers are required.
SSU address only.</p>
</li>
<li>
<p>itag[0-2]: Introducer&rsquo;s tag 1 - (2**32 - 1)
ASCII digits.
Only present if firewalled, and introducers are required.</p>
</li>
<li>
<p>key: Base 64 introduction key.</p>
</li>
<li>
<p>mtu: Optional. See MTU section above.</p>
</li>
<li>
<p>port: 1024 - 65535
May or may not be present if firewalled.</p>
</li>
</ul>
<h3 id="published-addresses">Published Addresses</h3>
<p>The published RouterAddress (part of the RouterInfo) will have a
protocol identifier of either &ldquo;SSU&rdquo; or &ldquo;SSU2&rdquo;.</p>
<p>The RouterAddress must contain three options
to indicate SSU2 support:</p>
<ul>
<li>
<p>s=(Base64 key)
The current Noise static public key (s) for this RouterAddress.
Base 64 encoded using the standard I2P Base 64 alphabet.
32 bytes in binary, 44 bytes as Base 64 encoded,
little-endian X25519 public key.</p>
</li>
<li>
<p>i=(Base64 key)
The current introduction key for encrypting the headers for this RouterAddress.
Base 64 encoded using the standard I2P Base 64 alphabet.
32 bytes in binary, 44 bytes as Base 64 encoded,
big-endian ChaCha20 key.</p>
</li>
<li>
<p>v=2
The current version (2).
When published as &ldquo;SSU&rdquo;, additional support for version 1 is implied.
Support for future versions will be with comma-separated values,
e.g. v=2,3
Implementation should verify compatibility, including multiple
versions if a comma is present. Comma-separated versions must
be in numerical order.</p>
</li>
</ul>
<p>Alice must verify that all three options are present and valid
before connecting using the SSU2 protocol.</p>
<p>When published as &ldquo;SSU&rdquo; with &ldquo;s&rdquo;, &ldquo;i&rdquo;, and &ldquo;v&rdquo; options,
and with &ldquo;host&rdquo; and &ldquo;port&rdquo; options,
the router must accept incoming connections on that host and port
for both SSU and SSU2 protocols, and automatically detect the protocol
version.</p>
<p>When published as &ldquo;SSU2&rdquo; with &ldquo;s&rdquo;, &ldquo;i&rdquo;, and &ldquo;v&rdquo; options,
and with &ldquo;host&rdquo; and &ldquo;port&rdquo; options,
the router accepts incoming connections on that host and port
for the SSU2 protocol only.</p>
<p>If a router supports both SSU1 and SSU2 connections but
does not implement automatic version detection for incoming connections,
it must advertise both &ldquo;SSU&rdquo; and &ldquo;SSU2&rdquo; addresses, and include
the SSU2 options in the &ldquo;SSU2&rdquo; address only.
The router should set a lower cost value (higher priority)
in the &ldquo;SSU2&rdquo; address than the &ldquo;SSU&rdquo; address, so SSU2 is preferred.</p>
<p>If multiple SSU2 RouterAddresses (either as &ldquo;SSU&rdquo; or &ldquo;SSU2&rdquo;) are published
in the same RouterInfo (for additional IP addresses or ports),
all addresses specifying the same port must contain the identical SSU2 options and values.
In particular, all must contain the same static key &ldquo;s&rdquo; and introduction key &ldquo;i&rdquo;.</p>
<h4 id="introducers">Introducers</h4>
<p>When published as SSU or SSU2 with introducers, the following options are present:</p>
<ul>
<li>
<p>ih[0-2]=(Base64 hash)
A router hash for an introducer.
Base 64 encoded using the standard I2P Base 64 alphabet.
32 bytes in binary, 44 bytes as Base 64 encoded</p>
</li>
<li>
<p>iexp[0-2]: Expiration of this introducer.
Unchanged from SSU 1.</p>
</li>
<li>
<p>itag[0-2]: Introducer&rsquo;s tag 1 - (2**32 - 1)
Unchanged from SSU 1.</p>
</li>
</ul>
<p>The following options are for SSU only and are not used for SSU2.
In SSU2, Alice gets this information from Charlie&rsquo;s RI instead.</p>
<ul>
<li>ihost[0-2]</li>
<li>ikey[0-2]</li>
<li>itag[0-2]</li>
</ul>
<p>A router must not publish host or port in the address when publishing introducers.
A router must publish 4 and/or 6 caps in the address when publishing introducers
to indicate support for IPv4 and/or IPv6.
This is the same as the current practice for recent SSU 1 addresses.</p>
<p>Note: If published as SSU, and there is a mix of SSU 1 and SSU2 introducers,
the SSU 1 introducers should be at the lower indexes and
the SSU2 introducers should be at the higher indexes,
for compatibility with older routers.</p>
<h3 id="unpublished-ssu2-address">Unpublished SSU2 Address</h3>
<p>If Alice does not publish her SSU2 address (as &ldquo;SSU&rdquo; or &ldquo;SSU2&rdquo;) for incoming connections,
she must publish a &ldquo;SSU2&rdquo; router address containing only her static key and SSU2 version,
so that Bob may validate the key after receiving Alice&rsquo;s RouterInfo in Session Confirmed part 2.</p>
<ul>
<li>
<p>s=(Base64 key)
As defined above for published addresses.</p>
</li>
<li>
<p>i=(Base64 key)
As defined above for published addresses.</p>
</li>
<li>
<p>v=2
As defined above for published addresses.</p>
</li>
</ul>
<p>This router address will not contain &ldquo;host&rdquo; or &ldquo;port&rdquo; options,
as these are not required for outbound SSU2 connections.
The published cost for this address does not strictly matter, as it is inbound only;
however, it may be helpful to other routers if the cost is set higher (lower priority)
than other addresses. The suggested value is 14.</p>
<p>Alice may also simply add the &ldquo;i&rdquo; &ldquo;s&rdquo; and &ldquo;v&rdquo; options to an existing published &ldquo;SSU&rdquo; address.</p>
<h3 id="public-key-and-iv-rotation">Public Key and IV Rotation</h3>
<p>Using the same static keys for NTCP2 and SSU2 is allowed, but not recommended.</p>
<p>Due to caching of RouterInfos, routers must not rotate the static public key or IV
while the router is up, whether in a published address or not. Routers must
persistently store this key and IV for reuse after an immediate restart, so incoming
connections will continue to work, and restart times are not exposed.  Routers
must persistently store, or otherwise determine, last-shutdown time, so that
the previous downtime may be calculated at startup.</p>
<p>Subject to concerns about exposing restart times, routers may rotate this key or IV
at startup if the router was previously down for some time (several days at
least).</p>
<p>If the router has any published SSU2 RouterAddresses (as SSU or SSU2), the
minimum downtime before rotation should be much longer, for example one month,
unless the local IP address has changed or the router &ldquo;rekeys&rdquo;.</p>
<p>If the router has any published SSU RouterAddresses, but not SSU2 (as SSU or
SSU2) the minimum downtime before rotation should be longer, for example one
day, unless the local IP address has changed or the router &ldquo;rekeys&rdquo;.  This
applies even if the published SSU address has introducers.</p>
<p>If the router does not have any published RouterAddresses (SSU, SSU2, or
SSU), the minimum downtime before rotation may be as short as two hours, even
if the IP address changes, unless the router &ldquo;rekeys&rdquo;.</p>
<p>If the router &ldquo;rekeys&rdquo; to a different Router Hash, it should generate a new
noise key and intro key as well.</p>
<p>Implementations must be aware that changing the static public key or IV will prohibit
incoming SSU2 connections from routers that have cached an older RouterInfo.
RouterInfo publishing, tunnel peer selection (including both OBGW and IB
closest hop), zero-hop tunnel selection, transport selection, and other
implementation strategies must take this into account.</p>
<p>Intro key rotation is subject to identical rules as key rotation.</p>
<p>Note: The minimum downtime before rekeying may be modified to ensure network
health, and to prevent reseeding by a router down for a moderate amount of
time.</p>
<h4 id="identity-hiding">Identity Hiding</h4>
<p>Deniability is not a goal. See overview above.</p>
<p>Each pattern is assigned properties describing the confidentiality supplied to
the initiator&rsquo;s static public key, and to the responder&rsquo;s static public key.
The underlying assumptions are that ephemeral private keys are secure, and that
parties abort the handshake if they receive a static public key from the other
party which they don&rsquo;t trust.</p>
<p>This section only considers identity leakage through static public key fields
in handshakes.  Of course, the identities of Noise participants might be
exposed through other means, including payload fields, traffic analysis, or
metadata such as IP addresses.</p>
<p>Alice: (8) Encrypted with forward secrecy to an authenticated party.</p>
<p>Bob: (3) Not transmitted, but a passive attacker can check candidates for the
responder&rsquo;s private key and determine whether the candidate is correct.</p>
<p>Bob publishes his static public key in the netdb. Alice may not, but must include it in the RI
sent to Bob.</p>
<h2 id="packet-guidelines">Packet Guidelines</h2>
<h3 id="outbound-packet-creation">Outbound Packet Creation</h3>
<p>Handshake messages (Session Request/Created/Confirmed, Retry) basic steps, in order:</p>
<ul>
<li>Create 16 or 32 byte header</li>
<li>Create payload</li>
<li>mixHash() the header (except for Retry)</li>
<li>Encrypt the payload using Noise (except for Retry, use ChaChaPoly with the header as AD)</li>
<li>Encrypt the header, and for Session Request/Created, the ephemeral key</li>
</ul>
<p>Data phase messages basic steps, in order:</p>
<ul>
<li>Create 16-byte header</li>
<li>Create payload</li>
<li>Encrypt the payload using ChaChaPoly using the header as AD</li>
<li>Encrypt the header</li>
</ul>
<h3 id="inbound-packet-handling">Inbound Packet Handling</h3>
<h4 id="summary-1">Summary</h4>
<p>Initial processing of all inbound messages:</p>
<ul>
<li>Decrypt the first 8 bytes of the header (the Destination Connection ID)
with the intro key</li>
<li>Lookup the connection by the Destination Connection ID</li>
<li>If the connection is found and is in the data phase, go to the
data phase section</li>
<li>If the connection is not found, go to the handshake section</li>
<li>Note: Peer Test and Hole Punch messages may also be looked up
by the Destination Connection ID created from the test or relay nonce.</li>
</ul>
<p>Handshake messages (Session Request/Created/Confirmed, Retry, Token Request)
and other out-of-session messages (Peer Test, Hole Punch)
processing:</p>
<ul>
<li>Decrypt bytes 8-15 of the header
(the packet type, version, and net ID) with the intro key. If it is a
valid Session Request, Token Request, Peer Test, or Hole Punch, continue</li>
<li>If not a valid message, lookup a pending outbound connection by the packet
source IP/port, treat the packet as a Session Created or Retry.
Re-decrypt the first 8 bytes of the header with the correct key,
and the bytes 8-15 of the header
(the packet type, version, and net ID). If it is a
valid Session Created or Retry, continue</li>
<li>If not a valid message, fail, or queue as a possible out-of-order data phase packet</li>
<li>For Session Request/Created, Retry, Token Request, Peer Test, and Hole Punch, decrypt bytes 16-31 of the header</li>
<li>For Session Request/Created, decrypt the ephemeral key</li>
<li>Validate all header fields, stop if not valid</li>
<li>mixHash() the header</li>
<li>For Session Request/Created/Confirmed, decrypt the payload using Noise</li>
<li>For Retry and data phase, decrypt the payload using ChaChaPoly</li>
<li>Process the header and payload</li>
</ul>
<p>Data phase messages processing:</p>
<ul>
<li>Decrypt bytes 8-15 of the header
(the packet type, version, and net ID) with the correct key</li>
<li>Decrypt the payload using ChaChaPoly using the header as AD</li>
<li>Process the header and payload</li>
</ul>
<h4 id="details">Details</h4>
<p>In SSU 1, inbound packet classification is difficult, because there is no
header to indicate session number. Routers must first match the source IP and port
to an existing peer state, and if not found, attempt multiple decryptions with different
keys to find the appropriate peer state or start a new one.
In the event that the source IP or port for an existing session changes,
possibly due to NAT behavior,
the router may use expensive heuristics to attempt to match the packet to an existing session
and recover the contents.</p>
<p>SSU 2 is designed to minimize the inbound packet classification effort while maintaining
DPI resistance and other on-path threats. The Connection ID number is included in the header
for all message types, and encrypted (obfuscated) using ChaCha20 with a known key and nonce.
Additionally, the message type is also included in the header
(encrypted with header protection to a known key and then obfuscated with ChaCha20)
and may be used for additional classification.
In no case is a trial DH or other asymmetric crypto operation necessary to classify a packet.</p>
<p>For almost all messages from all peers, the ChaCha20 key for the Connection ID encryption is the destination router&rsquo;s
introduction key as published in the netdb.</p>
<p>The only exceptions are the first messages sent from Bob to Alice (Session Created or Retry)
where Alice&rsquo;s introduction key is not yet known to Bob. In these cases, Bob&rsquo;s introduction key
is used as the key.</p>
<p>The protocol is designed to minimize packet classification processing that
might require additional crypto operations in multiple
fallback steps or complex heuristics.
Additionally, the vast majority of received packets will not require
a (possibly expensive) fallback lookup by source IP/port
and a second header decryption.
Only Session Created and Retry (and possibly others TBD) will require
the fallback processing.
If an endpoint changes IP or port after session creation,
the connection ID is still used to lookup the session.
It is never necessary to use heuristics to find the session,
for example by looking for a different session with the same
IP but a different port.</p>
<p>Therefore, the recommended processing steps in the receiver loop logic are:</p>
<ol>
<li>
<p>Decrypt the first 8 bytes with ChaCha20 using the local introduction key,
to recover the Destination Connection ID.
If the Connection ID matches a current or pending inbound session:</p>
<p>a) Using the appropriate key, decrypt the header bytes 8-15
to recover the version, net ID, and message type.
b) If the message type is Session Confirmed, it is a long header.
Verify the net ID and protocol version are valid.
Decrypt the bytes 15-31 of the header with ChaCha20
using the local intro key. Then MixHash() the
decrypted 32 byte header and decrypt the message with Noise.
c) If the message type is valid but not Session Confirmed,
it is a short header.
Verify the net ID and protocol version are valid.
decrypt the rest of the message with ChaCha20/Poly1305
using the session key, using the decrypted 16-byte header
as the AD.
d) (optional) If connection ID is a pending inbound session
awaiting a Session Confirmed message,
but the net ID, protocol, or message type is not valid,
it could be a Data message received out-of-order before the
Session Confirmed, so the data phase header protection keys are not yet known,
and the header bytes 8-15 were incorrectly decrypted.
Queue the message, and attempt to decrypt it once the
Session Confirmed message is received.
e) If b) or c) fails, drop the message.</p>
</li>
<li>
<p>If the connection ID does not match a current session:
Check the plaintext header at bytes 8-15 are valid
(without doing any header protection operation).
Verify the net ID and protocol version are valid, and
the message type is Session Request, or other message type
allowed out-of-session (TBD).</p>
<p>a) If all is valid and the message type is Session Request,
decrypt bytes 16-31 of the header and the 32-byte X value
with ChaCha20 using the local intro key.</p>
<ul>
<li>If the token at header bytes 24-31 is accepted,
then MixHash() the decrypted 32 byte header and
decrypt the message with Noise.
Send a Session Created in response.</li>
<li>If the token is not accepted, send a Retry message to the
source IP/port with a token. Do not attempt to
decrypt the message with Noise to avoid DDoS attacks.</li>
</ul>
<p>b) If the message type is some other message that is valid
out-of-session, presumably with a short header,
decrypt the rest of the message with ChaCha20/Poly1305
using the intro key, and using the decrypted 16-byte header
as the AD. Process the message.
c) If a) or b) fails, go to step 3)</p>
</li>
<li>
<p>Look up a pending outbound session by the source IP/port of the packet.</p>
<p>a) If found, re-decrypt the first 8 bytes with ChaCha20 using Bob&rsquo;s introduction key
to recover the Destination Connection ID.
b) If the connection ID matches the pending session:
Using the correct key, decrypt bytes 8-15 of the header
to recover the version, net ID, and message type.
Verify the net ID and protocol version are valid, and
the message type is Session Created or Retry, or other message type
allowed out-of-session (TBD).</p>
<ul>
<li>If all is valid and the message type is Session Created,
decrypt the next 16 bytes of the header and the 32-byte Y value
with ChaCha20 using Bob&rsquo;s intro key.
Then MixHash() the decrypted 32 byte header and
decrypt the message with Noise.
Send a Session Confirmed in response.</li>
<li>If all is valid and the message type is Retry,
decrypt bytes 16-31 of the header
with ChaCha20 using Bob&rsquo;s intro key.
Decrypt and validate the message using ChaCha20/Poly1305 using
TBD as the key and TBD as the nonce and the decrypted 32-byte header as the AD.
Resend a Session Request with the received token in response.</li>
<li>If the message type is some other message that is valid
out-of-session, presumably with a short header,
decrypt the rest of the message with ChaCha20/Poly1305
using the intro key, and using the decrypted 16-byte header
as the AD. Process the message.</li>
</ul>
<p>c) If a pending outbound session is not found,
or the connection ID does not match the pending session, drop the message,
unless the port is shared with SSU 1.</p>
</li>
<li>
<p>If running SSU 1 on the same port, attempt to process the message as an SSU 1 packet.</p>
</li>
</ol>
<h4 id="error-handling">Error Handling</h4>
<p>In general, a session (in the handshake or data phase) should never be destroyed
after receiving a packet with an unexpected message type. This prevents
packet injection attacks. These packets will also commonly be received
after retransmission of a handshake packet, when the header decryption keys
are no longer valid.</p>
<p>In most cases, simply drop the packet. An implementation may, but is not required to,
retransmit the previously-sent packet (handshake message or ACK 0) in response.</p>
<p>After sending Session Created as Bob, unexpected packets are commonly Data packets
that cannot be decrypted because the Session Confirmed packets were lost or out-of-order.
Queue the packets and attempt to decrypt them after receiving the Session Confirmed packets.</p>
<p>After receiving Session Confirmed as Bob, unexpected packets are commonly retransmitted
Session Confirmed packets, because the ACK 0 of the Sesssion Confirmed was lost.
The unexpected packets may be dropped.
An implementation may, but is not required to, send a Data packet containing an ACK block in response.</p>
<h3 id="notes-8">Notes</h3>
<p>For Session Created and Session Confirmed, implementations must carefully validate
all decrypted header fields (Connection IDs, packet number, packet type, version, id, frag, and flags)
BEFORE calling mixHash() on the header and attempting to decrypt the
payload with Noise AEAD. If the Noise AEAD decryption fails, no further processing
may be done, because mixHash() will have corrupted the handshake state,
unless an implementation stores and &ldquo;backs out&rdquo; the hash state.</p>
<h3 id="version-detection">Version Detection</h3>
<p>It may not be possible to efficiently detect if incoming packets are version 1 or 2 on the same inbound port.
The steps above may make sense to do before SSU 1 processing, to avoid attempting trial DH operations
using both protocol versions.</p>
<p>TBD if required.</p>
<h2 id="recommended-constants">Recommended Constants</h2>
<ul>
<li>Outbound handshake retransmission timeout: 1.25 seconds, with exponential backoff
(retransmissions at 1.25, 3.75, and 8.75 seconds)</li>
<li>Total outbound handshake timeout: 15 seconds</li>
<li>Inbound handshake retransmission timeout: 1 second, with exponential backoff
(retransmissions at 1, 3, and 7 seconds)</li>
<li>Total inbound handshake timeout: 12 seconds</li>
<li>Timeout after sending retry: 9 seconds</li>
<li>ACK delay: max(10, min(rtt/6, 150)) ms</li>
<li>Immediate ACK delay: min(rtt/16, 5) ms</li>
<li>Max ACK ranges: 256?</li>
<li>Max ACK depth: 512?</li>
<li>Padding distribution: 0-15 bytes, or greater</li>
</ul>
<h2 id="variants-fallbacks-and-general-issues">Variants, Fallbacks, and General Issues</h2>
<p>TBD</p>
<h2 id="packet-overhead-analysis">Packet Overhead Analysis</h2>
<p>Assumes IPv4, not including extra padding, not including IP and UDP header sizes.
Padding is mod-16 padding for SSU 1 only.</p>
<p>SSU 1</p>
<table>
  <thead>
      <tr>
          <th>Message</th>
          <th>Header+MAC</th>
          <th>Keys</th>
          <th>Data</th>
          <th>Padding</th>
          <th>Total</th>
          <th>Notes</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Session Request</td>
          <td>40</td>
          <td>256</td>
          <td>5</td>
          <td>3</td>
          <td>304</td>
          <td>Incl.</td>
      </tr>
      <tr>
          <td>Session Created</td>
          <td>37</td>
          <td>256</td>
          <td>79</td>
          <td>1</td>
          <td>336</td>
          <td>Incl.</td>
      </tr>
      <tr>
          <td>Session Confirmed</td>
          <td>37</td>
          <td></td>
          <td>462</td>
          <td>13</td>
          <td>512</td>
          <td>Incl.</td>
      </tr>
      <tr>
          <td>Data (RI)</td>
          <td>37</td>
          <td></td>
          <td>1014</td>
          <td></td>
          <td>1051</td>
          <td>Incl.</td>
      </tr>
      <tr>
          <td>Data (1 full msg)</td>
          <td>37</td>
          <td></td>
          <td>14</td>
          <td></td>
          <td>51</td>
          <td>Incl.</td>
      </tr>
      <tr>
          <td>Total</td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td>2254</td>
          <td></td>
      </tr>
  </tbody>
</table>
<p>SSU 2</p>
<table>
  <thead>
      <tr>
          <th>Message</th>
          <th>Header+MACs</th>
          <th>Keys</th>
          <th>Data</th>
          <th>Padding</th>
          <th>Total</th>
          <th>Notes</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Session Request</td>
          <td>48</td>
          <td>32</td>
          <td>7</td>
          <td></td>
          <td>87</td>
          <td>DateTi</td>
      </tr>
      <tr>
          <td>Session Created</td>
          <td>48</td>
          <td>32</td>
          <td>16</td>
          <td></td>
          <td>96</td>
          <td>DateTi</td>
      </tr>
      <tr>
          <td>Session Confirmed</td>
          <td>48</td>
          <td>32</td>
          <td>1005</td>
          <td></td>
          <td>1085</td>
          <td>1000 b</td>
      </tr>
      <tr>
          <td>Data (1 full msg)</td>
          <td>32</td>
          <td></td>
          <td>14</td>
          <td></td>
          <td>46</td>
          <td></td>
      </tr>
      <tr>
          <td>Total</td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td>1314</td>
          <td></td>
      </tr>
  </tbody>
</table>
<p>TODO UNLESS minimum packet size in Session Request and Created is enforced for PMTU.</p>
<h2 id="references">References</h2>
<ul>
<li><a href="../../../en/docs/specs/common-structures/">Common</a>
</li>
<li><a href="../../../en/docs/specs/ecies/">ECIES</a>
</li>
<li><a href="../../../en/docs/overview/network-database/">NetDB</a>
</li>
<li><a href="https://noiseprotocol.org/noise.html">NOISE</a>
</li>
<li><a href="https://eprint.iacr.org/2019/624.pdf">Nonces</a>
</li>
<li><a href="../../../en/docs/ntcp/">NTCP</a>
</li>
<li><a href="../../../en/docs/specs/ntcp2/">NTCP2</a>
</li>
<li><a href="https://aura.abdn.ac.uk/bitstream/handle/2164/11693/tma2018_paper57.pdf">PMTU</a>
</li>
<li><a href="../../../en/proposals/104-tls-transport/">Prop104</a>
</li>
<li><a href="../../../en/proposals/109-pt-transport/">Prop109</a>
</li>
<li><a href="../../../en/proposals/158-ipv6-transport-enhancements/">Prop158</a>
</li>
<li><a href="https://tools.ietf.org/html/rfc2104">RFC-2104</a>
</li>
<li><a href="https://tools.ietf.org/html/rfc3449">RFC-3449</a>
</li>
<li><a href="https://tools.ietf.org/html/rfc3526">RFC-3526</a>
</li>
<li><a href="https://tools.ietf.org/html/rfc3681">RFC-5681</a>
</li>
<li><a href="https://tools.ietf.org/html/rfc5869">RFC-5869</a>
</li>
<li><a href="https://tools.ietf.org/html/rfc6151">RFC-6151</a>
</li>
<li><a href="https://tools.ietf.org/html/rfc6298">RFC-6298</a>
</li>
<li><a href="https://tools.ietf.org/html/rfc6437">RFC-6437</a>
</li>
<li><a href="https://tools.ietf.org/html/rfc7539">RFC-7539</a>
</li>
<li><a href="https://tools.ietf.org/html/rfc7748">RFC-7748</a>
</li>
<li><a href="https://tools.ietf.org/html/rfc7905">RFC-7905</a>
</li>
<li><a href="https://datatracker.ietf.org/doc/html/rfc9000">RFC-9000</a>
</li>
<li><a href="https://datatracker.ietf.org/doc/html/rfc9001">RFC-9001</a>
</li>
<li><a href="https://datatracker.ietf.org/doc/html/rfc9002">RFC-9002</a>
</li>
<li><a href="../../../en/docs/specs/common-structures/#routeraddress">RouterAddress</a>
</li>
<li><a href="../../../en/docs/specs/common-structures/#routeridentity">RouterIdentity</a>
</li>
<li><a href="../../../en/docs/specs/common-structures/#signingpublickey">SigningPublicKey</a>
</li>
<li><a href="../../../en/docs/specs/ssu2/">SSU</a>
</li>
<li>[STS] Diffie, W.; van Oorschot P. C.; Wiener M. J., Authentication and Authenticated Key Exchanges</li>
<li><a href="https://trac.i2p2.i2p/ticket/1112">Ticket1112</a>
</li>
<li><a href="https://trac.i2p2.i2p/ticket/1849">Ticket1849</a>
</li>
</ul>

                </article>

                
                <nav class="page-nav">
                    <a href="../../../en/proposals/" class="page-nav-link">
                         Back to Proposals
                    </a>
                    
                    
                    
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                            
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                    <a href="../../../proposals/159-ssu2.txt" class="page-nav-link" download>
                        Download Source (.txt)
                    </a>
                    
                </nav>
            </div>
        </div>
    </div>
</div>

<style>
.proposals-page {
    min-height: 100vh;
    padding: var(--spacing-xl) 0;
}

.breadcrumbs {
    display: flex;
    align-items: center;
    gap: var(--spacing-xs);
    margin-bottom: var(--spacing-lg);
    font-size: 0.875rem;
    color: var(--color-text-muted);
}

.breadcrumbs a {
    color: var(--color-text-muted);
    text-decoration: none;
    transition: color var(--transition-fast);
}

.breadcrumbs a:hover {
    color: var(--color-primary);
}

.separator {
    color: var(--color-border);
}

.current {
    color: var(--color-text);
}

 
.translation-disclaimer {
    background: #fef3c7;
    border: 1px solid #f59e0b;
    border-radius: var(--radius-md);
    padding: var(--spacing-md);
    margin-bottom: var(--spacing-lg);
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: var(--spacing-md);
    flex-wrap: wrap;
}

.dark .translation-disclaimer {
    background: #78350f;
    border-color: #d97706;
}

.disclaimer-message {
    color: #92400e;
    font-size: 0.875rem;
}

.dark .disclaimer-message {
    color: #fde047;
}

.disclaimer-link {
    color: #92400e;
    font-weight: 600;
    text-decoration: underline;
    white-space: nowrap;
}

.dark .disclaimer-link {
    color: #fde047;
}

 
.proposal-header {
    margin-bottom: var(--spacing-2xl);
}

.proposal-title-section {
    margin-bottom: var(--spacing-lg);
}

.proposal-title {
    font-size: 2.5rem;
    margin: 0 0 var(--spacing-sm) 0;
    color: var(--color-text);
}

.proposal-number {
    font-size: 0.875rem;
    color: var(--color-text-muted);
    font-weight: 600;
}

 
.proposal-meta-box {
    background: var(--color-bg-secondary);
    border: 1px solid var(--color-border);
    border-radius: var(--radius-lg);
    padding: var(--spacing-lg);
}

.proposal-status {
    display: inline-block;
    padding: var(--spacing-xs) var(--spacing-md);
    border-radius: var(--radius-md);
    font-weight: 600;
    font-size: 0.875rem;
    margin-bottom: var(--spacing-md);
    text-transform: uppercase;
    letter-spacing: 0.05em;
}

 
.status-open {
    background: #dbeafe;
    color: #0369a1;
}

.dark .status-open {
    background: #0c4a6e;
    color: #7dd3fc;
}

.status-accepted {
    background: #dbeafe;
    color: #0369a1;
}

.dark .status-accepted {
    background: #0c4a6e;
    color: #7dd3fc;
}

.status-finished {
    background: #dcfce7;
    color: #15803d;
}

.dark .status-finished {
    background: #164e63;
    color: #86efac;
}

.status-closed {
    background: #dcfce7;
    color: #15803d;
}

.dark .status-closed {
    background: #164e63;
    color: #86efac;
}

.status-rejected {
    background: #fee2e2;
    color: #991b1b;
}

.dark .status-rejected {
    background: #7f1d1d;
    color: #fca5a5;
}

.status-draft,
.status-needs-revision,
.status-dead,
.status-needs-research {
    background: #fef3c7;
    color: #92400e;
}

.dark .status-draft,
.dark .status-needs-revision,
.dark .status-dead,
.dark .status-needs-research {
    background: #78350f;
    color: #fde047;
}

.status-meta,
.status-informational,
.status-reserve {
    background: #e9d5ff;
    color: #6b21a8;
}

.dark .status-meta,
.dark .status-informational,
.dark .status-reserve {
    background: #581c87;
    color: #e879f9;
}

 
.proposal-info-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: var(--spacing-md);
    margin-bottom: var(--spacing-lg);
}

.info-item {
    display: flex;
    flex-direction: column;
    gap: var(--spacing-xs);
}

.info-label {
    font-size: 0.75rem;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    color: var(--color-text-muted);
}

.info-value {
    font-size: 0.9375rem;
    color: var(--color-text);
    font-weight: 500;
}

 
.proposal-relationships {
    border-top: 1px solid var(--color-border);
    padding-top: var(--spacing-md);
}

.relationship {
    display: flex;
    gap: var(--spacing-md);
    margin-bottom: var(--spacing-sm);
}

.relationship:last-child {
    margin-bottom: 0;
}

.relationship-label {
    font-weight: 600;
    color: var(--color-text-muted);
    min-width: 120px;
}

.relationship-value {
    color: var(--color-text);
}

 
.proposal-layout {
    display: block;
}

.proposal-layout--with-toc {
    display: grid;
    grid-template-columns: 260px 1fr;
    gap: var(--spacing-2xl);
    align-items: start;
}

 
.proposal-toc-sidebar {
    position: sticky;
    top: 100px;
    max-height: calc(100vh - 120px);
    overflow-y: auto;
}

.toc-nav {
    background: var(--color-bg-secondary);
    border: 1px solid var(--color-border);
    border-radius: var(--radius-lg);
    padding: var(--spacing-md);
}

.toc-header {
    display: flex;
    align-items: center;
    gap: var(--spacing-sm);
    font-weight: 700;
    font-size: 0.875rem;
    color: var(--color-text);
    padding-bottom: var(--spacing-md);
    margin-bottom: var(--spacing-md);
    border-bottom: 1px solid var(--color-border);
}

.toc-content {
    max-height: calc(100vh - 250px);
    overflow-y: auto;
}

.toc-content::-webkit-scrollbar {
    width: 4px;
}

.toc-content::-webkit-scrollbar-track {
    background: transparent;
}

.toc-content::-webkit-scrollbar-thumb {
    background: var(--color-border);
    border-radius: 2px;
}

.toc-content::-webkit-scrollbar-thumb:hover {
    background: var(--color-text-muted);
}

.toc-nav ul {
    list-style: none;
    padding-left: 0;
    margin: 0;
}

.toc-nav li {
    margin-bottom: 0.25rem;
}

.toc-nav ul ul {
    padding-left: var(--spacing-md);
    margin-top: 0.25rem;
}

.toc-nav a {
    color: var(--color-text-secondary);
    text-decoration: none;
    font-size: 0.8125rem;
    display: block;
    padding: 0.25rem 0.5rem;
    border-radius: var(--radius-sm);
    transition: all var(--transition-fast);
    line-height: 1.4;
}

.toc-nav a:hover {
    color: var(--color-primary);
    background: var(--color-bg-tertiary);
}

 
.proposal-main {
    min-width: 0;
}

 
.proposal-content {
    line-height: 1.8;
    color: var(--color-text);
    max-width: 900px;
}

.proposal-content h2 {
    margin-top: var(--spacing-2xl);
    margin-bottom: var(--spacing-md);
    font-size: 1.75rem;
    scroll-margin-top: 100px;
}

.proposal-content h3 {
    margin-top: var(--spacing-xl);
    margin-bottom: var(--spacing-sm);
    font-size: 1.375rem;
    scroll-margin-top: 100px;
}

.proposal-content h4 {
    margin-top: var(--spacing-lg);
    margin-bottom: var(--spacing-xs);
    font-size: 1.125rem;
    scroll-margin-top: 100px;
}

.proposal-content p {
    margin-bottom: var(--spacing-md);
}

.proposal-content ul,
.proposal-content ol {
    margin-bottom: var(--spacing-md);
    padding-left: var(--spacing-xl);
}

.proposal-content li {
    margin-bottom: var(--spacing-xs);
}

.proposal-content code {
    background: var(--color-bg-secondary);
    padding: 0.125rem 0.375rem;
    border-radius: var(--radius-sm);
    font-size: 0.875em;
    font-family: 'Courier New', monospace;
}

.proposal-content pre {
    background: var(--color-bg-secondary);
    border: 1px solid var(--color-border);
    border-radius: var(--radius-md);
    padding: var(--spacing-md);
    overflow-x: auto;
    margin-bottom: var(--spacing-md);
    font-size: 0.875rem;
}

.proposal-content pre code {
    background: none;
    padding: 0;
}

.proposal-content blockquote {
    border-left: 4px solid var(--color-primary);
    padding-left: var(--spacing-md);
    margin-left: 0;
    margin-bottom: var(--spacing-md);
    font-style: italic;
    color: var(--color-text-secondary);
}

.proposal-content a {
    color: var(--color-primary);
    text-decoration: none;
    border-bottom: 1px solid transparent;
    transition: border-color var(--transition-fast);
}

.proposal-content a:hover {
    border-bottom-color: var(--color-primary);
}

.proposal-content table {
    width: 100%;
    border-collapse: collapse;
    margin-bottom: var(--spacing-md);
}

.proposal-content table th {
    background: var(--color-bg-secondary);
    padding: var(--spacing-sm);
    text-align: left;
    font-weight: 600;
    border-bottom: 2px solid var(--color-border);
}

.proposal-content table td {
    padding: var(--spacing-sm);
    border-bottom: 1px solid var(--color-border);
}

.proposal-content img {
    max-width: 100%;
    height: auto;
    border-radius: var(--radius-md);
    border: 1px solid var(--color-border);
    margin: var(--spacing-lg) 0;
    display: block;
}

 
.page-nav {
    margin-top: var(--spacing-2xl);
    padding-top: var(--spacing-xl);
    border-top: 1px solid var(--color-border);
    display: flex;
    gap: var(--spacing-md);
    flex-wrap: wrap;
}

.page-nav-link {
    display: inline-block;
    padding: var(--spacing-md) var(--spacing-lg);
    background: var(--color-bg-secondary);
    border: 1px solid var(--color-border);
    border-radius: var(--radius-md);
    color: var(--color-text);
    text-decoration: none;
    transition: all var(--transition-fast);
}

.page-nav-link:hover {
    border-color: var(--color-primary);
    color: var(--color-primary);
}

 
@media (max-width: 1024px) {
    .proposal-layout--with-toc {
        grid-template-columns: 1fr;
    }

    .proposal-toc-sidebar {
        position: static;
        max-height: none;
        margin-bottom: var(--spacing-xl);
    }

    .toc-content {
        max-height: 300px;
    }
}

@media (max-width: 768px) {
    .proposal-title {
        font-size: 1.75rem;
    }

    .proposal-info-grid {
        grid-template-columns: 1fr;
    }
}
</style>



<script>
document.addEventListener('DOMContentLoaded', function() {
    const tocLinks = document.querySelectorAll('.toc-nav a');
    const headings = [];

    tocLinks.forEach(link => {
        const href = link.getAttribute('href');
        if (href && href.startsWith('#')) {
            const heading = document.getElementById(href.slice(1));
            if (heading) {
                headings.push({ element: heading, link: link });
            }
        }
    });

    function updateActiveLink() {
        const scrollPos = window.scrollY + 120;
        let activeIndex = 0;

        for (let i = 0; i < headings.length; i++) {
            if (headings[i].element.offsetTop <= scrollPos) {
                activeIndex = i;
            }
        }

        tocLinks.forEach(link => link.classList.remove('active'));
        if (headings[activeIndex]) {
            headings[activeIndex].link.classList.add('active');
        }
    }

    window.addEventListener('scroll', updateActiveLink);
    updateActiveLink();
});
</script>
<style>
.toc-nav a.active {
    color: var(--color-primary);
    background: var(--color-bg-tertiary);
    font-weight: 600;
}
</style>



    </main>

    <footer class="site-footer">
    <div class="container">
        <div class="footer-grid">
            <div class="footer-col footer-brand">
                <img src="../../../images/i2plogo_lightmode.svg" alt="I2P Logo" class="footer-logo logo-light" loading="lazy" decoding="async">
                <img src="../../../images/i2plogo_darkmode.svg" alt="I2P Logo" class="footer-logo logo-dark" loading="lazy" decoding="async">
                <p class="footer-tagline">Privacy. Security. Freedom.</p>
                <p class="footer-description">The Invisible Internet Project - A privacy-focused, anonymous network layer</p>

                <div class="footer-social-newsletter">
                    <div class="social-links">
                        <a href="https://mastodon.social/@i2p" target="_blank" rel="noopener" aria-label="Mastodon">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                                <path d="M21.327 8.566c0-4.339-2.843-5.61-2.843-5.61-1.433-.658-3.894-.935-6.451-.956h-.063c-2.557.021-5.016.298-6.45.956 0 0-2.843 1.272-2.843 5.61 0 .993-.019 2.181.012 3.441.103 4.243.778 8.425 4.701 9.463 1.809.479 3.362.579 4.612.51 2.268-.126 3.541-.809 3.541-.809l-.075-1.646s-1.621.511-3.441.449c-1.804-.062-3.707-.194-3.999-2.409a4.523 4.523 0 0 1-.04-.621s1.77.433 4.014.536c1.372.063 2.658-.08 3.965-.236 2.506-.299 4.688-1.843 4.962-3.254.434-2.223.398-5.424.398-5.424zm-3.353 5.59h-2.081V9.057c0-1.075-.452-1.62-1.357-1.62-1 0-1.501.647-1.501 1.927v2.791h-2.069V9.364c0-1.28-.501-1.927-1.502-1.927-.905 0-1.357.546-1.357 1.62v5.099H6.026V8.903c0-1.074.273-1.927.823-2.558.566-.631 1.307-.955 2.228-.955 1.065 0 1.872.409 2.405 1.228l.518.869.519-.869c.533-.819 1.34-1.228 2.405-1.228.92 0 1.662.324 2.228.955.549.631.822 1.484.822 2.558v5.253z"/>
                            </svg>
                        </a>
                        <a href="https://twitter.com/GetI2P" target="_blank" rel="noopener" aria-label="Twitter">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                                <path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"/>
                            </svg>
                        </a>
                        <a href="https://old.reddit.com/r/i2p" target="_blank" rel="noopener" aria-label="Reddit">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                                <path d="M12 0A12 12 0 0 0 0 12a12 12 0 0 0 12 12 12 12 0 0 0 12-12A12 12 0 0 0 12 0zm5.01 4.744c.688 0 1.25.561 1.25 1.249a1.25 1.25 0 0 1-2.498.056l-2.597-.547-.8 3.747c1.824.07 3.48.632 4.674 1.488.308-.309.73-.491 1.207-.491.968 0 1.754.786 1.754 1.754 0 .716-.435 1.333-1.01 1.614a3.111 3.111 0 0 1 .042.52c0 2.694-3.13 4.87-7.004 4.87-3.874 0-7.004-2.176-7.004-4.87 0-.183.015-.366.043-.534A1.748 1.748 0 0 1 4.028 12c0-.968.786-1.754 1.754-1.754.463 0 .898.196 1.207.49 1.207-.883 2.878-1.43 4.744-1.487l.885-4.182a.342.342 0 0 1 .14-.197.35.35 0 0 1 .238-.042l2.906.617a1.214 1.214 0 0 1 1.108-.701zM9.25 12C8.561 12 8 12.562 8 13.25c0 .687.561 1.248 1.25 1.248.687 0 1.248-.561 1.248-1.249 0-.688-.561-1.249-1.249-1.249zm5.5 0c-.687 0-1.248.561-1.248 1.25 0 .687.561 1.248 1.249 1.248.688 0 1.249-.561 1.249-1.249 0-.687-.562-1.249-1.25-1.249zm-5.466 3.99a.327.327 0 0 0-.231.094.33.33 0 0 0 0 .463c.842.842 2.484.913 2.961.913.477 0 2.105-.056 2.961-.913a.361.361 0 0 0 .029-.463.33.33 0 0 0-.464 0c-.547.533-1.684.73-2.512.73-.828 0-1.979-.196-2.512-.73a.326.326 0 0 0-.232-.095z"/>
                            </svg>
                        </a>
                        <a href="https://signal.group/#CjQKIOSUTtxlhbumAKcRsthPFkxkTUrkWcX39bbN6njLEgAIEhCTNsR0KDuiehAXZnkt42v5" target="_blank" rel="noopener" aria-label="Signal" class="signal-link">
                            <img src="../../../images/Signal-Logo-Black.svg" alt="Signal" class="signal-logo signal-logo-light" loading="lazy" decoding="async">
                            <img src="../../../images/Signal-Logo-White.svg" alt="Signal" class="signal-logo signal-logo-dark" loading="lazy" decoding="async">
                        </a>
                    </div>

                    
                    <div class="footer-newsletter-inline">
                        <p class="newsletter-description">Stay updated with I2P news:</p>
                        <form action="https://feedback.i2p.net/api/mailing-list/subscribe" method="POST" class="newsletter-form">
                            <input type="email" name="email" placeholder="Enter your email" required>
                            <button type="submit">Subscribe</button>
                        </form>
                    </div>
                </div>
            </div>

            <div class="footer-col">
                <h3>Quick Links</h3>
                <ul>
                    <li><a href="../../../en/financial-support/">Donate</a></li>
                    <li><a href="../../../en/docs/overview/intro/">I2P Introduction</a></li>
                </ul>
            </div>

            <div class="footer-col">
                <h3>Community</h3>
                <ul>
                    <li><a href="../../../en/get-involved/">Get Involved</a></li>
                    <li><a href="../../../en/blog/">Blog</a></li>
                    <li><a href="http://i2pforum.net/" target="_blank" rel="noopener">Official Forums</a></li>
                    <li><a href="../../../en/contact/">Contact</a></li>
                </ul>
            </div>

            <div class="footer-col">
                <h3>Resources</h3>
                <ul>
                    <li><a href="https://i2p-metrics.np-tokumei.net/" target="_blank" rel="noopener">I2P Metrics</a></li>
                    <li><a href="../../../en/papers/">Research</a></li>
                    <li><a href="https://i2pgit.org/" target="_blank" rel="noopener">GitLab</a></li>
                    <li><a href="https://www.stormycloud.org/" target="_blank" rel="noopener">StormyCloud</a></li>
                </ul>
            </div>
        </div>

        <div class="footer-bottom">
            <p class="copyright">&copy; 2025 The Invisible Internet Project. Licensed under Creative Commons.</p>
            <div class="footer-links">
                <a href="../../../en/privacy/">Privacy</a>
                <a href="../../../en/terms/">Terms</a>
                <a href="../../../en/about/media/">Press</a>
            </div>
        </div>
    </div>
</footer>


    
    
<div class="modal-overlay" id="poll">
    <div class="modal-content poll-modal-content">
        <a href="#" class="modal-close" aria-label="Close">
            <span aria-hidden="true">&times;</span>
        </a>

        <div class="modal-header">
            <h2>Community Poll</h2>
            <p class="modal-subtitle">We&#39;d love to hear from you</p>
        </div>

        <div class="modal-body">
            
            <iframe 
                id="poll-iframe"
                data-poll-id="2"
                data-api-url="https://feedback.i2p.net"
                frameborder="0"
                scrolling="no"
                style="width: 100%; border: none; min-height: 400px;">
            </iframe>
        </div>

        <div class="modal-footer">
            <p class="modal-disclaimer">
                Your vote helps shape the future of I2P.
            </p>
        </div>
    </div>
</div>


<script>
(function() {
    const iframe = document.getElementById('poll-iframe');
    if (!iframe) return;
    
    const hostname = window.location.hostname;
    let apiUrl = 'https://feedback.i2p.net';
    const pollId = iframe.getAttribute('data-poll-id') || '1';

    
    if (hostname.endsWith('.b32.i2p') || hostname.endsWith('.i2p')) {
        apiUrl = 'http://5kwyynf3eetgqa2nors6ctwo7doi7yu73k7uvypy5eqmm326zkiq.b32.i2p';
    }
    
    else if (hostname.endsWith('.onion')) {
        apiUrl = 'http://gfonxmohvarpmocsvllscsuszdu5rikipm6innvcwq4vpng7zzqmmfyd.onion';
    }

    
    const pollUrl = apiUrl + '/widgets/poll.html?poll_id=' + encodeURIComponent(pollId) + '&api_url=' + encodeURIComponent(apiUrl);
    iframe.src = pollUrl;
})();
</script>



    
    



    
    <script>
        (function () {
            'use strict';
            var hostname = window.location.hostname;
            var baseUrl;

            
            if (hostname.endsWith('.b32.i2p') || hostname.endsWith('.i2p')) {
                baseUrl = 'http://5kwyynf3eetgqa2nors6ctwo7doi7yu73k7uvypy5eqmm326zkiq.b32.i2p';
            } else if (hostname.endsWith('.onion')) {
                baseUrl = 'http://gfonxmohvarpmocsvllscsuszdu5rikipm6innvcwq4vpng7zzqmmfyd.onion';
            } else {
                baseUrl = 'https://feedback.i2p.net';
            }

            window.feedbackBaseUrl = baseUrl;

            
            document.querySelectorAll('[data-api-url]').forEach(function (widget) {
                widget.setAttribute('data-api-url', baseUrl);
            });

            
            document.write('<link rel="stylesheet" href="' + baseUrl + '/widgets/styles.css">');
            
        })();
    </script>

    

    
    
    

    

</body>

</html>